<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Two Ravens: Architecture</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Two Ravens: Architecture</h1>

    



    


    <h3> </h3>










    




    <section>
        <article><h2>Useful Paths</h2><p>Front-end code: <code>assets/app/eventdata/</code><br>Front-end style: <code>assets/css/eventdata.css</code><br>Query construction: <code>assets/app/manipulations/</code><br>Back-end: <code>tworavens_apps/eventdata_queries/</code>  </p>
<p>Data api endpoint: <code>eventdata/api/get-eventdata</code><br>Meta api endpoint: <code>eventdata/api/get-metadata</code>  </p>
<p>Data is stored in MongoDB in the event_data database, with one collection per dataset.<br>Metadata is stored in the backend in three folders, a section is below.  </p>
<h3>Front-End</h3><p><code>assets/app/eventdata/eventdata.js</code>: Application state and methods to mutate state.
<code>assets/app/eventdata/Body_EventData.js</code>: Describes the Mithril virtual dom, which Mithril compiles to HTML.  </p>
<p>Mithril redraws the entire page after callbacks on UI elements or after <code>m.redraw()</code> is called. 
Since the page is completely determined by application state in <code>eventdata.js</code>, any changes to application state will be reflected on the page after the redraw. The declarative programming style used throughout the codebase to describe the HTML is typically much easier to write than editing every part of the HTML that is affected by a state change.   </p>
<p>The UI backbone in <code>Body_EventData.js</code> is composed of many individual components:<br><code>assets/common/views/</code>: Basic UI elements like buttons, panels, text fields<br><code>assets/app/canvases/</code>: Full menus shown in the center panel<br><code>assets/app/eventdata/canvases/</code>: Full menus specific to eventdata shown in the center panel </p>
<h4>Canvases</h4><p>Each canvas take the attributes:<br><code>data</code>: collected from the dataset<br><code>metadata</code>: comes from the <code>subsets</code> key in the <code>/collections/</code> dataset config file. Describes how to build the menu<br><code>subsetName</code>: 'Actor', 'Action', 'Coordinates', etc<br><code>redraw</code>: boolean, when set, rebuild any html outside the virtual dom. &quot;hard redraw&quot;<br><code>setRedraw</code>: function, call with false to to turn off the hard redraw on the next mithril redraw<br><code>preferences</code>: menu state (which bars are selected, location of brushes in date plot, etc)</p>
<p>This interface shared for all the page load menus, subset menus, aggregation menus, results menus and D3M constraint menus.</p>
<p>The canvas state object is passed to the canvas and mutated as the user makes changes. The state object is stored under a key in <code>eventdata.subsetPreferences</code>.</p>
<h3>Metadata</h3><p>There are three kinds of hardcoded metadata:  </p>
<p><code>/collections/</code>: each file represents a dataset. This information is used on the homepage, and determines what operations are available on the dataset.<br><code>/alignments/</code>: each file contains a list of equivalencies between formats<br><code>/formats/</code>: these are scraped from the dataset codebooks. Any code used in the dataset has a label in these files.  </p>
<p>When data is collected to draw a subset menu, there is an additional step: 
If the column collected uses an alignment or format, a request is sent to retrieve it at the metadata api endpoint.
The returned metadata is stored in the frontend global variables <code>app.formattingData</code> and <code>app.alignmentData</code>.</p>
<h3>Data Pipeline</h3><p>An abstract description of data subsetting steps is recorded in the global variable <code>app.manipulations</code>.<br>An abstract description of the pending subset step and aggregation step are stored in <code>app.looseSteps</code>.  </p>
<p>Many database queries need to be constructed depending on application state. An abstract query description is built:<br><code>abstract query = (subsetting steps) + (pending subset, aggregation step or menu step)</code></p>
<p>The abstract query is an array of objects, where each object represents a logical step in a data processing pipeline.
The abstract query is passed into a database adapter that converts the abstract query into an actual query.<br><code>{query, variables} = queryMongo.buildPipeline(abstractQuery, variables)</code></p>
<p>The adapter also tracks the variables available at each step of the pipeline.</p>
<p>MongoDB is the only database with an adapter: <code>assets/app/manipulations/queryMongo.js</code>  </p>
<p>The MongoDB adapter targets the MongoDB 'aggregation framework' specification:<br>https://docs.mongodb.com/manual/core/aggregation-pipeline/</p>
<h3>Abstract Steps</h3><p>Each step of an abstract data pipeline is in one of these general formats:</p>
<pre class="prettyprint source"><code>{
    type: 'transform',
    transformations: [{name: 'y', equation: 'x^2 + 3'}, ...],
    expansions: [...]
}</code></pre><pre class="prettyprint source"><code>{
    type: 'subset',
    abstractQuery: [JQTree structure]
}</code></pre><pre class="prettyprint source"><code>{
    type: 'aggregate',
    measuresUnit: [JQTree structure],
    measuresAccum: [JQTree structure]
}</code></pre><pre class="prettyprint source"><code>{
    type: 'menu',
    metadata: {
        type: 'date',
        ...
    },
    preferences: {...}
}</code></pre><p>The 'transform' step type is only used in D3M.<br>The 'menu' step type is typically appended to an abstract pipeline just before the query is built.  </p>
<p>The JQTree structure is documented in <code>assets/app/manipulations/queryAbstract.js</code></p>
<h2>Tools</h2><p>For those who are just starting out with web development, suddenly needing Mithril, Babel, Webpack, NPM, Django, etc is very confusing. So I wrote an explanation on how the code in the IDE makes its way to your browser screen.</p>
<p>When we develop the .html file is hosted from a Django server. Django provides some administration features, like easy integration with a database and templates.</p>
<p>Starting with templates— A template is an html file, but there’s some additional markup for spots in the file that get replaced by variables in Django. So when you edit the domain in the /admin/ menu, Django inserts values into the html template at marked up spots before serving it as html.</p>
<p>The template file is practically empty, but it uses a script tag to include a .js file generated by webpack. This .js file includes a modified version of all of the static files for TwoRavens (.js, .css, .png). Some static files are too big to be bundled inline, or aren’t the right file type, so they get served from /static/ instead.</p>
<p>The reason I said ‘modified’ is, we actually have webpack configured to bundle the output of Babel, which transpiles our fancy new ES6 JavaScript to be cross-browser compatible with older JavaScript versions</p>
<p>To get Babel and webpack to update the bundle (the mashed up .js file) automatically, we run npm with a file watcher setting. To get Django to serve the html template we start the Django server. Both of these are handled with ‘fab run’ (or 'fab run_eventdata_dev'), and the output from the npm file watcher is displayed in that console.</p>
<p>That’s all fine and well, but we still haven’t actually generated any of the html dom yet, all we have is JavaScript.</p>
<p>Mithril is mounted to the body of the template. So when the page is loaded, the JavaScript executes and all the mithril code in index.js is loaded into a virtual dom, a purely JavaScript data structure. Mithril then converts the virtual dom into actual html and writes it to the body.</p>
<p>Whenever mithril ‘redraws’ it updates the virtual dom with menu state you define in JavaScript variables, and then updates only the relevant portions of the html.</p>
<p>A mithril redraw is automatically invoked when state is modified in the callback of a mithril virtual dom element (any m(...) element). Alternatively, if you update state outside of a mithril context (for example from a d3.js plot, or in the callback for a data request), you can trigger a redraw manually via m.redraw()</p></article>
    </section>






</div>

<nav>
    <h2><a href="../doc_out/root_out/index.html">Home</a></h2><h2><a href="../doc_out/eventdata_docs_out/index.html">Event Data</a></h2><h2><a href="../doc_out/D3M_out/index.html">D3M</a></h2><h2><a href="../doc_out/metadata_service_out/index.html">Metadata Service</a></h2><h2><a href="index.html">Architecture</a></h2>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Tue Jan 22 2019 22:35:44 GMT-0600 (CST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>