!function(Q){function I(B){if(F[B])return F[B].exports;var g=F[B]={i:B,l:!1,exports:{}};return Q[B].call(g.exports,g,g.exports,I),g.l=!0,g.exports}var F={};I.m=Q,I.c=F,I.i=function(Q){return Q},I.d=function(Q,F,B){I.o(Q,F)||Object.defineProperty(Q,F,{configurable:!1,enumerable:!0,get:B})},I.n=function(Q){var F=Q&&Q.__esModule?function(){return Q.default}:function(){return Q};return I.d(F,"a",F),F},I.o=function(Q,I){return Object.prototype.hasOwnProperty.call(Q,I)},I.p="",I(I.s=10)}([function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(setImmediate, global) {;(function() {\n"use strict"\nfunction Vnode(tag, key, attrs0, children, text, dom) {\n\treturn {tag: tag, key: key, attrs: attrs0, children: children, text: text, dom: dom, domSize: undefined, state: undefined, _state: undefined, events: undefined, instance: undefined, skip: false}\n}\nVnode.normalize = function(node) {\n\tif (Array.isArray(node)) return Vnode("[", undefined, undefined, Vnode.normalizeChildren(node), undefined, undefined)\n\tif (node != null && typeof node !== "object") return Vnode("#", undefined, undefined, node === false ? "" : node, undefined, undefined)\n\treturn node\n}\nVnode.normalizeChildren = function normalizeChildren(children) {\n\tfor (var i = 0; i < children.length; i++) {\n\t\tchildren[i] = Vnode.normalize(children[i])\n\t}\n\treturn children\n}\nvar selectorParser = /(?:(^|#|\\.)([^#\\.\\[\\]]+))|(\\[(.+?)(?:\\s*=\\s*("|\'|)((?:\\\\["\'\\]]|.)*?)\\5)?\\])/g\nvar selectorCache = {}\nvar hasOwn = {}.hasOwnProperty\nfunction compileSelector(selector) {\n\tvar match, tag = "div", classes = [], attrs = {}\n\twhile (match = selectorParser.exec(selector)) {\n\t\tvar type = match[1], value = match[2]\n\t\tif (type === "" && value !== "") tag = value\n\t\telse if (type === "#") attrs.id = value\n\t\telse if (type === ".") classes.push(value)\n\t\telse if (match[3][0] === "[") {\n\t\t\tvar attrValue = match[6]\n\t\t\tif (attrValue) attrValue = attrValue.replace(/\\\\(["\'])/g, "$1").replace(/\\\\\\\\/g, "\\\\")\n\t\t\tif (match[4] === "class") classes.push(attrValue)\n\t\t\telse attrs[match[4]] = attrValue === "" ? attrValue : attrValue || true\n\t\t}\n\t}\n\tif (classes.length > 0) attrs.className = classes.join(" ")\n\treturn selectorCache[selector] = {tag: tag, attrs: attrs}\n}\nfunction execSelector(state, attrs, children) {\n\tvar hasAttrs = false, childList, text\n\tvar className = attrs.className || attrs.class\n\tfor (var key in state.attrs) {\n\t\tif (hasOwn.call(state.attrs, key)) {\n\t\t\tattrs[key] = state.attrs[key]\n\t\t}\n\t}\n\tif (className !== undefined) {\n\t\tif (attrs.class !== undefined) {\n\t\t\tattrs.class = undefined\n\t\t\tattrs.className = className\n\t\t}\n\t\tif (state.attrs.className != null) {\n\t\t\tattrs.className = state.attrs.className + " " + className\n\t\t}\n\t}\n\tfor (var key in attrs) {\n\t\tif (hasOwn.call(attrs, key) && key !== "key") {\n\t\t\thasAttrs = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif (Array.isArray(children) && children.length === 1 && children[0] != null && children[0].tag === "#") {\n\t\ttext = children[0].children\n\t} else {\n\t\tchildList = children\n\t}\n\treturn Vnode(state.tag, attrs.key, hasAttrs ? attrs : undefined, childList, text)\n}\nfunction hyperscript(selector) {\n\t// Because sloppy mode sucks\n\tvar attrs = arguments[1], start = 2, children\n\tif (selector == null || typeof selector !== "string" && typeof selector !== "function" && typeof selector.view !== "function") {\n\t\tthrow Error("The selector must be either a string or a component.");\n\t}\n\tif (typeof selector === "string") {\n\t\tvar cached = selectorCache[selector] || compileSelector(selector)\n\t}\n\tif (attrs == null) {\n\t\tattrs = {}\n\t} else if (typeof attrs !== "object" || attrs.tag != null || Array.isArray(attrs)) {\n\t\tattrs = {}\n\t\tstart = 1\n\t}\n\tif (arguments.length === start + 1) {\n\t\tchildren = arguments[start]\n\t\tif (!Array.isArray(children)) children = [children]\n\t} else {\n\t\tchildren = []\n\t\twhile (start < arguments.length) children.push(arguments[start++])\n\t}\n\tvar normalized = Vnode.normalizeChildren(children)\n\tif (typeof selector === "string") {\n\t\treturn execSelector(cached, attrs, normalized)\n\t} else {\n\t\treturn Vnode(selector, attrs.key, attrs, normalized)\n\t}\n}\nhyperscript.trust = function(html) {\n\tif (html == null) html = ""\n\treturn Vnode("<", undefined, undefined, html, undefined, undefined)\n}\nhyperscript.fragment = function(attrs1, children) {\n\treturn Vnode("[", attrs1.key, attrs1, Vnode.normalizeChildren(children), undefined, undefined)\n}\nvar m = hyperscript\n/** @constructor */\nvar PromisePolyfill = function(executor) {\n\tif (!(this instanceof PromisePolyfill)) throw new Error("Promise must be called with `new`")\n\tif (typeof executor !== "function") throw new TypeError("executor must be a function")\n\tvar self = this, resolvers = [], rejectors = [], resolveCurrent = handler(resolvers, true), rejectCurrent = handler(rejectors, false)\n\tvar instance = self._instance = {resolvers: resolvers, rejectors: rejectors}\n\tvar callAsync = typeof setImmediate === "function" ? setImmediate : setTimeout\n\tfunction handler(list, shouldAbsorb) {\n\t\treturn function execute(value) {\n\t\t\tvar then\n\t\t\ttry {\n\t\t\t\tif (shouldAbsorb && value != null && (typeof value === "object" || typeof value === "function") && typeof (then = value.then) === "function") {\n\t\t\t\t\tif (value === self) throw new TypeError("Promise can\'t be resolved w/ itself")\n\t\t\t\t\texecuteOnce(then.bind(value))\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcallAsync(function() {\n\t\t\t\t\t\tif (!shouldAbsorb && list.length === 0) console.error("Possible unhandled promise rejection:", value)\n\t\t\t\t\t\tfor (var i = 0; i < list.length; i++) list[i](value)\n\t\t\t\t\t\tresolvers.length = 0, rejectors.length = 0\n\t\t\t\t\t\tinstance.state = shouldAbsorb\n\t\t\t\t\t\tinstance.retry = function() {execute(value)}\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (e) {\n\t\t\t\trejectCurrent(e)\n\t\t\t}\n\t\t}\n\t}\n\tfunction executeOnce(then) {\n\t\tvar runs = 0\n\t\tfunction run(fn) {\n\t\t\treturn function(value) {\n\t\t\t\tif (runs++ > 0) return\n\t\t\t\tfn(value)\n\t\t\t}\n\t\t}\n\t\tvar onerror = run(rejectCurrent)\n\t\ttry {then(run(resolveCurrent), onerror)} catch (e) {onerror(e)}\n\t}\n\texecuteOnce(executor)\n}\nPromisePolyfill.prototype.then = function(onFulfilled, onRejection) {\n\tvar self = this, instance = self._instance\n\tfunction handle(callback, list, next, state) {\n\t\tlist.push(function(value) {\n\t\t\tif (typeof callback !== "function") next(value)\n\t\t\telse try {resolveNext(callback(value))} catch (e) {if (rejectNext) rejectNext(e)}\n\t\t})\n\t\tif (typeof instance.retry === "function" && state === instance.state) instance.retry()\n\t}\n\tvar resolveNext, rejectNext\n\tvar promise = new PromisePolyfill(function(resolve, reject) {resolveNext = resolve, rejectNext = reject})\n\thandle(onFulfilled, instance.resolvers, resolveNext, true), handle(onRejection, instance.rejectors, rejectNext, false)\n\treturn promise\n}\nPromisePolyfill.prototype.catch = function(onRejection) {\n\treturn this.then(null, onRejection)\n}\nPromisePolyfill.resolve = function(value) {\n\tif (value instanceof PromisePolyfill) return value\n\treturn new PromisePolyfill(function(resolve) {resolve(value)})\n}\nPromisePolyfill.reject = function(value) {\n\treturn new PromisePolyfill(function(resolve, reject) {reject(value)})\n}\nPromisePolyfill.all = function(list) {\n\treturn new PromisePolyfill(function(resolve, reject) {\n\t\tvar total = list.length, count = 0, values = []\n\t\tif (list.length === 0) resolve([])\n\t\telse for (var i = 0; i < list.length; i++) {\n\t\t\t(function(i) {\n\t\t\t\tfunction consume(value) {\n\t\t\t\t\tcount++\n\t\t\t\t\tvalues[i] = value\n\t\t\t\t\tif (count === total) resolve(values)\n\t\t\t\t}\n\t\t\t\tif (list[i] != null && (typeof list[i] === "object" || typeof list[i] === "function") && typeof list[i].then === "function") {\n\t\t\t\t\tlist[i].then(consume, reject)\n\t\t\t\t}\n\t\t\t\telse consume(list[i])\n\t\t\t})(i)\n\t\t}\n\t})\n}\nPromisePolyfill.race = function(list) {\n\treturn new PromisePolyfill(function(resolve, reject) {\n\t\tfor (var i = 0; i < list.length; i++) {\n\t\t\tlist[i].then(resolve, reject)\n\t\t}\n\t})\n}\nif (typeof window !== "undefined") {\n\tif (typeof window.Promise === "undefined") window.Promise = PromisePolyfill\n\tvar PromisePolyfill = window.Promise\n} else if (typeof global !== "undefined") {\n\tif (typeof global.Promise === "undefined") global.Promise = PromisePolyfill\n\tvar PromisePolyfill = global.Promise\n} else {\n}\nvar buildQueryString = function(object) {\n\tif (Object.prototype.toString.call(object) !== "[object Object]") return ""\n\tvar args = []\n\tfor (var key0 in object) {\n\t\tdestructure(key0, object[key0])\n\t}\n\treturn args.join("&")\n\tfunction destructure(key0, value) {\n\t\tif (Array.isArray(value)) {\n\t\t\tfor (var i = 0; i < value.length; i++) {\n\t\t\t\tdestructure(key0 + "[" + i + "]", value[i])\n\t\t\t}\n\t\t}\n\t\telse if (Object.prototype.toString.call(value) === "[object Object]") {\n\t\t\tfor (var i in value) {\n\t\t\t\tdestructure(key0 + "[" + i + "]", value[i])\n\t\t\t}\n\t\t}\n\t\telse args.push(encodeURIComponent(key0) + (value != null && value !== "" ? "=" + encodeURIComponent(value) : ""))\n\t}\n}\nvar FILE_PROTOCOL_REGEX = new RegExp("^file://", "i")\nvar _8 = function($window, Promise) {\n\tvar callbackCount = 0\n\tvar oncompletion\n\tfunction setCompletionCallback(callback) {oncompletion = callback}\n\tfunction finalizer() {\n\t\tvar count = 0\n\t\tfunction complete() {if (--count === 0 && typeof oncompletion === "function") oncompletion()}\n\t\treturn function finalize(promise0) {\n\t\t\tvar then0 = promise0.then\n\t\t\tpromise0.then = function() {\n\t\t\t\tcount++\n\t\t\t\tvar next = then0.apply(promise0, arguments)\n\t\t\t\tnext.then(complete, function(e) {\n\t\t\t\t\tcomplete()\n\t\t\t\t\tif (count === 0) throw e\n\t\t\t\t})\n\t\t\t\treturn finalize(next)\n\t\t\t}\n\t\t\treturn promise0\n\t\t}\n\t}\n\tfunction normalize(args, extra) {\n\t\tif (typeof args === "string") {\n\t\t\tvar url = args\n\t\t\targs = extra || {}\n\t\t\tif (args.url == null) args.url = url\n\t\t}\n\t\treturn args\n\t}\n\tfunction request(args, extra) {\n\t\tvar finalize = finalizer()\n\t\targs = normalize(args, extra)\n\t\tvar promise0 = new Promise(function(resolve, reject) {\n\t\t\tif (args.method == null) args.method = "GET"\n\t\t\targs.method = args.method.toUpperCase()\n\t\t\tvar useBody = (args.method === "GET" || args.method === "TRACE") ? false : (typeof args.useBody === "boolean" ? args.useBody : true)\n\t\t\tif (typeof args.serialize !== "function") args.serialize = typeof FormData !== "undefined" && args.data instanceof FormData ? function(value) {return value} : JSON.stringify\n\t\t\tif (typeof args.deserialize !== "function") args.deserialize = deserialize\n\t\t\tif (typeof args.extract !== "function") args.extract = extract\n\t\t\targs.url = interpolate(args.url, args.data)\n\t\t\tif (useBody) args.data = args.serialize(args.data)\n\t\t\telse args.url = assemble(args.url, args.data)\n\t\t\tvar xhr = new $window.XMLHttpRequest(),\n\t\t\t\taborted = false,\n\t\t\t\t_abort = xhr.abort\n\t\t\txhr.abort = function abort() {\n\t\t\t\taborted = true\n\t\t\t\t_abort.call(xhr)\n\t\t\t}\n\t\t\txhr.open(args.method, args.url, typeof args.async === "boolean" ? args.async : true, typeof args.user === "string" ? args.user : undefined, typeof args.password === "string" ? args.password : undefined)\n\t\t\tif (args.serialize === JSON.stringify && useBody) {\n\t\t\t\txhr.setRequestHeader("Content-Type", "application/json; charset=utf-8")\n\t\t\t}\n\t\t\tif (args.deserialize === deserialize) {\n\t\t\t\txhr.setRequestHeader("Accept", "application/json, text/*")\n\t\t\t}\n\t\t\tif (args.withCredentials) xhr.withCredentials = args.withCredentials\n\t\t\tfor (var key in args.headers) if ({}.hasOwnProperty.call(args.headers, key)) {\n\t\t\t\txhr.setRequestHeader(key, args.headers[key])\n\t\t\t}\n\t\t\tif (typeof args.config === "function") xhr = args.config(xhr, args) || xhr\n\t\t\txhr.onreadystatechange = function() {\n\t\t\t\t// Don\'t throw errors on xhr.abort().\n\t\t\t\tif(aborted) return\n\t\t\t\tif (xhr.readyState === 4) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvar response = (args.extract !== extract) ? args.extract(xhr, args) : args.deserialize(args.extract(xhr, args))\n\t\t\t\t\t\tif ((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304 || FILE_PROTOCOL_REGEX.test(args.url)) {\n\t\t\t\t\t\t\tresolve(cast(args.type, response))\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tvar error = new Error(xhr.responseText)\n\t\t\t\t\t\t\tfor (var key in response) error[key] = response[key]\n\t\t\t\t\t\t\treject(error)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (e) {\n\t\t\t\t\t\treject(e)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (useBody && (args.data != null)) xhr.send(args.data)\n\t\t\telse xhr.send()\n\t\t})\n\t\treturn args.background === true ? promise0 : finalize(promise0)\n\t}\n\tfunction jsonp(args, extra) {\n\t\tvar finalize = finalizer()\n\t\targs = normalize(args, extra)\n\t\tvar promise0 = new Promise(function(resolve, reject) {\n\t\t\tvar callbackName = args.callbackName || "_mithril_" + Math.round(Math.random() * 1e16) + "_" + callbackCount++\n\t\t\tvar script = $window.document.createElement("script")\n\t\t\t$window[callbackName] = function(data) {\n\t\t\t\tscript.parentNode.removeChild(script)\n\t\t\t\tresolve(cast(args.type, data))\n\t\t\t\tdelete $window[callbackName]\n\t\t\t}\n\t\t\tscript.onerror = function() {\n\t\t\t\tscript.parentNode.removeChild(script)\n\t\t\t\treject(new Error("JSONP request failed"))\n\t\t\t\tdelete $window[callbackName]\n\t\t\t}\n\t\t\tif (args.data == null) args.data = {}\n\t\t\targs.url = interpolate(args.url, args.data)\n\t\t\targs.data[args.callbackKey || "callback"] = callbackName\n\t\t\tscript.src = assemble(args.url, args.data)\n\t\t\t$window.document.documentElement.appendChild(script)\n\t\t})\n\t\treturn args.background === true? promise0 : finalize(promise0)\n\t}\n\tfunction interpolate(url, data) {\n\t\tif (data == null) return url\n\t\tvar tokens = url.match(/:[^\\/]+/gi) || []\n\t\tfor (var i = 0; i < tokens.length; i++) {\n\t\t\tvar key = tokens[i].slice(1)\n\t\t\tif (data[key] != null) {\n\t\t\t\turl = url.replace(tokens[i], data[key])\n\t\t\t}\n\t\t}\n\t\treturn url\n\t}\n\tfunction assemble(url, data) {\n\t\tvar querystring = buildQueryString(data)\n\t\tif (querystring !== "") {\n\t\t\tvar prefix = url.indexOf("?") < 0 ? "?" : "&"\n\t\t\turl += prefix + querystring\n\t\t}\n\t\treturn url\n\t}\n\tfunction deserialize(data) {\n\t\ttry {return data !== "" ? JSON.parse(data) : null}\n\t\tcatch (e) {throw new Error(data)}\n\t}\n\tfunction extract(xhr) {return xhr.responseText}\n\tfunction cast(type0, data) {\n\t\tif (typeof type0 === "function") {\n\t\t\tif (Array.isArray(data)) {\n\t\t\t\tfor (var i = 0; i < data.length; i++) {\n\t\t\t\t\tdata[i] = new type0(data[i])\n\t\t\t\t}\n\t\t\t}\n\t\t\telse return new type0(data)\n\t\t}\n\t\treturn data\n\t}\n\treturn {request: request, jsonp: jsonp, setCompletionCallback: setCompletionCallback}\n}\nvar requestService = _8(window, PromisePolyfill)\nvar coreRenderer = function($window) {\n\tvar $doc = $window.document\n\tvar $emptyFragment = $doc.createDocumentFragment()\n\tvar nameSpace = {\n\t\tsvg: "http://www.w3.org/2000/svg",\n\t\tmath: "http://www.w3.org/1998/Math/MathML"\n\t}\n\tvar onevent\n\tfunction setEventCallback(callback) {return onevent = callback}\n\tfunction getNameSpace(vnode) {\n\t\treturn vnode.attrs && vnode.attrs.xmlns || nameSpace[vnode.tag]\n\t}\n\t//create\n\tfunction createNodes(parent, vnodes, start, end, hooks, nextSibling, ns) {\n\t\tfor (var i = start; i < end; i++) {\n\t\t\tvar vnode = vnodes[i]\n\t\t\tif (vnode != null) {\n\t\t\t\tcreateNode(parent, vnode, hooks, ns, nextSibling)\n\t\t\t}\n\t\t}\n\t}\n\tfunction createNode(parent, vnode, hooks, ns, nextSibling) {\n\t\tvar tag = vnode.tag\n\t\tif (typeof tag === "string") {\n\t\t\tvnode.state = {}\n\t\t\tif (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks)\n\t\t\tswitch (tag) {\n\t\t\t\tcase "#": return createText(parent, vnode, nextSibling)\n\t\t\t\tcase "<": return createHTML(parent, vnode, nextSibling)\n\t\t\t\tcase "[": return createFragment(parent, vnode, hooks, ns, nextSibling)\n\t\t\t\tdefault: return createElement(parent, vnode, hooks, ns, nextSibling)\n\t\t\t}\n\t\t}\n\t\telse return createComponent(parent, vnode, hooks, ns, nextSibling)\n\t}\n\tfunction createText(parent, vnode, nextSibling) {\n\t\tvnode.dom = $doc.createTextNode(vnode.children)\n\t\tinsertNode(parent, vnode.dom, nextSibling)\n\t\treturn vnode.dom\n\t}\n\tfunction createHTML(parent, vnode, nextSibling) {\n\t\tvar match1 = vnode.children.match(/^\\s*?<(\\w+)/im) || []\n\t\tvar parent1 = {caption: "table", thead: "table", tbody: "table", tfoot: "table", tr: "tbody", th: "tr", td: "tr", colgroup: "table", col: "colgroup"}[match1[1]] || "div"\n\t\tvar temp = $doc.createElement(parent1)\n\t\ttemp.innerHTML = vnode.children\n\t\tvnode.dom = temp.firstChild\n\t\tvnode.domSize = temp.childNodes.length\n\t\tvar fragment = $doc.createDocumentFragment()\n\t\tvar child\n\t\twhile (child = temp.firstChild) {\n\t\t\tfragment.appendChild(child)\n\t\t}\n\t\tinsertNode(parent, fragment, nextSibling)\n\t\treturn fragment\n\t}\n\tfunction createFragment(parent, vnode, hooks, ns, nextSibling) {\n\t\tvar fragment = $doc.createDocumentFragment()\n\t\tif (vnode.children != null) {\n\t\t\tvar children = vnode.children\n\t\t\tcreateNodes(fragment, children, 0, children.length, hooks, null, ns)\n\t\t}\n\t\tvnode.dom = fragment.firstChild\n\t\tvnode.domSize = fragment.childNodes.length\n\t\tinsertNode(parent, fragment, nextSibling)\n\t\treturn fragment\n\t}\n\tfunction createElement(parent, vnode, hooks, ns, nextSibling) {\n\t\tvar tag = vnode.tag\n\t\tvar attrs2 = vnode.attrs\n\t\tvar is = attrs2 && attrs2.is\n\t\tns = getNameSpace(vnode) || ns\n\t\tvar element = ns ?\n\t\t\tis ? $doc.createElementNS(ns, tag, {is: is}) : $doc.createElementNS(ns, tag) :\n\t\t\tis ? $doc.createElement(tag, {is: is}) : $doc.createElement(tag)\n\t\tvnode.dom = element\n\t\tif (attrs2 != null) {\n\t\t\tsetAttrs(vnode, attrs2, ns)\n\t\t}\n\t\tinsertNode(parent, element, nextSibling)\n\t\tif (vnode.attrs != null && vnode.attrs.contenteditable != null) {\n\t\t\tsetContentEditable(vnode)\n\t\t}\n\t\telse {\n\t\t\tif (vnode.text != null) {\n\t\t\t\tif (vnode.text !== "") element.textContent = vnode.text\n\t\t\t\telse vnode.children = [Vnode("#", undefined, undefined, vnode.text, undefined, undefined)]\n\t\t\t}\n\t\t\tif (vnode.children != null) {\n\t\t\t\tvar children = vnode.children\n\t\t\t\tcreateNodes(element, children, 0, children.length, hooks, null, ns)\n\t\t\t\tsetLateAttrs(vnode)\n\t\t\t}\n\t\t}\n\t\treturn element\n\t}\n\tfunction initComponent(vnode, hooks) {\n\t\tvar sentinel\n\t\tif (typeof vnode.tag.view === "function") {\n\t\t\tvnode.state = Object.create(vnode.tag)\n\t\t\tsentinel = vnode.state.view\n\t\t\tif (sentinel.$$reentrantLock$$ != null) return $emptyFragment\n\t\t\tsentinel.$$reentrantLock$$ = true\n\t\t} else {\n\t\t\tvnode.state = void 0\n\t\t\tsentinel = vnode.tag\n\t\t\tif (sentinel.$$reentrantLock$$ != null) return $emptyFragment\n\t\t\tsentinel.$$reentrantLock$$ = true\n\t\t\tvnode.state = (vnode.tag.prototype != null && typeof vnode.tag.prototype.view === "function") ? new vnode.tag(vnode) : vnode.tag(vnode)\n\t\t}\n\t\tvnode._state = vnode.state\n\t\tif (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks)\n\t\tinitLifecycle(vnode._state, vnode, hooks)\n\t\tvnode.instance = Vnode.normalize(vnode._state.view.call(vnode.state, vnode))\n\t\tif (vnode.instance === vnode) throw Error("A view cannot return the vnode it received as argument")\n\t\tsentinel.$$reentrantLock$$ = null\n\t}\n\tfunction createComponent(parent, vnode, hooks, ns, nextSibling) {\n\t\tinitComponent(vnode, hooks)\n\t\tif (vnode.instance != null) {\n\t\t\tvar element = createNode(parent, vnode.instance, hooks, ns, nextSibling)\n\t\t\tvnode.dom = vnode.instance.dom\n\t\t\tvnode.domSize = vnode.dom != null ? vnode.instance.domSize : 0\n\t\t\tinsertNode(parent, element, nextSibling)\n\t\t\treturn element\n\t\t}\n\t\telse {\n\t\t\tvnode.domSize = 0\n\t\t\treturn $emptyFragment\n\t\t}\n\t}\n\t//update\n\tfunction updateNodes(parent, old, vnodes, recycling, hooks, nextSibling, ns) {\n\t\tif (old === vnodes || old == null && vnodes == null) return\n\t\telse if (old == null) createNodes(parent, vnodes, 0, vnodes.length, hooks, nextSibling, ns)\n\t\telse if (vnodes == null) removeNodes(old, 0, old.length, vnodes)\n\t\telse {\n\t\t\tif (old.length === vnodes.length) {\n\t\t\t\tvar isUnkeyed = false\n\t\t\t\tfor (var i = 0; i < vnodes.length; i++) {\n\t\t\t\t\tif (vnodes[i] != null && old[i] != null) {\n\t\t\t\t\t\tisUnkeyed = vnodes[i].key == null && old[i].key == null\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (isUnkeyed) {\n\t\t\t\t\tfor (var i = 0; i < old.length; i++) {\n\t\t\t\t\t\tif (old[i] === vnodes[i]) continue\n\t\t\t\t\t\telse if (old[i] == null && vnodes[i] != null) createNode(parent, vnodes[i], hooks, ns, getNextSibling(old, i + 1, nextSibling))\n\t\t\t\t\t\telse if (vnodes[i] == null) removeNodes(old, i, i + 1, vnodes)\n\t\t\t\t\t\telse updateNode(parent, old[i], vnodes[i], hooks, getNextSibling(old, i + 1, nextSibling), recycling, ns)\n\t\t\t\t\t}\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\trecycling = recycling || isRecyclable(old, vnodes)\n\t\t\tif (recycling) {\n\t\t\t\tvar pool = old.pool\n\t\t\t\told = old.concat(old.pool)\n\t\t\t}\n\t\t\tvar oldStart = 0, start = 0, oldEnd = old.length - 1, end = vnodes.length - 1, map\n\t\t\twhile (oldEnd >= oldStart && end >= start) {\n\t\t\t\tvar o = old[oldStart], v = vnodes[start]\n\t\t\t\tif (o === v && !recycling) oldStart++, start++\n\t\t\t\telse if (o == null) oldStart++\n\t\t\t\telse if (v == null) start++\n\t\t\t\telse if (o.key === v.key) {\n\t\t\t\t\tvar shouldRecycle = (pool != null && oldStart >= old.length - pool.length) || ((pool == null) && recycling)\n\t\t\t\t\toldStart++, start++\n\t\t\t\t\tupdateNode(parent, o, v, hooks, getNextSibling(old, oldStart, nextSibling), shouldRecycle, ns)\n\t\t\t\t\tif (recycling && o.tag === v.tag) insertNode(parent, toFragment(o), nextSibling)\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tvar o = old[oldEnd]\n\t\t\t\t\tif (o === v && !recycling) oldEnd--, start++\n\t\t\t\t\telse if (o == null) oldEnd--\n\t\t\t\t\telse if (v == null) start++\n\t\t\t\t\telse if (o.key === v.key) {\n\t\t\t\t\t\tvar shouldRecycle = (pool != null && oldEnd >= old.length - pool.length) || ((pool == null) && recycling)\n\t\t\t\t\t\tupdateNode(parent, o, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), shouldRecycle, ns)\n\t\t\t\t\t\tif (recycling || start < end) insertNode(parent, toFragment(o), getNextSibling(old, oldStart, nextSibling))\n\t\t\t\t\t\toldEnd--, start++\n\t\t\t\t\t}\n\t\t\t\t\telse break\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (oldEnd >= oldStart && end >= start) {\n\t\t\t\tvar o = old[oldEnd], v = vnodes[end]\n\t\t\t\tif (o === v && !recycling) oldEnd--, end--\n\t\t\t\telse if (o == null) oldEnd--\n\t\t\t\telse if (v == null) end--\n\t\t\t\telse if (o.key === v.key) {\n\t\t\t\t\tvar shouldRecycle = (pool != null && oldEnd >= old.length - pool.length) || ((pool == null) && recycling)\n\t\t\t\t\tupdateNode(parent, o, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), shouldRecycle, ns)\n\t\t\t\t\tif (recycling && o.tag === v.tag) insertNode(parent, toFragment(o), nextSibling)\n\t\t\t\t\tif (o.dom != null) nextSibling = o.dom\n\t\t\t\t\toldEnd--, end--\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (!map) map = getKeyMap(old, oldEnd)\n\t\t\t\t\tif (v != null) {\n\t\t\t\t\t\tvar oldIndex = map[v.key]\n\t\t\t\t\t\tif (oldIndex != null) {\n\t\t\t\t\t\t\tvar movable = old[oldIndex]\n\t\t\t\t\t\t\tvar shouldRecycle = (pool != null && oldIndex >= old.length - pool.length) || ((pool == null) && recycling)\n\t\t\t\t\t\t\tupdateNode(parent, movable, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), recycling, ns)\n\t\t\t\t\t\t\tinsertNode(parent, toFragment(movable), nextSibling)\n\t\t\t\t\t\t\told[oldIndex].skip = true\n\t\t\t\t\t\t\tif (movable.dom != null) nextSibling = movable.dom\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tvar dom = createNode(parent, v, hooks, ns, nextSibling)\n\t\t\t\t\t\t\tnextSibling = dom\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tend--\n\t\t\t\t}\n\t\t\t\tif (end < start) break\n\t\t\t}\n\t\t\tcreateNodes(parent, vnodes, start, end + 1, hooks, nextSibling, ns)\n\t\t\tremoveNodes(old, oldStart, oldEnd + 1, vnodes)\n\t\t}\n\t}\n\tfunction updateNode(parent, old, vnode, hooks, nextSibling, recycling, ns) {\n\t\tvar oldTag = old.tag, tag = vnode.tag\n\t\tif (oldTag === tag) {\n\t\t\tvnode.state = old.state\n\t\t\tvnode._state = old._state\n\t\t\tvnode.events = old.events\n\t\t\tif (!recycling && shouldNotUpdate(vnode, old)) return\n\t\t\tif (typeof oldTag === "string") {\n\t\t\t\tif (vnode.attrs != null) {\n\t\t\t\t\tif (recycling) {\n\t\t\t\t\t\tvnode.state = {}\n\t\t\t\t\t\tinitLifecycle(vnode.attrs, vnode, hooks)\n\t\t\t\t\t}\n\t\t\t\t\telse updateLifecycle(vnode.attrs, vnode, hooks)\n\t\t\t\t}\n\t\t\t\tswitch (oldTag) {\n\t\t\t\t\tcase "#": updateText(old, vnode); break\n\t\t\t\t\tcase "<": updateHTML(parent, old, vnode, nextSibling); break\n\t\t\t\t\tcase "[": updateFragment(parent, old, vnode, recycling, hooks, nextSibling, ns); break\n\t\t\t\t\tdefault: updateElement(old, vnode, recycling, hooks, ns)\n\t\t\t\t}\n\t\t\t}\n\t\t\telse updateComponent(parent, old, vnode, hooks, nextSibling, recycling, ns)\n\t\t}\n\t\telse {\n\t\t\tremoveNode(old, null)\n\t\t\tcreateNode(parent, vnode, hooks, ns, nextSibling)\n\t\t}\n\t}\n\tfunction updateText(old, vnode) {\n\t\tif (old.children.toString() !== vnode.children.toString()) {\n\t\t\told.dom.nodeValue = vnode.children\n\t\t}\n\t\tvnode.dom = old.dom\n\t}\n\tfunction updateHTML(parent, old, vnode, nextSibling) {\n\t\tif (old.children !== vnode.children) {\n\t\t\ttoFragment(old)\n\t\t\tcreateHTML(parent, vnode, nextSibling)\n\t\t}\n\t\telse vnode.dom = old.dom, vnode.domSize = old.domSize\n\t}\n\tfunction updateFragment(parent, old, vnode, recycling, hooks, nextSibling, ns) {\n\t\tupdateNodes(parent, old.children, vnode.children, recycling, hooks, nextSibling, ns)\n\t\tvar domSize = 0, children = vnode.children\n\t\tvnode.dom = null\n\t\tif (children != null) {\n\t\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\t\tvar child = children[i]\n\t\t\t\tif (child != null && child.dom != null) {\n\t\t\t\t\tif (vnode.dom == null) vnode.dom = child.dom\n\t\t\t\t\tdomSize += child.domSize || 1\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (domSize !== 1) vnode.domSize = domSize\n\t\t}\n\t}\n\tfunction updateElement(old, vnode, recycling, hooks, ns) {\n\t\tvar element = vnode.dom = old.dom\n\t\tns = getNameSpace(vnode) || ns\n\t\tif (vnode.tag === "textarea") {\n\t\t\tif (vnode.attrs == null) vnode.attrs = {}\n\t\t\tif (vnode.text != null) {\n\t\t\t\tvnode.attrs.value = vnode.text //FIXME handle0 multiple children\n\t\t\t\tvnode.text = undefined\n\t\t\t}\n\t\t}\n\t\tupdateAttrs(vnode, old.attrs, vnode.attrs, ns)\n\t\tif (vnode.attrs != null && vnode.attrs.contenteditable != null) {\n\t\t\tsetContentEditable(vnode)\n\t\t}\n\t\telse if (old.text != null && vnode.text != null && vnode.text !== "") {\n\t\t\tif (old.text.toString() !== vnode.text.toString()) old.dom.firstChild.nodeValue = vnode.text\n\t\t}\n\t\telse {\n\t\t\tif (old.text != null) old.children = [Vnode("#", undefined, undefined, old.text, undefined, old.dom.firstChild)]\n\t\t\tif (vnode.text != null) vnode.children = [Vnode("#", undefined, undefined, vnode.text, undefined, undefined)]\n\t\t\tupdateNodes(element, old.children, vnode.children, recycling, hooks, null, ns)\n\t\t}\n\t}\n\tfunction updateComponent(parent, old, vnode, hooks, nextSibling, recycling, ns) {\n\t\tif (recycling) {\n\t\t\tinitComponent(vnode, hooks)\n\t\t} else {\n\t\t\tvnode.instance = Vnode.normalize(vnode._state.view.call(vnode.state, vnode))\n\t\t\tif (vnode.instance === vnode) throw Error("A view cannot return the vnode it received as argument")\n\t\t\tif (vnode.attrs != null) updateLifecycle(vnode.attrs, vnode, hooks)\n\t\t\tupdateLifecycle(vnode._state, vnode, hooks)\n\t\t}\n\t\tif (vnode.instance != null) {\n\t\t\tif (old.instance == null) createNode(parent, vnode.instance, hooks, ns, nextSibling)\n\t\t\telse updateNode(parent, old.instance, vnode.instance, hooks, nextSibling, recycling, ns)\n\t\t\tvnode.dom = vnode.instance.dom\n\t\t\tvnode.domSize = vnode.instance.domSize\n\t\t}\n\t\telse if (old.instance != null) {\n\t\t\tremoveNode(old.instance, null)\n\t\t\tvnode.dom = undefined\n\t\t\tvnode.domSize = 0\n\t\t}\n\t\telse {\n\t\t\tvnode.dom = old.dom\n\t\t\tvnode.domSize = old.domSize\n\t\t}\n\t}\n\tfunction isRecyclable(old, vnodes) {\n\t\tif (old.pool != null && Math.abs(old.pool.length - vnodes.length) <= Math.abs(old.length - vnodes.length)) {\n\t\t\tvar oldChildrenLength = old[0] && old[0].children && old[0].children.length || 0\n\t\t\tvar poolChildrenLength = old.pool[0] && old.pool[0].children && old.pool[0].children.length || 0\n\t\t\tvar vnodesChildrenLength = vnodes[0] && vnodes[0].children && vnodes[0].children.length || 0\n\t\t\tif (Math.abs(poolChildrenLength - vnodesChildrenLength) <= Math.abs(oldChildrenLength - vnodesChildrenLength)) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\tfunction getKeyMap(vnodes, end) {\n\t\tvar map = {}, i = 0\n\t\tfor (var i = 0; i < end; i++) {\n\t\t\tvar vnode = vnodes[i]\n\t\t\tif (vnode != null) {\n\t\t\t\tvar key2 = vnode.key\n\t\t\t\tif (key2 != null) map[key2] = i\n\t\t\t}\n\t\t}\n\t\treturn map\n\t}\n\tfunction toFragment(vnode) {\n\t\tvar count0 = vnode.domSize\n\t\tif (count0 != null || vnode.dom == null) {\n\t\t\tvar fragment = $doc.createDocumentFragment()\n\t\t\tif (count0 > 0) {\n\t\t\t\tvar dom = vnode.dom\n\t\t\t\twhile (--count0) fragment.appendChild(dom.nextSibling)\n\t\t\t\tfragment.insertBefore(dom, fragment.firstChild)\n\t\t\t}\n\t\t\treturn fragment\n\t\t}\n\t\telse return vnode.dom\n\t}\n\tfunction getNextSibling(vnodes, i, nextSibling) {\n\t\tfor (; i < vnodes.length; i++) {\n\t\t\tif (vnodes[i] != null && vnodes[i].dom != null) return vnodes[i].dom\n\t\t}\n\t\treturn nextSibling\n\t}\n\tfunction insertNode(parent, dom, nextSibling) {\n\t\tif (nextSibling && nextSibling.parentNode) parent.insertBefore(dom, nextSibling)\n\t\telse parent.appendChild(dom)\n\t}\n\tfunction setContentEditable(vnode) {\n\t\tvar children = vnode.children\n\t\tif (children != null && children.length === 1 && children[0].tag === "<") {\n\t\t\tvar content = children[0].children\n\t\t\tif (vnode.dom.innerHTML !== content) vnode.dom.innerHTML = content\n\t\t}\n\t\telse if (vnode.text != null || children != null && children.length !== 0) throw new Error("Child node of a contenteditable must be trusted")\n\t}\n\t//remove\n\tfunction removeNodes(vnodes, start, end, context) {\n\t\tfor (var i = start; i < end; i++) {\n\t\t\tvar vnode = vnodes[i]\n\t\t\tif (vnode != null) {\n\t\t\t\tif (vnode.skip) vnode.skip = false\n\t\t\t\telse removeNode(vnode, context)\n\t\t\t}\n\t\t}\n\t}\n\tfunction removeNode(vnode, context) {\n\t\tvar expected = 1, called = 0\n\t\tif (vnode.attrs && typeof vnode.attrs.onbeforeremove === "function") {\n\t\t\tvar result = vnode.attrs.onbeforeremove.call(vnode.state, vnode)\n\t\t\tif (result != null && typeof result.then === "function") {\n\t\t\t\texpected++\n\t\t\t\tresult.then(continuation, continuation)\n\t\t\t}\n\t\t}\n\t\tif (typeof vnode.tag !== "string" && typeof vnode._state.onbeforeremove === "function") {\n\t\t\tvar result = vnode._state.onbeforeremove.call(vnode.state, vnode)\n\t\t\tif (result != null && typeof result.then === "function") {\n\t\t\t\texpected++\n\t\t\t\tresult.then(continuation, continuation)\n\t\t\t}\n\t\t}\n\t\tcontinuation()\n\t\tfunction continuation() {\n\t\t\tif (++called === expected) {\n\t\t\t\tonremove(vnode)\n\t\t\t\tif (vnode.dom) {\n\t\t\t\t\tvar count0 = vnode.domSize || 1\n\t\t\t\t\tif (count0 > 1) {\n\t\t\t\t\t\tvar dom = vnode.dom\n\t\t\t\t\t\twhile (--count0) {\n\t\t\t\t\t\t\tremoveNodeFromDOM(dom.nextSibling)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tremoveNodeFromDOM(vnode.dom)\n\t\t\t\t\tif (context != null && vnode.domSize == null && !hasIntegrationMethods(vnode.attrs) && typeof vnode.tag === "string") { //TODO test custom elements\n\t\t\t\t\t\tif (!context.pool) context.pool = [vnode]\n\t\t\t\t\t\telse context.pool.push(vnode)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfunction removeNodeFromDOM(node) {\n\t\tvar parent = node.parentNode\n\t\tif (parent != null) parent.removeChild(node)\n\t}\n\tfunction onremove(vnode) {\n\t\tif (vnode.attrs && typeof vnode.attrs.onremove === "function") vnode.attrs.onremove.call(vnode.state, vnode)\n\t\tif (typeof vnode.tag !== "string" && typeof vnode._state.onremove === "function") vnode._state.onremove.call(vnode.state, vnode)\n\t\tif (vnode.instance != null) onremove(vnode.instance)\n\t\telse {\n\t\t\tvar children = vnode.children\n\t\t\tif (Array.isArray(children)) {\n\t\t\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\t\t\tvar child = children[i]\n\t\t\t\t\tif (child != null) onremove(child)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//attrs2\n\tfunction setAttrs(vnode, attrs2, ns) {\n\t\tfor (var key2 in attrs2) {\n\t\t\tsetAttr(vnode, key2, null, attrs2[key2], ns)\n\t\t}\n\t}\n\tfunction setAttr(vnode, key2, old, value, ns) {\n\t\tvar element = vnode.dom\n\t\tif (key2 === "key" || key2 === "is" || (old === value && !isFormAttribute(vnode, key2)) && typeof value !== "object" || typeof value === "undefined" || isLifecycleMethod(key2)) return\n\t\tvar nsLastIndex = key2.indexOf(":")\n\t\tif (nsLastIndex > -1 && key2.substr(0, nsLastIndex) === "xlink") {\n\t\t\telement.setAttributeNS("http://www.w3.org/1999/xlink", key2.slice(nsLastIndex + 1), value)\n\t\t}\n\t\telse if (key2[0] === "o" && key2[1] === "n" && typeof value === "function") updateEvent(vnode, key2, value)\n\t\telse if (key2 === "style") updateStyle(element, old, value)\n\t\telse if (key2 in element && !isAttribute(key2) && ns === undefined && !isCustomElement(vnode)) {\n\t\t\tif (key2 === "value") {\n\t\t\t\tvar normalized0 = "" + value // eslint-disable-line no-implicit-coercion\n\t\t\t\t//setting input[value] to same value by typing on focused element moves cursor to end in Chrome\n\t\t\t\tif ((vnode.tag === "input" || vnode.tag === "textarea") && vnode.dom.value === normalized0 && vnode.dom === $doc.activeElement) return\n\t\t\t\t//setting select[value] to same value while having select open blinks select dropdown in Chrome\n\t\t\t\tif (vnode.tag === "select") {\n\t\t\t\t\tif (value === null) {\n\t\t\t\t\t\tif (vnode.dom.selectedIndex === -1 && vnode.dom === $doc.activeElement) return\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (old !== null && vnode.dom.value === normalized0 && vnode.dom === $doc.activeElement) return\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//setting option[value] to same value while having select open blinks select dropdown in Chrome\n\t\t\t\tif (vnode.tag === "option" && old != null && vnode.dom.value === normalized0) return\n\t\t\t}\n\t\t\t// If you assign an input type1 that is not supported by IE 11 with an assignment expression, an error0 will occur.\n\t\t\tif (vnode.tag === "input" && key2 === "type") {\n\t\t\t\telement.setAttribute(key2, value)\n\t\t\t\treturn\n\t\t\t}\n\t\t\telement[key2] = value\n\t\t}\n\t\telse {\n\t\t\tif (typeof value === "boolean") {\n\t\t\t\tif (value) element.setAttribute(key2, "")\n\t\t\t\telse element.removeAttribute(key2)\n\t\t\t}\n\t\t\telse element.setAttribute(key2 === "className" ? "class" : key2, value)\n\t\t}\n\t}\n\tfunction setLateAttrs(vnode) {\n\t\tvar attrs2 = vnode.attrs\n\t\tif (vnode.tag === "select" && attrs2 != null) {\n\t\t\tif ("value" in attrs2) setAttr(vnode, "value", null, attrs2.value, undefined)\n\t\t\tif ("selectedIndex" in attrs2) setAttr(vnode, "selectedIndex", null, attrs2.selectedIndex, undefined)\n\t\t}\n\t}\n\tfunction updateAttrs(vnode, old, attrs2, ns) {\n\t\tif (attrs2 != null) {\n\t\t\tfor (var key2 in attrs2) {\n\t\t\t\tsetAttr(vnode, key2, old && old[key2], attrs2[key2], ns)\n\t\t\t}\n\t\t}\n\t\tif (old != null) {\n\t\t\tfor (var key2 in old) {\n\t\t\t\tif (attrs2 == null || !(key2 in attrs2)) {\n\t\t\t\t\tif (key2 === "className") key2 = "class"\n\t\t\t\t\tif (key2[0] === "o" && key2[1] === "n" && !isLifecycleMethod(key2)) updateEvent(vnode, key2, undefined)\n\t\t\t\t\telse if (key2 !== "key") vnode.dom.removeAttribute(key2)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfunction isFormAttribute(vnode, attr) {\n\t\treturn attr === "value" || attr === "checked" || attr === "selectedIndex" || attr === "selected" && vnode.dom === $doc.activeElement\n\t}\n\tfunction isLifecycleMethod(attr) {\n\t\treturn attr === "oninit" || attr === "oncreate" || attr === "onupdate" || attr === "onremove" || attr === "onbeforeremove" || attr === "onbeforeupdate"\n\t}\n\tfunction isAttribute(attr) {\n\t\treturn attr === "href" || attr === "list" || attr === "form" || attr === "width" || attr === "height"// || attr === "type"\n\t}\n\tfunction isCustomElement(vnode){\n\t\treturn vnode.attrs.is || vnode.tag.indexOf("-") > -1\n\t}\n\tfunction hasIntegrationMethods(source) {\n\t\treturn source != null && (source.oncreate || source.onupdate || source.onbeforeremove || source.onremove)\n\t}\n\t//style\n\tfunction updateStyle(element, old, style) {\n\t\tif (old === style) element.style.cssText = "", old = null\n\t\tif (style == null) element.style.cssText = ""\n\t\telse if (typeof style === "string") element.style.cssText = style\n\t\telse {\n\t\t\tif (typeof old === "string") element.style.cssText = ""\n\t\t\tfor (var key2 in style) {\n\t\t\t\telement.style[key2] = style[key2]\n\t\t\t}\n\t\t\tif (old != null && typeof old !== "string") {\n\t\t\t\tfor (var key2 in old) {\n\t\t\t\t\tif (!(key2 in style)) element.style[key2] = ""\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//event\n\tfunction updateEvent(vnode, key2, value) {\n\t\tvar element = vnode.dom\n\t\tvar callback = typeof onevent !== "function" ? value : function(e) {\n\t\t\tvar result = value.call(element, e)\n\t\t\tonevent.call(element, e)\n\t\t\treturn result\n\t\t}\n\t\tif (key2 in element) element[key2] = typeof value === "function" ? callback : null\n\t\telse {\n\t\t\tvar eventName = key2.slice(2)\n\t\t\tif (vnode.events === undefined) vnode.events = {}\n\t\t\tif (vnode.events[key2] === callback) return\n\t\t\tif (vnode.events[key2] != null) element.removeEventListener(eventName, vnode.events[key2], false)\n\t\t\tif (typeof value === "function") {\n\t\t\t\tvnode.events[key2] = callback\n\t\t\t\telement.addEventListener(eventName, vnode.events[key2], false)\n\t\t\t}\n\t\t}\n\t}\n\t//lifecycle\n\tfunction initLifecycle(source, vnode, hooks) {\n\t\tif (typeof source.oninit === "function") source.oninit.call(vnode.state, vnode)\n\t\tif (typeof source.oncreate === "function") hooks.push(source.oncreate.bind(vnode.state, vnode))\n\t}\n\tfunction updateLifecycle(source, vnode, hooks) {\n\t\tif (typeof source.onupdate === "function") hooks.push(source.onupdate.bind(vnode.state, vnode))\n\t}\n\tfunction shouldNotUpdate(vnode, old) {\n\t\tvar forceVnodeUpdate, forceComponentUpdate\n\t\tif (vnode.attrs != null && typeof vnode.attrs.onbeforeupdate === "function") forceVnodeUpdate = vnode.attrs.onbeforeupdate.call(vnode.state, vnode, old)\n\t\tif (typeof vnode.tag !== "string" && typeof vnode._state.onbeforeupdate === "function") forceComponentUpdate = vnode._state.onbeforeupdate.call(vnode.state, vnode, old)\n\t\tif (!(forceVnodeUpdate === undefined && forceComponentUpdate === undefined) && !forceVnodeUpdate && !forceComponentUpdate) {\n\t\t\tvnode.dom = old.dom\n\t\t\tvnode.domSize = old.domSize\n\t\t\tvnode.instance = old.instance\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\tfunction render(dom, vnodes) {\n\t\tif (!dom) throw new Error("Ensure the DOM element being passed to m.route/m.mount/m.render is not undefined.")\n\t\tvar hooks = []\n\t\tvar active = $doc.activeElement\n\t\tvar namespace = dom.namespaceURI\n\t\t// First time0 rendering into a node clears it out\n\t\tif (dom.vnodes == null) dom.textContent = ""\n\t\tif (!Array.isArray(vnodes)) vnodes = [vnodes]\n\t\tupdateNodes(dom, dom.vnodes, Vnode.normalizeChildren(vnodes), false, hooks, null, namespace === "http://www.w3.org/1999/xhtml" ? undefined : namespace)\n\t\tdom.vnodes = vnodes\n\t\tfor (var i = 0; i < hooks.length; i++) hooks[i]()\n\t\tif ($doc.activeElement !== active) active.focus()\n\t}\n\treturn {render: render, setEventCallback: setEventCallback}\n}\nfunction throttle(callback) {\n\t//60fps translates to 16.6ms, round it down since setTimeout requires int\n\tvar time = 16\n\tvar last = 0, pending = null\n\tvar timeout = typeof requestAnimationFrame === "function" ? requestAnimationFrame : setTimeout\n\treturn function() {\n\t\tvar now = Date.now()\n\t\tif (last === 0 || now - last >= time) {\n\t\t\tlast = now\n\t\t\tcallback()\n\t\t}\n\t\telse if (pending === null) {\n\t\t\tpending = timeout(function() {\n\t\t\t\tpending = null\n\t\t\t\tcallback()\n\t\t\t\tlast = Date.now()\n\t\t\t}, time - (now - last))\n\t\t}\n\t}\n}\nvar _11 = function($window) {\n\tvar renderService = coreRenderer($window)\n\trenderService.setEventCallback(function(e) {\n\t\tif (e.redraw === false) e.redraw = undefined\n\t\telse redraw()\n\t})\n\tvar callbacks = []\n\tfunction subscribe(key1, callback) {\n\t\tunsubscribe(key1)\n\t\tcallbacks.push(key1, throttle(callback))\n\t}\n\tfunction unsubscribe(key1) {\n\t\tvar index = callbacks.indexOf(key1)\n\t\tif (index > -1) callbacks.splice(index, 2)\n\t}\n\tfunction redraw() {\n\t\tfor (var i = 1; i < callbacks.length; i += 2) {\n\t\t\tcallbacks[i]()\n\t\t}\n\t}\n\treturn {subscribe: subscribe, unsubscribe: unsubscribe, redraw: redraw, render: renderService.render}\n}\nvar redrawService = _11(window)\nrequestService.setCompletionCallback(redrawService.redraw)\nvar _16 = function(redrawService0) {\n\treturn function(root, component) {\n\t\tif (component === null) {\n\t\t\tredrawService0.render(root, [])\n\t\t\tredrawService0.unsubscribe(root)\n\t\t\treturn\n\t\t}\n\t\t\n\t\tif (component.view == null && typeof component !== "function") throw new Error("m.mount(element, component) expects a component, not a vnode")\n\t\t\n\t\tvar run0 = function() {\n\t\t\tredrawService0.render(root, Vnode(component))\n\t\t}\n\t\tredrawService0.subscribe(root, run0)\n\t\tredrawService0.redraw()\n\t}\n}\nm.mount = _16(redrawService)\nvar Promise = PromisePolyfill\nvar parseQueryString = function(string) {\n\tif (string === "" || string == null) return {}\n\tif (string.charAt(0) === "?") string = string.slice(1)\n\tvar entries = string.split("&"), data0 = {}, counters = {}\n\tfor (var i = 0; i < entries.length; i++) {\n\t\tvar entry = entries[i].split("=")\n\t\tvar key5 = decodeURIComponent(entry[0])\n\t\tvar value = entry.length === 2 ? decodeURIComponent(entry[1]) : ""\n\t\tif (value === "true") value = true\n\t\telse if (value === "false") value = false\n\t\tvar levels = key5.split(/\\]\\[?|\\[/)\n\t\tvar cursor = data0\n\t\tif (key5.indexOf("[") > -1) levels.pop()\n\t\tfor (var j = 0; j < levels.length; j++) {\n\t\t\tvar level = levels[j], nextLevel = levels[j + 1]\n\t\t\tvar isNumber = nextLevel == "" || !isNaN(parseInt(nextLevel, 10))\n\t\t\tvar isValue = j === levels.length - 1\n\t\t\tif (level === "") {\n\t\t\t\tvar key5 = levels.slice(0, j).join()\n\t\t\t\tif (counters[key5] == null) counters[key5] = 0\n\t\t\t\tlevel = counters[key5]++\n\t\t\t}\n\t\t\tif (cursor[level] == null) {\n\t\t\t\tcursor[level] = isValue ? value : isNumber ? [] : {}\n\t\t\t}\n\t\t\tcursor = cursor[level]\n\t\t}\n\t}\n\treturn data0\n}\nvar coreRouter = function($window) {\n\tvar supportsPushState = typeof $window.history.pushState === "function"\n\tvar callAsync0 = typeof setImmediate === "function" ? setImmediate : setTimeout\n\tfunction normalize1(fragment0) {\n\t\tvar data = $window.location[fragment0].replace(/(?:%[a-f89][a-f0-9])+/gim, decodeURIComponent)\n\t\tif (fragment0 === "pathname" && data[0] !== "/") data = "/" + data\n\t\treturn data\n\t}\n\tvar asyncId\n\tfunction debounceAsync(callback0) {\n\t\treturn function() {\n\t\t\tif (asyncId != null) return\n\t\t\tasyncId = callAsync0(function() {\n\t\t\t\tasyncId = null\n\t\t\t\tcallback0()\n\t\t\t})\n\t\t}\n\t}\n\tfunction parsePath(path, queryData, hashData) {\n\t\tvar queryIndex = path.indexOf("?")\n\t\tvar hashIndex = path.indexOf("#")\n\t\tvar pathEnd = queryIndex > -1 ? queryIndex : hashIndex > -1 ? hashIndex : path.length\n\t\tif (queryIndex > -1) {\n\t\t\tvar queryEnd = hashIndex > -1 ? hashIndex : path.length\n\t\t\tvar queryParams = parseQueryString(path.slice(queryIndex + 1, queryEnd))\n\t\t\tfor (var key4 in queryParams) queryData[key4] = queryParams[key4]\n\t\t}\n\t\tif (hashIndex > -1) {\n\t\t\tvar hashParams = parseQueryString(path.slice(hashIndex + 1))\n\t\t\tfor (var key4 in hashParams) hashData[key4] = hashParams[key4]\n\t\t}\n\t\treturn path.slice(0, pathEnd)\n\t}\n\tvar router = {prefix: "#!"}\n\trouter.getPath = function() {\n\t\tvar type2 = router.prefix.charAt(0)\n\t\tswitch (type2) {\n\t\t\tcase "#": return normalize1("hash").slice(router.prefix.length)\n\t\t\tcase "?": return normalize1("search").slice(router.prefix.length) + normalize1("hash")\n\t\t\tdefault: return normalize1("pathname").slice(router.prefix.length) + normalize1("search") + normalize1("hash")\n\t\t}\n\t}\n\trouter.setPath = function(path, data, options) {\n\t\tvar queryData = {}, hashData = {}\n\t\tpath = parsePath(path, queryData, hashData)\n\t\tif (data != null) {\n\t\t\tfor (var key4 in data) queryData[key4] = data[key4]\n\t\t\tpath = path.replace(/:([^\\/]+)/g, function(match2, token) {\n\t\t\t\tdelete queryData[token]\n\t\t\t\treturn data[token]\n\t\t\t})\n\t\t}\n\t\tvar query = buildQueryString(queryData)\n\t\tif (query) path += "?" + query\n\t\tvar hash = buildQueryString(hashData)\n\t\tif (hash) path += "#" + hash\n\t\tif (supportsPushState) {\n\t\t\tvar state = options ? options.state : null\n\t\t\tvar title = options ? options.title : null\n\t\t\t$window.onpopstate()\n\t\t\tif (options && options.replace) $window.history.replaceState(state, title, router.prefix + path)\n\t\t\telse $window.history.pushState(state, title, router.prefix + path)\n\t\t}\n\t\telse $window.location.href = router.prefix + path\n\t}\n\trouter.defineRoutes = function(routes, resolve, reject) {\n\t\tfunction resolveRoute() {\n\t\t\tvar path = router.getPath()\n\t\t\tvar params = {}\n\t\t\tvar pathname = parsePath(path, params, params)\n\t\t\tvar state = $window.history.state\n\t\t\tif (state != null) {\n\t\t\t\tfor (var k in state) params[k] = state[k]\n\t\t\t}\n\t\t\tfor (var route0 in routes) {\n\t\t\t\tvar matcher = new RegExp("^" + route0.replace(/:[^\\/]+?\\.{3}/g, "(.*?)").replace(/:[^\\/]+/g, "([^\\\\/]+)") + "\\/?$")\n\t\t\t\tif (matcher.test(pathname)) {\n\t\t\t\t\tpathname.replace(matcher, function() {\n\t\t\t\t\t\tvar keys = route0.match(/:[^\\/]+/g) || []\n\t\t\t\t\t\tvar values = [].slice.call(arguments, 1, -2)\n\t\t\t\t\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\t\t\t\t\tparams[keys[i].replace(/:|\\./g, "")] = decodeURIComponent(values[i])\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresolve(routes[route0], params, path, route0)\n\t\t\t\t\t})\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\treject(path, params)\n\t\t}\n\t\tif (supportsPushState) $window.onpopstate = debounceAsync(resolveRoute)\n\t\telse if (router.prefix.charAt(0) === "#") $window.onhashchange = resolveRoute\n\t\tresolveRoute()\n\t}\n\treturn router\n}\nvar _20 = function($window, redrawService0) {\n\tvar routeService = coreRouter($window)\n\tvar identity = function(v) {return v}\n\tvar render1, component, attrs3, currentPath, lastUpdate\n\tvar route = function(root, defaultRoute, routes) {\n\t\tif (root == null) throw new Error("Ensure the DOM element that was passed to `m.route` is not undefined")\n\t\tvar run1 = function() {\n\t\t\tif (render1 != null) redrawService0.render(root, render1(Vnode(component, attrs3.key, attrs3)))\n\t\t}\n\t\tvar bail = function(path) {\n\t\t\tif (path !== defaultRoute) routeService.setPath(defaultRoute, null, {replace: true})\n\t\t\telse throw new Error("Could not resolve default route " + defaultRoute)\n\t\t}\n\t\trouteService.defineRoutes(routes, function(payload, params, path) {\n\t\t\tvar update = lastUpdate = function(routeResolver, comp) {\n\t\t\t\tif (update !== lastUpdate) return\n\t\t\t\tcomponent = comp != null && (typeof comp.view === "function" || typeof comp === "function")? comp : "div"\n\t\t\t\tattrs3 = params, currentPath = path, lastUpdate = null\n\t\t\t\trender1 = (routeResolver.render || identity).bind(routeResolver)\n\t\t\t\trun1()\n\t\t\t}\n\t\t\tif (payload.view || typeof payload === "function") update({}, payload)\n\t\t\telse {\n\t\t\t\tif (payload.onmatch) {\n\t\t\t\t\tPromise.resolve(payload.onmatch(params, path)).then(function(resolved) {\n\t\t\t\t\t\tupdate(payload, resolved)\n\t\t\t\t\t}, bail)\n\t\t\t\t}\n\t\t\t\telse update(payload, "div")\n\t\t\t}\n\t\t}, bail)\n\t\tredrawService0.subscribe(root, run1)\n\t}\n\troute.set = function(path, data, options) {\n\t\tif (lastUpdate != null) {\n\t\t\toptions = options || {}\n\t\t\toptions.replace = true\n\t\t}\n\t\tlastUpdate = null\n\t\trouteService.setPath(path, data, options)\n\t}\n\troute.get = function() {return currentPath}\n\troute.prefix = function(prefix0) {routeService.prefix = prefix0}\n\troute.link = function(vnode1) {\n\t\tvnode1.dom.setAttribute("href", routeService.prefix + vnode1.attrs.href)\n\t\tvnode1.dom.onclick = function(e) {\n\t\t\tif (e.ctrlKey || e.metaKey || e.shiftKey || e.which === 2) return\n\t\t\te.preventDefault()\n\t\t\te.redraw = false\n\t\t\tvar href = this.getAttribute("href")\n\t\t\tif (href.indexOf(routeService.prefix) === 0) href = href.slice(routeService.prefix.length)\n\t\t\troute.set(href, undefined, undefined)\n\t\t}\n\t}\n\troute.param = function(key3) {\n\t\tif(typeof attrs3 !== "undefined" && typeof key3 !== "undefined") return attrs3[key3]\n\t\treturn attrs3\n\t}\n\treturn route\n}\nm.route = _20(window, redrawService)\nm.withAttr = function(attrName, callback1, context) {\n\treturn function(e) {\n\t\tcallback1.call(context || this, attrName in e.currentTarget ? e.currentTarget[attrName] : e.currentTarget.getAttribute(attrName))\n\t}\n}\nvar _28 = coreRenderer(window)\nm.render = _28.render\nm.redraw = redrawService.redraw\nm.request = requestService.request\nm.jsonp = requestService.jsonp\nm.parseQueryString = parseQueryString\nm.buildQueryString = buildQueryString\nm.version = "1.1.3"\nm.vnode = Vnode\nif (true) module["exports"] = m\nelse window.m = m\n}());\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(13).setImmediate, __webpack_require__(3)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21pdGhyaWwvbWl0aHJpbC5qcz9iZDQyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLDZEQUFDO0FBQ0Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLG1DQUFtQyxZQUFZO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDZCQUE2QixZQUFZO0FBQ3RELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsMkNBQTJDO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsZUFBZTtBQUM5RDtBQUNBO0FBQ0EsdURBQXVELGNBQWM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtKQUFrSixhQUFhO0FBQy9KO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLGFBQWE7QUFDYjtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsc0lBQXNJO0FBQ3ZKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QyxpQ0FBaUMsT0FBTztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsMkRBQTJEO0FBQzNELHFGQUFxRjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG1CQUFtQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0SEFBNEg7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QyxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsRUFBRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLGNBQWM7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsSSIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiOyhmdW5jdGlvbigpIHtcblwidXNlIHN0cmljdFwiXG5mdW5jdGlvbiBWbm9kZSh0YWcsIGtleSwgYXR0cnMwLCBjaGlsZHJlbiwgdGV4dCwgZG9tKSB7XG5cdHJldHVybiB7dGFnOiB0YWcsIGtleToga2V5LCBhdHRyczogYXR0cnMwLCBjaGlsZHJlbjogY2hpbGRyZW4sIHRleHQ6IHRleHQsIGRvbTogZG9tLCBkb21TaXplOiB1bmRlZmluZWQsIHN0YXRlOiB1bmRlZmluZWQsIF9zdGF0ZTogdW5kZWZpbmVkLCBldmVudHM6IHVuZGVmaW5lZCwgaW5zdGFuY2U6IHVuZGVmaW5lZCwgc2tpcDogZmFsc2V9XG59XG5Wbm9kZS5ub3JtYWxpemUgPSBmdW5jdGlvbihub2RlKSB7XG5cdGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSByZXR1cm4gVm5vZGUoXCJbXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBWbm9kZS5ub3JtYWxpemVDaGlsZHJlbihub2RlKSwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG5cdGlmIChub2RlICE9IG51bGwgJiYgdHlwZW9mIG5vZGUgIT09IFwib2JqZWN0XCIpIHJldHVybiBWbm9kZShcIiNcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG5vZGUgPT09IGZhbHNlID8gXCJcIiA6IG5vZGUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKVxuXHRyZXR1cm4gbm9kZVxufVxuVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4gPSBmdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbikge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0Y2hpbGRyZW5baV0gPSBWbm9kZS5ub3JtYWxpemUoY2hpbGRyZW5baV0pXG5cdH1cblx0cmV0dXJuIGNoaWxkcmVuXG59XG52YXIgc2VsZWN0b3JQYXJzZXIgPSAvKD86KF58I3xcXC4pKFteI1xcLlxcW1xcXV0rKSl8KFxcWyguKz8pKD86XFxzKj1cXHMqKFwifCd8KSgoPzpcXFxcW1wiJ1xcXV18LikqPylcXDUpP1xcXSkvZ1xudmFyIHNlbGVjdG9yQ2FjaGUgPSB7fVxudmFyIGhhc093biA9IHt9Lmhhc093blByb3BlcnR5XG5mdW5jdGlvbiBjb21waWxlU2VsZWN0b3Ioc2VsZWN0b3IpIHtcblx0dmFyIG1hdGNoLCB0YWcgPSBcImRpdlwiLCBjbGFzc2VzID0gW10sIGF0dHJzID0ge31cblx0d2hpbGUgKG1hdGNoID0gc2VsZWN0b3JQYXJzZXIuZXhlYyhzZWxlY3RvcikpIHtcblx0XHR2YXIgdHlwZSA9IG1hdGNoWzFdLCB2YWx1ZSA9IG1hdGNoWzJdXG5cdFx0aWYgKHR5cGUgPT09IFwiXCIgJiYgdmFsdWUgIT09IFwiXCIpIHRhZyA9IHZhbHVlXG5cdFx0ZWxzZSBpZiAodHlwZSA9PT0gXCIjXCIpIGF0dHJzLmlkID0gdmFsdWVcblx0XHRlbHNlIGlmICh0eXBlID09PSBcIi5cIikgY2xhc3Nlcy5wdXNoKHZhbHVlKVxuXHRcdGVsc2UgaWYgKG1hdGNoWzNdWzBdID09PSBcIltcIikge1xuXHRcdFx0dmFyIGF0dHJWYWx1ZSA9IG1hdGNoWzZdXG5cdFx0XHRpZiAoYXR0clZhbHVlKSBhdHRyVmFsdWUgPSBhdHRyVmFsdWUucmVwbGFjZSgvXFxcXChbXCInXSkvZywgXCIkMVwiKS5yZXBsYWNlKC9cXFxcXFxcXC9nLCBcIlxcXFxcIilcblx0XHRcdGlmIChtYXRjaFs0XSA9PT0gXCJjbGFzc1wiKSBjbGFzc2VzLnB1c2goYXR0clZhbHVlKVxuXHRcdFx0ZWxzZSBhdHRyc1ttYXRjaFs0XV0gPSBhdHRyVmFsdWUgPT09IFwiXCIgPyBhdHRyVmFsdWUgOiBhdHRyVmFsdWUgfHwgdHJ1ZVxuXHRcdH1cblx0fVxuXHRpZiAoY2xhc3Nlcy5sZW5ndGggPiAwKSBhdHRycy5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oXCIgXCIpXG5cdHJldHVybiBzZWxlY3RvckNhY2hlW3NlbGVjdG9yXSA9IHt0YWc6IHRhZywgYXR0cnM6IGF0dHJzfVxufVxuZnVuY3Rpb24gZXhlY1NlbGVjdG9yKHN0YXRlLCBhdHRycywgY2hpbGRyZW4pIHtcblx0dmFyIGhhc0F0dHJzID0gZmFsc2UsIGNoaWxkTGlzdCwgdGV4dFxuXHR2YXIgY2xhc3NOYW1lID0gYXR0cnMuY2xhc3NOYW1lIHx8IGF0dHJzLmNsYXNzXG5cdGZvciAodmFyIGtleSBpbiBzdGF0ZS5hdHRycykge1xuXHRcdGlmIChoYXNPd24uY2FsbChzdGF0ZS5hdHRycywga2V5KSkge1xuXHRcdFx0YXR0cnNba2V5XSA9IHN0YXRlLmF0dHJzW2tleV1cblx0XHR9XG5cdH1cblx0aWYgKGNsYXNzTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0aWYgKGF0dHJzLmNsYXNzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGF0dHJzLmNsYXNzID0gdW5kZWZpbmVkXG5cdFx0XHRhdHRycy5jbGFzc05hbWUgPSBjbGFzc05hbWVcblx0XHR9XG5cdFx0aWYgKHN0YXRlLmF0dHJzLmNsYXNzTmFtZSAhPSBudWxsKSB7XG5cdFx0XHRhdHRycy5jbGFzc05hbWUgPSBzdGF0ZS5hdHRycy5jbGFzc05hbWUgKyBcIiBcIiArIGNsYXNzTmFtZVxuXHRcdH1cblx0fVxuXHRmb3IgKHZhciBrZXkgaW4gYXR0cnMpIHtcblx0XHRpZiAoaGFzT3duLmNhbGwoYXR0cnMsIGtleSkgJiYga2V5ICE9PSBcImtleVwiKSB7XG5cdFx0XHRoYXNBdHRycyA9IHRydWVcblx0XHRcdGJyZWFrXG5cdFx0fVxuXHR9XG5cdGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJiBjaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgY2hpbGRyZW5bMF0gIT0gbnVsbCAmJiBjaGlsZHJlblswXS50YWcgPT09IFwiI1wiKSB7XG5cdFx0dGV4dCA9IGNoaWxkcmVuWzBdLmNoaWxkcmVuXG5cdH0gZWxzZSB7XG5cdFx0Y2hpbGRMaXN0ID0gY2hpbGRyZW5cblx0fVxuXHRyZXR1cm4gVm5vZGUoc3RhdGUudGFnLCBhdHRycy5rZXksIGhhc0F0dHJzID8gYXR0cnMgOiB1bmRlZmluZWQsIGNoaWxkTGlzdCwgdGV4dClcbn1cbmZ1bmN0aW9uIGh5cGVyc2NyaXB0KHNlbGVjdG9yKSB7XG5cdC8vIEJlY2F1c2Ugc2xvcHB5IG1vZGUgc3Vja3Ncblx0dmFyIGF0dHJzID0gYXJndW1lbnRzWzFdLCBzdGFydCA9IDIsIGNoaWxkcmVuXG5cdGlmIChzZWxlY3RvciA9PSBudWxsIHx8IHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygc2VsZWN0b3IgIT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygc2VsZWN0b3IudmlldyAhPT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0dGhyb3cgRXJyb3IoXCJUaGUgc2VsZWN0b3IgbXVzdCBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgYSBjb21wb25lbnQuXCIpO1xuXHR9XG5cdGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIpIHtcblx0XHR2YXIgY2FjaGVkID0gc2VsZWN0b3JDYWNoZVtzZWxlY3Rvcl0gfHwgY29tcGlsZVNlbGVjdG9yKHNlbGVjdG9yKVxuXHR9XG5cdGlmIChhdHRycyA9PSBudWxsKSB7XG5cdFx0YXR0cnMgPSB7fVxuXHR9IGVsc2UgaWYgKHR5cGVvZiBhdHRycyAhPT0gXCJvYmplY3RcIiB8fCBhdHRycy50YWcgIT0gbnVsbCB8fCBBcnJheS5pc0FycmF5KGF0dHJzKSkge1xuXHRcdGF0dHJzID0ge31cblx0XHRzdGFydCA9IDFcblx0fVxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gc3RhcnQgKyAxKSB7XG5cdFx0Y2hpbGRyZW4gPSBhcmd1bWVudHNbc3RhcnRdXG5cdFx0aWYgKCFBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkgY2hpbGRyZW4gPSBbY2hpbGRyZW5dXG5cdH0gZWxzZSB7XG5cdFx0Y2hpbGRyZW4gPSBbXVxuXHRcdHdoaWxlIChzdGFydCA8IGFyZ3VtZW50cy5sZW5ndGgpIGNoaWxkcmVuLnB1c2goYXJndW1lbnRzW3N0YXJ0KytdKVxuXHR9XG5cdHZhciBub3JtYWxpemVkID0gVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pXG5cdGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIpIHtcblx0XHRyZXR1cm4gZXhlY1NlbGVjdG9yKGNhY2hlZCwgYXR0cnMsIG5vcm1hbGl6ZWQpXG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIFZub2RlKHNlbGVjdG9yLCBhdHRycy5rZXksIGF0dHJzLCBub3JtYWxpemVkKVxuXHR9XG59XG5oeXBlcnNjcmlwdC50cnVzdCA9IGZ1bmN0aW9uKGh0bWwpIHtcblx0aWYgKGh0bWwgPT0gbnVsbCkgaHRtbCA9IFwiXCJcblx0cmV0dXJuIFZub2RlKFwiPFwiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaHRtbCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG59XG5oeXBlcnNjcmlwdC5mcmFnbWVudCA9IGZ1bmN0aW9uKGF0dHJzMSwgY2hpbGRyZW4pIHtcblx0cmV0dXJuIFZub2RlKFwiW1wiLCBhdHRyczEua2V5LCBhdHRyczEsIFZub2RlLm5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKSwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG59XG52YXIgbSA9IGh5cGVyc2NyaXB0XG4vKiogQGNvbnN0cnVjdG9yICovXG52YXIgUHJvbWlzZVBvbHlmaWxsID0gZnVuY3Rpb24oZXhlY3V0b3IpIHtcblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIFByb21pc2VQb2x5ZmlsbCkpIHRocm93IG5ldyBFcnJvcihcIlByb21pc2UgbXVzdCBiZSBjYWxsZWQgd2l0aCBgbmV3YFwiKVxuXHRpZiAodHlwZW9mIGV4ZWN1dG9yICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJleGVjdXRvciBtdXN0IGJlIGEgZnVuY3Rpb25cIilcblx0dmFyIHNlbGYgPSB0aGlzLCByZXNvbHZlcnMgPSBbXSwgcmVqZWN0b3JzID0gW10sIHJlc29sdmVDdXJyZW50ID0gaGFuZGxlcihyZXNvbHZlcnMsIHRydWUpLCByZWplY3RDdXJyZW50ID0gaGFuZGxlcihyZWplY3RvcnMsIGZhbHNlKVxuXHR2YXIgaW5zdGFuY2UgPSBzZWxmLl9pbnN0YW5jZSA9IHtyZXNvbHZlcnM6IHJlc29sdmVycywgcmVqZWN0b3JzOiByZWplY3RvcnN9XG5cdHZhciBjYWxsQXN5bmMgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBzZXRJbW1lZGlhdGUgOiBzZXRUaW1lb3V0XG5cdGZ1bmN0aW9uIGhhbmRsZXIobGlzdCwgc2hvdWxkQWJzb3JiKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGV4ZWN1dGUodmFsdWUpIHtcblx0XHRcdHZhciB0aGVuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAoc2hvdWxkQWJzb3JiICYmIHZhbHVlICE9IG51bGwgJiYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikgJiYgdHlwZW9mICh0aGVuID0gdmFsdWUudGhlbikgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdGlmICh2YWx1ZSA9PT0gc2VsZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByb21pc2UgY2FuJ3QgYmUgcmVzb2x2ZWQgdy8gaXRzZWxmXCIpXG5cdFx0XHRcdFx0ZXhlY3V0ZU9uY2UodGhlbi5iaW5kKHZhbHVlKSlcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRjYWxsQXN5bmMoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRpZiAoIXNob3VsZEFic29yYiAmJiBsaXN0Lmxlbmd0aCA9PT0gMCkgY29uc29sZS5lcnJvcihcIlBvc3NpYmxlIHVuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbjpcIiwgdmFsdWUpXG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIGxpc3RbaV0odmFsdWUpXG5cdFx0XHRcdFx0XHRyZXNvbHZlcnMubGVuZ3RoID0gMCwgcmVqZWN0b3JzLmxlbmd0aCA9IDBcblx0XHRcdFx0XHRcdGluc3RhbmNlLnN0YXRlID0gc2hvdWxkQWJzb3JiXG5cdFx0XHRcdFx0XHRpbnN0YW5jZS5yZXRyeSA9IGZ1bmN0aW9uKCkge2V4ZWN1dGUodmFsdWUpfVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGNhdGNoIChlKSB7XG5cdFx0XHRcdHJlamVjdEN1cnJlbnQoZSlcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gZXhlY3V0ZU9uY2UodGhlbikge1xuXHRcdHZhciBydW5zID0gMFxuXHRcdGZ1bmN0aW9uIHJ1bihmbikge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdGlmIChydW5zKysgPiAwKSByZXR1cm5cblx0XHRcdFx0Zm4odmFsdWUpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHZhciBvbmVycm9yID0gcnVuKHJlamVjdEN1cnJlbnQpXG5cdFx0dHJ5IHt0aGVuKHJ1bihyZXNvbHZlQ3VycmVudCksIG9uZXJyb3IpfSBjYXRjaCAoZSkge29uZXJyb3IoZSl9XG5cdH1cblx0ZXhlY3V0ZU9uY2UoZXhlY3V0b3IpXG59XG5Qcm9taXNlUG9seWZpbGwucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbihvbkZ1bGZpbGxlZCwgb25SZWplY3Rpb24pIHtcblx0dmFyIHNlbGYgPSB0aGlzLCBpbnN0YW5jZSA9IHNlbGYuX2luc3RhbmNlXG5cdGZ1bmN0aW9uIGhhbmRsZShjYWxsYmFjaywgbGlzdCwgbmV4dCwgc3RhdGUpIHtcblx0XHRsaXN0LnB1c2goZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikgbmV4dCh2YWx1ZSlcblx0XHRcdGVsc2UgdHJ5IHtyZXNvbHZlTmV4dChjYWxsYmFjayh2YWx1ZSkpfSBjYXRjaCAoZSkge2lmIChyZWplY3ROZXh0KSByZWplY3ROZXh0KGUpfVxuXHRcdH0pXG5cdFx0aWYgKHR5cGVvZiBpbnN0YW5jZS5yZXRyeSA9PT0gXCJmdW5jdGlvblwiICYmIHN0YXRlID09PSBpbnN0YW5jZS5zdGF0ZSkgaW5zdGFuY2UucmV0cnkoKVxuXHR9XG5cdHZhciByZXNvbHZlTmV4dCwgcmVqZWN0TmV4dFxuXHR2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlUG9seWZpbGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7cmVzb2x2ZU5leHQgPSByZXNvbHZlLCByZWplY3ROZXh0ID0gcmVqZWN0fSlcblx0aGFuZGxlKG9uRnVsZmlsbGVkLCBpbnN0YW5jZS5yZXNvbHZlcnMsIHJlc29sdmVOZXh0LCB0cnVlKSwgaGFuZGxlKG9uUmVqZWN0aW9uLCBpbnN0YW5jZS5yZWplY3RvcnMsIHJlamVjdE5leHQsIGZhbHNlKVxuXHRyZXR1cm4gcHJvbWlzZVxufVxuUHJvbWlzZVBvbHlmaWxsLnByb3RvdHlwZS5jYXRjaCA9IGZ1bmN0aW9uKG9uUmVqZWN0aW9uKSB7XG5cdHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3Rpb24pXG59XG5Qcm9taXNlUG9seWZpbGwucmVzb2x2ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2VQb2x5ZmlsbCkgcmV0dXJuIHZhbHVlXG5cdHJldHVybiBuZXcgUHJvbWlzZVBvbHlmaWxsKGZ1bmN0aW9uKHJlc29sdmUpIHtyZXNvbHZlKHZhbHVlKX0pXG59XG5Qcm9taXNlUG9seWZpbGwucmVqZWN0ID0gZnVuY3Rpb24odmFsdWUpIHtcblx0cmV0dXJuIG5ldyBQcm9taXNlUG9seWZpbGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7cmVqZWN0KHZhbHVlKX0pXG59XG5Qcm9taXNlUG9seWZpbGwuYWxsID0gZnVuY3Rpb24obGlzdCkge1xuXHRyZXR1cm4gbmV3IFByb21pc2VQb2x5ZmlsbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHR2YXIgdG90YWwgPSBsaXN0Lmxlbmd0aCwgY291bnQgPSAwLCB2YWx1ZXMgPSBbXVxuXHRcdGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkgcmVzb2x2ZShbXSlcblx0XHRlbHNlIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdFx0KGZ1bmN0aW9uKGkpIHtcblx0XHRcdFx0ZnVuY3Rpb24gY29uc3VtZSh2YWx1ZSkge1xuXHRcdFx0XHRcdGNvdW50Kytcblx0XHRcdFx0XHR2YWx1ZXNbaV0gPSB2YWx1ZVxuXHRcdFx0XHRcdGlmIChjb3VudCA9PT0gdG90YWwpIHJlc29sdmUodmFsdWVzKVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChsaXN0W2ldICE9IG51bGwgJiYgKHR5cGVvZiBsaXN0W2ldID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBsaXN0W2ldID09PSBcImZ1bmN0aW9uXCIpICYmIHR5cGVvZiBsaXN0W2ldLnRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdGxpc3RbaV0udGhlbihjb25zdW1lLCByZWplY3QpXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBjb25zdW1lKGxpc3RbaV0pXG5cdFx0XHR9KShpKVxuXHRcdH1cblx0fSlcbn1cblByb21pc2VQb2x5ZmlsbC5yYWNlID0gZnVuY3Rpb24obGlzdCkge1xuXHRyZXR1cm4gbmV3IFByb21pc2VQb2x5ZmlsbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHRcdGxpc3RbaV0udGhlbihyZXNvbHZlLCByZWplY3QpXG5cdFx0fVxuXHR9KVxufVxuaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcblx0aWYgKHR5cGVvZiB3aW5kb3cuUHJvbWlzZSA9PT0gXCJ1bmRlZmluZWRcIikgd2luZG93LlByb21pc2UgPSBQcm9taXNlUG9seWZpbGxcblx0dmFyIFByb21pc2VQb2x5ZmlsbCA9IHdpbmRvdy5Qcm9taXNlXG59IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcblx0aWYgKHR5cGVvZiBnbG9iYWwuUHJvbWlzZSA9PT0gXCJ1bmRlZmluZWRcIikgZ2xvYmFsLlByb21pc2UgPSBQcm9taXNlUG9seWZpbGxcblx0dmFyIFByb21pc2VQb2x5ZmlsbCA9IGdsb2JhbC5Qcm9taXNlXG59IGVsc2Uge1xufVxudmFyIGJ1aWxkUXVlcnlTdHJpbmcgPSBmdW5jdGlvbihvYmplY3QpIHtcblx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpICE9PSBcIltvYmplY3QgT2JqZWN0XVwiKSByZXR1cm4gXCJcIlxuXHR2YXIgYXJncyA9IFtdXG5cdGZvciAodmFyIGtleTAgaW4gb2JqZWN0KSB7XG5cdFx0ZGVzdHJ1Y3R1cmUoa2V5MCwgb2JqZWN0W2tleTBdKVxuXHR9XG5cdHJldHVybiBhcmdzLmpvaW4oXCImXCIpXG5cdGZ1bmN0aW9uIGRlc3RydWN0dXJlKGtleTAsIHZhbHVlKSB7XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGRlc3RydWN0dXJlKGtleTAgKyBcIltcIiArIGkgKyBcIl1cIiwgdmFsdWVbaV0pXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09IFwiW29iamVjdCBPYmplY3RdXCIpIHtcblx0XHRcdGZvciAodmFyIGkgaW4gdmFsdWUpIHtcblx0XHRcdFx0ZGVzdHJ1Y3R1cmUoa2V5MCArIFwiW1wiICsgaSArIFwiXVwiLCB2YWx1ZVtpXSlcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBhcmdzLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleTApICsgKHZhbHVlICE9IG51bGwgJiYgdmFsdWUgIT09IFwiXCIgPyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkgOiBcIlwiKSlcblx0fVxufVxudmFyIEZJTEVfUFJPVE9DT0xfUkVHRVggPSBuZXcgUmVnRXhwKFwiXmZpbGU6Ly9cIiwgXCJpXCIpXG52YXIgXzggPSBmdW5jdGlvbigkd2luZG93LCBQcm9taXNlKSB7XG5cdHZhciBjYWxsYmFja0NvdW50ID0gMFxuXHR2YXIgb25jb21wbGV0aW9uXG5cdGZ1bmN0aW9uIHNldENvbXBsZXRpb25DYWxsYmFjayhjYWxsYmFjaykge29uY29tcGxldGlvbiA9IGNhbGxiYWNrfVxuXHRmdW5jdGlvbiBmaW5hbGl6ZXIoKSB7XG5cdFx0dmFyIGNvdW50ID0gMFxuXHRcdGZ1bmN0aW9uIGNvbXBsZXRlKCkge2lmICgtLWNvdW50ID09PSAwICYmIHR5cGVvZiBvbmNvbXBsZXRpb24gPT09IFwiZnVuY3Rpb25cIikgb25jb21wbGV0aW9uKCl9XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGZpbmFsaXplKHByb21pc2UwKSB7XG5cdFx0XHR2YXIgdGhlbjAgPSBwcm9taXNlMC50aGVuXG5cdFx0XHRwcm9taXNlMC50aGVuID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNvdW50Kytcblx0XHRcdFx0dmFyIG5leHQgPSB0aGVuMC5hcHBseShwcm9taXNlMCwgYXJndW1lbnRzKVxuXHRcdFx0XHRuZXh0LnRoZW4oY29tcGxldGUsIGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0XHRjb21wbGV0ZSgpXG5cdFx0XHRcdFx0aWYgKGNvdW50ID09PSAwKSB0aHJvdyBlXG5cdFx0XHRcdH0pXG5cdFx0XHRcdHJldHVybiBmaW5hbGl6ZShuZXh0KVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHByb21pc2UwXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIG5vcm1hbGl6ZShhcmdzLCBleHRyYSkge1xuXHRcdGlmICh0eXBlb2YgYXJncyA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0dmFyIHVybCA9IGFyZ3Ncblx0XHRcdGFyZ3MgPSBleHRyYSB8fCB7fVxuXHRcdFx0aWYgKGFyZ3MudXJsID09IG51bGwpIGFyZ3MudXJsID0gdXJsXG5cdFx0fVxuXHRcdHJldHVybiBhcmdzXG5cdH1cblx0ZnVuY3Rpb24gcmVxdWVzdChhcmdzLCBleHRyYSkge1xuXHRcdHZhciBmaW5hbGl6ZSA9IGZpbmFsaXplcigpXG5cdFx0YXJncyA9IG5vcm1hbGl6ZShhcmdzLCBleHRyYSlcblx0XHR2YXIgcHJvbWlzZTAgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHRcdGlmIChhcmdzLm1ldGhvZCA9PSBudWxsKSBhcmdzLm1ldGhvZCA9IFwiR0VUXCJcblx0XHRcdGFyZ3MubWV0aG9kID0gYXJncy5tZXRob2QudG9VcHBlckNhc2UoKVxuXHRcdFx0dmFyIHVzZUJvZHkgPSAoYXJncy5tZXRob2QgPT09IFwiR0VUXCIgfHwgYXJncy5tZXRob2QgPT09IFwiVFJBQ0VcIikgPyBmYWxzZSA6ICh0eXBlb2YgYXJncy51c2VCb2R5ID09PSBcImJvb2xlYW5cIiA/IGFyZ3MudXNlQm9keSA6IHRydWUpXG5cdFx0XHRpZiAodHlwZW9mIGFyZ3Muc2VyaWFsaXplICE9PSBcImZ1bmN0aW9uXCIpIGFyZ3Muc2VyaWFsaXplID0gdHlwZW9mIEZvcm1EYXRhICE9PSBcInVuZGVmaW5lZFwiICYmIGFyZ3MuZGF0YSBpbnN0YW5jZW9mIEZvcm1EYXRhID8gZnVuY3Rpb24odmFsdWUpIHtyZXR1cm4gdmFsdWV9IDogSlNPTi5zdHJpbmdpZnlcblx0XHRcdGlmICh0eXBlb2YgYXJncy5kZXNlcmlhbGl6ZSAhPT0gXCJmdW5jdGlvblwiKSBhcmdzLmRlc2VyaWFsaXplID0gZGVzZXJpYWxpemVcblx0XHRcdGlmICh0eXBlb2YgYXJncy5leHRyYWN0ICE9PSBcImZ1bmN0aW9uXCIpIGFyZ3MuZXh0cmFjdCA9IGV4dHJhY3Rcblx0XHRcdGFyZ3MudXJsID0gaW50ZXJwb2xhdGUoYXJncy51cmwsIGFyZ3MuZGF0YSlcblx0XHRcdGlmICh1c2VCb2R5KSBhcmdzLmRhdGEgPSBhcmdzLnNlcmlhbGl6ZShhcmdzLmRhdGEpXG5cdFx0XHRlbHNlIGFyZ3MudXJsID0gYXNzZW1ibGUoYXJncy51cmwsIGFyZ3MuZGF0YSlcblx0XHRcdHZhciB4aHIgPSBuZXcgJHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpLFxuXHRcdFx0XHRhYm9ydGVkID0gZmFsc2UsXG5cdFx0XHRcdF9hYm9ydCA9IHhoci5hYm9ydFxuXHRcdFx0eGhyLmFib3J0ID0gZnVuY3Rpb24gYWJvcnQoKSB7XG5cdFx0XHRcdGFib3J0ZWQgPSB0cnVlXG5cdFx0XHRcdF9hYm9ydC5jYWxsKHhocilcblx0XHRcdH1cblx0XHRcdHhoci5vcGVuKGFyZ3MubWV0aG9kLCBhcmdzLnVybCwgdHlwZW9mIGFyZ3MuYXN5bmMgPT09IFwiYm9vbGVhblwiID8gYXJncy5hc3luYyA6IHRydWUsIHR5cGVvZiBhcmdzLnVzZXIgPT09IFwic3RyaW5nXCIgPyBhcmdzLnVzZXIgOiB1bmRlZmluZWQsIHR5cGVvZiBhcmdzLnBhc3N3b3JkID09PSBcInN0cmluZ1wiID8gYXJncy5wYXNzd29yZCA6IHVuZGVmaW5lZClcblx0XHRcdGlmIChhcmdzLnNlcmlhbGl6ZSA9PT0gSlNPTi5zdHJpbmdpZnkgJiYgdXNlQm9keSkge1xuXHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiLCBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIilcblx0XHRcdH1cblx0XHRcdGlmIChhcmdzLmRlc2VyaWFsaXplID09PSBkZXNlcmlhbGl6ZSkge1xuXHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkFjY2VwdFwiLCBcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvKlwiKVxuXHRcdFx0fVxuXHRcdFx0aWYgKGFyZ3Mud2l0aENyZWRlbnRpYWxzKSB4aHIud2l0aENyZWRlbnRpYWxzID0gYXJncy53aXRoQ3JlZGVudGlhbHNcblx0XHRcdGZvciAodmFyIGtleSBpbiBhcmdzLmhlYWRlcnMpIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFyZ3MuaGVhZGVycywga2V5KSkge1xuXHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIGFyZ3MuaGVhZGVyc1trZXldKVxuXHRcdFx0fVxuXHRcdFx0aWYgKHR5cGVvZiBhcmdzLmNvbmZpZyA9PT0gXCJmdW5jdGlvblwiKSB4aHIgPSBhcmdzLmNvbmZpZyh4aHIsIGFyZ3MpIHx8IHhoclxuXHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBEb24ndCB0aHJvdyBlcnJvcnMgb24geGhyLmFib3J0KCkuXG5cdFx0XHRcdGlmKGFib3J0ZWQpIHJldHVyblxuXHRcdFx0XHRpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0dmFyIHJlc3BvbnNlID0gKGFyZ3MuZXh0cmFjdCAhPT0gZXh0cmFjdCkgPyBhcmdzLmV4dHJhY3QoeGhyLCBhcmdzKSA6IGFyZ3MuZGVzZXJpYWxpemUoYXJncy5leHRyYWN0KHhociwgYXJncykpXG5cdFx0XHRcdFx0XHRpZiAoKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDApIHx8IHhoci5zdGF0dXMgPT09IDMwNCB8fCBGSUxFX1BST1RPQ09MX1JFR0VYLnRlc3QoYXJncy51cmwpKSB7XG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoY2FzdChhcmdzLnR5cGUsIHJlc3BvbnNlKSlcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR2YXIgZXJyb3IgPSBuZXcgRXJyb3IoeGhyLnJlc3BvbnNlVGV4dClcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIga2V5IGluIHJlc3BvbnNlKSBlcnJvcltrZXldID0gcmVzcG9uc2Vba2V5XVxuXHRcdFx0XHRcdFx0XHRyZWplY3QoZXJyb3IpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0XHRyZWplY3QoZSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICh1c2VCb2R5ICYmIChhcmdzLmRhdGEgIT0gbnVsbCkpIHhoci5zZW5kKGFyZ3MuZGF0YSlcblx0XHRcdGVsc2UgeGhyLnNlbmQoKVxuXHRcdH0pXG5cdFx0cmV0dXJuIGFyZ3MuYmFja2dyb3VuZCA9PT0gdHJ1ZSA/IHByb21pc2UwIDogZmluYWxpemUocHJvbWlzZTApXG5cdH1cblx0ZnVuY3Rpb24ganNvbnAoYXJncywgZXh0cmEpIHtcblx0XHR2YXIgZmluYWxpemUgPSBmaW5hbGl6ZXIoKVxuXHRcdGFyZ3MgPSBub3JtYWxpemUoYXJncywgZXh0cmEpXG5cdFx0dmFyIHByb21pc2UwID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0XHR2YXIgY2FsbGJhY2tOYW1lID0gYXJncy5jYWxsYmFja05hbWUgfHwgXCJfbWl0aHJpbF9cIiArIE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDFlMTYpICsgXCJfXCIgKyBjYWxsYmFja0NvdW50Kytcblx0XHRcdHZhciBzY3JpcHQgPSAkd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIilcblx0XHRcdCR3aW5kb3dbY2FsbGJhY2tOYW1lXSA9IGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdFx0c2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KVxuXHRcdFx0XHRyZXNvbHZlKGNhc3QoYXJncy50eXBlLCBkYXRhKSlcblx0XHRcdFx0ZGVsZXRlICR3aW5kb3dbY2FsbGJhY2tOYW1lXVxuXHRcdFx0fVxuXHRcdFx0c2NyaXB0Lm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KVxuXHRcdFx0XHRyZWplY3QobmV3IEVycm9yKFwiSlNPTlAgcmVxdWVzdCBmYWlsZWRcIikpXG5cdFx0XHRcdGRlbGV0ZSAkd2luZG93W2NhbGxiYWNrTmFtZV1cblx0XHRcdH1cblx0XHRcdGlmIChhcmdzLmRhdGEgPT0gbnVsbCkgYXJncy5kYXRhID0ge31cblx0XHRcdGFyZ3MudXJsID0gaW50ZXJwb2xhdGUoYXJncy51cmwsIGFyZ3MuZGF0YSlcblx0XHRcdGFyZ3MuZGF0YVthcmdzLmNhbGxiYWNrS2V5IHx8IFwiY2FsbGJhY2tcIl0gPSBjYWxsYmFja05hbWVcblx0XHRcdHNjcmlwdC5zcmMgPSBhc3NlbWJsZShhcmdzLnVybCwgYXJncy5kYXRhKVxuXHRcdFx0JHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoc2NyaXB0KVxuXHRcdH0pXG5cdFx0cmV0dXJuIGFyZ3MuYmFja2dyb3VuZCA9PT0gdHJ1ZT8gcHJvbWlzZTAgOiBmaW5hbGl6ZShwcm9taXNlMClcblx0fVxuXHRmdW5jdGlvbiBpbnRlcnBvbGF0ZSh1cmwsIGRhdGEpIHtcblx0XHRpZiAoZGF0YSA9PSBudWxsKSByZXR1cm4gdXJsXG5cdFx0dmFyIHRva2VucyA9IHVybC5tYXRjaCgvOlteXFwvXSsvZ2kpIHx8IFtdXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBrZXkgPSB0b2tlbnNbaV0uc2xpY2UoMSlcblx0XHRcdGlmIChkYXRhW2tleV0gIT0gbnVsbCkge1xuXHRcdFx0XHR1cmwgPSB1cmwucmVwbGFjZSh0b2tlbnNbaV0sIGRhdGFba2V5XSlcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHVybFxuXHR9XG5cdGZ1bmN0aW9uIGFzc2VtYmxlKHVybCwgZGF0YSkge1xuXHRcdHZhciBxdWVyeXN0cmluZyA9IGJ1aWxkUXVlcnlTdHJpbmcoZGF0YSlcblx0XHRpZiAocXVlcnlzdHJpbmcgIT09IFwiXCIpIHtcblx0XHRcdHZhciBwcmVmaXggPSB1cmwuaW5kZXhPZihcIj9cIikgPCAwID8gXCI/XCIgOiBcIiZcIlxuXHRcdFx0dXJsICs9IHByZWZpeCArIHF1ZXJ5c3RyaW5nXG5cdFx0fVxuXHRcdHJldHVybiB1cmxcblx0fVxuXHRmdW5jdGlvbiBkZXNlcmlhbGl6ZShkYXRhKSB7XG5cdFx0dHJ5IHtyZXR1cm4gZGF0YSAhPT0gXCJcIiA/IEpTT04ucGFyc2UoZGF0YSkgOiBudWxsfVxuXHRcdGNhdGNoIChlKSB7dGhyb3cgbmV3IEVycm9yKGRhdGEpfVxuXHR9XG5cdGZ1bmN0aW9uIGV4dHJhY3QoeGhyKSB7cmV0dXJuIHhoci5yZXNwb25zZVRleHR9XG5cdGZ1bmN0aW9uIGNhc3QodHlwZTAsIGRhdGEpIHtcblx0XHRpZiAodHlwZW9mIHR5cGUwID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGRhdGFbaV0gPSBuZXcgdHlwZTAoZGF0YVtpXSlcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSByZXR1cm4gbmV3IHR5cGUwKGRhdGEpXG5cdFx0fVxuXHRcdHJldHVybiBkYXRhXG5cdH1cblx0cmV0dXJuIHtyZXF1ZXN0OiByZXF1ZXN0LCBqc29ucDoganNvbnAsIHNldENvbXBsZXRpb25DYWxsYmFjazogc2V0Q29tcGxldGlvbkNhbGxiYWNrfVxufVxudmFyIHJlcXVlc3RTZXJ2aWNlID0gXzgod2luZG93LCBQcm9taXNlUG9seWZpbGwpXG52YXIgY29yZVJlbmRlcmVyID0gZnVuY3Rpb24oJHdpbmRvdykge1xuXHR2YXIgJGRvYyA9ICR3aW5kb3cuZG9jdW1lbnRcblx0dmFyICRlbXB0eUZyYWdtZW50ID0gJGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcblx0dmFyIG5hbWVTcGFjZSA9IHtcblx0XHRzdmc6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcblx0XHRtYXRoOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIlxuXHR9XG5cdHZhciBvbmV2ZW50XG5cdGZ1bmN0aW9uIHNldEV2ZW50Q2FsbGJhY2soY2FsbGJhY2spIHtyZXR1cm4gb25ldmVudCA9IGNhbGxiYWNrfVxuXHRmdW5jdGlvbiBnZXROYW1lU3BhY2Uodm5vZGUpIHtcblx0XHRyZXR1cm4gdm5vZGUuYXR0cnMgJiYgdm5vZGUuYXR0cnMueG1sbnMgfHwgbmFtZVNwYWNlW3Zub2RlLnRhZ11cblx0fVxuXHQvL2NyZWF0ZVxuXHRmdW5jdGlvbiBjcmVhdGVOb2RlcyhwYXJlbnQsIHZub2Rlcywgc3RhcnQsIGVuZCwgaG9va3MsIG5leHRTaWJsaW5nLCBucykge1xuXHRcdGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG5cdFx0XHR2YXIgdm5vZGUgPSB2bm9kZXNbaV1cblx0XHRcdGlmICh2bm9kZSAhPSBudWxsKSB7XG5cdFx0XHRcdGNyZWF0ZU5vZGUocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlTm9kZShwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKSB7XG5cdFx0dmFyIHRhZyA9IHZub2RlLnRhZ1xuXHRcdGlmICh0eXBlb2YgdGFnID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHR2bm9kZS5zdGF0ZSA9IHt9XG5cdFx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCkgaW5pdExpZmVjeWNsZSh2bm9kZS5hdHRycywgdm5vZGUsIGhvb2tzKVxuXHRcdFx0c3dpdGNoICh0YWcpIHtcblx0XHRcdFx0Y2FzZSBcIiNcIjogcmV0dXJuIGNyZWF0ZVRleHQocGFyZW50LCB2bm9kZSwgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdGNhc2UgXCI8XCI6IHJldHVybiBjcmVhdGVIVE1MKHBhcmVudCwgdm5vZGUsIG5leHRTaWJsaW5nKVxuXHRcdFx0XHRjYXNlIFwiW1wiOiByZXR1cm4gY3JlYXRlRnJhZ21lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdFx0ZGVmYXVsdDogcmV0dXJuIGNyZWF0ZUVsZW1lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSByZXR1cm4gY3JlYXRlQ29tcG9uZW50KHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlVGV4dChwYXJlbnQsIHZub2RlLCBuZXh0U2libGluZykge1xuXHRcdHZub2RlLmRvbSA9ICRkb2MuY3JlYXRlVGV4dE5vZGUodm5vZGUuY2hpbGRyZW4pXG5cdFx0aW5zZXJ0Tm9kZShwYXJlbnQsIHZub2RlLmRvbSwgbmV4dFNpYmxpbmcpXG5cdFx0cmV0dXJuIHZub2RlLmRvbVxuXHR9XG5cdGZ1bmN0aW9uIGNyZWF0ZUhUTUwocGFyZW50LCB2bm9kZSwgbmV4dFNpYmxpbmcpIHtcblx0XHR2YXIgbWF0Y2gxID0gdm5vZGUuY2hpbGRyZW4ubWF0Y2goL15cXHMqPzwoXFx3KykvaW0pIHx8IFtdXG5cdFx0dmFyIHBhcmVudDEgPSB7Y2FwdGlvbjogXCJ0YWJsZVwiLCB0aGVhZDogXCJ0YWJsZVwiLCB0Ym9keTogXCJ0YWJsZVwiLCB0Zm9vdDogXCJ0YWJsZVwiLCB0cjogXCJ0Ym9keVwiLCB0aDogXCJ0clwiLCB0ZDogXCJ0clwiLCBjb2xncm91cDogXCJ0YWJsZVwiLCBjb2w6IFwiY29sZ3JvdXBcIn1bbWF0Y2gxWzFdXSB8fCBcImRpdlwiXG5cdFx0dmFyIHRlbXAgPSAkZG9jLmNyZWF0ZUVsZW1lbnQocGFyZW50MSlcblx0XHR0ZW1wLmlubmVySFRNTCA9IHZub2RlLmNoaWxkcmVuXG5cdFx0dm5vZGUuZG9tID0gdGVtcC5maXJzdENoaWxkXG5cdFx0dm5vZGUuZG9tU2l6ZSA9IHRlbXAuY2hpbGROb2Rlcy5sZW5ndGhcblx0XHR2YXIgZnJhZ21lbnQgPSAkZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuXHRcdHZhciBjaGlsZFxuXHRcdHdoaWxlIChjaGlsZCA9IHRlbXAuZmlyc3RDaGlsZCkge1xuXHRcdFx0ZnJhZ21lbnQuYXBwZW5kQ2hpbGQoY2hpbGQpXG5cdFx0fVxuXHRcdGluc2VydE5vZGUocGFyZW50LCBmcmFnbWVudCwgbmV4dFNpYmxpbmcpXG5cdFx0cmV0dXJuIGZyYWdtZW50XG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlRnJhZ21lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZykge1xuXHRcdHZhciBmcmFnbWVudCA9ICRkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG5cdFx0aWYgKHZub2RlLmNoaWxkcmVuICE9IG51bGwpIHtcblx0XHRcdHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuXG5cdFx0XHRjcmVhdGVOb2RlcyhmcmFnbWVudCwgY2hpbGRyZW4sIDAsIGNoaWxkcmVuLmxlbmd0aCwgaG9va3MsIG51bGwsIG5zKVxuXHRcdH1cblx0XHR2bm9kZS5kb20gPSBmcmFnbWVudC5maXJzdENoaWxkXG5cdFx0dm5vZGUuZG9tU2l6ZSA9IGZyYWdtZW50LmNoaWxkTm9kZXMubGVuZ3RoXG5cdFx0aW5zZXJ0Tm9kZShwYXJlbnQsIGZyYWdtZW50LCBuZXh0U2libGluZylcblx0XHRyZXR1cm4gZnJhZ21lbnRcblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVFbGVtZW50KHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpIHtcblx0XHR2YXIgdGFnID0gdm5vZGUudGFnXG5cdFx0dmFyIGF0dHJzMiA9IHZub2RlLmF0dHJzXG5cdFx0dmFyIGlzID0gYXR0cnMyICYmIGF0dHJzMi5pc1xuXHRcdG5zID0gZ2V0TmFtZVNwYWNlKHZub2RlKSB8fCBuc1xuXHRcdHZhciBlbGVtZW50ID0gbnMgP1xuXHRcdFx0aXMgPyAkZG9jLmNyZWF0ZUVsZW1lbnROUyhucywgdGFnLCB7aXM6IGlzfSkgOiAkZG9jLmNyZWF0ZUVsZW1lbnROUyhucywgdGFnKSA6XG5cdFx0XHRpcyA/ICRkb2MuY3JlYXRlRWxlbWVudCh0YWcsIHtpczogaXN9KSA6ICRkb2MuY3JlYXRlRWxlbWVudCh0YWcpXG5cdFx0dm5vZGUuZG9tID0gZWxlbWVudFxuXHRcdGlmIChhdHRyczIgIT0gbnVsbCkge1xuXHRcdFx0c2V0QXR0cnModm5vZGUsIGF0dHJzMiwgbnMpXG5cdFx0fVxuXHRcdGluc2VydE5vZGUocGFyZW50LCBlbGVtZW50LCBuZXh0U2libGluZylcblx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCAmJiB2bm9kZS5hdHRycy5jb250ZW50ZWRpdGFibGUgIT0gbnVsbCkge1xuXHRcdFx0c2V0Q29udGVudEVkaXRhYmxlKHZub2RlKVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGlmICh2bm9kZS50ZXh0ICE9IG51bGwpIHtcblx0XHRcdFx0aWYgKHZub2RlLnRleHQgIT09IFwiXCIpIGVsZW1lbnQudGV4dENvbnRlbnQgPSB2bm9kZS50ZXh0XG5cdFx0XHRcdGVsc2Ugdm5vZGUuY2hpbGRyZW4gPSBbVm5vZGUoXCIjXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB2bm9kZS50ZXh0LCB1bmRlZmluZWQsIHVuZGVmaW5lZCldXG5cdFx0XHR9XG5cdFx0XHRpZiAodm5vZGUuY2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0XHR2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlblxuXHRcdFx0XHRjcmVhdGVOb2RlcyhlbGVtZW50LCBjaGlsZHJlbiwgMCwgY2hpbGRyZW4ubGVuZ3RoLCBob29rcywgbnVsbCwgbnMpXG5cdFx0XHRcdHNldExhdGVBdHRycyh2bm9kZSlcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGVsZW1lbnRcblx0fVxuXHRmdW5jdGlvbiBpbml0Q29tcG9uZW50KHZub2RlLCBob29rcykge1xuXHRcdHZhciBzZW50aW5lbFxuXHRcdGlmICh0eXBlb2Ygdm5vZGUudGFnLnZpZXcgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0dm5vZGUuc3RhdGUgPSBPYmplY3QuY3JlYXRlKHZub2RlLnRhZylcblx0XHRcdHNlbnRpbmVsID0gdm5vZGUuc3RhdGUudmlld1xuXHRcdFx0aWYgKHNlbnRpbmVsLiQkcmVlbnRyYW50TG9jayQkICE9IG51bGwpIHJldHVybiAkZW1wdHlGcmFnbWVudFxuXHRcdFx0c2VudGluZWwuJCRyZWVudHJhbnRMb2NrJCQgPSB0cnVlXG5cdFx0fSBlbHNlIHtcblx0XHRcdHZub2RlLnN0YXRlID0gdm9pZCAwXG5cdFx0XHRzZW50aW5lbCA9IHZub2RlLnRhZ1xuXHRcdFx0aWYgKHNlbnRpbmVsLiQkcmVlbnRyYW50TG9jayQkICE9IG51bGwpIHJldHVybiAkZW1wdHlGcmFnbWVudFxuXHRcdFx0c2VudGluZWwuJCRyZWVudHJhbnRMb2NrJCQgPSB0cnVlXG5cdFx0XHR2bm9kZS5zdGF0ZSA9ICh2bm9kZS50YWcucHJvdG90eXBlICE9IG51bGwgJiYgdHlwZW9mIHZub2RlLnRhZy5wcm90b3R5cGUudmlldyA9PT0gXCJmdW5jdGlvblwiKSA/IG5ldyB2bm9kZS50YWcodm5vZGUpIDogdm5vZGUudGFnKHZub2RlKVxuXHRcdH1cblx0XHR2bm9kZS5fc3RhdGUgPSB2bm9kZS5zdGF0ZVxuXHRcdGlmICh2bm9kZS5hdHRycyAhPSBudWxsKSBpbml0TGlmZWN5Y2xlKHZub2RlLmF0dHJzLCB2bm9kZSwgaG9va3MpXG5cdFx0aW5pdExpZmVjeWNsZSh2bm9kZS5fc3RhdGUsIHZub2RlLCBob29rcylcblx0XHR2bm9kZS5pbnN0YW5jZSA9IFZub2RlLm5vcm1hbGl6ZSh2bm9kZS5fc3RhdGUudmlldy5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSkpXG5cdFx0aWYgKHZub2RlLmluc3RhbmNlID09PSB2bm9kZSkgdGhyb3cgRXJyb3IoXCJBIHZpZXcgY2Fubm90IHJldHVybiB0aGUgdm5vZGUgaXQgcmVjZWl2ZWQgYXMgYXJndW1lbnRcIilcblx0XHRzZW50aW5lbC4kJHJlZW50cmFudExvY2skJCA9IG51bGxcblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVDb21wb25lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZykge1xuXHRcdGluaXRDb21wb25lbnQodm5vZGUsIGhvb2tzKVxuXHRcdGlmICh2bm9kZS5pbnN0YW5jZSAhPSBudWxsKSB7XG5cdFx0XHR2YXIgZWxlbWVudCA9IGNyZWF0ZU5vZGUocGFyZW50LCB2bm9kZS5pbnN0YW5jZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdHZub2RlLmRvbSA9IHZub2RlLmluc3RhbmNlLmRvbVxuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IHZub2RlLmRvbSAhPSBudWxsID8gdm5vZGUuaW5zdGFuY2UuZG9tU2l6ZSA6IDBcblx0XHRcdGluc2VydE5vZGUocGFyZW50LCBlbGVtZW50LCBuZXh0U2libGluZylcblx0XHRcdHJldHVybiBlbGVtZW50XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IDBcblx0XHRcdHJldHVybiAkZW1wdHlGcmFnbWVudFxuXHRcdH1cblx0fVxuXHQvL3VwZGF0ZVxuXHRmdW5jdGlvbiB1cGRhdGVOb2RlcyhwYXJlbnQsIG9sZCwgdm5vZGVzLCByZWN5Y2xpbmcsIGhvb2tzLCBuZXh0U2libGluZywgbnMpIHtcblx0XHRpZiAob2xkID09PSB2bm9kZXMgfHwgb2xkID09IG51bGwgJiYgdm5vZGVzID09IG51bGwpIHJldHVyblxuXHRcdGVsc2UgaWYgKG9sZCA9PSBudWxsKSBjcmVhdGVOb2RlcyhwYXJlbnQsIHZub2RlcywgMCwgdm5vZGVzLmxlbmd0aCwgaG9va3MsIG5leHRTaWJsaW5nLCBucylcblx0XHRlbHNlIGlmICh2bm9kZXMgPT0gbnVsbCkgcmVtb3ZlTm9kZXMob2xkLCAwLCBvbGQubGVuZ3RoLCB2bm9kZXMpXG5cdFx0ZWxzZSB7XG5cdFx0XHRpZiAob2xkLmxlbmd0aCA9PT0gdm5vZGVzLmxlbmd0aCkge1xuXHRcdFx0XHR2YXIgaXNVbmtleWVkID0gZmFsc2Vcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB2bm9kZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRpZiAodm5vZGVzW2ldICE9IG51bGwgJiYgb2xkW2ldICE9IG51bGwpIHtcblx0XHRcdFx0XHRcdGlzVW5rZXllZCA9IHZub2Rlc1tpXS5rZXkgPT0gbnVsbCAmJiBvbGRbaV0ua2V5ID09IG51bGxcblx0XHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChpc1Vua2V5ZWQpIHtcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG9sZC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0aWYgKG9sZFtpXSA9PT0gdm5vZGVzW2ldKSBjb250aW51ZVxuXHRcdFx0XHRcdFx0ZWxzZSBpZiAob2xkW2ldID09IG51bGwgJiYgdm5vZGVzW2ldICE9IG51bGwpIGNyZWF0ZU5vZGUocGFyZW50LCB2bm9kZXNbaV0sIGhvb2tzLCBucywgZ2V0TmV4dFNpYmxpbmcob2xkLCBpICsgMSwgbmV4dFNpYmxpbmcpKVxuXHRcdFx0XHRcdFx0ZWxzZSBpZiAodm5vZGVzW2ldID09IG51bGwpIHJlbW92ZU5vZGVzKG9sZCwgaSwgaSArIDEsIHZub2Rlcylcblx0XHRcdFx0XHRcdGVsc2UgdXBkYXRlTm9kZShwYXJlbnQsIG9sZFtpXSwgdm5vZGVzW2ldLCBob29rcywgZ2V0TmV4dFNpYmxpbmcob2xkLCBpICsgMSwgbmV4dFNpYmxpbmcpLCByZWN5Y2xpbmcsIG5zKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmVjeWNsaW5nID0gcmVjeWNsaW5nIHx8IGlzUmVjeWNsYWJsZShvbGQsIHZub2Rlcylcblx0XHRcdGlmIChyZWN5Y2xpbmcpIHtcblx0XHRcdFx0dmFyIHBvb2wgPSBvbGQucG9vbFxuXHRcdFx0XHRvbGQgPSBvbGQuY29uY2F0KG9sZC5wb29sKVxuXHRcdFx0fVxuXHRcdFx0dmFyIG9sZFN0YXJ0ID0gMCwgc3RhcnQgPSAwLCBvbGRFbmQgPSBvbGQubGVuZ3RoIC0gMSwgZW5kID0gdm5vZGVzLmxlbmd0aCAtIDEsIG1hcFxuXHRcdFx0d2hpbGUgKG9sZEVuZCA+PSBvbGRTdGFydCAmJiBlbmQgPj0gc3RhcnQpIHtcblx0XHRcdFx0dmFyIG8gPSBvbGRbb2xkU3RhcnRdLCB2ID0gdm5vZGVzW3N0YXJ0XVxuXHRcdFx0XHRpZiAobyA9PT0gdiAmJiAhcmVjeWNsaW5nKSBvbGRTdGFydCsrLCBzdGFydCsrXG5cdFx0XHRcdGVsc2UgaWYgKG8gPT0gbnVsbCkgb2xkU3RhcnQrK1xuXHRcdFx0XHRlbHNlIGlmICh2ID09IG51bGwpIHN0YXJ0Kytcblx0XHRcdFx0ZWxzZSBpZiAoby5rZXkgPT09IHYua2V5KSB7XG5cdFx0XHRcdFx0dmFyIHNob3VsZFJlY3ljbGUgPSAocG9vbCAhPSBudWxsICYmIG9sZFN0YXJ0ID49IG9sZC5sZW5ndGggLSBwb29sLmxlbmd0aCkgfHwgKChwb29sID09IG51bGwpICYmIHJlY3ljbGluZylcblx0XHRcdFx0XHRvbGRTdGFydCsrLCBzdGFydCsrXG5cdFx0XHRcdFx0dXBkYXRlTm9kZShwYXJlbnQsIG8sIHYsIGhvb2tzLCBnZXROZXh0U2libGluZyhvbGQsIG9sZFN0YXJ0LCBuZXh0U2libGluZyksIHNob3VsZFJlY3ljbGUsIG5zKVxuXHRcdFx0XHRcdGlmIChyZWN5Y2xpbmcgJiYgby50YWcgPT09IHYudGFnKSBpbnNlcnROb2RlKHBhcmVudCwgdG9GcmFnbWVudChvKSwgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0dmFyIG8gPSBvbGRbb2xkRW5kXVxuXHRcdFx0XHRcdGlmIChvID09PSB2ICYmICFyZWN5Y2xpbmcpIG9sZEVuZC0tLCBzdGFydCsrXG5cdFx0XHRcdFx0ZWxzZSBpZiAobyA9PSBudWxsKSBvbGRFbmQtLVxuXHRcdFx0XHRcdGVsc2UgaWYgKHYgPT0gbnVsbCkgc3RhcnQrK1xuXHRcdFx0XHRcdGVsc2UgaWYgKG8ua2V5ID09PSB2LmtleSkge1xuXHRcdFx0XHRcdFx0dmFyIHNob3VsZFJlY3ljbGUgPSAocG9vbCAhPSBudWxsICYmIG9sZEVuZCA+PSBvbGQubGVuZ3RoIC0gcG9vbC5sZW5ndGgpIHx8ICgocG9vbCA9PSBudWxsKSAmJiByZWN5Y2xpbmcpXG5cdFx0XHRcdFx0XHR1cGRhdGVOb2RlKHBhcmVudCwgbywgdiwgaG9va3MsIGdldE5leHRTaWJsaW5nKG9sZCwgb2xkRW5kICsgMSwgbmV4dFNpYmxpbmcpLCBzaG91bGRSZWN5Y2xlLCBucylcblx0XHRcdFx0XHRcdGlmIChyZWN5Y2xpbmcgfHwgc3RhcnQgPCBlbmQpIGluc2VydE5vZGUocGFyZW50LCB0b0ZyYWdtZW50KG8pLCBnZXROZXh0U2libGluZyhvbGQsIG9sZFN0YXJ0LCBuZXh0U2libGluZykpXG5cdFx0XHRcdFx0XHRvbGRFbmQtLSwgc3RhcnQrK1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIGJyZWFrXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHdoaWxlIChvbGRFbmQgPj0gb2xkU3RhcnQgJiYgZW5kID49IHN0YXJ0KSB7XG5cdFx0XHRcdHZhciBvID0gb2xkW29sZEVuZF0sIHYgPSB2bm9kZXNbZW5kXVxuXHRcdFx0XHRpZiAobyA9PT0gdiAmJiAhcmVjeWNsaW5nKSBvbGRFbmQtLSwgZW5kLS1cblx0XHRcdFx0ZWxzZSBpZiAobyA9PSBudWxsKSBvbGRFbmQtLVxuXHRcdFx0XHRlbHNlIGlmICh2ID09IG51bGwpIGVuZC0tXG5cdFx0XHRcdGVsc2UgaWYgKG8ua2V5ID09PSB2LmtleSkge1xuXHRcdFx0XHRcdHZhciBzaG91bGRSZWN5Y2xlID0gKHBvb2wgIT0gbnVsbCAmJiBvbGRFbmQgPj0gb2xkLmxlbmd0aCAtIHBvb2wubGVuZ3RoKSB8fCAoKHBvb2wgPT0gbnVsbCkgJiYgcmVjeWNsaW5nKVxuXHRcdFx0XHRcdHVwZGF0ZU5vZGUocGFyZW50LCBvLCB2LCBob29rcywgZ2V0TmV4dFNpYmxpbmcob2xkLCBvbGRFbmQgKyAxLCBuZXh0U2libGluZyksIHNob3VsZFJlY3ljbGUsIG5zKVxuXHRcdFx0XHRcdGlmIChyZWN5Y2xpbmcgJiYgby50YWcgPT09IHYudGFnKSBpbnNlcnROb2RlKHBhcmVudCwgdG9GcmFnbWVudChvKSwgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdFx0aWYgKG8uZG9tICE9IG51bGwpIG5leHRTaWJsaW5nID0gby5kb21cblx0XHRcdFx0XHRvbGRFbmQtLSwgZW5kLS1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRpZiAoIW1hcCkgbWFwID0gZ2V0S2V5TWFwKG9sZCwgb2xkRW5kKVxuXHRcdFx0XHRcdGlmICh2ICE9IG51bGwpIHtcblx0XHRcdFx0XHRcdHZhciBvbGRJbmRleCA9IG1hcFt2LmtleV1cblx0XHRcdFx0XHRcdGlmIChvbGRJbmRleCAhPSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBtb3ZhYmxlID0gb2xkW29sZEluZGV4XVxuXHRcdFx0XHRcdFx0XHR2YXIgc2hvdWxkUmVjeWNsZSA9IChwb29sICE9IG51bGwgJiYgb2xkSW5kZXggPj0gb2xkLmxlbmd0aCAtIHBvb2wubGVuZ3RoKSB8fCAoKHBvb2wgPT0gbnVsbCkgJiYgcmVjeWNsaW5nKVxuXHRcdFx0XHRcdFx0XHR1cGRhdGVOb2RlKHBhcmVudCwgbW92YWJsZSwgdiwgaG9va3MsIGdldE5leHRTaWJsaW5nKG9sZCwgb2xkRW5kICsgMSwgbmV4dFNpYmxpbmcpLCByZWN5Y2xpbmcsIG5zKVxuXHRcdFx0XHRcdFx0XHRpbnNlcnROb2RlKHBhcmVudCwgdG9GcmFnbWVudChtb3ZhYmxlKSwgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdFx0XHRcdG9sZFtvbGRJbmRleF0uc2tpcCA9IHRydWVcblx0XHRcdFx0XHRcdFx0aWYgKG1vdmFibGUuZG9tICE9IG51bGwpIG5leHRTaWJsaW5nID0gbW92YWJsZS5kb21cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR2YXIgZG9tID0gY3JlYXRlTm9kZShwYXJlbnQsIHYsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdFx0XHRcdG5leHRTaWJsaW5nID0gZG9tXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVuZC0tXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGVuZCA8IHN0YXJ0KSBicmVha1xuXHRcdFx0fVxuXHRcdFx0Y3JlYXRlTm9kZXMocGFyZW50LCB2bm9kZXMsIHN0YXJ0LCBlbmQgKyAxLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKVxuXHRcdFx0cmVtb3ZlTm9kZXMob2xkLCBvbGRTdGFydCwgb2xkRW5kICsgMSwgdm5vZGVzKVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVOb2RlKHBhcmVudCwgb2xkLCB2bm9kZSwgaG9va3MsIG5leHRTaWJsaW5nLCByZWN5Y2xpbmcsIG5zKSB7XG5cdFx0dmFyIG9sZFRhZyA9IG9sZC50YWcsIHRhZyA9IHZub2RlLnRhZ1xuXHRcdGlmIChvbGRUYWcgPT09IHRhZykge1xuXHRcdFx0dm5vZGUuc3RhdGUgPSBvbGQuc3RhdGVcblx0XHRcdHZub2RlLl9zdGF0ZSA9IG9sZC5fc3RhdGVcblx0XHRcdHZub2RlLmV2ZW50cyA9IG9sZC5ldmVudHNcblx0XHRcdGlmICghcmVjeWNsaW5nICYmIHNob3VsZE5vdFVwZGF0ZSh2bm9kZSwgb2xkKSkgcmV0dXJuXG5cdFx0XHRpZiAodHlwZW9mIG9sZFRhZyA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCkge1xuXHRcdFx0XHRcdGlmIChyZWN5Y2xpbmcpIHtcblx0XHRcdFx0XHRcdHZub2RlLnN0YXRlID0ge31cblx0XHRcdFx0XHRcdGluaXRMaWZlY3ljbGUodm5vZGUuYXR0cnMsIHZub2RlLCBob29rcylcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB1cGRhdGVMaWZlY3ljbGUodm5vZGUuYXR0cnMsIHZub2RlLCBob29rcylcblx0XHRcdFx0fVxuXHRcdFx0XHRzd2l0Y2ggKG9sZFRhZykge1xuXHRcdFx0XHRcdGNhc2UgXCIjXCI6IHVwZGF0ZVRleHQob2xkLCB2bm9kZSk7IGJyZWFrXG5cdFx0XHRcdFx0Y2FzZSBcIjxcIjogdXBkYXRlSFRNTChwYXJlbnQsIG9sZCwgdm5vZGUsIG5leHRTaWJsaW5nKTsgYnJlYWtcblx0XHRcdFx0XHRjYXNlIFwiW1wiOiB1cGRhdGVGcmFnbWVudChwYXJlbnQsIG9sZCwgdm5vZGUsIHJlY3ljbGluZywgaG9va3MsIG5leHRTaWJsaW5nLCBucyk7IGJyZWFrXG5cdFx0XHRcdFx0ZGVmYXVsdDogdXBkYXRlRWxlbWVudChvbGQsIHZub2RlLCByZWN5Y2xpbmcsIGhvb2tzLCBucylcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSB1cGRhdGVDb21wb25lbnQocGFyZW50LCBvbGQsIHZub2RlLCBob29rcywgbmV4dFNpYmxpbmcsIHJlY3ljbGluZywgbnMpXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0cmVtb3ZlTm9kZShvbGQsIG51bGwpXG5cdFx0XHRjcmVhdGVOb2RlKHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZVRleHQob2xkLCB2bm9kZSkge1xuXHRcdGlmIChvbGQuY2hpbGRyZW4udG9TdHJpbmcoKSAhPT0gdm5vZGUuY2hpbGRyZW4udG9TdHJpbmcoKSkge1xuXHRcdFx0b2xkLmRvbS5ub2RlVmFsdWUgPSB2bm9kZS5jaGlsZHJlblxuXHRcdH1cblx0XHR2bm9kZS5kb20gPSBvbGQuZG9tXG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlSFRNTChwYXJlbnQsIG9sZCwgdm5vZGUsIG5leHRTaWJsaW5nKSB7XG5cdFx0aWYgKG9sZC5jaGlsZHJlbiAhPT0gdm5vZGUuY2hpbGRyZW4pIHtcblx0XHRcdHRvRnJhZ21lbnQob2xkKVxuXHRcdFx0Y3JlYXRlSFRNTChwYXJlbnQsIHZub2RlLCBuZXh0U2libGluZylcblx0XHR9XG5cdFx0ZWxzZSB2bm9kZS5kb20gPSBvbGQuZG9tLCB2bm9kZS5kb21TaXplID0gb2xkLmRvbVNpemVcblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVGcmFnbWVudChwYXJlbnQsIG9sZCwgdm5vZGUsIHJlY3ljbGluZywgaG9va3MsIG5leHRTaWJsaW5nLCBucykge1xuXHRcdHVwZGF0ZU5vZGVzKHBhcmVudCwgb2xkLmNoaWxkcmVuLCB2bm9kZS5jaGlsZHJlbiwgcmVjeWNsaW5nLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKVxuXHRcdHZhciBkb21TaXplID0gMCwgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlblxuXHRcdHZub2RlLmRvbSA9IG51bGxcblx0XHRpZiAoY2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgY2hpbGQgPSBjaGlsZHJlbltpXVxuXHRcdFx0XHRpZiAoY2hpbGQgIT0gbnVsbCAmJiBjaGlsZC5kb20gIT0gbnVsbCkge1xuXHRcdFx0XHRcdGlmICh2bm9kZS5kb20gPT0gbnVsbCkgdm5vZGUuZG9tID0gY2hpbGQuZG9tXG5cdFx0XHRcdFx0ZG9tU2l6ZSArPSBjaGlsZC5kb21TaXplIHx8IDFcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGRvbVNpemUgIT09IDEpIHZub2RlLmRvbVNpemUgPSBkb21TaXplXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUVsZW1lbnQob2xkLCB2bm9kZSwgcmVjeWNsaW5nLCBob29rcywgbnMpIHtcblx0XHR2YXIgZWxlbWVudCA9IHZub2RlLmRvbSA9IG9sZC5kb21cblx0XHRucyA9IGdldE5hbWVTcGFjZSh2bm9kZSkgfHwgbnNcblx0XHRpZiAodm5vZGUudGFnID09PSBcInRleHRhcmVhXCIpIHtcblx0XHRcdGlmICh2bm9kZS5hdHRycyA9PSBudWxsKSB2bm9kZS5hdHRycyA9IHt9XG5cdFx0XHRpZiAodm5vZGUudGV4dCAhPSBudWxsKSB7XG5cdFx0XHRcdHZub2RlLmF0dHJzLnZhbHVlID0gdm5vZGUudGV4dCAvL0ZJWE1FIGhhbmRsZTAgbXVsdGlwbGUgY2hpbGRyZW5cblx0XHRcdFx0dm5vZGUudGV4dCA9IHVuZGVmaW5lZFxuXHRcdFx0fVxuXHRcdH1cblx0XHR1cGRhdGVBdHRycyh2bm9kZSwgb2xkLmF0dHJzLCB2bm9kZS5hdHRycywgbnMpXG5cdFx0aWYgKHZub2RlLmF0dHJzICE9IG51bGwgJiYgdm5vZGUuYXR0cnMuY29udGVudGVkaXRhYmxlICE9IG51bGwpIHtcblx0XHRcdHNldENvbnRlbnRFZGl0YWJsZSh2bm9kZSlcblx0XHR9XG5cdFx0ZWxzZSBpZiAob2xkLnRleHQgIT0gbnVsbCAmJiB2bm9kZS50ZXh0ICE9IG51bGwgJiYgdm5vZGUudGV4dCAhPT0gXCJcIikge1xuXHRcdFx0aWYgKG9sZC50ZXh0LnRvU3RyaW5nKCkgIT09IHZub2RlLnRleHQudG9TdHJpbmcoKSkgb2xkLmRvbS5maXJzdENoaWxkLm5vZGVWYWx1ZSA9IHZub2RlLnRleHRcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRpZiAob2xkLnRleHQgIT0gbnVsbCkgb2xkLmNoaWxkcmVuID0gW1Zub2RlKFwiI1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgb2xkLnRleHQsIHVuZGVmaW5lZCwgb2xkLmRvbS5maXJzdENoaWxkKV1cblx0XHRcdGlmICh2bm9kZS50ZXh0ICE9IG51bGwpIHZub2RlLmNoaWxkcmVuID0gW1Zub2RlKFwiI1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdm5vZGUudGV4dCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXVxuXHRcdFx0dXBkYXRlTm9kZXMoZWxlbWVudCwgb2xkLmNoaWxkcmVuLCB2bm9kZS5jaGlsZHJlbiwgcmVjeWNsaW5nLCBob29rcywgbnVsbCwgbnMpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUNvbXBvbmVudChwYXJlbnQsIG9sZCwgdm5vZGUsIGhvb2tzLCBuZXh0U2libGluZywgcmVjeWNsaW5nLCBucykge1xuXHRcdGlmIChyZWN5Y2xpbmcpIHtcblx0XHRcdGluaXRDb21wb25lbnQodm5vZGUsIGhvb2tzKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2bm9kZS5pbnN0YW5jZSA9IFZub2RlLm5vcm1hbGl6ZSh2bm9kZS5fc3RhdGUudmlldy5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSkpXG5cdFx0XHRpZiAodm5vZGUuaW5zdGFuY2UgPT09IHZub2RlKSB0aHJvdyBFcnJvcihcIkEgdmlldyBjYW5ub3QgcmV0dXJuIHRoZSB2bm9kZSBpdCByZWNlaXZlZCBhcyBhcmd1bWVudFwiKVxuXHRcdFx0aWYgKHZub2RlLmF0dHJzICE9IG51bGwpIHVwZGF0ZUxpZmVjeWNsZSh2bm9kZS5hdHRycywgdm5vZGUsIGhvb2tzKVxuXHRcdFx0dXBkYXRlTGlmZWN5Y2xlKHZub2RlLl9zdGF0ZSwgdm5vZGUsIGhvb2tzKVxuXHRcdH1cblx0XHRpZiAodm5vZGUuaW5zdGFuY2UgIT0gbnVsbCkge1xuXHRcdFx0aWYgKG9sZC5pbnN0YW5jZSA9PSBudWxsKSBjcmVhdGVOb2RlKHBhcmVudCwgdm5vZGUuaW5zdGFuY2UsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0XHRlbHNlIHVwZGF0ZU5vZGUocGFyZW50LCBvbGQuaW5zdGFuY2UsIHZub2RlLmluc3RhbmNlLCBob29rcywgbmV4dFNpYmxpbmcsIHJlY3ljbGluZywgbnMpXG5cdFx0XHR2bm9kZS5kb20gPSB2bm9kZS5pbnN0YW5jZS5kb21cblx0XHRcdHZub2RlLmRvbVNpemUgPSB2bm9kZS5pbnN0YW5jZS5kb21TaXplXG5cdFx0fVxuXHRcdGVsc2UgaWYgKG9sZC5pbnN0YW5jZSAhPSBudWxsKSB7XG5cdFx0XHRyZW1vdmVOb2RlKG9sZC5pbnN0YW5jZSwgbnVsbClcblx0XHRcdHZub2RlLmRvbSA9IHVuZGVmaW5lZFxuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IDBcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHR2bm9kZS5kb20gPSBvbGQuZG9tXG5cdFx0XHR2bm9kZS5kb21TaXplID0gb2xkLmRvbVNpemVcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gaXNSZWN5Y2xhYmxlKG9sZCwgdm5vZGVzKSB7XG5cdFx0aWYgKG9sZC5wb29sICE9IG51bGwgJiYgTWF0aC5hYnMob2xkLnBvb2wubGVuZ3RoIC0gdm5vZGVzLmxlbmd0aCkgPD0gTWF0aC5hYnMob2xkLmxlbmd0aCAtIHZub2Rlcy5sZW5ndGgpKSB7XG5cdFx0XHR2YXIgb2xkQ2hpbGRyZW5MZW5ndGggPSBvbGRbMF0gJiYgb2xkWzBdLmNoaWxkcmVuICYmIG9sZFswXS5jaGlsZHJlbi5sZW5ndGggfHwgMFxuXHRcdFx0dmFyIHBvb2xDaGlsZHJlbkxlbmd0aCA9IG9sZC5wb29sWzBdICYmIG9sZC5wb29sWzBdLmNoaWxkcmVuICYmIG9sZC5wb29sWzBdLmNoaWxkcmVuLmxlbmd0aCB8fCAwXG5cdFx0XHR2YXIgdm5vZGVzQ2hpbGRyZW5MZW5ndGggPSB2bm9kZXNbMF0gJiYgdm5vZGVzWzBdLmNoaWxkcmVuICYmIHZub2Rlc1swXS5jaGlsZHJlbi5sZW5ndGggfHwgMFxuXHRcdFx0aWYgKE1hdGguYWJzKHBvb2xDaGlsZHJlbkxlbmd0aCAtIHZub2Rlc0NoaWxkcmVuTGVuZ3RoKSA8PSBNYXRoLmFicyhvbGRDaGlsZHJlbkxlbmd0aCAtIHZub2Rlc0NoaWxkcmVuTGVuZ3RoKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2Vcblx0fVxuXHRmdW5jdGlvbiBnZXRLZXlNYXAodm5vZGVzLCBlbmQpIHtcblx0XHR2YXIgbWFwID0ge30sIGkgPSAwXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBlbmQ7IGkrKykge1xuXHRcdFx0dmFyIHZub2RlID0gdm5vZGVzW2ldXG5cdFx0XHRpZiAodm5vZGUgIT0gbnVsbCkge1xuXHRcdFx0XHR2YXIga2V5MiA9IHZub2RlLmtleVxuXHRcdFx0XHRpZiAoa2V5MiAhPSBudWxsKSBtYXBba2V5Ml0gPSBpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBtYXBcblx0fVxuXHRmdW5jdGlvbiB0b0ZyYWdtZW50KHZub2RlKSB7XG5cdFx0dmFyIGNvdW50MCA9IHZub2RlLmRvbVNpemVcblx0XHRpZiAoY291bnQwICE9IG51bGwgfHwgdm5vZGUuZG9tID09IG51bGwpIHtcblx0XHRcdHZhciBmcmFnbWVudCA9ICRkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG5cdFx0XHRpZiAoY291bnQwID4gMCkge1xuXHRcdFx0XHR2YXIgZG9tID0gdm5vZGUuZG9tXG5cdFx0XHRcdHdoaWxlICgtLWNvdW50MCkgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZG9tLm5leHRTaWJsaW5nKVxuXHRcdFx0XHRmcmFnbWVudC5pbnNlcnRCZWZvcmUoZG9tLCBmcmFnbWVudC5maXJzdENoaWxkKVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZyYWdtZW50XG5cdFx0fVxuXHRcdGVsc2UgcmV0dXJuIHZub2RlLmRvbVxuXHR9XG5cdGZ1bmN0aW9uIGdldE5leHRTaWJsaW5nKHZub2RlcywgaSwgbmV4dFNpYmxpbmcpIHtcblx0XHRmb3IgKDsgaSA8IHZub2Rlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKHZub2Rlc1tpXSAhPSBudWxsICYmIHZub2Rlc1tpXS5kb20gIT0gbnVsbCkgcmV0dXJuIHZub2Rlc1tpXS5kb21cblx0XHR9XG5cdFx0cmV0dXJuIG5leHRTaWJsaW5nXG5cdH1cblx0ZnVuY3Rpb24gaW5zZXJ0Tm9kZShwYXJlbnQsIGRvbSwgbmV4dFNpYmxpbmcpIHtcblx0XHRpZiAobmV4dFNpYmxpbmcgJiYgbmV4dFNpYmxpbmcucGFyZW50Tm9kZSkgcGFyZW50Lmluc2VydEJlZm9yZShkb20sIG5leHRTaWJsaW5nKVxuXHRcdGVsc2UgcGFyZW50LmFwcGVuZENoaWxkKGRvbSlcblx0fVxuXHRmdW5jdGlvbiBzZXRDb250ZW50RWRpdGFibGUodm5vZGUpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlblxuXHRcdGlmIChjaGlsZHJlbiAhPSBudWxsICYmIGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBjaGlsZHJlblswXS50YWcgPT09IFwiPFwiKSB7XG5cdFx0XHR2YXIgY29udGVudCA9IGNoaWxkcmVuWzBdLmNoaWxkcmVuXG5cdFx0XHRpZiAodm5vZGUuZG9tLmlubmVySFRNTCAhPT0gY29udGVudCkgdm5vZGUuZG9tLmlubmVySFRNTCA9IGNvbnRlbnRcblx0XHR9XG5cdFx0ZWxzZSBpZiAodm5vZGUudGV4dCAhPSBudWxsIHx8IGNoaWxkcmVuICE9IG51bGwgJiYgY2hpbGRyZW4ubGVuZ3RoICE9PSAwKSB0aHJvdyBuZXcgRXJyb3IoXCJDaGlsZCBub2RlIG9mIGEgY29udGVudGVkaXRhYmxlIG11c3QgYmUgdHJ1c3RlZFwiKVxuXHR9XG5cdC8vcmVtb3ZlXG5cdGZ1bmN0aW9uIHJlbW92ZU5vZGVzKHZub2Rlcywgc3RhcnQsIGVuZCwgY29udGV4dCkge1xuXHRcdGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG5cdFx0XHR2YXIgdm5vZGUgPSB2bm9kZXNbaV1cblx0XHRcdGlmICh2bm9kZSAhPSBudWxsKSB7XG5cdFx0XHRcdGlmICh2bm9kZS5za2lwKSB2bm9kZS5za2lwID0gZmFsc2Vcblx0XHRcdFx0ZWxzZSByZW1vdmVOb2RlKHZub2RlLCBjb250ZXh0KVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiByZW1vdmVOb2RlKHZub2RlLCBjb250ZXh0KSB7XG5cdFx0dmFyIGV4cGVjdGVkID0gMSwgY2FsbGVkID0gMFxuXHRcdGlmICh2bm9kZS5hdHRycyAmJiB0eXBlb2Ygdm5vZGUuYXR0cnMub25iZWZvcmVyZW1vdmUgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0dmFyIHJlc3VsdCA9IHZub2RlLmF0dHJzLm9uYmVmb3JlcmVtb3ZlLmNhbGwodm5vZGUuc3RhdGUsIHZub2RlKVxuXHRcdFx0aWYgKHJlc3VsdCAhPSBudWxsICYmIHR5cGVvZiByZXN1bHQudGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdGV4cGVjdGVkKytcblx0XHRcdFx0cmVzdWx0LnRoZW4oY29udGludWF0aW9uLCBjb250aW51YXRpb24pXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICh0eXBlb2Ygdm5vZGUudGFnICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiB2bm9kZS5fc3RhdGUub25iZWZvcmVyZW1vdmUgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0dmFyIHJlc3VsdCA9IHZub2RlLl9zdGF0ZS5vbmJlZm9yZXJlbW92ZS5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSlcblx0XHRcdGlmIChyZXN1bHQgIT0gbnVsbCAmJiB0eXBlb2YgcmVzdWx0LnRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRleHBlY3RlZCsrXG5cdFx0XHRcdHJlc3VsdC50aGVuKGNvbnRpbnVhdGlvbiwgY29udGludWF0aW9uKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRjb250aW51YXRpb24oKVxuXHRcdGZ1bmN0aW9uIGNvbnRpbnVhdGlvbigpIHtcblx0XHRcdGlmICgrK2NhbGxlZCA9PT0gZXhwZWN0ZWQpIHtcblx0XHRcdFx0b25yZW1vdmUodm5vZGUpXG5cdFx0XHRcdGlmICh2bm9kZS5kb20pIHtcblx0XHRcdFx0XHR2YXIgY291bnQwID0gdm5vZGUuZG9tU2l6ZSB8fCAxXG5cdFx0XHRcdFx0aWYgKGNvdW50MCA+IDEpIHtcblx0XHRcdFx0XHRcdHZhciBkb20gPSB2bm9kZS5kb21cblx0XHRcdFx0XHRcdHdoaWxlICgtLWNvdW50MCkge1xuXHRcdFx0XHRcdFx0XHRyZW1vdmVOb2RlRnJvbURPTShkb20ubmV4dFNpYmxpbmcpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJlbW92ZU5vZGVGcm9tRE9NKHZub2RlLmRvbSlcblx0XHRcdFx0XHRpZiAoY29udGV4dCAhPSBudWxsICYmIHZub2RlLmRvbVNpemUgPT0gbnVsbCAmJiAhaGFzSW50ZWdyYXRpb25NZXRob2RzKHZub2RlLmF0dHJzKSAmJiB0eXBlb2Ygdm5vZGUudGFnID09PSBcInN0cmluZ1wiKSB7IC8vVE9ETyB0ZXN0IGN1c3RvbSBlbGVtZW50c1xuXHRcdFx0XHRcdFx0aWYgKCFjb250ZXh0LnBvb2wpIGNvbnRleHQucG9vbCA9IFt2bm9kZV1cblx0XHRcdFx0XHRcdGVsc2UgY29udGV4dC5wb29sLnB1c2godm5vZGUpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHJlbW92ZU5vZGVGcm9tRE9NKG5vZGUpIHtcblx0XHR2YXIgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlXG5cdFx0aWYgKHBhcmVudCAhPSBudWxsKSBwYXJlbnQucmVtb3ZlQ2hpbGQobm9kZSlcblx0fVxuXHRmdW5jdGlvbiBvbnJlbW92ZSh2bm9kZSkge1xuXHRcdGlmICh2bm9kZS5hdHRycyAmJiB0eXBlb2Ygdm5vZGUuYXR0cnMub25yZW1vdmUgPT09IFwiZnVuY3Rpb25cIikgdm5vZGUuYXR0cnMub25yZW1vdmUuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpXG5cdFx0aWYgKHR5cGVvZiB2bm9kZS50YWcgIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHZub2RlLl9zdGF0ZS5vbnJlbW92ZSA9PT0gXCJmdW5jdGlvblwiKSB2bm9kZS5fc3RhdGUub25yZW1vdmUuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpXG5cdFx0aWYgKHZub2RlLmluc3RhbmNlICE9IG51bGwpIG9ucmVtb3ZlKHZub2RlLmluc3RhbmNlKVxuXHRcdGVsc2Uge1xuXHRcdFx0dmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW5cblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0dmFyIGNoaWxkID0gY2hpbGRyZW5baV1cblx0XHRcdFx0XHRpZiAoY2hpbGQgIT0gbnVsbCkgb25yZW1vdmUoY2hpbGQpXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0Ly9hdHRyczJcblx0ZnVuY3Rpb24gc2V0QXR0cnModm5vZGUsIGF0dHJzMiwgbnMpIHtcblx0XHRmb3IgKHZhciBrZXkyIGluIGF0dHJzMikge1xuXHRcdFx0c2V0QXR0cih2bm9kZSwga2V5MiwgbnVsbCwgYXR0cnMyW2tleTJdLCBucylcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gc2V0QXR0cih2bm9kZSwga2V5Miwgb2xkLCB2YWx1ZSwgbnMpIHtcblx0XHR2YXIgZWxlbWVudCA9IHZub2RlLmRvbVxuXHRcdGlmIChrZXkyID09PSBcImtleVwiIHx8IGtleTIgPT09IFwiaXNcIiB8fCAob2xkID09PSB2YWx1ZSAmJiAhaXNGb3JtQXR0cmlidXRlKHZub2RlLCBrZXkyKSkgJiYgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIiB8fCBpc0xpZmVjeWNsZU1ldGhvZChrZXkyKSkgcmV0dXJuXG5cdFx0dmFyIG5zTGFzdEluZGV4ID0ga2V5Mi5pbmRleE9mKFwiOlwiKVxuXHRcdGlmIChuc0xhc3RJbmRleCA+IC0xICYmIGtleTIuc3Vic3RyKDAsIG5zTGFzdEluZGV4KSA9PT0gXCJ4bGlua1wiKSB7XG5cdFx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZU5TKFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLCBrZXkyLnNsaWNlKG5zTGFzdEluZGV4ICsgMSksIHZhbHVlKVxuXHRcdH1cblx0XHRlbHNlIGlmIChrZXkyWzBdID09PSBcIm9cIiAmJiBrZXkyWzFdID09PSBcIm5cIiAmJiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikgdXBkYXRlRXZlbnQodm5vZGUsIGtleTIsIHZhbHVlKVxuXHRcdGVsc2UgaWYgKGtleTIgPT09IFwic3R5bGVcIikgdXBkYXRlU3R5bGUoZWxlbWVudCwgb2xkLCB2YWx1ZSlcblx0XHRlbHNlIGlmIChrZXkyIGluIGVsZW1lbnQgJiYgIWlzQXR0cmlidXRlKGtleTIpICYmIG5zID09PSB1bmRlZmluZWQgJiYgIWlzQ3VzdG9tRWxlbWVudCh2bm9kZSkpIHtcblx0XHRcdGlmIChrZXkyID09PSBcInZhbHVlXCIpIHtcblx0XHRcdFx0dmFyIG5vcm1hbGl6ZWQwID0gXCJcIiArIHZhbHVlIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8taW1wbGljaXQtY29lcmNpb25cblx0XHRcdFx0Ly9zZXR0aW5nIGlucHV0W3ZhbHVlXSB0byBzYW1lIHZhbHVlIGJ5IHR5cGluZyBvbiBmb2N1c2VkIGVsZW1lbnQgbW92ZXMgY3Vyc29yIHRvIGVuZCBpbiBDaHJvbWVcblx0XHRcdFx0aWYgKCh2bm9kZS50YWcgPT09IFwiaW5wdXRcIiB8fCB2bm9kZS50YWcgPT09IFwidGV4dGFyZWFcIikgJiYgdm5vZGUuZG9tLnZhbHVlID09PSBub3JtYWxpemVkMCAmJiB2bm9kZS5kb20gPT09ICRkb2MuYWN0aXZlRWxlbWVudCkgcmV0dXJuXG5cdFx0XHRcdC8vc2V0dGluZyBzZWxlY3RbdmFsdWVdIHRvIHNhbWUgdmFsdWUgd2hpbGUgaGF2aW5nIHNlbGVjdCBvcGVuIGJsaW5rcyBzZWxlY3QgZHJvcGRvd24gaW4gQ2hyb21lXG5cdFx0XHRcdGlmICh2bm9kZS50YWcgPT09IFwic2VsZWN0XCIpIHtcblx0XHRcdFx0XHRpZiAodmFsdWUgPT09IG51bGwpIHtcblx0XHRcdFx0XHRcdGlmICh2bm9kZS5kb20uc2VsZWN0ZWRJbmRleCA9PT0gLTEgJiYgdm5vZGUuZG9tID09PSAkZG9jLmFjdGl2ZUVsZW1lbnQpIHJldHVyblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpZiAob2xkICE9PSBudWxsICYmIHZub2RlLmRvbS52YWx1ZSA9PT0gbm9ybWFsaXplZDAgJiYgdm5vZGUuZG9tID09PSAkZG9jLmFjdGl2ZUVsZW1lbnQpIHJldHVyblxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHQvL3NldHRpbmcgb3B0aW9uW3ZhbHVlXSB0byBzYW1lIHZhbHVlIHdoaWxlIGhhdmluZyBzZWxlY3Qgb3BlbiBibGlua3Mgc2VsZWN0IGRyb3Bkb3duIGluIENocm9tZVxuXHRcdFx0XHRpZiAodm5vZGUudGFnID09PSBcIm9wdGlvblwiICYmIG9sZCAhPSBudWxsICYmIHZub2RlLmRvbS52YWx1ZSA9PT0gbm9ybWFsaXplZDApIHJldHVyblxuXHRcdFx0fVxuXHRcdFx0Ly8gSWYgeW91IGFzc2lnbiBhbiBpbnB1dCB0eXBlMSB0aGF0IGlzIG5vdCBzdXBwb3J0ZWQgYnkgSUUgMTEgd2l0aCBhbiBhc3NpZ25tZW50IGV4cHJlc3Npb24sIGFuIGVycm9yMCB3aWxsIG9jY3VyLlxuXHRcdFx0aWYgKHZub2RlLnRhZyA9PT0gXCJpbnB1dFwiICYmIGtleTIgPT09IFwidHlwZVwiKSB7XG5cdFx0XHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleTIsIHZhbHVlKVxuXHRcdFx0XHRyZXR1cm5cblx0XHRcdH1cblx0XHRcdGVsZW1lbnRba2V5Ml0gPSB2YWx1ZVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiKSB7XG5cdFx0XHRcdGlmICh2YWx1ZSkgZWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5MiwgXCJcIilcblx0XHRcdFx0ZWxzZSBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShrZXkyKVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSBlbGVtZW50LnNldEF0dHJpYnV0ZShrZXkyID09PSBcImNsYXNzTmFtZVwiID8gXCJjbGFzc1wiIDoga2V5MiwgdmFsdWUpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHNldExhdGVBdHRycyh2bm9kZSkge1xuXHRcdHZhciBhdHRyczIgPSB2bm9kZS5hdHRyc1xuXHRcdGlmICh2bm9kZS50YWcgPT09IFwic2VsZWN0XCIgJiYgYXR0cnMyICE9IG51bGwpIHtcblx0XHRcdGlmIChcInZhbHVlXCIgaW4gYXR0cnMyKSBzZXRBdHRyKHZub2RlLCBcInZhbHVlXCIsIG51bGwsIGF0dHJzMi52YWx1ZSwgdW5kZWZpbmVkKVxuXHRcdFx0aWYgKFwic2VsZWN0ZWRJbmRleFwiIGluIGF0dHJzMikgc2V0QXR0cih2bm9kZSwgXCJzZWxlY3RlZEluZGV4XCIsIG51bGwsIGF0dHJzMi5zZWxlY3RlZEluZGV4LCB1bmRlZmluZWQpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUF0dHJzKHZub2RlLCBvbGQsIGF0dHJzMiwgbnMpIHtcblx0XHRpZiAoYXR0cnMyICE9IG51bGwpIHtcblx0XHRcdGZvciAodmFyIGtleTIgaW4gYXR0cnMyKSB7XG5cdFx0XHRcdHNldEF0dHIodm5vZGUsIGtleTIsIG9sZCAmJiBvbGRba2V5Ml0sIGF0dHJzMltrZXkyXSwgbnMpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChvbGQgIT0gbnVsbCkge1xuXHRcdFx0Zm9yICh2YXIga2V5MiBpbiBvbGQpIHtcblx0XHRcdFx0aWYgKGF0dHJzMiA9PSBudWxsIHx8ICEoa2V5MiBpbiBhdHRyczIpKSB7XG5cdFx0XHRcdFx0aWYgKGtleTIgPT09IFwiY2xhc3NOYW1lXCIpIGtleTIgPSBcImNsYXNzXCJcblx0XHRcdFx0XHRpZiAoa2V5MlswXSA9PT0gXCJvXCIgJiYga2V5MlsxXSA9PT0gXCJuXCIgJiYgIWlzTGlmZWN5Y2xlTWV0aG9kKGtleTIpKSB1cGRhdGVFdmVudCh2bm9kZSwga2V5MiwgdW5kZWZpbmVkKVxuXHRcdFx0XHRcdGVsc2UgaWYgKGtleTIgIT09IFwia2V5XCIpIHZub2RlLmRvbS5yZW1vdmVBdHRyaWJ1dGUoa2V5Milcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBpc0Zvcm1BdHRyaWJ1dGUodm5vZGUsIGF0dHIpIHtcblx0XHRyZXR1cm4gYXR0ciA9PT0gXCJ2YWx1ZVwiIHx8IGF0dHIgPT09IFwiY2hlY2tlZFwiIHx8IGF0dHIgPT09IFwic2VsZWN0ZWRJbmRleFwiIHx8IGF0dHIgPT09IFwic2VsZWN0ZWRcIiAmJiB2bm9kZS5kb20gPT09ICRkb2MuYWN0aXZlRWxlbWVudFxuXHR9XG5cdGZ1bmN0aW9uIGlzTGlmZWN5Y2xlTWV0aG9kKGF0dHIpIHtcblx0XHRyZXR1cm4gYXR0ciA9PT0gXCJvbmluaXRcIiB8fCBhdHRyID09PSBcIm9uY3JlYXRlXCIgfHwgYXR0ciA9PT0gXCJvbnVwZGF0ZVwiIHx8IGF0dHIgPT09IFwib25yZW1vdmVcIiB8fCBhdHRyID09PSBcIm9uYmVmb3JlcmVtb3ZlXCIgfHwgYXR0ciA9PT0gXCJvbmJlZm9yZXVwZGF0ZVwiXG5cdH1cblx0ZnVuY3Rpb24gaXNBdHRyaWJ1dGUoYXR0cikge1xuXHRcdHJldHVybiBhdHRyID09PSBcImhyZWZcIiB8fCBhdHRyID09PSBcImxpc3RcIiB8fCBhdHRyID09PSBcImZvcm1cIiB8fCBhdHRyID09PSBcIndpZHRoXCIgfHwgYXR0ciA9PT0gXCJoZWlnaHRcIi8vIHx8IGF0dHIgPT09IFwidHlwZVwiXG5cdH1cblx0ZnVuY3Rpb24gaXNDdXN0b21FbGVtZW50KHZub2RlKXtcblx0XHRyZXR1cm4gdm5vZGUuYXR0cnMuaXMgfHwgdm5vZGUudGFnLmluZGV4T2YoXCItXCIpID4gLTFcblx0fVxuXHRmdW5jdGlvbiBoYXNJbnRlZ3JhdGlvbk1ldGhvZHMoc291cmNlKSB7XG5cdFx0cmV0dXJuIHNvdXJjZSAhPSBudWxsICYmIChzb3VyY2Uub25jcmVhdGUgfHwgc291cmNlLm9udXBkYXRlIHx8IHNvdXJjZS5vbmJlZm9yZXJlbW92ZSB8fCBzb3VyY2Uub25yZW1vdmUpXG5cdH1cblx0Ly9zdHlsZVxuXHRmdW5jdGlvbiB1cGRhdGVTdHlsZShlbGVtZW50LCBvbGQsIHN0eWxlKSB7XG5cdFx0aWYgKG9sZCA9PT0gc3R5bGUpIGVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IFwiXCIsIG9sZCA9IG51bGxcblx0XHRpZiAoc3R5bGUgPT0gbnVsbCkgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gXCJcIlxuXHRcdGVsc2UgaWYgKHR5cGVvZiBzdHlsZSA9PT0gXCJzdHJpbmdcIikgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gc3R5bGVcblx0XHRlbHNlIHtcblx0XHRcdGlmICh0eXBlb2Ygb2xkID09PSBcInN0cmluZ1wiKSBlbGVtZW50LnN0eWxlLmNzc1RleHQgPSBcIlwiXG5cdFx0XHRmb3IgKHZhciBrZXkyIGluIHN0eWxlKSB7XG5cdFx0XHRcdGVsZW1lbnQuc3R5bGVba2V5Ml0gPSBzdHlsZVtrZXkyXVxuXHRcdFx0fVxuXHRcdFx0aWYgKG9sZCAhPSBudWxsICYmIHR5cGVvZiBvbGQgIT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0Zm9yICh2YXIga2V5MiBpbiBvbGQpIHtcblx0XHRcdFx0XHRpZiAoIShrZXkyIGluIHN0eWxlKSkgZWxlbWVudC5zdHlsZVtrZXkyXSA9IFwiXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHQvL2V2ZW50XG5cdGZ1bmN0aW9uIHVwZGF0ZUV2ZW50KHZub2RlLCBrZXkyLCB2YWx1ZSkge1xuXHRcdHZhciBlbGVtZW50ID0gdm5vZGUuZG9tXG5cdFx0dmFyIGNhbGxiYWNrID0gdHlwZW9mIG9uZXZlbnQgIT09IFwiZnVuY3Rpb25cIiA/IHZhbHVlIDogZnVuY3Rpb24oZSkge1xuXHRcdFx0dmFyIHJlc3VsdCA9IHZhbHVlLmNhbGwoZWxlbWVudCwgZSlcblx0XHRcdG9uZXZlbnQuY2FsbChlbGVtZW50LCBlKVxuXHRcdFx0cmV0dXJuIHJlc3VsdFxuXHRcdH1cblx0XHRpZiAoa2V5MiBpbiBlbGVtZW50KSBlbGVtZW50W2tleTJdID0gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBjYWxsYmFjayA6IG51bGxcblx0XHRlbHNlIHtcblx0XHRcdHZhciBldmVudE5hbWUgPSBrZXkyLnNsaWNlKDIpXG5cdFx0XHRpZiAodm5vZGUuZXZlbnRzID09PSB1bmRlZmluZWQpIHZub2RlLmV2ZW50cyA9IHt9XG5cdFx0XHRpZiAodm5vZGUuZXZlbnRzW2tleTJdID09PSBjYWxsYmFjaykgcmV0dXJuXG5cdFx0XHRpZiAodm5vZGUuZXZlbnRzW2tleTJdICE9IG51bGwpIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIHZub2RlLmV2ZW50c1trZXkyXSwgZmFsc2UpXG5cdFx0XHRpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0dm5vZGUuZXZlbnRzW2tleTJdID0gY2FsbGJhY2tcblx0XHRcdFx0ZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgdm5vZGUuZXZlbnRzW2tleTJdLCBmYWxzZSlcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0Ly9saWZlY3ljbGVcblx0ZnVuY3Rpb24gaW5pdExpZmVjeWNsZShzb3VyY2UsIHZub2RlLCBob29rcykge1xuXHRcdGlmICh0eXBlb2Ygc291cmNlLm9uaW5pdCA9PT0gXCJmdW5jdGlvblwiKSBzb3VyY2Uub25pbml0LmNhbGwodm5vZGUuc3RhdGUsIHZub2RlKVxuXHRcdGlmICh0eXBlb2Ygc291cmNlLm9uY3JlYXRlID09PSBcImZ1bmN0aW9uXCIpIGhvb2tzLnB1c2goc291cmNlLm9uY3JlYXRlLmJpbmQodm5vZGUuc3RhdGUsIHZub2RlKSlcblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVMaWZlY3ljbGUoc291cmNlLCB2bm9kZSwgaG9va3MpIHtcblx0XHRpZiAodHlwZW9mIHNvdXJjZS5vbnVwZGF0ZSA9PT0gXCJmdW5jdGlvblwiKSBob29rcy5wdXNoKHNvdXJjZS5vbnVwZGF0ZS5iaW5kKHZub2RlLnN0YXRlLCB2bm9kZSkpXG5cdH1cblx0ZnVuY3Rpb24gc2hvdWxkTm90VXBkYXRlKHZub2RlLCBvbGQpIHtcblx0XHR2YXIgZm9yY2VWbm9kZVVwZGF0ZSwgZm9yY2VDb21wb25lbnRVcGRhdGVcblx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCAmJiB0eXBlb2Ygdm5vZGUuYXR0cnMub25iZWZvcmV1cGRhdGUgPT09IFwiZnVuY3Rpb25cIikgZm9yY2VWbm9kZVVwZGF0ZSA9IHZub2RlLmF0dHJzLm9uYmVmb3JldXBkYXRlLmNhbGwodm5vZGUuc3RhdGUsIHZub2RlLCBvbGQpXG5cdFx0aWYgKHR5cGVvZiB2bm9kZS50YWcgIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHZub2RlLl9zdGF0ZS5vbmJlZm9yZXVwZGF0ZSA9PT0gXCJmdW5jdGlvblwiKSBmb3JjZUNvbXBvbmVudFVwZGF0ZSA9IHZub2RlLl9zdGF0ZS5vbmJlZm9yZXVwZGF0ZS5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSwgb2xkKVxuXHRcdGlmICghKGZvcmNlVm5vZGVVcGRhdGUgPT09IHVuZGVmaW5lZCAmJiBmb3JjZUNvbXBvbmVudFVwZGF0ZSA9PT0gdW5kZWZpbmVkKSAmJiAhZm9yY2VWbm9kZVVwZGF0ZSAmJiAhZm9yY2VDb21wb25lbnRVcGRhdGUpIHtcblx0XHRcdHZub2RlLmRvbSA9IG9sZC5kb21cblx0XHRcdHZub2RlLmRvbVNpemUgPSBvbGQuZG9tU2l6ZVxuXHRcdFx0dm5vZGUuaW5zdGFuY2UgPSBvbGQuaW5zdGFuY2Vcblx0XHRcdHJldHVybiB0cnVlXG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZVxuXHR9XG5cdGZ1bmN0aW9uIHJlbmRlcihkb20sIHZub2Rlcykge1xuXHRcdGlmICghZG9tKSB0aHJvdyBuZXcgRXJyb3IoXCJFbnN1cmUgdGhlIERPTSBlbGVtZW50IGJlaW5nIHBhc3NlZCB0byBtLnJvdXRlL20ubW91bnQvbS5yZW5kZXIgaXMgbm90IHVuZGVmaW5lZC5cIilcblx0XHR2YXIgaG9va3MgPSBbXVxuXHRcdHZhciBhY3RpdmUgPSAkZG9jLmFjdGl2ZUVsZW1lbnRcblx0XHR2YXIgbmFtZXNwYWNlID0gZG9tLm5hbWVzcGFjZVVSSVxuXHRcdC8vIEZpcnN0IHRpbWUwIHJlbmRlcmluZyBpbnRvIGEgbm9kZSBjbGVhcnMgaXQgb3V0XG5cdFx0aWYgKGRvbS52bm9kZXMgPT0gbnVsbCkgZG9tLnRleHRDb250ZW50ID0gXCJcIlxuXHRcdGlmICghQXJyYXkuaXNBcnJheSh2bm9kZXMpKSB2bm9kZXMgPSBbdm5vZGVzXVxuXHRcdHVwZGF0ZU5vZGVzKGRvbSwgZG9tLnZub2RlcywgVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4odm5vZGVzKSwgZmFsc2UsIGhvb2tzLCBudWxsLCBuYW1lc3BhY2UgPT09IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiID8gdW5kZWZpbmVkIDogbmFtZXNwYWNlKVxuXHRcdGRvbS52bm9kZXMgPSB2bm9kZXNcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSBob29rc1tpXSgpXG5cdFx0aWYgKCRkb2MuYWN0aXZlRWxlbWVudCAhPT0gYWN0aXZlKSBhY3RpdmUuZm9jdXMoKVxuXHR9XG5cdHJldHVybiB7cmVuZGVyOiByZW5kZXIsIHNldEV2ZW50Q2FsbGJhY2s6IHNldEV2ZW50Q2FsbGJhY2t9XG59XG5mdW5jdGlvbiB0aHJvdHRsZShjYWxsYmFjaykge1xuXHQvLzYwZnBzIHRyYW5zbGF0ZXMgdG8gMTYuNm1zLCByb3VuZCBpdCBkb3duIHNpbmNlIHNldFRpbWVvdXQgcmVxdWlyZXMgaW50XG5cdHZhciB0aW1lID0gMTZcblx0dmFyIGxhc3QgPSAwLCBwZW5kaW5nID0gbnVsbFxuXHR2YXIgdGltZW91dCA9IHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09IFwiZnVuY3Rpb25cIiA/IHJlcXVlc3RBbmltYXRpb25GcmFtZSA6IHNldFRpbWVvdXRcblx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBub3cgPSBEYXRlLm5vdygpXG5cdFx0aWYgKGxhc3QgPT09IDAgfHwgbm93IC0gbGFzdCA+PSB0aW1lKSB7XG5cdFx0XHRsYXN0ID0gbm93XG5cdFx0XHRjYWxsYmFjaygpXG5cdFx0fVxuXHRcdGVsc2UgaWYgKHBlbmRpbmcgPT09IG51bGwpIHtcblx0XHRcdHBlbmRpbmcgPSB0aW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRwZW5kaW5nID0gbnVsbFxuXHRcdFx0XHRjYWxsYmFjaygpXG5cdFx0XHRcdGxhc3QgPSBEYXRlLm5vdygpXG5cdFx0XHR9LCB0aW1lIC0gKG5vdyAtIGxhc3QpKVxuXHRcdH1cblx0fVxufVxudmFyIF8xMSA9IGZ1bmN0aW9uKCR3aW5kb3cpIHtcblx0dmFyIHJlbmRlclNlcnZpY2UgPSBjb3JlUmVuZGVyZXIoJHdpbmRvdylcblx0cmVuZGVyU2VydmljZS5zZXRFdmVudENhbGxiYWNrKGZ1bmN0aW9uKGUpIHtcblx0XHRpZiAoZS5yZWRyYXcgPT09IGZhbHNlKSBlLnJlZHJhdyA9IHVuZGVmaW5lZFxuXHRcdGVsc2UgcmVkcmF3KClcblx0fSlcblx0dmFyIGNhbGxiYWNrcyA9IFtdXG5cdGZ1bmN0aW9uIHN1YnNjcmliZShrZXkxLCBjYWxsYmFjaykge1xuXHRcdHVuc3Vic2NyaWJlKGtleTEpXG5cdFx0Y2FsbGJhY2tzLnB1c2goa2V5MSwgdGhyb3R0bGUoY2FsbGJhY2spKVxuXHR9XG5cdGZ1bmN0aW9uIHVuc3Vic2NyaWJlKGtleTEpIHtcblx0XHR2YXIgaW5kZXggPSBjYWxsYmFja3MuaW5kZXhPZihrZXkxKVxuXHRcdGlmIChpbmRleCA+IC0xKSBjYWxsYmFja3Muc3BsaWNlKGluZGV4LCAyKVxuXHR9XG5cdGZ1bmN0aW9uIHJlZHJhdygpIHtcblx0XHRmb3IgKHZhciBpID0gMTsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkgKz0gMikge1xuXHRcdFx0Y2FsbGJhY2tzW2ldKClcblx0XHR9XG5cdH1cblx0cmV0dXJuIHtzdWJzY3JpYmU6IHN1YnNjcmliZSwgdW5zdWJzY3JpYmU6IHVuc3Vic2NyaWJlLCByZWRyYXc6IHJlZHJhdywgcmVuZGVyOiByZW5kZXJTZXJ2aWNlLnJlbmRlcn1cbn1cbnZhciByZWRyYXdTZXJ2aWNlID0gXzExKHdpbmRvdylcbnJlcXVlc3RTZXJ2aWNlLnNldENvbXBsZXRpb25DYWxsYmFjayhyZWRyYXdTZXJ2aWNlLnJlZHJhdylcbnZhciBfMTYgPSBmdW5jdGlvbihyZWRyYXdTZXJ2aWNlMCkge1xuXHRyZXR1cm4gZnVuY3Rpb24ocm9vdCwgY29tcG9uZW50KSB7XG5cdFx0aWYgKGNvbXBvbmVudCA9PT0gbnVsbCkge1xuXHRcdFx0cmVkcmF3U2VydmljZTAucmVuZGVyKHJvb3QsIFtdKVxuXHRcdFx0cmVkcmF3U2VydmljZTAudW5zdWJzY3JpYmUocm9vdClcblx0XHRcdHJldHVyblxuXHRcdH1cblx0XHRcblx0XHRpZiAoY29tcG9uZW50LnZpZXcgPT0gbnVsbCAmJiB0eXBlb2YgY29tcG9uZW50ICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcihcIm0ubW91bnQoZWxlbWVudCwgY29tcG9uZW50KSBleHBlY3RzIGEgY29tcG9uZW50LCBub3QgYSB2bm9kZVwiKVxuXHRcdFxuXHRcdHZhciBydW4wID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZWRyYXdTZXJ2aWNlMC5yZW5kZXIocm9vdCwgVm5vZGUoY29tcG9uZW50KSlcblx0XHR9XG5cdFx0cmVkcmF3U2VydmljZTAuc3Vic2NyaWJlKHJvb3QsIHJ1bjApXG5cdFx0cmVkcmF3U2VydmljZTAucmVkcmF3KClcblx0fVxufVxubS5tb3VudCA9IF8xNihyZWRyYXdTZXJ2aWNlKVxudmFyIFByb21pc2UgPSBQcm9taXNlUG9seWZpbGxcbnZhciBwYXJzZVF1ZXJ5U3RyaW5nID0gZnVuY3Rpb24oc3RyaW5nKSB7XG5cdGlmIChzdHJpbmcgPT09IFwiXCIgfHwgc3RyaW5nID09IG51bGwpIHJldHVybiB7fVxuXHRpZiAoc3RyaW5nLmNoYXJBdCgwKSA9PT0gXCI/XCIpIHN0cmluZyA9IHN0cmluZy5zbGljZSgxKVxuXHR2YXIgZW50cmllcyA9IHN0cmluZy5zcGxpdChcIiZcIiksIGRhdGEwID0ge30sIGNvdW50ZXJzID0ge31cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGVudHJ5ID0gZW50cmllc1tpXS5zcGxpdChcIj1cIilcblx0XHR2YXIga2V5NSA9IGRlY29kZVVSSUNvbXBvbmVudChlbnRyeVswXSlcblx0XHR2YXIgdmFsdWUgPSBlbnRyeS5sZW5ndGggPT09IDIgPyBkZWNvZGVVUklDb21wb25lbnQoZW50cnlbMV0pIDogXCJcIlxuXHRcdGlmICh2YWx1ZSA9PT0gXCJ0cnVlXCIpIHZhbHVlID0gdHJ1ZVxuXHRcdGVsc2UgaWYgKHZhbHVlID09PSBcImZhbHNlXCIpIHZhbHVlID0gZmFsc2Vcblx0XHR2YXIgbGV2ZWxzID0ga2V5NS5zcGxpdCgvXFxdXFxbP3xcXFsvKVxuXHRcdHZhciBjdXJzb3IgPSBkYXRhMFxuXHRcdGlmIChrZXk1LmluZGV4T2YoXCJbXCIpID4gLTEpIGxldmVscy5wb3AoKVxuXHRcdGZvciAodmFyIGogPSAwOyBqIDwgbGV2ZWxzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHR2YXIgbGV2ZWwgPSBsZXZlbHNbal0sIG5leHRMZXZlbCA9IGxldmVsc1tqICsgMV1cblx0XHRcdHZhciBpc051bWJlciA9IG5leHRMZXZlbCA9PSBcIlwiIHx8ICFpc05hTihwYXJzZUludChuZXh0TGV2ZWwsIDEwKSlcblx0XHRcdHZhciBpc1ZhbHVlID0gaiA9PT0gbGV2ZWxzLmxlbmd0aCAtIDFcblx0XHRcdGlmIChsZXZlbCA9PT0gXCJcIikge1xuXHRcdFx0XHR2YXIga2V5NSA9IGxldmVscy5zbGljZSgwLCBqKS5qb2luKClcblx0XHRcdFx0aWYgKGNvdW50ZXJzW2tleTVdID09IG51bGwpIGNvdW50ZXJzW2tleTVdID0gMFxuXHRcdFx0XHRsZXZlbCA9IGNvdW50ZXJzW2tleTVdKytcblx0XHRcdH1cblx0XHRcdGlmIChjdXJzb3JbbGV2ZWxdID09IG51bGwpIHtcblx0XHRcdFx0Y3Vyc29yW2xldmVsXSA9IGlzVmFsdWUgPyB2YWx1ZSA6IGlzTnVtYmVyID8gW10gOiB7fVxuXHRcdFx0fVxuXHRcdFx0Y3Vyc29yID0gY3Vyc29yW2xldmVsXVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gZGF0YTBcbn1cbnZhciBjb3JlUm91dGVyID0gZnVuY3Rpb24oJHdpbmRvdykge1xuXHR2YXIgc3VwcG9ydHNQdXNoU3RhdGUgPSB0eXBlb2YgJHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSA9PT0gXCJmdW5jdGlvblwiXG5cdHZhciBjYWxsQXN5bmMwID0gdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiID8gc2V0SW1tZWRpYXRlIDogc2V0VGltZW91dFxuXHRmdW5jdGlvbiBub3JtYWxpemUxKGZyYWdtZW50MCkge1xuXHRcdHZhciBkYXRhID0gJHdpbmRvdy5sb2NhdGlvbltmcmFnbWVudDBdLnJlcGxhY2UoLyg/OiVbYS1mODldW2EtZjAtOV0pKy9naW0sIGRlY29kZVVSSUNvbXBvbmVudClcblx0XHRpZiAoZnJhZ21lbnQwID09PSBcInBhdGhuYW1lXCIgJiYgZGF0YVswXSAhPT0gXCIvXCIpIGRhdGEgPSBcIi9cIiArIGRhdGFcblx0XHRyZXR1cm4gZGF0YVxuXHR9XG5cdHZhciBhc3luY0lkXG5cdGZ1bmN0aW9uIGRlYm91bmNlQXN5bmMoY2FsbGJhY2swKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKGFzeW5jSWQgIT0gbnVsbCkgcmV0dXJuXG5cdFx0XHRhc3luY0lkID0gY2FsbEFzeW5jMChmdW5jdGlvbigpIHtcblx0XHRcdFx0YXN5bmNJZCA9IG51bGxcblx0XHRcdFx0Y2FsbGJhY2swKClcblx0XHRcdH0pXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHBhcnNlUGF0aChwYXRoLCBxdWVyeURhdGEsIGhhc2hEYXRhKSB7XG5cdFx0dmFyIHF1ZXJ5SW5kZXggPSBwYXRoLmluZGV4T2YoXCI/XCIpXG5cdFx0dmFyIGhhc2hJbmRleCA9IHBhdGguaW5kZXhPZihcIiNcIilcblx0XHR2YXIgcGF0aEVuZCA9IHF1ZXJ5SW5kZXggPiAtMSA/IHF1ZXJ5SW5kZXggOiBoYXNoSW5kZXggPiAtMSA/IGhhc2hJbmRleCA6IHBhdGgubGVuZ3RoXG5cdFx0aWYgKHF1ZXJ5SW5kZXggPiAtMSkge1xuXHRcdFx0dmFyIHF1ZXJ5RW5kID0gaGFzaEluZGV4ID4gLTEgPyBoYXNoSW5kZXggOiBwYXRoLmxlbmd0aFxuXHRcdFx0dmFyIHF1ZXJ5UGFyYW1zID0gcGFyc2VRdWVyeVN0cmluZyhwYXRoLnNsaWNlKHF1ZXJ5SW5kZXggKyAxLCBxdWVyeUVuZCkpXG5cdFx0XHRmb3IgKHZhciBrZXk0IGluIHF1ZXJ5UGFyYW1zKSBxdWVyeURhdGFba2V5NF0gPSBxdWVyeVBhcmFtc1trZXk0XVxuXHRcdH1cblx0XHRpZiAoaGFzaEluZGV4ID4gLTEpIHtcblx0XHRcdHZhciBoYXNoUGFyYW1zID0gcGFyc2VRdWVyeVN0cmluZyhwYXRoLnNsaWNlKGhhc2hJbmRleCArIDEpKVxuXHRcdFx0Zm9yICh2YXIga2V5NCBpbiBoYXNoUGFyYW1zKSBoYXNoRGF0YVtrZXk0XSA9IGhhc2hQYXJhbXNba2V5NF1cblx0XHR9XG5cdFx0cmV0dXJuIHBhdGguc2xpY2UoMCwgcGF0aEVuZClcblx0fVxuXHR2YXIgcm91dGVyID0ge3ByZWZpeDogXCIjIVwifVxuXHRyb3V0ZXIuZ2V0UGF0aCA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0eXBlMiA9IHJvdXRlci5wcmVmaXguY2hhckF0KDApXG5cdFx0c3dpdGNoICh0eXBlMikge1xuXHRcdFx0Y2FzZSBcIiNcIjogcmV0dXJuIG5vcm1hbGl6ZTEoXCJoYXNoXCIpLnNsaWNlKHJvdXRlci5wcmVmaXgubGVuZ3RoKVxuXHRcdFx0Y2FzZSBcIj9cIjogcmV0dXJuIG5vcm1hbGl6ZTEoXCJzZWFyY2hcIikuc2xpY2Uocm91dGVyLnByZWZpeC5sZW5ndGgpICsgbm9ybWFsaXplMShcImhhc2hcIilcblx0XHRcdGRlZmF1bHQ6IHJldHVybiBub3JtYWxpemUxKFwicGF0aG5hbWVcIikuc2xpY2Uocm91dGVyLnByZWZpeC5sZW5ndGgpICsgbm9ybWFsaXplMShcInNlYXJjaFwiKSArIG5vcm1hbGl6ZTEoXCJoYXNoXCIpXG5cdFx0fVxuXHR9XG5cdHJvdXRlci5zZXRQYXRoID0gZnVuY3Rpb24ocGF0aCwgZGF0YSwgb3B0aW9ucykge1xuXHRcdHZhciBxdWVyeURhdGEgPSB7fSwgaGFzaERhdGEgPSB7fVxuXHRcdHBhdGggPSBwYXJzZVBhdGgocGF0aCwgcXVlcnlEYXRhLCBoYXNoRGF0YSlcblx0XHRpZiAoZGF0YSAhPSBudWxsKSB7XG5cdFx0XHRmb3IgKHZhciBrZXk0IGluIGRhdGEpIHF1ZXJ5RGF0YVtrZXk0XSA9IGRhdGFba2V5NF1cblx0XHRcdHBhdGggPSBwYXRoLnJlcGxhY2UoLzooW15cXC9dKykvZywgZnVuY3Rpb24obWF0Y2gyLCB0b2tlbikge1xuXHRcdFx0XHRkZWxldGUgcXVlcnlEYXRhW3Rva2VuXVxuXHRcdFx0XHRyZXR1cm4gZGF0YVt0b2tlbl1cblx0XHRcdH0pXG5cdFx0fVxuXHRcdHZhciBxdWVyeSA9IGJ1aWxkUXVlcnlTdHJpbmcocXVlcnlEYXRhKVxuXHRcdGlmIChxdWVyeSkgcGF0aCArPSBcIj9cIiArIHF1ZXJ5XG5cdFx0dmFyIGhhc2ggPSBidWlsZFF1ZXJ5U3RyaW5nKGhhc2hEYXRhKVxuXHRcdGlmIChoYXNoKSBwYXRoICs9IFwiI1wiICsgaGFzaFxuXHRcdGlmIChzdXBwb3J0c1B1c2hTdGF0ZSkge1xuXHRcdFx0dmFyIHN0YXRlID0gb3B0aW9ucyA/IG9wdGlvbnMuc3RhdGUgOiBudWxsXG5cdFx0XHR2YXIgdGl0bGUgPSBvcHRpb25zID8gb3B0aW9ucy50aXRsZSA6IG51bGxcblx0XHRcdCR3aW5kb3cub25wb3BzdGF0ZSgpXG5cdFx0XHRpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlcGxhY2UpICR3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoc3RhdGUsIHRpdGxlLCByb3V0ZXIucHJlZml4ICsgcGF0aClcblx0XHRcdGVsc2UgJHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZShzdGF0ZSwgdGl0bGUsIHJvdXRlci5wcmVmaXggKyBwYXRoKVxuXHRcdH1cblx0XHRlbHNlICR3aW5kb3cubG9jYXRpb24uaHJlZiA9IHJvdXRlci5wcmVmaXggKyBwYXRoXG5cdH1cblx0cm91dGVyLmRlZmluZVJvdXRlcyA9IGZ1bmN0aW9uKHJvdXRlcywgcmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0ZnVuY3Rpb24gcmVzb2x2ZVJvdXRlKCkge1xuXHRcdFx0dmFyIHBhdGggPSByb3V0ZXIuZ2V0UGF0aCgpXG5cdFx0XHR2YXIgcGFyYW1zID0ge31cblx0XHRcdHZhciBwYXRobmFtZSA9IHBhcnNlUGF0aChwYXRoLCBwYXJhbXMsIHBhcmFtcylcblx0XHRcdHZhciBzdGF0ZSA9ICR3aW5kb3cuaGlzdG9yeS5zdGF0ZVxuXHRcdFx0aWYgKHN0YXRlICE9IG51bGwpIHtcblx0XHRcdFx0Zm9yICh2YXIgayBpbiBzdGF0ZSkgcGFyYW1zW2tdID0gc3RhdGVba11cblx0XHRcdH1cblx0XHRcdGZvciAodmFyIHJvdXRlMCBpbiByb3V0ZXMpIHtcblx0XHRcdFx0dmFyIG1hdGNoZXIgPSBuZXcgUmVnRXhwKFwiXlwiICsgcm91dGUwLnJlcGxhY2UoLzpbXlxcL10rP1xcLnszfS9nLCBcIiguKj8pXCIpLnJlcGxhY2UoLzpbXlxcL10rL2csIFwiKFteXFxcXC9dKylcIikgKyBcIlxcLz8kXCIpXG5cdFx0XHRcdGlmIChtYXRjaGVyLnRlc3QocGF0aG5hbWUpKSB7XG5cdFx0XHRcdFx0cGF0aG5hbWUucmVwbGFjZShtYXRjaGVyLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHZhciBrZXlzID0gcm91dGUwLm1hdGNoKC86W15cXC9dKy9nKSB8fCBbXVxuXHRcdFx0XHRcdFx0dmFyIHZhbHVlcyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxLCAtMilcblx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRwYXJhbXNba2V5c1tpXS5yZXBsYWNlKC86fFxcLi9nLCBcIlwiKV0gPSBkZWNvZGVVUklDb21wb25lbnQodmFsdWVzW2ldKVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmVzb2x2ZShyb3V0ZXNbcm91dGUwXSwgcGFyYW1zLCBwYXRoLCByb3V0ZTApXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmVqZWN0KHBhdGgsIHBhcmFtcylcblx0XHR9XG5cdFx0aWYgKHN1cHBvcnRzUHVzaFN0YXRlKSAkd2luZG93Lm9ucG9wc3RhdGUgPSBkZWJvdW5jZUFzeW5jKHJlc29sdmVSb3V0ZSlcblx0XHRlbHNlIGlmIChyb3V0ZXIucHJlZml4LmNoYXJBdCgwKSA9PT0gXCIjXCIpICR3aW5kb3cub25oYXNoY2hhbmdlID0gcmVzb2x2ZVJvdXRlXG5cdFx0cmVzb2x2ZVJvdXRlKClcblx0fVxuXHRyZXR1cm4gcm91dGVyXG59XG52YXIgXzIwID0gZnVuY3Rpb24oJHdpbmRvdywgcmVkcmF3U2VydmljZTApIHtcblx0dmFyIHJvdXRlU2VydmljZSA9IGNvcmVSb3V0ZXIoJHdpbmRvdylcblx0dmFyIGlkZW50aXR5ID0gZnVuY3Rpb24odikge3JldHVybiB2fVxuXHR2YXIgcmVuZGVyMSwgY29tcG9uZW50LCBhdHRyczMsIGN1cnJlbnRQYXRoLCBsYXN0VXBkYXRlXG5cdHZhciByb3V0ZSA9IGZ1bmN0aW9uKHJvb3QsIGRlZmF1bHRSb3V0ZSwgcm91dGVzKSB7XG5cdFx0aWYgKHJvb3QgPT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKFwiRW5zdXJlIHRoZSBET00gZWxlbWVudCB0aGF0IHdhcyBwYXNzZWQgdG8gYG0ucm91dGVgIGlzIG5vdCB1bmRlZmluZWRcIilcblx0XHR2YXIgcnVuMSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKHJlbmRlcjEgIT0gbnVsbCkgcmVkcmF3U2VydmljZTAucmVuZGVyKHJvb3QsIHJlbmRlcjEoVm5vZGUoY29tcG9uZW50LCBhdHRyczMua2V5LCBhdHRyczMpKSlcblx0XHR9XG5cdFx0dmFyIGJhaWwgPSBmdW5jdGlvbihwYXRoKSB7XG5cdFx0XHRpZiAocGF0aCAhPT0gZGVmYXVsdFJvdXRlKSByb3V0ZVNlcnZpY2Uuc2V0UGF0aChkZWZhdWx0Um91dGUsIG51bGwsIHtyZXBsYWNlOiB0cnVlfSlcblx0XHRcdGVsc2UgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IHJlc29sdmUgZGVmYXVsdCByb3V0ZSBcIiArIGRlZmF1bHRSb3V0ZSlcblx0XHR9XG5cdFx0cm91dGVTZXJ2aWNlLmRlZmluZVJvdXRlcyhyb3V0ZXMsIGZ1bmN0aW9uKHBheWxvYWQsIHBhcmFtcywgcGF0aCkge1xuXHRcdFx0dmFyIHVwZGF0ZSA9IGxhc3RVcGRhdGUgPSBmdW5jdGlvbihyb3V0ZVJlc29sdmVyLCBjb21wKSB7XG5cdFx0XHRcdGlmICh1cGRhdGUgIT09IGxhc3RVcGRhdGUpIHJldHVyblxuXHRcdFx0XHRjb21wb25lbnQgPSBjb21wICE9IG51bGwgJiYgKHR5cGVvZiBjb21wLnZpZXcgPT09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgY29tcCA9PT0gXCJmdW5jdGlvblwiKT8gY29tcCA6IFwiZGl2XCJcblx0XHRcdFx0YXR0cnMzID0gcGFyYW1zLCBjdXJyZW50UGF0aCA9IHBhdGgsIGxhc3RVcGRhdGUgPSBudWxsXG5cdFx0XHRcdHJlbmRlcjEgPSAocm91dGVSZXNvbHZlci5yZW5kZXIgfHwgaWRlbnRpdHkpLmJpbmQocm91dGVSZXNvbHZlcilcblx0XHRcdFx0cnVuMSgpXG5cdFx0XHR9XG5cdFx0XHRpZiAocGF5bG9hZC52aWV3IHx8IHR5cGVvZiBwYXlsb2FkID09PSBcImZ1bmN0aW9uXCIpIHVwZGF0ZSh7fSwgcGF5bG9hZClcblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRpZiAocGF5bG9hZC5vbm1hdGNoKSB7XG5cdFx0XHRcdFx0UHJvbWlzZS5yZXNvbHZlKHBheWxvYWQub25tYXRjaChwYXJhbXMsIHBhdGgpKS50aGVuKGZ1bmN0aW9uKHJlc29sdmVkKSB7XG5cdFx0XHRcdFx0XHR1cGRhdGUocGF5bG9hZCwgcmVzb2x2ZWQpXG5cdFx0XHRcdFx0fSwgYmFpbClcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHVwZGF0ZShwYXlsb2FkLCBcImRpdlwiKVxuXHRcdFx0fVxuXHRcdH0sIGJhaWwpXG5cdFx0cmVkcmF3U2VydmljZTAuc3Vic2NyaWJlKHJvb3QsIHJ1bjEpXG5cdH1cblx0cm91dGUuc2V0ID0gZnVuY3Rpb24ocGF0aCwgZGF0YSwgb3B0aW9ucykge1xuXHRcdGlmIChsYXN0VXBkYXRlICE9IG51bGwpIHtcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cdFx0XHRvcHRpb25zLnJlcGxhY2UgPSB0cnVlXG5cdFx0fVxuXHRcdGxhc3RVcGRhdGUgPSBudWxsXG5cdFx0cm91dGVTZXJ2aWNlLnNldFBhdGgocGF0aCwgZGF0YSwgb3B0aW9ucylcblx0fVxuXHRyb3V0ZS5nZXQgPSBmdW5jdGlvbigpIHtyZXR1cm4gY3VycmVudFBhdGh9XG5cdHJvdXRlLnByZWZpeCA9IGZ1bmN0aW9uKHByZWZpeDApIHtyb3V0ZVNlcnZpY2UucHJlZml4ID0gcHJlZml4MH1cblx0cm91dGUubGluayA9IGZ1bmN0aW9uKHZub2RlMSkge1xuXHRcdHZub2RlMS5kb20uc2V0QXR0cmlidXRlKFwiaHJlZlwiLCByb3V0ZVNlcnZpY2UucHJlZml4ICsgdm5vZGUxLmF0dHJzLmhyZWYpXG5cdFx0dm5vZGUxLmRvbS5vbmNsaWNrID0gZnVuY3Rpb24oZSkge1xuXHRcdFx0aWYgKGUuY3RybEtleSB8fCBlLm1ldGFLZXkgfHwgZS5zaGlmdEtleSB8fCBlLndoaWNoID09PSAyKSByZXR1cm5cblx0XHRcdGUucHJldmVudERlZmF1bHQoKVxuXHRcdFx0ZS5yZWRyYXcgPSBmYWxzZVxuXHRcdFx0dmFyIGhyZWYgPSB0aGlzLmdldEF0dHJpYnV0ZShcImhyZWZcIilcblx0XHRcdGlmIChocmVmLmluZGV4T2Yocm91dGVTZXJ2aWNlLnByZWZpeCkgPT09IDApIGhyZWYgPSBocmVmLnNsaWNlKHJvdXRlU2VydmljZS5wcmVmaXgubGVuZ3RoKVxuXHRcdFx0cm91dGUuc2V0KGhyZWYsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKVxuXHRcdH1cblx0fVxuXHRyb3V0ZS5wYXJhbSA9IGZ1bmN0aW9uKGtleTMpIHtcblx0XHRpZih0eXBlb2YgYXR0cnMzICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBrZXkzICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gYXR0cnMzW2tleTNdXG5cdFx0cmV0dXJuIGF0dHJzM1xuXHR9XG5cdHJldHVybiByb3V0ZVxufVxubS5yb3V0ZSA9IF8yMCh3aW5kb3csIHJlZHJhd1NlcnZpY2UpXG5tLndpdGhBdHRyID0gZnVuY3Rpb24oYXR0ck5hbWUsIGNhbGxiYWNrMSwgY29udGV4dCkge1xuXHRyZXR1cm4gZnVuY3Rpb24oZSkge1xuXHRcdGNhbGxiYWNrMS5jYWxsKGNvbnRleHQgfHwgdGhpcywgYXR0ck5hbWUgaW4gZS5jdXJyZW50VGFyZ2V0ID8gZS5jdXJyZW50VGFyZ2V0W2F0dHJOYW1lXSA6IGUuY3VycmVudFRhcmdldC5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpKVxuXHR9XG59XG52YXIgXzI4ID0gY29yZVJlbmRlcmVyKHdpbmRvdylcbm0ucmVuZGVyID0gXzI4LnJlbmRlclxubS5yZWRyYXcgPSByZWRyYXdTZXJ2aWNlLnJlZHJhd1xubS5yZXF1ZXN0ID0gcmVxdWVzdFNlcnZpY2UucmVxdWVzdFxubS5qc29ucCA9IHJlcXVlc3RTZXJ2aWNlLmpzb25wXG5tLnBhcnNlUXVlcnlTdHJpbmcgPSBwYXJzZVF1ZXJ5U3RyaW5nXG5tLmJ1aWxkUXVlcnlTdHJpbmcgPSBidWlsZFF1ZXJ5U3RyaW5nXG5tLnZlcnNpb24gPSBcIjEuMS4zXCJcbm0udm5vZGUgPSBWbm9kZVxuaWYgKHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIpIG1vZHVsZVtcImV4cG9ydHNcIl0gPSBtXG5lbHNlIHdpbmRvdy5tID0gbVxufSgpKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbWl0aHJpbC9taXRocmlsLmpzXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n')},function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.fakeClick = exports.hexToRgba = exports.popoverContent = exports.summary = exports.legend = exports.spliceLinksForNode = exports.findNode = exports.findNodeIndex = exports.clickVar = exports.reset = exports.nodes = exports.allNodes = exports.valueKey = exports.zparams = exports.logArray = exports.righttab = exports.summaryHold = exports.subset = exports.lefttab = exports.timeColor = exports.varColor = exports.nomColor = exports.dvColor = exports.csColor = exports.inspect = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nexports.cdb = cdb;\nexports.main = main;\nexports.getVariableData = getVariableData;\nexports.forceSwitch = forceSwitch;\nexports.estimate = estimate;\nexports.erase = erase;\nexports.tabLeft = tabLeft;\nexports.tabRight = tabRight;\nexports.panelPlots = panelPlots;\nexports.borderState = borderState;\nexports.subsetSelect = subsetSelect;\n\nvar _mithril = __webpack_require__(0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _plots = __webpack_require__(2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// hostname default - the app will use it to obtain the variable metadata\n// (ddi) and pre-processed data info if the file id is supplied as an\n// argument (for ex., gui.html?dfId=17), but hostname isn't.\n// Edit it to suit your installation.\n// (NOTE that if the file id isn't supplied, the app will default to the\n// local files specified below!)\n// NEW: it is also possible now to supply complete urls for the ddi and\n// the tab-delimited data file; the parameters are ddiurl and dataurl.\n// These new parameters are optional. If they are not supplied, the app\n// will go the old route - will try to cook standard dataverse urls\n// for both the data and metadata, if the file id is supplied; or the\n// local files if nothing is supplied.\n\n// FOR variables \"production\" and \"rappURL\", see /template/index.html\n//\n//let production = false;\n//let rappURL = 'http://127.0.0.1:8080/rook-custom/'; // via Django -> to RApache/rook\n//let rappURL = 'http://0.0.0.0:8000/custom/'; // Direct to RApache/rook\n\n// for debugging\nfunction cdb(msg) {\n    if (!production) {\n        console.log(msg);\n    };\n};\n\nvar inspect = exports.inspect = function inspect(obj) {\n    console.log(obj);\n    return obj;\n};\n\n// initial color scale used to establish the initial colors of nodes\n// allNodes.push() below establishes a field for the master node array allNodes called \"nodeCol\" and assigns a color from this scale to that field\n// everything there after should refer to the nodeCol and not the color scale, this enables us to update colors and pass the variable type to R based on its coloring\nvar colors = d3.scale.category20();\nvar csColor = exports.csColor = '#419641';\nvar dvColor = exports.dvColor = '#28a4c9';\nvar grayColor = '#c0c0c0';\nvar nomColor = exports.nomColor = '#ff6600';\nvar varColor = exports.varColor = '#f0f8ff'; // d3.rgb(\"aliceblue\");\nvar taggedColor = '#f5f5f5'; // d3.rgb(\"whitesmoke\");\nvar timeColor = exports.timeColor = '#2d6ca2';\n\nvar lefttab = exports.lefttab = 'tab1'; // current tab in left panel\nvar subset = exports.subset = false;\nvar summaryHold = exports.summaryHold = false;\nvar righttab = exports.righttab = 'btnModels'; // current tab in right panel\n\n// transformation toolbar options\nvar t = void 0,\n    typeTransform = void 0;\nvar transformList = 'log(d) exp(d) d^2 sqrt(d) interact(d,e)'.split(' ');\nvar transformVar = '';\n\n// var list for each space contain variables in original data\n// plus trans in that space\nvar trans = [];\nvar preprocess = {}; // hold pre-processed data\nvar spaces = [];\n\n// layout function constants\nvar layoutAdd = \"add\";\nvar layoutMove = \"move\";\n\n// Radius of circle\nvar allR = 40;\n\n// space index\nvar myspace = 0;\n\nvar forcetoggle = [\"true\"];\nvar priv = true;\n\nvar logArray = exports.logArray = [];\nvar zparams = exports.zparams = {\n    zdata: [],\n    zedges: [],\n    ztime: [],\n    znom: [],\n    zcross: [],\n    zmodel: \"\",\n    zvars: [],\n    zdv: [],\n    zdataurl: \"\",\n    zsubset: [],\n    zsetx: [],\n    zmodelcount: 0,\n    zplot: [],\n    zsessionid: \"\",\n    zdatacite: \"\"\n};\n\nvar modelCount = 0;\nvar valueKey = exports.valueKey = [];\nvar allNodes = exports.allNodes = [];\nvar allResults = [];\nvar nodes = exports.nodes = [];\nvar links = [];\nvar mods = {};\nvar estimated = false;\nvar rightClickLast = false;\nvar selInteract = false;\nvar callHistory = []; // transform and subset calls\n\nvar svg, width, height, div, estimateLadda, selectLadda;\nvar arc3, arc4;\n\nvar byId = function byId(id) {\n    return document.getElementById(id);\n};\n\n// page reload linked to btnReset\nvar reset = exports.reset = function reloadPage() {\n    location.reload();\n};\n\nvar dataurl;\nfunction main(fileid, hostname, ddiurl, dataurl) {\n    dataurl = dataurl;\n    if (production && fileid == \"\") {\n        alert(\"Error: No fileid has been provided.\");\n        throw new Error(\"Error: No fileid has been provided.\");\n    }\n\n    var dataverseurl = '';\n    if (hostname) dataverseurl = \"https://\" + hostname;else if (production) dataverseurl = \"%PRODUCTION_DATAVERSE_URL%\";else dataverseurl = \"http://localhost:8080\";\n\n    if (fileid && !dataurl) {\n        // file id supplied; assume we are dealing with dataverse and cook a standard dataverse data access url\n        // with the fileid supplied and the hostname we have supplied or configured\n        dataurl = dataverseurl + \"/api/access/datafile/\" + fileid;\n        dataurl = dataurl + \"?key=\" + apikey;\n    }\n\n    svg = d3.select(\"#whitespace\");\n\n    var tempWidth = d3.select(\"#main.left\").style(\"width\");\n    width = tempWidth.substring(0, tempWidth.length - 2);\n    height = $(window).height() - 120; // Hard coding for header and footer and bottom margin.\n\n    estimateLadda = Ladda.create(byId(\"btnEstimate\"));\n    selectLadda = Ladda.create(byId(\"btnSelect\"));\n\n    var colorTime = false;\n    var colorCS = false;\n\n    var depVar = false;\n    var subsetdiv = false;\n    var setxdiv = false;\n\n    //Width and height for histgrams\n    var barwidth = 1.3 * allR;\n    var barheight = 0.5 * allR;\n    var barPadding = 0.35;\n    var barnumber = 7;\n\n    var arc = function arc(start, end) {\n        return d3.svg.arc().innerRadius(allR + 5).outerRadius(allR + 20).startAngle(start).endAngle(end);\n    };\n    var _ref = [arc(0, 3.2), arc(0, 1), arc(1.1, 2.2)],\n        arc0 = _ref[0],\n        arc1 = _ref[1],\n        arc2 = _ref[2];\n\n    arc3 = arc(2.3, 3.3);\n    arc4 = arc(4.3, 5.3);\n\n    // From .csv\n    var dataset2 = [];\n    var lablArray = [];\n    var hold = [];\n    var subsetNodes = [];\n\n    // collapsable user log\n    $('#collapseLog').on('shown.bs.collapse', function () {\n        d3.select(\"#collapseLog div.panel-body\").selectAll(\"p\").data(logArray).enter().append(\"p\").text(function (d) {\n            return d;\n        });\n    });\n    $('#collapseLog').on('hidden.bs.collapse', function () {\n        d3.select(\"#collapseLog div.panel-body\").selectAll(\"p\").remove();\n    });\n\n    // default to California PUMS subset\n    var data = 'data/' + (false ? 'PUMS5small' : 'fearonLaitin');\n    var metadataurl = ddiurl || (fileid ? dataverseurl + '/api/meta/datafile/' + fileid : data + '.xml');\n    // read pre-processed metadata and data\n    var pURL = dataurl ? dataurl + '&format=prep' : data + '.json';\n    cdb('pURL: ' + pURL);\n    // loads all external data: metadata (DVN's ddi), preprocessed (for plotting distributions), and zeligmodels (produced by Zelig) and initiates the data download to the server\n    var url, p, v, _callback;\n    readPreprocess(url = pURL, p = preprocess, v = null, _callback = function callback() {\n        d3.xml(metadataurl, \"application/xml\", function (xml) {\n            var vars = xml.documentElement.getElementsByTagName(\"var\");\n            var temp = xml.documentElement.getElementsByTagName(\"fileName\");\n            zparams.zdata = temp[0].childNodes[0].nodeValue;\n\n            var cite = xml.documentElement.getElementsByTagName(\"biblCit\");\n            zparams.zdatacite = cite[0].childNodes[0].nodeValue;\n            // clean citation so POST is valid json\n            zparams.zdatacite = zparams.zdatacite.replace(/\\&/g, \"and\").replace(/\\;/g, \",\").replace(/\\%/g, \"-\");\n\n            // dataset name trimmed to 12 chars\n            var dataname = zparams.zdata.replace(/\\.(.*)/, ''); // drop file extension\n            d3.select(\"#dataName\").html(dataname);\n            $('#cite div.panel-body').text(zparams.zdatacite);\n\n            // Put dataset name, from meta-data, into page title\n            d3.select(\"title\").html(\"TwoRavens \" + dataname);\n            // temporary values for hold that correspond to histogram bins\n            hold = [.6, .2, .9, .8, .1, .3, .4];\n            for (var i = 0; i < vars.length; i++) {\n                valueKey[i] = vars[i].attributes.name.nodeValue;\n                lablArray[i] = vars[i].getElementsByTagName(\"labl\").length == 0 ? \"no label\" : vars[i].getElementsByTagName(\"labl\")[0].childNodes[0].nodeValue;\n                var datasetcount = d3.layout.histogram().bins(barnumber).frequency(false)([0, 0, 0, 0, 0]);\n                // contains all the preprocessed data we have for the variable, as well as UI data pertinent to that variable, such as setx values (if the user has selected them) and pebble coordinates\n                var obj = {\n                    id: i,\n                    reflexive: false,\n                    name: valueKey[i],\n                    labl: lablArray[i],\n                    data: [5, 15, 20, 0, 5, 15, 20],\n                    count: hold,\n                    nodeCol: colors(i),\n                    baseCol: colors(i),\n                    strokeColor: _plots.selVarColor,\n                    strokeWidth: \"1\",\n                    subsetplot: false,\n                    subsetrange: [\"\", \"\"],\n                    setxplot: false,\n                    setxvals: [\"\", \"\"],\n                    grayout: false\n                };\n                jQuery.extend(true, obj, preprocess[valueKey[i]]);\n                allNodes.push(obj);\n            };\n\n            // read the zelig models and populate model list in right panel\n            d3.json(\"data/zelig5models.json\", function (err, data) {\n                if (err) return console.warn(err);\n                cdb(\"zelig models json: \", data);\n                for (var key in data.zelig5models) {\n                    if (data.zelig5models.hasOwnProperty(key)) mods[data.zelig5models[key].name[0]] = data.zelig5models[key].description[0];\n                }\n                d3.json(\"data/zelig5choicemodels.json\", function (err, data) {\n                    if (err) return console.warn(err);\n                    cdb(\"zelig choice models json: \", data);\n                    for (var _key in data.zelig5choicemodels) {\n                        if (data.zelig5choicemodels.hasOwnProperty(_key)) mods[data.zelig5choicemodels[_key].name[0]] = data.zelig5choicemodels[_key].description[0];\n                    }\n                    scaffolding(_callback = layout);\n                    dataDownload();\n                });\n            });\n        });\n    });\n}\n\nvar $fill = function $fill(obj, op, d1, d2) {\n    return d3.select(obj).transition().attr('fill-opacity', op).delay(d1).duration(d2);\n};\nvar fill = function fill(d, id, op, d1, d2) {\n    return $fill('#' + id + d.id, op, d1, d2);\n};\nvar fillThis = function fillThis(self, op, d1, d2) {\n    return $fill(self, op, d1, d2);\n};\n\n// scaffolding is called after all external data are guaranteed to have been read to completion. this populates the left panel with variable names, the right panel with model names, the transformation tool, an the associated mouseovers. its callback is layout(), which initializes the modeling space\nfunction scaffolding(callback) {\n    var _this = this;\n\n    // establishing the transformation element\n    d3.select(\"#transformations\").append(\"input\").attr(\"id\", \"tInput\").attr(\"class\", \"form-control\").attr(\"type\", \"text\").attr(\"value\", \"Variable transformation\");\n\n    // variable dropdown\n    d3.select(\"#transformations\").append(\"ul\").attr(\"id\", \"transSel\").style(\"display\", \"none\").style(\"background-color\", varColor).selectAll('li').data([\"a\", \"b\"]) //set to variables in model space as they're added\n    .enter().append(\"li\").text(function (d) {\n        return d;\n    });\n\n    // function dropdown\n    d3.select(\"#transformations\").append(\"ul\").attr(\"id\", \"transList\").style(\"display\", \"none\").style(\"background-color\", varColor).selectAll('li').data(transformList).enter().append(\"li\").text(function (d) {\n        return d;\n    });\n\n    $('#tInput').click(function () {\n        var t = byId('transSel').style.display;\n        if (t !== \"none\") {\n            // if variable list is displayed when input is clicked...\n            $('#transSel').fadeOut(100);\n            return false;\n        }\n        var t1 = byId('transList').style.display;\n        if (t1 !== \"none\") {\n            // if function list is displayed when input is clicked...\n            $('#transList').fadeOut(100);\n            return false;\n        }\n\n        // highlight the text\n        $(_this).select();\n        var pos = $('#tInput').offset();\n        pos.top += $('#tInput').width();\n        $('#transSel').fadeIn(100);\n        return false;\n    });\n\n    var n;\n    $('#tInput').keyup(function (evt) {\n        var t = byId('transSel').style.display;\n        var t1 = byId('transList').style.display;\n        if (t != \"none\") $('#transSel').fadeOut(100);else if (t1 != \"none\") $('#transList').fadeOut(100);\n\n        if (evt.keyCode == 13) {\n            // keyup on Enter\n            n = $('#tInput').val();\n            var t = transParse(n = n);\n            if (!t) return;\n            transform(n = t.slice(0, t.length - 1), t = t[t.length - 1], typeTransform = false);\n        }\n    });\n\n    var t;\n    $('#transList li').click(function (evt) {\n        // if interact is selected, show variable list again\n        if ($(this).text() == \"interact(d,e)\") {\n            $('#tInput').val(tvar.concat('*'));\n            selInteract = true;\n            $(this).parent().fandeOut(100);\n            $('#transSel').fadeIn(100);\n            evt.stopPropagation();\n            return;\n        }\n\n        var tvar = $('#tInput').val();\n        var tfunc = $(this).text().replace(\"d\", \"_transvar0\");\n        var tcall = $(this).text().replace(\"d\", tvar);\n        $('#tInput').val(tcall);\n        $(this).parent().fadeOut(100);\n        evt.stopPropagation();\n        transform(n = tvar, t = tfunc, typeTransform = false);\n    });\n\n    d3.select(\"#models\").style('height', 2000).style('overfill', 'scroll');\n\n    d3.select(\"#models\").selectAll(\"p\").data(Object.keys(mods)).enter().append(\"p\").attr(\"id\", \"_model_\".concat).text(function (d) {\n        return d;\n    }).style('background-color', function (d) {\n        return varColor;\n    }).attr(\"data-container\", \"body\").attr(\"data-toggle\", \"popover\").attr(\"data-trigger\", \"hover\").attr(\"data-placement\", \"top\").attr(\"data-html\", \"true\").attr(\"onmouseover\", \"$(this).popover('toggle');\").attr(\"onmouseout\", \"$(this).popover('toggle');\").attr(\"data-original-title\", \"Model Description\").attr(\"data-content\", function (d) {\n        return mods[d];\n    });\n\n    // call layout() because at this point all scaffolding is up and ready\n    if (typeof callback == \"function\") {\n        callback();\n        _mithril2.default.redraw();\n    }\n}\n\nvar splice = function splice(color, text) {\n    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key2 = 2; _key2 < _len; _key2++) {\n        args[_key2 - 2] = arguments[_key2];\n    }\n\n    args.forEach(function (x) {\n        if (color != x[0]) return;\n        var idx = zparams[x[1]].indexOf(text);\n        idx > -1 && zparams[x[1]].splice(idx, 1);\n    });\n};\n\nvar clickVar = exports.clickVar = void 0;\n\nfunction layout(v) {\n    var myValues = [];\n    exports.nodes = nodes = [];\n    links = [];\n\n    if (v == layoutAdd || v == layoutMove) {\n        for (var j = 0; j < zparams.zvars.length; j++) {\n            var ii = findNodeIndex(zparams.zvars[j]);\n            if (allNodes[ii].grayout) continue;\n            nodes.push(allNodes[ii]);\n            var selectMe = zparams.zvars[j].replace(/\\W/g, \"_\");\n            selectMe = \"#\".concat(selectMe);\n            d3.select(selectMe).style('background-color', function () {\n                return hexToRgba(nodes[j].strokeColor);\n            });\n        }\n\n        for (var j = 0; j < zparams.zedges.length; j++) {\n            var mysrc = nodeIndex(zparams.zedges[j][0]);\n            var mytgt = nodeIndex(zparams.zedges[j][1]);\n            links.push({\n                source: nodes[mysrc],\n                target: nodes[mytgt],\n                left: false,\n                right: true\n            });\n        }\n    } else {\n        if (allNodes.length > 2) {\n            exports.nodes = nodes = [allNodes[0], allNodes[1], allNodes[2]];\n            links = [{\n                source: nodes[1],\n                target: nodes[0],\n                left: false,\n                right: true\n            }, {\n                source: nodes[0],\n                target: nodes[2],\n                left: false,\n                right: true\n            }];\n        } else if (allNodes.length === 2) {\n            exports.nodes = nodes = [allNodes[0], allNodes[1]];\n            links = [{\n                source: nodes[1],\n                target: nodes[0],\n                left: false,\n                right: true\n            }];\n        } else if (allNodes.length === 1) {\n            exports.nodes = nodes = [allNodes[0]];\n        } else {\n            alert(\"There are zero variables in the metadata.\");\n            return;\n        }\n    }\n\n    panelPlots(); // after nodes is populated, add subset and setx panels\n\n    var force = d3.layout.force().nodes(nodes).links(links).size([width, height]).linkDistance(150).charge(-800).on('tick', tick);\n\n    // define arrow markers for graph links\n    svg.append('svg:defs').append('svg:marker').attr('id', 'end-arrow').attr('viewBox', '0 -5 10 10').attr('refX', 6).attr('markerWidth', 3).attr('markerHeight', 3).attr('orient', 'auto').append('svg:path').attr('d', 'M0,-5L10,0L0,5').style('fill', '#000');\n\n    svg.append('svg:defs').append('svg:marker').attr('id', 'start-arrow').attr('viewBox', '0 -5 10 10').attr('refX', 4).attr('markerWidth', 3).attr('markerHeight', 3).attr('orient', 'auto').append('svg:path').attr('d', 'M10,-5L0,0L10,5').style('fill', '#000');\n\n    // line displayed when dragging new nodes\n    var drag_line = svg.append('svg:path').attr('class', 'link dragline hidden').attr('d', 'M0,0L0,0');\n\n    // handles to link and node element groups\n    var path = svg.append('svg:g').selectAll('path'),\n        circle = svg.append('svg:g').selectAll('g');\n\n    // mouse event vars\n    var selected_node = null,\n        selected_link = null,\n        mousedown_link = null,\n        mousedown_node = null,\n        mouseup_node = null;\n\n    function resetMouseVars() {\n        mousedown_node = null;\n        mouseup_node = null;\n        mousedown_link = null;\n    }\n\n    // update force layout (called automatically each iteration)\n    function tick() {\n        // draw directed edges with proper padding from node centers\n        path.attr('d', function (d) {\n            var deltaX = d.target.x - d.source.x,\n                deltaY = d.target.y - d.source.y,\n                dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY),\n                normX = deltaX / dist,\n                normY = deltaY / dist,\n                sourcePadding = d.left ? allR + 5 : allR,\n                targetPadding = d.right ? allR + 5 : allR,\n                sourceX = d.source.x + sourcePadding * normX,\n                sourceY = d.source.y + sourcePadding * normY,\n                targetX = d.target.x - targetPadding * normX,\n                targetY = d.target.y - targetPadding * normY;\n            return 'M' + sourceX + ',' + sourceY + 'L' + targetX + ',' + targetY;\n        });\n        circle.attr('transform', function (d) {\n            return 'translate(' + d.x + ',' + d.y + ')';\n        });\n    }\n\n    exports.clickVar = clickVar = function clickVar() {\n        // every time a variable in leftpanel is clicked, nodes updates and background color changes\n        if (findNodeIndex(this.id, true).grayout) return;\n        zparams.zvars = [];\n        var text = d3.select(this).text();\n        var node = findNode(text);\n        if (nodes.map(function (n) {\n            return n.name;\n        }).includes(text)) {\n            nodes.splice(node.index, 1);\n            spliceLinksForNode(node);\n            splice(node.strokeColor, text, [dvColor, 'zdv'], [csColor, 'zcross'], [timeColor, 'ztime'], [nomColor, 'znom']);\n            nodeReset(node);\n            legend();\n        } else {\n            nodes.push(node);\n            if (nodes.length === 0) nodes[0].reflexive = true;\n        }\n        panelPlots();\n        restart();\n    };\n\n    d3.select(\"#models\").selectAll(\"p\") // models tab\n    //  d3.select(\"#Display_content\")\n    .on(\"click\", function () {\n        var myColor = d3.select(this).style('background-color');\n        d3.select(\"#models\").selectAll(\"p\").style('background-color', varColor);\n        d3.select(this).style('background-color', function (d) {\n            if (d3.rgb(myColor).toString() === varColor.toString()) {\n                zparams.zmodel = d.toString();\n                return hexToRgba(_plots.selVarColor);\n            } else {\n                zparams.zmodel = '';\n                return varColor;\n            }\n        });\n        restart();\n    });\n\n    // update graph (called when needed)\n    function restart() {\n        // nodes.id is pegged to allNodes, i.e. the order in which variables are read in\n        // nodes.index is floating and depends on updates to nodes.  a variables index changes when new variables are added.\n        circle.call(force.drag);\n        if (forcetoggle[0] == \"true\") {\n            force.gravity(0.1);\n            force.charge(-800);\n            force.linkStrength(1);\n        } else {\n            force.gravity(0);\n            force.charge(0);\n            force.linkStrength(0);\n        }\n        force.resume();\n\n        // path (link) group\n        path = path.data(links);\n\n        // update existing links\n        // VJD: dashed links between pebbles are \"selected\". this is disabled for now\n        path.classed('selected', function (x) {\n            return null;\n        }).style('marker-start', function (x) {\n            return x.left ? 'url(#start-arrow)' : '';\n        }).style('marker-end', function (x) {\n            return x.right ? 'url(#end-arrow)' : '';\n        });\n\n        // add new links\n        path.enter().append('svg:path').attr('class', 'link').classed('selected', function (x) {\n            return null;\n        }).style('marker-start', function (x) {\n            return x.left ? 'url(#start-arrow)' : '';\n        }).style('marker-end', function (x) {\n            return x.right ? 'url(#end-arrow)' : '';\n        }).on('mousedown', function (d) {\n            // do we ever need to select a link? make it delete..\n            var obj = JSON.stringify(d);\n            for (var j = 0; j < links.length; j++) {\n                if (obj === JSON.stringify(links[j])) links.splice(j, 1);\n            }\n        });\n\n        // remove old links\n        path.exit().remove();\n\n        // circle (node) group\n        circle = circle.data(nodes, function (x) {\n            return x.id;\n        });\n\n        // update existing nodes (reflexive & selected visual states)\n        // d3.rgb is the function adjusting the color here\n        circle.selectAll('circle').classed('reflexive', function (x) {\n            return x.reflexive;\n        }).style('fill', function (x) {\n            return d3.rgb(x.nodeCol);\n        }).style('stroke', function (x) {\n            return d3.rgb(x.strokeColor);\n        }).style('stroke-width', function (x) {\n            return x.strokeWidth;\n        });\n\n        // add new nodes\n        var g = circle.enter().append('svg:g').attr('id', function (x) {\n            return x.name + 'biggroup';\n        });\n\n        // add plot\n        g.each(function (d) {\n            d3.select(this);\n            if (d.plottype == 'continuous') (0, _plots.densityNode)(d, this);else if (d.plottype == 'bar') (0, _plots.barsNode)(d, this);\n        });\n\n        var append = function append(str, attr) {\n            return function (x) {\n                return str + x[attr || 'id'];\n            };\n        };\n\n        g.append(\"path\").attr(\"id\", append('dvArc')).attr(\"d\", arc3).style(\"fill\", dvColor).attr(\"fill-opacity\", 0).on('mouseover', function (d) {\n            fillThis(this, .3, 0, 100);\n            fill(d, 'dvText', .9, 0, 100);\n        }).on('mouseout', function (d) {\n            fillThis(this, 0, 100, 500);\n            fill(d, 'dvText', 0, 100, 500);\n        }).on('click', function (d) {\n            setColors(d, dvColor);\n            legend(dvColor);\n            restart();\n        });\n\n        g.append(\"text\").attr(\"id\", append('dvText')).attr(\"x\", 6).attr(\"dy\", 11.5).attr(\"fill-opacity\", 0).append(\"textPath\").attr(\"xlink:href\", append('#dvArc')).text(\"Dep Var\");\n\n        g.append(\"path\").attr(\"id\", append('nomArc')).attr(\"d\", arc4).style(\"fill\", nomColor).attr(\"fill-opacity\", 0).on('mouseover', function (d) {\n            if (d.defaultNumchar == \"character\") return;\n            fillThis(this, .3, 0, 100);\n            fill(d, \"nomText\", .9, 0, 100);\n        }).on('mouseout', function (d) {\n            if (d.defaultNumchar == \"character\") return;\n            fillThis(this, 0, 100, 500);\n            fill(d, \"nomText\", 0, 100, 500);\n        }).on('click', function (d) {\n            if (d.defaultNumchar == \"character\") return;\n            setColors(d, nomColor);\n            legend(nomColor);\n            restart();\n        });\n\n        g.append(\"text\").attr(\"id\", append(\"nomText\")).attr(\"x\", 6).attr(\"dy\", 11.5).attr(\"fill-opacity\", 0).append(\"textPath\").attr(\"xlink:href\", append(\"#nomArc\")).text(\"Nominal\");\n\n        g.append('svg:circle').attr('class', 'node').attr('r', allR).style('pointer-events', 'inherit').style('fill', function (d) {\n            return d.nodeCol;\n        }).style('opacity', \"0.5\").style('stroke', function (d) {\n            return d3.rgb(d.strokeColor).toString();\n        }).classed('reflexive', function (d) {\n            return d.reflexive;\n        }).on('dblclick', function (_) {\n            d3.event.stopPropagation(); // stop click from bubbling\n            exports.summaryHold = summaryHold = true;\n        }).on('contextmenu', function (d) {\n            // right click on node\n            d3.event.preventDefault();\n            d3.event.stopPropagation();\n\n            rightClickLast = true;\n            mousedown_node = d;\n            selected_node = mousedown_node === selected_node ? null : mousedown_node;\n            selected_link = null;\n\n            // reposition drag line\n            drag_line.style('marker-end', 'url(#end-arrow)').classed('hidden', false).attr('d', 'M' + mousedown_node.x + ',' + mousedown_node.y + 'L' + mousedown_node.x + ',' + mousedown_node.y);\n\n            svg.on('mousemove', mousemove);\n            restart();\n        }).on('mouseup', function (d) {\n            d3.event.stopPropagation();\n\n            if (rightClickLast) {\n                rightClickLast = false;\n                return;\n            }\n            if (!mousedown_node) return;\n\n            // needed by FF\n            drag_line.classed('hidden', true).style('marker-end', '');\n\n            // check for drag-to-self\n            mouseup_node = d;\n            if (mouseup_node === mousedown_node) {\n                resetMouseVars();\n                return;\n            }\n\n            // unenlarge target node\n            d3.select(this).attr('transform', '');\n\n            // add link to graph (update if exists)\n            // NB: links are strictly source < target; arrows separately specified by booleans\n            var source, target, direction;\n            if (mousedown_node.id < mouseup_node.id) {\n                source = mousedown_node;\n                target = mouseup_node;\n                direction = 'right';\n            } else {\n                source = mouseup_node;\n                target = mousedown_node;\n                direction = 'left';\n            }\n\n            var link = links.filter(function (x) {\n                return x.source == source && x.target == target;\n            })[0];\n            if (link) {\n                link[direction] = true;\n            } else {\n                link = {\n                    source: source,\n                    target: target,\n                    left: false,\n                    right: false\n                };\n                link[direction] = true;\n                links.push(link);\n            }\n\n            // select new link\n            selected_link = link;\n            selected_node = null;\n            svg.on('mousemove', null);\n\n            resetMouseVars();\n            restart();\n        });\n\n        // show node names\n        g.append('svg:text').attr('x', 0).attr('y', 15).attr('class', 'id').text(function (d) {\n            return d.name;\n        });\n\n        // show summary stats on mouseover\n        // SVG doesn't support text wrapping, use html instead\n        g.selectAll(\"circle.node\").on(\"mouseover\", function (d) {\n            tabLeft('tab3');\n            varSummary(d);\n\n            byId('transformations').setAttribute('style', 'display:block');\n            byId(\"transSel\").selectedIndex = d.id;\n            transformVar = valueKey[d.id];\n\n            fill(d, \"dvArc\", .1, 0, 100);\n            fill(d, \"dvText\", .5, 0, 100);\n            if (d.defaultNumchar == \"numeric\") {\n                fill(d, \"nomArc\", .1, 0, 100);\n                fill(d, \"nomText\", .5, 0, 100);\n            }\n            fill(d, \"csArc\", .1, 0, 100);\n            fill(d, \"csText\", .5, 0, 100);\n            fill(d, \"timeArc\", .1, 0, 100);\n            fill(d, \"timeText\", .5, 0, 100);\n\n            _mithril2.default.redraw();\n        }).on('mouseout', function (d) {\n            summaryHold || tabLeft(subset ? 'tab2' : 'tab1');\n            'csArc csText timeArc timeText dvArc dvText nomArc nomText'.split(' ').map(function (x) {\n                return fill(d, x, 0, 100, 500);\n            });\n            _mithril2.default.redraw();\n        });\n\n        // the transformation variable list is silently updated as pebbles are added/removed\n        d3.select(\"#transSel\").selectAll('li').remove();\n\n        d3.select(\"#transSel\").selectAll('li').data(nodes.map(function (x) {\n            return x.name;\n        })) // set to variables in model space as they're added\n        .enter().append(\"li\").text(function (d) {\n            return d;\n        });\n\n        $('#transSel li').click(function (evt) {\n            // if 'interaction' is the selected function, don't show the function list again\n            if (selInteract) {\n                var n = $('#tInput').val().concat($(this).text());\n                $('#tInput').val(n);\n                evt.stopPropagation();\n                var t = transParse(n = n);\n                if (!t) return;\n                $(this).parent().fadeOut(100);\n                transform(n = t.slice(0, t.length - 1), t = t[t.length - 1], typeTransform = false);\n                return;\n            }\n\n            $('#tInput').val($(this).text());\n            $(this).parent().fadeOut(100);\n            $('#transList').fadeIn(100);\n            evt.stopPropagation();\n        });\n\n        // remove old nodes\n        circle.exit().remove();\n        force.start();\n    }\n\n    function mousedown(d) {\n        // prevent I-bar on drag\n        d3.event.preventDefault();\n        // because :active only works in WebKit?\n        svg.classed('active', true);\n        if (d3.event.ctrlKey || mousedown_node || mousedown_link) return;\n        restart();\n    }\n\n    function mousemove(d) {\n        if (!mousedown_node) return;\n        // update drag line\n        drag_line.attr('d', 'M' + mousedown_node.x + ',' + mousedown_node.y + 'L' + d3.mouse(this)[0] + ',' + d3.mouse(this)[1]);\n    }\n\n    function mouseup(d) {\n        if (mousedown_node) {\n            drag_line.classed('hidden', true).style('marker-end', '');\n        }\n        // because :active only works in WebKit?\n        svg.classed('active', false);\n        // clear mouse event vars\n        resetMouseVars();\n    }\n\n    // app starts here\n    svg.attr('id', function () {\n        return \"whitespace\".concat(myspace);\n    }).attr('height', height).on('mousedown', function () {\n        mousedown(this);\n    }).on('mouseup', function () {\n        mouseup(this);\n    });\n\n    d3.select(window).on('click', function () {\n        // all clicks will bubble here unless event.stopPropagation()\n        $('#transList').fadeOut(100);\n        $('#transSel').fadeOut(100);\n    });\n\n    restart(); // initializes force.layout()\n    fakeClick();\n}\n\nvar find = function find($nodes, name) {\n    for (var i in $nodes) {\n        if ($nodes[i].name == name) return $nodes[i].id;\n    }\n};\n\n// returns id\nvar findNodeIndex = exports.findNodeIndex = function findNodeIndex(name, all) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n        for (var _iterator = allNodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var node = _step.value;\n\n            if (node.name === name) {\n                //cdb('Yes!' + allNodes[i].id);\n                return all ? node : node.id;\n            }\n        }\n    } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n            }\n        } finally {\n            if (_didIteratorError) {\n                throw _iteratorError;\n            }\n        }\n    }\n};\n\nvar nodeIndex = function nodeIndex(nodeName) {\n    for (var i in nodes) {\n        if (nodes[i].name == nodeName) return i;\n    }\n};\n\nvar findNode = exports.findNode = function findNode(nodeName) {\n    for (var i in allNodes) {\n        if (allNodes[i].name == nodeName) return allNodes[i];\n    }\n};\n\n/*\n    Retrieve the variable list from the preprocess data.\n    This helps handle the new format and (temporarily)\n    the older format in production (rp 8.14.2017)\n */\nfunction getVariableData(jsonData) {\n    /* \"new\" response:\n    {\n        \"dataset\" : {...}\n        \"variables\" : {\n            \"var1\" : {...}, (etc)\n        }\n    }\n    \"old\" response\n    {\n         \"var1\" : {...},\n         (etc)\n    }*/\n    return jsonData.hasOwnProperty('variables') ? jsonData.variables : jsonData;\n}\n\n// function called by force button\nfunction forceSwitch() {\n    forcetoggle = [forcetoggle[0] == 'true' ? 'false' : 'true'];\n    if (forcetoggle[0] === \"false\") {\n        byId('btnForce').setAttribute(\"class\", \"btn active\");\n    } else {\n        byId('btnForce').setAttribute(\"class\", \"btn btn-default\");\n        fakeClick();\n    }\n}\n\nvar spliceLinksForNode = exports.spliceLinksForNode = function spliceLinksForNode(node) {\n    return links.filter(function (l) {\n        return l.source === node || l.target === node;\n    }).map(function (x) {\n        return links.splice(links.indexOf(x), 1);\n    });\n};\n\nfunction zPop() {\n    if (dataurl) zparams.zdataurl = dataurl;\n    zparams.zmodelcount = modelCount;\n    zparams.zedges = [];\n    zparams.zvars = [];\n    for (var j = 0; j < nodes.length; j++) {\n        //populate zvars array\n        zparams.zvars.push(nodes[j].name);\n        var temp = nodes[j].id;\n        zparams.zsetx[j] = allNodes[temp].setxvals;\n        zparams.zsubset[j] = allNodes[temp].subsetrange;\n    }\n    for (var _j = 0; _j < links.length; _j++) {\n        //populate zedges array\n        //correct the source target ordering for Zelig\n        var srctgt = links[_j].left == false ? [links[_j].source.name, links[_j].target.name] : [links[_j].target.name, links[_j].source.name];\n        zparams.zedges.push(srctgt);\n    }\n}\n\nfunction estimate(btn) {\n    if (production && zparams.zsessionid == '') {\n        alert(\"Warning: Data download is not complete. Try again soon.\");\n        return;\n    }\n\n    zPop();\n    // write links to file & run R CMD\n    // package the output as JSON\n    // add call history and package the zparams object as JSON\n    zparams.callHistory = callHistory;\n    var jsonout = JSON.stringify(zparams);\n\n    var urlcall = rappURL + \"zeligapp\"; //base.concat(jsonout);\n    var solajsonout = \"solaJSON=\" + jsonout;\n    cdb(\"urlcall out: \", urlcall);\n    cdb(\"POST out: \", solajsonout);\n\n    zparams.allVars = valueKey.slice(10, 25); // because the URL is too long...\n    jsonout = JSON.stringify(zparams);\n    var selectorurlcall = rappURL + \"selectorapp\";\n\n    function estimateSuccess(btn, json) {\n        estimateLadda.stop(); // stop spinner\n        allResults.push(json);\n        cdb(\"json in: \", json);\n\n        if (!estimated) byId(\"results\").removeChild(byId(\"resultsHolder\"));\n\n        estimated = true;\n        d3.select(\"#results\").style(\"display\", \"block\");\n\n        d3.select(\"#resultsView\").style(\"display\", \"block\");\n\n        d3.select(\"#modelView\").style(\"display\", \"block\");\n\n        // programmatic click on Results button\n        $(\"#btnResults\").trigger(\"click\");\n\n        var model = \"Model\".concat(modelCount = modelCount + 1);\n\n        function modCol() {\n            d3.select(\"#modelView\").selectAll(\"p\").style('background-color', hexToRgba(varColor));\n        }\n        modCol();\n\n        d3.select(\"#modelView\").insert(\"p\", \":first-child\") // top stack for results\n        .attr(\"id\", model).text(model).style('background-color', hexToRgba(_plots.selVarColor)).on(\"click\", function () {\n            var a = this.style.backgroundColor.replace(/\\s*/g, \"\");\n            var b = hexToRgba(_plots.selVarColor).replace(/\\s*/g, \"\");\n            if (a.substr(0, 17) == b.substr(0, 17)) return; // escape function if displayed model is clicked\n            modCol();\n            d3.select(this).style('background-color', hexToRgba(_plots.selVarColor));\n            viz(this.id);\n        });\n\n        var rCall = [];\n        rCall[0] = json.call;\n        showLog(\"estimate\", rCall);\n\n        viz(model);\n    }\n\n    function estimateFail(btn) {\n        estimateLadda.stop(); // stop spinner\n        estimated = true;\n    }\n\n    function selectorSuccess(btn, json) {\n        d3.select(\"#ticker\").text(\"Suggested variables and percent improvement on RMSE: \" + json.vars);\n        cdb(\"selectorSuccess: \", json);\n    }\n\n    function selectorFail(btn) {\n        alert(\"Selector Fail\");\n    }\n\n    estimateLadda.start(); // start spinner\n    makeCorsRequest(urlcall, btn, estimateSuccess, estimateFail, solajsonout);\n}\n\nfunction dataDownload() {\n    zPop();\n    // write links to file & run R CMD\n\n    //package the output as JSON\n    // add call history and package the zparams object as JSON\n    var jsonout = JSON.stringify(zparams);\n    var btn = \"nobutton\";\n\n    var urlcall = rappURL + \"dataapp\";\n    var solajsonout = \"solaJSON=\" + jsonout;\n    cdb(\"urlcall out: \", urlcall);\n    cdb(\"POST out: \", solajsonout);\n\n    var downloadSuccess = function downloadSuccess(btn, json) {\n        cdb('dataDownload json in: ', json);\n        zparams.zsessionid = json.sessionid[0];\n        // set link URL\n        byId(\"logID\").href = '' + (production ? rappURL + 'log_dir/log_' : 'rook/log_') + zparams.zsessionid + '.txt';\n    };\n    var downloadFail = function downloadFail(_) {\n        return cdb('Data have not been downloaded');\n    };\n    makeCorsRequest(urlcall, btn, downloadSuccess, downloadFail, solajsonout);\n}\n\nfunction viz(mym) {\n    var mym = +mym.substr(5, 5) - 1;\n\n    function removeKids(parent) {\n        while (parent.firstChild) {\n            parent.removeChild(parent.firstChild);\n        }\n    }\n\n    removeKids(byId(\"resultsView\"));\n\n    var json = allResults[mym];\n\n    // pipe in figures to right panel\n    var filelist = new Array();\n    for (var i in json.images) {\n        var zfig = document.createElement(\"img\");\n        zfig.setAttribute(\"src\", json.images[i]);\n        zfig.setAttribute('width', 200);\n        zfig.setAttribute('height', 200);\n        byId(\"resultsView\").appendChild(zfig);\n    }\n\n    // write the results table\n    var resultsArray = [];\n    for (var key in json.sumInfo) {\n        if (key == 'colnames') continue;\n        resultsArray.push(json.sumInfo[key]);\n    }\n\n    var table = d3.select(\"#resultsView\").append(\"p\").append(\"table\");\n\n    var thead = table.append(\"thead\");\n    thead.append(\"tr\").selectAll(\"th\").data(json.sumInfo.colnames).enter().append(\"th\").text(function (d) {\n        return d;\n    });\n\n    var tbody = table.append(\"tbody\");\n    tbody.selectAll(\"tr\").data(resultsArray).enter().append(\"tr\").selectAll(\"td\").data(function (d) {\n        return d;\n    }).enter().append(\"td\").text(function (d) {\n        var myNum = Number(d);\n        if (isNaN(myNum)) return d;\n        return myNum.toPrecision(3);\n    }).on(\"mouseover\", function () {\n        d3.select(this).style(\"background-color\", \"aliceblue\");\n    }) // for no discernable reason\n    .on(\"mouseout\", function () {\n        d3.select(this).style(\"background-color\", \"#F9F9F9\");\n    }); //(but maybe we'll think of one)\n\n    d3.select(\"#resultsView\").append(\"p\").html(function () {\n        return \"<b>Formula: </b>\".concat(json.call[0]);\n    });\n\n    _mithril2.default.redraw();\n}\n\n// parses the transformation input. variable names are often nested inside one another, e.g., ethwar, war, wars, and so this is handled\nfunction transParse(n) {\n    var out2 = [];\n    var t2 = n;\n    var k2 = 0;\n    var subMe2 = \"_transvar\".concat(k2);\n    var indexed = [];\n\n    // out2 is all matched variables, indexed is an array, each element is an object that contains the matched variables starting index and finishing index.  e.g., n=\"wars+2\", out2=[war, wars], indexed=[{0,2},{0,3}]\n    for (var i in valueKey) {\n        var m2 = n.match(valueKey[i]);\n        if (m2 != null) out2.push(m2[0]);\n\n        var re = new RegExp(valueKey[i], \"g\");\n        var s = n.search(re);\n        if (s != -1) indexed.push({ from: s, to: s + valueKey[i].length });\n    }\n\n    // nested loop not good, but indexed is not likely to be very large.\n    // if a variable is nested, it is removed from out2\n    // notice, loop is backwards so that index changes don't affect the splice\n    cdb(\"indexed \", indexed);\n    for (var i = indexed.length - 1; i > -1; i--) {\n        for (var j = indexed.length - 1; j > -1; j--) {\n            if (i === j) continue;\n            if (indexed[i].from >= indexed[j].from & indexed[i].to <= indexed[j].to) {\n                cdb(i, \" is nested in \", j);\n                out2.splice(i, 1);\n            }\n        }\n    }\n\n    for (var i in out2) {\n        t2 = t2.replace(out2[i], subMe2); //something that'll never be a variable name\n        k2 = k2 + 1;\n        subMe2 = \"_transvar\".concat(k2);\n    }\n\n    if (out2.length > 0) {\n        out2.push(t2);\n        cdb(\"new out \", out2);\n        return out2;\n    } else {\n        alert(\"No variable name found. Perhaps check your spelling?\");\n        return null;\n    }\n}\n\n/**\n  n = name of column/node\n  t = selected transformation\n */\nfunction transform(n, t, typeTransform) {\n    if (production && zparams.zsessionid == \"\") {\n        alert(\"Warning: Data download is not complete. Try again soon.\");\n        return;\n    }\n    if (!typeTransform) t = t.replace(\"+\", \"_plus_\"); // can't send the plus operator\n\n    cdb('name of col: ' + n);\n    cdb('transformation: ' + t);\n\n    var btn = byId('btnEstimate');\n\n    // find the node by name\n    var myn = findNodeIndex(n[0], true);\n\n    if (typeof myn === \"undefined\") {\n        myn = findNodeIndex(n, true);\n    }\n\n    var outtypes = {\n        varnamesTypes: n,\n        interval: myn.interval,\n        numchar: myn.numchar,\n        nature: myn.nature,\n        binary: myn.binary\n    };\n\n    cdb(myn);\n    // if typeTransform but we already have the metadata\n    if (typeTransform) {\n        if (myn.nature == \"nominal\" & typeof myn.plotvalues !== \"undefined\") {\n            myn.plottype = \"bar\";\n            (0, _plots.barsNode)(myn);\n            panelPlots();\n            return;\n        } else if (myn.nature != \"nominal\" & typeof myn.plotx !== \"undefined\") {\n            myn.plottype = \"continuous\";\n            (0, _plots.densityNode)(myn);\n            panelPlots();\n            return;\n        }\n    }\n\n    //package the output as JSON\n    var transformstuff = {\n        zdataurl: dataurl,\n        zvars: myn.name,\n        zsessionid: zparams.zsessionid,\n        transform: t,\n        callHistory: callHistory,\n        typeTransform: typeTransform,\n        typeStuff: outtypes\n    };\n    var jsonout = JSON.stringify(transformstuff);\n    var urlcall = rappURL + \"transformapp\";\n    var solajsonout = \"solaJSON=\" + jsonout;\n    cdb(\"urlcall out: \" + urlcall);\n    cdb(\"POST out: \" + solajsonout);\n\n    function transformSuccess(btn, json) {\n        estimateLadda.stop();\n        cdb(\"json in: \" + JSON.stringify(json));\n\n        // Is this a typeTransform?\n        if (json.typeTransform[0]) {\n            // Yes. We're updating an existing node\n            d3.json(json.url, function (err, data) {\n                if (err) return console.warn(err);\n                var node = void 0;\n                for (var key in data) {\n                    node = findNodeIndex(key, true);\n                    if (!node) continue;\n                    jQuery.extend(true, node, data[key]);\n                    node.plottype === \"continuous\" ? (0, _plots.densityNode)(node) : node.plottype === \"bar\" ? (0, _plots.barsNode)(node) : null;\n                }\n                fakeClick();\n                panelPlots();\n                node && cdb(node);\n            });\n        } else {\n            /* No, we have a new node here--e.g. the transformed column\n                 example response: {\n                 \"call\":[\"t_year_2\"],\n                 \"url\":[\"data/preprocessSubset_BACCBC78-7DD9-4482-B31D-6EB01C3A0C95.txt\"],\n                 \"trans\":[\"year\",\"_transvar0^2\"],\n                 \"typeTransform\":[false]\n               }\n            */\n            callHistory.push({\n                func: \"transform\",\n                zvars: n,\n                transform: t\n            });\n\n            var subseted = false;\n            var rCall = [];\n\n            rCall[0] = json.call;\n            var newVar = rCall[0][0];\n\n            trans.push(newVar);\n\n            // Read the preprocess file containing values\n            // for the transformed variable\n            //\n            d3.json(json.url, function (error, json) {\n                if (error) return console.warn(error);\n\n                var jsondata = getVariableData(json);\n\n                for (var key in jsondata) {\n                    var myIndex = findNodeIndex(key);\n                    if (typeof myIndex !== \"undefined\") {\n                        alert(\"Invalid transformation: this variable name already exists.\");\n                        return;\n                    }\n                    // add transformed variable to the current space\n                    var i = allNodes.length; // get new index\n                    var obj1 = {\n                        id: i,\n                        reflexive: false,\n                        name: key,\n                        labl: \"transformlabel\",\n                        data: [5, 15, 20, 0, 5, 15, 20],\n                        count: [.6, .2, .9, .8, .1, .3, .4],\n                        nodeCol: colors(i),\n                        baseCol: colors(i),\n                        strokeColor: _plots.selVarColor,\n                        strokeWidth: \"1\",\n                        subsetplot: false,\n                        subsetrange: [\"\", \"\"],\n                        setxplot: false,\n                        setxvals: [\"\", \"\"],\n                        grayout: false,\n                        defaultInterval: jsondata[key].interval,\n                        defaultNumchar: jsondata[key].numchar,\n                        defaultNature: jsondata[key].nature,\n                        defaultBinary: jsondata[key].binary\n                    };\n\n                    jQuery.extend(true, obj1, jsondata[key]);\n                    allNodes.push(obj1);\n\n                    valueKey.push(newVar);\n                    nodes.push(allNodes[i]);\n                    fakeClick();\n                    panelPlots();\n\n                    if (allNodes[i].plottype === \"continuous\") {\n                        (0, _plots.densityNode)(allNodes[i]);\n                    } else if (allNodes[i].plottype === \"bar\") {\n                        (0, _plots.barsNode)(allNodes[i]);\n                    }\n\n                    _mithril2.default.redraw();\n                }\n            });\n\n            showLog('transform', rCall);\n        }\n    }\n\n    function transformFail(btn) {\n        alert(\"transform fail\");\n        estimateLadda.stop();\n    }\n\n    estimateLadda.start(); // start spinner\n    makeCorsRequest(urlcall, btn, transformSuccess, transformFail, solajsonout);\n}\n\n// below from http://www.html5rocks.com/en/tutorials/cors/ for cross-origin resource sharing\n// Create the XHR object.\nfunction createCORSRequest(method, url, callback) {\n    var xhr = new XMLHttpRequest();\n    if (\"withCredentials\" in xhr) {\n        // XHR for Chrome/Firefox/Opera/Safari.\n        xhr.open(method, url, true);\n    } else if (typeof XDomainRequest != \"undefined\") {\n        // XDomainRequest for IE.\n        xhr = new XDomainRequest();\n        xhr.open(method, url);\n    } else {\n        // CORS not supported.\n        xhr = null;\n    }\n    // xhr.setRequestHeader('Content-Type', 'text/plain');\n    xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n    return xhr;\n}\n\n// Make the actual CORS request.\nfunction makeCorsRequest(url, btn, callback, warningcallback, jsonstring) {\n    var xhr = createCORSRequest('POST', url);\n    if (!xhr) {\n        alert('CORS not supported');\n        return;\n    }\n    // Response handlers for asynchronous load\n    // onload or onreadystatechange?\n\n    xhr.onload = function () {\n        var text = xhr.responseText;\n        cdb(\"text \", text);\n\n        try {\n            var json = JSON.parse(text); // should wrap in try / catch\n            var names = Object.keys(json);\n        } catch (err) {\n            estimateLadda.stop();\n            selectLadda.stop();\n            cdb(err);\n            alert('Error: Could not parse incoming JSON.');\n        }\n\n        if (names[0] == \"warning\") {\n            warningcallback(btn);\n            alert(\"Warning: \" + json.warning);\n        } else {\n            callback(btn, json);\n        }\n    };\n    xhr.onerror = function () {\n        // note: xhr.readystate should be 4 and status should be 200. a status of 0 occurs when the url is too large\n        xhr.status == 0 ? alert('There was an error making the request. xmlhttprequest status is 0.') : xhr.readyState != 4 ? alert('There was an error making the request. xmlhttprequest readystate is not 4.') : alert('Woops, there was an error making the request.');\n        cdb(xhr);\n        estimateLadda.stop();\n        selectLadda.stop();\n    };\n    xhr.send(jsonstring);\n}\n\nvar legend = exports.legend = function legend(_) {\n    borderState();\n    _mithril2.default.redraw();\n};\n\n// programmatically deselect every selected variable\nfunction erase() {\n    leftpanelMedium();\n    rightpanelMedium();\n    tabLeft('tab1');\n    jQuery.fn.d3Click = function () {\n        this.children().each(function (i, e) {\n            var mycol = d3.rgb(this.style.backgroundColor);\n            if (mycol.toString() === varColor.toString()) return;\n            var evt = document.createEvent(\"MouseEvents\");\n            evt.initMouseEvent(\"click\", true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);\n            e.dispatchEvent(evt);\n        });\n    };\n    $(\"#varList\").d3Click();\n}\n\n// http://www.tutorials2learn.com/tutorials/scripts/javascript/xml-parser-javascript.html\nfunction loadXMLDoc(XMLname) {\n    var xmlDoc;\n    if (window.XMLHttpRequest) {\n        xmlDoc = new window.XMLHttpRequest();\n        xmlDoc.open(\"GET\", XMLname, false);\n        xmlDoc.send(\"\");\n        return xmlDoc.responseXML;\n    }\n    // IE 5 and IE 6\n    else if (ActiveXObject(\"Microsoft.XMLDOM\")) {\n            xmlDoc = new ActiveXObject(\"Microsoft.XMLDOM\");\n            xmlDoc.async = false;\n            xmlDoc.load(XMLname);\n            return xmlDoc;\n        }\n    alert(\"Error loading document!\");\n}\n\nfunction tabLeft(tab) {\n    byId('tab1').style.display = 'none';\n    byId('tab2').style.display = 'none';\n    byId('tab3').style.display = 'none';\n    byId(tab).style.display = 'block';\n    if (tab != 'tab3') {\n        exports.subset = subset = tab == 'tab2';\n        exports.summaryHold = summaryHold = false;\n    }\n    exports.lefttab = lefttab = tab;\n}\n\nfunction tabRight(tabid) {\n\n    var cls = \"sidepanel container clearfix\";\n    var select = function select(cls) {\n        var panel = d3.select(\"#rightpanel\");\n        return cls ? panel.attr('class', cls) : panel.attr('class');\n    };\n\n    var toggleR = function toggleR() {\n        select(function () {\n            var expand = cls + ' expandpanel';\n            return this.getAttribute(\"class\") === expand ? cls : expand;\n        });\n    };\n\n    if (tabid == \"btnModels\") select(cls);else if (tabid == \"btnSetx\") righttab == \"btnSetx\" || select() == cls && toggleR();else if (tabid == \"btnResults\") !estimated ? select(cls) : righttab == \"btnResults\" || select() == cls ? toggleR() : null;\n\n    exports.righttab = righttab = tabid;\n}\n\nvar summary = exports.summary = { data: [] };\n\nfunction varSummary(d) {\n    var t1 = 'Mean:, Median:, Most Freq:, Occurrences:, Median Freq:, Occurrences:, Least Freq:, Occurrences:, Std Dev:, Minimum:, Maximum:, Invalid:, Valid:, Uniques:, Herfindahl'.split(', ');\n\n    var rint = d3.format('r');\n    var str = function str(x, p) {\n        return (+x).toPrecision(p || 4).toString();\n    };\n    var t2 = priv && d.meanCI ? [str(d.mean, 2) + ' (' + str(d.meanCI.lowerBound, 2) + ' - ' + str(d.meanCI.upperBound, 2) + ')', str(d.median), d.mode, rint(d.freqmode), d.mid, rint(d.freqmid), d.fewest, rint(d.freqfewest), str(d.sd), str(d.min), str(d.max), rint(d.invalid), rint(d.valid), rint(d.uniques), str(d.herfindahl)] : [str(d.mean), str(d.median), d.mode, rint(d.freqmode), d.mid, rint(d.freqmid), d.fewest, rint(d.freqfewest), str(d.sd), str(d.min), str(d.max), rint(d.invalid), rint(d.valid), rint(d.uniques), str(d.herfindahl)];\n\n    summary.data = [];\n    t1.forEach(function (e, i) {\n        return !t2[i].includes('NaN') && t2[i] != 'NA' && t2[i] != '' && summary.data.push([e, t2[i]]);\n    });\n\n    summary.name = d.name;\n    summary.labl = d.labl;\n\n    d3.select('#tab3').selectAll('svg').remove();\n\n    if (!d.plottype) return;\n    d.plottype == 'continuous' ? (0, _plots.density)(d, 'varSummary', priv) : d.plottype == \"bar\" ? (0, _plots.bars)(d, 'varSummary', priv) : d3.select(\"#tab3\") // no graph to draw, but still need to remove previous graph\n    .selectAll(\"svg\").remove();\n}\n\nvar popoverContent = exports.popoverContent = function popoverContent(d) {\n    var text = '';\n    var _ref2 = [d3.format('r'), function (val, int) {\n        return (+val).toPrecision(int).toString();\n    }],\n        rint = _ref2[0],\n        prec = _ref2[1];\n\n    var div = function div(field, name, val) {\n        if (field != 'NA') text += '<div class=\\'form-group\\'><label class=\\'col-sm-4 control-label\\'>' + name + '</label><div class=\\'col-sm-6\\'><p class=\\'form-control-static\\'>' + (val || field) + '</p></div></div>';\n    };\n    d.labl != '' && div(d.labl, 'Label');\n    div(d.mean, 'Mean', priv && d.meanCI ? prec(d.mean, 2) + ' (' + prec(d.meanCI.lowerBound, 2) + ' - ' + prec(d.meanCI.upperBound, 2) + ')' : prec(d.mean, 4));\n    div(d.median, 'Median', prec(d.median, 4));\n    div(d.mode, 'Most Freq');\n    div(d.freqmode, 'Occurrences', rint(d.freqmode));\n    div(d.mid, 'Median Freq');\n    div(d.freqmid, 'Occurrences', rint(d.freqmid));\n    div(d.fewest, 'Least Freq');\n    div(d.freqfewest, 'Occurrences', rint(d.freqfewest));\n    div(d.sd, 'Stand Dev', prec(d.sd, 4));\n    div(d.max, 'Maximum', prec(d.max, 4));\n    div(d.min, 'Minimum', prec(d.min, 4));\n    div(d.invalid, 'Invalid', rint(d.invalid));\n    div(d.valid, 'Valid', rint(d.valid));\n    div(d.uniques, 'Uniques', rint(d.uniques));\n    div(d.herfindahl, 'Herfindahl', prec(d.herfindahl, 4));\n    return text;\n};\n\nfunction popupX(d) {\n    var tsf = d3.format(\".4r\");\n    var rint = d3.format(\"r\");\n    //Create the tooltip label\n    d3.select(\"#tooltip\").style(\"left\", tempX + \"px\").style(\"top\", tempY + \"px\").select(\"#tooltiptext\").html(\"<div class='form-group'><label class='col-sm-4 control-label'>Mean</label><div class='col-sm-6'><p class='form-control-static'>\" + tsf(d.mean) + \"</p></div></div>\" + \"<div class='form-group'><label class='col-sm-4 control-label'>Median</label><div class='col-sm-6'><p class='form-control-static'>\" + tsf(d.median) + \"</p></div></div>\" + \"<div class='form-group'><label class='col-sm-4 control-label'>Mode</label><div class='col-sm-6'><p class='form-control-static'>\" + d.mode + \"</p></div></div>\" + \"<div class='form-group'><label class='col-sm-4 control-label'>Stand Dev</label><div class='col-sm-6'><p class='form-control-static'>\" + tsf(d.sd) + \"</p></div></div>\" + \"<div class='form-group'><label class='col-sm-4 control-label'>Maximum</label><div class='col-sm-6'><p class='form-control-static'>\" + tsf(d.max) + \"</p></div></div>\" + \"<div class='form-group'><label class='col-sm-4 control-label'>Minimum</label><div class='col-sm-6'><p class='form-control-static'>\" + tsf(d.min) + \"</p></div></div>\" + \"<div class='form-group'><label class='col-sm-4 control-label'>Valid</label><div class='col-sm-6'><p class='form-control-static'>\" + rint(d.valid) + \"</p></div></div>\" + \"<div class='form-group'><label class='col-sm-4 control-label'>Invalid</label><div class='col-sm-6'><p class='form-control-static'>\" + rint(d.invalid) + \"</p></div></div>\");\n}\n\nfunction panelPlots() {\n    // build arrays from nodes in main\n    var vars = [];\n    var ids = [];\n    nodes.forEach(function (n) {\n        vars.push(n.name.replace(/\\(|\\)/g, ''));\n        ids.push(n.id);\n    });\n\n    //remove all plots, could be smarter here\n    d3.select('#setx').selectAll('svg').remove();\n    d3.select('#tab2').selectAll('svg').remove();\n    for (var i = 0; i < vars.length; i++) {\n        var node = allNodes[ids[i]];\n        node.setxplot = false;\n        node.subsetplot = false;\n        if (node.plottype === \"continuous\" & node.setxplot == false) {\n            node.setxplot = true;\n            (0, _plots.density)(node, div = \"setx\", priv);\n            node.subsetplot = true;\n            (0, _plots.density)(node, div = \"subset\", priv);\n        } else if (node.plottype === \"bar\" & node.setxplot == false) {\n            node.setxplot = true;\n            (0, _plots.bars)(node, div = \"setx\", priv);\n            node.subsetplot = true;\n            (0, _plots.barsSubset)(node);\n        }\n    }\n\n    d3.select(\"#setx\").selectAll(\"svg\").each(function () {\n        d3.select(this);\n        var regstr = /(.+)_setx_(\\d+)/;\n        var myname = regstr.exec(this.id);\n        var nodeid = myname[2];\n        myname = myname[1];\n        if (!vars.includes(myname)) {\n            allNodes[nodeid].setxplot = false;\n            var temp = \"#\".concat(myname, \"_setx_\", nodeid);\n            d3.select(temp).remove();\n            allNodes[nodeid].subsetplot = false;\n            temp = \"#\".concat(myname, \"_tab2_\", nodeid);\n            d3.select(temp).remove();\n        }\n    });\n}\n\n// easy functions to collapse panels to base\nfunction rightpanelMedium() {\n    d3.select(\"#rightpanel\").attr(\"class\", \"sidepanel container clearfix\");\n}\n\nfunction leftpanelMedium() {\n    d3.select(\"#leftpanel\").attr(\"class\", \"sidepanel container clearfix\");\n}\n\n// converts color codes\nvar hexToRgba = exports.hexToRgba = function hexToRgba(hex) {\n    var int = parseInt(hex.replace('#', ''), 16);\n    return 'rgba(' + [int >> 16 & 255, int >> 8 & 255, int & 255, '0.5'].join(',') + ')';\n};\n\n// takes node and color and updates zparams\nfunction setColors(n, c) {\n    if (n.strokeWidth == '1') {\n        // adding time, cs, dv, nom to node with no stroke\n        n.strokeWidth = '4';\n        n.strokeColor = c;\n        n.nodeCol = taggedColor;\n        var push = function push(_ref3) {\n            var _ref4 = _slicedToArray(_ref3, 2),\n                color = _ref4[0],\n                key = _ref4[1];\n\n            if (color != c) return;\n            zparams[key] = Array.isArray(zparams[key]) ? zparams[key] : [];\n            zparams[key].push(n.name);\n            if (key == 'znom') {\n                findNodeIndex(n.name, true).nature = \"nominal\";\n                transform(n.name, t = null, typeTransform = true);\n            }\n        };\n        [[dvColor, 'zdv'], [csColor, 'zcross'], [timeColor, 'ztime'], [nomColor, 'znom']].forEach(push);\n    } else if (n.strokeWidth == '4') {\n        if (c == n.strokeColor) {\n            // deselecting time, cs, dv, nom\n            n.strokeWidth = '1';\n            n.strokeColor = _plots.selVarColor;\n            n.nodeCol = colors(n.id);\n            splice(c, n.name, [dvColor, 'zdv'], [csColor, 'zcross'], [timeColor, 'ztime'], [nomColor, 'znom']);\n            if (nomColor == c && zparams.znom.includes(n.name)) {\n                findNodeIndex(n.name, true).nature = findNodeIndex(n.name, true).defaultNature;\n                transform(n.name, t = null, typeTransform = true);\n            }\n        } else {\n            // deselecting time, cs, dv, nom AND changing it to time, cs, dv, nom\n            splice(n.strokeColor, n.name, [dvColor, 'zdv'], [csColor, 'zcross'], [timeColor, 'ztime'], [nomColor, 'znom']);\n            if (nomColor == n.strokeColor && zparams.znom.includes(n.name)) {\n                findNodeIndex(n.name, true).nature = findNodeIndex(n.name, true).defaultNature;\n                transform(n.name, t = null, typeTransform = true);\n            }\n            n.strokeColor = c;\n            if (dvColor == c) zparams.zdv.push(n.name);else if (csColor == c) zparams.zcross.push(n.name);else if (timeColor == c) zparams.ztime.push(n.name);else if (nomColor == c) {\n                zparams.znom.push(n.name);\n                findNodeIndex(n.name, true).nature = \"nominal\";\n                transform(n.name, t = null, typeTransform = true);\n            }\n        }\n    }\n}\n\nfunction borderState() {\n    zparams.zdv.length > 0 ? $('#dvButton .rectColor svg circle').attr('stroke', dvColor) : $('#dvButton').css('border-color', '#ccc');\n    zparams.zcross.length > 0 ? $('#csButton .rectColor svg circle').attr('stroke', csColor) : $('#csButton').css('border-color', '#ccc');\n    zparams.ztime.length > 0 ? $('#timeButton .rectColor svg circle').attr('stroke', timeColor) : $('#timeButton').css('border-color', '#ccc');\n    zparams.znom.length > 0 ? $('#nomButton .rectColor svg circle').attr('stroke', nomColor) : $('#nomButton').css('border-color', '#ccc');\n}\n\n// small appearance resets, but perhaps this will become a hard reset back to all original allNode values?\nfunction nodeReset(n) {\n    n.strokeColor = _plots.selVarColor;\n    n.strokeWidth = \"1\";\n    n.nodeCol = n.baseCol;\n}\n\nfunction subsetSelect(btn) {\n    if (dataurl) zparams.zdataurl = dataurl;\n    if (production && zparams.zsessionid == \"\") {\n        alert(\"Warning: Data download is not complete. Try again soon.\");\n        return;\n    }\n    zparams.zvars = [];\n    zparams.zplot = [];\n    var subsetEmpty = true;\n    // is this the same as zPop()?\n    for (var j = 0; j < nodes.length; j++) {\n        // populate zvars and zsubset arrays\n        zparams.zvars.push(nodes[j].name);\n        var temp = nodes[j].id;\n        zparams.zsubset[j] = allNodes[temp].subsetrange;\n        if (zparams.zsubset[j].length > 0) {\n            if (zparams.zsubset[j][0] != \"\") zparams.zsubset[j][0] = Number(zparams.zsubset[j][0]);\n            if (zparams.zsubset[j][1] != \"\") zparams.zsubset[j][1] = Number(zparams.zsubset[j][1]);\n        }\n        zparams.zplot.push(allNodes[temp].plottype);\n        if (zparams.zsubset[j][1] != \"\") subsetEmpty = false; // only need to check one\n    }\n\n    if (subsetEmpty == true) {\n        alert(\"Warning: No new subset selected.\");\n        return;\n    }\n\n    var outtypes = [];\n    for (var j = 0; j < allNodes.length; j++) {\n        outtypes.push({\n            varnamesTypes: allNodes[j].name,\n            nature: allNodes[j].nature,\n            numchar: allNodes[j].numchar,\n            binary: allNodes[j].binary,\n            interval: allNodes[j].interval\n        });\n    }\n\n    var subsetstuff = {\n        zdataurl: zparams.zdataurl,\n        zvars: zparams.zvars,\n        zsubset: zparams.zsubset,\n        zsessionid: zparams.zsessionid,\n        zplot: zparams.zplot,\n        callHistory: callHistory,\n        typeStuff: outtypes\n    };\n\n    var jsonout = JSON.stringify(subsetstuff);\n    var urlcall = rappURL + \"subsetapp\";\n    var solajsonout = \"solaJSON=\" + jsonout;\n    cdb(\"urlcall out: \", urlcall);\n    cdb(\"POST out: \", solajsonout);\n\n    function subsetSelectSuccess(btn, json) {\n        selectLadda.stop(); // stop motion\n        $(\"#btnVariables\").trigger(\"click\"); // programmatic clicks\n        $(\"#btnModels\").trigger(\"click\");\n\n        var grayOuts = [];\n        var rCall = [];\n        rCall[0] = json.call;\n\n        // store contents of the pre-subset space\n        zPop();\n        var myNodes = jQuery.extend(true, [], allNodes);\n        var myParams = jQuery.extend(true, {}, zparams);\n        var myTrans = jQuery.extend(true, [], trans);\n        var myForce = jQuery.extend(true, [], forcetoggle);\n        var myPreprocess = jQuery.extend(true, {}, preprocess);\n        var myLog = jQuery.extend(true, [], logArray);\n        var myHistory = jQuery.extend(true, [], callHistory);\n\n        spaces[myspace] = {\n            \"allNodes\": myNodes,\n            \"zparams\": myParams,\n            \"trans\": myTrans,\n            \"force\": myForce,\n            \"preprocess\": myPreprocess,\n            \"logArray\": myLog,\n            \"callHistory\": myHistory\n        };\n\n        // remove pre-subset svg\n        var selectMe = \"#m\".concat(myspace);\n        d3.select(selectMe).attr('class', 'item');\n        selectMe = \"#whitespace\".concat(myspace);\n        d3.select(selectMe).remove();\n\n        myspace = spaces.length;\n        callHistory.push({\n            func: \"subset\",\n            zvars: jQuery.extend(true, [], zparams.zvars),\n            zsubset: jQuery.extend(true, [], zparams.zsubset),\n            zplot: jQuery.extend(true, [], zparams.zplot)\n        });\n\n        // this is to be used to gray out and remove listeners for variables that have been subsetted out of the data\n        function varOut(v) {\n            // if in nodes, remove gray out in left panel\n            // make unclickable in left panel\n            for (var i = 0; i < v.length; i++) {\n                var selectMe = v[i].replace(/\\W/g, \"_\");\n                byId(selectMe).style.color = hexToRgba(grayColor);\n                selectMe = \"p#\".concat(selectMe);\n                d3.select(selectMe).on(\"click\", null);\n            }\n        }\n\n        showLog('subset', rCall);\n        reWriteLog();\n\n        d3.select(\"#innercarousel\").append('div').attr('class', 'item active').attr('id', function () {\n            return \"m\".concat(myspace.toString());\n        }).append('svg').attr('id', 'whitespace');\n        svg = d3.select(\"#whitespace\");\n\n        d3.json(json.url, function (error, json) {\n            if (error) {\n                return console.warn(error);\n            }\n            var jsondata = getVariableData(json);\n\n            for (var key in jsondata) {\n                var myIndex = findNodeIndex(key);\n\n                allNodes[myIndex].plotx = undefined;\n                allNodes[myIndex].ploty = undefined;\n                allNodes[myIndex].plotvalues = undefined;\n                allNodes[myIndex].plottype = \"\";\n\n                jQuery.extend(true, allNodes[myIndex], jsondata[key]);\n                allNodes[myIndex].subsetplot = false;\n                allNodes[myIndex].subsetrange = [\"\", \"\"];\n                allNodes[myIndex].setxplot = false;\n                allNodes[myIndex].setxvals = [\"\", \"\"];\n\n                if (allNodes[myIndex].valid == 0) {\n                    grayOuts.push(allNodes[myIndex].name);\n                    allNodes[myIndex].grayout = true;\n                }\n            }\n            rePlot();\n\n            layout(layoutAdd);\n        });\n\n        varOut(grayOuts);\n    }\n\n    selectLadda.start(); //start button motion\n    makeCorsRequest(urlcall, btn, subsetSelectSuccess, function (btn) {\n        return selectLadda.stop();\n    }, solajsonout);\n}\n\nfunction readPreprocess(url, p, v, callback) {\n    cdb('readPreprocess: ' + url);\n\n    d3.json(url, function (err, json) {\n        if (err) return console.warn(err);\n        cdb('inside readPreprocess function');\n        cdb(json);\n\n        priv = json.dataset.priv || priv;\n        // copy object\n        Object.keys(json.variables).forEach(function (k) {\n            return p[k] = json.variables[k];\n        });\n        if (typeof callback == 'function') callback();\n    });\n}\n\n// removes all the children svgs inside subset and setx divs\nfunction rePlot() {\n    d3.select('#tab2').selectAll('svg').remove();\n    d3.select('#setx').selectAll('svg').remove();\n    allNodes.forEach(function (n) {\n        return n.setxplot = n.subsetplot = false;\n    });\n}\n\nvar showLog = function showLog(val, rCall) {\n    logArray.push((val + ': ').concat(rCall[0]));\n    _mithril2.default.redraw();\n};\n\nfunction reWriteLog() {\n    d3.select(\"#collapseLog div.panel-body\").selectAll(\"p\").remove();\n    d3.select(\"#collapseLog div.panel-body\").selectAll(\"p\").data(logArray).enter().append(\"p\").text(function (d) {\n        return d;\n    });\n}\n\n// acts as if the user clicked in whitespace. useful when restart() is outside of scope\nvar fakeClick = exports.fakeClick = function fakeClick() {\n    var ws = \"#whitespace\".concat(myspace);\n    // d3 and programmatic events don't mesh well, here's a SO workaround that looks good but uses jquery...\n    jQuery.fn.d3Click = function () {\n        this.each(function (i, e) {\n            var evt = document.createEvent(\"MouseEvents\");\n            evt.initMouseEvent(\"mousedown\", true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);\n            e.dispatchEvent(evt);\n        });\n    };\n    $(ws).d3Click();\n    d3.select(ws).classed('active', false);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvYXBwL2FwcC5qcz9mNTEyIl0sIm5hbWVzIjpbImNkYiIsIm1haW4iLCJnZXRWYXJpYWJsZURhdGEiLCJmb3JjZVN3aXRjaCIsImVzdGltYXRlIiwiZXJhc2UiLCJ0YWJMZWZ0IiwidGFiUmlnaHQiLCJwYW5lbFBsb3RzIiwiYm9yZGVyU3RhdGUiLCJzdWJzZXRTZWxlY3QiLCJtc2ciLCJwcm9kdWN0aW9uIiwiY29uc29sZSIsImxvZyIsImluc3BlY3QiLCJvYmoiLCJjb2xvcnMiLCJkMyIsInNjYWxlIiwiY2F0ZWdvcnkyMCIsImNzQ29sb3IiLCJkdkNvbG9yIiwiZ3JheUNvbG9yIiwibm9tQ29sb3IiLCJ2YXJDb2xvciIsInRhZ2dlZENvbG9yIiwidGltZUNvbG9yIiwibGVmdHRhYiIsInN1YnNldCIsInN1bW1hcnlIb2xkIiwicmlnaHR0YWIiLCJ0IiwidHlwZVRyYW5zZm9ybSIsInRyYW5zZm9ybUxpc3QiLCJzcGxpdCIsInRyYW5zZm9ybVZhciIsInRyYW5zIiwicHJlcHJvY2VzcyIsInNwYWNlcyIsImxheW91dEFkZCIsImxheW91dE1vdmUiLCJhbGxSIiwibXlzcGFjZSIsImZvcmNldG9nZ2xlIiwicHJpdiIsImxvZ0FycmF5IiwienBhcmFtcyIsInpkYXRhIiwiemVkZ2VzIiwienRpbWUiLCJ6bm9tIiwiemNyb3NzIiwiem1vZGVsIiwienZhcnMiLCJ6ZHYiLCJ6ZGF0YXVybCIsInpzdWJzZXQiLCJ6c2V0eCIsInptb2RlbGNvdW50IiwienBsb3QiLCJ6c2Vzc2lvbmlkIiwiemRhdGFjaXRlIiwibW9kZWxDb3VudCIsInZhbHVlS2V5IiwiYWxsTm9kZXMiLCJhbGxSZXN1bHRzIiwibm9kZXMiLCJsaW5rcyIsIm1vZHMiLCJlc3RpbWF0ZWQiLCJyaWdodENsaWNrTGFzdCIsInNlbEludGVyYWN0IiwiY2FsbEhpc3RvcnkiLCJzdmciLCJ3aWR0aCIsImhlaWdodCIsImRpdiIsImVzdGltYXRlTGFkZGEiLCJzZWxlY3RMYWRkYSIsImFyYzMiLCJhcmM0IiwiYnlJZCIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJpZCIsInJlc2V0IiwicmVsb2FkUGFnZSIsImxvY2F0aW9uIiwicmVsb2FkIiwiZGF0YXVybCIsImZpbGVpZCIsImhvc3RuYW1lIiwiZGRpdXJsIiwiYWxlcnQiLCJFcnJvciIsImRhdGF2ZXJzZXVybCIsImFwaWtleSIsInNlbGVjdCIsInRlbXBXaWR0aCIsInN0eWxlIiwic3Vic3RyaW5nIiwibGVuZ3RoIiwiJCIsIndpbmRvdyIsIkxhZGRhIiwiY3JlYXRlIiwiY29sb3JUaW1lIiwiY29sb3JDUyIsImRlcFZhciIsInN1YnNldGRpdiIsInNldHhkaXYiLCJiYXJ3aWR0aCIsImJhcmhlaWdodCIsImJhclBhZGRpbmciLCJiYXJudW1iZXIiLCJhcmMiLCJzdGFydCIsImVuZCIsImlubmVyUmFkaXVzIiwib3V0ZXJSYWRpdXMiLCJzdGFydEFuZ2xlIiwiZW5kQW5nbGUiLCJhcmMwIiwiYXJjMSIsImFyYzIiLCJkYXRhc2V0MiIsImxhYmxBcnJheSIsImhvbGQiLCJzdWJzZXROb2RlcyIsIm9uIiwic2VsZWN0QWxsIiwiZGF0YSIsImVudGVyIiwiYXBwZW5kIiwidGV4dCIsImQiLCJyZW1vdmUiLCJtZXRhZGF0YXVybCIsInBVUkwiLCJ1cmwiLCJwIiwidiIsImNhbGxiYWNrIiwicmVhZFByZXByb2Nlc3MiLCJ4bWwiLCJ2YXJzIiwiZG9jdW1lbnRFbGVtZW50IiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJ0ZW1wIiwiY2hpbGROb2RlcyIsIm5vZGVWYWx1ZSIsImNpdGUiLCJyZXBsYWNlIiwiZGF0YW5hbWUiLCJodG1sIiwiaSIsImF0dHJpYnV0ZXMiLCJuYW1lIiwiZGF0YXNldGNvdW50IiwibGF5b3V0IiwiaGlzdG9ncmFtIiwiYmlucyIsImZyZXF1ZW5jeSIsInJlZmxleGl2ZSIsImxhYmwiLCJjb3VudCIsIm5vZGVDb2wiLCJiYXNlQ29sIiwic3Ryb2tlQ29sb3IiLCJzdHJva2VXaWR0aCIsInN1YnNldHBsb3QiLCJzdWJzZXRyYW5nZSIsInNldHhwbG90Iiwic2V0eHZhbHMiLCJncmF5b3V0IiwialF1ZXJ5IiwiZXh0ZW5kIiwicHVzaCIsImpzb24iLCJlcnIiLCJ3YXJuIiwia2V5IiwiemVsaWc1bW9kZWxzIiwiaGFzT3duUHJvcGVydHkiLCJkZXNjcmlwdGlvbiIsInplbGlnNWNob2ljZW1vZGVscyIsInNjYWZmb2xkaW5nIiwiZGF0YURvd25sb2FkIiwiJGZpbGwiLCJvcCIsImQxIiwiZDIiLCJ0cmFuc2l0aW9uIiwiYXR0ciIsImRlbGF5IiwiZHVyYXRpb24iLCJmaWxsIiwiZmlsbFRoaXMiLCJzZWxmIiwiY2xpY2siLCJkaXNwbGF5IiwiZmFkZU91dCIsInQxIiwicG9zIiwib2Zmc2V0IiwidG9wIiwiZmFkZUluIiwibiIsImtleXVwIiwiZXZ0Iiwia2V5Q29kZSIsInZhbCIsInRyYW5zUGFyc2UiLCJ0cmFuc2Zvcm0iLCJzbGljZSIsInR2YXIiLCJjb25jYXQiLCJwYXJlbnQiLCJmYW5kZU91dCIsInN0b3BQcm9wYWdhdGlvbiIsInRmdW5jIiwidGNhbGwiLCJPYmplY3QiLCJrZXlzIiwicmVkcmF3Iiwic3BsaWNlIiwiY29sb3IiLCJhcmdzIiwiZm9yRWFjaCIsIngiLCJpZHgiLCJpbmRleE9mIiwiY2xpY2tWYXIiLCJteVZhbHVlcyIsImoiLCJpaSIsImZpbmROb2RlSW5kZXgiLCJzZWxlY3RNZSIsImhleFRvUmdiYSIsIm15c3JjIiwibm9kZUluZGV4IiwibXl0Z3QiLCJzb3VyY2UiLCJ0YXJnZXQiLCJsZWZ0IiwicmlnaHQiLCJmb3JjZSIsInNpemUiLCJsaW5rRGlzdGFuY2UiLCJjaGFyZ2UiLCJ0aWNrIiwiZHJhZ19saW5lIiwicGF0aCIsImNpcmNsZSIsInNlbGVjdGVkX25vZGUiLCJzZWxlY3RlZF9saW5rIiwibW91c2Vkb3duX2xpbmsiLCJtb3VzZWRvd25fbm9kZSIsIm1vdXNldXBfbm9kZSIsInJlc2V0TW91c2VWYXJzIiwiZGVsdGFYIiwiZGVsdGFZIiwieSIsImRpc3QiLCJNYXRoIiwic3FydCIsIm5vcm1YIiwibm9ybVkiLCJzb3VyY2VQYWRkaW5nIiwidGFyZ2V0UGFkZGluZyIsInNvdXJjZVgiLCJzb3VyY2VZIiwidGFyZ2V0WCIsInRhcmdldFkiLCJub2RlIiwiZmluZE5vZGUiLCJtYXAiLCJpbmNsdWRlcyIsImluZGV4Iiwic3BsaWNlTGlua3NGb3JOb2RlIiwibm9kZVJlc2V0IiwibGVnZW5kIiwicmVzdGFydCIsIm15Q29sb3IiLCJyZ2IiLCJ0b1N0cmluZyIsImNhbGwiLCJkcmFnIiwiZ3Jhdml0eSIsImxpbmtTdHJlbmd0aCIsInJlc3VtZSIsImNsYXNzZWQiLCJKU09OIiwic3RyaW5naWZ5IiwiZXhpdCIsImciLCJlYWNoIiwicGxvdHR5cGUiLCJzdHIiLCJzZXRDb2xvcnMiLCJkZWZhdWx0TnVtY2hhciIsIl8iLCJldmVudCIsInByZXZlbnREZWZhdWx0IiwibW91c2Vtb3ZlIiwiZGlyZWN0aW9uIiwibGluayIsImZpbHRlciIsInZhclN1bW1hcnkiLCJzZXRBdHRyaWJ1dGUiLCJzZWxlY3RlZEluZGV4IiwibW91c2Vkb3duIiwiY3RybEtleSIsIm1vdXNlIiwibW91c2V1cCIsImZha2VDbGljayIsImZpbmQiLCIkbm9kZXMiLCJhbGwiLCJub2RlTmFtZSIsImpzb25EYXRhIiwidmFyaWFibGVzIiwibCIsInpQb3AiLCJzcmN0Z3QiLCJidG4iLCJqc29ub3V0IiwidXJsY2FsbCIsInJhcHBVUkwiLCJzb2xhanNvbm91dCIsImFsbFZhcnMiLCJzZWxlY3RvcnVybGNhbGwiLCJlc3RpbWF0ZVN1Y2Nlc3MiLCJzdG9wIiwicmVtb3ZlQ2hpbGQiLCJ0cmlnZ2VyIiwibW9kZWwiLCJtb2RDb2wiLCJpbnNlcnQiLCJhIiwiYmFja2dyb3VuZENvbG9yIiwiYiIsInN1YnN0ciIsInZpeiIsInJDYWxsIiwic2hvd0xvZyIsImVzdGltYXRlRmFpbCIsInNlbGVjdG9yU3VjY2VzcyIsInNlbGVjdG9yRmFpbCIsIm1ha2VDb3JzUmVxdWVzdCIsImRvd25sb2FkU3VjY2VzcyIsInNlc3Npb25pZCIsImhyZWYiLCJkb3dubG9hZEZhaWwiLCJteW0iLCJyZW1vdmVLaWRzIiwiZmlyc3RDaGlsZCIsImZpbGVsaXN0IiwiQXJyYXkiLCJpbWFnZXMiLCJ6ZmlnIiwiY3JlYXRlRWxlbWVudCIsImFwcGVuZENoaWxkIiwicmVzdWx0c0FycmF5Iiwic3VtSW5mbyIsInRhYmxlIiwidGhlYWQiLCJjb2xuYW1lcyIsInRib2R5IiwibXlOdW0iLCJOdW1iZXIiLCJpc05hTiIsInRvUHJlY2lzaW9uIiwib3V0MiIsInQyIiwiazIiLCJzdWJNZTIiLCJpbmRleGVkIiwibTIiLCJtYXRjaCIsInJlIiwiUmVnRXhwIiwicyIsInNlYXJjaCIsImZyb20iLCJ0byIsIm15biIsIm91dHR5cGVzIiwidmFybmFtZXNUeXBlcyIsImludGVydmFsIiwibnVtY2hhciIsIm5hdHVyZSIsImJpbmFyeSIsInBsb3R2YWx1ZXMiLCJwbG90eCIsInRyYW5zZm9ybXN0dWZmIiwidHlwZVN0dWZmIiwidHJhbnNmb3JtU3VjY2VzcyIsImZ1bmMiLCJzdWJzZXRlZCIsIm5ld1ZhciIsImVycm9yIiwianNvbmRhdGEiLCJteUluZGV4Iiwib2JqMSIsImRlZmF1bHRJbnRlcnZhbCIsImRlZmF1bHROYXR1cmUiLCJkZWZhdWx0QmluYXJ5IiwidHJhbnNmb3JtRmFpbCIsImNyZWF0ZUNPUlNSZXF1ZXN0IiwibWV0aG9kIiwieGhyIiwiWE1MSHR0cFJlcXVlc3QiLCJvcGVuIiwiWERvbWFpblJlcXVlc3QiLCJzZXRSZXF1ZXN0SGVhZGVyIiwid2FybmluZ2NhbGxiYWNrIiwianNvbnN0cmluZyIsIm9ubG9hZCIsInJlc3BvbnNlVGV4dCIsInBhcnNlIiwibmFtZXMiLCJ3YXJuaW5nIiwib25lcnJvciIsInN0YXR1cyIsInJlYWR5U3RhdGUiLCJzZW5kIiwibGVmdHBhbmVsTWVkaXVtIiwicmlnaHRwYW5lbE1lZGl1bSIsImZuIiwiZDNDbGljayIsImNoaWxkcmVuIiwiZSIsIm15Y29sIiwiY3JlYXRlRXZlbnQiLCJpbml0TW91c2VFdmVudCIsImRpc3BhdGNoRXZlbnQiLCJsb2FkWE1MRG9jIiwiWE1MbmFtZSIsInhtbERvYyIsInJlc3BvbnNlWE1MIiwiQWN0aXZlWE9iamVjdCIsImFzeW5jIiwibG9hZCIsInRhYiIsInRhYmlkIiwiY2xzIiwicGFuZWwiLCJ0b2dnbGVSIiwiZXhwYW5kIiwiZ2V0QXR0cmlidXRlIiwic3VtbWFyeSIsInJpbnQiLCJmb3JtYXQiLCJtZWFuQ0kiLCJtZWFuIiwibG93ZXJCb3VuZCIsInVwcGVyQm91bmQiLCJtZWRpYW4iLCJtb2RlIiwiZnJlcW1vZGUiLCJtaWQiLCJmcmVxbWlkIiwiZmV3ZXN0IiwiZnJlcWZld2VzdCIsInNkIiwibWluIiwibWF4IiwiaW52YWxpZCIsInZhbGlkIiwidW5pcXVlcyIsImhlcmZpbmRhaGwiLCJwb3BvdmVyQ29udGVudCIsImludCIsInByZWMiLCJmaWVsZCIsInBvcHVwWCIsInRzZiIsInRlbXBYIiwidGVtcFkiLCJpZHMiLCJyZWdzdHIiLCJteW5hbWUiLCJleGVjIiwibm9kZWlkIiwicGFyc2VJbnQiLCJoZXgiLCJqb2luIiwiYyIsImlzQXJyYXkiLCJjc3MiLCJzdWJzZXRFbXB0eSIsInN1YnNldHN0dWZmIiwic3Vic2V0U2VsZWN0U3VjY2VzcyIsImdyYXlPdXRzIiwibXlOb2RlcyIsIm15UGFyYW1zIiwibXlUcmFucyIsIm15Rm9yY2UiLCJteVByZXByb2Nlc3MiLCJteUxvZyIsIm15SGlzdG9yeSIsInZhck91dCIsInJlV3JpdGVMb2ciLCJ1bmRlZmluZWQiLCJwbG90eSIsInJlUGxvdCIsImRhdGFzZXQiLCJrIiwid3MiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztRQXdCZ0JBLEcsR0FBQUEsRztRQStGQUMsSSxHQUFBQSxJO1FBOHpCQUMsZSxHQUFBQSxlO1FBaUJBQyxXLEdBQUFBLFc7UUFrQ0FDLFEsR0FBQUEsUTtRQXFlQUMsSyxHQUFBQSxLO1FBb0NBQyxPLEdBQUFBLE87UUFZQUMsUSxHQUFBQSxRO1FBdUdBQyxVLEdBQUFBLFU7UUFp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RCxFQUE2RCxDQUE3RCxFQUFnRSxDQUFoRSxFQUFtRSxLQUFuRSxFQUEwRSxLQUExRSxFQUFpRixLQUFqRixFQUF3RixLQUF4RixFQUErRixDQUEvRixFQUFrRyxJQUFsRztBQUNBeVUsY0FBRUksYUFBRixDQUFnQm5PLEdBQWhCO0FBQ0gsU0FKRDtBQUtILEtBTkQ7QUFPQTNHLE1BQUV1WixFQUFGLEVBQU0vRSxPQUFOO0FBQ0E3WixPQUFHZ0YsTUFBSCxDQUFVNFosRUFBVixFQUNLMU4sT0FETCxDQUNhLFFBRGIsRUFDdUIsS0FEdkI7QUFFSCxDQWJNIiwiZmlsZSI6IjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbSBmcm9tICdtaXRocmlsJztcblxuaW1wb3J0IHtiYXJzLCBiYXJzTm9kZSwgYmFyc1N1YnNldCwgZGVuc2l0eSwgZGVuc2l0eU5vZGUsIHNlbFZhckNvbG9yfSBmcm9tICcuL3Bsb3RzLmpzJztcblxuLy8gaG9zdG5hbWUgZGVmYXVsdCAtIHRoZSBhcHAgd2lsbCB1c2UgaXQgdG8gb2J0YWluIHRoZSB2YXJpYWJsZSBtZXRhZGF0YVxuLy8gKGRkaSkgYW5kIHByZS1wcm9jZXNzZWQgZGF0YSBpbmZvIGlmIHRoZSBmaWxlIGlkIGlzIHN1cHBsaWVkIGFzIGFuXG4vLyBhcmd1bWVudCAoZm9yIGV4LiwgZ3VpLmh0bWw/ZGZJZD0xNyksIGJ1dCBob3N0bmFtZSBpc24ndC5cbi8vIEVkaXQgaXQgdG8gc3VpdCB5b3VyIGluc3RhbGxhdGlvbi5cbi8vIChOT1RFIHRoYXQgaWYgdGhlIGZpbGUgaWQgaXNuJ3Qgc3VwcGxpZWQsIHRoZSBhcHAgd2lsbCBkZWZhdWx0IHRvIHRoZVxuLy8gbG9jYWwgZmlsZXMgc3BlY2lmaWVkIGJlbG93ISlcbi8vIE5FVzogaXQgaXMgYWxzbyBwb3NzaWJsZSBub3cgdG8gc3VwcGx5IGNvbXBsZXRlIHVybHMgZm9yIHRoZSBkZGkgYW5kXG4vLyB0aGUgdGFiLWRlbGltaXRlZCBkYXRhIGZpbGU7IHRoZSBwYXJhbWV0ZXJzIGFyZSBkZGl1cmwgYW5kIGRhdGF1cmwuXG4vLyBUaGVzZSBuZXcgcGFyYW1ldGVycyBhcmUgb3B0aW9uYWwuIElmIHRoZXkgYXJlIG5vdCBzdXBwbGllZCwgdGhlIGFwcFxuLy8gd2lsbCBnbyB0aGUgb2xkIHJvdXRlIC0gd2lsbCB0cnkgdG8gY29vayBzdGFuZGFyZCBkYXRhdmVyc2UgdXJsc1xuLy8gZm9yIGJvdGggdGhlIGRhdGEgYW5kIG1ldGFkYXRhLCBpZiB0aGUgZmlsZSBpZCBpcyBzdXBwbGllZDsgb3IgdGhlXG4vLyBsb2NhbCBmaWxlcyBpZiBub3RoaW5nIGlzIHN1cHBsaWVkLlxuXG4vLyBGT1IgdmFyaWFibGVzIFwicHJvZHVjdGlvblwiIGFuZCBcInJhcHBVUkxcIiwgc2VlIC90ZW1wbGF0ZS9pbmRleC5odG1sXG4vL1xuLy9sZXQgcHJvZHVjdGlvbiA9IGZhbHNlO1xuLy9sZXQgcmFwcFVSTCA9ICdodHRwOi8vMTI3LjAuMC4xOjgwODAvcm9vay1jdXN0b20vJzsgLy8gdmlhIERqYW5nbyAtPiB0byBSQXBhY2hlL3Jvb2tcbi8vbGV0IHJhcHBVUkwgPSAnaHR0cDovLzAuMC4wLjA6ODAwMC9jdXN0b20vJzsgLy8gRGlyZWN0IHRvIFJBcGFjaGUvcm9va1xuXG4vLyBmb3IgZGVidWdnaW5nXG5leHBvcnQgZnVuY3Rpb24gY2RiKG1zZykge1xuICAgIGlmICghcHJvZHVjdGlvbil7XG4gICAgICAgIGNvbnNvbGUubG9nKG1zZyk7XG4gICAgfTtcbn07XG5cbmV4cG9ydCBsZXQgaW5zcGVjdCA9IG9iaiA9PiB7XG4gICAgY29uc29sZS5sb2cob2JqKTtcbiAgICByZXR1cm4gb2JqO1xufTtcblxuLy8gaW5pdGlhbCBjb2xvciBzY2FsZSB1c2VkIHRvIGVzdGFibGlzaCB0aGUgaW5pdGlhbCBjb2xvcnMgb2Ygbm9kZXNcbi8vIGFsbE5vZGVzLnB1c2goKSBiZWxvdyBlc3RhYmxpc2hlcyBhIGZpZWxkIGZvciB0aGUgbWFzdGVyIG5vZGUgYXJyYXkgYWxsTm9kZXMgY2FsbGVkIFwibm9kZUNvbFwiIGFuZCBhc3NpZ25zIGEgY29sb3IgZnJvbSB0aGlzIHNjYWxlIHRvIHRoYXQgZmllbGRcbi8vIGV2ZXJ5dGhpbmcgdGhlcmUgYWZ0ZXIgc2hvdWxkIHJlZmVyIHRvIHRoZSBub2RlQ29sIGFuZCBub3QgdGhlIGNvbG9yIHNjYWxlLCB0aGlzIGVuYWJsZXMgdXMgdG8gdXBkYXRlIGNvbG9ycyBhbmQgcGFzcyB0aGUgdmFyaWFibGUgdHlwZSB0byBSIGJhc2VkIG9uIGl0cyBjb2xvcmluZ1xudmFyIGNvbG9ycyA9IGQzLnNjYWxlLmNhdGVnb3J5MjAoKTtcbmV4cG9ydCBsZXQgY3NDb2xvciA9ICcjNDE5NjQxJztcbmV4cG9ydCBsZXQgZHZDb2xvciA9ICcjMjhhNGM5JztcbnZhciBncmF5Q29sb3IgPSAnI2MwYzBjMCc7XG5leHBvcnQgbGV0IG5vbUNvbG9yID0gJyNmZjY2MDAnO1xuZXhwb3J0IGxldCB2YXJDb2xvciA9ICcjZjBmOGZmJzsgLy8gZDMucmdiKFwiYWxpY2VibHVlXCIpO1xudmFyIHRhZ2dlZENvbG9yID0gJyNmNWY1ZjUnOyAvLyBkMy5yZ2IoXCJ3aGl0ZXNtb2tlXCIpO1xuZXhwb3J0IGxldCB0aW1lQ29sb3IgPSAnIzJkNmNhMic7XG5cbmV4cG9ydCBsZXQgbGVmdHRhYiA9ICd0YWIxJzsgLy8gY3VycmVudCB0YWIgaW4gbGVmdCBwYW5lbFxuZXhwb3J0IGxldCBzdWJzZXQgPSBmYWxzZTtcbmV4cG9ydCBsZXQgc3VtbWFyeUhvbGQgPSBmYWxzZTtcbmV4cG9ydCBsZXQgcmlnaHR0YWIgPSAnYnRuTW9kZWxzJzsgLy8gY3VycmVudCB0YWIgaW4gcmlnaHQgcGFuZWxcblxuLy8gdHJhbnNmb3JtYXRpb24gdG9vbGJhciBvcHRpb25zXG5sZXQgdCwgdHlwZVRyYW5zZm9ybTtcbmxldCB0cmFuc2Zvcm1MaXN0ID0gJ2xvZyhkKSBleHAoZCkgZF4yIHNxcnQoZCkgaW50ZXJhY3QoZCxlKScuc3BsaXQoJyAnKTtcbmxldCB0cmFuc2Zvcm1WYXIgPSAnJztcblxuLy8gdmFyIGxpc3QgZm9yIGVhY2ggc3BhY2UgY29udGFpbiB2YXJpYWJsZXMgaW4gb3JpZ2luYWwgZGF0YVxuLy8gcGx1cyB0cmFucyBpbiB0aGF0IHNwYWNlXG5sZXQgdHJhbnMgPSBbXTtcbmxldCBwcmVwcm9jZXNzID0ge307IC8vIGhvbGQgcHJlLXByb2Nlc3NlZCBkYXRhXG5sZXQgc3BhY2VzID0gW107XG5cbi8vIGxheW91dCBmdW5jdGlvbiBjb25zdGFudHNcbmNvbnN0IGxheW91dEFkZCA9IFwiYWRkXCI7XG5jb25zdCBsYXlvdXRNb3ZlID0gXCJtb3ZlXCI7XG5cbi8vIFJhZGl1cyBvZiBjaXJjbGVcbnZhciBhbGxSID0gNDA7XG5cbi8vIHNwYWNlIGluZGV4XG52YXIgbXlzcGFjZSA9IDA7XG5cbnZhciBmb3JjZXRvZ2dsZSA9IFtcInRydWVcIl07XG52YXIgcHJpdiA9IHRydWU7XG5cbmV4cG9ydCBsZXQgbG9nQXJyYXkgPSBbXTtcbmV4cG9ydCBsZXQgenBhcmFtcyA9IHtcbiAgICB6ZGF0YTogW10sXG4gICAgemVkZ2VzOiBbXSxcbiAgICB6dGltZTogW10sXG4gICAgem5vbTogW10sXG4gICAgemNyb3NzOiBbXSxcbiAgICB6bW9kZWw6IFwiXCIsXG4gICAgenZhcnM6IFtdLFxuICAgIHpkdjogW10sXG4gICAgemRhdGF1cmw6IFwiXCIsXG4gICAgenN1YnNldDogW10sXG4gICAgenNldHg6IFtdLFxuICAgIHptb2RlbGNvdW50OiAwLFxuICAgIHpwbG90OiBbXSxcbiAgICB6c2Vzc2lvbmlkOiBcIlwiLFxuICAgIHpkYXRhY2l0ZTogXCJcIlxufTtcblxudmFyIG1vZGVsQ291bnQgPSAwO1xuZXhwb3J0IGxldCB2YWx1ZUtleSA9IFtdO1xuZXhwb3J0IGxldCBhbGxOb2RlcyA9IFtdO1xudmFyIGFsbFJlc3VsdHMgPSBbXTtcbmV4cG9ydCBsZXQgbm9kZXMgPSBbXTtcbnZhciBsaW5rcyA9IFtdO1xudmFyIG1vZHMgPSB7fTtcbnZhciBlc3RpbWF0ZWQgPSBmYWxzZTtcbnZhciByaWdodENsaWNrTGFzdCA9IGZhbHNlO1xudmFyIHNlbEludGVyYWN0ID0gZmFsc2U7XG52YXIgY2FsbEhpc3RvcnkgPSBbXTsgLy8gdHJhbnNmb3JtIGFuZCBzdWJzZXQgY2FsbHNcblxudmFyIHN2Zywgd2lkdGgsIGhlaWdodCwgZGl2LCBlc3RpbWF0ZUxhZGRhLCBzZWxlY3RMYWRkYTtcbnZhciBhcmMzLCBhcmM0O1xuXG5sZXQgYnlJZCA9IGlkID0+IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcblxuLy8gcGFnZSByZWxvYWQgbGlua2VkIHRvIGJ0blJlc2V0XG5leHBvcnQgY29uc3QgcmVzZXQgPSBmdW5jdGlvbiByZWxvYWRQYWdlKCkge1xuICBsb2NhdGlvbi5yZWxvYWQoKTtcbn1cblxuXG52YXIgZGF0YXVybDtcbmV4cG9ydCBmdW5jdGlvbiBtYWluKGZpbGVpZCwgaG9zdG5hbWUsIGRkaXVybCwgZGF0YXVybCkge1xuICAgIGRhdGF1cmwgPSBkYXRhdXJsO1xuICAgIGlmIChwcm9kdWN0aW9uICYmIGZpbGVpZCA9PSBcIlwiKSB7XG4gICAgICAgIGFsZXJ0KFwiRXJyb3I6IE5vIGZpbGVpZCBoYXMgYmVlbiBwcm92aWRlZC5cIik7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yOiBObyBmaWxlaWQgaGFzIGJlZW4gcHJvdmlkZWQuXCIpO1xuICAgIH1cblxuICAgIGxldCBkYXRhdmVyc2V1cmwgPSAnJztcbiAgICBpZiAoaG9zdG5hbWUpIGRhdGF2ZXJzZXVybCA9IFwiaHR0cHM6Ly9cIiArIGhvc3RuYW1lO1xuICAgIGVsc2UgaWYgKHByb2R1Y3Rpb24pIGRhdGF2ZXJzZXVybCA9IFwiJVBST0RVQ1RJT05fREFUQVZFUlNFX1VSTCVcIjtcbiAgICBlbHNlIGRhdGF2ZXJzZXVybCA9IFwiaHR0cDovL2xvY2FsaG9zdDo4MDgwXCI7XG5cbiAgICBpZiAoZmlsZWlkICYmICFkYXRhdXJsKSB7XG4gICAgICAgIC8vIGZpbGUgaWQgc3VwcGxpZWQ7IGFzc3VtZSB3ZSBhcmUgZGVhbGluZyB3aXRoIGRhdGF2ZXJzZSBhbmQgY29vayBhIHN0YW5kYXJkIGRhdGF2ZXJzZSBkYXRhIGFjY2VzcyB1cmxcbiAgICAgICAgLy8gd2l0aCB0aGUgZmlsZWlkIHN1cHBsaWVkIGFuZCB0aGUgaG9zdG5hbWUgd2UgaGF2ZSBzdXBwbGllZCBvciBjb25maWd1cmVkXG4gICAgICAgIGRhdGF1cmwgPSBkYXRhdmVyc2V1cmwgKyBcIi9hcGkvYWNjZXNzL2RhdGFmaWxlL1wiICsgZmlsZWlkO1xuICAgICAgICBkYXRhdXJsID0gZGF0YXVybCArIFwiP2tleT1cIiArIGFwaWtleTtcbiAgICB9XG5cbiAgICBzdmcgPSBkMy5zZWxlY3QoXCIjd2hpdGVzcGFjZVwiKTtcblxuICAgIHZhciB0ZW1wV2lkdGggPSBkMy5zZWxlY3QoXCIjbWFpbi5sZWZ0XCIpLnN0eWxlKFwid2lkdGhcIik7XG4gICAgd2lkdGggPSB0ZW1wV2lkdGguc3Vic3RyaW5nKDAsIHRlbXBXaWR0aC5sZW5ndGggLSAyKTtcbiAgICBoZWlnaHQgPSAkKHdpbmRvdykuaGVpZ2h0KCkgLSAxMjA7IC8vIEhhcmQgY29kaW5nIGZvciBoZWFkZXIgYW5kIGZvb3RlciBhbmQgYm90dG9tIG1hcmdpbi5cblxuICAgIGVzdGltYXRlTGFkZGEgPSBMYWRkYS5jcmVhdGUoYnlJZChcImJ0bkVzdGltYXRlXCIpKTtcbiAgICBzZWxlY3RMYWRkYSA9IExhZGRhLmNyZWF0ZShieUlkKFwiYnRuU2VsZWN0XCIpKTtcblxuICAgIHZhciBjb2xvclRpbWUgPSBmYWxzZTtcbiAgICB2YXIgY29sb3JDUyA9IGZhbHNlO1xuXG4gICAgdmFyIGRlcFZhciA9IGZhbHNlO1xuICAgIHZhciBzdWJzZXRkaXYgPSBmYWxzZTtcbiAgICB2YXIgc2V0eGRpdiA9IGZhbHNlO1xuXG4gICAgLy9XaWR0aCBhbmQgaGVpZ2h0IGZvciBoaXN0Z3JhbXNcbiAgICB2YXIgYmFyd2lkdGggPSAxLjMgKiBhbGxSO1xuICAgIHZhciBiYXJoZWlnaHQgPSAwLjUgKiBhbGxSO1xuICAgIHZhciBiYXJQYWRkaW5nID0gMC4zNTtcbiAgICB2YXIgYmFybnVtYmVyID0gNztcblxuICAgIGxldCBhcmMgPSAoc3RhcnQsIGVuZCkgPT4gZDMuc3ZnLmFyYygpXG4gICAgICAgIC5pbm5lclJhZGl1cyhhbGxSICsgNSlcbiAgICAgICAgLm91dGVyUmFkaXVzKGFsbFIgKyAyMClcbiAgICAgICAgLnN0YXJ0QW5nbGUoc3RhcnQpXG4gICAgICAgIC5lbmRBbmdsZShlbmQpO1xuICAgIGxldCBbYXJjMCwgYXJjMSwgYXJjMl0gPSBbYXJjKDAsIDMuMiksIGFyYygwLCAxKSwgYXJjKDEuMSwgMi4yKV07XG4gICAgYXJjMyA9IGFyYygyLjMsIDMuMyk7XG4gICAgYXJjNCA9IGFyYyg0LjMsIDUuMyk7XG5cbiAgICAvLyBGcm9tIC5jc3ZcbiAgICB2YXIgZGF0YXNldDIgPSBbXTtcbiAgICB2YXIgbGFibEFycmF5ID0gW107XG4gICAgdmFyIGhvbGQgPSBbXTtcbiAgICB2YXIgc3Vic2V0Tm9kZXMgPSBbXTtcblxuXG4gICAgLy8gY29sbGFwc2FibGUgdXNlciBsb2dcbiAgICAkKCcjY29sbGFwc2VMb2cnKS5vbignc2hvd24uYnMuY29sbGFwc2UnLCAoKSA9PiB7XG4gICAgICAgIGQzLnNlbGVjdChcIiNjb2xsYXBzZUxvZyBkaXYucGFuZWwtYm9keVwiKS5zZWxlY3RBbGwoXCJwXCIpXG4gICAgICAgICAgICAuZGF0YShsb2dBcnJheSlcbiAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAuYXBwZW5kKFwicFwiKVxuICAgICAgICAgICAgLnRleHQoZCA9PiBkKTtcbiAgICB9KTtcbiAgICAkKCcjY29sbGFwc2VMb2cnKS5vbignaGlkZGVuLmJzLmNvbGxhcHNlJywgKCkgPT4ge1xuICAgICAgICBkMy5zZWxlY3QoXCIjY29sbGFwc2VMb2cgZGl2LnBhbmVsLWJvZHlcIikuc2VsZWN0QWxsKFwicFwiKVxuICAgICAgICAgICAgLnJlbW92ZSgpO1xuICAgIH0pO1xuXG4gICAgLy8gZGVmYXVsdCB0byBDYWxpZm9ybmlhIFBVTVMgc3Vic2V0XG4gICAgbGV0IGRhdGEgPSAnZGF0YS8nICsgKGZhbHNlID8gJ1BVTVM1c21hbGwnIDogJ2ZlYXJvbkxhaXRpbicpO1xuICAgIGxldCBtZXRhZGF0YXVybCA9IGRkaXVybCB8fCAoZmlsZWlkID8gYCR7ZGF0YXZlcnNldXJsfS9hcGkvbWV0YS9kYXRhZmlsZS8ke2ZpbGVpZH1gIDogZGF0YSArICcueG1sJyk7XG4gICAgLy8gcmVhZCBwcmUtcHJvY2Vzc2VkIG1ldGFkYXRhIGFuZCBkYXRhXG4gICAgbGV0IHBVUkwgPSBkYXRhdXJsID8gYCR7ZGF0YXVybH0mZm9ybWF0PXByZXBgIDogZGF0YSArICcuanNvbic7XG4gICAgY2RiKCdwVVJMOiAnICsgcFVSTCk7XG4gICAgLy8gbG9hZHMgYWxsIGV4dGVybmFsIGRhdGE6IG1ldGFkYXRhIChEVk4ncyBkZGkpLCBwcmVwcm9jZXNzZWQgKGZvciBwbG90dGluZyBkaXN0cmlidXRpb25zKSwgYW5kIHplbGlnbW9kZWxzIChwcm9kdWNlZCBieSBaZWxpZykgYW5kIGluaXRpYXRlcyB0aGUgZGF0YSBkb3dubG9hZCB0byB0aGUgc2VydmVyXG4gICAgdmFyIHVybCwgcCwgdiwgY2FsbGJhY2s7XG4gICAgcmVhZFByZXByb2Nlc3ModXJsID0gcFVSTCwgcCA9IHByZXByb2Nlc3MsIHYgPSBudWxsLCBjYWxsYmFjayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBkMy54bWwobWV0YWRhdGF1cmwsIFwiYXBwbGljYXRpb24veG1sXCIsIHhtbCA9PiB7XG4gICAgICAgICAgICB2YXIgdmFycyA9IHhtbC5kb2N1bWVudEVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ2YXJcIik7XG4gICAgICAgICAgICB2YXIgdGVtcCA9IHhtbC5kb2N1bWVudEVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJmaWxlTmFtZVwiKTtcbiAgICAgICAgICAgIHpwYXJhbXMuemRhdGEgPSB0ZW1wWzBdLmNoaWxkTm9kZXNbMF0ubm9kZVZhbHVlO1xuXG4gICAgICAgICAgICB2YXIgY2l0ZSA9IHhtbC5kb2N1bWVudEVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJiaWJsQ2l0XCIpO1xuICAgICAgICAgICAgenBhcmFtcy56ZGF0YWNpdGUgPSBjaXRlWzBdLmNoaWxkTm9kZXNbMF0ubm9kZVZhbHVlO1xuICAgICAgICAgICAgLy8gY2xlYW4gY2l0YXRpb24gc28gUE9TVCBpcyB2YWxpZCBqc29uXG4gICAgICAgICAgICB6cGFyYW1zLnpkYXRhY2l0ZSA9IHpwYXJhbXMuemRhdGFjaXRlLnJlcGxhY2UoL1xcJi9nLCBcImFuZFwiKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXDsvZywgXCIsXCIpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcJS9nLCBcIi1cIik7XG5cbiAgICAgICAgICAgIC8vIGRhdGFzZXQgbmFtZSB0cmltbWVkIHRvIDEyIGNoYXJzXG4gICAgICAgICAgICB2YXIgZGF0YW5hbWUgPSB6cGFyYW1zLnpkYXRhLnJlcGxhY2UoL1xcLiguKikvLCAnJyk7IC8vIGRyb3AgZmlsZSBleHRlbnNpb25cbiAgICAgICAgICAgIGQzLnNlbGVjdChcIiNkYXRhTmFtZVwiKVxuICAgICAgICAgICAgICAgIC5odG1sKGRhdGFuYW1lKTtcbiAgICAgICAgICAgICQoJyNjaXRlIGRpdi5wYW5lbC1ib2R5JykudGV4dCh6cGFyYW1zLnpkYXRhY2l0ZSk7XG5cbiAgICAgICAgICAgIC8vIFB1dCBkYXRhc2V0IG5hbWUsIGZyb20gbWV0YS1kYXRhLCBpbnRvIHBhZ2UgdGl0bGVcbiAgICAgICAgICAgIGQzLnNlbGVjdChcInRpdGxlXCIpLmh0bWwoXCJUd29SYXZlbnMgXCIgKyBkYXRhbmFtZSk7XG4gICAgICAgICAgICAvLyB0ZW1wb3JhcnkgdmFsdWVzIGZvciBob2xkIHRoYXQgY29ycmVzcG9uZCB0byBoaXN0b2dyYW0gYmluc1xuICAgICAgICAgICAgaG9sZCA9IFsuNiwgLjIsIC45LCAuOCwgLjEsIC4zLCAuNF07XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YWx1ZUtleVtpXSA9IHZhcnNbaV0uYXR0cmlidXRlcy5uYW1lLm5vZGVWYWx1ZTtcbiAgICAgICAgICAgICAgICBsYWJsQXJyYXlbaV0gPSB2YXJzW2ldLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwibGFibFwiKS5sZW5ndGggPT0gMCA/XG4gICAgICAgICAgICAgICAgICAgIFwibm8gbGFiZWxcIiA6XG4gICAgICAgICAgICAgICAgICAgIHZhcnNbaV0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJsYWJsXCIpWzBdLmNoaWxkTm9kZXNbMF0ubm9kZVZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciBkYXRhc2V0Y291bnQgPSBkMy5sYXlvdXQuaGlzdG9ncmFtKClcbiAgICAgICAgICAgICAgICAgICAgLmJpbnMoYmFybnVtYmVyKS5mcmVxdWVuY3koZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIChbMCwgMCwgMCwgMCwgMF0pO1xuICAgICAgICAgICAgICAgIC8vIGNvbnRhaW5zIGFsbCB0aGUgcHJlcHJvY2Vzc2VkIGRhdGEgd2UgaGF2ZSBmb3IgdGhlIHZhcmlhYmxlLCBhcyB3ZWxsIGFzIFVJIGRhdGEgcGVydGluZW50IHRvIHRoYXQgdmFyaWFibGUsIHN1Y2ggYXMgc2V0eCB2YWx1ZXMgKGlmIHRoZSB1c2VyIGhhcyBzZWxlY3RlZCB0aGVtKSBhbmQgcGViYmxlIGNvb3JkaW5hdGVzXG4gICAgICAgICAgICAgICAgbGV0IG9iaiA9IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGksXG4gICAgICAgICAgICAgICAgICAgIHJlZmxleGl2ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHZhbHVlS2V5W2ldLFxuICAgICAgICAgICAgICAgICAgICBsYWJsOiBsYWJsQXJyYXlbaV0sXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IFs1LCAxNSwgMjAsIDAsIDUsIDE1LCAyMF0sXG4gICAgICAgICAgICAgICAgICAgIGNvdW50OiBob2xkLFxuICAgICAgICAgICAgICAgICAgICBub2RlQ29sOiBjb2xvcnMoaSksXG4gICAgICAgICAgICAgICAgICAgIGJhc2VDb2w6IGNvbG9ycyhpKSxcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlQ29sb3I6IHNlbFZhckNvbG9yLFxuICAgICAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogXCIxXCIsXG4gICAgICAgICAgICAgICAgICAgIHN1YnNldHBsb3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBzdWJzZXRyYW5nZTogW1wiXCIsIFwiXCJdLFxuICAgICAgICAgICAgICAgICAgICBzZXR4cGxvdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHNldHh2YWxzOiBbXCJcIiwgXCJcIl0sXG4gICAgICAgICAgICAgICAgICAgIGdyYXlvdXQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBqUXVlcnkuZXh0ZW5kKHRydWUsIG9iaiwgcHJlcHJvY2Vzc1t2YWx1ZUtleVtpXV0pO1xuICAgICAgICAgICAgICAgIGFsbE5vZGVzLnB1c2gob2JqKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIHJlYWQgdGhlIHplbGlnIG1vZGVscyBhbmQgcG9wdWxhdGUgbW9kZWwgbGlzdCBpbiByaWdodCBwYW5lbFxuICAgICAgICAgICAgZDMuanNvbihcImRhdGEvemVsaWc1bW9kZWxzLmpzb25cIiwgKGVyciwgZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oZXJyKTtcbiAgICAgICAgICAgICAgICBjZGIoXCJ6ZWxpZyBtb2RlbHMganNvbjogXCIsIGRhdGEpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBkYXRhLnplbGlnNW1vZGVscykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS56ZWxpZzVtb2RlbHMuaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZHNbZGF0YS56ZWxpZzVtb2RlbHNba2V5XS5uYW1lWzBdXSA9IGRhdGEuemVsaWc1bW9kZWxzW2tleV0uZGVzY3JpcHRpb25bMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGQzLmpzb24oXCJkYXRhL3plbGlnNWNob2ljZW1vZGVscy5qc29uXCIsIChlcnIsIGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgY2RiKFwiemVsaWcgY2hvaWNlIG1vZGVscyBqc29uOiBcIiwgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBkYXRhLnplbGlnNWNob2ljZW1vZGVscykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuemVsaWc1Y2hvaWNlbW9kZWxzLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kc1tkYXRhLnplbGlnNWNob2ljZW1vZGVsc1trZXldLm5hbWVbMF1dID0gZGF0YS56ZWxpZzVjaG9pY2Vtb2RlbHNba2V5XS5kZXNjcmlwdGlvblswXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzY2FmZm9sZGluZyhjYWxsYmFjayA9IGxheW91dCk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFEb3dubG9hZCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG5sZXQgJGZpbGwgPSAob2JqLCBvcCwgZDEsIGQyKSA9PiBkMy5zZWxlY3Qob2JqKS50cmFuc2l0aW9uKClcbiAgICAuYXR0cignZmlsbC1vcGFjaXR5Jywgb3ApXG4gICAgLmRlbGF5KGQxKVxuICAgIC5kdXJhdGlvbihkMik7XG5sZXQgZmlsbCA9IChkLCBpZCwgb3AsIGQxLCBkMikgPT4gJGZpbGwoJyMnICsgaWQgKyBkLmlkLCBvcCwgZDEsIGQyKTtcbmxldCBmaWxsVGhpcyA9IChzZWxmLCBvcCwgZDEsIGQyKSA9PiAkZmlsbChzZWxmLCBvcCwgZDEsIGQyKTtcblxuLy8gc2NhZmZvbGRpbmcgaXMgY2FsbGVkIGFmdGVyIGFsbCBleHRlcm5hbCBkYXRhIGFyZSBndWFyYW50ZWVkIHRvIGhhdmUgYmVlbiByZWFkIHRvIGNvbXBsZXRpb24uIHRoaXMgcG9wdWxhdGVzIHRoZSBsZWZ0IHBhbmVsIHdpdGggdmFyaWFibGUgbmFtZXMsIHRoZSByaWdodCBwYW5lbCB3aXRoIG1vZGVsIG5hbWVzLCB0aGUgdHJhbnNmb3JtYXRpb24gdG9vbCwgYW4gdGhlIGFzc29jaWF0ZWQgbW91c2VvdmVycy4gaXRzIGNhbGxiYWNrIGlzIGxheW91dCgpLCB3aGljaCBpbml0aWFsaXplcyB0aGUgbW9kZWxpbmcgc3BhY2VcbmZ1bmN0aW9uIHNjYWZmb2xkaW5nKGNhbGxiYWNrKSB7XG4gICAgLy8gZXN0YWJsaXNoaW5nIHRoZSB0cmFuc2Zvcm1hdGlvbiBlbGVtZW50XG4gICAgZDMuc2VsZWN0KFwiI3RyYW5zZm9ybWF0aW9uc1wiKVxuICAgICAgICAuYXBwZW5kKFwiaW5wdXRcIilcbiAgICAgICAgLmF0dHIoXCJpZFwiLCBcInRJbnB1dFwiKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiZm9ybS1jb250cm9sXCIpXG4gICAgICAgIC5hdHRyKFwidHlwZVwiLCBcInRleHRcIilcbiAgICAgICAgLmF0dHIoXCJ2YWx1ZVwiLCBcIlZhcmlhYmxlIHRyYW5zZm9ybWF0aW9uXCIpO1xuXG4gICAgLy8gdmFyaWFibGUgZHJvcGRvd25cbiAgICBkMy5zZWxlY3QoXCIjdHJhbnNmb3JtYXRpb25zXCIpXG4gICAgICAgIC5hcHBlbmQoXCJ1bFwiKVxuICAgICAgICAuYXR0cihcImlkXCIsIFwidHJhbnNTZWxcIilcbiAgICAgICAgLnN0eWxlKFwiZGlzcGxheVwiLCBcIm5vbmVcIilcbiAgICAgICAgLnN0eWxlKFwiYmFja2dyb3VuZC1jb2xvclwiLCB2YXJDb2xvcilcbiAgICAgICAgLnNlbGVjdEFsbCgnbGknKVxuICAgICAgICAuZGF0YShbXCJhXCIsIFwiYlwiXSkgLy9zZXQgdG8gdmFyaWFibGVzIGluIG1vZGVsIHNwYWNlIGFzIHRoZXkncmUgYWRkZWRcbiAgICAgICAgLmVudGVyKClcbiAgICAgICAgLmFwcGVuZChcImxpXCIpXG4gICAgICAgIC50ZXh0KGQgPT4gZCk7XG5cbiAgICAvLyBmdW5jdGlvbiBkcm9wZG93blxuICAgIGQzLnNlbGVjdChcIiN0cmFuc2Zvcm1hdGlvbnNcIilcbiAgICAgICAgLmFwcGVuZChcInVsXCIpXG4gICAgICAgIC5hdHRyKFwiaWRcIiwgXCJ0cmFuc0xpc3RcIilcbiAgICAgICAgLnN0eWxlKFwiZGlzcGxheVwiLCBcIm5vbmVcIilcbiAgICAgICAgLnN0eWxlKFwiYmFja2dyb3VuZC1jb2xvclwiLCB2YXJDb2xvcilcbiAgICAgICAgLnNlbGVjdEFsbCgnbGknKVxuICAgICAgICAuZGF0YSh0cmFuc2Zvcm1MaXN0KVxuICAgICAgICAuZW50ZXIoKVxuICAgICAgICAuYXBwZW5kKFwibGlcIilcbiAgICAgICAgLnRleHQoZCA9PiBkKTtcblxuICAgICQoJyN0SW5wdXQnKS5jbGljaygoKSA9PiB7XG4gICAgICAgIHZhciB0ID0gYnlJZCgndHJhbnNTZWwnKS5zdHlsZS5kaXNwbGF5O1xuICAgICAgICBpZiAodCAhPT0gXCJub25lXCIpIHsgLy8gaWYgdmFyaWFibGUgbGlzdCBpcyBkaXNwbGF5ZWQgd2hlbiBpbnB1dCBpcyBjbGlja2VkLi4uXG4gICAgICAgICAgICAkKCcjdHJhbnNTZWwnKS5mYWRlT3V0KDEwMCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHQxID0gYnlJZCgndHJhbnNMaXN0Jykuc3R5bGUuZGlzcGxheTtcbiAgICAgICAgaWYgKHQxICE9PSBcIm5vbmVcIikgeyAvLyBpZiBmdW5jdGlvbiBsaXN0IGlzIGRpc3BsYXllZCB3aGVuIGlucHV0IGlzIGNsaWNrZWQuLi5cbiAgICAgICAgICAgICQoJyN0cmFuc0xpc3QnKS5mYWRlT3V0KDEwMCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBoaWdobGlnaHQgdGhlIHRleHRcbiAgICAgICAgJCh0aGlzKS5zZWxlY3QoKTtcbiAgICAgICAgdmFyIHBvcyA9ICQoJyN0SW5wdXQnKS5vZmZzZXQoKTtcbiAgICAgICAgcG9zLnRvcCArPSAkKCcjdElucHV0Jykud2lkdGgoKTtcbiAgICAgICAgJCgnI3RyYW5zU2VsJykuZmFkZUluKDEwMCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcblxuICAgIHZhciBuO1xuICAgICQoJyN0SW5wdXQnKS5rZXl1cChldnQgPT4ge1xuICAgICAgICB2YXIgdCA9IGJ5SWQoJ3RyYW5zU2VsJykuc3R5bGUuZGlzcGxheTtcbiAgICAgICAgdmFyIHQxID0gYnlJZCgndHJhbnNMaXN0Jykuc3R5bGUuZGlzcGxheTtcbiAgICAgICAgaWYgKHQgIT0gXCJub25lXCIpICQoJyN0cmFuc1NlbCcpLmZhZGVPdXQoMTAwKTtcbiAgICAgICAgZWxzZSBpZiAodDEgIT0gXCJub25lXCIpICQoJyN0cmFuc0xpc3QnKS5mYWRlT3V0KDEwMCk7XG5cbiAgICAgICAgaWYgKGV2dC5rZXlDb2RlID09IDEzKSB7IC8vIGtleXVwIG9uIEVudGVyXG4gICAgICAgICAgICBuID0gJCgnI3RJbnB1dCcpLnZhbCgpO1xuICAgICAgICAgICAgdmFyIHQgPSB0cmFuc1BhcnNlKG49bik7XG4gICAgICAgICAgICBpZiAoIXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdHJhbnNmb3JtKG4gPSB0LnNsaWNlKDAsIHQubGVuZ3RoIC0gMSksIHQgPSB0W3QubGVuZ3RoIC0gMV0sIHR5cGVUcmFuc2Zvcm0gPSBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciB0O1xuICAgICQoJyN0cmFuc0xpc3QgbGknKS5jbGljayhmdW5jdGlvbihldnQpe1xuICAgICAgICAvLyBpZiBpbnRlcmFjdCBpcyBzZWxlY3RlZCwgc2hvdyB2YXJpYWJsZSBsaXN0IGFnYWluXG4gICAgICAgIGlmICgkKHRoaXMpLnRleHQoKSA9PSBcImludGVyYWN0KGQsZSlcIikge1xuICAgICAgICAgICAgJCgnI3RJbnB1dCcpLnZhbCh0dmFyLmNvbmNhdCgnKicpKTtcbiAgICAgICAgICAgIHNlbEludGVyYWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICQodGhpcykucGFyZW50KCkuZmFuZGVPdXQoMTAwKTtcbiAgICAgICAgICAgICQoJyN0cmFuc1NlbCcpLmZhZGVJbigxMDApO1xuICAgICAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHR2YXIgPSAkKCcjdElucHV0JykudmFsKCk7XG4gICAgICAgIHZhciB0ZnVuYyA9ICQodGhpcykudGV4dCgpLnJlcGxhY2UoXCJkXCIsIFwiX3RyYW5zdmFyMFwiKTtcbiAgICAgICAgdmFyIHRjYWxsID0gJCh0aGlzKS50ZXh0KCkucmVwbGFjZShcImRcIiwgdHZhcik7XG4gICAgICAgICQoJyN0SW5wdXQnKS52YWwodGNhbGwpO1xuICAgICAgICAkKHRoaXMpLnBhcmVudCgpLmZhZGVPdXQoMTAwKTtcbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB0cmFuc2Zvcm0obiA9IHR2YXIsIHQgPSB0ZnVuYywgdHlwZVRyYW5zZm9ybSA9IGZhbHNlKTtcbiAgICB9KTtcblxuICAgIGQzLnNlbGVjdChcIiNtb2RlbHNcIilcbiAgICAgICAgLnN0eWxlKCdoZWlnaHQnLCAyMDAwKVxuICAgICAgICAuc3R5bGUoJ292ZXJmaWxsJywgJ3Njcm9sbCcpO1xuXG4gICAgZDMuc2VsZWN0KFwiI21vZGVsc1wiKS5zZWxlY3RBbGwoXCJwXCIpXG4gICAgICAgIC5kYXRhKE9iamVjdC5rZXlzKG1vZHMpKVxuICAgICAgICAuZW50ZXIoKVxuICAgICAgICAuYXBwZW5kKFwicFwiKVxuICAgICAgICAuYXR0cihcImlkXCIsIFwiX21vZGVsX1wiLmNvbmNhdClcbiAgICAgICAgLnRleHQoZCA9PiBkKVxuICAgICAgICAuc3R5bGUoJ2JhY2tncm91bmQtY29sb3InLCBkID0+IHZhckNvbG9yKVxuICAgICAgICAuYXR0cihcImRhdGEtY29udGFpbmVyXCIsIFwiYm9keVwiKVxuICAgICAgICAuYXR0cihcImRhdGEtdG9nZ2xlXCIsIFwicG9wb3ZlclwiKVxuICAgICAgICAuYXR0cihcImRhdGEtdHJpZ2dlclwiLCBcImhvdmVyXCIpXG4gICAgICAgIC5hdHRyKFwiZGF0YS1wbGFjZW1lbnRcIiwgXCJ0b3BcIilcbiAgICAgICAgLmF0dHIoXCJkYXRhLWh0bWxcIiwgXCJ0cnVlXCIpXG4gICAgICAgIC5hdHRyKFwib25tb3VzZW92ZXJcIiwgXCIkKHRoaXMpLnBvcG92ZXIoJ3RvZ2dsZScpO1wiKVxuICAgICAgICAuYXR0cihcIm9ubW91c2VvdXRcIiwgXCIkKHRoaXMpLnBvcG92ZXIoJ3RvZ2dsZScpO1wiKVxuICAgICAgICAuYXR0cihcImRhdGEtb3JpZ2luYWwtdGl0bGVcIiwgXCJNb2RlbCBEZXNjcmlwdGlvblwiKVxuICAgICAgICAuYXR0cihcImRhdGEtY29udGVudFwiLCBkID0+IG1vZHNbZF0pO1xuXG4gICAgLy8gY2FsbCBsYXlvdXQoKSBiZWNhdXNlIGF0IHRoaXMgcG9pbnQgYWxsIHNjYWZmb2xkaW5nIGlzIHVwIGFuZCByZWFkeVxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIG0ucmVkcmF3KCk7XG4gICAgfVxufVxuXG5sZXQgc3BsaWNlID0gKGNvbG9yLCB0ZXh0LCAuLi5hcmdzKSA9PiB7XG4gICAgYXJncy5mb3JFYWNoKHggPT4ge1xuICAgICAgICBpZiAoY29sb3IgIT0geFswXSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGlkeCA9IHpwYXJhbXNbeFsxXV0uaW5kZXhPZih0ZXh0KTtcbiAgICAgICAgaWR4ID4gLTEgJiYgenBhcmFtc1t4WzFdXS5zcGxpY2UoaWR4LCAxKTtcbiAgICB9KTtcbn07XG5cbmV4cG9ydCBsZXQgY2xpY2tWYXI7XG5cbmZ1bmN0aW9uIGxheW91dCh2KSB7XG4gICAgdmFyIG15VmFsdWVzID0gW107XG4gICAgbm9kZXMgPSBbXTtcbiAgICBsaW5rcyA9IFtdO1xuXG4gICAgaWYgKHYgPT0gbGF5b3V0QWRkIHx8IHYgPT0gbGF5b3V0TW92ZSkge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHpwYXJhbXMuenZhcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBpaSA9IGZpbmROb2RlSW5kZXgoenBhcmFtcy56dmFyc1tqXSk7XG4gICAgICAgICAgICBpZiAoYWxsTm9kZXNbaWldLmdyYXlvdXQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBub2Rlcy5wdXNoKGFsbE5vZGVzW2lpXSk7XG4gICAgICAgICAgICB2YXIgc2VsZWN0TWUgPSB6cGFyYW1zLnp2YXJzW2pdLnJlcGxhY2UoL1xcVy9nLCBcIl9cIik7XG4gICAgICAgICAgICBzZWxlY3RNZSA9IFwiI1wiLmNvbmNhdChzZWxlY3RNZSk7XG4gICAgICAgICAgICBkMy5zZWxlY3Qoc2VsZWN0TWUpLnN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJywgKCkgPT4gaGV4VG9SZ2JhKG5vZGVzW2pdLnN0cm9rZUNvbG9yKSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHpwYXJhbXMuemVkZ2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgbXlzcmMgPSBub2RlSW5kZXgoenBhcmFtcy56ZWRnZXNbal1bMF0pO1xuICAgICAgICAgICAgdmFyIG15dGd0ID0gbm9kZUluZGV4KHpwYXJhbXMuemVkZ2VzW2pdWzFdKTtcbiAgICAgICAgICAgIGxpbmtzLnB1c2goe1xuICAgICAgICAgICAgICAgIHNvdXJjZTogbm9kZXNbbXlzcmNdLFxuICAgICAgICAgICAgICAgIHRhcmdldDogbm9kZXNbbXl0Z3RdLFxuICAgICAgICAgICAgICAgIGxlZnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChhbGxOb2Rlcy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICBub2RlcyA9IFthbGxOb2Rlc1swXSwgYWxsTm9kZXNbMV0sIGFsbE5vZGVzWzJdXTtcbiAgICAgICAgICAgIGxpbmtzID0gW3tcbiAgICAgICAgICAgICAgICBzb3VyY2U6IG5vZGVzWzFdLFxuICAgICAgICAgICAgICAgIHRhcmdldDogbm9kZXNbMF0sXG4gICAgICAgICAgICAgICAgbGVmdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IHRydWVcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBzb3VyY2U6IG5vZGVzWzBdLFxuICAgICAgICAgICAgICAgIHRhcmdldDogbm9kZXNbMl0sXG4gICAgICAgICAgICAgICAgbGVmdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IHRydWVcbiAgICAgICAgICAgIH1dO1xuICAgICAgICB9IGVsc2UgaWYgKGFsbE5vZGVzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgbm9kZXMgPSBbYWxsTm9kZXNbMF0sIGFsbE5vZGVzWzFdXTtcbiAgICAgICAgICAgIGxpbmtzID0gW3tcbiAgICAgICAgICAgICAgICBzb3VyY2U6IG5vZGVzWzFdLFxuICAgICAgICAgICAgICAgIHRhcmdldDogbm9kZXNbMF0sXG4gICAgICAgICAgICAgICAgbGVmdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IHRydWVcbiAgICAgICAgICAgIH1dO1xuICAgICAgICB9IGVsc2UgaWYgKGFsbE5vZGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgbm9kZXMgPSBbYWxsTm9kZXNbMF1dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWxlcnQoXCJUaGVyZSBhcmUgemVybyB2YXJpYWJsZXMgaW4gdGhlIG1ldGFkYXRhLlwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHBhbmVsUGxvdHMoKTsgLy8gYWZ0ZXIgbm9kZXMgaXMgcG9wdWxhdGVkLCBhZGQgc3Vic2V0IGFuZCBzZXR4IHBhbmVsc1xuXG4gICAgdmFyIGZvcmNlID0gZDMubGF5b3V0LmZvcmNlKClcbiAgICAgICAgLm5vZGVzKG5vZGVzKVxuICAgICAgICAubGlua3MobGlua3MpXG4gICAgICAgIC5zaXplKFt3aWR0aCwgaGVpZ2h0XSlcbiAgICAgICAgLmxpbmtEaXN0YW5jZSgxNTApXG4gICAgICAgIC5jaGFyZ2UoLTgwMClcbiAgICAgICAgLm9uKCd0aWNrJywgdGljayk7XG5cbiAgICAvLyBkZWZpbmUgYXJyb3cgbWFya2VycyBmb3IgZ3JhcGggbGlua3NcbiAgICBzdmcuYXBwZW5kKCdzdmc6ZGVmcycpLmFwcGVuZCgnc3ZnOm1hcmtlcicpXG4gICAgICAgIC5hdHRyKCdpZCcsICdlbmQtYXJyb3cnKVxuICAgICAgICAuYXR0cigndmlld0JveCcsICcwIC01IDEwIDEwJylcbiAgICAgICAgLmF0dHIoJ3JlZlgnLCA2KVxuICAgICAgICAuYXR0cignbWFya2VyV2lkdGgnLCAzKVxuICAgICAgICAuYXR0cignbWFya2VySGVpZ2h0JywgMylcbiAgICAgICAgLmF0dHIoJ29yaWVudCcsICdhdXRvJylcbiAgICAgICAgLmFwcGVuZCgnc3ZnOnBhdGgnKVxuICAgICAgICAuYXR0cignZCcsICdNMCwtNUwxMCwwTDAsNScpXG4gICAgICAgIC5zdHlsZSgnZmlsbCcsICcjMDAwJyk7XG5cbiAgICBzdmcuYXBwZW5kKCdzdmc6ZGVmcycpLmFwcGVuZCgnc3ZnOm1hcmtlcicpXG4gICAgICAgIC5hdHRyKCdpZCcsICdzdGFydC1hcnJvdycpXG4gICAgICAgIC5hdHRyKCd2aWV3Qm94JywgJzAgLTUgMTAgMTAnKVxuICAgICAgICAuYXR0cigncmVmWCcsIDQpXG4gICAgICAgIC5hdHRyKCdtYXJrZXJXaWR0aCcsIDMpXG4gICAgICAgIC5hdHRyKCdtYXJrZXJIZWlnaHQnLCAzKVxuICAgICAgICAuYXR0cignb3JpZW50JywgJ2F1dG8nKVxuICAgICAgICAuYXBwZW5kKCdzdmc6cGF0aCcpXG4gICAgICAgIC5hdHRyKCdkJywgJ00xMCwtNUwwLDBMMTAsNScpXG4gICAgICAgIC5zdHlsZSgnZmlsbCcsICcjMDAwJyk7XG5cbiAgICAvLyBsaW5lIGRpc3BsYXllZCB3aGVuIGRyYWdnaW5nIG5ldyBub2Rlc1xuICAgIHZhciBkcmFnX2xpbmUgPSBzdmcuYXBwZW5kKCdzdmc6cGF0aCcpXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdsaW5rIGRyYWdsaW5lIGhpZGRlbicpXG4gICAgICAgIC5hdHRyKCdkJywgJ00wLDBMMCwwJyk7XG5cbiAgICAvLyBoYW5kbGVzIHRvIGxpbmsgYW5kIG5vZGUgZWxlbWVudCBncm91cHNcbiAgICB2YXIgcGF0aCA9IHN2Zy5hcHBlbmQoJ3N2ZzpnJykuc2VsZWN0QWxsKCdwYXRoJyksXG4gICAgICAgIGNpcmNsZSA9IHN2Zy5hcHBlbmQoJ3N2ZzpnJykuc2VsZWN0QWxsKCdnJyk7XG5cbiAgICAvLyBtb3VzZSBldmVudCB2YXJzXG4gICAgdmFyIHNlbGVjdGVkX25vZGUgPSBudWxsLFxuICAgICAgICBzZWxlY3RlZF9saW5rID0gbnVsbCxcbiAgICAgICAgbW91c2Vkb3duX2xpbmsgPSBudWxsLFxuICAgICAgICBtb3VzZWRvd25fbm9kZSA9IG51bGwsXG4gICAgICAgIG1vdXNldXBfbm9kZSA9IG51bGw7XG5cbiAgICBmdW5jdGlvbiByZXNldE1vdXNlVmFycygpIHtcbiAgICAgICAgbW91c2Vkb3duX25vZGUgPSBudWxsO1xuICAgICAgICBtb3VzZXVwX25vZGUgPSBudWxsO1xuICAgICAgICBtb3VzZWRvd25fbGluayA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIGZvcmNlIGxheW91dCAoY2FsbGVkIGF1dG9tYXRpY2FsbHkgZWFjaCBpdGVyYXRpb24pXG4gICAgZnVuY3Rpb24gdGljaygpIHtcbiAgICAgICAgLy8gZHJhdyBkaXJlY3RlZCBlZGdlcyB3aXRoIHByb3BlciBwYWRkaW5nIGZyb20gbm9kZSBjZW50ZXJzXG4gICAgICAgIHBhdGguYXR0cignZCcsIGQgPT4ge1xuICAgICAgICAgICAgdmFyIGRlbHRhWCA9IGQudGFyZ2V0LnggLSBkLnNvdXJjZS54LFxuICAgICAgICAgICAgICAgIGRlbHRhWSA9IGQudGFyZ2V0LnkgLSBkLnNvdXJjZS55LFxuICAgICAgICAgICAgICAgIGRpc3QgPSBNYXRoLnNxcnQoZGVsdGFYICogZGVsdGFYICsgZGVsdGFZICogZGVsdGFZKSxcbiAgICAgICAgICAgICAgICBub3JtWCA9IGRlbHRhWCAvIGRpc3QsXG4gICAgICAgICAgICAgICAgbm9ybVkgPSBkZWx0YVkgLyBkaXN0LFxuICAgICAgICAgICAgICAgIHNvdXJjZVBhZGRpbmcgPSBkLmxlZnQgPyBhbGxSICsgNSA6IGFsbFIsXG4gICAgICAgICAgICAgICAgdGFyZ2V0UGFkZGluZyA9IGQucmlnaHQgPyBhbGxSICsgNSA6IGFsbFIsXG4gICAgICAgICAgICAgICAgc291cmNlWCA9IGQuc291cmNlLnggKyAoc291cmNlUGFkZGluZyAqIG5vcm1YKSxcbiAgICAgICAgICAgICAgICBzb3VyY2VZID0gZC5zb3VyY2UueSArIChzb3VyY2VQYWRkaW5nICogbm9ybVkpLFxuICAgICAgICAgICAgICAgIHRhcmdldFggPSBkLnRhcmdldC54IC0gKHRhcmdldFBhZGRpbmcgKiBub3JtWCksXG4gICAgICAgICAgICAgICAgdGFyZ2V0WSA9IGQudGFyZ2V0LnkgLSAodGFyZ2V0UGFkZGluZyAqIG5vcm1ZKTtcbiAgICAgICAgICAgIHJldHVybiBgTSR7c291cmNlWH0sJHtzb3VyY2VZfUwke3RhcmdldFh9LCR7dGFyZ2V0WX1gO1xuICAgICAgICB9KTtcbiAgICAgICAgY2lyY2xlLmF0dHIoJ3RyYW5zZm9ybScsIGQgPT4gJ3RyYW5zbGF0ZSgnICsgZC54ICsgJywnICsgZC55ICsgJyknKTtcbiAgICB9XG5cbiAgICBjbGlja1ZhciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBldmVyeSB0aW1lIGEgdmFyaWFibGUgaW4gbGVmdHBhbmVsIGlzIGNsaWNrZWQsIG5vZGVzIHVwZGF0ZXMgYW5kIGJhY2tncm91bmQgY29sb3IgY2hhbmdlc1xuICAgICAgICBpZiAoZmluZE5vZGVJbmRleCh0aGlzLmlkLCB0cnVlKS5ncmF5b3V0KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB6cGFyYW1zLnp2YXJzID0gW107XG4gICAgICAgIGxldCB0ZXh0ID0gZDMuc2VsZWN0KHRoaXMpLnRleHQoKTtcbiAgICAgICAgbGV0IG5vZGUgPSBmaW5kTm9kZSh0ZXh0KTtcbiAgICAgICAgaWYgKG5vZGVzLm1hcChuID0+IG4ubmFtZSkuaW5jbHVkZXModGV4dCkpIHtcbiAgICAgICAgICAgIG5vZGVzLnNwbGljZShub2RlLmluZGV4LCAxKTtcbiAgICAgICAgICAgIHNwbGljZUxpbmtzRm9yTm9kZShub2RlKTtcbiAgICAgICAgICAgIHNwbGljZShub2RlLnN0cm9rZUNvbG9yLCB0ZXh0LCBbZHZDb2xvciwgJ3pkdiddLCBbY3NDb2xvciwgJ3pjcm9zcyddLCBbdGltZUNvbG9yLCAnenRpbWUnXSwgW25vbUNvbG9yLCAnem5vbSddKTtcbiAgICAgICAgICAgIG5vZGVSZXNldChub2RlKTtcbiAgICAgICAgICAgIGxlZ2VuZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgICAgIGlmIChub2Rlcy5sZW5ndGggPT09IDApIG5vZGVzWzBdLnJlZmxleGl2ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcGFuZWxQbG90cygpO1xuICAgICAgICByZXN0YXJ0KCk7XG4gICAgfVxuXG4gICAgZDMuc2VsZWN0KFwiI21vZGVsc1wiKS5zZWxlY3RBbGwoXCJwXCIpIC8vIG1vZGVscyB0YWJcbiAgICAgICAgLy8gIGQzLnNlbGVjdChcIiNEaXNwbGF5X2NvbnRlbnRcIilcbiAgICAgICAgLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgbXlDb2xvciA9IGQzLnNlbGVjdCh0aGlzKS5zdHlsZSgnYmFja2dyb3VuZC1jb2xvcicpO1xuICAgICAgICAgICAgZDMuc2VsZWN0KFwiI21vZGVsc1wiKS5zZWxlY3RBbGwoXCJwXCIpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJywgdmFyQ29sb3IpO1xuICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJywgZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkMy5yZ2IobXlDb2xvcikudG9TdHJpbmcoKSA9PT0gdmFyQ29sb3IudG9TdHJpbmcoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgenBhcmFtcy56bW9kZWwgPSBkLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGV4VG9SZ2JhKHNlbFZhckNvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHpwYXJhbXMuem1vZGVsID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFyQ29sb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlc3RhcnQoKTtcbiAgICAgICAgfSk7XG5cbiAgICAvLyB1cGRhdGUgZ3JhcGggKGNhbGxlZCB3aGVuIG5lZWRlZClcbiAgICBmdW5jdGlvbiByZXN0YXJ0KCkge1xuICAgICAgICAvLyBub2Rlcy5pZCBpcyBwZWdnZWQgdG8gYWxsTm9kZXMsIGkuZS4gdGhlIG9yZGVyIGluIHdoaWNoIHZhcmlhYmxlcyBhcmUgcmVhZCBpblxuICAgICAgICAvLyBub2Rlcy5pbmRleCBpcyBmbG9hdGluZyBhbmQgZGVwZW5kcyBvbiB1cGRhdGVzIHRvIG5vZGVzLiAgYSB2YXJpYWJsZXMgaW5kZXggY2hhbmdlcyB3aGVuIG5ldyB2YXJpYWJsZXMgYXJlIGFkZGVkLlxuICAgICAgICBjaXJjbGUuY2FsbChmb3JjZS5kcmFnKTtcbiAgICAgICAgaWYgKGZvcmNldG9nZ2xlWzBdID09IFwidHJ1ZVwiKSB7XG4gICAgICAgICAgICBmb3JjZS5ncmF2aXR5KDAuMSk7XG4gICAgICAgICAgICBmb3JjZS5jaGFyZ2UoLTgwMCk7XG4gICAgICAgICAgICBmb3JjZS5saW5rU3RyZW5ndGgoMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3JjZS5ncmF2aXR5KDApO1xuICAgICAgICAgICAgZm9yY2UuY2hhcmdlKDApO1xuICAgICAgICAgICAgZm9yY2UubGlua1N0cmVuZ3RoKDApO1xuICAgICAgICB9XG4gICAgICAgIGZvcmNlLnJlc3VtZSgpO1xuXG4gICAgICAgIC8vIHBhdGggKGxpbmspIGdyb3VwXG4gICAgICAgIHBhdGggPSBwYXRoLmRhdGEobGlua3MpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSBleGlzdGluZyBsaW5rc1xuICAgICAgICAvLyBWSkQ6IGRhc2hlZCBsaW5rcyBiZXR3ZWVuIHBlYmJsZXMgYXJlIFwic2VsZWN0ZWRcIi4gdGhpcyBpcyBkaXNhYmxlZCBmb3Igbm93XG4gICAgICAgIHBhdGguY2xhc3NlZCgnc2VsZWN0ZWQnLCB4ID0+IG51bGwpXG4gICAgICAgICAgICAuc3R5bGUoJ21hcmtlci1zdGFydCcsIHggPT4geC5sZWZ0ID8gJ3VybCgjc3RhcnQtYXJyb3cpJyA6ICcnKVxuICAgICAgICAgICAgLnN0eWxlKCdtYXJrZXItZW5kJywgeCA9PiB4LnJpZ2h0ID8gJ3VybCgjZW5kLWFycm93KScgOiAnJyk7XG5cbiAgICAgICAgLy8gYWRkIG5ldyBsaW5rc1xuICAgICAgICBwYXRoLmVudGVyKCkuYXBwZW5kKCdzdmc6cGF0aCcpXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbGluaycpXG4gICAgICAgICAgICAuY2xhc3NlZCgnc2VsZWN0ZWQnLCB4ID0+IG51bGwpXG4gICAgICAgICAgICAuc3R5bGUoJ21hcmtlci1zdGFydCcsIHggPT4geC5sZWZ0ID8gJ3VybCgjc3RhcnQtYXJyb3cpJyA6ICcnKVxuICAgICAgICAgICAgLnN0eWxlKCdtYXJrZXItZW5kJywgeCA9PiB4LnJpZ2h0ID8gJ3VybCgjZW5kLWFycm93KScgOiAnJylcbiAgICAgICAgICAgIC5vbignbW91c2Vkb3duJywgZnVuY3Rpb24oZCkgeyAvLyBkbyB3ZSBldmVyIG5lZWQgdG8gc2VsZWN0IGEgbGluaz8gbWFrZSBpdCBkZWxldGUuLlxuICAgICAgICAgICAgICAgIHZhciBvYmogPSBKU09OLnN0cmluZ2lmeShkKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxpbmtzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmogPT09IEpTT04uc3RyaW5naWZ5KGxpbmtzW2pdKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtzLnNwbGljZShqLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAvLyByZW1vdmUgb2xkIGxpbmtzXG4gICAgICAgIHBhdGguZXhpdCgpLnJlbW92ZSgpO1xuXG4gICAgICAgIC8vIGNpcmNsZSAobm9kZSkgZ3JvdXBcbiAgICAgICAgY2lyY2xlID0gY2lyY2xlLmRhdGEobm9kZXMsIHggPT4geC5pZCk7XG5cbiAgICAgICAgLy8gdXBkYXRlIGV4aXN0aW5nIG5vZGVzIChyZWZsZXhpdmUgJiBzZWxlY3RlZCB2aXN1YWwgc3RhdGVzKVxuICAgICAgICAvLyBkMy5yZ2IgaXMgdGhlIGZ1bmN0aW9uIGFkanVzdGluZyB0aGUgY29sb3IgaGVyZVxuICAgICAgICBjaXJjbGUuc2VsZWN0QWxsKCdjaXJjbGUnKVxuICAgICAgICAgICAgLmNsYXNzZWQoJ3JlZmxleGl2ZScsIHggPT4geC5yZWZsZXhpdmUpXG4gICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCB4ID0+IGQzLnJnYih4Lm5vZGVDb2wpKVxuICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCB4ID0+IGQzLnJnYih4LnN0cm9rZUNvbG9yKSlcbiAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlLXdpZHRoJywgeCA9PiB4LnN0cm9rZVdpZHRoKTtcblxuICAgICAgICAvLyBhZGQgbmV3IG5vZGVzXG4gICAgICAgIGxldCBnID0gY2lyY2xlLmVudGVyKClcbiAgICAgICAgICAgIC5hcHBlbmQoJ3N2ZzpnJylcbiAgICAgICAgICAgIC5hdHRyKCdpZCcsIHggPT4geC5uYW1lICsgJ2JpZ2dyb3VwJyk7XG5cbiAgICAgICAgLy8gYWRkIHBsb3RcbiAgICAgICAgZy5lYWNoKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKTtcbiAgICAgICAgICAgIGlmIChkLnBsb3R0eXBlID09ICdjb250aW51b3VzJykgZGVuc2l0eU5vZGUoZCwgdGhpcyk7XG4gICAgICAgICAgICBlbHNlIGlmIChkLnBsb3R0eXBlID09ICdiYXInKSBiYXJzTm9kZShkLCB0aGlzKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbGV0IGFwcGVuZCA9IChzdHIsIGF0dHIpID0+IHggPT4gc3RyICsgeFthdHRyIHx8ICdpZCddO1xuXG4gICAgICAgIGcuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBhcHBlbmQoJ2R2QXJjJykpXG4gICAgICAgICAgICAuYXR0cihcImRcIiwgYXJjMylcbiAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgZHZDb2xvcilcbiAgICAgICAgICAgIC5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICBmaWxsVGhpcyh0aGlzLCAuMywgMCwgMTAwKTtcbiAgICAgICAgICAgICAgICBmaWxsKGQsICdkdlRleHQnLCAuOSwgMCwgMTAwKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIGZpbGxUaGlzKHRoaXMsIDAsIDEwMCwgNTAwKTtcbiAgICAgICAgICAgICAgICBmaWxsKGQsICdkdlRleHQnLCAwLCAxMDAsIDUwMCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdjbGljaycsIGQgPT4ge1xuICAgICAgICAgICAgICAgIHNldENvbG9ycyhkLCBkdkNvbG9yKTtcbiAgICAgICAgICAgICAgICBsZWdlbmQoZHZDb2xvcik7XG4gICAgICAgICAgICAgICAgcmVzdGFydCgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgZy5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsIGFwcGVuZCgnZHZUZXh0JykpXG4gICAgICAgICAgICAuYXR0cihcInhcIiwgNilcbiAgICAgICAgICAgIC5hdHRyKFwiZHlcIiwgMTEuNSlcbiAgICAgICAgICAgIC5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAuYXBwZW5kKFwidGV4dFBhdGhcIilcbiAgICAgICAgICAgIC5hdHRyKFwieGxpbms6aHJlZlwiLCBhcHBlbmQoJyNkdkFyYycpKVxuICAgICAgICAgICAgLnRleHQoXCJEZXAgVmFyXCIpO1xuXG4gICAgICAgIGcuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBhcHBlbmQoJ25vbUFyYycpKVxuICAgICAgICAgICAgLmF0dHIoXCJkXCIsIGFyYzQpXG4gICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIG5vbUNvbG9yKVxuICAgICAgICAgICAgLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIGlmIChkLmRlZmF1bHROdW1jaGFyID09IFwiY2hhcmFjdGVyXCIpIHJldHVybjtcbiAgICAgICAgICAgICAgICBmaWxsVGhpcyh0aGlzLCAuMywgMCwgMTAwKTtcbiAgICAgICAgICAgICAgICBmaWxsKGQsIFwibm9tVGV4dFwiLCAuOSwgMCwgMTAwKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIGlmIChkLmRlZmF1bHROdW1jaGFyID09IFwiY2hhcmFjdGVyXCIpIHJldHVybjtcbiAgICAgICAgICAgICAgICBmaWxsVGhpcyh0aGlzLCAwLCAxMDAsIDUwMCk7XG4gICAgICAgICAgICAgICAgZmlsbChkLCBcIm5vbVRleHRcIiwgMCwgMTAwLCA1MDApO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignY2xpY2snLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGQuZGVmYXVsdE51bWNoYXIgPT0gXCJjaGFyYWN0ZXJcIikgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHNldENvbG9ycyhkLCBub21Db2xvcik7XG4gICAgICAgICAgICAgICAgbGVnZW5kKG5vbUNvbG9yKTtcbiAgICAgICAgICAgICAgICByZXN0YXJ0KCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgYXBwZW5kKFwibm9tVGV4dFwiKSlcbiAgICAgICAgICAgIC5hdHRyKFwieFwiLCA2KVxuICAgICAgICAgICAgLmF0dHIoXCJkeVwiLCAxMS41KVxuICAgICAgICAgICAgLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgIC5hcHBlbmQoXCJ0ZXh0UGF0aFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ4bGluazpocmVmXCIsIGFwcGVuZChcIiNub21BcmNcIikpXG4gICAgICAgICAgICAudGV4dChcIk5vbWluYWxcIik7XG5cbiAgICAgICAgZy5hcHBlbmQoJ3N2ZzpjaXJjbGUnKVxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ25vZGUnKVxuICAgICAgICAgICAgLmF0dHIoJ3InLCBhbGxSKVxuICAgICAgICAgICAgLnN0eWxlKCdwb2ludGVyLWV2ZW50cycsICdpbmhlcml0JylcbiAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIGQgPT4gZC5ub2RlQ29sKVxuICAgICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgXCIwLjVcIilcbiAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgZCA9PiBkMy5yZ2IoZC5zdHJva2VDb2xvcikudG9TdHJpbmcoKSlcbiAgICAgICAgICAgIC5jbGFzc2VkKCdyZWZsZXhpdmUnLCBkID0+IGQucmVmbGV4aXZlKVxuICAgICAgICAgICAgLm9uKCdkYmxjbGljaycsIGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgICAgICAgICBkMy5ldmVudC5zdG9wUHJvcGFnYXRpb24oKTsgLy8gc3RvcCBjbGljayBmcm9tIGJ1YmJsaW5nXG4gICAgICAgICAgICAgICAgc3VtbWFyeUhvbGQgPSB0cnVlO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignY29udGV4dG1lbnUnLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgLy8gcmlnaHQgY2xpY2sgb24gbm9kZVxuICAgICAgICAgICAgICAgIGQzLmV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZDMuZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgICAgICAgICByaWdodENsaWNrTGFzdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgbW91c2Vkb3duX25vZGUgPSBkO1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkX25vZGUgPSBtb3VzZWRvd25fbm9kZSA9PT0gc2VsZWN0ZWRfbm9kZSA/IG51bGwgOiBtb3VzZWRvd25fbm9kZTtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZF9saW5rID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIC8vIHJlcG9zaXRpb24gZHJhZyBsaW5lXG4gICAgICAgICAgICAgICAgZHJhZ19saW5lXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnbWFya2VyLWVuZCcsICd1cmwoI2VuZC1hcnJvdyknKVxuICAgICAgICAgICAgICAgICAgICAuY2xhc3NlZCgnaGlkZGVuJywgZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkJywgJ00nICsgbW91c2Vkb3duX25vZGUueCArICcsJyArIG1vdXNlZG93bl9ub2RlLnkgKyAnTCcgKyBtb3VzZWRvd25fbm9kZS54ICsgJywnICsgbW91c2Vkb3duX25vZGUueSk7XG5cbiAgICAgICAgICAgICAgICBzdmcub24oJ21vdXNlbW92ZScsIG1vdXNlbW92ZSk7XG4gICAgICAgICAgICAgICAgcmVzdGFydCgpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignbW91c2V1cCcsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICBkMy5ldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAgICAgICAgIGlmIChyaWdodENsaWNrTGFzdCkge1xuICAgICAgICAgICAgICAgICAgICByaWdodENsaWNrTGFzdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghbW91c2Vkb3duX25vZGUpIHJldHVybjtcblxuICAgICAgICAgICAgICAgIC8vIG5lZWRlZCBieSBGRlxuICAgICAgICAgICAgICAgIGRyYWdfbGluZVxuICAgICAgICAgICAgICAgICAgICAuY2xhc3NlZCgnaGlkZGVuJywgdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdtYXJrZXItZW5kJywgJycpO1xuXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGRyYWctdG8tc2VsZlxuICAgICAgICAgICAgICAgIG1vdXNldXBfbm9kZSA9IGQ7XG4gICAgICAgICAgICAgICAgaWYgKG1vdXNldXBfbm9kZSA9PT0gbW91c2Vkb3duX25vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzZXRNb3VzZVZhcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHVuZW5sYXJnZSB0YXJnZXQgbm9kZVxuICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5hdHRyKCd0cmFuc2Zvcm0nLCAnJyk7XG5cbiAgICAgICAgICAgICAgICAvLyBhZGQgbGluayB0byBncmFwaCAodXBkYXRlIGlmIGV4aXN0cylcbiAgICAgICAgICAgICAgICAvLyBOQjogbGlua3MgYXJlIHN0cmljdGx5IHNvdXJjZSA8IHRhcmdldDsgYXJyb3dzIHNlcGFyYXRlbHkgc3BlY2lmaWVkIGJ5IGJvb2xlYW5zXG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZSwgdGFyZ2V0LCBkaXJlY3Rpb247XG4gICAgICAgICAgICAgICAgaWYgKG1vdXNlZG93bl9ub2RlLmlkIDwgbW91c2V1cF9ub2RlLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZSA9IG1vdXNlZG93bl9ub2RlO1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSBtb3VzZXVwX25vZGU7XG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlID0gbW91c2V1cF9ub2RlO1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSBtb3VzZWRvd25fbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gJ2xlZnQnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxldCBsaW5rID0gbGlua3MuZmlsdGVyKHggPT4geC5zb3VyY2UgPT0gc291cmNlICYmIHgudGFyZ2V0ID09IHRhcmdldClbMF07XG4gICAgICAgICAgICAgICAgaWYgKGxpbmspIHtcbiAgICAgICAgICAgICAgICAgICAgbGlua1tkaXJlY3Rpb25dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsaW5rID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGxpbmtbZGlyZWN0aW9uXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGxpbmtzLnB1c2gobGluayk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gc2VsZWN0IG5ldyBsaW5rXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRfbGluayA9IGxpbms7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRfbm9kZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgc3ZnLm9uKCdtb3VzZW1vdmUnLCBudWxsKTtcblxuICAgICAgICAgICAgICAgIHJlc2V0TW91c2VWYXJzKCk7XG4gICAgICAgICAgICAgICAgcmVzdGFydCgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gc2hvdyBub2RlIG5hbWVzXG4gICAgICAgIGcuYXBwZW5kKCdzdmc6dGV4dCcpXG4gICAgICAgICAgICAuYXR0cigneCcsIDApXG4gICAgICAgICAgICAuYXR0cigneScsIDE1KVxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2lkJylcbiAgICAgICAgICAgIC50ZXh0KGQgPT4gZC5uYW1lKTtcblxuICAgICAgICAvLyBzaG93IHN1bW1hcnkgc3RhdHMgb24gbW91c2VvdmVyXG4gICAgICAgIC8vIFNWRyBkb2Vzbid0IHN1cHBvcnQgdGV4dCB3cmFwcGluZywgdXNlIGh0bWwgaW5zdGVhZFxuICAgICAgICBnLnNlbGVjdEFsbChcImNpcmNsZS5ub2RlXCIpXG4gICAgICAgICAgICAub24oXCJtb3VzZW92ZXJcIiwgZCA9PiB7XG4gICAgICAgICAgICAgICAgdGFiTGVmdCgndGFiMycpO1xuICAgICAgICAgICAgICAgIHZhclN1bW1hcnkoZCk7XG5cbiAgICAgICAgICAgICAgICBieUlkKCd0cmFuc2Zvcm1hdGlvbnMnKS5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2Rpc3BsYXk6YmxvY2snKTtcbiAgICAgICAgICAgICAgICBieUlkKFwidHJhbnNTZWxcIikuc2VsZWN0ZWRJbmRleCA9IGQuaWQ7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtVmFyID0gdmFsdWVLZXlbZC5pZF07XG5cbiAgICAgICAgICAgICAgICBmaWxsKGQsIFwiZHZBcmNcIiwgLjEsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgZmlsbChkLCBcImR2VGV4dFwiLCAuNSwgMCwgMTAwKTtcbiAgICAgICAgICAgICAgICBpZiAoZC5kZWZhdWx0TnVtY2hhciA9PSBcIm51bWVyaWNcIikge1xuICAgICAgICAgICAgICAgICAgICBmaWxsKGQsIFwibm9tQXJjXCIsIC4xLCAwLCAxMDApO1xuICAgICAgICAgICAgICAgICAgICBmaWxsKGQsIFwibm9tVGV4dFwiLCAuNSwgMCwgMTAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmlsbChkLCBcImNzQXJjXCIsIC4xLCAwLCAxMDApO1xuICAgICAgICAgICAgICAgIGZpbGwoZCwgXCJjc1RleHRcIiwgLjUsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgZmlsbChkLCBcInRpbWVBcmNcIiwgLjEsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgZmlsbChkLCBcInRpbWVUZXh0XCIsIC41LCAwLCAxMDApO1xuXG4gICAgICAgICAgICAgICAgbS5yZWRyYXcoKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZCA9PiB7XG4gICAgICAgICAgICAgICAgc3VtbWFyeUhvbGQgfHwgdGFiTGVmdChzdWJzZXQgPyAndGFiMicgOiAndGFiMScpO1xuICAgICAgICAgICAgICAgICdjc0FyYyBjc1RleHQgdGltZUFyYyB0aW1lVGV4dCBkdkFyYyBkdlRleHQgbm9tQXJjIG5vbVRleHQnLnNwbGl0KCcgJykubWFwKHggPT4gZmlsbChkLCB4LCAwLCAxMDAsIDUwMCkpO1xuICAgICAgICAgICAgICAgIG0ucmVkcmF3KCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAvLyB0aGUgdHJhbnNmb3JtYXRpb24gdmFyaWFibGUgbGlzdCBpcyBzaWxlbnRseSB1cGRhdGVkIGFzIHBlYmJsZXMgYXJlIGFkZGVkL3JlbW92ZWRcbiAgICAgICAgZDMuc2VsZWN0KFwiI3RyYW5zU2VsXCIpXG4gICAgICAgICAgICAuc2VsZWN0QWxsKCdsaScpXG4gICAgICAgICAgICAucmVtb3ZlKCk7XG5cbiAgICAgICAgZDMuc2VsZWN0KFwiI3RyYW5zU2VsXCIpXG4gICAgICAgICAgICAuc2VsZWN0QWxsKCdsaScpXG4gICAgICAgICAgICAuZGF0YShub2Rlcy5tYXAoeCA9PiB4Lm5hbWUpKSAvLyBzZXQgdG8gdmFyaWFibGVzIGluIG1vZGVsIHNwYWNlIGFzIHRoZXkncmUgYWRkZWRcbiAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAuYXBwZW5kKFwibGlcIilcbiAgICAgICAgICAgIC50ZXh0KGQgPT4gZCk7XG5cbiAgICAgICAgJCgnI3RyYW5zU2VsIGxpJykuY2xpY2soZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgICAvLyBpZiAnaW50ZXJhY3Rpb24nIGlzIHRoZSBzZWxlY3RlZCBmdW5jdGlvbiwgZG9uJ3Qgc2hvdyB0aGUgZnVuY3Rpb24gbGlzdCBhZ2FpblxuICAgICAgICAgICAgaWYgKHNlbEludGVyYWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIG4gPSAkKCcjdElucHV0JykudmFsKCkuY29uY2F0KCQodGhpcykudGV4dCgpKTtcbiAgICAgICAgICAgICAgICAkKCcjdElucHV0JykudmFsKG4pO1xuICAgICAgICAgICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHRyYW5zUGFyc2UobiA9IG4pO1xuICAgICAgICAgICAgICAgIGlmICghdCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICQodGhpcykucGFyZW50KCkuZmFkZU91dCgxMDApO1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybShuID0gdC5zbGljZSgwLCB0Lmxlbmd0aCAtIDEpLCB0ID0gdFt0Lmxlbmd0aCAtIDFdLCB0eXBlVHJhbnNmb3JtID0gZmFsc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgJCgnI3RJbnB1dCcpLnZhbCgkKHRoaXMpLnRleHQoKSk7XG4gICAgICAgICAgICAkKHRoaXMpLnBhcmVudCgpLmZhZGVPdXQoMTAwKTtcbiAgICAgICAgICAgICQoJyN0cmFuc0xpc3QnKS5mYWRlSW4oMTAwKTtcbiAgICAgICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gcmVtb3ZlIG9sZCBub2Rlc1xuICAgICAgICBjaXJjbGUuZXhpdCgpLnJlbW92ZSgpO1xuICAgICAgICBmb3JjZS5zdGFydCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vdXNlZG93bihkKSB7XG4gICAgICAgIC8vIHByZXZlbnQgSS1iYXIgb24gZHJhZ1xuICAgICAgICBkMy5ldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAvLyBiZWNhdXNlIDphY3RpdmUgb25seSB3b3JrcyBpbiBXZWJLaXQ/XG4gICAgICAgIHN2Zy5jbGFzc2VkKCdhY3RpdmUnLCB0cnVlKTtcbiAgICAgICAgaWYgKGQzLmV2ZW50LmN0cmxLZXkgfHwgbW91c2Vkb3duX25vZGUgfHwgbW91c2Vkb3duX2xpbmspIHJldHVybjtcbiAgICAgICAgcmVzdGFydCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vdXNlbW92ZShkKSB7XG4gICAgICAgIGlmICghbW91c2Vkb3duX25vZGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIHVwZGF0ZSBkcmFnIGxpbmVcbiAgICAgICAgZHJhZ19saW5lLmF0dHIoJ2QnLCAnTScgKyBtb3VzZWRvd25fbm9kZS54ICsgJywnICsgbW91c2Vkb3duX25vZGUueSArICdMJyArIGQzLm1vdXNlKHRoaXMpWzBdICsgJywnICsgZDMubW91c2UodGhpcylbMV0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vdXNldXAoZCkge1xuICAgICAgICBpZiAobW91c2Vkb3duX25vZGUpIHtcbiAgICAgICAgICAgIGRyYWdfbGluZVxuICAgICAgICAgICAgICAgIC5jbGFzc2VkKCdoaWRkZW4nLCB0cnVlKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnbWFya2VyLWVuZCcsICcnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBiZWNhdXNlIDphY3RpdmUgb25seSB3b3JrcyBpbiBXZWJLaXQ/XG4gICAgICAgIHN2Zy5jbGFzc2VkKCdhY3RpdmUnLCBmYWxzZSk7XG4gICAgICAgIC8vIGNsZWFyIG1vdXNlIGV2ZW50IHZhcnNcbiAgICAgICAgcmVzZXRNb3VzZVZhcnMoKTtcbiAgICB9XG5cbiAgICAvLyBhcHAgc3RhcnRzIGhlcmVcbiAgICBzdmcuYXR0cignaWQnLCAoKSA9PiBcIndoaXRlc3BhY2VcIi5jb25jYXQobXlzcGFjZSkpXG4gICAgICAgIC5hdHRyKCdoZWlnaHQnLCBoZWlnaHQpXG4gICAgICAgIC5vbignbW91c2Vkb3duJywgZnVuY3Rpb24oKSB7bW91c2Vkb3duKHRoaXMpO30pXG4gICAgICAgIC5vbignbW91c2V1cCcsIGZ1bmN0aW9uKCkge21vdXNldXAodGhpcyk7fSk7XG5cbiAgICBkMy5zZWxlY3Qod2luZG93KVxuICAgICAgICAub24oJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgICAgLy8gYWxsIGNsaWNrcyB3aWxsIGJ1YmJsZSBoZXJlIHVubGVzcyBldmVudC5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgICAgICAgJCgnI3RyYW5zTGlzdCcpLmZhZGVPdXQoMTAwKTtcbiAgICAgICAgICAgICQoJyN0cmFuc1NlbCcpLmZhZGVPdXQoMTAwKTtcbiAgICAgICAgfSk7XG5cbiAgICByZXN0YXJ0KCk7IC8vIGluaXRpYWxpemVzIGZvcmNlLmxheW91dCgpXG4gICAgZmFrZUNsaWNrKCk7XG59XG5cblxubGV0IGZpbmQgPSAoJG5vZGVzLCBuYW1lKSA9PiB7XG4gICAgZm9yIChsZXQgaSBpbiAkbm9kZXMpXG4gICAgICAgIGlmICgkbm9kZXNbaV0ubmFtZSA9PSBuYW1lKSByZXR1cm4gJG5vZGVzW2ldLmlkO1xufTtcblxuLy8gcmV0dXJucyBpZFxuZXhwb3J0IGxldCBmaW5kTm9kZUluZGV4ID0gKG5hbWUsIGFsbCkgPT4ge1xuICAgIGZvciAobGV0IG5vZGUgb2YgYWxsTm9kZXMpIHtcbiAgICAgICAgaWYgKG5vZGUubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgLy9jZGIoJ1llcyEnICsgYWxsTm9kZXNbaV0uaWQpO1xuICAgICAgICAgICAgcmV0dXJuIGFsbD8gbm9kZSA6IG5vZGUuaWQ7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5sZXQgbm9kZUluZGV4ID0gbm9kZU5hbWUgPT4ge1xuICAgIGZvciAobGV0IGkgaW4gbm9kZXMpXG4gICAgICAgIGlmIChub2Rlc1tpXS5uYW1lID09IG5vZGVOYW1lKSByZXR1cm4gaTtcbn07XG5cbmV4cG9ydCBsZXQgZmluZE5vZGUgPSBub2RlTmFtZSA9PiB7XG4gICAgZm9yIChsZXQgaSBpbiBhbGxOb2RlcylcbiAgICAgICAgaWYgKGFsbE5vZGVzW2ldLm5hbWUgPT0gbm9kZU5hbWUpIHJldHVybiBhbGxOb2Rlc1tpXTtcbn07XG5cbi8qXG4gICAgUmV0cmlldmUgdGhlIHZhcmlhYmxlIGxpc3QgZnJvbSB0aGUgcHJlcHJvY2VzcyBkYXRhLlxuICAgIFRoaXMgaGVscHMgaGFuZGxlIHRoZSBuZXcgZm9ybWF0IGFuZCAodGVtcG9yYXJpbHkpXG4gICAgdGhlIG9sZGVyIGZvcm1hdCBpbiBwcm9kdWN0aW9uIChycCA4LjE0LjIwMTcpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRWYXJpYWJsZURhdGEoanNvbkRhdGEpe1xuICAgIC8qIFwibmV3XCIgcmVzcG9uc2U6XG4gICAge1xuICAgICAgICBcImRhdGFzZXRcIiA6IHsuLi59XG4gICAgICAgIFwidmFyaWFibGVzXCIgOiB7XG4gICAgICAgICAgICBcInZhcjFcIiA6IHsuLi59LCAoZXRjKVxuICAgICAgICB9XG4gICAgfVxuICAgIFwib2xkXCIgcmVzcG9uc2VcbiAgICB7XG4gICAgICAgICBcInZhcjFcIiA6IHsuLi59LFxuICAgICAgICAgKGV0YylcbiAgICB9Ki9cbiAgICByZXR1cm4ganNvbkRhdGEuaGFzT3duUHJvcGVydHkoJ3ZhcmlhYmxlcycpID8ganNvbkRhdGEudmFyaWFibGVzIDoganNvbkRhdGE7XG59XG5cbi8vIGZ1bmN0aW9uIGNhbGxlZCBieSBmb3JjZSBidXR0b25cbmV4cG9ydCBmdW5jdGlvbiBmb3JjZVN3aXRjaCgpIHtcbiAgICBmb3JjZXRvZ2dsZSA9IFtmb3JjZXRvZ2dsZVswXSA9PSAndHJ1ZScgPyAnZmFsc2UnIDogJ3RydWUnXTtcbiAgICBpZiAoZm9yY2V0b2dnbGVbMF0gPT09IFwiZmFsc2VcIikge1xuICAgICAgICBieUlkKCdidG5Gb3JjZScpLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiYnRuIGFjdGl2ZVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBieUlkKCdidG5Gb3JjZScpLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiYnRuIGJ0bi1kZWZhdWx0XCIpO1xuICAgICAgICBmYWtlQ2xpY2soKTtcbiAgICB9XG59XG5cbmV4cG9ydCBsZXQgc3BsaWNlTGlua3NGb3JOb2RlID0gbm9kZSA9PiBsaW5rc1xuICAgIC5maWx0ZXIobCA9PiBsLnNvdXJjZSA9PT0gbm9kZSB8fCBsLnRhcmdldCA9PT0gbm9kZSlcbiAgICAubWFwKHggPT4gbGlua3Muc3BsaWNlKGxpbmtzLmluZGV4T2YoeCksIDEpKTtcblxuZnVuY3Rpb24gelBvcCgpIHtcbiAgICBpZiAoZGF0YXVybCkgenBhcmFtcy56ZGF0YXVybCA9IGRhdGF1cmw7XG4gICAgenBhcmFtcy56bW9kZWxjb3VudCA9IG1vZGVsQ291bnQ7XG4gICAgenBhcmFtcy56ZWRnZXMgPSBbXTtcbiAgICB6cGFyYW1zLnp2YXJzID0gW107XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBub2Rlcy5sZW5ndGg7IGorKykgeyAvL3BvcHVsYXRlIHp2YXJzIGFycmF5XG4gICAgICAgIHpwYXJhbXMuenZhcnMucHVzaChub2Rlc1tqXS5uYW1lKTtcbiAgICAgICAgbGV0IHRlbXAgPSBub2Rlc1tqXS5pZDtcbiAgICAgICAgenBhcmFtcy56c2V0eFtqXSA9IGFsbE5vZGVzW3RlbXBdLnNldHh2YWxzO1xuICAgICAgICB6cGFyYW1zLnpzdWJzZXRbal0gPSBhbGxOb2Rlc1t0ZW1wXS5zdWJzZXRyYW5nZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBsaW5rcy5sZW5ndGg7IGorKykgeyAvL3BvcHVsYXRlIHplZGdlcyBhcnJheVxuICAgICAgICAvL2NvcnJlY3QgdGhlIHNvdXJjZSB0YXJnZXQgb3JkZXJpbmcgZm9yIFplbGlnXG4gICAgICAgIGxldCBzcmN0Z3QgPSBsaW5rc1tqXS5sZWZ0ID09IGZhbHNlID9cbiAgICAgICAgICAgIFtsaW5rc1tqXS5zb3VyY2UubmFtZSwgbGlua3Nbal0udGFyZ2V0Lm5hbWVdIDpcbiAgICAgICAgICAgIFtsaW5rc1tqXS50YXJnZXQubmFtZSwgbGlua3Nbal0uc291cmNlLm5hbWVdO1xuICAgICAgICB6cGFyYW1zLnplZGdlcy5wdXNoKHNyY3RndCk7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZXN0aW1hdGUoYnRuKSB7XG4gICAgaWYgKHByb2R1Y3Rpb24gJiYgenBhcmFtcy56c2Vzc2lvbmlkID09ICcnKSB7XG4gICAgICAgIGFsZXJ0KFwiV2FybmluZzogRGF0YSBkb3dubG9hZCBpcyBub3QgY29tcGxldGUuIFRyeSBhZ2FpbiBzb29uLlwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHpQb3AoKTtcbiAgICAvLyB3cml0ZSBsaW5rcyB0byBmaWxlICYgcnVuIFIgQ01EXG4gICAgLy8gcGFja2FnZSB0aGUgb3V0cHV0IGFzIEpTT05cbiAgICAvLyBhZGQgY2FsbCBoaXN0b3J5IGFuZCBwYWNrYWdlIHRoZSB6cGFyYW1zIG9iamVjdCBhcyBKU09OXG4gICAgenBhcmFtcy5jYWxsSGlzdG9yeSA9IGNhbGxIaXN0b3J5O1xuICAgIHZhciBqc29ub3V0ID0gSlNPTi5zdHJpbmdpZnkoenBhcmFtcyk7XG5cbiAgICB2YXIgdXJsY2FsbCA9IHJhcHBVUkwgKyBcInplbGlnYXBwXCI7IC8vYmFzZS5jb25jYXQoanNvbm91dCk7XG4gICAgdmFyIHNvbGFqc29ub3V0ID0gXCJzb2xhSlNPTj1cIiArIGpzb25vdXQ7XG4gICAgY2RiKFwidXJsY2FsbCBvdXQ6IFwiLCB1cmxjYWxsKTtcbiAgICBjZGIoXCJQT1NUIG91dDogXCIsIHNvbGFqc29ub3V0KTtcblxuICAgIHpwYXJhbXMuYWxsVmFycyA9IHZhbHVlS2V5LnNsaWNlKDEwLCAyNSk7IC8vIGJlY2F1c2UgdGhlIFVSTCBpcyB0b28gbG9uZy4uLlxuICAgIGpzb25vdXQgPSBKU09OLnN0cmluZ2lmeSh6cGFyYW1zKTtcbiAgICB2YXIgc2VsZWN0b3J1cmxjYWxsID0gcmFwcFVSTCArIFwic2VsZWN0b3JhcHBcIjtcblxuICAgIGZ1bmN0aW9uIGVzdGltYXRlU3VjY2VzcyhidG4sIGpzb24pIHtcbiAgICAgICAgZXN0aW1hdGVMYWRkYS5zdG9wKCk7IC8vIHN0b3Agc3Bpbm5lclxuICAgICAgICBhbGxSZXN1bHRzLnB1c2goanNvbik7XG4gICAgICAgIGNkYihcImpzb24gaW46IFwiLCBqc29uKTtcblxuICAgICAgICBpZiAoIWVzdGltYXRlZCkgYnlJZChcInJlc3VsdHNcIikucmVtb3ZlQ2hpbGQoYnlJZChcInJlc3VsdHNIb2xkZXJcIikpO1xuXG4gICAgICAgIGVzdGltYXRlZCA9IHRydWU7XG4gICAgICAgIGQzLnNlbGVjdChcIiNyZXN1bHRzXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJkaXNwbGF5XCIsIFwiYmxvY2tcIik7XG5cbiAgICAgICAgZDMuc2VsZWN0KFwiI3Jlc3VsdHNWaWV3XCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJkaXNwbGF5XCIsIFwiYmxvY2tcIik7XG5cbiAgICAgICAgZDMuc2VsZWN0KFwiI21vZGVsVmlld1wiKVxuICAgICAgICAgICAgLnN0eWxlKFwiZGlzcGxheVwiLCBcImJsb2NrXCIpO1xuXG4gICAgICAgIC8vIHByb2dyYW1tYXRpYyBjbGljayBvbiBSZXN1bHRzIGJ1dHRvblxuICAgICAgICAkKFwiI2J0blJlc3VsdHNcIikudHJpZ2dlcihcImNsaWNrXCIpO1xuXG4gICAgICAgIGxldCBtb2RlbCA9IFwiTW9kZWxcIi5jb25jYXQobW9kZWxDb3VudCA9IG1vZGVsQ291bnQgKyAxKTtcblxuICAgICAgICBmdW5jdGlvbiBtb2RDb2woKSB7XG4gICAgICAgICAgICBkMy5zZWxlY3QoXCIjbW9kZWxWaWV3XCIpXG4gICAgICAgICAgICAgICAgLnNlbGVjdEFsbChcInBcIilcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2JhY2tncm91bmQtY29sb3InLCBoZXhUb1JnYmEodmFyQ29sb3IpKTtcbiAgICAgICAgfVxuICAgICAgICBtb2RDb2woKTtcblxuICAgICAgICBkMy5zZWxlY3QoXCIjbW9kZWxWaWV3XCIpXG4gICAgICAgICAgICAuaW5zZXJ0KFwicFwiLCBcIjpmaXJzdC1jaGlsZFwiKSAvLyB0b3Agc3RhY2sgZm9yIHJlc3VsdHNcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgbW9kZWwpXG4gICAgICAgICAgICAudGV4dChtb2RlbClcbiAgICAgICAgICAgIC5zdHlsZSgnYmFja2dyb3VuZC1jb2xvcicsIGhleFRvUmdiYShzZWxWYXJDb2xvcikpXG4gICAgICAgICAgICAub24oXCJjbGlja1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IHRoaXMuc3R5bGUuYmFja2dyb3VuZENvbG9yLnJlcGxhY2UoL1xccyovZywgXCJcIik7XG4gICAgICAgICAgICAgICAgdmFyIGIgPSBoZXhUb1JnYmEoc2VsVmFyQ29sb3IpLnJlcGxhY2UoL1xccyovZywgXCJcIik7XG4gICAgICAgICAgICAgICAgaWYgKGEuc3Vic3RyKDAsIDE3KSA9PSBiLnN1YnN0cigwLCAxNykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gZXNjYXBlIGZ1bmN0aW9uIGlmIGRpc3BsYXllZCBtb2RlbCBpcyBjbGlja2VkXG4gICAgICAgICAgICAgICAgbW9kQ29sKCk7XG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnYmFja2dyb3VuZC1jb2xvcicsIGhleFRvUmdiYShzZWxWYXJDb2xvcikpO1xuICAgICAgICAgICAgICAgIHZpeih0aGlzLmlkKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIGxldCByQ2FsbCA9IFtdO1xuICAgICAgICByQ2FsbFswXSA9IGpzb24uY2FsbDtcbiAgICAgICAgc2hvd0xvZyhcImVzdGltYXRlXCIsIHJDYWxsKTtcblxuICAgICAgICB2aXoobW9kZWwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVzdGltYXRlRmFpbChidG4pIHtcbiAgICAgICAgZXN0aW1hdGVMYWRkYS5zdG9wKCk7IC8vIHN0b3Agc3Bpbm5lclxuICAgICAgICBlc3RpbWF0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNlbGVjdG9yU3VjY2VzcyhidG4sIGpzb24pIHtcbiAgICAgICAgZDMuc2VsZWN0KFwiI3RpY2tlclwiKVxuICAgICAgICAgICAgLnRleHQoXCJTdWdnZXN0ZWQgdmFyaWFibGVzIGFuZCBwZXJjZW50IGltcHJvdmVtZW50IG9uIFJNU0U6IFwiICsganNvbi52YXJzKTtcbiAgICAgICAgY2RiKFwic2VsZWN0b3JTdWNjZXNzOiBcIiwganNvbik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2VsZWN0b3JGYWlsKGJ0bikge1xuICAgICAgICBhbGVydChcIlNlbGVjdG9yIEZhaWxcIik7XG4gICAgfVxuXG4gICAgZXN0aW1hdGVMYWRkYS5zdGFydCgpOyAvLyBzdGFydCBzcGlubmVyXG4gICAgbWFrZUNvcnNSZXF1ZXN0KHVybGNhbGwsIGJ0biwgZXN0aW1hdGVTdWNjZXNzLCBlc3RpbWF0ZUZhaWwsIHNvbGFqc29ub3V0KTtcbn1cblxuZnVuY3Rpb24gZGF0YURvd25sb2FkKCkge1xuICAgIHpQb3AoKTtcbiAgICAvLyB3cml0ZSBsaW5rcyB0byBmaWxlICYgcnVuIFIgQ01EXG5cbiAgICAvL3BhY2thZ2UgdGhlIG91dHB1dCBhcyBKU09OXG4gICAgLy8gYWRkIGNhbGwgaGlzdG9yeSBhbmQgcGFja2FnZSB0aGUgenBhcmFtcyBvYmplY3QgYXMgSlNPTlxuICAgIHZhciBqc29ub3V0ID0gSlNPTi5zdHJpbmdpZnkoenBhcmFtcyk7XG4gICAgdmFyIGJ0biA9IFwibm9idXR0b25cIjtcblxuICAgIHZhciB1cmxjYWxsID0gcmFwcFVSTCArIFwiZGF0YWFwcFwiO1xuICAgIHZhciBzb2xhanNvbm91dCA9IFwic29sYUpTT049XCIgKyBqc29ub3V0O1xuICAgIGNkYihcInVybGNhbGwgb3V0OiBcIiwgdXJsY2FsbCk7XG4gICAgY2RiKFwiUE9TVCBvdXQ6IFwiLCBzb2xhanNvbm91dCk7XG5cbiAgICBsZXQgZG93bmxvYWRTdWNjZXNzID0gKGJ0biwganNvbikgPT4ge1xuICAgICAgICBjZGIoJ2RhdGFEb3dubG9hZCBqc29uIGluOiAnLCBqc29uKTtcbiAgICAgICAgenBhcmFtcy56c2Vzc2lvbmlkID0ganNvbi5zZXNzaW9uaWRbMF07XG4gICAgICAgIC8vIHNldCBsaW5rIFVSTFxuICAgICAgICBieUlkKFwibG9nSURcIikuaHJlZiA9IGAke3Byb2R1Y3Rpb24gPyByYXBwVVJMICsgJ2xvZ19kaXIvbG9nXycgOiAncm9vay9sb2dfJyB9JHt6cGFyYW1zLnpzZXNzaW9uaWR9LnR4dGA7XG4gICAgfTtcbiAgICBsZXQgZG93bmxvYWRGYWlsID0gXyA9PiBjZGIoJ0RhdGEgaGF2ZSBub3QgYmVlbiBkb3dubG9hZGVkJyk7XG4gICAgbWFrZUNvcnNSZXF1ZXN0KHVybGNhbGwsIGJ0biwgZG93bmxvYWRTdWNjZXNzLCBkb3dubG9hZEZhaWwsIHNvbGFqc29ub3V0KTtcbn1cblxuZnVuY3Rpb24gdml6KG15bSkge1xuICAgIHZhciBteW0gPSArbXltLnN1YnN0cig1LCA1KSAtIDE7XG5cbiAgICBmdW5jdGlvbiByZW1vdmVLaWRzKHBhcmVudCkge1xuICAgICAgICB3aGlsZSAocGFyZW50LmZpcnN0Q2hpbGQpXG4gICAgICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQocGFyZW50LmZpcnN0Q2hpbGQpO1xuICAgIH1cblxuICAgIHJlbW92ZUtpZHMoYnlJZChcInJlc3VsdHNWaWV3XCIpKTtcblxuICAgIGxldCBqc29uID0gYWxsUmVzdWx0c1tteW1dO1xuXG4gICAgLy8gcGlwZSBpbiBmaWd1cmVzIHRvIHJpZ2h0IHBhbmVsXG4gICAgdmFyIGZpbGVsaXN0ID0gbmV3IEFycmF5O1xuICAgIGZvciAodmFyIGkgaW4ganNvbi5pbWFnZXMpIHtcbiAgICAgICAgdmFyIHpmaWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgICAgICB6ZmlnLnNldEF0dHJpYnV0ZShcInNyY1wiLCBqc29uLmltYWdlc1tpXSk7XG4gICAgICAgIHpmaWcuc2V0QXR0cmlidXRlKCd3aWR0aCcsIDIwMCk7XG4gICAgICAgIHpmaWcuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAyMDApO1xuICAgICAgICBieUlkKFwicmVzdWx0c1ZpZXdcIikuYXBwZW5kQ2hpbGQoemZpZyk7XG4gICAgfVxuXG4gICAgLy8gd3JpdGUgdGhlIHJlc3VsdHMgdGFibGVcbiAgICB2YXIgcmVzdWx0c0FycmF5ID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIGpzb24uc3VtSW5mbykge1xuICAgICAgICBpZiAoa2V5ID09ICdjb2xuYW1lcycpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgcmVzdWx0c0FycmF5LnB1c2goanNvbi5zdW1JbmZvW2tleV0pO1xuICAgIH1cblxuICAgIHZhciB0YWJsZSA9IGQzLnNlbGVjdChcIiNyZXN1bHRzVmlld1wiKVxuICAgICAgICAuYXBwZW5kKFwicFwiKVxuICAgICAgICAuYXBwZW5kKFwidGFibGVcIik7XG5cbiAgICB2YXIgdGhlYWQgPSB0YWJsZS5hcHBlbmQoXCJ0aGVhZFwiKTtcbiAgICB0aGVhZC5hcHBlbmQoXCJ0clwiKVxuICAgICAgICAuc2VsZWN0QWxsKFwidGhcIilcbiAgICAgICAgLmRhdGEoanNvbi5zdW1JbmZvLmNvbG5hbWVzKVxuICAgICAgICAuZW50ZXIoKVxuICAgICAgICAuYXBwZW5kKFwidGhcIilcbiAgICAgICAgLnRleHQoZCA9PiBkKTtcblxuICAgIHZhciB0Ym9keSA9IHRhYmxlLmFwcGVuZChcInRib2R5XCIpO1xuICAgIHRib2R5LnNlbGVjdEFsbChcInRyXCIpXG4gICAgICAgIC5kYXRhKHJlc3VsdHNBcnJheSlcbiAgICAgICAgLmVudGVyKCkuYXBwZW5kKFwidHJcIilcbiAgICAgICAgLnNlbGVjdEFsbChcInRkXCIpXG4gICAgICAgIC5kYXRhKGQgPT4gZClcbiAgICAgICAgLmVudGVyKCkuYXBwZW5kKFwidGRcIilcbiAgICAgICAgLnRleHQoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgdmFyIG15TnVtID0gTnVtYmVyKGQpO1xuICAgICAgICAgICAgaWYgKGlzTmFOKG15TnVtKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgICAgIHJldHVybiBteU51bS50b1ByZWNpc2lvbigzKTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnN0eWxlKFwiYmFja2dyb3VuZC1jb2xvclwiLCBcImFsaWNlYmx1ZVwiKTtcbiAgICAgICAgfSkgLy8gZm9yIG5vIGRpc2Nlcm5hYmxlIHJlYXNvblxuICAgICAgICAub24oXCJtb3VzZW91dFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5zdHlsZShcImJhY2tncm91bmQtY29sb3JcIiwgXCIjRjlGOUY5XCIpO1xuICAgICAgICB9KTsgLy8oYnV0IG1heWJlIHdlJ2xsIHRoaW5rIG9mIG9uZSlcblxuICAgIGQzLnNlbGVjdChcIiNyZXN1bHRzVmlld1wiKVxuICAgICAgICAuYXBwZW5kKFwicFwiKVxuICAgICAgICAuaHRtbCgoKSA9PiBcIjxiPkZvcm11bGE6IDwvYj5cIi5jb25jYXQoanNvbi5jYWxsWzBdKSk7XG5cbiAgICBtLnJlZHJhdygpO1xufVxuXG4vLyBwYXJzZXMgdGhlIHRyYW5zZm9ybWF0aW9uIGlucHV0LiB2YXJpYWJsZSBuYW1lcyBhcmUgb2Z0ZW4gbmVzdGVkIGluc2lkZSBvbmUgYW5vdGhlciwgZS5nLiwgZXRod2FyLCB3YXIsIHdhcnMsIGFuZCBzbyB0aGlzIGlzIGhhbmRsZWRcbmZ1bmN0aW9uIHRyYW5zUGFyc2Uobikge1xuICAgIHZhciBvdXQyID0gW107XG4gICAgdmFyIHQyID0gbjtcbiAgICB2YXIgazIgPSAwO1xuICAgIHZhciBzdWJNZTIgPSBcIl90cmFuc3ZhclwiLmNvbmNhdChrMik7XG4gICAgdmFyIGluZGV4ZWQgPSBbXTtcblxuICAgIC8vIG91dDIgaXMgYWxsIG1hdGNoZWQgdmFyaWFibGVzLCBpbmRleGVkIGlzIGFuIGFycmF5LCBlYWNoIGVsZW1lbnQgaXMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIG1hdGNoZWQgdmFyaWFibGVzIHN0YXJ0aW5nIGluZGV4IGFuZCBmaW5pc2hpbmcgaW5kZXguICBlLmcuLCBuPVwid2FycysyXCIsIG91dDI9W3dhciwgd2Fyc10sIGluZGV4ZWQ9W3swLDJ9LHswLDN9XVxuICAgIGZvciAodmFyIGkgaW4gdmFsdWVLZXkpIHtcbiAgICAgICAgdmFyIG0yID0gbi5tYXRjaCh2YWx1ZUtleVtpXSk7XG4gICAgICAgIGlmIChtMiAhPSBudWxsKVxuICAgICAgICAgICAgb3V0Mi5wdXNoKG0yWzBdKTtcblxuICAgICAgICB2YXIgcmUgPSBuZXcgUmVnRXhwKHZhbHVlS2V5W2ldLCBcImdcIik7XG4gICAgICAgIHZhciBzID0gbi5zZWFyY2gocmUpO1xuICAgICAgICBpZiAocyAhPSAtMSlcbiAgICAgICAgICAgIGluZGV4ZWQucHVzaCh7ZnJvbTogcywgdG86IHMgKyB2YWx1ZUtleVtpXS5sZW5ndGh9KTtcbiAgICB9XG5cbiAgICAvLyBuZXN0ZWQgbG9vcCBub3QgZ29vZCwgYnV0IGluZGV4ZWQgaXMgbm90IGxpa2VseSB0byBiZSB2ZXJ5IGxhcmdlLlxuICAgIC8vIGlmIGEgdmFyaWFibGUgaXMgbmVzdGVkLCBpdCBpcyByZW1vdmVkIGZyb20gb3V0MlxuICAgIC8vIG5vdGljZSwgbG9vcCBpcyBiYWNrd2FyZHMgc28gdGhhdCBpbmRleCBjaGFuZ2VzIGRvbid0IGFmZmVjdCB0aGUgc3BsaWNlXG4gICAgY2RiKFwiaW5kZXhlZCBcIiwgaW5kZXhlZCk7XG4gICAgZm9yICh2YXIgaSA9IGluZGV4ZWQubGVuZ3RoIC0gMTsgaSA+IC0xOyBpLS0pIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IGluZGV4ZWQubGVuZ3RoIC0gMTsgaiA+IC0xOyBqLS0pIHtcbiAgICAgICAgICAgIGlmIChpID09PSBqKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKChpbmRleGVkW2ldLmZyb20gPj0gaW5kZXhlZFtqXS5mcm9tKSAmIChpbmRleGVkW2ldLnRvIDw9IGluZGV4ZWRbal0udG8pKSB7XG4gICAgICAgICAgICAgICAgY2RiKGksIFwiIGlzIG5lc3RlZCBpbiBcIiwgaik7XG4gICAgICAgICAgICAgICAgb3V0Mi5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBpIGluIG91dDIpIHtcbiAgICAgICAgdDIgPSB0Mi5yZXBsYWNlKG91dDJbaV0sIHN1Yk1lMik7IC8vc29tZXRoaW5nIHRoYXQnbGwgbmV2ZXIgYmUgYSB2YXJpYWJsZSBuYW1lXG4gICAgICAgIGsyID0gazIgKyAxO1xuICAgICAgICBzdWJNZTIgPSBcIl90cmFuc3ZhclwiLmNvbmNhdChrMik7XG4gICAgfVxuXG4gICAgaWYgKG91dDIubGVuZ3RoID4gMCkge1xuICAgICAgICBvdXQyLnB1c2godDIpO1xuICAgICAgICBjZGIoXCJuZXcgb3V0IFwiLCBvdXQyKTtcbiAgICAgICAgcmV0dXJuIChvdXQyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBhbGVydChcIk5vIHZhcmlhYmxlIG5hbWUgZm91bmQuIFBlcmhhcHMgY2hlY2sgeW91ciBzcGVsbGluZz9cIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cblxuLyoqXG4gIG4gPSBuYW1lIG9mIGNvbHVtbi9ub2RlXG4gIHQgPSBzZWxlY3RlZCB0cmFuc2Zvcm1hdGlvblxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm0obiwgdCwgdHlwZVRyYW5zZm9ybSkge1xuICAgIGlmIChwcm9kdWN0aW9uICYmIHpwYXJhbXMuenNlc3Npb25pZCA9PSBcIlwiKSB7XG4gICAgICAgIGFsZXJ0KFwiV2FybmluZzogRGF0YSBkb3dubG9hZCBpcyBub3QgY29tcGxldGUuIFRyeSBhZ2FpbiBzb29uLlwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXR5cGVUcmFuc2Zvcm0pXG4gICAgICAgIHQgPSB0LnJlcGxhY2UoXCIrXCIsIFwiX3BsdXNfXCIpOyAvLyBjYW4ndCBzZW5kIHRoZSBwbHVzIG9wZXJhdG9yXG5cbiAgICBjZGIoJ25hbWUgb2YgY29sOiAnICsgbik7XG4gICAgY2RiKCd0cmFuc2Zvcm1hdGlvbjogJyArIHQpO1xuXG4gICAgdmFyIGJ0biA9IGJ5SWQoJ2J0bkVzdGltYXRlJyk7XG5cbiAgICAvLyBmaW5kIHRoZSBub2RlIGJ5IG5hbWVcbiAgICB2YXIgbXluID0gZmluZE5vZGVJbmRleChuWzBdLCB0cnVlKTtcblxuICAgIGlmICh0eXBlb2YgbXluID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIG15biA9IGZpbmROb2RlSW5kZXgobiwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgdmFyIG91dHR5cGVzID0ge1xuICAgICAgICB2YXJuYW1lc1R5cGVzOiBuLFxuICAgICAgICBpbnRlcnZhbDogbXluLmludGVydmFsLFxuICAgICAgICBudW1jaGFyOiBteW4ubnVtY2hhcixcbiAgICAgICAgbmF0dXJlOiBteW4ubmF0dXJlLFxuICAgICAgICBiaW5hcnk6IG15bi5iaW5hcnlcbiAgICB9O1xuXG4gICAgY2RiKG15bik7XG4gICAgLy8gaWYgdHlwZVRyYW5zZm9ybSBidXQgd2UgYWxyZWFkeSBoYXZlIHRoZSBtZXRhZGF0YVxuICAgIGlmICh0eXBlVHJhbnNmb3JtKSB7XG4gICAgICAgIGlmIChteW4ubmF0dXJlID09IFwibm9taW5hbFwiICYgdHlwZW9mIG15bi5wbG90dmFsdWVzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBteW4ucGxvdHR5cGUgPSBcImJhclwiO1xuICAgICAgICAgICAgYmFyc05vZGUobXluKTtcbiAgICAgICAgICAgIHBhbmVsUGxvdHMoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmIChteW4ubmF0dXJlICE9IFwibm9taW5hbFwiICYgdHlwZW9mIG15bi5wbG90eCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgbXluLnBsb3R0eXBlID0gXCJjb250aW51b3VzXCI7XG4gICAgICAgICAgICBkZW5zaXR5Tm9kZShteW4pO1xuICAgICAgICAgICAgcGFuZWxQbG90cygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy9wYWNrYWdlIHRoZSBvdXRwdXQgYXMgSlNPTlxuICAgIHZhciB0cmFuc2Zvcm1zdHVmZiA9IHtcbiAgICAgICAgemRhdGF1cmw6IGRhdGF1cmwsXG4gICAgICAgIHp2YXJzOiBteW4ubmFtZSxcbiAgICAgICAgenNlc3Npb25pZDogenBhcmFtcy56c2Vzc2lvbmlkLFxuICAgICAgICB0cmFuc2Zvcm06IHQsXG4gICAgICAgIGNhbGxIaXN0b3J5OiBjYWxsSGlzdG9yeSxcbiAgICAgICAgdHlwZVRyYW5zZm9ybTogdHlwZVRyYW5zZm9ybSxcbiAgICAgICAgdHlwZVN0dWZmOiBvdXR0eXBlc1xuICAgIH07XG4gICAgdmFyIGpzb25vdXQgPSBKU09OLnN0cmluZ2lmeSh0cmFuc2Zvcm1zdHVmZik7XG4gICAgdmFyIHVybGNhbGwgPSByYXBwVVJMICsgXCJ0cmFuc2Zvcm1hcHBcIjtcbiAgICB2YXIgc29sYWpzb25vdXQgPSBcInNvbGFKU09OPVwiICsganNvbm91dDtcbiAgICBjZGIoXCJ1cmxjYWxsIG91dDogXCIgKyB1cmxjYWxsKTtcbiAgICBjZGIoXCJQT1NUIG91dDogXCIgKyBzb2xhanNvbm91dCk7XG5cbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm1TdWNjZXNzKGJ0biwganNvbikge1xuICAgICAgICBlc3RpbWF0ZUxhZGRhLnN0b3AoKTtcbiAgICAgICAgY2RiKFwianNvbiBpbjogXCIgKyBKU09OLnN0cmluZ2lmeShqc29uKSk7XG5cbiAgICAgICAgLy8gSXMgdGhpcyBhIHR5cGVUcmFuc2Zvcm0/XG4gICAgICAgIGlmIChqc29uLnR5cGVUcmFuc2Zvcm1bMF0pIHtcbiAgICAgICAgICAgIC8vIFllcy4gV2UncmUgdXBkYXRpbmcgYW4gZXhpc3Rpbmcgbm9kZVxuICAgICAgICAgICAgZDMuanNvbihqc29uLnVybCwgKGVyciwgZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oZXJyKTtcbiAgICAgICAgICAgICAgICBsZXQgbm9kZTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gZmluZE5vZGVJbmRleChrZXksIHRydWUpO1xuXHRcdCAgICBpZiAoIW5vZGUpXG5cdFx0ICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmV4dGVuZCh0cnVlLCBub2RlLCBkYXRhW2tleV0pO1xuICAgICAgICAgICAgICAgICAgICBub2RlLnBsb3R0eXBlID09PSBcImNvbnRpbnVvdXNcIiA/IGRlbnNpdHlOb2RlKG5vZGUpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucGxvdHR5cGUgPT09IFwiYmFyXCIgPyBiYXJzTm9kZShub2RlKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZha2VDbGljaygpO1xuICAgICAgICAgICAgICAgIHBhbmVsUGxvdHMoKTtcbiAgICAgICAgICAgICAgICBub2RlICYmIGNkYihub2RlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8qIE5vLCB3ZSBoYXZlIGEgbmV3IG5vZGUgaGVyZS0tZS5nLiB0aGUgdHJhbnNmb3JtZWQgY29sdW1uXG4gICAgICAgICAgICAgICBleGFtcGxlIHJlc3BvbnNlOiB7XG4gICAgICAgICAgICAgICBcImNhbGxcIjpbXCJ0X3llYXJfMlwiXSxcbiAgICAgICAgICAgICAgIFwidXJsXCI6W1wiZGF0YS9wcmVwcm9jZXNzU3Vic2V0X0JBQ0NCQzc4LTdERDktNDQ4Mi1CMzFELTZFQjAxQzNBMEM5NS50eHRcIl0sXG4gICAgICAgICAgICAgICBcInRyYW5zXCI6W1wieWVhclwiLFwiX3RyYW5zdmFyMF4yXCJdLFxuICAgICAgICAgICAgICAgXCJ0eXBlVHJhbnNmb3JtXCI6W2ZhbHNlXVxuICAgICAgICAgICAgIH1cbiAgICAgICAgICAqL1xuICAgICAgICAgICAgY2FsbEhpc3RvcnkucHVzaCh7XG4gICAgICAgICAgICAgICAgZnVuYzogXCJ0cmFuc2Zvcm1cIixcbiAgICAgICAgICAgICAgICB6dmFyczogbixcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHRcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgc3Vic2V0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciByQ2FsbCA9IFtdO1xuXG4gICAgICAgICAgICByQ2FsbFswXSA9IGpzb24uY2FsbDtcbiAgICAgICAgICAgIHZhciBuZXdWYXIgPSByQ2FsbFswXVswXTtcblxuICAgICAgICAgICAgdHJhbnMucHVzaChuZXdWYXIpO1xuXG4gICAgICAgICAgICAvLyBSZWFkIHRoZSBwcmVwcm9jZXNzIGZpbGUgY29udGFpbmluZyB2YWx1ZXNcbiAgICAgICAgICAgIC8vIGZvciB0aGUgdHJhbnNmb3JtZWQgdmFyaWFibGVcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBkMy5qc29uKGpzb24udXJsLCBmdW5jdGlvbihlcnJvciwganNvbikge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikgcmV0dXJuIGNvbnNvbGUud2FybihlcnJvcik7XG5cbiAgICAgICAgICAgICAgICB2YXIganNvbmRhdGEgPSBnZXRWYXJpYWJsZURhdGEoanNvbik7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4ganNvbmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG15SW5kZXggPSBmaW5kTm9kZUluZGV4KGtleSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbXlJbmRleCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxlcnQoXCJJbnZhbGlkIHRyYW5zZm9ybWF0aW9uOiB0aGlzIHZhcmlhYmxlIG5hbWUgYWxyZWFkeSBleGlzdHMuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCB0cmFuc2Zvcm1lZCB2YXJpYWJsZSB0byB0aGUgY3VycmVudCBzcGFjZVxuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IGFsbE5vZGVzLmxlbmd0aDsgIC8vIGdldCBuZXcgaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9iajEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZmxleGl2ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJsOiBcInRyYW5zZm9ybWxhYmVsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBbNSwgMTUsIDIwLCAwLCA1LCAxNSwgMjBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgY291bnQ6IFsuNiwgLjIsIC45LCAuOCwgLjEsIC4zLCAuNF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlQ29sOiBjb2xvcnMoaSksXG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlQ29sOiBjb2xvcnMoaSksXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VDb2xvcjogc2VsVmFyQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogXCIxXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzZXRwbG90OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNldHJhbmdlOiBbXCJcIiwgXCJcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR4cGxvdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR4dmFsczogW1wiXCIsIFwiXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JheW91dDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0SW50ZXJ2YWw6IGpzb25kYXRhW2tleV0uaW50ZXJ2YWwsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0TnVtY2hhcjoganNvbmRhdGFba2V5XS5udW1jaGFyLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdE5hdHVyZToganNvbmRhdGFba2V5XS5uYXR1cmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0QmluYXJ5OiBqc29uZGF0YVtrZXldLmJpbmFyeVxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5leHRlbmQodHJ1ZSwgb2JqMSwganNvbmRhdGFba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgIGFsbE5vZGVzLnB1c2gob2JqMSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWVLZXkucHVzaChuZXdWYXIpO1xuICAgICAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKGFsbE5vZGVzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgZmFrZUNsaWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIHBhbmVsUGxvdHMoKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxsTm9kZXNbaV0ucGxvdHR5cGUgPT09IFwiY29udGludW91c1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZW5zaXR5Tm9kZShhbGxOb2Rlc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYWxsTm9kZXNbaV0ucGxvdHR5cGUgPT09IFwiYmFyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhcnNOb2RlKGFsbE5vZGVzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIG0ucmVkcmF3KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHNob3dMb2coJ3RyYW5zZm9ybScsIHJDYWxsKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybUZhaWwoYnRuKSB7XG4gICAgICAgIGFsZXJ0KFwidHJhbnNmb3JtIGZhaWxcIik7XG4gICAgICAgIGVzdGltYXRlTGFkZGEuc3RvcCgpO1xuICAgIH1cblxuICAgIGVzdGltYXRlTGFkZGEuc3RhcnQoKTsgLy8gc3RhcnQgc3Bpbm5lclxuICAgIG1ha2VDb3JzUmVxdWVzdCh1cmxjYWxsLCBidG4sIHRyYW5zZm9ybVN1Y2Nlc3MsIHRyYW5zZm9ybUZhaWwsIHNvbGFqc29ub3V0KTtcbn1cblxuLy8gYmVsb3cgZnJvbSBodHRwOi8vd3d3Lmh0bWw1cm9ja3MuY29tL2VuL3R1dG9yaWFscy9jb3JzLyBmb3IgY3Jvc3Mtb3JpZ2luIHJlc291cmNlIHNoYXJpbmdcbi8vIENyZWF0ZSB0aGUgWEhSIG9iamVjdC5cbmZ1bmN0aW9uIGNyZWF0ZUNPUlNSZXF1ZXN0KG1ldGhvZCwgdXJsLCBjYWxsYmFjaykge1xuICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICBpZiAoXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiB4aHIpIHtcbiAgICAgICAgLy8gWEhSIGZvciBDaHJvbWUvRmlyZWZveC9PcGVyYS9TYWZhcmkuXG4gICAgICAgIHhoci5vcGVuKG1ldGhvZCwgdXJsLCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBYRG9tYWluUmVxdWVzdCAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIC8vIFhEb21haW5SZXF1ZXN0IGZvciBJRS5cbiAgICAgICAgeGhyID0gbmV3IFhEb21haW5SZXF1ZXN0KCk7XG4gICAgICAgIHhoci5vcGVuKG1ldGhvZCwgdXJsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDT1JTIG5vdCBzdXBwb3J0ZWQuXG4gICAgICAgIHhociA9IG51bGw7XG4gICAgfVxuICAgIC8vIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LVR5cGUnLCAndGV4dC9wbGFpbicpO1xuICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LVR5cGUnLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyk7XG4gICAgcmV0dXJuIHhocjtcbn1cblxuLy8gTWFrZSB0aGUgYWN0dWFsIENPUlMgcmVxdWVzdC5cbmZ1bmN0aW9uIG1ha2VDb3JzUmVxdWVzdCh1cmwsIGJ0biwgY2FsbGJhY2ssIHdhcm5pbmdjYWxsYmFjaywganNvbnN0cmluZykge1xuICAgIHZhciB4aHIgPSBjcmVhdGVDT1JTUmVxdWVzdCgnUE9TVCcsIHVybCk7XG4gICAgaWYgKCF4aHIpIHtcbiAgICAgICAgYWxlcnQoJ0NPUlMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFJlc3BvbnNlIGhhbmRsZXJzIGZvciBhc3luY2hyb25vdXMgbG9hZFxuICAgIC8vIG9ubG9hZCBvciBvbnJlYWR5c3RhdGVjaGFuZ2U/XG5cbiAgICB4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0ZXh0ID0geGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgY2RiKFwidGV4dCBcIiwgdGV4dCk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBqc29uID0gSlNPTi5wYXJzZSh0ZXh0KTsgLy8gc2hvdWxkIHdyYXAgaW4gdHJ5IC8gY2F0Y2hcbiAgICAgICAgICAgIHZhciBuYW1lcyA9IE9iamVjdC5rZXlzKGpzb24pO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGVzdGltYXRlTGFkZGEuc3RvcCgpO1xuICAgICAgICAgICAgc2VsZWN0TGFkZGEuc3RvcCgpO1xuICAgICAgICAgICAgY2RiKGVycik7XG4gICAgICAgICAgICBhbGVydCgnRXJyb3I6IENvdWxkIG5vdCBwYXJzZSBpbmNvbWluZyBKU09OLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5hbWVzWzBdID09IFwid2FybmluZ1wiKSB7XG4gICAgICAgICAgICB3YXJuaW5nY2FsbGJhY2soYnRuKTtcbiAgICAgICAgICAgIGFsZXJ0KFwiV2FybmluZzogXCIgKyBqc29uLndhcm5pbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2soYnRuLCBqc29uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gbm90ZTogeGhyLnJlYWR5c3RhdGUgc2hvdWxkIGJlIDQgYW5kIHN0YXR1cyBzaG91bGQgYmUgMjAwLiBhIHN0YXR1cyBvZiAwIG9jY3VycyB3aGVuIHRoZSB1cmwgaXMgdG9vIGxhcmdlXG4gICAgICAgIHhoci5zdGF0dXMgPT0gMCA/IGFsZXJ0KCdUaGVyZSB3YXMgYW4gZXJyb3IgbWFraW5nIHRoZSByZXF1ZXN0LiB4bWxodHRwcmVxdWVzdCBzdGF0dXMgaXMgMC4nKSA6XG4gICAgICAgICAgICB4aHIucmVhZHlTdGF0ZSAhPSA0ID8gYWxlcnQoJ1RoZXJlIHdhcyBhbiBlcnJvciBtYWtpbmcgdGhlIHJlcXVlc3QuIHhtbGh0dHByZXF1ZXN0IHJlYWR5c3RhdGUgaXMgbm90IDQuJykgOlxuICAgICAgICAgICAgYWxlcnQoJ1dvb3BzLCB0aGVyZSB3YXMgYW4gZXJyb3IgbWFraW5nIHRoZSByZXF1ZXN0LicpO1xuICAgICAgICBjZGIoeGhyKTtcbiAgICAgICAgZXN0aW1hdGVMYWRkYS5zdG9wKCk7XG4gICAgICAgIHNlbGVjdExhZGRhLnN0b3AoKTtcbiAgICB9O1xuICAgIHhoci5zZW5kKGpzb25zdHJpbmcpO1xufVxuXG5leHBvcnQgbGV0IGxlZ2VuZCA9IF8gPT4ge1xuICAgIGJvcmRlclN0YXRlKCk7XG4gICAgbS5yZWRyYXcoKTtcbn07XG5cbi8vIHByb2dyYW1tYXRpY2FsbHkgZGVzZWxlY3QgZXZlcnkgc2VsZWN0ZWQgdmFyaWFibGVcbmV4cG9ydCBmdW5jdGlvbiBlcmFzZSgpIHtcbiAgICBsZWZ0cGFuZWxNZWRpdW0oKTtcbiAgICByaWdodHBhbmVsTWVkaXVtKCk7XG4gICAgdGFiTGVmdCgndGFiMScpO1xuICAgIGpRdWVyeS5mbi5kM0NsaWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4oKS5lYWNoKGZ1bmN0aW9uKGksIGUpIHtcbiAgICAgICAgICAgIHZhciBteWNvbCA9IGQzLnJnYih0aGlzLnN0eWxlLmJhY2tncm91bmRDb2xvcik7XG4gICAgICAgICAgICBpZiAobXljb2wudG9TdHJpbmcoKSA9PT0gdmFyQ29sb3IudG9TdHJpbmcoKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJNb3VzZUV2ZW50c1wiKTtcbiAgICAgICAgICAgIGV2dC5pbml0TW91c2VFdmVudChcImNsaWNrXCIsIHRydWUsIHRydWUsIHdpbmRvdywgMCwgMCwgMCwgMCwgMCwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGwpO1xuICAgICAgICAgICAgZS5kaXNwYXRjaEV2ZW50KGV2dCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgJChcIiN2YXJMaXN0XCIpLmQzQ2xpY2soKTtcbn1cblxuLy8gaHR0cDovL3d3dy50dXRvcmlhbHMybGVhcm4uY29tL3R1dG9yaWFscy9zY3JpcHRzL2phdmFzY3JpcHQveG1sLXBhcnNlci1qYXZhc2NyaXB0Lmh0bWxcbmZ1bmN0aW9uIGxvYWRYTUxEb2MoWE1MbmFtZSkge1xuICAgIHZhciB4bWxEb2M7XG4gICAgaWYgKHdpbmRvdy5YTUxIdHRwUmVxdWVzdCkge1xuICAgICAgICB4bWxEb2MgPSBuZXcgd2luZG93LlhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIHhtbERvYy5vcGVuKFwiR0VUXCIsIFhNTG5hbWUsIGZhbHNlKTtcbiAgICAgICAgeG1sRG9jLnNlbmQoXCJcIik7XG4gICAgICAgIHJldHVybiB4bWxEb2MucmVzcG9uc2VYTUw7XG4gICAgfVxuICAgIC8vIElFIDUgYW5kIElFIDZcbiAgICBlbHNlIGlmIChBY3RpdmVYT2JqZWN0KFwiTWljcm9zb2Z0LlhNTERPTVwiKSkge1xuICAgICAgICB4bWxEb2MgPSBuZXcgQWN0aXZlWE9iamVjdChcIk1pY3Jvc29mdC5YTUxET01cIik7XG4gICAgICAgIHhtbERvYy5hc3luYyA9IGZhbHNlO1xuICAgICAgICB4bWxEb2MubG9hZChYTUxuYW1lKTtcbiAgICAgICAgcmV0dXJuIHhtbERvYztcbiAgICB9XG4gICAgYWxlcnQoXCJFcnJvciBsb2FkaW5nIGRvY3VtZW50IVwiKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRhYkxlZnQodGFiKSB7XG4gICAgYnlJZCgndGFiMScpLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgYnlJZCgndGFiMicpLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgYnlJZCgndGFiMycpLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgYnlJZCh0YWIpLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIGlmICh0YWIgIT0gJ3RhYjMnKSB7XG4gICAgICAgIHN1YnNldCA9IHRhYiA9PSAndGFiMic7XG4gICAgICAgIHN1bW1hcnlIb2xkID0gZmFsc2U7XG4gICAgfVxuICAgIGxlZnR0YWIgPSB0YWI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0YWJSaWdodCh0YWJpZCkge1xuXG4gICAgbGV0IGNscyA9IFwic2lkZXBhbmVsIGNvbnRhaW5lciBjbGVhcmZpeFwiO1xuICAgIGxldCBzZWxlY3QgPSBjbHMgPT4ge1xuICAgICAgICBsZXQgcGFuZWwgPSBkMy5zZWxlY3QoXCIjcmlnaHRwYW5lbFwiKTtcbiAgICAgICAgcmV0dXJuIGNscyA/IHBhbmVsLmF0dHIoJ2NsYXNzJywgY2xzKSA6IHBhbmVsLmF0dHIoJ2NsYXNzJyk7XG4gICAgfTtcblxuICAgIGxldCB0b2dnbGVSID0gKCkgPT4ge1xuICAgICAgICBzZWxlY3QoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBsZXQgZXhwYW5kID0gY2xzICsgJyBleHBhbmRwYW5lbCc7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSA9PT0gZXhwYW5kID8gY2xzIDogZXhwYW5kO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgaWYgKHRhYmlkID09IFwiYnRuTW9kZWxzXCIpIHNlbGVjdChjbHMpO1xuICAgIGVsc2UgaWYgKHRhYmlkID09IFwiYnRuU2V0eFwiKSByaWdodHRhYiA9PSBcImJ0blNldHhcIiB8fCBzZWxlY3QoKSA9PSBjbHMgJiYgdG9nZ2xlUigpO1xuICAgIGVsc2UgaWYgKHRhYmlkID09IFwiYnRuUmVzdWx0c1wiKSAhZXN0aW1hdGVkID8gc2VsZWN0KGNscykgOlxuICAgICAgICByaWdodHRhYiA9PSBcImJ0blJlc3VsdHNcIiB8fCBzZWxlY3QoKSA9PSBjbHMgPyB0b2dnbGVSKCkgOiBudWxsO1xuXG4gICAgcmlnaHR0YWIgPSB0YWJpZDtcblxufVxuXG5leHBvcnQgbGV0IHN1bW1hcnkgPSB7ZGF0YTogW119O1xuXG5mdW5jdGlvbiB2YXJTdW1tYXJ5KGQpIHtcbiAgICBsZXQgdDEgPSAnTWVhbjosIE1lZGlhbjosIE1vc3QgRnJlcTosIE9jY3VycmVuY2VzOiwgTWVkaWFuIEZyZXE6LCBPY2N1cnJlbmNlczosIExlYXN0IEZyZXE6LCBPY2N1cnJlbmNlczosIFN0ZCBEZXY6LCBNaW5pbXVtOiwgTWF4aW11bTosIEludmFsaWQ6LCBWYWxpZDosIFVuaXF1ZXM6LCBIZXJmaW5kYWhsJy5zcGxpdCgnLCAnKTtcblxuICAgIGxldCByaW50ID0gZDMuZm9ybWF0KCdyJyk7XG4gICAgbGV0IHN0ciA9ICh4LCBwKSA9PiAoK3gpLnRvUHJlY2lzaW9uKHAgfHwgNCkudG9TdHJpbmcoKTtcbiAgICBsZXQgdDIgPSBwcml2ICYmIGQubWVhbkNJID9cbiAgICAgICAgW3N0cihkLm1lYW4sIDIpICsgJyAoJyArIHN0cihkLm1lYW5DSS5sb3dlckJvdW5kLCAyKSArICcgLSAnICsgc3RyKGQubWVhbkNJLnVwcGVyQm91bmQsIDIpICsgJyknLFxuICAgICAgICAgc3RyKGQubWVkaWFuKSwgZC5tb2RlLCByaW50KGQuZnJlcW1vZGUpLCBkLm1pZCwgcmludChkLmZyZXFtaWQpLCBkLmZld2VzdCwgcmludChkLmZyZXFmZXdlc3QpLFxuICAgICAgICAgc3RyKGQuc2QpLCBzdHIoZC5taW4pLCBzdHIoZC5tYXgpLCByaW50KGQuaW52YWxpZCksIHJpbnQoZC52YWxpZCksIHJpbnQoZC51bmlxdWVzKSwgc3RyKGQuaGVyZmluZGFobCldIDpcbiAgICAgICAgW3N0cihkLm1lYW4pLCBzdHIoZC5tZWRpYW4pLCBkLm1vZGUsIHJpbnQoZC5mcmVxbW9kZSksIGQubWlkLCByaW50KGQuZnJlcW1pZCksIGQuZmV3ZXN0LCByaW50KGQuZnJlcWZld2VzdCksXG4gICAgICAgICBzdHIoZC5zZCksIHN0cihkLm1pbiksIHN0cihkLm1heCksIHJpbnQoZC5pbnZhbGlkKSwgcmludChkLnZhbGlkKSwgcmludChkLnVuaXF1ZXMpLCBzdHIoZC5oZXJmaW5kYWhsKV07XG5cbiAgICBzdW1tYXJ5LmRhdGEgPSBbXTtcbiAgICB0MS5mb3JFYWNoKChlLCBpKSA9PiAhdDJbaV0uaW5jbHVkZXMoJ05hTicpICYmIHQyW2ldICE9ICdOQScgJiYgdDJbaV0gIT0gJycgJiYgc3VtbWFyeS5kYXRhLnB1c2goW2UsIHQyW2ldXSkpO1xuXG4gICAgc3VtbWFyeS5uYW1lID0gZC5uYW1lO1xuICAgIHN1bW1hcnkubGFibCA9IGQubGFibDtcblxuICAgIGQzLnNlbGVjdCgnI3RhYjMnKVxuICAgICAgICAuc2VsZWN0QWxsKCdzdmcnKVxuICAgICAgICAucmVtb3ZlKCk7XG5cbiAgICBpZiAoIWQucGxvdHR5cGUpXG4gICAgICAgIHJldHVybjtcbiAgICBkLnBsb3R0eXBlID09ICdjb250aW51b3VzJyA/IGRlbnNpdHkoZCwgJ3ZhclN1bW1hcnknLCBwcml2KSA6XG4gICAgICAgIGQucGxvdHR5cGUgPT0gXCJiYXJcIiA/IGJhcnMoZCwgJ3ZhclN1bW1hcnknLCBwcml2KSA6XG4gICAgICAgIGQzLnNlbGVjdChcIiN0YWIzXCIpIC8vIG5vIGdyYXBoIHRvIGRyYXcsIGJ1dCBzdGlsbCBuZWVkIHRvIHJlbW92ZSBwcmV2aW91cyBncmFwaFxuICAgICAgICAuc2VsZWN0QWxsKFwic3ZnXCIpXG4gICAgICAgIC5yZW1vdmUoKTtcbn1cblxuZXhwb3J0IGxldCBwb3BvdmVyQ29udGVudCA9IGQgPT4ge1xuICAgIGxldCB0ZXh0ID0gJyc7XG4gICAgbGV0IFtyaW50LCBwcmVjXSA9IFtkMy5mb3JtYXQoJ3InKSwgKHZhbCwgaW50KSA9PiAoK3ZhbCkudG9QcmVjaXNpb24oaW50KS50b1N0cmluZygpXTtcbiAgICBsZXQgZGl2ID0gKGZpZWxkLCBuYW1lLCB2YWwpID0+IHtcbiAgICAgICAgaWYgKGZpZWxkICE9ICdOQScpIHRleHQgKz0gYDxkaXYgY2xhc3M9J2Zvcm0tZ3JvdXAnPjxsYWJlbCBjbGFzcz0nY29sLXNtLTQgY29udHJvbC1sYWJlbCc+JHtuYW1lfTwvbGFiZWw+PGRpdiBjbGFzcz0nY29sLXNtLTYnPjxwIGNsYXNzPSdmb3JtLWNvbnRyb2wtc3RhdGljJz4ke3ZhbCB8fCBmaWVsZH08L3A+PC9kaXY+PC9kaXY+YDtcbiAgICB9O1xuICAgIGQubGFibCAhPSAnJyAmJiBkaXYoZC5sYWJsLCAnTGFiZWwnKTtcbiAgICBkaXYoZC5tZWFuLCAnTWVhbicsIHByaXYgJiYgZC5tZWFuQ0kgP1xuICAgICAgICBgJHtwcmVjKGQubWVhbiwgMil9ICgke3ByZWMoZC5tZWFuQ0kubG93ZXJCb3VuZCwgMil9IC0gJHtwcmVjKGQubWVhbkNJLnVwcGVyQm91bmQsIDIpfSlgIDpcbiAgICAgICAgcHJlYyhkLm1lYW4sIDQpKTtcbiAgICBkaXYoZC5tZWRpYW4sICdNZWRpYW4nLCBwcmVjKGQubWVkaWFuLCA0KSk7XG4gICAgZGl2KGQubW9kZSwgJ01vc3QgRnJlcScpO1xuICAgIGRpdihkLmZyZXFtb2RlLCAnT2NjdXJyZW5jZXMnLCAgcmludChkLmZyZXFtb2RlKSk7XG4gICAgZGl2KGQubWlkLCAnTWVkaWFuIEZyZXEnKTtcbiAgICBkaXYoZC5mcmVxbWlkLCAnT2NjdXJyZW5jZXMnLCByaW50KGQuZnJlcW1pZCkpO1xuICAgIGRpdihkLmZld2VzdCwgJ0xlYXN0IEZyZXEnKTtcbiAgICBkaXYoZC5mcmVxZmV3ZXN0LCAnT2NjdXJyZW5jZXMnLCByaW50KGQuZnJlcWZld2VzdCkpO1xuICAgIGRpdihkLnNkLCAnU3RhbmQgRGV2JywgcHJlYyhkLnNkLCA0KSk7XG4gICAgZGl2KGQubWF4LCAnTWF4aW11bScsIHByZWMoZC5tYXgsIDQpKTtcbiAgICBkaXYoZC5taW4sICdNaW5pbXVtJywgcHJlYyhkLm1pbiwgNCkpO1xuICAgIGRpdihkLmludmFsaWQsICdJbnZhbGlkJywgcmludChkLmludmFsaWQpKTtcbiAgICBkaXYoZC52YWxpZCwgJ1ZhbGlkJywgcmludChkLnZhbGlkKSk7XG4gICAgZGl2KGQudW5pcXVlcywgJ1VuaXF1ZXMnLCByaW50KGQudW5pcXVlcykpO1xuICAgIGRpdihkLmhlcmZpbmRhaGwsICdIZXJmaW5kYWhsJywgcHJlYyhkLmhlcmZpbmRhaGwsIDQpKTtcbiAgICByZXR1cm4gdGV4dDtcbn1cblxuZnVuY3Rpb24gcG9wdXBYKGQpIHtcbiAgICB2YXIgdHNmID0gZDMuZm9ybWF0KFwiLjRyXCIpO1xuICAgIHZhciByaW50ID0gZDMuZm9ybWF0KFwiclwiKTtcbiAgICAvL0NyZWF0ZSB0aGUgdG9vbHRpcCBsYWJlbFxuICAgIGQzLnNlbGVjdChcIiN0b29sdGlwXCIpXG4gICAgICAgIC5zdHlsZShcImxlZnRcIiwgdGVtcFggKyBcInB4XCIpXG4gICAgICAgIC5zdHlsZShcInRvcFwiLCB0ZW1wWSArIFwicHhcIilcbiAgICAgICAgLnNlbGVjdChcIiN0b29sdGlwdGV4dFwiKVxuICAgICAgICAuaHRtbChcIjxkaXYgY2xhc3M9J2Zvcm0tZ3JvdXAnPjxsYWJlbCBjbGFzcz0nY29sLXNtLTQgY29udHJvbC1sYWJlbCc+TWVhbjwvbGFiZWw+PGRpdiBjbGFzcz0nY29sLXNtLTYnPjxwIGNsYXNzPSdmb3JtLWNvbnRyb2wtc3RhdGljJz5cIiArIHRzZihkLm1lYW4pICsgXCI8L3A+PC9kaXY+PC9kaXY+XCIgK1xuICAgICAgICAgICAgXCI8ZGl2IGNsYXNzPSdmb3JtLWdyb3VwJz48bGFiZWwgY2xhc3M9J2NvbC1zbS00IGNvbnRyb2wtbGFiZWwnPk1lZGlhbjwvbGFiZWw+PGRpdiBjbGFzcz0nY29sLXNtLTYnPjxwIGNsYXNzPSdmb3JtLWNvbnRyb2wtc3RhdGljJz5cIiArIHRzZihkLm1lZGlhbikgKyBcIjwvcD48L2Rpdj48L2Rpdj5cIiArXG4gICAgICAgICAgICBcIjxkaXYgY2xhc3M9J2Zvcm0tZ3JvdXAnPjxsYWJlbCBjbGFzcz0nY29sLXNtLTQgY29udHJvbC1sYWJlbCc+TW9kZTwvbGFiZWw+PGRpdiBjbGFzcz0nY29sLXNtLTYnPjxwIGNsYXNzPSdmb3JtLWNvbnRyb2wtc3RhdGljJz5cIiArIGQubW9kZSArIFwiPC9wPjwvZGl2PjwvZGl2PlwiICtcbiAgICAgICAgICAgIFwiPGRpdiBjbGFzcz0nZm9ybS1ncm91cCc+PGxhYmVsIGNsYXNzPSdjb2wtc20tNCBjb250cm9sLWxhYmVsJz5TdGFuZCBEZXY8L2xhYmVsPjxkaXYgY2xhc3M9J2NvbC1zbS02Jz48cCBjbGFzcz0nZm9ybS1jb250cm9sLXN0YXRpYyc+XCIgKyB0c2YoZC5zZCkgKyBcIjwvcD48L2Rpdj48L2Rpdj5cIiArXG4gICAgICAgICAgICBcIjxkaXYgY2xhc3M9J2Zvcm0tZ3JvdXAnPjxsYWJlbCBjbGFzcz0nY29sLXNtLTQgY29udHJvbC1sYWJlbCc+TWF4aW11bTwvbGFiZWw+PGRpdiBjbGFzcz0nY29sLXNtLTYnPjxwIGNsYXNzPSdmb3JtLWNvbnRyb2wtc3RhdGljJz5cIiArIHRzZihkLm1heCkgKyBcIjwvcD48L2Rpdj48L2Rpdj5cIiArXG4gICAgICAgICAgICBcIjxkaXYgY2xhc3M9J2Zvcm0tZ3JvdXAnPjxsYWJlbCBjbGFzcz0nY29sLXNtLTQgY29udHJvbC1sYWJlbCc+TWluaW11bTwvbGFiZWw+PGRpdiBjbGFzcz0nY29sLXNtLTYnPjxwIGNsYXNzPSdmb3JtLWNvbnRyb2wtc3RhdGljJz5cIiArIHRzZihkLm1pbikgKyBcIjwvcD48L2Rpdj48L2Rpdj5cIiArXG4gICAgICAgICAgICBcIjxkaXYgY2xhc3M9J2Zvcm0tZ3JvdXAnPjxsYWJlbCBjbGFzcz0nY29sLXNtLTQgY29udHJvbC1sYWJlbCc+VmFsaWQ8L2xhYmVsPjxkaXYgY2xhc3M9J2NvbC1zbS02Jz48cCBjbGFzcz0nZm9ybS1jb250cm9sLXN0YXRpYyc+XCIgKyByaW50KGQudmFsaWQpICsgXCI8L3A+PC9kaXY+PC9kaXY+XCIgK1xuICAgICAgICAgICAgXCI8ZGl2IGNsYXNzPSdmb3JtLWdyb3VwJz48bGFiZWwgY2xhc3M9J2NvbC1zbS00IGNvbnRyb2wtbGFiZWwnPkludmFsaWQ8L2xhYmVsPjxkaXYgY2xhc3M9J2NvbC1zbS02Jz48cCBjbGFzcz0nZm9ybS1jb250cm9sLXN0YXRpYyc+XCIgKyByaW50KGQuaW52YWxpZCkgKyBcIjwvcD48L2Rpdj48L2Rpdj5cIlxuICAgICAgICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFuZWxQbG90cygpIHtcbiAgICAvLyBidWlsZCBhcnJheXMgZnJvbSBub2RlcyBpbiBtYWluXG4gICAgbGV0IHZhcnMgPSBbXTtcbiAgICBsZXQgaWRzID0gW107XG4gICAgbm9kZXMuZm9yRWFjaChuID0+IHtcbiAgICAgICAgdmFycy5wdXNoKG4ubmFtZS5yZXBsYWNlKC9cXCh8XFwpL2csICcnKSk7XG4gICAgICAgIGlkcy5wdXNoKG4uaWQpO1xuICAgIH0pO1xuXG4gICAgLy9yZW1vdmUgYWxsIHBsb3RzLCBjb3VsZCBiZSBzbWFydGVyIGhlcmVcbiAgICBkMy5zZWxlY3QoJyNzZXR4Jykuc2VsZWN0QWxsKCdzdmcnKS5yZW1vdmUoKTtcbiAgICBkMy5zZWxlY3QoJyN0YWIyJykuc2VsZWN0QWxsKCdzdmcnKS5yZW1vdmUoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG5vZGUgPSBhbGxOb2Rlc1tpZHNbaV1dO1xuICAgICAgICBub2RlLnNldHhwbG90ID0gZmFsc2U7XG4gICAgICAgIG5vZGUuc3Vic2V0cGxvdCA9IGZhbHNlO1xuICAgICAgICBpZiAobm9kZS5wbG90dHlwZSA9PT0gXCJjb250aW51b3VzXCIgJiBub2RlLnNldHhwbG90ID09IGZhbHNlKSB7XG4gICAgICAgICAgICBub2RlLnNldHhwbG90ID0gdHJ1ZTtcbiAgICAgICAgICAgIGRlbnNpdHkobm9kZSwgZGl2ID0gXCJzZXR4XCIsIHByaXYpO1xuICAgICAgICAgICAgbm9kZS5zdWJzZXRwbG90ID0gdHJ1ZTtcbiAgICAgICAgICAgIGRlbnNpdHkobm9kZSwgZGl2ID0gXCJzdWJzZXRcIiwgcHJpdik7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS5wbG90dHlwZSA9PT0gXCJiYXJcIiAmIG5vZGUuc2V0eHBsb3QgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG5vZGUuc2V0eHBsb3QgPSB0cnVlO1xuICAgICAgICAgICAgYmFycyhub2RlLCBkaXYgPSBcInNldHhcIiwgcHJpdik7XG4gICAgICAgICAgICBub2RlLnN1YnNldHBsb3QgPSB0cnVlO1xuICAgICAgICAgICAgYmFyc1N1YnNldChub2RlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGQzLnNlbGVjdChcIiNzZXR4XCIpLnNlbGVjdEFsbChcInN2Z1wiKVxuICAgICAgICAuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBkMy5zZWxlY3QodGhpcyk7XG4gICAgICAgICAgICB2YXIgcmVnc3RyID0gLyguKylfc2V0eF8oXFxkKykvO1xuICAgICAgICAgICAgdmFyIG15bmFtZSA9IHJlZ3N0ci5leGVjKHRoaXMuaWQpO1xuICAgICAgICAgICAgdmFyIG5vZGVpZCA9IG15bmFtZVsyXTtcbiAgICAgICAgICAgIG15bmFtZSA9IG15bmFtZVsxXTtcbiAgICAgICAgICAgIGlmICghdmFycy5pbmNsdWRlcyhteW5hbWUpKSB7XG4gICAgICAgICAgICAgICAgYWxsTm9kZXNbbm9kZWlkXS5zZXR4cGxvdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGxldCB0ZW1wID0gXCIjXCIuY29uY2F0KG15bmFtZSwgXCJfc2V0eF9cIiwgbm9kZWlkKTtcbiAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGVtcClcbiAgICAgICAgICAgICAgICAgICAgLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIGFsbE5vZGVzW25vZGVpZF0uc3Vic2V0cGxvdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRlbXAgPSBcIiNcIi5jb25jYXQobXluYW1lLCBcIl90YWIyX1wiLCBub2RlaWQpO1xuICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0ZW1wKVxuICAgICAgICAgICAgICAgICAgICAucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xufVxuXG4vLyBlYXN5IGZ1bmN0aW9ucyB0byBjb2xsYXBzZSBwYW5lbHMgdG8gYmFzZVxuZnVuY3Rpb24gcmlnaHRwYW5lbE1lZGl1bSgpIHtcbiAgICBkMy5zZWxlY3QoXCIjcmlnaHRwYW5lbFwiKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwic2lkZXBhbmVsIGNvbnRhaW5lciBjbGVhcmZpeFwiKTtcbn1cblxuZnVuY3Rpb24gbGVmdHBhbmVsTWVkaXVtKCkge1xuICAgIGQzLnNlbGVjdChcIiNsZWZ0cGFuZWxcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInNpZGVwYW5lbCBjb250YWluZXIgY2xlYXJmaXhcIik7XG59XG5cbi8vIGNvbnZlcnRzIGNvbG9yIGNvZGVzXG5leHBvcnQgbGV0IGhleFRvUmdiYSA9IGhleCA9PiB7XG4gICAgbGV0IGludCA9IHBhcnNlSW50KGhleC5yZXBsYWNlKCcjJywgJycpLCAxNik7XG4gICAgcmV0dXJuIGByZ2JhKCR7WyhpbnQgPj4gMTYpICYgMjU1LCAoaW50ID4+IDgpICYgMjU1LCBpbnQgJiAyNTUsICcwLjUnXS5qb2luKCcsJyl9KWA7XG59O1xuXG4vLyB0YWtlcyBub2RlIGFuZCBjb2xvciBhbmQgdXBkYXRlcyB6cGFyYW1zXG5mdW5jdGlvbiBzZXRDb2xvcnMobiwgYykge1xuICAgIGlmIChuLnN0cm9rZVdpZHRoID09ICcxJykge1xuICAgICAgICAvLyBhZGRpbmcgdGltZSwgY3MsIGR2LCBub20gdG8gbm9kZSB3aXRoIG5vIHN0cm9rZVxuICAgICAgICBuLnN0cm9rZVdpZHRoID0gJzQnO1xuICAgICAgICBuLnN0cm9rZUNvbG9yID0gYztcbiAgICAgICAgbi5ub2RlQ29sID0gdGFnZ2VkQ29sb3I7XG4gICAgICAgIGxldCBwdXNoID0gKFtjb2xvciwga2V5XSkgPT4ge1xuICAgICAgICAgICAgaWYgKGNvbG9yICE9IGMpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgenBhcmFtc1trZXldID0gQXJyYXkuaXNBcnJheSh6cGFyYW1zW2tleV0pID8genBhcmFtc1trZXldIDogW107XG4gICAgICAgICAgICB6cGFyYW1zW2tleV0ucHVzaChuLm5hbWUpO1xuICAgICAgICAgICAgaWYgKGtleSA9PSAnem5vbScpIHtcbiAgICAgICAgICAgICAgICBmaW5kTm9kZUluZGV4KG4ubmFtZSwgdHJ1ZSkubmF0dXJlID0gXCJub21pbmFsXCI7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtKG4ubmFtZSwgdCA9IG51bGwsIHR5cGVUcmFuc2Zvcm0gPSB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgW1tkdkNvbG9yLCAnemR2J10sIFtjc0NvbG9yLCAnemNyb3NzJ10sIFt0aW1lQ29sb3IsICd6dGltZSddLCBbbm9tQ29sb3IsICd6bm9tJ11dLmZvckVhY2gocHVzaCk7XG4gICAgfSBlbHNlIGlmIChuLnN0cm9rZVdpZHRoID09ICc0Jykge1xuICAgICAgICBpZiAoYyA9PSBuLnN0cm9rZUNvbG9yKSB7IC8vIGRlc2VsZWN0aW5nIHRpbWUsIGNzLCBkdiwgbm9tXG4gICAgICAgICAgICBuLnN0cm9rZVdpZHRoID0gJzEnO1xuICAgICAgICAgICAgbi5zdHJva2VDb2xvciA9IHNlbFZhckNvbG9yO1xuICAgICAgICAgICAgbi5ub2RlQ29sID0gY29sb3JzKG4uaWQpO1xuICAgICAgICAgICAgc3BsaWNlKGMsIG4ubmFtZSwgW2R2Q29sb3IsICd6ZHYnXSwgW2NzQ29sb3IsICd6Y3Jvc3MnXSwgW3RpbWVDb2xvciwgJ3p0aW1lJ10sIFtub21Db2xvciwgJ3pub20nXSk7XG4gICAgICAgICAgICBpZiAobm9tQ29sb3IgPT0gYyAmJiB6cGFyYW1zLnpub20uaW5jbHVkZXMobi5uYW1lKSkge1xuICAgICAgICAgICAgICAgIGZpbmROb2RlSW5kZXgobi5uYW1lLCB0cnVlKS5uYXR1cmUgPSBmaW5kTm9kZUluZGV4KG4ubmFtZSwgdHJ1ZSkuZGVmYXVsdE5hdHVyZTtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm0obi5uYW1lLCB0ID0gbnVsbCwgdHlwZVRyYW5zZm9ybSA9IHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgeyAvLyBkZXNlbGVjdGluZyB0aW1lLCBjcywgZHYsIG5vbSBBTkQgY2hhbmdpbmcgaXQgdG8gdGltZSwgY3MsIGR2LCBub21cbiAgICAgICAgICAgIHNwbGljZShuLnN0cm9rZUNvbG9yLCBuLm5hbWUsIFtkdkNvbG9yLCAnemR2J10sIFtjc0NvbG9yLCAnemNyb3NzJ10sIFt0aW1lQ29sb3IsICd6dGltZSddLCBbbm9tQ29sb3IsICd6bm9tJ10pO1xuICAgICAgICAgICAgaWYgKG5vbUNvbG9yID09IG4uc3Ryb2tlQ29sb3IgJiYgenBhcmFtcy56bm9tLmluY2x1ZGVzKG4ubmFtZSkpIHtcbiAgICAgICAgICAgICAgICBmaW5kTm9kZUluZGV4KG4ubmFtZSwgdHJ1ZSkubmF0dXJlID0gZmluZE5vZGVJbmRleChuLm5hbWUsIHRydWUpLmRlZmF1bHROYXR1cmU7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtKG4ubmFtZSwgdCA9IG51bGwsIHR5cGVUcmFuc2Zvcm0gPSB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG4uc3Ryb2tlQ29sb3IgPSBjO1xuICAgICAgICAgICAgaWYgKGR2Q29sb3IgPT0gYykgenBhcmFtcy56ZHYucHVzaChuLm5hbWUpO1xuICAgICAgICAgICAgZWxzZSBpZiAoY3NDb2xvciA9PSBjKSB6cGFyYW1zLnpjcm9zcy5wdXNoKG4ubmFtZSk7XG4gICAgICAgICAgICBlbHNlIGlmICh0aW1lQ29sb3IgPT0gYykgenBhcmFtcy56dGltZS5wdXNoKG4ubmFtZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChub21Db2xvciA9PSBjKSB7XG4gICAgICAgICAgICAgICAgenBhcmFtcy56bm9tLnB1c2gobi5uYW1lKTtcbiAgICAgICAgICAgICAgICBmaW5kTm9kZUluZGV4KG4ubmFtZSwgdHJ1ZSkubmF0dXJlID0gXCJub21pbmFsXCI7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtKG4ubmFtZSwgdCA9IG51bGwsIHR5cGVUcmFuc2Zvcm0gPSB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJvcmRlclN0YXRlKCkge1xuICAgIHpwYXJhbXMuemR2Lmxlbmd0aCA+IDAgP1xuICAgICAgICAkKCcjZHZCdXR0b24gLnJlY3RDb2xvciBzdmcgY2lyY2xlJykuYXR0cignc3Ryb2tlJywgZHZDb2xvcikgOlxuICAgICAgICAkKCcjZHZCdXR0b24nKS5jc3MoJ2JvcmRlci1jb2xvcicsICcjY2NjJyk7XG4gICAgenBhcmFtcy56Y3Jvc3MubGVuZ3RoID4gMCA/XG4gICAgICAgICQoJyNjc0J1dHRvbiAucmVjdENvbG9yIHN2ZyBjaXJjbGUnKS5hdHRyKCdzdHJva2UnLCBjc0NvbG9yKSA6XG4gICAgICAgICQoJyNjc0J1dHRvbicpLmNzcygnYm9yZGVyLWNvbG9yJywgJyNjY2MnKTtcbiAgICB6cGFyYW1zLnp0aW1lLmxlbmd0aCA+IDAgP1xuICAgICAgICAkKCcjdGltZUJ1dHRvbiAucmVjdENvbG9yIHN2ZyBjaXJjbGUnKS5hdHRyKCdzdHJva2UnLCB0aW1lQ29sb3IpIDpcbiAgICAgICAgJCgnI3RpbWVCdXR0b24nKS5jc3MoJ2JvcmRlci1jb2xvcicsICcjY2NjJyk7XG4gICAgenBhcmFtcy56bm9tLmxlbmd0aCA+IDAgP1xuICAgICAgICAkKCcjbm9tQnV0dG9uIC5yZWN0Q29sb3Igc3ZnIGNpcmNsZScpLmF0dHIoJ3N0cm9rZScsIG5vbUNvbG9yKSA6XG4gICAgICAgICQoJyNub21CdXR0b24nKS5jc3MoJ2JvcmRlci1jb2xvcicsICcjY2NjJyk7XG59XG5cbi8vIHNtYWxsIGFwcGVhcmFuY2UgcmVzZXRzLCBidXQgcGVyaGFwcyB0aGlzIHdpbGwgYmVjb21lIGEgaGFyZCByZXNldCBiYWNrIHRvIGFsbCBvcmlnaW5hbCBhbGxOb2RlIHZhbHVlcz9cbmZ1bmN0aW9uIG5vZGVSZXNldChuKSB7XG4gICAgbi5zdHJva2VDb2xvciA9IHNlbFZhckNvbG9yO1xuICAgIG4uc3Ryb2tlV2lkdGggPSBcIjFcIjtcbiAgICBuLm5vZGVDb2wgPSBuLmJhc2VDb2w7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdWJzZXRTZWxlY3QoYnRuKSB7XG4gICAgaWYgKGRhdGF1cmwpXG4gICAgICAgIHpwYXJhbXMuemRhdGF1cmwgPSBkYXRhdXJsO1xuICAgIGlmIChwcm9kdWN0aW9uICYmIHpwYXJhbXMuenNlc3Npb25pZCA9PSBcIlwiKSB7XG4gICAgICAgIGFsZXJ0KFwiV2FybmluZzogRGF0YSBkb3dubG9hZCBpcyBub3QgY29tcGxldGUuIFRyeSBhZ2FpbiBzb29uLlwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB6cGFyYW1zLnp2YXJzID0gW107XG4gICAgenBhcmFtcy56cGxvdCA9IFtdO1xuICAgIHZhciBzdWJzZXRFbXB0eSA9IHRydWU7XG4gICAgLy8gaXMgdGhpcyB0aGUgc2FtZSBhcyB6UG9wKCk/XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBub2Rlcy5sZW5ndGg7IGorKykgeyAvLyBwb3B1bGF0ZSB6dmFycyBhbmQgenN1YnNldCBhcnJheXNcbiAgICAgICAgenBhcmFtcy56dmFycy5wdXNoKG5vZGVzW2pdLm5hbWUpO1xuICAgICAgICB2YXIgdGVtcCA9IG5vZGVzW2pdLmlkO1xuICAgICAgICB6cGFyYW1zLnpzdWJzZXRbal0gPSBhbGxOb2Rlc1t0ZW1wXS5zdWJzZXRyYW5nZTtcbiAgICAgICAgaWYgKHpwYXJhbXMuenN1YnNldFtqXS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpZiAoenBhcmFtcy56c3Vic2V0W2pdWzBdICE9IFwiXCIpXG4gICAgICAgICAgICAgICAgenBhcmFtcy56c3Vic2V0W2pdWzBdID0gTnVtYmVyKHpwYXJhbXMuenN1YnNldFtqXVswXSk7XG4gICAgICAgICAgICBpZiAoenBhcmFtcy56c3Vic2V0W2pdWzFdICE9IFwiXCIpXG4gICAgICAgICAgICAgICAgenBhcmFtcy56c3Vic2V0W2pdWzFdID0gTnVtYmVyKHpwYXJhbXMuenN1YnNldFtqXVsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgenBhcmFtcy56cGxvdC5wdXNoKGFsbE5vZGVzW3RlbXBdLnBsb3R0eXBlKTtcbiAgICAgICAgaWYgKHpwYXJhbXMuenN1YnNldFtqXVsxXSAhPSBcIlwiKVxuICAgICAgICAgICAgc3Vic2V0RW1wdHkgPSBmYWxzZTsgLy8gb25seSBuZWVkIHRvIGNoZWNrIG9uZVxuICAgIH1cblxuICAgIGlmIChzdWJzZXRFbXB0eSA9PSB0cnVlKSB7XG4gICAgICAgIGFsZXJ0KFwiV2FybmluZzogTm8gbmV3IHN1YnNldCBzZWxlY3RlZC5cIik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgb3V0dHlwZXMgPSBbXTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGFsbE5vZGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIG91dHR5cGVzLnB1c2goe1xuICAgICAgICAgICAgdmFybmFtZXNUeXBlczogYWxsTm9kZXNbal0ubmFtZSxcbiAgICAgICAgICAgIG5hdHVyZTogYWxsTm9kZXNbal0ubmF0dXJlLFxuICAgICAgICAgICAgbnVtY2hhcjogYWxsTm9kZXNbal0ubnVtY2hhcixcbiAgICAgICAgICAgIGJpbmFyeTogYWxsTm9kZXNbal0uYmluYXJ5LFxuICAgICAgICAgICAgaW50ZXJ2YWw6IGFsbE5vZGVzW2pdLmludGVydmFsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBzdWJzZXRzdHVmZiA9IHtcbiAgICAgICAgemRhdGF1cmw6IHpwYXJhbXMuemRhdGF1cmwsXG4gICAgICAgIHp2YXJzOiB6cGFyYW1zLnp2YXJzLFxuICAgICAgICB6c3Vic2V0OiB6cGFyYW1zLnpzdWJzZXQsXG4gICAgICAgIHpzZXNzaW9uaWQ6IHpwYXJhbXMuenNlc3Npb25pZCxcbiAgICAgICAgenBsb3Q6IHpwYXJhbXMuenBsb3QsXG4gICAgICAgIGNhbGxIaXN0b3J5OiBjYWxsSGlzdG9yeSxcbiAgICAgICAgdHlwZVN0dWZmOiBvdXR0eXBlc1xuICAgIH07XG5cbiAgICB2YXIganNvbm91dCA9IEpTT04uc3RyaW5naWZ5KHN1YnNldHN0dWZmKTtcbiAgICB2YXIgdXJsY2FsbCA9IHJhcHBVUkwgKyBcInN1YnNldGFwcFwiO1xuICAgIHZhciBzb2xhanNvbm91dCA9IFwic29sYUpTT049XCIgKyBqc29ub3V0O1xuICAgIGNkYihcInVybGNhbGwgb3V0OiBcIiwgdXJsY2FsbCk7XG4gICAgY2RiKFwiUE9TVCBvdXQ6IFwiLCBzb2xhanNvbm91dCk7XG5cbiAgICBmdW5jdGlvbiBzdWJzZXRTZWxlY3RTdWNjZXNzKGJ0biwganNvbikge1xuICAgICAgICBzZWxlY3RMYWRkYS5zdG9wKCk7IC8vIHN0b3AgbW90aW9uXG4gICAgICAgICQoXCIjYnRuVmFyaWFibGVzXCIpLnRyaWdnZXIoXCJjbGlja1wiKTsgLy8gcHJvZ3JhbW1hdGljIGNsaWNrc1xuICAgICAgICAkKFwiI2J0bk1vZGVsc1wiKS50cmlnZ2VyKFwiY2xpY2tcIik7XG5cbiAgICAgICAgdmFyIGdyYXlPdXRzID0gW107XG4gICAgICAgIHZhciByQ2FsbCA9IFtdO1xuICAgICAgICByQ2FsbFswXSA9IGpzb24uY2FsbDtcblxuICAgICAgICAvLyBzdG9yZSBjb250ZW50cyBvZiB0aGUgcHJlLXN1YnNldCBzcGFjZVxuICAgICAgICB6UG9wKCk7XG4gICAgICAgIHZhciBteU5vZGVzID0galF1ZXJ5LmV4dGVuZCh0cnVlLCBbXSwgYWxsTm9kZXMpO1xuICAgICAgICB2YXIgbXlQYXJhbXMgPSBqUXVlcnkuZXh0ZW5kKHRydWUsIHt9LCB6cGFyYW1zKTtcbiAgICAgICAgdmFyIG15VHJhbnMgPSBqUXVlcnkuZXh0ZW5kKHRydWUsIFtdLCB0cmFucyk7XG4gICAgICAgIHZhciBteUZvcmNlID0galF1ZXJ5LmV4dGVuZCh0cnVlLCBbXSwgZm9yY2V0b2dnbGUpO1xuICAgICAgICB2YXIgbXlQcmVwcm9jZXNzID0galF1ZXJ5LmV4dGVuZCh0cnVlLCB7fSwgcHJlcHJvY2Vzcyk7XG4gICAgICAgIHZhciBteUxvZyA9IGpRdWVyeS5leHRlbmQodHJ1ZSwgW10sIGxvZ0FycmF5KTtcbiAgICAgICAgdmFyIG15SGlzdG9yeSA9IGpRdWVyeS5leHRlbmQodHJ1ZSwgW10sIGNhbGxIaXN0b3J5KTtcblxuICAgICAgICBzcGFjZXNbbXlzcGFjZV0gPSB7XG4gICAgICAgICAgICBcImFsbE5vZGVzXCI6IG15Tm9kZXMsXG4gICAgICAgICAgICBcInpwYXJhbXNcIjogbXlQYXJhbXMsXG4gICAgICAgICAgICBcInRyYW5zXCI6IG15VHJhbnMsXG4gICAgICAgICAgICBcImZvcmNlXCI6IG15Rm9yY2UsXG4gICAgICAgICAgICBcInByZXByb2Nlc3NcIjogbXlQcmVwcm9jZXNzLFxuICAgICAgICAgICAgXCJsb2dBcnJheVwiOiBteUxvZyxcbiAgICAgICAgICAgIFwiY2FsbEhpc3RvcnlcIjogbXlIaXN0b3J5XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gcmVtb3ZlIHByZS1zdWJzZXQgc3ZnXG4gICAgICAgIHZhciBzZWxlY3RNZSA9IFwiI21cIi5jb25jYXQobXlzcGFjZSk7XG4gICAgICAgIGQzLnNlbGVjdChzZWxlY3RNZSkuYXR0cignY2xhc3MnLCAnaXRlbScpO1xuICAgICAgICBzZWxlY3RNZSA9IFwiI3doaXRlc3BhY2VcIi5jb25jYXQobXlzcGFjZSk7XG4gICAgICAgIGQzLnNlbGVjdChzZWxlY3RNZSkucmVtb3ZlKCk7XG5cbiAgICAgICAgbXlzcGFjZSA9IHNwYWNlcy5sZW5ndGg7XG4gICAgICAgIGNhbGxIaXN0b3J5LnB1c2goe1xuICAgICAgICAgICAgZnVuYzogXCJzdWJzZXRcIixcbiAgICAgICAgICAgIHp2YXJzOiBqUXVlcnkuZXh0ZW5kKHRydWUsIFtdLCB6cGFyYW1zLnp2YXJzKSxcbiAgICAgICAgICAgIHpzdWJzZXQ6IGpRdWVyeS5leHRlbmQodHJ1ZSwgW10sIHpwYXJhbXMuenN1YnNldCksXG4gICAgICAgICAgICB6cGxvdDogalF1ZXJ5LmV4dGVuZCh0cnVlLCBbXSwgenBhcmFtcy56cGxvdClcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gdGhpcyBpcyB0byBiZSB1c2VkIHRvIGdyYXkgb3V0IGFuZCByZW1vdmUgbGlzdGVuZXJzIGZvciB2YXJpYWJsZXMgdGhhdCBoYXZlIGJlZW4gc3Vic2V0dGVkIG91dCBvZiB0aGUgZGF0YVxuICAgICAgICBmdW5jdGlvbiB2YXJPdXQodikge1xuICAgICAgICAgICAgLy8gaWYgaW4gbm9kZXMsIHJlbW92ZSBncmF5IG91dCBpbiBsZWZ0IHBhbmVsXG4gICAgICAgICAgICAvLyBtYWtlIHVuY2xpY2thYmxlIGluIGxlZnQgcGFuZWxcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBzZWxlY3RNZSA9IHZbaV0ucmVwbGFjZSgvXFxXL2csIFwiX1wiKTtcbiAgICAgICAgICAgICAgICBieUlkKHNlbGVjdE1lKS5zdHlsZS5jb2xvciA9IGhleFRvUmdiYShncmF5Q29sb3IpO1xuICAgICAgICAgICAgICAgIHNlbGVjdE1lID0gXCJwI1wiLmNvbmNhdChzZWxlY3RNZSk7XG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KHNlbGVjdE1lKVxuICAgICAgICAgICAgICAgICAgICAub24oXCJjbGlja1wiLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNob3dMb2coJ3N1YnNldCcsIHJDYWxsKTtcbiAgICAgICAgcmVXcml0ZUxvZygpO1xuXG4gICAgICAgIGQzLnNlbGVjdChcIiNpbm5lcmNhcm91c2VsXCIpXG4gICAgICAgICAgICAuYXBwZW5kKCdkaXYnKVxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2l0ZW0gYWN0aXZlJylcbiAgICAgICAgICAgIC5hdHRyKCdpZCcsICgpID0+IFwibVwiLmNvbmNhdChteXNwYWNlLnRvU3RyaW5nKCkpKVxuICAgICAgICAgICAgLmFwcGVuZCgnc3ZnJylcbiAgICAgICAgICAgIC5hdHRyKCdpZCcsICd3aGl0ZXNwYWNlJyk7XG4gICAgICAgIHN2ZyA9IGQzLnNlbGVjdChcIiN3aGl0ZXNwYWNlXCIpO1xuXG4gICAgICAgIGQzLmpzb24oanNvbi51cmwsIGZ1bmN0aW9uKGVycm9yLCBqc29uKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3Ipe1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGpzb25kYXRhID0gZ2V0VmFyaWFibGVEYXRhKGpzb24pO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4ganNvbmRhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgbXlJbmRleCA9IGZpbmROb2RlSW5kZXgoa2V5KTtcblxuICAgICAgICAgICAgICAgIGFsbE5vZGVzW215SW5kZXhdLnBsb3R4ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGFsbE5vZGVzW215SW5kZXhdLnBsb3R5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGFsbE5vZGVzW215SW5kZXhdLnBsb3R2YWx1ZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgYWxsTm9kZXNbbXlJbmRleF0ucGxvdHR5cGUgPSBcIlwiO1xuXG4gICAgICAgICAgICAgICAgalF1ZXJ5LmV4dGVuZCh0cnVlLCBhbGxOb2Rlc1tteUluZGV4XSwganNvbmRhdGFba2V5XSk7XG4gICAgICAgICAgICAgICAgYWxsTm9kZXNbbXlJbmRleF0uc3Vic2V0cGxvdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGFsbE5vZGVzW215SW5kZXhdLnN1YnNldHJhbmdlID0gW1wiXCIsIFwiXCJdO1xuICAgICAgICAgICAgICAgIGFsbE5vZGVzW215SW5kZXhdLnNldHhwbG90ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYWxsTm9kZXNbbXlJbmRleF0uc2V0eHZhbHMgPSBbXCJcIiwgXCJcIl07XG5cbiAgICAgICAgICAgICAgICBpZiAoYWxsTm9kZXNbbXlJbmRleF0udmFsaWQgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBncmF5T3V0cy5wdXNoKGFsbE5vZGVzW215SW5kZXhdLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBhbGxOb2Rlc1tteUluZGV4XS5ncmF5b3V0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZVBsb3QoKTtcblxuICAgICAgICAgICAgbGF5b3V0KGxheW91dEFkZCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhck91dChncmF5T3V0cyk7XG4gICAgfVxuXG4gICAgc2VsZWN0TGFkZGEuc3RhcnQoKTsgLy9zdGFydCBidXR0b24gbW90aW9uXG4gICAgbWFrZUNvcnNSZXF1ZXN0KHVybGNhbGwsIGJ0biwgc3Vic2V0U2VsZWN0U3VjY2VzcywgYnRuID0+IHNlbGVjdExhZGRhLnN0b3AoKSwgc29sYWpzb25vdXQpO1xufVxuXG5mdW5jdGlvbiByZWFkUHJlcHJvY2Vzcyh1cmwsIHAsIHYsIGNhbGxiYWNrKSB7XG4gIGNkYigncmVhZFByZXByb2Nlc3M6ICcgKyB1cmwgKTtcblxuICAgIGQzLmpzb24odXJsLCAoZXJyLCBqc29uKSA9PiB7XG4gICAgICAgIGlmIChlcnIpXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKGVycik7XG4gICAgICAgIGNkYignaW5zaWRlIHJlYWRQcmVwcm9jZXNzIGZ1bmN0aW9uJyk7XG4gICAgICAgIGNkYihqc29uKTtcblxuICAgICAgICBwcml2ID0ganNvbi5kYXRhc2V0LnByaXYgfHwgcHJpdjtcbiAgICAgICAgLy8gY29weSBvYmplY3RcbiAgICAgICAgT2JqZWN0LmtleXMoanNvbi52YXJpYWJsZXMpLmZvckVhY2goayA9PiBwW2tdID0ganNvbi52YXJpYWJsZXNba10pO1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09ICdmdW5jdGlvbicpIGNhbGxiYWNrKCk7XG4gICAgfSk7XG59XG5cbi8vIHJlbW92ZXMgYWxsIHRoZSBjaGlsZHJlbiBzdmdzIGluc2lkZSBzdWJzZXQgYW5kIHNldHggZGl2c1xuZnVuY3Rpb24gcmVQbG90KCkge1xuICAgIGQzLnNlbGVjdCgnI3RhYjInKVxuICAgICAgICAuc2VsZWN0QWxsKCdzdmcnKVxuICAgICAgICAucmVtb3ZlKCk7XG4gICAgZDMuc2VsZWN0KCcjc2V0eCcpXG4gICAgICAgIC5zZWxlY3RBbGwoJ3N2ZycpXG4gICAgICAgIC5yZW1vdmUoKTtcbiAgICBhbGxOb2Rlcy5mb3JFYWNoKG4gPT4gbi5zZXR4cGxvdCA9IG4uc3Vic2V0cGxvdCA9IGZhbHNlKTtcbn1cblxubGV0IHNob3dMb2cgPSAodmFsLCByQ2FsbCkgPT4ge1xuICAgIGxvZ0FycmF5LnB1c2goKHZhbCArICc6ICcpLmNvbmNhdChyQ2FsbFswXSkpO1xuICAgIG0ucmVkcmF3KCk7XG59XG5cbmZ1bmN0aW9uIHJlV3JpdGVMb2coKSB7XG4gICAgZDMuc2VsZWN0KFwiI2NvbGxhcHNlTG9nIGRpdi5wYW5lbC1ib2R5XCIpLnNlbGVjdEFsbChcInBcIilcbiAgICAgICAgLnJlbW92ZSgpO1xuICAgIGQzLnNlbGVjdChcIiNjb2xsYXBzZUxvZyBkaXYucGFuZWwtYm9keVwiKS5zZWxlY3RBbGwoXCJwXCIpXG4gICAgICAgIC5kYXRhKGxvZ0FycmF5KVxuICAgICAgICAuZW50ZXIoKVxuICAgICAgICAuYXBwZW5kKFwicFwiKVxuICAgICAgICAudGV4dChkID0+IGQpO1xufVxuXG4vLyBhY3RzIGFzIGlmIHRoZSB1c2VyIGNsaWNrZWQgaW4gd2hpdGVzcGFjZS4gdXNlZnVsIHdoZW4gcmVzdGFydCgpIGlzIG91dHNpZGUgb2Ygc2NvcGVcbmV4cG9ydCBsZXQgZmFrZUNsaWNrID0gKCkgPT4ge1xuICAgIGxldCB3cyA9IFwiI3doaXRlc3BhY2VcIi5jb25jYXQobXlzcGFjZSk7XG4gICAgLy8gZDMgYW5kIHByb2dyYW1tYXRpYyBldmVudHMgZG9uJ3QgbWVzaCB3ZWxsLCBoZXJlJ3MgYSBTTyB3b3JrYXJvdW5kIHRoYXQgbG9va3MgZ29vZCBidXQgdXNlcyBqcXVlcnkuLi5cbiAgICBqUXVlcnkuZm4uZDNDbGljayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmVhY2goKGksIGUpID0+IHtcbiAgICAgICAgICAgIGxldCBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIk1vdXNlRXZlbnRzXCIpO1xuICAgICAgICAgICAgZXZ0LmluaXRNb3VzZUV2ZW50KFwibW91c2Vkb3duXCIsIHRydWUsIHRydWUsIHdpbmRvdywgMCwgMCwgMCwgMCwgMCwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGwpO1xuICAgICAgICAgICAgZS5kaXNwYXRjaEV2ZW50KGV2dCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgJCh3cykuZDNDbGljaygpO1xuICAgIGQzLnNlbGVjdCh3cylcbiAgICAgICAgLmNsYXNzZWQoJ2FjdGl2ZScsIGZhbHNlKTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9hc3NldHMvYXBwL2FwcC5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1\n")},function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();\n\nexports.density = density;\nexports.bars = bars;\nexports.barsSubset = barsSubset;\nexports.densityNode = densityNode;\nexports.barsNode = barsNode;\nvar d3Color = \'#1f77b4\'; // d3\'s default blue\nvar selVarColor = exports.selVarColor = \'#fa8072\'; // d3.rgb("salmon");\n\n// function to use d3 to graph density plots with preprocessed data\nfunction density(node, div, priv) {\n    div = { subset: \'#tab2\', setx: \'#setx\', varSummary: \'#tab3\' }[div];\n    if (!div) return alert("Error: incorrect div selected for plots");\n\n    var _ref = [node.plotx, node.ploty],\n        xVals = _ref[0],\n        yVals = _ref[1];\n\n    if (priv && node.plotCI) {\n        var _map = [\'upperBound\', \'lowerBound\'].map(function (bound) {\n            return xVals.map(function (x, i) {\n                return { x: +x, y: +node.plotCI[bound][i] };\n            });\n        }),\n            _map2 = _slicedToArray(_map, 2),\n            _upperError = _map2[0],\n            _lowerError = _map2[1];\n\n        console.log(\'upperError\\n\', _upperError);\n    }\n\n    var tempWidth = d3.select(div).style("width");\n    var width = tempWidth.substring(0, tempWidth.length - 2);\n    var tempHeight = d3.select(div).style("height");\n    var height = tempHeight.substring(0, tempHeight.length - 2);\n    var margin = {\n        top: 20,\n        right: 20,\n        bottom: 53,\n        left: 30\n    };\n\n    // Need to fix automatic width and height settings for leftpanel (#tab2, #tab3)\n    if (div == "#tab3") {\n        width = 0.7 * (width - margin.left - margin.right), height = 0.3 * (height - margin.top - margin.bottom);\n    } else if (div == "#tab2" | div == "#setx") {\n        width = 200;\n        height = 120;\n    } else {\n        width = 0.35 * (width - margin.left - margin.right), height = 0.25 * (height - margin.top - margin.bottom);\n    };\n\n    var x = d3.scale.linear().domain([d3.min(xVals), d3.max(xVals)]).range([0, width]);\n    var invx = d3.scale.linear().range([d3.min(xVals), d3.max(xVals)]).domain([0, width]);\n    var y = d3.scale.linear().domain([d3.min(yVals), d3.max(yVals)]).range([height, 0]);\n    var xAxis = d3.svg.axis().scale(x).ticks(5).orient("bottom");\n    var yAxis = d3.svg.axis().scale(y).orient("left");\n    var brush = d3.svg.brush().x(x).extent(node.subsetrange).on("brush", brushed);\n    var brush2 = d3.svg.brush().x(x).on("brush", brushed2);\n    var area = d3.svg.area().interpolate("monotone").x(function (d) {\n        return x(d.x);\n    }).y0(height).y1(function (d) {\n        return y(d.y);\n    });\n    var line = d3.svg.line().x(function (d) {\n        return x(d.x);\n    }).y(function (d) {\n        return y(d.y);\n    }).interpolate("monotone");\n\n    // cumbersome to treat "tab3" differently, but works for now\n    // tab3, has an issue, that unless width height hardcoded, they grow with each additional graph.\n    if (div == "#tab3") {\n        var plotsvg = d3.select(div).selectAll("svg").remove();\n        plotsvg = d3.select(div).append("svg").attr("id", function () {\n            return node.name.toString().concat(div.substr(1));\n        }).style("width", 300) // set height to the height of #main.left\n        .style("height", 200).append("g").attr("transform", \'translate(\' + margin.left + \',\' + margin.top + \')\');\n    } else {\n        var plotsvg = d3.select(div).append("svg").attr("id", function () {\n            return node.name.toString().replace(/\\(|\\)/g, "").concat("_", div.substr(1), "_", node.id);\n        }).style("width", width + margin.left + margin.right) //setting height to the height of #main.left\n        .style("height", height + margin.top + margin.bottom).append("g").attr("transform", \'translate(\' + margin.left + \',\' + margin.top + \')\');\n    };\n    plotsvg.append("path").datum(xVals.map(function (x, i) {\n        return { x: +x, y: +node.ploty[i] };\n    })).attr("class", "area").attr("d", area);\n\n    //add upper bound\n    priv && node.plotCI && plotsvg.append("path").attr("class", "upperError").datum(upperError).attr("d", area);\n\n    //add lower bound\n    priv && node.plotCI && plotsvg.append("path").attr("class", "lowerError").datum(lowerError).attr("d", area);\n\n    plotsvg.append("g").attr("class", "x axis").attr("transform", "translate(0," + height + ")").call(xAxis);\n\n    plotsvg.append("text").attr("x", width / 2).attr("y", 0 - margin.top / 2).attr("text-anchor", "middle").style("font-size", "12px").text(node.name);\n\n    // add brush if subset\n    if (div == "#tab2") {\n        plotsvg.append("text").attr("id", "range").attr("x", 25).attr("y", height + 40).text(function () {\n            return "Range: ".concat(d3.min(xVals).toPrecision(4), " to ", d3.max(xVals).toPrecision(4));\n        });\n        plotsvg.append("g").attr("class", "x brush").call(brush).selectAll("rect").attr("height", height);\n    }\n\n    // add z lines and sliders setx\n    if (div == "#setx") {\n        plotsvg.append("text").attr("id", "range").attr("x", 25).attr("y", height + 40).text(function () {\n            return "x: ".concat((+node.mean).toPrecision(4));\n        });\n\n        plotsvg.append("text").attr("id", "range2").attr("x", 25).attr("y", height + 50).text(function () {\n            return "x1: ".concat((+node.mean).toPrecision(4));\n        });\n\n        // create tick marks at all zscores in the bounds of the data\n        var lineFunction = d3.svg.line().x(function (d) {\n            return d.x;\n        }).y(function (d) {\n            return d.y;\n        }).interpolate("linear");\n\n        var colSeq = ["#A2CD5A", "orange", "red"]; // will cycle through color sequence, and then repeat last color\n        var lineData = new Array();\n\n        var zLower = -1 * (d3.min(xVals) - node.mean) / node.sd; // zscore of lower bound\n        var zUpper = (d3.max(xVals) - node.mean) / node.sd; // zscore of upper bound\n\n        for (var i = 0; i < zUpper; i++) {\n            lineData = [{\n                "x": x(+node.mean + i * node.sd),\n                "y": height * .7\n            }, {\n                "x": x(+node.mean + i * node.sd),\n                "y": height * .9\n            }];\n            plotsvg.append("path").attr("d", lineFunction([lineData[0], lineData[1]])).attr("stroke", colSeq[d3.min([i, colSeq.length - 1])]).attr("stroke-width", 1.5).attr("fill", "none");\n        }\n\n        for (var i = 1; i < zLower; i++) {\n            lineData = [{\n                "x": x(+node.mean - i * node.sd),\n                "y": height * .7\n            }, {\n                "x": x(+node.mean - i * node.sd),\n                "y": height * .9\n            }];\n            plotsvg.append("path").attr("d", lineFunction([lineData[0], lineData[1]])).attr("stroke", colSeq[d3.min([i, colSeq.length - 1])]).attr("stroke-width", 1.5).attr("fill", "none");\n        }\n\n        // initialize slider components\n        var slideBox = plotsvg.append("g").attr("class", "x axis").attr("transform", "translate(0," + height * .8 + ")").call(d3.svg.axis().scale(x).ticks(0).orient("bottom"));\n        var slider = plotsvg.append("g").attr("class", "slider").call(brush);\n        var handle = slider.append("polygon").attr("class", "handle").attr("transform", "translate(0," + height * .7 + ")").attr("points", function (_) {\n            var s = 6;\n            var xnm = node.setxvals[0] == \'\' ? x(node.mean) : x(node.setxvals[0]);\n            return xnm - s + "," + -s + " " + (xnm + s) + "," + -s + " " + xnm + "," + s * 1.3;\n        });\n        var slider2 = plotsvg.append("g").attr("class", "slider").call(brush2);\n        var handle2 = slider2.append("polygon").attr("class", "handle").attr("transform", "translate(0," + height * .9 + ")").attr("points", function (_) {\n            var s = 6;\n            var xnm = node.setxvals[1] == \'\' ? x(node.mean) : x(node.setxvals[1]);\n            return xnm - s + "," + s + " " + (xnm + s) + "," + s + " " + xnm + "," + -s * 1.3;\n        });\n    }\n\n    // brushing functions\n    function brushed() {\n        if (div == "#tab2") {\n            plotsvg.select("text#range").text(function () {\n                return brush.empty() ? "Range: ".concat(d3.min(xVals).toPrecision(4), " to ", d3.max(xVals).toPrecision(4)) : "Range: ".concat(brush.extent()[0].toPrecision(4), " to ", brush.extent()[1].toPrecision(4));\n            });\n            node.subsetrange = brush.extent()[0].toPrecision(4) != brush.extent()[1].toPrecision(4) ? [brush.extent()[0].toPrecision(4), brush.extent()[1].toPrecision(4)] : ["", ""];\n        } else if (div == "#setx") {\n            var value = brush.extent()[0];\n            var s = 6;\n            if (d3.event.sourceEvent) {\n                value = x.invert(d3.mouse(this)[0]);\n                brush.extent([value, value]);\n            }\n\n            // set x position of slider center\n            var xpos = x(value);\n            if (value > d3.max(xVals)) {\n                // dragged past max\n                xpos = x(d3.max(xVals));\n            } else if (value < d3.min(xVals)) {\n                // dragged past min\n                xpos = x(d3.min(xVals));\n            } else {\n                var m = +node.mean;\n                var sd = +node.sd;\n                var zScore = (value - m) / sd; // z-score\n                var zRound = Math.round(zScore); // nearest integer z-score\n                if (.1 > Math.abs(zRound - zScore)) // snap to integer z-score\n                    xpos = x(m + zRound * sd);\n            }\n\n            // create slider symbol and text\n            handle.attr("points", function (_) {\n                return xpos - s + "," + -s + " " + (xpos + s) + "," + -s + " " + xpos + "," + s * 1.3;\n            });\n            plotsvg.select("text#range").text(function () {\n                return "x: ".concat(invx(xpos).toPrecision(4));\n            });\n            node.setxvals[1] = invx(xpos).toPrecision(4);\n        }\n    }\n\n    // certainly a more clever way to do this, but for now it\'s basically copied with brush and handle changes to brush2 and handle2 and #range to #range2 and setxvals[0] to setxvals[1]\n    function brushed2() {\n        var value = brush2.extent()[0];\n        var s = 6; // scaling for triangle shape\n\n        if (d3.event.sourceEvent) {\n            value = x.invert(d3.mouse(this)[0]);\n            brush2.extent([value, value]);\n        }\n\n        // set x position of slider center\n        var xpos = x(value);\n        if (value > d3.max(xVals)) {\n            // dragged past max\n            xpos = x(d3.max(xVals));\n        } else if (value < d3.min(xVals)) {\n            // dragged past min\n            xpos = x(d3.min(xVals));\n        } else {\n            var m = +node.mean;\n            var sd = +node.sd;\n            var zScore = (value - m) / sd; // z-score\n            var zRound = Math.round(zScore); // nearest integer z-score\n            if (.1 > Math.abs(zRound - zScore)) // snap to integer z-score\n                xpos = x(m + zRound * sd);\n        }\n\n        // create slider symbol and text\n        handle2.attr("points", function (_) {\n            return xpos - s + "," + s + " " + (xpos + s) + "," + s + " " + xpos + "," + -s * 1.3;\n        });\n        plotsvg.select("text#range2").text(function () {\n            return "x1: ".concat(invx(xpos).toPrecision(4));\n        });\n        node.setxvals[1] = invx(xpos).toPrecision(4);\n    }\n}\n\nfunction bars(node, div, priv) {\n    // Histogram spacing\n    var barPadding = .015; // Space between bars\n    var topScale = 1.2; // Multiplicative factor to assign space at top within graph - currently removed from implementation\n    var plotXaxis = true;\n\n    // Data\n    var keys = Object.keys(node.plotvalues);\n    var yVals = new Array();\n    var ciUpperVals = new Array();\n    var ciLowerVals = new Array();\n    var ciSize;\n\n    var xVals = new Array();\n    var yValKey = new Array();\n\n    if (node.nature == "nominal") {\n        var xi = 0;\n        for (var i = 0; i < keys.length; i++) {\n            if (node.plotvalues[keys[i]] == 0) continue;\n            yVals[xi] = node.plotvalues[keys[i]];\n            xVals[xi] = xi;\n            if (priv) {\n                if (node.plotvaluesCI) {\n                    ciLowerVals[xi] = node.plotValuesCI.lowerBound[keys[i]];\n                    ciUpperVals[xi] = node.plotValuesCI.upperBound[keys[i]];\n                }\n                ciSize = ciUpperVals[xi] - ciLowerVals[xi];\n            };\n\n            yValKey.push({\n                y: yVals[xi],\n                x: keys[i]\n            });\n            xi = xi + 1;\n        }\n        yValKey.sort(function (a, b) {\n            return b.y - a.y;\n        }); // array of objects, each object has y, the same as yVals, and x, the category\n        yVals.sort(function (a, b) {\n            return b - a;\n        }); // array of y values, the height of the bars\n        ciUpperVals.sort(function (a, b) {\n            return b.y - a.y;\n        }); // ?\n        ciLowerVals.sort(function (a, b) {\n            return b.y - a.y;\n        }); // ?\n    } else {\n        for (var i = 0; i < keys.length; i++) {\n            console.log("plotvalues in bars");\n            yVals[i] = node.plotvalues[keys[i]];\n            xVals[i] = Number(keys[i]);\n            if (priv) {\n                if (node.plotvaluesCI) {\n                    ciLowerVals[i] = node.plotvaluesCI.lowerBound[keys[i]];\n                    ciUpperVals[i] = node.plotvaluesCI.upperBound[keys[i]];\n                }\n                ciSize = ciUpperVals[i] - ciLowerVals[i];\n            }\n        }\n    }\n\n    if (yVals.length > 15 & node.numchar == "numeric" || yVals.length > 5 & node.numchar == "character") plotXaxis = false;\n    var maxY = d3.max(yVals); // in the future, set maxY to the value of the maximum confidence limit\n    if (priv && node.plotvaluesCI) maxY = d3.max(ciUpperVals);\n    var minX = d3.min(xVals);\n    var maxX = d3.max(xVals);\n\n    var mydiv = void 0;\n    if (div == "setx") mydiv = "#setx";else if (div == "varSummary") mydiv = "#tab3";else return alert("Error: incorrect div selected for plots");\n\n    var tempWidth = d3.select(mydiv).style("width");\n    var width = tempWidth.substring(0, tempWidth.length - 2);\n    var tempHeight = d3.select(mydiv).style("height");\n    var height = tempHeight.substring(0, tempHeight.length - 2);\n\n    var margin = {\n        top: 20,\n        right: 20,\n        bottom: 53,\n        left: 50\n    };\n\n    // Need to fix automatic width and height settings for leftpanel (#tab2, #tab3)\n    if (mydiv == "#tab3") {\n        width = 0.7 * (width - margin.left - margin.right);\n        height = 0.3 * (height - margin.top - margin.bottom);\n    } else if (mydiv == "#setx") {\n        width = 200;\n        height = 120;\n    } else {\n        width = 0.35 * (width - margin.left - margin.right);\n        height = 0.25 * (height - margin.top - margin.bottom);\n    };\n\n    if (priv && node.stabilityBin) {\n        var x = d3.scale.linear().domain([minX - 0.5, maxX + 1.5]).range([0, width]);\n    } else {\n        var x = d3.scale.linear().domain([minX - 0.5, maxX + 0.5]).range([0, width]);\n    }\n\n    var invx = d3.scale.linear().range([minX - 0.5, maxX + 0.5]).domain([0, width]);\n\n    var y = d3.scale.linear().domain([0, maxY]).range([0, height]);\n\n    var xAxis = d3.svg.axis().scale(x).ticks(yVals.length).orient("bottom");\n\n    var yAxis = d3.svg.axis().scale(y).orient("left");\n\n    var brush = d3.svg.brush().x(x).extent(function () {\n        return node.subsetrange.length == 1 ? [node.subsetrange[0], node.subsetrange[0]] : node.subsetrange;\n    }).on("brush", brushed);\n\n    var brush2 = d3.svg.brush().x(x).on("brush", brushed2);\n\n    // Create SVG element\n    // cumbersome to treat "tab3" differently, but works for now\n    // tab3, has an issue, that unless width height hardcoded, they grow with each additional graph.\n    if (mydiv == "#tab3") {\n        var plotsvg = d3.select(mydiv).selectAll("svg").remove();\n\n        var plotsvg = d3.select(mydiv).append("svg").attr("id", function () {\n            return node.name.toString().concat(mydiv.substr(1));\n        }).style("width", 300) //setting height to the height of #main.left\n        .style("height", 200).append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");\n    } else {\n        var plotsvg = d3.select(mydiv).append("svg").attr("id", function () {\n            var myname = node.name.toString();\n            myname = myname.replace(/\\(|\\)/g, "");\n            return myname.concat("_", mydiv.substr(1), "_", node.id);\n        }).style("width", width + margin.left + margin.right) //setting height to the height of #main.left\n        .style("height", height + margin.top + margin.bottom).append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");\n    };\n\n    var rectWidth = x(minX + 0.5 - 2 * barPadding); //the "width" is the coordinate of the end of the first bar\n\n    plotsvg.selectAll("rect").data(yVals).enter().append("rect").attr("x", function (d, i) {\n        return x(xVals[i] - 0.5 + barPadding);\n    }).attr("y", function (d) {\n        return y(maxY - d);\n    }).attr("width", rectWidth).attr("height", y).attr("fill", "#1f77b4");\n\n    // draw error bars, threshold line and extra bin\n    if (priv) {\n        if (yVals.length <= 20) {\n            plotsvg.selectAll("line").data(ciUpperVals).enter().append("line").style("stroke", "black").attr("x1", function (d, i) {\n                return x(xVals[i] - 0.5 + barPadding) + rectWidth / 2;\n            }).attr("y1", function (d) {\n                return y(maxY - d);\n            }).attr("x2", function (d, i) {\n                return x(xVals[i] - 0.5 + barPadding) + rectWidth / 2;\n            }).attr("y2", function (d) {\n                var y2 = y(maxY - d + ciSize);\n                return y2 >= y(maxY) ? y(maxY) : y2;\n            });\n\n            //draw top ticks on error bars\n            //need to fix the height of the graphs - the tops of error bars are getting cut off\n            plotsvg.selectAll(".topTick").data(ciUpperVals).enter().append("line").attr("class", "topTick").style("stroke", "black").attr("x1", function (d, i) {\n                if (yVals.length > 20) {\n                    return x(xVals[i] - 0.5 + barPadding); //make tick bigger to increase visibility\n                } else {\n                    return x(xVals[i] - 0.5 + barPadding) + 0.4 * rectWidth;\n                }\n            }).attr("y1", function (d) {\n                return y(maxY - d);\n            }).attr("x2", function (d, i) {\n                if (yVals.length > 20) {\n                    return x(xVals[i] - 0.5 + barPadding) + rectWidth; //make tick bigger to increase visibility\n                } else {\n                    return x(xVals[i] - 0.5 + barPadding) + 0.6 * rectWidth;\n                }\n            }).attr("y2", function (d) {\n                return y(maxY - d);\n            });\n\n            // draw bottom ticks of error bars\n            plotsvg.selectAll(".bottomTick").data(ciLowerVals).enter().append("line").attr("class", "bottomTick").style("stroke", "black").attr("x1", function (d, i) {\n                if (yVals.length > 20) {\n                    return x(xVals[i] - 0.5 + barPadding);\n                } else {\n                    return x(xVals[i] - 0.5 + barPadding) + 0.4 * rectWidth;\n                }\n            }).attr("y1", function (d) {\n                return y(maxY - d);\n            }).attr("x2", function (d, i) {\n                if (yVals.length > 20) {\n                    return x(xVals[i] - 0.5 + barPadding) + rectWidth;\n                } else {\n                    return x(xVals[i] - 0.5 + barPadding) + 0.6 * rectWidth;\n                }\n            }).attr("y2", function (d) {\n                return y(maxY - d);\n            });\n        } else {\n            plotsvg.selectAll(".denseError").data(yVals).enter().append("rect").attr("class", "denseError").attr("x", function (d, i) {\n                return x(xVals[i] - 0.5 + barPadding);\n            }).attr("y", function (d) {\n                return y(maxY - d) - .1 * y(d);\n            }).attr("width", rectWidth).attr("height", function (d) {\n                return y(maxY - d) + .1 * y(d) - (y(maxY - d) - .1 * y(d));\n            }).attr("fill", "silver");\n        }\n\n        //if statement for stability histograms\n        //extra stability bin\n        if (node.stabilityBin) {\n            plotsvg.append("rect").attr("x", x(maxX + 0.5 - barPadding)).attr("y", y(maxY) - node.stabilityBin).attr("width", rectWidth).attr("height", node.stabilityBin).attr("fill", "silver");\n        }\n\n        //threshold line\n        if (node.threshold) {\n            plotsvg.append("line").style("stroke", "black").attr("x1", x(minX - 0.5 + barPadding)).attr("y1", y(maxY) - node.threshold).attr("x2", function () {\n                console.log("stabilityBin");\n                console.log(node.stabilityBin);\n                if (node.stabilityBin) {\n                    return x(maxX + 0.5 - barPadding) + rectWidth;\n                } else {\n                    return x(maxX + 0.5 - barPadding);\n                }\n            }).attr("y2", y(maxY) - node.threshold);\n        }\n    }\n\n    if (plotXaxis) {\n        plotsvg.append("g").attr("class", "x axis").attr("transform", "translate(0," + height + ")").call(xAxis);\n    }\n\n    plotsvg.append("text").attr("x", width / 2).attr("y", 0 - margin.top / 2).attr("text-anchor", "middle").style("font-size", "12px").text(node.name);\n\n    if (mydiv == "#setx") {\n        plotsvg.append("text").attr("id", "range").attr("x", 25).attr("y", height + 40).text(function () {\n            if (node.nature === "nominal") {\n                var t = Math.round(yValKey.length / 2) - 1;\n                return "x: " + yValKey[t].x;\n            } else {\n                return "x: ".concat((+node.mean).toPrecision(4).toString());\n            }\n        });\n\n        plotsvg.append("text").attr("id", "range2").attr("x", 25).attr("y", height + 50).text(function () {\n            if (node.nature === "nominal") {\n                var t = Math.round(yValKey.length / 2) - 1;\n                return "x1: " + yValKey[t].x;\n            } else {\n                return "x1: ".concat((+node.mean).toPrecision(4).toString());\n            }\n        });\n\n        // create tick marks at all zscores in the bounds of the data\n        var lineFunction = d3.svg.line().x(function (d) {\n            return d.x;\n        }).y(function (d) {\n            return d.y;\n        }).interpolate("linear");\n\n        var colSeq = ["#A2CD5A", "orange", "red"]; // will cycle through color sequence, and then repeat last color\n        var lineData = new Array();\n\n        var zLower = -1 * (minX - node.mean) / node.sd; // zscore of lower bound\n        var zUpper = (maxX - node.mean) / node.sd; // zscore of upper bound\n\n        for (var i = 0; i < zUpper; i++) {\n            lineData = [{\n                "x": x(+node.mean + i * node.sd),\n                "y": height * .7\n            }, {\n                "x": x(+node.mean + i * node.sd),\n                "y": height * .9\n            }];\n            plotsvg.append("path").attr("d", lineFunction([lineData[0], lineData[1]])).attr("stroke", colSeq[d3.min([i, colSeq.length - 1])]).attr("stroke-width", 1.5).attr("fill", "none");\n        }\n\n        for (var i = 1; i < zLower; i++) {\n            lineData = [{\n                "x": x(+node.mean - i * node.sd),\n                "y": height * .7\n            }, {\n                "x": x(+node.mean - i * node.sd),\n                "y": height * .9\n            }];\n            plotsvg.append("path").attr("d", lineFunction([lineData[0], lineData[1]])).attr("stroke", colSeq[d3.min([i, colSeq.length - 1])]).attr("stroke-width", 1.5).attr("fill", "none");\n        }\n\n        for (var i = d3.min(xVals); i <= d3.max(xVals); i++) {\n            lineData = [{\n                "x": x(i),\n                "y": height * .75\n            }, {\n                "x": x(i),\n                "y": height * .85\n            }];\n            plotsvg.append("path").attr("d", lineFunction([lineData[0], lineData[1]])).attr("stroke", "black").attr("stroke-width", 1).attr("fill", "none");\n        }\n\n        // initialize slider components\n        var slideBox = plotsvg.append("g").attr("class", "x axis").attr("transform", "translate(0," + height * .8 + ")").call(d3.svg.axis().scale(x).ticks(0).orient("bottom"));\n\n        var slider = plotsvg.append("g").attr("class", "slider").call(brush);\n        var slider2 = plotsvg.append("g").attr("class", "slider").call(brush2);\n\n        var points = function points(i) {\n            return function (d) {\n                var xnm = void 0,\n                    s = 6;\n                if (node.setxvals[i] == \'\') {\n                    // if nominal, use the median frequency as the position for the setx slider\n                    xnm = node.nature == \'nominal\' ? x(Math.round(xVals.length / 2) - 1) : x(node.mean);\n                } else {\n                    xnm = x(node.setxvals[i]);\n                };\n                return xnm - s + \',\' + -s + \' \' + (xnm + s) + \',\' + -s + \' \' + xnm + \',\' + s * 1.3;\n            };\n        };\n        var handle = slider.append("polygon").attr("class", "handle").attr("transform", "translate(0," + height * .7 + ")").attr("points", points(0));\n        var handle2 = slider2.append("polygon").attr("class", "handle").attr("transform", "translate(0," + height * .9 + ")").attr("points", points(1));\n    }\n\n    function twoSF(x) {\n        var tsf = d3.format(".2r"); // format to two significant figures after the decimal place\n        return tsf(x).replace(/0+$/, "").replace(/\\.$/, ""); // trim trailing zeros after a period, and any orphaned period\n    }\n\n    // brushing functions\n    function brushed() {\n        var value = brush.extent()[0];\n        var s = 6;\n\n        if (d3.event.sourceEvent) {\n            value = x.invert(d3.mouse(this)[0]);\n            brush.extent([value, value]);\n        }\n\n        // set x position of slider center\n        var xpos = x(value);\n        if (value > maxX) {\n            // dragged past max\n            xpos = x(maxX);\n        } else if (value < minX) {\n            // dragged past min\n            xpos = x(minX);\n        } else {\n            var m = +node.mean;\n            var sd = +node.sd;\n            var zScore = (value - m) / sd; // z-score\n            var zRound = Math.round(zScore); // nearest integer z-score\n            if (.1 > Math.abs(Math.round(value) - value)) {\n                // snap to integer\n                xpos = x(Math.round(value));\n            } else if (.1 > Math.abs(zRound - zScore)) {\n                // snap to integer z-score\n                xpos = x(m + zRound * sd);\n            }\n        }\n\n        // create slider symbol and text\n        handle.attr("points", function (d) {\n            return xpos - s + "," + -s + " " + (xpos + s) + "," + -s + " " + xpos + "," + s * 1.3;\n        });\n        plotsvg.select("text#range").text(function () {\n            if (node.nature === "nominal") {\n                return "x: " + yValKey[Math.round(invx(xpos))].x;\n            } else {\n                return "x: ".concat(+invx(xpos).toPrecision(4).toString());\n            }\n        });\n        node.setxvals[1] = +invx(xpos).toPrecision(4);\n    }\n\n    // certainly a more clever way to do this, but for now it\'s basically copied with brush and handle changes to brush2 and handle2 and #range to #range2 and setxvals[0] to setxvals[1]\n    function brushed2() {\n        var value = brush2.extent()[0];\n        var s = 6; // scaling for triangle shape\n\n        if (d3.event.sourceEvent) {\n            value = x.invert(d3.mouse(this)[0]);\n            brush2.extent([value, value]);\n        }\n\n        // set x position of slider center\n        var xpos = x(value);\n        if (value > maxX) {\n            // dragged past max\n            xpos = x(maxX);\n        } else if (value < minX) {\n            // dragged past min\n            xpos = x(minX);\n        } else {\n            var m = +node.mean;\n            var sd = +node.sd;\n            var zScore = (value - m) / sd; // z-score\n            var zRound = Math.round(zScore); // nearest integer z-score\n            if (.1 > Math.abs(Math.round(value) - value)) {\n                // snap to integer\n                xpos = x(Math.round(value));\n            } else if (.1 > Math.abs(zRound - zScore)) {\n                // snap to integer z-score\n                xpos = x(m + zRound * sd);\n            }\n        }\n\n        // create slider symbol and text\n        handle2.attr("points", function (d) {\n            return xpos - s + "," + s + " " + (xpos + s) + "," + s + " " + xpos + "," + -s * 1.3;\n        });\n        plotsvg.select("text#range2").text(function () {\n            if (node.nature === "nominal") {\n                return "x1: " + yValKey[Math.round(invx(xpos))].x;\n            } else {\n                return "x1: ".concat(+invx(xpos).toPrecision(4).toString());\n            }\n        });\n        node.setxvals[1] = +invx(xpos).toPrecision(4);\n    }\n}\n\n// draws barplots in subset tab\nfunction barsSubset(node) {\n    // if untouched, set node.subsetrange to an empty array, meaning all values selected by default\n    if (node.subsetrange[0] == "" & node.subsetrange[1] == "") {\n        node.subsetrange = [];\n    }\n\n    // Histogram spacing\n    var barPadding = .015; // Space between bars\n    var topScale = 1.2; // Multiplicative factor to assign space at top within graph - currently removed from implementation\n    var plotXaxis = true;\n\n    // Variable name\n    var myname = node.name.toString();\n    myname = myname.replace(/\\(|\\)/g, "");\n\n    // Data\n    var keys = Object.keys(node.plotvalues);\n    var yVals = new Array();\n    var xVals = new Array();\n    var yValKey = new Array();\n\n    var xi = 0;\n    for (var i = 0; i < keys.length; i++) {\n        if (node.plotvalues[keys[i]] == 0) continue;\n        yVals[xi] = node.plotvalues[keys[i]];\n        xVals[xi] = xi;\n        yValKey.push({\n            y: yVals[xi],\n            x: keys[i]\n        });\n        xi = xi + 1;\n    }\n    if (node.nature === "nominal") {\n        // if nominal, orders bars left to right, highest frequency to lowest\n        yValKey.sort(function (a, b) {\n            return b.y - a.y;\n        }); // array of objects, each object has y, the same as yVals, and x, the category\n        yVals.sort(function (a, b) {\n            return b - a;\n        }); // array of y values, the height of the bars\n    }\n\n    plotXaxis = false;\n\n    var maxY = d3.max(yVals);\n    var minX = d3.min(xVals);\n    var maxX = d3.max(xVals);\n    var gname = ["subsetyes", "subsetno"];\n\n    var yVals2 = [];\n    var yVals1 = [];\n    for (i = 0; i < yVals.length; i++) {\n        yVals1.push({\n            y0: maxY - yVals[i],\n            y1: yVals[i],\n            col: d3Color\n        });\n        yVals2.push({\n            y0: 0,\n            y1: maxY - yVals[i],\n            col: "transparent"\n        });\n    }\n    var freqs = [yVals1, yVals2];\n\n    // y0 is the starting point\n    // y1 is the length of the bar\n\n    var mydiv = "#tab2";\n    var width = 200;\n    var height = 120;\n    var margin = {\n        top: 20,\n        right: 20,\n        bottom: 53,\n        left: 50\n    };\n\n    var x = d3.scale.linear().domain([minX - 0.5, maxX + 0.5]).range([0, width]);\n\n    var invx = d3.scale.linear().range([minX - 0.5, maxX + 0.5]).domain([0, width]);\n\n    var y = d3.scale.linear().domain([0, maxY]).range([0, height]);\n\n    var xAxis = d3.svg.axis().scale(x).ticks(yVals.length).orient("bottom");\n\n    var yAxis = d3.svg.axis().scale(y).orient("left");\n\n    //Create SVG element\n    var plotsvg = d3.select(mydiv).append("svg").attr("id", function () {\n        return myname.concat("_", mydiv.substr(1), "_", node.id);\n    }).style("width", width + margin.left + margin.right) //setting height to the height of #main.left\n    .style("height", height + margin.top + margin.bottom).append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");\n\n    var freq = plotsvg.selectAll("g.freq").data(freqs).enter().append("g").attr("class", "freq").attr("name", function (d, i) {\n        return myname.concat(gname[i]);\n    });\n\n    var rect = freq.selectAll("rect").data(Object).enter().append("rect").attr("class", "bar").attr("name", function (d, i) {\n        return xVals[i];\n    }).attr("x", function (d, i) {\n        return x(xVals[i] - 0.5 + barPadding);\n    }).attr("y", function (d) {\n        return y(d.y0);\n    }).attr("width", x(minX + 0.5 - 2 * barPadding)) // the "width" is the coordinate of the end of the first bar\n    .attr("height", function (d) {\n        return y(d.y1);\n    }).style("fill", function (d, i) {\n        if (node.subsetrange.length > 0 & d.col === d3Color & $.inArray(xVals[i].toString(), node.subsetrange) > -1) {\n            return selVarColor;\n        } else {\n            return d.col;\n        }\n    }).on("click", function () {\n        var selectMe = this;\n        var selectName = this.getAttribute("name");\n        if (this.parentNode.getAttribute("name") == myname.concat("subsetno")) {\n            selectMe = $(\'[name="\' + myname.concat("subsetyes") + \'"]\').children(\'[name="\' + selectName + \'"]\')[0];\n        }\n        d3.select(selectMe).style("fill", function (d, i) {\n            var myCol = "";\n            if (this.style.fill === selVarColor) {\n                var myindex = node.subsetrange.indexOf(this.getAttribute("name"));\n                node.subsetrange.splice(myindex, 1);\n                myCol = d3Color;\n            } else {\n                node.subsetrange.push(this.getAttribute("name"));\n                myCol = selVarColor;\n            }\n            return myCol;\n        });\n        plotsvg.select("text#selectrange").text(function () {\n            if (node.subsetrange.length == 0) {\n                return "Selected: all values";\n            } else {\n                var a = node.subsetrange;\n                var selecteds = new Array();\n                a.forEach(function (val) {\n                    selecteds.push(yValKey[val].x);\n                });\n                return "Selected: " + selecteds;\n            }\n        });\n    }).on("mouseover", function () {\n        var i = this.getAttribute("name");\n        plotsvg.select("text#mymouseover").text(function () {\n            return yValKey[i].x + ": " + yValKey[i].y;\n        });\n    }).on("mouseout", function () {\n        var i = this.getAttribute("name");\n        plotsvg.select("text#mymouseover").text(function () {\n            return "Value: Frequency";\n        });\n    });\n\n    if (plotXaxis) {\n        plotsvg.append("g").attr("class", "x axis").attr("transform", "translate(0," + height + ")").call(xAxis);\n    } else {\n        plotsvg.append("text").attr("id", "mymouseover").attr("x", 25).attr("y", height + 20).text(function () {\n            return "Value: Frequency";\n        });\n    }\n\n    plotsvg.append("text").attr("x", width / 2).attr("y", 0 - margin.top / 2).attr("text-anchor", "middle").style("font-size", "12px").text(myname);\n\n    plotsvg.append("text").attr("id", "selectrange").attr("x", 25).attr("y", height + 40).text(function () {\n        if (node.subsetrange.length == 0) return "Selected: all values";\n        var selecteds = new Array();\n        node.subsetrange.forEach(function (val) {\n            return selecteds.push(yValKey[val].x);\n        });\n        return "Selected: " + selecteds;\n    });\n}\n\nfunction densityNode(node, obj) {\n    var myname = node.name.toString().concat("nodeplot");\n\n    if (typeof obj === "undefined") {\n        var obj = document.getElementById(node.name.toString() + "biggroup");\n        // if obj contains an svg element, remove it. this removes any plot inside the node\n        if (d3.select(obj).selectAll("svg")[0].length > 0) d3.select(obj).selectAll("svg").remove();\n    }\n\n    var yVals = node.ploty;\n    var xVals = node.plotx;\n    // array of objects\n    var data2 = node.plotx.map(function (x, i) {\n        return { x: +x, y: +node.ploty[i] };\n    });\n\n    var width = 60; // hardcoded, should be set automatically\n    var height = 30;\n    var margin = {\n        top: 20,\n        right: 10,\n        bottom: 53,\n        left: 10\n    };\n\n    var x = d3.scale.linear().domain([d3.min(xVals), d3.max(xVals)]).range([0, width]);\n\n    var y = d3.scale.linear().domain([d3.min(yVals), d3.max(yVals)]).range([height, 0]);\n\n    var area = d3.svg.area().interpolate("monotone").x(function (d) {\n        return x(d.x);\n    }).y0(height).y1(function (d) {\n        return y(d.y);\n    });\n\n    var plotsvg = d3.select(obj).insert("svg", ":first-child").attr("x", -40) // NOTE: Not sure exactly why these numbers work, but these hardcoded values seem to position the plot inside g correctly.  this shouldn\'t be hardcoded in the future\n    .attr("y", -45).attr("id", function () {\n        return myname;\n    }).style("width", width).style("height", height).append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");\n\n    plotsvg.append("path").datum(data2).attr("class", "area").attr("d", area);\n}\n\nfunction barsNode(node, obj) {\n    var myname = node.name.toString().concat("nodeplot");\n\n    if (typeof obj === "undefined") {\n        var obj = document.getElementById(node.name.toString() + "biggroup");\n        // if obj contains an svg element, remove it. this removes any plot inside the node\n        if (d3.select(obj).selectAll("svg")[0].length > 0) {\n            d3.select(obj).selectAll("svg").remove();\n        }\n    }\n\n    // Histogram spacing\n    var barPadding = .015; // Space between bars\n    var topScale = 1.2; // Multiplicative factor to assign space at top within graph - currently removed from implementation\n\n    // Data\n    var keys = Object.keys(node.plotvalues);\n    var yVals = new Array();\n    var xVals = new Array();\n    var yValKey = new Array();\n\n    if (node.nature === "nominal") {\n        var xi = 0;\n        for (var i = 0; i < keys.length; i++) {\n            if (node.plotvalues[keys[i]] == 0) continue;\n            yVals[xi] = node.plotvalues[keys[i]];\n            xVals[xi] = xi;\n            yValKey.push({ y: yVals[xi], x: keys[i] });\n            xi = xi + 1;\n        }\n        yValKey.sort(function (a, b) {\n            return b.y - a.y;\n        }); // array of objects, each object has y, the same as yVals, and x, the category\n        yVals.sort(function (a, b) {\n            return b - a;\n        }); // array of y values, the height of the bars\n    } else {\n        for (var i = 0; i < keys.length; i++) {\n            yVals[i] = node.plotvalues[keys[i]];\n            xVals[i] = Number(keys[i]);\n        }\n    }\n\n    var maxY = d3.max(yVals);\n    var minX = d3.min(xVals);\n    var maxX = d3.max(xVals);\n\n    var width = 60;\n    var height = 30;\n    var margin = {\n        top: 20,\n        right: 10,\n        bottom: 53,\n        left: 10\n    };\n\n    var x = d3.scale.linear().domain([minX - 0.5, maxX + 0.5]).range([0, width]);\n\n    var invx = d3.scale.linear().range([minX - 0.5, maxX + 0.5]).domain([0, width]);\n\n    var y = d3.scale.linear().domain([0, maxY]).range([0, height]);\n\n    //Create SVG element\n    var plotsvg = d3.select(obj).insert("svg", ":first-child").attr("x", -40).attr("y", -45).attr("id", function () {\n        return myname;\n    }).style("width", width) // set height to the height of #main.left\n    .style("height", height).append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");\n\n    plotsvg.selectAll("rect").data(yVals).enter().append("rect").attr("x", function (d, i) {\n        return x(xVals[i] - 0.5 + barPadding);\n    }).attr("y", function (d) {\n        return y(maxY - d);\n    }).attr("width", x(minX + 0.5 - 2 * barPadding)) // the "width" is the coordinate of the end of the first bar\n    .attr("height", y).attr("fill", "#1f77b4");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvYXBwL3Bsb3RzLmpzP2JmMWYiXSwibmFtZXMiOlsiZGVuc2l0eSIsImJhcnMiLCJiYXJzU3Vic2V0IiwiZGVuc2l0eU5vZGUiLCJiYXJzTm9kZSIsImQzQ29sb3IiLCJzZWxWYXJDb2xvciIsIm5vZGUiLCJkaXYiLCJwcml2Iiwic3Vic2V0Iiwic2V0eCIsInZhclN1bW1hcnkiLCJhbGVydCIsInBsb3R4IiwicGxvdHkiLCJ4VmFscyIsInlWYWxzIiwicGxvdENJIiwibWFwIiwieCIsImkiLCJ5IiwiYm91bmQiLCJ1cHBlckVycm9yIiwibG93ZXJFcnJvciIsImNvbnNvbGUiLCJsb2ciLCJ0ZW1wV2lkdGgiLCJkMyIsInNlbGVjdCIsInN0eWxlIiwid2lkdGgiLCJzdWJzdHJpbmciLCJsZW5ndGgiLCJ0ZW1wSGVpZ2h0IiwiaGVpZ2h0IiwibWFyZ2luIiwidG9wIiwicmlnaHQiLCJib3R0b20iLCJsZWZ0Iiwic2NhbGUiLCJsaW5lYXIiLCJkb21haW4iLCJtaW4iLCJtYXgiLCJyYW5nZSIsImludngiLCJ4QXhpcyIsInN2ZyIsImF4aXMiLCJ0aWNrcyIsIm9yaWVudCIsInlBeGlzIiwiYnJ1c2giLCJleHRlbnQiLCJzdWJzZXRyYW5nZSIsIm9uIiwiYnJ1c2hlZCIsImJydXNoMiIsImJydXNoZWQyIiwiYXJlYSIsImludGVycG9sYXRlIiwiZCIsInkwIiwieTEiLCJsaW5lIiwicGxvdHN2ZyIsInNlbGVjdEFsbCIsInJlbW92ZSIsImFwcGVuZCIsImF0dHIiLCJuYW1lIiwidG9TdHJpbmciLCJjb25jYXQiLCJzdWJzdHIiLCJyZXBsYWNlIiwiaWQiLCJkYXR1bSIsImNhbGwiLCJ0ZXh0IiwidG9QcmVjaXNpb24iLCJtZWFuIiwibGluZUZ1bmN0aW9uIiwiY29sU2VxIiwibGluZURhdGEiLCJBcnJheSIsInpMb3dlciIsInNkIiwielVwcGVyIiwic2xpZGVCb3giLCJzbGlkZXIiLCJoYW5kbGUiLCJzIiwieG5tIiwic2V0eHZhbHMiLCJzbGlkZXIyIiwiaGFuZGxlMiIsImVtcHR5IiwidmFsdWUiLCJldmVudCIsInNvdXJjZUV2ZW50IiwiaW52ZXJ0IiwibW91c2UiLCJ4cG9zIiwibSIsInpTY29yZSIsInpSb3VuZCIsIk1hdGgiLCJyb3VuZCIsImFicyIsImJhclBhZGRpbmciLCJ0b3BTY2FsZSIsInBsb3RYYXhpcyIsImtleXMiLCJPYmplY3QiLCJwbG90dmFsdWVzIiwiY2lVcHBlclZhbHMiLCJjaUxvd2VyVmFscyIsImNpU2l6ZSIsInlWYWxLZXkiLCJuYXR1cmUiLCJ4aSIsInBsb3R2YWx1ZXNDSSIsInBsb3RWYWx1ZXNDSSIsImxvd2VyQm91bmQiLCJ1cHBlckJvdW5kIiwicHVzaCIsInNvcnQiLCJhIiwiYiIsIk51bWJlciIsIm51bWNoYXIiLCJtYXhZIiwibWluWCIsIm1heFgiLCJteWRpdiIsInN0YWJpbGl0eUJpbiIsIm15bmFtZSIsInJlY3RXaWR0aCIsImRhdGEiLCJlbnRlciIsInkyIiwidGhyZXNob2xkIiwidCIsInBvaW50cyIsInR3b1NGIiwidHNmIiwiZm9ybWF0IiwiZ25hbWUiLCJ5VmFsczIiLCJ5VmFsczEiLCJjb2wiLCJmcmVxcyIsImZyZXEiLCJyZWN0IiwiJCIsImluQXJyYXkiLCJzZWxlY3RNZSIsInNlbGVjdE5hbWUiLCJnZXRBdHRyaWJ1dGUiLCJwYXJlbnROb2RlIiwiY2hpbGRyZW4iLCJteUNvbCIsImZpbGwiLCJteWluZGV4IiwiaW5kZXhPZiIsInNwbGljZSIsInNlbGVjdGVkcyIsImZvckVhY2giLCJ2YWwiLCJvYmoiLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwiZGF0YTIiLCJpbnNlcnQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O1FBSWdCQSxPLEdBQUFBLE87UUEwU0FDLEksR0FBQUEsSTtRQWtnQkFDLFUsR0FBQUEsVTtRQTZOQUMsVyxHQUFBQSxXO1FBc0RBQyxRLEdBQUFBLFE7QUFua0NoQixJQUFJQyxVQUFVLFNBQWQsQyxDQUF5QjtBQUNsQixJQUFJQyxvQ0FBYyxT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QU47QUFBQSxLQUpGLEVBS1Q1RyxLQUxTLENBS0gsT0FMRyxFQUtNQyxLQUxOLEVBS2E7QUFMYixLQU1URCxLQU5TLENBTUgsUUFORyxFQU1PSyxNQU5QLEVBT1RtQyxNQVBTLENBT0YsR0FQRSxFQVFUQyxJQVJTLENBUUosV0FSSSxFQVFTLGVBQWVuQyxPQUFPSSxJQUF0QixHQUE2QixHQUE3QixHQUFtQ0osT0FBT0MsR0FBMUMsR0FBZ0QsR0FSekQsQ0FBZDs7QUFVQThCLFlBQVFDLFNBQVIsQ0FBa0IsTUFBbEIsRUFDS3dFLElBREwsQ0FDVTVILEtBRFYsRUFFSzZILEtBRkwsR0FHS3ZFLE1BSEwsQ0FHWSxNQUhaLEVBSUtDLElBSkwsQ0FJVSxHQUpWLEVBSWUsVUFBQ1IsQ0FBRCxFQUFJM0MsQ0FBSjtBQUFBLGVBQVdELEVBQUVKLE1BQU1LLENBQU4sSUFBVyxHQUFYLEdBQWlCMkYsVUFBbkIsQ0FBWDtBQUFBLEtBSmYsRUFLS3hDLElBTEwsQ0FLVSxHQUxWLEVBS2U7QUFBQSxlQUFNbEQsRUFBRWdILE9BQU90RSxDQUFULENBQU47QUFBQSxLQUxmLEVBTUtRLElBTkwsQ0FNVSxPQU5WLEVBTW1CcEQsRUFBRW1ILE9BQU8sR0FBUCxHQUFhLElBQUl2QixVQUFuQixDQU5uQixFQU1tRDtBQU5uRCxLQU9LeEMsSUFQTCxDQU9VLFFBUFYsRUFPb0JsRCxDQVBwQixFQVFLa0QsSUFSTCxDQVFVLE1BUlYsRUFRa0IsU0FSbEI7QUFTSCIsImZpbGUiOiIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsibGV0IGQzQ29sb3IgPSAnIzFmNzdiNCc7IC8vIGQzJ3MgZGVmYXVsdCBibHVlXG5leHBvcnQgbGV0IHNlbFZhckNvbG9yID0gJyNmYTgwNzInOyAvLyBkMy5yZ2IoXCJzYWxtb25cIik7XG5cbi8vIGZ1bmN0aW9uIHRvIHVzZSBkMyB0byBncmFwaCBkZW5zaXR5IHBsb3RzIHdpdGggcHJlcHJvY2Vzc2VkIGRhdGFcbmV4cG9ydCBmdW5jdGlvbiBkZW5zaXR5KG5vZGUsIGRpdiwgcHJpdikge1xuICAgIGRpdiA9IHtzdWJzZXQ6ICcjdGFiMicsIHNldHg6ICcjc2V0eCcsIHZhclN1bW1hcnk6ICcjdGFiMyd9W2Rpdl07XG4gICAgaWYgKCFkaXYpXG4gICAgICAgIHJldHVybiBhbGVydChcIkVycm9yOiBpbmNvcnJlY3QgZGl2IHNlbGVjdGVkIGZvciBwbG90c1wiKTtcblxuICAgIGxldCBbeFZhbHMsIHlWYWxzXSA9IFtub2RlLnBsb3R4LCBub2RlLnBsb3R5XTtcbiAgICBpZiAocHJpdiAmJiBub2RlLnBsb3RDSSkge1xuICAgICAgICBsZXQgW3VwcGVyRXJyb3IsIGxvd2VyRXJyb3JdID0gWyd1cHBlckJvdW5kJywgJ2xvd2VyQm91bmQnXS5tYXAoXG4gICAgICAgICAgICBib3VuZCA9PiB4VmFscy5tYXAoKHgsIGkpID0+ICh7eDogK3gsIHk6ICtub2RlLnBsb3RDSVtib3VuZF1baV19KSkpO1xuICAgICAgICBjb25zb2xlLmxvZygndXBwZXJFcnJvclxcbicsIHVwcGVyRXJyb3IpO1xuICAgIH1cblxuICAgIHZhciB0ZW1wV2lkdGggPSBkMy5zZWxlY3QoZGl2KS5zdHlsZShcIndpZHRoXCIpO1xuICAgIHZhciB3aWR0aCA9IHRlbXBXaWR0aC5zdWJzdHJpbmcoMCwgKHRlbXBXaWR0aC5sZW5ndGggLSAyKSk7XG4gICAgdmFyIHRlbXBIZWlnaHQgPSBkMy5zZWxlY3QoZGl2KS5zdHlsZShcImhlaWdodFwiKTtcbiAgICB2YXIgaGVpZ2h0ID0gdGVtcEhlaWdodC5zdWJzdHJpbmcoMCwgKHRlbXBIZWlnaHQubGVuZ3RoIC0gMikpO1xuICAgIHZhciBtYXJnaW4gPSB7XG4gICAgICAgIHRvcDogMjAsXG4gICAgICAgIHJpZ2h0OiAyMCxcbiAgICAgICAgYm90dG9tOiA1MyxcbiAgICAgICAgbGVmdDogMzBcbiAgICB9O1xuXG4gICAgLy8gTmVlZCB0byBmaXggYXV0b21hdGljIHdpZHRoIGFuZCBoZWlnaHQgc2V0dGluZ3MgZm9yIGxlZnRwYW5lbCAoI3RhYjIsICN0YWIzKVxuICAgIGlmIChkaXYgPT0gXCIjdGFiM1wiKSB7XG4gICAgICAgIHdpZHRoID0gMC43ICogKHdpZHRoIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQpLFxuICAgICAgICBoZWlnaHQgPSAwLjMgKiAoaGVpZ2h0IC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b20pO1xuICAgIH0gZWxzZSBpZiAoZGl2ID09IFwiI3RhYjJcIiB8IGRpdiA9PSBcIiNzZXR4XCIpIHtcbiAgICAgICAgd2lkdGggPSAyMDA7XG4gICAgICAgIGhlaWdodCA9IDEyMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB3aWR0aCA9IDAuMzUgKiAod2lkdGggLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodCksXG4gICAgICAgIGhlaWdodCA9IDAuMjUgKiAoaGVpZ2h0IC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b20pO1xuICAgIH07XG5cbiAgICB2YXIgeCA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgIC5kb21haW4oW2QzLm1pbih4VmFscyksIGQzLm1heCh4VmFscyldKVxuICAgICAgICAucmFuZ2UoWzAsIHdpZHRoXSk7XG4gICAgdmFyIGludnggPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAucmFuZ2UoW2QzLm1pbih4VmFscyksIGQzLm1heCh4VmFscyldKVxuICAgICAgICAuZG9tYWluKFswLCB3aWR0aF0pO1xuICAgIHZhciB5ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLmRvbWFpbihbZDMubWluKHlWYWxzKSwgZDMubWF4KHlWYWxzKV0pXG4gICAgICAgIC5yYW5nZShbaGVpZ2h0LCAwXSk7XG4gICAgdmFyIHhBeGlzID0gZDMuc3ZnLmF4aXMoKVxuICAgICAgICAuc2NhbGUoeClcbiAgICAgICAgLnRpY2tzKDUpXG4gICAgICAgIC5vcmllbnQoXCJib3R0b21cIik7XG4gICAgdmFyIHlBeGlzID0gZDMuc3ZnLmF4aXMoKVxuICAgICAgICAuc2NhbGUoeSlcbiAgICAgICAgLm9yaWVudChcImxlZnRcIik7XG4gICAgdmFyIGJydXNoID0gZDMuc3ZnLmJydXNoKClcbiAgICAgICAgLngoeClcbiAgICAgICAgLmV4dGVudChub2RlLnN1YnNldHJhbmdlKVxuICAgICAgICAub24oXCJicnVzaFwiLCBicnVzaGVkKTtcbiAgICB2YXIgYnJ1c2gyID0gZDMuc3ZnLmJydXNoKClcbiAgICAgICAgLngoeClcbiAgICAgICAgLm9uKFwiYnJ1c2hcIiwgYnJ1c2hlZDIpO1xuICAgIHZhciBhcmVhID0gZDMuc3ZnLmFyZWEoKVxuICAgICAgICAuaW50ZXJwb2xhdGUoXCJtb25vdG9uZVwiKVxuICAgICAgICAueChkID0+IHgoZC54KSlcbiAgICAgICAgLnkwKGhlaWdodClcbiAgICAgICAgLnkxKGQgPT4geShkLnkpKTtcbiAgICB2YXIgbGluZSA9IGQzLnN2Zy5saW5lKClcbiAgICAgICAgLngoZCA9PiB4KGQueCkpXG4gICAgICAgIC55KGQgPT4geShkLnkpKVxuICAgICAgICAuaW50ZXJwb2xhdGUoXCJtb25vdG9uZVwiKTtcblxuICAgIC8vIGN1bWJlcnNvbWUgdG8gdHJlYXQgXCJ0YWIzXCIgZGlmZmVyZW50bHksIGJ1dCB3b3JrcyBmb3Igbm93XG4gICAgLy8gdGFiMywgaGFzIGFuIGlzc3VlLCB0aGF0IHVubGVzcyB3aWR0aCBoZWlnaHQgaGFyZGNvZGVkLCB0aGV5IGdyb3cgd2l0aCBlYWNoIGFkZGl0aW9uYWwgZ3JhcGguXG4gICAgaWYgKGRpdiA9PSBcIiN0YWIzXCIpIHtcbiAgICAgICAgdmFyIHBsb3RzdmcgPSBkMy5zZWxlY3QoZGl2KVxuICAgICAgICAgICAgLnNlbGVjdEFsbChcInN2Z1wiKVxuICAgICAgICAgICAgLnJlbW92ZSgpO1xuICAgICAgICBwbG90c3ZnID0gZDMuc2VsZWN0KGRpdilcbiAgICAgICAgICAgIC5hcHBlbmQoXCJzdmdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgKCkgPT4gbm9kZS5uYW1lLnRvU3RyaW5nKCkuY29uY2F0KGRpdi5zdWJzdHIoMSkpKVxuICAgICAgICAgICAgLnN0eWxlKFwid2lkdGhcIiwgMzAwKSAvLyBzZXQgaGVpZ2h0IHRvIHRoZSBoZWlnaHQgb2YgI21haW4ubGVmdFxuICAgICAgICAgICAgLnN0eWxlKFwiaGVpZ2h0XCIsIDIwMClcbiAgICAgICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBgdHJhbnNsYXRlKCR7bWFyZ2luLmxlZnR9LCR7bWFyZ2luLnRvcH0pYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHBsb3RzdmcgPSBkMy5zZWxlY3QoZGl2KVxuICAgICAgICAgICAgLmFwcGVuZChcInN2Z1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCAoKSA9PiBub2RlLm5hbWUudG9TdHJpbmcoKVxuICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcKHxcXCkvZywgXCJcIilcbiAgICAgICAgICAgICAgICAgIC5jb25jYXQoXCJfXCIsIGRpdi5zdWJzdHIoMSksIFwiX1wiLCBub2RlLmlkKSlcbiAgICAgICAgICAgIC5zdHlsZShcIndpZHRoXCIsIHdpZHRoICsgbWFyZ2luLmxlZnQgKyBtYXJnaW4ucmlnaHQpIC8vc2V0dGluZyBoZWlnaHQgdG8gdGhlIGhlaWdodCBvZiAjbWFpbi5sZWZ0XG4gICAgICAgICAgICAuc3R5bGUoXCJoZWlnaHRcIiwgaGVpZ2h0ICsgbWFyZ2luLnRvcCArIG1hcmdpbi5ib3R0b20pXG4gICAgICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgYHRyYW5zbGF0ZSgke21hcmdpbi5sZWZ0fSwke21hcmdpbi50b3B9KWApO1xuICAgIH07XG4gICAgcGxvdHN2Zy5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgIC5kYXR1bSh4VmFscy5tYXAoKHgsIGkpID0+ICh7eDogK3gsIHk6ICtub2RlLnBsb3R5W2ldfSkpKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiYXJlYVwiKVxuICAgICAgICAuYXR0cihcImRcIiwgYXJlYSk7XG5cbiAgICAvL2FkZCB1cHBlciBib3VuZFxuICAgIHByaXYgJiYgbm9kZS5wbG90Q0kgJiYgcGxvdHN2Zy5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJ1cHBlckVycm9yXCIpXG4gICAgICAgIC5kYXR1bSh1cHBlckVycm9yKVxuICAgICAgICAuYXR0cihcImRcIiwgYXJlYSk7XG5cbiAgICAvL2FkZCBsb3dlciBib3VuZFxuICAgIHByaXYgJiYgbm9kZS5wbG90Q0kgJiYgcGxvdHN2Zy5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJsb3dlckVycm9yXCIpXG4gICAgICAgIC5kYXR1bShsb3dlckVycm9yKVxuICAgICAgICAuYXR0cihcImRcIiwgYXJlYSk7XG5cbiAgICBwbG90c3ZnLmFwcGVuZChcImdcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInggYXhpc1wiKVxuICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLFwiICsgaGVpZ2h0ICsgXCIpXCIpXG4gICAgICAgIC5jYWxsKHhBeGlzKTtcblxuICAgIHBsb3RzdmcuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAuYXR0cihcInhcIiwgKHdpZHRoIC8gMikpXG4gICAgICAgIC5hdHRyKFwieVwiLCAwIC0gKG1hcmdpbi50b3AgLyAyKSlcbiAgICAgICAgLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKVxuICAgICAgICAuc3R5bGUoXCJmb250LXNpemVcIiwgXCIxMnB4XCIpXG4gICAgICAgIC50ZXh0KG5vZGUubmFtZSk7XG5cbiAgICAvLyBhZGQgYnJ1c2ggaWYgc3Vic2V0XG4gICAgaWYgKGRpdiA9PSBcIiN0YWIyXCIpIHtcbiAgICAgICAgcGxvdHN2Zy5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsIFwicmFuZ2VcIilcbiAgICAgICAgICAgIC5hdHRyKFwieFwiLCAyNSlcbiAgICAgICAgICAgIC5hdHRyKFwieVwiLCBoZWlnaHQgKyA0MClcbiAgICAgICAgICAgIC50ZXh0KCgpID0+IFwiUmFuZ2U6IFwiLmNvbmNhdChkMy5taW4oeFZhbHMpLnRvUHJlY2lzaW9uKDQpLCBcIiB0byBcIiwgZDMubWF4KHhWYWxzKS50b1ByZWNpc2lvbig0KSkpO1xuICAgICAgICBwbG90c3ZnLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJ4IGJydXNoXCIpXG4gICAgICAgICAgICAuY2FsbChicnVzaClcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoXCJyZWN0XCIpXG4gICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCBoZWlnaHQpO1xuICAgIH1cblxuICAgIC8vIGFkZCB6IGxpbmVzIGFuZCBzbGlkZXJzIHNldHhcbiAgICBpZiAoZGl2ID09IFwiI3NldHhcIikge1xuICAgICAgICBwbG90c3ZnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgXCJyYW5nZVwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIDI1KVxuICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIGhlaWdodCArIDQwKVxuICAgICAgICAgICAgLnRleHQoKCkgPT4gXCJ4OiBcIi5jb25jYXQoKCtub2RlLm1lYW4pLnRvUHJlY2lzaW9uKDQpKSk7XG5cbiAgICAgICAgcGxvdHN2Zy5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsIFwicmFuZ2UyXCIpXG4gICAgICAgICAgICAuYXR0cihcInhcIiwgMjUpXG4gICAgICAgICAgICAuYXR0cihcInlcIiwgaGVpZ2h0ICsgNTApXG4gICAgICAgICAgICAudGV4dCgoKSA9PiBcIngxOiBcIi5jb25jYXQoKCtub2RlLm1lYW4pLnRvUHJlY2lzaW9uKDQpKSk7XG5cbiAgICAgICAgLy8gY3JlYXRlIHRpY2sgbWFya3MgYXQgYWxsIHpzY29yZXMgaW4gdGhlIGJvdW5kcyBvZiB0aGUgZGF0YVxuICAgICAgICB2YXIgbGluZUZ1bmN0aW9uID0gZDMuc3ZnLmxpbmUoKVxuICAgICAgICAgICAgLngoZCA9PiBkLngpXG4gICAgICAgICAgICAueShkID0+IGQueSlcbiAgICAgICAgICAgIC5pbnRlcnBvbGF0ZShcImxpbmVhclwiKTtcblxuICAgICAgICB2YXIgY29sU2VxID0gW1wiI0EyQ0Q1QVwiLCBcIm9yYW5nZVwiLCBcInJlZFwiXTsgLy8gd2lsbCBjeWNsZSB0aHJvdWdoIGNvbG9yIHNlcXVlbmNlLCBhbmQgdGhlbiByZXBlYXQgbGFzdCBjb2xvclxuICAgICAgICB2YXIgbGluZURhdGEgPSBuZXcgQXJyYXk7XG5cbiAgICAgICAgdmFyIHpMb3dlciA9IC0xICogKGQzLm1pbih4VmFscykgLSBub2RlLm1lYW4pIC8gbm9kZS5zZDsgLy8genNjb3JlIG9mIGxvd2VyIGJvdW5kXG4gICAgICAgIHZhciB6VXBwZXIgPSAoZDMubWF4KHhWYWxzKSAtIG5vZGUubWVhbikgLyBub2RlLnNkOyAvLyB6c2NvcmUgb2YgdXBwZXIgYm91bmRcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHpVcHBlcjsgaSsrKSB7XG4gICAgICAgICAgICBsaW5lRGF0YSA9IFt7XG4gICAgICAgICAgICAgICAgXCJ4XCI6IHgoK25vZGUubWVhbiArIGkgKiBub2RlLnNkKSxcbiAgICAgICAgICAgICAgICBcInlcIjogaGVpZ2h0ICogLjdcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBcInhcIjogeCgrbm9kZS5tZWFuICsgaSAqIG5vZGUuc2QpLFxuICAgICAgICAgICAgICAgIFwieVwiOiBoZWlnaHQgKiAuOVxuICAgICAgICAgICAgfV07XG4gICAgICAgICAgICBwbG90c3ZnLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImRcIiwgbGluZUZ1bmN0aW9uKFtsaW5lRGF0YVswXSwgbGluZURhdGFbMV1dKSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInN0cm9rZVwiLCBjb2xTZXFbZDMubWluKFtpLCBjb2xTZXEubGVuZ3RoIC0gMV0pXSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInN0cm9rZS13aWR0aFwiLCAxLjUpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJmaWxsXCIsIFwibm9uZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgekxvd2VyOyBpKyspIHtcbiAgICAgICAgICAgIGxpbmVEYXRhID0gW3tcbiAgICAgICAgICAgICAgICBcInhcIjogeCgrbm9kZS5tZWFuIC0gaSAqIG5vZGUuc2QpLFxuICAgICAgICAgICAgICAgIFwieVwiOiBoZWlnaHQgKiAuN1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIFwieFwiOiB4KCtub2RlLm1lYW4gLSBpICogbm9kZS5zZCksXG4gICAgICAgICAgICAgICAgXCJ5XCI6IGhlaWdodCAqIC45XG4gICAgICAgICAgICB9XTtcbiAgICAgICAgICAgIHBsb3RzdmcuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiZFwiLCBsaW5lRnVuY3Rpb24oW2xpbmVEYXRhWzBdLCBsaW5lRGF0YVsxXV0pKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwic3Ryb2tlXCIsIGNvbFNlcVtkMy5taW4oW2ksIGNvbFNlcS5sZW5ndGggLSAxXSldKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwic3Ryb2tlLXdpZHRoXCIsIDEuNSlcbiAgICAgICAgICAgICAgICAuYXR0cihcImZpbGxcIiwgXCJub25lXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaW5pdGlhbGl6ZSBzbGlkZXIgY29tcG9uZW50c1xuICAgICAgICB2YXIgc2xpZGVCb3ggPSBwbG90c3ZnLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJ4IGF4aXNcIilcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsXCIgKyBoZWlnaHQgKiAuOCArIFwiKVwiKVxuICAgICAgICAgICAgLmNhbGwoZDMuc3ZnLmF4aXMoKVxuICAgICAgICAgICAgICAgICAgLnNjYWxlKHgpXG4gICAgICAgICAgICAgICAgICAudGlja3MoMClcbiAgICAgICAgICAgICAgICAgIC5vcmllbnQoXCJib3R0b21cIikpO1xuICAgICAgICB2YXIgc2xpZGVyID0gcGxvdHN2Zy5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwic2xpZGVyXCIpXG4gICAgICAgICAgICAuY2FsbChicnVzaCk7XG4gICAgICAgIHZhciBoYW5kbGUgPSBzbGlkZXIuYXBwZW5kKFwicG9seWdvblwiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImhhbmRsZVwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCxcIiArIGhlaWdodCAqIC43ICsgXCIpXCIpXG4gICAgICAgICAgICAuYXR0cihcInBvaW50c1wiLCBfID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgcyA9IDY7XG4gICAgICAgICAgICAgICAgbGV0IHhubSA9IG5vZGUuc2V0eHZhbHNbMF0gPT0gJycgPyB4KG5vZGUubWVhbikgOiB4KG5vZGUuc2V0eHZhbHNbMF0pO1xuICAgICAgICAgICAgICAgIHJldHVybiAoeG5tIC0gcykgKyBcIixcIiArICgtcykgKyBcIiBcIiArICh4bm0gKyBzKSArIFwiLFwiICsgKC1zKSArIFwiIFwiICsgeG5tICsgXCIsXCIgKyAocyAqIDEuMyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgdmFyIHNsaWRlcjIgPSBwbG90c3ZnLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJzbGlkZXJcIilcbiAgICAgICAgICAgIC5jYWxsKGJydXNoMik7XG4gICAgICAgIHZhciBoYW5kbGUyID0gc2xpZGVyMi5hcHBlbmQoXCJwb2x5Z29uXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiaGFuZGxlXCIpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLFwiICsgaGVpZ2h0ICogLjkgKyBcIilcIilcbiAgICAgICAgICAgIC5hdHRyKFwicG9pbnRzXCIsIF8gPT4ge1xuICAgICAgICAgICAgICAgIGxldCBzID0gNjtcbiAgICAgICAgICAgICAgICBsZXQgeG5tID0gbm9kZS5zZXR4dmFsc1sxXSA9PSAnJyA/IHgobm9kZS5tZWFuKSA6IHgobm9kZS5zZXR4dmFsc1sxXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh4bm0gLSBzKSArIFwiLFwiICsgcyArIFwiIFwiICsgKHhubSArIHMpICsgXCIsXCIgKyBzICsgXCIgXCIgKyB4bm0gKyBcIixcIiArICgtcyAqIDEuMyk7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBicnVzaGluZyBmdW5jdGlvbnNcbiAgICBmdW5jdGlvbiBicnVzaGVkKCkge1xuICAgICAgICBpZiAoZGl2ID09IFwiI3RhYjJcIikge1xuICAgICAgICAgICAgcGxvdHN2Zy5zZWxlY3QoXCJ0ZXh0I3JhbmdlXCIpXG4gICAgICAgICAgICAgICAgLnRleHQoKCkgPT4gYnJ1c2guZW1wdHkoKSA/XG4gICAgICAgICAgICAgICAgICAgIFwiUmFuZ2U6IFwiLmNvbmNhdChkMy5taW4oeFZhbHMpLnRvUHJlY2lzaW9uKDQpLCBcIiB0byBcIiwgZDMubWF4KHhWYWxzKS50b1ByZWNpc2lvbig0KSkgOlxuICAgICAgICAgICAgICAgICAgICBcIlJhbmdlOiBcIi5jb25jYXQoKGJydXNoLmV4dGVudCgpWzBdKS50b1ByZWNpc2lvbig0KSwgXCIgdG8gXCIsIChicnVzaC5leHRlbnQoKVsxXSkudG9QcmVjaXNpb24oNCkpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG5vZGUuc3Vic2V0cmFuZ2UgPSBicnVzaC5leHRlbnQoKVswXS50b1ByZWNpc2lvbig0KSAhPSBicnVzaC5leHRlbnQoKVsxXS50b1ByZWNpc2lvbig0KSA/XG4gICAgICAgICAgICAgICAgWyhicnVzaC5leHRlbnQoKVswXSkudG9QcmVjaXNpb24oNCksIChicnVzaC5leHRlbnQoKVsxXSkudG9QcmVjaXNpb24oNCldIDpcbiAgICAgICAgICAgICAgICBbXCJcIiwgXCJcIl07XG4gICAgICAgIH0gZWxzZSBpZiAoZGl2ID09IFwiI3NldHhcIikge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gYnJ1c2guZXh0ZW50KClbMF07XG4gICAgICAgICAgICB2YXIgcyA9IDY7XG4gICAgICAgICAgICBpZiAoZDMuZXZlbnQuc291cmNlRXZlbnQpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHguaW52ZXJ0KGQzLm1vdXNlKHRoaXMpWzBdKTtcbiAgICAgICAgICAgICAgICBicnVzaC5leHRlbnQoW3ZhbHVlLCB2YWx1ZV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzZXQgeCBwb3NpdGlvbiBvZiBzbGlkZXIgY2VudGVyXG4gICAgICAgICAgICB2YXIgeHBvcyA9IHgodmFsdWUpO1xuICAgICAgICAgICAgaWYgKHZhbHVlID4gZDMubWF4KHhWYWxzKSkgeyAvLyBkcmFnZ2VkIHBhc3QgbWF4XG4gICAgICAgICAgICAgICAgeHBvcyA9IHgoZDMubWF4KHhWYWxzKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlIDwgZDMubWluKHhWYWxzKSkgeyAvLyBkcmFnZ2VkIHBhc3QgbWluXG4gICAgICAgICAgICAgICAgeHBvcyA9IHgoZDMubWluKHhWYWxzKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBtID0gK25vZGUubWVhbjtcbiAgICAgICAgICAgICAgICB2YXIgc2QgPSArbm9kZS5zZDtcbiAgICAgICAgICAgICAgICB2YXIgelNjb3JlID0gKHZhbHVlIC0gbSkgLyBzZDsgLy8gei1zY29yZVxuICAgICAgICAgICAgICAgIHZhciB6Um91bmQgPSBNYXRoLnJvdW5kKHpTY29yZSk7IC8vIG5lYXJlc3QgaW50ZWdlciB6LXNjb3JlXG4gICAgICAgICAgICAgICAgaWYgKC4xID4gTWF0aC5hYnMoelJvdW5kIC0gelNjb3JlKSkgLy8gc25hcCB0byBpbnRlZ2VyIHotc2NvcmVcbiAgICAgICAgICAgICAgICAgICAgeHBvcyA9IHgobSArICh6Um91bmQgKiBzZCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjcmVhdGUgc2xpZGVyIHN5bWJvbCBhbmQgdGV4dFxuICAgICAgICAgICAgaGFuZGxlLmF0dHIoXCJwb2ludHNcIiwgXyA9PiAoeHBvcyAtIHMpICsgXCIsXCIgKyAoLXMpICsgXCIgXCIgKyAoeHBvcyArIHMpICsgXCIsXCIgKyAoLXMpICsgXCIgXCIgKyB4cG9zICsgXCIsXCIgKyAocyAqIDEuMykpO1xuICAgICAgICAgICAgcGxvdHN2Zy5zZWxlY3QoXCJ0ZXh0I3JhbmdlXCIpXG4gICAgICAgICAgICAgICAgLnRleHQoKCkgPT4gXCJ4OiBcIi5jb25jYXQoKGludngoeHBvcykpLnRvUHJlY2lzaW9uKDQpKSk7XG4gICAgICAgICAgICBub2RlLnNldHh2YWxzWzFdID0gKGludngoeHBvcykpLnRvUHJlY2lzaW9uKDQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2VydGFpbmx5IGEgbW9yZSBjbGV2ZXIgd2F5IHRvIGRvIHRoaXMsIGJ1dCBmb3Igbm93IGl0J3MgYmFzaWNhbGx5IGNvcGllZCB3aXRoIGJydXNoIGFuZCBoYW5kbGUgY2hhbmdlcyB0byBicnVzaDIgYW5kIGhhbmRsZTIgYW5kICNyYW5nZSB0byAjcmFuZ2UyIGFuZCBzZXR4dmFsc1swXSB0byBzZXR4dmFsc1sxXVxuICAgIGZ1bmN0aW9uIGJydXNoZWQyKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBicnVzaDIuZXh0ZW50KClbMF07XG4gICAgICAgIHZhciBzID0gNjsgLy8gc2NhbGluZyBmb3IgdHJpYW5nbGUgc2hhcGVcblxuICAgICAgICBpZiAoZDMuZXZlbnQuc291cmNlRXZlbnQpIHtcbiAgICAgICAgICAgIHZhbHVlID0geC5pbnZlcnQoZDMubW91c2UodGhpcylbMF0pO1xuICAgICAgICAgICAgYnJ1c2gyLmV4dGVudChbdmFsdWUsIHZhbHVlXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgeCBwb3NpdGlvbiBvZiBzbGlkZXIgY2VudGVyXG4gICAgICAgIHZhciB4cG9zID0geCh2YWx1ZSk7XG4gICAgICAgIGlmICh2YWx1ZSA+IGQzLm1heCh4VmFscykpIHsgLy8gZHJhZ2dlZCBwYXN0IG1heFxuICAgICAgICAgICAgeHBvcyA9IHgoZDMubWF4KHhWYWxzKSk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPCBkMy5taW4oeFZhbHMpKSB7IC8vIGRyYWdnZWQgcGFzdCBtaW5cbiAgICAgICAgICAgIHhwb3MgPSB4KGQzLm1pbih4VmFscykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG0gPSArbm9kZS5tZWFuO1xuICAgICAgICAgICAgdmFyIHNkID0gK25vZGUuc2Q7XG4gICAgICAgICAgICB2YXIgelNjb3JlID0gKHZhbHVlIC0gbSkgLyBzZDsgLy8gei1zY29yZVxuICAgICAgICAgICAgdmFyIHpSb3VuZCA9IE1hdGgucm91bmQoelNjb3JlKTsgLy8gbmVhcmVzdCBpbnRlZ2VyIHotc2NvcmVcbiAgICAgICAgICAgIGlmICguMSA+IE1hdGguYWJzKHpSb3VuZCAtIHpTY29yZSkpIC8vIHNuYXAgdG8gaW50ZWdlciB6LXNjb3JlXG4gICAgICAgICAgICAgICAgeHBvcyA9IHgobSArICh6Um91bmQgKiBzZCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JlYXRlIHNsaWRlciBzeW1ib2wgYW5kIHRleHRcbiAgICAgICAgaGFuZGxlMi5hdHRyKFwicG9pbnRzXCIsIF8gPT4gKHhwb3MgLSBzKSArIFwiLFwiICsgcyArIFwiIFwiICsgKHhwb3MgKyBzKSArIFwiLFwiICsgcyArIFwiIFwiICsgeHBvcyArIFwiLFwiICsgKC1zICogMS4zKSk7XG4gICAgICAgIHBsb3Rzdmcuc2VsZWN0KFwidGV4dCNyYW5nZTJcIilcbiAgICAgICAgICAgIC50ZXh0KCgpID0+IFwieDE6IFwiLmNvbmNhdCgoaW52eCh4cG9zKSkudG9QcmVjaXNpb24oNCkpKTtcbiAgICAgICAgbm9kZS5zZXR4dmFsc1sxXSA9IChpbnZ4KHhwb3MpKS50b1ByZWNpc2lvbig0KTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBiYXJzKG5vZGUsIGRpdiwgcHJpdikge1xuICAgIC8vIEhpc3RvZ3JhbSBzcGFjaW5nXG4gICAgdmFyIGJhclBhZGRpbmcgPSAuMDE1OyAvLyBTcGFjZSBiZXR3ZWVuIGJhcnNcbiAgICB2YXIgdG9wU2NhbGUgPSAxLjI7IC8vIE11bHRpcGxpY2F0aXZlIGZhY3RvciB0byBhc3NpZ24gc3BhY2UgYXQgdG9wIHdpdGhpbiBncmFwaCAtIGN1cnJlbnRseSByZW1vdmVkIGZyb20gaW1wbGVtZW50YXRpb25cbiAgICB2YXIgcGxvdFhheGlzID0gdHJ1ZTtcblxuICAgIC8vIERhdGFcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG5vZGUucGxvdHZhbHVlcyk7XG4gICAgdmFyIHlWYWxzID0gbmV3IEFycmF5O1xuICAgIHZhciBjaVVwcGVyVmFscyA9IG5ldyBBcnJheTtcbiAgICB2YXIgY2lMb3dlclZhbHMgPSBuZXcgQXJyYXk7XG4gICAgdmFyIGNpU2l6ZTtcblxuICAgIHZhciB4VmFscyA9IG5ldyBBcnJheTtcbiAgICB2YXIgeVZhbEtleSA9IG5ldyBBcnJheTtcblxuICAgIGlmIChub2RlLm5hdHVyZSA9PSBcIm5vbWluYWxcIikge1xuICAgICAgICB2YXIgeGkgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChub2RlLnBsb3R2YWx1ZXNba2V5c1tpXV0gPT0gMClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHlWYWxzW3hpXSA9IG5vZGUucGxvdHZhbHVlc1trZXlzW2ldXTtcbiAgICAgICAgICAgIHhWYWxzW3hpXSA9IHhpO1xuICAgICAgICAgICAgaWYgKHByaXYpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5wbG90dmFsdWVzQ0kpIHtcbiAgICAgICAgICAgICAgICAgICAgY2lMb3dlclZhbHNbeGldID0gbm9kZS5wbG90VmFsdWVzQ0kubG93ZXJCb3VuZFtrZXlzW2ldXTtcbiAgICAgICAgICAgICAgICAgICAgY2lVcHBlclZhbHNbeGldID0gbm9kZS5wbG90VmFsdWVzQ0kudXBwZXJCb3VuZFtrZXlzW2ldXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2lTaXplID0gY2lVcHBlclZhbHNbeGldIC0gY2lMb3dlclZhbHNbeGldO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgeVZhbEtleS5wdXNoKHtcbiAgICAgICAgICAgICAgICB5OiB5VmFsc1t4aV0sXG4gICAgICAgICAgICAgICAgeDoga2V5c1tpXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB4aSA9IHhpICsgMTtcbiAgICAgICAgfVxuICAgICAgICB5VmFsS2V5LnNvcnQoKGEsIGIpID0+IGIueSAtIGEueSk7IC8vIGFycmF5IG9mIG9iamVjdHMsIGVhY2ggb2JqZWN0IGhhcyB5LCB0aGUgc2FtZSBhcyB5VmFscywgYW5kIHgsIHRoZSBjYXRlZ29yeVxuICAgICAgICB5VmFscy5zb3J0KChhLCBiKSA9PiBiIC0gYSk7IC8vIGFycmF5IG9mIHkgdmFsdWVzLCB0aGUgaGVpZ2h0IG9mIHRoZSBiYXJzXG4gICAgICAgIGNpVXBwZXJWYWxzLnNvcnQoKGEsIGIpID0+IGIueSAtIGEueSk7IC8vID9cbiAgICAgICAgY2lMb3dlclZhbHMuc29ydCgoYSwgYikgPT4gYi55IC0gYS55KTsgLy8gP1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJwbG90dmFsdWVzIGluIGJhcnNcIik7XG4gICAgICAgICAgICB5VmFsc1tpXSA9IG5vZGUucGxvdHZhbHVlc1trZXlzW2ldXTtcbiAgICAgICAgICAgIHhWYWxzW2ldID0gTnVtYmVyKGtleXNbaV0pO1xuICAgICAgICAgICAgaWYgKHByaXYpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5wbG90dmFsdWVzQ0kpIHtcbiAgICAgICAgICAgICAgICAgICAgY2lMb3dlclZhbHNbaV0gPSBub2RlLnBsb3R2YWx1ZXNDSS5sb3dlckJvdW5kW2tleXNbaV1dO1xuICAgICAgICAgICAgICAgICAgICBjaVVwcGVyVmFsc1tpXSA9IG5vZGUucGxvdHZhbHVlc0NJLnVwcGVyQm91bmRba2V5c1tpXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNpU2l6ZSA9IGNpVXBwZXJWYWxzW2ldIC0gY2lMb3dlclZhbHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoKHlWYWxzLmxlbmd0aCA+IDE1ICYgbm9kZS5udW1jaGFyID09IFwibnVtZXJpY1wiKSB8fCAoeVZhbHMubGVuZ3RoID4gNSAmIG5vZGUubnVtY2hhciA9PSBcImNoYXJhY3RlclwiKSlcbiAgICAgICAgcGxvdFhheGlzID0gZmFsc2U7XG4gICAgdmFyIG1heFkgPSBkMy5tYXgoeVZhbHMpOyAvLyBpbiB0aGUgZnV0dXJlLCBzZXQgbWF4WSB0byB0aGUgdmFsdWUgb2YgdGhlIG1heGltdW0gY29uZmlkZW5jZSBsaW1pdFxuICAgIGlmIChwcml2ICYmIG5vZGUucGxvdHZhbHVlc0NJKSBtYXhZID0gZDMubWF4KGNpVXBwZXJWYWxzKTtcbiAgICB2YXIgbWluWCA9IGQzLm1pbih4VmFscyk7XG4gICAgdmFyIG1heFggPSBkMy5tYXgoeFZhbHMpO1xuXG4gICAgbGV0IG15ZGl2O1xuICAgIGlmIChkaXYgPT0gXCJzZXR4XCIpIG15ZGl2ID0gXCIjc2V0eFwiO1xuICAgIGVsc2UgaWYgKGRpdiA9PSBcInZhclN1bW1hcnlcIikgbXlkaXYgPSBcIiN0YWIzXCI7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gYWxlcnQoXCJFcnJvcjogaW5jb3JyZWN0IGRpdiBzZWxlY3RlZCBmb3IgcGxvdHNcIik7XG5cbiAgICB2YXIgdGVtcFdpZHRoID0gZDMuc2VsZWN0KG15ZGl2KS5zdHlsZShcIndpZHRoXCIpXG4gICAgdmFyIHdpZHRoID0gdGVtcFdpZHRoLnN1YnN0cmluZygwLCAodGVtcFdpZHRoLmxlbmd0aCAtIDIpKTtcbiAgICB2YXIgdGVtcEhlaWdodCA9IGQzLnNlbGVjdChteWRpdikuc3R5bGUoXCJoZWlnaHRcIilcbiAgICB2YXIgaGVpZ2h0ID0gdGVtcEhlaWdodC5zdWJzdHJpbmcoMCwgKHRlbXBIZWlnaHQubGVuZ3RoIC0gMikpO1xuXG4gICAgdmFyIG1hcmdpbiA9IHtcbiAgICAgICAgdG9wOiAyMCxcbiAgICAgICAgcmlnaHQ6IDIwLFxuICAgICAgICBib3R0b206IDUzLFxuICAgICAgICBsZWZ0OiA1MFxuICAgIH07XG5cbiAgICAvLyBOZWVkIHRvIGZpeCBhdXRvbWF0aWMgd2lkdGggYW5kIGhlaWdodCBzZXR0aW5ncyBmb3IgbGVmdHBhbmVsICgjdGFiMiwgI3RhYjMpXG4gICAgaWYgKG15ZGl2ID09IFwiI3RhYjNcIikge1xuICAgICAgICB3aWR0aCA9IDAuNyAqICh3aWR0aCAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0KTtcbiAgICAgICAgaGVpZ2h0ID0gMC4zICogKGhlaWdodCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tKTtcbiAgICB9IGVsc2UgaWYgKG15ZGl2ID09IFwiI3NldHhcIikge1xuICAgICAgICB3aWR0aCA9IDIwMDtcbiAgICAgICAgaGVpZ2h0ID0gMTIwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHdpZHRoID0gMC4zNSAqICh3aWR0aCAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0KTtcbiAgICAgICAgaGVpZ2h0ID0gMC4yNSAqIChoZWlnaHQgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbSk7XG4gICAgfTtcblxuICAgIGlmIChwcml2ICYmIG5vZGUuc3RhYmlsaXR5QmluKSB7XG4gICAgICAgIHZhciB4ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgICAgIC5kb21haW4oW21pblggLSAwLjUsIG1heFggKyAxLjVdKVxuICAgICAgICAgICAgLnJhbmdlKFswLCB3aWR0aF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB4ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgICAgIC5kb21haW4oW21pblggLSAwLjUsIG1heFggKyAwLjVdKVxuICAgICAgICAgICAgLnJhbmdlKFswLCB3aWR0aF0pO1xuICAgIH1cblxuICAgIHZhciBpbnZ4ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLnJhbmdlKFttaW5YIC0gMC41LCBtYXhYICsgMC41XSlcbiAgICAgICAgLmRvbWFpbihbMCwgd2lkdGhdKTtcblxuICAgIHZhciB5ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLmRvbWFpbihbMCwgbWF4WV0pXG4gICAgICAgIC5yYW5nZShbMCwgaGVpZ2h0XSk7XG5cbiAgICB2YXIgeEF4aXMgPSBkMy5zdmcuYXhpcygpXG4gICAgICAgIC5zY2FsZSh4KVxuICAgICAgICAudGlja3MoeVZhbHMubGVuZ3RoKVxuICAgICAgICAub3JpZW50KFwiYm90dG9tXCIpO1xuXG4gICAgdmFyIHlBeGlzID0gZDMuc3ZnLmF4aXMoKVxuICAgICAgICAuc2NhbGUoeSlcbiAgICAgICAgLm9yaWVudChcImxlZnRcIik7XG5cbiAgICB2YXIgYnJ1c2ggPSBkMy5zdmcuYnJ1c2goKVxuICAgICAgICAueCh4KVxuICAgICAgICAuZXh0ZW50KCgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBub2RlLnN1YnNldHJhbmdlLmxlbmd0aCA9PSAxID9cbiAgICAgICAgICAgICAgICBbbm9kZS5zdWJzZXRyYW5nZVswXSwgbm9kZS5zdWJzZXRyYW5nZVswXV1cbiAgICAgICAgICAgICAgICA6IG5vZGUuc3Vic2V0cmFuZ2U7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbihcImJydXNoXCIsIGJydXNoZWQpO1xuXG4gICAgdmFyIGJydXNoMiA9IGQzLnN2Zy5icnVzaCgpXG4gICAgICAgIC54KHgpXG4gICAgICAgIC5vbihcImJydXNoXCIsIGJydXNoZWQyKTtcblxuICAgIC8vIENyZWF0ZSBTVkcgZWxlbWVudFxuICAgIC8vIGN1bWJlcnNvbWUgdG8gdHJlYXQgXCJ0YWIzXCIgZGlmZmVyZW50bHksIGJ1dCB3b3JrcyBmb3Igbm93XG4gICAgLy8gdGFiMywgaGFzIGFuIGlzc3VlLCB0aGF0IHVubGVzcyB3aWR0aCBoZWlnaHQgaGFyZGNvZGVkLCB0aGV5IGdyb3cgd2l0aCBlYWNoIGFkZGl0aW9uYWwgZ3JhcGguXG4gICAgaWYgKG15ZGl2ID09IFwiI3RhYjNcIikge1xuICAgICAgICB2YXIgcGxvdHN2ZyA9IGQzLnNlbGVjdChteWRpdilcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoXCJzdmdcIilcbiAgICAgICAgICAgIC5yZW1vdmUoKTtcblxuICAgICAgICB2YXIgcGxvdHN2ZyA9IGQzLnNlbGVjdChteWRpdilcbiAgICAgICAgICAgIC5hcHBlbmQoXCJzdmdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgKCkgPT4gbm9kZS5uYW1lLnRvU3RyaW5nKCkuY29uY2F0KG15ZGl2LnN1YnN0cigxKSkpXG4gICAgICAgICAgICAuc3R5bGUoXCJ3aWR0aFwiLCAzMDApIC8vc2V0dGluZyBoZWlnaHQgdG8gdGhlIGhlaWdodCBvZiAjbWFpbi5sZWZ0XG4gICAgICAgICAgICAuc3R5bGUoXCJoZWlnaHRcIiwgMjAwKVxuICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgbWFyZ2luLmxlZnQgKyBcIixcIiArIG1hcmdpbi50b3AgKyBcIilcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHBsb3RzdmcgPSBkMy5zZWxlY3QobXlkaXYpXG4gICAgICAgICAgICAuYXBwZW5kKFwic3ZnXCIpXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBteW5hbWUgPSBub2RlLm5hbWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBteW5hbWUgPSBteW5hbWUucmVwbGFjZSgvXFwofFxcKS9nLCBcIlwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbXluYW1lLmNvbmNhdChcIl9cIiwgbXlkaXYuc3Vic3RyKDEpLCBcIl9cIiwgbm9kZS5pZCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnN0eWxlKFwid2lkdGhcIiwgd2lkdGggKyBtYXJnaW4ubGVmdCArIG1hcmdpbi5yaWdodCkgLy9zZXR0aW5nIGhlaWdodCB0byB0aGUgaGVpZ2h0IG9mICNtYWluLmxlZnRcbiAgICAgICAgICAgIC5zdHlsZShcImhlaWdodFwiLCBoZWlnaHQgKyBtYXJnaW4udG9wICsgbWFyZ2luLmJvdHRvbSlcbiAgICAgICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIG1hcmdpbi5sZWZ0ICsgXCIsXCIgKyBtYXJnaW4udG9wICsgXCIpXCIpO1xuICAgIH07XG5cbiAgICB2YXIgcmVjdFdpZHRoID0geChtaW5YICsgMC41IC0gMiAqIGJhclBhZGRpbmcpOyAvL3RoZSBcIndpZHRoXCIgaXMgdGhlIGNvb3JkaW5hdGUgb2YgdGhlIGVuZCBvZiB0aGUgZmlyc3QgYmFyXG5cbiAgICBwbG90c3ZnLnNlbGVjdEFsbChcInJlY3RcIilcbiAgICAgICAgLmRhdGEoeVZhbHMpXG4gICAgICAgIC5lbnRlcigpXG4gICAgICAgIC5hcHBlbmQoXCJyZWN0XCIpXG4gICAgICAgIC5hdHRyKFwieFwiLCAoZCwgaSkgPT4geCh4VmFsc1tpXSAtIDAuNSArIGJhclBhZGRpbmcpKVxuICAgICAgICAuYXR0cihcInlcIiwgZCA9PiB5KG1heFkgLSBkKSlcbiAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCByZWN0V2lkdGgpXG4gICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIHkpXG4gICAgICAgIC5hdHRyKFwiZmlsbFwiLCBcIiMxZjc3YjRcIik7XG5cbiAgICAvLyBkcmF3IGVycm9yIGJhcnMsIHRocmVzaG9sZCBsaW5lIGFuZCBleHRyYSBiaW5cbiAgICBpZiAocHJpdikge1xuICAgICAgICBpZiAoeVZhbHMubGVuZ3RoIDw9IDIwKSB7XG4gICAgICAgICAgICBwbG90c3ZnLnNlbGVjdEFsbChcImxpbmVcIilcbiAgICAgICAgICAgICAgICAuZGF0YShjaVVwcGVyVmFscylcbiAgICAgICAgICAgICAgICAuZW50ZXIoKVxuICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJsaW5lXCIpXG4gICAgICAgICAgICAgICAgLnN0eWxlKFwic3Ryb2tlXCIsIFwiYmxhY2tcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcIngxXCIsIGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHgoeFZhbHNbaV0gLSAwLjUgKyBiYXJQYWRkaW5nKSArIHJlY3RXaWR0aCAvIDJcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICBcdC5hdHRyKFwieTFcIiwgZCA9PiB5KG1heFkgLSBkKSlcbiAgICAgICAgICAgICAgICAuYXR0cihcIngyXCIsIGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHgoeFZhbHNbaV0gLSAwLjUgKyBiYXJQYWRkaW5nKSArIHJlY3RXaWR0aCAvIDJcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieTJcIiwgZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB5MiA9IHkobWF4WSAtIGQgKyBjaVNpemUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geTIgPj0geShtYXhZKSA/IHkobWF4WSkgOiB5MjtcbiAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vZHJhdyB0b3AgdGlja3Mgb24gZXJyb3IgYmFyc1xuICAgICAgICAgICAgLy9uZWVkIHRvIGZpeCB0aGUgaGVpZ2h0IG9mIHRoZSBncmFwaHMgLSB0aGUgdG9wcyBvZiBlcnJvciBiYXJzIGFyZSBnZXR0aW5nIGN1dCBvZmZcbiAgICAgICAgICAgIHBsb3Rzdmcuc2VsZWN0QWxsKFwiLnRvcFRpY2tcIilcbiAgICAgICAgICAgICAgICAuZGF0YShjaVVwcGVyVmFscylcbiAgICAgICAgICAgICAgICAuZW50ZXIoKVxuICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJsaW5lXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInRvcFRpY2tcIilcbiAgICAgICAgICAgICAgICAuc3R5bGUoXCJzdHJva2VcIiwgXCJibGFja1wiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieDFcIiwgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoeVZhbHMubGVuZ3RoID4gMjApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB4KHhWYWxzW2ldIC0gMC41ICsgYmFyUGFkZGluZykgLy9tYWtlIHRpY2sgYmlnZ2VyIHRvIGluY3JlYXNlIHZpc2liaWxpdHlcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB4KHhWYWxzW2ldIC0gMC41ICsgYmFyUGFkZGluZykgKyAwLjQgKiByZWN0V2lkdGhcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ5MVwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB5KG1heFkgLSBkKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieDJcIiwgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoeVZhbHMubGVuZ3RoID4gMjApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB4KHhWYWxzW2ldIC0gMC41ICsgYmFyUGFkZGluZykgKyByZWN0V2lkdGggLy9tYWtlIHRpY2sgYmlnZ2VyIHRvIGluY3JlYXNlIHZpc2liaWxpdHlcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB4KHhWYWxzW2ldIC0gMC41ICsgYmFyUGFkZGluZykgKyAwLjYgKiByZWN0V2lkdGhcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ5MlwiLCBkID0+IHkobWF4WSAtIGQpKTtcblxuICAgICAgICAgICAgLy8gZHJhdyBib3R0b20gdGlja3Mgb2YgZXJyb3IgYmFyc1xuICAgICAgICAgICAgcGxvdHN2Zy5zZWxlY3RBbGwoXCIuYm90dG9tVGlja1wiKVxuICAgICAgICAgICAgICAgIC5kYXRhKGNpTG93ZXJWYWxzKVxuICAgICAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAgICAgLmFwcGVuZChcImxpbmVcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiYm90dG9tVGlja1wiKVxuICAgICAgICAgICAgICAgIC5zdHlsZShcInN0cm9rZVwiLCBcImJsYWNrXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ4MVwiLCBmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh5VmFscy5sZW5ndGggPiAyMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHgoeFZhbHNbaV0gLSAwLjUgKyBiYXJQYWRkaW5nKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHgoeFZhbHNbaV0gLSAwLjUgKyBiYXJQYWRkaW5nKSArIDAuNCAqIHJlY3RXaWR0aFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInkxXCIsIGQgPT4geShtYXhZIC0gZCkpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ4MlwiLCBmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh5VmFscy5sZW5ndGggPiAyMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHgoeFZhbHNbaV0gLSAwLjUgKyBiYXJQYWRkaW5nKSArIHJlY3RXaWR0aFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHgoeFZhbHNbaV0gLSAwLjUgKyBiYXJQYWRkaW5nKSArIDAuNiAqIHJlY3RXaWR0aFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInkyXCIsIGQgPT4geShtYXhZIC0gZCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGxvdHN2Zy5zZWxlY3RBbGwoXCIuZGVuc2VFcnJvclwiKVxuICAgICAgICAgICAgICAgIC5kYXRhKHlWYWxzKVxuICAgICAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAgICAgLmFwcGVuZChcInJlY3RcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiZGVuc2VFcnJvclwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieFwiLCAoZCwgaSkgPT4geCh4VmFsc1tpXSAtIDAuNSArIGJhclBhZGRpbmcpKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieVwiLCBkID0+IHkobWF4WSAtIGQpIC0gLjEgKiB5KGQpKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgcmVjdFdpZHRoKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGQgPT4gKHkobWF4WSAtIGQpICsgLjEgKiB5KGQpKSAtICh5KG1heFkgLSBkKSAtIC4xICogeShkKSkpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJmaWxsXCIsIFwic2lsdmVyXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9pZiBzdGF0ZW1lbnQgZm9yIHN0YWJpbGl0eSBoaXN0b2dyYW1zXG4gICAgICAgIC8vZXh0cmEgc3RhYmlsaXR5IGJpblxuICAgICAgICBpZiAobm9kZS5zdGFiaWxpdHlCaW4pIHtcbiAgICAgICAgICAgIHBsb3RzdmcuYXBwZW5kKFwicmVjdFwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieFwiLCB4KG1heFggKyAwLjUgLSBiYXJQYWRkaW5nKSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInlcIiwgeShtYXhZKSAtIG5vZGUuc3RhYmlsaXR5QmluKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgcmVjdFdpZHRoKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIG5vZGUuc3RhYmlsaXR5QmluKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiZmlsbFwiLCBcInNpbHZlclwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vdGhyZXNob2xkIGxpbmVcbiAgICAgICAgaWYgKG5vZGUudGhyZXNob2xkKSB7XG4gICAgICAgICAgICBwbG90c3ZnLmFwcGVuZChcImxpbmVcIilcbiAgICAgICAgICAgICAgICAuc3R5bGUoXCJzdHJva2VcIiwgXCJibGFja1wiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieDFcIiwgeChtaW5YIC0gMC41ICsgYmFyUGFkZGluZykpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ5MVwiLCB5KG1heFkpIC0gbm9kZS50aHJlc2hvbGQpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ4MlwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJzdGFiaWxpdHlCaW5cIik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKG5vZGUuc3RhYmlsaXR5QmluKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuc3RhYmlsaXR5QmluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geChtYXhYICsgMC41IC0gYmFyUGFkZGluZykgKyByZWN0V2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geChtYXhYICsgMC41IC0gYmFyUGFkZGluZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieTJcIiwgeShtYXhZKSAtIG5vZGUudGhyZXNob2xkKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBsb3RYYXhpcykge1xuICAgICAgICBwbG90c3ZnLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJ4IGF4aXNcIilcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsXCIgKyBoZWlnaHQgKyBcIilcIilcbiAgICAgICAgICAgIC5jYWxsKHhBeGlzKTtcbiAgICB9XG5cbiAgICBwbG90c3ZnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgLmF0dHIoXCJ4XCIsICh3aWR0aCAvIDIpKVxuICAgICAgICAuYXR0cihcInlcIiwgMCAtIChtYXJnaW4udG9wIC8gMikpXG4gICAgICAgIC5hdHRyKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIilcbiAgICAgICAgLnN0eWxlKFwiZm9udC1zaXplXCIsIFwiMTJweFwiKVxuICAgICAgICAudGV4dChub2RlLm5hbWUpO1xuXG4gICAgaWYgKG15ZGl2ID09IFwiI3NldHhcIikge1xuICAgICAgICBwbG90c3ZnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgXCJyYW5nZVwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIDI1KVxuICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIGhlaWdodCArIDQwKVxuICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubmF0dXJlID09PSBcIm5vbWluYWxcIikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IE1hdGgucm91bmQoeVZhbEtleS5sZW5ndGggLyAyKSAtIDE7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoXCJ4OiBcIiArIHlWYWxLZXlbdF0ueCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcIng6IFwiLmNvbmNhdCgoK25vZGUubWVhbikudG9QcmVjaXNpb24oNCkudG9TdHJpbmcoKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHBsb3RzdmcuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBcInJhbmdlMlwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIDI1KVxuICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIGhlaWdodCArIDUwKVxuICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubmF0dXJlID09PSBcIm5vbWluYWxcIikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IE1hdGgucm91bmQoeVZhbEtleS5sZW5ndGggLyAyKSAtIDE7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoXCJ4MTogXCIgKyB5VmFsS2V5W3RdLngpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoXCJ4MTogXCIuY29uY2F0KCgrbm9kZS5tZWFuKS50b1ByZWNpc2lvbig0KS50b1N0cmluZygpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gY3JlYXRlIHRpY2sgbWFya3MgYXQgYWxsIHpzY29yZXMgaW4gdGhlIGJvdW5kcyBvZiB0aGUgZGF0YVxuICAgICAgICB2YXIgbGluZUZ1bmN0aW9uID0gZDMuc3ZnLmxpbmUoKVxuICAgICAgICAgICAgLngoZCA9PiBkLngpXG4gICAgICAgICAgICAueShkID0+IGQueSlcbiAgICAgICAgICAgIC5pbnRlcnBvbGF0ZShcImxpbmVhclwiKTtcblxuICAgICAgICB2YXIgY29sU2VxID0gW1wiI0EyQ0Q1QVwiLCBcIm9yYW5nZVwiLCBcInJlZFwiXTsgLy8gd2lsbCBjeWNsZSB0aHJvdWdoIGNvbG9yIHNlcXVlbmNlLCBhbmQgdGhlbiByZXBlYXQgbGFzdCBjb2xvclxuICAgICAgICB2YXIgbGluZURhdGEgPSBuZXcgQXJyYXk7XG5cbiAgICAgICAgdmFyIHpMb3dlciA9IC0xICogKG1pblggLSBub2RlLm1lYW4pIC8gbm9kZS5zZDsgLy8genNjb3JlIG9mIGxvd2VyIGJvdW5kXG4gICAgICAgIHZhciB6VXBwZXIgPSAobWF4WCAtIG5vZGUubWVhbikgLyBub2RlLnNkOyAvLyB6c2NvcmUgb2YgdXBwZXIgYm91bmRcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHpVcHBlcjsgaSsrKSB7XG4gICAgICAgICAgICBsaW5lRGF0YSA9IFt7XG4gICAgICAgICAgICAgICAgXCJ4XCI6IHgoK25vZGUubWVhbiArIGkgKiBub2RlLnNkKSxcbiAgICAgICAgICAgICAgICBcInlcIjogaGVpZ2h0ICogLjdcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBcInhcIjogeCgrbm9kZS5tZWFuICsgaSAqIG5vZGUuc2QpLFxuICAgICAgICAgICAgICAgIFwieVwiOiBoZWlnaHQgKiAuOVxuICAgICAgICAgICAgfV07XG4gICAgICAgICAgICBwbG90c3ZnLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImRcIiwgbGluZUZ1bmN0aW9uKFtsaW5lRGF0YVswXSwgbGluZURhdGFbMV1dKSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInN0cm9rZVwiLCBjb2xTZXFbZDMubWluKFtpLCBjb2xTZXEubGVuZ3RoIC0gMV0pXSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInN0cm9rZS13aWR0aFwiLCAxLjUpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJmaWxsXCIsIFwibm9uZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgekxvd2VyOyBpKyspIHtcbiAgICAgICAgICAgIGxpbmVEYXRhID0gW3tcbiAgICAgICAgICAgICAgICBcInhcIjogeCgrbm9kZS5tZWFuIC0gaSAqIG5vZGUuc2QpLFxuICAgICAgICAgICAgICAgIFwieVwiOiBoZWlnaHQgKiAuN1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIFwieFwiOiB4KCtub2RlLm1lYW4gLSBpICogbm9kZS5zZCksXG4gICAgICAgICAgICAgICAgXCJ5XCI6IGhlaWdodCAqIC45XG4gICAgICAgICAgICB9XTtcbiAgICAgICAgICAgIHBsb3RzdmcuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiZFwiLCBsaW5lRnVuY3Rpb24oW2xpbmVEYXRhWzBdLCBsaW5lRGF0YVsxXV0pKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwic3Ryb2tlXCIsIGNvbFNlcVtkMy5taW4oW2ksIGNvbFNlcS5sZW5ndGggLSAxXSldKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwic3Ryb2tlLXdpZHRoXCIsIDEuNSlcbiAgICAgICAgICAgICAgICAuYXR0cihcImZpbGxcIiwgXCJub25lXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IGQzLm1pbih4VmFscyk7IGkgPD0gZDMubWF4KHhWYWxzKTsgaSsrKSB7XG4gICAgICAgICAgICBsaW5lRGF0YSA9IFt7XG4gICAgICAgICAgICAgICAgXCJ4XCI6IHgoaSksXG4gICAgICAgICAgICAgICAgXCJ5XCI6IGhlaWdodCAqIC43NVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIFwieFwiOiB4KGkpLFxuICAgICAgICAgICAgICAgIFwieVwiOiBoZWlnaHQgKiAuODVcbiAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgcGxvdHN2Zy5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJkXCIsIGxpbmVGdW5jdGlvbihbbGluZURhdGFbMF0sIGxpbmVEYXRhWzFdXSkpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJzdHJva2VcIiwgXCJibGFja1wiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwic3Ryb2tlLXdpZHRoXCIsIDEpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJmaWxsXCIsIFwibm9uZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGluaXRpYWxpemUgc2xpZGVyIGNvbXBvbmVudHNcbiAgICAgICAgdmFyIHNsaWRlQm94ID0gcGxvdHN2Zy5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwieCBheGlzXCIpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLFwiICsgaGVpZ2h0ICogLjggKyBcIilcIilcbiAgICAgICAgICAgIC5jYWxsKGQzLnN2Zy5heGlzKClcbiAgICAgICAgICAgICAgICAgIC5zY2FsZSh4KVxuICAgICAgICAgICAgICAgICAgLnRpY2tzKDApXG4gICAgICAgICAgICAgICAgICAub3JpZW50KFwiYm90dG9tXCIpKTtcblxuICAgICAgICB2YXIgc2xpZGVyID0gcGxvdHN2Zy5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwic2xpZGVyXCIpXG4gICAgICAgICAgICAuY2FsbChicnVzaCk7XG4gICAgICAgIHZhciBzbGlkZXIyID0gcGxvdHN2Zy5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwic2xpZGVyXCIpXG4gICAgICAgICAgICAuY2FsbChicnVzaDIpO1xuXG4gICAgICAgIGxldCBwb2ludHMgPSBpID0+IGQgPT4ge1xuICAgICAgICAgICAgbGV0IHhubSwgcyA9IDY7XG4gICAgICAgICAgICBpZiAobm9kZS5zZXR4dmFsc1tpXSA9PSAnJykge1xuICAgICAgICAgICAgICAgIC8vIGlmIG5vbWluYWwsIHVzZSB0aGUgbWVkaWFuIGZyZXF1ZW5jeSBhcyB0aGUgcG9zaXRpb24gZm9yIHRoZSBzZXR4IHNsaWRlclxuICAgICAgICAgICAgICAgIHhubSA9IG5vZGUubmF0dXJlID09ICdub21pbmFsJyA/IHgoTWF0aC5yb3VuZCh4VmFscy5sZW5ndGggLyAyKSAtIDEpIDogeChub2RlLm1lYW4pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB4bm0gPSB4KG5vZGUuc2V0eHZhbHNbaV0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBgJHt4bm0gLSBzfSwkey1zfSAke3hubSArIHN9LCR7LXN9ICR7eG5tfSwke3MgKiAxLjN9YDtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGhhbmRsZSA9IHNsaWRlci5hcHBlbmQoXCJwb2x5Z29uXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiaGFuZGxlXCIpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLFwiICsgaGVpZ2h0ICogLjcgKyBcIilcIilcbiAgICAgICAgICAgIC5hdHRyKFwicG9pbnRzXCIsIHBvaW50cygwKSk7XG4gICAgICAgIHZhciBoYW5kbGUyID0gc2xpZGVyMi5hcHBlbmQoXCJwb2x5Z29uXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiaGFuZGxlXCIpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLFwiICsgaGVpZ2h0ICogLjkgKyBcIilcIilcbiAgICAgICAgICAgIC5hdHRyKFwicG9pbnRzXCIsIHBvaW50cygxKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHdvU0YoeCkge1xuICAgICAgICB2YXIgdHNmID0gZDMuZm9ybWF0KFwiLjJyXCIpOyAvLyBmb3JtYXQgdG8gdHdvIHNpZ25pZmljYW50IGZpZ3VyZXMgYWZ0ZXIgdGhlIGRlY2ltYWwgcGxhY2VcbiAgICAgICAgcmV0dXJuIHRzZih4KS5yZXBsYWNlKC8wKyQvLCBcIlwiKS5yZXBsYWNlKC9cXC4kLywgXCJcIik7IC8vIHRyaW0gdHJhaWxpbmcgemVyb3MgYWZ0ZXIgYSBwZXJpb2QsIGFuZCBhbnkgb3JwaGFuZWQgcGVyaW9kXG4gICAgfVxuXG4gICAgLy8gYnJ1c2hpbmcgZnVuY3Rpb25zXG4gICAgZnVuY3Rpb24gYnJ1c2hlZCgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYnJ1c2guZXh0ZW50KClbMF07XG4gICAgICAgIHZhciBzID0gNjtcblxuICAgICAgICBpZiAoZDMuZXZlbnQuc291cmNlRXZlbnQpIHtcbiAgICAgICAgICAgIHZhbHVlID0geC5pbnZlcnQoZDMubW91c2UodGhpcylbMF0pO1xuICAgICAgICAgICAgYnJ1c2guZXh0ZW50KFt2YWx1ZSwgdmFsdWVdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldCB4IHBvc2l0aW9uIG9mIHNsaWRlciBjZW50ZXJcbiAgICAgICAgdmFyIHhwb3MgPSB4KHZhbHVlKTtcbiAgICAgICAgaWYgKHZhbHVlID4gbWF4WCkgeyAvLyBkcmFnZ2VkIHBhc3QgbWF4XG4gICAgICAgICAgICB4cG9zID0geChtYXhYKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA8IG1pblgpIHsgLy8gZHJhZ2dlZCBwYXN0IG1pblxuICAgICAgICAgICAgeHBvcyA9IHgobWluWCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbSA9ICtub2RlLm1lYW47XG4gICAgICAgICAgICB2YXIgc2QgPSArbm9kZS5zZDtcbiAgICAgICAgICAgIHZhciB6U2NvcmUgPSAodmFsdWUgLSBtKSAvIHNkOyAvLyB6LXNjb3JlXG4gICAgICAgICAgICB2YXIgelJvdW5kID0gTWF0aC5yb3VuZCh6U2NvcmUpOyAvLyBuZWFyZXN0IGludGVnZXIgei1zY29yZVxuICAgICAgICAgICAgaWYgKC4xID4gTWF0aC5hYnMoTWF0aC5yb3VuZCh2YWx1ZSkgLSB2YWx1ZSkpIHsgLy8gc25hcCB0byBpbnRlZ2VyXG4gICAgICAgICAgICAgICAgeHBvcyA9IHgoTWF0aC5yb3VuZCh2YWx1ZSkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICguMSA+IE1hdGguYWJzKHpSb3VuZCAtIHpTY29yZSkpIHsgLy8gc25hcCB0byBpbnRlZ2VyIHotc2NvcmVcbiAgICAgICAgICAgICAgICB4cG9zID0geChtICsgKHpSb3VuZCAqIHNkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjcmVhdGUgc2xpZGVyIHN5bWJvbCBhbmQgdGV4dFxuICAgICAgICBoYW5kbGUuYXR0cihcInBvaW50c1wiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICByZXR1cm4gKHhwb3MgLSBzKSArIFwiLFwiICsgKC1zKSArIFwiIFwiICsgKHhwb3MgKyBzKSArIFwiLFwiICsgKC1zKSArIFwiIFwiICsgeHBvcyArIFwiLFwiICsgKHMgKiAxLjMpO1xuICAgICAgICB9KTtcbiAgICAgICAgcGxvdHN2Zy5zZWxlY3QoXCJ0ZXh0I3JhbmdlXCIpXG4gICAgICAgICAgICAudGV4dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5uYXR1cmUgPT09IFwibm9taW5hbFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoXCJ4OiBcIiArIHlWYWxLZXlbTWF0aC5yb3VuZChpbnZ4KHhwb3MpKV0ueCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcIng6IFwiLmNvbmNhdCgrKGludngoeHBvcykpLnRvUHJlY2lzaW9uKDQpLnRvU3RyaW5nKCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgbm9kZS5zZXR4dmFsc1sxXSA9ICsoaW52eCh4cG9zKSkudG9QcmVjaXNpb24oNCk7XG4gICAgfVxuXG4gICAgLy8gY2VydGFpbmx5IGEgbW9yZSBjbGV2ZXIgd2F5IHRvIGRvIHRoaXMsIGJ1dCBmb3Igbm93IGl0J3MgYmFzaWNhbGx5IGNvcGllZCB3aXRoIGJydXNoIGFuZCBoYW5kbGUgY2hhbmdlcyB0byBicnVzaDIgYW5kIGhhbmRsZTIgYW5kICNyYW5nZSB0byAjcmFuZ2UyIGFuZCBzZXR4dmFsc1swXSB0byBzZXR4dmFsc1sxXVxuICAgIGZ1bmN0aW9uIGJydXNoZWQyKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBicnVzaDIuZXh0ZW50KClbMF07XG4gICAgICAgIHZhciBzID0gNjsgLy8gc2NhbGluZyBmb3IgdHJpYW5nbGUgc2hhcGVcblxuICAgICAgICBpZiAoZDMuZXZlbnQuc291cmNlRXZlbnQpIHtcbiAgICAgICAgICAgIHZhbHVlID0geC5pbnZlcnQoZDMubW91c2UodGhpcylbMF0pO1xuICAgICAgICAgICAgYnJ1c2gyLmV4dGVudChbdmFsdWUsIHZhbHVlXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgeCBwb3NpdGlvbiBvZiBzbGlkZXIgY2VudGVyXG4gICAgICAgIHZhciB4cG9zID0geCh2YWx1ZSk7XG4gICAgICAgIGlmICh2YWx1ZSA+IG1heFgpIHsgLy8gZHJhZ2dlZCBwYXN0IG1heFxuICAgICAgICAgICAgeHBvcyA9IHgobWF4WCk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPCBtaW5YKSB7IC8vIGRyYWdnZWQgcGFzdCBtaW5cbiAgICAgICAgICAgIHhwb3MgPSB4KG1pblgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG0gPSArbm9kZS5tZWFuO1xuICAgICAgICAgICAgdmFyIHNkID0gK25vZGUuc2Q7XG4gICAgICAgICAgICB2YXIgelNjb3JlID0gKHZhbHVlIC0gbSkgLyBzZDsgLy8gei1zY29yZVxuICAgICAgICAgICAgdmFyIHpSb3VuZCA9IE1hdGgucm91bmQoelNjb3JlKTsgLy8gbmVhcmVzdCBpbnRlZ2VyIHotc2NvcmVcbiAgICAgICAgICAgIGlmICguMSA+IE1hdGguYWJzKE1hdGgucm91bmQodmFsdWUpIC0gdmFsdWUpKSB7IC8vIHNuYXAgdG8gaW50ZWdlclxuICAgICAgICAgICAgICAgIHhwb3MgPSB4KE1hdGgucm91bmQodmFsdWUpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoLjEgPiBNYXRoLmFicyh6Um91bmQgLSB6U2NvcmUpKSB7IC8vIHNuYXAgdG8gaW50ZWdlciB6LXNjb3JlXG4gICAgICAgICAgICAgICAgeHBvcyA9IHgobSArICh6Um91bmQgKiBzZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JlYXRlIHNsaWRlciBzeW1ib2wgYW5kIHRleHRcbiAgICAgICAgaGFuZGxlMi5hdHRyKFwicG9pbnRzXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHJldHVybiAoeHBvcyAtIHMpICsgXCIsXCIgKyBzICsgXCIgXCIgKyAoeHBvcyArIHMpICsgXCIsXCIgKyBzICsgXCIgXCIgKyB4cG9zICsgXCIsXCIgKyAoLXMgKiAxLjMpO1xuICAgICAgICB9KTtcbiAgICAgICAgcGxvdHN2Zy5zZWxlY3QoXCJ0ZXh0I3JhbmdlMlwiKVxuICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubmF0dXJlID09PSBcIm5vbWluYWxcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFwieDE6IFwiICsgeVZhbEtleVtNYXRoLnJvdW5kKGludngoeHBvcykpXS54KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFwieDE6IFwiLmNvbmNhdCgrKGludngoeHBvcykpLnRvUHJlY2lzaW9uKDQpLnRvU3RyaW5nKCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgbm9kZS5zZXR4dmFsc1sxXSA9ICsoaW52eCh4cG9zKSkudG9QcmVjaXNpb24oNCk7XG4gICAgfVxufVxuXG4vLyBkcmF3cyBiYXJwbG90cyBpbiBzdWJzZXQgdGFiXG5leHBvcnQgZnVuY3Rpb24gYmFyc1N1YnNldChub2RlKSB7XG4gICAgLy8gaWYgdW50b3VjaGVkLCBzZXQgbm9kZS5zdWJzZXRyYW5nZSB0byBhbiBlbXB0eSBhcnJheSwgbWVhbmluZyBhbGwgdmFsdWVzIHNlbGVjdGVkIGJ5IGRlZmF1bHRcbiAgICBpZiAobm9kZS5zdWJzZXRyYW5nZVswXSA9PSBcIlwiICYgbm9kZS5zdWJzZXRyYW5nZVsxXSA9PSBcIlwiKSB7XG4gICAgICAgIG5vZGUuc3Vic2V0cmFuZ2UgPSBbXTtcbiAgICB9XG5cbiAgICAvLyBIaXN0b2dyYW0gc3BhY2luZ1xuICAgIHZhciBiYXJQYWRkaW5nID0gLjAxNTsgLy8gU3BhY2UgYmV0d2VlbiBiYXJzXG4gICAgdmFyIHRvcFNjYWxlID0gMS4yOyAvLyBNdWx0aXBsaWNhdGl2ZSBmYWN0b3IgdG8gYXNzaWduIHNwYWNlIGF0IHRvcCB3aXRoaW4gZ3JhcGggLSBjdXJyZW50bHkgcmVtb3ZlZCBmcm9tIGltcGxlbWVudGF0aW9uXG4gICAgdmFyIHBsb3RYYXhpcyA9IHRydWU7XG5cbiAgICAvLyBWYXJpYWJsZSBuYW1lXG4gICAgdmFyIG15bmFtZSA9IG5vZGUubmFtZS50b1N0cmluZygpO1xuICAgIG15bmFtZSA9IG15bmFtZS5yZXBsYWNlKC9cXCh8XFwpL2csIFwiXCIpO1xuXG4gICAgLy8gRGF0YVxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMobm9kZS5wbG90dmFsdWVzKTtcbiAgICB2YXIgeVZhbHMgPSBuZXcgQXJyYXk7XG4gICAgdmFyIHhWYWxzID0gbmV3IEFycmF5O1xuICAgIHZhciB5VmFsS2V5ID0gbmV3IEFycmF5O1xuXG4gICAgdmFyIHhpID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKG5vZGUucGxvdHZhbHVlc1trZXlzW2ldXSA9PSAwKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIHlWYWxzW3hpXSA9IG5vZGUucGxvdHZhbHVlc1trZXlzW2ldXTtcbiAgICAgICAgeFZhbHNbeGldID0geGk7XG4gICAgICAgIHlWYWxLZXkucHVzaCh7XG4gICAgICAgICAgICB5OiB5VmFsc1t4aV0sXG4gICAgICAgICAgICB4OiBrZXlzW2ldXG4gICAgICAgIH0pO1xuICAgICAgICB4aSA9IHhpICsgMTtcbiAgICB9XG4gICAgaWYgKG5vZGUubmF0dXJlID09PSBcIm5vbWluYWxcIikgeyAvLyBpZiBub21pbmFsLCBvcmRlcnMgYmFycyBsZWZ0IHRvIHJpZ2h0LCBoaWdoZXN0IGZyZXF1ZW5jeSB0byBsb3dlc3RcbiAgICAgICAgeVZhbEtleS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBiLnkgLSBhLnlcbiAgICAgICAgfSk7IC8vIGFycmF5IG9mIG9iamVjdHMsIGVhY2ggb2JqZWN0IGhhcyB5LCB0aGUgc2FtZSBhcyB5VmFscywgYW5kIHgsIHRoZSBjYXRlZ29yeVxuICAgICAgICB5VmFscy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBiIC0gYVxuICAgICAgICB9KTsgLy8gYXJyYXkgb2YgeSB2YWx1ZXMsIHRoZSBoZWlnaHQgb2YgdGhlIGJhcnNcbiAgICB9XG5cbiAgICBwbG90WGF4aXMgPSBmYWxzZTtcblxuICAgIHZhciBtYXhZID0gZDMubWF4KHlWYWxzKTtcbiAgICB2YXIgbWluWCA9IGQzLm1pbih4VmFscyk7XG4gICAgdmFyIG1heFggPSBkMy5tYXgoeFZhbHMpO1xuICAgIHZhciBnbmFtZSA9IFtcInN1YnNldHllc1wiLCBcInN1YnNldG5vXCJdO1xuXG4gICAgdmFyIHlWYWxzMiA9IFtdO1xuICAgIHZhciB5VmFsczEgPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgeVZhbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgeVZhbHMxLnB1c2goe1xuICAgICAgICAgICAgeTA6IG1heFkgLSB5VmFsc1tpXSxcbiAgICAgICAgICAgIHkxOiB5VmFsc1tpXSxcbiAgICAgICAgICAgIGNvbDogZDNDb2xvclxuICAgICAgICB9KTtcbiAgICAgICAgeVZhbHMyLnB1c2goe1xuICAgICAgICAgICAgeTA6IDAsXG4gICAgICAgICAgICB5MTogbWF4WSAtIHlWYWxzW2ldLFxuICAgICAgICAgICAgY29sOiBcInRyYW5zcGFyZW50XCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBmcmVxcyA9IFt5VmFsczEsIHlWYWxzMl07XG5cbiAgICAvLyB5MCBpcyB0aGUgc3RhcnRpbmcgcG9pbnRcbiAgICAvLyB5MSBpcyB0aGUgbGVuZ3RoIG9mIHRoZSBiYXJcblxuICAgIHZhciBteWRpdiA9IFwiI3RhYjJcIjtcbiAgICB2YXIgd2lkdGggPSAyMDA7XG4gICAgdmFyIGhlaWdodCA9IDEyMDtcbiAgICB2YXIgbWFyZ2luID0ge1xuICAgICAgICB0b3A6IDIwLFxuICAgICAgICByaWdodDogMjAsXG4gICAgICAgIGJvdHRvbTogNTMsXG4gICAgICAgIGxlZnQ6IDUwXG4gICAgfTtcblxuICAgIHZhciB4ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLmRvbWFpbihbbWluWCAtIDAuNSwgbWF4WCArIDAuNV0pXG4gICAgICAgIC5yYW5nZShbMCwgd2lkdGhdKTtcblxuICAgIHZhciBpbnZ4ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLnJhbmdlKFttaW5YIC0gMC41LCBtYXhYICsgMC41XSlcbiAgICAgICAgLmRvbWFpbihbMCwgd2lkdGhdKTtcblxuICAgIHZhciB5ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLmRvbWFpbihbMCwgbWF4WV0pXG4gICAgICAgIC5yYW5nZShbMCwgaGVpZ2h0XSk7XG5cbiAgICB2YXIgeEF4aXMgPSBkMy5zdmcuYXhpcygpXG4gICAgICAgIC5zY2FsZSh4KVxuICAgICAgICAudGlja3MoeVZhbHMubGVuZ3RoKVxuICAgICAgICAub3JpZW50KFwiYm90dG9tXCIpO1xuXG4gICAgdmFyIHlBeGlzID0gZDMuc3ZnLmF4aXMoKVxuICAgICAgICAuc2NhbGUoeSlcbiAgICAgICAgLm9yaWVudChcImxlZnRcIik7XG5cbiAgICAvL0NyZWF0ZSBTVkcgZWxlbWVudFxuICAgIHZhciBwbG90c3ZnID0gZDMuc2VsZWN0KG15ZGl2KVxuICAgICAgICAuYXBwZW5kKFwic3ZnXCIpXG4gICAgICAgIC5hdHRyKFwiaWRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gbXluYW1lLmNvbmNhdChcIl9cIiwgbXlkaXYuc3Vic3RyKDEpLCBcIl9cIiwgbm9kZS5pZCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5zdHlsZShcIndpZHRoXCIsIHdpZHRoICsgbWFyZ2luLmxlZnQgKyBtYXJnaW4ucmlnaHQpIC8vc2V0dGluZyBoZWlnaHQgdG8gdGhlIGhlaWdodCBvZiAjbWFpbi5sZWZ0XG4gICAgICAgIC5zdHlsZShcImhlaWdodFwiLCBoZWlnaHQgKyBtYXJnaW4udG9wICsgbWFyZ2luLmJvdHRvbSlcbiAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBtYXJnaW4ubGVmdCArIFwiLFwiICsgbWFyZ2luLnRvcCArIFwiKVwiKTtcblxuICAgIHZhciBmcmVxID0gcGxvdHN2Zy5zZWxlY3RBbGwoXCJnLmZyZXFcIilcbiAgICAgICAgLmRhdGEoZnJlcXMpXG4gICAgICAgIC5lbnRlcigpLmFwcGVuZChcImdcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImZyZXFcIilcbiAgICAgICAgLmF0dHIoXCJuYW1lXCIsIGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiBteW5hbWUuY29uY2F0KGduYW1lW2ldKTtcbiAgICAgICAgfSk7XG5cbiAgICB2YXIgcmVjdCA9IGZyZXEuc2VsZWN0QWxsKFwicmVjdFwiKVxuICAgICAgICAuZGF0YShPYmplY3QpXG4gICAgICAgIC5lbnRlcigpLmFwcGVuZChcInJlY3RcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImJhclwiKVxuICAgICAgICAuYXR0cihcIm5hbWVcIiwgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIHhWYWxzW2ldO1xuICAgICAgICB9KVxuICAgICAgICAuYXR0cihcInhcIiwgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIHgoeFZhbHNbaV0gLSAwLjUgKyBiYXJQYWRkaW5nKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoXCJ5XCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHJldHVybiB5KGQueTApO1xuICAgICAgICB9KVxuICAgICAgICAuYXR0cihcIndpZHRoXCIsIHgobWluWCArIDAuNSAtIDIgKiBiYXJQYWRkaW5nKSkgLy8gdGhlIFwid2lkdGhcIiBpcyB0aGUgY29vcmRpbmF0ZSBvZiB0aGUgZW5kIG9mIHRoZSBmaXJzdCBiYXJcbiAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgcmV0dXJuIHkoZC55MSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5zdHlsZShcImZpbGxcIiwgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgaWYgKG5vZGUuc3Vic2V0cmFuZ2UubGVuZ3RoID4gMCAmIGQuY29sID09PSBkM0NvbG9yICYgJC5pbkFycmF5KHhWYWxzW2ldLnRvU3RyaW5nKCksIG5vZGUuc3Vic2V0cmFuZ2UpID4gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsVmFyQ29sb3I7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBkLmNvbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0TWUgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHNlbGVjdE5hbWUgPSB0aGlzLmdldEF0dHJpYnV0ZShcIm5hbWVcIik7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnROb2RlLmdldEF0dHJpYnV0ZShcIm5hbWVcIikgPT0gbXluYW1lLmNvbmNhdChcInN1YnNldG5vXCIpKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0TWUgPSAkKCdbbmFtZT1cIicgKyBteW5hbWUuY29uY2F0KFwic3Vic2V0eWVzXCIpICsgJ1wiXScpLmNoaWxkcmVuKCdbbmFtZT1cIicgKyBzZWxlY3ROYW1lICsgJ1wiXScpWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZDMuc2VsZWN0KHNlbGVjdE1lKVxuICAgICAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbXlDb2wgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zdHlsZS5maWxsID09PSBzZWxWYXJDb2xvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG15aW5kZXggPSBub2RlLnN1YnNldHJhbmdlLmluZGV4T2YodGhpcy5nZXRBdHRyaWJ1dGUoXCJuYW1lXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc3Vic2V0cmFuZ2Uuc3BsaWNlKG15aW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbXlDb2wgPSBkM0NvbG9yO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5zdWJzZXRyYW5nZS5wdXNoKHRoaXMuZ2V0QXR0cmlidXRlKFwibmFtZVwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBteUNvbCA9IHNlbFZhckNvbG9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBteUNvbDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBsb3Rzdmcuc2VsZWN0KFwidGV4dCNzZWxlY3RyYW5nZVwiKVxuICAgICAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5zdWJzZXRyYW5nZS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcIlNlbGVjdGVkOiBhbGwgdmFsdWVzXCIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBub2RlLnN1YnNldHJhbmdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGVjdGVkcyA9IG5ldyBBcnJheTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGEuZm9yRWFjaChmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZHMucHVzaCh5VmFsS2V5W3ZhbF0ueCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcIlNlbGVjdGVkOiBcIiArIHNlbGVjdGVkcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICB9KVxuICAgICAgICAub24oXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaSA9IHRoaXMuZ2V0QXR0cmlidXRlKFwibmFtZVwiKTtcbiAgICAgICAgICAgIHBsb3Rzdmcuc2VsZWN0KFwidGV4dCNteW1vdXNlb3ZlclwiKVxuICAgICAgICAgICAgICAgIC50ZXh0KCgpID0+IHlWYWxLZXlbaV0ueCArIFwiOiBcIiArIHlWYWxLZXlbaV0ueSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbihcIm1vdXNlb3V0XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGkgPSB0aGlzLmdldEF0dHJpYnV0ZShcIm5hbWVcIik7XG4gICAgICAgICAgICBwbG90c3ZnLnNlbGVjdChcInRleHQjbXltb3VzZW92ZXJcIilcbiAgICAgICAgICAgICAgICAudGV4dCgoKSA9PiBcIlZhbHVlOiBGcmVxdWVuY3lcIik7XG4gICAgICAgIH0pO1xuXG4gICAgaWYgKHBsb3RYYXhpcykge1xuICAgICAgICBwbG90c3ZnLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJ4IGF4aXNcIilcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsXCIgKyBoZWlnaHQgKyBcIilcIilcbiAgICAgICAgICAgIC5jYWxsKHhBeGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBwbG90c3ZnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgXCJteW1vdXNlb3ZlclwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIDI1KVxuICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIGhlaWdodCArIDIwKVxuICAgICAgICAgICAgLnRleHQoKCkgPT4gXCJWYWx1ZTogRnJlcXVlbmN5XCIpO1xuICAgIH1cblxuICAgIHBsb3RzdmcuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAuYXR0cihcInhcIiwgKHdpZHRoIC8gMikpXG4gICAgICAgIC5hdHRyKFwieVwiLCAwIC0gKG1hcmdpbi50b3AgLyAyKSlcbiAgICAgICAgLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKVxuICAgICAgICAuc3R5bGUoXCJmb250LXNpemVcIiwgXCIxMnB4XCIpXG4gICAgICAgIC50ZXh0KG15bmFtZSk7XG5cbiAgICBwbG90c3ZnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgLmF0dHIoXCJpZFwiLCBcInNlbGVjdHJhbmdlXCIpXG4gICAgICAgIC5hdHRyKFwieFwiLCAyNSlcbiAgICAgICAgLmF0dHIoXCJ5XCIsIGhlaWdodCArIDQwKVxuICAgICAgICAudGV4dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAobm9kZS5zdWJzZXRyYW5nZS5sZW5ndGggPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJTZWxlY3RlZDogYWxsIHZhbHVlc1wiO1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkcyA9IG5ldyBBcnJheTtcbiAgICAgICAgICAgIG5vZGUuc3Vic2V0cmFuZ2UuZm9yRWFjaCh2YWwgPT4gIHNlbGVjdGVkcy5wdXNoKHlWYWxLZXlbdmFsXS54KSk7XG4gICAgICAgICAgICByZXR1cm4gXCJTZWxlY3RlZDogXCIgKyBzZWxlY3RlZHM7XG4gICAgICAgIH0pO1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBkZW5zaXR5Tm9kZShub2RlLCBvYmopIHtcbiAgICB2YXIgbXluYW1lID0gbm9kZS5uYW1lLnRvU3RyaW5nKCkuY29uY2F0KFwibm9kZXBsb3RcIik7XG5cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB2YXIgb2JqID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobm9kZS5uYW1lLnRvU3RyaW5nKCkgKyBcImJpZ2dyb3VwXCIpO1xuICAgICAgICAvLyBpZiBvYmogY29udGFpbnMgYW4gc3ZnIGVsZW1lbnQsIHJlbW92ZSBpdC4gdGhpcyByZW1vdmVzIGFueSBwbG90IGluc2lkZSB0aGUgbm9kZVxuICAgICAgICBpZiAoZDMuc2VsZWN0KG9iaikuc2VsZWN0QWxsKFwic3ZnXCIpWzBdLmxlbmd0aCA+IDApXG4gICAgICAgICAgICBkMy5zZWxlY3Qob2JqKS5zZWxlY3RBbGwoXCJzdmdcIikucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgdmFyIHlWYWxzID0gbm9kZS5wbG90eTtcbiAgICB2YXIgeFZhbHMgPSBub2RlLnBsb3R4O1xuICAgIC8vIGFycmF5IG9mIG9iamVjdHNcbiAgICBsZXQgZGF0YTIgPSBub2RlLnBsb3R4Lm1hcCgoeCwgaSkgPT4gKHt4OiAreCwgeTogK25vZGUucGxvdHlbaV19KSk7XG5cbiAgICB2YXIgd2lkdGggPSA2MDsgLy8gaGFyZGNvZGVkLCBzaG91bGQgYmUgc2V0IGF1dG9tYXRpY2FsbHlcbiAgICB2YXIgaGVpZ2h0ID0gMzA7XG4gICAgdmFyIG1hcmdpbiA9IHtcbiAgICAgICAgdG9wOiAyMCxcbiAgICAgICAgcmlnaHQ6IDEwLFxuICAgICAgICBib3R0b206IDUzLFxuICAgICAgICBsZWZ0OiAxMFxuICAgIH07XG5cbiAgICB2YXIgeCA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgIC5kb21haW4oW2QzLm1pbih4VmFscyksIGQzLm1heCh4VmFscyldKVxuICAgICAgICAucmFuZ2UoWzAsIHdpZHRoXSk7XG5cbiAgICB2YXIgeSA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgIC5kb21haW4oW2QzLm1pbih5VmFscyksIGQzLm1heCh5VmFscyldKVxuICAgICAgICAucmFuZ2UoW2hlaWdodCwgMF0pO1xuXG4gICAgdmFyIGFyZWEgPSBkMy5zdmcuYXJlYSgpXG4gICAgICAgIC5pbnRlcnBvbGF0ZShcIm1vbm90b25lXCIpXG4gICAgICAgIC54KGQgPT4geChkLngpKVxuICAgICAgICAueTAoaGVpZ2h0KVxuICAgICAgICAueTEoZCA9PiB5KGQueSkpO1xuXG4gICAgdmFyIHBsb3RzdmcgPSBkMy5zZWxlY3Qob2JqKVxuICAgICAgICAuaW5zZXJ0KFwic3ZnXCIsIFwiOmZpcnN0LWNoaWxkXCIpXG4gICAgICAgIC5hdHRyKFwieFwiLCAtNDApIC8vIE5PVEU6IE5vdCBzdXJlIGV4YWN0bHkgd2h5IHRoZXNlIG51bWJlcnMgd29yaywgYnV0IHRoZXNlIGhhcmRjb2RlZCB2YWx1ZXMgc2VlbSB0byBwb3NpdGlvbiB0aGUgcGxvdCBpbnNpZGUgZyBjb3JyZWN0bHkuICB0aGlzIHNob3VsZG4ndCBiZSBoYXJkY29kZWQgaW4gdGhlIGZ1dHVyZVxuICAgICAgICAuYXR0cihcInlcIiwgLTQ1KVxuICAgICAgICAuYXR0cihcImlkXCIsICgpID0+IG15bmFtZSlcbiAgICAgICAgLnN0eWxlKFwid2lkdGhcIiwgd2lkdGgpXG4gICAgICAgIC5zdHlsZShcImhlaWdodFwiLCBoZWlnaHQpXG4gICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgbWFyZ2luLmxlZnQgKyBcIixcIiArIG1hcmdpbi50b3AgKyBcIilcIik7XG5cbiAgICBwbG90c3ZnLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgLmRhdHVtKGRhdGEyKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiYXJlYVwiKVxuICAgICAgICAuYXR0cihcImRcIiwgYXJlYSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBiYXJzTm9kZShub2RlLCBvYmopIHtcbiAgICB2YXIgbXluYW1lID0gbm9kZS5uYW1lLnRvU3RyaW5nKCkuY29uY2F0KFwibm9kZXBsb3RcIik7XG5cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB2YXIgb2JqID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobm9kZS5uYW1lLnRvU3RyaW5nKCkgKyBcImJpZ2dyb3VwXCIpO1xuICAgICAgICAvLyBpZiBvYmogY29udGFpbnMgYW4gc3ZnIGVsZW1lbnQsIHJlbW92ZSBpdC4gdGhpcyByZW1vdmVzIGFueSBwbG90IGluc2lkZSB0aGUgbm9kZVxuICAgICAgICBpZiAoZDMuc2VsZWN0KG9iaikuc2VsZWN0QWxsKFwic3ZnXCIpWzBdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGQzLnNlbGVjdChvYmopLnNlbGVjdEFsbChcInN2Z1wiKS5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEhpc3RvZ3JhbSBzcGFjaW5nXG4gICAgdmFyIGJhclBhZGRpbmcgPSAuMDE1OyAvLyBTcGFjZSBiZXR3ZWVuIGJhcnNcbiAgICB2YXIgdG9wU2NhbGUgPSAxLjI7IC8vIE11bHRpcGxpY2F0aXZlIGZhY3RvciB0byBhc3NpZ24gc3BhY2UgYXQgdG9wIHdpdGhpbiBncmFwaCAtIGN1cnJlbnRseSByZW1vdmVkIGZyb20gaW1wbGVtZW50YXRpb25cblxuICAgIC8vIERhdGFcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG5vZGUucGxvdHZhbHVlcyk7XG4gICAgdmFyIHlWYWxzID0gbmV3IEFycmF5O1xuICAgIHZhciB4VmFscyA9IG5ldyBBcnJheTtcbiAgICB2YXIgeVZhbEtleSA9IG5ldyBBcnJheTtcblxuICAgIGlmIChub2RlLm5hdHVyZSA9PT0gXCJub21pbmFsXCIpIHtcbiAgICAgICAgdmFyIHhpID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5wbG90dmFsdWVzW2tleXNbaV1dID09IDApXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB5VmFsc1t4aV0gPSBub2RlLnBsb3R2YWx1ZXNba2V5c1tpXV07XG4gICAgICAgICAgICB4VmFsc1t4aV0gPSB4aTtcbiAgICAgICAgICAgIHlWYWxLZXkucHVzaCh7eTogeVZhbHNbeGldLCB4OiBrZXlzW2ldfSk7XG4gICAgICAgICAgICB4aSA9IHhpICsgMTtcbiAgICAgICAgfVxuICAgICAgICB5VmFsS2V5LnNvcnQoKGEsIGIpID0+IGIueSAtIGEueSk7IC8vIGFycmF5IG9mIG9iamVjdHMsIGVhY2ggb2JqZWN0IGhhcyB5LCB0aGUgc2FtZSBhcyB5VmFscywgYW5kIHgsIHRoZSBjYXRlZ29yeVxuICAgICAgICB5VmFscy5zb3J0KChhLCBiKSA9PiBiIC0gYSk7IC8vIGFycmF5IG9mIHkgdmFsdWVzLCB0aGUgaGVpZ2h0IG9mIHRoZSBiYXJzXG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB5VmFsc1tpXSA9IG5vZGUucGxvdHZhbHVlc1trZXlzW2ldXTtcbiAgICAgICAgICAgIHhWYWxzW2ldID0gTnVtYmVyKGtleXNbaV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG1heFkgPSBkMy5tYXgoeVZhbHMpO1xuICAgIHZhciBtaW5YID0gZDMubWluKHhWYWxzKTtcbiAgICB2YXIgbWF4WCA9IGQzLm1heCh4VmFscyk7XG5cbiAgICB2YXIgd2lkdGggPSA2MDtcbiAgICB2YXIgaGVpZ2h0ID0gMzA7XG4gICAgdmFyIG1hcmdpbiA9IHtcbiAgICAgICAgdG9wOiAyMCxcbiAgICAgICAgcmlnaHQ6IDEwLFxuICAgICAgICBib3R0b206IDUzLFxuICAgICAgICBsZWZ0OiAxMFxuICAgIH07XG5cbiAgICB2YXIgeCA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgIC5kb21haW4oW21pblggLSAwLjUsIG1heFggKyAwLjVdKVxuICAgICAgICAucmFuZ2UoWzAsIHdpZHRoXSk7XG5cbiAgICB2YXIgaW52eCA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgIC5yYW5nZShbbWluWCAtIDAuNSwgbWF4WCArIDAuNV0pXG4gICAgICAgIC5kb21haW4oWzAsIHdpZHRoXSk7XG5cbiAgICB2YXIgeSA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgIC5kb21haW4oWzAsIG1heFldKVxuICAgICAgICAucmFuZ2UoWzAsIGhlaWdodF0pO1xuXG4gICAgLy9DcmVhdGUgU1ZHIGVsZW1lbnRcbiAgICB2YXIgcGxvdHN2ZyA9IGQzLnNlbGVjdChvYmopXG4gICAgICAgIC5pbnNlcnQoXCJzdmdcIiwgXCI6Zmlyc3QtY2hpbGRcIilcbiAgICAgICAgLmF0dHIoXCJ4XCIsIC00MClcbiAgICAgICAgLmF0dHIoXCJ5XCIsIC00NSlcbiAgICAgICAgLmF0dHIoXCJpZFwiLCAoKSA9PiBteW5hbWUpXG4gICAgICAgIC5zdHlsZShcIndpZHRoXCIsIHdpZHRoKSAvLyBzZXQgaGVpZ2h0IHRvIHRoZSBoZWlnaHQgb2YgI21haW4ubGVmdFxuICAgICAgICAuc3R5bGUoXCJoZWlnaHRcIiwgaGVpZ2h0KVxuICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIG1hcmdpbi5sZWZ0ICsgXCIsXCIgKyBtYXJnaW4udG9wICsgXCIpXCIpO1xuXG4gICAgcGxvdHN2Zy5zZWxlY3RBbGwoXCJyZWN0XCIpXG4gICAgICAgIC5kYXRhKHlWYWxzKVxuICAgICAgICAuZW50ZXIoKVxuICAgICAgICAuYXBwZW5kKFwicmVjdFwiKVxuICAgICAgICAuYXR0cihcInhcIiwgKGQsIGkpID0+ICB4KHhWYWxzW2ldIC0gMC41ICsgYmFyUGFkZGluZykpXG4gICAgICAgIC5hdHRyKFwieVwiLCBkID0+ICB5KG1heFkgLSBkKSlcbiAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCB4KG1pblggKyAwLjUgLSAyICogYmFyUGFkZGluZykpIC8vIHRoZSBcIndpZHRoXCIgaXMgdGhlIGNvb3JkaW5hdGUgb2YgdGhlIGVuZCBvZiB0aGUgZmlyc3QgYmFyXG4gICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIHkpXG4gICAgICAgIC5hdHRyKFwiZmlsbFwiLCBcIiMxZjc3YjRcIik7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9hc3NldHMvYXBwL3Bsb3RzLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2\n')},function(module,exports){eval('var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function("return this")() || (1,eval)("this");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === "object")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it\'s\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzPzM2OTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUMiLCJmaWxlIjoiMy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBnO1xyXG5cclxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcclxuZyA9IChmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufSkoKTtcclxuXHJcbnRyeSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXHJcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLGV2YWwpKFwidGhpc1wiKTtcclxufSBjYXRjaChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZih0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKVxyXG5cdFx0ZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3\n')},function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.getClass = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mithril = __webpack_require__(0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _app = __webpack_require__(1);\n\nvar app = _interopRequireWildcard(_app);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar getClass = exports.getClass = function getClass(panel) {\n    if (panel.closed) return '.closepanel';\n    return panel.side === 'left' && app.lefttab === 'tab2' ? '.expandpanel' : '';\n};\n\nvar Panel = function () {\n    function Panel() {\n        _classCallCheck(this, Panel);\n    }\n\n    _createClass(Panel, [{\n        key: 'oninit',\n        value: function oninit(vnode) {\n            this.closed = false;\n        }\n    }, {\n        key: 'view',\n        value: function view(vnode) {\n            var _this = this;\n\n            var dot = [_mithril2.default.trust('&#9679;'), (0, _mithril2.default)('br')];\n            return (0, _mithril2.default)('#' + vnode.attrs.side + 'panel.sidepanel.container.clearfix' + getClass(this), [(0, _mithril2.default)('#toggle' + (vnode.attrs.side === 'left' ? 'L' : 'R') + 'panelicon.panelbar[style=height: calc(100% - 60px)]', (0, _mithril2.default)('span', { onclick: function onclick(_) {\n                    return _this.closed = !_this.closed;\n                } }, [].concat([dot, dot, dot, dot]))), (0, _mithril2.default)('#' + this.side + 'paneltitle.panel-heading.text-center', (0, _mithril2.default)(\"h3.panel-title\", vnode.attrs.title))].concat(vnode.children));\n        }\n    }]);\n\n    return Panel;\n}();\n\nexports.default = Panel;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvYXBwL3ZpZXdzL1BhbmVsLmpzPzkyNGYiXSwibmFtZXMiOlsiYXBwIiwiZ2V0Q2xhc3MiLCJwYW5lbCIsImNsb3NlZCIsInNpZGUiLCJsZWZ0dGFiIiwiUGFuZWwiLCJ2bm9kZSIsImRvdCIsInRydXN0IiwiYXR0cnMiLCJvbmNsaWNrIiwiY29uY2F0IiwidGl0bGUiLCJjaGlsZHJlbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7Ozs7QUFFQTs7SUFBWUEsRzs7Ozs7Ozs7QUFFTCxJQUFJQyw4QkFBVyxTQUFYQSxRQUFXLENBQVNDLEtBQVQsRUFBZ0I7QUFDbEMsUUFBSUEsTUFBTUMsTUFBVixFQUFrQixPQUFPLGFBQVA7QUFDbEIsV0FBUUQsTUFBTUUsSUFBTixLQUFlLE1BQWYsSUFBeUJKLElBQUlLLE9BQUosS0FBZ0IsTUFBMUMsR0FBb0QsY0FBcEQsR0FBcUUsRUFBNUU7QUFDSCxDQUhNOztJQUtEQyxLOzs7Ozs7OytCQUNLQyxLLEVBQU87QUFDVixpQkFBS0osTUFBTCxHQUFjLEtBQWQ7QUFDSDs7OzZCQUVJSSxLLEVBQU87QUFBQTs7QUFDUixnQkFBSUMsTUFBTSxDQUFDLGtCQUFFQyxLQUFGLENBQVEsU0FBUixDQUFELEVBQXFCLHVCQUFFLElBQUYsQ0FBckIsQ0FBVjtBQUNBLG1CQUFPLDZCQUFNRixNQUFNRyxLQUFOLENBQVlOLElBQWxCLDBDQUEyREgsU0FBUyxJQUFULENBQTNELEVBQTZFLENBQ2hGLG9DQUFZTSxNQUFNRyxLQUFOLENBQVlOLElBQVosS0FBcUIsTUFBckIsR0FBOEIsR0FBOUIsR0FBb0MsR0FBaEQsMkRBQ0UsdUJBQUUsTUFBRixFQUFVLEVBQUNPLFNBQVM7QUFBQSwyQkFBSyxNQUFLUixNQUFMLEdBQWMsQ0FBQyxNQUFLQSxNQUF6QjtBQUFBLGlCQUFWLEVBQVYsRUFDRSxHQUFHUyxNQUFILENBQVUsQ0FBQ0osR0FBRCxFQUFNQSxHQUFOLEVBQVdBLEdBQVgsRUFBZ0JBLEdBQWhCLENBQVYsQ0FERixDQURGLENBRGdGLEVBSWhGLDZCQUFNLEtBQUtKLElBQVgsMkNBQ0UsdUJBQUUsZ0JBQUYsRUFBb0JHLE1BQU1HLEtBQU4sQ0FBWUcsS0FBaEMsQ0FERixDQUpnRixFQU1sRkQsTUFOa0YsQ0FNM0VMLE1BQU1PLFFBTnFFLENBQTdFLENBQVA7QUFPSDs7Ozs7O2tCQUdVUixLIiwiZmlsZSI6IjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbSBmcm9tICdtaXRocmlsJztcblxuaW1wb3J0ICogYXMgYXBwIGZyb20gJy4uL2FwcCc7XG5cbmV4cG9ydCBsZXQgZ2V0Q2xhc3MgPSBmdW5jdGlvbihwYW5lbCkge1xuICAgIGlmIChwYW5lbC5jbG9zZWQpIHJldHVybiAnLmNsb3NlcGFuZWwnO1xuICAgIHJldHVybiAocGFuZWwuc2lkZSA9PT0gJ2xlZnQnICYmIGFwcC5sZWZ0dGFiID09PSAndGFiMicpID8gJy5leHBhbmRwYW5lbCcgOiAnJztcbn07XG5cbmNsYXNzIFBhbmVsIHtcbiAgICBvbmluaXQodm5vZGUpIHtcbiAgICAgICAgdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2aWV3KHZub2RlKSB7XG4gICAgICAgIGxldCBkb3QgPSBbbS50cnVzdCgnJiM5Njc5OycpLCBtKCdicicpXTtcbiAgICAgICAgcmV0dXJuIG0oYCMke3Zub2RlLmF0dHJzLnNpZGV9cGFuZWwuc2lkZXBhbmVsLmNvbnRhaW5lci5jbGVhcmZpeCR7Z2V0Q2xhc3ModGhpcyl9YCwgW1xuICAgICAgICAgICAgbShgI3RvZ2dsZSR7dm5vZGUuYXR0cnMuc2lkZSA9PT0gJ2xlZnQnID8gJ0wnIDogJ1InfXBhbmVsaWNvbi5wYW5lbGJhcltzdHlsZT1oZWlnaHQ6IGNhbGMoMTAwJSAtIDYwcHgpXWAsXG4gICAgICAgICAgICAgIG0oJ3NwYW4nLCB7b25jbGljazogXyA9PiB0aGlzLmNsb3NlZCA9ICF0aGlzLmNsb3NlZH0sXG4gICAgICAgICAgICAgICAgW10uY29uY2F0KFtkb3QsIGRvdCwgZG90LCBkb3RdKSkpLFxuICAgICAgICAgICAgbShgIyR7dGhpcy5zaWRlfXBhbmVsdGl0bGUucGFuZWwtaGVhZGluZy50ZXh0LWNlbnRlcmAsXG4gICAgICAgICAgICAgIG0oXCJoMy5wYW5lbC10aXRsZVwiLCB2bm9kZS5hdHRycy50aXRsZSkpXG4gICAgICAgIF0uY29uY2F0KHZub2RlLmNoaWxkcmVuKSk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBQYW5lbDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Fzc2V0cy9hcHAvdmlld3MvUGFuZWwuanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.searchIndex = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mithril = __webpack_require__(0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _app = __webpack_require__(1);\n\nvar app = _interopRequireWildcard(_app);\n\nvar _plots = __webpack_require__(2);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar searchIndex = exports.searchIndex = void 0;\n\nvar search = function search(val) {\n    var all = app.allNodes;\n    if (val === '') {\n        exports.searchIndex = searchIndex = null;\n        return app.valueKey = all.map(function (n) {\n            return n.name;\n        });\n    }\n\n    var matches = [],\n        others = [],\n        match = function match(n, key) {\n        return n[key].toLowerCase().includes(val.toLowerCase());\n    };\n\n    all.forEach(function (n) {\n        return match(n, 'name') || match(n, 'labl') ? matches.push(n) : others.push(n);\n    });\n    exports.searchIndex = searchIndex = matches.length;\n    app.valueKey = matches.concat(others).map(function (n) {\n        return n.name;\n    });\n};\n\nvar Search = function () {\n    function Search() {\n        _classCallCheck(this, Search);\n    }\n\n    _createClass(Search, [{\n        key: 'view',\n        value: function view(vnode) {\n            vnode.attrs.oninput = _mithril2.default.withAttr('value', search);\n            return (0, _mithril2.default)('input#searchvar.form-control[style=margin-bottom: 5px; width: 100%]', vnode.attrs);\n        }\n    }]);\n\n    return Search;\n}();\n\nexports.default = Search;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvYXBwL3ZpZXdzL1NlYXJjaC5qcz8xMzc4Il0sIm5hbWVzIjpbImFwcCIsInNlYXJjaEluZGV4Iiwic2VhcmNoIiwiYWxsIiwiYWxsTm9kZXMiLCJ2YWwiLCJ2YWx1ZUtleSIsIm1hcCIsIm4iLCJuYW1lIiwibWF0Y2hlcyIsIm90aGVycyIsIm1hdGNoIiwia2V5IiwidG9Mb3dlckNhc2UiLCJpbmNsdWRlcyIsImZvckVhY2giLCJwdXNoIiwibGVuZ3RoIiwiY29uY2F0IiwiU2VhcmNoIiwidm5vZGUiLCJhdHRycyIsIm9uaW5wdXQiLCJ3aXRoQXR0ciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7Ozs7QUFFQTs7SUFBWUEsRzs7QUFDWjs7Ozs7Ozs7QUFFTyxJQUFJQywwQ0FBSjs7QUFFUCxJQUFJQyxTQUFTLFNBQVRBLE1BQVMsTUFBTztBQUNoQixRQUFJQyxNQUFNSCxJQUFJSSxRQUFkO0FBQ0EsUUFBSUMsUUFBUSxFQUFaLEVBQWdCO0FBQ1osZ0JBTEdKLFdBS0gsaUJBQWMsSUFBZDtBQUNBLGVBQU9ELElBQUlNLFFBQUosR0FBZUgsSUFBSUksR0FBSixDQUFRO0FBQUEsbUJBQUtDLEVBQUVDLElBQVA7QUFBQSxTQUFSLENBQXRCO0FBQ0g7O0FBTGUsUUFNWEMsT0FOVyxHQU1nQixFQU5oQjtBQUFBLFFBTUZDLE1BTkUsR0FNb0IsRUFOcEI7QUFBQSxRQU1NQyxLQU5OLEdBTXdCLFNBQWxCQSxLQUFrQixDQUFDSixDQUFELEVBQUlLLEdBQUo7QUFBQSxlQUFZTCxFQUFFSyxHQUFGLEVBQU9DLFdBQVAsR0FBcUJDLFFBQXJCLENBQThCVixJQUFJUyxXQUFKLEVBQTlCLENBQVo7QUFBQSxLQU54Qjs7QUFPaEJYLFFBQUlhLE9BQUosQ0FBWTtBQUFBLGVBQUtKLE1BQU1KLENBQU4sRUFBUyxNQUFULEtBQW9CSSxNQUFNSixDQUFOLEVBQVMsTUFBVCxDQUFwQixHQUF1Q0UsUUFBUU8sSUFBUixDQUFhVCxDQUFiLENBQXZDLEdBQXlERyxPQUFPTSxJQUFQLENBQVlULENBQVosQ0FBOUQ7QUFBQSxLQUFaO0FBQ0EsWUFWT1AsV0FVUCxpQkFBY1MsUUFBUVEsTUFBdEI7QUFDQWxCLFFBQUlNLFFBQUosR0FBZUksUUFDVlMsTUFEVSxDQUNIUixNQURHLEVBRVZKLEdBRlUsQ0FFTjtBQUFBLGVBQUtDLEVBQUVDLElBQVA7QUFBQSxLQUZNLENBQWY7QUFHSCxDQVpEOztJQWNNVyxNOzs7Ozs7OzZCQUNHQyxLLEVBQU87QUFDUkEsa0JBQU1DLEtBQU4sQ0FBWUMsT0FBWixHQUFzQixrQkFBRUMsUUFBRixDQUFXLE9BQVgsRUFBb0J0QixNQUFwQixDQUF0QjtBQUNBLG1CQUFPLHVCQUFFLHFFQUFGLEVBQXlFbUIsTUFBTUMsS0FBL0UsQ0FBUDtBQUNIOzs7Ozs7a0JBR1VGLE0iLCJmaWxlIjoiNS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuXG5pbXBvcnQgKiBhcyBhcHAgZnJvbSAnLi4vYXBwJztcbmltcG9ydCB7c2VsVmFyQ29sb3J9IGZyb20gJy4uL3Bsb3RzJztcblxuZXhwb3J0IGxldCBzZWFyY2hJbmRleDtcblxubGV0IHNlYXJjaCA9IHZhbCA9PiB7XG4gICAgbGV0IGFsbCA9IGFwcC5hbGxOb2RlcztcbiAgICBpZiAodmFsID09PSAnJykge1xuICAgICAgICBzZWFyY2hJbmRleCA9IG51bGw7XG4gICAgICAgIHJldHVybiBhcHAudmFsdWVLZXkgPSBhbGwubWFwKG4gPT4gbi5uYW1lKTtcbiAgICB9XG4gICAgbGV0IFttYXRjaGVzLCBvdGhlcnMsIG1hdGNoXSA9IFtbXSwgW10sIChuLCBrZXkpID0+IG5ba2V5XS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHZhbC50b0xvd2VyQ2FzZSgpKV07XG4gICAgYWxsLmZvckVhY2gobiA9PiBtYXRjaChuLCAnbmFtZScpIHx8IG1hdGNoKG4sICdsYWJsJykgPyBtYXRjaGVzLnB1c2gobikgOiBvdGhlcnMucHVzaChuKSk7XG4gICAgc2VhcmNoSW5kZXggPSBtYXRjaGVzLmxlbmd0aDtcbiAgICBhcHAudmFsdWVLZXkgPSBtYXRjaGVzXG4gICAgICAgIC5jb25jYXQob3RoZXJzKVxuICAgICAgICAubWFwKG4gPT4gbi5uYW1lKTtcbn07XG5cbmNsYXNzIFNlYXJjaCB7XG4gICAgdmlldyh2bm9kZSkge1xuICAgICAgICB2bm9kZS5hdHRycy5vbmlucHV0ID0gbS53aXRoQXR0cigndmFsdWUnLCBzZWFyY2gpO1xuICAgICAgICByZXR1cm4gbSgnaW5wdXQjc2VhcmNodmFyLmZvcm0tY29udHJvbFtzdHlsZT1tYXJnaW4tYm90dG9tOiA1cHg7IHdpZHRoOiAxMDAlXScsIHZub2RlLmF0dHJzKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNlYXJjaDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Fzc2V0cy9hcHAvdmlld3MvU2VhcmNoLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mithril = __webpack_require__(0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _app = __webpack_require__(1);\n\nvar app = _interopRequireWildcard(_app);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Subpanel = function () {\n    function Subpanel() {\n        _classCallCheck(this, Subpanel);\n    }\n\n    _createClass(Subpanel, [{\n        key: 'oninit',\n        value: function oninit(vnode) {\n            this.hide = false;\n        }\n    }, {\n        key: 'view',\n        value: function view(vnode) {\n            var _this = this;\n\n            var title = vnode.attrs.title;\n            var legend = title === 'Legend';\n            var target = 'collapse' + title;\n            var z = app.zparams;\n            return (0, _mithril2.default)('#' + (legend ? \"legend.legendary\" : \"logdiv.logbox\") + '.panel.panel-default', {\n                style: { display: legend && z.ztime.length + z.zcross.length + z.zdv.length + z.znom.length || !legend && app.logArray.length > 0 ? 'block' : 'none' } }, (0, _mithril2.default)(\".panel-heading\", (0, _mithril2.default)(\"h3.panel-title\", title, (0, _mithril2.default)('span.glyphicon.glyphicon-large.glyphicon-chevron-' + (this.hide ? 'up' : 'down') + '.pull-right[data-target=#' + target + '][data-toggle=collapse][href=#' + target + ']', {\n                style: 'cursor: pointer',\n                onclick: function onclick(_) {\n                    return _this.hide = !_this.hide;\n                } }))), (0, _mithril2.default)('#' + target + '.panel-collapse.collapse.in', (0, _mithril2.default)(\".panel-body\", !legend ? app.logArray.map(function (x) {\n                return (0, _mithril2.default)('p', x);\n            }) : vnode.attrs.buttons.map(function (x) {\n                return (0, _mithril2.default)('#' + x[0] + '.clearfix.' + (z[x[1]].length === 0 ? \"hide\" : \"show\"), (0, _mithril2.default)(\".rectColor\", (0, _mithril2.default)(\"svg[style=width: 20px; height: 20px]\", (0, _mithril2.default)(\"circle[cx=10][cy=10][fill=white][r=9][stroke=black][stroke-width=2]\"))), (0, _mithril2.default)(\".rectLabel\", x[2]));\n            }))));\n        }\n    }]);\n\n    return Subpanel;\n}();\n\nexports.default = Subpanel;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvYXBwL3ZpZXdzL1N1YnBhbmVsLmpzP2ViYWIiXSwibmFtZXMiOlsiYXBwIiwiU3VicGFuZWwiLCJ2bm9kZSIsImhpZGUiLCJ0aXRsZSIsImF0dHJzIiwibGVnZW5kIiwidGFyZ2V0IiwieiIsInpwYXJhbXMiLCJzdHlsZSIsImRpc3BsYXkiLCJ6dGltZSIsImxlbmd0aCIsInpjcm9zcyIsInpkdiIsInpub20iLCJsb2dBcnJheSIsIm9uY2xpY2siLCJtYXAiLCJ4IiwiYnV0dG9ucyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7OztBQUVBOztJQUFZQSxHOzs7Ozs7OztJQUVOQyxROzs7Ozs7OytCQUNLQyxLLEVBQU87QUFDVixpQkFBS0MsSUFBTCxHQUFZLEtBQVo7QUFDSDs7OzZCQUVJRCxLLEVBQU87QUFBQTs7QUFDUixnQkFBSUUsUUFBUUYsTUFBTUcsS0FBTixDQUFZRCxLQUF4QjtBQUNBLGdCQUFJRSxTQUFTRixVQUFVLFFBQXZCO0FBQ0EsZ0JBQUlHLFNBQVMsYUFBYUgsS0FBMUI7QUFDQSxnQkFBSUksSUFBSVIsSUFBSVMsT0FBWjtBQUNBLG1CQUFPLDhCQUFNSCxTQUFTLGtCQUFULEdBQThCLGVBQXBDLDRCQUEyRTtBQUM5RUksdUJBQU8sRUFBQ0MsU0FBU0wsVUFBVUUsRUFBRUksS0FBRixDQUFRQyxNQUFSLEdBQWlCTCxFQUFFTSxNQUFGLENBQVNELE1BQTFCLEdBQW1DTCxFQUFFTyxHQUFGLENBQU1GLE1BQXpDLEdBQWtETCxFQUFFUSxJQUFGLENBQU9ILE1BQW5FLElBQTZFLENBQUNQLE1BQUQsSUFBV04sSUFBSWlCLFFBQUosQ0FBYUosTUFBYixHQUFzQixDQUE5RyxHQUFrSCxPQUFsSCxHQUE0SCxNQUF0SSxFQUR1RSxFQUEzRSxFQUVFLHVCQUFFLGdCQUFGLEVBQ0UsdUJBQUUsZ0JBQUYsRUFDRVQsS0FERixFQUVFLDhFQUFzRCxLQUFLRCxJQUFMLEdBQVksSUFBWixHQUFrQixNQUF4RSxrQ0FBMEdJLE1BQTFHLHNDQUFpSkEsTUFBakosUUFBNEo7QUFDeEpHLHVCQUFPLGlCQURpSjtBQUV4SlEseUJBQVM7QUFBQSwyQkFBSyxNQUFLZixJQUFMLEdBQVksQ0FBQyxNQUFLQSxJQUF2QjtBQUFBLGlCQUYrSSxFQUE1SixDQUZGLENBREYsQ0FGRixFQVFFLDZCQUFNSSxNQUFOLGtDQUNFLHVCQUFFLGFBQUYsRUFBaUIsQ0FBQ0QsTUFBRCxHQUFVTixJQUFJaUIsUUFBSixDQUFhRSxHQUFiLENBQWlCO0FBQUEsdUJBQUssdUJBQUUsR0FBRixFQUFPQyxDQUFQLENBQUw7QUFBQSxhQUFqQixDQUFWLEdBQTZDbEIsTUFBTUcsS0FBTixDQUFZZ0IsT0FBWixDQUFvQkYsR0FBcEIsQ0FBd0IsYUFBSztBQUN2Rix1QkFBTyw2QkFBTUMsRUFBRSxDQUFGLENBQU4sbUJBQXVCWixFQUFFWSxFQUFFLENBQUYsQ0FBRixFQUFRUCxNQUFSLEtBQW1CLENBQW5CLEdBQXVCLE1BQXZCLEdBQWdDLE1BQXZELEdBQ0UsdUJBQUUsWUFBRixFQUNFLHVCQUFFLHNDQUFGLEVBQ0UsdUJBQUUscUVBQUYsQ0FERixDQURGLENBREYsRUFJRSx1QkFBRSxZQUFGLEVBQWdCTyxFQUFFLENBQUYsQ0FBaEIsQ0FKRixDQUFQO0FBSWlDLGFBTHlCLENBQTlELENBREYsQ0FSRixDQUFQO0FBZUg7Ozs7OztrQkFHVW5CLFEiLCJmaWxlIjoiNi5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuXG5pbXBvcnQgKiBhcyBhcHAgZnJvbSAnLi4vYXBwJztcblxuY2xhc3MgU3VicGFuZWwge1xuICAgIG9uaW5pdCh2bm9kZSkge1xuICAgICAgICB0aGlzLmhpZGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2aWV3KHZub2RlKSB7XG4gICAgICAgIGxldCB0aXRsZSA9IHZub2RlLmF0dHJzLnRpdGxlO1xuICAgICAgICBsZXQgbGVnZW5kID0gdGl0bGUgPT09ICdMZWdlbmQnO1xuICAgICAgICBsZXQgdGFyZ2V0ID0gJ2NvbGxhcHNlJyArIHRpdGxlO1xuICAgICAgICBsZXQgeiA9IGFwcC56cGFyYW1zO1xuICAgICAgICByZXR1cm4gbShgIyR7bGVnZW5kID8gXCJsZWdlbmQubGVnZW5kYXJ5XCIgOiBcImxvZ2Rpdi5sb2dib3hcIn0ucGFuZWwucGFuZWwtZGVmYXVsdGAsIHtcbiAgICAgICAgICAgIHN0eWxlOiB7ZGlzcGxheTogbGVnZW5kICYmIHouenRpbWUubGVuZ3RoICsgei56Y3Jvc3MubGVuZ3RoICsgei56ZHYubGVuZ3RoICsgei56bm9tLmxlbmd0aCB8fCAhbGVnZW5kICYmIGFwcC5sb2dBcnJheS5sZW5ndGggPiAwID8gJ2Jsb2NrJyA6ICdub25lJ319LFxuICAgICAgICAgICAgICAgICBtKFwiLnBhbmVsLWhlYWRpbmdcIixcbiAgICAgICAgICAgICAgICAgICBtKFwiaDMucGFuZWwtdGl0bGVcIixcbiAgICAgICAgICAgICAgICAgICAgIHRpdGxlLFxuICAgICAgICAgICAgICAgICAgICAgbShgc3Bhbi5nbHlwaGljb24uZ2x5cGhpY29uLWxhcmdlLmdseXBoaWNvbi1jaGV2cm9uLSR7dGhpcy5oaWRlID8gJ3VwJzogJ2Rvd24nfS5wdWxsLXJpZ2h0W2RhdGEtdGFyZ2V0PSMke3RhcmdldH1dW2RhdGEtdG9nZ2xlPWNvbGxhcHNlXVtocmVmPSMke3RhcmdldH1dYCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiAnY3Vyc29yOiBwb2ludGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICBvbmNsaWNrOiBfID0+IHRoaXMuaGlkZSA9ICF0aGlzLmhpZGV9KSkpLFxuICAgICAgICAgICAgICAgICBtKGAjJHt0YXJnZXR9LnBhbmVsLWNvbGxhcHNlLmNvbGxhcHNlLmluYCxcbiAgICAgICAgICAgICAgICAgICBtKFwiLnBhbmVsLWJvZHlcIiwgIWxlZ2VuZCA/IGFwcC5sb2dBcnJheS5tYXAoeCA9PiBtKCdwJywgeCkpIDogdm5vZGUuYXR0cnMuYnV0dG9ucy5tYXAoeCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtKGAjJHt4WzBdfS5jbGVhcmZpeC4ke3pbeFsxXV0ubGVuZ3RoID09PSAwID8gXCJoaWRlXCIgOiBcInNob3dcIn1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKFwiLnJlY3RDb2xvclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0oXCJzdmdbc3R5bGU9d2lkdGg6IDIwcHg7IGhlaWdodDogMjBweF1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0oXCJjaXJjbGVbY3g9MTBdW2N5PTEwXVtmaWxsPXdoaXRlXVtyPTldW3N0cm9rZT1ibGFja11bc3Ryb2tlLXdpZHRoPTJdXCIpKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0oXCIucmVjdExhYmVsXCIsIHhbMl0pKTt9KSkpKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFN1YnBhbmVsO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYXNzZXRzL2FwcC92aWV3cy9TdWJwYW5lbC5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6\n")},function(module,exports){eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvY3NzL2FwcC5jc3M/MmY3ZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiI3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Fzc2V0cy9jc3MvYXBwLmNzc1xuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7\n")},function(module,exports){eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvcGtncy9MYWRkYS9kaXN0L2xhZGRhLXRoZW1lbGVzcy5taW4uY3NzP2E2ZTEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hc3NldHMvcGtncy9MYWRkYS9kaXN0L2xhZGRhLXRoZW1lbGVzcy5taW4uY3NzXG4vLyBtb2R1bGUgaWQgPSA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8\n")},function(module,exports){eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvcGtncy9ib290c3RyYXAvY3NzL2Jvb3RzdHJhcC10aGVtZS5taW4uY3NzP2ZiNzQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiOS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hc3NldHMvcGtncy9ib290c3RyYXAvY3NzL2Jvb3RzdHJhcC10aGVtZS5taW4uY3NzXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n__webpack_require__(9);\n\n__webpack_require__(7);\n\n__webpack_require__(8);\n\nvar _mithril = __webpack_require__(0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _app = __webpack_require__(1);\n\nvar app = _interopRequireWildcard(_app);\n\nvar _plots = __webpack_require__(2);\n\nvar plots = _interopRequireWildcard(_plots);\n\nvar _Panel = __webpack_require__(4);\n\nvar _Panel2 = _interopRequireDefault(_Panel);\n\nvar _Search = __webpack_require__(5);\n\nvar _Search2 = _interopRequireDefault(_Search);\n\nvar _Subpanel = __webpack_require__(6);\n\nvar _Subpanel2 = _interopRequireDefault(_Subpanel);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar or = function or(side, val) {\n  var y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'block';\n  var n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'none';\n\n  return app[side + 'tab'] === val ? y : n;\n};\n\nvar leftpanel = function leftpanel() {\n  return (0, _mithril2.default)(_Panel2.default, { side: 'left', title: 'Data Selection' }, (0, _mithril2.default)(\".btn-toolbar[role=toolbar][style=margin-left: .5em; margin-top: .5em]\", (0, _mithril2.default)(\".btn-group\", (0, _mithril2.default)('button#btnVariables.btn.' + or('left', 'tab1', 'active', 'btn-default') + '[type=button]', {\n    title: 'Click variable name to add or remove the variable pebble from the modeling space.',\n    onclick: function onclick(_) {\n      return app.tabLeft('tab1');\n    } }, \"Variables\"), (0, _mithril2.default)('button#btnSubset.btn.' + or('left', 'tab2', 'active', 'btn-default') + '[type=button]', {\n    onclick: function onclick(_) {\n      return app.tabLeft('tab2');\n    } }, \"Subset\")), (0, _mithril2.default)(\"button#btnSelect.btn.btn-default.ladda-button[data-spinner-color=#000000][data-style=zoom-in][type=button]\", {\n    style: 'display: ' + (app.subset ? 'block' : 'none') + '; float: right; margin-right: 10px',\n    onclick: function onclick(_) {\n      return app.subsetSelect('btnSelect');\n    },\n    title: 'Subset data by the intersection of all selected values.' }, (0, _mithril2.default)(\"span.ladda-label[style=pointer-events: none]\", \"Select\"))), (0, _mithril2.default)('.row-fluid' + (0, _Panel.getClass)({ side: 'left' }), (0, _mithril2.default)('#leftpanelcontent', (0, _mithril2.default)('#leftContentArea[style=height: 453px; overflow: auto]', (0, _mithril2.default)('#tab1[style=display: ' + or('left', 'tab1') + '; padding: 10px 8px; text-align: center]', (0, _mithril2.default)(_Search2.default, { placeholder: 'Search variables and labels' }), (0, _mithril2.default)('#varList[style=display: block]', app.valueKey.map(function (v, i) {\n    return (0, _mithril2.default)('p#' + v.replace(/\\W/g, '_'), {\n      style: {\n        'background-color': app.zparams.zdv.includes(v) ? app.hexToRgba(app.dvColor) : app.zparams.znom.includes(v) ? app.hexToRgba(app.nomColor) : app.nodes.map(function (n) {\n          return n.name;\n        }).includes(v) ? app.hexToRgba(plots.selVarColor) : app.varColor,\n        'border-color': '#000000',\n        'border-style': _Search.searchIndex && i < _Search.searchIndex ? 'solid' : 'none'\n      },\n      onclick: app.clickVar,\n      onmouseover: function onmouseover() {\n        $(this).popover('show');\n        $(\"body div.popover\").addClass(\"variables\");\n        $(\"body div.popover div.popover-content\").addClass(\"form-horizontal\");\n      },\n      onmouseout: \"$(this).popover('hide');\",\n      'data-container': 'body',\n      'data-content': app.popoverContent(app.findNodeIndex(v, true)),\n      'data-html': 'true',\n      'data-original-title': 'Summary Statistics',\n      'data-placement': 'right',\n      'data-toggle': 'popover',\n      'data-trigger': 'hover' }, v);\n  }))), (0, _mithril2.default)('#tab2[style=display: ' + or('left', 'tab2') + '; margin-top: .5em]'), (0, _mithril2.default)('#tab3[style=height: 350px]', (0, _mithril2.default)('p[style=padding: .5em 1em; display: ' + or('left', 'tab3') + ']', {\n    title: \"Select a variable from within the visualization in the center panel to view its summary statistics.\" }, (0, _mithril2.default)('center', (0, _mithril2.default)('b', app.summary.name), (0, _mithril2.default)('br'), (0, _mithril2.default)('i', app.summary.labl)), (0, _mithril2.default)('table', app.summary.data.map(function (tr) {\n    return (0, _mithril2.default)('tr', tr.map(function (td) {\n      return (0, _mithril2.default)('td', {\n        onmouseover: function onmouseover() {\n          this.style['background-color'] = 'aliceblue';\n        },\n        onmouseout: function onmouseout() {\n          this.style['background-color'] = '#f9f9f9';\n        } }, td);\n    }));\n  }))))))));\n};\n\nvar rightpanel = function rightpanel() {\n  var button = function button(id, width, text) {\n    return (0, _mithril2.default)('button#' + id + '.btn.' + or('right', id, 'active', 'btn-default') + '[type=button][style=width: ' + width + ']', {\n      onclick: function onclick(_) {\n        return app.tabRight(id);\n      } }, text);\n  };\n  return (0, _mithril2.default)(_Panel2.default, { side: 'right', title: 'Model Selection' }, (0, _mithril2.default)(\".btn-group.btn-group-justified[aria-label=...][role=group][style=margin-top: .5em]\", button('btnModels', \"33%\", \"Models\"), button('btnSetx', \"34%\", \"Set Covar.\"), button('btnResults', \"33%\", \"Results\")), (0, _mithril2.default)('.row-fluid' + (0, _Panel.getClass)({ side: 'right' }), (0, _mithril2.default)('#rightpanelcontent', (0, _mithril2.default)('#rightContentArea[style=height: 453px; overflow: auto]', (0, _mithril2.default)('#results[style=display: ' + or('right', 'btnResults') + '; margin-top: .5em]', (0, _mithril2.default)(\"#resultsView.container[style=float: right; overflow: auto; width: 80%; background-color: white; white-space: nowrap]\"), (0, _mithril2.default)('#modelView[style=display: none; float: left; width: 20%; background-color: white]'), (0, _mithril2.default)(\"p#resultsHolder[style=padding: .5em 1em]\")), (0, _mithril2.default)('#setx[style=display: ' + or('right', 'btnSetx') + ']'), (0, _mithril2.default)('#models[style=display: ' + or('right', 'btnModels') + '; padding: 6px 12px; text-align: center]')))));\n};\n\nvar Body = function () {\n  function Body() {\n    _classCallCheck(this, Body);\n  }\n\n  _createClass(Body, [{\n    key: 'oninit',\n    value: function oninit() {\n      this.about = false;\n      this.cite = false;\n      this.citeHidden = false;\n    }\n  }, {\n    key: 'oncreate',\n    value: function oncreate() {\n      var extract = function extract(name, key, offset, replace) {\n        key = key + '=';\n        var loc = window.location.toString();\n        var val = loc.indexOf(key) > 0 ? loc.substring(loc.indexOf(key) + offset) : '';\n        var idx = val.indexOf('&');\n        val = idx > 0 ? val.substring(0, idx) : val;\n        console.log(name, ': ', val);\n        if (replace) val = val.replace(/%25/g, '%').replace(/%3A/g, ':').replace(/%2F/g, '/');\n        return val;\n      };\n      // let apikey = extract('apikey', 'key', 4);\n      app.main(extract('fileid', 'dfId', 5), extract('hostname', 'host', 5), extract('ddiurl', 'ddiurl', 7, true), extract('dataurl', 'dataurl', 8, true));\n    }\n  }, {\n    key: 'view',\n    value: function view() {\n      var _this = this;\n\n      return (0, _mithril2.default)('main', (0, _mithril2.default)(\"nav#navbar.navbar.navbar-default.navbar-fixed-top[role=navigation]\", (0, _mithril2.default)(\"a.navbar-brand[style=margin-left: 0]\", (0, _mithril2.default)(\"img[src=/static/images/TwoRavens.png][alt=TwoRavens][width=100][style=margin-left: 2em; margin-top: -0.5em]\", {\n        onmouseover: function onmouseover(_) {\n          return _this.about = true;\n        },\n        onmouseout: function onmouseout(_) {\n          return _this.about = false;\n        } })), (0, _mithril2.default)('#navbarNav[style=padding: 0.5em]', (0, _mithril2.default)('#dataField.field[style=margin-top: 0.5em; text-align: center]', (0, _mithril2.default)('h4#dataName[style=display: inline]', {\n        onclick: function onclick(_) {\n          return _this.cite = _this.citeHidden = !_this.citeHidden;\n        },\n        onmouseout: function onmouseout(_) {\n          return _this.citeHidden || (_this.cite = false);\n        },\n        onmouseover: function onmouseover(_) {\n          return _this.cite = true;\n        } }, \"Dataset Name\"), (0, _mithril2.default)('#cite.panel.panel-default[style=display: ' + (this.cite ? 'block' : 'none') + '; position: absolute; right: 50%; width: 380px; text-align: left; z-index: 50]', (0, _mithril2.default)(\".panel-body\")), (0, _mithril2.default)(\"button#btnEstimate.btn.btn-default.ladda-button.navbar-right[data-spinner-color=#000000][data-style=zoom-in][style=margin-left: 2em; margin-right: 1em]\", {\n        onclick: function onclick(_) {\n          return app.estimate('btnEstimate');\n        } }, (0, _mithril2.default)(\"span.ladda-label\", \"Estimate\")), (0, _mithril2.default)(\"button#btnReset.btn.btn-default.navbar-right[title=Reset][style=margin-left: 2.0em]\", {\n        onclick: app.reset }, (0, _mithril2.default)(\"span.glyphicon.glyphicon-repeat[style=color: #818181; font-size: 1em; pointer-events: none]\")), (0, _mithril2.default)('#transformations.transformTool', {\n        title: 'Construct transformations of existing variables using valid R syntax. For example, assuming a variable named d, you can enter \"log(d)\" or \"d^2\".' }))),\n      /*m('.text-center', {\n        style: {margin: '5px'}\n        }, m(\".btn-group\", [\n        m(`a.btn.btn-default${location.href.endsWith('model') ? '.active' : ''}[href=/model][role=button]`, {oncreate: m.route.link}, \"Model\"),\n        m(`a.btn.btn-default${location.href.endsWith('explore') ? '.active' : ''}[href=/explore][role=button]`, {oncreate: m.route.link}, \"Explore\")\n        ]))*/\n      (0, _mithril2.default)('#about.panel.panel-default[style=display: ' + (this.about ? 'block' : 'none') + '; left: 140px; position: absolute; width: 500px; z-index: 50]', (0, _mithril2.default)('.panel-body', 'TwoRavens v0.1 \"Dallas\" -- The Norse god Odin had two talking ravens as advisors, who would fly out into the world and report back all they observed. In the Norse, their names were \"Thought\" and \"Memory\". In our coming release, our thought-raven automatically advises on statistical model selection, while our memory-raven accumulates previous statistical models from Dataverse, to provide cummulative guidance and meta-analysis.'))), (0, _mithril2.default)('#main.left.carousel.slide.svg-leftpanel.svg-rightpanel[style=overflow: auto]', (0, _mithril2.default)(\"#innercarousel.carousel-inner\", (0, _mithril2.default)('#m0.item.active', (0, _mithril2.default)('svg#whitespace'))), (0, _mithril2.default)(\"#spacetools.spaceTool[style=z-index: 16]\", (0, _mithril2.default)(\"button#btnForce.btn.btn-default[title=Pin the variable pebbles to the page.]\", {\n        onclick: app.forceSwitch }, (0, _mithril2.default)(\"span.glyphicon.glyphicon-pushpin\")), (0, _mithril2.default)(\"button#btnEraser.btn.btn-default[title=Wipe all variables from the modeling space.]\", {\n        onclick: app.erase }, (0, _mithril2.default)(\"span.glyphicon.glyphicon-magnet\"))), (0, _mithril2.default)(_Subpanel2.default, {\n        title: \"Legend\",\n        buttons: [['timeButton', 'ztime', 'Time'], ['csButton', 'zcross', 'Cross Sec'], ['dvButton', 'zdv', 'Dep Var'], ['nomButton', 'znom', 'Nom Var']] }), (0, _mithril2.default)(_Subpanel2.default, { title: \"History\" }), (0, _mithril2.default)('#ticker[style=background: #F9F9F9; bottom: 0; height: 40px; position: fixed; width: 100%; border-top: 1px solid #ADADAD]', (0, _mithril2.default)(\"a#logID[href=somelink][target=_blank]\", \"Replication\")), leftpanel(), rightpanel()));\n    }\n  }]);\n\n  return Body;\n}();\n\n_mithril2.default.route(document.body, '/model', {\n  '/model': Body,\n  '/explore': Body\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvYXBwL2luZGV4LmpzPzMzYmUiXSwibmFtZXMiOlsiYXBwIiwicGxvdHMiLCJvciIsInNpZGUiLCJ2YWwiLCJ5IiwibiIsImxlZnRwYW5lbCIsInRpdGxlIiwib25jbGljayIsInRhYkxlZnQiLCJzdHlsZSIsInN1YnNldCIsInN1YnNldFNlbGVjdCIsInBsYWNlaG9sZGVyIiwidmFsdWVLZXkiLCJtYXAiLCJ2IiwiaSIsInJlcGxhY2UiLCJ6cGFyYW1zIiwiemR2IiwiaW5jbHVkZXMiLCJoZXhUb1JnYmEiLCJkdkNvbG9yIiwiem5vbSIsIm5vbUNvbG9yIiwibm9kZXMiLCJuYW1lIiwic2VsVmFyQ29sb3IiLCJ2YXJDb2xvciIsImNsaWNrVmFyIiwib25tb3VzZW92ZXIiLCIkIiwicG9wb3ZlciIsImFkZENsYXNzIiwib25tb3VzZW91dCIsInBvcG92ZXJDb250ZW50IiwiZmluZE5vZGVJbmRleCIsInN1bW1hcnkiLCJsYWJsIiwiZGF0YSIsInRyIiwidGQiLCJyaWdodHBhbmVsIiwiYnV0dG9uIiwiaWQiLCJ3aWR0aCIsInRleHQiLCJ0YWJSaWdodCIsIkJvZHkiLCJhYm91dCIsImNpdGUiLCJjaXRlSGlkZGVuIiwiZXh0cmFjdCIsImtleSIsIm9mZnNldCIsImxvYyIsIndpbmRvdyIsImxvY2F0aW9uIiwidG9TdHJpbmciLCJpbmRleE9mIiwic3Vic3RyaW5nIiwiaWR4IiwiY29uc29sZSIsImxvZyIsIm1haW4iLCJlc3RpbWF0ZSIsInJlc2V0IiwiZm9yY2VTd2l0Y2giLCJlcmFzZSIsImJ1dHRvbnMiLCJyb3V0ZSIsImRvY3VtZW50IiwiYm9keSJdLCJtYXBwaW5ncyI6Ijs7OztBQUFBOztBQUNBOztBQUNBOztBQUVBOzs7O0FBRUE7O0lBQVlBLEc7O0FBQ1o7O0lBQVlDLEs7O0FBQ1o7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7O0FBRUEsSUFBSUMsS0FBSyxTQUFMQSxFQUFLLENBQVNDLElBQVQsRUFBZUMsR0FB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RUFDRSx1QkFBRSxhQUFGLEVBQ0UsK2FBREYsQ0FERixDQTVCRixDQURGLEVBZ0NFLHVHQUNFLHVCQUFFLCtCQUFGLEVBQ0UsdUJBQUUsaUJBQUYsRUFDRSx1QkFBRSxnQkFBRixDQURGLENBREYsQ0FERixFQUlFLHVCQUFFLDBDQUFGLEVBQ0UsdUJBQUUsOEVBQUYsRUFBa0Y7QUFDaEYxQyxpQkFBU1QsSUFBSXFFLFdBRG1FLEVBQWxGLEVBRUUsdUJBQUUsa0NBQUYsQ0FGRixDQURGLEVBSUUsdUJBQUUscUZBQUYsRUFBeUY7QUFDdkY1RCxpQkFBU1QsSUFBSXNFLEtBRDBFLEVBQXpGLEVBRUUsdUJBQUUsaUNBQUYsQ0FGRixDQUpGLENBSkYsRUFXRSwyQ0FBWTtBQUNWOUQsZUFBTyxRQURHO0FBRVYrRCxpQkFBUyxDQUNQLENBQUMsWUFBRCxFQUFlLE9BQWYsRUFBd0IsTUFBeEIsQ0FETyxFQUVQLENBQUMsVUFBRCxFQUFhLFFBQWIsRUFBdUIsV0FBdkIsQ0FGTyxFQUdQLENBQUMsVUFBRCxFQUFhLEtBQWIsRUFBb0IsU0FBcEIsQ0FITyxFQUlQLENBQUMsV0FBRCxFQUFjLE1BQWQsRUFBc0IsU0FBdEIsQ0FKTyxDQUZDLEVBQVosQ0FYRixFQWtCRSwyQ0FBWSxFQUFDL0QsT0FBTyxTQUFSLEVBQVosQ0FsQkYsRUFtQkUsdUJBQUUsMEhBQUYsRUFDRSx1QkFBRSx1Q0FBRixFQUEyQyxhQUEzQyxDQURGLENBbkJGLEVBcUJFRCxXQXJCRixFQXNCRXFDLFlBdEJGLENBaENGLENBQVA7QUF1REg7Ozs7OztBQUdMLGtCQUFFNEIsS0FBRixDQUFRQyxTQUFTQyxJQUFqQixFQUF1QixRQUF2QixFQUFpQztBQUM3QixZQUFVeEIsSUFEbUI7QUFFN0IsY0FBWUE7QUFGaUIsQ0FBakMiLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJy4uL3BrZ3MvYm9vdHN0cmFwL2Nzcy9ib290c3RyYXAtdGhlbWUubWluLmNzcyc7XG5pbXBvcnQgJy4uL2Nzcy9hcHAuY3NzJztcbmltcG9ydCAnLi4vcGtncy9MYWRkYS9kaXN0L2xhZGRhLXRoZW1lbGVzcy5taW4uY3NzJztcblxuaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCc7XG5cbmltcG9ydCAqIGFzIGFwcCBmcm9tICcuL2FwcCc7XG5pbXBvcnQgKiBhcyBwbG90cyBmcm9tICcuL3Bsb3RzJztcbmltcG9ydCBQYW5lbCwge2dldENsYXNzfSBmcm9tICcuL3ZpZXdzL1BhbmVsJztcbmltcG9ydCBTZWFyY2gsIHtzZWFyY2hJbmRleH0gZnJvbSAnLi92aWV3cy9TZWFyY2gnO1xuaW1wb3J0IFN1YnBhbmVsIGZyb20gJy4vdmlld3MvU3VicGFuZWwnO1xuXG5sZXQgb3IgPSBmdW5jdGlvbihzaWRlLCB2YWwsIHk9J2Jsb2NrJywgbj0nbm9uZScpIHtcbiAgICByZXR1cm4gYXBwW3NpZGUgKyAndGFiJ10gPT09IHZhbCA/IHkgOiBuO1xufTtcblxubGV0IGxlZnRwYW5lbCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBtKFBhbmVsLCB7c2lkZTogJ2xlZnQnLCB0aXRsZTogJ0RhdGEgU2VsZWN0aW9uJ30sXG4gICAgICAgICAgICAgbShcIi5idG4tdG9vbGJhcltyb2xlPXRvb2xiYXJdW3N0eWxlPW1hcmdpbi1sZWZ0OiAuNWVtOyBtYXJnaW4tdG9wOiAuNWVtXVwiLFxuICAgICAgICAgICAgICAgbShcIi5idG4tZ3JvdXBcIixcbiAgICAgICAgICAgICAgICAgbShgYnV0dG9uI2J0blZhcmlhYmxlcy5idG4uJHtvcignbGVmdCcsICd0YWIxJywgJ2FjdGl2ZScsICdidG4tZGVmYXVsdCcpfVt0eXBlPWJ1dHRvbl1gLCB7XG4gICAgICAgICAgICAgICAgICAgdGl0bGU6ICdDbGljayB2YXJpYWJsZSBuYW1lIHRvIGFkZCBvciByZW1vdmUgdGhlIHZhcmlhYmxlIHBlYmJsZSBmcm9tIHRoZSBtb2RlbGluZyBzcGFjZS4nLFxuICAgICAgICAgICAgICAgICAgIG9uY2xpY2s6IF8gPT4gYXBwLnRhYkxlZnQoJ3RhYjEnKX0sXG4gICAgICAgICAgICAgICAgICAgXCJWYXJpYWJsZXNcIiksXG4gICAgICAgICAgICAgICAgIG0oYGJ1dHRvbiNidG5TdWJzZXQuYnRuLiR7b3IoJ2xlZnQnLCAndGFiMicsICdhY3RpdmUnLCAnYnRuLWRlZmF1bHQnKX1bdHlwZT1idXR0b25dYCwge1xuICAgICAgICAgICAgICAgICAgIG9uY2xpY2s6IF8gPT4gYXBwLnRhYkxlZnQoJ3RhYjInKX0sXG4gICAgICAgICAgICAgICAgICAgXCJTdWJzZXRcIikpLFxuICAgICAgICAgICAgICAgbShcImJ1dHRvbiNidG5TZWxlY3QuYnRuLmJ0bi1kZWZhdWx0LmxhZGRhLWJ1dHRvbltkYXRhLXNwaW5uZXItY29sb3I9IzAwMDAwMF1bZGF0YS1zdHlsZT16b29tLWluXVt0eXBlPWJ1dHRvbl1cIiwge1xuICAgICAgICAgICAgICAgICBzdHlsZTogYGRpc3BsYXk6ICR7YXBwLnN1YnNldCA/ICdibG9jaycgOiAnbm9uZSd9OyBmbG9hdDogcmlnaHQ7IG1hcmdpbi1yaWdodDogMTBweGAsXG4gICAgICAgICAgICAgICAgIG9uY2xpY2s6IF8gPT4gYXBwLnN1YnNldFNlbGVjdCgnYnRuU2VsZWN0JyksXG4gICAgICAgICAgICAgICAgIHRpdGxlOiAnU3Vic2V0IGRhdGEgYnkgdGhlIGludGVyc2VjdGlvbiBvZiBhbGwgc2VsZWN0ZWQgdmFsdWVzLid9LFxuICAgICAgICAgICAgICAgICBtKFwic3Bhbi5sYWRkYS1sYWJlbFtzdHlsZT1wb2ludGVyLWV2ZW50czogbm9uZV1cIiwgXCJTZWxlY3RcIikpKSxcbiAgICAgICAgICAgICBtKCcucm93LWZsdWlkJyArIGdldENsYXNzKHtzaWRlOiAnbGVmdCd9KSxcbiAgICAgICAgICAgICAgIG0oJyNsZWZ0cGFuZWxjb250ZW50JyxcbiAgICAgICAgICAgICAgICAgbSgnI2xlZnRDb250ZW50QXJlYVtzdHlsZT1oZWlnaHQ6IDQ1M3B4OyBvdmVyZmxvdzogYXV0b10nLFxuICAgICAgICAgICAgICAgICAgIG0oYCN0YWIxW3N0eWxlPWRpc3BsYXk6ICR7b3IoJ2xlZnQnLCAndGFiMScpfTsgcGFkZGluZzogMTBweCA4cHg7IHRleHQtYWxpZ246IGNlbnRlcl1gLFxuICAgICAgICAgICAgICAgICAgICAgbShTZWFyY2gsIHtwbGFjZWhvbGRlcjogJ1NlYXJjaCB2YXJpYWJsZXMgYW5kIGxhYmVscyd9KSxcbiAgICAgICAgICAgICAgICAgICAgIG0oJyN2YXJMaXN0W3N0eWxlPWRpc3BsYXk6IGJsb2NrXScsIGFwcC52YWx1ZUtleS5tYXAoKHYsIGkpID0+XG4gICAgICAgICAgICAgICAgICAgICAgIG0oYHAjJHt2LnJlcGxhY2UoL1xcVy9nLCAnXycpfWAsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2JhY2tncm91bmQtY29sb3InOiBhcHAuenBhcmFtcy56ZHYuaW5jbHVkZXModikgPyBhcHAuaGV4VG9SZ2JhKGFwcC5kdkNvbG9yKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHAuenBhcmFtcy56bm9tLmluY2x1ZGVzKHYpID8gYXBwLmhleFRvUmdiYShhcHAubm9tQ29sb3IpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcC5ub2Rlcy5tYXAobiA9PiBuLm5hbWUpLmluY2x1ZGVzKHYpID8gYXBwLmhleFRvUmdiYShwbG90cy5zZWxWYXJDb2xvcikgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwLnZhckNvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2JvcmRlci1jb2xvcic6ICcjMDAwMDAwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICdib3JkZXItc3R5bGUnOiBzZWFyY2hJbmRleCAmJiBpIDwgc2VhcmNoSW5kZXggPyAnc29saWQnIDogJ25vbmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgb25jbGljazogYXBwLmNsaWNrVmFyLFxuICAgICAgICAgICAgICAgICAgICAgICAgIG9ubW91c2VvdmVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICQodGhpcykucG9wb3Zlcignc2hvdycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgJChcImJvZHkgZGl2LnBvcG92ZXJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhcInZhcmlhYmxlc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICQoXCJib2R5IGRpdi5wb3BvdmVyIGRpdi5wb3BvdmVyLWNvbnRlbnRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhcImZvcm0taG9yaXpvbnRhbFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgIG9ubW91c2VvdXQ6IFwiJCh0aGlzKS5wb3BvdmVyKCdoaWRlJyk7XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEtY29udGFpbmVyJzogJ2JvZHknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhLWNvbnRlbnQnOiBhcHAucG9wb3ZlckNvbnRlbnQoYXBwLmZpbmROb2RlSW5kZXgodiwgdHJ1ZSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhLWh0bWwnOiAndHJ1ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEtb3JpZ2luYWwtdGl0bGUnOiAnU3VtbWFyeSBTdGF0aXN0aWNzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAnZGF0YS1wbGFjZW1lbnQnOiAncmlnaHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhLXRvZ2dsZSc6ICdwb3BvdmVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAnZGF0YS10cmlnZ2VyJzogJ2hvdmVyJ30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgdikpKSksXG4gICAgICAgICAgICAgICAgICAgbShgI3RhYjJbc3R5bGU9ZGlzcGxheTogJHtvcignbGVmdCcsICd0YWIyJyl9OyBtYXJnaW4tdG9wOiAuNWVtXWApLFxuICAgICAgICAgICAgICAgICAgIG0oJyN0YWIzW3N0eWxlPWhlaWdodDogMzUwcHhdJyxcbiAgICAgICAgICAgICAgICAgICAgIG0oYHBbc3R5bGU9cGFkZGluZzogLjVlbSAxZW07IGRpc3BsYXk6ICR7b3IoJ2xlZnQnLCAndGFiMycpfV1gLCB7XG4gICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcIlNlbGVjdCBhIHZhcmlhYmxlIGZyb20gd2l0aGluIHRoZSB2aXN1YWxpemF0aW9uIGluIHRoZSBjZW50ZXIgcGFuZWwgdG8gdmlldyBpdHMgc3VtbWFyeSBzdGF0aXN0aWNzLlwifSxcbiAgICAgICAgICAgICAgICAgICAgICAgbSgnY2VudGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICBtKCdiJywgYXBwLnN1bW1hcnkubmFtZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgbSgnYnInKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICBtKCdpJywgYXBwLnN1bW1hcnkubGFibCkpLFxuICAgICAgICAgICAgICAgICAgICAgICBtKCd0YWJsZScsIGFwcC5zdW1tYXJ5LmRhdGEubWFwKFxuICAgICAgICAgICAgICAgICAgICAgICAgIHRyID0+IG0oJ3RyJywgdHIubWFwKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdGQgPT4gbSgndGQnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ubW91c2VvdmVyOiBmdW5jdGlvbigpIHt0aGlzLnN0eWxlWydiYWNrZ3JvdW5kLWNvbG9yJ10gPSAnYWxpY2VibHVlJ30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ubW91c2VvdXQ6IGZ1bmN0aW9uKCkge3RoaXMuc3R5bGVbJ2JhY2tncm91bmQtY29sb3InXSA9ICcjZjlmOWY5J319LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZCkpKSkpKSkpKSkpO1xufTtcblxubGV0IHJpZ2h0cGFuZWwgPSBmdW5jdGlvbigpIHtcbiAgICBsZXQgYnV0dG9uID0gKGlkLCB3aWR0aCwgdGV4dCkgPT5cbiAgICAgICAgbShgYnV0dG9uIyR7aWR9LmJ0bi4ke29yKCdyaWdodCcsIGlkLCAnYWN0aXZlJywgJ2J0bi1kZWZhdWx0Jyl9W3R5cGU9YnV0dG9uXVtzdHlsZT13aWR0aDogJHt3aWR0aH1dYCwge1xuICAgICAgICAgIG9uY2xpY2s6IF8gPT4gYXBwLnRhYlJpZ2h0KGlkKX0sXG4gICAgICAgICAgdGV4dCk7XG4gICAgcmV0dXJuIG0oUGFuZWwsIHtzaWRlOiAncmlnaHQnLCB0aXRsZTogJ01vZGVsIFNlbGVjdGlvbid9LFxuICAgICAgICAgICAgIG0oXCIuYnRuLWdyb3VwLmJ0bi1ncm91cC1qdXN0aWZpZWRbYXJpYS1sYWJlbD0uLi5dW3JvbGU9Z3JvdXBdW3N0eWxlPW1hcmdpbi10b3A6IC41ZW1dXCIsXG4gICAgICAgICAgICAgICBidXR0b24oJ2J0bk1vZGVscycsIFwiMzMlXCIsIFwiTW9kZWxzXCIpLFxuICAgICAgICAgICAgICAgYnV0dG9uKCdidG5TZXR4JywgXCIzNCVcIiwgXCJTZXQgQ292YXIuXCIpLFxuICAgICAgICAgICAgICAgYnV0dG9uKCdidG5SZXN1bHRzJywgXCIzMyVcIiwgXCJSZXN1bHRzXCIpKSxcbiAgICAgICAgICAgICBtKCcucm93LWZsdWlkJyArIGdldENsYXNzKHtzaWRlOiAncmlnaHQnfSksXG4gICAgICAgICAgICAgICBtKCcjcmlnaHRwYW5lbGNvbnRlbnQnLFxuICAgICAgICAgICAgICAgICBtKCcjcmlnaHRDb250ZW50QXJlYVtzdHlsZT1oZWlnaHQ6IDQ1M3B4OyBvdmVyZmxvdzogYXV0b10nLFxuICAgICAgICAgICAgICAgICAgIG0oYCNyZXN1bHRzW3N0eWxlPWRpc3BsYXk6ICR7b3IoJ3JpZ2h0JywgJ2J0blJlc3VsdHMnKX07IG1hcmdpbi10b3A6IC41ZW1dYCxcbiAgICAgICAgICAgICAgICAgICAgIG0oXCIjcmVzdWx0c1ZpZXcuY29udGFpbmVyW3N0eWxlPWZsb2F0OiByaWdodDsgb3ZlcmZsb3c6IGF1dG87IHdpZHRoOiA4MCU7IGJhY2tncm91bmQtY29sb3I6IHdoaXRlOyB3aGl0ZS1zcGFjZTogbm93cmFwXVwiKSxcbiAgICAgICAgICAgICAgICAgICAgIG0oJyNtb2RlbFZpZXdbc3R5bGU9ZGlzcGxheTogbm9uZTsgZmxvYXQ6IGxlZnQ7IHdpZHRoOiAyMCU7IGJhY2tncm91bmQtY29sb3I6IHdoaXRlXScpLFxuICAgICAgICAgICAgICAgICAgICAgbShcInAjcmVzdWx0c0hvbGRlcltzdHlsZT1wYWRkaW5nOiAuNWVtIDFlbV1cIikpLFxuICAgICAgICAgICAgICAgICAgIG0oYCNzZXR4W3N0eWxlPWRpc3BsYXk6ICR7b3IoJ3JpZ2h0JywgJ2J0blNldHgnKX1dYCksXG4gICAgICAgICAgICAgICAgICAgbShgI21vZGVsc1tzdHlsZT1kaXNwbGF5OiAke29yKCdyaWdodCcsICdidG5Nb2RlbHMnKX07IHBhZGRpbmc6IDZweCAxMnB4OyB0ZXh0LWFsaWduOiBjZW50ZXJdYCkpKSkpO1xufTtcblxuY2xhc3MgQm9keSB7XG4gICAgb25pbml0KCkge1xuICAgICAgICB0aGlzLmFib3V0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2l0ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNpdGVIaWRkZW4gPSBmYWxzZTtcbiAgICB9XG5cbiAgICBvbmNyZWF0ZSgpIHtcbiAgICAgICAgbGV0IGV4dHJhY3QgPSAobmFtZSwga2V5LCBvZmZzZXQsIHJlcGxhY2UpID0+IHtcbiAgICAgICAgICAgIGtleSA9IGtleSArICc9JztcbiAgICAgICAgICAgIGxldCBsb2MgPSB3aW5kb3cubG9jYXRpb24udG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGxldCB2YWwgPSBsb2MuaW5kZXhPZihrZXkpID4gMCA/IGxvYy5zdWJzdHJpbmcobG9jLmluZGV4T2Yoa2V5KSArIG9mZnNldCkgOiAnJztcbiAgICAgICAgICAgIGxldCBpZHggPSB2YWwuaW5kZXhPZignJicpO1xuICAgICAgICAgICAgdmFsID0gaWR4ID4gMCA/IHZhbC5zdWJzdHJpbmcoMCwgaWR4KSA6IHZhbDtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG5hbWUsICc6ICcsIHZhbCk7XG4gICAgICAgICAgICBpZiAocmVwbGFjZSkgdmFsID0gdmFsXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoLyUyNS9nLCAnJScpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoLyUzQS9nLCAnOicpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoLyUyRi9nLCAnLycpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gbGV0IGFwaWtleSA9IGV4dHJhY3QoJ2FwaWtleScsICdrZXknLCA0KTtcbiAgICAgICAgYXBwLm1haW4oXG4gICAgICAgICAgICBleHRyYWN0KCdmaWxlaWQnLCAnZGZJZCcsIDUpLFxuICAgICAgICAgICAgZXh0cmFjdCgnaG9zdG5hbWUnLCAnaG9zdCcsIDUpLFxuICAgICAgICAgICAgZXh0cmFjdCgnZGRpdXJsJywgJ2RkaXVybCcsIDcsIHRydWUpLFxuICAgICAgICAgICAgZXh0cmFjdCgnZGF0YXVybCcsICdkYXRhdXJsJywgOCwgdHJ1ZSkpO1xuICAgIH1cblxuICAgIHZpZXcoKSB7XG4gICAgICAgIHJldHVybiBtKCdtYWluJyxcbiAgICAgICAgICAgICAgICAgbShcIm5hdiNuYXZiYXIubmF2YmFyLm5hdmJhci1kZWZhdWx0Lm5hdmJhci1maXhlZC10b3Bbcm9sZT1uYXZpZ2F0aW9uXVwiLFxuICAgICAgICAgICAgICAgICAgIG0oXCJhLm5hdmJhci1icmFuZFtzdHlsZT1tYXJnaW4tbGVmdDogMF1cIixcbiAgICAgICAgICAgICAgICAgICAgIG0oXCJpbWdbc3JjPS9zdGF0aWMvaW1hZ2VzL1R3b1JhdmVucy5wbmddW2FsdD1Ud29SYXZlbnNdW3dpZHRoPTEwMF1bc3R5bGU9bWFyZ2luLWxlZnQ6IDJlbTsgbWFyZ2luLXRvcDogLTAuNWVtXVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgIG9ubW91c2VvdmVyOiBfID0+IHRoaXMuYWJvdXQgPSB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICBvbm1vdXNlb3V0OiBfID0+IHRoaXMuYWJvdXQgPSBmYWxzZX0pKSxcbiAgICAgICAgICAgICAgICAgICBtKCcjbmF2YmFyTmF2W3N0eWxlPXBhZGRpbmc6IDAuNWVtXScsXG4gICAgICAgICAgICAgICAgICAgICBtKCcjZGF0YUZpZWxkLmZpZWxkW3N0eWxlPW1hcmdpbi10b3A6IDAuNWVtOyB0ZXh0LWFsaWduOiBjZW50ZXJdJyxcbiAgICAgICAgICAgICAgICAgICAgICAgbSgnaDQjZGF0YU5hbWVbc3R5bGU9ZGlzcGxheTogaW5saW5lXScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICBvbmNsaWNrOiBfID0+IHRoaXMuY2l0ZSA9IHRoaXMuY2l0ZUhpZGRlbiA9ICF0aGlzLmNpdGVIaWRkZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgb25tb3VzZW91dDogXyA9PiB0aGlzLmNpdGVIaWRkZW4gfHwgKHRoaXMuY2l0ZSA9IGZhbHNlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICBvbm1vdXNlb3ZlcjogXyA9PiB0aGlzLmNpdGUgPSB0cnVlfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICBcIkRhdGFzZXQgTmFtZVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgbShgI2NpdGUucGFuZWwucGFuZWwtZGVmYXVsdFtzdHlsZT1kaXNwbGF5OiAke3RoaXMuY2l0ZSA/ICdibG9jaycgOiAnbm9uZSd9OyBwb3NpdGlvbjogYWJzb2x1dGU7IHJpZ2h0OiA1MCU7IHdpZHRoOiAzODBweDsgdGV4dC1hbGlnbjogbGVmdDsgei1pbmRleDogNTBdYCxcbiAgICAgICAgICAgICAgICAgICAgICAgICBtKFwiLnBhbmVsLWJvZHlcIikpLFxuICAgICAgICAgICAgICAgICAgICAgICBtKFwiYnV0dG9uI2J0bkVzdGltYXRlLmJ0bi5idG4tZGVmYXVsdC5sYWRkYS1idXR0b24ubmF2YmFyLXJpZ2h0W2RhdGEtc3Bpbm5lci1jb2xvcj0jMDAwMDAwXVtkYXRhLXN0eWxlPXpvb20taW5dW3N0eWxlPW1hcmdpbi1sZWZ0OiAyZW07IG1hcmdpbi1yaWdodDogMWVtXVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgb25jbGljazogXyA9PiBhcHAuZXN0aW1hdGUoJ2J0bkVzdGltYXRlJyl9LFxuICAgICAgICAgICAgICAgICAgICAgICAgIG0oXCJzcGFuLmxhZGRhLWxhYmVsXCIsIFwiRXN0aW1hdGVcIikpLFxuICAgICAgICAgICAgICAgICAgICAgICBtKFwiYnV0dG9uI2J0blJlc2V0LmJ0bi5idG4tZGVmYXVsdC5uYXZiYXItcmlnaHRbdGl0bGU9UmVzZXRdW3N0eWxlPW1hcmdpbi1sZWZ0OiAyLjBlbV1cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgIG9uY2xpY2s6IGFwcC5yZXNldH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgbShcInNwYW4uZ2x5cGhpY29uLmdseXBoaWNvbi1yZXBlYXRbc3R5bGU9Y29sb3I6ICM4MTgxODE7IGZvbnQtc2l6ZTogMWVtOyBwb2ludGVyLWV2ZW50czogbm9uZV1cIikpLFxuICAgICAgICAgICAgICAgICAgICAgICBtKCcjdHJhbnNmb3JtYXRpb25zLnRyYW5zZm9ybVRvb2wnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICdDb25zdHJ1Y3QgdHJhbnNmb3JtYXRpb25zIG9mIGV4aXN0aW5nIHZhcmlhYmxlcyB1c2luZyB2YWxpZCBSIHN5bnRheC4gRm9yIGV4YW1wbGUsIGFzc3VtaW5nIGEgdmFyaWFibGUgbmFtZWQgZCwgeW91IGNhbiBlbnRlciBcImxvZyhkKVwiIG9yIFwiZF4yXCIuJ30pKSksXG4gICAgICAgICAgICAgICAgICAgLyptKCcudGV4dC1jZW50ZXInLCB7XG4gICAgICAgICAgICAgICAgICAgICBzdHlsZToge21hcmdpbjogJzVweCd9XG4gICAgICAgICAgICAgICAgICAgICB9LCBtKFwiLmJ0bi1ncm91cFwiLCBbXG4gICAgICAgICAgICAgICAgICAgICBtKGBhLmJ0bi5idG4tZGVmYXVsdCR7bG9jYXRpb24uaHJlZi5lbmRzV2l0aCgnbW9kZWwnKSA/ICcuYWN0aXZlJyA6ICcnfVtocmVmPS9tb2RlbF1bcm9sZT1idXR0b25dYCwge29uY3JlYXRlOiBtLnJvdXRlLmxpbmt9LCBcIk1vZGVsXCIpLFxuICAgICAgICAgICAgICAgICAgICAgbShgYS5idG4uYnRuLWRlZmF1bHQke2xvY2F0aW9uLmhyZWYuZW5kc1dpdGgoJ2V4cGxvcmUnKSA/ICcuYWN0aXZlJyA6ICcnfVtocmVmPS9leHBsb3JlXVtyb2xlPWJ1dHRvbl1gLCB7b25jcmVhdGU6IG0ucm91dGUubGlua30sIFwiRXhwbG9yZVwiKVxuICAgICAgICAgICAgICAgICAgICAgXSkpKi9cbiAgICAgICAgICAgICAgICAgICBtKGAjYWJvdXQucGFuZWwucGFuZWwtZGVmYXVsdFtzdHlsZT1kaXNwbGF5OiAke3RoaXMuYWJvdXQgPyAnYmxvY2snIDogJ25vbmUnfTsgbGVmdDogMTQwcHg7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgd2lkdGg6IDUwMHB4OyB6LWluZGV4OiA1MF1gLFxuICAgICAgICAgICAgICAgICAgICAgbSgnLnBhbmVsLWJvZHknLFxuICAgICAgICAgICAgICAgICAgICAgICAnVHdvUmF2ZW5zIHYwLjEgXCJEYWxsYXNcIiAtLSBUaGUgTm9yc2UgZ29kIE9kaW4gaGFkIHR3byB0YWxraW5nIHJhdmVucyBhcyBhZHZpc29ycywgd2hvIHdvdWxkIGZseSBvdXQgaW50byB0aGUgd29ybGQgYW5kIHJlcG9ydCBiYWNrIGFsbCB0aGV5IG9ic2VydmVkLiBJbiB0aGUgTm9yc2UsIHRoZWlyIG5hbWVzIHdlcmUgXCJUaG91Z2h0XCIgYW5kIFwiTWVtb3J5XCIuIEluIG91ciBjb21pbmcgcmVsZWFzZSwgb3VyIHRob3VnaHQtcmF2ZW4gYXV0b21hdGljYWxseSBhZHZpc2VzIG9uIHN0YXRpc3RpY2FsIG1vZGVsIHNlbGVjdGlvbiwgd2hpbGUgb3VyIG1lbW9yeS1yYXZlbiBhY2N1bXVsYXRlcyBwcmV2aW91cyBzdGF0aXN0aWNhbCBtb2RlbHMgZnJvbSBEYXRhdmVyc2UsIHRvIHByb3ZpZGUgY3VtbXVsYXRpdmUgZ3VpZGFuY2UgYW5kIG1ldGEtYW5hbHlzaXMuJykpKSxcbiAgICAgICAgICAgICAgICAgbShgI21haW4ubGVmdC5jYXJvdXNlbC5zbGlkZS5zdmctbGVmdHBhbmVsLnN2Zy1yaWdodHBhbmVsW3N0eWxlPW92ZXJmbG93OiBhdXRvXWAsXG4gICAgICAgICAgICAgICAgICAgbShcIiNpbm5lcmNhcm91c2VsLmNhcm91c2VsLWlubmVyXCIsXG4gICAgICAgICAgICAgICAgICAgICBtKCcjbTAuaXRlbS5hY3RpdmUnLFxuICAgICAgICAgICAgICAgICAgICAgICBtKCdzdmcjd2hpdGVzcGFjZScpKSksXG4gICAgICAgICAgICAgICAgICAgbShcIiNzcGFjZXRvb2xzLnNwYWNlVG9vbFtzdHlsZT16LWluZGV4OiAxNl1cIixcbiAgICAgICAgICAgICAgICAgICAgIG0oXCJidXR0b24jYnRuRm9yY2UuYnRuLmJ0bi1kZWZhdWx0W3RpdGxlPVBpbiB0aGUgdmFyaWFibGUgcGViYmxlcyB0byB0aGUgcGFnZS5dXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgb25jbGljazogYXBwLmZvcmNlU3dpdGNofSxcbiAgICAgICAgICAgICAgICAgICAgICAgbShcInNwYW4uZ2x5cGhpY29uLmdseXBoaWNvbi1wdXNocGluXCIpKSxcbiAgICAgICAgICAgICAgICAgICAgIG0oXCJidXR0b24jYnRuRXJhc2VyLmJ0bi5idG4tZGVmYXVsdFt0aXRsZT1XaXBlIGFsbCB2YXJpYWJsZXMgZnJvbSB0aGUgbW9kZWxpbmcgc3BhY2UuXVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgIG9uY2xpY2s6IGFwcC5lcmFzZX0sXG4gICAgICAgICAgICAgICAgICAgICAgIG0oXCJzcGFuLmdseXBoaWNvbi5nbHlwaGljb24tbWFnbmV0XCIpKSksXG4gICAgICAgICAgICAgICAgICAgbShTdWJwYW5lbCwge1xuICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFwiTGVnZW5kXCIsXG4gICAgICAgICAgICAgICAgICAgICBidXR0b25zOiBbXG4gICAgICAgICAgICAgICAgICAgICAgIFsndGltZUJ1dHRvbicsICd6dGltZScsICdUaW1lJ10sXG4gICAgICAgICAgICAgICAgICAgICAgIFsnY3NCdXR0b24nLCAnemNyb3NzJywgJ0Nyb3NzIFNlYyddLFxuICAgICAgICAgICAgICAgICAgICAgICBbJ2R2QnV0dG9uJywgJ3pkdicsICdEZXAgVmFyJ10sXG4gICAgICAgICAgICAgICAgICAgICAgIFsnbm9tQnV0dG9uJywgJ3pub20nLCAnTm9tIFZhciddXX0pLFxuICAgICAgICAgICAgICAgICAgIG0oU3VicGFuZWwsIHt0aXRsZTogXCJIaXN0b3J5XCJ9KSxcbiAgICAgICAgICAgICAgICAgICBtKCcjdGlja2VyW3N0eWxlPWJhY2tncm91bmQ6ICNGOUY5Rjk7IGJvdHRvbTogMDsgaGVpZ2h0OiA0MHB4OyBwb3NpdGlvbjogZml4ZWQ7IHdpZHRoOiAxMDAlOyBib3JkZXItdG9wOiAxcHggc29saWQgI0FEQURBRF0nLFxuICAgICAgICAgICAgICAgICAgICAgbShcImEjbG9nSURbaHJlZj1zb21lbGlua11bdGFyZ2V0PV9ibGFua11cIiwgXCJSZXBsaWNhdGlvblwiKSksXG4gICAgICAgICAgICAgICAgICAgbGVmdHBhbmVsKCksXG4gICAgICAgICAgICAgICAgICAgcmlnaHRwYW5lbCgpKSk7XG4gICAgfVxufVxuXG5tLnJvdXRlKGRvY3VtZW50LmJvZHksICcvbW9kZWwnLCB7XG4gICAgJy9tb2RlbCc6IEJvZHksXG4gICAgJy9leHBsb3JlJzogQm9keVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9hc3NldHMvYXBwL2luZGV4LmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///10\n")},function(module,exports){eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2Nlc3MvYnJvd3Nlci5qcz84MmU0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVUiLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Byb2Nlc3MvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///11\n")},function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    "use strict";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== "function") {\n        callback = new Function("" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."\n        // So if we\'re currently running a task, we\'ll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // "too much recursion" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can\'t be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage("", "*");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = "setImmediate$" + Math.random() + "$";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === "string" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener("message", onGlobalMessage, false);\n        } else {\n            global.attachEvent("onmessage", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, "*");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it\'s been called.\n            var script = doc.createElement("script");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don\'t get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === "[object process]") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && "onreadystatechange" in doc.createElement("script")) {\n        // For IE 68\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3), __webpack_require__(11)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanM/NGE4MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMsc0JBQXNCLEVBQUU7QUFDbEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgdW5kZWZpbmVkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZiAoZ2xvYmFsLnNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5leHRIYW5kbGUgPSAxOyAvLyBTcGVjIHNheXMgZ3JlYXRlciB0aGFuIHplcm9cbiAgICB2YXIgdGFza3NCeUhhbmRsZSA9IHt9O1xuICAgIHZhciBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICB2YXIgZG9jID0gZ2xvYmFsLmRvY3VtZW50O1xuICAgIHZhciByZWdpc3RlckltbWVkaWF0ZTtcblxuICAgIGZ1bmN0aW9uIHNldEltbWVkaWF0ZShjYWxsYmFjaykge1xuICAgICAgLy8gQ2FsbGJhY2sgY2FuIGVpdGhlciBiZSBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBuZXcgRnVuY3Rpb24oXCJcIiArIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIC8vIENvcHkgZnVuY3Rpb24gYXJndW1lbnRzXG4gICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2kgKyAxXTtcbiAgICAgIH1cbiAgICAgIC8vIFN0b3JlIGFuZCByZWdpc3RlciB0aGUgdGFza1xuICAgICAgdmFyIHRhc2sgPSB7IGNhbGxiYWNrOiBjYWxsYmFjaywgYXJnczogYXJncyB9O1xuICAgICAgdGFza3NCeUhhbmRsZVtuZXh0SGFuZGxlXSA9IHRhc2s7XG4gICAgICByZWdpc3RlckltbWVkaWF0ZShuZXh0SGFuZGxlKTtcbiAgICAgIHJldHVybiBuZXh0SGFuZGxlKys7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaGFuZGxlKSB7XG4gICAgICAgIGRlbGV0ZSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuKHRhc2spIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gdGFzay5jYWxsYmFjaztcbiAgICAgICAgdmFyIGFyZ3MgPSB0YXNrLmFyZ3M7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuSWZQcmVzZW50KGhhbmRsZSkge1xuICAgICAgICAvLyBGcm9tIHRoZSBzcGVjOiBcIldhaXQgdW50aWwgYW55IGludm9jYXRpb25zIG9mIHRoaXMgYWxnb3JpdGhtIHN0YXJ0ZWQgYmVmb3JlIHRoaXMgb25lIGhhdmUgY29tcGxldGVkLlwiXG4gICAgICAgIC8vIFNvIGlmIHdlJ3JlIGN1cnJlbnRseSBydW5uaW5nIGEgdGFzaywgd2UnbGwgbmVlZCB0byBkZWxheSB0aGlzIGludm9jYXRpb24uXG4gICAgICAgIGlmIChjdXJyZW50bHlSdW5uaW5nQVRhc2spIHtcbiAgICAgICAgICAgIC8vIERlbGF5IGJ5IGRvaW5nIGEgc2V0VGltZW91dC4gc2V0SW1tZWRpYXRlIHdhcyB0cmllZCBpbnN0ZWFkLCBidXQgaW4gRmlyZWZveCA3IGl0IGdlbmVyYXRlZCBhXG4gICAgICAgICAgICAvLyBcInRvbyBtdWNoIHJlY3Vyc2lvblwiIGVycm9yLlxuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGFzayA9IHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICAgICAgICAgIGlmICh0YXNrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBydW4odGFzayk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbW1lZGlhdGUoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHsgcnVuSWZQcmVzZW50KGhhbmRsZSk7IH0pO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhblVzZVBvc3RNZXNzYWdlKCkge1xuICAgICAgICAvLyBUaGUgdGVzdCBhZ2FpbnN0IGBpbXBvcnRTY3JpcHRzYCBwcmV2ZW50cyB0aGlzIGltcGxlbWVudGF0aW9uIGZyb20gYmVpbmcgaW5zdGFsbGVkIGluc2lkZSBhIHdlYiB3b3JrZXIsXG4gICAgICAgIC8vIHdoZXJlIGBnbG9iYWwucG9zdE1lc3NhZ2VgIG1lYW5zIHNvbWV0aGluZyBjb21wbGV0ZWx5IGRpZmZlcmVudCBhbmQgY2FuJ3QgYmUgdXNlZCBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgICBpZiAoZ2xvYmFsLnBvc3RNZXNzYWdlICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cykge1xuICAgICAgICAgICAgdmFyIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG9sZE9uTWVzc2FnZSA9IGdsb2JhbC5vbm1lc3NhZ2U7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShcIlwiLCBcIipcIik7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gb2xkT25NZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgLy8gSW5zdGFsbHMgYW4gZXZlbnQgaGFuZGxlciBvbiBgZ2xvYmFsYCBmb3IgdGhlIGBtZXNzYWdlYCBldmVudDogc2VlXG4gICAgICAgIC8vICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vRE9NL3dpbmRvdy5wb3N0TWVzc2FnZVxuICAgICAgICAvLyAqIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL2NvbW1zLmh0bWwjY3Jvc3NEb2N1bWVudE1lc3NhZ2VzXG5cbiAgICAgICAgdmFyIG1lc3NhZ2VQcmVmaXggPSBcInNldEltbWVkaWF0ZSRcIiArIE1hdGgucmFuZG9tKCkgKyBcIiRcIjtcbiAgICAgICAgdmFyIG9uR2xvYmFsTWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlID09PSBnbG9iYWwgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZXZlbnQuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEuaW5kZXhPZihtZXNzYWdlUHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudCgrZXZlbnQuZGF0YS5zbGljZShtZXNzYWdlUHJlZml4Lmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFsLmF0dGFjaEV2ZW50KFwib25tZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKG1lc3NhZ2VQcmVmaXggKyBoYW5kbGUsIFwiKlwiKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZShoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBodG1sID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIDxzY3JpcHQ+IGVsZW1lbnQ7IGl0cyByZWFkeXN0YXRlY2hhbmdlIGV2ZW50IHdpbGwgYmUgZmlyZWQgYXN5bmNocm9ub3VzbHkgb25jZSBpdCBpcyBpbnNlcnRlZFxuICAgICAgICAgICAgLy8gaW50byB0aGUgZG9jdW1lbnQuIERvIHNvLCB0aHVzIHF1ZXVpbmcgdXAgdGhlIHRhc2suIFJlbWVtYmVyIHRvIGNsZWFuIHVwIG9uY2UgaXQncyBiZWVuIGNhbGxlZC5cbiAgICAgICAgICAgIHZhciBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaHRtbC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgICAgIHNjcmlwdCA9IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaHRtbC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBJZiBzdXBwb3J0ZWQsIHdlIHNob3VsZCBhdHRhY2ggdG8gdGhlIHByb3RvdHlwZSBvZiBnbG9iYWwsIHNpbmNlIHRoYXQgaXMgd2hlcmUgc2V0VGltZW91dCBldCBhbC4gbGl2ZS5cbiAgICB2YXIgYXR0YWNoVG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGdsb2JhbCk7XG4gICAgYXR0YWNoVG8gPSBhdHRhY2hUbyAmJiBhdHRhY2hUby5zZXRUaW1lb3V0ID8gYXR0YWNoVG8gOiBnbG9iYWw7XG5cbiAgICAvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IGUuZy4gYnJvd3NlcmlmeSBlbnZpcm9ubWVudHMuXG4gICAgaWYgKHt9LnRvU3RyaW5nLmNhbGwoZ2xvYmFsLnByb2Nlc3MpID09PSBcIltvYmplY3QgcHJvY2Vzc11cIikge1xuICAgICAgICAvLyBGb3IgTm9kZS5qcyBiZWZvcmUgMC45XG4gICAgICAgIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGNhblVzZVBvc3RNZXNzYWdlKCkpIHtcbiAgICAgICAgLy8gRm9yIG5vbi1JRTEwIG1vZGVybiBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChnbG9iYWwuTWVzc2FnZUNoYW5uZWwpIHtcbiAgICAgICAgLy8gRm9yIHdlYiB3b3JrZXJzLCB3aGVyZSBzdXBwb3J0ZWRcbiAgICAgICAgaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZG9jICYmIFwib25yZWFkeXN0YXRlY2hhbmdlXCIgaW4gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIikpIHtcbiAgICAgICAgLy8gRm9yIElFIDbigJM4XG4gICAgICAgIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBvbGRlciBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCk7XG4gICAgfVxuXG4gICAgYXR0YWNoVG8uc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlO1xuICAgIGF0dGFjaFRvLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG59KHR5cGVvZiBzZWxmID09PSBcInVuZGVmaW5lZFwiID8gdHlwZW9mIGdsb2JhbCA9PT0gXCJ1bmRlZmluZWRcIiA/IHRoaXMgOiBnbG9iYWwgOiBzZWxmKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///12\n')},function(module,exports,__webpack_require__){eval("var apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(12);\nexports.setImmediate = setImmediate;\nexports.clearImmediate = clearImmediate;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3RpbWVycy1icm93c2VyaWZ5L21haW4uanM/YjA4OCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjEzLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkge1xuICBpZiAodGltZW91dCkge1xuICAgIHRpbWVvdXQuY2xvc2UoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbCh3aW5kb3csIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBzZXRpbW1lZGlhdGUgYXR0YWNoZXMgaXRzZWxmIHRvIHRoZSBnbG9iYWwgb2JqZWN0XG5yZXF1aXJlKFwic2V0aW1tZWRpYXRlXCIpO1xuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qc1xuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///13\n")}]);