!function(Q){function I(B){if(F[B])return F[B].exports;var C=F[B]={i:B,l:!1,exports:{}};return Q[B].call(C.exports,C,C.exports,I),C.l=!0,C.exports}var F={};I.m=Q,I.c=F,I.i=function(Q){return Q},I.d=function(Q,F,B){I.o(Q,F)||Object.defineProperty(Q,F,{configurable:!1,enumerable:!0,get:B})},I.n=function(Q){var F=Q&&Q.__esModule?function(){return Q.default}:function(){return Q};return I.d(F,"a",F),F},I.o=function(Q,I){return Object.prototype.hasOwnProperty.call(Q,I)},I.p="",I(I.s=14)}([function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(setImmediate, global) {;(function() {\n"use strict"\nfunction Vnode(tag, key, attrs0, children, text, dom) {\n\treturn {tag: tag, key: key, attrs: attrs0, children: children, text: text, dom: dom, domSize: undefined, state: undefined, _state: undefined, events: undefined, instance: undefined, skip: false}\n}\nVnode.normalize = function(node) {\n\tif (Array.isArray(node)) return Vnode("[", undefined, undefined, Vnode.normalizeChildren(node), undefined, undefined)\n\tif (node != null && typeof node !== "object") return Vnode("#", undefined, undefined, node === false ? "" : node, undefined, undefined)\n\treturn node\n}\nVnode.normalizeChildren = function normalizeChildren(children) {\n\tfor (var i = 0; i < children.length; i++) {\n\t\tchildren[i] = Vnode.normalize(children[i])\n\t}\n\treturn children\n}\nvar selectorParser = /(?:(^|#|\\.)([^#\\.\\[\\]]+))|(\\[(.+?)(?:\\s*=\\s*("|\'|)((?:\\\\["\'\\]]|.)*?)\\5)?\\])/g\nvar selectorCache = {}\nvar hasOwn = {}.hasOwnProperty\nfunction compileSelector(selector) {\n\tvar match, tag = "div", classes = [], attrs = {}\n\twhile (match = selectorParser.exec(selector)) {\n\t\tvar type = match[1], value = match[2]\n\t\tif (type === "" && value !== "") tag = value\n\t\telse if (type === "#") attrs.id = value\n\t\telse if (type === ".") classes.push(value)\n\t\telse if (match[3][0] === "[") {\n\t\t\tvar attrValue = match[6]\n\t\t\tif (attrValue) attrValue = attrValue.replace(/\\\\(["\'])/g, "$1").replace(/\\\\\\\\/g, "\\\\")\n\t\t\tif (match[4] === "class") classes.push(attrValue)\n\t\t\telse attrs[match[4]] = attrValue === "" ? attrValue : attrValue || true\n\t\t}\n\t}\n\tif (classes.length > 0) attrs.className = classes.join(" ")\n\treturn selectorCache[selector] = {tag: tag, attrs: attrs}\n}\nfunction execSelector(state, attrs, children) {\n\tvar hasAttrs = false, childList, text\n\tvar className = attrs.className || attrs.class\n\tfor (var key in state.attrs) {\n\t\tif (hasOwn.call(state.attrs, key)) {\n\t\t\tattrs[key] = state.attrs[key]\n\t\t}\n\t}\n\tif (className !== undefined) {\n\t\tif (attrs.class !== undefined) {\n\t\t\tattrs.class = undefined\n\t\t\tattrs.className = className\n\t\t}\n\t\tif (state.attrs.className != null) {\n\t\t\tattrs.className = state.attrs.className + " " + className\n\t\t}\n\t}\n\tfor (var key in attrs) {\n\t\tif (hasOwn.call(attrs, key) && key !== "key") {\n\t\t\thasAttrs = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif (Array.isArray(children) && children.length === 1 && children[0] != null && children[0].tag === "#") {\n\t\ttext = children[0].children\n\t} else {\n\t\tchildList = children\n\t}\n\treturn Vnode(state.tag, attrs.key, hasAttrs ? attrs : undefined, childList, text)\n}\nfunction hyperscript(selector) {\n\t// Because sloppy mode sucks\n\tvar attrs = arguments[1], start = 2, children\n\tif (selector == null || typeof selector !== "string" && typeof selector !== "function" && typeof selector.view !== "function") {\n\t\tthrow Error("The selector must be either a string or a component.");\n\t}\n\tif (typeof selector === "string") {\n\t\tvar cached = selectorCache[selector] || compileSelector(selector)\n\t}\n\tif (attrs == null) {\n\t\tattrs = {}\n\t} else if (typeof attrs !== "object" || attrs.tag != null || Array.isArray(attrs)) {\n\t\tattrs = {}\n\t\tstart = 1\n\t}\n\tif (arguments.length === start + 1) {\n\t\tchildren = arguments[start]\n\t\tif (!Array.isArray(children)) children = [children]\n\t} else {\n\t\tchildren = []\n\t\twhile (start < arguments.length) children.push(arguments[start++])\n\t}\n\tvar normalized = Vnode.normalizeChildren(children)\n\tif (typeof selector === "string") {\n\t\treturn execSelector(cached, attrs, normalized)\n\t} else {\n\t\treturn Vnode(selector, attrs.key, attrs, normalized)\n\t}\n}\nhyperscript.trust = function(html) {\n\tif (html == null) html = ""\n\treturn Vnode("<", undefined, undefined, html, undefined, undefined)\n}\nhyperscript.fragment = function(attrs1, children) {\n\treturn Vnode("[", attrs1.key, attrs1, Vnode.normalizeChildren(children), undefined, undefined)\n}\nvar m = hyperscript\n/** @constructor */\nvar PromisePolyfill = function(executor) {\n\tif (!(this instanceof PromisePolyfill)) throw new Error("Promise must be called with `new`")\n\tif (typeof executor !== "function") throw new TypeError("executor must be a function")\n\tvar self = this, resolvers = [], rejectors = [], resolveCurrent = handler(resolvers, true), rejectCurrent = handler(rejectors, false)\n\tvar instance = self._instance = {resolvers: resolvers, rejectors: rejectors}\n\tvar callAsync = typeof setImmediate === "function" ? setImmediate : setTimeout\n\tfunction handler(list, shouldAbsorb) {\n\t\treturn function execute(value) {\n\t\t\tvar then\n\t\t\ttry {\n\t\t\t\tif (shouldAbsorb && value != null && (typeof value === "object" || typeof value === "function") && typeof (then = value.then) === "function") {\n\t\t\t\t\tif (value === self) throw new TypeError("Promise can\'t be resolved w/ itself")\n\t\t\t\t\texecuteOnce(then.bind(value))\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcallAsync(function() {\n\t\t\t\t\t\tif (!shouldAbsorb && list.length === 0) console.error("Possible unhandled promise rejection:", value)\n\t\t\t\t\t\tfor (var i = 0; i < list.length; i++) list[i](value)\n\t\t\t\t\t\tresolvers.length = 0, rejectors.length = 0\n\t\t\t\t\t\tinstance.state = shouldAbsorb\n\t\t\t\t\t\tinstance.retry = function() {execute(value)}\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (e) {\n\t\t\t\trejectCurrent(e)\n\t\t\t}\n\t\t}\n\t}\n\tfunction executeOnce(then) {\n\t\tvar runs = 0\n\t\tfunction run(fn) {\n\t\t\treturn function(value) {\n\t\t\t\tif (runs++ > 0) return\n\t\t\t\tfn(value)\n\t\t\t}\n\t\t}\n\t\tvar onerror = run(rejectCurrent)\n\t\ttry {then(run(resolveCurrent), onerror)} catch (e) {onerror(e)}\n\t}\n\texecuteOnce(executor)\n}\nPromisePolyfill.prototype.then = function(onFulfilled, onRejection) {\n\tvar self = this, instance = self._instance\n\tfunction handle(callback, list, next, state) {\n\t\tlist.push(function(value) {\n\t\t\tif (typeof callback !== "function") next(value)\n\t\t\telse try {resolveNext(callback(value))} catch (e) {if (rejectNext) rejectNext(e)}\n\t\t})\n\t\tif (typeof instance.retry === "function" && state === instance.state) instance.retry()\n\t}\n\tvar resolveNext, rejectNext\n\tvar promise = new PromisePolyfill(function(resolve, reject) {resolveNext = resolve, rejectNext = reject})\n\thandle(onFulfilled, instance.resolvers, resolveNext, true), handle(onRejection, instance.rejectors, rejectNext, false)\n\treturn promise\n}\nPromisePolyfill.prototype.catch = function(onRejection) {\n\treturn this.then(null, onRejection)\n}\nPromisePolyfill.resolve = function(value) {\n\tif (value instanceof PromisePolyfill) return value\n\treturn new PromisePolyfill(function(resolve) {resolve(value)})\n}\nPromisePolyfill.reject = function(value) {\n\treturn new PromisePolyfill(function(resolve, reject) {reject(value)})\n}\nPromisePolyfill.all = function(list) {\n\treturn new PromisePolyfill(function(resolve, reject) {\n\t\tvar total = list.length, count = 0, values = []\n\t\tif (list.length === 0) resolve([])\n\t\telse for (var i = 0; i < list.length; i++) {\n\t\t\t(function(i) {\n\t\t\t\tfunction consume(value) {\n\t\t\t\t\tcount++\n\t\t\t\t\tvalues[i] = value\n\t\t\t\t\tif (count === total) resolve(values)\n\t\t\t\t}\n\t\t\t\tif (list[i] != null && (typeof list[i] === "object" || typeof list[i] === "function") && typeof list[i].then === "function") {\n\t\t\t\t\tlist[i].then(consume, reject)\n\t\t\t\t}\n\t\t\t\telse consume(list[i])\n\t\t\t})(i)\n\t\t}\n\t})\n}\nPromisePolyfill.race = function(list) {\n\treturn new PromisePolyfill(function(resolve, reject) {\n\t\tfor (var i = 0; i < list.length; i++) {\n\t\t\tlist[i].then(resolve, reject)\n\t\t}\n\t})\n}\nif (typeof window !== "undefined") {\n\tif (typeof window.Promise === "undefined") window.Promise = PromisePolyfill\n\tvar PromisePolyfill = window.Promise\n} else if (typeof global !== "undefined") {\n\tif (typeof global.Promise === "undefined") global.Promise = PromisePolyfill\n\tvar PromisePolyfill = global.Promise\n} else {\n}\nvar buildQueryString = function(object) {\n\tif (Object.prototype.toString.call(object) !== "[object Object]") return ""\n\tvar args = []\n\tfor (var key0 in object) {\n\t\tdestructure(key0, object[key0])\n\t}\n\treturn args.join("&")\n\tfunction destructure(key0, value) {\n\t\tif (Array.isArray(value)) {\n\t\t\tfor (var i = 0; i < value.length; i++) {\n\t\t\t\tdestructure(key0 + "[" + i + "]", value[i])\n\t\t\t}\n\t\t}\n\t\telse if (Object.prototype.toString.call(value) === "[object Object]") {\n\t\t\tfor (var i in value) {\n\t\t\t\tdestructure(key0 + "[" + i + "]", value[i])\n\t\t\t}\n\t\t}\n\t\telse args.push(encodeURIComponent(key0) + (value != null && value !== "" ? "=" + encodeURIComponent(value) : ""))\n\t}\n}\nvar FILE_PROTOCOL_REGEX = new RegExp("^file://", "i")\nvar _8 = function($window, Promise) {\n\tvar callbackCount = 0\n\tvar oncompletion\n\tfunction setCompletionCallback(callback) {oncompletion = callback}\n\tfunction finalizer() {\n\t\tvar count = 0\n\t\tfunction complete() {if (--count === 0 && typeof oncompletion === "function") oncompletion()}\n\t\treturn function finalize(promise0) {\n\t\t\tvar then0 = promise0.then\n\t\t\tpromise0.then = function() {\n\t\t\t\tcount++\n\t\t\t\tvar next = then0.apply(promise0, arguments)\n\t\t\t\tnext.then(complete, function(e) {\n\t\t\t\t\tcomplete()\n\t\t\t\t\tif (count === 0) throw e\n\t\t\t\t})\n\t\t\t\treturn finalize(next)\n\t\t\t}\n\t\t\treturn promise0\n\t\t}\n\t}\n\tfunction normalize(args, extra) {\n\t\tif (typeof args === "string") {\n\t\t\tvar url = args\n\t\t\targs = extra || {}\n\t\t\tif (args.url == null) args.url = url\n\t\t}\n\t\treturn args\n\t}\n\tfunction request(args, extra) {\n\t\tvar finalize = finalizer()\n\t\targs = normalize(args, extra)\n\t\tvar promise0 = new Promise(function(resolve, reject) {\n\t\t\tif (args.method == null) args.method = "GET"\n\t\t\targs.method = args.method.toUpperCase()\n\t\t\tvar useBody = (args.method === "GET" || args.method === "TRACE") ? false : (typeof args.useBody === "boolean" ? args.useBody : true)\n\t\t\tif (typeof args.serialize !== "function") args.serialize = typeof FormData !== "undefined" && args.data instanceof FormData ? function(value) {return value} : JSON.stringify\n\t\t\tif (typeof args.deserialize !== "function") args.deserialize = deserialize\n\t\t\tif (typeof args.extract !== "function") args.extract = extract\n\t\t\targs.url = interpolate(args.url, args.data)\n\t\t\tif (useBody) args.data = args.serialize(args.data)\n\t\t\telse args.url = assemble(args.url, args.data)\n\t\t\tvar xhr = new $window.XMLHttpRequest(),\n\t\t\t\taborted = false,\n\t\t\t\t_abort = xhr.abort\n\t\t\txhr.abort = function abort() {\n\t\t\t\taborted = true\n\t\t\t\t_abort.call(xhr)\n\t\t\t}\n\t\t\txhr.open(args.method, args.url, typeof args.async === "boolean" ? args.async : true, typeof args.user === "string" ? args.user : undefined, typeof args.password === "string" ? args.password : undefined)\n\t\t\tif (args.serialize === JSON.stringify && useBody) {\n\t\t\t\txhr.setRequestHeader("Content-Type", "application/json; charset=utf-8")\n\t\t\t}\n\t\t\tif (args.deserialize === deserialize) {\n\t\t\t\txhr.setRequestHeader("Accept", "application/json, text/*")\n\t\t\t}\n\t\t\tif (args.withCredentials) xhr.withCredentials = args.withCredentials\n\t\t\tfor (var key in args.headers) if ({}.hasOwnProperty.call(args.headers, key)) {\n\t\t\t\txhr.setRequestHeader(key, args.headers[key])\n\t\t\t}\n\t\t\tif (typeof args.config === "function") xhr = args.config(xhr, args) || xhr\n\t\t\txhr.onreadystatechange = function() {\n\t\t\t\t// Don\'t throw errors on xhr.abort().\n\t\t\t\tif(aborted) return\n\t\t\t\tif (xhr.readyState === 4) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvar response = (args.extract !== extract) ? args.extract(xhr, args) : args.deserialize(args.extract(xhr, args))\n\t\t\t\t\t\tif ((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304 || FILE_PROTOCOL_REGEX.test(args.url)) {\n\t\t\t\t\t\t\tresolve(cast(args.type, response))\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tvar error = new Error(xhr.responseText)\n\t\t\t\t\t\t\tfor (var key in response) error[key] = response[key]\n\t\t\t\t\t\t\treject(error)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (e) {\n\t\t\t\t\t\treject(e)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (useBody && (args.data != null)) xhr.send(args.data)\n\t\t\telse xhr.send()\n\t\t})\n\t\treturn args.background === true ? promise0 : finalize(promise0)\n\t}\n\tfunction jsonp(args, extra) {\n\t\tvar finalize = finalizer()\n\t\targs = normalize(args, extra)\n\t\tvar promise0 = new Promise(function(resolve, reject) {\n\t\t\tvar callbackName = args.callbackName || "_mithril_" + Math.round(Math.random() * 1e16) + "_" + callbackCount++\n\t\t\tvar script = $window.document.createElement("script")\n\t\t\t$window[callbackName] = function(data) {\n\t\t\t\tscript.parentNode.removeChild(script)\n\t\t\t\tresolve(cast(args.type, data))\n\t\t\t\tdelete $window[callbackName]\n\t\t\t}\n\t\t\tscript.onerror = function() {\n\t\t\t\tscript.parentNode.removeChild(script)\n\t\t\t\treject(new Error("JSONP request failed"))\n\t\t\t\tdelete $window[callbackName]\n\t\t\t}\n\t\t\tif (args.data == null) args.data = {}\n\t\t\targs.url = interpolate(args.url, args.data)\n\t\t\targs.data[args.callbackKey || "callback"] = callbackName\n\t\t\tscript.src = assemble(args.url, args.data)\n\t\t\t$window.document.documentElement.appendChild(script)\n\t\t})\n\t\treturn args.background === true? promise0 : finalize(promise0)\n\t}\n\tfunction interpolate(url, data) {\n\t\tif (data == null) return url\n\t\tvar tokens = url.match(/:[^\\/]+/gi) || []\n\t\tfor (var i = 0; i < tokens.length; i++) {\n\t\t\tvar key = tokens[i].slice(1)\n\t\t\tif (data[key] != null) {\n\t\t\t\turl = url.replace(tokens[i], data[key])\n\t\t\t}\n\t\t}\n\t\treturn url\n\t}\n\tfunction assemble(url, data) {\n\t\tvar querystring = buildQueryString(data)\n\t\tif (querystring !== "") {\n\t\t\tvar prefix = url.indexOf("?") < 0 ? "?" : "&"\n\t\t\turl += prefix + querystring\n\t\t}\n\t\treturn url\n\t}\n\tfunction deserialize(data) {\n\t\ttry {return data !== "" ? JSON.parse(data) : null}\n\t\tcatch (e) {throw new Error(data)}\n\t}\n\tfunction extract(xhr) {return xhr.responseText}\n\tfunction cast(type0, data) {\n\t\tif (typeof type0 === "function") {\n\t\t\tif (Array.isArray(data)) {\n\t\t\t\tfor (var i = 0; i < data.length; i++) {\n\t\t\t\t\tdata[i] = new type0(data[i])\n\t\t\t\t}\n\t\t\t}\n\t\t\telse return new type0(data)\n\t\t}\n\t\treturn data\n\t}\n\treturn {request: request, jsonp: jsonp, setCompletionCallback: setCompletionCallback}\n}\nvar requestService = _8(window, PromisePolyfill)\nvar coreRenderer = function($window) {\n\tvar $doc = $window.document\n\tvar $emptyFragment = $doc.createDocumentFragment()\n\tvar nameSpace = {\n\t\tsvg: "http://www.w3.org/2000/svg",\n\t\tmath: "http://www.w3.org/1998/Math/MathML"\n\t}\n\tvar onevent\n\tfunction setEventCallback(callback) {return onevent = callback}\n\tfunction getNameSpace(vnode) {\n\t\treturn vnode.attrs && vnode.attrs.xmlns || nameSpace[vnode.tag]\n\t}\n\t//create\n\tfunction createNodes(parent, vnodes, start, end, hooks, nextSibling, ns) {\n\t\tfor (var i = start; i < end; i++) {\n\t\t\tvar vnode = vnodes[i]\n\t\t\tif (vnode != null) {\n\t\t\t\tcreateNode(parent, vnode, hooks, ns, nextSibling)\n\t\t\t}\n\t\t}\n\t}\n\tfunction createNode(parent, vnode, hooks, ns, nextSibling) {\n\t\tvar tag = vnode.tag\n\t\tif (typeof tag === "string") {\n\t\t\tvnode.state = {}\n\t\t\tif (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks)\n\t\t\tswitch (tag) {\n\t\t\t\tcase "#": return createText(parent, vnode, nextSibling)\n\t\t\t\tcase "<": return createHTML(parent, vnode, nextSibling)\n\t\t\t\tcase "[": return createFragment(parent, vnode, hooks, ns, nextSibling)\n\t\t\t\tdefault: return createElement(parent, vnode, hooks, ns, nextSibling)\n\t\t\t}\n\t\t}\n\t\telse return createComponent(parent, vnode, hooks, ns, nextSibling)\n\t}\n\tfunction createText(parent, vnode, nextSibling) {\n\t\tvnode.dom = $doc.createTextNode(vnode.children)\n\t\tinsertNode(parent, vnode.dom, nextSibling)\n\t\treturn vnode.dom\n\t}\n\tfunction createHTML(parent, vnode, nextSibling) {\n\t\tvar match1 = vnode.children.match(/^\\s*?<(\\w+)/im) || []\n\t\tvar parent1 = {caption: "table", thead: "table", tbody: "table", tfoot: "table", tr: "tbody", th: "tr", td: "tr", colgroup: "table", col: "colgroup"}[match1[1]] || "div"\n\t\tvar temp = $doc.createElement(parent1)\n\t\ttemp.innerHTML = vnode.children\n\t\tvnode.dom = temp.firstChild\n\t\tvnode.domSize = temp.childNodes.length\n\t\tvar fragment = $doc.createDocumentFragment()\n\t\tvar child\n\t\twhile (child = temp.firstChild) {\n\t\t\tfragment.appendChild(child)\n\t\t}\n\t\tinsertNode(parent, fragment, nextSibling)\n\t\treturn fragment\n\t}\n\tfunction createFragment(parent, vnode, hooks, ns, nextSibling) {\n\t\tvar fragment = $doc.createDocumentFragment()\n\t\tif (vnode.children != null) {\n\t\t\tvar children = vnode.children\n\t\t\tcreateNodes(fragment, children, 0, children.length, hooks, null, ns)\n\t\t}\n\t\tvnode.dom = fragment.firstChild\n\t\tvnode.domSize = fragment.childNodes.length\n\t\tinsertNode(parent, fragment, nextSibling)\n\t\treturn fragment\n\t}\n\tfunction createElement(parent, vnode, hooks, ns, nextSibling) {\n\t\tvar tag = vnode.tag\n\t\tvar attrs2 = vnode.attrs\n\t\tvar is = attrs2 && attrs2.is\n\t\tns = getNameSpace(vnode) || ns\n\t\tvar element = ns ?\n\t\t\tis ? $doc.createElementNS(ns, tag, {is: is}) : $doc.createElementNS(ns, tag) :\n\t\t\tis ? $doc.createElement(tag, {is: is}) : $doc.createElement(tag)\n\t\tvnode.dom = element\n\t\tif (attrs2 != null) {\n\t\t\tsetAttrs(vnode, attrs2, ns)\n\t\t}\n\t\tinsertNode(parent, element, nextSibling)\n\t\tif (vnode.attrs != null && vnode.attrs.contenteditable != null) {\n\t\t\tsetContentEditable(vnode)\n\t\t}\n\t\telse {\n\t\t\tif (vnode.text != null) {\n\t\t\t\tif (vnode.text !== "") element.textContent = vnode.text\n\t\t\t\telse vnode.children = [Vnode("#", undefined, undefined, vnode.text, undefined, undefined)]\n\t\t\t}\n\t\t\tif (vnode.children != null) {\n\t\t\t\tvar children = vnode.children\n\t\t\t\tcreateNodes(element, children, 0, children.length, hooks, null, ns)\n\t\t\t\tsetLateAttrs(vnode)\n\t\t\t}\n\t\t}\n\t\treturn element\n\t}\n\tfunction initComponent(vnode, hooks) {\n\t\tvar sentinel\n\t\tif (typeof vnode.tag.view === "function") {\n\t\t\tvnode.state = Object.create(vnode.tag)\n\t\t\tsentinel = vnode.state.view\n\t\t\tif (sentinel.$$reentrantLock$$ != null) return $emptyFragment\n\t\t\tsentinel.$$reentrantLock$$ = true\n\t\t} else {\n\t\t\tvnode.state = void 0\n\t\t\tsentinel = vnode.tag\n\t\t\tif (sentinel.$$reentrantLock$$ != null) return $emptyFragment\n\t\t\tsentinel.$$reentrantLock$$ = true\n\t\t\tvnode.state = (vnode.tag.prototype != null && typeof vnode.tag.prototype.view === "function") ? new vnode.tag(vnode) : vnode.tag(vnode)\n\t\t}\n\t\tvnode._state = vnode.state\n\t\tif (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks)\n\t\tinitLifecycle(vnode._state, vnode, hooks)\n\t\tvnode.instance = Vnode.normalize(vnode._state.view.call(vnode.state, vnode))\n\t\tif (vnode.instance === vnode) throw Error("A view cannot return the vnode it received as argument")\n\t\tsentinel.$$reentrantLock$$ = null\n\t}\n\tfunction createComponent(parent, vnode, hooks, ns, nextSibling) {\n\t\tinitComponent(vnode, hooks)\n\t\tif (vnode.instance != null) {\n\t\t\tvar element = createNode(parent, vnode.instance, hooks, ns, nextSibling)\n\t\t\tvnode.dom = vnode.instance.dom\n\t\t\tvnode.domSize = vnode.dom != null ? vnode.instance.domSize : 0\n\t\t\tinsertNode(parent, element, nextSibling)\n\t\t\treturn element\n\t\t}\n\t\telse {\n\t\t\tvnode.domSize = 0\n\t\t\treturn $emptyFragment\n\t\t}\n\t}\n\t//update\n\tfunction updateNodes(parent, old, vnodes, recycling, hooks, nextSibling, ns) {\n\t\tif (old === vnodes || old == null && vnodes == null) return\n\t\telse if (old == null) createNodes(parent, vnodes, 0, vnodes.length, hooks, nextSibling, ns)\n\t\telse if (vnodes == null) removeNodes(old, 0, old.length, vnodes)\n\t\telse {\n\t\t\tif (old.length === vnodes.length) {\n\t\t\t\tvar isUnkeyed = false\n\t\t\t\tfor (var i = 0; i < vnodes.length; i++) {\n\t\t\t\t\tif (vnodes[i] != null && old[i] != null) {\n\t\t\t\t\t\tisUnkeyed = vnodes[i].key == null && old[i].key == null\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (isUnkeyed) {\n\t\t\t\t\tfor (var i = 0; i < old.length; i++) {\n\t\t\t\t\t\tif (old[i] === vnodes[i]) continue\n\t\t\t\t\t\telse if (old[i] == null && vnodes[i] != null) createNode(parent, vnodes[i], hooks, ns, getNextSibling(old, i + 1, nextSibling))\n\t\t\t\t\t\telse if (vnodes[i] == null) removeNodes(old, i, i + 1, vnodes)\n\t\t\t\t\t\telse updateNode(parent, old[i], vnodes[i], hooks, getNextSibling(old, i + 1, nextSibling), recycling, ns)\n\t\t\t\t\t}\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\trecycling = recycling || isRecyclable(old, vnodes)\n\t\t\tif (recycling) {\n\t\t\t\tvar pool = old.pool\n\t\t\t\told = old.concat(old.pool)\n\t\t\t}\n\t\t\tvar oldStart = 0, start = 0, oldEnd = old.length - 1, end = vnodes.length - 1, map\n\t\t\twhile (oldEnd >= oldStart && end >= start) {\n\t\t\t\tvar o = old[oldStart], v = vnodes[start]\n\t\t\t\tif (o === v && !recycling) oldStart++, start++\n\t\t\t\telse if (o == null) oldStart++\n\t\t\t\telse if (v == null) start++\n\t\t\t\telse if (o.key === v.key) {\n\t\t\t\t\tvar shouldRecycle = (pool != null && oldStart >= old.length - pool.length) || ((pool == null) && recycling)\n\t\t\t\t\toldStart++, start++\n\t\t\t\t\tupdateNode(parent, o, v, hooks, getNextSibling(old, oldStart, nextSibling), shouldRecycle, ns)\n\t\t\t\t\tif (recycling && o.tag === v.tag) insertNode(parent, toFragment(o), nextSibling)\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tvar o = old[oldEnd]\n\t\t\t\t\tif (o === v && !recycling) oldEnd--, start++\n\t\t\t\t\telse if (o == null) oldEnd--\n\t\t\t\t\telse if (v == null) start++\n\t\t\t\t\telse if (o.key === v.key) {\n\t\t\t\t\t\tvar shouldRecycle = (pool != null && oldEnd >= old.length - pool.length) || ((pool == null) && recycling)\n\t\t\t\t\t\tupdateNode(parent, o, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), shouldRecycle, ns)\n\t\t\t\t\t\tif (recycling || start < end) insertNode(parent, toFragment(o), getNextSibling(old, oldStart, nextSibling))\n\t\t\t\t\t\toldEnd--, start++\n\t\t\t\t\t}\n\t\t\t\t\telse break\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (oldEnd >= oldStart && end >= start) {\n\t\t\t\tvar o = old[oldEnd], v = vnodes[end]\n\t\t\t\tif (o === v && !recycling) oldEnd--, end--\n\t\t\t\telse if (o == null) oldEnd--\n\t\t\t\telse if (v == null) end--\n\t\t\t\telse if (o.key === v.key) {\n\t\t\t\t\tvar shouldRecycle = (pool != null && oldEnd >= old.length - pool.length) || ((pool == null) && recycling)\n\t\t\t\t\tupdateNode(parent, o, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), shouldRecycle, ns)\n\t\t\t\t\tif (recycling && o.tag === v.tag) insertNode(parent, toFragment(o), nextSibling)\n\t\t\t\t\tif (o.dom != null) nextSibling = o.dom\n\t\t\t\t\toldEnd--, end--\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (!map) map = getKeyMap(old, oldEnd)\n\t\t\t\t\tif (v != null) {\n\t\t\t\t\t\tvar oldIndex = map[v.key]\n\t\t\t\t\t\tif (oldIndex != null) {\n\t\t\t\t\t\t\tvar movable = old[oldIndex]\n\t\t\t\t\t\t\tvar shouldRecycle = (pool != null && oldIndex >= old.length - pool.length) || ((pool == null) && recycling)\n\t\t\t\t\t\t\tupdateNode(parent, movable, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), recycling, ns)\n\t\t\t\t\t\t\tinsertNode(parent, toFragment(movable), nextSibling)\n\t\t\t\t\t\t\told[oldIndex].skip = true\n\t\t\t\t\t\t\tif (movable.dom != null) nextSibling = movable.dom\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tvar dom = createNode(parent, v, hooks, ns, nextSibling)\n\t\t\t\t\t\t\tnextSibling = dom\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tend--\n\t\t\t\t}\n\t\t\t\tif (end < start) break\n\t\t\t}\n\t\t\tcreateNodes(parent, vnodes, start, end + 1, hooks, nextSibling, ns)\n\t\t\tremoveNodes(old, oldStart, oldEnd + 1, vnodes)\n\t\t}\n\t}\n\tfunction updateNode(parent, old, vnode, hooks, nextSibling, recycling, ns) {\n\t\tvar oldTag = old.tag, tag = vnode.tag\n\t\tif (oldTag === tag) {\n\t\t\tvnode.state = old.state\n\t\t\tvnode._state = old._state\n\t\t\tvnode.events = old.events\n\t\t\tif (!recycling && shouldNotUpdate(vnode, old)) return\n\t\t\tif (typeof oldTag === "string") {\n\t\t\t\tif (vnode.attrs != null) {\n\t\t\t\t\tif (recycling) {\n\t\t\t\t\t\tvnode.state = {}\n\t\t\t\t\t\tinitLifecycle(vnode.attrs, vnode, hooks)\n\t\t\t\t\t}\n\t\t\t\t\telse updateLifecycle(vnode.attrs, vnode, hooks)\n\t\t\t\t}\n\t\t\t\tswitch (oldTag) {\n\t\t\t\t\tcase "#": updateText(old, vnode); break\n\t\t\t\t\tcase "<": updateHTML(parent, old, vnode, nextSibling); break\n\t\t\t\t\tcase "[": updateFragment(parent, old, vnode, recycling, hooks, nextSibling, ns); break\n\t\t\t\t\tdefault: updateElement(old, vnode, recycling, hooks, ns)\n\t\t\t\t}\n\t\t\t}\n\t\t\telse updateComponent(parent, old, vnode, hooks, nextSibling, recycling, ns)\n\t\t}\n\t\telse {\n\t\t\tremoveNode(old, null)\n\t\t\tcreateNode(parent, vnode, hooks, ns, nextSibling)\n\t\t}\n\t}\n\tfunction updateText(old, vnode) {\n\t\tif (old.children.toString() !== vnode.children.toString()) {\n\t\t\told.dom.nodeValue = vnode.children\n\t\t}\n\t\tvnode.dom = old.dom\n\t}\n\tfunction updateHTML(parent, old, vnode, nextSibling) {\n\t\tif (old.children !== vnode.children) {\n\t\t\ttoFragment(old)\n\t\t\tcreateHTML(parent, vnode, nextSibling)\n\t\t}\n\t\telse vnode.dom = old.dom, vnode.domSize = old.domSize\n\t}\n\tfunction updateFragment(parent, old, vnode, recycling, hooks, nextSibling, ns) {\n\t\tupdateNodes(parent, old.children, vnode.children, recycling, hooks, nextSibling, ns)\n\t\tvar domSize = 0, children = vnode.children\n\t\tvnode.dom = null\n\t\tif (children != null) {\n\t\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\t\tvar child = children[i]\n\t\t\t\tif (child != null && child.dom != null) {\n\t\t\t\t\tif (vnode.dom == null) vnode.dom = child.dom\n\t\t\t\t\tdomSize += child.domSize || 1\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (domSize !== 1) vnode.domSize = domSize\n\t\t}\n\t}\n\tfunction updateElement(old, vnode, recycling, hooks, ns) {\n\t\tvar element = vnode.dom = old.dom\n\t\tns = getNameSpace(vnode) || ns\n\t\tif (vnode.tag === "textarea") {\n\t\t\tif (vnode.attrs == null) vnode.attrs = {}\n\t\t\tif (vnode.text != null) {\n\t\t\t\tvnode.attrs.value = vnode.text //FIXME handle0 multiple children\n\t\t\t\tvnode.text = undefined\n\t\t\t}\n\t\t}\n\t\tupdateAttrs(vnode, old.attrs, vnode.attrs, ns)\n\t\tif (vnode.attrs != null && vnode.attrs.contenteditable != null) {\n\t\t\tsetContentEditable(vnode)\n\t\t}\n\t\telse if (old.text != null && vnode.text != null && vnode.text !== "") {\n\t\t\tif (old.text.toString() !== vnode.text.toString()) old.dom.firstChild.nodeValue = vnode.text\n\t\t}\n\t\telse {\n\t\t\tif (old.text != null) old.children = [Vnode("#", undefined, undefined, old.text, undefined, old.dom.firstChild)]\n\t\t\tif (vnode.text != null) vnode.children = [Vnode("#", undefined, undefined, vnode.text, undefined, undefined)]\n\t\t\tupdateNodes(element, old.children, vnode.children, recycling, hooks, null, ns)\n\t\t}\n\t}\n\tfunction updateComponent(parent, old, vnode, hooks, nextSibling, recycling, ns) {\n\t\tif (recycling) {\n\t\t\tinitComponent(vnode, hooks)\n\t\t} else {\n\t\t\tvnode.instance = Vnode.normalize(vnode._state.view.call(vnode.state, vnode))\n\t\t\tif (vnode.instance === vnode) throw Error("A view cannot return the vnode it received as argument")\n\t\t\tif (vnode.attrs != null) updateLifecycle(vnode.attrs, vnode, hooks)\n\t\t\tupdateLifecycle(vnode._state, vnode, hooks)\n\t\t}\n\t\tif (vnode.instance != null) {\n\t\t\tif (old.instance == null) createNode(parent, vnode.instance, hooks, ns, nextSibling)\n\t\t\telse updateNode(parent, old.instance, vnode.instance, hooks, nextSibling, recycling, ns)\n\t\t\tvnode.dom = vnode.instance.dom\n\t\t\tvnode.domSize = vnode.instance.domSize\n\t\t}\n\t\telse if (old.instance != null) {\n\t\t\tremoveNode(old.instance, null)\n\t\t\tvnode.dom = undefined\n\t\t\tvnode.domSize = 0\n\t\t}\n\t\telse {\n\t\t\tvnode.dom = old.dom\n\t\t\tvnode.domSize = old.domSize\n\t\t}\n\t}\n\tfunction isRecyclable(old, vnodes) {\n\t\tif (old.pool != null && Math.abs(old.pool.length - vnodes.length) <= Math.abs(old.length - vnodes.length)) {\n\t\t\tvar oldChildrenLength = old[0] && old[0].children && old[0].children.length || 0\n\t\t\tvar poolChildrenLength = old.pool[0] && old.pool[0].children && old.pool[0].children.length || 0\n\t\t\tvar vnodesChildrenLength = vnodes[0] && vnodes[0].children && vnodes[0].children.length || 0\n\t\t\tif (Math.abs(poolChildrenLength - vnodesChildrenLength) <= Math.abs(oldChildrenLength - vnodesChildrenLength)) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\tfunction getKeyMap(vnodes, end) {\n\t\tvar map = {}, i = 0\n\t\tfor (var i = 0; i < end; i++) {\n\t\t\tvar vnode = vnodes[i]\n\t\t\tif (vnode != null) {\n\t\t\t\tvar key2 = vnode.key\n\t\t\t\tif (key2 != null) map[key2] = i\n\t\t\t}\n\t\t}\n\t\treturn map\n\t}\n\tfunction toFragment(vnode) {\n\t\tvar count0 = vnode.domSize\n\t\tif (count0 != null || vnode.dom == null) {\n\t\t\tvar fragment = $doc.createDocumentFragment()\n\t\t\tif (count0 > 0) {\n\t\t\t\tvar dom = vnode.dom\n\t\t\t\twhile (--count0) fragment.appendChild(dom.nextSibling)\n\t\t\t\tfragment.insertBefore(dom, fragment.firstChild)\n\t\t\t}\n\t\t\treturn fragment\n\t\t}\n\t\telse return vnode.dom\n\t}\n\tfunction getNextSibling(vnodes, i, nextSibling) {\n\t\tfor (; i < vnodes.length; i++) {\n\t\t\tif (vnodes[i] != null && vnodes[i].dom != null) return vnodes[i].dom\n\t\t}\n\t\treturn nextSibling\n\t}\n\tfunction insertNode(parent, dom, nextSibling) {\n\t\tif (nextSibling && nextSibling.parentNode) parent.insertBefore(dom, nextSibling)\n\t\telse parent.appendChild(dom)\n\t}\n\tfunction setContentEditable(vnode) {\n\t\tvar children = vnode.children\n\t\tif (children != null && children.length === 1 && children[0].tag === "<") {\n\t\t\tvar content = children[0].children\n\t\t\tif (vnode.dom.innerHTML !== content) vnode.dom.innerHTML = content\n\t\t}\n\t\telse if (vnode.text != null || children != null && children.length !== 0) throw new Error("Child node of a contenteditable must be trusted")\n\t}\n\t//remove\n\tfunction removeNodes(vnodes, start, end, context) {\n\t\tfor (var i = start; i < end; i++) {\n\t\t\tvar vnode = vnodes[i]\n\t\t\tif (vnode != null) {\n\t\t\t\tif (vnode.skip) vnode.skip = false\n\t\t\t\telse removeNode(vnode, context)\n\t\t\t}\n\t\t}\n\t}\n\tfunction removeNode(vnode, context) {\n\t\tvar expected = 1, called = 0\n\t\tif (vnode.attrs && typeof vnode.attrs.onbeforeremove === "function") {\n\t\t\tvar result = vnode.attrs.onbeforeremove.call(vnode.state, vnode)\n\t\t\tif (result != null && typeof result.then === "function") {\n\t\t\t\texpected++\n\t\t\t\tresult.then(continuation, continuation)\n\t\t\t}\n\t\t}\n\t\tif (typeof vnode.tag !== "string" && typeof vnode._state.onbeforeremove === "function") {\n\t\t\tvar result = vnode._state.onbeforeremove.call(vnode.state, vnode)\n\t\t\tif (result != null && typeof result.then === "function") {\n\t\t\t\texpected++\n\t\t\t\tresult.then(continuation, continuation)\n\t\t\t}\n\t\t}\n\t\tcontinuation()\n\t\tfunction continuation() {\n\t\t\tif (++called === expected) {\n\t\t\t\tonremove(vnode)\n\t\t\t\tif (vnode.dom) {\n\t\t\t\t\tvar count0 = vnode.domSize || 1\n\t\t\t\t\tif (count0 > 1) {\n\t\t\t\t\t\tvar dom = vnode.dom\n\t\t\t\t\t\twhile (--count0) {\n\t\t\t\t\t\t\tremoveNodeFromDOM(dom.nextSibling)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tremoveNodeFromDOM(vnode.dom)\n\t\t\t\t\tif (context != null && vnode.domSize == null && !hasIntegrationMethods(vnode.attrs) && typeof vnode.tag === "string") { //TODO test custom elements\n\t\t\t\t\t\tif (!context.pool) context.pool = [vnode]\n\t\t\t\t\t\telse context.pool.push(vnode)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfunction removeNodeFromDOM(node) {\n\t\tvar parent = node.parentNode\n\t\tif (parent != null) parent.removeChild(node)\n\t}\n\tfunction onremove(vnode) {\n\t\tif (vnode.attrs && typeof vnode.attrs.onremove === "function") vnode.attrs.onremove.call(vnode.state, vnode)\n\t\tif (typeof vnode.tag !== "string" && typeof vnode._state.onremove === "function") vnode._state.onremove.call(vnode.state, vnode)\n\t\tif (vnode.instance != null) onremove(vnode.instance)\n\t\telse {\n\t\t\tvar children = vnode.children\n\t\t\tif (Array.isArray(children)) {\n\t\t\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\t\t\tvar child = children[i]\n\t\t\t\t\tif (child != null) onremove(child)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//attrs2\n\tfunction setAttrs(vnode, attrs2, ns) {\n\t\tfor (var key2 in attrs2) {\n\t\t\tsetAttr(vnode, key2, null, attrs2[key2], ns)\n\t\t}\n\t}\n\tfunction setAttr(vnode, key2, old, value, ns) {\n\t\tvar element = vnode.dom\n\t\tif (key2 === "key" || key2 === "is" || (old === value && !isFormAttribute(vnode, key2)) && typeof value !== "object" || typeof value === "undefined" || isLifecycleMethod(key2)) return\n\t\tvar nsLastIndex = key2.indexOf(":")\n\t\tif (nsLastIndex > -1 && key2.substr(0, nsLastIndex) === "xlink") {\n\t\t\telement.setAttributeNS("http://www.w3.org/1999/xlink", key2.slice(nsLastIndex + 1), value)\n\t\t}\n\t\telse if (key2[0] === "o" && key2[1] === "n" && typeof value === "function") updateEvent(vnode, key2, value)\n\t\telse if (key2 === "style") updateStyle(element, old, value)\n\t\telse if (key2 in element && !isAttribute(key2) && ns === undefined && !isCustomElement(vnode)) {\n\t\t\tif (key2 === "value") {\n\t\t\t\tvar normalized0 = "" + value // eslint-disable-line no-implicit-coercion\n\t\t\t\t//setting input[value] to same value by typing on focused element moves cursor to end in Chrome\n\t\t\t\tif ((vnode.tag === "input" || vnode.tag === "textarea") && vnode.dom.value === normalized0 && vnode.dom === $doc.activeElement) return\n\t\t\t\t//setting select[value] to same value while having select open blinks select dropdown in Chrome\n\t\t\t\tif (vnode.tag === "select") {\n\t\t\t\t\tif (value === null) {\n\t\t\t\t\t\tif (vnode.dom.selectedIndex === -1 && vnode.dom === $doc.activeElement) return\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (old !== null && vnode.dom.value === normalized0 && vnode.dom === $doc.activeElement) return\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//setting option[value] to same value while having select open blinks select dropdown in Chrome\n\t\t\t\tif (vnode.tag === "option" && old != null && vnode.dom.value === normalized0) return\n\t\t\t}\n\t\t\t// If you assign an input type1 that is not supported by IE 11 with an assignment expression, an error0 will occur.\n\t\t\tif (vnode.tag === "input" && key2 === "type") {\n\t\t\t\telement.setAttribute(key2, value)\n\t\t\t\treturn\n\t\t\t}\n\t\t\telement[key2] = value\n\t\t}\n\t\telse {\n\t\t\tif (typeof value === "boolean") {\n\t\t\t\tif (value) element.setAttribute(key2, "")\n\t\t\t\telse element.removeAttribute(key2)\n\t\t\t}\n\t\t\telse element.setAttribute(key2 === "className" ? "class" : key2, value)\n\t\t}\n\t}\n\tfunction setLateAttrs(vnode) {\n\t\tvar attrs2 = vnode.attrs\n\t\tif (vnode.tag === "select" && attrs2 != null) {\n\t\t\tif ("value" in attrs2) setAttr(vnode, "value", null, attrs2.value, undefined)\n\t\t\tif ("selectedIndex" in attrs2) setAttr(vnode, "selectedIndex", null, attrs2.selectedIndex, undefined)\n\t\t}\n\t}\n\tfunction updateAttrs(vnode, old, attrs2, ns) {\n\t\tif (attrs2 != null) {\n\t\t\tfor (var key2 in attrs2) {\n\t\t\t\tsetAttr(vnode, key2, old && old[key2], attrs2[key2], ns)\n\t\t\t}\n\t\t}\n\t\tif (old != null) {\n\t\t\tfor (var key2 in old) {\n\t\t\t\tif (attrs2 == null || !(key2 in attrs2)) {\n\t\t\t\t\tif (key2 === "className") key2 = "class"\n\t\t\t\t\tif (key2[0] === "o" && key2[1] === "n" && !isLifecycleMethod(key2)) updateEvent(vnode, key2, undefined)\n\t\t\t\t\telse if (key2 !== "key") vnode.dom.removeAttribute(key2)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfunction isFormAttribute(vnode, attr) {\n\t\treturn attr === "value" || attr === "checked" || attr === "selectedIndex" || attr === "selected" && vnode.dom === $doc.activeElement\n\t}\n\tfunction isLifecycleMethod(attr) {\n\t\treturn attr === "oninit" || attr === "oncreate" || attr === "onupdate" || attr === "onremove" || attr === "onbeforeremove" || attr === "onbeforeupdate"\n\t}\n\tfunction isAttribute(attr) {\n\t\treturn attr === "href" || attr === "list" || attr === "form" || attr === "width" || attr === "height"// || attr === "type"\n\t}\n\tfunction isCustomElement(vnode){\n\t\treturn vnode.attrs.is || vnode.tag.indexOf("-") > -1\n\t}\n\tfunction hasIntegrationMethods(source) {\n\t\treturn source != null && (source.oncreate || source.onupdate || source.onbeforeremove || source.onremove)\n\t}\n\t//style\n\tfunction updateStyle(element, old, style) {\n\t\tif (old === style) element.style.cssText = "", old = null\n\t\tif (style == null) element.style.cssText = ""\n\t\telse if (typeof style === "string") element.style.cssText = style\n\t\telse {\n\t\t\tif (typeof old === "string") element.style.cssText = ""\n\t\t\tfor (var key2 in style) {\n\t\t\t\telement.style[key2] = style[key2]\n\t\t\t}\n\t\t\tif (old != null && typeof old !== "string") {\n\t\t\t\tfor (var key2 in old) {\n\t\t\t\t\tif (!(key2 in style)) element.style[key2] = ""\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//event\n\tfunction updateEvent(vnode, key2, value) {\n\t\tvar element = vnode.dom\n\t\tvar callback = typeof onevent !== "function" ? value : function(e) {\n\t\t\tvar result = value.call(element, e)\n\t\t\tonevent.call(element, e)\n\t\t\treturn result\n\t\t}\n\t\tif (key2 in element) element[key2] = typeof value === "function" ? callback : null\n\t\telse {\n\t\t\tvar eventName = key2.slice(2)\n\t\t\tif (vnode.events === undefined) vnode.events = {}\n\t\t\tif (vnode.events[key2] === callback) return\n\t\t\tif (vnode.events[key2] != null) element.removeEventListener(eventName, vnode.events[key2], false)\n\t\t\tif (typeof value === "function") {\n\t\t\t\tvnode.events[key2] = callback\n\t\t\t\telement.addEventListener(eventName, vnode.events[key2], false)\n\t\t\t}\n\t\t}\n\t}\n\t//lifecycle\n\tfunction initLifecycle(source, vnode, hooks) {\n\t\tif (typeof source.oninit === "function") source.oninit.call(vnode.state, vnode)\n\t\tif (typeof source.oncreate === "function") hooks.push(source.oncreate.bind(vnode.state, vnode))\n\t}\n\tfunction updateLifecycle(source, vnode, hooks) {\n\t\tif (typeof source.onupdate === "function") hooks.push(source.onupdate.bind(vnode.state, vnode))\n\t}\n\tfunction shouldNotUpdate(vnode, old) {\n\t\tvar forceVnodeUpdate, forceComponentUpdate\n\t\tif (vnode.attrs != null && typeof vnode.attrs.onbeforeupdate === "function") forceVnodeUpdate = vnode.attrs.onbeforeupdate.call(vnode.state, vnode, old)\n\t\tif (typeof vnode.tag !== "string" && typeof vnode._state.onbeforeupdate === "function") forceComponentUpdate = vnode._state.onbeforeupdate.call(vnode.state, vnode, old)\n\t\tif (!(forceVnodeUpdate === undefined && forceComponentUpdate === undefined) && !forceVnodeUpdate && !forceComponentUpdate) {\n\t\t\tvnode.dom = old.dom\n\t\t\tvnode.domSize = old.domSize\n\t\t\tvnode.instance = old.instance\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\tfunction render(dom, vnodes) {\n\t\tif (!dom) throw new Error("Ensure the DOM element being passed to m.route/m.mount/m.render is not undefined.")\n\t\tvar hooks = []\n\t\tvar active = $doc.activeElement\n\t\tvar namespace = dom.namespaceURI\n\t\t// First time0 rendering into a node clears it out\n\t\tif (dom.vnodes == null) dom.textContent = ""\n\t\tif (!Array.isArray(vnodes)) vnodes = [vnodes]\n\t\tupdateNodes(dom, dom.vnodes, Vnode.normalizeChildren(vnodes), false, hooks, null, namespace === "http://www.w3.org/1999/xhtml" ? undefined : namespace)\n\t\tdom.vnodes = vnodes\n\t\tfor (var i = 0; i < hooks.length; i++) hooks[i]()\n\t\tif ($doc.activeElement !== active) active.focus()\n\t}\n\treturn {render: render, setEventCallback: setEventCallback}\n}\nfunction throttle(callback) {\n\t//60fps translates to 16.6ms, round it down since setTimeout requires int\n\tvar time = 16\n\tvar last = 0, pending = null\n\tvar timeout = typeof requestAnimationFrame === "function" ? requestAnimationFrame : setTimeout\n\treturn function() {\n\t\tvar now = Date.now()\n\t\tif (last === 0 || now - last >= time) {\n\t\t\tlast = now\n\t\t\tcallback()\n\t\t}\n\t\telse if (pending === null) {\n\t\t\tpending = timeout(function() {\n\t\t\t\tpending = null\n\t\t\t\tcallback()\n\t\t\t\tlast = Date.now()\n\t\t\t}, time - (now - last))\n\t\t}\n\t}\n}\nvar _11 = function($window) {\n\tvar renderService = coreRenderer($window)\n\trenderService.setEventCallback(function(e) {\n\t\tif (e.redraw === false) e.redraw = undefined\n\t\telse redraw()\n\t})\n\tvar callbacks = []\n\tfunction subscribe(key1, callback) {\n\t\tunsubscribe(key1)\n\t\tcallbacks.push(key1, throttle(callback))\n\t}\n\tfunction unsubscribe(key1) {\n\t\tvar index = callbacks.indexOf(key1)\n\t\tif (index > -1) callbacks.splice(index, 2)\n\t}\n\tfunction redraw() {\n\t\tfor (var i = 1; i < callbacks.length; i += 2) {\n\t\t\tcallbacks[i]()\n\t\t}\n\t}\n\treturn {subscribe: subscribe, unsubscribe: unsubscribe, redraw: redraw, render: renderService.render}\n}\nvar redrawService = _11(window)\nrequestService.setCompletionCallback(redrawService.redraw)\nvar _16 = function(redrawService0) {\n\treturn function(root, component) {\n\t\tif (component === null) {\n\t\t\tredrawService0.render(root, [])\n\t\t\tredrawService0.unsubscribe(root)\n\t\t\treturn\n\t\t}\n\t\t\n\t\tif (component.view == null && typeof component !== "function") throw new Error("m.mount(element, component) expects a component, not a vnode")\n\t\t\n\t\tvar run0 = function() {\n\t\t\tredrawService0.render(root, Vnode(component))\n\t\t}\n\t\tredrawService0.subscribe(root, run0)\n\t\tredrawService0.redraw()\n\t}\n}\nm.mount = _16(redrawService)\nvar Promise = PromisePolyfill\nvar parseQueryString = function(string) {\n\tif (string === "" || string == null) return {}\n\tif (string.charAt(0) === "?") string = string.slice(1)\n\tvar entries = string.split("&"), data0 = {}, counters = {}\n\tfor (var i = 0; i < entries.length; i++) {\n\t\tvar entry = entries[i].split("=")\n\t\tvar key5 = decodeURIComponent(entry[0])\n\t\tvar value = entry.length === 2 ? decodeURIComponent(entry[1]) : ""\n\t\tif (value === "true") value = true\n\t\telse if (value === "false") value = false\n\t\tvar levels = key5.split(/\\]\\[?|\\[/)\n\t\tvar cursor = data0\n\t\tif (key5.indexOf("[") > -1) levels.pop()\n\t\tfor (var j = 0; j < levels.length; j++) {\n\t\t\tvar level = levels[j], nextLevel = levels[j + 1]\n\t\t\tvar isNumber = nextLevel == "" || !isNaN(parseInt(nextLevel, 10))\n\t\t\tvar isValue = j === levels.length - 1\n\t\t\tif (level === "") {\n\t\t\t\tvar key5 = levels.slice(0, j).join()\n\t\t\t\tif (counters[key5] == null) counters[key5] = 0\n\t\t\t\tlevel = counters[key5]++\n\t\t\t}\n\t\t\tif (cursor[level] == null) {\n\t\t\t\tcursor[level] = isValue ? value : isNumber ? [] : {}\n\t\t\t}\n\t\t\tcursor = cursor[level]\n\t\t}\n\t}\n\treturn data0\n}\nvar coreRouter = function($window) {\n\tvar supportsPushState = typeof $window.history.pushState === "function"\n\tvar callAsync0 = typeof setImmediate === "function" ? setImmediate : setTimeout\n\tfunction normalize1(fragment0) {\n\t\tvar data = $window.location[fragment0].replace(/(?:%[a-f89][a-f0-9])+/gim, decodeURIComponent)\n\t\tif (fragment0 === "pathname" && data[0] !== "/") data = "/" + data\n\t\treturn data\n\t}\n\tvar asyncId\n\tfunction debounceAsync(callback0) {\n\t\treturn function() {\n\t\t\tif (asyncId != null) return\n\t\t\tasyncId = callAsync0(function() {\n\t\t\t\tasyncId = null\n\t\t\t\tcallback0()\n\t\t\t})\n\t\t}\n\t}\n\tfunction parsePath(path, queryData, hashData) {\n\t\tvar queryIndex = path.indexOf("?")\n\t\tvar hashIndex = path.indexOf("#")\n\t\tvar pathEnd = queryIndex > -1 ? queryIndex : hashIndex > -1 ? hashIndex : path.length\n\t\tif (queryIndex > -1) {\n\t\t\tvar queryEnd = hashIndex > -1 ? hashIndex : path.length\n\t\t\tvar queryParams = parseQueryString(path.slice(queryIndex + 1, queryEnd))\n\t\t\tfor (var key4 in queryParams) queryData[key4] = queryParams[key4]\n\t\t}\n\t\tif (hashIndex > -1) {\n\t\t\tvar hashParams = parseQueryString(path.slice(hashIndex + 1))\n\t\t\tfor (var key4 in hashParams) hashData[key4] = hashParams[key4]\n\t\t}\n\t\treturn path.slice(0, pathEnd)\n\t}\n\tvar router = {prefix: "#!"}\n\trouter.getPath = function() {\n\t\tvar type2 = router.prefix.charAt(0)\n\t\tswitch (type2) {\n\t\t\tcase "#": return normalize1("hash").slice(router.prefix.length)\n\t\t\tcase "?": return normalize1("search").slice(router.prefix.length) + normalize1("hash")\n\t\t\tdefault: return normalize1("pathname").slice(router.prefix.length) + normalize1("search") + normalize1("hash")\n\t\t}\n\t}\n\trouter.setPath = function(path, data, options) {\n\t\tvar queryData = {}, hashData = {}\n\t\tpath = parsePath(path, queryData, hashData)\n\t\tif (data != null) {\n\t\t\tfor (var key4 in data) queryData[key4] = data[key4]\n\t\t\tpath = path.replace(/:([^\\/]+)/g, function(match2, token) {\n\t\t\t\tdelete queryData[token]\n\t\t\t\treturn data[token]\n\t\t\t})\n\t\t}\n\t\tvar query = buildQueryString(queryData)\n\t\tif (query) path += "?" + query\n\t\tvar hash = buildQueryString(hashData)\n\t\tif (hash) path += "#" + hash\n\t\tif (supportsPushState) {\n\t\t\tvar state = options ? options.state : null\n\t\t\tvar title = options ? options.title : null\n\t\t\t$window.onpopstate()\n\t\t\tif (options && options.replace) $window.history.replaceState(state, title, router.prefix + path)\n\t\t\telse $window.history.pushState(state, title, router.prefix + path)\n\t\t}\n\t\telse $window.location.href = router.prefix + path\n\t}\n\trouter.defineRoutes = function(routes, resolve, reject) {\n\t\tfunction resolveRoute() {\n\t\t\tvar path = router.getPath()\n\t\t\tvar params = {}\n\t\t\tvar pathname = parsePath(path, params, params)\n\t\t\tvar state = $window.history.state\n\t\t\tif (state != null) {\n\t\t\t\tfor (var k in state) params[k] = state[k]\n\t\t\t}\n\t\t\tfor (var route0 in routes) {\n\t\t\t\tvar matcher = new RegExp("^" + route0.replace(/:[^\\/]+?\\.{3}/g, "(.*?)").replace(/:[^\\/]+/g, "([^\\\\/]+)") + "\\/?$")\n\t\t\t\tif (matcher.test(pathname)) {\n\t\t\t\t\tpathname.replace(matcher, function() {\n\t\t\t\t\t\tvar keys = route0.match(/:[^\\/]+/g) || []\n\t\t\t\t\t\tvar values = [].slice.call(arguments, 1, -2)\n\t\t\t\t\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\t\t\t\t\tparams[keys[i].replace(/:|\\./g, "")] = decodeURIComponent(values[i])\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresolve(routes[route0], params, path, route0)\n\t\t\t\t\t})\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\treject(path, params)\n\t\t}\n\t\tif (supportsPushState) $window.onpopstate = debounceAsync(resolveRoute)\n\t\telse if (router.prefix.charAt(0) === "#") $window.onhashchange = resolveRoute\n\t\tresolveRoute()\n\t}\n\treturn router\n}\nvar _20 = function($window, redrawService0) {\n\tvar routeService = coreRouter($window)\n\tvar identity = function(v) {return v}\n\tvar render1, component, attrs3, currentPath, lastUpdate\n\tvar route = function(root, defaultRoute, routes) {\n\t\tif (root == null) throw new Error("Ensure the DOM element that was passed to `m.route` is not undefined")\n\t\tvar run1 = function() {\n\t\t\tif (render1 != null) redrawService0.render(root, render1(Vnode(component, attrs3.key, attrs3)))\n\t\t}\n\t\tvar bail = function(path) {\n\t\t\tif (path !== defaultRoute) routeService.setPath(defaultRoute, null, {replace: true})\n\t\t\telse throw new Error("Could not resolve default route " + defaultRoute)\n\t\t}\n\t\trouteService.defineRoutes(routes, function(payload, params, path) {\n\t\t\tvar update = lastUpdate = function(routeResolver, comp) {\n\t\t\t\tif (update !== lastUpdate) return\n\t\t\t\tcomponent = comp != null && (typeof comp.view === "function" || typeof comp === "function")? comp : "div"\n\t\t\t\tattrs3 = params, currentPath = path, lastUpdate = null\n\t\t\t\trender1 = (routeResolver.render || identity).bind(routeResolver)\n\t\t\t\trun1()\n\t\t\t}\n\t\t\tif (payload.view || typeof payload === "function") update({}, payload)\n\t\t\telse {\n\t\t\t\tif (payload.onmatch) {\n\t\t\t\t\tPromise.resolve(payload.onmatch(params, path)).then(function(resolved) {\n\t\t\t\t\t\tupdate(payload, resolved)\n\t\t\t\t\t}, bail)\n\t\t\t\t}\n\t\t\t\telse update(payload, "div")\n\t\t\t}\n\t\t}, bail)\n\t\tredrawService0.subscribe(root, run1)\n\t}\n\troute.set = function(path, data, options) {\n\t\tif (lastUpdate != null) {\n\t\t\toptions = options || {}\n\t\t\toptions.replace = true\n\t\t}\n\t\tlastUpdate = null\n\t\trouteService.setPath(path, data, options)\n\t}\n\troute.get = function() {return currentPath}\n\troute.prefix = function(prefix0) {routeService.prefix = prefix0}\n\troute.link = function(vnode1) {\n\t\tvnode1.dom.setAttribute("href", routeService.prefix + vnode1.attrs.href)\n\t\tvnode1.dom.onclick = function(e) {\n\t\t\tif (e.ctrlKey || e.metaKey || e.shiftKey || e.which === 2) return\n\t\t\te.preventDefault()\n\t\t\te.redraw = false\n\t\t\tvar href = this.getAttribute("href")\n\t\t\tif (href.indexOf(routeService.prefix) === 0) href = href.slice(routeService.prefix.length)\n\t\t\troute.set(href, undefined, undefined)\n\t\t}\n\t}\n\troute.param = function(key3) {\n\t\tif(typeof attrs3 !== "undefined" && typeof key3 !== "undefined") return attrs3[key3]\n\t\treturn attrs3\n\t}\n\treturn route\n}\nm.route = _20(window, redrawService)\nm.withAttr = function(attrName, callback1, context) {\n\treturn function(e) {\n\t\tcallback1.call(context || this, attrName in e.currentTarget ? e.currentTarget[attrName] : e.currentTarget.getAttribute(attrName))\n\t}\n}\nvar _28 = coreRenderer(window)\nm.render = _28.render\nm.redraw = redrawService.redraw\nm.request = requestService.request\nm.jsonp = requestService.jsonp\nm.parseQueryString = parseQueryString\nm.buildQueryString = buildQueryString\nm.version = "1.1.3"\nm.vnode = Vnode\nif (true) module["exports"] = m\nelse window.m = m\n}());\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(18).setImmediate, __webpack_require__(4)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21pdGhyaWwvbWl0aHJpbC5qcz9iZDQyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLDZEQUFDO0FBQ0Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxP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QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QyxpQ0FBaUMsT0FBTztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsMkRBQTJEO0FBQzNELHFGQUFxRjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG1CQUFtQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0SEFBNEg7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QyxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsRUFBRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLGNBQWM7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsSSIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiOyhmdW5jdGlvbigpIHtcblwidXNlIHN0cmljdFwiXG5mdW5jdGlvbiBWbm9kZSh0YWcsIGtleSwgYXR0cnMwLCBjaGlsZHJlbiwgdGV4dCwgZG9tKSB7XG5cdHJldHVybiB7dGFnOiB0YWcsIGtleToga2V5LCBhdHRyczogYXR0cnMwLCBjaGlsZHJlbjogY2hpbGRyZW4sIHRleHQ6IHRleHQsIGRvbTogZG9tLCBkb21TaXplOiB1bmRlZmluZWQsIHN0YXRlOiB1bmRlZmluZWQsIF9zdGF0ZTogdW5kZWZpbmVkLCBldmVudHM6IHVuZGVmaW5lZCwgaW5zdGFuY2U6IHVuZGVmaW5lZCwgc2tpcDogZmFsc2V9XG59XG5Wbm9kZS5ub3JtYWxpemUgPSBmdW5jdGlvbihub2RlKSB7XG5cdGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSByZXR1cm4gVm5vZGUoXCJbXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBWbm9kZS5ub3JtYWxpemVDaGlsZHJlbihub2RlKSwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG5cdGlmIChub2RlICE9IG51bGwgJiYgdHlwZW9mIG5vZGUgIT09IFwib2JqZWN0XCIpIHJldHVybiBWbm9kZShcIiNcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG5vZGUgPT09IGZhbHNlID8gXCJcIiA6IG5vZGUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKVxuXHRyZXR1cm4gbm9kZVxufVxuVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4gPSBmdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbikge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0Y2hpbGRyZW5baV0gPSBWbm9kZS5ub3JtYWxpemUoY2hpbGRyZW5baV0pXG5cdH1cblx0cmV0dXJuIGNoaWxkcmVuXG59XG52YXIgc2VsZWN0b3JQYXJzZXIgPSAvKD86KF58I3xcXC4pKFteI1xcLlxcW1xcXV0rKSl8KFxcWyguKz8pKD86XFxzKj1cXHMqKFwifCd8KSgoPzpcXFxcW1wiJ1xcXV18LikqPylcXDUpP1xcXSkvZ1xudmFyIHNlbGVjdG9yQ2FjaGUgPSB7fVxudmFyIGhhc093biA9IHt9Lmhhc093blByb3BlcnR5XG5mdW5jdGlvbiBjb21waWxlU2VsZWN0b3Ioc2VsZWN0b3IpIHtcblx0dmFyIG1hdGNoLCB0YWcgPSBcImRpdlwiLCBjbGFzc2VzID0gW10sIGF0dHJzID0ge31cblx0d2hpbGUgKG1hdGNoID0gc2VsZWN0b3JQYXJzZXIuZXhlYyhzZWxlY3RvcikpIHtcblx0XHR2YXIgdHlwZSA9IG1hdGNoWzFdLCB2YWx1ZSA9IG1hdGNoWzJdXG5cdFx0aWYgKHR5cGUgPT09IFwiXCIgJiYgdmFsdWUgIT09IFwiXCIpIHRhZyA9IHZhbHVlXG5cdFx0ZWxzZSBpZiAodHlwZSA9PT0gXCIjXCIpIGF0dHJzLmlkID0gdmFsdWVcblx0XHRlbHNlIGlmICh0eXBlID09PSBcIi5cIikgY2xhc3Nlcy5wdXNoKHZhbHVlKVxuXHRcdGVsc2UgaWYgKG1hdGNoWzNdWzBdID09PSBcIltcIikge1xuXHRcdFx0dmFyIGF0dHJWYWx1ZSA9IG1hdGNoWzZdXG5cdFx0XHRpZiAoYXR0clZhbHVlKSBhdHRyVmFsdWUgPSBhdHRyVmFsdWUucmVwbGFjZSgvXFxcXChbXCInXSkvZywgXCIkMVwiKS5yZXBsYWNlKC9cXFxcXFxcXC9nLCBcIlxcXFxcIilcblx0XHRcdGlmIChtYXRjaFs0XSA9PT0gXCJjbGFzc1wiKSBjbGFzc2VzLnB1c2goYXR0clZhbHVlKVxuXHRcdFx0ZWxzZSBhdHRyc1ttYXRjaFs0XV0gPSBhdHRyVmFsdWUgPT09IFwiXCIgPyBhdHRyVmFsdWUgOiBhdHRyVmFsdWUgfHwgdHJ1ZVxuXHRcdH1cblx0fVxuXHRpZiAoY2xhc3Nlcy5sZW5ndGggPiAwKSBhdHRycy5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oXCIgXCIpXG5cdHJldHVybiBzZWxlY3RvckNhY2hlW3NlbGVjdG9yXSA9IHt0YWc6IHRhZywgYXR0cnM6IGF0dHJzfVxufVxuZnVuY3Rpb24gZXhlY1NlbGVjdG9yKHN0YXRlLCBhdHRycywgY2hpbGRyZW4pIHtcblx0dmFyIGhhc0F0dHJzID0gZmFsc2UsIGNoaWxkTGlzdCwgdGV4dFxuXHR2YXIgY2xhc3NOYW1lID0gYXR0cnMuY2xhc3NOYW1lIHx8IGF0dHJzLmNsYXNzXG5cdGZvciAodmFyIGtleSBpbiBzdGF0ZS5hdHRycykge1xuXHRcdGlmIChoYXNPd24uY2FsbChzdGF0ZS5hdHRycywga2V5KSkge1xuXHRcdFx0YXR0cnNba2V5XSA9IHN0YXRlLmF0dHJzW2tleV1cblx0XHR9XG5cdH1cblx0aWYgKGNsYXNzTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0aWYgKGF0dHJzLmNsYXNzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGF0dHJzLmNsYXNzID0gdW5kZWZpbmVkXG5cdFx0XHRhdHRycy5jbGFzc05hbWUgPSBjbGFzc05hbWVcblx0XHR9XG5cdFx0aWYgKHN0YXRlLmF0dHJzLmNsYXNzTmFtZSAhPSBudWxsKSB7XG5cdFx0XHRhdHRycy5jbGFzc05hbWUgPSBzdGF0ZS5hdHRycy5jbGFzc05hbWUgKyBcIiBcIiArIGNsYXNzTmFtZVxuXHRcdH1cblx0fVxuXHRmb3IgKHZhciBrZXkgaW4gYXR0cnMpIHtcblx0XHRpZiAoaGFzT3duLmNhbGwoYXR0cnMsIGtleSkgJiYga2V5ICE9PSBcImtleVwiKSB7XG5cdFx0XHRoYXNBdHRycyA9IHRydWVcblx0XHRcdGJyZWFrXG5cdFx0fVxuXHR9XG5cdGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJiBjaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgY2hpbGRyZW5bMF0gIT0gbnVsbCAmJiBjaGlsZHJlblswXS50YWcgPT09IFwiI1wiKSB7XG5cdFx0dGV4dCA9IGNoaWxkcmVuWzBdLmNoaWxkcmVuXG5cdH0gZWxzZSB7XG5cdFx0Y2hpbGRMaXN0ID0gY2hpbGRyZW5cblx0fVxuXHRyZXR1cm4gVm5vZGUoc3RhdGUudGFnLCBhdHRycy5rZXksIGhhc0F0dHJzID8gYXR0cnMgOiB1bmRlZmluZWQsIGNoaWxkTGlzdCwgdGV4dClcbn1cbmZ1bmN0aW9uIGh5cGVyc2NyaXB0KHNlbGVjdG9yKSB7XG5cdC8vIEJlY2F1c2Ugc2xvcHB5IG1vZGUgc3Vja3Ncblx0dmFyIGF0dHJzID0gYXJndW1lbnRzWzFdLCBzdGFydCA9IDIsIGNoaWxkcmVuXG5cdGlmIChzZWxlY3RvciA9PSBudWxsIHx8IHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygc2VsZWN0b3IgIT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygc2VsZWN0b3IudmlldyAhPT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0dGhyb3cgRXJyb3IoXCJUaGUgc2VsZWN0b3IgbXVzdCBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgYSBjb21wb25lbnQuXCIpO1xuXHR9XG5cdGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIpIHtcblx0XHR2YXIgY2FjaGVkID0gc2VsZWN0b3JDYWNoZVtzZWxlY3Rvcl0gfHwgY29tcGlsZVNlbGVjdG9yKHNlbGVjdG9yKVxuXHR9XG5cdGlmIChhdHRycyA9PSBudWxsKSB7XG5cdFx0YXR0cnMgPSB7fVxuXHR9IGVsc2UgaWYgKHR5cGVvZiBhdHRycyAhPT0gXCJvYmplY3RcIiB8fCBhdHRycy50YWcgIT0gbnVsbCB8fCBBcnJheS5pc0FycmF5KGF0dHJzKSkge1xuXHRcdGF0dHJzID0ge31cblx0XHRzdGFydCA9IDFcblx0fVxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gc3RhcnQgKyAxKSB7XG5cdFx0Y2hpbGRyZW4gPSBhcmd1bWVudHNbc3RhcnRdXG5cdFx0aWYgKCFBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkgY2hpbGRyZW4gPSBbY2hpbGRyZW5dXG5cdH0gZWxzZSB7XG5cdFx0Y2hpbGRyZW4gPSBbXVxuXHRcdHdoaWxlIChzdGFydCA8IGFyZ3VtZW50cy5sZW5ndGgpIGNoaWxkcmVuLnB1c2goYXJndW1lbnRzW3N0YXJ0KytdKVxuXHR9XG5cdHZhciBub3JtYWxpemVkID0gVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pXG5cdGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIpIHtcblx0XHRyZXR1cm4gZXhlY1NlbGVjdG9yKGNhY2hlZCwgYXR0cnMsIG5vcm1hbGl6ZWQpXG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIFZub2RlKHNlbGVjdG9yLCBhdHRycy5rZXksIGF0dHJzLCBub3JtYWxpemVkKVxuXHR9XG59XG5oeXBlcnNjcmlwdC50cnVzdCA9IGZ1bmN0aW9uKGh0bWwpIHtcblx0aWYgKGh0bWwgPT0gbnVsbCkgaHRtbCA9IFwiXCJcblx0cmV0dXJuIFZub2RlKFwiPFwiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaHRtbCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG59XG5oeXBlcnNjcmlwdC5mcmFnbWVudCA9IGZ1bmN0aW9uKGF0dHJzMSwgY2hpbGRyZW4pIHtcblx0cmV0dXJuIFZub2RlKFwiW1wiLCBhdHRyczEua2V5LCBhdHRyczEsIFZub2RlLm5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKSwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG59XG52YXIgbSA9IGh5cGVyc2NyaXB0XG4vKiogQGNvbnN0cnVjdG9yICovXG52YXIgUHJvbWlzZVBvbHlmaWxsID0gZnVuY3Rpb24oZXhlY3V0b3IpIHtcblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIFByb21pc2VQb2x5ZmlsbCkpIHRocm93IG5ldyBFcnJvcihcIlByb21pc2UgbXVzdCBiZSBjYWxsZWQgd2l0aCBgbmV3YFwiKVxuXHRpZiAodHlwZW9mIGV4ZWN1dG9yICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJleGVjdXRvciBtdXN0IGJlIGEgZnVuY3Rpb25cIilcblx0dmFyIHNlbGYgPSB0aGlzLCByZXNvbHZlcnMgPSBbXSwgcmVqZWN0b3JzID0gW10sIHJlc29sdmVDdXJyZW50ID0gaGFuZGxlcihyZXNvbHZlcnMsIHRydWUpLCByZWplY3RDdXJyZW50ID0gaGFuZGxlcihyZWplY3RvcnMsIGZhbHNlKVxuXHR2YXIgaW5zdGFuY2UgPSBzZWxmLl9pbnN0YW5jZSA9IHtyZXNvbHZlcnM6IHJlc29sdmVycywgcmVqZWN0b3JzOiByZWplY3RvcnN9XG5cdHZhciBjYWxsQXN5bmMgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBzZXRJbW1lZGlhdGUgOiBzZXRUaW1lb3V0XG5cdGZ1bmN0aW9uIGhhbmRsZXIobGlzdCwgc2hvdWxkQWJzb3JiKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGV4ZWN1dGUodmFsdWUpIHtcblx0XHRcdHZhciB0aGVuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAoc2hvdWxkQWJzb3JiICYmIHZhbHVlICE9IG51bGwgJiYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikgJiYgdHlwZW9mICh0aGVuID0gdmFsdWUudGhlbikgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdGlmICh2YWx1ZSA9PT0gc2VsZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByb21pc2UgY2FuJ3QgYmUgcmVzb2x2ZWQgdy8gaXRzZWxmXCIpXG5cdFx0XHRcdFx0ZXhlY3V0ZU9uY2UodGhlbi5iaW5kKHZhbHVlKSlcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRjYWxsQXN5bmMoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRpZiAoIXNob3VsZEFic29yYiAmJiBsaXN0Lmxlbmd0aCA9PT0gMCkgY29uc29sZS5lcnJvcihcIlBvc3NpYmxlIHVuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbjpcIiwgdmFsdWUpXG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIGxpc3RbaV0odmFsdWUpXG5cdFx0XHRcdFx0XHRyZXNvbHZlcnMubGVuZ3RoID0gMCwgcmVqZWN0b3JzLmxlbmd0aCA9IDBcblx0XHRcdFx0XHRcdGluc3RhbmNlLnN0YXRlID0gc2hvdWxkQWJzb3JiXG5cdFx0XHRcdFx0XHRpbnN0YW5jZS5yZXRyeSA9IGZ1bmN0aW9uKCkge2V4ZWN1dGUodmFsdWUpfVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGNhdGNoIChlKSB7XG5cdFx0XHRcdHJlamVjdEN1cnJlbnQoZSlcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gZXhlY3V0ZU9uY2UodGhlbikge1xuXHRcdHZhciBydW5zID0gMFxuXHRcdGZ1bmN0aW9uIHJ1bihmbikge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdGlmIChydW5zKysgPiAwKSByZXR1cm5cblx0XHRcdFx0Zm4odmFsdWUpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHZhciBvbmVycm9yID0gcnVuKHJlamVjdEN1cnJlbnQpXG5cdFx0dHJ5IHt0aGVuKHJ1bihyZXNvbHZlQ3VycmVudCksIG9uZXJyb3IpfSBjYXRjaCAoZSkge29uZXJyb3IoZSl9XG5cdH1cblx0ZXhlY3V0ZU9uY2UoZXhlY3V0b3IpXG59XG5Qcm9taXNlUG9seWZpbGwucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbihvbkZ1bGZpbGxlZCwgb25SZWplY3Rpb24pIHtcblx0dmFyIHNlbGYgPSB0aGlzLCBpbnN0YW5jZSA9IHNlbGYuX2luc3RhbmNlXG5cdGZ1bmN0aW9uIGhhbmRsZShjYWxsYmFjaywgbGlzdCwgbmV4dCwgc3RhdGUpIHtcblx0XHRsaXN0LnB1c2goZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikgbmV4dCh2YWx1ZSlcblx0XHRcdGVsc2UgdHJ5IHtyZXNvbHZlTmV4dChjYWxsYmFjayh2YWx1ZSkpfSBjYXRjaCAoZSkge2lmIChyZWplY3ROZXh0KSByZWplY3ROZXh0KGUpfVxuXHRcdH0pXG5cdFx0aWYgKHR5cGVvZiBpbnN0YW5jZS5yZXRyeSA9PT0gXCJmdW5jdGlvblwiICYmIHN0YXRlID09PSBpbnN0YW5jZS5zdGF0ZSkgaW5zdGFuY2UucmV0cnkoKVxuXHR9XG5cdHZhciByZXNvbHZlTmV4dCwgcmVqZWN0TmV4dFxuXHR2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlUG9seWZpbGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7cmVzb2x2ZU5leHQgPSByZXNvbHZlLCByZWplY3ROZXh0ID0gcmVqZWN0fSlcblx0aGFuZGxlKG9uRnVsZmlsbGVkLCBpbnN0YW5jZS5yZXNvbHZlcnMsIHJlc29sdmVOZXh0LCB0cnVlKSwgaGFuZGxlKG9uUmVqZWN0aW9uLCBpbnN0YW5jZS5yZWplY3RvcnMsIHJlamVjdE5leHQsIGZhbHNlKVxuXHRyZXR1cm4gcHJvbWlzZVxufVxuUHJvbWlzZVBvbHlmaWxsLnByb3RvdHlwZS5jYXRjaCA9IGZ1bmN0aW9uKG9uUmVqZWN0aW9uKSB7XG5cdHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3Rpb24pXG59XG5Qcm9taXNlUG9seWZpbGwucmVzb2x2ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2VQb2x5ZmlsbCkgcmV0dXJuIHZhbHVlXG5cdHJldHVybiBuZXcgUHJvbWlzZVBvbHlmaWxsKGZ1bmN0aW9uKHJlc29sdmUpIHtyZXNvbHZlKHZhbHVlKX0pXG59XG5Qcm9taXNlUG9seWZpbGwucmVqZWN0ID0gZnVuY3Rpb24odmFsdWUpIHtcblx0cmV0dXJuIG5ldyBQcm9taXNlUG9seWZpbGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7cmVqZWN0KHZhbHVlKX0pXG59XG5Qcm9taXNlUG9seWZpbGwuYWxsID0gZnVuY3Rpb24obGlzdCkge1xuXHRyZXR1cm4gbmV3IFByb21pc2VQb2x5ZmlsbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHR2YXIgdG90YWwgPSBsaXN0Lmxlbmd0aCwgY291bnQgPSAwLCB2YWx1ZXMgPSBbXVxuXHRcdGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkgcmVzb2x2ZShbXSlcblx0XHRlbHNlIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdFx0KGZ1bmN0aW9uKGkpIHtcblx0XHRcdFx0ZnVuY3Rpb24gY29uc3VtZSh2YWx1ZSkge1xuXHRcdFx0XHRcdGNvdW50Kytcblx0XHRcdFx0XHR2YWx1ZXNbaV0gPSB2YWx1ZVxuXHRcdFx0XHRcdGlmIChjb3VudCA9PT0gdG90YWwpIHJlc29sdmUodmFsdWVzKVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChsaXN0W2ldICE9IG51bGwgJiYgKHR5cGVvZiBsaXN0W2ldID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBsaXN0W2ldID09PSBcImZ1bmN0aW9uXCIpICYmIHR5cGVvZiBsaXN0W2ldLnRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdGxpc3RbaV0udGhlbihjb25zdW1lLCByZWplY3QpXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBjb25zdW1lKGxpc3RbaV0pXG5cdFx0XHR9KShpKVxuXHRcdH1cblx0fSlcbn1cblByb21pc2VQb2x5ZmlsbC5yYWNlID0gZnVuY3Rpb24obGlzdCkge1xuXHRyZXR1cm4gbmV3IFByb21pc2VQb2x5ZmlsbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHRcdGxpc3RbaV0udGhlbihyZXNvbHZlLCByZWplY3QpXG5cdFx0fVxuXHR9KVxufVxuaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcblx0aWYgKHR5cGVvZiB3aW5kb3cuUHJvbWlzZSA9PT0gXCJ1bmRlZmluZWRcIikgd2luZG93LlByb21pc2UgPSBQcm9taXNlUG9seWZpbGxcblx0dmFyIFByb21pc2VQb2x5ZmlsbCA9IHdpbmRvdy5Qcm9taXNlXG59IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcblx0aWYgKHR5cGVvZiBnbG9iYWwuUHJvbWlzZSA9PT0gXCJ1bmRlZmluZWRcIikgZ2xvYmFsLlByb21pc2UgPSBQcm9taXNlUG9seWZpbGxcblx0dmFyIFByb21pc2VQb2x5ZmlsbCA9IGdsb2JhbC5Qcm9taXNlXG59IGVsc2Uge1xufVxudmFyIGJ1aWxkUXVlcnlTdHJpbmcgPSBmdW5jdGlvbihvYmplY3QpIHtcblx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpICE9PSBcIltvYmplY3QgT2JqZWN0XVwiKSByZXR1cm4gXCJcIlxuXHR2YXIgYXJncyA9IFtdXG5cdGZvciAodmFyIGtleTAgaW4gb2JqZWN0KSB7XG5cdFx0ZGVzdHJ1Y3R1cmUoa2V5MCwgb2JqZWN0W2tleTBdKVxuXHR9XG5cdHJldHVybiBhcmdzLmpvaW4oXCImXCIpXG5cdGZ1bmN0aW9uIGRlc3RydWN0dXJlKGtleTAsIHZhbHVlKSB7XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGRlc3RydWN0dXJlKGtleTAgKyBcIltcIiArIGkgKyBcIl1cIiwgdmFsdWVbaV0pXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09IFwiW29iamVjdCBPYmplY3RdXCIpIHtcblx0XHRcdGZvciAodmFyIGkgaW4gdmFsdWUpIHtcblx0XHRcdFx0ZGVzdHJ1Y3R1cmUoa2V5MCArIFwiW1wiICsgaSArIFwiXVwiLCB2YWx1ZVtpXSlcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBhcmdzLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleTApICsgKHZhbHVlICE9IG51bGwgJiYgdmFsdWUgIT09IFwiXCIgPyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkgOiBcIlwiKSlcblx0fVxufVxudmFyIEZJTEVfUFJPVE9DT0xfUkVHRVggPSBuZXcgUmVnRXhwKFwiXmZpbGU6Ly9cIiwgXCJpXCIpXG52YXIgXzggPSBmdW5jdGlvbigkd2luZG93LCBQcm9taXNlKSB7XG5cdHZhciBjYWxsYmFja0NvdW50ID0gMFxuXHR2YXIgb25jb21wbGV0aW9uXG5cdGZ1bmN0aW9uIHNldENvbXBsZXRpb25DYWxsYmFjayhjYWxsYmFjaykge29uY29tcGxldGlvbiA9IGNhbGxiYWNrfVxuXHRmdW5jdGlvbiBmaW5hbGl6ZXIoKSB7XG5cdFx0dmFyIGNvdW50ID0gMFxuXHRcdGZ1bmN0aW9uIGNvbXBsZXRlKCkge2lmICgtLWNvdW50ID09PSAwICYmIHR5cGVvZiBvbmNvbXBsZXRpb24gPT09IFwiZnVuY3Rpb25cIikgb25jb21wbGV0aW9uKCl9XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGZpbmFsaXplKHByb21pc2UwKSB7XG5cdFx0XHR2YXIgdGhlbjAgPSBwcm9taXNlMC50aGVuXG5cdFx0XHRwcm9taXNlMC50aGVuID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNvdW50Kytcblx0XHRcdFx0dmFyIG5leHQgPSB0aGVuMC5hcHBseShwcm9taXNlMCwgYXJndW1lbnRzKVxuXHRcdFx0XHRuZXh0LnRoZW4oY29tcGxldGUsIGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0XHRjb21wbGV0ZSgpXG5cdFx0XHRcdFx0aWYgKGNvdW50ID09PSAwKSB0aHJvdyBlXG5cdFx0XHRcdH0pXG5cdFx0XHRcdHJldHVybiBmaW5hbGl6ZShuZXh0KVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHByb21pc2UwXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIG5vcm1hbGl6ZShhcmdzLCBleHRyYSkge1xuXHRcdGlmICh0eXBlb2YgYXJncyA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0dmFyIHVybCA9IGFyZ3Ncblx0XHRcdGFyZ3MgPSBleHRyYSB8fCB7fVxuXHRcdFx0aWYgKGFyZ3MudXJsID09IG51bGwpIGFyZ3MudXJsID0gdXJsXG5cdFx0fVxuXHRcdHJldHVybiBhcmdzXG5cdH1cblx0ZnVuY3Rpb24gcmVxdWVzdChhcmdzLCBleHRyYSkge1xuXHRcdHZhciBmaW5hbGl6ZSA9IGZpbmFsaXplcigpXG5cdFx0YXJncyA9IG5vcm1hbGl6ZShhcmdzLCBleHRyYSlcblx0XHR2YXIgcHJvbWlzZTAgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHRcdGlmIChhcmdzLm1ldGhvZCA9PSBudWxsKSBhcmdzLm1ldGhvZCA9IFwiR0VUXCJcblx0XHRcdGFyZ3MubWV0aG9kID0gYXJncy5tZXRob2QudG9VcHBlckNhc2UoKVxuXHRcdFx0dmFyIHVzZUJvZHkgPSAoYXJncy5tZXRob2QgPT09IFwiR0VUXCIgfHwgYXJncy5tZXRob2QgPT09IFwiVFJBQ0VcIikgPyBmYWxzZSA6ICh0eXBlb2YgYXJncy51c2VCb2R5ID09PSBcImJvb2xlYW5cIiA/IGFyZ3MudXNlQm9keSA6IHRydWUpXG5cdFx0XHRpZiAodHlwZW9mIGFyZ3Muc2VyaWFsaXplICE9PSBcImZ1bmN0aW9uXCIpIGFyZ3Muc2VyaWFsaXplID0gdHlwZW9mIEZvcm1EYXRhICE9PSBcInVuZGVmaW5lZFwiICYmIGFyZ3MuZGF0YSBpbnN0YW5jZW9mIEZvcm1EYXRhID8gZnVuY3Rpb24odmFsdWUpIHtyZXR1cm4gdmFsdWV9IDogSlNPTi5zdHJpbmdpZnlcblx0XHRcdGlmICh0eXBlb2YgYXJncy5kZXNlcmlhbGl6ZSAhPT0gXCJmdW5jdGlvblwiKSBhcmdzLmRlc2VyaWFsaXplID0gZGVzZXJpYWxpemVcblx0XHRcdGlmICh0eXBlb2YgYXJncy5leHRyYWN0ICE9PSBcImZ1bmN0aW9uXCIpIGFyZ3MuZXh0cmFjdCA9IGV4dHJhY3Rcblx0XHRcdGFyZ3MudXJsID0gaW50ZXJwb2xhdGUoYXJncy51cmwsIGFyZ3MuZGF0YSlcblx0XHRcdGlmICh1c2VCb2R5KSBhcmdzLmRhdGEgPSBhcmdzLnNlcmlhbGl6ZShhcmdzLmRhdGEpXG5cdFx0XHRlbHNlIGFyZ3MudXJsID0gYXNzZW1ibGUoYXJncy51cmwsIGFyZ3MuZGF0YSlcblx0XHRcdHZhciB4aHIgPSBuZXcgJHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpLFxuXHRcdFx0XHRhYm9ydGVkID0gZmFsc2UsXG5cdFx0XHRcdF9hYm9ydCA9IHhoci5hYm9ydFxuXHRcdFx0eGhyLmFib3J0ID0gZnVuY3Rpb24gYWJvcnQoKSB7XG5cdFx0XHRcdGFib3J0ZWQgPSB0cnVlXG5cdFx0XHRcdF9hYm9ydC5jYWxsKHhocilcblx0XHRcdH1cblx0XHRcdHhoci5vcGVuKGFyZ3MubWV0aG9kLCBhcmdzLnVybCwgdHlwZW9mIGFyZ3MuYXN5bmMgPT09IFwiYm9vbGVhblwiID8gYXJncy5hc3luYyA6IHRydWUsIHR5cGVvZiBhcmdzLnVzZXIgPT09IFwic3RyaW5nXCIgPyBhcmdzLnVzZXIgOiB1bmRlZmluZWQsIHR5cGVvZiBhcmdzLnBhc3N3b3JkID09PSBcInN0cmluZ1wiID8gYXJncy5wYXNzd29yZCA6IHVuZGVmaW5lZClcblx0XHRcdGlmIChhcmdzLnNlcmlhbGl6ZSA9PT0gSlNPTi5zdHJpbmdpZnkgJiYgdXNlQm9keSkge1xuXHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiLCBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIilcblx0XHRcdH1cblx0XHRcdGlmIChhcmdzLmRlc2VyaWFsaXplID09PSBkZXNlcmlhbGl6ZSkge1xuXHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkFjY2VwdFwiLCBcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvKlwiKVxuXHRcdFx0fVxuXHRcdFx0aWYgKGFyZ3Mud2l0aENyZWRlbnRpYWxzKSB4aHIud2l0aENyZWRlbnRpYWxzID0gYXJncy53aXRoQ3JlZGVudGlhbHNcblx0XHRcdGZvciAodmFyIGtleSBpbiBhcmdzLmhlYWRlcnMpIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFyZ3MuaGVhZGVycywga2V5KSkge1xuXHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIGFyZ3MuaGVhZGVyc1trZXldKVxuXHRcdFx0fVxuXHRcdFx0aWYgKHR5cGVvZiBhcmdzLmNvbmZpZyA9PT0gXCJmdW5jdGlvblwiKSB4aHIgPSBhcmdzLmNvbmZpZyh4aHIsIGFyZ3MpIHx8IHhoclxuXHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBEb24ndCB0aHJvdyBlcnJvcnMgb24geGhyLmFib3J0KCkuXG5cdFx0XHRcdGlmKGFib3J0ZWQpIHJldHVyblxuXHRcdFx0XHRpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0dmFyIHJlc3BvbnNlID0gKGFyZ3MuZXh0cmFjdCAhPT0gZXh0cmFjdCkgPyBhcmdzLmV4dHJhY3QoeGhyLCBhcmdzKSA6IGFyZ3MuZGVzZXJpYWxpemUoYXJncy5leHRyYWN0KHhociwgYXJncykpXG5cdFx0XHRcdFx0XHRpZiAoKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDApIHx8IHhoci5zdGF0dXMgPT09IDMwNCB8fCBGSUxFX1BST1RPQ09MX1JFR0VYLnRlc3QoYXJncy51cmwpKSB7XG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoY2FzdChhcmdzLnR5cGUsIHJlc3BvbnNlKSlcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR2YXIgZXJyb3IgPSBuZXcgRXJyb3IoeGhyLnJlc3BvbnNlVGV4dClcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIga2V5IGluIHJlc3BvbnNlKSBlcnJvcltrZXldID0gcmVzcG9uc2Vba2V5XVxuXHRcdFx0XHRcdFx0XHRyZWplY3QoZXJyb3IpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0XHRyZWplY3QoZSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICh1c2VCb2R5ICYmIChhcmdzLmRhdGEgIT0gbnVsbCkpIHhoci5zZW5kKGFyZ3MuZGF0YSlcblx0XHRcdGVsc2UgeGhyLnNlbmQoKVxuXHRcdH0pXG5cdFx0cmV0dXJuIGFyZ3MuYmFja2dyb3VuZCA9PT0gdHJ1ZSA/IHByb21pc2UwIDogZmluYWxpemUocHJvbWlzZTApXG5cdH1cblx0ZnVuY3Rpb24ganNvbnAoYXJncywgZXh0cmEpIHtcblx0XHR2YXIgZmluYWxpemUgPSBmaW5hbGl6ZXIoKVxuXHRcdGFyZ3MgPSBub3JtYWxpemUoYXJncywgZXh0cmEpXG5cdFx0dmFyIHByb21pc2UwID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0XHR2YXIgY2FsbGJhY2tOYW1lID0gYXJncy5jYWxsYmFja05hbWUgfHwgXCJfbWl0aHJpbF9cIiArIE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDFlMTYpICsgXCJfXCIgKyBjYWxsYmFja0NvdW50Kytcblx0XHRcdHZhciBzY3JpcHQgPSAkd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIilcblx0XHRcdCR3aW5kb3dbY2FsbGJhY2tOYW1lXSA9IGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdFx0c2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KVxuXHRcdFx0XHRyZXNvbHZlKGNhc3QoYXJncy50eXBlLCBkYXRhKSlcblx0XHRcdFx0ZGVsZXRlICR3aW5kb3dbY2FsbGJhY2tOYW1lXVxuXHRcdFx0fVxuXHRcdFx0c2NyaXB0Lm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KVxuXHRcdFx0XHRyZWplY3QobmV3IEVycm9yKFwiSlNPTlAgcmVxdWVzdCBmYWlsZWRcIikpXG5cdFx0XHRcdGRlbGV0ZSAkd2luZG93W2NhbGxiYWNrTmFtZV1cblx0XHRcdH1cblx0XHRcdGlmIChhcmdzLmRhdGEgPT0gbnVsbCkgYXJncy5kYXRhID0ge31cblx0XHRcdGFyZ3MudXJsID0gaW50ZXJwb2xhdGUoYXJncy51cmwsIGFyZ3MuZGF0YSlcblx0XHRcdGFyZ3MuZGF0YVthcmdzLmNhbGxiYWNrS2V5IHx8IFwiY2FsbGJhY2tcIl0gPSBjYWxsYmFja05hbWVcblx0XHRcdHNjcmlwdC5zcmMgPSBhc3NlbWJsZShhcmdzLnVybCwgYXJncy5kYXRhKVxuXHRcdFx0JHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoc2NyaXB0KVxuXHRcdH0pXG5cdFx0cmV0dXJuIGFyZ3MuYmFja2dyb3VuZCA9PT0gdHJ1ZT8gcHJvbWlzZTAgOiBmaW5hbGl6ZShwcm9taXNlMClcblx0fVxuXHRmdW5jdGlvbiBpbnRlcnBvbGF0ZSh1cmwsIGRhdGEpIHtcblx0XHRpZiAoZGF0YSA9PSBudWxsKSByZXR1cm4gdXJsXG5cdFx0dmFyIHRva2VucyA9IHVybC5tYXRjaCgvOlteXFwvXSsvZ2kpIHx8IFtdXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBrZXkgPSB0b2tlbnNbaV0uc2xpY2UoMSlcblx0XHRcdGlmIChkYXRhW2tleV0gIT0gbnVsbCkge1xuXHRcdFx0XHR1cmwgPSB1cmwucmVwbGFjZSh0b2tlbnNbaV0sIGRhdGFba2V5XSlcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHVybFxuXHR9XG5cdGZ1bmN0aW9uIGFzc2VtYmxlKHVybCwgZGF0YSkge1xuXHRcdHZhciBxdWVyeXN0cmluZyA9IGJ1aWxkUXVlcnlTdHJpbmcoZGF0YSlcblx0XHRpZiAocXVlcnlzdHJpbmcgIT09IFwiXCIpIHtcblx0XHRcdHZhciBwcmVmaXggPSB1cmwuaW5kZXhPZihcIj9cIikgPCAwID8gXCI/XCIgOiBcIiZcIlxuXHRcdFx0dXJsICs9IHByZWZpeCArIHF1ZXJ5c3RyaW5nXG5cdFx0fVxuXHRcdHJldHVybiB1cmxcblx0fVxuXHRmdW5jdGlvbiBkZXNlcmlhbGl6ZShkYXRhKSB7XG5cdFx0dHJ5IHtyZXR1cm4gZGF0YSAhPT0gXCJcIiA/IEpTT04ucGFyc2UoZGF0YSkgOiBudWxsfVxuXHRcdGNhdGNoIChlKSB7dGhyb3cgbmV3IEVycm9yKGRhdGEpfVxuXHR9XG5cdGZ1bmN0aW9uIGV4dHJhY3QoeGhyKSB7cmV0dXJuIHhoci5yZXNwb25zZVRleHR9XG5cdGZ1bmN0aW9uIGNhc3QodHlwZTAsIGRhdGEpIHtcblx0XHRpZiAodHlwZW9mIHR5cGUwID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGRhdGFbaV0gPSBuZXcgdHlwZTAoZGF0YVtpXSlcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSByZXR1cm4gbmV3IHR5cGUwKGRhdGEpXG5cdFx0fVxuXHRcdHJldHVybiBkYXRhXG5cdH1cblx0cmV0dXJuIHtyZXF1ZXN0OiByZXF1ZXN0LCBqc29ucDoganNvbnAsIHNldENvbXBsZXRpb25DYWxsYmFjazogc2V0Q29tcGxldGlvbkNhbGxiYWNrfVxufVxudmFyIHJlcXVlc3RTZXJ2aWNlID0gXzgod2luZG93LCBQcm9taXNlUG9seWZpbGwpXG52YXIgY29yZVJlbmRlcmVyID0gZnVuY3Rpb24oJHdpbmRvdykge1xuXHR2YXIgJGRvYyA9ICR3aW5kb3cuZG9jdW1lbnRcblx0dmFyICRlbXB0eUZyYWdtZW50ID0gJGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcblx0dmFyIG5hbWVTcGFjZSA9IHtcblx0XHRzdmc6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcblx0XHRtYXRoOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIlxuXHR9XG5cdHZhciBvbmV2ZW50XG5cdGZ1bmN0aW9uIHNldEV2ZW50Q2FsbGJhY2soY2FsbGJhY2spIHtyZXR1cm4gb25ldmVudCA9IGNhbGxiYWNrfVxuXHRmdW5jdGlvbiBnZXROYW1lU3BhY2Uodm5vZGUpIHtcblx0XHRyZXR1cm4gdm5vZGUuYXR0cnMgJiYgdm5vZGUuYXR0cnMueG1sbnMgfHwgbmFtZVNwYWNlW3Zub2RlLnRhZ11cblx0fVxuXHQvL2NyZWF0ZVxuXHRmdW5jdGlvbiBjcmVhdGVOb2RlcyhwYXJlbnQsIHZub2Rlcywgc3RhcnQsIGVuZCwgaG9va3MsIG5leHRTaWJsaW5nLCBucykge1xuXHRcdGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG5cdFx0XHR2YXIgdm5vZGUgPSB2bm9kZXNbaV1cblx0XHRcdGlmICh2bm9kZSAhPSBudWxsKSB7XG5cdFx0XHRcdGNyZWF0ZU5vZGUocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlTm9kZShwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKSB7XG5cdFx0dmFyIHRhZyA9IHZub2RlLnRhZ1xuXHRcdGlmICh0eXBlb2YgdGFnID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHR2bm9kZS5zdGF0ZSA9IHt9XG5cdFx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCkgaW5pdExpZmVjeWNsZSh2bm9kZS5hdHRycywgdm5vZGUsIGhvb2tzKVxuXHRcdFx0c3dpdGNoICh0YWcpIHtcblx0XHRcdFx0Y2FzZSBcIiNcIjogcmV0dXJuIGNyZWF0ZVRleHQocGFyZW50LCB2bm9kZSwgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdGNhc2UgXCI8XCI6IHJldHVybiBjcmVhdGVIVE1MKHBhcmVudCwgdm5vZGUsIG5leHRTaWJsaW5nKVxuXHRcdFx0XHRjYXNlIFwiW1wiOiByZXR1cm4gY3JlYXRlRnJhZ21lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdFx0ZGVmYXVsdDogcmV0dXJuIGNyZWF0ZUVsZW1lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSByZXR1cm4gY3JlYXRlQ29tcG9uZW50KHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlVGV4dChwYXJlbnQsIHZub2RlLCBuZXh0U2libGluZykge1xuXHRcdHZub2RlLmRvbSA9ICRkb2MuY3JlYXRlVGV4dE5vZGUodm5vZGUuY2hpbGRyZW4pXG5cdFx0aW5zZXJ0Tm9kZShwYXJlbnQsIHZub2RlLmRvbSwgbmV4dFNpYmxpbmcpXG5cdFx0cmV0dXJuIHZub2RlLmRvbVxuXHR9XG5cdGZ1bmN0aW9uIGNyZWF0ZUhUTUwocGFyZW50LCB2bm9kZSwgbmV4dFNpYmxpbmcpIHtcblx0XHR2YXIgbWF0Y2gxID0gdm5vZGUuY2hpbGRyZW4ubWF0Y2goL15cXHMqPzwoXFx3KykvaW0pIHx8IFtdXG5cdFx0dmFyIHBhcmVudDEgPSB7Y2FwdGlvbjogXCJ0YWJsZVwiLCB0aGVhZDogXCJ0YWJsZVwiLCB0Ym9keTogXCJ0YWJsZVwiLCB0Zm9vdDogXCJ0YWJsZVwiLCB0cjogXCJ0Ym9keVwiLCB0aDogXCJ0clwiLCB0ZDogXCJ0clwiLCBjb2xncm91cDogXCJ0YWJsZVwiLCBjb2w6IFwiY29sZ3JvdXBcIn1bbWF0Y2gxWzFdXSB8fCBcImRpdlwiXG5cdFx0dmFyIHRlbXAgPSAkZG9jLmNyZWF0ZUVsZW1lbnQocGFyZW50MSlcblx0XHR0ZW1wLmlubmVySFRNTCA9IHZub2RlLmNoaWxkcmVuXG5cdFx0dm5vZGUuZG9tID0gdGVtcC5maXJzdENoaWxkXG5cdFx0dm5vZGUuZG9tU2l6ZSA9IHRlbXAuY2hpbGROb2Rlcy5sZW5ndGhcblx0XHR2YXIgZnJhZ21lbnQgPSAkZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuXHRcdHZhciBjaGlsZFxuXHRcdHdoaWxlIChjaGlsZCA9IHRlbXAuZmlyc3RDaGlsZCkge1xuXHRcdFx0ZnJhZ21lbnQuYXBwZW5kQ2hpbGQoY2hpbGQpXG5cdFx0fVxuXHRcdGluc2VydE5vZGUocGFyZW50LCBmcmFnbWVudCwgbmV4dFNpYmxpbmcpXG5cdFx0cmV0dXJuIGZyYWdtZW50XG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlRnJhZ21lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZykge1xuXHRcdHZhciBmcmFnbWVudCA9ICRkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG5cdFx0aWYgKHZub2RlLmNoaWxkcmVuICE9IG51bGwpIHtcblx0XHRcdHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuXG5cdFx0XHRjcmVhdGVOb2RlcyhmcmFnbWVudCwgY2hpbGRyZW4sIDAsIGNoaWxkcmVuLmxlbmd0aCwgaG9va3MsIG51bGwsIG5zKVxuXHRcdH1cblx0XHR2bm9kZS5kb20gPSBmcmFnbWVudC5maXJzdENoaWxkXG5cdFx0dm5vZGUuZG9tU2l6ZSA9IGZyYWdtZW50LmNoaWxkTm9kZXMubGVuZ3RoXG5cdFx0aW5zZXJ0Tm9kZShwYXJlbnQsIGZyYWdtZW50LCBuZXh0U2libGluZylcblx0XHRyZXR1cm4gZnJhZ21lbnRcblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVFbGVtZW50KHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpIHtcblx0XHR2YXIgdGFnID0gdm5vZGUudGFnXG5cdFx0dmFyIGF0dHJzMiA9IHZub2RlLmF0dHJzXG5cdFx0dmFyIGlzID0gYXR0cnMyICYmIGF0dHJzMi5pc1xuXHRcdG5zID0gZ2V0TmFtZVNwYWNlKHZub2RlKSB8fCBuc1xuXHRcdHZhciBlbGVtZW50ID0gbnMgP1xuXHRcdFx0aXMgPyAkZG9jLmNyZWF0ZUVsZW1lbnROUyhucywgdGFnLCB7aXM6IGlzfSkgOiAkZG9jLmNyZWF0ZUVsZW1lbnROUyhucywgdGFnKSA6XG5cdFx0XHRpcyA/ICRkb2MuY3JlYXRlRWxlbWVudCh0YWcsIHtpczogaXN9KSA6ICRkb2MuY3JlYXRlRWxlbWVudCh0YWcpXG5cdFx0dm5vZGUuZG9tID0gZWxlbWVudFxuXHRcdGlmIChhdHRyczIgIT0gbnVsbCkge1xuXHRcdFx0c2V0QXR0cnModm5vZGUsIGF0dHJzMiwgbnMpXG5cdFx0fVxuXHRcdGluc2VydE5vZGUocGFyZW50LCBlbGVtZW50LCBuZXh0U2libGluZylcblx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCAmJiB2bm9kZS5hdHRycy5jb250ZW50ZWRpdGFibGUgIT0gbnVsbCkge1xuXHRcdFx0c2V0Q29udGVudEVkaXRhYmxlKHZub2RlKVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGlmICh2bm9kZS50ZXh0ICE9IG51bGwpIHtcblx0XHRcdFx0aWYgKHZub2RlLnRleHQgIT09IFwiXCIpIGVsZW1lbnQudGV4dENvbnRlbnQgPSB2bm9kZS50ZXh0XG5cdFx0XHRcdGVsc2Ugdm5vZGUuY2hpbGRyZW4gPSBbVm5vZGUoXCIjXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB2bm9kZS50ZXh0LCB1bmRlZmluZWQsIHVuZGVmaW5lZCldXG5cdFx0XHR9XG5cdFx0XHRpZiAodm5vZGUuY2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0XHR2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlblxuXHRcdFx0XHRjcmVhdGVOb2RlcyhlbGVtZW50LCBjaGlsZHJlbiwgMCwgY2hpbGRyZW4ubGVuZ3RoLCBob29rcywgbnVsbCwgbnMpXG5cdFx0XHRcdHNldExhdGVBdHRycyh2bm9kZSlcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGVsZW1lbnRcblx0fVxuXHRmdW5jdGlvbiBpbml0Q29tcG9uZW50KHZub2RlLCBob29rcykge1xuXHRcdHZhciBzZW50aW5lbFxuXHRcdGlmICh0eXBlb2Ygdm5vZGUudGFnLnZpZXcgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0dm5vZGUuc3RhdGUgPSBPYmplY3QuY3JlYXRlKHZub2RlLnRhZylcblx0XHRcdHNlbnRpbmVsID0gdm5vZGUuc3RhdGUudmlld1xuXHRcdFx0aWYgKHNlbnRpbmVsLiQkcmVlbnRyYW50TG9jayQkICE9IG51bGwpIHJldHVybiAkZW1wdHlGcmFnbWVudFxuXHRcdFx0c2VudGluZWwuJCRyZWVudHJhbnRMb2NrJCQgPSB0cnVlXG5cdFx0fSBlbHNlIHtcblx0XHRcdHZub2RlLnN0YXRlID0gdm9pZCAwXG5cdFx0XHRzZW50aW5lbCA9IHZub2RlLnRhZ1xuXHRcdFx0aWYgKHNlbnRpbmVsLiQkcmVlbnRyYW50TG9jayQkICE9IG51bGwpIHJldHVybiAkZW1wdHlGcmFnbWVudFxuXHRcdFx0c2VudGluZWwuJCRyZWVudHJhbnRMb2NrJCQgPSB0cnVlXG5cdFx0XHR2bm9kZS5zdGF0ZSA9ICh2bm9kZS50YWcucHJvdG90eXBlICE9IG51bGwgJiYgdHlwZW9mIHZub2RlLnRhZy5wcm90b3R5cGUudmlldyA9PT0gXCJmdW5jdGlvblwiKSA/IG5ldyB2bm9kZS50YWcodm5vZGUpIDogdm5vZGUudGFnKHZub2RlKVxuXHRcdH1cblx0XHR2bm9kZS5fc3RhdGUgPSB2bm9kZS5zdGF0ZVxuXHRcdGlmICh2bm9kZS5hdHRycyAhPSBudWxsKSBpbml0TGlmZWN5Y2xlKHZub2RlLmF0dHJzLCB2bm9kZSwgaG9va3MpXG5cdFx0aW5pdExpZmVjeWNsZSh2bm9kZS5fc3RhdGUsIHZub2RlLCBob29rcylcblx0XHR2bm9kZS5pbnN0YW5jZSA9IFZub2RlLm5vcm1hbGl6ZSh2bm9kZS5fc3RhdGUudmlldy5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSkpXG5cdFx0aWYgKHZub2RlLmluc3RhbmNlID09PSB2bm9kZSkgdGhyb3cgRXJyb3IoXCJBIHZpZXcgY2Fubm90IHJldHVybiB0aGUgdm5vZGUgaXQgcmVjZWl2ZWQgYXMgYXJndW1lbnRcIilcblx0XHRzZW50aW5lbC4kJHJlZW50cmFudExvY2skJCA9IG51bGxcblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVDb21wb25lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZykge1xuXHRcdGluaXRDb21wb25lbnQodm5vZGUsIGhvb2tzKVxuXHRcdGlmICh2bm9kZS5pbnN0YW5jZSAhPSBudWxsKSB7XG5cdFx0XHR2YXIgZWxlbWVudCA9IGNyZWF0ZU5vZGUocGFyZW50LCB2bm9kZS5pbnN0YW5jZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdHZub2RlLmRvbSA9IHZub2RlLmluc3RhbmNlLmRvbVxuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IHZub2RlLmRvbSAhPSBudWxsID8gdm5vZGUuaW5zdGFuY2UuZG9tU2l6ZSA6IDBcblx0XHRcdGluc2VydE5vZGUocGFyZW50LCBlbGVtZW50LCBuZXh0U2libGluZylcblx0XHRcdHJldHVybiBlbGVtZW50XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IDBcblx0XHRcdHJldHVybiAkZW1wdHlGcmFnbWVudFxuXHRcdH1cblx0fVxuXHQvL3VwZGF0ZVxuXHRmdW5jdGlvbiB1cGRhdGVOb2RlcyhwYXJlbnQsIG9sZCwgdm5vZGVzLCByZWN5Y2xpbmcsIGhvb2tzLCBuZXh0U2libGluZywgbnMpIHtcblx0XHRpZiAob2xkID09PSB2bm9kZXMgfHwgb2xkID09IG51bGwgJiYgdm5vZGVzID09IG51bGwpIHJldHVyblxuXHRcdGVsc2UgaWYgKG9sZCA9PSBudWxsKSBjcmVhdGVOb2RlcyhwYXJlbnQsIHZub2RlcywgMCwgdm5vZGVzLmxlbmd0aCwgaG9va3MsIG5leHRTaWJsaW5nLCBucylcblx0XHRlbHNlIGlmICh2bm9kZXMgPT0gbnVsbCkgcmVtb3ZlTm9kZXMob2xkLCAwLCBvbGQubGVuZ3RoLCB2bm9kZXMpXG5cdFx0ZWxzZSB7XG5cdFx0XHRpZiAob2xkLmxlbmd0aCA9PT0gdm5vZGVzLmxlbmd0aCkge1xuXHRcdFx0XHR2YXIgaXNVbmtleWVkID0gZmFsc2Vcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB2bm9kZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRpZiAodm5vZGVzW2ldICE9IG51bGwgJiYgb2xkW2ldICE9IG51bGwpIHtcblx0XHRcdFx0XHRcdGlzVW5rZXllZCA9IHZub2Rlc1tpXS5rZXkgPT0gbnVsbCAmJiBvbGRbaV0ua2V5ID09IG51bGxcblx0XHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChpc1Vua2V5ZWQpIHtcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG9sZC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0aWYgKG9sZFtpXSA9PT0gdm5vZGVzW2ldKSBjb250aW51ZVxuXHRcdFx0XHRcdFx0ZWxzZSBpZiAob2xkW2ldID09IG51bGwgJiYgdm5vZGVzW2ldICE9IG51bGwpIGNyZWF0ZU5vZGUocGFyZW50LCB2bm9kZXNbaV0sIGhvb2tzLCBucywgZ2V0TmV4dFNpYmxpbmcob2xkLCBpICsgMSwgbmV4dFNpYmxpbmcpKVxuXHRcdFx0XHRcdFx0ZWxzZSBpZiAodm5vZGVzW2ldID09IG51bGwpIHJlbW92ZU5vZGVzKG9sZCwgaSwgaSArIDEsIHZub2Rlcylcblx0XHRcdFx0XHRcdGVsc2UgdXBkYXRlTm9kZShwYXJlbnQsIG9sZFtpXSwgdm5vZGVzW2ldLCBob29rcywgZ2V0TmV4dFNpYmxpbmcob2xkLCBpICsgMSwgbmV4dFNpYmxpbmcpLCByZWN5Y2xpbmcsIG5zKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmVjeWNsaW5nID0gcmVjeWNsaW5nIHx8IGlzUmVjeWNsYWJsZShvbGQsIHZub2Rlcylcblx0XHRcdGlmIChyZWN5Y2xpbmcpIHtcblx0XHRcdFx0dmFyIHBvb2wgPSBvbGQucG9vbFxuXHRcdFx0XHRvbGQgPSBvbGQuY29uY2F0KG9sZC5wb29sKVxuXHRcdFx0fVxuXHRcdFx0dmFyIG9sZFN0YXJ0ID0gMCwgc3RhcnQgPSAwLCBvbGRFbmQgPSBvbGQubGVuZ3RoIC0gMSwgZW5kID0gdm5vZGVzLmxlbmd0aCAtIDEsIG1hcFxuXHRcdFx0d2hpbGUgKG9sZEVuZCA+PSBvbGRTdGFydCAmJiBlbmQgPj0gc3RhcnQpIHtcblx0XHRcdFx0dmFyIG8gPSBvbGRbb2xkU3RhcnRdLCB2ID0gdm5vZGVzW3N0YXJ0XVxuXHRcdFx0XHRpZiAobyA9PT0gdiAmJiAhcmVjeWNsaW5nKSBvbGRTdGFydCsrLCBzdGFydCsrXG5cdFx0XHRcdGVsc2UgaWYgKG8gPT0gbnVsbCkgb2xkU3RhcnQrK1xuXHRcdFx0XHRlbHNlIGlmICh2ID09IG51bGwpIHN0YXJ0Kytcblx0XHRcdFx0ZWxzZSBpZiAoby5rZXkgPT09IHYua2V5KSB7XG5cdFx0XHRcdFx0dmFyIHNob3VsZFJlY3ljbGUgPSAocG9vbCAhPSBudWxsICYmIG9sZFN0YXJ0ID49IG9sZC5sZW5ndGggLSBwb29sLmxlbmd0aCkgfHwgKChwb29sID09IG51bGwpICYmIHJlY3ljbGluZylcblx0XHRcdFx0XHRvbGRTdGFydCsrLCBzdGFydCsrXG5cdFx0XHRcdFx0dXBkYXRlTm9kZShwYXJlbnQsIG8sIHYsIGhvb2tzLCBnZXROZXh0U2libGluZyhvbGQsIG9sZFN0YXJ0LCBuZXh0U2libGluZyksIHNob3VsZFJlY3ljbGUsIG5zKVxuXHRcdFx0XHRcdGlmIChyZWN5Y2xpbmcgJiYgby50YWcgPT09IHYudGFnKSBpbnNlcnROb2RlKHBhcmVudCwgdG9GcmFnbWVudChvKSwgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0dmFyIG8gPSBvbGRbb2xkRW5kXVxuXHRcdFx0XHRcdGlmIChvID09PSB2ICYmICFyZWN5Y2xpbmcpIG9sZEVuZC0tLCBzdGFydCsrXG5cdFx0XHRcdFx0ZWxzZSBpZiAobyA9PSBudWxsKSBvbGRFbmQtLVxuXHRcdFx0XHRcdGVsc2UgaWYgKHYgPT0gbnVsbCkgc3RhcnQrK1xuXHRcdFx0XHRcdGVsc2UgaWYgKG8ua2V5ID09PSB2LmtleSkge1xuXHRcdFx0XHRcdFx0dmFyIHNob3VsZFJlY3ljbGUgPSAocG9vbCAhPSBudWxsICYmIG9sZEVuZCA+PSBvbGQubGVuZ3RoIC0gcG9vbC5sZW5ndGgpIHx8ICgocG9vbCA9PSBudWxsKSAmJiByZWN5Y2xpbmcpXG5cdFx0XHRcdFx0XHR1cGRhdGVOb2RlKHBhcmVudCwgbywgdiwgaG9va3MsIGdldE5leHRTaWJsaW5nKG9sZCwgb2xkRW5kICsgMSwgbmV4dFNpYmxpbmcpLCBzaG91bGRSZWN5Y2xlLCBucylcblx0XHRcdFx0XHRcdGlmIChyZWN5Y2xpbmcgfHwgc3RhcnQgPCBlbmQpIGluc2VydE5vZGUocGFyZW50LCB0b0ZyYWdtZW50KG8pLCBnZXROZXh0U2libGluZyhvbGQsIG9sZFN0YXJ0LCBuZXh0U2libGluZykpXG5cdFx0XHRcdFx0XHRvbGRFbmQtLSwgc3RhcnQrK1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIGJyZWFrXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHdoaWxlIChvbGRFbmQgPj0gb2xkU3RhcnQgJiYgZW5kID49IHN0YXJ0KSB7XG5cdFx0XHRcdHZhciBvID0gb2xkW29sZEVuZF0sIHYgPSB2bm9kZXNbZW5kXVxuXHRcdFx0XHRpZiAobyA9PT0gdiAmJiAhcmVjeWNsaW5nKSBvbGRFbmQtLSwgZW5kLS1cblx0XHRcdFx0ZWxzZSBpZiAobyA9PSBudWxsKSBvbGRFbmQtLVxuXHRcdFx0XHRlbHNlIGlmICh2ID09IG51bGwpIGVuZC0tXG5cdFx0XHRcdGVsc2UgaWYgKG8ua2V5ID09PSB2LmtleSkge1xuXHRcdFx0XHRcdHZhciBzaG91bGRSZWN5Y2xlID0gKHBvb2wgIT0gbnVsbCAmJiBvbGRFbmQgPj0gb2xkLmxlbmd0aCAtIHBvb2wubGVuZ3RoKSB8fCAoKHBvb2wgPT0gbnVsbCkgJiYgcmVjeWNsaW5nKVxuXHRcdFx0XHRcdHVwZGF0ZU5vZGUocGFyZW50LCBvLCB2LCBob29rcywgZ2V0TmV4dFNpYmxpbmcob2xkLCBvbGRFbmQgKyAxLCBuZXh0U2libGluZyksIHNob3VsZFJlY3ljbGUsIG5zKVxuXHRcdFx0XHRcdGlmIChyZWN5Y2xpbmcgJiYgby50YWcgPT09IHYudGFnKSBpbnNlcnROb2RlKHBhcmVudCwgdG9GcmFnbWVudChvKSwgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdFx0aWYgKG8uZG9tICE9IG51bGwpIG5leHRTaWJsaW5nID0gby5kb21cblx0XHRcdFx0XHRvbGRFbmQtLSwgZW5kLS1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRpZiAoIW1hcCkgbWFwID0gZ2V0S2V5TWFwKG9sZCwgb2xkRW5kKVxuXHRcdFx0XHRcdGlmICh2ICE9IG51bGwpIHtcblx0XHRcdFx0XHRcdHZhciBvbGRJbmRleCA9IG1hcFt2LmtleV1cblx0XHRcdFx0XHRcdGlmIChvbGRJbmRleCAhPSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBtb3ZhYmxlID0gb2xkW29sZEluZGV4XVxuXHRcdFx0XHRcdFx0XHR2YXIgc2hvdWxkUmVjeWNsZSA9IChwb29sICE9IG51bGwgJiYgb2xkSW5kZXggPj0gb2xkLmxlbmd0aCAtIHBvb2wubGVuZ3RoKSB8fCAoKHBvb2wgPT0gbnVsbCkgJiYgcmVjeWNsaW5nKVxuXHRcdFx0XHRcdFx0XHR1cGRhdGVOb2RlKHBhcmVudCwgbW92YWJsZSwgdiwgaG9va3MsIGdldE5leHRTaWJsaW5nKG9sZCwgb2xkRW5kICsgMSwgbmV4dFNpYmxpbmcpLCByZWN5Y2xpbmcsIG5zKVxuXHRcdFx0XHRcdFx0XHRpbnNlcnROb2RlKHBhcmVudCwgdG9GcmFnbWVudChtb3ZhYmxlKSwgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdFx0XHRcdG9sZFtvbGRJbmRleF0uc2tpcCA9IHRydWVcblx0XHRcdFx0XHRcdFx0aWYgKG1vdmFibGUuZG9tICE9IG51bGwpIG5leHRTaWJsaW5nID0gbW92YWJsZS5kb21cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR2YXIgZG9tID0gY3JlYXRlTm9kZShwYXJlbnQsIHYsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdFx0XHRcdG5leHRTaWJsaW5nID0gZG9tXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVuZC0tXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGVuZCA8IHN0YXJ0KSBicmVha1xuXHRcdFx0fVxuXHRcdFx0Y3JlYXRlTm9kZXMocGFyZW50LCB2bm9kZXMsIHN0YXJ0LCBlbmQgKyAxLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKVxuXHRcdFx0cmVtb3ZlTm9kZXMob2xkLCBvbGRTdGFydCwgb2xkRW5kICsgMSwgdm5vZGVzKVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVOb2RlKHBhcmVudCwgb2xkLCB2bm9kZSwgaG9va3MsIG5leHRTaWJsaW5nLCByZWN5Y2xpbmcsIG5zKSB7XG5cdFx0dmFyIG9sZFRhZyA9IG9sZC50YWcsIHRhZyA9IHZub2RlLnRhZ1xuXHRcdGlmIChvbGRUYWcgPT09IHRhZykge1xuXHRcdFx0dm5vZGUuc3RhdGUgPSBvbGQuc3RhdGVcblx0XHRcdHZub2RlLl9zdGF0ZSA9IG9sZC5fc3RhdGVcblx0XHRcdHZub2RlLmV2ZW50cyA9IG9sZC5ldmVudHNcblx0XHRcdGlmICghcmVjeWNsaW5nICYmIHNob3VsZE5vdFVwZGF0ZSh2bm9kZSwgb2xkKSkgcmV0dXJuXG5cdFx0XHRpZiAodHlwZW9mIG9sZFRhZyA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCkge1xuXHRcdFx0XHRcdGlmIChyZWN5Y2xpbmcpIHtcblx0XHRcdFx0XHRcdHZub2RlLnN0YXRlID0ge31cblx0XHRcdFx0XHRcdGluaXRMaWZlY3ljbGUodm5vZGUuYXR0cnMsIHZub2RlLCBob29rcylcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB1cGRhdGVMaWZlY3ljbGUodm5vZGUuYXR0cnMsIHZub2RlLCBob29rcylcblx0XHRcdFx0fVxuXHRcdFx0XHRzd2l0Y2ggKG9sZFRhZykge1xuXHRcdFx0XHRcdGNhc2UgXCIjXCI6IHVwZGF0ZVRleHQob2xkLCB2bm9kZSk7IGJyZWFrXG5cdFx0XHRcdFx0Y2FzZSBcIjxcIjogdXBkYXRlSFRNTChwYXJlbnQsIG9sZCwgdm5vZGUsIG5leHRTaWJsaW5nKTsgYnJlYWtcblx0XHRcdFx0XHRjYXNlIFwiW1wiOiB1cGRhdGVGcmFnbWVudChwYXJlbnQsIG9sZCwgdm5vZGUsIHJlY3ljbGluZywgaG9va3MsIG5leHRTaWJsaW5nLCBucyk7IGJyZWFrXG5cdFx0XHRcdFx0ZGVmYXVsdDogdXBkYXRlRWxlbWVudChvbGQsIHZub2RlLCByZWN5Y2xpbmcsIGhvb2tzLCBucylcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSB1cGRhdGVDb21wb25lbnQocGFyZW50LCBvbGQsIHZub2RlLCBob29rcywgbmV4dFNpYmxpbmcsIHJlY3ljbGluZywgbnMpXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0cmVtb3ZlTm9kZShvbGQsIG51bGwpXG5cdFx0XHRjcmVhdGVOb2RlKHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZVRleHQob2xkLCB2bm9kZSkge1xuXHRcdGlmIChvbGQuY2hpbGRyZW4udG9TdHJpbmcoKSAhPT0gdm5vZGUuY2hpbGRyZW4udG9TdHJpbmcoKSkge1xuXHRcdFx0b2xkLmRvbS5ub2RlVmFsdWUgPSB2bm9kZS5jaGlsZHJlblxuXHRcdH1cblx0XHR2bm9kZS5kb20gPSBvbGQuZG9tXG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlSFRNTChwYXJlbnQsIG9sZCwgdm5vZGUsIG5leHRTaWJsaW5nKSB7XG5cdFx0aWYgKG9sZC5jaGlsZHJlbiAhPT0gdm5vZGUuY2hpbGRyZW4pIHtcblx0XHRcdHRvRnJhZ21lbnQob2xkKVxuXHRcdFx0Y3JlYXRlSFRNTChwYXJlbnQsIHZub2RlLCBuZXh0U2libGluZylcblx0XHR9XG5cdFx0ZWxzZSB2bm9kZS5kb20gPSBvbGQuZG9tLCB2bm9kZS5kb21TaXplID0gb2xkLmRvbVNpemVcblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVGcmFnbWVudChwYXJlbnQsIG9sZCwgdm5vZGUsIHJlY3ljbGluZywgaG9va3MsIG5leHRTaWJsaW5nLCBucykge1xuXHRcdHVwZGF0ZU5vZGVzKHBhcmVudCwgb2xkLmNoaWxkcmVuLCB2bm9kZS5jaGlsZHJlbiwgcmVjeWNsaW5nLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKVxuXHRcdHZhciBkb21TaXplID0gMCwgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlblxuXHRcdHZub2RlLmRvbSA9IG51bGxcblx0XHRpZiAoY2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgY2hpbGQgPSBjaGlsZHJlbltpXVxuXHRcdFx0XHRpZiAoY2hpbGQgIT0gbnVsbCAmJiBjaGlsZC5kb20gIT0gbnVsbCkge1xuXHRcdFx0XHRcdGlmICh2bm9kZS5kb20gPT0gbnVsbCkgdm5vZGUuZG9tID0gY2hpbGQuZG9tXG5cdFx0XHRcdFx0ZG9tU2l6ZSArPSBjaGlsZC5kb21TaXplIHx8IDFcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGRvbVNpemUgIT09IDEpIHZub2RlLmRvbVNpemUgPSBkb21TaXplXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUVsZW1lbnQob2xkLCB2bm9kZSwgcmVjeWNsaW5nLCBob29rcywgbnMpIHtcblx0XHR2YXIgZWxlbWVudCA9IHZub2RlLmRvbSA9IG9sZC5kb21cblx0XHRucyA9IGdldE5hbWVTcGFjZSh2bm9kZSkgfHwgbnNcblx0XHRpZiAodm5vZGUudGFnID09PSBcInRleHRhcmVhXCIpIHtcblx0XHRcdGlmICh2bm9kZS5hdHRycyA9PSBudWxsKSB2bm9kZS5hdHRycyA9IHt9XG5cdFx0XHRpZiAodm5vZGUudGV4dCAhPSBudWxsKSB7XG5cdFx0XHRcdHZub2RlLmF0dHJzLnZhbHVlID0gdm5vZGUudGV4dCAvL0ZJWE1FIGhhbmRsZTAgbXVsdGlwbGUgY2hpbGRyZW5cblx0XHRcdFx0dm5vZGUudGV4dCA9IHVuZGVmaW5lZFxuXHRcdFx0fVxuXHRcdH1cblx0XHR1cGRhdGVBdHRycyh2bm9kZSwgb2xkLmF0dHJzLCB2bm9kZS5hdHRycywgbnMpXG5cdFx0aWYgKHZub2RlLmF0dHJzICE9IG51bGwgJiYgdm5vZGUuYXR0cnMuY29udGVudGVkaXRhYmxlICE9IG51bGwpIHtcblx0XHRcdHNldENvbnRlbnRFZGl0YWJsZSh2bm9kZSlcblx0XHR9XG5cdFx0ZWxzZSBpZiAob2xkLnRleHQgIT0gbnVsbCAmJiB2bm9kZS50ZXh0ICE9IG51bGwgJiYgdm5vZGUudGV4dCAhPT0gXCJcIikge1xuXHRcdFx0aWYgKG9sZC50ZXh0LnRvU3RyaW5nKCkgIT09IHZub2RlLnRleHQudG9TdHJpbmcoKSkgb2xkLmRvbS5maXJzdENoaWxkLm5vZGVWYWx1ZSA9IHZub2RlLnRleHRcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRpZiAob2xkLnRleHQgIT0gbnVsbCkgb2xkLmNoaWxkcmVuID0gW1Zub2RlKFwiI1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgb2xkLnRleHQsIHVuZGVmaW5lZCwgb2xkLmRvbS5maXJzdENoaWxkKV1cblx0XHRcdGlmICh2bm9kZS50ZXh0ICE9IG51bGwpIHZub2RlLmNoaWxkcmVuID0gW1Zub2RlKFwiI1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdm5vZGUudGV4dCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXVxuXHRcdFx0dXBkYXRlTm9kZXMoZWxlbWVudCwgb2xkLmNoaWxkcmVuLCB2bm9kZS5jaGlsZHJlbiwgcmVjeWNsaW5nLCBob29rcywgbnVsbCwgbnMpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUNvbXBvbmVudChwYXJlbnQsIG9sZCwgdm5vZGUsIGhvb2tzLCBuZXh0U2libGluZywgcmVjeWNsaW5nLCBucykge1xuXHRcdGlmIChyZWN5Y2xpbmcpIHtcblx0XHRcdGluaXRDb21wb25lbnQodm5vZGUsIGhvb2tzKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2bm9kZS5pbnN0YW5jZSA9IFZub2RlLm5vcm1hbGl6ZSh2bm9kZS5fc3RhdGUudmlldy5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSkpXG5cdFx0XHRpZiAodm5vZGUuaW5zdGFuY2UgPT09IHZub2RlKSB0aHJvdyBFcnJvcihcIkEgdmlldyBjYW5ub3QgcmV0dXJuIHRoZSB2bm9kZSBpdCByZWNlaXZlZCBhcyBhcmd1bWVudFwiKVxuXHRcdFx0aWYgKHZub2RlLmF0dHJzICE9IG51bGwpIHVwZGF0ZUxpZmVjeWNsZSh2bm9kZS5hdHRycywgdm5vZGUsIGhvb2tzKVxuXHRcdFx0dXBkYXRlTGlmZWN5Y2xlKHZub2RlLl9zdGF0ZSwgdm5vZGUsIGhvb2tzKVxuXHRcdH1cblx0XHRpZiAodm5vZGUuaW5zdGFuY2UgIT0gbnVsbCkge1xuXHRcdFx0aWYgKG9sZC5pbnN0YW5jZSA9PSBudWxsKSBjcmVhdGVOb2RlKHBhcmVudCwgdm5vZGUuaW5zdGFuY2UsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0XHRlbHNlIHVwZGF0ZU5vZGUocGFyZW50LCBvbGQuaW5zdGFuY2UsIHZub2RlLmluc3RhbmNlLCBob29rcywgbmV4dFNpYmxpbmcsIHJlY3ljbGluZywgbnMpXG5cdFx0XHR2bm9kZS5kb20gPSB2bm9kZS5pbnN0YW5jZS5kb21cblx0XHRcdHZub2RlLmRvbVNpemUgPSB2bm9kZS5pbnN0YW5jZS5kb21TaXplXG5cdFx0fVxuXHRcdGVsc2UgaWYgKG9sZC5pbnN0YW5jZSAhPSBudWxsKSB7XG5cdFx0XHRyZW1vdmVOb2RlKG9sZC5pbnN0YW5jZSwgbnVsbClcblx0XHRcdHZub2RlLmRvbSA9IHVuZGVmaW5lZFxuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IDBcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHR2bm9kZS5kb20gPSBvbGQuZG9tXG5cdFx0XHR2bm9kZS5kb21TaXplID0gb2xkLmRvbVNpemVcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gaXNSZWN5Y2xhYmxlKG9sZCwgdm5vZGVzKSB7XG5cdFx0aWYgKG9sZC5wb29sICE9IG51bGwgJiYgTWF0aC5hYnMob2xkLnBvb2wubGVuZ3RoIC0gdm5vZGVzLmxlbmd0aCkgPD0gTWF0aC5hYnMob2xkLmxlbmd0aCAtIHZub2Rlcy5sZW5ndGgpKSB7XG5cdFx0XHR2YXIgb2xkQ2hpbGRyZW5MZW5ndGggPSBvbGRbMF0gJiYgb2xkWzBdLmNoaWxkcmVuICYmIG9sZFswXS5jaGlsZHJlbi5sZW5ndGggfHwgMFxuXHRcdFx0dmFyIHBvb2xDaGlsZHJlbkxlbmd0aCA9IG9sZC5wb29sWzBdICYmIG9sZC5wb29sWzBdLmNoaWxkcmVuICYmIG9sZC5wb29sWzBdLmNoaWxkcmVuLmxlbmd0aCB8fCAwXG5cdFx0XHR2YXIgdm5vZGVzQ2hpbGRyZW5MZW5ndGggPSB2bm9kZXNbMF0gJiYgdm5vZGVzWzBdLmNoaWxkcmVuICYmIHZub2Rlc1swXS5jaGlsZHJlbi5sZW5ndGggfHwgMFxuXHRcdFx0aWYgKE1hdGguYWJzKHBvb2xDaGlsZHJlbkxlbmd0aCAtIHZub2Rlc0NoaWxkcmVuTGVuZ3RoKSA8PSBNYXRoLmFicyhvbGRDaGlsZHJlbkxlbmd0aCAtIHZub2Rlc0NoaWxkcmVuTGVuZ3RoKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2Vcblx0fVxuXHRmdW5jdGlvbiBnZXRLZXlNYXAodm5vZGVzLCBlbmQpIHtcblx0XHR2YXIgbWFwID0ge30sIGkgPSAwXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBlbmQ7IGkrKykge1xuXHRcdFx0dmFyIHZub2RlID0gdm5vZGVzW2ldXG5cdFx0XHRpZiAodm5vZGUgIT0gbnVsbCkge1xuXHRcdFx0XHR2YXIga2V5MiA9IHZub2RlLmtleVxuXHRcdFx0XHRpZiAoa2V5MiAhPSBudWxsKSBtYXBba2V5Ml0gPSBpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBtYXBcblx0fVxuXHRmdW5jdGlvbiB0b0ZyYWdtZW50KHZub2RlKSB7XG5cdFx0dmFyIGNvdW50MCA9IHZub2RlLmRvbVNpemVcblx0XHRpZiAoY291bnQwICE9IG51bGwgfHwgdm5vZGUuZG9tID09IG51bGwpIHtcblx0XHRcdHZhciBmcmFnbWVudCA9ICRkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG5cdFx0XHRpZiAoY291bnQwID4gMCkge1xuXHRcdFx0XHR2YXIgZG9tID0gdm5vZGUuZG9tXG5cdFx0XHRcdHdoaWxlICgtLWNvdW50MCkgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZG9tLm5leHRTaWJsaW5nKVxuXHRcdFx0XHRmcmFnbWVudC5pbnNlcnRCZWZvcmUoZG9tLCBmcmFnbWVudC5maXJzdENoaWxkKVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZyYWdtZW50XG5cdFx0fVxuXHRcdGVsc2UgcmV0dXJuIHZub2RlLmRvbVxuXHR9XG5cdGZ1bmN0aW9uIGdldE5leHRTaWJsaW5nKHZub2RlcywgaSwgbmV4dFNpYmxpbmcpIHtcblx0XHRmb3IgKDsgaSA8IHZub2Rlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKHZub2Rlc1tpXSAhPSBudWxsICYmIHZub2Rlc1tpXS5kb20gIT0gbnVsbCkgcmV0dXJuIHZub2Rlc1tpXS5kb21cblx0XHR9XG5cdFx0cmV0dXJuIG5leHRTaWJsaW5nXG5cdH1cblx0ZnVuY3Rpb24gaW5zZXJ0Tm9kZShwYXJlbnQsIGRvbSwgbmV4dFNpYmxpbmcpIHtcblx0XHRpZiAobmV4dFNpYmxpbmcgJiYgbmV4dFNpYmxpbmcucGFyZW50Tm9kZSkgcGFyZW50Lmluc2VydEJlZm9yZShkb20sIG5leHRTaWJsaW5nKVxuXHRcdGVsc2UgcGFyZW50LmFwcGVuZENoaWxkKGRvbSlcblx0fVxuXHRmdW5jdGlvbiBzZXRDb250ZW50RWRpdGFibGUodm5vZGUpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlblxuXHRcdGlmIChjaGlsZHJlbiAhPSBudWxsICYmIGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBjaGlsZHJlblswXS50YWcgPT09IFwiPFwiKSB7XG5cdFx0XHR2YXIgY29udGVudCA9IGNoaWxkcmVuWzBdLmNoaWxkcmVuXG5cdFx0XHRpZiAodm5vZGUuZG9tLmlubmVySFRNTCAhPT0gY29udGVudCkgdm5vZGUuZG9tLmlubmVySFRNTCA9IGNvbnRlbnRcblx0XHR9XG5cdFx0ZWxzZSBpZiAodm5vZGUudGV4dCAhPSBudWxsIHx8IGNoaWxkcmVuICE9IG51bGwgJiYgY2hpbGRyZW4ubGVuZ3RoICE9PSAwKSB0aHJvdyBuZXcgRXJyb3IoXCJDaGlsZCBub2RlIG9mIGEgY29udGVudGVkaXRhYmxlIG11c3QgYmUgdHJ1c3RlZFwiKVxuXHR9XG5cdC8vcmVtb3ZlXG5cdGZ1bmN0aW9uIHJlbW92ZU5vZGVzKHZub2Rlcywgc3RhcnQsIGVuZCwgY29udGV4dCkge1xuXHRcdGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG5cdFx0XHR2YXIgdm5vZGUgPSB2bm9kZXNbaV1cblx0XHRcdGlmICh2bm9kZSAhPSBudWxsKSB7XG5cdFx0XHRcdGlmICh2bm9kZS5za2lwKSB2bm9kZS5za2lwID0gZmFsc2Vcblx0XHRcdFx0ZWxzZSByZW1vdmVOb2RlKHZub2RlLCBjb250ZXh0KVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiByZW1vdmVOb2RlKHZub2RlLCBjb250ZXh0KSB7XG5cdFx0dmFyIGV4cGVjdGVkID0gMSwgY2FsbGVkID0gMFxuXHRcdGlmICh2bm9kZS5hdHRycyAmJiB0eXBlb2Ygdm5vZGUuYXR0cnMub25iZWZvcmVyZW1vdmUgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0dmFyIHJlc3VsdCA9IHZub2RlLmF0dHJzLm9uYmVmb3JlcmVtb3ZlLmNhbGwodm5vZGUuc3RhdGUsIHZub2RlKVxuXHRcdFx0aWYgKHJlc3VsdCAhPSBudWxsICYmIHR5cGVvZiByZXN1bHQudGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdGV4cGVjdGVkKytcblx0XHRcdFx0cmVzdWx0LnRoZW4oY29udGludWF0aW9uLCBjb250aW51YXRpb24pXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICh0eXBlb2Ygdm5vZGUudGFnICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiB2bm9kZS5fc3RhdGUub25iZWZvcmVyZW1vdmUgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0dmFyIHJlc3VsdCA9IHZub2RlLl9zdGF0ZS5vbmJlZm9yZXJlbW92ZS5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSlcblx0XHRcdGlmIChyZXN1bHQgIT0gbnVsbCAmJiB0eXBlb2YgcmVzdWx0LnRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRleHBlY3RlZCsrXG5cdFx0XHRcdHJlc3VsdC50aGVuKGNvbnRpbnVhdGlvbiwgY29udGludWF0aW9uKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRjb250aW51YXRpb24oKVxuXHRcdGZ1bmN0aW9uIGNvbnRpbnVhdGlvbigpIHtcblx0XHRcdGlmICgrK2NhbGxlZCA9PT0gZXhwZWN0ZWQpIHtcblx0XHRcdFx0b25yZW1vdmUodm5vZGUpXG5cdFx0XHRcdGlmICh2bm9kZS5kb20pIHtcblx0XHRcdFx0XHR2YXIgY291bnQwID0gdm5vZGUuZG9tU2l6ZSB8fCAxXG5cdFx0XHRcdFx0aWYgKGNvdW50MCA+IDEpIHtcblx0XHRcdFx0XHRcdHZhciBkb20gPSB2bm9kZS5kb21cblx0XHRcdFx0XHRcdHdoaWxlICgtLWNvdW50MCkge1xuXHRcdFx0XHRcdFx0XHRyZW1vdmVOb2RlRnJvbURPTShkb20ubmV4dFNpYmxpbmcpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJlbW92ZU5vZGVGcm9tRE9NKHZub2RlLmRvbSlcblx0XHRcdFx0XHRpZiAoY29udGV4dCAhPSBudWxsICYmIHZub2RlLmRvbVNpemUgPT0gbnVsbCAmJiAhaGFzSW50ZWdyYXRpb25NZXRob2RzKHZub2RlLmF0dHJzKSAmJiB0eXBlb2Ygdm5vZGUudGFnID09PSBcInN0cmluZ1wiKSB7IC8vVE9ETyB0ZXN0IGN1c3RvbSBlbGVtZW50c1xuXHRcdFx0XHRcdFx0aWYgKCFjb250ZXh0LnBvb2wpIGNvbnRleHQucG9vbCA9IFt2bm9kZV1cblx0XHRcdFx0XHRcdGVsc2UgY29udGV4dC5wb29sLnB1c2godm5vZGUpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHJlbW92ZU5vZGVGcm9tRE9NKG5vZGUpIHtcblx0XHR2YXIgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlXG5cdFx0aWYgKHBhcmVudCAhPSBudWxsKSBwYXJlbnQucmVtb3ZlQ2hpbGQobm9kZSlcblx0fVxuXHRmdW5jdGlvbiBvbnJlbW92ZSh2bm9kZSkge1xuXHRcdGlmICh2bm9kZS5hdHRycyAmJiB0eXBlb2Ygdm5vZGUuYXR0cnMub25yZW1vdmUgPT09IFwiZnVuY3Rpb25cIikgdm5vZGUuYXR0cnMub25yZW1vdmUuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpXG5cdFx0aWYgKHR5cGVvZiB2bm9kZS50YWcgIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHZub2RlLl9zdGF0ZS5vbnJlbW92ZSA9PT0gXCJmdW5jdGlvblwiKSB2bm9kZS5fc3RhdGUub25yZW1vdmUuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpXG5cdFx0aWYgKHZub2RlLmluc3RhbmNlICE9IG51bGwpIG9ucmVtb3ZlKHZub2RlLmluc3RhbmNlKVxuXHRcdGVsc2Uge1xuXHRcdFx0dmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW5cblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0dmFyIGNoaWxkID0gY2hpbGRyZW5baV1cblx0XHRcdFx0XHRpZiAoY2hpbGQgIT0gbnVsbCkgb25yZW1vdmUoY2hpbGQpXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0Ly9hdHRyczJcblx0ZnVuY3Rpb24gc2V0QXR0cnModm5vZGUsIGF0dHJzMiwgbnMpIHtcblx0XHRmb3IgKHZhciBrZXkyIGluIGF0dHJzMikge1xuXHRcdFx0c2V0QXR0cih2bm9kZSwga2V5MiwgbnVsbCwgYXR0cnMyW2tleTJdLCBucylcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gc2V0QXR0cih2bm9kZSwga2V5Miwgb2xkLCB2YWx1ZSwgbnMpIHtcblx0XHR2YXIgZWxlbWVudCA9IHZub2RlLmRvbVxuXHRcdGlmIChrZXkyID09PSBcImtleVwiIHx8IGtleTIgPT09IFwiaXNcIiB8fCAob2xkID09PSB2YWx1ZSAmJiAhaXNGb3JtQXR0cmlidXRlKHZub2RlLCBrZXkyKSkgJiYgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIiB8fCBpc0xpZmVjeWNsZU1ldGhvZChrZXkyKSkgcmV0dXJuXG5cdFx0dmFyIG5zTGFzdEluZGV4ID0ga2V5Mi5pbmRleE9mKFwiOlwiKVxuXHRcdGlmIChuc0xhc3RJbmRleCA+IC0xICYmIGtleTIuc3Vic3RyKDAsIG5zTGFzdEluZGV4KSA9PT0gXCJ4bGlua1wiKSB7XG5cdFx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZU5TKFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLCBrZXkyLnNsaWNlKG5zTGFzdEluZGV4ICsgMSksIHZhbHVlKVxuXHRcdH1cblx0XHRlbHNlIGlmIChrZXkyWzBdID09PSBcIm9cIiAmJiBrZXkyWzFdID09PSBcIm5cIiAmJiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikgdXBkYXRlRXZlbnQodm5vZGUsIGtleTIsIHZhbHVlKVxuXHRcdGVsc2UgaWYgKGtleTIgPT09IFwic3R5bGVcIikgdXBkYXRlU3R5bGUoZWxlbWVudCwgb2xkLCB2YWx1ZSlcblx0XHRlbHNlIGlmIChrZXkyIGluIGVsZW1lbnQgJiYgIWlzQXR0cmlidXRlKGtleTIpICYmIG5zID09PSB1bmRlZmluZWQgJiYgIWlzQ3VzdG9tRWxlbWVudCh2bm9kZSkpIHtcblx0XHRcdGlmIChrZXkyID09PSBcInZhbHVlXCIpIHtcblx0XHRcdFx0dmFyIG5vcm1hbGl6ZWQwID0gXCJcIiArIHZhbHVlIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8taW1wbGljaXQtY29lcmNpb25cblx0XHRcdFx0Ly9zZXR0aW5nIGlucHV0W3ZhbHVlXSB0byBzYW1lIHZhbHVlIGJ5IHR5cGluZyBvbiBmb2N1c2VkIGVsZW1lbnQgbW92ZXMgY3Vyc29yIHRvIGVuZCBpbiBDaHJvbWVcblx0XHRcdFx0aWYgKCh2bm9kZS50YWcgPT09IFwiaW5wdXRcIiB8fCB2bm9kZS50YWcgPT09IFwidGV4dGFyZWFcIikgJiYgdm5vZGUuZG9tLnZhbHVlID09PSBub3JtYWxpemVkMCAmJiB2bm9kZS5kb20gPT09ICRkb2MuYWN0aXZlRWxlbWVudCkgcmV0dXJuXG5cdFx0XHRcdC8vc2V0dGluZyBzZWxlY3RbdmFsdWVdIHRvIHNhbWUgdmFsdWUgd2hpbGUgaGF2aW5nIHNlbGVjdCBvcGVuIGJsaW5rcyBzZWxlY3QgZHJvcGRvd24gaW4gQ2hyb21lXG5cdFx0XHRcdGlmICh2bm9kZS50YWcgPT09IFwic2VsZWN0XCIpIHtcblx0XHRcdFx0XHRpZiAodmFsdWUgPT09IG51bGwpIHtcblx0XHRcdFx0XHRcdGlmICh2bm9kZS5kb20uc2VsZWN0ZWRJbmRleCA9PT0gLTEgJiYgdm5vZGUuZG9tID09PSAkZG9jLmFjdGl2ZUVsZW1lbnQpIHJldHVyblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpZiAob2xkICE9PSBudWxsICYmIHZub2RlLmRvbS52YWx1ZSA9PT0gbm9ybWFsaXplZDAgJiYgdm5vZGUuZG9tID09PSAkZG9jLmFjdGl2ZUVsZW1lbnQpIHJldHVyblxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHQvL3NldHRpbmcgb3B0aW9uW3ZhbHVlXSB0byBzYW1lIHZhbHVlIHdoaWxlIGhhdmluZyBzZWxlY3Qgb3BlbiBibGlua3Mgc2VsZWN0IGRyb3Bkb3duIGluIENocm9tZVxuXHRcdFx0XHRpZiAodm5vZGUudGFnID09PSBcIm9wdGlvblwiICYmIG9sZCAhPSBudWxsICYmIHZub2RlLmRvbS52YWx1ZSA9PT0gbm9ybWFsaXplZDApIHJldHVyblxuXHRcdFx0fVxuXHRcdFx0Ly8gSWYgeW91IGFzc2lnbiBhbiBpbnB1dCB0eXBlMSB0aGF0IGlzIG5vdCBzdXBwb3J0ZWQgYnkgSUUgMTEgd2l0aCBhbiBhc3NpZ25tZW50IGV4cHJlc3Npb24sIGFuIGVycm9yMCB3aWxsIG9jY3VyLlxuXHRcdFx0aWYgKHZub2RlLnRhZyA9PT0gXCJpbnB1dFwiICYmIGtleTIgPT09IFwidHlwZVwiKSB7XG5cdFx0XHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleTIsIHZhbHVlKVxuXHRcdFx0XHRyZXR1cm5cblx0XHRcdH1cblx0XHRcdGVsZW1lbnRba2V5Ml0gPSB2YWx1ZVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiKSB7XG5cdFx0XHRcdGlmICh2YWx1ZSkgZWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5MiwgXCJcIilcblx0XHRcdFx0ZWxzZSBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShrZXkyKVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSBlbGVtZW50LnNldEF0dHJpYnV0ZShrZXkyID09PSBcImNsYXNzTmFtZVwiID8gXCJjbGFzc1wiIDoga2V5MiwgdmFsdWUpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHNldExhdGVBdHRycyh2bm9kZSkge1xuXHRcdHZhciBhdHRyczIgPSB2bm9kZS5hdHRyc1xuXHRcdGlmICh2bm9kZS50YWcgPT09IFwic2VsZWN0XCIgJiYgYXR0cnMyICE9IG51bGwpIHtcblx0XHRcdGlmIChcInZhbHVlXCIgaW4gYXR0cnMyKSBzZXRBdHRyKHZub2RlLCBcInZhbHVlXCIsIG51bGwsIGF0dHJzMi52YWx1ZSwgdW5kZWZpbmVkKVxuXHRcdFx0aWYgKFwic2VsZWN0ZWRJbmRleFwiIGluIGF0dHJzMikgc2V0QXR0cih2bm9kZSwgXCJzZWxlY3RlZEluZGV4XCIsIG51bGwsIGF0dHJzMi5zZWxlY3RlZEluZGV4LCB1bmRlZmluZWQpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUF0dHJzKHZub2RlLCBvbGQsIGF0dHJzMiwgbnMpIHtcblx0XHRpZiAoYXR0cnMyICE9IG51bGwpIHtcblx0XHRcdGZvciAodmFyIGtleTIgaW4gYXR0cnMyKSB7XG5cdFx0XHRcdHNldEF0dHIodm5vZGUsIGtleTIsIG9sZCAmJiBvbGRba2V5Ml0sIGF0dHJzMltrZXkyXSwgbnMpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChvbGQgIT0gbnVsbCkge1xuXHRcdFx0Zm9yICh2YXIga2V5MiBpbiBvbGQpIHtcblx0XHRcdFx0aWYgKGF0dHJzMiA9PSBudWxsIHx8ICEoa2V5MiBpbiBhdHRyczIpKSB7XG5cdFx0XHRcdFx0aWYgKGtleTIgPT09IFwiY2xhc3NOYW1lXCIpIGtleTIgPSBcImNsYXNzXCJcblx0XHRcdFx0XHRpZiAoa2V5MlswXSA9PT0gXCJvXCIgJiYga2V5MlsxXSA9PT0gXCJuXCIgJiYgIWlzTGlmZWN5Y2xlTWV0aG9kKGtleTIpKSB1cGRhdGVFdmVudCh2bm9kZSwga2V5MiwgdW5kZWZpbmVkKVxuXHRcdFx0XHRcdGVsc2UgaWYgKGtleTIgIT09IFwia2V5XCIpIHZub2RlLmRvbS5yZW1vdmVBdHRyaWJ1dGUoa2V5Milcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBpc0Zvcm1BdHRyaWJ1dGUodm5vZGUsIGF0dHIpIHtcblx0XHRyZXR1cm4gYXR0ciA9PT0gXCJ2YWx1ZVwiIHx8IGF0dHIgPT09IFwiY2hlY2tlZFwiIHx8IGF0dHIgPT09IFwic2VsZWN0ZWRJbmRleFwiIHx8IGF0dHIgPT09IFwic2VsZWN0ZWRcIiAmJiB2bm9kZS5kb20gPT09ICRkb2MuYWN0aXZlRWxlbWVudFxuXHR9XG5cdGZ1bmN0aW9uIGlzTGlmZWN5Y2xlTWV0aG9kKGF0dHIpIHtcblx0XHRyZXR1cm4gYXR0ciA9PT0gXCJvbmluaXRcIiB8fCBhdHRyID09PSBcIm9uY3JlYXRlXCIgfHwgYXR0ciA9PT0gXCJvbnVwZGF0ZVwiIHx8IGF0dHIgPT09IFwib25yZW1vdmVcIiB8fCBhdHRyID09PSBcIm9uYmVmb3JlcmVtb3ZlXCIgfHwgYXR0ciA9PT0gXCJvbmJlZm9yZXVwZGF0ZVwiXG5cdH1cblx0ZnVuY3Rpb24gaXNBdHRyaWJ1dGUoYXR0cikge1xuXHRcdHJldHVybiBhdHRyID09PSBcImhyZWZcIiB8fCBhdHRyID09PSBcImxpc3RcIiB8fCBhdHRyID09PSBcImZvcm1cIiB8fCBhdHRyID09PSBcIndpZHRoXCIgfHwgYXR0ciA9PT0gXCJoZWlnaHRcIi8vIHx8IGF0dHIgPT09IFwidHlwZVwiXG5cdH1cblx0ZnVuY3Rpb24gaXNDdXN0b21FbGVtZW50KHZub2RlKXtcblx0XHRyZXR1cm4gdm5vZGUuYXR0cnMuaXMgfHwgdm5vZGUudGFnLmluZGV4T2YoXCItXCIpID4gLTFcblx0fVxuXHRmdW5jdGlvbiBoYXNJbnRlZ3JhdGlvbk1ldGhvZHMoc291cmNlKSB7XG5cdFx0cmV0dXJuIHNvdXJjZSAhPSBudWxsICYmIChzb3VyY2Uub25jcmVhdGUgfHwgc291cmNlLm9udXBkYXRlIHx8IHNvdXJjZS5vbmJlZm9yZXJlbW92ZSB8fCBzb3VyY2Uub25yZW1vdmUpXG5cdH1cblx0Ly9zdHlsZVxuXHRmdW5jdGlvbiB1cGRhdGVTdHlsZShlbGVtZW50LCBvbGQsIHN0eWxlKSB7XG5cdFx0aWYgKG9sZCA9PT0gc3R5bGUpIGVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IFwiXCIsIG9sZCA9IG51bGxcblx0XHRpZiAoc3R5bGUgPT0gbnVsbCkgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gXCJcIlxuXHRcdGVsc2UgaWYgKHR5cGVvZiBzdHlsZSA9PT0gXCJzdHJpbmdcIikgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gc3R5bGVcblx0XHRlbHNlIHtcblx0XHRcdGlmICh0eXBlb2Ygb2xkID09PSBcInN0cmluZ1wiKSBlbGVtZW50LnN0eWxlLmNzc1RleHQgPSBcIlwiXG5cdFx0XHRmb3IgKHZhciBrZXkyIGluIHN0eWxlKSB7XG5cdFx0XHRcdGVsZW1lbnQuc3R5bGVba2V5Ml0gPSBzdHlsZVtrZXkyXVxuXHRcdFx0fVxuXHRcdFx0aWYgKG9sZCAhPSBudWxsICYmIHR5cGVvZiBvbGQgIT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0Zm9yICh2YXIga2V5MiBpbiBvbGQpIHtcblx0XHRcdFx0XHRpZiAoIShrZXkyIGluIHN0eWxlKSkgZWxlbWVudC5zdHlsZVtrZXkyXSA9IFwiXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHQvL2V2ZW50XG5cdGZ1bmN0aW9uIHVwZGF0ZUV2ZW50KHZub2RlLCBrZXkyLCB2YWx1ZSkge1xuXHRcdHZhciBlbGVtZW50ID0gdm5vZGUuZG9tXG5cdFx0dmFyIGNhbGxiYWNrID0gdHlwZW9mIG9uZXZlbnQgIT09IFwiZnVuY3Rpb25cIiA/IHZhbHVlIDogZnVuY3Rpb24oZSkge1xuXHRcdFx0dmFyIHJlc3VsdCA9IHZhbHVlLmNhbGwoZWxlbWVudCwgZSlcblx0XHRcdG9uZXZlbnQuY2FsbChlbGVtZW50LCBlKVxuXHRcdFx0cmV0dXJuIHJlc3VsdFxuXHRcdH1cblx0XHRpZiAoa2V5MiBpbiBlbGVtZW50KSBlbGVtZW50W2tleTJdID0gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBjYWxsYmFjayA6IG51bGxcblx0XHRlbHNlIHtcblx0XHRcdHZhciBldmVudE5hbWUgPSBrZXkyLnNsaWNlKDIpXG5cdFx0XHRpZiAodm5vZGUuZXZlbnRzID09PSB1bmRlZmluZWQpIHZub2RlLmV2ZW50cyA9IHt9XG5cdFx0XHRpZiAodm5vZGUuZXZlbnRzW2tleTJdID09PSBjYWxsYmFjaykgcmV0dXJuXG5cdFx0XHRpZiAodm5vZGUuZXZlbnRzW2tleTJdICE9IG51bGwpIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIHZub2RlLmV2ZW50c1trZXkyXSwgZmFsc2UpXG5cdFx0XHRpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0dm5vZGUuZXZlbnRzW2tleTJdID0gY2FsbGJhY2tcblx0XHRcdFx0ZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgdm5vZGUuZXZlbnRzW2tleTJdLCBmYWxzZSlcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0Ly9saWZlY3ljbGVcblx0ZnVuY3Rpb24gaW5pdExpZmVjeWNsZShzb3VyY2UsIHZub2RlLCBob29rcykge1xuXHRcdGlmICh0eXBlb2Ygc291cmNlLm9uaW5pdCA9PT0gXCJmdW5jdGlvblwiKSBzb3VyY2Uub25pbml0LmNhbGwodm5vZGUuc3RhdGUsIHZub2RlKVxuXHRcdGlmICh0eXBlb2Ygc291cmNlLm9uY3JlYXRlID09PSBcImZ1bmN0aW9uXCIpIGhvb2tzLnB1c2goc291cmNlLm9uY3JlYXRlLmJpbmQodm5vZGUuc3RhdGUsIHZub2RlKSlcblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVMaWZlY3ljbGUoc291cmNlLCB2bm9kZSwgaG9va3MpIHtcblx0XHRpZiAodHlwZW9mIHNvdXJjZS5vbnVwZGF0ZSA9PT0gXCJmdW5jdGlvblwiKSBob29rcy5wdXNoKHNvdXJjZS5vbnVwZGF0ZS5iaW5kKHZub2RlLnN0YXRlLCB2bm9kZSkpXG5cdH1cblx0ZnVuY3Rpb24gc2hvdWxkTm90VXBkYXRlKHZub2RlLCBvbGQpIHtcblx0XHR2YXIgZm9yY2VWbm9kZVVwZGF0ZSwgZm9yY2VDb21wb25lbnRVcGRhdGVcblx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCAmJiB0eXBlb2Ygdm5vZGUuYXR0cnMub25iZWZvcmV1cGRhdGUgPT09IFwiZnVuY3Rpb25cIikgZm9yY2VWbm9kZVVwZGF0ZSA9IHZub2RlLmF0dHJzLm9uYmVmb3JldXBkYXRlLmNhbGwodm5vZGUuc3RhdGUsIHZub2RlLCBvbGQpXG5cdFx0aWYgKHR5cGVvZiB2bm9kZS50YWcgIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHZub2RlLl9zdGF0ZS5vbmJlZm9yZXVwZGF0ZSA9PT0gXCJmdW5jdGlvblwiKSBmb3JjZUNvbXBvbmVudFVwZGF0ZSA9IHZub2RlLl9zdGF0ZS5vbmJlZm9yZXVwZGF0ZS5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSwgb2xkKVxuXHRcdGlmICghKGZvcmNlVm5vZGVVcGRhdGUgPT09IHVuZGVmaW5lZCAmJiBmb3JjZUNvbXBvbmVudFVwZGF0ZSA9PT0gdW5kZWZpbmVkKSAmJiAhZm9yY2VWbm9kZVVwZGF0ZSAmJiAhZm9yY2VDb21wb25lbnRVcGRhdGUpIHtcblx0XHRcdHZub2RlLmRvbSA9IG9sZC5kb21cblx0XHRcdHZub2RlLmRvbVNpemUgPSBvbGQuZG9tU2l6ZVxuXHRcdFx0dm5vZGUuaW5zdGFuY2UgPSBvbGQuaW5zdGFuY2Vcblx0XHRcdHJldHVybiB0cnVlXG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZVxuXHR9XG5cdGZ1bmN0aW9uIHJlbmRlcihkb20sIHZub2Rlcykge1xuXHRcdGlmICghZG9tKSB0aHJvdyBuZXcgRXJyb3IoXCJFbnN1cmUgdGhlIERPTSBlbGVtZW50IGJlaW5nIHBhc3NlZCB0byBtLnJvdXRlL20ubW91bnQvbS5yZW5kZXIgaXMgbm90IHVuZGVmaW5lZC5cIilcblx0XHR2YXIgaG9va3MgPSBbXVxuXHRcdHZhciBhY3RpdmUgPSAkZG9jLmFjdGl2ZUVsZW1lbnRcblx0XHR2YXIgbmFtZXNwYWNlID0gZG9tLm5hbWVzcGFjZVVSSVxuXHRcdC8vIEZpcnN0IHRpbWUwIHJlbmRlcmluZyBpbnRvIGEgbm9kZSBjbGVhcnMgaXQgb3V0XG5cdFx0aWYgKGRvbS52bm9kZXMgPT0gbnVsbCkgZG9tLnRleHRDb250ZW50ID0gXCJcIlxuXHRcdGlmICghQXJyYXkuaXNBcnJheSh2bm9kZXMpKSB2bm9kZXMgPSBbdm5vZGVzXVxuXHRcdHVwZGF0ZU5vZGVzKGRvbSwgZG9tLnZub2RlcywgVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4odm5vZGVzKSwgZmFsc2UsIGhvb2tzLCBudWxsLCBuYW1lc3BhY2UgPT09IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiID8gdW5kZWZpbmVkIDogbmFtZXNwYWNlKVxuXHRcdGRvbS52bm9kZXMgPSB2bm9kZXNcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSBob29rc1tpXSgpXG5cdFx0aWYgKCRkb2MuYWN0aXZlRWxlbWVudCAhPT0gYWN0aXZlKSBhY3RpdmUuZm9jdXMoKVxuXHR9XG5cdHJldHVybiB7cmVuZGVyOiByZW5kZXIsIHNldEV2ZW50Q2FsbGJhY2s6IHNldEV2ZW50Q2FsbGJhY2t9XG59XG5mdW5jdGlvbiB0aHJvdHRsZShjYWxsYmFjaykge1xuXHQvLzYwZnBzIHRyYW5zbGF0ZXMgdG8gMTYuNm1zLCByb3VuZCBpdCBkb3duIHNpbmNlIHNldFRpbWVvdXQgcmVxdWlyZXMgaW50XG5cdHZhciB0aW1lID0gMTZcblx0dmFyIGxhc3QgPSAwLCBwZW5kaW5nID0gbnVsbFxuXHR2YXIgdGltZW91dCA9IHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09IFwiZnVuY3Rpb25cIiA/IHJlcXVlc3RBbmltYXRpb25GcmFtZSA6IHNldFRpbWVvdXRcblx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBub3cgPSBEYXRlLm5vdygpXG5cdFx0aWYgKGxhc3QgPT09IDAgfHwgbm93IC0gbGFzdCA+PSB0aW1lKSB7XG5cdFx0XHRsYXN0ID0gbm93XG5cdFx0XHRjYWxsYmFjaygpXG5cdFx0fVxuXHRcdGVsc2UgaWYgKHBlbmRpbmcgPT09IG51bGwpIHtcblx0XHRcdHBlbmRpbmcgPSB0aW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRwZW5kaW5nID0gbnVsbFxuXHRcdFx0XHRjYWxsYmFjaygpXG5cdFx0XHRcdGxhc3QgPSBEYXRlLm5vdygpXG5cdFx0XHR9LCB0aW1lIC0gKG5vdyAtIGxhc3QpKVxuXHRcdH1cblx0fVxufVxudmFyIF8xMSA9IGZ1bmN0aW9uKCR3aW5kb3cpIHtcblx0dmFyIHJlbmRlclNlcnZpY2UgPSBjb3JlUmVuZGVyZXIoJHdpbmRvdylcblx0cmVuZGVyU2VydmljZS5zZXRFdmVudENhbGxiYWNrKGZ1bmN0aW9uKGUpIHtcblx0XHRpZiAoZS5yZWRyYXcgPT09IGZhbHNlKSBlLnJlZHJhdyA9IHVuZGVmaW5lZFxuXHRcdGVsc2UgcmVkcmF3KClcblx0fSlcblx0dmFyIGNhbGxiYWNrcyA9IFtdXG5cdGZ1bmN0aW9uIHN1YnNjcmliZShrZXkxLCBjYWxsYmFjaykge1xuXHRcdHVuc3Vic2NyaWJlKGtleTEpXG5cdFx0Y2FsbGJhY2tzLnB1c2goa2V5MSwgdGhyb3R0bGUoY2FsbGJhY2spKVxuXHR9XG5cdGZ1bmN0aW9uIHVuc3Vic2NyaWJlKGtleTEpIHtcblx0XHR2YXIgaW5kZXggPSBjYWxsYmFja3MuaW5kZXhPZihrZXkxKVxuXHRcdGlmIChpbmRleCA+IC0xKSBjYWxsYmFja3Muc3BsaWNlKGluZGV4LCAyKVxuXHR9XG5cdGZ1bmN0aW9uIHJlZHJhdygpIHtcblx0XHRmb3IgKHZhciBpID0gMTsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkgKz0gMikge1xuXHRcdFx0Y2FsbGJhY2tzW2ldKClcblx0XHR9XG5cdH1cblx0cmV0dXJuIHtzdWJzY3JpYmU6IHN1YnNjcmliZSwgdW5zdWJzY3JpYmU6IHVuc3Vic2NyaWJlLCByZWRyYXc6IHJlZHJhdywgcmVuZGVyOiByZW5kZXJTZXJ2aWNlLnJlbmRlcn1cbn1cbnZhciByZWRyYXdTZXJ2aWNlID0gXzExKHdpbmRvdylcbnJlcXVlc3RTZXJ2aWNlLnNldENvbXBsZXRpb25DYWxsYmFjayhyZWRyYXdTZXJ2aWNlLnJlZHJhdylcbnZhciBfMTYgPSBmdW5jdGlvbihyZWRyYXdTZXJ2aWNlMCkge1xuXHRyZXR1cm4gZnVuY3Rpb24ocm9vdCwgY29tcG9uZW50KSB7XG5cdFx0aWYgKGNvbXBvbmVudCA9PT0gbnVsbCkge1xuXHRcdFx0cmVkcmF3U2VydmljZTAucmVuZGVyKHJvb3QsIFtdKVxuXHRcdFx0cmVkcmF3U2VydmljZTAudW5zdWJzY3JpYmUocm9vdClcblx0XHRcdHJldHVyblxuXHRcdH1cblx0XHRcblx0XHRpZiAoY29tcG9uZW50LnZpZXcgPT0gbnVsbCAmJiB0eXBlb2YgY29tcG9uZW50ICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcihcIm0ubW91bnQoZWxlbWVudCwgY29tcG9uZW50KSBleHBlY3RzIGEgY29tcG9uZW50LCBub3QgYSB2bm9kZVwiKVxuXHRcdFxuXHRcdHZhciBydW4wID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZWRyYXdTZXJ2aWNlMC5yZW5kZXIocm9vdCwgVm5vZGUoY29tcG9uZW50KSlcblx0XHR9XG5cdFx0cmVkcmF3U2VydmljZTAuc3Vic2NyaWJlKHJvb3QsIHJ1bjApXG5cdFx0cmVkcmF3U2VydmljZTAucmVkcmF3KClcblx0fVxufVxubS5tb3VudCA9IF8xNihyZWRyYXdTZXJ2aWNlKVxudmFyIFByb21pc2UgPSBQcm9taXNlUG9seWZpbGxcbnZhciBwYXJzZVF1ZXJ5U3RyaW5nID0gZnVuY3Rpb24oc3RyaW5nKSB7XG5cdGlmIChzdHJpbmcgPT09IFwiXCIgfHwgc3RyaW5nID09IG51bGwpIHJldHVybiB7fVxuXHRpZiAoc3RyaW5nLmNoYXJBdCgwKSA9PT0gXCI/XCIpIHN0cmluZyA9IHN0cmluZy5zbGljZSgxKVxuXHR2YXIgZW50cmllcyA9IHN0cmluZy5zcGxpdChcIiZcIiksIGRhdGEwID0ge30sIGNvdW50ZXJzID0ge31cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGVudHJ5ID0gZW50cmllc1tpXS5zcGxpdChcIj1cIilcblx0XHR2YXIga2V5NSA9IGRlY29kZVVSSUNvbXBvbmVudChlbnRyeVswXSlcblx0XHR2YXIgdmFsdWUgPSBlbnRyeS5sZW5ndGggPT09IDIgPyBkZWNvZGVVUklDb21wb25lbnQoZW50cnlbMV0pIDogXCJcIlxuXHRcdGlmICh2YWx1ZSA9PT0gXCJ0cnVlXCIpIHZhbHVlID0gdHJ1ZVxuXHRcdGVsc2UgaWYgKHZhbHVlID09PSBcImZhbHNlXCIpIHZhbHVlID0gZmFsc2Vcblx0XHR2YXIgbGV2ZWxzID0ga2V5NS5zcGxpdCgvXFxdXFxbP3xcXFsvKVxuXHRcdHZhciBjdXJzb3IgPSBkYXRhMFxuXHRcdGlmIChrZXk1LmluZGV4T2YoXCJbXCIpID4gLTEpIGxldmVscy5wb3AoKVxuXHRcdGZvciAodmFyIGogPSAwOyBqIDwgbGV2ZWxzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHR2YXIgbGV2ZWwgPSBsZXZlbHNbal0sIG5leHRMZXZlbCA9IGxldmVsc1tqICsgMV1cblx0XHRcdHZhciBpc051bWJlciA9IG5leHRMZXZlbCA9PSBcIlwiIHx8ICFpc05hTihwYXJzZUludChuZXh0TGV2ZWwsIDEwKSlcblx0XHRcdHZhciBpc1ZhbHVlID0gaiA9PT0gbGV2ZWxzLmxlbmd0aCAtIDFcblx0XHRcdGlmIChsZXZlbCA9PT0gXCJcIikge1xuXHRcdFx0XHR2YXIga2V5NSA9IGxldmVscy5zbGljZSgwLCBqKS5qb2luKClcblx0XHRcdFx0aWYgKGNvdW50ZXJzW2tleTVdID09IG51bGwpIGNvdW50ZXJzW2tleTVdID0gMFxuXHRcdFx0XHRsZXZlbCA9IGNvdW50ZXJzW2tleTVdKytcblx0XHRcdH1cblx0XHRcdGlmIChjdXJzb3JbbGV2ZWxdID09IG51bGwpIHtcblx0XHRcdFx0Y3Vyc29yW2xldmVsXSA9IGlzVmFsdWUgPyB2YWx1ZSA6IGlzTnVtYmVyID8gW10gOiB7fVxuXHRcdFx0fVxuXHRcdFx0Y3Vyc29yID0gY3Vyc29yW2xldmVsXVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gZGF0YTBcbn1cbnZhciBjb3JlUm91dGVyID0gZnVuY3Rpb24oJHdpbmRvdykge1xuXHR2YXIgc3VwcG9ydHNQdXNoU3RhdGUgPSB0eXBlb2YgJHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSA9PT0gXCJmdW5jdGlvblwiXG5cdHZhciBjYWxsQXN5bmMwID0gdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiID8gc2V0SW1tZWRpYXRlIDogc2V0VGltZW91dFxuXHRmdW5jdGlvbiBub3JtYWxpemUxKGZyYWdtZW50MCkge1xuXHRcdHZhciBkYXRhID0gJHdpbmRvdy5sb2NhdGlvbltmcmFnbWVudDBdLnJlcGxhY2UoLyg/OiVbYS1mODldW2EtZjAtOV0pKy9naW0sIGRlY29kZVVSSUNvbXBvbmVudClcblx0XHRpZiAoZnJhZ21lbnQwID09PSBcInBhdGhuYW1lXCIgJiYgZGF0YVswXSAhPT0gXCIvXCIpIGRhdGEgPSBcIi9cIiArIGRhdGFcblx0XHRyZXR1cm4gZGF0YVxuXHR9XG5cdHZhciBhc3luY0lkXG5cdGZ1bmN0aW9uIGRlYm91bmNlQXN5bmMoY2FsbGJhY2swKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKGFzeW5jSWQgIT0gbnVsbCkgcmV0dXJuXG5cdFx0XHRhc3luY0lkID0gY2FsbEFzeW5jMChmdW5jdGlvbigpIHtcblx0XHRcdFx0YXN5bmNJZCA9IG51bGxcblx0XHRcdFx0Y2FsbGJhY2swKClcblx0XHRcdH0pXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHBhcnNlUGF0aChwYXRoLCBxdWVyeURhdGEsIGhhc2hEYXRhKSB7XG5cdFx0dmFyIHF1ZXJ5SW5kZXggPSBwYXRoLmluZGV4T2YoXCI/XCIpXG5cdFx0dmFyIGhhc2hJbmRleCA9IHBhdGguaW5kZXhPZihcIiNcIilcblx0XHR2YXIgcGF0aEVuZCA9IHF1ZXJ5SW5kZXggPiAtMSA/IHF1ZXJ5SW5kZXggOiBoYXNoSW5kZXggPiAtMSA/IGhhc2hJbmRleCA6IHBhdGgubGVuZ3RoXG5cdFx0aWYgKHF1ZXJ5SW5kZXggPiAtMSkge1xuXHRcdFx0dmFyIHF1ZXJ5RW5kID0gaGFzaEluZGV4ID4gLTEgPyBoYXNoSW5kZXggOiBwYXRoLmxlbmd0aFxuXHRcdFx0dmFyIHF1ZXJ5UGFyYW1zID0gcGFyc2VRdWVyeVN0cmluZyhwYXRoLnNsaWNlKHF1ZXJ5SW5kZXggKyAxLCBxdWVyeUVuZCkpXG5cdFx0XHRmb3IgKHZhciBrZXk0IGluIHF1ZXJ5UGFyYW1zKSBxdWVyeURhdGFba2V5NF0gPSBxdWVyeVBhcmFtc1trZXk0XVxuXHRcdH1cblx0XHRpZiAoaGFzaEluZGV4ID4gLTEpIHtcblx0XHRcdHZhciBoYXNoUGFyYW1zID0gcGFyc2VRdWVyeVN0cmluZyhwYXRoLnNsaWNlKGhhc2hJbmRleCArIDEpKVxuXHRcdFx0Zm9yICh2YXIga2V5NCBpbiBoYXNoUGFyYW1zKSBoYXNoRGF0YVtrZXk0XSA9IGhhc2hQYXJhbXNba2V5NF1cblx0XHR9XG5cdFx0cmV0dXJuIHBhdGguc2xpY2UoMCwgcGF0aEVuZClcblx0fVxuXHR2YXIgcm91dGVyID0ge3ByZWZpeDogXCIjIVwifVxuXHRyb3V0ZXIuZ2V0UGF0aCA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0eXBlMiA9IHJvdXRlci5wcmVmaXguY2hhckF0KDApXG5cdFx0c3dpdGNoICh0eXBlMikge1xuXHRcdFx0Y2FzZSBcIiNcIjogcmV0dXJuIG5vcm1hbGl6ZTEoXCJoYXNoXCIpLnNsaWNlKHJvdXRlci5wcmVmaXgubGVuZ3RoKVxuXHRcdFx0Y2FzZSBcIj9cIjogcmV0dXJuIG5vcm1hbGl6ZTEoXCJzZWFyY2hcIikuc2xpY2Uocm91dGVyLnByZWZpeC5sZW5ndGgpICsgbm9ybWFsaXplMShcImhhc2hcIilcblx0XHRcdGRlZmF1bHQ6IHJldHVybiBub3JtYWxpemUxKFwicGF0aG5hbWVcIikuc2xpY2Uocm91dGVyLnByZWZpeC5sZW5ndGgpICsgbm9ybWFsaXplMShcInNlYXJjaFwiKSArIG5vcm1hbGl6ZTEoXCJoYXNoXCIpXG5cdFx0fVxuXHR9XG5cdHJvdXRlci5zZXRQYXRoID0gZnVuY3Rpb24ocGF0aCwgZGF0YSwgb3B0aW9ucykge1xuXHRcdHZhciBxdWVyeURhdGEgPSB7fSwgaGFzaERhdGEgPSB7fVxuXHRcdHBhdGggPSBwYXJzZVBhdGgocGF0aCwgcXVlcnlEYXRhLCBoYXNoRGF0YSlcblx0XHRpZiAoZGF0YSAhPSBudWxsKSB7XG5cdFx0XHRmb3IgKHZhciBrZXk0IGluIGRhdGEpIHF1ZXJ5RGF0YVtrZXk0XSA9IGRhdGFba2V5NF1cblx0XHRcdHBhdGggPSBwYXRoLnJlcGxhY2UoLzooW15cXC9dKykvZywgZnVuY3Rpb24obWF0Y2gyLCB0b2tlbikge1xuXHRcdFx0XHRkZWxldGUgcXVlcnlEYXRhW3Rva2VuXVxuXHRcdFx0XHRyZXR1cm4gZGF0YVt0b2tlbl1cblx0XHRcdH0pXG5cdFx0fVxuXHRcdHZhciBxdWVyeSA9IGJ1aWxkUXVlcnlTdHJpbmcocXVlcnlEYXRhKVxuXHRcdGlmIChxdWVyeSkgcGF0aCArPSBcIj9cIiArIHF1ZXJ5XG5cdFx0dmFyIGhhc2ggPSBidWlsZFF1ZXJ5U3RyaW5nKGhhc2hEYXRhKVxuXHRcdGlmIChoYXNoKSBwYXRoICs9IFwiI1wiICsgaGFzaFxuXHRcdGlmIChzdXBwb3J0c1B1c2hTdGF0ZSkge1xuXHRcdFx0dmFyIHN0YXRlID0gb3B0aW9ucyA/IG9wdGlvbnMuc3RhdGUgOiBudWxsXG5cdFx0XHR2YXIgdGl0bGUgPSBvcHRpb25zID8gb3B0aW9ucy50aXRsZSA6IG51bGxcblx0XHRcdCR3aW5kb3cub25wb3BzdGF0ZSgpXG5cdFx0XHRpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlcGxhY2UpICR3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoc3RhdGUsIHRpdGxlLCByb3V0ZXIucHJlZml4ICsgcGF0aClcblx0XHRcdGVsc2UgJHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZShzdGF0ZSwgdGl0bGUsIHJvdXRlci5wcmVmaXggKyBwYXRoKVxuXHRcdH1cblx0XHRlbHNlICR3aW5kb3cubG9jYXRpb24uaHJlZiA9IHJvdXRlci5wcmVmaXggKyBwYXRoXG5cdH1cblx0cm91dGVyLmRlZmluZVJvdXRlcyA9IGZ1bmN0aW9uKHJvdXRlcywgcmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0ZnVuY3Rpb24gcmVzb2x2ZVJvdXRlKCkge1xuXHRcdFx0dmFyIHBhdGggPSByb3V0ZXIuZ2V0UGF0aCgpXG5cdFx0XHR2YXIgcGFyYW1zID0ge31cblx0XHRcdHZhciBwYXRobmFtZSA9IHBhcnNlUGF0aChwYXRoLCBwYXJhbXMsIHBhcmFtcylcblx0XHRcdHZhciBzdGF0ZSA9ICR3aW5kb3cuaGlzdG9yeS5zdGF0ZVxuXHRcdFx0aWYgKHN0YXRlICE9IG51bGwpIHtcblx0XHRcdFx0Zm9yICh2YXIgayBpbiBzdGF0ZSkgcGFyYW1zW2tdID0gc3RhdGVba11cblx0XHRcdH1cblx0XHRcdGZvciAodmFyIHJvdXRlMCBpbiByb3V0ZXMpIHtcblx0XHRcdFx0dmFyIG1hdGNoZXIgPSBuZXcgUmVnRXhwKFwiXlwiICsgcm91dGUwLnJlcGxhY2UoLzpbXlxcL10rP1xcLnszfS9nLCBcIiguKj8pXCIpLnJlcGxhY2UoLzpbXlxcL10rL2csIFwiKFteXFxcXC9dKylcIikgKyBcIlxcLz8kXCIpXG5cdFx0XHRcdGlmIChtYXRjaGVyLnRlc3QocGF0aG5hbWUpKSB7XG5cdFx0XHRcdFx0cGF0aG5hbWUucmVwbGFjZShtYXRjaGVyLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHZhciBrZXlzID0gcm91dGUwLm1hdGNoKC86W15cXC9dKy9nKSB8fCBbXVxuXHRcdFx0XHRcdFx0dmFyIHZhbHVlcyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxLCAtMilcblx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRwYXJhbXNba2V5c1tpXS5yZXBsYWNlKC86fFxcLi9nLCBcIlwiKV0gPSBkZWNvZGVVUklDb21wb25lbnQodmFsdWVzW2ldKVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmVzb2x2ZShyb3V0ZXNbcm91dGUwXSwgcGFyYW1zLCBwYXRoLCByb3V0ZTApXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmVqZWN0KHBhdGgsIHBhcmFtcylcblx0XHR9XG5cdFx0aWYgKHN1cHBvcnRzUHVzaFN0YXRlKSAkd2luZG93Lm9ucG9wc3RhdGUgPSBkZWJvdW5jZUFzeW5jKHJlc29sdmVSb3V0ZSlcblx0XHRlbHNlIGlmIChyb3V0ZXIucHJlZml4LmNoYXJBdCgwKSA9PT0gXCIjXCIpICR3aW5kb3cub25oYXNoY2hhbmdlID0gcmVzb2x2ZVJvdXRlXG5cdFx0cmVzb2x2ZVJvdXRlKClcblx0fVxuXHRyZXR1cm4gcm91dGVyXG59XG52YXIgXzIwID0gZnVuY3Rpb24oJHdpbmRvdywgcmVkcmF3U2VydmljZTApIHtcblx0dmFyIHJvdXRlU2VydmljZSA9IGNvcmVSb3V0ZXIoJHdpbmRvdylcblx0dmFyIGlkZW50aXR5ID0gZnVuY3Rpb24odikge3JldHVybiB2fVxuXHR2YXIgcmVuZGVyMSwgY29tcG9uZW50LCBhdHRyczMsIGN1cnJlbnRQYXRoLCBsYXN0VXBkYXRlXG5cdHZhciByb3V0ZSA9IGZ1bmN0aW9uKHJvb3QsIGRlZmF1bHRSb3V0ZSwgcm91dGVzKSB7XG5cdFx0aWYgKHJvb3QgPT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKFwiRW5zdXJlIHRoZSBET00gZWxlbWVudCB0aGF0IHdhcyBwYXNzZWQgdG8gYG0ucm91dGVgIGlzIG5vdCB1bmRlZmluZWRcIilcblx0XHR2YXIgcnVuMSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKHJlbmRlcjEgIT0gbnVsbCkgcmVkcmF3U2VydmljZTAucmVuZGVyKHJvb3QsIHJlbmRlcjEoVm5vZGUoY29tcG9uZW50LCBhdHRyczMua2V5LCBhdHRyczMpKSlcblx0XHR9XG5cdFx0dmFyIGJhaWwgPSBmdW5jdGlvbihwYXRoKSB7XG5cdFx0XHRpZiAocGF0aCAhPT0gZGVmYXVsdFJvdXRlKSByb3V0ZVNlcnZpY2Uuc2V0UGF0aChkZWZhdWx0Um91dGUsIG51bGwsIHtyZXBsYWNlOiB0cnVlfSlcblx0XHRcdGVsc2UgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IHJlc29sdmUgZGVmYXVsdCByb3V0ZSBcIiArIGRlZmF1bHRSb3V0ZSlcblx0XHR9XG5cdFx0cm91dGVTZXJ2aWNlLmRlZmluZVJvdXRlcyhyb3V0ZXMsIGZ1bmN0aW9uKHBheWxvYWQsIHBhcmFtcywgcGF0aCkge1xuXHRcdFx0dmFyIHVwZGF0ZSA9IGxhc3RVcGRhdGUgPSBmdW5jdGlvbihyb3V0ZVJlc29sdmVyLCBjb21wKSB7XG5cdFx0XHRcdGlmICh1cGRhdGUgIT09IGxhc3RVcGRhdGUpIHJldHVyblxuXHRcdFx0XHRjb21wb25lbnQgPSBjb21wICE9IG51bGwgJiYgKHR5cGVvZiBjb21wLnZpZXcgPT09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgY29tcCA9PT0gXCJmdW5jdGlvblwiKT8gY29tcCA6IFwiZGl2XCJcblx0XHRcdFx0YXR0cnMzID0gcGFyYW1zLCBjdXJyZW50UGF0aCA9IHBhdGgsIGxhc3RVcGRhdGUgPSBudWxsXG5cdFx0XHRcdHJlbmRlcjEgPSAocm91dGVSZXNvbHZlci5yZW5kZXIgfHwgaWRlbnRpdHkpLmJpbmQocm91dGVSZXNvbHZlcilcblx0XHRcdFx0cnVuMSgpXG5cdFx0XHR9XG5cdFx0XHRpZiAocGF5bG9hZC52aWV3IHx8IHR5cGVvZiBwYXlsb2FkID09PSBcImZ1bmN0aW9uXCIpIHVwZGF0ZSh7fSwgcGF5bG9hZClcblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRpZiAocGF5bG9hZC5vbm1hdGNoKSB7XG5cdFx0XHRcdFx0UHJvbWlzZS5yZXNvbHZlKHBheWxvYWQub25tYXRjaChwYXJhbXMsIHBhdGgpKS50aGVuKGZ1bmN0aW9uKHJlc29sdmVkKSB7XG5cdFx0XHRcdFx0XHR1cGRhdGUocGF5bG9hZCwgcmVzb2x2ZWQpXG5cdFx0XHRcdFx0fSwgYmFpbClcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHVwZGF0ZShwYXlsb2FkLCBcImRpdlwiKVxuXHRcdFx0fVxuXHRcdH0sIGJhaWwpXG5cdFx0cmVkcmF3U2VydmljZTAuc3Vic2NyaWJlKHJvb3QsIHJ1bjEpXG5cdH1cblx0cm91dGUuc2V0ID0gZnVuY3Rpb24ocGF0aCwgZGF0YSwgb3B0aW9ucykge1xuXHRcdGlmIChsYXN0VXBkYXRlICE9IG51bGwpIHtcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cdFx0XHRvcHRpb25zLnJlcGxhY2UgPSB0cnVlXG5cdFx0fVxuXHRcdGxhc3RVcGRhdGUgPSBudWxsXG5cdFx0cm91dGVTZXJ2aWNlLnNldFBhdGgocGF0aCwgZGF0YSwgb3B0aW9ucylcblx0fVxuXHRyb3V0ZS5nZXQgPSBmdW5jdGlvbigpIHtyZXR1cm4gY3VycmVudFBhdGh9XG5cdHJvdXRlLnByZWZpeCA9IGZ1bmN0aW9uKHByZWZpeDApIHtyb3V0ZVNlcnZpY2UucHJlZml4ID0gcHJlZml4MH1cblx0cm91dGUubGluayA9IGZ1bmN0aW9uKHZub2RlMSkge1xuXHRcdHZub2RlMS5kb20uc2V0QXR0cmlidXRlKFwiaHJlZlwiLCByb3V0ZVNlcnZpY2UucHJlZml4ICsgdm5vZGUxLmF0dHJzLmhyZWYpXG5cdFx0dm5vZGUxLmRvbS5vbmNsaWNrID0gZnVuY3Rpb24oZSkge1xuXHRcdFx0aWYgKGUuY3RybEtleSB8fCBlLm1ldGFLZXkgfHwgZS5zaGlmdEtleSB8fCBlLndoaWNoID09PSAyKSByZXR1cm5cblx0XHRcdGUucHJldmVudERlZmF1bHQoKVxuXHRcdFx0ZS5yZWRyYXcgPSBmYWxzZVxuXHRcdFx0dmFyIGhyZWYgPSB0aGlzLmdldEF0dHJpYnV0ZShcImhyZWZcIilcblx0XHRcdGlmIChocmVmLmluZGV4T2Yocm91dGVTZXJ2aWNlLnByZWZpeCkgPT09IDApIGhyZWYgPSBocmVmLnNsaWNlKHJvdXRlU2VydmljZS5wcmVmaXgubGVuZ3RoKVxuXHRcdFx0cm91dGUuc2V0KGhyZWYsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKVxuXHRcdH1cblx0fVxuXHRyb3V0ZS5wYXJhbSA9IGZ1bmN0aW9uKGtleTMpIHtcblx0XHRpZih0eXBlb2YgYXR0cnMzICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBrZXkzICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gYXR0cnMzW2tleTNdXG5cdFx0cmV0dXJuIGF0dHJzM1xuXHR9XG5cdHJldHVybiByb3V0ZVxufVxubS5yb3V0ZSA9IF8yMCh3aW5kb3csIHJlZHJhd1NlcnZpY2UpXG5tLndpdGhBdHRyID0gZnVuY3Rpb24oYXR0ck5hbWUsIGNhbGxiYWNrMSwgY29udGV4dCkge1xuXHRyZXR1cm4gZnVuY3Rpb24oZSkge1xuXHRcdGNhbGxiYWNrMS5jYWxsKGNvbnRleHQgfHwgdGhpcywgYXR0ck5hbWUgaW4gZS5jdXJyZW50VGFyZ2V0ID8gZS5jdXJyZW50VGFyZ2V0W2F0dHJOYW1lXSA6IGUuY3VycmVudFRhcmdldC5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpKVxuXHR9XG59XG52YXIgXzI4ID0gY29yZVJlbmRlcmVyKHdpbmRvdylcbm0ucmVuZGVyID0gXzI4LnJlbmRlclxubS5yZWRyYXcgPSByZWRyYXdTZXJ2aWNlLnJlZHJhd1xubS5yZXF1ZXN0ID0gcmVxdWVzdFNlcnZpY2UucmVxdWVzdFxubS5qc29ucCA9IHJlcXVlc3RTZXJ2aWNlLmpzb25wXG5tLnBhcnNlUXVlcnlTdHJpbmcgPSBwYXJzZVF1ZXJ5U3RyaW5nXG5tLmJ1aWxkUXVlcnlTdHJpbmcgPSBidWlsZFF1ZXJ5U3RyaW5nXG5tLnZlcnNpb24gPSBcIjEuMS4zXCJcbm0udm5vZGUgPSBWbm9kZVxuaWYgKHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIpIG1vZHVsZVtcImV4cG9ydHNcIl0gPSBtXG5lbHNlIHdpbmRvdy5tID0gbVxufSgpKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbWl0aHJpbC9taXRocmlsLmpzXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n')},function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\nexports.fakeClick = exports.hexToRgba = exports.popoverContent = exports.summary = exports.restart = exports.reset = exports.byId = exports.estimateLadda = exports.d3mProblemDescription = exports.d3mMetrics = exports.d3mTaskSubtype = exports.d3mTaskType = exports.domainIdentifier = exports.callHistory = exports.links = exports.nodes = exports.allResults = exports.allNodes = exports.valueKey = exports.modelCount = exports.zparams = exports.logArray = exports.locktoggle = exports.transformList = exports.righttab = exports.summaryHold = exports.subset = exports.lefttab = exports.timeColor = exports.varColor = exports.nomColor = exports.gr2Color = exports.gr1Color = exports.dvColor = exports.csColor = exports.cdb = exports.is_results_mode = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();\n\nvar _arguments = arguments;\nexports.main = main;\nexports.findNodeIndex = findNodeIndex;\nexports.findNode = findNode;\nexports.clickVar = clickVar;\nexports.getVariableData = getVariableData;\nexports.forceSwitch = forceSwitch;\nexports.helpmaterials = helpmaterials;\nexports.lockDescription = lockDescription;\nexports.zPop = zPop;\nexports.downloadIncomplete = downloadIncomplete;\nexports.estimate = estimate;\nexports.ta2stuff = ta2stuff;\nexports.makeRequest = makeRequest;\nexports.legend = legend;\nexports.erase = erase;\nexports.tabLeft = tabLeft;\nexports.tabRight = tabRight;\nexports.panelPlots = panelPlots;\nexports.borderState = borderState;\nexports.subsetSelect = subsetSelect;\nexports.endsession = endsession;\nexports.listpipelines = listpipelines;\nexports.executepipeline = executepipeline;\nexports.expandrightpanel = expandrightpanel;\nexports.resultsplotinit = resultsplotinit;\nexports.genconfdata = genconfdata;\nexports.confusionmatrix = confusionmatrix;\nexports.bivariatePlot = bivariatePlot;\nexports.setxTable = setxTable;\nexports.exportpipeline = exportpipeline;\nexports.deletepipeline = deletepipeline;\nexports.ta3_search_message = ta3_search_message;\nexports.test_msg_ta3_search = test_msg_ta3_search;\nexports.end_ta3_search = end_ta3_search;\nexports.record_user_metadata = record_user_metadata;\n\nvar _hopscotch = __webpack_require__(15);\n\nvar _hopscotch2 = _interopRequireDefault(_hopscotch);\n\nvar _mithril = __webpack_require__(0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _plots = __webpack_require__(2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// hostname default - the app will use it to obtain the variable metadata\n// (ddi) and pre-processed data info if the file id is supplied as an\n// argument (for ex., gui.html?dfId=17), but hostname isn\'t.\n// Edit it to suit your installation.\n// (NOTE that if the file id isn\'t supplied, the app will default to the\n// local files specified below!)\n// NEW: it is also possible now to supply complete urls for the ddi and\n// the tab-delimited data file; the parameters are ddiurl and dataurl.\n// These new parameters are optional. If they are not supplied, the app\n// will go the old route - will try to cook standard dataverse urls\n// for both the data and metadata, if the file id is supplied; or the\n// local files if nothing is supplied.\n\n//-------------------------------------------------\n// NOTE: global variables are now set in the index.html file.\n//    Developers, see /template/index.html\n//-------------------------------------------------\n\nvar is_results_mode = exports.is_results_mode = false;\n\n// for debugging - if not in PRODUCTION, prints args\nvar cdb = exports.cdb = function cdb(_) {\n    var _console;\n\n    return PRODUCTION || (_console = console).log.apply(_console, _arguments);\n};\n\nvar k = 4; // strength parameter for group attraction/repulsion\nvar tutorial_mode = true;\nvar first_load = true;\n\n// initial color scale used to establish the initial colors of nodes\n// allNodes.push() below establishes a field for the master node array allNodes called "nodeCol" and assigns a color from this scale to that field\n// everything there after should refer to the nodeCol and not the color scale, this enables us to update colors and pass the variable type to R based on its coloring\nvar colors = d3.scale.category20();\nvar csColor = exports.csColor = \'#419641\';\nvar dvColor = exports.dvColor = \'#28a4c9\';\nvar gr1Color = exports.gr1Color = \'#14bdcc\'; // initially was #24a4c9\', but that is dvColor, and we track some properties by color assuming them unique\nvar gr1Opacity = [0, 1];\nvar gr2Color = exports.gr2Color = \'#ffcccc\';\nvar gr2Opacity = [0, 1];\n\nvar grayColor = \'#c0c0c0\';\nvar nomColor = exports.nomColor = \'#ff6600\';\nvar varColor = exports.varColor = \'#f0f8ff\'; // d3.rgb("aliceblue");\nvar taggedColor = \'#f5f5f5\'; // d3.rgb("whitesmoke");\nvar timeColor = exports.timeColor = \'#2d6ca2\';\n\nvar lefttab = exports.lefttab = \'tab1\'; // current tab in left panel\nvar subset = exports.subset = false;\nvar summaryHold = exports.summaryHold = false;\nvar righttab = exports.righttab = \'btnModels\'; // current tab in right panel\n\n// transformation toolbar options\nvar t = void 0,\n    typeTransform = void 0;\nvar transformList = exports.transformList = \'log(d) exp(d) d^2 sqrt(d) interact(d,e)\'.split(\' \');\nvar transformVar = \'\';\n\n// var list for each space contain variables in original data\n// plus trans in that space\nvar trans = [];\nvar preprocess = {}; // hold pre-processed data\nvar spaces = [];\n\n// layout function constants\nvar layoutAdd = "add";\nvar layoutMove = "move";\n\n// radius of circle\nvar RADIUS = 40;\n\n// cx, cy, r values for indicator lights\nvar ind1 = [(RADIUS + 30) * Math.cos(1.3), -1 * (RADIUS + 30) * Math.sin(1.3), 5];\nvar ind2 = [(RADIUS + 30) * Math.cos(1.1), -1 * (RADIUS + 30) * Math.sin(1.1), 5];\n\n// space index\nvar myspace = 0;\n\nvar forcetoggle = ["true"];\nvar locktoggle = exports.locktoggle = true;\nvar priv = true;\n\n// swandive is our graceful fail for d3m\n// swandive set to true if task is in failset\nvar swandive = false;\nvar failset = ["TIMESERIESFORECASTING", "GRAPHMATCHING", "LINKPREDICTION", "timeSeriesForecasting", "graphMatching", "linkPrediction"];\n\nvar logArray = exports.logArray = [];\nvar zparams = exports.zparams = {\n    zdata: [],\n    zedges: [],\n    ztime: [],\n    znom: [],\n    zcross: [],\n    zmodel: "",\n    zvars: [],\n    zdv: [],\n    zgroup1: [],\n    zgroup2: [], // hard coding to two groups for present experiments, but will eventually make zgroup array of arrays, with zgroup.lenght the number of groups\n    zdataurl: "",\n    zd3mdata: "", //these take the place of zdataurl for d3m, because data is in two placees. eventually will generalize\n    zd3mtarget: "",\n    zsubset: [],\n    zsetx: [],\n    zmodelcount: 0,\n    zplot: [],\n    zsessionid: "",\n    zdatacite: \'...\',\n    zcrosstab: []\n};\n\nvar modelCount = exports.modelCount = 0;\nvar valueKey = exports.valueKey = [];\nvar allNodes = exports.allNodes = [];\nvar allResults = exports.allResults = [];\nvar nodes = exports.nodes = [];\nvar links = exports.links = [];\nvar mods = {};\nvar estimated = false;\nvar rightClickLast = false;\nvar selInteract = false;\nvar callHistory = exports.callHistory = []; // transform and subset calls\nvar mytarget = \'\';\n\nvar configurations = {};\nvar dataschema = {};\n\nvar domainIdentifier = exports.domainIdentifier = null; // available throughout apps js; used for saving workspace\n\n// eventually read this from the schema with real descriptions\n// metrics, tasks, and subtasks as specified in D3M schemas\n// MEAN SQUARED ERROR IS SET TO SAME AS RMSE. MSE is in schema but not proto\nvar d3mTaskType = exports.d3mTaskType = {\n    taskTypeUndefined: ["description", "TASK_TYPE_UNDEFINED", 0],\n    classification: ["description", "CLASSIFICATION", 1],\n    regression: ["description", "REGRESSION", 2],\n    clustering: ["description", "CLUSTERING", 3],\n    linkPrediction: ["description", "LINK_PREDICTION", 4],\n    vertexNomination: ["description", "VERTEX_NOMINATION", 5],\n    communityDetection: ["description", "COMMUNITY_DETECTION", 6],\n    graphClustering: ["description", "GRAPH_CLUSTERING", 7],\n    graphMatching: ["description", "GRAPH_MATCHING", 8],\n    timeSeriesForecasting: ["description", "TIME_SERIES_FORECASTING", 9],\n    collaborativeFiltering: ["description", "COLLABORATIVE_FILTERING", 10]\n};\n\nvar d3mTaskSubtype = exports.d3mTaskSubtype = {\n    taskSubtypeUndefined: ["description", "TASK_SUBTYPE_UNDEFINED", 0],\n    subtypeNone: ["description", "NONE", 1],\n    binary: ["description", "BINARY", 2],\n    multiClass: ["description", "MULTICLASS", 3],\n    multiLabel: ["description", "MULTILABEL", 4],\n    univariate: ["description", "UNIVARIATE", 5],\n    multivariate: ["description", "MULTIVARIATE", 6],\n    overlapping: ["description", "OVERLAPPING", 7],\n    nonOverlapping: ["description", "NONOVERLAPPING", 8]\n};\n/*export let d3mOutputType = {\n    outputUndefined:["description","OUTPUT_TYPE_UNDEFINED ", 0],\n    predictionsFile:["description","PREDICTIONS_FILE",1],\n    scoresFile:["description","SCORES_FILE",2]\n}; */\nvar d3mMetrics = exports.d3mMetrics = {\n    metricUndefined: ["description", "METRIC_UNDEFINED", 0],\n    executionTime: ["description", "EXECUTION_TIME", 1],\n    accuracy: ["description", "ACCURACY", 2],\n    f1: ["description", "F1", 3],\n    f1Micro: ["description", "F1_MICRO", 4],\n    f1Macro: ["description", "F1_MACRO", 5],\n    rocAuc: ["description", "ROC_AUC", 6],\n    rocAucMicro: ["description", "ROC_AUC_MICRO", 7],\n    rocAucMacro: ["description", "ROC_AUC_MACRO", 8],\n    meanSquaredError: ["description", "MEAN_SQUARED_ERROR", 9],\n    rootMeanSquaredError: ["description", "ROOT_MEAN_SQUARED_ERROR", 10],\n    rootMeanSquaredErrorAvg: ["description", "ROOT_MEAN_SQUARED_ERROR_AVG", 11],\n    meanAbsoluteError: ["description", "MEAN_ABSOLUTE_ERROR", 12],\n    rSquared: ["description", "R_SQUARED", 13],\n    normalizedMutualInformation: ["description", "NORMALIZED_MUTUAL_INFORMATION", 14],\n    jaccardSimilarityScore: ["description", "JACCARD_SIMILARITY_SCORE", 15]\n};\n\nvar d3mProblemDescription = exports.d3mProblemDescription = {\n    taskType: [2, "DEFAULT"],\n    taskSubtype: [1, "DEFAFULT"],\n    //   outputType: [3,"DEFAULT"],\n    metric: [3, "DEFAULT"],\n    taskDescription: ""\n};\n\nvar svg = void 0,\n    width = void 0,\n    height = void 0,\n    div = void 0,\n    selectLadda = void 0;\nvar estimateLadda = exports.estimateLadda = void 0;\n\n// arcs for denoting pebble characteristics\nvar arc = function arc(start, end) {\n    return d3.svg.arc().innerRadius(RADIUS + 5).outerRadius(RADIUS + 20).startAngle(start).endAngle(end);\n};\nvar _ref = [arc(0, 3.2), arc(0, 1), arc(1.1, 2.2), arc(2.3, 3.3), arc(4.3, 5.3)],\n    arc0 = _ref[0],\n    arc1 = _ref[1],\n    arc2 = _ref[2],\n    arc3 = _ref[3],\n    arc4 = _ref[4];\n\nvar arcInd = function arcInd(arclimits) {\n    return d3.svg.arc().innerRadius(RADIUS + 22).outerRadius(RADIUS + 37).startAngle(arclimits[0]).endAngle(arclimits[1]);\n};\n\nvar arcInd1Limits = [0, 0.3],\n    arcInd2Limits = [0.35, 0.65];\nvar _ref2 = [arcInd(arcInd1Limits), arcInd(arcInd2Limits)],\n    arcInd1 = _ref2[0],\n    arcInd2 = _ref2[1];\nvar byId = exports.byId = function byId(id) {\n    return document.getElementById(id);\n};\n\n/**\n   page reload linked to btnReset\n*/\nvar reset = exports.reset = function reloadPage() {\n    location.reload();\n};\nvar _restart = void 0;\n\nexports.restart = _restart;\nvar dataurl = \'\';\n\n/**\n  called by main\n  Loads all external data in the following order (logic is not included):\n  1. Retrieve the configuration information\n  2. Set \'configurations\'\n  3. Read the problem schema and set \'d3mProblemDescription\'\n  4. Read the data schema and set \'dataschema\'\n  5. Read in zelig models (not for d3m)\n  6. Read in zeligchoice models (not for d3m)\n  7. Start the user session\n  8. Read preprocess data or (if necessary) run preprocess\n  9. Build allNodes[] using preprocessed information\n  10. Add dataschema information to allNodes (when in IS_D3M_DOMAIN)\n  11. Call layout() and start up\n*/\nasync function load(hold, lablArray, d3mRootPath, d3mDataName, d3mPreprocess, d3mData, d3mPS, d3mDS, pURL) {\n    if (!IS_D3M_DOMAIN) {\n        return;\n    }\n\n    // 1. Retrieve the configuration information\n    var res = await _mithril2.default.request({\n        method: "POST",\n        url: "/config/d3m-config/json/latest"\n    });\n    console.log(res);\n    // 2. Set \'configurations\'\n    configurations = JSON.parse(JSON.stringify(res)); // this is just copying res\n    d3mRootPath = configurations.training_data_root.replace(/\\/data/, \'\');\n    d3mDataName = configurations.name;\n\n    // scopes at app.js level; used for saving workspace\n    exports.domainIdentifier = domainIdentifier = { name: configurations.name,\n        source_url: configurations.config_url,\n        description: \'D3M config file\' };\n    //id: configurations.id};\n\n    d3mPS = "/config/d3m-config/get-problem-schema/json";\n    d3mDS = "/config/d3m-config/get-dataset-schema/json";\n    console.log("Configurations: ", configurations);\n    d3mPreprocess = pURL = \'rook-custom/rook-files/\' + d3mDataName + \'/preprocess/preprocess.json\';\n\n    // 3. Read the problem schema and set \'d3mProblemDescription\'\n    // ...and make a call to start the session with TA2. if we get this far, data are guaranteed to exist for the frontend\n    res = await _mithril2.default.request("/config/d3m-config/get-problem-data-file-info");\n    console.log(res);\n    // some simple logic to get the paths right\n    // note that if neither exist, stay as default which is null\n    var set = function set(field, val) {\n        return res.data[field].exists ? res.data[field].path : res.data[field + \'.gz\'].exists ? res.data[field + \'.gz\'].path : val;\n    };\n\n    zparams.zd3mdata = d3mData = set(\'learningData.csv\', d3mData);\n    zparams.zd3mtarget = set(\'learningData.csv\', d3mData);\n\n    // hardcoding this, once get-problem-data-file-info is revised this hardcode can go away and use the previous two LOC\n    //  zparams.zd3mdata = d3mData = d3mRootPath+"/dataset_TRAIN/tables/learningData.csv";\n    //  zparams.zd3mtarget = d3mRootPath+"/dataset_TRAIN/tables/learningData.csv";\n\n    res = await _mithril2.default.request(d3mPS);\n    console.log("prob schema data: ", res);\n    mytarget = res.inputs.data[0].targets[0].colName; // easier way to access target name?\n\n    if (IS_D3M_DOMAIN) {\n        zparams.zdata = d3mDataName;\n    } else {\n        // Note: presently xml is no longer being read from Dataverse metadata anywhere\n        var temp = xml.documentElement.getElementsByTagName("fileName");\n        zparams.zdata = temp[0].childNodes[0].nodeValue;\n        var cite = xml.documentElement.getElementsByTagName("biblCit");\n        // clean citation so POST is valid json\n        zparams.zdatacite = cite[0].childNodes[0].nodeValue.replace(/\\&/g, "and").replace(/\\;/g, ",").replace(/\\%/g, "-");\n        $(\'#cite div.panel-body\').text(zparams.zdatacite);\n    }\n    // drop file extension\n    var dataname = IS_D3M_DOMAIN ? zparams.zdata : zparams.zdata.replace(/\\.(.*)/, \'\');\n    d3.select("#dataName").html(dataname);\n    // put dataset name, from meta-data, into page title\n    d3.select("title").html("TwoRavens " + dataname);\n\n    //  set = (field, arr) => d3mProblemDescription[field] = res[field] in arr ? res[field] : field + \'Undefined\';\n    d3mProblemDescription.taskType = res.about.taskType;\n    d3mProblemDescription.taskSubtype = res.about.taskSubType;\n    d3mProblemDescription.metric = res.inputs.performanceMetrics[0].metric;\n    //   d3mProblemDescription.outputType = res.expectedOutputs.predictionsFile;\n    //   set(\'taskType\', d3mTaskType);\n    //   set(\'taskSubtype\', d3mTaskSubtype);\n    //   set(\'metric\', d3mMetrics);\n    //   set(\'outputType\', d3mOutputType);\n    d3mProblemDescription.taskDescription = res.descriptionFile;\n    byId("btnType").click();\n\n    // making it case insensitive because the case seems to disagree all too often\n    if (failset.includes(d3mProblemDescription.taskType.toUpperCase())) {\n        swandive = true;\n    }\n\n    // 4. Read the data schema and set \'dataschema\'\n    dataschema = await _mithril2.default.request(d3mDS);\n    // if swandive, we have to set valueKey here so that left panel can populate\n    if (swandive) {\n        [dataschema.trainData.trainData, dataschema.trainData.trainTargets].forEach(function (vars) {\n            return vars && vars.forEach(function (v) {\n                return valueKey.push(v.varName);\n            });\n        });\n        // end session if neither trainData nor trainTargets?\n        valueKey.length === 0 && alert("no trainData or trainTargest in data description file. valueKey length is 0");\n        // perhaps allow users to unlock and select things?\n        byId(\'btnLock\').classList.add(\'noshow\');\n        byId(\'btnForce\').classList.add(\'noshow\');\n        byId(\'btnEraser\').classList.add(\'noshow\');\n        byId(\'btnSubset\').classList.add(\'noshow\');\n        byId(\'main\').style.backgroundColor = \'grey\';\n        byId(\'whitespace\').style.backgroundColor = \'grey\';\n    }\n    console.log("data schema data: ", dataschema);\n\n    // 5. Read in zelig models (not for d3m)\n    // 6. Read in zeligchoice models (not for d3m)\n    if (!IS_D3M_DOMAIN) {\n        var _arr = [\'zelig5models\', \'zelig5choicemodels\'];\n\n        var _loop = async function _loop() {\n            var field = _arr[_i];\n            try {\n                res = await _mithril2.default.request(\'data/\' + field + \'.json\');\n                cdb(field + \' json: \', res);\n                res[field].filter(function (key) {\n                    return res[field].hasOwnProperty(key);\n                }).forEach(function (key) {\n                    return mods[key.name[0]] = key.description[0];\n                });\n            } catch (_) {\n                console.log("can\'t load " + field);\n            }\n        };\n\n        for (var _i = 0; _i < _arr.length; _i++) {\n            await _loop();\n        }\n    }\n    // 7. Start the user session\n    // rpc StartSession(SessionRequest) returns (SessionResponse) {}\n    res = await makeRequest(D3M_SVC_URL + \'/startsession\', { user_agent: \'some agent\', version: \'some version\' });\n    if (res) {\n        zparams.zsessionid = res.context.sessionId;\n    }\n\n    // hopscotch tutorial\n    if (tutorial_mode) {\n        console.log(\'Starting Hopscotch Tour\');\n        var step = function step(target, placement, title, content) {\n            return {\n                target: target,\n                placement: placement,\n                title: title,\n                content: content,\n                showCTAButton: true,\n                ctaLabel: \'Disable these messages\',\n                onCTA: function onCTA() {\n                    _hopscotch2.default.endTour(true);\n                    tutorial_mode = false;\n                }\n            };\n        };\n        _hopscotch2.default.startTour({\n            id: "dataset_launch",\n            i18n: { doneBtn: \'Ok\' },\n            showCloseButton: false,\n            scrollDuration: 300,\n            onEnd: function onEnd() {\n                return first_load = false;\n            },\n            steps: [step("dataName", "bottom", "Welcome to TwoRavens Solver", \'<p>This tool can guide you to solve an empirical problem in the dataset listed above.</p>\\n                      <p>These messages will teach you the steps to take to find and submit a solution.</p>\'), step("btnReset", "bottom", "Restart Any Problem Here", \'<p>You can always start a problem over by using this reset button.</p>\'), step("btnEstimate", "left", "Solve Problem", \'<p>The current green button is generally the next step to follow to move the system forward.</p>\\n                      <p>Click this Solve button to tell the tool to find a solution to the problem.</p>\'), step(mytarget + \'biggroup\', "left", "Target Variable", \'This is the variable, \' + mytarget + \', we are trying to predict.\\n                      This center panel graphically represents the problem currently being attempted.\'), step("gr1hull", "right", "Explanation Set", "This set of variables can potentially predict the target."), step("displacement", "right", "Variable List", \'<p>Click on any variable name here if you wish to remove it from the problem solution.</p>\\n                      <p>You likely do not need to adjust the problem representation in the center panel.</p>\'), step("btnEndSession", "bottom", "Finish Problem", "If the solution reported back seems acceptable, then finish this problem by clicking this End Session button.")]\n        });\n        console.log(\'Ending Hopscotch Tour\');\n    }\n\n    // 8. read preprocess data or (if necessary) run preprocess\n    // NOTE: preprocess.json is now guaranteed to exist...\n    var read = function read(res) {\n        priv = res.dataset.private || priv;\n        Object.keys(res.variables).forEach(function (k) {\n            return preprocess[k] = res.variables[k];\n        });\n        return res;\n    };\n    try {\n        console.log(\'attempt to read preprocess file (which may not exist): \' + pURL);\n        res = read((await _mithril2.default.request(pURL)));\n    } catch (_) {\n        console.log("Ok, preprocess not found, try to RUN THE PREPROCESSAPP");\n        var url = ROOK_SVC_URL + \'preprocessapp\';\n        var json_input;\n        if (IS_D3M_DOMAIN) {\n            // For D3M inputs, change the preprocess input data\n            //\n            json_input = JSON.stringify({ data: d3mData, datastub: d3mDataName });\n        } else {\n            json_input = JSON.stringify({ data: dataloc, target: targetloc, datastub: datastub });\n        }\n\n        console.log(\'json_input: \', json_input);\n        console.log(\'url: \', url);\n        var data = new FormData();\n        try {\n            res = read((await _mithril2.default.request({ method: \'POST\', url: url, data: json_input })));\n        } catch (_) {\n            console.log(\'preprocess failed\');\n            alert(\'preprocess failed. ending user session.\');\n            endsession();\n        }\n    }\n\n    // 9. Build allNodes[] using preprocessed information\n    var vars = Object.keys(preprocess);\n    // temporary values for hold that correspond to histogram bins\n    hold = [.6, .2, .9, .8, .1, .3, .4];\n    for (var i = 0; i < vars.length; i++) {\n        // valueKey[i] = vars[i].attributes.name.nodeValue;\n        // lablArray[i] = varsXML[i].getElementsByTagName("labl").length == 0 ?\n        // "no label" :\n        // varsXML[i].getElementsByTagName("labl")[0].childNodes[0].nodeValue;\n        // let datasetcount = d3.layout.histogram()\n        //     .bins(barnumber).frequency(false)\n        //     ([0, 0, 0, 0, 0]);\n        valueKey[i] = vars[i];\n        lablArray[i] = "no label";\n        // contains all the preprocessed data we have for the variable, as well as UI data pertinent to that variable,\n        // such as setx values (if the user has selected them) and pebble coordinates\n        var obj = {\n            id: i,\n            reflexive: false,\n            name: valueKey[i],\n            labl: lablArray[i],\n            data: [5, 15, 20, 0, 5, 15, 20],\n            count: hold,\n            nodeCol: colors(i),\n            baseCol: colors(i),\n            strokeColor: _plots.selVarColor,\n            strokeWidth: "1",\n            subsetplot: false,\n            subsetrange: ["", ""],\n            setxplot: false,\n            setxvals: ["", ""],\n            grayout: false,\n            group1: false,\n            group2: false,\n            forefront: false\n        };\n        jQuery.extend(true, obj, preprocess[valueKey[i]]);\n        allNodes.push(obj);\n    }\n\n    // 10. Add dataschema information to allNodes (when in IS_D3M_DOMAIN)\n    var datavars = dataschema.dataResources[0].columns;\n    datavars.forEach(function (v, i) {\n        var myi = findNodeIndex(v.colName);\n        allNodes[myi] = Object.assign(allNodes[myi], { d3mDescription: v });\n    });\n    console.log(allNodes);\n\n    // 11. Call layout() and start up\n    IS_D3M_DOMAIN && toggleRightButtons("tasks");\n    layout(false, true);\n    IS_D3M_DOMAIN ? zPop() : dataDownload();\n}\n\n/**\n   called on app start\n   @param {string} fileid\n   @param {string} hostname\n   @param {string} ddiurl\n   @param {string} dataurl\n   @param {string} apikey\n*/\nfunction main(fileid, hostname, ddiurl, dataurl, apikey) {\n    if (PRODUCTION && fileid === \'\') {\n        var msg = \'Error: No fileid has been provided.\';\n        alert(msg);\n        throw new Error(msg);\n    }\n\n    var dataverseurl = hostname ? \'https://\' + hostname : PRODUCTION ? DATAVERSE_URL : \'http://localhost:8080\';\n    // if file id supplied, assume we are dealing with dataverse and cook a standard dataverse data access url\n    // with the fileid supplied and the hostname we have supplied or configured\n    dataurl = fileid && !dataurl ? dataverseurl + \'/api/access/datafile/\' + fileid + \'?key=\' + apikey : dataurl;\n    cdb(\'--dataurl: \' + dataurl);\n    cdb(\'--dataverseurl: \' + dataverseurl);\n\n    var tempWidth = d3.select(\'#main.left\').style(\'width\');\n    width = tempWidth.substring(0, tempWidth.length - 2);\n    height = $(window).height() - 120; // hard code header, footer, and bottom margin\n\n    exports.estimateLadda = estimateLadda = Ladda.create(byId("btnEstimate"));\n    selectLadda = Ladda.create(byId("btnSelect"));\n    svg = d3.select("#whitespace");\n\n    // indicators for showing membership above arcs\n    // let indicator = (degree) => d3.svg.circle()\n    //     .cx( RADIUS )//(RADIUS+35) * Math.sin(degree))\n    //     .cy( RADIUS )//(RADIUS+35) * Math.cos(degree))\n    //     .r(3);\n    // ind1 = indicator(1);\n    // ind2 = indicator(1.2);\n\n    // from .csv\n    var hold = [],\n        lablArray = [];\n\n    // assume locations are consistent based on d3m directory structure\n\n    var d3mRootPath = \'\';\n    var d3mDataName = \'\';\n    var d3mData = null;\n    var d3mPreprocess = \'\';\n    var d3mPS = \'\';\n    var d3mDS = \'\';\n\n    // default to Fearon Laitin\n    var data = \'data/\' + (false ? \'PUMS5small\' : \'fearonLaitin\');\n    var metadataurl = ddiurl || (fileid ? dataverseurl + \'/api/meta/datafile/\' + fileid : data + \'.xml\');\n    // read pre-processed metadata and data\n    var pURL = dataurl ? dataurl + \'&format=prep\' : data + \'.json\';\n\n    if (IS_D3M_DOMAIN) {\n        pURL = d3mPreprocess;\n    } else if (!PRODUCTION) {\n        zparams.zdataurl = \'data/fearonLaitin.tsv\';\n    }\n\n    load(hold, lablArray, d3mRootPath, d3mDataName, d3mPreprocess, d3mData, d3mPS, d3mDS, pURL);\n}\n\nvar $fill = function $fill(obj, op, d1, d2) {\n    return d3.select(obj).transition().attr(\'fill-opacity\', op).delay(d1).duration(d2);\n};\nvar fill = function fill(d, id, op, d1, d2) {\n    return $fill(\'#\' + id + d.id, op, d1, d2);\n};\nvar fillThis = function fillThis(self, op, d1, d2) {\n    return $fill(self, op, d1, d2);\n};\n\n/**\n   deletes the item at index from array.\n   if object is provided, deletes first instance of object from array.\n   @param {Object[]} arr - array\n   @param {number} idx - index\n   @param {Object} [obj] - object\n*/\nfunction del(arr, idx, obj) {\n    idx = obj ? arr.indexOf(obj) : idx;\n    idx > -1 && arr.splice(idx, 1);\n}\n\n/** needs doc */\nfunction zparamsReset(text) {\n    \'zdv zcross ztime znom\'.split(\' \').forEach(function (x) {\n        return del(zparams[x], -1, text);\n    });\n}\n\n/** needs doc */\nfunction layout(v, v2) {\n    var myValues = [];\n    exports.nodes = nodes = [];\n    exports.links = links = [];\n\n    svg.append("svg:defs").append("svg:marker").attr("id", "group1-arrow").attr(\'viewBox\', \'0 -5 15 15\').attr("refX", 2.5).attr("refY", 0).attr("markerWidth", 3).attr("markerHeight", 3).attr("orient", "auto").append("path").attr(\'d\', \'M0,-5L10,0L0,5\').style("fill", gr1Color);\n\n    svg.append("svg:defs").append("svg:marker").attr("id", "group2-arrow").attr(\'viewBox\', \'0 -5 15 15\').attr("refX", 2.5).attr("refY", 0).attr("markerWidth", 3).attr("markerHeight", 3).attr("orient", "auto").append("path").attr(\'d\', \'M0,-5L10,0L0,5\').style("fill", gr2Color);\n\n    var line = svg.append("line").style(\'fill\', \'none\').style(\'stroke\', gr1Color).style(\'stroke-width\', 5).attr("marker-end", "url(#group1-arrow)");\n\n    var line2 = svg.append("line").style(\'fill\', \'none\').style(\'stroke\', gr2Color).style(\'stroke-width\', 5).attr("marker-end", "url(#group2-arrow)");;\n\n    var visbackground = d3.select("#whitespace").append("svg").attr("width", width).attr("height", height);\n\n    visbackground.append("path") // note lines, are behind group hulls of which there is a white and colored semi transparent layer\n    .attr("id", \'gr1background\').style("fill", \'#ffffff\').style("stroke", \'#ffffff\').style("stroke-width", 2.5 * RADIUS).style(\'stroke-linejoin\', \'round\').style("opacity", 1);\n\n    var vis2background = d3.select("#whitespace").append("svg").attr("width", width).attr("height", height);\n\n    vis2background.append("path").attr("id", \'gr1background\').style("fill", \'#ffffff\').style("stroke", \'#ffffff\').style("stroke-width", 2.5 * RADIUS).style(\'stroke-linejoin\', \'round\').style("opacity", 1);\n\n    var vis = d3.select("#whitespace").append("svg").attr("width", width).attr("height", height);\n\n    vis.append("path").attr("id", \'gr1hull\').style("fill", gr1Color).style("stroke", gr1Color).style("stroke-width", 2.5 * RADIUS).style(\'stroke-linejoin\', \'round\');\n\n    var vis2 = d3.select("#whitespace").append("svg").attr("width", width).attr("height", height);\n\n    vis2.append("path").style("fill", gr2Color).style("stroke", gr2Color).style("stroke-width", 2.5 * RADIUS).style(\'stroke-linejoin\', \'round\');\n\n    if (v == layoutAdd || v == layoutMove) {\n        for (var j = 0; j < zparams.zvars.length; j++) {\n            var ii = findNodeIndex(zparams.zvars[j]);\n            if (allNodes[ii].grayout) continue;\n            nodes.push(allNodes[ii]);\n            var selectMe = zparams.zvars[j].replace(/\\W/g, "_");\n            selectMe = "#".concat(selectMe);\n            d3.select(selectMe).style(\'background-color\', function () {\n                return hexToRgba(nodes[j].strokeColor);\n            });\n        }\n\n        for (var j = 0; j < zparams.zedges.length; j++) {\n            var mysrc = nodeIndex(zparams.zedges[j][0]);\n            var mytgt = nodeIndex(zparams.zedges[j][1]);\n            links.push({\n                source: nodes[mysrc],\n                target: nodes[mytgt],\n                left: false,\n                right: true\n            });\n        }\n    } else {\n        if (IS_D3M_DOMAIN) {\n            //nodes = [findNode(mytarget)];               // Only add dependent variable on startup\n            exports.nodes = nodes = allNodes.slice(1, allNodes.length); // Add all but first variable on startup (assumes 0 position is d3m index variable)\n            for (var _j = 0; _j < nodes.length; _j++) {\n                //populate zvars array\n                if (nodes[_j].name != mytarget) {\n                    nodes[_j].group1 = true;\n                    zparams.zgroup1.push(nodes[_j].name); // write all names (except d3m index and the dependent variable) to zgroup1 array\n                };\n            };\n        } else if (allNodes.length > 2) {\n            exports.nodes = nodes = [allNodes[0], allNodes[1], allNodes[2]];\n            exports.links = links = [{\n                source: nodes[1],\n                target: nodes[0],\n                left: false,\n                right: true\n            }, {\n                source: nodes[0],\n                target: nodes[2],\n                left: false,\n                right: true\n            }];\n        } else if (allNodes.length === 2) {\n            exports.nodes = nodes = [allNodes[0], allNodes[1]];\n            exports.links = links = [{\n                source: nodes[1],\n                target: nodes[0],\n                left: false,\n                right: true\n            }];\n        } else if (allNodes.length === 1) {\n            exports.nodes = nodes = [allNodes[0]];\n        } else {\n            alert("There are zero variables in the metadata.");\n            return;\n        }\n    }\n\n    panelPlots(); // after nodes is populated, add subset and (if !IS_D3M_DOMAIN) setx panels\n\n    var force = d3.layout.force().nodes(nodes).links(links).size([width, height]).linkDistance(150).charge(-800).on(\'tick\', tick);\n\n    // define arrow markers for graph links\n    svg.append(\'svg:defs\').append(\'svg:marker\').attr(\'id\', \'end-arrow\').attr(\'viewBox\', \'0 -5 10 10\').attr(\'refX\', 6).attr(\'markerWidth\', 3).attr(\'markerHeight\', 3).attr(\'orient\', \'auto\').append(\'svg:path\').attr(\'d\', \'M0,-5L10,0L0,5\').style(\'fill\', \'#000\');\n\n    svg.append(\'svg:defs\').append(\'svg:marker\').attr(\'id\', \'start-arrow\').attr(\'viewBox\', \'0 -5 10 10\').attr(\'refX\', 4).attr(\'markerWidth\', 3).attr(\'markerHeight\', 3).attr(\'orient\', \'auto\').append(\'svg:path\').attr(\'d\', \'M10,-5L0,0L10,5\').style(\'fill\', \'#000\');\n\n    // line displayed when dragging new nodes\n    var drag_line = svg.append(\'svg:path\').attr(\'class\', \'link dragline hidden\').attr(\'d\', \'M0,0L0,0\');\n\n    // handles to link and node element groups\n    var path = svg.append(\'svg:g\').selectAll(\'path\'),\n        circle = svg.append(\'svg:g\').selectAll(\'g\');\n    //line = svg.append(\'svg:g\').selectAll(\'line\');\n\n    // mouse event vars\n    var selected_node = null,\n        selected_link = null,\n        mousedown_link = null,\n        mousedown_node = null,\n        mouseup_node = null;\n\n    function resetMouseVars() {\n        mousedown_node = null;\n        mouseup_node = null;\n        mousedown_link = null;\n    }\n\n    // update force layout (called automatically each iteration)\n    function tick() {\n        function findcoords(findnames, allnames, coords, lengthen) {\n            var fcoords = new Array(findnames.length); // found coordinates\n            var addlocation = 0;\n            if (findnames.length > 0) {\n                for (var j = 0; j < findnames.length; j++) {\n                    addlocation = allnames.indexOf(findnames[j]);\n                    fcoords[j] = coords[addlocation];\n                };\n            };\n\n            if (lengthen) {\n                // d3.geom.hull returns null for two points, and fails if three points are in a line,\n                // so this puts a couple points slightly off the line for two points, or around a singleton.\n                if (fcoords.length == 2) {\n                    var deltax = fcoords[0][0] - fcoords[1][0];\n                    var deltay = fcoords[0][1] - fcoords[1][1];\n                    fcoords.push([(fcoords[0][0] + fcoords[1][0]) / 2 + deltay / 20, (fcoords[0][1] + fcoords[1][1]) / 2 + deltax / 20]);\n                    fcoords.push([(fcoords[0][0] + fcoords[1][0]) / 2 - deltay / 20, (fcoords[0][1] + fcoords[1][1]) / 2 - deltax / 20]);\n                }\n                if (fcoords.length == 1) {\n                    var delta = RADIUS * 0.2;\n                    fcoords.push([fcoords[0][0] + delta, fcoords[0][1]]);\n                    fcoords.push([fcoords[0][0] - delta, fcoords[0][1]]);\n                    fcoords.push([fcoords[0][0], fcoords[0][1] + delta]);\n                    fcoords.push([fcoords[0][0], fcoords[0][1] - delta]);\n                }\n            }\n            return fcoords;\n        };\n\n        // d3.geom.hull returns null for two points, and fails if three points are in a line,\n        // so this puts a couple points slightly off the line for two points, or around a singleton.\n        function lengthencoords(coords) {\n            if (coords.length == 2) {\n                var deltax = coords[0][0] - coords[1][0];\n                var deltay = coords[0][1] - coords[1][1];\n                coords.push([(coords[0][0] + coords[1][0]) / 2 + deltay / 20, (coords[0][1] + coords[1][1]) / 2 + deltax / 20]);\n                coords.push([(coords[0][0] + coords[1][0]) / 2 - deltay / 20, (coords[0][1] + coords[1][1]) / 2 - deltax / 20]);\n            }\n            if (coords.length == 1) {\n                var delta = RADIUS * 0.2;\n                coords.push([coords[0][0] + delta, coords[0][1]]);\n                coords.push([coords[0][0] - delta, coords[0][1]]);\n                coords.push([coords[0][0], coords[0][1] + delta]);\n                coords.push([coords[0][0], coords[0][1] - delta]);\n            }\n            return coords;\n        };\n\n        var coords = nodes.map(function (d) {\n            return [d.x, d.y];\n        });\n        var gr1coords = findcoords(zparams.zgroup1, zparams.zvars, coords, true);\n        var gr2coords = findcoords(zparams.zgroup2, zparams.zvars, coords, true);\n        var depcoords = findcoords(zparams.zdv, zparams.zvars, coords, false);\n\n        // draw convex hull around independent variables, if three or more coordinates given\n        // note, d3.geom.hull returns null if shorter coordinate set than 3,\n        // so findcoords() function has option to lengthen the coordinates returned to bypass this\n        if (gr1coords.length > 2) {\n            line.style("opacity", 1);\n            visbackground.style("opacity", 1);\n            vis.style("opacity", 0.3);\n            var myhull = d3.geom.hull(gr1coords);\n\n            vis.selectAll("path").data([myhull]) // returns null if less than three coordinates\n            .attr("d", function (d) {\n                return "M" + d.join("L") + "Z";\n            });\n            visbackground.selectAll("path").data([myhull]) // returns null if less than three coordinates\n            .attr("d", function (d) {\n                return "M" + d.join("L") + "Z";\n            });\n\n            //var p = d3.geom.polygon(indcoords).centroid();  // Seems to go strange sometimes\n            var p = jamescentroid(gr1coords);\n\n            if (depcoords.length > 0) {\n                var q = depcoords[0]; // Note, only using first dep var currently\n                //var r = findboundary(p,q,gr1coords);        // An approach to find the exact boundary, not presently working\n                var ldeltaX = q[0] - p[0],\n                    ldeltaY = q[1] - p[1],\n                    ldist = Math.sqrt(ldeltaX * ldeltaX + ldeltaY * ldeltaY),\n                    lnormX = 0,\n                    lnormY = 0,\n                    lsourcePadding = RADIUS + 7,\n                    ltargetPadding = RADIUS + 10;\n\n                if (ldist > 0) {\n                    lnormX = ldeltaX / ldist;\n                    lnormY = ldeltaY / ldist;\n                };\n\n                line.attr("x1", p[0] + lsourcePadding * lnormX) // or r[0] if findboundary works\n                .attr("y1", p[1] + lsourcePadding * lnormY) // or r[1] if findboundary works\n                .attr("x2", q[0] - ltargetPadding * lnormX).attr("y2", q[1] - ltargetPadding * lnormY);\n            };\n\n            // group members attract each other, repulse non-group members\n            nodes.forEach(function (n) {\n                var sign = n.group1 ? 1 : -1; //was: Math.sign( zparams.zgroup1.indexOf(n.name) +0.5 );  // 1 if n in group, -1 if n not in group;\n                var ldeltaX = p[0] - n.x,\n                    ldeltaY = p[1] - n.y,\n                    ldist = Math.sqrt(ldeltaX * ldeltaX + ldeltaY * ldeltaY);\n                lnormX = 0, lnormY = 0;\n\n                if (ldist > 0) {\n                    lnormX = ldeltaX / ldist;\n                    lnormY = ldeltaY / ldist;\n                };\n\n                n.x += Math.min(lnormX, ldeltaX / 100) * k * sign * force.alpha();\n                n.y += Math.min(lnormY, ldeltaY / 100) * k * sign * force.alpha();\n            });\n        } else {\n            visbackground.style("opacity", 0);\n\n            vis.style("opacity", 0);\n            //            vis.style("opacity", 0);\n            line.style("opacity", 0);\n        };\n\n        if (gr2coords.length > 2) {\n            line2.style("opacity", 1);\n            vis2background.style("opacity", 1);\n            vis2.style("opacity", 0.3);\n            var myhull = d3.geom.hull(gr2coords);\n            vis2.selectAll("path").data([myhull]) // returns null if less than three coordinates\n            .attr("d", function (d) {\n                return "M" + d.join("L") + "Z";\n            });\n            vis2background.selectAll("path").data([myhull]) // returns null if less than three coordinates\n            .attr("d", function (d) {\n                return "M" + d.join("L") + "Z";\n            });\n\n            //var p = d3.geom.polygon(indcoords).centroid();  // Seems to go strange sometimes\n            var p = jamescentroid(gr2coords);\n\n            if (depcoords.length > 0) {\n                var q = depcoords[0]; // Note, only using first dep var currently\n                var ldeltaX = q[0] - p[0],\n                    ldeltaY = q[1] - p[1],\n                    ldist = Math.sqrt(ldeltaX * ldeltaX + ldeltaY * ldeltaY),\n                    lnormX = ldeltaX / ldist,\n                    lnormY = ldeltaY / ldist,\n                    lsourcePadding = RADIUS + 7,\n                    ltargetPadding = RADIUS + 10;\n\n                line2.attr("x1", p[0] + lsourcePadding * lnormX).attr("y1", p[1] + lsourcePadding * lnormY).attr("x2", q[0] - ltargetPadding * lnormX).attr("y2", q[1] - ltargetPadding * lnormY);\n            };\n\n            // group members attract each other, repulse non-group members\n            nodes.forEach(function (n) {\n                var sign = n.group2 ? 1 : -1; // was: Math.sign( zparams.zgroup2.indexOf(n.name) +0.5 );  // 1 if n in group, -1 if n not in group;\n                var ldeltaX = p[0] - n.x,\n                    ldeltaY = p[1] - n.y,\n                    ldist = Math.sqrt(ldeltaX * ldeltaX + ldeltaY * ldeltaY),\n                    lnormX = 0,\n                    lnormY = 0;\n\n                if (ldist > 0) {\n                    lnormX = ldeltaX / ldist;\n                    lnormY = ldeltaY / ldist;\n                };\n\n                n.x += Math.min(lnormX, ldeltaX / 100) * k * sign * force.alpha();\n                n.y += Math.min(lnormY, ldeltaY / 100) * k * sign * force.alpha();\n            });\n        } else {\n            vis2background.style("opacity", 0);\n            vis2.style("opacity", 0);\n            line2.style("opacity", 0);\n        };\n\n        // draw directed edges with proper padding from node centers\n        path.attr(\'d\', function (d) {\n            var deltaX = d.target.x - d.source.x,\n                deltaY = d.target.y - d.source.y,\n                dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY),\n                normX = deltaX / dist,\n                normY = deltaY / dist,\n                sourcePadding = d.left ? RADIUS + 5 : RADIUS,\n                targetPadding = d.right ? RADIUS + 5 : RADIUS,\n                sourceX = d.source.x + sourcePadding * normX,\n                sourceY = d.source.y + sourcePadding * normY,\n                targetX = d.target.x - targetPadding * normX,\n                targetY = d.target.y - targetPadding * normY;\n            return \'M\' + sourceX + \',\' + sourceY + \'L\' + targetX + \',\' + targetY;\n        });\n\n        circle.attr(\'transform\', function (d) {\n            return \'translate(\' + d.x + \',\' + d.y + \')\';\n        });\n\n        circle.selectAll(\'circle\') // Shrink/expand pebbles that join/leave groups\n        .transition().duration(100).attr(\'r\', function (d) {\n            return setPebbleRadius(d);\n        });\n    }\n\n    d3.select("#models").selectAll("p") // models tab\n    //  d3.select("#Display_content")\n    .on("click", function () {\n        var myColor = d3.select(this).style(\'background-color\');\n        d3.select("#models").selectAll("p").style(\'background-color\', varColor);\n        d3.select(this).style(\'background-color\', function (d) {\n            if (d3.rgb(myColor).toString() === varColor.toString()) {\n                zparams.zmodel = d.toString();\n                return hexToRgba(_plots.selVarColor);\n            } else {\n                zparams.zmodel = \'\';\n                return varColor;\n            }\n        });\n        _restart();\n    });\n\n    d3.select("#types").selectAll("p") // models tab\n    //  d3.select("#Display_content")\n    .on("click", function () {\n        if (locktoggle) return;\n        if (this.className == "item-select") {\n            return;\n        } else {\n            d3.select("#types").select("p.item-select").attr(\'class\', \'item-default\');\n            d3mProblemDescription.taskType = this.innerHTML.toString();\n            d3.select(this).attr(\'class\', "item-select");\n        }\n        _restart();\n        updateSchema("taskType", d3mProblemDescription, d3mTaskType);\n    });\n\n    d3.select("#subtypes").selectAll("p").on("click", function () {\n        if (locktoggle) return;\n        if (this.className == "item-select") {\n            return;\n        } else {\n            d3.select("#subtypes").select("p.item-select").attr(\'class\', \'item-default\');\n            d3mProblemDescription.taskSubtype = this.innerHTML.toString();\n            d3.select(this).attr(\'class\', "item-select");\n        }\n        _restart();\n        updateSchema("taskSubtype", d3mProblemDescription, d3mTaskSubtype);\n    });\n\n    d3.select("#metrics").selectAll("p").on("click", function () {\n        if (locktoggle) return;\n        if (this.className == "item-select") {\n            return;\n            // d3mProblemDescription.metric = ["",""];\n            // this.className="item-default";\n        } else {\n            d3.select("#metrics").select("p.item-select").attr(\'class\', \'item-default\');\n            d3mProblemDescription.metric = this.innerHTML.toString();\n            d3.select(this).attr(\'class\', "item-select");\n        }\n        _restart();\n        updateSchema("metric", d3mProblemDescription, d3mMetrics);\n    });\n\n    /*  d3.select("#outputs").selectAll("p")\n      .on("click", function() {\n          if(locktoggle) return;\n          if(this.className=="item-select") {\n              return;\n          } else {\n              d3.select("#outputs").select("p.item-select")\n              .attr(\'class\', \'item-default\');\n              d3mProblemDescription.outputType = this.innerHTML.toString();\n              d3.select(this).attr(\'class\',"item-select");\n          }\n          restart();\n          updateSchema("outputType", d3mProblemDescription, d3mOutputType);\n          });\n          */\n\n    // update graph (called when needed)\n    exports.restart = _restart = function restart($links) {\n        exports.links = links = $links || links;\n        // nodes.id is pegged to allNodes, i.e. the order in which variables are read in\n        // nodes.index is floating and depends on updates to nodes.  a variables index changes when new variables are added.\n        circle.call(force.drag);\n        if (forcetoggle[0] == "true") {\n            force.gravity(0.1);\n            force.charge(function (d) {\n                return setPebbleCharge(d);\n            });\n            force.start();\n            force.linkStrength(1);\n            k = 4; // strength parameter for group attraction/repulsion\n            if (zparams.zgroup1.length > 0 & zparams.zgroup2.length > 0) {\n                // scale down by number of active groups\n                k = 2.5;\n            }\n        } else {\n            force.gravity(0);\n            force.charge(0);\n            force.linkStrength(0);\n            k = 0;\n        }\n        force.resume();\n\n        // path (link) group\n        path = path.data(links);\n\n        // update existing links\n        // VJD: dashed links between pebbles are "selected". this is disabled for now\n        path.classed(\'selected\', function (x) {\n            return null;\n        }).style(\'marker-start\', function (x) {\n            return x.left ? \'url(#start-arrow)\' : \'\';\n        }).style(\'marker-end\', function (x) {\n            return x.right ? \'url(#end-arrow)\' : \'\';\n        });\n\n        // add new links\n        path.enter().append(\'svg:path\').attr(\'class\', \'link\').classed(\'selected\', function (x) {\n            return null;\n        }).style(\'marker-start\', function (x) {\n            return x.left ? \'url(#start-arrow)\' : \'\';\n        }).style(\'marker-end\', function (x) {\n            return x.right ? \'url(#end-arrow)\' : \'\';\n        }).on(\'mousedown\', function (d) {\n            // do we ever need to select a link? make it delete..\n            var obj = JSON.stringify(d);\n            for (var j = 0; j < links.length; j++) {\n                if (obj === JSON.stringify(links[j])) del(links, j);\n            }\n        });\n\n        // remove old links\n        path.exit().remove();\n\n        // circle (node) group\n        circle = circle.data(nodes, function (x) {\n            return x.id;\n        });\n\n        // update existing nodes (reflexive & selected visual states)\n        // d3.rgb is the function adjusting the color here\n        circle.selectAll(\'circle\').classed(\'reflexive\', function (x) {\n            return x.reflexive;\n        }).style(\'fill\', function (x) {\n            return d3.rgb(x.nodeCol);\n        }).style(\'stroke\', function (x) {\n            return d3.rgb(x.strokeColor);\n        }).style(\'stroke-width\', function (x) {\n            return x.strokeWidth;\n        });\n\n        // add new nodes\n        var g = circle.enter().append(\'svg:g\').attr(\'id\', function (x) {\n            return x.name + \'biggroup\';\n        });\n\n        // add plot\n        g.each(function (d) {\n            d3.select(this);\n            if (d.plottype == \'continuous\') (0, _plots.densityNode)(d, this);else if (d.plottype == \'bar\') (0, _plots.barsNode)(d, this);\n        });\n\n        var append = function append(str, attr) {\n            return function (x) {\n                return str + x[attr || \'id\'];\n            };\n        };\n\n        g.append("path").attr("id", append(\'dvArc\')).attr("d", arc3).style("fill", dvColor).attr("fill-opacity", 0).on(\'mouseover\', function (d) {\n            fillThis(this, .3, 0, 100);\n            fill(d, \'dvText\', .9, 0, 100);\n        }).on(\'mouseout\', function (d) {\n            fillThis(this, 0, 100, 500);\n            fill(d, \'dvText\', 0, 100, 500);\n        }).on(\'click\', function (d) {\n            setColors(d, dvColor);\n            legend(dvColor);\n            _restart();\n            d.group1 = d.group2 = false;\n        });\n\n        g.append("text").attr("id", append(\'dvText\')).attr("x", 6).attr("dy", 11.5).attr("fill-opacity", 0).append("textPath").attr("xlink:href", append(\'#dvArc\')).text("Dep Var");\n\n        g.append("path").attr("id", append(\'nomArc\')).attr("d", arc4).style("fill", nomColor).attr("fill-opacity", 0).on(\'mouseover\', function (d) {\n            if (d.defaultNumchar == "character") return;\n            fillThis(this, .3, 0, 100);\n            fill(d, "nomText", .9, 0, 100);\n        }).on(\'mouseout\', function (d) {\n            if (d.defaultNumchar == "character") return;\n            fillThis(this, 0, 100, 500);\n            fill(d, "nomText", 0, 100, 500);\n        }).on(\'click\', function (d) {\n            if (d.defaultNumchar == "character") return;\n            setColors(d, nomColor);\n            legend(nomColor);\n            _restart();\n        });\n\n        g.append("text").attr("id", append("nomText")).attr("x", 6).attr("dy", 11.5).attr("fill-opacity", 0).append("textPath").attr("xlink:href", append("#nomArc")).text("Nominal");\n\n        g.append("path").attr("id", append(\'grArc\')).attr("d", arc1).style("fill", gr1Color).attr("fill-opacity", 0).on(\'mouseover\', function (d) {\n            fill(d, "gr1indicator", .3, 0, 100);\n            fill(d, "gr2indicator", .3, 0, 100);\n            fillThis(this, .3, 0, 100);\n            fill(d, \'grText\', .9, 0, 100);\n        }).on(\'mouseout\', function (d) {\n            fill(d, "gr1indicator", 0, 100, 500);\n            fill(d, "gr2indicator", 0, 100, 500);\n            fillThis(this, 0, 100, 500);\n            fill(d, \'grText\', 0, 100, 500);\n        }).on(\'click\', function (d) {\n            //d.group1 = !d.group1;      // This might be easier, but currently set in setColors()\n            setColors(d, gr1Color);\n            legend(gr1Color);\n            _restart();\n        });\n\n        g.append("path").attr("id", append(\'gr1indicator\')).attr("d", arcInd1).style("fill", gr1Color) // something like: zparams.zgroup1.indexOf(node.name) > -1  ?  #FFFFFF : gr1Color)\n        .attr("fill-opacity", 0).on(\'mouseover\', function (d) {\n            fillThis(this, .3, 0, 100);\n            fill(d, "grArc", .1, 0, 100);\n            fill(d, \'grText\', .9, 0, 100);\n        }).on(\'mouseout\', function (d) {\n            fillThis(this, 0, 100, 500);\n            fill(d, "grArc", 0, 100, 500);\n            fill(d, \'grText\', 0, 100, 500);\n        }).on(\'click\', function (d) {\n            //d.group1 = !d.group1;      // This might be easier, but currently set in setColors()\n            setColors(d, gr1Color);\n            legend(gr1Color);\n            _restart();\n        });\n\n        g.append("path").attr("id", append(\'gr2indicator\')).attr("d", arcInd2).style("fill", gr2Color) // something like: zparams.zgroup1.indexOf(node.name) > -1  ?  #FFFFFF : gr1Color)\n        .attr("fill-opacity", 0).on(\'mouseover\', function (d) {\n            fillThis(this, .3, 0, 100);\n            fill(d, "grArc", .1, 0, 100);\n            fill(d, \'grText\', .9, 0, 100);\n        }).on(\'mouseout\', function (d) {\n            fillThis(this, 0, 100, 500);\n            fill(d, "grArc", 0, 100, 500);\n            fill(d, \'grText\', 0, 100, 500);\n        }).on(\'click\', function (d) {\n            //d.group2 = !d.group2;      // This might be easier, but currently set in setColors()\n            setColors(d, gr2Color);\n            legend(gr2Color);\n            _restart();\n        });\n\n        g.append("text").attr("id", append(\'grText\')).attr("x", 6).attr("dy", 11.5).attr("fill-opacity", 0).append("textPath").attr("xlink:href", append(\'#grArc\')).text("Groups");\n\n        g.append(\'svg:circle\').attr(\'class\', \'node\').attr(\'r\', function (d) {\n            return setPebbleRadius(d);\n        }).style(\'pointer-events\', \'inherit\').style(\'fill\', function (d) {\n            return d.nodeCol;\n        }).style(\'opacity\', "0.5").style(\'stroke\', function (d) {\n            return d3.rgb(d.strokeColor).toString();\n        }).classed(\'reflexive\', function (d) {\n            return d.reflexive;\n        }).on(\'dblclick\', function (_) {\n            d3.event.stopPropagation(); // stop click from bubbling\n            exports.summaryHold = summaryHold = true;\n        }).on(\'contextmenu\', function (d) {\n            // right click on node\n            d3.event.preventDefault();\n            d3.event.stopPropagation();\n\n            rightClickLast = true;\n            mousedown_node = d;\n            selected_node = mousedown_node === selected_node ? null : mousedown_node;\n            selected_link = null;\n\n            // reposition drag line\n            drag_line.style(\'marker-end\', \'url(#end-arrow)\').classed(\'hidden\', false).attr(\'d\', \'M\' + mousedown_node.x + \',\' + mousedown_node.y + \'L\' + mousedown_node.x + \',\' + mousedown_node.y);\n\n            svg.on(\'mousemove\', mousemove);\n            _restart();\n        }).on(\'mouseup\', function (d) {\n            d3.event.stopPropagation();\n\n            if (rightClickLast) {\n                rightClickLast = false;\n                return;\n            }\n            if (!mousedown_node) return;\n\n            // needed by FF\n            drag_line.classed(\'hidden\', true).style(\'marker-end\', \'\');\n\n            // check for drag-to-self\n            mouseup_node = d;\n            if (mouseup_node === mousedown_node) {\n                resetMouseVars();\n                return;\n            }\n\n            // unenlarge target node\n            d3.select(this).attr(\'transform\', \'\');\n\n            // add link to graph (update if exists)\n            // NB: links are strictly source < target; arrows separately specified by booleans\n            var source, target, direction;\n            if (mousedown_node.id < mouseup_node.id) {\n                source = mousedown_node;\n                target = mouseup_node;\n                direction = \'right\';\n            } else {\n                source = mouseup_node;\n                target = mousedown_node;\n                direction = \'left\';\n            }\n\n            var link = links.filter(function (x) {\n                return x.source == source && x.target == target;\n            })[0];\n            if (link) {\n                link[direction] = true;\n            } else {\n                link = {\n                    source: source,\n                    target: target,\n                    left: false,\n                    right: false\n                };\n                link[direction] = true;\n                links.push(link);\n            }\n\n            // select new link\n            selected_link = link;\n            selected_node = null;\n            svg.on(\'mousemove\', null);\n\n            resetMouseVars();\n            _restart();\n        });\n\n        // show node names\n        g.append(\'svg:text\').attr(\'x\', 0).attr(\'y\', 15).attr(\'class\', \'id\').text(function (d) {\n            return d.name;\n        });\n\n        // show summary stats on mouseover\n        // SVG doesn\'t support text wrapping, use html instead\n        g.selectAll("circle.node").on("mouseover", function (d) {\n            tabLeft(\'tab3\');\n            varSummary(d);\n            d.forefront = true;\n\n            byId(\'transformations\').setAttribute(\'style\', \'display:block\');\n            byId("transSel").selectedIndex = d.id;\n            transformVar = valueKey[d.id];\n\n            fill(d, "dvArc", .1, 0, 100);\n            fill(d, "dvText", .5, 0, 100);\n            fill(d, "grArc", .1, 0, 100);\n            fill(d, "grText", .5, 0, 100);\n            //fill(d, "gr1indicator", .1, 0, 100);\n            //fill(d, "gr1indicatorText", .1, 0, 100);\n            //fill(d, "gr2indicator", .1, 0, 100);\n            //fill(d, "gr2indicatorText", .1, 0, 100);\n\n            if (d.defaultNumchar == "numeric") {\n                fill(d, "nomArc", .1, 0, 100);\n                fill(d, "nomText", .5, 0, 100);\n            }\n            fill(d, "csArc", .1, 0, 100);\n            fill(d, "csText", .5, 0, 100);\n            fill(d, "timeArc", .1, 0, 100);\n            fill(d, "timeText", .5, 0, 100);\n\n            _mithril2.default.redraw();\n        }).on(\'mouseout\', function (d) {\n            d.forefront = false;\n            summaryHold || tabLeft(subset ? \'tab2\' : \'tab1\');\n            \'csArc csText timeArc timeText dvArc dvText nomArc nomText grArc grText\'.split(\' \').map(function (x) {\n                return fill(d, x, 0, 100, 500);\n            });\n            _mithril2.default.redraw();\n        });\n\n        // the transformation variable list is silently updated as pebbles are added/removed\n        d3.select("#transSel").selectAll(\'li\').remove();\n\n        d3.select("#transSel").selectAll(\'li\').data(nodes.map(function (x) {\n            return x.name;\n        })) // set to variables in model space as they\'re added\n        .enter().append("li").text(function (d) {\n            return d;\n        });\n\n        if (!IS_D3M_DOMAIN) {\n            $(\'#transSel li\').click(function (evt) {\n                // if \'interaction\' is the selected function, don\'t show the function list again\n                if (selInteract) {\n                    var n = $(\'#tInput\').val().concat($(this).text());\n                    $(\'#tInput\').val(n);\n                    evt.stopPropagation();\n                    var t = transParse(n = n);\n                    if (!t) return;\n                    $(this).parent().fadeOut(100);\n                    transform(n = t.slice(0, t.length - 1), t = t[t.length - 1], typeTransform = false);\n                    return;\n                }\n\n                $(\'#tInput\').val($(this).text());\n                $(this).parent().fadeOut(100);\n                $(\'#transList\').fadeIn(100);\n                evt.stopPropagation();\n            });\n        };\n\n        // remove old nodes\n        circle.exit().remove();\n        force.start();\n\n        // save workspaces\n        console.log(\'ok ws\');\n        record_user_metadata();\n    };\n\n    function mousedown(d) {\n        // prevent I-bar on drag\n        d3.event.preventDefault();\n        // because :active only works in WebKit?\n        svg.classed(\'active\', true);\n        if (d3.event.ctrlKey || mousedown_node || mousedown_link) return;\n        _restart();\n    }\n\n    function mousemove(d) {\n        if (!mousedown_node) return;\n        // update drag line\n        drag_line.attr(\'d\', \'M\' + mousedown_node.x + \',\' + mousedown_node.y + \'L\' + d3.mouse(this)[0] + \',\' + d3.mouse(this)[1]);\n    }\n\n    function mouseup(d) {\n        if (mousedown_node) {\n            drag_line.classed(\'hidden\', true).style(\'marker-end\', \'\');\n        }\n        // because :active only works in WebKit?\n        svg.classed(\'active\', false);\n        // clear mouse event vars\n        resetMouseVars();\n    }\n\n    // app starts here\n    svg.attr(\'id\', function () {\n        return "whitespace".concat(myspace);\n    }).attr(\'height\', height).on(\'mousedown\', function () {\n        mousedown(this);\n    }).on(\'mouseup\', function () {\n        mouseup(this);\n    });\n\n    d3.select(window).on(\'click\', function () {\n        // all clicks will bubble here unless event.stopPropagation()\n        $(\'#transList\').fadeOut(100);\n        $(\'#transSel\').fadeOut(100);\n    });\n\n    _restart(); // initializes force.layout()\n    fakeClick();\n\n    if (v2 & IS_D3M_DOMAIN) {\n        var click_ev = document.createEvent("MouseEvents");\n        // initialize the event\n        click_ev.initEvent("click", true /* bubble */, true /* cancelable */);\n        // trigger the event\n        var clickID = "dvArc" + findNodeIndex(mytarget);\n        byId(clickID).dispatchEvent(click_ev);\n    }\n}\n\n/** needs doc */\nfunction find($nodes, name) {\n    for (var i in $nodes) {\n        if ($nodes[i].name == name) return $nodes[i].id;\n    }\n}\n\n/**\n   returns id\n*/\nfunction findNodeIndex(name, whole) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n        for (var _iterator = allNodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var node = _step.value;\n\n            if (node.name === name) return whole ? node : node.id;\n        }\n    } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n            }\n        } finally {\n            if (_didIteratorError) {\n                throw _iteratorError;\n            }\n        }\n    }\n}\n\n/** needs doc */\nfunction nodeIndex(nodeName) {\n    for (var i in nodes) {\n        if (nodes[i].name === nodeName) return i;\n    }\n}\n\n/** needs doc */\nfunction findNode(name) {\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n        for (var _iterator2 = allNodes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var n = _step2.value;\n\n            if (n.name === name) return n;\n        }\n    } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                _iterator2.return();\n            }\n        } finally {\n            if (_didIteratorError2) {\n                throw _iteratorError2;\n            }\n        }\n    }\n}\n\n/** needs doc */\nfunction updateNode(id) {\n    var node = findNode(id);\n    if (node.grayout) return false;\n\n    var name = node.name;\n    var names = function names() {\n        return nodes.map(function (n) {\n            return n.name;\n        });\n    };\n    if (names().includes(name)) {\n        del(nodes, node.index);\n        links.filter(function (l) {\n            return l.source === node || l.target === node;\n        }).forEach(function (l) {\n            return del(links, -1, l);\n        });\n        zparamsReset(name);\n\n        // remove node name from group lists\n        node.group1 && del(zparams.zgroup1, -1, name);\n        node.group2 && del(zparams.zgroup2, -1, name);\n        node.group1 = node.group2 = false;\n\n        // node reset - perhaps this will become a hard reset back to all original allNode values?\n        node.nodeCol = node.baseCol;\n        node.strokeColor = _plots.selVarColor;\n        node.strokeWidth = \'1\';\n\n        borderState();\n    } else {\n        nodes.push(node);\n    }\n    zparams.zvars = names();\n    return true;\n}\n\n/**\n   every time a variable in leftpanel is clicked, nodes updates and background color changes\n*/\nfunction clickVar(elem) {\n    if (updateNode(elem.target.id)) {\n        // panelPlots(); is this necessary?\n        _restart();\n    }\n}\n\n/**\n  Retrieve the variable list from the preprocess data.\n  This helps handle the new format and (temporarily)\n  the older format in PRODUCTION (rp 8.14.2017)\n  "new" response:\n  {\n  "dataset" : {...}\n  "variables" : {\n  "var1" : {...},\n  (etc)\n  }\n  }\n  "old" response:\n  {\n  "var1" : {...},\n  (etc)\n  }\n*/\nfunction getVariableData(json) {\n    return json.hasOwnProperty(\'variables\') ? json.variables : json;\n}\n\n/**\n   called by force button\n*/\nfunction forceSwitch() {\n    forcetoggle = [forcetoggle[0] == \'true\' ? \'false\' : \'true\'];\n    if (forcetoggle[0] === "false") {\n        byId(\'btnForce\').setAttribute("class", "btn active");\n    } else {\n        byId(\'btnForce\').setAttribute("class", "btn btn-default");\n        fakeClick();\n    }\n}\n\n/** needs doc */\nfunction helpmaterials(type) {\n    if (type == "video") {\n        var win = window.open("http://2ra.vn/demos/d3mintegrationdemo.mp4", \'_blank\');\n        win.focus();\n    } else {\n        var win = window.open("http://2ra.vn/papers/tworavens-d3mguide.pdf", \'_blank\');\n        win.focus();\n    }\n    console.log(type);\n}\n\n/** needs doc */\nfunction lockDescription() {\n    exports.locktoggle = locktoggle = locktoggle ? false : true;\n    var temp = void 0;\n    var i = void 0;\n    if (!locktoggle) {\n        byId(\'btnLock\').setAttribute("class", "btn btn-default");\n        temp = byId(\'rightContentArea\').querySelectorAll("p.item-lineout");\n        for (i = 0; i < temp.length; i++) {\n            temp[i].classList.remove("item-lineout");\n        }\n    } else {\n        byId(\'btnLock\').setAttribute("class", "btn active");\n        temp = byId(\'metrics\').querySelectorAll("p.item-default");\n        console.log(temp);\n        for (i = 0; i < temp.length; i++) {\n            temp[i].classList.add("item-lineout");\n        }\n        temp = byId(\'types\').querySelectorAll("p.item-default");\n        for (i = 0; i < temp.length; i++) {\n            temp[i].classList.add("item-lineout");\n        }\n        temp = byId(\'subtypes\').querySelectorAll("p.item-default");\n        for (i = 0; i < temp.length; i++) {\n            temp[i].classList.add("item-lineout");\n        }\n        /*    temp = byId(\'outputs\').querySelectorAll("p.item-default");\n            for (i = 0; i < temp.length; i++) {\n                temp[i].classList.add("item-lineout");\n            }  */\n        fakeClick();\n    }\n}\n\n/** needs doc */\nfunction zPop() {\n    if (dataurl) zparams.zdataurl = dataurl;\n    zparams.zmodelcount = modelCount;\n    zparams.zedges = [];\n    zparams.zvars = [];\n    zparams.znature = [];\n    for (var j = 0; j < nodes.length; j++) {\n        //populate zvars array\n        zparams.zvars.push(nodes[j].name);\n        zparams.znature.push(nodes[j].nature);\n        var temp = nodes[j].id;\n        zparams.zsetx[j] = allNodes[temp].setxvals;\n        zparams.zsubset[j] = allNodes[temp].subsetrange;\n    }\n    for (var _j2 = 0; _j2 < links.length; _j2++) {\n        //populate zedges array\n        //correct the source target ordering for Zelig\n        var srctgt = links[_j2].left == false ? [links[_j2].source.name, links[_j2].target.name] : [links[_j2].target.name, links[_j2].source.name];\n        zparams.zedges.push(srctgt);\n    }\n}\n\nfunction tabulate(data, columns, divid) {\n    var table = d3.select(divid).append(\'table\');\n    var thead = table.append(\'thead\');\n    var tbody = table.append(\'tbody\');\n\n    // append the header row\n    thead.append(\'tr\').selectAll(\'th\').data(columns).enter().append(\'th\').text(function (column) {\n        return column;\n    });\n\n    // create a row for each object in the data\n    var rows = tbody.selectAll(\'tr\').data(data).enter().append(\'tr\').attr(\'class\', function (d, i) {\n        if (i == 0) return \'item-select\';else return \'item-default\';\n    });\n\n    // create a cell in each row for each column\n    var cells = rows.selectAll(\'td\').data(function (row) {\n        return columns.map(function (column) {\n            return { column: column, value: row[column] };\n        });\n    }).enter().append(\'td\').text(function (d) {\n        return d.value;\n    }).on("click", function (d) {\n        var myrow = this.parentElement;\n        if (myrow.className == "item-select") {\n            return;\n        } else {\n            d3.select(divid).select("tr.item-select").attr(\'class\', \'item-default\');\n            d3.select(myrow).attr(\'class\', "item-select");\n            if (divid == \'#setxRight\') {\n                resultsplotinit(allPipelineInfo[myrow.firstChild.innerText], dvvalues);\n            }\n        }\n    });\n\n    // this is code to add a checkbox to each row of pipeline results table\n    /*\n      d3.select(divid).selectAll("tr")\n      .append("input")\n      .attr("type", "checkbox")\n      .style("float","right");\n    */\n\n    return table;\n}\n\nfunction onPipelineCreate(PipelineCreateResult) {\n    // rpc GetExecutePipelineResults(PipelineExecuteResultsRequest) returns (stream PipelineExecuteResult) {}\n    estimateLadda.stop(); // stop spinner\n\n    $("#btnEstimate").removeClass("btn-success");\n    $("#btnEstimate").addClass("btn-default");\n    $("#btnEndSession").removeClass("btn-default");\n    $("#btnEndSession").addClass("btn-success");\n\n    var allPipelineInfo = {};\n    for (var i = 0; i < PipelineCreateResult.length; i++) {\n        if (PipelineCreateResult[i].pipelineId in allPipelineInfo) {\n            allPipelineInfo[PipelineCreateResult[i].pipelineId] = Object.assign(allPipelineInfo[PipelineCreateResult[i].pipelineId], PipelineCreateResult[i]);\n        } else {\n            allPipelineInfo[PipelineCreateResult[i].pipelineId] = PipelineCreateResult[i];\n        }\n    }\n    console.log(allPipelineInfo);\n    // to get all pipeline ids: Object.keys(allPipelineInfo)\n\n    var resultstable = [];\n    for (var key in allPipelineInfo) {\n        // don\'t report the pipeline to user if it has failed\n        if (allPipelineInfo[key].responseInfo.status.details == "Pipeline Failed") {\n            continue;\n        }\n        var myid = "";\n        var mymetric = "";\n        var myval = "";\n        console.log(allPipelineInfo);\n        var myscores = allPipelineInfo[key].pipelineInfo.scores;\n        for (var i = 0; i < myscores.length; i++) {\n            //if(i==0) {myid=key;}\n            //   else myid="";\n            myid = key;\n            mymetric = myscores[i].metric;\n            myval = +myscores[i].value.toFixed(3);\n            resultstable.push({ "PipelineID": myid, "Metric": mymetric, "Score": myval });\n        }\n    }\n\n    // render the table\n    tabulate(resultstable, [\'PipelineID\', \'Metric\', \'Score\'], \'#results\');\n    tabulate(resultstable, [\'PipelineID\', \'Metric\', \'Score\'], \'#setxRight\');\n    /////////////////////////\n\n    toggleRightButtons("all");\n    byId("btnResults").click();\n\n    // this initializes the main\n    // this piece here is the first pipeline through: allPipelineInfo[resultstable[1].PipelineID]\n    //resultsplotinit(allPipelineInfo[resultstable[1].PipelineID], dvvalues);\n    exportpipeline(resultstable[1].PipelineID);\n\n    // I don\'t think we need these until we are handling streaming pipelines\n    // They are set up and called, but don\'t actually render anything for the user\n\n    // this is our function for the ListPipelines of API\n    listpipelines();\n\n    //let pipelineid = PipelineCreateResult.pipelineid;\n    // getexecutepipelineresults is the third to be called\n    makeRequest(D3M_SVC_URL + \'/getexecutepipelineresults\', { context: context, pipeline_ids: Object.keys(allPipelineInfo) });\n}\nfunction CreatePipelineData(predictors, depvar) {\n    var context = apiSession(zparams.zsessionid);\n    var uri = { features: zparams.zd3mdata, target: zparams.zd3mtarget };\n    return {\n        context: context,\n        trainFeatures: apiFeatureShortPath(predictors, uri.features), // putting in short paths (no filename) for current API usage\n        targetFeatures: apiFeatureShortPath(depvar, uri.target), // putting in short paths (no filename) for current API usage\n        task: d3mTaskType[d3mProblemDescription.taskType][1],\n        taskSubtype: d3mTaskSubtype[d3mProblemDescription.taskSubtype][1],\n        //    output: d3mOutputType[d3mProblemDescription.outputType][1],\n        metrics: [d3mMetrics[d3mProblemDescription.metric][1]],\n        taskDescription: d3mProblemDescription.taskDescription,\n        maxPipelines: 5 //user to specify this eventually?\n    };\n}\n\nfunction downloadIncomplete() {\n    if (PRODUCTION && zparams.zsessionid === \'\') {\n        alert(\'Warning: Data download is not complete. Try again soon.\');\n        return true;\n    }\n    return false;\n}\n\n/**\n    called by clicking \'Solve This Problem\' in model mode\n*/\nasync function estimate(btn) {\n    if (!IS_D3M_DOMAIN) {\n        if (downloadIncomplete()) {\n            return;\n        }\n\n        zPop();\n        // write links to file & run R CMD\n        // package the output as JSON\n        // add call history and package the zparams object as JSON\n        zparams.callHistory = callHistory;\n        zparams.allVars = valueKey.slice(10, 25); // because the URL is too long...\n\n        /* UNUSED\n        var selectorurlcall = ROOK_SVC_URL + "selectorapp";\n        function selectorSuccess(btn, json) {\n            d3.select("#ticker")\n                .text("Suggested variables and percent improvement on RMSE: " + json.vars);\n            cdb("selectorSuccess: ", json);\n        }\n        function selectorFail(btn) {\n            alert("Selector Fail");\n        }\n        */\n\n        estimateLadda.start(); // start spinner\n        var json = await makeRequest(ROOK_SVC_URL + \'zeligapp\', zparams);\n        if (!json) {\n            estimated = true;\n        } else {\n            var modCol = function modCol() {\n                d3.select("#modelView").selectAll("p").style(\'background-color\', hexToRgba(varColor));\n            };\n\n            allResults.push(json);\n            if (!estimated) byId("results").removeChild(byId("resultsHolder"));\n\n            estimated = true;\n            d3.select("#results").style("display", "block");\n\n            d3.select("#resultsView").style("display", "block");\n\n            d3.select("#modelView").style("display", "block");\n\n            // programmatic click on Results button\n            $("#btnResults").trigger("click");\n\n            var model = "Model".concat(exports.modelCount = modelCount = modelCount + 1);\n\n            modCol();\n\n            d3.select("#modelView").insert("p", ":first-child") // top stack for results\n            .attr("id", model).text(model).style(\'background-color\', hexToRgba(_plots.selVarColor)).on("click", function () {\n                var a = this.style.backgroundColor.replace(/\\s*/g, "");\n                var b = hexToRgba(_plots.selVarColor).replace(/\\s*/g, "");\n                if (a.substr(0, 17) == b.substr(0, 17)) return; // escape function if displayed model is clicked\n                modCol();\n                d3.select(this).style(\'background-color\', hexToRgba(_plots.selVarColor));\n                viz(this.id);\n            });\n\n            var rCall = [json.call];\n            showLog(\'estimate\', rCall);\n\n            viz(model);\n        }\n    } else if (swandive) {\n        // IS_D3M_DOMAIN and swandive is true\n        zPop();\n        zparams.callHistory = callHistory;\n\n        var myvki = valueKey.indexOf(mytarget);\n        if (myvki != -1) {\n            del(valueKey, myvki);\n        }\n\n        estimateLadda.start(); // start spinner\n        var res = await makeRequest(D3M_SVC_URL + \'/createpipeline\', CreatePipelineData(valueKey, mytarget));\n        res && onPipelineCreate(res);\n    } else {\n        // we are in IS_D3M_DOMAIN no swandive\n        // rpc CreatePipelines(PipelineCreateRequest) returns (stream PipelineCreateResult) {}\n        zPop();\n        zparams.callHistory = callHistory;\n\n        // pipelineapp is a rook application that returns the dependent variable, the DV values, and the predictors. can think of it was a way to translate the potentially complex grammar from the UI\n\n        estimateLadda.start(); // start spinner\n        var _res = await makeRequest(ROOK_SVC_URL + \'pipelineapp\', zparams);\n        if (!_res) {\n            estimated = true;\n        } else {\n            console.log(_res);\n            setxTable(_res.predictors);\n            var _dvvalues = _res.dvvalues;\n            _res = await makeRequest(D3M_SVC_URL + \'/createpipeline\', CreatePipelineData(_res.predictors, _res.depvar));\n            //   res = await makeRequest(ROOK_SVC_URL + \'createpipeline\', zparams);\n            _res && onPipelineCreate(_res);\n        }\n    }\n}\n\n/** needs doc */\nfunction ta2stuff() {\n    console.log(d3mProblemDescription);\n}\n\n/** needs doc */\nasync function dataDownload() {\n    zPop();\n    // write links to file & run R CMD\n\n    // package the output as JSON\n    // add call history and package the zparams object as JSON\n    var res = await makeRequest(ROOK_SVC_URL + \'dataapp\', zparams);\n    if (!res) {\n        return;\n    }\n\n    zparams.zsessionid = res.sessionid[0];\n    // set link URL\n    byId("logID").href = \'\' + (PRODUCTION ? ROOK_SVC_URL + \'log_dir/log_\' : \'rook/log_\') + zparams.zsessionid + \'.txt\';\n}\n\n/** needs doc */\nfunction viz(mym) {\n    mym = +mym.substr(5, 5) - 1;\n\n    var removeKids = function removeKids(parent) {\n        while (parent.firstChild) {\n            parent.removeChild(parent.firstChild);\n        }\n    };\n    removeKids(byId("resultsView"));\n\n    var json = allResults[mym];\n\n    // pipe in figures to right panel\n    var filelist = new Array();\n    for (var i in json.images) {\n        var zfig = document.createElement("img");\n        zfig.setAttribute("src", json.images[i]);\n        zfig.setAttribute(\'width\', 200);\n        zfig.setAttribute(\'height\', 200);\n        byId("resultsView").appendChild(zfig);\n    }\n\n    // write the results table\n    var resultsArray = [];\n    for (var key in json.sumInfo) {\n        if (key == \'colnames\') continue;\n        resultsArray.push(json.sumInfo[key]);\n    }\n\n    var table = d3.select("#resultsView").append("p").append("table");\n\n    var thead = table.append("thead");\n    thead.append("tr").selectAll("th").data(json.sumInfo.colnames).enter().append("th").text(function (d) {\n        return d;\n    });\n\n    var tbody = table.append("tbody");\n    tbody.selectAll("tr").data(resultsArray).enter().append("tr").selectAll("td").data(function (d) {\n        return d;\n    }).enter().append("td").text(function (d) {\n        var myNum = Number(d);\n        if (isNaN(myNum)) return d;\n        return myNum.toPrecision(3);\n    }).on("mouseover", function () {\n        d3.select(this).style("background-color", "aliceblue");\n    }) // for no discernable reason\n    .on("mouseout", function () {\n        d3.select(this).style("background-color", "#F9F9F9");\n    }); //(but maybe we\'ll think of one)\n\n    d3.select("#resultsView").append("p").html(function () {\n        return "<b>Formula: </b>".concat(json.call[0]);\n    });\n\n    _mithril2.default.redraw();\n}\n\n/**\n   parses the transformation input.\n   variable names are often nested inside one another, e.g., ethwar, war, wars, and so this is handled\n*/\nfunction transParse(n) {\n    var out2 = [];\n    var t2 = n;\n    var k2 = 0;\n    var subMe2 = "_transvar".concat(k2);\n    var indexed = [];\n\n    // out2 is all matched variables, indexed is an array, each element is an object that contains the matched variables starting index and finishing index.  e.g., n="wars+2", out2=[war, wars], indexed=[{0,2},{0,3}]\n    for (var i in valueKey) {\n        var m2 = n.match(valueKey[i]);\n        if (m2 != null) out2.push(m2[0]);\n\n        var re = new RegExp(valueKey[i], "g");\n        var s = n.search(re);\n        if (s != -1) indexed.push({ from: s, to: s + valueKey[i].length });\n    }\n\n    // nested loop not good, but indexed is not likely to be very large.\n    // if a variable is nested, it is removed from out2\n    // notice, loop is backwards so that index changes don\'t affect the splice\n    cdb("indexed ", indexed);\n    for (var i = indexed.length - 1; i > -1; i--) {\n        for (var j = indexed.length - 1; j > -1; j--) {\n            if (i === j) continue;\n            if (indexed[i].from >= indexed[j].from & indexed[i].to <= indexed[j].to) {\n                cdb(i, " is nested in ", j);\n                del(out2, i);\n            }\n        }\n    }\n\n    for (var i in out2) {\n        t2 = t2.replace(out2[i], subMe2); //something that\'ll never be a variable name\n        k2 = k2 + 1;\n        subMe2 = "_transvar".concat(k2);\n    }\n\n    if (out2.length > 0) {\n        out2.push(t2);\n        cdb("new out ", out2);\n        return out2;\n    } else {\n        alert("No variable name found. Perhaps check your spelling?");\n        return null;\n    }\n}\n\n/**\n   n = name of column/node\n   t = selected transformation\n*/\nasync function transform(n, t, typeTransform) {\n    if (downloadIncomplete()) {\n        return;\n    }\n\n    if (!typeTransform) t = t.replace("+", "_plus_"); // can\'t send the plus operator\n\n    cdb(\'name of col: \' + n);\n    cdb(\'transformation: \' + t);\n\n    var btn = byId(\'btnEstimate\');\n\n    // find the node by name\n    var myn = findNodeIndex(n[0], true);\n\n    if (typeof myn === "undefined") {\n        myn = findNodeIndex(n, true);\n    }\n\n    var outtypes = {\n        varnamesTypes: n,\n        interval: myn.interval,\n        numchar: myn.numchar,\n        nature: myn.nature,\n        binary: myn.binary\n    };\n\n    cdb(myn);\n    // if typeTransform but we already have the metadata\n    if (typeTransform) {\n        if (myn.nature == "nominal" & typeof myn.plotvalues !== "undefined") {\n            myn.plottype = "bar";\n            (0, _plots.barsNode)(myn);\n            panelPlots();\n            return;\n        } else if (myn.nature != "nominal" & typeof myn.plotx !== "undefined") {\n            myn.plottype = "continuous";\n            (0, _plots.densityNode)(myn);\n            panelPlots();\n            return;\n        }\n    }\n\n    estimateLadda.start(); // start spinner\n    var json = await makeRequest(ROOK_SVC_URL + \'transformapp\', { zdataurl: dataurl,\n        zvars: myn.name,\n        zsessionid: zparams.zsessionid,\n        transform: t,\n        callHistory: callHistory,\n        typeTransform: typeTransform,\n        typeStuff: outtypes });\n    if (!json) {\n        return;\n    }\n\n    // Is this a typeTransform?\n    if (json.typeTransform[0]) {\n        // Yes. We\'re updating an existing node\n        d3.json(json.url, function (err, data) {\n            if (err) return console.warn(err);\n            var node = void 0;\n            for (var key in data) {\n                node = findNodeIndex(key, true);\n                if (!node) continue;\n                jQuery.extend(true, node, data[key]);\n                node.plottype === "continuous" ? (0, _plots.densityNode)(node) : node.plottype === "bar" ? (0, _plots.barsNode)(node) : null;\n            }\n            fakeClick();\n            panelPlots();\n            node && cdb(node);\n        });\n    } else {\n        /* No, we have a new node here--e.g. the transformed column\n           example response: {\n           "call":["t_year_2"],\n           "url":["data/preprocessSubset_BACCBC78-7DD9-4482-B31D-6EB01C3A0C95.txt"],\n           "trans":["year","_transvar0^2"],\n           "typeTransform":[false]\n           }\n        */\n        callHistory.push({\n            func: "transform",\n            zvars: n,\n            transform: t\n        });\n\n        var subseted = false;\n        var rCall = [];\n\n        rCall[0] = json.call;\n        var newVar = rCall[0][0];\n\n        trans.push(newVar);\n\n        // Read the preprocess file containing values\n        // for the transformed variable\n        //\n        d3.json(json.url, function (error, json) {\n            if (error) return console.warn(error);\n\n            var jsondata = getVariableData(json);\n\n            for (var key in jsondata) {\n                var myIndex = findNodeIndex(key);\n                if (typeof myIndex !== "undefined") {\n                    alert("Invalid transformation: this variable name already exists.");\n                    return;\n                }\n                // add transformed variable to the current space\n                var i = allNodes.length; // get new index\n                var obj1 = {\n                    id: i,\n                    reflexive: false,\n                    name: key,\n                    labl: "transformlabel",\n                    data: [5, 15, 20, 0, 5, 15, 20],\n                    count: [.6, .2, .9, .8, .1, .3, .4],\n                    nodeCol: colors(i),\n                    baseCol: colors(i),\n                    strokeColor: _plots.selVarColor,\n                    strokeWidth: "1",\n                    subsetplot: false,\n                    subsetrange: ["", ""],\n                    setxplot: false,\n                    setxvals: ["", ""],\n                    grayout: false,\n                    defaultInterval: jsondata[key].interval,\n                    defaultNumchar: jsondata[key].numchar,\n                    defaultNature: jsondata[key].nature,\n                    defaultBinary: jsondata[key].binary\n                };\n\n                jQuery.extend(true, obj1, jsondata[key]);\n                allNodes.push(obj1);\n\n                valueKey.push(newVar);\n                nodes.push(allNodes[i]);\n                fakeClick();\n                panelPlots();\n\n                if (allNodes[i].plottype === "continuous") {\n                    (0, _plots.densityNode)(allNodes[i]);\n                } else if (allNodes[i].plottype === "bar") {\n                    (0, _plots.barsNode)(allNodes[i]);\n                }\n\n                _mithril2.default.redraw();\n            }\n        });\n\n        showLog(\'transform\', rCall);\n    }\n}\n\nasync function makeRequest(url, data) {\n    console.log(\'url:\', url);\n    console.log(\'POST:\', data);\n    var res = void 0;\n    try {\n        res = await _mithril2.default.request(url, { method: \'POST\', data: data });\n        console.log(\'response:\', res);\n        if (Object.keys(res)[0] === \'warning\') {\n            alert(\'Warning: \' + res.warning);\n            end_ta3_search(false, res.warning);\n        }\n    } catch (err) {\n        end_ta3_search(false, err);\n        cdb(err);\n        alert(\'Error: call to \' + url + \' failed\');\n    }\n\n    /*\n     //call end_ta3_search if status != OK\n     // status may be in different places for different calls though, and this is not worth doing at the moment\n     let myreg = /d3m-service/g;\n     let isd3mcall = myreg.test(url);\n     if(isd3mcall) {\n         let mystatus = res.responseInfo.status.code.toUpperCase();\n         if(mystatus != "OK") {\n             end_ta3_search(false, "grpc response status not ok");\n         }\n     }\n     \n     */\n\n    estimateLadda.stop();\n    selectLadda.stop();\n    return res;\n}\n\n/** needs doc */\nfunction legend() {\n    borderState();\n    _mithril2.default.redraw();\n}\n\n/**\n   programmatically deselect every selected variable\n*/\nfunction erase() {\n    [\'#leftpanel\', \'#rightpanel\'].forEach(function (id) {\n        return d3.select(id).attr(\'class\', \'sidepanel container clearfix\');\n    });\n    tabLeft(\'tab1\');\n    $("#varList").children().each(function () {\n        if (zparams.zdv.concat(zparams.znom, zparams.zvars).includes(this.id)) clickVar({ target: this });\n    });\n}\n\n/** needs doc */\nfunction tabLeft(tab) {\n    byId(\'tab1\').style.display = \'none\';\n    byId(\'tab2\').style.display = \'none\';\n    byId(\'tab3\').style.display = \'none\';\n    byId(tab).style.display = \'block\';\n    if (tab != \'tab3\') {\n        exports.subset = subset = tab == \'tab2\';\n        exports.summaryHold = summaryHold = false;\n    }\n    exports.lefttab = lefttab = tab;\n}\n\n/** needs doc */\nfunction tabRight(tab) {\n    var select = function select(cls) {\n        var panel = d3.select("#rightpanel");\n        return cls ? panel.attr(\'class\', cls) : panel.attr(\'class\');\n    };\n    var cls = "sidepanel container clearfix";\n    var toggleR = function toggleR() {\n        select(function () {\n            var expand = cls + \' expandpanel\';\n            return this.getAttribute("class") === expand ? cls : expand;\n        });\n    };\n    var toggleRFull = function toggleRFull() {\n        select(function () {\n            var expand = cls + \' expandpanelfull\';\n            return this.getAttribute("class") === expand ? cls : expand;\n        });\n    };\n    if (tab === "btnModels") select(cls);else if (tab === "btnSetx") righttab === "btnSetx" || select() === cls && toggleRFull();else if (tab === "btnResults") !estimated ? select(cls) : righttab === "btnResults" || select() === cls && toggleR();\n    exports.righttab = righttab = tab;\n}\n\nvar summary = exports.summary = { data: [] };\n\n/** needs doc */\nfunction varSummary(d) {\n    var t1 = \'Mean:, Median:, Most Freq:, Occurrences:, Median Freq:, Occurrences:, Least Freq:, Occurrences:, Std Dev:, Minimum:, Maximum:, Invalid:, Valid:, Uniques:, Herfindahl\'.split(\', \');\n\n    var rint = d3.format(\'r\');\n    var str = function str(x, p) {\n        return (+x).toPrecision(p || 4).toString();\n    };\n    var t2 = priv && d.meanCI ? [str(d.mean, 2) + \' (\' + str(d.meanCI.lowerBound, 2) + \' - \' + str(d.meanCI.upperBound, 2) + \')\', str(d.median), d.mode, rint(d.freqmode), d.mid, rint(d.freqmid), d.fewest, rint(d.freqfewest), str(d.sd), str(d.min), str(d.max), rint(d.invalid), rint(d.valid), rint(d.uniques), str(d.herfindahl)] : [str(d.mean), str(d.median), d.mode, rint(d.freqmode), d.mid, rint(d.freqmid), d.fewest, rint(d.freqfewest), str(d.sd), str(d.min), str(d.max), rint(d.invalid), rint(d.valid), rint(d.uniques), str(d.herfindahl)];\n\n    summary.data = [];\n    t1.forEach(function (e, i) {\n        return !t2[i].includes(\'NaN\') && t2[i] != \'NA\' && t2[i] != \'\' && summary.data.push([e, t2[i]]);\n    });\n\n    summary.name = d.name;\n    summary.labl = d.labl;\n\n    d3.select(\'#tab3\').selectAll(\'svg\').remove();\n\n    if (!d.plottype) return;\n    d.plottype == \'continuous\' ? (0, _plots.density)(d, \'varSummary\', priv) : d.plottype == "bar" ? (0, _plots.bars)(d, \'varSummary\', priv) : d3.select("#tab3") // no graph to draw, but still need to remove previous graph\n    .selectAll("svg").remove();\n}\n\nvar popoverContent = exports.popoverContent = function popoverContent(d) {\n    if (swandive) return;\n    var text = \'\';\n    var _ref3 = [d3.format(\'r\'), function (val, int) {\n        return (+val).toPrecision(int).toString();\n    }],\n        rint = _ref3[0],\n        prec = _ref3[1];\n\n    var div = function div(field, name, val) {\n        if (field != \'NA\') text += \'<div class=\\\'form-group\\\'><label class=\\\'col-sm-4 control-label\\\'>\' + name + \'</label><div class=\\\'col-sm-6\\\'><p class=\\\'form-control-static\\\'>\' + (val || field) + \'</p></div></div>\';\n    };\n    d.labl != \'\' && div(d.labl, \'Label\');\n    div(d.mean, \'Mean\', priv && d.meanCI ? prec(d.mean, 2) + \' (\' + prec(d.meanCI.lowerBound, 2) + \' - \' + prec(d.meanCI.upperBound, 2) + \')\' : prec(d.mean, 4));\n    div(d.median, \'Median\', prec(d.median, 4));\n    div(d.mode, \'Most Freq\');\n    div(d.freqmode, \'Occurrences\', rint(d.freqmode));\n    div(d.mid, \'Median Freq\');\n    div(d.freqmid, \'Occurrences\', rint(d.freqmid));\n    div(d.fewest, \'Least Freq\');\n    div(d.freqfewest, \'Occurrences\', rint(d.freqfewest));\n    div(d.sd, \'Stand Dev\', prec(d.sd, 4));\n    div(d.max, \'Maximum\', prec(d.max, 4));\n    div(d.min, \'Minimum\', prec(d.min, 4));\n    div(d.invalid, \'Invalid\', rint(d.invalid));\n    div(d.valid, \'Valid\', rint(d.valid));\n    div(d.uniques, \'Uniques\', rint(d.uniques));\n    div(d.herfindahl, \'Herfindahl\', prec(d.herfindahl, 4));\n    return text;\n};\n\n/** needs doc */\nfunction panelPlots() {\n    if (IS_D3M_DOMAIN) {\n        byId(\'btnSubset\').classList.add(\'noshow\');\n    }\n    // build arrays from nodes in main\n    var vars = [];\n    var ids = [];\n    nodes.forEach(function (n) {\n        vars.push(n.name.replace(/\\(|\\)/g, \'\'));\n        ids.push(n.id);\n    });\n\n    //remove all plots, could be smarter here\n    d3.select(\'#setxLeft\').selectAll(\'svg\').remove();\n    d3.select(\'#tab2\').selectAll(\'svg\').remove();\n    for (var i = 0; i < vars.length; i++) {\n        if (allNodes[ids[i]].valid == 0) // this was a silent error... very frustrating...\n            continue;\n        var node = allNodes[ids[i]];\n        node.setxplot = false;\n        node.subsetplot = false;\n        if (node.plottype === "continuous" & node.setxplot == false) {\n            node.setxplot = true;\n            (0, _plots.density)(node, div = "setxLeft", priv);\n            node.subsetplot = true;\n            (0, _plots.density)(node, div = "subset", priv);\n        } else if (node.plottype === "bar" & node.setxplot == false) {\n            node.setxplot = true;\n            (0, _plots.bars)(node, div = "setxLeft", priv);\n            node.subsetplot = true;\n            (0, _plots.barsSubset)(node);\n        }\n    }\n\n    d3.select("#setxLeft").selectAll("svg").each(function () {\n        d3.select(this);\n        var regstr = /(.+)_setxLeft_(\\d+)/;\n        var myname = regstr.exec(this.id);\n        var nodeid = myname[2];\n        myname = myname[1];\n        if (!vars.includes(myname)) {\n            allNodes[nodeid].setxplot = false;\n            var temp = "#".concat(myname, "_setxLeft_", nodeid);\n            d3.select(temp).remove();\n            allNodes[nodeid].subsetplot = false;\n            temp = "#".concat(myname, "_tab2_", nodeid);\n            d3.select(temp).remove();\n        }\n    });\n}\n\n/**\n   converts color codes\n*/\nvar hexToRgba = exports.hexToRgba = function hexToRgba(hex) {\n    var int = parseInt(hex.replace(\'#\', \'\'), 16);\n    return \'rgba(\' + [int >> 16 & 255, int >> 8 & 255, int & 255, \'0.5\'].join(\',\') + \')\';\n};\n\n/**\n   takes node and color and updates zparams\n*/\nfunction setColors(n, c) {\n    if (n.strokeWidth == \'1\') {\n        if (c == gr1Color) {\n            var tempindex = zparams.zgroup1.indexOf(n.name);\n            if (tempindex > -1) {\n                n.group1 = false;\n                del(zparams.zgroup1, tempindex);\n            } else {\n                n.group1 = true;\n                zparams.zgroup1.push(n.name);\n            };\n        } else if (c == gr2Color) {\n            var tempindex = zparams.zgroup2.indexOf(n.name);\n            if (tempindex > -1) {\n                n.group2 = false;\n                del(zparams.zgroup2, tempindex);\n            } else {\n                n.group2 = true;\n                zparams.zgroup2.push(n.name);\n            };\n        } else {\n            // adding time, cs, dv, nom to node with no stroke\n            n.strokeWidth = \'4\';\n            n.strokeColor = c;\n            n.nodeCol = taggedColor;\n            var push = function push(_ref4) {\n                var _ref5 = _slicedToArray(_ref4, 2),\n                    color = _ref5[0],\n                    key = _ref5[1];\n\n                if (color != c) return;\n                zparams[key] = Array.isArray(zparams[key]) ? zparams[key] : [];\n                zparams[key].push(n.name);\n                if (key == \'znom\') {\n                    findNodeIndex(n.name, true).nature = "nominal";\n                    transform(n.name, t = null, typeTransform = true);\n                }\n                if (key == \'zdv\') {\n                    // remove group memberships from dv\'s\n                    if (n.group1) {\n                        n.group1 = false;\n                        del(zparams.zgroup1, -1, n.name);\n                    };\n                    if (n.group2) {\n                        n.group2 = false;\n                        del(zparams.zgroup2, -1, n.name);\n                    };\n                }\n            };\n            [[dvColor, \'zdv\'], [csColor, \'zcross\'], [timeColor, \'ztime\'], [nomColor, \'znom\']].forEach(push);\n        }\n    } else if (n.strokeWidth == \'4\') {\n        if (c == n.strokeColor) {\n            // deselecting time, cs, dv, nom\n            n.strokeWidth = \'1\';\n            n.strokeColor = _plots.selVarColor;\n            n.nodeCol = colors(n.id);\n            zparamsReset(n.name);\n            if (nomColor == c && zparams.znom.includes(n.name)) {\n                findNodeIndex(n.name, true).nature = findNodeIndex(n.name, true).defaultNature;\n                transform(n.name, t = null, typeTransform = true);\n            }\n        } else {\n            // deselecting time, cs, dv, nom AND changing it to time, cs, dv, nom\n            zparamsReset(n.name);\n            if (nomColor == n.strokeColor && zparams.znom.includes(n.name)) {\n                findNodeIndex(n.name, true).nature = findNodeIndex(n.name, true).defaultNature;\n                transform(n.name, t = null, typeTransform = true);\n            }\n            n.strokeColor = c;\n            if (dvColor == c) {\n                var dvname = n.name;\n                zparams.zdv.push(dvname);\n                if (n.group1) {\n                    // remove group memberships from dv\'s\n                    ngroup1 = false;\n                    del(zparams.zgroup1, -1, dvname);\n                };\n                if (n.group2) {\n                    ngroup2 = false;\n                    del(zparams.zgroup2, -1, dvname);\n                };\n            } else if (csColor == c) zparams.zcross.push(n.name);else if (timeColor == c) zparams.ztime.push(n.name);else if (nomColor == c) {\n                zparams.znom.push(n.name);\n                findNodeIndex(n.name, true).nature = "nominal";\n                transform(n.name, t = null, typeTransform = true);\n            }\n        }\n    }\n}\n\n/** needs doc */\nfunction borderState() {\n    zparams.zdv.length > 0 ? $(\'#dvButton .rectColor svg circle\').attr(\'stroke\', dvColor) : $(\'#dvButton\').css(\'border-color\', \'#ccc\');\n    zparams.zcross.length > 0 ? $(\'#csButton .rectColor svg circle\').attr(\'stroke\', csColor) : $(\'#csButton\').css(\'border-color\', \'#ccc\');\n    zparams.ztime.length > 0 ? $(\'#timeButton .rectColor svg circle\').attr(\'stroke\', timeColor) : $(\'#timeButton\').css(\'border-color\', \'#ccc\');\n    zparams.znom.length > 0 ? $(\'#nomButton .rectColor svg circle\').attr(\'stroke\', nomColor) : $(\'#nomButton\').css(\'border-color\', \'#ccc\');\n    zparams.zgroup1.length > 0 ? $(\'#gr1Button .rectColor svg circle\').attr(\'stroke\', gr1Color).attr(\'fill\', gr1Color).attr(\'fill-opacity\', 0.6).attr(\'stroke-opacity\', 0) : $(\'#gr1Button\').css(\'border-color\', \'#ccc\');\n    zparams.zgroup2.length > 0 ? $(\'#gr2Button .rectColor svg circle\').attr(\'stroke\', gr2Color).attr(\'fill\', gr2Color).attr(\'fill-opacity\', 0.6).attr(\'stroke-opacity\', 0) : $(\'#gr2Button\').css(\'border-color\', \'#ccc\');\n}\n\n/** needs doc */\nfunction subsetSelect(btn) {\n    if (dataurl) {\n        zparams.zdataurl = dataurl;\n    }\n    if (downloadIncomplete()) {\n        return;\n    }\n\n    zparams.zvars = [];\n    zparams.zplot = [];\n    var subsetEmpty = true;\n    // is this the same as zPop()?\n    for (var j = 0; j < nodes.length; j++) {\n        // populate zvars and zsubset arrays\n        zparams.zvars.push(nodes[j].name);\n        var temp = nodes[j].id;\n        zparams.zsubset[j] = allNodes[temp].subsetrange;\n        if (zparams.zsubset[j].length > 0) {\n            if (zparams.zsubset[j][0] != "") zparams.zsubset[j][0] = Number(zparams.zsubset[j][0]);\n            if (zparams.zsubset[j][1] != "") zparams.zsubset[j][1] = Number(zparams.zsubset[j][1]);\n        }\n        zparams.zplot.push(allNodes[temp].plottype);\n        if (zparams.zsubset[j][1] != "") subsetEmpty = false; // only need to check one\n    }\n\n    if (subsetEmpty == true) {\n        alert("Warning: No new subset selected.");\n        return;\n    }\n\n    var outtypes = [];\n    for (var j = 0; j < allNodes.length; j++) {\n        outtypes.push({\n            varnamesTypes: allNodes[j].name,\n            nature: allNodes[j].nature,\n            numchar: allNodes[j].numchar,\n            binary: allNodes[j].binary,\n            interval: allNodes[j].interval\n        });\n    }\n\n    selectLadda.start(); // start button motion\n    var json = makeRequest(ROOK_SVC_URL + \'subsetSelect\', { zdataurl: zparams.zdataurl,\n        zvars: zparams.zvars,\n        zsubset: zparams.zsubset,\n        zsessionid: zparams.zsessionid,\n        zplot: zparams.zplot,\n        callHistory: callHistory,\n        typeStuff: outtypes });\n    selectLadda.stop();\n    if (!json) {\n        return;\n    }\n\n    $("#btnVariables").trigger("click"); // programmatic clicks\n    $("#btnModels").trigger("click");\n\n    var grayOuts = [];\n    var rCall = [];\n    rCall[0] = json.call;\n\n    // store contents of the pre-subset space\n    zPop();\n    var myNodes = jQuery.extend(true, [], allNodes);\n    var myParams = jQuery.extend(true, {}, zparams);\n    var myTrans = jQuery.extend(true, [], trans);\n    var myForce = jQuery.extend(true, [], forcetoggle);\n    var myPreprocess = jQuery.extend(true, {}, preprocess);\n    var myLog = jQuery.extend(true, [], logArray);\n    var myHistory = jQuery.extend(true, [], callHistory);\n\n    spaces[myspace] = {\n        "allNodes": myNodes,\n        "zparams": myParams,\n        "trans": myTrans,\n        "force": myForce,\n        "preprocess": myPreprocess,\n        "logArray": myLog,\n        "callHistory": myHistory\n    };\n\n    // remove pre-subset svg\n    var selectMe = "#m".concat(myspace);\n    d3.select(selectMe).attr(\'class\', \'item\');\n    selectMe = "#whitespace".concat(myspace);\n    d3.select(selectMe).remove();\n\n    myspace = spaces.length;\n    callHistory.push({\n        func: "subset",\n        zvars: jQuery.extend(true, [], zparams.zvars),\n        zsubset: jQuery.extend(true, [], zparams.zsubset),\n        zplot: jQuery.extend(true, [], zparams.zplot)\n    });\n\n    // this is to be used to gray out and remove listeners for variables that have been subsetted out of the data\n    function varOut(v) {\n        // if in nodes, remove gray out in left panel\n        // make unclickable in left panel\n        for (var i = 0; i < v.length; i++) {\n            var selectMe = v[i].replace(/\\W/g, "_");\n            byId(selectMe).style.color = hexToRgba(grayColor);\n            selectMe = "p#".concat(selectMe);\n            d3.select(selectMe).on("click", null);\n        }\n    }\n\n    showLog(\'subset\', rCall);\n\n    d3.select("#innercarousel").append(\'div\').attr(\'class\', \'item active\').attr(\'id\', function () {\n        return "m".concat(myspace.toString());\n    }).append(\'svg\').attr(\'id\', \'whitespace\');\n    svg = d3.select("#whitespace");\n\n    d3.json(json.url, function (error, json) {\n        if (error) {\n            return console.warn(error);\n        }\n        var jsondata = getVariableData(json);\n\n        for (var key in jsondata) {\n            var myIndex = findNodeIndex(key);\n\n            allNodes[myIndex].plotx = undefined;\n            allNodes[myIndex].ploty = undefined;\n            allNodes[myIndex].plotvalues = undefined;\n            allNodes[myIndex].plottype = "";\n\n            jQuery.extend(true, allNodes[myIndex], jsondata[key]);\n            allNodes[myIndex].subsetplot = false;\n            allNodes[myIndex].subsetrange = ["", ""];\n            allNodes[myIndex].setxplot = false;\n            allNodes[myIndex].setxvals = ["", ""];\n\n            if (allNodes[myIndex].valid == 0) {\n                grayOuts.push(allNodes[myIndex].name);\n                allNodes[myIndex].grayout = true;\n            }\n        }\n        rePlot();\n        layout(layoutAdd);\n    });\n\n    varOut(grayOuts);\n}\n\n/**\n   removes all the children svgs inside subset and setx divs\n*/\nfunction rePlot() {\n    d3.select(\'#tab2\').selectAll(\'svg\').remove();\n    d3.select(\'#setx\').selectAll(\'svg\').remove();\n    allNodes.forEach(function (n) {\n        return n.setxplot = n.subsetplot = false;\n    });\n}\n\n// acts as if the user clicked in whitespace. useful when restart() is outside of scope\nvar fakeClick = exports.fakeClick = function fakeClick() {\n    var ws = "#whitespace".concat(myspace);\n    // d3 and programmatic events don\'t mesh well, here\'s a SO workaround that looks good but uses jquery...\n    jQuery.fn.d3Click = function () {\n        this.each(function (i, e) {\n            var evt = document.createEvent("MouseEvents");\n            evt.initMouseEvent("mousedown", true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);\n            e.dispatchEvent(evt);\n        });\n    };\n    $(ws).d3Click();\n    d3.select(ws).classed(\'active\', false);\n};\n\n/**\n   EndSession(SessionContext) returns (Response) {}\n*/\nasync function endsession() {\n    // makeRequest(D3M_SVC_URL + \'/endsession\', apiSession(zparams.zsessionid));\n    var res = await makeRequest(D3M_SVC_URL + \'/endsession\', apiSession(zparams.zsessionid));\n    var mystatus = res.status.code.toUpperCase();\n    if (mystatus == "OK") {\n        end_ta3_search(true, "Problem marked as complete.");\n    }\n}\n\n/**\n   rpc ListPipelines(PipelineListRequest) returns (PipelineListResult) {}\n   pipes is an array of pipeline IDs\n*/\nfunction listpipelines() {\n    var res = makeRequest(D3M_SVC_URL + \'/listpipelines\', { context: apiSession(zparams.zsessionid) });\n    if (!res) {\n        return;\n    }\n\n    //hardcoded pipes for now\n    var pipes = res.pipelineIds;\n\n    /*\n      pipes.unshift("place");\n      console.log(pipes);\n      d3.select("#results").selectAll("p")\n      .data(pipes)\n      .enter()\n      .append("p")\n      .attr("id", "_pipe_".concat)\n      .text(d => d)\n      .attr(\'class\', \'item-default\')\n      .on("click", function() {\n      if(this.className=="item-select") {\n      return;\n      } else {\n      d3.select("#results").select("p.item-select")\n      .attr(\'class\', \'item-default\');\n      d3.select(this).attr(\'class\',"item-select");\n      }});\n       pipes.shift();\n        d3.select("#setxRight").selectAll("p")\n      .data(pipes)\n      .enter()\n      .append("p")\n      .attr("id", "_setxpipe_".concat)\n      .text(d => d)\n      .attr(\'class\', \'item-default\')\n      .on("click", function() {\n      if(this.className=="item-select") {\n      return;\n      } else {\n      d3.select("#setxRight").select("p.item-select")\n      .attr(\'class\', \'item-default\');\n      d3.select(this).attr(\'class\',"item-select");\n      }});\n    */\n}\n\n/**\n   rpc ExecutePipeline(PipelineExecuteRequest) returns (stream PipelineExecuteResult) {}\n*/\nfunction executepipeline() {\n    var context = apiSession(zparams.zsessionid);\n    var tablerow = byId(\'setxRight\').querySelector(\'tr.item-select\');\n    if (tablerow == null) {\n        alert("Please select a pipeline to execute on.");return;\n    }\n    var pipelineId = tablerow.firstChild.innerText;\n\n    zPop();\n    zparams.callHistory = callHistory;\n    var jsonout = JSON.stringify(zparams);\n\n    var predictFeatures = apiFeature(zparams.zvars, "<<DATA_URI>>");\n    var data = [];\n\n    //this will just set zparams.zsetx to the mean, which is default for setx plots\n    //note that if setxplot is modified, it will NOT == "" because zparams.zsetx is modified when the setx plot slider is moved for the first time\n    for (var i = 0; i < zparams.zvars.length; i++) {\n        var mydata = [];\n        var mymean = allNodes[findNodeIndex(zparams.zvars[i])].mean;\n        if (zparams.zsetx[i][0] == "") {\n            mydata[0] = mymean;\n        } else if (zparams.zsetx[i][0] != mymean) {\n            mydata[0] = zparams.zsetx[i][0];\n        }\n        if (zparams.zsetx[i][1] == "") {\n            mydata[1] = allNodes[findNodeIndex(zparams.zvars[i])].mean;\n        } else if (zparams.zsetx[i][1] != mymean) {\n            mydata[1] = zparams.zsetx[i][1];\n        }\n        data.push(mydata);\n    }\n\n    makeRequest(D3M_SVC_URL + \'/executepipeline\', { context: context, pipelineId: pipelineId, predictFeatures: predictFeatures, data: data });\n}\n\n/**\n   call to django to update the problem schema\n   rpc UpdateProblemSchema(UpdateProblemSchemaRequest) returns (Response) {}\n*/\nfunction updateSchema(type, updates, lookup) {\n    makeRequest(D3M_SVC_URL + "/updateproblemschema", { replaceProblemSchemaField: _defineProperty({}, type, lookup[updates[type]][1]), context: apiSession(zparams.zsessionid) });\n}\n\n/**\n   find something centerish to the vertices of a convex hull\n   (specifically, the center of the bounding box)\n*/\nfunction jamescentroid(coord) {\n    var minx = coord[0][0],\n        maxx = coord[0][0],\n        miny = coord[0][1],\n        maxy = coord[0][1];\n    for (var j = 1; j < coord.length; j++) {\n        if (coord[j][0] < minx) minx = coord[j][0];\n        if (coord[j][1] < miny) miny = coord[j][1];\n        if (coord[j][0] > maxx) maxx = coord[j][0];\n        if (coord[j][1] > maxy) maxy = coord[j][1];\n    };\n    return [(minx + maxx) / 2, (miny + maxy) / 2];\n};\n\n/**\n   Define each pebble radius.\n   Presently, most pebbles are scaled to radius set by global RADIUS.\n   Members of groups are scaled down if group gets large.\n*/\nfunction setPebbleRadius(d) {\n    if (d.group1 || d.group2) {\n        // if a member of a group, need to calculate radius size\n        var uppersize = 7;\n        var ng1 = d.group1 ? zparams.zgroup1.length : 1; // size of group1, if a member of group 1\n        var ng2 = d.group2 ? zparams.zgroup2.length : 1; // size of group2, if a member of group 2\n        var maxng = Math.max(ng1, ng2); // size of the largest group variable is member of\n        return maxng > uppersize ? RADIUS * Math.sqrt(uppersize / maxng) : RADIUS; // keep total area of pebbles bounded to pi * RADIUS^2 * uppersize, thus shrinking radius for pebbles in larger groups\n    } else {\n        return RADIUS; // nongroup members get the common global radius\n    }\n};\n\n/**\n   Define each pebble charge.\n*/\nfunction setPebbleCharge(d) {\n    if (d.group1 || d.group2) {\n        if (d.forefront) {\n            // pebbles packed in groups repel others on mouseover\n            return -1000;\n        }\n        var uppersize = 7;\n        var ng1 = d.group1 ? zparams.zgroup1.length : 1; // size of group1, if a member of group 1\n        var ng2 = d.group2 ? zparams.zgroup2.length : 1; // size of group2, if a member of group 2\n        var maxng = Math.max(ng1, ng2); // size of the largest group variable is member of\n        return maxng > uppersize ? -400 * (uppersize / maxng) : -400; // decrease charge as pebbles become smaller, so they can pack together\n    } else {\n        return -800;\n    }\n};\n\n/** needs doc */\nfunction expandrightpanel() {\n    byId(\'rightpanel\').classList.add("expandpanelfull");\n    console.log("HERE");\n}\n\n/** needs doc */\nfunction toggleRightButtons(set) {\n    function setWidths(btns) {\n        var width = 100 / btns.length + \'%\';\n        var expandwidth = \'35%\';\n        var shrinkwidth = 65 / (btns.length - 1) + \'%\';\n        var lis = byId(\'rightpanel\').querySelectorAll(".accordion li");\n        // hardly ever runs on the page\n        lis.forEach(function (li) {\n            li.style.width = width;\n            li.addEventListener(\'mouseover\', function () {\n                lis.forEach(function (li) {\n                    return li.style.width = shrinkwidth;\n                });\n                this.style.width = expandwidth;\n            });\n            li.addEventListener(\'mouseout\', function () {\n                lis.forEach(function (li) {\n                    return li.style.width = width;\n                });\n            });\n        });\n    }\n\n    if (set == "tasks") {\n        byId(\'btnModels\').classList.add("noshow");\n        byId(\'btnSetx\').classList.add("noshow");\n        byId(\'btnResults\').classList.add("noshow");\n        var btns = byId(\'rightpanelbuttons\').querySelectorAll(".btn:not(.noshow)");\n        setWidths(btns);\n    } else if (set == "all") {\n        // first remove noshow class\n        var _btns = byId(\'rightpanelbuttons\').querySelectorAll(".noshow");\n        _btns.forEach(function (b) {\n            return b.classList.remove("noshow");\n        });\n\n        // dropping models for IS_D3M_DOMAIN\n        byId(\'btnModels\').classList.add("noshow");\n\n        // if swandive, dropping setx\n        if (swandive) byId(\'btnSetx\').classList.add("noshow");\n\n        // then select all the buttons\n        _btns = byId(\'rightpanelbuttons\').querySelectorAll(".btn:not(.noshow)");\n        setWidths(_btns);\n    } else if (set == "models") {\n        byId(\'btnModels\').style.display = \'inline\';\n        byId(\'btnSetx\').style.display = \'inline\';\n        byId(\'btnResults\').style.display = \'inline\';\n\n        byId(\'btnType\').style.display = \'none\';\n        byId(\'btnSubtype\').style.display = \'none\';\n        byId(\'btnMetrics\').style.display = \'none\';\n        //       byId(\'btnOutputs\').style.display = \'none\';\n    }\n}\n\n/** needs doc */\nfunction resultsplotinit(pid, dvvalues) {\n    // presumably we\'ll be reading in results from a path\n    // for now it\'s just hardcoded\n    console.log(pid);\n    var predfile = pid.pipelineInfo.predictResultData.file_1;\n    var predvals = [];\n\n    for (var i = 0; i < predfile.length; i++) {\n        predvals.push(Number(predfile[i].preds));\n    }\n\n    // only do this for classification tasks\n    if (d3mTaskType[d3mProblemDescription.taskType][1] == "CLASSIFICATION") {\n        genconfdata(dvvalues, predvals);\n    } else {\n        var xdata = "Actual";\n        var ydata = "Predicted";\n        bivariatePlot(dvvalues, predvals, xdata, ydata);\n    }\n}\n\n/** needs doc */\nfunction genconfdata(dvvalues, predvals) {\n    // FOR TESTING\n    dvvalues = predvals.slice(0);\n    for (var i = 0; i < dvvalues.length; i++) {\n        var randomnumber = Math.floor(Math.random() * (2 - -2 + 1)) + -2;\n        dvvalues[i] = dvvalues[i] + randomnumber;\n    }\n\n    // done for testing. drop above when dvvalues are real values returned by R when pipeline is constructed\n\n    function onlyUnique(value, index, self) {\n        return self.indexOf(value) === index;\n    }\n\n    var mycounts = [];\n    var mypairs = [];\n\n    // this should eventually be just read from the URI in pipeline\n    // let dvvalues = [1,1,1,2,3,2,3,3,3,3,3,2,3,2,1,2,3,4,4];\n    // let predvals = [1,2,3,2,3,1,3,3,3,2,2,1,3,3,1,2,3,4,3];\n\n    // combine actuals and predicted, and get all unique elements\n    var myuniques = dvvalues.concat(predvals);\n    myuniques = myuniques.filter(onlyUnique);\n\n    // create two arrays: mycounts initialized to 0, mypairs have elements set to all possible pairs of uniques\n    // looked into solutions other than nested fors, but Internet suggest performance is just fine this way\n    for (var _i2 = 0; _i2 < myuniques.length; _i2++) {\n        var tempcount = [];\n        var temppair = [];\n        for (var j = 0; j < myuniques.length; j++) {\n            mycounts.push(0);\n            mypairs.push(+myuniques[_i2] + \',\' + myuniques[j]);\n        }\n    }\n\n    // line up actuals and predicted, and increment mycounts at index where mypair has a match for the \'actual,predicted\'\n    for (var _i3 = 0; _i3 < dvvalues.length; _i3++) {\n        var _temppair = +dvvalues[_i3] + \',\' + predvals[_i3];\n        var myindex = mypairs.indexOf(_temppair);\n        mycounts[myindex] += 1;\n    }\n\n    var confdata = [],\n        size = myuniques.length;\n    // another loop... this builds the array of arrays from the flat array mycounts for input to confusionsmatrix function\n    while (mycounts.length > 0) {\n        confdata.push(mycounts.splice(0, size));\n    }confusionmatrix(confdata, myuniques);\n}\n\n/** needs doc */\nfunction confusionmatrix(matrixdata, classes) {\n    d3.select("#setxMiddle").html("");\n    d3.select("#setxMiddle").select("svg").remove();\n\n    // adapted from this block: https://bl.ocks.org/arpitnarechania/dbf03d8ef7fffa446379d59db6354bac\n    var mainwidth = byId(\'main\').clientWidth;\n    var mainheight = byId(\'main\').clientHeight;\n\n    var condiv = document.createElement(\'div\');\n    condiv.id = "confusioncontainer";\n    condiv.style.display = "inline-block";\n    condiv.style.width = +(mainwidth * .25) + \'px\';\n    condiv.style.marginLeft = \'20px\';\n    condiv.style.height = +(mainheight * .4) + \'px\';\n    condiv.style.float = "left";\n    byId(\'setxMiddle\').appendChild(condiv);\n\n    var legdiv = document.createElement(\'div\');\n    legdiv.id = "confusionlegend";\n    legdiv.style.width = +(mainwidth * .07) + \'px\';\n    legdiv.style.marginLeft = \'20px\';\n    legdiv.style.height = +(mainheight * .4) + \'px\';\n    legdiv.style.display = "inline-block";\n    byId(\'setxMiddle\').appendChild(legdiv);\n\n    var margin = { top: 20, right: 10, bottom: 0, left: 50 };\n    function Matrix(options) {\n        var width = options.width,\n            height = options.height,\n            data = options.data,\n            container = options.container,\n            labelsData = options.labels,\n            startColor = options.start_color,\n            endColor = options.end_color;\n\n        var widthLegend = options.widthLegend;\n\n        if (!data) {\n            throw new Error(\'Please pass data\');\n        }\n\n        if (!Array.isArray(data) || !data.length || !Array.isArray(data[0])) {\n            throw new Error(\'It should be a 2-D array\');\n        }\n\n        var maxValue = d3.max(data, function (layer) {\n            return d3.max(layer, function (d) {\n                return d;\n            });\n        });\n        var minValue = d3.min(data, function (layer) {\n            return d3.min(layer, function (d) {\n                return d;\n            });\n        });\n\n        var numrows = data.length;\n        var numcols = data[0].length;\n\n        var svg = d3.select(container).append("svg").attr("width", width + margin.left + margin.right).attr("height", height + margin.top + margin.bottom).append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");\n\n        var background = svg.append("rect").style("stroke", "black").style("stroke-width", "2px").attr("width", width).attr("height", height);\n\n        var x = d3.scale.ordinal().domain(d3.range(numcols)).rangeBands([0, width]);\n\n        var y = d3.scale.ordinal().domain(d3.range(numrows)).rangeBands([0, height]);\n\n        var colorMap = d3.scale.linear().domain([minValue, maxValue]).range([startColor, endColor]);\n\n        var row = svg.selectAll(".row").data(data).enter().append("g").attr("class", "row").attr("transform", function (d, i) {\n            return "translate(0," + y(i) + ")";\n        });\n\n        var cell = row.selectAll(".cell").data(function (d) {\n            return d;\n        }).enter().append("g").attr("class", "cell").attr("transform", function (d, i) {\n            return "translate(" + x(i) + ", 0)";\n        });\n\n        cell.append(\'rect\').attr("width", x.rangeBand()).attr("height", y.rangeBand()).style("stroke-width", 0);\n\n        cell.append("text").attr("dy", ".32em").attr("x", x.rangeBand() / 2).attr("y", y.rangeBand() / 2).attr("text-anchor", "middle").style("fill", function (d, i) {\n            return d >= maxValue / 2 ? \'white\' : \'black\';\n        }).text(function (d, i) {\n            return d;\n        });\n\n        row.selectAll(".cell").data(function (d, i) {\n            return data[i];\n        }).style("fill", colorMap);\n\n        // this portion of the code isn\'t as robust to sizing. column labels not rendering in the right place\n        var labels = svg.append(\'g\').attr(\'class\', "labels");\n\n        var columnLabels = labels.selectAll(".column-label").data(labelsData).enter().append("g").attr("class", "column-label").attr("transform", function (d, i) {\n            // let temp = "translate(" + x(i) + "," + (height+20) + ")"; // this in particular looks to be the cause\n            //  console.log(temp);\n            return "translate(" + x(i) + "," + (height + 30) + ")";\n        });\n\n        columnLabels.append("line").style("stroke", "black").style("stroke-width", "1px").attr("x1", x.rangeBand() / 2).attr("x2", x.rangeBand() / 2).attr("y1", 0).attr("y2", 5);\n\n        columnLabels.append("text").attr("x", 30).attr("y", y.rangeBand() / 2).attr("dy", ".22em").attr("text-anchor", "end").attr("transform", "rotate(-60)").text(function (d, i) {\n            return d;\n        });\n\n        var rowLabels = labels.selectAll(".row-label").data(labelsData).enter().append("g").attr("class", "row-label").attr("transform", function (d, i) {\n            return "translate(" + 0 + "," + y(i) + ")";\n        });\n\n        rowLabels.append("line").style("stroke", "black").style("stroke-width", "1px").attr("x1", 0).attr("x2", -5).attr("y1", y.rangeBand() / 2).attr("y2", y.rangeBand() / 2);\n\n        rowLabels.append("text").attr("x", -8).attr("y", y.rangeBand() / 2).attr("dy", ".32em").attr("text-anchor", "end").text(function (d, i) {\n            return d;\n        });\n\n        var key = d3.select("#confusionlegend").append("svg").attr("width", widthLegend).attr("height", height + margin.top + margin.bottom);\n\n        var legend = key.append("defs").append("svg:linearGradient").attr("id", "gradient").attr("x1", "100%").attr("y1", "0%").attr("x2", "100%").attr("y2", "100%").attr("spreadMethod", "pad");\n\n        legend.append("stop").attr("offset", "0%").attr("stop-color", endColor).attr("stop-opacity", 1);\n\n        legend.append("stop").attr("offset", "100%").attr("stop-color", startColor).attr("stop-opacity", 1);\n\n        key.append("rect").attr("width", widthLegend / 2 - 10).attr("height", height).style("fill", "url(#gradient)").attr("transform", "translate(0," + margin.top + ")");\n\n        // this y is for the legend\n        y = d3.scale.linear().range([height, 0]).domain([minValue, maxValue]);\n\n        var yAxis = d3.svg.axis().scale(y).orient("right");\n\n        key.append("g").attr("class", "y axis").attr("transform", "translate(41," + margin.top + ")").call(yAxis);\n    }\n\n    // The table generation function. Used for the table of performance measures, not the confusion matrix\n    function tabulate(data, columns) {\n        var table = d3.select("#setxMiddle").append("table").attr("style", "margin-left: " + margin.left + "px"),\n            thead = table.append("thead"),\n            tbody = table.append("tbody");\n\n        // append the header row\n        thead.append("tr").selectAll("th").data(columns).enter().append("th").text(function (column) {\n            return column;\n        });\n\n        // create a row for each object in the data\n        var rows = tbody.selectAll("tr").data(data).enter().append("tr");\n\n        // create a cell in each row for each column\n        var cells = rows.selectAll("td").data(function (row) {\n            return columns.map(function (column) {\n                return { column: column, value: row[column] };\n            });\n        }).enter().append("td").attr("style", "font-family: Courier") // sets the font style\n        .html(function (d) {\n            return d.value;\n        });\n\n        return table;\n    }\n\n    // this code is all for producing a table with performance measures\n    //var confusionMatrix = [[169, 10],[7, 46]];\n    var tp = matrixdata[0][0];\n    var fn = matrixdata[0][1];\n    var fp = matrixdata[1][0];\n    var tn = matrixdata[1][1];\n\n    var p = tp + fn;\n    var n = fp + tn;\n\n    var accuracy = (tp + tn) / (p + n);\n    var f1 = 2 * tp / (2 * tp + fp + fn);\n    var precision = tp / (tp + fp);\n    var recall = tp / (tp + fn);\n\n    accuracy = Math.round(accuracy * 100) / 100;\n    f1 = Math.round(f1 * 100) / 100;\n    precision = Math.round(precision * 100) / 100;\n    recall = Math.round(recall * 100) / 100;\n\n    var computedData = [];\n    computedData.push({ "F1": f1, "PRECISION": precision, "RECALL": recall, "ACCURACY": accuracy });\n\n    Matrix({\n        container: \'#confusioncontainer\',\n        data: matrixdata,\n        labels: classes,\n        start_color: \'#ffffff\',\n        end_color: \'#e67e22\',\n        width: mainwidth * .15,\n        height: mainheight * .25,\n        widthLegend: mainwidth * .05\n    });\n\n    // not rendering this table for right now, left all the code in place though. maybe we use it eventually\n    // var table = tabulate(computedData, ["F1", "PRECISION","RECALL","ACCURACY"]);\n}\n\n/**\n   scatterplot function to go to plots.js to be reused\n*/\nfunction bivariatePlot(x_Axis, y_Axis, x_Axis_name, y_Axis_name) {\n    d3.select("#setxMiddle").html("");\n    d3.select("#setxMiddle").select("svg").remove();\n\n    var mainwidth = byId(\'main\').clientWidth;\n    var mainheight = byId(\'main\').clientHeight;\n\n    // scatter plot\n    var data_plot = [];\n    var nanCount = 0;\n    for (var i = 0; i < x_Axis.length; i++) {\n        if (isNaN(x_Axis[i]) || isNaN(y_Axis[i])) {\n            nanCount++;\n        } else {\n            var newNumber1 = x_Axis[i];\n            var newNumber2 = y_Axis[i];\n            data_plot.push({ xaxis: newNumber1, yaxis: newNumber2, score: Math.random() * 100 });\n        }\n    }\n\n    var margin = { top: 35, right: 35, bottom: 35, left: 35 },\n        width = mainwidth * .25 - margin.left - margin.right,\n        height = mainwidth * .25 - margin.top - margin.bottom;\n    var padding = 100;\n\n    var min_x = d3.min(data_plot, function (d, i) {\n        return data_plot[i].xaxis;\n    });\n    var max_x = d3.max(data_plot, function (d, i) {\n        return data_plot[i].xaxis;\n    });\n    var avg_x = (max_x - min_x) / 10;\n    var min_y = d3.min(data_plot, function (d, i) {\n        return data_plot[i].yaxis;\n    });\n    var max_y = d3.max(data_plot, function (d, i) {\n        return data_plot[i].yaxis;\n    });\n    var avg_y = (max_y - min_y) / 10;\n\n    var xScale = d3.scale.linear().domain([min_x - avg_x, max_x + avg_x]).range([0, width]);\n\n    var yScale = d3.scale.linear().domain([min_y - avg_y, max_y + avg_y]).range([height, 0]);\n\n    var xAxis = d3.svg.axis().scale(xScale).orient(\'bottom\').tickSize(-height);\n\n    var yAxis = d3.svg.axis().scale(yScale).orient(\'left\').ticks(5).tickSize(-width);\n\n    var zoom = d3.behavior.zoom().x(xScale).y(yScale).scaleExtent([1, 10]).on("zoom", zoomed);\n\n    var chart_scatter = d3.select(\'#setxMiddle\').append(\'svg:svg\').attr(\'width\', width + margin.right + margin.left).attr(\'height\', height + margin.top + margin.bottom);\n    // .call(zoom); dropping this for now, until the line zooms properly\n\n    var main1 = chart_scatter.append(\'g\').attr(\'transform\', \'translate(\' + margin.left + \',\' + margin.top + \')\').attr(\'width\', width + margin.right + margin.left).attr(\'height\', height + margin.top + margin.bottom).attr(\'class\', \'main\');\n\n    var gX = main1.append(\'g\').attr(\'transform\', \'translate(0,\' + height + \')\').attr(\'class\', \'x axis\').call(xAxis);\n\n    var gY = main1.append(\'g\').attr(\'transform\', \'translate(0,0)\').attr(\'class\', \'y axis\').call(yAxis);\n\n    var clip = main1.append("defs").append("svg:clipPath").attr("id", "clip").append("svg:rect").attr("id", "clip-rect").attr("x", "0").attr("y", "0").attr(\'width\', width).attr(\'height\', height);\n\n    main1.append("g").attr("clip-path", "url(#clip)").selectAll("circle").data(data_plot).enter().append("circle").attr("cx", function (d, i) {\n        return xScale(data_plot[i].xaxis);\n    }).attr("cy", function (d, i) {\n        return yScale(data_plot[i].yaxis);\n    }).attr("r", 2).style("fill", "#B71C1C");\n\n    chart_scatter.append("text").attr("text-anchor", "middle") // this makes it easy to centre the text as the transform is applied to the anchor\n    .attr("transform", "translate(" + padding / 5 + "," + height / 2 + ")rotate(-90)") // text is drawn off the screen top left, move down and out and rotate\n    .text(y_Axis_name).style("fill", "#424242").style("text-indent", "20px").style("font-size", "12px").style("font-weight", "bold");\n\n    chart_scatter.append("text").attr("text-anchor", "middle") // this makes it easy to centre the text as the transform is applied to the anchor\n    .attr("transform", "translate(" + width / 2 + "," + (height + padding / 2) + ")") // centre below axis\n    .text(x_Axis_name).style("fill", "#424242").style("text-indent", "20px").style("font-size", "12px").style("font-weight", "bold");\n\n    main1.append("line").attr("x1", xScale(min_x)).attr("y1", yScale(min_x)).attr("x2", xScale(max_x)).attr("y2", yScale(max_x)).attr("stroke-width", 2).attr("stroke", "black");\n\n    function zoomed() {\n        var panX = d3.event.translate[0];\n        var panY = d3.event.translate[1];\n        var scale = d3.event.scale;\n\n        panX = panX > 10 ? 10 : panX;\n        var maxX = -(scale - 1) * width - 10;\n        panX = panX < maxX ? maxX : panX;\n\n        panY = panY > 10 ? 10 : panY;\n        var maxY = -(scale - 1) * height - 10;\n        panY = panY < maxY ? maxY : panY;\n\n        zoom.translate([panX, panY]);\n\n        main1.select(".x.axis").call(xAxis);\n        main1.select(".y.axis").call(yAxis);\n        main1.selectAll("circle").attr("cx", function (d, i) {\n            console.log("circle x ", xScale(5));\n            return xScale(data_plot[i].xaxis);\n        }).attr("cy", function (d, i) {\n            return yScale(data_plot[i].yaxis);\n        }).attr("r", 2.5).style("fill", "#B71C1C");\n\n        // below doesn\'t work, so I\'m just dropping the zoom\n        main1.select("line").attr("x1", function (d, i) {\n            return xScale(min_x);\n        }).attr("y1", function (d, i) {\n            return xScale(min_x);\n        }).attr("x2", function (d, i) {\n            return xScale(max_x);\n        }).attr("y2", function (d, i) {\n            return yScale(max_x);\n        }).attr("stroke-width", 2).attr("stroke", "black");\n    }\n    //  d3.select("#NAcount").text("There are " + nanCount + " number of NA values in the relation.");\n}\n\n/** needs doc */\nfunction setxTable(features) {\n    function tabulate(data, columns) {\n        var table = d3.select(\'#setxRightBottomLeft\').append(\'table\');\n        var thead = table.append(\'thead\');\n        var tbody = table.append(\'tbody\');\n\n        // append the header row\n        thead.append(\'tr\').selectAll(\'th\').data(columns).enter().append(\'th\').text(function (column) {\n            return column;\n        });\n\n        // create a row for each object in the data\n        var rows = tbody.selectAll(\'tr\').data(data).enter().append(\'tr\');\n\n        // create a cell in each row for each column\n        var cells = rows.selectAll(\'td\').data(function (row) {\n            return columns.map(function (column) {\n                return { column: column, value: row[column] };\n            });\n        }).enter().append(\'td\').text(function (d) {\n            return d.value;\n        }).attr(\'id\', function (d, i) {\n            var rowname = this.parentElement.firstChild.innerText;\n            return rowname + d.column;\n        });\n\n        return table;\n    }\n\n    var mydata = [];\n    for (var i = 0; i < features.length; i++) {\n        if (allNodes[findNodeIndex(features[i])].valid == 0) {\n            xval = 0;\n            x1val = 0;\n            mydata.push({ "Variables": features[i], "From": xval, "To": x1val });\n            continue;\n        }\n\n        var myi = i + 1;\n        var mysvg = features[i] + "_setxLeft_" + myi;\n        var xval = byId(mysvg).querySelector(\'.xval\').innerHTML;\n        var x1val = byId(mysvg).querySelector(\'.x1val\').innerHTML;\n        xval = xval.split("x: ").pop();\n        x1val = x1val.split("x1: ").pop();\n        console.log(xval);\n        console.log(mysvg);\n\n        mydata.push({ "Variables": features[i], "From": xval, "To": x1val });\n    }\n\n    // render the table(s)\n    tabulate(mydata, [\'Variables\', \'From\', \'To\']); // 2 column table\n}\n\n/**\n  rpc ExportPipeline(PipelineExportRequest) returns (Response) {}\n*/\nasync function exportpipeline(pipelineId) {\n    console.log(pipelineId);\n    var res = await makeRequest(D3M_SVC_URL + \'exportpipeline\', { pipelineId: pipelineId, context: apiSession(zparams.zsessionid), pipelineExecUri: \'<<EXECUTABLE_URI>>\' });\n    res && console.log(\'Executable for \' + pipelineId + \' has been written\');\n}\n\n/** needs doc */\nfunction deletepipeline() {\n    console.log("DELETE CALLED");\n}\n\n/**\n   D3M API HELPERS\n   because these get built in various places, pulling them out for easy manipulation\n*/\nfunction apiFeature(vars, uri) {\n    var out = [];\n    for (var i = 0; i < vars.length; i++) {\n        out.push({ featureId: vars[i], dataUri: uri });\n    }\n    return out;\n}\n\n/** needs doc */\nfunction apiFeatureShortPath(vars, uri) {\n    var out = [];\n    var shortUri = uri.substring(0, uri.lastIndexOf("/"));\n    for (var i = 0; i < vars.length; i++) {\n        out.push({ featureId: vars[i], dataUri: shortUri });\n    }\n    return out;\n}\n\n/**\n   silly but perhaps useful if in the future SessionContext requires more things (as suggest by core)\n*/\nfunction apiSession(context) {\n    return { session_id: context };\n}\n\n/**\n *  Send a status message to the TA3 console\n */\nfunction ta3_search_message(user_msg) {\n\n    var ta3_search_message = { \'message\': user_msg };\n\n    var end_search_url = \'ta3-search/send-reviewer-message\';\n\n    try {\n        var res = _mithril2.default.request(end_search_url, { method: \'POST\', data: ta3_search_message });\n        console.log(\'ta3_search_message succeeded:\' + res);\n    } catch (err) {\n        console.log(\'ta3_search_message failed: \' + err);\n    }\n}\n\nfunction test_msg_ta3_search() {}\n//end_ta3_search(true, \'it worked!\');\n//end_ta3_search(false, \'it failed!\');\n//ta3_search_message(\'just sending a message!\');\n\n\n/**\n *  End the TA3 search.  This sends a message\n *  to the ta3_search console as well as message\n *  for the console to exit with a:\n *  - return code 0 for success\n *  - return code -1 for failure\n *\n *  > is_success - boolean\n *  > user_msg - string sent to the console\n */\nfunction end_ta3_search(is_success, user_msg) {\n\n    var end_search_msg = { \'is_success\': is_success,\n        \'message\': user_msg };\n\n    var end_search_url = \'ta3-search/end-search\';\n\n    try {\n        var res = _mithril2.default.request(end_search_url, { method: \'POST\', data: end_search_msg });\n        console.log(\'end_ta3_search succeeded:\' + res);\n    } catch (err) {\n        console.log(\'end_ta3_search failed: \' + err);\n    }\n}\n\n/**\n *  record user metadata\n */\nvar recorder_cnt = 0;\nvar save_workspace_url = \'/workspaces/record-user-workspace\';\n\nfunction record_user_metadata() {\n\n    // (1) Set domain identifier: differs for D3M, Dataverse, etc\n    //\n    var domain_identifier = \'unknown!\';\n    if (IS_D3M_DOMAIN) {\n        // domain specific identifier\n        domain_identifier = domainIdentifier;\n    } /*else if (IS_DATAVERSE_DOMAIN){\n       domain_identifier = \'TODO: DV IDENTIFIER\';\n      }else if (IS_EVENTDATA_DOMAIN){\n       domain_identifier = \'TODO: EVENTDATA IDENTIFIER\';\n      }*/\n\n    if (zparams == null) {\n        console.log(\'No workspace recording. zparams not defined\');\n        return;\n    }\n    if (allNodes == null) {\n        console.log(\'No workspace recording. zparams not defined\');\n        return;\n    }\n\n    // (2) Format workspace data\n    //\n    var workspace_data = { \'app_domain\': APP_DOMAIN,\n        \'domain_identifier\': domain_identifier,\n        \'allnodes\': allNodes,\n        \'zparams\': zparams\n\n        //console.log(\'workspace_data: \' + workspace_data);\n\n        // (3) Save workspace data\n        //\n    };try {\n        var res = _mithril2.default.request(save_workspace_url, { method: \'POST\', data: workspace_data });\n        recorder_cnt++;\n        console.log(\'Session recorded: (cnt: \' + recorder_cnt + \') \' + res);\n    } catch (err) {\n        console.log(\'record_user_metadata failed: \' + err);\n    }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvYXBwL2FwcC5qcz9mNTEyIl0sIm5hbWVzIjpbIm1haW4iLCJmaW5kTm9kZUluZGV4IiwiZmluZE5vZGUiLCJjbGlja1ZhciIsImdldFZhcmlhYmxlRGF0YSIsImZvcmNlU3dpdGNoIiwiaGVscG1hdGVyaWFscyIsImxvY2tEZXNjcmlwdGlvbiIsInpQb3AiLCJkb3dubG9hZEluY29tcGxldGUiLCJlc3RpbWF0ZSIsInRhMnN0dWZmIiwibWFrZVJlcXVlc3QiLCJsZWdlbmQiLCJlcmFzZSIsInRhYkxlZnQiLCJ0YWJSaWdodCIsInBhbmVsUGxvdHMiLCJib3JkZXJTdGF0ZSIsInN1YnNldFNlbGVjdCIsImVuZHNlc3Npb24iLCJsaXN0cGlwZWxpbmVzIiwiZXhlY3V0ZXBpcGVsaW5lIiwiZXhwYW5kcmlnaHRwYW5lbCIsInJlc3VsdHNwbG90aW5pdCIsImdlbmNvbmZkYXRhIiwiY29uZnVzaW9ubWF0cml4IiwiYml2YXJpYXRlUGxvdCIsInNldHhUYWJsZSIsImV4cG9ydHBpcGVsaW5lIiwiZGVsZXRlcGlwZWxpbmUiLCJ0YTNfc2VhcmNoX21lc3NhZ2UiLCJ0ZXN0X21zZ190YTNfc2VhcmNoIiwiZW5kX3RhM19zZWFyY2giLCJyZWNvcmRfdXNlcl9tZXRhZGF0YSIsImlzX3Jlc3VsdHNfbW9kZSIsImNkYiIsIlBST0RVQ1RJT04iLCJsb2ciLCJrIiwidHV0b3JpYWxfbW9kZSIsImZpcnN0X2xvYWQiLCJjb2xvcnMiLCJkMyIsInNjYWxlIiwiY2F0ZWdvcnkyMCIsImNzQ29sb3IiLCJkdkNvbG9yIiwiZ3IxQ29sb3IiLCJncjFPcGFjaXR5IiwiZ3IyQ29sb3IiLCJncjJPcGFjaXR5IiwiZ3JheUNvbG9yIiwibm9tQ29sb3IiLCJ2YXJDb2xvciIsInRhZ2dlZENvbG9yIiwidGltZUNvbG9yIiwibGVmdHRhYiIsInN1YnNldCIsInN1bW1hcnlIb2xkIiwicmlnaHR0YWIiLCJ0IiwidHlwZVRyYW5zZm9ybSIsInRyYW5zZm9ybUxpc3QiLCJzcGxpdCIsInRyYW5zZm9ybVZhciIsInRyYW5zIiwicHJlcHJvY2VzcyIsInNwYWNlcyIsImxheW91dEFkZCIsImxheW91dE1vdmUiLCJSQURJVVMiLCJpbmQxIiwiTWF0aCIsImNvcyIsInNpbiIsImluZDIiLCJteXNwYWNlIiwiZm9yY2V0b2dnbGUiLCJsb2NrdG9nZ2xlIiwicHJpdiIsInN3YW5kaXZlIiwiZmFpbHNldCIsImxvZ0FycmF5IiwienBhcmFtcyIsInpkYXRhIiwiemVkZ2VzIiwienRpbWUiLCJ6bm9tIiwiemNyb3NzIiwiem1vZGVsIiwienZhcnMiLCJ6ZHYiLCJ6Z3JvdXAxIiwiemdyb3VwMiIsInpkYXRhdXJsIiwiemQzbWRhdGEiLCJ6ZDNtdGFyZ2V0IiwienN1YnNldCIsInpzZXR4Iiwiem1vZGVsY291bnQiLCJ6cGxvdCIsInpzZXNzaW9uaWQiLCJ6ZGF0YWNpdGUiLCJ6Y3Jvc3N0YWIiLCJtb2RlbENvdW50IiwidmFsdWVLZXkiLCJhbGxOb2RlcyIsImFsbFJlc3VsdHMiLCJub2RlcyIsImxpbmtzIiwibW9kcyIsImVzdGltYXRlZCIsInJpZ2h0Q2xpY2tMYXN0Iiwic2VsSW50ZXJhY3QiLCJjYWxsSGlzdG9yeSIsIm15dGFyZ2V0IiwiY29uZmlndXJhdGlvbnMiLCJkYXRhc2NoZW1hIiwiZG9tYWluSWRlbnRpZmllciIsImQzbVRhc2tUeXBlIiwidGFza1R5cGVVbmRlZmluZWQiLCJjbGFzc2lmaWNhdGlvbiIsInJlZ3Jlc3Npb24iLCJjbHVzdGVyaW5nIiwibGlua1ByZWRpY3Rpb24iLCJ2ZXJ0ZXhOb21pbmF0aW9uIiwiY29tbXVuaXR5RGV0ZWN0aW9uIiwiZ3JhcGhDbHVzdGVyaW5nIiwiZ3JhcGhNYXRjaGluZyIsInRpbWVTZXJpZXNGb3JlY2FzdGluZyIsImNvbGxhYm9yYXRpdmVGaWx0ZXJpbmciLCJkM21UYXNrU3VidHlwZSIsInRhc2tTdWJ0eXBlVW5kZWZpbmVkIiwic3VidHlwZU5vbmUiLCJiaW5hcnkiLCJtdWx0aUNsYXNzIiwibXVsdGlMYWJlbCIsInVuaXZhcmlhdGUiLCJtdWx0aXZhcmlhdGUiLCJvdmVybGFwcGluZyIsIm5vbk92ZXJsYXBwaW5nIiwiZDNtTWV0cmljcyIsIm1ldHJpY1VuZGVmaW5lZCIsImV4ZWN1dGlvblRpbWUiLCJhY2N1cmFjeSIsImYxIiwiZjFNaWNybyIsImYxTWFjcm8iLCJyb2NBdWMiLCJyb2NBdWNNaWNybyIsInJvY0F1Y01hY3JvIiwibWVhblNxdWFyZWRFcnJvciIsInJvb3RNZWFuU3F1YXJlZEVycm9yIiwicm9vdE1lYW5TcXVhcmVkRXJyb3JBdmciLCJtZWFuQWJzb2x1dGVFcnJvciIsInJTcXVhcmVkIiwibm9ybWFsaXplZE11dHVhbEluZm9ybWF0aW9uIiwiamFjY2FyZFNpbWlsYXJpdHlTY29yZSIsImQzbVByb2JsZW1EZXNjcmlwdGlvbiIsInRhc2tUeXBlIiwidGFza1N1YnR5cGUiLCJtZXRyaWMiLCJ0YXNrRGVzY3JpcHRpb24iLCJzdmciLCJ3aWR0aCIsImhlaWdodCIsImRpdiIsInNlbGVjdExhZGRhIiwiZXN0aW1hdGVMYWRkYSIsImFyYyIsInN0YXJ0IiwiZW5kIiwiaW5uZXJSYWRpdXMiLCJvdXRlclJhZGl1cyIsInN0YXJ0QW5nbGUiLCJlbmRBbmdsZSIsImFyYzAiLCJhcmMxIiwiYXJjMiIsImFyYzMiLCJhcmM0IiwiYXJjSW5kIiwiYXJjbGltaXRzIiwiYXJjSW5kMUxpbWl0cyIsImFyY0luZDJMaW1pdHMiLCJhcmNJbmQxIiwiYXJjSW5kMiIsImJ5SWQiLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwiaWQiLCJyZXNldCIsInJlbG9hZFBhZ2UiLCJsb2NhdGlvbiIsInJlbG9hZCIsInJlc3RhcnQiLCJkYXRhdXJsIiwibG9hZCIsImhvbGQiLCJsYWJsQXJyYXkiLCJkM21Sb290UGF0aCIsImQzbURhdGFOYW1lIiwiZDNtUHJlcHJvY2VzcyIsImQzbURhdGEiLCJkM21QUyIsImQzbURTIiwicFVSTCIsIklTX0QzTV9ET01BSU4iLCJyZXMiLCJyZXF1ZXN0IiwibWV0aG9kIiwidXJsIiwiY29uc29sZSIsIkpTT04iLCJwYXJzZSIsInN0cmluZ2lmeSIsInRyYWluaW5nX2RhdGFfcm9vdCIsInJlcGxhY2UiLCJuYW1lIiwic291cmNlX3VybCIsImNvbmZpZ191cmwiLCJkZXNjcmlwdGlvbiIsInNldCIsImZpZWxkIiwidmFsIiwiZGF0YSIsImV4aXN0cyIsInBhdGgiLCJpbnB1dHMiLCJ0YXJnZXRzIiwiY29sTmFtZSIsInRlbXAiLCJ4bWwiLCJkb2N1bWVudEVsZW1lbnQiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsImNoaWxkTm9kZXMiLCJub2RlVmFsdWUiLCJjaXRlIiwiJCIsInRleHQiLCJkYXRhbmFtZSIsInNlbGVjdCIsImh0bWwiLCJhYm91dCIsInRhc2tTdWJUeXBlIiwicGVyZm9ybWFuY2VNZXRyaWNzIiwiZGVzY3JpcHRpb25GaWxlIiwiY2xpY2siLCJpbmNsdWRlcyIsInRvVXBwZXJDYXNlIiwidHJhaW5EYXRhIiwidHJhaW5UYXJnZXRzIiwiZm9yRWFjaCIsInZhcnMiLCJwdXNoIiwidiIsInZhck5hbWUiLCJsZW5ndGgiLCJhbGVydCIsImNsYXNzTGlzdCIsImFkZCIsInN0eWxlIiwiYmFja2dyb3VuZENvbG9yIiwiZmlsdGVyIiwiaGFzT3duUHJvcGVydHkiLCJrZXkiLCJfIiwiRDNNX1NWQ19VUkwiLCJ1c2VyX2FnZW50IiwidmVyc2lvbiIsImNvbnRleHQiLCJzZXNzaW9uSWQiLCJzdGVwIiwidGFyZ2V0IiwicGxhY2VtZW50IiwidGl0bGUiLCJjb250ZW50Iiwic2hvd0NUQUJ1dHRvbiIsImN0YUxhYmVsIiwib25DVEEiLCJlbmRUb3VyIiwic3RhcnRUb3VyIiwiaTE4biIsImRvbmVCdG4iLCJzaG93Q2xvc2VCdXR0b24iLCJzY3JvbGxEdXJhdGlvbiIsIm9uRW5kIiwic3RlcHMiLCJyZWFkIiwiZGF0YXNldCIsInByaXZhdGUiLCJPYmplY3QiLCJrZXlzIiwidmFyaWFibGVzIiwiUk9PS19TVkNfVVJMIiwianNvbl9pbnB1dCIsImRhdGFzdHViIiwiZGF0YWxvYyIsInRhcmdldGxvYyIsIkZvcm1EYXRhIiwiaSIsIm9iaiIsInJlZmxleGl2ZSIsImxhYmwiLCJjb3VudCIsIm5vZGVDb2wiLCJiYXNlQ29sIiwic3Ryb2tlQ29sb3IiLCJzdHJva2VXaWR0aCIsInN1YnNldHBsb3QiLCJzdWJzZXRyYW5nZSIsInNldHhwbG90Iiwic2V0eHZhbHMiLCJncmF5b3V0IiwiZ3JvdXAxIiwiZ3JvdXAyIiwiZm9yZWZyb250IiwialF1ZXJ5IiwiZXh0ZW5kIiwiZGF0YXZhcnMiLCJkYXRhUmVzb3VyY2VzIiwiY29sdW1ucyIsIm15aSIsImFzc2lnbiIsImQzbURlc2NyaXB0aW9uIiwidG9nZ2xlUmlnaHRCdXR0b25zIiwibGF5b3V0IiwiZGF0YURvd25sb2FkIiwiZmlsZWlkIiwiaG9zdG5hbWUiLCJkZGl1cmwiLCJhcGlrZXkiLCJtc2ciLCJFcnJvciIsImRhdGF2ZXJzZXVybCIsIkRBVEFWRVJTRV9VUkwiLCJ0ZW1wV2lkdGgiLCJzdWJzdHJpbmciLCJ3aW5kb3ciLCJMYWRkYSIsImNyZWF0ZSIsIm1ldGFkYXRhdXJsIiwiJGZpbGwiLCJvcCIsImQxIiwiZDIiLCJ0cmFuc2l0aW9uIiwiYXR0ciIsImRlbGF5IiwiZHVyYXRpb24iLCJmaWxsIiwiZCIsImZpbGxUaGlzIiwic2VsZiIsImRlbCIsImFyciIsImlkeCIsImluZGV4T2YiLCJzcGxpY2UiLCJ6cGFyYW1zUmVzZXQiLCJ4IiwidjIiLCJteVZhbHVlcyIsImFwcGVuZCIsImxpbmUiLCJsaW5lMiIsInZpc2JhY2tncm91bmQiLCJ2aXMyYmFja2dyb3VuZCIsInZpcyIsInZpczIiLCJqIiwiaWkiLCJzZWxlY3RNZSIsImNvbmNhdCIsImhleFRvUmdiYSIsIm15c3JjIiwibm9kZUluZGV4IiwibXl0Z3QiLCJzb3VyY2UiLCJsZWZ0IiwicmlnaHQiLCJzbGljZSIsImZvcmNlIiwic2l6ZSIsImxpbmtEaXN0YW5jZSIsImNoYXJnZSIsIm9uIiwidGljayIsImRyYWdfbGluZSIsInNlbGVjdEFsbCIsImNpcmNsZSIsInNlbGVjdGVkX25vZGUiLCJzZWxlY3RlZF9saW5rIiwibW91c2Vkb3duX2xpbmsiLCJtb3VzZWRvd25fbm9kZSIsIm1vdXNldXBfbm9kZSIsInJlc2V0TW91c2VWYXJzIiwiZmluZGNvb3JkcyIsImZpbmRuYW1lcyIsImFsbG5hbWVzIiwiY29vcmRzIiwibGVuZ3RoZW4iLCJmY29vcmRzIiwiQXJyYXkiLCJhZGRsb2NhdGlvbiIsImRlbHRheCIsImRlbHRheSIsImRlbHRhIiwibGVuZ3RoZW5jb29yZHMiLCJtYXAiLCJ5IiwiZ3IxY29vcmRzIiwiZ3IyY29vcmRzIiwiZGVwY29vcmRzIiwibXlodWxsIiwiZ2VvbSIsImh1bGwiLCJqb2luIiwicCIsImphbWVzY2VudHJvaWQiLCJxIiwibGRlbHRhWCIsImxkZWx0YVkiLCJsZGlzdCIsInNxcnQiLCJsbm9ybVgiLCJsbm9ybVkiLCJsc291cmNlUGFkZGluZyIsImx0YXJnZXRQYWRkaW5nIiwic2lnbiIsIm4iLCJtaW4iLCJhbHBoYSIsImRlbHRhWCIsImRlbHRhWSIsImRpc3QiLCJub3JtWCIsIm5vcm1ZIiwic291cmNlUGFkZGluZyIsInRhcmdldFBhZGRpbmciLCJzb3VyY2VYIiwic291cmNlWSIsInRhcmdldFgiLCJ0YXJnZXRZIiwic2V0UGViYmxlUmFkaXVzIiwibXlDb2xvciIsInJnYiIsInRvU3RyaW5nIiwiY2xhc3NOYW1lIiwiaW5uZXJIVE1MIiwidXBkYXRlU2NoZW1hIiwiJGxpbmtzIiwiY2FsbCIsImRyYWciLCJncmF2aXR5Iiwic2V0UGViYmxlQ2hhcmdlIiwibGlua1N0cmVuZ3RoIiwicmVzdW1lIiwiY2xhc3NlZCIsImVudGVyIiwiZXhpdCIsInJlbW92ZSIsImciLCJlYWNoIiwicGxvdHR5cGUiLCJzdHIiLCJzZXRDb2xvcnMiLCJkZWZhdWx0TnVtY2hhciIsImV2ZW50Iiwic3RvcFByb3BhZ2F0aW9uIiwicHJldmVudERlZmF1bHQiLCJtb3VzZW1vdmUiLCJkaXJlY3Rpb24iLCJsaW5rIiwidmFyU3VtbWFyeSIsInNldEF0dHJpYnV0ZSIsInNlbGVjdGVkSW5kZXgiLCJyZWRyYXciLCJldnQiLCJ0cmFuc1BhcnNlIiwicGFyZW50IiwiZmFkZU91dCIsInRyYW5zZm9ybSIsImZhZGVJbiIsIm1vdXNlZG93biIsImN0cmxLZXkiLCJtb3VzZSIsIm1vdXNldXAiLCJmYWtlQ2xpY2siLCJjbGlja19ldiIsImNyZWF0ZUV2ZW50IiwiaW5pdEV2ZW50IiwiY2xpY2tJRCIsImRpc3BhdGNoRXZlbnQiLCJmaW5kIiwiJG5vZGVzIiwid2hvbGUiLCJub2RlIiwibm9kZU5hbWUiLCJ1cGRhdGVOb2RlIiwibmFtZXMiLCJpbmRleCIsImwiLCJlbGVtIiwianNvbiIsInR5cGUiLCJ3aW4iLCJvcGVuIiwiZm9jdXMiLCJxdWVyeVNlbGVjdG9yQWxsIiwiem5hdHVyZSIsIm5hdHVyZSIsInNyY3RndCIsInRhYnVsYXRlIiwiZGl2aWQiLCJ0YWJsZSIsInRoZWFkIiwidGJvZHkiLCJjb2x1bW4iLCJyb3dzIiwiY2VsbHMiLCJyb3ciLCJ2YWx1ZSIsIm15cm93IiwicGFyZW50RWxlbWVudCIsImFsbFBpcGVsaW5lSW5mbyIsImZpcnN0Q2hpbGQiLCJpbm5lclRleHQiLCJkdnZhbHVlcyIsIm9uUGlwZWxpbmVDcmVhdGUiLCJQaXBlbGluZUNyZWF0ZVJlc3VsdCIsInN0b3AiLCJyZW1vdmVDbGFzcyIsImFkZENsYXNzIiwicGlwZWxpbmVJZCIsInJlc3VsdHN0YWJsZSIsInJlc3BvbnNlSW5mbyIsInN0YXR1cyIsImRldGFpbHMiLCJteWlkIiwibXltZXRyaWMiLCJteXZhbCIsIm15c2NvcmVzIiwicGlwZWxpbmVJbmZvIiwic2NvcmVzIiwidG9GaXhlZCIsIlBpcGVsaW5lSUQiLCJwaXBlbGluZV9pZHMiLCJDcmVhdGVQaXBlbGluZURhdGEiLCJwcmVkaWN0b3JzIiwiZGVwdmFyIiwiYXBpU2Vzc2lvbiIsInVyaSIsImZlYXR1cmVzIiwidHJhaW5GZWF0dXJlcyIsImFwaUZlYXR1cmVTaG9ydFBhdGgiLCJ0YXJnZXRGZWF0dXJlcyIsInRhc2siLCJtZXRyaWNzIiwibWF4UGlwZWxpbmVzIiwiYnRuIiwiYWxsVmFycyIsIm1vZENvbCIsInJlbW92ZUNoaWxkIiwidHJpZ2dlciIsIm1vZGVsIiwiaW5zZXJ0IiwiYSIsImIiLCJzdWJzdHIiLCJ2aXoiLCJyQ2FsbCIsInNob3dMb2ciLCJteXZraSIsInNlc3Npb25pZCIsImhyZWYiLCJteW0iLCJyZW1vdmVLaWRzIiwiZmlsZWxpc3QiLCJpbWFnZXMiLCJ6ZmlnIiwiY3JlYXRlRWxlbWVudCIsImFwcGVuZENoaWxkIiwicmVzdWx0c0FycmF5Iiwic3VtSW5mbyIsImNvbG5hbWVzIiwibXlOdW0iLCJOdW1iZXIiLCJpc05hTiIsInRvUHJlY2lzaW9uIiwib3V0MiIsInQyIiwiazIiLCJzdWJNZTIiLCJpbmRleGVkIiwibTIiLCJtYXRjaCIsInJlIiwiUmVnRXhwIiwicyIsInNlYXJjaCIsImZyb20iLCJ0byIsIm15biIsIm91dHR5cGVzIiwidmFybmFtZXNUeXBlcyIsImludGVydmFsIiwibnVtY2hhciIsInBsb3R2YWx1ZXMiLCJwbG90eCIsInR5cGVTdHVmZiIsImVyciIsIndhcm4iLCJmdW5jIiwic3Vic2V0ZWQiLCJuZXdWYXIiLCJlcnJvciIsImpzb25kYXRhIiwibXlJbmRleCIsIm9iajEiLCJkZWZhdWx0SW50ZXJ2YWwiLCJkZWZhdWx0TmF0dXJlIiwiZGVmYXVsdEJpbmFyeSIsIndhcm5pbmciLCJjaGlsZHJlbiIsInRhYiIsImRpc3BsYXkiLCJwYW5lbCIsImNscyIsInRvZ2dsZVIiLCJleHBhbmQiLCJnZXRBdHRyaWJ1dGUiLCJ0b2dnbGVSRnVsbCIsInN1bW1hcnkiLCJ0MSIsInJpbnQiLCJmb3JtYXQiLCJtZWFuQ0kiLCJtZWFuIiwibG93ZXJCb3VuZCIsInVwcGVyQm91bmQiLCJtZWRpYW4iLCJtb2RlIiwiZnJlcW1vZGUiLCJtaWQiLCJmcmVxbWlkIiwiZmV3ZXN0IiwiZnJlcWZld2VzdCIsInNkIiwibWF4IiwiaW52YWxpZCIsInZhbGlkIiwidW5pcXVlcyIsImhlcmZpbmRhaGwiLCJlIiwicG9wb3ZlckNvbnRlbnQiLCJpbnQiLCJwcmVjIiwiaWRzIiwicmVnc3RyIiwibXluYW1lIiwiZXhlYyIsIm5vZGVpZCIsInBhcnNlSW50IiwiaGV4IiwiYyIsInRlbXBpbmRleCIsImNvbG9yIiwiaXNBcnJheSIsImR2bmFtZSIsIm5ncm91cDEiLCJuZ3JvdXAyIiwiY3NzIiwic3Vic2V0RW1wdHkiLCJncmF5T3V0cyIsIm15Tm9kZXMiLCJteVBhcmFtcyIsIm15VHJhbnMiLCJteUZvcmNlIiwibXlQcmVwcm9jZXNzIiwibXlMb2ciLCJteUhpc3RvcnkiLCJ2YXJPdXQiLCJ1bmRlZmluZWQiLCJwbG90eSIsInJlUGxvdCIsIndzIiwiZm4iLCJkM0NsaWNrIiwiaW5pdE1vdXNlRXZlbnQiLCJteXN0YXR1cyIsImNvZGUiLCJwaXBlcyIsInBpcGVsaW5lSWRzIiwidGFibGVyb3ciLCJxdWVyeVNlbGVjdG9yIiwianNvbm91dCIsInByZWRpY3RGZWF0dXJlcyIsImFwaUZlYXR1cmUiLCJteWRhdGEiLCJteW1lYW4iLCJ1cGRhdGVzIiwibG9va3VwIiwicmVwbGFjZVByb2JsZW1TY2hlbWFGaWVsZCIsImNvb3JkIiwibWlueCIsIm1heHgiLCJtaW55IiwibWF4eSIsInVwcGVyc2l6ZSIsIm5nMSIsIm5nMiIsIm1heG5nIiwic2V0V2lkdGhzIiwiYnRucyIsImV4cGFuZHdpZHRoIiwic2hyaW5rd2lkdGgiLCJsaXMiLCJsaSIsImFkZEV2ZW50TGlzdGVuZXIiLCJwaWQiLCJwcmVkZmlsZSIsInByZWRpY3RSZXN1bHREYXRhIiwiZmlsZV8xIiwicHJlZHZhbHMiLCJwcmVkcyIsInhkYXRhIiwieWRhdGEiLCJyYW5kb21udW1iZXIiLCJmbG9vciIsInJhbmRvbSIsIm9ubHlVbmlxdWUiLCJteWNvdW50cyIsIm15cGFpcnMiLCJteXVuaXF1ZXMiLCJ0ZW1wY291bnQiLCJ0ZW1wcGFpciIsIm15aW5kZXgiLCJjb25mZGF0YSIsIm1hdHJpeGRhdGEiLCJjbGFzc2VzIiwibWFpbndpZHRoIiwiY2xpZW50V2lkdGgiLCJtYWluaGVpZ2h0IiwiY2xpZW50SGVpZ2h0IiwiY29uZGl2IiwibWFyZ2luTGVmdCIsImZsb2F0IiwibGVnZGl2IiwibWFyZ2luIiwidG9wIiwiYm90dG9tIiwiTWF0cml4Iiwib3B0aW9ucyIsImNvbnRhaW5lciIsImxhYmVsc0RhdGEiLCJsYWJlbHMiLCJzdGFydENvbG9yIiwic3RhcnRfY29sb3IiLCJlbmRDb2xvciIsImVuZF9jb2xvciIsIndpZHRoTGVnZW5kIiwibWF4VmFsdWUiLCJsYXllciIsIm1pblZhbHVlIiwibnVtcm93cyIsIm51bWNvbHMiLCJiYWNrZ3JvdW5kIiwib3JkaW5hbCIsImRvbWFpbiIsInJhbmdlIiwicmFuZ2VCYW5kcyIsImNvbG9yTWFwIiwibGluZWFyIiwiY2VsbCIsInJhbmdlQmFuZCIsImNvbHVtbkxhYmVscyIsInJvd0xhYmVscyIsInlBeGlzIiwiYXhpcyIsIm9yaWVudCIsInRwIiwiZnAiLCJ0biIsInByZWNpc2lvbiIsInJlY2FsbCIsInJvdW5kIiwiY29tcHV0ZWREYXRhIiwieF9BeGlzIiwieV9BeGlzIiwieF9BeGlzX25hbWUiLCJ5X0F4aXNfbmFtZSIsImRhdGFfcGxvdCIsIm5hbkNvdW50IiwibmV3TnVtYmVyMSIsIm5ld051bWJlcjIiLCJ4YXhpcyIsInlheGlzIiwic2NvcmUiLCJwYWRkaW5nIiwibWluX3giLCJtYXhfeCIsImF2Z194IiwibWluX3kiLCJtYXhfeSIsImF2Z195IiwieFNjYWxlIiwieVNjYWxlIiwieEF4aXMiLCJ0aWNrU2l6ZSIsInRpY2tzIiwiem9vbSIsImJlaGF2aW9yIiwic2NhbGVFeHRlbnQiLCJ6b29tZWQiLCJjaGFydF9zY2F0dGVyIiwibWFpbjEiLCJnWCIsImdZIiwiY2xpcCIsInBhblgiLCJ0cmFuc2xhdGUiLCJwYW5ZIiwibWF4WCIsIm1heFkiLCJyb3duYW1lIiwieHZhbCIsIngxdmFsIiwibXlzdmciLCJwb3AiLCJwaXBlbGluZUV4ZWNVcmkiLCJvdXQiLCJmZWF0dXJlSWQiLCJkYXRhVXJpIiwic2hvcnRVcmkiLCJsYXN0SW5kZXhPZiIsInNlc3Npb25faWQiLCJ1c2VyX21zZyIsImVuZF9zZWFyY2hfdXJsIiwiaXNfc3VjY2VzcyIsImVuZF9zZWFyY2hfbXNnIiwicmVjb3JkZXJfY250Iiwic2F2ZV93b3Jrc3BhY2VfdXJsIiwiZG9tYWluX2lkZW50aWZpZXIiLCJ3b3Jrc3BhY2VfZGF0YSIsIkFQUF9ET01BSU4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7UUFxZmdCQSxJLEdBQUFBLEk7UUFrZ0NBQyxhLEdBQUFBLGE7UUFZQUMsUSxHQUFBQSxRO1FBMENBQyxRLEdBQUFBLFE7UUF5QkFDLGUsR0FBQUEsZTtRQU9BQyxXLEdBQUFBLFc7UUFXQUMsYSxHQUFBQSxhO1FBWUFDLGUsR0FBQUEsZTtRQWtDQUMsSSxHQUFBQSxJO1FBaUtBQyxrQixHQUFBQSxrQjtRQVdNQyxRLEdBQUFBLFE7UUFnSE5DLFEsR0FBQUEsUTtRQW9UTUMsVyxHQUFBQSxXO1FBcUNOQyxNLEdBQUFBLE07UUFRQUMsSyxHQUFBQSxLO1FBVUFDLE8sR0FBQUEsTztRQWFBQyxRLEdBQUFBLFE7UUF5RkFDLFUsR0FBQUEsVTtRQXlKQUMsVyxHQUFBQSxXO1FBc0JBQyxZLEdBQUFBLFk7UUEwTE1DLFUsR0FBQUEsVTtRQWFOQyxhLEdBQUFBLGE7UUFvREFDLGUsR0FBQUEsZTtRQWtHQUMsZ0IsR0FBQUEsZ0I7UUE0REFDLGUsR0FBQUEsZTtRQXNCQUMsVyxHQUFBQSxXO1FBb0RBQyxlLEdBQUFBLGU7UUF3UkFDLGEsR0FBQUEsYTtRQTBMQUMsUyxHQUFBQSxTO1FBa0VNQyxjLEdBQUFBLGM7UUFTTkMsYyxHQUFBQSxjO1FBcUNBQyxrQixHQUFBQSxrQjtRQWVBQyxtQixHQUFBQSxtQjtRQWdCQUMsYyxHQUFBQSxjO1FBdUJBQyxvQixHQUFBQSxvQjs7QUE3bkhoQjs7OztBQUNBOzs7O0FBQ0E7Ozs7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFD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QUFSLENBQVksNkNBQVo7QUFDQTtBQUNEO0FBQ0QsUUFBSXFFLFlBQVksSUFBaEIsRUFBcUI7QUFDbkIwRyxnQkFBUS9LLEdBQVIsQ0FBWSw2Q0FBWjtBQUNBO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBLFFBQUl1eUIsaUJBQWlCLEVBQUMsY0FBY0MsVUFBZjtBQUNDLDZCQUFxQkYsaUJBRHRCO0FBRUMsb0JBQVlqdUIsUUFGYjtBQUdDLG1CQUFXdkI7O0FBRTNCOztBQUVGO0FBQ0E7QUFSaUIsS0FBckIsQ0FTSSxJQUFJO0FBQ0EsWUFBSTZILE1BQU0sa0JBQUVDLE9BQUYsQ0FBVXluQixrQkFBVixFQUE4QixFQUFDeG5CLFFBQVEsTUFBVCxFQUFpQmUsTUFBTTJtQixjQUF2QixFQUE5QixDQUFWO0FBQ0FIO0FBQ0FybkIsZ0JBQVEvSyxHQUFSLENBQVksNkJBQTZCb3lCLFlBQTdCLEdBQTRDLElBQTVDLEdBQW1Eem5CLEdBQS9EO0FBQ0gsS0FKRCxDQUlFLE9BQU9tWixHQUFQLEVBQVk7QUFDVi9ZLGdCQUFRL0ssR0FBUixDQUFZLGtDQUFrQzhqQixHQUE5QztBQUNIO0FBQ04iLCJmaWxlIjoiMS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBob3BzY290Y2ggZnJvbSAnaG9wc2NvdGNoJztcbmltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuaW1wb3J0IHtiYXJzLCBiYXJzTm9kZSwgYmFyc1N1YnNldCwgZGVuc2l0eSwgZGVuc2l0eU5vZGUsIHNlbFZhckNvbG9yfSBmcm9tICcuL3Bsb3RzLmpzJztcblxuLy8gaG9zdG5hbWUgZGVmYXVsdCAtIHRoZSBhcHAgd2lsbCB1c2UgaXQgdG8gb2J0YWluIHRoZSB2YXJpYWJsZSBtZXRhZGF0YVxuLy8gKGRkaSkgYW5kIHByZS1wcm9jZXNzZWQgZGF0YSBpbmZvIGlmIHRoZSBmaWxlIGlkIGlzIHN1cHBsaWVkIGFzIGFuXG4vLyBhcmd1bWVudCAoZm9yIGV4LiwgZ3VpLmh0bWw/ZGZJZD0xNyksIGJ1dCBob3N0bmFtZSBpc24ndC5cbi8vIEVkaXQgaXQgdG8gc3VpdCB5b3VyIGluc3RhbGxhdGlvbi5cbi8vIChOT1RFIHRoYXQgaWYgdGhlIGZpbGUgaWQgaXNuJ3Qgc3VwcGxpZWQsIHRoZSBhcHAgd2lsbCBkZWZhdWx0IHRvIHRoZVxuLy8gbG9jYWwgZmlsZXMgc3BlY2lmaWVkIGJlbG93ISlcbi8vIE5FVzogaXQgaXMgYWxzbyBwb3NzaWJsZSBub3cgdG8gc3VwcGx5IGNvbXBsZXRlIHVybHMgZm9yIHRoZSBkZGkgYW5kXG4vLyB0aGUgdGFiLWRlbGltaXRlZCBkYXRhIGZpbGU7IHRoZSBwYXJhbWV0ZXJzIGFyZSBkZGl1cmwgYW5kIGRhdGF1cmwuXG4vLyBUaGVzZSBuZXcgcGFyYW1ldGVycyBhcmUgb3B0aW9uYWwuIElmIHRoZXkgYXJlIG5vdCBzdXBwbGllZCwgdGhlIGFwcFxuLy8gd2lsbCBnbyB0aGUgb2xkIHJvdXRlIC0gd2lsbCB0cnkgdG8gY29vayBzdGFuZGFyZCBkYXRhdmVyc2UgdXJsc1xuLy8gZm9yIGJvdGggdGhlIGRhdGEgYW5kIG1ldGFkYXRhLCBpZiB0aGUgZmlsZSBpZCBpcyBzdXBwbGllZDsgb3IgdGhlXG4vLyBsb2NhbCBmaWxlcyBpZiBub3RoaW5nIGlzIHN1cHBsaWVkLlxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE5PVEU6IGdsb2JhbCB2YXJpYWJsZXMgYXJlIG5vdyBzZXQgaW4gdGhlIGluZGV4Lmh0bWwgZmlsZS5cbi8vICAgIERldmVsb3BlcnMsIHNlZSAvdGVtcGxhdGUvaW5kZXguaHRtbFxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBsZXQgaXNfcmVzdWx0c19tb2RlID0gZmFsc2U7XG5cbi8vIGZvciBkZWJ1Z2dpbmcgLSBpZiBub3QgaW4gUFJPRFVDVElPTiwgcHJpbnRzIGFyZ3NcbmV4cG9ydCBsZXQgY2RiID0gXyA9PiBQUk9EVUNUSU9OIHx8IGNvbnNvbGUubG9nKC4uLmFyZ3VtZW50cyk7XG5cbmxldCBrID0gNDsgLy8gc3RyZW5ndGggcGFyYW1ldGVyIGZvciBncm91cCBhdHRyYWN0aW9uL3JlcHVsc2lvblxubGV0IHR1dG9yaWFsX21vZGUgPSB0cnVlO1xubGV0IGZpcnN0X2xvYWQgPSB0cnVlO1xuXG4vLyBpbml0aWFsIGNvbG9yIHNjYWxlIHVzZWQgdG8gZXN0YWJsaXNoIHRoZSBpbml0aWFsIGNvbG9ycyBvZiBub2Rlc1xuLy8gYWxsTm9kZXMucHVzaCgpIGJlbG93IGVzdGFibGlzaGVzIGEgZmllbGQgZm9yIHRoZSBtYXN0ZXIgbm9kZSBhcnJheSBhbGxOb2RlcyBjYWxsZWQgXCJub2RlQ29sXCIgYW5kIGFzc2lnbnMgYSBjb2xvciBmcm9tIHRoaXMgc2NhbGUgdG8gdGhhdCBmaWVsZFxuLy8gZXZlcnl0aGluZyB0aGVyZSBhZnRlciBzaG91bGQgcmVmZXIgdG8gdGhlIG5vZGVDb2wgYW5kIG5vdCB0aGUgY29sb3Igc2NhbGUsIHRoaXMgZW5hYmxlcyB1cyB0byB1cGRhdGUgY29sb3JzIGFuZCBwYXNzIHRoZSB2YXJpYWJsZSB0eXBlIHRvIFIgYmFzZWQgb24gaXRzIGNvbG9yaW5nXG5sZXQgY29sb3JzID0gZDMuc2NhbGUuY2F0ZWdvcnkyMCgpO1xuZXhwb3J0IGxldCBjc0NvbG9yID0gJyM0MTk2NDEnO1xuZXhwb3J0IGxldCBkdkNvbG9yID0gJyMyOGE0YzknO1xuZXhwb3J0IGxldCBncjFDb2xvciA9ICcjMTRiZGNjJzsgIC8vIGluaXRpYWxseSB3YXMgIzI0YTRjOScsIGJ1dCB0aGF0IGlzIGR2Q29sb3IsIGFuZCB3ZSB0cmFjayBzb21lIHByb3BlcnRpZXMgYnkgY29sb3IgYXNzdW1pbmcgdGhlbSB1bmlxdWVcbmxldCBncjFPcGFjaXR5ID0gWzAsMV07XG5leHBvcnQgbGV0IGdyMkNvbG9yID0gJyNmZmNjY2MnO1xubGV0IGdyMk9wYWNpdHkgPSBbMCwxXTtcblxubGV0IGdyYXlDb2xvciA9ICcjYzBjMGMwJztcbmV4cG9ydCBsZXQgbm9tQ29sb3IgPSAnI2ZmNjYwMCc7XG5leHBvcnQgbGV0IHZhckNvbG9yID0gJyNmMGY4ZmYnOyAvLyBkMy5yZ2IoXCJhbGljZWJsdWVcIik7XG5sZXQgdGFnZ2VkQ29sb3IgPSAnI2Y1ZjVmNSc7IC8vIGQzLnJnYihcIndoaXRlc21va2VcIik7XG5leHBvcnQgbGV0IHRpbWVDb2xvciA9ICcjMmQ2Y2EyJztcblxuZXhwb3J0IGxldCBsZWZ0dGFiID0gJ3RhYjEnOyAvLyBjdXJyZW50IHRhYiBpbiBsZWZ0IHBhbmVsXG5leHBvcnQgbGV0IHN1YnNldCA9IGZhbHNlO1xuZXhwb3J0IGxldCBzdW1tYXJ5SG9sZCA9IGZhbHNlO1xuZXhwb3J0IGxldCByaWdodHRhYiA9ICdidG5Nb2RlbHMnOyAvLyBjdXJyZW50IHRhYiBpbiByaWdodCBwYW5lbFxuXG4vLyB0cmFuc2Zvcm1hdGlvbiB0b29sYmFyIG9wdGlvbnNcbmxldCB0LCB0eXBlVHJhbnNmb3JtO1xuZXhwb3J0IGxldCB0cmFuc2Zvcm1MaXN0ID0gJ2xvZyhkKSBleHAoZCkgZF4yIHNxcnQoZCkgaW50ZXJhY3QoZCxlKScuc3BsaXQoJyAnKTtcbmxldCB0cmFuc2Zvcm1WYXIgPSAnJztcblxuLy8gdmFyIGxpc3QgZm9yIGVhY2ggc3BhY2UgY29udGFpbiB2YXJpYWJsZXMgaW4gb3JpZ2luYWwgZGF0YVxuLy8gcGx1cyB0cmFucyBpbiB0aGF0IHNwYWNlXG5sZXQgdHJhbnMgPSBbXTtcbmxldCBwcmVwcm9jZXNzID0ge307IC8vIGhvbGQgcHJlLXByb2Nlc3NlZCBkYXRhXG5sZXQgc3BhY2VzID0gW107XG5cbi8vIGxheW91dCBmdW5jdGlvbiBjb25zdGFudHNcbmNvbnN0IGxheW91dEFkZCA9IFwiYWRkXCI7XG5jb25zdCBsYXlvdXRNb3ZlID0gXCJtb3ZlXCI7XG5cbi8vIHJhZGl1cyBvZiBjaXJjbGVcbmNvbnN0IFJBRElVUyA9IDQwO1xuXG4vLyBjeCwgY3ksIHIgdmFsdWVzIGZvciBpbmRpY2F0b3IgbGlnaHRzXG5sZXQgaW5kMSA9IFsoUkFESVVTKzMwKSAqIE1hdGguY29zKDEuMyksIC0xKihSQURJVVMrMzApICogTWF0aC5zaW4oMS4zKSwgNV07XG5sZXQgaW5kMiA9IFsoUkFESVVTKzMwKSAqIE1hdGguY29zKDEuMSksIC0xKihSQURJVVMrMzApICogTWF0aC5zaW4oMS4xKSwgNV07XG5cbi8vIHNwYWNlIGluZGV4XG5sZXQgbXlzcGFjZSA9IDA7XG5cbmxldCBmb3JjZXRvZ2dsZSA9IFtcInRydWVcIl07XG5leHBvcnQgbGV0IGxvY2t0b2dnbGUgPSB0cnVlO1xubGV0IHByaXYgPSB0cnVlO1xuXG4vLyBzd2FuZGl2ZSBpcyBvdXIgZ3JhY2VmdWwgZmFpbCBmb3IgZDNtXG4vLyBzd2FuZGl2ZSBzZXQgdG8gdHJ1ZSBpZiB0YXNrIGlzIGluIGZhaWxzZXRcbmxldCBzd2FuZGl2ZSA9IGZhbHNlO1xubGV0IGZhaWxzZXQgPSBbXCJUSU1FU0VSSUVTRk9SRUNBU1RJTkdcIixcIkdSQVBITUFUQ0hJTkdcIixcIkxJTktQUkVESUNUSU9OXCIsXCJ0aW1lU2VyaWVzRm9yZWNhc3RpbmdcIixcImdyYXBoTWF0Y2hpbmdcIixcImxpbmtQcmVkaWN0aW9uXCJdO1xuXG5leHBvcnQgbGV0IGxvZ0FycmF5ID0gW107XG5leHBvcnQgbGV0IHpwYXJhbXMgPSB7XG4gICAgemRhdGE6IFtdLFxuICAgIHplZGdlczogW10sXG4gICAgenRpbWU6IFtdLFxuICAgIHpub206IFtdLFxuICAgIHpjcm9zczogW10sXG4gICAgem1vZGVsOiBcIlwiLFxuICAgIHp2YXJzOiBbXSxcbiAgICB6ZHY6IFtdLFxuICAgIHpncm91cDE6IFtdLFxuICAgIHpncm91cDI6IFtdLCAgICAgICAvLyBoYXJkIGNvZGluZyB0byB0d28gZ3JvdXBzIGZvciBwcmVzZW50IGV4cGVyaW1lbnRzLCBidXQgd2lsbCBldmVudHVhbGx5IG1ha2Ugemdyb3VwIGFycmF5IG9mIGFycmF5cywgd2l0aCB6Z3JvdXAubGVuZ2h0IHRoZSBudW1iZXIgb2YgZ3JvdXBzXG4gICAgemRhdGF1cmw6IFwiXCIsXG4gICAgemQzbWRhdGE6IFwiXCIsIC8vdGhlc2UgdGFrZSB0aGUgcGxhY2Ugb2YgemRhdGF1cmwgZm9yIGQzbSwgYmVjYXVzZSBkYXRhIGlzIGluIHR3byBwbGFjZWVzLiBldmVudHVhbGx5IHdpbGwgZ2VuZXJhbGl6ZVxuICAgIHpkM210YXJnZXQ6IFwiXCIsXG4gICAgenN1YnNldDogW10sXG4gICAgenNldHg6IFtdLFxuICAgIHptb2RlbGNvdW50OiAwLFxuICAgIHpwbG90OiBbXSxcbiAgICB6c2Vzc2lvbmlkOiBcIlwiLFxuICAgIHpkYXRhY2l0ZTogJy4uLicsXG4gICAgemNyb3NzdGFiOiBbXSxcbn07XG5cbmV4cG9ydCBsZXQgbW9kZWxDb3VudCA9IDA7XG5leHBvcnQgbGV0IHZhbHVlS2V5ID0gW107XG5leHBvcnQgbGV0IGFsbE5vZGVzID0gW107XG5leHBvcnQgbGV0IGFsbFJlc3VsdHMgPSBbXTtcbmV4cG9ydCBsZXQgbm9kZXMgPSBbXTtcbmV4cG9ydCBsZXQgbGlua3MgPSBbXTtcbmxldCBtb2RzID0ge307XG5sZXQgZXN0aW1hdGVkID0gZmFsc2U7XG5sZXQgcmlnaHRDbGlja0xhc3QgPSBmYWxzZTtcbmxldCBzZWxJbnRlcmFjdCA9IGZhbHNlO1xuZXhwb3J0IGxldCBjYWxsSGlzdG9yeSA9IFtdOyAvLyB0cmFuc2Zvcm0gYW5kIHN1YnNldCBjYWxsc1xubGV0IG15dGFyZ2V0ID0gJyc7XG5cbmxldCBjb25maWd1cmF0aW9ucyA9IHt9O1xubGV0IGRhdGFzY2hlbWEgPSB7fTtcblxuZXhwb3J0IGxldCBkb21haW5JZGVudGlmaWVyID0gbnVsbDsgLy8gYXZhaWxhYmxlIHRocm91Z2hvdXQgYXBwcyBqczsgdXNlZCBmb3Igc2F2aW5nIHdvcmtzcGFjZVxuXG4vLyBldmVudHVhbGx5IHJlYWQgdGhpcyBmcm9tIHRoZSBzY2hlbWEgd2l0aCByZWFsIGRlc2NyaXB0aW9uc1xuLy8gbWV0cmljcywgdGFza3MsIGFuZCBzdWJ0YXNrcyBhcyBzcGVjaWZpZWQgaW4gRDNNIHNjaGVtYXNcbi8vIE1FQU4gU1FVQVJFRCBFUlJPUiBJUyBTRVQgVE8gU0FNRSBBUyBSTVNFLiBNU0UgaXMgaW4gc2NoZW1hIGJ1dCBub3QgcHJvdG9cbmV4cG9ydCBsZXQgZDNtVGFza1R5cGUgPSB7XG4gICAgdGFza1R5cGVVbmRlZmluZWQ6IFtcImRlc2NyaXB0aW9uXCIsIFwiVEFTS19UWVBFX1VOREVGSU5FRFwiLCAwXSxcbiAgICBjbGFzc2lmaWNhdGlvbjogW1wiZGVzY3JpcHRpb25cIiwgXCJDTEFTU0lGSUNBVElPTlwiICwgMV0sXG4gICAgcmVncmVzc2lvbjogW1wiZGVzY3JpcHRpb25cIiwgXCJSRUdSRVNTSU9OXCIgLCAyXSxcbiAgICBjbHVzdGVyaW5nOiBbXCJkZXNjcmlwdGlvblwiLCBcIkNMVVNURVJJTkdcIiwgM10sXG4gICAgbGlua1ByZWRpY3Rpb246IFtcImRlc2NyaXB0aW9uXCIsIFwiTElOS19QUkVESUNUSU9OXCIgLCA0XSxcbiAgICB2ZXJ0ZXhOb21pbmF0aW9uOiBbXCJkZXNjcmlwdGlvblwiLCBcIlZFUlRFWF9OT01JTkFUSU9OXCIgLCA1XSxcbiAgICBjb21tdW5pdHlEZXRlY3Rpb246IFtcImRlc2NyaXB0aW9uXCIsIFwiQ09NTVVOSVRZX0RFVEVDVElPTlwiICwgNl0sXG4gICAgZ3JhcGhDbHVzdGVyaW5nOiBbXCJkZXNjcmlwdGlvblwiLCBcIkdSQVBIX0NMVVNURVJJTkdcIiAsIDddLFxuICAgIGdyYXBoTWF0Y2hpbmc6IFtcImRlc2NyaXB0aW9uXCIsIFwiR1JBUEhfTUFUQ0hJTkdcIiAsIDhdLFxuICAgIHRpbWVTZXJpZXNGb3JlY2FzdGluZzogW1wiZGVzY3JpcHRpb25cIiwgXCJUSU1FX1NFUklFU19GT1JFQ0FTVElOR1wiICwgOV0sXG4gICAgY29sbGFib3JhdGl2ZUZpbHRlcmluZzogW1wiZGVzY3JpcHRpb25cIiwgXCJDT0xMQUJPUkFUSVZFX0ZJTFRFUklOR1wiICwgMTBdXG59O1xuXG5leHBvcnQgbGV0IGQzbVRhc2tTdWJ0eXBlID0ge1xuICAgIHRhc2tTdWJ0eXBlVW5kZWZpbmVkOltcImRlc2NyaXB0aW9uXCIsIFwiVEFTS19TVUJUWVBFX1VOREVGSU5FRFwiLCAwXSxcbiAgICBzdWJ0eXBlTm9uZTpbXCJkZXNjcmlwdGlvblwiLFwiTk9ORVwiLDFdLFxuICAgIGJpbmFyeTpbXCJkZXNjcmlwdGlvblwiLCBcIkJJTkFSWVwiICwgMl0sXG4gICAgbXVsdGlDbGFzczpbXCJkZXNjcmlwdGlvblwiLCBcIk1VTFRJQ0xBU1NcIiAsIDNdLFxuICAgIG11bHRpTGFiZWw6W1wiZGVzY3JpcHRpb25cIiwgXCJNVUxUSUxBQkVMXCIgLCA0XSxcbiAgICB1bml2YXJpYXRlOltcImRlc2NyaXB0aW9uXCIsIFwiVU5JVkFSSUFURVwiICwgNV0sXG4gICAgbXVsdGl2YXJpYXRlOltcImRlc2NyaXB0aW9uXCIsIFwiTVVMVElWQVJJQVRFXCIgLCA2XSxcbiAgICBvdmVybGFwcGluZzpbXCJkZXNjcmlwdGlvblwiLCBcIk9WRVJMQVBQSU5HXCIgLCA3XSxcbiAgICBub25PdmVybGFwcGluZzpbXCJkZXNjcmlwdGlvblwiLCBcIk5PTk9WRVJMQVBQSU5HXCIgLCA4XVxufTtcbi8qZXhwb3J0IGxldCBkM21PdXRwdXRUeXBlID0ge1xuICAgIG91dHB1dFVuZGVmaW5lZDpbXCJkZXNjcmlwdGlvblwiLFwiT1VUUFVUX1RZUEVfVU5ERUZJTkVEIFwiLCAwXSxcbiAgICBwcmVkaWN0aW9uc0ZpbGU6W1wiZGVzY3JpcHRpb25cIixcIlBSRURJQ1RJT05TX0ZJTEVcIiwxXSxcbiAgICBzY29yZXNGaWxlOltcImRlc2NyaXB0aW9uXCIsXCJTQ09SRVNfRklMRVwiLDJdXG59OyAqL1xuZXhwb3J0IGxldCBkM21NZXRyaWNzID0ge1xuICAgIG1ldHJpY1VuZGVmaW5lZDpbXCJkZXNjcmlwdGlvblwiLCBcIk1FVFJJQ19VTkRFRklORURcIiAsIDBdLFxuICAgIGV4ZWN1dGlvblRpbWU6W1wiZGVzY3JpcHRpb25cIiwgXCJFWEVDVVRJT05fVElNRVwiLCAxXSxcbiAgICBhY2N1cmFjeSA6IFtcImRlc2NyaXB0aW9uXCIsIFwiQUNDVVJBQ1lcIiAsIDJdLFxuICAgIGYxOltcImRlc2NyaXB0aW9uXCIsIFwiRjFcIiAsIDNdLFxuICAgIGYxTWljcm86W1wiZGVzY3JpcHRpb25cIiwgXCJGMV9NSUNST1wiICwgNF0sXG4gICAgZjFNYWNybzpbXCJkZXNjcmlwdGlvblwiLCBcIkYxX01BQ1JPXCIgLCA1XSxcbiAgICByb2NBdWM6W1wiZGVzY3JpcHRpb25cIiwgXCJST0NfQVVDXCIgLCA2XSxcbiAgICByb2NBdWNNaWNybzpbXCJkZXNjcmlwdGlvblwiLCBcIlJPQ19BVUNfTUlDUk9cIiAsIDddLFxuICAgIHJvY0F1Y01hY3JvOltcImRlc2NyaXB0aW9uXCIsIFwiUk9DX0FVQ19NQUNST1wiICwgOF0sXG4gICAgbWVhblNxdWFyZWRFcnJvcjpbXCJkZXNjcmlwdGlvblwiLCBcIk1FQU5fU1FVQVJFRF9FUlJPUlwiLCA5XSxcbiAgICByb290TWVhblNxdWFyZWRFcnJvcjpbXCJkZXNjcmlwdGlvblwiLCBcIlJPT1RfTUVBTl9TUVVBUkVEX0VSUk9SXCIgLCAxMF0sXG4gICAgcm9vdE1lYW5TcXVhcmVkRXJyb3JBdmc6W1wiZGVzY3JpcHRpb25cIiwgXCJST09UX01FQU5fU1FVQVJFRF9FUlJPUl9BVkdcIiAsIDExXSxcbiAgICBtZWFuQWJzb2x1dGVFcnJvcjpbXCJkZXNjcmlwdGlvblwiLCBcIk1FQU5fQUJTT0xVVEVfRVJST1JcIiAsIDEyXSxcbiAgICByU3F1YXJlZDpbXCJkZXNjcmlwdGlvblwiLCBcIlJfU1FVQVJFRFwiICwgMTNdLFxuICAgIG5vcm1hbGl6ZWRNdXR1YWxJbmZvcm1hdGlvbjpbXCJkZXNjcmlwdGlvblwiLCBcIk5PUk1BTElaRURfTVVUVUFMX0lORk9STUFUSU9OXCIgLCAxNF0sXG4gICAgamFjY2FyZFNpbWlsYXJpdHlTY29yZTpbXCJkZXNjcmlwdGlvblwiLCBcIkpBQ0NBUkRfU0lNSUxBUklUWV9TQ09SRVwiICwgMTVdXG59O1xuXG5leHBvcnQgbGV0IGQzbVByb2JsZW1EZXNjcmlwdGlvbiA9IHtcbiAgICB0YXNrVHlwZTogWzIsXCJERUZBVUxUXCJdLFxuICAgIHRhc2tTdWJ0eXBlOiBbMSxcIkRFRkFGVUxUXCJdLFxuIC8vICAgb3V0cHV0VHlwZTogWzMsXCJERUZBVUxUXCJdLFxuICAgIG1ldHJpYzogWzMsXCJERUZBVUxUXCJdLFxuICAgIHRhc2tEZXNjcmlwdGlvbjogXCJcIlxufTtcblxubGV0IHN2Zywgd2lkdGgsIGhlaWdodCwgZGl2LCBzZWxlY3RMYWRkYTtcbmV4cG9ydCBsZXQgZXN0aW1hdGVMYWRkYTtcblxuLy8gYXJjcyBmb3IgZGVub3RpbmcgcGViYmxlIGNoYXJhY3RlcmlzdGljc1xuY29uc3QgYXJjID0gKHN0YXJ0LCBlbmQpID0+IGQzLnN2Zy5hcmMoKVxuICAgIC5pbm5lclJhZGl1cyhSQURJVVMgKyA1KVxuICAgIC5vdXRlclJhZGl1cyhSQURJVVMgKyAyMClcbiAgICAuc3RhcnRBbmdsZShzdGFydClcbiAgICAuZW5kQW5nbGUoZW5kKTtcbmNvbnN0IFthcmMwLCBhcmMxLCBhcmMyLCBhcmMzLCBhcmM0XSA9IFthcmMoMCwgMy4yKSwgYXJjKDAsIDEpLCBhcmMoMS4xLCAyLjIpLCBhcmMoMi4zLCAzLjMpLCBhcmMoNC4zLCA1LjMpXTtcbmNvbnN0IGFyY0luZCA9IChhcmNsaW1pdHMpID0+IGQzLnN2Zy5hcmMoKVxuICAgIC5pbm5lclJhZGl1cyhSQURJVVMgKyAyMilcbiAgICAub3V0ZXJSYWRpdXMoUkFESVVTICsgMzcpXG4gICAgLnN0YXJ0QW5nbGUoYXJjbGltaXRzWzBdKVxuICAgIC5lbmRBbmdsZShhcmNsaW1pdHNbMV0pO1xuXG5jb25zdCBbYXJjSW5kMUxpbWl0cywgYXJjSW5kMkxpbWl0c10gPSBbWzAsIDAuM10sIFswLjM1LCAwLjY1XV07XG5jb25zdCBbYXJjSW5kMSwgYXJjSW5kMl0gPSBbYXJjSW5kKGFyY0luZDFMaW1pdHMpLCBhcmNJbmQoYXJjSW5kMkxpbWl0cyldO1xuXG5leHBvcnQgbGV0IGJ5SWQgPSBpZCA9PiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XG5cbi8qKlxuICAgcGFnZSByZWxvYWQgbGlua2VkIHRvIGJ0blJlc2V0XG4qL1xuZXhwb3J0IGNvbnN0IHJlc2V0ID0gZnVuY3Rpb24gcmVsb2FkUGFnZSgpIHtcbiAgICBsb2NhdGlvbi5yZWxvYWQoKTtcbn07XG5leHBvcnQgbGV0IHJlc3RhcnQ7XG5cbmxldCBkYXRhdXJsID0gJyc7XG5cbi8qKlxuICBjYWxsZWQgYnkgbWFpblxuICBMb2FkcyBhbGwgZXh0ZXJuYWwgZGF0YSBpbiB0aGUgZm9sbG93aW5nIG9yZGVyIChsb2dpYyBpcyBub3QgaW5jbHVkZWQpOlxuICAxLiBSZXRyaWV2ZSB0aGUgY29uZmlndXJhdGlvbiBpbmZvcm1hdGlvblxuICAyLiBTZXQgJ2NvbmZpZ3VyYXRpb25zJ1xuICAzLiBSZWFkIHRoZSBwcm9ibGVtIHNjaGVtYSBhbmQgc2V0ICdkM21Qcm9ibGVtRGVzY3JpcHRpb24nXG4gIDQuIFJlYWQgdGhlIGRhdGEgc2NoZW1hIGFuZCBzZXQgJ2RhdGFzY2hlbWEnXG4gIDUuIFJlYWQgaW4gemVsaWcgbW9kZWxzIChub3QgZm9yIGQzbSlcbiAgNi4gUmVhZCBpbiB6ZWxpZ2Nob2ljZSBtb2RlbHMgKG5vdCBmb3IgZDNtKVxuICA3LiBTdGFydCB0aGUgdXNlciBzZXNzaW9uXG4gIDguIFJlYWQgcHJlcHJvY2VzcyBkYXRhIG9yIChpZiBuZWNlc3NhcnkpIHJ1biBwcmVwcm9jZXNzXG4gIDkuIEJ1aWxkIGFsbE5vZGVzW10gdXNpbmcgcHJlcHJvY2Vzc2VkIGluZm9ybWF0aW9uXG4gIDEwLiBBZGQgZGF0YXNjaGVtYSBpbmZvcm1hdGlvbiB0byBhbGxOb2RlcyAod2hlbiBpbiBJU19EM01fRE9NQUlOKVxuICAxMS4gQ2FsbCBsYXlvdXQoKSBhbmQgc3RhcnQgdXBcbiovXG5hc3luYyBmdW5jdGlvbiBsb2FkKGhvbGQsIGxhYmxBcnJheSwgZDNtUm9vdFBhdGgsIGQzbURhdGFOYW1lLCBkM21QcmVwcm9jZXNzLCBkM21EYXRhLCBkM21QUywgZDNtRFMsIHBVUkwpIHtcbiAgICBpZiAoIUlTX0QzTV9ET01BSU4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIDEuIFJldHJpZXZlIHRoZSBjb25maWd1cmF0aW9uIGluZm9ybWF0aW9uXG4gICAgbGV0IHJlcyA9IGF3YWl0IG0ucmVxdWVzdCh7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIHVybDogXCIvY29uZmlnL2QzbS1jb25maWcvanNvbi9sYXRlc3RcIlxuICAgIH0pO1xuICAgIGNvbnNvbGUubG9nKHJlcyk7XG4gICAgLy8gMi4gU2V0ICdjb25maWd1cmF0aW9ucydcbiAgICBjb25maWd1cmF0aW9ucyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocmVzKSk7IC8vIHRoaXMgaXMganVzdCBjb3B5aW5nIHJlc1xuICAgIGQzbVJvb3RQYXRoID0gY29uZmlndXJhdGlvbnMudHJhaW5pbmdfZGF0YV9yb290LnJlcGxhY2UoL1xcL2RhdGEvLCcnKTtcbiAgICBkM21EYXRhTmFtZSA9IGNvbmZpZ3VyYXRpb25zLm5hbWU7XG5cbiAgICAvLyBzY29wZXMgYXQgYXBwLmpzIGxldmVsOyB1c2VkIGZvciBzYXZpbmcgd29ya3NwYWNlXG4gICAgZG9tYWluSWRlbnRpZmllciA9IHtuYW1lOiBjb25maWd1cmF0aW9ucy5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlX3VybDogY29uZmlndXJhdGlvbnMuY29uZmlnX3VybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnRDNNIGNvbmZpZyBmaWxlJ307XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2lkOiBjb25maWd1cmF0aW9ucy5pZH07XG5cbiAgICBkM21QUyA9IFwiL2NvbmZpZy9kM20tY29uZmlnL2dldC1wcm9ibGVtLXNjaGVtYS9qc29uXCI7XG4gICAgZDNtRFMgPSBcIi9jb25maWcvZDNtLWNvbmZpZy9nZXQtZGF0YXNldC1zY2hlbWEvanNvblwiO1xuICAgIGNvbnNvbGUubG9nKFwiQ29uZmlndXJhdGlvbnM6IFwiLCBjb25maWd1cmF0aW9ucyk7XG4gICAgZDNtUHJlcHJvY2VzcyA9IHBVUkwgPSBgcm9vay1jdXN0b20vcm9vay1maWxlcy8ke2QzbURhdGFOYW1lfS9wcmVwcm9jZXNzL3ByZXByb2Nlc3MuanNvbmA7XG5cbiAgICAvLyAzLiBSZWFkIHRoZSBwcm9ibGVtIHNjaGVtYSBhbmQgc2V0ICdkM21Qcm9ibGVtRGVzY3JpcHRpb24nXG4gICAgLy8gLi4uYW5kIG1ha2UgYSBjYWxsIHRvIHN0YXJ0IHRoZSBzZXNzaW9uIHdpdGggVEEyLiBpZiB3ZSBnZXQgdGhpcyBmYXIsIGRhdGEgYXJlIGd1YXJhbnRlZWQgdG8gZXhpc3QgZm9yIHRoZSBmcm9udGVuZFxuICAgIHJlcyA9IGF3YWl0IG0ucmVxdWVzdChcIi9jb25maWcvZDNtLWNvbmZpZy9nZXQtcHJvYmxlbS1kYXRhLWZpbGUtaW5mb1wiKTtcbiAgICBjb25zb2xlLmxvZyhyZXMpO1xuICAgIC8vIHNvbWUgc2ltcGxlIGxvZ2ljIHRvIGdldCB0aGUgcGF0aHMgcmlnaHRcbiAgICAvLyBub3RlIHRoYXQgaWYgbmVpdGhlciBleGlzdCwgc3RheSBhcyBkZWZhdWx0IHdoaWNoIGlzIG51bGxcbiAgICBsZXQgc2V0ID0gKGZpZWxkLCB2YWwpID0+IHJlcy5kYXRhW2ZpZWxkXS5leGlzdHMgPyByZXMuZGF0YVtmaWVsZF0ucGF0aCA6XG4gICAgICAgIHJlcy5kYXRhW2ZpZWxkICsgJy5neiddLmV4aXN0cyA/IHJlcy5kYXRhW2ZpZWxkICsgJy5neiddLnBhdGggOlxuICAgICAgICB2YWw7XG5cbiAgICB6cGFyYW1zLnpkM21kYXRhID0gZDNtRGF0YSA9IHNldCgnbGVhcm5pbmdEYXRhLmNzdicsIGQzbURhdGEpO1xuICAgIHpwYXJhbXMuemQzbXRhcmdldCA9IHNldCgnbGVhcm5pbmdEYXRhLmNzdicsIGQzbURhdGEpO1xuXG4gICAgLy8gaGFyZGNvZGluZyB0aGlzLCBvbmNlIGdldC1wcm9ibGVtLWRhdGEtZmlsZS1pbmZvIGlzIHJldmlzZWQgdGhpcyBoYXJkY29kZSBjYW4gZ28gYXdheSBhbmQgdXNlIHRoZSBwcmV2aW91cyB0d28gTE9DXG4gIC8vICB6cGFyYW1zLnpkM21kYXRhID0gZDNtRGF0YSA9IGQzbVJvb3RQYXRoK1wiL2RhdGFzZXRfVFJBSU4vdGFibGVzL2xlYXJuaW5nRGF0YS5jc3ZcIjtcbiAgLy8gIHpwYXJhbXMuemQzbXRhcmdldCA9IGQzbVJvb3RQYXRoK1wiL2RhdGFzZXRfVFJBSU4vdGFibGVzL2xlYXJuaW5nRGF0YS5jc3ZcIjtcblxuICAgIHJlcyA9IGF3YWl0IG0ucmVxdWVzdChkM21QUyk7XG4gICAgY29uc29sZS5sb2coXCJwcm9iIHNjaGVtYSBkYXRhOiBcIiwgcmVzKTtcbiAgICBteXRhcmdldCA9IHJlcy5pbnB1dHMuZGF0YVswXS50YXJnZXRzWzBdLmNvbE5hbWU7IC8vIGVhc2llciB3YXkgdG8gYWNjZXNzIHRhcmdldCBuYW1lP1xuXG4gICAgaWYgKElTX0QzTV9ET01BSU4pIHtcbiAgICAgICAgenBhcmFtcy56ZGF0YSA9IGQzbURhdGFOYW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5vdGU6IHByZXNlbnRseSB4bWwgaXMgbm8gbG9uZ2VyIGJlaW5nIHJlYWQgZnJvbSBEYXRhdmVyc2UgbWV0YWRhdGEgYW55d2hlcmVcbiAgICAgICAgbGV0IHRlbXAgPSB4bWwuZG9jdW1lbnRFbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiZmlsZU5hbWVcIik7XG4gICAgICAgIHpwYXJhbXMuemRhdGEgPSB0ZW1wWzBdLmNoaWxkTm9kZXNbMF0ubm9kZVZhbHVlO1xuICAgICAgICBsZXQgY2l0ZSA9IHhtbC5kb2N1bWVudEVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJiaWJsQ2l0XCIpO1xuICAgICAgICAvLyBjbGVhbiBjaXRhdGlvbiBzbyBQT1NUIGlzIHZhbGlkIGpzb25cbiAgICAgICAgenBhcmFtcy56ZGF0YWNpdGUgPSBjaXRlWzBdLmNoaWxkTm9kZXNbMF0ubm9kZVZhbHVlXG4gICAgICAgICAgICAucmVwbGFjZSgvXFwmL2csIFwiYW5kXCIpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFw7L2csIFwiLFwiKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcJS9nLCBcIi1cIik7XG4gICAgICAgICQoJyNjaXRlIGRpdi5wYW5lbC1ib2R5JykudGV4dCh6cGFyYW1zLnpkYXRhY2l0ZSk7XG4gICAgfVxuICAgIC8vIGRyb3AgZmlsZSBleHRlbnNpb25cbiAgICBsZXQgZGF0YW5hbWUgPSBJU19EM01fRE9NQUlOID8genBhcmFtcy56ZGF0YSA6IHpwYXJhbXMuemRhdGEucmVwbGFjZSgvXFwuKC4qKS8sICcnKTtcbiAgICBkMy5zZWxlY3QoXCIjZGF0YU5hbWVcIikuaHRtbChkYXRhbmFtZSk7XG4gICAgLy8gcHV0IGRhdGFzZXQgbmFtZSwgZnJvbSBtZXRhLWRhdGEsIGludG8gcGFnZSB0aXRsZVxuICAgIGQzLnNlbGVjdChcInRpdGxlXCIpLmh0bWwoXCJUd29SYXZlbnMgXCIgKyBkYXRhbmFtZSk7XG5cbiAgLy8gIHNldCA9IChmaWVsZCwgYXJyKSA9PiBkM21Qcm9ibGVtRGVzY3JpcHRpb25bZmllbGRdID0gcmVzW2ZpZWxkXSBpbiBhcnIgPyByZXNbZmllbGRdIDogZmllbGQgKyAnVW5kZWZpbmVkJztcbiAgICBkM21Qcm9ibGVtRGVzY3JpcHRpb24udGFza1R5cGU9cmVzLmFib3V0LnRhc2tUeXBlO1xuICAgIGQzbVByb2JsZW1EZXNjcmlwdGlvbi50YXNrU3VidHlwZT1yZXMuYWJvdXQudGFza1N1YlR5cGU7XG4gICAgZDNtUHJvYmxlbURlc2NyaXB0aW9uLm1ldHJpYyA9IHJlcy5pbnB1dHMucGVyZm9ybWFuY2VNZXRyaWNzWzBdLm1ldHJpYztcbiAvLyAgIGQzbVByb2JsZW1EZXNjcmlwdGlvbi5vdXRwdXRUeXBlID0gcmVzLmV4cGVjdGVkT3V0cHV0cy5wcmVkaWN0aW9uc0ZpbGU7XG4gLy8gICBzZXQoJ3Rhc2tUeXBlJywgZDNtVGFza1R5cGUpO1xuIC8vICAgc2V0KCd0YXNrU3VidHlwZScsIGQzbVRhc2tTdWJ0eXBlKTtcbiAvLyAgIHNldCgnbWV0cmljJywgZDNtTWV0cmljcyk7XG4gLy8gICBzZXQoJ291dHB1dFR5cGUnLCBkM21PdXRwdXRUeXBlKTtcbiAgICBkM21Qcm9ibGVtRGVzY3JpcHRpb24udGFza0Rlc2NyaXB0aW9uID0gcmVzLmRlc2NyaXB0aW9uRmlsZTtcbiAgICBieUlkKFwiYnRuVHlwZVwiKS5jbGljaygpO1xuXG4gICAgLy8gbWFraW5nIGl0IGNhc2UgaW5zZW5zaXRpdmUgYmVjYXVzZSB0aGUgY2FzZSBzZWVtcyB0byBkaXNhZ3JlZSBhbGwgdG9vIG9mdGVuXG4gICAgaWYgKGZhaWxzZXQuaW5jbHVkZXMoZDNtUHJvYmxlbURlc2NyaXB0aW9uLnRhc2tUeXBlLnRvVXBwZXJDYXNlKCkpKSB7XG4gICAgICAgIHN3YW5kaXZlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyA0LiBSZWFkIHRoZSBkYXRhIHNjaGVtYSBhbmQgc2V0ICdkYXRhc2NoZW1hJ1xuICAgIGRhdGFzY2hlbWEgPSBhd2FpdCBtLnJlcXVlc3QoZDNtRFMpO1xuICAgIC8vIGlmIHN3YW5kaXZlLCB3ZSBoYXZlIHRvIHNldCB2YWx1ZUtleSBoZXJlIHNvIHRoYXQgbGVmdCBwYW5lbCBjYW4gcG9wdWxhdGVcbiAgICBpZiAoc3dhbmRpdmUpIHtcbiAgICAgICAgW2RhdGFzY2hlbWEudHJhaW5EYXRhLnRyYWluRGF0YSwgZGF0YXNjaGVtYS50cmFpbkRhdGEudHJhaW5UYXJnZXRzXVxuICAgICAgICAgICAgLmZvckVhY2godmFycyA9PiB2YXJzICYmIHZhcnMuZm9yRWFjaCh2ID0+IHZhbHVlS2V5LnB1c2godi52YXJOYW1lKSkpO1xuICAgICAgICAvLyBlbmQgc2Vzc2lvbiBpZiBuZWl0aGVyIHRyYWluRGF0YSBub3IgdHJhaW5UYXJnZXRzP1xuICAgICAgICB2YWx1ZUtleS5sZW5ndGggPT09IDAgJiYgYWxlcnQoXCJubyB0cmFpbkRhdGEgb3IgdHJhaW5UYXJnZXN0IGluIGRhdGEgZGVzY3JpcHRpb24gZmlsZS4gdmFsdWVLZXkgbGVuZ3RoIGlzIDBcIik7XG4gICAgICAgIC8vIHBlcmhhcHMgYWxsb3cgdXNlcnMgdG8gdW5sb2NrIGFuZCBzZWxlY3QgdGhpbmdzP1xuICAgICAgICBieUlkKCdidG5Mb2NrJykuY2xhc3NMaXN0LmFkZCgnbm9zaG93Jyk7XG4gICAgICAgIGJ5SWQoJ2J0bkZvcmNlJykuY2xhc3NMaXN0LmFkZCgnbm9zaG93Jyk7XG4gICAgICAgIGJ5SWQoJ2J0bkVyYXNlcicpLmNsYXNzTGlzdC5hZGQoJ25vc2hvdycpO1xuICAgICAgICBieUlkKCdidG5TdWJzZXQnKS5jbGFzc0xpc3QuYWRkKCdub3Nob3cnKTtcbiAgICAgICAgYnlJZCgnbWFpbicpLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICdncmV5JztcbiAgICAgICAgYnlJZCgnd2hpdGVzcGFjZScpLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICdncmV5JztcbiAgICB9XG4gICAgY29uc29sZS5sb2coXCJkYXRhIHNjaGVtYSBkYXRhOiBcIiwgZGF0YXNjaGVtYSk7XG5cbiAgICAvLyA1LiBSZWFkIGluIHplbGlnIG1vZGVscyAobm90IGZvciBkM20pXG4gICAgLy8gNi4gUmVhZCBpbiB6ZWxpZ2Nob2ljZSBtb2RlbHMgKG5vdCBmb3IgZDNtKVxuICAgIGlmICghSVNfRDNNX0RPTUFJTil7XG4gICAgICBmb3IgKGxldCBmaWVsZCBvZiBbJ3plbGlnNW1vZGVscycsICd6ZWxpZzVjaG9pY2Vtb2RlbHMnXSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJlcyA9IGF3YWl0IG0ucmVxdWVzdChgZGF0YS8ke2ZpZWxkfS5qc29uYCk7XG4gICAgICAgICAgICAgIGNkYihmaWVsZCArICcganNvbjogJywgcmVzKTtcbiAgICAgICAgICAgICAgcmVzW2ZpZWxkXVxuICAgICAgICAgICAgICAgICAgLmZpbHRlcihrZXkgPT4gcmVzW2ZpZWxkXS5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgICAgICAgLmZvckVhY2goa2V5ID0+IG1vZHNba2V5Lm5hbWVbMF1dID0ga2V5LmRlc2NyaXB0aW9uWzBdKTtcbiAgICAgICAgICB9IGNhdGNoKF8pIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJjYW4ndCBsb2FkIFwiICsgZmllbGQpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gNy4gU3RhcnQgdGhlIHVzZXIgc2Vzc2lvblxuICAgIC8vIHJwYyBTdGFydFNlc3Npb24oU2Vzc2lvblJlcXVlc3QpIHJldHVybnMgKFNlc3Npb25SZXNwb25zZSkge31cbiAgICByZXMgPSBhd2FpdCBtYWtlUmVxdWVzdChEM01fU1ZDX1VSTCArICcvc3RhcnRzZXNzaW9uJywge3VzZXJfYWdlbnQ6ICdzb21lIGFnZW50JywgdmVyc2lvbjogJ3NvbWUgdmVyc2lvbid9KTtcbiAgICBpZiAocmVzKSB7XG4gICAgICAgIHpwYXJhbXMuenNlc3Npb25pZCA9IHJlcy5jb250ZXh0LnNlc3Npb25JZDtcbiAgICB9XG5cbiAgICAvLyBob3BzY290Y2ggdHV0b3JpYWxcbiAgICBpZiAodHV0b3JpYWxfbW9kZSkge1xuICAgICAgICBjb25zb2xlLmxvZygnU3RhcnRpbmcgSG9wc2NvdGNoIFRvdXInKTtcbiAgICAgICAgbGV0IHN0ZXAgPSAodGFyZ2V0LCBwbGFjZW1lbnQsIHRpdGxlLCBjb250ZW50KSA9PiAoe1xuICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICAgICAgdGl0bGUsXG4gICAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgICAgc2hvd0NUQUJ1dHRvbjogdHJ1ZSxcbiAgICAgICAgICAgIGN0YUxhYmVsOiAnRGlzYWJsZSB0aGVzZSBtZXNzYWdlcycsXG4gICAgICAgICAgICBvbkNUQTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGhvcHNjb3RjaC5lbmRUb3VyKHRydWUpO1xuICAgICAgICAgICAgICAgIHR1dG9yaWFsX21vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBob3BzY290Y2guc3RhcnRUb3VyKHtcbiAgICAgICAgICAgIGlkOiBcImRhdGFzZXRfbGF1bmNoXCIsXG4gICAgICAgICAgICBpMThuOiB7ZG9uZUJ0bjonT2snfSxcbiAgICAgICAgICAgIHNob3dDbG9zZUJ1dHRvbjogZmFsc2UsXG4gICAgICAgICAgICBzY3JvbGxEdXJhdGlvbjogMzAwLFxuICAgICAgICAgICAgb25FbmQ6ICgpID0+IGZpcnN0X2xvYWQgPSBmYWxzZSxcbiAgICAgICAgICAgIHN0ZXBzOiBbXG4gICAgICAgICAgICAgICAgc3RlcChcImRhdGFOYW1lXCIsIFwiYm90dG9tXCIsIFwiV2VsY29tZSB0byBUd29SYXZlbnMgU29sdmVyXCIsXG4gICAgICAgICAgICAgICAgICAgICBgPHA+VGhpcyB0b29sIGNhbiBndWlkZSB5b3UgdG8gc29sdmUgYW4gZW1waXJpY2FsIHByb2JsZW0gaW4gdGhlIGRhdGFzZXQgbGlzdGVkIGFib3ZlLjwvcD5cbiAgICAgICAgICAgICAgICAgICAgICA8cD5UaGVzZSBtZXNzYWdlcyB3aWxsIHRlYWNoIHlvdSB0aGUgc3RlcHMgdG8gdGFrZSB0byBmaW5kIGFuZCBzdWJtaXQgYSBzb2x1dGlvbi48L3A+YCksXG4gICAgICAgICAgICAgICAgc3RlcChcImJ0blJlc2V0XCIsIFwiYm90dG9tXCIsIFwiUmVzdGFydCBBbnkgUHJvYmxlbSBIZXJlXCIsXG4gICAgICAgICAgICAgICAgICAgICAnPHA+WW91IGNhbiBhbHdheXMgc3RhcnQgYSBwcm9ibGVtIG92ZXIgYnkgdXNpbmcgdGhpcyByZXNldCBidXR0b24uPC9wPicpLFxuICAgICAgICAgICAgICAgIHN0ZXAoXCJidG5Fc3RpbWF0ZVwiLCBcImxlZnRcIiwgXCJTb2x2ZSBQcm9ibGVtXCIsXG4gICAgICAgICAgICAgICAgICAgICBgPHA+VGhlIGN1cnJlbnQgZ3JlZW4gYnV0dG9uIGlzIGdlbmVyYWxseSB0aGUgbmV4dCBzdGVwIHRvIGZvbGxvdyB0byBtb3ZlIHRoZSBzeXN0ZW0gZm9yd2FyZC48L3A+XG4gICAgICAgICAgICAgICAgICAgICAgPHA+Q2xpY2sgdGhpcyBTb2x2ZSBidXR0b24gdG8gdGVsbCB0aGUgdG9vbCB0byBmaW5kIGEgc29sdXRpb24gdG8gdGhlIHByb2JsZW0uPC9wPmApLFxuICAgICAgICAgICAgICAgIHN0ZXAobXl0YXJnZXQgKyAnYmlnZ3JvdXAnLCBcImxlZnRcIiwgXCJUYXJnZXQgVmFyaWFibGVcIixcbiAgICAgICAgICAgICAgICAgICAgIGBUaGlzIGlzIHRoZSB2YXJpYWJsZSwgJHtteXRhcmdldH0sIHdlIGFyZSB0cnlpbmcgdG8gcHJlZGljdC5cbiAgICAgICAgICAgICAgICAgICAgICBUaGlzIGNlbnRlciBwYW5lbCBncmFwaGljYWxseSByZXByZXNlbnRzIHRoZSBwcm9ibGVtIGN1cnJlbnRseSBiZWluZyBhdHRlbXB0ZWQuYCksXG4gICAgICAgICAgICAgICAgc3RlcChcImdyMWh1bGxcIiwgXCJyaWdodFwiLCBcIkV4cGxhbmF0aW9uIFNldFwiLCBcIlRoaXMgc2V0IG9mIHZhcmlhYmxlcyBjYW4gcG90ZW50aWFsbHkgcHJlZGljdCB0aGUgdGFyZ2V0LlwiKSxcbiAgICAgICAgICAgICAgICBzdGVwKFwiZGlzcGxhY2VtZW50XCIsIFwicmlnaHRcIiwgXCJWYXJpYWJsZSBMaXN0XCIsXG4gICAgICAgICAgICAgICAgICAgICBgPHA+Q2xpY2sgb24gYW55IHZhcmlhYmxlIG5hbWUgaGVyZSBpZiB5b3Ugd2lzaCB0byByZW1vdmUgaXQgZnJvbSB0aGUgcHJvYmxlbSBzb2x1dGlvbi48L3A+XG4gICAgICAgICAgICAgICAgICAgICAgPHA+WW91IGxpa2VseSBkbyBub3QgbmVlZCB0byBhZGp1c3QgdGhlIHByb2JsZW0gcmVwcmVzZW50YXRpb24gaW4gdGhlIGNlbnRlciBwYW5lbC48L3A+YCksXG4gICAgICAgICAgICAgICAgc3RlcChcImJ0bkVuZFNlc3Npb25cIiwgXCJib3R0b21cIiwgXCJGaW5pc2ggUHJvYmxlbVwiLFxuICAgICAgICAgICAgICAgICAgICAgXCJJZiB0aGUgc29sdXRpb24gcmVwb3J0ZWQgYmFjayBzZWVtcyBhY2NlcHRhYmxlLCB0aGVuIGZpbmlzaCB0aGlzIHByb2JsZW0gYnkgY2xpY2tpbmcgdGhpcyBFbmQgU2Vzc2lvbiBidXR0b24uXCIpLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdFbmRpbmcgSG9wc2NvdGNoIFRvdXInKTtcbiAgICB9XG5cbiAgICAvLyA4LiByZWFkIHByZXByb2Nlc3MgZGF0YSBvciAoaWYgbmVjZXNzYXJ5KSBydW4gcHJlcHJvY2Vzc1xuICAgIC8vIE5PVEU6IHByZXByb2Nlc3MuanNvbiBpcyBub3cgZ3VhcmFudGVlZCB0byBleGlzdC4uLlxuICAgIGxldCByZWFkID0gcmVzID0+IHtcbiAgICAgICAgcHJpdiA9IHJlcy5kYXRhc2V0LnByaXZhdGUgfHwgcHJpdjtcbiAgICAgICAgT2JqZWN0LmtleXMocmVzLnZhcmlhYmxlcykuZm9yRWFjaChrID0+IHByZXByb2Nlc3Nba10gPSByZXMudmFyaWFibGVzW2tdKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdhdHRlbXB0IHRvIHJlYWQgcHJlcHJvY2VzcyBmaWxlICh3aGljaCBtYXkgbm90IGV4aXN0KTogJyArIHBVUkwpO1xuICAgICAgICByZXMgPSByZWFkKGF3YWl0IG0ucmVxdWVzdChwVVJMKSk7XG4gICAgfSBjYXRjaChfKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiT2ssIHByZXByb2Nlc3Mgbm90IGZvdW5kLCB0cnkgdG8gUlVOIFRIRSBQUkVQUk9DRVNTQVBQXCIpO1xuICAgICAgICBsZXQgdXJsID0gUk9PS19TVkNfVVJMICsgJ3ByZXByb2Nlc3NhcHAnO1xuICAgICAgICB2YXIganNvbl9pbnB1dDtcbiAgICAgICAgaWYgKElTX0QzTV9ET01BSU4pe1xuICAgICAgICAgIC8vIEZvciBEM00gaW5wdXRzLCBjaGFuZ2UgdGhlIHByZXByb2Nlc3MgaW5wdXQgZGF0YVxuICAgICAgICAgIC8vXG4gICAgICAgICAganNvbl9pbnB1dCA9IEpTT04uc3RyaW5naWZ5KHtkYXRhOiBkM21EYXRhLCBkYXRhc3R1YjogZDNtRGF0YU5hbWV9KTtcblxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgIGpzb25faW5wdXQgPSBKU09OLnN0cmluZ2lmeSh7ZGF0YTogZGF0YWxvYywgdGFyZ2V0OiB0YXJnZXRsb2MsIGRhdGFzdHViOiBkYXRhc3R1Yn0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS5sb2coJ2pzb25faW5wdXQ6ICcsIGpzb25faW5wdXQpO1xuICAgICAgICBjb25zb2xlLmxvZygndXJsOiAnLCB1cmwpO1xuICAgICAgICBsZXQgZGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzID0gcmVhZChhd2FpdCBtLnJlcXVlc3Qoe21ldGhvZDogJ1BPU1QnLCB1cmw6IHVybCwgZGF0YToganNvbl9pbnB1dH0pKTtcbiAgICAgICAgfSBjYXRjaChfKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygncHJlcHJvY2VzcyBmYWlsZWQnKTtcbiAgICAgICAgICAgIGFsZXJ0KCdwcmVwcm9jZXNzIGZhaWxlZC4gZW5kaW5nIHVzZXIgc2Vzc2lvbi4nKTtcbiAgICAgICAgICAgIGVuZHNlc3Npb24oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIDkuIEJ1aWxkIGFsbE5vZGVzW10gdXNpbmcgcHJlcHJvY2Vzc2VkIGluZm9ybWF0aW9uXG4gICAgbGV0IHZhcnMgPSBPYmplY3Qua2V5cyhwcmVwcm9jZXNzKTtcbiAgICAvLyB0ZW1wb3JhcnkgdmFsdWVzIGZvciBob2xkIHRoYXQgY29ycmVzcG9uZCB0byBoaXN0b2dyYW0gYmluc1xuICAgIGhvbGQgPSBbLjYsIC4yLCAuOSwgLjgsIC4xLCAuMywgLjRdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyB2YWx1ZUtleVtpXSA9IHZhcnNbaV0uYXR0cmlidXRlcy5uYW1lLm5vZGVWYWx1ZTtcbiAgICAgICAgLy8gbGFibEFycmF5W2ldID0gdmFyc1hNTFtpXS5nZXRFbGVtZW50c0J5VGFnTmFtZShcImxhYmxcIikubGVuZ3RoID09IDAgP1xuICAgICAgICAvLyBcIm5vIGxhYmVsXCIgOlxuICAgICAgICAvLyB2YXJzWE1MW2ldLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwibGFibFwiKVswXS5jaGlsZE5vZGVzWzBdLm5vZGVWYWx1ZTtcbiAgICAgICAgLy8gbGV0IGRhdGFzZXRjb3VudCA9IGQzLmxheW91dC5oaXN0b2dyYW0oKVxuICAgICAgICAvLyAgICAgLmJpbnMoYmFybnVtYmVyKS5mcmVxdWVuY3koZmFsc2UpXG4gICAgICAgIC8vICAgICAoWzAsIDAsIDAsIDAsIDBdKTtcbiAgICAgICAgdmFsdWVLZXlbaV0gPSB2YXJzW2ldO1xuICAgICAgICBsYWJsQXJyYXlbaV0gPSBcIm5vIGxhYmVsXCI7XG4gICAgICAgIC8vIGNvbnRhaW5zIGFsbCB0aGUgcHJlcHJvY2Vzc2VkIGRhdGEgd2UgaGF2ZSBmb3IgdGhlIHZhcmlhYmxlLCBhcyB3ZWxsIGFzIFVJIGRhdGEgcGVydGluZW50IHRvIHRoYXQgdmFyaWFibGUsXG4gICAgICAgIC8vIHN1Y2ggYXMgc2V0eCB2YWx1ZXMgKGlmIHRoZSB1c2VyIGhhcyBzZWxlY3RlZCB0aGVtKSBhbmQgcGViYmxlIGNvb3JkaW5hdGVzXG4gICAgICAgIGxldCBvYmogPSB7XG4gICAgICAgICAgICBpZDogaSxcbiAgICAgICAgICAgIHJlZmxleGl2ZTogZmFsc2UsXG4gICAgICAgICAgICBuYW1lOiB2YWx1ZUtleVtpXSxcbiAgICAgICAgICAgIGxhYmw6IGxhYmxBcnJheVtpXSxcbiAgICAgICAgICAgIGRhdGE6IFs1LCAxNSwgMjAsIDAsIDUsIDE1LCAyMF0sXG4gICAgICAgICAgICBjb3VudDogaG9sZCxcbiAgICAgICAgICAgIG5vZGVDb2w6IGNvbG9ycyhpKSxcbiAgICAgICAgICAgIGJhc2VDb2w6IGNvbG9ycyhpKSxcbiAgICAgICAgICAgIHN0cm9rZUNvbG9yOiBzZWxWYXJDb2xvcixcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiBcIjFcIixcbiAgICAgICAgICAgIHN1YnNldHBsb3Q6IGZhbHNlLFxuICAgICAgICAgICAgc3Vic2V0cmFuZ2U6IFtcIlwiLCBcIlwiXSxcbiAgICAgICAgICAgIHNldHhwbG90OiBmYWxzZSxcbiAgICAgICAgICAgIHNldHh2YWxzOiBbXCJcIiwgXCJcIl0sXG4gICAgICAgICAgICBncmF5b3V0OiBmYWxzZSxcbiAgICAgICAgICAgIGdyb3VwMTogZmFsc2UsXG4gICAgICAgICAgICBncm91cDI6IGZhbHNlLFxuICAgICAgICAgICAgZm9yZWZyb250OiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBqUXVlcnkuZXh0ZW5kKHRydWUsIG9iaiwgcHJlcHJvY2Vzc1t2YWx1ZUtleVtpXV0pO1xuICAgICAgICBhbGxOb2Rlcy5wdXNoKG9iaik7XG4gICAgfVxuXG4gICAgLy8gMTAuIEFkZCBkYXRhc2NoZW1hIGluZm9ybWF0aW9uIHRvIGFsbE5vZGVzICh3aGVuIGluIElTX0QzTV9ET01BSU4pXG4gICAgbGV0IGRhdGF2YXJzID0gZGF0YXNjaGVtYS5kYXRhUmVzb3VyY2VzWzBdLmNvbHVtbnM7XG4gICAgZGF0YXZhcnMuZm9yRWFjaCgodiwgaSkgPT4ge1xuICAgICAgICBsZXQgbXlpID0gZmluZE5vZGVJbmRleCh2LmNvbE5hbWUpO1xuICAgICAgICBhbGxOb2Rlc1tteWldID0gT2JqZWN0LmFzc2lnbihhbGxOb2Rlc1tteWldLCB7ZDNtRGVzY3JpcHRpb246IHZ9KTtcbiAgICB9KTtcbiAgICBjb25zb2xlLmxvZyhhbGxOb2Rlcyk7XG5cbiAgICAvLyAxMS4gQ2FsbCBsYXlvdXQoKSBhbmQgc3RhcnQgdXBcbiAgICBJU19EM01fRE9NQUlOICYmIHRvZ2dsZVJpZ2h0QnV0dG9ucyhcInRhc2tzXCIpO1xuICAgIGxheW91dChmYWxzZSwgdHJ1ZSk7XG4gICAgSVNfRDNNX0RPTUFJTiA/IHpQb3AoKSA6IGRhdGFEb3dubG9hZCgpO1xufVxuXG4vKipcbiAgIGNhbGxlZCBvbiBhcHAgc3RhcnRcbiAgIEBwYXJhbSB7c3RyaW5nfSBmaWxlaWRcbiAgIEBwYXJhbSB7c3RyaW5nfSBob3N0bmFtZVxuICAgQHBhcmFtIHtzdHJpbmd9IGRkaXVybFxuICAgQHBhcmFtIHtzdHJpbmd9IGRhdGF1cmxcbiAgIEBwYXJhbSB7c3RyaW5nfSBhcGlrZXlcbiovXG5leHBvcnQgZnVuY3Rpb24gbWFpbihmaWxlaWQsIGhvc3RuYW1lLCBkZGl1cmwsIGRhdGF1cmwsIGFwaWtleSkge1xuICAgIGlmIChQUk9EVUNUSU9OICYmIGZpbGVpZCA9PT0gJycpIHtcbiAgICAgICAgbGV0IG1zZyA9ICdFcnJvcjogTm8gZmlsZWlkIGhhcyBiZWVuIHByb3ZpZGVkLic7XG4gICAgICAgIGFsZXJ0KG1zZyk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH1cblxuICAgIGxldCBkYXRhdmVyc2V1cmwgPSBob3N0bmFtZSA/ICdodHRwczovLycgKyBob3N0bmFtZSA6XG4gICAgICAgIFBST0RVQ1RJT04gPyBEQVRBVkVSU0VfVVJMIDpcbiAgICAgICAgJ2h0dHA6Ly9sb2NhbGhvc3Q6ODA4MCc7XG4gICAgLy8gaWYgZmlsZSBpZCBzdXBwbGllZCwgYXNzdW1lIHdlIGFyZSBkZWFsaW5nIHdpdGggZGF0YXZlcnNlIGFuZCBjb29rIGEgc3RhbmRhcmQgZGF0YXZlcnNlIGRhdGEgYWNjZXNzIHVybFxuICAgIC8vIHdpdGggdGhlIGZpbGVpZCBzdXBwbGllZCBhbmQgdGhlIGhvc3RuYW1lIHdlIGhhdmUgc3VwcGxpZWQgb3IgY29uZmlndXJlZFxuICAgIGRhdGF1cmwgPSBmaWxlaWQgJiYgIWRhdGF1cmwgPyBgJHtkYXRhdmVyc2V1cmx9L2FwaS9hY2Nlc3MvZGF0YWZpbGUvJHtmaWxlaWR9P2tleT0ke2FwaWtleX1gIDogZGF0YXVybDtcbiAgICBjZGIoJy0tZGF0YXVybDogJyArIGRhdGF1cmwpO1xuICAgIGNkYignLS1kYXRhdmVyc2V1cmw6ICcgKyBkYXRhdmVyc2V1cmwpO1xuXG4gICAgbGV0IHRlbXBXaWR0aCA9IGQzLnNlbGVjdCgnI21haW4ubGVmdCcpLnN0eWxlKCd3aWR0aCcpO1xuICAgIHdpZHRoID0gdGVtcFdpZHRoLnN1YnN0cmluZygwLCB0ZW1wV2lkdGgubGVuZ3RoIC0gMik7XG4gICAgaGVpZ2h0ID0gJCh3aW5kb3cpLmhlaWdodCgpIC0gMTIwOyAvLyBoYXJkIGNvZGUgaGVhZGVyLCBmb290ZXIsIGFuZCBib3R0b20gbWFyZ2luXG5cbiAgICBlc3RpbWF0ZUxhZGRhID0gTGFkZGEuY3JlYXRlKGJ5SWQoXCJidG5Fc3RpbWF0ZVwiKSk7XG4gICAgc2VsZWN0TGFkZGEgPSBMYWRkYS5jcmVhdGUoYnlJZChcImJ0blNlbGVjdFwiKSk7XG4gICAgc3ZnID0gZDMuc2VsZWN0KFwiI3doaXRlc3BhY2VcIik7XG5cbiAgICAvLyBpbmRpY2F0b3JzIGZvciBzaG93aW5nIG1lbWJlcnNoaXAgYWJvdmUgYXJjc1xuICAgIC8vIGxldCBpbmRpY2F0b3IgPSAoZGVncmVlKSA9PiBkMy5zdmcuY2lyY2xlKClcbiAgICAvLyAgICAgLmN4KCBSQURJVVMgKS8vKFJBRElVUyszNSkgKiBNYXRoLnNpbihkZWdyZWUpKVxuICAgIC8vICAgICAuY3koIFJBRElVUyApLy8oUkFESVVTKzM1KSAqIE1hdGguY29zKGRlZ3JlZSkpXG4gICAgLy8gICAgIC5yKDMpO1xuICAgIC8vIGluZDEgPSBpbmRpY2F0b3IoMSk7XG4gICAgLy8gaW5kMiA9IGluZGljYXRvcigxLjIpO1xuXG4gICAgLy8gZnJvbSAuY3N2XG4gICAgbGV0IFtob2xkLCBsYWJsQXJyYXldID0gW1tdLCBbXV07XG5cbiAgICAvLyBhc3N1bWUgbG9jYXRpb25zIGFyZSBjb25zaXN0ZW50IGJhc2VkIG9uIGQzbSBkaXJlY3Rvcnkgc3RydWN0dXJlXG4gICAgbGV0IGQzbVJvb3RQYXRoID0gJyc7XG4gICAgbGV0IGQzbURhdGFOYW1lID0gJyc7XG4gICAgbGV0IGQzbURhdGEgPSBudWxsO1xuICAgIGxldCBkM21QcmVwcm9jZXNzID0gJyc7XG4gICAgbGV0IGQzbVBTID0gJyc7XG4gICAgbGV0IGQzbURTID0gJyc7XG5cbiAgICAvLyBkZWZhdWx0IHRvIEZlYXJvbiBMYWl0aW5cbiAgICBsZXQgZGF0YSA9ICdkYXRhLycgKyAoZmFsc2UgPyAnUFVNUzVzbWFsbCcgOiAnZmVhcm9uTGFpdGluJyk7XG4gICAgbGV0IG1ldGFkYXRhdXJsID0gZGRpdXJsIHx8IChmaWxlaWQgPyBgJHtkYXRhdmVyc2V1cmx9L2FwaS9tZXRhL2RhdGFmaWxlLyR7ZmlsZWlkfWAgOiBkYXRhICsgJy54bWwnKTtcbiAgICAvLyByZWFkIHByZS1wcm9jZXNzZWQgbWV0YWRhdGEgYW5kIGRhdGFcbiAgICBsZXQgcFVSTCA9IGRhdGF1cmwgPyBgJHtkYXRhdXJsfSZmb3JtYXQ9cHJlcGAgOiBkYXRhICsgJy5qc29uJztcblxuICAgIGlmIChJU19EM01fRE9NQUlOKSB7XG4gICAgICAgIHBVUkwgPSBkM21QcmVwcm9jZXNzO1xuICAgIH0gZWxzZSBpZiAoIVBST0RVQ1RJT04pIHtcbiAgICAgICAgenBhcmFtcy56ZGF0YXVybCA9ICdkYXRhL2ZlYXJvbkxhaXRpbi50c3YnO1xuICAgIH1cblxuICAgIGxvYWQoaG9sZCwgbGFibEFycmF5LCBkM21Sb290UGF0aCwgZDNtRGF0YU5hbWUsIGQzbVByZXByb2Nlc3MsIGQzbURhdGEsIGQzbVBTLCBkM21EUywgcFVSTCk7XG59XG5cbmxldCAkZmlsbCA9IChvYmosIG9wLCBkMSwgZDIpID0+IGQzLnNlbGVjdChvYmopLnRyYW5zaXRpb24oKVxuICAgIC5hdHRyKCdmaWxsLW9wYWNpdHknLCBvcClcbiAgICAuZGVsYXkoZDEpXG4gICAgLmR1cmF0aW9uKGQyKTtcbmxldCBmaWxsID0gKGQsIGlkLCBvcCwgZDEsIGQyKSA9PiAkZmlsbCgnIycgKyBpZCArIGQuaWQsIG9wLCBkMSwgZDIpO1xubGV0IGZpbGxUaGlzID0gKHNlbGYsIG9wLCBkMSwgZDIpID0+ICRmaWxsKHNlbGYsIG9wLCBkMSwgZDIpO1xuXG4vKipcbiAgIGRlbGV0ZXMgdGhlIGl0ZW0gYXQgaW5kZXggZnJvbSBhcnJheS5cbiAgIGlmIG9iamVjdCBpcyBwcm92aWRlZCwgZGVsZXRlcyBmaXJzdCBpbnN0YW5jZSBvZiBvYmplY3QgZnJvbSBhcnJheS5cbiAgIEBwYXJhbSB7T2JqZWN0W119IGFyciAtIGFycmF5XG4gICBAcGFyYW0ge251bWJlcn0gaWR4IC0gaW5kZXhcbiAgIEBwYXJhbSB7T2JqZWN0fSBbb2JqXSAtIG9iamVjdFxuKi9cbmZ1bmN0aW9uIGRlbChhcnIsIGlkeCwgb2JqKSB7XG4gICAgaWR4ID0gb2JqID8gYXJyLmluZGV4T2Yob2JqKSA6IGlkeDtcbiAgICBpZHggPiAtMSAmJiBhcnIuc3BsaWNlKGlkeCwgMSk7XG59XG5cbi8qKiBuZWVkcyBkb2MgKi9cbmZ1bmN0aW9uIHpwYXJhbXNSZXNldCh0ZXh0KSB7XG4gICAgJ3pkdiB6Y3Jvc3MgenRpbWUgem5vbScuc3BsaXQoJyAnKS5mb3JFYWNoKHggPT4gZGVsKHpwYXJhbXNbeF0sIC0xLCB0ZXh0KSk7XG59XG5cbi8qKiBuZWVkcyBkb2MgKi9cbmZ1bmN0aW9uIGxheW91dCh2LHYyKSB7XG4gICAgdmFyIG15VmFsdWVzID0gW107XG4gICAgbm9kZXMgPSBbXTtcbiAgICBsaW5rcyA9IFtdO1xuXG4gICAgc3ZnLmFwcGVuZChcInN2ZzpkZWZzXCIpLmFwcGVuZChcInN2ZzptYXJrZXJcIilcbiAgICAgICAgLmF0dHIoXCJpZFwiLCBcImdyb3VwMS1hcnJvd1wiKVxuICAgICAgICAuYXR0cigndmlld0JveCcsICcwIC01IDE1IDE1JylcbiAgICAgICAgLmF0dHIoXCJyZWZYXCIsIDIuNSlcbiAgICAgICAgLmF0dHIoXCJyZWZZXCIsIDApXG4gICAgICAgIC5hdHRyKFwibWFya2VyV2lkdGhcIiwgMylcbiAgICAgICAgLmF0dHIoXCJtYXJrZXJIZWlnaHRcIiwgMylcbiAgICAgICAgLmF0dHIoXCJvcmllbnRcIiwgXCJhdXRvXCIpXG4gICAgICAgIC5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgIC5hdHRyKCdkJywgJ00wLC01TDEwLDBMMCw1JylcbiAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBncjFDb2xvcik7XG5cbiAgICBzdmcuYXBwZW5kKFwic3ZnOmRlZnNcIikuYXBwZW5kKFwic3ZnOm1hcmtlclwiKVxuICAgICAgICAuYXR0cihcImlkXCIsIFwiZ3JvdXAyLWFycm93XCIpXG4gICAgICAgIC5hdHRyKCd2aWV3Qm94JywgJzAgLTUgMTUgMTUnKVxuICAgICAgICAuYXR0cihcInJlZlhcIiwgMi41KVxuICAgICAgICAuYXR0cihcInJlZllcIiwgMClcbiAgICAgICAgLmF0dHIoXCJtYXJrZXJXaWR0aFwiLCAzKVxuICAgICAgICAuYXR0cihcIm1hcmtlckhlaWdodFwiLCAzKVxuICAgICAgICAuYXR0cihcIm9yaWVudFwiLCBcImF1dG9cIilcbiAgICAgICAgLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgLmF0dHIoJ2QnLCAnTTAsLTVMMTAsMEwwLDUnKVxuICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGdyMkNvbG9yKTtcblxuICAgIHZhciBsaW5lID0gc3ZnLmFwcGVuZChcImxpbmVcIilcbiAgICAgICAgLnN0eWxlKCdmaWxsJywgJ25vbmUnKVxuICAgICAgICAuc3R5bGUoJ3N0cm9rZScsIGdyMUNvbG9yKVxuICAgICAgICAuc3R5bGUoJ3N0cm9rZS13aWR0aCcsIDUpXG4gICAgICAgIC5hdHRyKFwibWFya2VyLWVuZFwiLCBcInVybCgjZ3JvdXAxLWFycm93KVwiKTtcblxuICAgIHZhciBsaW5lMiA9IHN2Zy5hcHBlbmQoXCJsaW5lXCIpXG4gICAgICAgIC5zdHlsZSgnZmlsbCcsICdub25lJylcbiAgICAgICAgLnN0eWxlKCdzdHJva2UnLCBncjJDb2xvcilcbiAgICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLCA1KVxuICAgICAgICAuYXR0cihcIm1hcmtlci1lbmRcIiwgXCJ1cmwoI2dyb3VwMi1hcnJvdylcIik7O1xuXG4gICAgdmFyIHZpc2JhY2tncm91bmQgPSBkMy5zZWxlY3QoXCIjd2hpdGVzcGFjZVwiKS5hcHBlbmQoXCJzdmdcIilcbiAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCB3aWR0aClcbiAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgaGVpZ2h0KTtcblxuICAgIHZpc2JhY2tncm91bmQuYXBwZW5kKFwicGF0aFwiKSAvLyBub3RlIGxpbmVzLCBhcmUgYmVoaW5kIGdyb3VwIGh1bGxzIG9mIHdoaWNoIHRoZXJlIGlzIGEgd2hpdGUgYW5kIGNvbG9yZWQgc2VtaSB0cmFuc3BhcmVudCBsYXllclxuICAgICAgICAuYXR0cihcImlkXCIsICdncjFiYWNrZ3JvdW5kJylcbiAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCAnI2ZmZmZmZicpXG4gICAgICAgIC5zdHlsZShcInN0cm9rZVwiLCAnI2ZmZmZmZicpXG4gICAgICAgIC5zdHlsZShcInN0cm9rZS13aWR0aFwiLCAyLjUqUkFESVVTKVxuICAgICAgICAuc3R5bGUoJ3N0cm9rZS1saW5lam9pbicsJ3JvdW5kJylcbiAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAxKTtcblxuICAgIHZhciB2aXMyYmFja2dyb3VuZCA9IGQzLnNlbGVjdChcIiN3aGl0ZXNwYWNlXCIpLmFwcGVuZChcInN2Z1wiKVxuICAgICAgICAuYXR0cihcIndpZHRoXCIsIHdpZHRoKVxuICAgICAgICAuYXR0cihcImhlaWdodFwiLCBoZWlnaHQpO1xuXG4gICAgdmlzMmJhY2tncm91bmQuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAuYXR0cihcImlkXCIsICdncjFiYWNrZ3JvdW5kJylcbiAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCAnI2ZmZmZmZicpXG4gICAgICAgIC5zdHlsZShcInN0cm9rZVwiLCAnI2ZmZmZmZicpXG4gICAgICAgIC5zdHlsZShcInN0cm9rZS13aWR0aFwiLCAyLjUqUkFESVVTKVxuICAgICAgICAuc3R5bGUoJ3N0cm9rZS1saW5lam9pbicsJ3JvdW5kJylcbiAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAxKTtcblxuICAgIHZhciB2aXMgPSBkMy5zZWxlY3QoXCIjd2hpdGVzcGFjZVwiKS5hcHBlbmQoXCJzdmdcIilcbiAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCB3aWR0aClcbiAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgaGVpZ2h0KTtcblxuICAgIHZpcy5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgIC5hdHRyKFwiaWRcIiwgJ2dyMWh1bGwnKVxuICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGdyMUNvbG9yKVxuICAgICAgICAuc3R5bGUoXCJzdHJva2VcIiwgZ3IxQ29sb3IpXG4gICAgICAgIC5zdHlsZShcInN0cm9rZS13aWR0aFwiLCAyLjUqUkFESVVTKVxuICAgICAgICAuc3R5bGUoJ3N0cm9rZS1saW5lam9pbicsJ3JvdW5kJyk7XG5cbiAgICB2YXIgdmlzMiA9IGQzLnNlbGVjdChcIiN3aGl0ZXNwYWNlXCIpLmFwcGVuZChcInN2Z1wiKVxuICAgICAgICAuYXR0cihcIndpZHRoXCIsIHdpZHRoKVxuICAgICAgICAuYXR0cihcImhlaWdodFwiLCBoZWlnaHQpO1xuXG4gICAgdmlzMi5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgIC5zdHlsZShcImZpbGxcIiwgZ3IyQ29sb3IpXG4gICAgICAgIC5zdHlsZShcInN0cm9rZVwiLCBncjJDb2xvcilcbiAgICAgICAgLnN0eWxlKFwic3Ryb2tlLXdpZHRoXCIsIDIuNSpSQURJVVMpXG4gICAgICAgIC5zdHlsZSgnc3Ryb2tlLWxpbmVqb2luJywncm91bmQnKTtcblxuICAgIGlmICh2ID09IGxheW91dEFkZCB8fCB2ID09IGxheW91dE1vdmUpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB6cGFyYW1zLnp2YXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgaWkgPSBmaW5kTm9kZUluZGV4KHpwYXJhbXMuenZhcnNbal0pO1xuICAgICAgICAgICAgaWYgKGFsbE5vZGVzW2lpXS5ncmF5b3V0KVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgbm9kZXMucHVzaChhbGxOb2Rlc1tpaV0pO1xuICAgICAgICAgICAgdmFyIHNlbGVjdE1lID0genBhcmFtcy56dmFyc1tqXS5yZXBsYWNlKC9cXFcvZywgXCJfXCIpO1xuICAgICAgICAgICAgc2VsZWN0TWUgPSBcIiNcIi5jb25jYXQoc2VsZWN0TWUpO1xuICAgICAgICAgICAgZDMuc2VsZWN0KHNlbGVjdE1lKS5zdHlsZSgnYmFja2dyb3VuZC1jb2xvcicsICgpID0+IGhleFRvUmdiYShub2Rlc1tqXS5zdHJva2VDb2xvcikpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB6cGFyYW1zLnplZGdlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIG15c3JjID0gbm9kZUluZGV4KHpwYXJhbXMuemVkZ2VzW2pdWzBdKTtcbiAgICAgICAgICAgIHZhciBteXRndCA9IG5vZGVJbmRleCh6cGFyYW1zLnplZGdlc1tqXVsxXSk7XG4gICAgICAgICAgICBsaW5rcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBzb3VyY2U6IG5vZGVzW215c3JjXSxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IG5vZGVzW215dGd0XSxcbiAgICAgICAgICAgICAgICBsZWZ0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICByaWdodDogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZihJU19EM01fRE9NQUlOKSB7XG4gICAgICAgICAgICAvL25vZGVzID0gW2ZpbmROb2RlKG15dGFyZ2V0KV07ICAgICAgICAgICAgICAgLy8gT25seSBhZGQgZGVwZW5kZW50IHZhcmlhYmxlIG9uIHN0YXJ0dXBcbiAgICAgICAgICAgIG5vZGVzID0gYWxsTm9kZXMuc2xpY2UoMSxhbGxOb2Rlcy5sZW5ndGgpOyAgICAvLyBBZGQgYWxsIGJ1dCBmaXJzdCB2YXJpYWJsZSBvbiBzdGFydHVwIChhc3N1bWVzIDAgcG9zaXRpb24gaXMgZDNtIGluZGV4IHZhcmlhYmxlKVxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBub2Rlcy5sZW5ndGg7IGorKykgeyAvL3BvcHVsYXRlIHp2YXJzIGFycmF5XG4gICAgICAgICAgICAgICAgaWYgKG5vZGVzW2pdLm5hbWUgIT0gbXl0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXNbal0uZ3JvdXAxID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgenBhcmFtcy56Z3JvdXAxLnB1c2gobm9kZXNbal0ubmFtZSk7ICAvLyB3cml0ZSBhbGwgbmFtZXMgKGV4Y2VwdCBkM20gaW5kZXggYW5kIHRoZSBkZXBlbmRlbnQgdmFyaWFibGUpIHRvIHpncm91cDEgYXJyYXlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChhbGxOb2Rlcy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICBub2RlcyA9IFthbGxOb2Rlc1swXSwgYWxsTm9kZXNbMV0sIGFsbE5vZGVzWzJdXTtcbiAgICAgICAgICAgIGxpbmtzID0gW3tcbiAgICAgICAgICAgICAgICBzb3VyY2U6IG5vZGVzWzFdLFxuICAgICAgICAgICAgICAgIHRhcmdldDogbm9kZXNbMF0sXG4gICAgICAgICAgICAgICAgbGVmdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IHRydWVcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBzb3VyY2U6IG5vZGVzWzBdLFxuICAgICAgICAgICAgICAgIHRhcmdldDogbm9kZXNbMl0sXG4gICAgICAgICAgICAgICAgbGVmdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IHRydWVcbiAgICAgICAgICAgIH1dO1xuICAgICAgICB9IGVsc2UgaWYgKGFsbE5vZGVzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgbm9kZXMgPSBbYWxsTm9kZXNbMF0sIGFsbE5vZGVzWzFdXTtcbiAgICAgICAgICAgIGxpbmtzID0gW3tcbiAgICAgICAgICAgICAgICBzb3VyY2U6IG5vZGVzWzFdLFxuICAgICAgICAgICAgICAgIHRhcmdldDogbm9kZXNbMF0sXG4gICAgICAgICAgICAgICAgbGVmdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IHRydWVcbiAgICAgICAgICAgIH1dO1xuICAgICAgICB9IGVsc2UgaWYgKGFsbE5vZGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgbm9kZXMgPSBbYWxsTm9kZXNbMF1dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWxlcnQoXCJUaGVyZSBhcmUgemVybyB2YXJpYWJsZXMgaW4gdGhlIG1ldGFkYXRhLlwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHBhbmVsUGxvdHMoKTsgLy8gYWZ0ZXIgbm9kZXMgaXMgcG9wdWxhdGVkLCBhZGQgc3Vic2V0IGFuZCAoaWYgIUlTX0QzTV9ET01BSU4pIHNldHggcGFuZWxzXG5cbiAgICB2YXIgZm9yY2UgPSBkMy5sYXlvdXQuZm9yY2UoKVxuICAgICAgICAubm9kZXMobm9kZXMpXG4gICAgICAgIC5saW5rcyhsaW5rcylcbiAgICAgICAgLnNpemUoW3dpZHRoLCBoZWlnaHRdKVxuICAgICAgICAubGlua0Rpc3RhbmNlKDE1MClcbiAgICAgICAgLmNoYXJnZSgtODAwKVxuICAgICAgICAub24oJ3RpY2snLCB0aWNrKTtcblxuICAgIC8vIGRlZmluZSBhcnJvdyBtYXJrZXJzIGZvciBncmFwaCBsaW5rc1xuICAgIHN2Zy5hcHBlbmQoJ3N2ZzpkZWZzJykuYXBwZW5kKCdzdmc6bWFya2VyJylcbiAgICAgICAgLmF0dHIoJ2lkJywgJ2VuZC1hcnJvdycpXG4gICAgICAgIC5hdHRyKCd2aWV3Qm94JywgJzAgLTUgMTAgMTAnKVxuICAgICAgICAuYXR0cigncmVmWCcsIDYpXG4gICAgICAgIC5hdHRyKCdtYXJrZXJXaWR0aCcsIDMpXG4gICAgICAgIC5hdHRyKCdtYXJrZXJIZWlnaHQnLCAzKVxuICAgICAgICAuYXR0cignb3JpZW50JywgJ2F1dG8nKVxuICAgICAgICAuYXBwZW5kKCdzdmc6cGF0aCcpXG4gICAgICAgIC5hdHRyKCdkJywgJ00wLC01TDEwLDBMMCw1JylcbiAgICAgICAgLnN0eWxlKCdmaWxsJywgJyMwMDAnKTtcblxuICAgIHN2Zy5hcHBlbmQoJ3N2ZzpkZWZzJykuYXBwZW5kKCdzdmc6bWFya2VyJylcbiAgICAgICAgLmF0dHIoJ2lkJywgJ3N0YXJ0LWFycm93JylcbiAgICAgICAgLmF0dHIoJ3ZpZXdCb3gnLCAnMCAtNSAxMCAxMCcpXG4gICAgICAgIC5hdHRyKCdyZWZYJywgNClcbiAgICAgICAgLmF0dHIoJ21hcmtlcldpZHRoJywgMylcbiAgICAgICAgLmF0dHIoJ21hcmtlckhlaWdodCcsIDMpXG4gICAgICAgIC5hdHRyKCdvcmllbnQnLCAnYXV0bycpXG4gICAgICAgIC5hcHBlbmQoJ3N2ZzpwYXRoJylcbiAgICAgICAgLmF0dHIoJ2QnLCAnTTEwLC01TDAsMEwxMCw1JylcbiAgICAgICAgLnN0eWxlKCdmaWxsJywgJyMwMDAnKTtcblxuICAgIC8vIGxpbmUgZGlzcGxheWVkIHdoZW4gZHJhZ2dpbmcgbmV3IG5vZGVzXG4gICAgdmFyIGRyYWdfbGluZSA9IHN2Zy5hcHBlbmQoJ3N2ZzpwYXRoJylcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2xpbmsgZHJhZ2xpbmUgaGlkZGVuJylcbiAgICAgICAgLmF0dHIoJ2QnLCAnTTAsMEwwLDAnKTtcblxuICAgIC8vIGhhbmRsZXMgdG8gbGluayBhbmQgbm9kZSBlbGVtZW50IGdyb3Vwc1xuICAgIHZhciBwYXRoID0gc3ZnLmFwcGVuZCgnc3ZnOmcnKS5zZWxlY3RBbGwoJ3BhdGgnKSxcbiAgICAgICAgY2lyY2xlID0gc3ZnLmFwcGVuZCgnc3ZnOmcnKS5zZWxlY3RBbGwoJ2cnKTtcbiAgICAgICAgLy9saW5lID0gc3ZnLmFwcGVuZCgnc3ZnOmcnKS5zZWxlY3RBbGwoJ2xpbmUnKTtcblxuICAgIC8vIG1vdXNlIGV2ZW50IHZhcnNcbiAgICB2YXIgc2VsZWN0ZWRfbm9kZSA9IG51bGwsXG4gICAgICAgIHNlbGVjdGVkX2xpbmsgPSBudWxsLFxuICAgICAgICBtb3VzZWRvd25fbGluayA9IG51bGwsXG4gICAgICAgIG1vdXNlZG93bl9ub2RlID0gbnVsbCxcbiAgICAgICAgbW91c2V1cF9ub2RlID0gbnVsbDtcblxuICAgIGZ1bmN0aW9uIHJlc2V0TW91c2VWYXJzKCkge1xuICAgICAgICBtb3VzZWRvd25fbm9kZSA9IG51bGw7XG4gICAgICAgIG1vdXNldXBfbm9kZSA9IG51bGw7XG4gICAgICAgIG1vdXNlZG93bl9saW5rID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgZm9yY2UgbGF5b3V0IChjYWxsZWQgYXV0b21hdGljYWxseSBlYWNoIGl0ZXJhdGlvbilcbiAgICBmdW5jdGlvbiB0aWNrKCkge1xuICAgICAgICBmdW5jdGlvbiBmaW5kY29vcmRzKGZpbmRuYW1lcyxhbGxuYW1lcyxjb29yZHMsbGVuZ3RoZW4pe1xuICAgICAgICAgICAgdmFyIGZjb29yZHMgPSBuZXcgQXJyYXkoZmluZG5hbWVzLmxlbmd0aCk7ICAgLy8gZm91bmQgY29vcmRpbmF0ZXNcbiAgICAgICAgICAgIHZhciBhZGRsb2NhdGlvbiA9IDA7XG4gICAgICAgICAgICBpZihmaW5kbmFtZXMubGVuZ3RoPjApe1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZmluZG5hbWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZGxvY2F0aW9uID0gYWxsbmFtZXMuaW5kZXhPZihmaW5kbmFtZXNbal0pO1xuICAgICAgICAgICAgICAgICAgICBmY29vcmRzW2pdID0gY29vcmRzW2FkZGxvY2F0aW9uXTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYobGVuZ3RoZW4pe1xuICAgICAgICAgICAgICAgIC8vIGQzLmdlb20uaHVsbCByZXR1cm5zIG51bGwgZm9yIHR3byBwb2ludHMsIGFuZCBmYWlscyBpZiB0aHJlZSBwb2ludHMgYXJlIGluIGEgbGluZSxcbiAgICAgICAgICAgICAgICAvLyBzbyB0aGlzIHB1dHMgYSBjb3VwbGUgcG9pbnRzIHNsaWdodGx5IG9mZiB0aGUgbGluZSBmb3IgdHdvIHBvaW50cywgb3IgYXJvdW5kIGEgc2luZ2xldG9uLlxuICAgICAgICAgICAgICAgIGlmIChmY29vcmRzLmxlbmd0aCA9PSAyKXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlbHRheCA9IGZjb29yZHNbMF1bMF0tIGZjb29yZHNbMV1bMF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWx0YXkgPSBmY29vcmRzWzBdWzFdLSBmY29vcmRzWzFdWzFdO1xuICAgICAgICAgICAgICAgICAgICBmY29vcmRzLnB1c2goWyhmY29vcmRzWzBdWzBdICsgZmNvb3Jkc1sxXVswXSkvMiArIGRlbHRheS8yMCwgKGZjb29yZHNbMF1bMV0rIGZjb29yZHNbMV1bMV0pLzIgKyBkZWx0YXgvMjBdKTtcbiAgICAgICAgICAgICAgICAgICAgZmNvb3Jkcy5wdXNoKFsoZmNvb3Jkc1swXVswXSArIGZjb29yZHNbMV1bMF0pLzIgLSBkZWx0YXkvMjAsIChmY29vcmRzWzBdWzFdKyBmY29vcmRzWzFdWzFdKS8yIC0gZGVsdGF4LzIwXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmY29vcmRzLmxlbmd0aCA9PSAxKXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlbHRhID0gUkFESVVTICogMC4yO1xuICAgICAgICAgICAgICAgICAgICBmY29vcmRzLnB1c2goW2Zjb29yZHNbMF1bMF0gKyBkZWx0YSwgZmNvb3Jkc1swXVsxXV0pO1xuICAgICAgICAgICAgICAgICAgICBmY29vcmRzLnB1c2goW2Zjb29yZHNbMF1bMF0gLSBkZWx0YSwgZmNvb3Jkc1swXVsxXV0pO1xuICAgICAgICAgICAgICAgICAgICBmY29vcmRzLnB1c2goW2Zjb29yZHNbMF1bMF0sIGZjb29yZHNbMF1bMV0gKyBkZWx0YV0pO1xuICAgICAgICAgICAgICAgICAgICBmY29vcmRzLnB1c2goW2Zjb29yZHNbMF1bMF0sIGZjb29yZHNbMF1bMV0gLSBkZWx0YV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoZmNvb3Jkcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gZDMuZ2VvbS5odWxsIHJldHVybnMgbnVsbCBmb3IgdHdvIHBvaW50cywgYW5kIGZhaWxzIGlmIHRocmVlIHBvaW50cyBhcmUgaW4gYSBsaW5lLFxuICAgICAgICAvLyBzbyB0aGlzIHB1dHMgYSBjb3VwbGUgcG9pbnRzIHNsaWdodGx5IG9mZiB0aGUgbGluZSBmb3IgdHdvIHBvaW50cywgb3IgYXJvdW5kIGEgc2luZ2xldG9uLlxuICAgICAgICBmdW5jdGlvbiBsZW5ndGhlbmNvb3Jkcyhjb29yZHMpe1xuICAgICAgICAgICAgaWYgKGNvb3Jkcy5sZW5ndGggPT0gMil7XG4gICAgICAgICAgICAgICAgdmFyIGRlbHRheCA9IGNvb3Jkc1swXVswXS0gY29vcmRzWzFdWzBdO1xuICAgICAgICAgICAgICAgIHZhciBkZWx0YXkgPSBjb29yZHNbMF1bMV0tIGNvb3Jkc1sxXVsxXTtcbiAgICAgICAgICAgICAgICBjb29yZHMucHVzaChbKGNvb3Jkc1swXVswXSArIGNvb3Jkc1sxXVswXSkvMiArIGRlbHRheS8yMCwgKGNvb3Jkc1swXVsxXSsgY29vcmRzWzFdWzFdKS8yICsgZGVsdGF4LzIwXSk7XG4gICAgICAgICAgICAgICAgY29vcmRzLnB1c2goWyhjb29yZHNbMF1bMF0gKyBjb29yZHNbMV1bMF0pLzIgLSBkZWx0YXkvMjAsIChjb29yZHNbMF1bMV0rIGNvb3Jkc1sxXVsxXSkvMiAtIGRlbHRheC8yMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvb3Jkcy5sZW5ndGggPT0gMSl7XG4gICAgICAgICAgICAgICAgdmFyIGRlbHRhID0gUkFESVVTICogMC4yO1xuICAgICAgICAgICAgICAgIGNvb3Jkcy5wdXNoKFtjb29yZHNbMF1bMF0gKyBkZWx0YSwgY29vcmRzWzBdWzFdXSk7XG4gICAgICAgICAgICAgICAgY29vcmRzLnB1c2goW2Nvb3Jkc1swXVswXSAtIGRlbHRhLCBjb29yZHNbMF1bMV1dKTtcbiAgICAgICAgICAgICAgICBjb29yZHMucHVzaChbY29vcmRzWzBdWzBdLCBjb29yZHNbMF1bMV0gKyBkZWx0YV0pO1xuICAgICAgICAgICAgICAgIGNvb3Jkcy5wdXNoKFtjb29yZHNbMF1bMF0sIGNvb3Jkc1swXVsxXSAtIGRlbHRhXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKGNvb3Jkcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGNvb3JkcyA9IG5vZGVzLm1hcChmdW5jdGlvbihkKSB7ICByZXR1cm4gWyBkLngsIGQueV07IH0pO1xuICAgICAgICB2YXIgZ3IxY29vcmRzID0gZmluZGNvb3Jkcyh6cGFyYW1zLnpncm91cDEsIHpwYXJhbXMuenZhcnMsIGNvb3JkcywgdHJ1ZSk7XG4gICAgICAgIHZhciBncjJjb29yZHMgPSBmaW5kY29vcmRzKHpwYXJhbXMuemdyb3VwMiwgenBhcmFtcy56dmFycywgY29vcmRzLCB0cnVlKTtcbiAgICAgICAgdmFyIGRlcGNvb3JkcyA9IGZpbmRjb29yZHMoenBhcmFtcy56ZHYsIHpwYXJhbXMuenZhcnMsIGNvb3JkcywgZmFsc2UpO1xuXG4gICAgICAgIC8vIGRyYXcgY29udmV4IGh1bGwgYXJvdW5kIGluZGVwZW5kZW50IHZhcmlhYmxlcywgaWYgdGhyZWUgb3IgbW9yZSBjb29yZGluYXRlcyBnaXZlblxuICAgICAgICAvLyBub3RlLCBkMy5nZW9tLmh1bGwgcmV0dXJucyBudWxsIGlmIHNob3J0ZXIgY29vcmRpbmF0ZSBzZXQgdGhhbiAzLFxuICAgICAgICAvLyBzbyBmaW5kY29vcmRzKCkgZnVuY3Rpb24gaGFzIG9wdGlvbiB0byBsZW5ndGhlbiB0aGUgY29vcmRpbmF0ZXMgcmV0dXJuZWQgdG8gYnlwYXNzIHRoaXNcbiAgICAgICAgaWYoZ3IxY29vcmRzLmxlbmd0aCA+IDIpe1xuICAgICAgICAgICAgbGluZS5zdHlsZShcIm9wYWNpdHlcIiwgMSk7XG4gICAgICAgICAgICB2aXNiYWNrZ3JvdW5kLnN0eWxlKFwib3BhY2l0eVwiLCAxKTtcbiAgICAgICAgICAgIHZpcy5zdHlsZShcIm9wYWNpdHlcIiwgMC4zKTtcbiAgICAgICAgICAgIHZhciBteWh1bGwgPSBkMy5nZW9tLmh1bGwoZ3IxY29vcmRzKTtcblxuICAgICAgICAgICAgdmlzLnNlbGVjdEFsbChcInBhdGhcIilcbiAgICAgICAgICAgICAgICAuZGF0YShbbXlodWxsXSkgICAvLyByZXR1cm5zIG51bGwgaWYgbGVzcyB0aGFuIHRocmVlIGNvb3JkaW5hdGVzXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJkXCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIFwiTVwiICsgZC5qb2luKFwiTFwiKSArIFwiWlwiOyB9KTtcbiAgICAgICAgICAgIHZpc2JhY2tncm91bmQuc2VsZWN0QWxsKFwicGF0aFwiKVxuICAgICAgICAgICAgICAgIC5kYXRhKFtteWh1bGxdKSAgIC8vIHJldHVybnMgbnVsbCBpZiBsZXNzIHRoYW4gdGhyZWUgY29vcmRpbmF0ZXNcbiAgICAgICAgICAgICAgICAuYXR0cihcImRcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gXCJNXCIgKyBkLmpvaW4oXCJMXCIpICsgXCJaXCI7IH0pO1xuXG4gICAgICAgICAgICAvL3ZhciBwID0gZDMuZ2VvbS5wb2x5Z29uKGluZGNvb3JkcykuY2VudHJvaWQoKTsgIC8vIFNlZW1zIHRvIGdvIHN0cmFuZ2Ugc29tZXRpbWVzXG4gICAgICAgICAgICB2YXIgcCA9IGphbWVzY2VudHJvaWQoZ3IxY29vcmRzKTtcblxuICAgICAgICAgICAgaWYoZGVwY29vcmRzLmxlbmd0aD4wKXtcbiAgICAgICAgICAgICAgICB2YXIgcSA9IGRlcGNvb3Jkc1swXTsgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90ZSwgb25seSB1c2luZyBmaXJzdCBkZXAgdmFyIGN1cnJlbnRseVxuICAgICAgICAgICAgICAgIC8vdmFyIHIgPSBmaW5kYm91bmRhcnkocCxxLGdyMWNvb3Jkcyk7ICAgICAgICAvLyBBbiBhcHByb2FjaCB0byBmaW5kIHRoZSBleGFjdCBib3VuZGFyeSwgbm90IHByZXNlbnRseSB3b3JraW5nXG4gICAgICAgICAgICAgICAgdmFyIGxkZWx0YVggPSBxWzBdIC0gcFswXSxcbiAgICAgICAgICAgICAgICAgICAgbGRlbHRhWSA9IHFbMV0gLSBwWzFdLFxuICAgICAgICAgICAgICAgICAgICBsZGlzdCA9IE1hdGguc3FydChsZGVsdGFYICogbGRlbHRhWCArIGxkZWx0YVkgKiBsZGVsdGFZKSxcbiAgICAgICAgICAgICAgICAgICAgbG5vcm1YID0gMCxcbiAgICAgICAgICAgICAgICAgICAgbG5vcm1ZID0gMCxcbiAgICAgICAgICAgICAgICAgICAgbHNvdXJjZVBhZGRpbmcgPSBSQURJVVMgKyA3LFxuICAgICAgICAgICAgICAgICAgICBsdGFyZ2V0UGFkZGluZyA9IFJBRElVUyArIDEwO1xuXG4gICAgICAgICAgICAgICAgaWYgKGxkaXN0ID4gMCl7XG4gICAgICAgICAgICAgICAgICAgIGxub3JtWCA9IGxkZWx0YVggLyBsZGlzdDtcbiAgICAgICAgICAgICAgICAgICAgbG5vcm1ZID0gbGRlbHRhWSAvIGxkaXN0O1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBsaW5lLmF0dHIoXCJ4MVwiLCBwWzBdICsgKGxzb3VyY2VQYWRkaW5nICogbG5vcm1YKSkgICAvLyBvciByWzBdIGlmIGZpbmRib3VuZGFyeSB3b3Jrc1xuICAgICAgICAgICAgICAgICAgICAuYXR0cihcInkxXCIsIHBbMV0gKyAobHNvdXJjZVBhZGRpbmcgKiBsbm9ybVkpKSAgIC8vIG9yIHJbMV0gaWYgZmluZGJvdW5kYXJ5IHdvcmtzXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieDJcIiwgcVswXS0gKGx0YXJnZXRQYWRkaW5nICogbG5vcm1YKSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ5MlwiLCBxWzFdLSAobHRhcmdldFBhZGRpbmcgKiBsbm9ybVkpKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIGdyb3VwIG1lbWJlcnMgYXR0cmFjdCBlYWNoIG90aGVyLCByZXB1bHNlIG5vbi1ncm91cCBtZW1iZXJzXG4gICAgICAgICAgICBub2Rlcy5mb3JFYWNoKG4gPT4ge1xuICAgICAgICAgICAgICAgIHZhciBzaWduID0gKG4uZ3JvdXAxKSA/IDEgOiAtMTsgICAgLy93YXM6IE1hdGguc2lnbiggenBhcmFtcy56Z3JvdXAxLmluZGV4T2Yobi5uYW1lKSArMC41ICk7ICAvLyAxIGlmIG4gaW4gZ3JvdXAsIC0xIGlmIG4gbm90IGluIGdyb3VwO1xuICAgICAgICAgICAgICAgIHZhciBsZGVsdGFYID0gcFswXSAtIG4ueCxcbiAgICAgICAgICAgICAgICAgICAgbGRlbHRhWSA9IHBbMV0gLSBuLnksXG4gICAgICAgICAgICAgICAgICAgIGxkaXN0ID0gTWF0aC5zcXJ0KGxkZWx0YVggKiBsZGVsdGFYICsgbGRlbHRhWSAqIGxkZWx0YVkpO1xuICAgICAgICAgICAgICAgICAgICBsbm9ybVggPSAwLFxuICAgICAgICAgICAgICAgICAgICBsbm9ybVkgPSAwO1xuXG4gICAgICAgICAgICAgICAgaWYgKGxkaXN0ID4gMCl7XG4gICAgICAgICAgICAgICAgICAgIGxub3JtWCA9IGxkZWx0YVggLyBsZGlzdDtcbiAgICAgICAgICAgICAgICAgICAgbG5vcm1ZID0gbGRlbHRhWSAvIGxkaXN0O1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBuLnggKz0gTWF0aC5taW4obG5vcm1YICwgbGRlbHRhWC8xMDAgKSAqIGsgKiBzaWduICAgKiBmb3JjZS5hbHBoYSgpO1xuICAgICAgICAgICAgICAgIG4ueSArPSBNYXRoLm1pbihsbm9ybVkgLCBsZGVsdGFZLzEwMCApICogayAqIHNpZ24gICAqIGZvcmNlLmFscGhhKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHZpc2JhY2tncm91bmQuc3R5bGUoXCJvcGFjaXR5XCIsIDApO1xuXG4gICAgICAgICAgICB2aXMuc3R5bGUoXCJvcGFjaXR5XCIsIDApO1xuLy8gICAgICAgICAgICB2aXMuc3R5bGUoXCJvcGFjaXR5XCIsIDApO1xuICAgICAgICAgICAgbGluZS5zdHlsZShcIm9wYWNpdHlcIiwgMCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYoZ3IyY29vcmRzLmxlbmd0aCA+IDIpe1xuICAgICAgICAgICAgbGluZTIuc3R5bGUoXCJvcGFjaXR5XCIsIDEpO1xuICAgICAgICAgICAgdmlzMmJhY2tncm91bmQuc3R5bGUoXCJvcGFjaXR5XCIsIDEpO1xuICAgICAgICAgICAgdmlzMi5zdHlsZShcIm9wYWNpdHlcIiwgMC4zKTtcbiAgICAgICAgICAgIHZhciBteWh1bGwgPSBkMy5nZW9tLmh1bGwoZ3IyY29vcmRzKTtcbiAgICAgICAgICAgIHZpczIuc2VsZWN0QWxsKFwicGF0aFwiKVxuICAgICAgICAgICAgICAgIC5kYXRhKFtteWh1bGxdKSAgIC8vIHJldHVybnMgbnVsbCBpZiBsZXNzIHRoYW4gdGhyZWUgY29vcmRpbmF0ZXNcbiAgICAgICAgICAgICAgICAuYXR0cihcImRcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gXCJNXCIgKyBkLmpvaW4oXCJMXCIpICsgXCJaXCI7IH0pO1xuICAgICAgICAgICAgdmlzMmJhY2tncm91bmQuc2VsZWN0QWxsKFwicGF0aFwiKVxuICAgICAgICAgICAgICAgIC5kYXRhKFtteWh1bGxdKSAgIC8vIHJldHVybnMgbnVsbCBpZiBsZXNzIHRoYW4gdGhyZWUgY29vcmRpbmF0ZXNcbiAgICAgICAgICAgICAgICAuYXR0cihcImRcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gXCJNXCIgKyBkLmpvaW4oXCJMXCIpICsgXCJaXCI7IH0pO1xuXG4gICAgICAgICAgICAvL3ZhciBwID0gZDMuZ2VvbS5wb2x5Z29uKGluZGNvb3JkcykuY2VudHJvaWQoKTsgIC8vIFNlZW1zIHRvIGdvIHN0cmFuZ2Ugc29tZXRpbWVzXG4gICAgICAgICAgICB2YXIgcCA9IGphbWVzY2VudHJvaWQoZ3IyY29vcmRzKTtcblxuICAgICAgICAgICAgaWYoZGVwY29vcmRzLmxlbmd0aD4wKXtcbiAgICAgICAgICAgICAgICB2YXIgcSA9IGRlcGNvb3Jkc1swXTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdGUsIG9ubHkgdXNpbmcgZmlyc3QgZGVwIHZhciBjdXJyZW50bHlcbiAgICAgICAgICAgICAgICB2YXIgbGRlbHRhWCA9IHFbMF0gLSBwWzBdLFxuICAgICAgICAgICAgICAgICAgICBsZGVsdGFZID0gcVsxXSAtIHBbMV0sXG4gICAgICAgICAgICAgICAgICAgIGxkaXN0ID0gTWF0aC5zcXJ0KGxkZWx0YVggKiBsZGVsdGFYICsgbGRlbHRhWSAqIGxkZWx0YVkpLFxuICAgICAgICAgICAgICAgICAgICBsbm9ybVggPSBsZGVsdGFYIC8gbGRpc3QsXG4gICAgICAgICAgICAgICAgICAgIGxub3JtWSA9IGxkZWx0YVkgLyBsZGlzdCxcbiAgICAgICAgICAgICAgICAgICAgbHNvdXJjZVBhZGRpbmcgPSBSQURJVVMgKyA3LFxuICAgICAgICAgICAgICAgICAgICBsdGFyZ2V0UGFkZGluZyA9IFJBRElVUyArIDEwO1xuXG4gICAgICAgICAgICAgICAgbGluZTIuYXR0cihcIngxXCIsIHBbMF0gKyAobHNvdXJjZVBhZGRpbmcgKiBsbm9ybVgpKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcInkxXCIsIHBbMV0gKyAobHNvdXJjZVBhZGRpbmcgKiBsbm9ybVkpKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcIngyXCIsIHFbMF0tIChsdGFyZ2V0UGFkZGluZyAqIGxub3JtWCkpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieTJcIiwgcVsxXS0gKGx0YXJnZXRQYWRkaW5nICogbG5vcm1ZKSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBncm91cCBtZW1iZXJzIGF0dHJhY3QgZWFjaCBvdGhlciwgcmVwdWxzZSBub24tZ3JvdXAgbWVtYmVyc1xuICAgICAgICAgICAgbm9kZXMuZm9yRWFjaChuID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgc2lnbiA9IChuLmdyb3VwMikgPyAxIDogLTE7ICAvLyB3YXM6IE1hdGguc2lnbiggenBhcmFtcy56Z3JvdXAyLmluZGV4T2Yobi5uYW1lKSArMC41ICk7ICAvLyAxIGlmIG4gaW4gZ3JvdXAsIC0xIGlmIG4gbm90IGluIGdyb3VwO1xuICAgICAgICAgICAgICAgIHZhciBsZGVsdGFYID0gcFswXSAtIG4ueCxcbiAgICAgICAgICAgICAgICAgICAgbGRlbHRhWSA9IHBbMV0gLSBuLnksXG4gICAgICAgICAgICAgICAgICAgIGxkaXN0ID0gTWF0aC5zcXJ0KGxkZWx0YVggKiBsZGVsdGFYICsgbGRlbHRhWSAqIGxkZWx0YVkpLFxuICAgICAgICAgICAgICAgICAgICBsbm9ybVggPSAwLFxuICAgICAgICAgICAgICAgICAgICBsbm9ybVkgPSAwO1xuXG4gICAgICAgICAgICAgICAgaWYgKGxkaXN0ID4gMCl7XG4gICAgICAgICAgICAgICAgICAgIGxub3JtWCA9IGxkZWx0YVggLyBsZGlzdDtcbiAgICAgICAgICAgICAgICAgICAgbG5vcm1ZID0gbGRlbHRhWSAvIGxkaXN0O1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBuLnggKz0gTWF0aC5taW4obG5vcm1YICwgbGRlbHRhWC8xMDAgKSAqIGsgKiBzaWduICAgKiBmb3JjZS5hbHBoYSgpO1xuICAgICAgICAgICAgICAgIG4ueSArPSBNYXRoLm1pbihsbm9ybVkgLCBsZGVsdGFZLzEwMCApICogayAqIHNpZ24gICAqIGZvcmNlLmFscGhhKCk7XG4gICAgICAgICAgICB9KTtcblxuXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgdmlzMmJhY2tncm91bmQuc3R5bGUoXCJvcGFjaXR5XCIsIDApO1xuICAgICAgICAgICAgdmlzMi5zdHlsZShcIm9wYWNpdHlcIiwgMCk7XG4gICAgICAgICAgICBsaW5lMi5zdHlsZShcIm9wYWNpdHlcIiwgMCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gZHJhdyBkaXJlY3RlZCBlZGdlcyB3aXRoIHByb3BlciBwYWRkaW5nIGZyb20gbm9kZSBjZW50ZXJzXG4gICAgICAgIHBhdGguYXR0cignZCcsIGQgPT4ge1xuICAgICAgICAgICAgdmFyIGRlbHRhWCA9IGQudGFyZ2V0LnggLSBkLnNvdXJjZS54LFxuICAgICAgICAgICAgICAgIGRlbHRhWSA9IGQudGFyZ2V0LnkgLSBkLnNvdXJjZS55LFxuICAgICAgICAgICAgICAgIGRpc3QgPSBNYXRoLnNxcnQoZGVsdGFYICogZGVsdGFYICsgZGVsdGFZICogZGVsdGFZKSxcbiAgICAgICAgICAgICAgICBub3JtWCA9IGRlbHRhWCAvIGRpc3QsXG4gICAgICAgICAgICAgICAgbm9ybVkgPSBkZWx0YVkgLyBkaXN0LFxuICAgICAgICAgICAgICAgIHNvdXJjZVBhZGRpbmcgPSBkLmxlZnQgPyBSQURJVVMgKyA1IDogUkFESVVTLFxuICAgICAgICAgICAgICAgIHRhcmdldFBhZGRpbmcgPSBkLnJpZ2h0ID8gUkFESVVTICsgNSA6IFJBRElVUyxcbiAgICAgICAgICAgICAgICBzb3VyY2VYID0gZC5zb3VyY2UueCArIChzb3VyY2VQYWRkaW5nICogbm9ybVgpLFxuICAgICAgICAgICAgICAgIHNvdXJjZVkgPSBkLnNvdXJjZS55ICsgKHNvdXJjZVBhZGRpbmcgKiBub3JtWSksXG4gICAgICAgICAgICAgICAgdGFyZ2V0WCA9IGQudGFyZ2V0LnggLSAodGFyZ2V0UGFkZGluZyAqIG5vcm1YKSxcbiAgICAgICAgICAgICAgICB0YXJnZXRZID0gZC50YXJnZXQueSAtICh0YXJnZXRQYWRkaW5nICogbm9ybVkpO1xuICAgICAgICAgICAgcmV0dXJuIGBNJHtzb3VyY2VYfSwke3NvdXJjZVl9TCR7dGFyZ2V0WH0sJHt0YXJnZXRZfWA7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNpcmNsZS5hdHRyKCd0cmFuc2Zvcm0nLCBkID0+ICd0cmFuc2xhdGUoJyArIGQueCArICcsJyArIGQueSArICcpJyk7XG5cbiAgICAgICAgY2lyY2xlLnNlbGVjdEFsbCgnY2lyY2xlJykgICAgICAgICAgIC8vIFNocmluay9leHBhbmQgcGViYmxlcyB0aGF0IGpvaW4vbGVhdmUgZ3JvdXBzXG4gICAgICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAuZHVyYXRpb24oMTAwKVxuICAgICAgICAgICAgLmF0dHIoJ3InLCBkID0+IHNldFBlYmJsZVJhZGl1cyhkKSk7XG5cbiAgICB9XG5cbiAgICBkMy5zZWxlY3QoXCIjbW9kZWxzXCIpLnNlbGVjdEFsbChcInBcIikgLy8gbW9kZWxzIHRhYlxuICAgICAgICAvLyAgZDMuc2VsZWN0KFwiI0Rpc3BsYXlfY29udGVudFwiKVxuICAgICAgICAub24oXCJjbGlja1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBteUNvbG9yID0gZDMuc2VsZWN0KHRoaXMpLnN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJyk7XG4gICAgICAgICAgICBkMy5zZWxlY3QoXCIjbW9kZWxzXCIpLnNlbGVjdEFsbChcInBcIilcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2JhY2tncm91bmQtY29sb3InLCB2YXJDb2xvcik7XG4gICAgICAgICAgICBkMy5zZWxlY3QodGhpcylcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2JhY2tncm91bmQtY29sb3InLCBkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGQzLnJnYihteUNvbG9yKS50b1N0cmluZygpID09PSB2YXJDb2xvci50b1N0cmluZygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB6cGFyYW1zLnptb2RlbCA9IGQudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoZXhUb1JnYmEoc2VsVmFyQ29sb3IpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgenBhcmFtcy56bW9kZWwgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YXJDb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVzdGFydCgpO1xuICAgICAgICB9KTtcblxuICAgIGQzLnNlbGVjdChcIiN0eXBlc1wiKS5zZWxlY3RBbGwoXCJwXCIpIC8vIG1vZGVscyB0YWJcbiAgICAvLyAgZDMuc2VsZWN0KFwiI0Rpc3BsYXlfY29udGVudFwiKVxuICAgIC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZihsb2NrdG9nZ2xlKSByZXR1cm47XG4gICAgICAgIGlmKHRoaXMuY2xhc3NOYW1lPT1cIml0ZW0tc2VsZWN0XCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGQzLnNlbGVjdChcIiN0eXBlc1wiKS5zZWxlY3QoXCJwLml0ZW0tc2VsZWN0XCIpXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnaXRlbS1kZWZhdWx0Jyk7XG4gICAgICAgICAgICBkM21Qcm9ibGVtRGVzY3JpcHRpb24udGFza1R5cGUgPSB0aGlzLmlubmVySFRNTC50b1N0cmluZygpO1xuICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmF0dHIoJ2NsYXNzJyxcIml0ZW0tc2VsZWN0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3RhcnQoKTtcbiAgICAgICAgdXBkYXRlU2NoZW1hKFwidGFza1R5cGVcIiwgZDNtUHJvYmxlbURlc2NyaXB0aW9uLCBkM21UYXNrVHlwZSk7XG4gICAgICAgIH0pO1xuXG4gICAgZDMuc2VsZWN0KFwiI3N1YnR5cGVzXCIpLnNlbGVjdEFsbChcInBcIilcbiAgICAub24oXCJjbGlja1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYobG9ja3RvZ2dsZSkgcmV0dXJuO1xuICAgICAgICBpZih0aGlzLmNsYXNzTmFtZT09XCJpdGVtLXNlbGVjdFwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkMy5zZWxlY3QoXCIjc3VidHlwZXNcIikuc2VsZWN0KFwicC5pdGVtLXNlbGVjdFwiKVxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2l0ZW0tZGVmYXVsdCcpO1xuICAgICAgICAgICAgZDNtUHJvYmxlbURlc2NyaXB0aW9uLnRhc2tTdWJ0eXBlID0gdGhpcy5pbm5lckhUTUwudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5hdHRyKCdjbGFzcycsXCJpdGVtLXNlbGVjdFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXN0YXJ0KCk7XG4gICAgICAgIHVwZGF0ZVNjaGVtYShcInRhc2tTdWJ0eXBlXCIsIGQzbVByb2JsZW1EZXNjcmlwdGlvbiwgZDNtVGFza1N1YnR5cGUpO1xuICAgICAgICB9KTtcblxuICAgIGQzLnNlbGVjdChcIiNtZXRyaWNzXCIpLnNlbGVjdEFsbChcInBcIilcbiAgICAub24oXCJjbGlja1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYobG9ja3RvZ2dsZSkgcmV0dXJuO1xuICAgICAgICBpZih0aGlzLmNsYXNzTmFtZT09XCJpdGVtLXNlbGVjdFwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBkM21Qcm9ibGVtRGVzY3JpcHRpb24ubWV0cmljID0gW1wiXCIsXCJcIl07XG4gICAgICAgICAgICAvLyB0aGlzLmNsYXNzTmFtZT1cIml0ZW0tZGVmYXVsdFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZDMuc2VsZWN0KFwiI21ldHJpY3NcIikuc2VsZWN0KFwicC5pdGVtLXNlbGVjdFwiKVxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2l0ZW0tZGVmYXVsdCcpO1xuICAgICAgICAgICAgZDNtUHJvYmxlbURlc2NyaXB0aW9uLm1ldHJpYyA9IHRoaXMuaW5uZXJIVE1MLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuYXR0cignY2xhc3MnLFwiaXRlbS1zZWxlY3RcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdGFydCgpO1xuICAgICAgICB1cGRhdGVTY2hlbWEoXCJtZXRyaWNcIiwgZDNtUHJvYmxlbURlc2NyaXB0aW9uLCBkM21NZXRyaWNzKTtcbiAgICAgICAgfSk7XG5cbiAgLyogIGQzLnNlbGVjdChcIiNvdXRwdXRzXCIpLnNlbGVjdEFsbChcInBcIilcbiAgICAub24oXCJjbGlja1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYobG9ja3RvZ2dsZSkgcmV0dXJuO1xuICAgICAgICBpZih0aGlzLmNsYXNzTmFtZT09XCJpdGVtLXNlbGVjdFwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkMy5zZWxlY3QoXCIjb3V0cHV0c1wiKS5zZWxlY3QoXCJwLml0ZW0tc2VsZWN0XCIpXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnaXRlbS1kZWZhdWx0Jyk7XG4gICAgICAgICAgICBkM21Qcm9ibGVtRGVzY3JpcHRpb24ub3V0cHV0VHlwZSA9IHRoaXMuaW5uZXJIVE1MLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuYXR0cignY2xhc3MnLFwiaXRlbS1zZWxlY3RcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdGFydCgpO1xuICAgICAgICB1cGRhdGVTY2hlbWEoXCJvdXRwdXRUeXBlXCIsIGQzbVByb2JsZW1EZXNjcmlwdGlvbiwgZDNtT3V0cHV0VHlwZSk7XG4gICAgICAgIH0pO1xuICAgICAgICAqL1xuXG4gICAgLy8gdXBkYXRlIGdyYXBoIChjYWxsZWQgd2hlbiBuZWVkZWQpXG4gICAgcmVzdGFydCA9IGZ1bmN0aW9uKCRsaW5rcykge1xuICAgICAgICBsaW5rcyA9ICRsaW5rcyB8fCBsaW5rcztcbiAgICAgICAgLy8gbm9kZXMuaWQgaXMgcGVnZ2VkIHRvIGFsbE5vZGVzLCBpLmUuIHRoZSBvcmRlciBpbiB3aGljaCB2YXJpYWJsZXMgYXJlIHJlYWQgaW5cbiAgICAgICAgLy8gbm9kZXMuaW5kZXggaXMgZmxvYXRpbmcgYW5kIGRlcGVuZHMgb24gdXBkYXRlcyB0byBub2Rlcy4gIGEgdmFyaWFibGVzIGluZGV4IGNoYW5nZXMgd2hlbiBuZXcgdmFyaWFibGVzIGFyZSBhZGRlZC5cbiAgICAgICAgY2lyY2xlLmNhbGwoZm9yY2UuZHJhZyk7XG4gICAgICAgIGlmIChmb3JjZXRvZ2dsZVswXSA9PSBcInRydWVcIikge1xuICAgICAgICAgICAgZm9yY2UuZ3Jhdml0eSgwLjEpO1xuICAgICAgICAgICAgZm9yY2UuY2hhcmdlKGQgPT4gc2V0UGViYmxlQ2hhcmdlKGQpKTtcbiAgICAgICAgICAgIGZvcmNlLnN0YXJ0KCk7XG4gICAgICAgICAgICBmb3JjZS5saW5rU3RyZW5ndGgoMSk7XG4gICAgICAgICAgICBrID0gNDsgLy8gc3RyZW5ndGggcGFyYW1ldGVyIGZvciBncm91cCBhdHRyYWN0aW9uL3JlcHVsc2lvblxuICAgICAgICAgICAgaWYgKCh6cGFyYW1zLnpncm91cDEubGVuZ3RoID4gMCkgJiAoenBhcmFtcy56Z3JvdXAyLmxlbmd0aCA+IDAgKSkgeyAvLyBzY2FsZSBkb3duIGJ5IG51bWJlciBvZiBhY3RpdmUgZ3JvdXBzXG4gICAgICAgICAgICAgICAgayA9IDIuNTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvcmNlLmdyYXZpdHkoMCk7XG4gICAgICAgICAgICBmb3JjZS5jaGFyZ2UoMCk7XG4gICAgICAgICAgICBmb3JjZS5saW5rU3RyZW5ndGgoMCk7XG4gICAgICAgICAgICBrID0gMDtcbiAgICAgICAgfVxuICAgICAgICBmb3JjZS5yZXN1bWUoKTtcblxuICAgICAgICAvLyBwYXRoIChsaW5rKSBncm91cFxuICAgICAgICBwYXRoID0gcGF0aC5kYXRhKGxpbmtzKTtcblxuICAgICAgICAvLyB1cGRhdGUgZXhpc3RpbmcgbGlua3NcbiAgICAgICAgLy8gVkpEOiBkYXNoZWQgbGlua3MgYmV0d2VlbiBwZWJibGVzIGFyZSBcInNlbGVjdGVkXCIuIHRoaXMgaXMgZGlzYWJsZWQgZm9yIG5vd1xuICAgICAgICBwYXRoLmNsYXNzZWQoJ3NlbGVjdGVkJywgeCA9PiBudWxsKVxuICAgICAgICAgICAgLnN0eWxlKCdtYXJrZXItc3RhcnQnLCB4ID0+IHgubGVmdCA/ICd1cmwoI3N0YXJ0LWFycm93KScgOiAnJylcbiAgICAgICAgICAgIC5zdHlsZSgnbWFya2VyLWVuZCcsIHggPT4geC5yaWdodCA/ICd1cmwoI2VuZC1hcnJvdyknIDogJycpO1xuXG4gICAgICAgIC8vIGFkZCBuZXcgbGlua3NcbiAgICAgICAgcGF0aC5lbnRlcigpLmFwcGVuZCgnc3ZnOnBhdGgnKVxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2xpbmsnKVxuICAgICAgICAgICAgLmNsYXNzZWQoJ3NlbGVjdGVkJywgeCA9PiBudWxsKVxuICAgICAgICAgICAgLnN0eWxlKCdtYXJrZXItc3RhcnQnLCB4ID0+IHgubGVmdCA/ICd1cmwoI3N0YXJ0LWFycm93KScgOiAnJylcbiAgICAgICAgICAgIC5zdHlsZSgnbWFya2VyLWVuZCcsIHggPT4geC5yaWdodCA/ICd1cmwoI2VuZC1hcnJvdyknIDogJycpXG4gICAgICAgICAgICAub24oJ21vdXNlZG93bicsIGZ1bmN0aW9uKGQpIHsgLy8gZG8gd2UgZXZlciBuZWVkIHRvIHNlbGVjdCBhIGxpbms/IG1ha2UgaXQgZGVsZXRlLi5cbiAgICAgICAgICAgICAgICB2YXIgb2JqID0gSlNPTi5zdHJpbmdpZnkoZCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsaW5rcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAob2JqID09PSBKU09OLnN0cmluZ2lmeShsaW5rc1tqXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWwobGlua3MsIGopO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHJlbW92ZSBvbGQgbGlua3NcbiAgICAgICAgcGF0aC5leGl0KCkucmVtb3ZlKCk7XG5cbiAgICAgICAgLy8gY2lyY2xlIChub2RlKSBncm91cFxuICAgICAgICBjaXJjbGUgPSBjaXJjbGUuZGF0YShub2RlcywgeCA9PiB4LmlkKTtcblxuICAgICAgICAvLyB1cGRhdGUgZXhpc3Rpbmcgbm9kZXMgKHJlZmxleGl2ZSAmIHNlbGVjdGVkIHZpc3VhbCBzdGF0ZXMpXG4gICAgICAgIC8vIGQzLnJnYiBpcyB0aGUgZnVuY3Rpb24gYWRqdXN0aW5nIHRoZSBjb2xvciBoZXJlXG4gICAgICAgIGNpcmNsZS5zZWxlY3RBbGwoJ2NpcmNsZScpXG4gICAgICAgICAgICAuY2xhc3NlZCgncmVmbGV4aXZlJywgeCA9PiB4LnJlZmxleGl2ZSlcbiAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIHggPT4gZDMucmdiKHgubm9kZUNvbCkpXG4gICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsIHggPT4gZDMucmdiKHguc3Ryb2tlQ29sb3IpKVxuICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLCB4ID0+IHguc3Ryb2tlV2lkdGgpO1xuXG4gICAgICAgIC8vIGFkZCBuZXcgbm9kZXNcbiAgICAgICAgbGV0IGcgPSBjaXJjbGUuZW50ZXIoKVxuICAgICAgICAgICAgLmFwcGVuZCgnc3ZnOmcnKVxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgeCA9PiB4Lm5hbWUgKyAnYmlnZ3JvdXAnKTtcblxuICAgICAgICAvLyBhZGQgcGxvdFxuICAgICAgICBnLmVhY2goZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpO1xuICAgICAgICAgICAgaWYgKGQucGxvdHR5cGUgPT0gJ2NvbnRpbnVvdXMnKSBkZW5zaXR5Tm9kZShkLCB0aGlzKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGQucGxvdHR5cGUgPT0gJ2JhcicpIGJhcnNOb2RlKGQsIHRoaXMpO1xuICAgICAgICB9KTtcblxuICAgICAgICBsZXQgYXBwZW5kID0gKHN0ciwgYXR0cikgPT4geCA9PiBzdHIgKyB4W2F0dHIgfHwgJ2lkJ107XG5cbiAgICAgICAgZy5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsIGFwcGVuZCgnZHZBcmMnKSlcbiAgICAgICAgICAgIC5hdHRyKFwiZFwiLCBhcmMzKVxuICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBkdkNvbG9yKVxuICAgICAgICAgICAgLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIGZpbGxUaGlzKHRoaXMsIC4zLCAwLCAxMDApO1xuICAgICAgICAgICAgICAgIGZpbGwoZCwgJ2R2VGV4dCcsIC45LCAwLCAxMDApO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgZmlsbFRoaXModGhpcywgMCwgMTAwLCA1MDApO1xuICAgICAgICAgICAgICAgIGZpbGwoZCwgJ2R2VGV4dCcsIDAsIDEwMCwgNTAwKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ2NsaWNrJywgZCA9PiB7XG4gICAgICAgICAgICAgICAgc2V0Q29sb3JzKGQsIGR2Q29sb3IpO1xuICAgICAgICAgICAgICAgIGxlZ2VuZChkdkNvbG9yKTtcbiAgICAgICAgICAgICAgICByZXN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgZC5ncm91cDEgPSBkLmdyb3VwMiA9IGZhbHNlO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgZy5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsIGFwcGVuZCgnZHZUZXh0JykpXG4gICAgICAgICAgICAuYXR0cihcInhcIiwgNilcbiAgICAgICAgICAgIC5hdHRyKFwiZHlcIiwgMTEuNSlcbiAgICAgICAgICAgIC5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAuYXBwZW5kKFwidGV4dFBhdGhcIilcbiAgICAgICAgICAgIC5hdHRyKFwieGxpbms6aHJlZlwiLCBhcHBlbmQoJyNkdkFyYycpKVxuICAgICAgICAgICAgLnRleHQoXCJEZXAgVmFyXCIpO1xuXG4gICAgICAgIGcuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBhcHBlbmQoJ25vbUFyYycpKVxuICAgICAgICAgICAgLmF0dHIoXCJkXCIsIGFyYzQpXG4gICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIG5vbUNvbG9yKVxuICAgICAgICAgICAgLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIGlmIChkLmRlZmF1bHROdW1jaGFyID09IFwiY2hhcmFjdGVyXCIpIHJldHVybjtcbiAgICAgICAgICAgICAgICBmaWxsVGhpcyh0aGlzLCAuMywgMCwgMTAwKTtcbiAgICAgICAgICAgICAgICBmaWxsKGQsIFwibm9tVGV4dFwiLCAuOSwgMCwgMTAwKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIGlmIChkLmRlZmF1bHROdW1jaGFyID09IFwiY2hhcmFjdGVyXCIpIHJldHVybjtcbiAgICAgICAgICAgICAgICBmaWxsVGhpcyh0aGlzLCAwLCAxMDAsIDUwMCk7XG4gICAgICAgICAgICAgICAgZmlsbChkLCBcIm5vbVRleHRcIiwgMCwgMTAwLCA1MDApO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignY2xpY2snLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGQuZGVmYXVsdE51bWNoYXIgPT0gXCJjaGFyYWN0ZXJcIikgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHNldENvbG9ycyhkLCBub21Db2xvcik7XG4gICAgICAgICAgICAgICAgbGVnZW5kKG5vbUNvbG9yKTtcbiAgICAgICAgICAgICAgICByZXN0YXJ0KCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgYXBwZW5kKFwibm9tVGV4dFwiKSlcbiAgICAgICAgICAgIC5hdHRyKFwieFwiLCA2KVxuICAgICAgICAgICAgLmF0dHIoXCJkeVwiLCAxMS41KVxuICAgICAgICAgICAgLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgIC5hcHBlbmQoXCJ0ZXh0UGF0aFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ4bGluazpocmVmXCIsIGFwcGVuZChcIiNub21BcmNcIikpXG4gICAgICAgICAgICAudGV4dChcIk5vbWluYWxcIik7XG5cbiAgICAgICAgZy5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsIGFwcGVuZCgnZ3JBcmMnKSlcbiAgICAgICAgICAgIC5hdHRyKFwiZFwiLCBhcmMxKVxuICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCAgZ3IxQ29sb3IpXG4gICAgICAgICAgICAuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgZmlsbChkLCBcImdyMWluZGljYXRvclwiLCAuMywgMCwgMTAwKTtcbiAgICAgICAgICAgICAgICBmaWxsKGQsIFwiZ3IyaW5kaWNhdG9yXCIsIC4zLCAwLCAxMDApO1xuICAgICAgICAgICAgICAgIGZpbGxUaGlzKHRoaXMsIC4zLCAwLCAxMDApO1xuICAgICAgICAgICAgICAgIGZpbGwoZCwgJ2dyVGV4dCcsIC45LCAwLCAxMDApO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgZmlsbChkLCBcImdyMWluZGljYXRvclwiLCAwLCAxMDAsIDUwMCk7XG4gICAgICAgICAgICAgICAgZmlsbChkLCBcImdyMmluZGljYXRvclwiLCAwLCAxMDAsIDUwMCk7XG4gICAgICAgICAgICAgICAgZmlsbFRoaXModGhpcywgMCwgMTAwLCA1MDApO1xuICAgICAgICAgICAgICAgIGZpbGwoZCwgJ2dyVGV4dCcsIDAsIDEwMCwgNTAwKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ2NsaWNrJywgZCA9PiB7XG4gICAgICAgICAgICAgICAgLy9kLmdyb3VwMSA9ICFkLmdyb3VwMTsgICAgICAvLyBUaGlzIG1pZ2h0IGJlIGVhc2llciwgYnV0IGN1cnJlbnRseSBzZXQgaW4gc2V0Q29sb3JzKClcbiAgICAgICAgICAgICAgICBzZXRDb2xvcnMoZCwgZ3IxQ29sb3IpO1xuICAgICAgICAgICAgICAgIGxlZ2VuZChncjFDb2xvcik7XG4gICAgICAgICAgICAgICAgcmVzdGFydCgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgZy5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsIGFwcGVuZCgnZ3IxaW5kaWNhdG9yJykpXG4gICAgICAgICAgICAuYXR0cihcImRcIiwgYXJjSW5kMSlcbiAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgZ3IxQ29sb3IpICAvLyBzb21ldGhpbmcgbGlrZTogenBhcmFtcy56Z3JvdXAxLmluZGV4T2Yobm9kZS5uYW1lKSA+IC0xICA/ICAjRkZGRkZGIDogZ3IxQ29sb3IpXG4gICAgICAgICAgICAuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgZmlsbFRoaXModGhpcywgLjMsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgZmlsbChkLCBcImdyQXJjXCIsIC4xLCAwLCAxMDApO1xuICAgICAgICAgICAgICAgIGZpbGwoZCwgJ2dyVGV4dCcsIC45LCAwLCAxMDApO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgZmlsbFRoaXModGhpcywgMCwgMTAwLCA1MDApO1xuICAgICAgICAgICAgICAgIGZpbGwoZCwgXCJnckFyY1wiLCAwLCAxMDAsIDUwMCk7XG4gICAgICAgICAgICAgICAgZmlsbChkLCAnZ3JUZXh0JywgMCwgMTAwLCA1MDApO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignY2xpY2snLCBkID0+IHtcbiAgICAgICAgICAgICAgICAvL2QuZ3JvdXAxID0gIWQuZ3JvdXAxOyAgICAgIC8vIFRoaXMgbWlnaHQgYmUgZWFzaWVyLCBidXQgY3VycmVudGx5IHNldCBpbiBzZXRDb2xvcnMoKVxuICAgICAgICAgICAgICAgIHNldENvbG9ycyhkLCBncjFDb2xvcik7XG4gICAgICAgICAgICAgICAgbGVnZW5kKGdyMUNvbG9yKTtcbiAgICAgICAgICAgICAgICByZXN0YXJ0KCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgZy5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsIGFwcGVuZCgnZ3IyaW5kaWNhdG9yJykpXG4gICAgICAgICAgICAuYXR0cihcImRcIiwgYXJjSW5kMilcbiAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgZ3IyQ29sb3IpICAvLyBzb21ldGhpbmcgbGlrZTogenBhcmFtcy56Z3JvdXAxLmluZGV4T2Yobm9kZS5uYW1lKSA+IC0xICA/ICAjRkZGRkZGIDogZ3IxQ29sb3IpXG4gICAgICAgICAgICAuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgZmlsbFRoaXModGhpcywgLjMsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgZmlsbChkLCBcImdyQXJjXCIsIC4xLCAwLCAxMDApO1xuICAgICAgICAgICAgICAgIGZpbGwoZCwgJ2dyVGV4dCcsIC45LCAwLCAxMDApO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgZmlsbFRoaXModGhpcywgMCwgMTAwLCA1MDApO1xuICAgICAgICAgICAgICAgIGZpbGwoZCwgXCJnckFyY1wiLCAwLCAxMDAsIDUwMCk7XG4gICAgICAgICAgICAgICAgZmlsbChkLCAnZ3JUZXh0JywgMCwgMTAwLCA1MDApO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignY2xpY2snLCBkID0+IHtcbiAgICAgICAgICAgICAgICAvL2QuZ3JvdXAyID0gIWQuZ3JvdXAyOyAgICAgIC8vIFRoaXMgbWlnaHQgYmUgZWFzaWVyLCBidXQgY3VycmVudGx5IHNldCBpbiBzZXRDb2xvcnMoKVxuICAgICAgICAgICAgICAgIHNldENvbG9ycyhkLCBncjJDb2xvcik7XG4gICAgICAgICAgICAgICAgbGVnZW5kKGdyMkNvbG9yKTtcbiAgICAgICAgICAgICAgICByZXN0YXJ0KCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgYXBwZW5kKCdnclRleHQnKSlcbiAgICAgICAgICAgIC5hdHRyKFwieFwiLCA2KVxuICAgICAgICAgICAgLmF0dHIoXCJkeVwiLCAxMS41KVxuICAgICAgICAgICAgLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgIC5hcHBlbmQoXCJ0ZXh0UGF0aFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ4bGluazpocmVmXCIsIGFwcGVuZCgnI2dyQXJjJykpXG4gICAgICAgICAgICAudGV4dChcIkdyb3Vwc1wiKTtcblxuICAgICAgICBnLmFwcGVuZCgnc3ZnOmNpcmNsZScpXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbm9kZScpXG4gICAgICAgICAgICAuYXR0cigncicsIGQgPT4gc2V0UGViYmxlUmFkaXVzKGQpKVxuICAgICAgICAgICAgLnN0eWxlKCdwb2ludGVyLWV2ZW50cycsICdpbmhlcml0JylcbiAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIGQgPT4gZC5ub2RlQ29sKVxuICAgICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgXCIwLjVcIilcbiAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgZCA9PiBkMy5yZ2IoZC5zdHJva2VDb2xvcikudG9TdHJpbmcoKSlcbiAgICAgICAgICAgIC5jbGFzc2VkKCdyZWZsZXhpdmUnLCBkID0+IGQucmVmbGV4aXZlKVxuICAgICAgICAgICAgLm9uKCdkYmxjbGljaycsIGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgICAgICAgICBkMy5ldmVudC5zdG9wUHJvcGFnYXRpb24oKTsgLy8gc3RvcCBjbGljayBmcm9tIGJ1YmJsaW5nXG4gICAgICAgICAgICAgICAgc3VtbWFyeUhvbGQgPSB0cnVlO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignY29udGV4dG1lbnUnLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgLy8gcmlnaHQgY2xpY2sgb24gbm9kZVxuICAgICAgICAgICAgICAgIGQzLmV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZDMuZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgICAgICAgICByaWdodENsaWNrTGFzdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgbW91c2Vkb3duX25vZGUgPSBkO1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkX25vZGUgPSBtb3VzZWRvd25fbm9kZSA9PT0gc2VsZWN0ZWRfbm9kZSA/IG51bGwgOiBtb3VzZWRvd25fbm9kZTtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZF9saW5rID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIC8vIHJlcG9zaXRpb24gZHJhZyBsaW5lXG4gICAgICAgICAgICAgICAgZHJhZ19saW5lXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnbWFya2VyLWVuZCcsICd1cmwoI2VuZC1hcnJvdyknKVxuICAgICAgICAgICAgICAgICAgICAuY2xhc3NlZCgnaGlkZGVuJywgZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkJywgJ00nICsgbW91c2Vkb3duX25vZGUueCArICcsJyArIG1vdXNlZG93bl9ub2RlLnkgKyAnTCcgKyBtb3VzZWRvd25fbm9kZS54ICsgJywnICsgbW91c2Vkb3duX25vZGUueSk7XG5cbiAgICAgICAgICAgICAgICBzdmcub24oJ21vdXNlbW92ZScsIG1vdXNlbW92ZSk7XG4gICAgICAgICAgICAgICAgcmVzdGFydCgpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignbW91c2V1cCcsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICBkMy5ldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAgICAgICAgIGlmIChyaWdodENsaWNrTGFzdCkge1xuICAgICAgICAgICAgICAgICAgICByaWdodENsaWNrTGFzdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghbW91c2Vkb3duX25vZGUpIHJldHVybjtcblxuICAgICAgICAgICAgICAgIC8vIG5lZWRlZCBieSBGRlxuICAgICAgICAgICAgICAgIGRyYWdfbGluZVxuICAgICAgICAgICAgICAgICAgICAuY2xhc3NlZCgnaGlkZGVuJywgdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdtYXJrZXItZW5kJywgJycpO1xuXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGRyYWctdG8tc2VsZlxuICAgICAgICAgICAgICAgIG1vdXNldXBfbm9kZSA9IGQ7XG4gICAgICAgICAgICAgICAgaWYgKG1vdXNldXBfbm9kZSA9PT0gbW91c2Vkb3duX25vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzZXRNb3VzZVZhcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHVuZW5sYXJnZSB0YXJnZXQgbm9kZVxuICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5hdHRyKCd0cmFuc2Zvcm0nLCAnJyk7XG5cbiAgICAgICAgICAgICAgICAvLyBhZGQgbGluayB0byBncmFwaCAodXBkYXRlIGlmIGV4aXN0cylcbiAgICAgICAgICAgICAgICAvLyBOQjogbGlua3MgYXJlIHN0cmljdGx5IHNvdXJjZSA8IHRhcmdldDsgYXJyb3dzIHNlcGFyYXRlbHkgc3BlY2lmaWVkIGJ5IGJvb2xlYW5zXG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZSwgdGFyZ2V0LCBkaXJlY3Rpb247XG4gICAgICAgICAgICAgICAgaWYgKG1vdXNlZG93bl9ub2RlLmlkIDwgbW91c2V1cF9ub2RlLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZSA9IG1vdXNlZG93bl9ub2RlO1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSBtb3VzZXVwX25vZGU7XG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlID0gbW91c2V1cF9ub2RlO1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSBtb3VzZWRvd25fbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gJ2xlZnQnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxldCBsaW5rID0gbGlua3MuZmlsdGVyKHggPT4geC5zb3VyY2UgPT0gc291cmNlICYmIHgudGFyZ2V0ID09IHRhcmdldClbMF07XG4gICAgICAgICAgICAgICAgaWYgKGxpbmspIHtcbiAgICAgICAgICAgICAgICAgICAgbGlua1tkaXJlY3Rpb25dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsaW5rID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGxpbmtbZGlyZWN0aW9uXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGxpbmtzLnB1c2gobGluayk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gc2VsZWN0IG5ldyBsaW5rXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRfbGluayA9IGxpbms7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRfbm9kZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgc3ZnLm9uKCdtb3VzZW1vdmUnLCBudWxsKTtcblxuICAgICAgICAgICAgICAgIHJlc2V0TW91c2VWYXJzKCk7XG4gICAgICAgICAgICAgICAgcmVzdGFydCgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gc2hvdyBub2RlIG5hbWVzXG4gICAgICAgIGcuYXBwZW5kKCdzdmc6dGV4dCcpXG4gICAgICAgICAgICAuYXR0cigneCcsIDApXG4gICAgICAgICAgICAuYXR0cigneScsIDE1KVxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2lkJylcbiAgICAgICAgICAgIC50ZXh0KGQgPT4gZC5uYW1lKTtcblxuICAgICAgICAvLyBzaG93IHN1bW1hcnkgc3RhdHMgb24gbW91c2VvdmVyXG4gICAgICAgIC8vIFNWRyBkb2Vzbid0IHN1cHBvcnQgdGV4dCB3cmFwcGluZywgdXNlIGh0bWwgaW5zdGVhZFxuICAgICAgICBnLnNlbGVjdEFsbChcImNpcmNsZS5ub2RlXCIpXG4gICAgICAgICAgICAub24oXCJtb3VzZW92ZXJcIiwgZCA9PiB7XG4gICAgICAgICAgICAgICAgdGFiTGVmdCgndGFiMycpO1xuICAgICAgICAgICAgICAgIHZhclN1bW1hcnkoZCk7XG4gICAgICAgICAgICAgICAgZC5mb3JlZnJvbnQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgYnlJZCgndHJhbnNmb3JtYXRpb25zJykuc2V0QXR0cmlidXRlKCdzdHlsZScsICdkaXNwbGF5OmJsb2NrJyk7XG4gICAgICAgICAgICAgICAgYnlJZChcInRyYW5zU2VsXCIpLnNlbGVjdGVkSW5kZXggPSBkLmlkO1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybVZhciA9IHZhbHVlS2V5W2QuaWRdO1xuXG4gICAgICAgICAgICAgICAgZmlsbChkLCBcImR2QXJjXCIsIC4xLCAwLCAxMDApO1xuICAgICAgICAgICAgICAgIGZpbGwoZCwgXCJkdlRleHRcIiwgLjUsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgZmlsbChkLCBcImdyQXJjXCIsIC4xLCAwLCAxMDApO1xuICAgICAgICAgICAgICAgIGZpbGwoZCwgXCJnclRleHRcIiwgLjUsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgLy9maWxsKGQsIFwiZ3IxaW5kaWNhdG9yXCIsIC4xLCAwLCAxMDApO1xuICAgICAgICAgICAgICAgIC8vZmlsbChkLCBcImdyMWluZGljYXRvclRleHRcIiwgLjEsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgLy9maWxsKGQsIFwiZ3IyaW5kaWNhdG9yXCIsIC4xLCAwLCAxMDApO1xuICAgICAgICAgICAgICAgIC8vZmlsbChkLCBcImdyMmluZGljYXRvclRleHRcIiwgLjEsIDAsIDEwMCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZC5kZWZhdWx0TnVtY2hhciA9PSBcIm51bWVyaWNcIikge1xuICAgICAgICAgICAgICAgICAgICBmaWxsKGQsIFwibm9tQXJjXCIsIC4xLCAwLCAxMDApO1xuICAgICAgICAgICAgICAgICAgICBmaWxsKGQsIFwibm9tVGV4dFwiLCAuNSwgMCwgMTAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmlsbChkLCBcImNzQXJjXCIsIC4xLCAwLCAxMDApO1xuICAgICAgICAgICAgICAgIGZpbGwoZCwgXCJjc1RleHRcIiwgLjUsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgZmlsbChkLCBcInRpbWVBcmNcIiwgLjEsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgZmlsbChkLCBcInRpbWVUZXh0XCIsIC41LCAwLCAxMDApO1xuXG4gICAgICAgICAgICAgICAgbS5yZWRyYXcoKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZCA9PiB7XG4gICAgICAgICAgICAgICAgZC5mb3JlZnJvbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBzdW1tYXJ5SG9sZCB8fCB0YWJMZWZ0KHN1YnNldCA/ICd0YWIyJyA6ICd0YWIxJyk7XG4gICAgICAgICAgICAgICAgJ2NzQXJjIGNzVGV4dCB0aW1lQXJjIHRpbWVUZXh0IGR2QXJjIGR2VGV4dCBub21BcmMgbm9tVGV4dCBnckFyYyBnclRleHQnLnNwbGl0KCcgJykubWFwKHggPT4gZmlsbChkLCB4LCAwLCAxMDAsIDUwMCkpO1xuICAgICAgICAgICAgICAgIG0ucmVkcmF3KCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAvLyB0aGUgdHJhbnNmb3JtYXRpb24gdmFyaWFibGUgbGlzdCBpcyBzaWxlbnRseSB1cGRhdGVkIGFzIHBlYmJsZXMgYXJlIGFkZGVkL3JlbW92ZWRcbiAgICAgICAgZDMuc2VsZWN0KFwiI3RyYW5zU2VsXCIpXG4gICAgICAgICAgICAuc2VsZWN0QWxsKCdsaScpXG4gICAgICAgICAgICAucmVtb3ZlKCk7XG5cbiAgICAgICAgZDMuc2VsZWN0KFwiI3RyYW5zU2VsXCIpXG4gICAgICAgICAgICAuc2VsZWN0QWxsKCdsaScpXG4gICAgICAgICAgICAuZGF0YShub2Rlcy5tYXAoeCA9PiB4Lm5hbWUpKSAvLyBzZXQgdG8gdmFyaWFibGVzIGluIG1vZGVsIHNwYWNlIGFzIHRoZXkncmUgYWRkZWRcbiAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAuYXBwZW5kKFwibGlcIilcbiAgICAgICAgICAgIC50ZXh0KGQgPT4gZCk7XG5cbiAgICAgICAgaWYoIUlTX0QzTV9ET01BSU4pe1xuICAgICAgICAgICAgJCgnI3RyYW5zU2VsIGxpJykuY2xpY2soZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgJ2ludGVyYWN0aW9uJyBpcyB0aGUgc2VsZWN0ZWQgZnVuY3Rpb24sIGRvbid0IHNob3cgdGhlIGZ1bmN0aW9uIGxpc3QgYWdhaW5cbiAgICAgICAgICAgICAgICBpZiAoc2VsSW50ZXJhY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSAkKCcjdElucHV0JykudmFsKCkuY29uY2F0KCQodGhpcykudGV4dCgpKTtcbiAgICAgICAgICAgICAgICAgICAgJCgnI3RJbnB1dCcpLnZhbChuKTtcbiAgICAgICAgICAgICAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IHRyYW5zUGFyc2UobiA9IG4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXQpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5wYXJlbnQoKS5mYWRlT3V0KDEwMCk7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybShuID0gdC5zbGljZSgwLCB0Lmxlbmd0aCAtIDEpLCB0ID0gdFt0Lmxlbmd0aCAtIDFdLCB0eXBlVHJhbnNmb3JtID0gZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgJCgnI3RJbnB1dCcpLnZhbCgkKHRoaXMpLnRleHQoKSk7XG4gICAgICAgICAgICAgICAgJCh0aGlzKS5wYXJlbnQoKS5mYWRlT3V0KDEwMCk7XG4gICAgICAgICAgICAgICAgJCgnI3RyYW5zTGlzdCcpLmZhZGVJbigxMDApO1xuICAgICAgICAgICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHJlbW92ZSBvbGQgbm9kZXNcbiAgICAgICAgY2lyY2xlLmV4aXQoKS5yZW1vdmUoKTtcbiAgICAgICAgZm9yY2Uuc3RhcnQoKTtcblxuICAgICAgICAvLyBzYXZlIHdvcmtzcGFjZXNcbiAgICAgICAgY29uc29sZS5sb2coJ29rIHdzJyk7XG4gICAgICAgIHJlY29yZF91c2VyX21ldGFkYXRhKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW91c2Vkb3duKGQpIHtcbiAgICAgICAgLy8gcHJldmVudCBJLWJhciBvbiBkcmFnXG4gICAgICAgIGQzLmV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIC8vIGJlY2F1c2UgOmFjdGl2ZSBvbmx5IHdvcmtzIGluIFdlYktpdD9cbiAgICAgICAgc3ZnLmNsYXNzZWQoJ2FjdGl2ZScsIHRydWUpO1xuICAgICAgICBpZiAoZDMuZXZlbnQuY3RybEtleSB8fCBtb3VzZWRvd25fbm9kZSB8fCBtb3VzZWRvd25fbGluaykgcmV0dXJuO1xuICAgICAgICByZXN0YXJ0KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW91c2Vtb3ZlKGQpIHtcbiAgICAgICAgaWYgKCFtb3VzZWRvd25fbm9kZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gdXBkYXRlIGRyYWcgbGluZVxuICAgICAgICBkcmFnX2xpbmUuYXR0cignZCcsICdNJyArIG1vdXNlZG93bl9ub2RlLnggKyAnLCcgKyBtb3VzZWRvd25fbm9kZS55ICsgJ0wnICsgZDMubW91c2UodGhpcylbMF0gKyAnLCcgKyBkMy5tb3VzZSh0aGlzKVsxXSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW91c2V1cChkKSB7XG4gICAgICAgIGlmIChtb3VzZWRvd25fbm9kZSkge1xuICAgICAgICAgICAgZHJhZ19saW5lXG4gICAgICAgICAgICAgICAgLmNsYXNzZWQoJ2hpZGRlbicsIHRydWUpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdtYXJrZXItZW5kJywgJycpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGJlY2F1c2UgOmFjdGl2ZSBvbmx5IHdvcmtzIGluIFdlYktpdD9cbiAgICAgICAgc3ZnLmNsYXNzZWQoJ2FjdGl2ZScsIGZhbHNlKTtcbiAgICAgICAgLy8gY2xlYXIgbW91c2UgZXZlbnQgdmFyc1xuICAgICAgICByZXNldE1vdXNlVmFycygpO1xuICAgIH1cblxuICAgIC8vIGFwcCBzdGFydHMgaGVyZVxuICAgIHN2Zy5hdHRyKCdpZCcsICgpID0+IFwid2hpdGVzcGFjZVwiLmNvbmNhdChteXNwYWNlKSlcbiAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGhlaWdodClcbiAgICAgICAgLm9uKCdtb3VzZWRvd24nLCBmdW5jdGlvbigpIHttb3VzZWRvd24odGhpcyk7fSlcbiAgICAgICAgLm9uKCdtb3VzZXVwJywgZnVuY3Rpb24oKSB7bW91c2V1cCh0aGlzKTt9KTtcblxuICAgIGQzLnNlbGVjdCh3aW5kb3cpXG4gICAgICAgIC5vbignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgICAvLyBhbGwgY2xpY2tzIHdpbGwgYnViYmxlIGhlcmUgdW5sZXNzIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICAgICAgICAkKCcjdHJhbnNMaXN0JykuZmFkZU91dCgxMDApO1xuICAgICAgICAgICAgJCgnI3RyYW5zU2VsJykuZmFkZU91dCgxMDApO1xuICAgICAgICB9KTtcblxuICAgIHJlc3RhcnQoKTsgLy8gaW5pdGlhbGl6ZXMgZm9yY2UubGF5b3V0KClcbiAgICBmYWtlQ2xpY2soKTtcblxuICAgIGlmKHYyICYgSVNfRDNNX0RPTUFJTikge1xuICAgICAgICB2YXIgY2xpY2tfZXYgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIk1vdXNlRXZlbnRzXCIpO1xuICAgICAgICAvLyBpbml0aWFsaXplIHRoZSBldmVudFxuICAgICAgICBjbGlja19ldi5pbml0RXZlbnQoXCJjbGlja1wiLCB0cnVlIC8qIGJ1YmJsZSAqLywgdHJ1ZSAvKiBjYW5jZWxhYmxlICovKTtcbiAgICAgICAgLy8gdHJpZ2dlciB0aGUgZXZlbnRcbiAgICAgICAgbGV0IGNsaWNrSUQgPSBcImR2QXJjXCIrZmluZE5vZGVJbmRleChteXRhcmdldCk7XG4gICAgICAgIGJ5SWQoY2xpY2tJRCkuZGlzcGF0Y2hFdmVudChjbGlja19ldik7XG4gICAgfVxufVxuXG5cbi8qKiBuZWVkcyBkb2MgKi9cbmZ1bmN0aW9uIGZpbmQoJG5vZGVzLCBuYW1lKSB7XG4gICAgZm9yIChsZXQgaSBpbiAkbm9kZXMpXG4gICAgICAgIGlmICgkbm9kZXNbaV0ubmFtZSA9PSBuYW1lKSByZXR1cm4gJG5vZGVzW2ldLmlkO1xufVxuXG4vKipcbiAgIHJldHVybnMgaWRcbiovXG5leHBvcnQgZnVuY3Rpb24gZmluZE5vZGVJbmRleChuYW1lLCB3aG9sZSkge1xuICAgIGZvciAobGV0IG5vZGUgb2YgYWxsTm9kZXMpXG4gICAgICAgIGlmIChub2RlLm5hbWUgPT09IG5hbWUpIHJldHVybiB3aG9sZSA/IG5vZGUgOiBub2RlLmlkO1xufVxuXG4vKiogbmVlZHMgZG9jICovXG5mdW5jdGlvbiBub2RlSW5kZXgobm9kZU5hbWUpIHtcbiAgICBmb3IgKGxldCBpIGluIG5vZGVzKVxuICAgICAgICBpZiAobm9kZXNbaV0ubmFtZSA9PT0gbm9kZU5hbWUpIHJldHVybiBpO1xufVxuXG4vKiogbmVlZHMgZG9jICovXG5leHBvcnQgZnVuY3Rpb24gZmluZE5vZGUobmFtZSkge1xuICAgIGZvciAobGV0IG4gb2YgYWxsTm9kZXMpXG4gICAgICAgIGlmIChuLm5hbWUgPT09IG5hbWUpXG4gICAgICAgICAgICByZXR1cm4gbjtcbn1cblxuLyoqIG5lZWRzIGRvYyAqL1xuZnVuY3Rpb24gdXBkYXRlTm9kZShpZCkge1xuICAgIGxldCBub2RlID0gZmluZE5vZGUoaWQpO1xuICAgIGlmIChub2RlLmdyYXlvdXQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIGxldCBuYW1lID0gbm9kZS5uYW1lO1xuICAgIGxldCBuYW1lcyA9ICgpID0+IG5vZGVzLm1hcChuID0+IG4ubmFtZSk7XG4gICAgaWYgKG5hbWVzKCkuaW5jbHVkZXMobmFtZSkpIHtcbiAgICAgICAgZGVsKG5vZGVzLCBub2RlLmluZGV4KTtcbiAgICAgICAgbGlua3NcbiAgICAgICAgICAgIC5maWx0ZXIobCA9PiBsLnNvdXJjZSA9PT0gbm9kZSB8fCBsLnRhcmdldCA9PT0gbm9kZSlcbiAgICAgICAgICAgIC5mb3JFYWNoKGwgPT4gZGVsKGxpbmtzLCAtMSwgbCkpO1xuICAgICAgICB6cGFyYW1zUmVzZXQobmFtZSk7XG5cbiAgICAgICAgLy8gcmVtb3ZlIG5vZGUgbmFtZSBmcm9tIGdyb3VwIGxpc3RzXG4gICAgICAgIG5vZGUuZ3JvdXAxICYmIGRlbCh6cGFyYW1zLnpncm91cDEsIC0xLCBuYW1lKTtcbiAgICAgICAgbm9kZS5ncm91cDIgJiYgZGVsKHpwYXJhbXMuemdyb3VwMiwgLTEsIG5hbWUpO1xuICAgICAgICBub2RlLmdyb3VwMSA9IG5vZGUuZ3JvdXAyID0gZmFsc2U7XG5cbiAgICAgICAgLy8gbm9kZSByZXNldCAtIHBlcmhhcHMgdGhpcyB3aWxsIGJlY29tZSBhIGhhcmQgcmVzZXQgYmFjayB0byBhbGwgb3JpZ2luYWwgYWxsTm9kZSB2YWx1ZXM/XG4gICAgICAgIG5vZGUubm9kZUNvbCA9IG5vZGUuYmFzZUNvbDtcbiAgICAgICAgbm9kZS5zdHJva2VDb2xvciA9IHNlbFZhckNvbG9yO1xuICAgICAgICBub2RlLnN0cm9rZVdpZHRoID0gJzEnO1xuXG4gICAgICAgIGJvcmRlclN0YXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZXMucHVzaChub2RlKTtcbiAgICB9XG4gICAgenBhcmFtcy56dmFycyA9IG5hbWVzKCk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICAgZXZlcnkgdGltZSBhIHZhcmlhYmxlIGluIGxlZnRwYW5lbCBpcyBjbGlja2VkLCBub2RlcyB1cGRhdGVzIGFuZCBiYWNrZ3JvdW5kIGNvbG9yIGNoYW5nZXNcbiovXG5leHBvcnQgZnVuY3Rpb24gY2xpY2tWYXIoZWxlbSkge1xuICAgIGlmICh1cGRhdGVOb2RlKGVsZW0udGFyZ2V0LmlkKSkge1xuICAgICAgICAvLyBwYW5lbFBsb3RzKCk7IGlzIHRoaXMgbmVjZXNzYXJ5P1xuICAgICAgICByZXN0YXJ0KCk7XG4gICAgfVxufVxuXG4vKipcbiAgUmV0cmlldmUgdGhlIHZhcmlhYmxlIGxpc3QgZnJvbSB0aGUgcHJlcHJvY2VzcyBkYXRhLlxuICBUaGlzIGhlbHBzIGhhbmRsZSB0aGUgbmV3IGZvcm1hdCBhbmQgKHRlbXBvcmFyaWx5KVxuICB0aGUgb2xkZXIgZm9ybWF0IGluIFBST0RVQ1RJT04gKHJwIDguMTQuMjAxNylcbiAgXCJuZXdcIiByZXNwb25zZTpcbiAge1xuICBcImRhdGFzZXRcIiA6IHsuLi59XG4gIFwidmFyaWFibGVzXCIgOiB7XG4gIFwidmFyMVwiIDogey4uLn0sXG4gIChldGMpXG4gIH1cbiAgfVxuICBcIm9sZFwiIHJlc3BvbnNlOlxuICB7XG4gIFwidmFyMVwiIDogey4uLn0sXG4gIChldGMpXG4gIH1cbiovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VmFyaWFibGVEYXRhKGpzb24pIHtcbiAgICByZXR1cm4ganNvbi5oYXNPd25Qcm9wZXJ0eSgndmFyaWFibGVzJykgPyBqc29uLnZhcmlhYmxlcyA6IGpzb247XG59XG5cbi8qKlxuICAgY2FsbGVkIGJ5IGZvcmNlIGJ1dHRvblxuKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JjZVN3aXRjaCgpIHtcbiAgICBmb3JjZXRvZ2dsZSA9IFtmb3JjZXRvZ2dsZVswXSA9PSAndHJ1ZScgPyAnZmFsc2UnIDogJ3RydWUnXTtcbiAgICBpZiAoZm9yY2V0b2dnbGVbMF0gPT09IFwiZmFsc2VcIikge1xuICAgICAgICBieUlkKCdidG5Gb3JjZScpLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiYnRuIGFjdGl2ZVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBieUlkKCdidG5Gb3JjZScpLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiYnRuIGJ0bi1kZWZhdWx0XCIpO1xuICAgICAgICBmYWtlQ2xpY2soKTtcbiAgICB9XG59XG5cbi8qKiBuZWVkcyBkb2MgKi9cbmV4cG9ydCBmdW5jdGlvbiBoZWxwbWF0ZXJpYWxzKHR5cGUpIHtcbiAgICBpZih0eXBlPT1cInZpZGVvXCIpe1xuICAgICAgICB2YXIgd2luID0gd2luZG93Lm9wZW4oXCJodHRwOi8vMnJhLnZuL2RlbW9zL2QzbWludGVncmF0aW9uZGVtby5tcDRcIiwgJ19ibGFuaycpO1xuICAgICAgICB3aW4uZm9jdXMoKTtcbiAgICB9ZWxzZXtcbiAgICAgICAgdmFyIHdpbiA9IHdpbmRvdy5vcGVuKFwiaHR0cDovLzJyYS52bi9wYXBlcnMvdHdvcmF2ZW5zLWQzbWd1aWRlLnBkZlwiLCAnX2JsYW5rJyk7XG4gICAgICAgIHdpbi5mb2N1cygpO1xuICAgIH1cbiAgICBjb25zb2xlLmxvZyh0eXBlKTtcbn1cblxuLyoqIG5lZWRzIGRvYyAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxvY2tEZXNjcmlwdGlvbigpIHtcbiAgICBsb2NrdG9nZ2xlID0gbG9ja3RvZ2dsZSA/IGZhbHNlIDogdHJ1ZTtcbiAgICBsZXQgdGVtcDtcbiAgICBsZXQgaTtcbiAgICBpZiAoIWxvY2t0b2dnbGUpIHtcbiAgICAgICAgYnlJZCgnYnRuTG9jaycpLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiYnRuIGJ0bi1kZWZhdWx0XCIpO1xuICAgICAgICB0ZW1wID0gYnlJZCgncmlnaHRDb250ZW50QXJlYScpLnF1ZXJ5U2VsZWN0b3JBbGwoXCJwLml0ZW0tbGluZW91dFwiKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRlbXAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRlbXBbaV0uY2xhc3NMaXN0LnJlbW92ZShcIml0ZW0tbGluZW91dFwiKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGJ5SWQoJ2J0bkxvY2snKS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImJ0biBhY3RpdmVcIik7XG4gICAgICAgIHRlbXAgPSBieUlkKCdtZXRyaWNzJykucXVlcnlTZWxlY3RvckFsbChcInAuaXRlbS1kZWZhdWx0XCIpO1xuICAgICAgICBjb25zb2xlLmxvZyh0ZW1wKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRlbXAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRlbXBbaV0uY2xhc3NMaXN0LmFkZChcIml0ZW0tbGluZW91dFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0ZW1wID0gYnlJZCgndHlwZXMnKS5xdWVyeVNlbGVjdG9yQWxsKFwicC5pdGVtLWRlZmF1bHRcIik7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0ZW1wLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0ZW1wW2ldLmNsYXNzTGlzdC5hZGQoXCJpdGVtLWxpbmVvdXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGVtcCA9IGJ5SWQoJ3N1YnR5cGVzJykucXVlcnlTZWxlY3RvckFsbChcInAuaXRlbS1kZWZhdWx0XCIpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGVtcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGVtcFtpXS5jbGFzc0xpc3QuYWRkKFwiaXRlbS1saW5lb3V0XCIpO1xuICAgICAgICB9XG4gICAgLyogICAgdGVtcCA9IGJ5SWQoJ291dHB1dHMnKS5xdWVyeVNlbGVjdG9yQWxsKFwicC5pdGVtLWRlZmF1bHRcIik7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0ZW1wLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0ZW1wW2ldLmNsYXNzTGlzdC5hZGQoXCJpdGVtLWxpbmVvdXRcIik7XG4gICAgICAgIH0gICovXG4gICAgICAgIGZha2VDbGljaygpO1xuICAgIH1cbn1cblxuLyoqIG5lZWRzIGRvYyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHpQb3AoKSB7XG4gICAgaWYgKGRhdGF1cmwpIHpwYXJhbXMuemRhdGF1cmwgPSBkYXRhdXJsO1xuICAgIHpwYXJhbXMuem1vZGVsY291bnQgPSBtb2RlbENvdW50O1xuICAgIHpwYXJhbXMuemVkZ2VzID0gW107XG4gICAgenBhcmFtcy56dmFycyA9IFtdO1xuICAgIHpwYXJhbXMuem5hdHVyZSA9IFtdO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgbm9kZXMubGVuZ3RoOyBqKyspIHsgLy9wb3B1bGF0ZSB6dmFycyBhcnJheVxuICAgICAgICB6cGFyYW1zLnp2YXJzLnB1c2gobm9kZXNbal0ubmFtZSk7XG4gICAgICAgIHpwYXJhbXMuem5hdHVyZS5wdXNoKG5vZGVzW2pdLm5hdHVyZSk7XG4gICAgICAgIGxldCB0ZW1wID0gbm9kZXNbal0uaWQ7XG4gICAgICAgIHpwYXJhbXMuenNldHhbal0gPSBhbGxOb2Rlc1t0ZW1wXS5zZXR4dmFscztcbiAgICAgICAgenBhcmFtcy56c3Vic2V0W2pdID0gYWxsTm9kZXNbdGVtcF0uc3Vic2V0cmFuZ2U7XG4gICAgfVxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgbGlua3MubGVuZ3RoOyBqKyspIHsgLy9wb3B1bGF0ZSB6ZWRnZXMgYXJyYXlcbiAgICAgICAgLy9jb3JyZWN0IHRoZSBzb3VyY2UgdGFyZ2V0IG9yZGVyaW5nIGZvciBaZWxpZ1xuICAgICAgICBsZXQgc3JjdGd0ID0gbGlua3Nbal0ubGVmdCA9PSBmYWxzZSA/XG4gICAgICAgICAgICBbbGlua3Nbal0uc291cmNlLm5hbWUsIGxpbmtzW2pdLnRhcmdldC5uYW1lXSA6XG4gICAgICAgICAgICBbbGlua3Nbal0udGFyZ2V0Lm5hbWUsIGxpbmtzW2pdLnNvdXJjZS5uYW1lXTtcbiAgICAgICAgenBhcmFtcy56ZWRnZXMucHVzaChzcmN0Z3QpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdGFidWxhdGUoZGF0YSwgY29sdW1ucywgZGl2aWQpIHtcbiAgICB2YXIgdGFibGUgPSBkMy5zZWxlY3QoZGl2aWQpLmFwcGVuZCgndGFibGUnKTtcbiAgICB2YXIgdGhlYWQgPSB0YWJsZS5hcHBlbmQoJ3RoZWFkJyk7XG4gICAgdmFyXHR0Ym9keSA9IHRhYmxlLmFwcGVuZCgndGJvZHknKTtcblxuICAgIC8vIGFwcGVuZCB0aGUgaGVhZGVyIHJvd1xuICAgIHRoZWFkLmFwcGVuZCgndHInKVxuICAgICAgICAuc2VsZWN0QWxsKCd0aCcpXG4gICAgICAgIC5kYXRhKGNvbHVtbnMpLmVudGVyKClcbiAgICAgICAgLmFwcGVuZCgndGgnKVxuICAgICAgICAudGV4dChmdW5jdGlvbiAoY29sdW1uKSB7IHJldHVybiBjb2x1bW47IH0pO1xuXG4gICAgLy8gY3JlYXRlIGEgcm93IGZvciBlYWNoIG9iamVjdCBpbiB0aGUgZGF0YVxuICAgIHZhciByb3dzID0gdGJvZHkuc2VsZWN0QWxsKCd0cicpXG4gICAgICAgIC5kYXRhKGRhdGEpXG4gICAgICAgIC5lbnRlcigpXG4gICAgICAgIC5hcHBlbmQoJ3RyJylcbiAgICAgICAgLmF0dHIoJ2NsYXNzJyxmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgIGlmKGk9PTApIHJldHVybiAnaXRlbS1zZWxlY3QnO1xuICAgICAgICAgICAgZWxzZSByZXR1cm4gJ2l0ZW0tZGVmYXVsdCc7XG4gICAgICAgIH0pO1xuXG4gICAgLy8gY3JlYXRlIGEgY2VsbCBpbiBlYWNoIHJvdyBmb3IgZWFjaCBjb2x1bW5cbiAgICB2YXIgY2VsbHMgPSByb3dzLnNlbGVjdEFsbCgndGQnKVxuICAgICAgICAuZGF0YShmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgICByZXR1cm4gY29sdW1ucy5tYXAoZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7Y29sdW1uOiBjb2x1bW4sIHZhbHVlOiByb3dbY29sdW1uXX07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlcbiAgICAgICAgLmVudGVyKClcbiAgICAgICAgLmFwcGVuZCgndGQnKVxuICAgICAgICAudGV4dChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuIGQudmFsdWU7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIGxldCBteXJvdyA9IHRoaXMucGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgIGlmKG15cm93LmNsYXNzTmFtZT09XCJpdGVtLXNlbGVjdFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkMy5zZWxlY3QoZGl2aWQpLnNlbGVjdChcInRyLml0ZW0tc2VsZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdpdGVtLWRlZmF1bHQnKTtcbiAgICAgICAgICAgICAgICBkMy5zZWxlY3QobXlyb3cpLmF0dHIoJ2NsYXNzJyxcIml0ZW0tc2VsZWN0XCIpO1xuICAgICAgICAgICAgICAgIGlmKGRpdmlkPT0nI3NldHhSaWdodCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c3Bsb3Rpbml0KGFsbFBpcGVsaW5lSW5mb1tteXJvdy5maXJzdENoaWxkLmlubmVyVGV4dF0sIGR2dmFsdWVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9fSk7XG5cbiAgICAvLyB0aGlzIGlzIGNvZGUgdG8gYWRkIGEgY2hlY2tib3ggdG8gZWFjaCByb3cgb2YgcGlwZWxpbmUgcmVzdWx0cyB0YWJsZVxuICAgIC8qXG4gICAgICBkMy5zZWxlY3QoZGl2aWQpLnNlbGVjdEFsbChcInRyXCIpXG4gICAgICAuYXBwZW5kKFwiaW5wdXRcIilcbiAgICAgIC5hdHRyKFwidHlwZVwiLCBcImNoZWNrYm94XCIpXG4gICAgICAuc3R5bGUoXCJmbG9hdFwiLFwicmlnaHRcIik7XG4gICAgKi9cblxuICAgIHJldHVybiB0YWJsZTtcblxufVxuXG5mdW5jdGlvbiBvblBpcGVsaW5lQ3JlYXRlKFBpcGVsaW5lQ3JlYXRlUmVzdWx0KSB7XG4gICAgLy8gcnBjIEdldEV4ZWN1dGVQaXBlbGluZVJlc3VsdHMoUGlwZWxpbmVFeGVjdXRlUmVzdWx0c1JlcXVlc3QpIHJldHVybnMgKHN0cmVhbSBQaXBlbGluZUV4ZWN1dGVSZXN1bHQpIHt9XG4gICAgZXN0aW1hdGVMYWRkYS5zdG9wKCk7IC8vIHN0b3Agc3Bpbm5lclxuXG4gICAgJChcIiNidG5Fc3RpbWF0ZVwiKS5yZW1vdmVDbGFzcyhcImJ0bi1zdWNjZXNzXCIpO1xuICAgICQoXCIjYnRuRXN0aW1hdGVcIikuYWRkQ2xhc3MoXCJidG4tZGVmYXVsdFwiKTtcbiAgICAkKFwiI2J0bkVuZFNlc3Npb25cIikucmVtb3ZlQ2xhc3MoXCJidG4tZGVmYXVsdFwiKTtcbiAgICAkKFwiI2J0bkVuZFNlc3Npb25cIikuYWRkQ2xhc3MoXCJidG4tc3VjY2Vzc1wiKTtcblxuICAgIGxldCBhbGxQaXBlbGluZUluZm8gPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaTxQaXBlbGluZUNyZWF0ZVJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZihQaXBlbGluZUNyZWF0ZVJlc3VsdFtpXS5waXBlbGluZUlkIGluIGFsbFBpcGVsaW5lSW5mbykge1xuICAgICAgICAgICAgYWxsUGlwZWxpbmVJbmZvW1BpcGVsaW5lQ3JlYXRlUmVzdWx0W2ldLnBpcGVsaW5lSWRdPU9iamVjdC5hc3NpZ24oYWxsUGlwZWxpbmVJbmZvW1BpcGVsaW5lQ3JlYXRlUmVzdWx0W2ldLnBpcGVsaW5lSWRdLFBpcGVsaW5lQ3JlYXRlUmVzdWx0W2ldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFsbFBpcGVsaW5lSW5mb1tQaXBlbGluZUNyZWF0ZVJlc3VsdFtpXS5waXBlbGluZUlkXT1QaXBlbGluZUNyZWF0ZVJlc3VsdFtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zb2xlLmxvZyhhbGxQaXBlbGluZUluZm8pO1xuICAgIC8vIHRvIGdldCBhbGwgcGlwZWxpbmUgaWRzOiBPYmplY3Qua2V5cyhhbGxQaXBlbGluZUluZm8pXG5cbiAgICBsZXQgcmVzdWx0c3RhYmxlID0gW107XG4gICAgZm9yKHZhciBrZXkgaW4gYWxsUGlwZWxpbmVJbmZvKSB7XG4gICAgICAgIC8vIGRvbid0IHJlcG9ydCB0aGUgcGlwZWxpbmUgdG8gdXNlciBpZiBpdCBoYXMgZmFpbGVkXG4gICAgICAgIGlmKGFsbFBpcGVsaW5lSW5mb1trZXldLnJlc3BvbnNlSW5mby5zdGF0dXMuZGV0YWlscyA9PSBcIlBpcGVsaW5lIEZhaWxlZFwiKSAge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG15aWQgPSBcIlwiO1xuICAgICAgICBsZXQgbXltZXRyaWMgPSBcIlwiO1xuICAgICAgICBsZXQgbXl2YWwgPSBcIlwiO1xuICAgICAgICBjb25zb2xlLmxvZyhhbGxQaXBlbGluZUluZm8pO1xuICAgICAgICBsZXQgbXlzY29yZXMgPSBhbGxQaXBlbGluZUluZm9ba2V5XS5waXBlbGluZUluZm8uc2NvcmVzO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbXlzY29yZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIC8vaWYoaT09MCkge215aWQ9a2V5O31cbiAgICAgICAgICAgIC8vICAgZWxzZSBteWlkPVwiXCI7XG4gICAgICAgICAgICBteWlkPWtleTtcbiAgICAgICAgICAgIG15bWV0cmljPW15c2NvcmVzW2ldLm1ldHJpYztcbiAgICAgICAgICAgIG15dmFsPStteXNjb3Jlc1tpXS52YWx1ZS50b0ZpeGVkKDMpO1xuICAgICAgICAgICAgcmVzdWx0c3RhYmxlLnB1c2goe1wiUGlwZWxpbmVJRFwiOm15aWQsXCJNZXRyaWNcIjpteW1ldHJpYywgXCJTY29yZVwiOm15dmFsfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZW5kZXIgdGhlIHRhYmxlXG4gICAgdGFidWxhdGUocmVzdWx0c3RhYmxlLCBbJ1BpcGVsaW5lSUQnLCAnTWV0cmljJywgJ1Njb3JlJ10sICcjcmVzdWx0cycpO1xuICAgIHRhYnVsYXRlKHJlc3VsdHN0YWJsZSwgWydQaXBlbGluZUlEJywgJ01ldHJpYycsICdTY29yZSddLCAnI3NldHhSaWdodCcpO1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgIHRvZ2dsZVJpZ2h0QnV0dG9ucyhcImFsbFwiKTtcbiAgICBieUlkKFwiYnRuUmVzdWx0c1wiKS5jbGljaygpO1xuXG4gICAgLy8gdGhpcyBpbml0aWFsaXplcyB0aGUgbWFpblxuICAgIC8vIHRoaXMgcGllY2UgaGVyZSBpcyB0aGUgZmlyc3QgcGlwZWxpbmUgdGhyb3VnaDogYWxsUGlwZWxpbmVJbmZvW3Jlc3VsdHN0YWJsZVsxXS5QaXBlbGluZUlEXVxuICAgIC8vcmVzdWx0c3Bsb3Rpbml0KGFsbFBpcGVsaW5lSW5mb1tyZXN1bHRzdGFibGVbMV0uUGlwZWxpbmVJRF0sIGR2dmFsdWVzKTtcbiAgICBleHBvcnRwaXBlbGluZShyZXN1bHRzdGFibGVbMV0uUGlwZWxpbmVJRCk7XG5cbiAgICAvLyBJIGRvbid0IHRoaW5rIHdlIG5lZWQgdGhlc2UgdW50aWwgd2UgYXJlIGhhbmRsaW5nIHN0cmVhbWluZyBwaXBlbGluZXNcbiAgICAvLyBUaGV5IGFyZSBzZXQgdXAgYW5kIGNhbGxlZCwgYnV0IGRvbid0IGFjdHVhbGx5IHJlbmRlciBhbnl0aGluZyBmb3IgdGhlIHVzZXJcblxuICAgIC8vIHRoaXMgaXMgb3VyIGZ1bmN0aW9uIGZvciB0aGUgTGlzdFBpcGVsaW5lcyBvZiBBUElcbiAgICBsaXN0cGlwZWxpbmVzKCk7XG5cbiAgICAvL2xldCBwaXBlbGluZWlkID0gUGlwZWxpbmVDcmVhdGVSZXN1bHQucGlwZWxpbmVpZDtcbiAgICAvLyBnZXRleGVjdXRlcGlwZWxpbmVyZXN1bHRzIGlzIHRoZSB0aGlyZCB0byBiZSBjYWxsZWRcbiAgICBtYWtlUmVxdWVzdChEM01fU1ZDX1VSTCArICcvZ2V0ZXhlY3V0ZXBpcGVsaW5lcmVzdWx0cycsIHtjb250ZXh0LCBwaXBlbGluZV9pZHM6IE9iamVjdC5rZXlzKGFsbFBpcGVsaW5lSW5mbyl9KTtcbn1cbmZ1bmN0aW9uIENyZWF0ZVBpcGVsaW5lRGF0YShwcmVkaWN0b3JzLCBkZXB2YXIpIHtcbiAgICBsZXQgY29udGV4dCA9IGFwaVNlc3Npb24oenBhcmFtcy56c2Vzc2lvbmlkKTtcbiAgICBsZXQgdXJpID0ge2ZlYXR1cmVzOiB6cGFyYW1zLnpkM21kYXRhLCB0YXJnZXQ6enBhcmFtcy56ZDNtdGFyZ2V0fTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICB0cmFpbkZlYXR1cmVzOiBhcGlGZWF0dXJlU2hvcnRQYXRoKHByZWRpY3RvcnMsIHVyaS5mZWF0dXJlcyksIC8vIHB1dHRpbmcgaW4gc2hvcnQgcGF0aHMgKG5vIGZpbGVuYW1lKSBmb3IgY3VycmVudCBBUEkgdXNhZ2VcbiAgICAgICAgdGFyZ2V0RmVhdHVyZXM6IGFwaUZlYXR1cmVTaG9ydFBhdGgoZGVwdmFyLCB1cmkudGFyZ2V0KSwgLy8gcHV0dGluZyBpbiBzaG9ydCBwYXRocyAobm8gZmlsZW5hbWUpIGZvciBjdXJyZW50IEFQSSB1c2FnZVxuICAgICAgICB0YXNrOiBkM21UYXNrVHlwZVtkM21Qcm9ibGVtRGVzY3JpcHRpb24udGFza1R5cGVdWzFdLFxuICAgICAgICB0YXNrU3VidHlwZTogZDNtVGFza1N1YnR5cGVbZDNtUHJvYmxlbURlc2NyaXB0aW9uLnRhc2tTdWJ0eXBlXVsxXSxcbiAgICAvLyAgICBvdXRwdXQ6IGQzbU91dHB1dFR5cGVbZDNtUHJvYmxlbURlc2NyaXB0aW9uLm91dHB1dFR5cGVdWzFdLFxuICAgICAgICBtZXRyaWNzOiBbZDNtTWV0cmljc1tkM21Qcm9ibGVtRGVzY3JpcHRpb24ubWV0cmljXVsxXV0sXG4gICAgICAgIHRhc2tEZXNjcmlwdGlvbjogZDNtUHJvYmxlbURlc2NyaXB0aW9uLnRhc2tEZXNjcmlwdGlvbixcbiAgICAgICAgbWF4UGlwZWxpbmVzOiA1LCAvL3VzZXIgdG8gc3BlY2lmeSB0aGlzIGV2ZW50dWFsbHk/XG4gICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRvd25sb2FkSW5jb21wbGV0ZSgpIHtcbiAgICBpZiAoUFJPRFVDVElPTiAmJiB6cGFyYW1zLnpzZXNzaW9uaWQgPT09ICcnKSB7XG4gICAgICAgIGFsZXJ0KCdXYXJuaW5nOiBEYXRhIGRvd25sb2FkIGlzIG5vdCBjb21wbGV0ZS4gVHJ5IGFnYWluIHNvb24uJyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICAgIGNhbGxlZCBieSBjbGlja2luZyAnU29sdmUgVGhpcyBQcm9ibGVtJyBpbiBtb2RlbCBtb2RlXG4qL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGVzdGltYXRlKGJ0bikge1xuICAgIGlmICghSVNfRDNNX0RPTUFJTil7XG4gICAgICAgIGlmIChkb3dubG9hZEluY29tcGxldGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgelBvcCgpO1xuICAgICAgICAvLyB3cml0ZSBsaW5rcyB0byBmaWxlICYgcnVuIFIgQ01EXG4gICAgICAgIC8vIHBhY2thZ2UgdGhlIG91dHB1dCBhcyBKU09OXG4gICAgICAgIC8vIGFkZCBjYWxsIGhpc3RvcnkgYW5kIHBhY2thZ2UgdGhlIHpwYXJhbXMgb2JqZWN0IGFzIEpTT05cbiAgICAgICAgenBhcmFtcy5jYWxsSGlzdG9yeSA9IGNhbGxIaXN0b3J5O1xuICAgICAgICB6cGFyYW1zLmFsbFZhcnMgPSB2YWx1ZUtleS5zbGljZSgxMCwgMjUpOyAvLyBiZWNhdXNlIHRoZSBVUkwgaXMgdG9vIGxvbmcuLi5cblxuICAgICAgICAvKiBVTlVTRURcbiAgICAgICAgdmFyIHNlbGVjdG9ydXJsY2FsbCA9IFJPT0tfU1ZDX1VSTCArIFwic2VsZWN0b3JhcHBcIjtcbiAgICAgICAgZnVuY3Rpb24gc2VsZWN0b3JTdWNjZXNzKGJ0biwganNvbikge1xuICAgICAgICAgICAgZDMuc2VsZWN0KFwiI3RpY2tlclwiKVxuICAgICAgICAgICAgICAgIC50ZXh0KFwiU3VnZ2VzdGVkIHZhcmlhYmxlcyBhbmQgcGVyY2VudCBpbXByb3ZlbWVudCBvbiBSTVNFOiBcIiArIGpzb24udmFycyk7XG4gICAgICAgICAgICBjZGIoXCJzZWxlY3RvclN1Y2Nlc3M6IFwiLCBqc29uKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZWxlY3RvckZhaWwoYnRuKSB7XG4gICAgICAgICAgICBhbGVydChcIlNlbGVjdG9yIEZhaWxcIik7XG4gICAgICAgIH1cbiAgICAgICAgKi9cblxuICAgICAgICBlc3RpbWF0ZUxhZGRhLnN0YXJ0KCk7IC8vIHN0YXJ0IHNwaW5uZXJcbiAgICAgICAgbGV0IGpzb24gPSBhd2FpdCBtYWtlUmVxdWVzdChST09LX1NWQ19VUkwgKyAnemVsaWdhcHAnLCB6cGFyYW1zKTtcbiAgICAgICAgaWYgKCFqc29uKSB7XG4gICAgICAgICAgICBlc3RpbWF0ZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWxsUmVzdWx0cy5wdXNoKGpzb24pO1xuICAgICAgICAgICAgaWYgKCFlc3RpbWF0ZWQpIGJ5SWQoXCJyZXN1bHRzXCIpLnJlbW92ZUNoaWxkKGJ5SWQoXCJyZXN1bHRzSG9sZGVyXCIpKTtcblxuICAgICAgICAgICAgZXN0aW1hdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGQzLnNlbGVjdChcIiNyZXN1bHRzXCIpXG4gICAgICAgICAgICAgICAgLnN0eWxlKFwiZGlzcGxheVwiLCBcImJsb2NrXCIpO1xuXG4gICAgICAgICAgICBkMy5zZWxlY3QoXCIjcmVzdWx0c1ZpZXdcIilcbiAgICAgICAgICAgICAgICAuc3R5bGUoXCJkaXNwbGF5XCIsIFwiYmxvY2tcIik7XG5cbiAgICAgICAgICAgIGQzLnNlbGVjdChcIiNtb2RlbFZpZXdcIilcbiAgICAgICAgICAgICAgICAuc3R5bGUoXCJkaXNwbGF5XCIsIFwiYmxvY2tcIik7XG5cblxuICAgICAgICAgICAgLy8gcHJvZ3JhbW1hdGljIGNsaWNrIG9uIFJlc3VsdHMgYnV0dG9uXG4gICAgICAgICAgICAkKFwiI2J0blJlc3VsdHNcIikudHJpZ2dlcihcImNsaWNrXCIpO1xuXG4gICAgICAgICAgICBsZXQgbW9kZWwgPSBcIk1vZGVsXCIuY29uY2F0KG1vZGVsQ291bnQgPSBtb2RlbENvdW50ICsgMSk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIG1vZENvbCgpIHtcbiAgICAgICAgICAgICAgICBkMy5zZWxlY3QoXCIjbW9kZWxWaWV3XCIpXG4gICAgICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoXCJwXCIpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnYmFja2dyb3VuZC1jb2xvcicsIGhleFRvUmdiYSh2YXJDb2xvcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbW9kQ29sKCk7XG5cbiAgICAgICAgICAgIGQzLnNlbGVjdChcIiNtb2RlbFZpZXdcIilcbiAgICAgICAgICAgICAgICAuaW5zZXJ0KFwicFwiLCBcIjpmaXJzdC1jaGlsZFwiKSAvLyB0b3Agc3RhY2sgZm9yIHJlc3VsdHNcbiAgICAgICAgICAgICAgICAuYXR0cihcImlkXCIsIG1vZGVsKVxuICAgICAgICAgICAgICAgIC50ZXh0KG1vZGVsKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnYmFja2dyb3VuZC1jb2xvcicsIGhleFRvUmdiYShzZWxWYXJDb2xvcikpXG4gICAgICAgICAgICAgICAgLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gdGhpcy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IucmVwbGFjZSgvXFxzKi9nLCBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSBoZXhUb1JnYmEoc2VsVmFyQ29sb3IpLnJlcGxhY2UoL1xccyovZywgXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhLnN1YnN0cigwLCAxNykgPT0gYi5zdWJzdHIoMCwgMTcpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBlc2NhcGUgZnVuY3Rpb24gaWYgZGlzcGxheWVkIG1vZGVsIGlzIGNsaWNrZWRcbiAgICAgICAgICAgICAgICAgICAgbW9kQ29sKCk7XG4gICAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJywgaGV4VG9SZ2JhKHNlbFZhckNvbG9yKSk7XG4gICAgICAgICAgICAgICAgICAgIHZpeih0aGlzLmlkKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbGV0IHJDYWxsID0gW2pzb24uY2FsbF07XG4gICAgICAgICAgICBzaG93TG9nKCdlc3RpbWF0ZScsIHJDYWxsKTtcblxuICAgICAgICAgICAgdml6KG1vZGVsKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc3dhbmRpdmUpIHsgLy8gSVNfRDNNX0RPTUFJTiBhbmQgc3dhbmRpdmUgaXMgdHJ1ZVxuICAgICAgICB6UG9wKCk7XG4gICAgICAgIHpwYXJhbXMuY2FsbEhpc3RvcnkgPSBjYWxsSGlzdG9yeTtcblxuICAgICAgICBsZXQgbXl2a2kgPSB2YWx1ZUtleS5pbmRleE9mKG15dGFyZ2V0KTtcbiAgICAgICAgaWYobXl2a2kgIT0gLTEpIHtcbiAgICAgICAgICAgIGRlbCh2YWx1ZUtleSwgbXl2a2kpO1xuICAgICAgICB9XG5cbiAgICAgICAgZXN0aW1hdGVMYWRkYS5zdGFydCgpOyAvLyBzdGFydCBzcGlubmVyXG4gICAgICAgIGxldCByZXMgPSBhd2FpdCBtYWtlUmVxdWVzdChEM01fU1ZDX1VSTCArICcvY3JlYXRlcGlwZWxpbmUnLCBDcmVhdGVQaXBlbGluZURhdGEodmFsdWVLZXksIG15dGFyZ2V0KSk7XG4gICAgICAgIHJlcyAmJiBvblBpcGVsaW5lQ3JlYXRlKHJlcyk7XG4gICAgfSBlbHNlIHsgLy8gd2UgYXJlIGluIElTX0QzTV9ET01BSU4gbm8gc3dhbmRpdmVcbiAgICAgICAgLy8gcnBjIENyZWF0ZVBpcGVsaW5lcyhQaXBlbGluZUNyZWF0ZVJlcXVlc3QpIHJldHVybnMgKHN0cmVhbSBQaXBlbGluZUNyZWF0ZVJlc3VsdCkge31cbiAgICAgICAgelBvcCgpO1xuICAgICAgICB6cGFyYW1zLmNhbGxIaXN0b3J5ID0gY2FsbEhpc3Rvcnk7XG5cbiAgICAgICAgLy8gcGlwZWxpbmVhcHAgaXMgYSByb29rIGFwcGxpY2F0aW9uIHRoYXQgcmV0dXJucyB0aGUgZGVwZW5kZW50IHZhcmlhYmxlLCB0aGUgRFYgdmFsdWVzLCBhbmQgdGhlIHByZWRpY3RvcnMuIGNhbiB0aGluayBvZiBpdCB3YXMgYSB3YXkgdG8gdHJhbnNsYXRlIHRoZSBwb3RlbnRpYWxseSBjb21wbGV4IGdyYW1tYXIgZnJvbSB0aGUgVUlcblxuICAgICAgICBlc3RpbWF0ZUxhZGRhLnN0YXJ0KCk7IC8vIHN0YXJ0IHNwaW5uZXJcbiAgICAgICAgbGV0IHJlcyA9IGF3YWl0IG1ha2VSZXF1ZXN0KFJPT0tfU1ZDX1VSTCArICdwaXBlbGluZWFwcCcsIHpwYXJhbXMpO1xuICAgICAgICBpZiAoIXJlcykge1xuICAgICAgICAgICAgZXN0aW1hdGVkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2cocmVzKTtcbiAgICAgICAgICAgIHNldHhUYWJsZShyZXMucHJlZGljdG9ycyk7XG4gICAgICAgICAgICBsZXQgZHZ2YWx1ZXMgPSByZXMuZHZ2YWx1ZXM7XG4gICAgICAgICAgICByZXMgPSBhd2FpdCBtYWtlUmVxdWVzdChEM01fU1ZDX1VSTCArICcvY3JlYXRlcGlwZWxpbmUnLCBDcmVhdGVQaXBlbGluZURhdGEocmVzLnByZWRpY3RvcnMsIHJlcy5kZXB2YXIpKTtcbiAgICAgICAgIC8vICAgcmVzID0gYXdhaXQgbWFrZVJlcXVlc3QoUk9PS19TVkNfVVJMICsgJ2NyZWF0ZXBpcGVsaW5lJywgenBhcmFtcyk7XG4gICAgICAgICAgICByZXMgJiYgb25QaXBlbGluZUNyZWF0ZShyZXMpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKiogbmVlZHMgZG9jICovXG5leHBvcnQgZnVuY3Rpb24gdGEyc3R1ZmYoKSB7XG4gICAgY29uc29sZS5sb2coZDNtUHJvYmxlbURlc2NyaXB0aW9uKTtcbn1cblxuLyoqIG5lZWRzIGRvYyAqL1xuYXN5bmMgZnVuY3Rpb24gZGF0YURvd25sb2FkKCkge1xuICAgIHpQb3AoKTtcbiAgICAvLyB3cml0ZSBsaW5rcyB0byBmaWxlICYgcnVuIFIgQ01EXG5cbiAgICAvLyBwYWNrYWdlIHRoZSBvdXRwdXQgYXMgSlNPTlxuICAgIC8vIGFkZCBjYWxsIGhpc3RvcnkgYW5kIHBhY2thZ2UgdGhlIHpwYXJhbXMgb2JqZWN0IGFzIEpTT05cbiAgICBsZXQgcmVzID0gYXdhaXQgbWFrZVJlcXVlc3QoUk9PS19TVkNfVVJMICsgJ2RhdGFhcHAnLCB6cGFyYW1zKTtcbiAgICBpZiAoIXJlcykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgenBhcmFtcy56c2Vzc2lvbmlkID0gcmVzLnNlc3Npb25pZFswXTtcbiAgICAvLyBzZXQgbGluayBVUkxcbiAgICBieUlkKFwibG9nSURcIikuaHJlZiA9IGAke1BST0RVQ1RJT04gPyBST09LX1NWQ19VUkwgKyAnbG9nX2Rpci9sb2dfJyA6ICdyb29rL2xvZ18nIH0ke3pwYXJhbXMuenNlc3Npb25pZH0udHh0YDtcbn1cblxuLyoqIG5lZWRzIGRvYyAqL1xuZnVuY3Rpb24gdml6KG15bSkge1xuICAgIG15bSA9ICtteW0uc3Vic3RyKDUsIDUpIC0gMTtcblxuICAgIGxldCByZW1vdmVLaWRzID0gcGFyZW50ID0+IHtcbiAgICAgICAgd2hpbGUgKHBhcmVudC5maXJzdENoaWxkKVxuICAgICAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKHBhcmVudC5maXJzdENoaWxkKTtcbiAgICB9O1xuICAgIHJlbW92ZUtpZHMoYnlJZChcInJlc3VsdHNWaWV3XCIpKTtcblxuICAgIGxldCBqc29uID0gYWxsUmVzdWx0c1tteW1dO1xuXG4gICAgLy8gcGlwZSBpbiBmaWd1cmVzIHRvIHJpZ2h0IHBhbmVsXG4gICAgdmFyIGZpbGVsaXN0ID0gbmV3IEFycmF5O1xuICAgIGZvciAodmFyIGkgaW4ganNvbi5pbWFnZXMpIHtcbiAgICAgICAgdmFyIHpmaWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgICAgICB6ZmlnLnNldEF0dHJpYnV0ZShcInNyY1wiLCBqc29uLmltYWdlc1tpXSk7XG4gICAgICAgIHpmaWcuc2V0QXR0cmlidXRlKCd3aWR0aCcsIDIwMCk7XG4gICAgICAgIHpmaWcuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAyMDApO1xuICAgICAgICBieUlkKFwicmVzdWx0c1ZpZXdcIikuYXBwZW5kQ2hpbGQoemZpZyk7XG4gICAgfVxuXG4gICAgLy8gd3JpdGUgdGhlIHJlc3VsdHMgdGFibGVcbiAgICB2YXIgcmVzdWx0c0FycmF5ID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIGpzb24uc3VtSW5mbykge1xuICAgICAgICBpZiAoa2V5ID09ICdjb2xuYW1lcycpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgcmVzdWx0c0FycmF5LnB1c2goanNvbi5zdW1JbmZvW2tleV0pO1xuICAgIH1cblxuICAgIHZhciB0YWJsZSA9IGQzLnNlbGVjdChcIiNyZXN1bHRzVmlld1wiKVxuICAgICAgICAuYXBwZW5kKFwicFwiKVxuICAgICAgICAuYXBwZW5kKFwidGFibGVcIik7XG5cbiAgICB2YXIgdGhlYWQgPSB0YWJsZS5hcHBlbmQoXCJ0aGVhZFwiKTtcbiAgICB0aGVhZC5hcHBlbmQoXCJ0clwiKVxuICAgICAgICAuc2VsZWN0QWxsKFwidGhcIilcbiAgICAgICAgLmRhdGEoanNvbi5zdW1JbmZvLmNvbG5hbWVzKVxuICAgICAgICAuZW50ZXIoKVxuICAgICAgICAuYXBwZW5kKFwidGhcIilcbiAgICAgICAgLnRleHQoZCA9PiBkKTtcblxuICAgIHZhciB0Ym9keSA9IHRhYmxlLmFwcGVuZChcInRib2R5XCIpO1xuICAgIHRib2R5LnNlbGVjdEFsbChcInRyXCIpXG4gICAgICAgIC5kYXRhKHJlc3VsdHNBcnJheSlcbiAgICAgICAgLmVudGVyKCkuYXBwZW5kKFwidHJcIilcbiAgICAgICAgLnNlbGVjdEFsbChcInRkXCIpXG4gICAgICAgIC5kYXRhKGQgPT4gZClcbiAgICAgICAgLmVudGVyKCkuYXBwZW5kKFwidGRcIilcbiAgICAgICAgLnRleHQoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgdmFyIG15TnVtID0gTnVtYmVyKGQpO1xuICAgICAgICAgICAgaWYgKGlzTmFOKG15TnVtKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgICAgIHJldHVybiBteU51bS50b1ByZWNpc2lvbigzKTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnN0eWxlKFwiYmFja2dyb3VuZC1jb2xvclwiLCBcImFsaWNlYmx1ZVwiKTtcbiAgICAgICAgfSkgLy8gZm9yIG5vIGRpc2Nlcm5hYmxlIHJlYXNvblxuICAgICAgICAub24oXCJtb3VzZW91dFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5zdHlsZShcImJhY2tncm91bmQtY29sb3JcIiwgXCIjRjlGOUY5XCIpO1xuICAgICAgICB9KTsgLy8oYnV0IG1heWJlIHdlJ2xsIHRoaW5rIG9mIG9uZSlcblxuICAgIGQzLnNlbGVjdChcIiNyZXN1bHRzVmlld1wiKVxuICAgICAgICAuYXBwZW5kKFwicFwiKVxuICAgICAgICAuaHRtbCgoKSA9PiBcIjxiPkZvcm11bGE6IDwvYj5cIi5jb25jYXQoanNvbi5jYWxsWzBdKSk7XG5cbiAgICBtLnJlZHJhdygpO1xufVxuXG4vKipcbiAgIHBhcnNlcyB0aGUgdHJhbnNmb3JtYXRpb24gaW5wdXQuXG4gICB2YXJpYWJsZSBuYW1lcyBhcmUgb2Z0ZW4gbmVzdGVkIGluc2lkZSBvbmUgYW5vdGhlciwgZS5nLiwgZXRod2FyLCB3YXIsIHdhcnMsIGFuZCBzbyB0aGlzIGlzIGhhbmRsZWRcbiovXG5mdW5jdGlvbiB0cmFuc1BhcnNlKG4pIHtcbiAgICB2YXIgb3V0MiA9IFtdO1xuICAgIHZhciB0MiA9IG47XG4gICAgdmFyIGsyID0gMDtcbiAgICB2YXIgc3ViTWUyID0gXCJfdHJhbnN2YXJcIi5jb25jYXQoazIpO1xuICAgIHZhciBpbmRleGVkID0gW107XG5cbiAgICAvLyBvdXQyIGlzIGFsbCBtYXRjaGVkIHZhcmlhYmxlcywgaW5kZXhlZCBpcyBhbiBhcnJheSwgZWFjaCBlbGVtZW50IGlzIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBtYXRjaGVkIHZhcmlhYmxlcyBzdGFydGluZyBpbmRleCBhbmQgZmluaXNoaW5nIGluZGV4LiAgZS5nLiwgbj1cIndhcnMrMlwiLCBvdXQyPVt3YXIsIHdhcnNdLCBpbmRleGVkPVt7MCwyfSx7MCwzfV1cbiAgICBmb3IgKHZhciBpIGluIHZhbHVlS2V5KSB7XG4gICAgICAgIHZhciBtMiA9IG4ubWF0Y2godmFsdWVLZXlbaV0pO1xuICAgICAgICBpZiAobTIgIT0gbnVsbClcbiAgICAgICAgICAgIG91dDIucHVzaChtMlswXSk7XG5cbiAgICAgICAgdmFyIHJlID0gbmV3IFJlZ0V4cCh2YWx1ZUtleVtpXSwgXCJnXCIpO1xuICAgICAgICB2YXIgcyA9IG4uc2VhcmNoKHJlKTtcbiAgICAgICAgaWYgKHMgIT0gLTEpXG4gICAgICAgICAgICBpbmRleGVkLnB1c2goe2Zyb206IHMsIHRvOiBzICsgdmFsdWVLZXlbaV0ubGVuZ3RofSk7XG4gICAgfVxuXG4gICAgLy8gbmVzdGVkIGxvb3Agbm90IGdvb2QsIGJ1dCBpbmRleGVkIGlzIG5vdCBsaWtlbHkgdG8gYmUgdmVyeSBsYXJnZS5cbiAgICAvLyBpZiBhIHZhcmlhYmxlIGlzIG5lc3RlZCwgaXQgaXMgcmVtb3ZlZCBmcm9tIG91dDJcbiAgICAvLyBub3RpY2UsIGxvb3AgaXMgYmFja3dhcmRzIHNvIHRoYXQgaW5kZXggY2hhbmdlcyBkb24ndCBhZmZlY3QgdGhlIHNwbGljZVxuICAgIGNkYihcImluZGV4ZWQgXCIsIGluZGV4ZWQpO1xuICAgIGZvciAodmFyIGkgPSBpbmRleGVkLmxlbmd0aCAtIDE7IGkgPiAtMTsgaS0tKSB7XG4gICAgICAgIGZvciAodmFyIGogPSBpbmRleGVkLmxlbmd0aCAtIDE7IGogPiAtMTsgai0tKSB7XG4gICAgICAgICAgICBpZiAoaSA9PT0gailcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICgoaW5kZXhlZFtpXS5mcm9tID49IGluZGV4ZWRbal0uZnJvbSkgJiAoaW5kZXhlZFtpXS50byA8PSBpbmRleGVkW2pdLnRvKSkge1xuICAgICAgICAgICAgICAgIGNkYihpLCBcIiBpcyBuZXN0ZWQgaW4gXCIsIGopO1xuICAgICAgICAgICAgICAgIGRlbChvdXQyLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGkgaW4gb3V0Mikge1xuICAgICAgICB0MiA9IHQyLnJlcGxhY2Uob3V0MltpXSwgc3ViTWUyKTsgLy9zb21ldGhpbmcgdGhhdCdsbCBuZXZlciBiZSBhIHZhcmlhYmxlIG5hbWVcbiAgICAgICAgazIgPSBrMiArIDE7XG4gICAgICAgIHN1Yk1lMiA9IFwiX3RyYW5zdmFyXCIuY29uY2F0KGsyKTtcbiAgICB9XG5cbiAgICBpZiAob3V0Mi5sZW5ndGggPiAwKSB7XG4gICAgICAgIG91dDIucHVzaCh0Mik7XG4gICAgICAgIGNkYihcIm5ldyBvdXQgXCIsIG91dDIpO1xuICAgICAgICByZXR1cm4gKG91dDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGFsZXJ0KFwiTm8gdmFyaWFibGUgbmFtZSBmb3VuZC4gUGVyaGFwcyBjaGVjayB5b3VyIHNwZWxsaW5nP1wiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuXG4vKipcbiAgIG4gPSBuYW1lIG9mIGNvbHVtbi9ub2RlXG4gICB0ID0gc2VsZWN0ZWQgdHJhbnNmb3JtYXRpb25cbiovXG5hc3luYyBmdW5jdGlvbiB0cmFuc2Zvcm0obiwgdCwgdHlwZVRyYW5zZm9ybSkge1xuICAgIGlmIChkb3dubG9hZEluY29tcGxldGUoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCF0eXBlVHJhbnNmb3JtKVxuICAgICAgICB0ID0gdC5yZXBsYWNlKFwiK1wiLCBcIl9wbHVzX1wiKTsgLy8gY2FuJ3Qgc2VuZCB0aGUgcGx1cyBvcGVyYXRvclxuXG4gICAgY2RiKCduYW1lIG9mIGNvbDogJyArIG4pO1xuICAgIGNkYigndHJhbnNmb3JtYXRpb246ICcgKyB0KTtcblxuICAgIHZhciBidG4gPSBieUlkKCdidG5Fc3RpbWF0ZScpO1xuXG4gICAgLy8gZmluZCB0aGUgbm9kZSBieSBuYW1lXG4gICAgdmFyIG15biA9IGZpbmROb2RlSW5kZXgoblswXSwgdHJ1ZSk7XG5cbiAgICBpZiAodHlwZW9mIG15biA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBteW4gPSBmaW5kTm9kZUluZGV4KG4sIHRydWUpO1xuICAgIH1cblxuICAgIHZhciBvdXR0eXBlcyA9IHtcbiAgICAgICAgdmFybmFtZXNUeXBlczogbixcbiAgICAgICAgaW50ZXJ2YWw6IG15bi5pbnRlcnZhbCxcbiAgICAgICAgbnVtY2hhcjogbXluLm51bWNoYXIsXG4gICAgICAgIG5hdHVyZTogbXluLm5hdHVyZSxcbiAgICAgICAgYmluYXJ5OiBteW4uYmluYXJ5XG4gICAgfTtcblxuICAgIGNkYihteW4pO1xuICAgIC8vIGlmIHR5cGVUcmFuc2Zvcm0gYnV0IHdlIGFscmVhZHkgaGF2ZSB0aGUgbWV0YWRhdGFcbiAgICBpZiAodHlwZVRyYW5zZm9ybSkge1xuICAgICAgICBpZiAobXluLm5hdHVyZSA9PSBcIm5vbWluYWxcIiAmIHR5cGVvZiBteW4ucGxvdHZhbHVlcyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgbXluLnBsb3R0eXBlID0gXCJiYXJcIjtcbiAgICAgICAgICAgIGJhcnNOb2RlKG15bik7XG4gICAgICAgICAgICBwYW5lbFBsb3RzKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAobXluLm5hdHVyZSAhPSBcIm5vbWluYWxcIiAmIHR5cGVvZiBteW4ucGxvdHggIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIG15bi5wbG90dHlwZSA9IFwiY29udGludW91c1wiO1xuICAgICAgICAgICAgZGVuc2l0eU5vZGUobXluKTtcbiAgICAgICAgICAgIHBhbmVsUGxvdHMoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGVzdGltYXRlTGFkZGEuc3RhcnQoKTsgLy8gc3RhcnQgc3Bpbm5lclxuICAgIGxldCBqc29uID0gYXdhaXQgbWFrZVJlcXVlc3QoXG4gICAgICAgIFJPT0tfU1ZDX1VSTCArICd0cmFuc2Zvcm1hcHAnLFxuICAgICAgICB7emRhdGF1cmw6IGRhdGF1cmwsXG4gICAgICAgICB6dmFyczogbXluLm5hbWUsXG4gICAgICAgICB6c2Vzc2lvbmlkOiB6cGFyYW1zLnpzZXNzaW9uaWQsXG4gICAgICAgICB0cmFuc2Zvcm06IHQsXG4gICAgICAgICBjYWxsSGlzdG9yeTogY2FsbEhpc3RvcnksXG4gICAgICAgICB0eXBlVHJhbnNmb3JtOiB0eXBlVHJhbnNmb3JtLFxuICAgICAgICAgdHlwZVN0dWZmOiBvdXR0eXBlc30pO1xuICAgIGlmICghanNvbikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSXMgdGhpcyBhIHR5cGVUcmFuc2Zvcm0/XG4gICAgaWYgKGpzb24udHlwZVRyYW5zZm9ybVswXSkge1xuICAgICAgICAvLyBZZXMuIFdlJ3JlIHVwZGF0aW5nIGFuIGV4aXN0aW5nIG5vZGVcbiAgICAgICAgZDMuanNvbihqc29uLnVybCwgKGVyciwgZGF0YSkgPT4ge1xuICAgICAgICAgICAgaWYgKGVycilcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKGVycik7XG4gICAgICAgICAgICBsZXQgbm9kZTtcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IGZpbmROb2RlSW5kZXgoa2V5LCB0cnVlKTtcblx0XHQgICAgICAgICAgICBpZiAoIW5vZGUpXG5cdFx0ICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGpRdWVyeS5leHRlbmQodHJ1ZSwgbm9kZSwgZGF0YVtrZXldKTtcbiAgICAgICAgICAgICAgICBub2RlLnBsb3R0eXBlID09PSBcImNvbnRpbnVvdXNcIiA/IGRlbnNpdHlOb2RlKG5vZGUpIDpcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5wbG90dHlwZSA9PT0gXCJiYXJcIiA/IGJhcnNOb2RlKG5vZGUpIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZha2VDbGljaygpO1xuICAgICAgICAgICAgcGFuZWxQbG90cygpO1xuICAgICAgICAgICAgbm9kZSAmJiBjZGIobm9kZSk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIE5vLCB3ZSBoYXZlIGEgbmV3IG5vZGUgaGVyZS0tZS5nLiB0aGUgdHJhbnNmb3JtZWQgY29sdW1uXG4gICAgICAgICAgIGV4YW1wbGUgcmVzcG9uc2U6IHtcbiAgICAgICAgICAgXCJjYWxsXCI6W1widF95ZWFyXzJcIl0sXG4gICAgICAgICAgIFwidXJsXCI6W1wiZGF0YS9wcmVwcm9jZXNzU3Vic2V0X0JBQ0NCQzc4LTdERDktNDQ4Mi1CMzFELTZFQjAxQzNBMEM5NS50eHRcIl0sXG4gICAgICAgICAgIFwidHJhbnNcIjpbXCJ5ZWFyXCIsXCJfdHJhbnN2YXIwXjJcIl0sXG4gICAgICAgICAgIFwidHlwZVRyYW5zZm9ybVwiOltmYWxzZV1cbiAgICAgICAgICAgfVxuICAgICAgICAqL1xuICAgICAgICBjYWxsSGlzdG9yeS5wdXNoKHtcbiAgICAgICAgICAgIGZ1bmM6IFwidHJhbnNmb3JtXCIsXG4gICAgICAgICAgICB6dmFyczogbixcbiAgICAgICAgICAgIHRyYW5zZm9ybTogdFxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgc3Vic2V0ZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIHJDYWxsID0gW107XG5cbiAgICAgICAgckNhbGxbMF0gPSBqc29uLmNhbGw7XG4gICAgICAgIHZhciBuZXdWYXIgPSByQ2FsbFswXVswXTtcblxuICAgICAgICB0cmFucy5wdXNoKG5ld1Zhcik7XG5cbiAgICAgICAgLy8gUmVhZCB0aGUgcHJlcHJvY2VzcyBmaWxlIGNvbnRhaW5pbmcgdmFsdWVzXG4gICAgICAgIC8vIGZvciB0aGUgdHJhbnNmb3JtZWQgdmFyaWFibGVcbiAgICAgICAgLy9cbiAgICAgICAgZDMuanNvbihqc29uLnVybCwgZnVuY3Rpb24oZXJyb3IsIGpzb24pIHtcbiAgICAgICAgICAgIGlmIChlcnJvcikgcmV0dXJuIGNvbnNvbGUud2FybihlcnJvcik7XG5cbiAgICAgICAgICAgIHZhciBqc29uZGF0YSA9IGdldFZhcmlhYmxlRGF0YShqc29uKTtcblxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGpzb25kYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIG15SW5kZXggPSBmaW5kTm9kZUluZGV4KGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBteUluZGV4ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGFsZXJ0KFwiSW52YWxpZCB0cmFuc2Zvcm1hdGlvbjogdGhpcyB2YXJpYWJsZSBuYW1lIGFscmVhZHkgZXhpc3RzLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBhZGQgdHJhbnNmb3JtZWQgdmFyaWFibGUgdG8gdGhlIGN1cnJlbnQgc3BhY2VcbiAgICAgICAgICAgICAgICB2YXIgaSA9IGFsbE5vZGVzLmxlbmd0aDsgIC8vIGdldCBuZXcgaW5kZXhcbiAgICAgICAgICAgICAgICB2YXIgb2JqMSA9IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGksXG4gICAgICAgICAgICAgICAgICAgIHJlZmxleGl2ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgbGFibDogXCJ0cmFuc2Zvcm1sYWJlbFwiLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBbNSwgMTUsIDIwLCAwLCA1LCAxNSwgMjBdLFxuICAgICAgICAgICAgICAgICAgICBjb3VudDogWy42LCAuMiwgLjksIC44LCAuMSwgLjMsIC40XSxcbiAgICAgICAgICAgICAgICAgICAgbm9kZUNvbDogY29sb3JzKGkpLFxuICAgICAgICAgICAgICAgICAgICBiYXNlQ29sOiBjb2xvcnMoaSksXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZUNvbG9yOiBzZWxWYXJDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IFwiMVwiLFxuICAgICAgICAgICAgICAgICAgICBzdWJzZXRwbG90OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgc3Vic2V0cmFuZ2U6IFtcIlwiLCBcIlwiXSxcbiAgICAgICAgICAgICAgICAgICAgc2V0eHBsb3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBzZXR4dmFsczogW1wiXCIsIFwiXCJdLFxuICAgICAgICAgICAgICAgICAgICBncmF5b3V0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdEludGVydmFsOiBqc29uZGF0YVtrZXldLmludGVydmFsLFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0TnVtY2hhcjoganNvbmRhdGFba2V5XS5udW1jaGFyLFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0TmF0dXJlOiBqc29uZGF0YVtrZXldLm5hdHVyZSxcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdEJpbmFyeToganNvbmRhdGFba2V5XS5iaW5hcnlcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgalF1ZXJ5LmV4dGVuZCh0cnVlLCBvYmoxLCBqc29uZGF0YVtrZXldKTtcbiAgICAgICAgICAgICAgICBhbGxOb2Rlcy5wdXNoKG9iajEpO1xuXG4gICAgICAgICAgICAgICAgdmFsdWVLZXkucHVzaChuZXdWYXIpO1xuICAgICAgICAgICAgICAgIG5vZGVzLnB1c2goYWxsTm9kZXNbaV0pO1xuICAgICAgICAgICAgICAgIGZha2VDbGljaygpO1xuICAgICAgICAgICAgICAgIHBhbmVsUGxvdHMoKTtcblxuICAgICAgICAgICAgICAgIGlmIChhbGxOb2Rlc1tpXS5wbG90dHlwZSA9PT0gXCJjb250aW51b3VzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVuc2l0eU5vZGUoYWxsTm9kZXNbaV0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYWxsTm9kZXNbaV0ucGxvdHR5cGUgPT09IFwiYmFyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgYmFyc05vZGUoYWxsTm9kZXNbaV0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG0ucmVkcmF3KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNob3dMb2coJ3RyYW5zZm9ybScsIHJDYWxsKTtcbiAgICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBtYWtlUmVxdWVzdCh1cmwsIGRhdGEpIHtcbiAgICBjb25zb2xlLmxvZygndXJsOicsIHVybCk7XG4gICAgY29uc29sZS5sb2coJ1BPU1Q6JywgZGF0YSk7XG4gICAgbGV0IHJlcztcbiAgICB0cnkge1xuICAgICAgICByZXMgPSBhd2FpdCBtLnJlcXVlc3QodXJsLCB7bWV0aG9kOiAnUE9TVCcsIGRhdGE6IGRhdGF9KTtcbiAgICAgICAgY29uc29sZS5sb2coJ3Jlc3BvbnNlOicsIHJlcyk7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhyZXMpWzBdID09PSAnd2FybmluZycpIHtcbiAgICAgICAgICAgIGFsZXJ0KCdXYXJuaW5nOiAnICsgcmVzLndhcm5pbmcpO1xuICAgICAgICAgICAgZW5kX3RhM19zZWFyY2goZmFsc2UsIHJlcy53YXJuaW5nKTtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgIGVuZF90YTNfc2VhcmNoKGZhbHNlLCBlcnIpO1xuICAgICAgICBjZGIoZXJyKTtcbiAgICAgICAgYWxlcnQoYEVycm9yOiBjYWxsIHRvICR7dXJsfSBmYWlsZWRgKTtcbiAgICB9XG4gICBcbiAgIC8qXG4gICAgLy9jYWxsIGVuZF90YTNfc2VhcmNoIGlmIHN0YXR1cyAhPSBPS1xuICAgIC8vIHN0YXR1cyBtYXkgYmUgaW4gZGlmZmVyZW50IHBsYWNlcyBmb3IgZGlmZmVyZW50IGNhbGxzIHRob3VnaCwgYW5kIHRoaXMgaXMgbm90IHdvcnRoIGRvaW5nIGF0IHRoZSBtb21lbnRcbiAgICBsZXQgbXlyZWcgPSAvZDNtLXNlcnZpY2UvZztcbiAgICBsZXQgaXNkM21jYWxsID0gbXlyZWcudGVzdCh1cmwpO1xuICAgIGlmKGlzZDNtY2FsbCkge1xuICAgICAgICBsZXQgbXlzdGF0dXMgPSByZXMucmVzcG9uc2VJbmZvLnN0YXR1cy5jb2RlLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIGlmKG15c3RhdHVzICE9IFwiT0tcIikge1xuICAgICAgICAgICAgZW5kX3RhM19zZWFyY2goZmFsc2UsIFwiZ3JwYyByZXNwb25zZSBzdGF0dXMgbm90IG9rXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgICovXG4gICAgXG4gICAgZXN0aW1hdGVMYWRkYS5zdG9wKCk7XG4gICAgc2VsZWN0TGFkZGEuc3RvcCgpO1xuICAgIHJldHVybiByZXM7XG59XG5cbi8qKiBuZWVkcyBkb2MgKi9cbmV4cG9ydCBmdW5jdGlvbiBsZWdlbmQoKSB7XG4gICAgYm9yZGVyU3RhdGUoKTtcbiAgICBtLnJlZHJhdygpO1xufVxuXG4vKipcbiAgIHByb2dyYW1tYXRpY2FsbHkgZGVzZWxlY3QgZXZlcnkgc2VsZWN0ZWQgdmFyaWFibGVcbiovXG5leHBvcnQgZnVuY3Rpb24gZXJhc2UoKSB7XG4gICAgWycjbGVmdHBhbmVsJywgJyNyaWdodHBhbmVsJ10uZm9yRWFjaChpZCA9PiBkMy5zZWxlY3QoaWQpLmF0dHIoJ2NsYXNzJywgJ3NpZGVwYW5lbCBjb250YWluZXIgY2xlYXJmaXgnKSk7XG4gICAgdGFiTGVmdCgndGFiMScpO1xuICAgICQoXCIjdmFyTGlzdFwiKS5jaGlsZHJlbigpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh6cGFyYW1zLnpkdi5jb25jYXQoenBhcmFtcy56bm9tLCB6cGFyYW1zLnp2YXJzKS5pbmNsdWRlcyh0aGlzLmlkKSlcbiAgICAgICAgICAgIGNsaWNrVmFyKHt0YXJnZXQ6IHRoaXN9KTtcbiAgICB9KTtcbn1cblxuLyoqIG5lZWRzIGRvYyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRhYkxlZnQodGFiKSB7XG4gICAgYnlJZCgndGFiMScpLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgYnlJZCgndGFiMicpLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgYnlJZCgndGFiMycpLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgYnlJZCh0YWIpLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIGlmICh0YWIgIT0gJ3RhYjMnKSB7XG4gICAgICAgIHN1YnNldCA9IHRhYiA9PSAndGFiMic7XG4gICAgICAgIHN1bW1hcnlIb2xkID0gZmFsc2U7XG4gICAgfVxuICAgIGxlZnR0YWIgPSB0YWI7XG59XG5cbi8qKiBuZWVkcyBkb2MgKi9cbmV4cG9ydCBmdW5jdGlvbiB0YWJSaWdodCh0YWIpIHtcbiAgICBsZXQgc2VsZWN0ID0gY2xzID0+IHtcbiAgICAgICAgbGV0IHBhbmVsID0gZDMuc2VsZWN0KFwiI3JpZ2h0cGFuZWxcIik7XG4gICAgICAgIHJldHVybiBjbHMgPyBwYW5lbC5hdHRyKCdjbGFzcycsIGNscykgOiBwYW5lbC5hdHRyKCdjbGFzcycpO1xuICAgIH07XG4gICAgbGV0IGNscyA9IFwic2lkZXBhbmVsIGNvbnRhaW5lciBjbGVhcmZpeFwiO1xuICAgIGxldCB0b2dnbGVSID0gKCkgPT4ge1xuICAgICAgICBzZWxlY3QoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBsZXQgZXhwYW5kID0gY2xzICsgJyBleHBhbmRwYW5lbCc7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSA9PT0gZXhwYW5kID8gY2xzIDogZXhwYW5kO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGxldCB0b2dnbGVSRnVsbCA9ICgpID0+IHtcbiAgICAgICAgc2VsZWN0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgbGV0IGV4cGFuZCA9IGNscyArICcgZXhwYW5kcGFuZWxmdWxsJztcbiAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpID09PSBleHBhbmQgPyBjbHMgOiBleHBhbmQ7XG4gICAgICAgICAgICAgICB9KTtcbiAgICB9O1xuICAgIGlmICh0YWIgPT09IFwiYnRuTW9kZWxzXCIpIHNlbGVjdChjbHMpO1xuICAgIGVsc2UgaWYgKHRhYiA9PT0gXCJidG5TZXR4XCIpIHJpZ2h0dGFiID09PSBcImJ0blNldHhcIiB8fCBzZWxlY3QoKSA9PT0gY2xzICYmIHRvZ2dsZVJGdWxsKCk7XG4gICAgZWxzZSBpZiAodGFiID09PSBcImJ0blJlc3VsdHNcIikgIWVzdGltYXRlZCA/IHNlbGVjdChjbHMpIDpcbiAgICAgICAgcmlnaHR0YWIgPT09IFwiYnRuUmVzdWx0c1wiIHx8IHNlbGVjdCgpID09PSBjbHMgJiYgdG9nZ2xlUigpO1xuICAgIHJpZ2h0dGFiID0gdGFiO1xufVxuXG5leHBvcnQgbGV0IHN1bW1hcnkgPSB7ZGF0YTogW119O1xuXG4vKiogbmVlZHMgZG9jICovXG5mdW5jdGlvbiB2YXJTdW1tYXJ5KGQpIHtcbiAgICBsZXQgdDEgPSAnTWVhbjosIE1lZGlhbjosIE1vc3QgRnJlcTosIE9jY3VycmVuY2VzOiwgTWVkaWFuIEZyZXE6LCBPY2N1cnJlbmNlczosIExlYXN0IEZyZXE6LCBPY2N1cnJlbmNlczosIFN0ZCBEZXY6LCBNaW5pbXVtOiwgTWF4aW11bTosIEludmFsaWQ6LCBWYWxpZDosIFVuaXF1ZXM6LCBIZXJmaW5kYWhsJy5zcGxpdCgnLCAnKTtcblxuICAgIGxldCByaW50ID0gZDMuZm9ybWF0KCdyJyk7XG4gICAgbGV0IHN0ciA9ICh4LCBwKSA9PiAoK3gpLnRvUHJlY2lzaW9uKHAgfHwgNCkudG9TdHJpbmcoKTtcbiAgICBsZXQgdDIgPSBwcml2ICYmIGQubWVhbkNJID9cbiAgICAgICAgW3N0cihkLm1lYW4sIDIpICsgJyAoJyArIHN0cihkLm1lYW5DSS5sb3dlckJvdW5kLCAyKSArICcgLSAnICsgc3RyKGQubWVhbkNJLnVwcGVyQm91bmQsIDIpICsgJyknLFxuICAgICAgICAgc3RyKGQubWVkaWFuKSwgZC5tb2RlLCByaW50KGQuZnJlcW1vZGUpLCBkLm1pZCwgcmludChkLmZyZXFtaWQpLCBkLmZld2VzdCwgcmludChkLmZyZXFmZXdlc3QpLFxuICAgICAgICAgc3RyKGQuc2QpLCBzdHIoZC5taW4pLCBzdHIoZC5tYXgpLCByaW50KGQuaW52YWxpZCksIHJpbnQoZC52YWxpZCksIHJpbnQoZC51bmlxdWVzKSwgc3RyKGQuaGVyZmluZGFobCldIDpcbiAgICAgICAgW3N0cihkLm1lYW4pLCBzdHIoZC5tZWRpYW4pLCBkLm1vZGUsIHJpbnQoZC5mcmVxbW9kZSksIGQubWlkLCByaW50KGQuZnJlcW1pZCksIGQuZmV3ZXN0LCByaW50KGQuZnJlcWZld2VzdCksXG4gICAgICAgICBzdHIoZC5zZCksIHN0cihkLm1pbiksIHN0cihkLm1heCksIHJpbnQoZC5pbnZhbGlkKSwgcmludChkLnZhbGlkKSwgcmludChkLnVuaXF1ZXMpLCBzdHIoZC5oZXJmaW5kYWhsKV07XG5cbiAgICBzdW1tYXJ5LmRhdGEgPSBbXTtcbiAgICB0MS5mb3JFYWNoKChlLCBpKSA9PiAhdDJbaV0uaW5jbHVkZXMoJ05hTicpICYmIHQyW2ldICE9ICdOQScgJiYgdDJbaV0gIT0gJycgJiYgc3VtbWFyeS5kYXRhLnB1c2goW2UsIHQyW2ldXSkpO1xuXG4gICAgc3VtbWFyeS5uYW1lID0gZC5uYW1lO1xuICAgIHN1bW1hcnkubGFibCA9IGQubGFibDtcblxuICAgIGQzLnNlbGVjdCgnI3RhYjMnKVxuICAgICAgICAuc2VsZWN0QWxsKCdzdmcnKVxuICAgICAgICAucmVtb3ZlKCk7XG5cbiAgICBpZiAoIWQucGxvdHR5cGUpXG4gICAgICAgIHJldHVybjtcbiAgICBkLnBsb3R0eXBlID09ICdjb250aW51b3VzJyA/IGRlbnNpdHkoZCwgJ3ZhclN1bW1hcnknLCBwcml2KSA6XG4gICAgICAgIGQucGxvdHR5cGUgPT0gXCJiYXJcIiA/IGJhcnMoZCwgJ3ZhclN1bW1hcnknLCBwcml2KSA6XG4gICAgICAgIGQzLnNlbGVjdChcIiN0YWIzXCIpIC8vIG5vIGdyYXBoIHRvIGRyYXcsIGJ1dCBzdGlsbCBuZWVkIHRvIHJlbW92ZSBwcmV2aW91cyBncmFwaFxuICAgICAgICAuc2VsZWN0QWxsKFwic3ZnXCIpXG4gICAgICAgIC5yZW1vdmUoKTtcbn1cblxuZXhwb3J0IGxldCBwb3BvdmVyQ29udGVudCA9IGQgPT4ge1xuICAgIGlmKHN3YW5kaXZlKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IHRleHQgPSAnJztcbiAgICBsZXQgW3JpbnQsIHByZWNdID0gW2QzLmZvcm1hdCgncicpLCAodmFsLCBpbnQpID0+ICgrdmFsKS50b1ByZWNpc2lvbihpbnQpLnRvU3RyaW5nKCldO1xuICAgIGxldCBkaXYgPSAoZmllbGQsIG5hbWUsIHZhbCkgPT4ge1xuICAgICAgICBpZiAoZmllbGQgIT0gJ05BJykgdGV4dCArPSBgPGRpdiBjbGFzcz0nZm9ybS1ncm91cCc+PGxhYmVsIGNsYXNzPSdjb2wtc20tNCBjb250cm9sLWxhYmVsJz4ke25hbWV9PC9sYWJlbD48ZGl2IGNsYXNzPSdjb2wtc20tNic+PHAgY2xhc3M9J2Zvcm0tY29udHJvbC1zdGF0aWMnPiR7dmFsIHx8IGZpZWxkfTwvcD48L2Rpdj48L2Rpdj5gO1xuICAgIH07XG4gICAgZC5sYWJsICE9ICcnICYmIGRpdihkLmxhYmwsICdMYWJlbCcpO1xuICAgIGRpdihkLm1lYW4sICdNZWFuJywgcHJpdiAmJiBkLm1lYW5DSSA/XG4gICAgICAgIGAke3ByZWMoZC5tZWFuLCAyKX0gKCR7cHJlYyhkLm1lYW5DSS5sb3dlckJvdW5kLCAyKX0gLSAke3ByZWMoZC5tZWFuQ0kudXBwZXJCb3VuZCwgMil9KWAgOlxuICAgICAgICBwcmVjKGQubWVhbiwgNCkpO1xuICAgIGRpdihkLm1lZGlhbiwgJ01lZGlhbicsIHByZWMoZC5tZWRpYW4sIDQpKTtcbiAgICBkaXYoZC5tb2RlLCAnTW9zdCBGcmVxJyk7XG4gICAgZGl2KGQuZnJlcW1vZGUsICdPY2N1cnJlbmNlcycsICByaW50KGQuZnJlcW1vZGUpKTtcbiAgICBkaXYoZC5taWQsICdNZWRpYW4gRnJlcScpO1xuICAgIGRpdihkLmZyZXFtaWQsICdPY2N1cnJlbmNlcycsIHJpbnQoZC5mcmVxbWlkKSk7XG4gICAgZGl2KGQuZmV3ZXN0LCAnTGVhc3QgRnJlcScpO1xuICAgIGRpdihkLmZyZXFmZXdlc3QsICdPY2N1cnJlbmNlcycsIHJpbnQoZC5mcmVxZmV3ZXN0KSk7XG4gICAgZGl2KGQuc2QsICdTdGFuZCBEZXYnLCBwcmVjKGQuc2QsIDQpKTtcbiAgICBkaXYoZC5tYXgsICdNYXhpbXVtJywgcHJlYyhkLm1heCwgNCkpO1xuICAgIGRpdihkLm1pbiwgJ01pbmltdW0nLCBwcmVjKGQubWluLCA0KSk7XG4gICAgZGl2KGQuaW52YWxpZCwgJ0ludmFsaWQnLCByaW50KGQuaW52YWxpZCkpO1xuICAgIGRpdihkLnZhbGlkLCAnVmFsaWQnLCByaW50KGQudmFsaWQpKTtcbiAgICBkaXYoZC51bmlxdWVzLCAnVW5pcXVlcycsIHJpbnQoZC51bmlxdWVzKSk7XG4gICAgZGl2KGQuaGVyZmluZGFobCwgJ0hlcmZpbmRhaGwnLCBwcmVjKGQuaGVyZmluZGFobCwgNCkpO1xuICAgIHJldHVybiB0ZXh0O1xufVxuXG4vKiogbmVlZHMgZG9jICovXG5leHBvcnQgZnVuY3Rpb24gcGFuZWxQbG90cygpIHtcbiAgICBpZihJU19EM01fRE9NQUlOKSB7XG4gICAgICAgIGJ5SWQoJ2J0blN1YnNldCcpLmNsYXNzTGlzdC5hZGQoJ25vc2hvdycpO1xuICAgIH1cbiAgICAvLyBidWlsZCBhcnJheXMgZnJvbSBub2RlcyBpbiBtYWluXG4gICAgbGV0IHZhcnMgPSBbXTtcbiAgICBsZXQgaWRzID0gW107XG4gICAgbm9kZXMuZm9yRWFjaChuID0+IHtcbiAgICAgICAgdmFycy5wdXNoKG4ubmFtZS5yZXBsYWNlKC9cXCh8XFwpL2csICcnKSk7XG4gICAgICAgIGlkcy5wdXNoKG4uaWQpO1xuICAgIH0pO1xuXG4gICAgLy9yZW1vdmUgYWxsIHBsb3RzLCBjb3VsZCBiZSBzbWFydGVyIGhlcmVcbiAgICBkMy5zZWxlY3QoJyNzZXR4TGVmdCcpLnNlbGVjdEFsbCgnc3ZnJykucmVtb3ZlKCk7XG4gICAgZDMuc2VsZWN0KCcjdGFiMicpLnNlbGVjdEFsbCgnc3ZnJykucmVtb3ZlKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmKGFsbE5vZGVzW2lkc1tpXV0udmFsaWQ9PTApIC8vIHRoaXMgd2FzIGEgc2lsZW50IGVycm9yLi4uIHZlcnkgZnJ1c3RyYXRpbmcuLi5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBsZXQgbm9kZSA9IGFsbE5vZGVzW2lkc1tpXV07XG4gICAgICAgIG5vZGUuc2V0eHBsb3QgPSBmYWxzZTtcbiAgICAgICAgbm9kZS5zdWJzZXRwbG90ID0gZmFsc2U7XG4gICAgICAgIGlmIChub2RlLnBsb3R0eXBlID09PSBcImNvbnRpbnVvdXNcIiAmIG5vZGUuc2V0eHBsb3QgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG5vZGUuc2V0eHBsb3QgPSB0cnVlO1xuICAgICAgICAgICAgZGVuc2l0eShub2RlLCBkaXYgPSBcInNldHhMZWZ0XCIsIHByaXYpO1xuICAgICAgICAgICAgbm9kZS5zdWJzZXRwbG90ID0gdHJ1ZTtcbiAgICAgICAgICAgIGRlbnNpdHkobm9kZSwgZGl2ID0gXCJzdWJzZXRcIiwgcHJpdik7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS5wbG90dHlwZSA9PT0gXCJiYXJcIiAmIG5vZGUuc2V0eHBsb3QgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG5vZGUuc2V0eHBsb3QgPSB0cnVlO1xuICAgICAgICAgICAgYmFycyhub2RlLCBkaXYgPSBcInNldHhMZWZ0XCIsIHByaXYpO1xuICAgICAgICAgICAgbm9kZS5zdWJzZXRwbG90ID0gdHJ1ZTtcbiAgICAgICAgICAgIGJhcnNTdWJzZXQobm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAgICAgZDMuc2VsZWN0KFwiI3NldHhMZWZ0XCIpLnNlbGVjdEFsbChcInN2Z1wiKVxuICAgICAgICAuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKTtcbiAgICAgICAgICAgICAgdmFyIHJlZ3N0ciA9IC8oLispX3NldHhMZWZ0XyhcXGQrKS87XG4gICAgICAgICAgICAgIHZhciBteW5hbWUgPSByZWdzdHIuZXhlYyh0aGlzLmlkKTtcbiAgICAgICAgICAgICAgdmFyIG5vZGVpZCA9IG15bmFtZVsyXTtcbiAgICAgICAgICAgICAgbXluYW1lID0gbXluYW1lWzFdO1xuICAgICAgICAgICAgICBpZiAoIXZhcnMuaW5jbHVkZXMobXluYW1lKSkge1xuICAgICAgICAgICAgICBhbGxOb2Rlc1tub2RlaWRdLnNldHhwbG90ID0gZmFsc2U7XG4gICAgICAgICAgICAgIGxldCB0ZW1wID0gXCIjXCIuY29uY2F0KG15bmFtZSwgXCJfc2V0eExlZnRfXCIsIG5vZGVpZCk7XG4gICAgICAgICAgICAgIGQzLnNlbGVjdCh0ZW1wKVxuICAgICAgICAgICAgICAucmVtb3ZlKCk7XG4gICAgICAgICAgICAgIGFsbE5vZGVzW25vZGVpZF0uc3Vic2V0cGxvdCA9IGZhbHNlO1xuICAgICAgICAgICAgICB0ZW1wID0gXCIjXCIuY29uY2F0KG15bmFtZSwgXCJfdGFiMl9cIiwgbm9kZWlkKTtcbiAgICAgICAgICAgICAgZDMuc2VsZWN0KHRlbXApXG4gICAgICAgICAgICAgIC5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbn1cblxuLyoqXG4gICBjb252ZXJ0cyBjb2xvciBjb2Rlc1xuKi9cbmV4cG9ydCBsZXQgaGV4VG9SZ2JhID0gaGV4ID0+IHtcbiAgICBsZXQgaW50ID0gcGFyc2VJbnQoaGV4LnJlcGxhY2UoJyMnLCAnJyksIDE2KTtcbiAgICByZXR1cm4gYHJnYmEoJHtbKGludCA+PiAxNikgJiAyNTUsIChpbnQgPj4gOCkgJiAyNTUsIGludCAmIDI1NSwgJzAuNSddLmpvaW4oJywnKX0pYDtcbn07XG5cbi8qKlxuICAgdGFrZXMgbm9kZSBhbmQgY29sb3IgYW5kIHVwZGF0ZXMgenBhcmFtc1xuKi9cbmZ1bmN0aW9uIHNldENvbG9ycyhuLCBjKSB7XG4gICAgaWYgKG4uc3Ryb2tlV2lkdGggPT0gJzEnKSB7XG4gICAgICAgIGlmIChjID09IGdyMUNvbG9yKXtcbiAgICAgICAgICAgIHZhciB0ZW1waW5kZXggPSB6cGFyYW1zLnpncm91cDEuaW5kZXhPZihuLm5hbWUpO1xuICAgICAgICAgICAgaWYgKHRlbXBpbmRleCA+IC0xKXtcbiAgICAgICAgICAgICAgICBuLmdyb3VwMSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGRlbCh6cGFyYW1zLnpncm91cDEsIHRlbXBpbmRleCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG4uZ3JvdXAxID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB6cGFyYW1zLnpncm91cDEucHVzaChuLm5hbWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChjID09IGdyMkNvbG9yKXtcbiAgICAgICAgICAgIHZhciB0ZW1waW5kZXggPSB6cGFyYW1zLnpncm91cDIuaW5kZXhPZihuLm5hbWUpO1xuICAgICAgICAgICAgaWYgKHRlbXBpbmRleCA+IC0xKXtcbiAgICAgICAgICAgICAgICBuLmdyb3VwMiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGRlbCh6cGFyYW1zLnpncm91cDIsIHRlbXBpbmRleCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG4uZ3JvdXAyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB6cGFyYW1zLnpncm91cDIucHVzaChuLm5hbWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYWRkaW5nIHRpbWUsIGNzLCBkdiwgbm9tIHRvIG5vZGUgd2l0aCBubyBzdHJva2VcbiAgICAgICAgbi5zdHJva2VXaWR0aCA9ICc0JztcbiAgICAgICAgbi5zdHJva2VDb2xvciA9IGM7XG4gICAgICAgIG4ubm9kZUNvbCA9IHRhZ2dlZENvbG9yO1xuICAgICAgICBsZXQgcHVzaCA9IChbY29sb3IsIGtleV0pID0+IHtcbiAgICAgICAgICAgIGlmIChjb2xvciAhPSBjKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHpwYXJhbXNba2V5XSA9IEFycmF5LmlzQXJyYXkoenBhcmFtc1trZXldKSA/IHpwYXJhbXNba2V5XSA6IFtdO1xuICAgICAgICAgICAgenBhcmFtc1trZXldLnB1c2gobi5uYW1lKTtcbiAgICAgICAgICAgIGlmIChrZXkgPT0gJ3pub20nKSB7XG4gICAgICAgICAgICAgICAgZmluZE5vZGVJbmRleChuLm5hbWUsIHRydWUpLm5hdHVyZSA9IFwibm9taW5hbFwiO1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybShuLm5hbWUsIHQgPSBudWxsLCB0eXBlVHJhbnNmb3JtID0gdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoa2V5ID09ICd6ZHYnKXsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGdyb3VwIG1lbWJlcnNoaXBzIGZyb20gZHYnc1xuICAgICAgICAgICAgICAgIGlmKG4uZ3JvdXAxKXtcbiAgICAgICAgICAgICAgICAgICAgbi5ncm91cDEgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZGVsKHpwYXJhbXMuemdyb3VwMSwgLTEsIG4ubmFtZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZihuLmdyb3VwMil7XG4gICAgICAgICAgICAgICAgICAgIG4uZ3JvdXAyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGRlbCh6cGFyYW1zLnpncm91cDIsIC0xLCBuLm5hbWUpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFtbZHZDb2xvciwgJ3pkdiddLCBbY3NDb2xvciwgJ3pjcm9zcyddLCBbdGltZUNvbG9yLCAnenRpbWUnXSwgW25vbUNvbG9yLCAnem5vbSddXS5mb3JFYWNoKHB1c2gpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChuLnN0cm9rZVdpZHRoID09ICc0Jykge1xuICAgICAgICBpZiAoYyA9PSBuLnN0cm9rZUNvbG9yKSB7IC8vIGRlc2VsZWN0aW5nIHRpbWUsIGNzLCBkdiwgbm9tXG4gICAgICAgICAgICBuLnN0cm9rZVdpZHRoID0gJzEnO1xuICAgICAgICAgICAgbi5zdHJva2VDb2xvciA9IHNlbFZhckNvbG9yO1xuICAgICAgICAgICAgbi5ub2RlQ29sID0gY29sb3JzKG4uaWQpO1xuICAgICAgICAgICAgenBhcmFtc1Jlc2V0KG4ubmFtZSk7XG4gICAgICAgICAgICBpZiAobm9tQ29sb3IgPT0gYyAmJiB6cGFyYW1zLnpub20uaW5jbHVkZXMobi5uYW1lKSkge1xuICAgICAgICAgICAgICAgIGZpbmROb2RlSW5kZXgobi5uYW1lLCB0cnVlKS5uYXR1cmUgPSBmaW5kTm9kZUluZGV4KG4ubmFtZSwgdHJ1ZSkuZGVmYXVsdE5hdHVyZTtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm0obi5uYW1lLCB0ID0gbnVsbCwgdHlwZVRyYW5zZm9ybSA9IHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgeyAvLyBkZXNlbGVjdGluZyB0aW1lLCBjcywgZHYsIG5vbSBBTkQgY2hhbmdpbmcgaXQgdG8gdGltZSwgY3MsIGR2LCBub21cbiAgICAgICAgICAgIHpwYXJhbXNSZXNldChuLm5hbWUpO1xuICAgICAgICAgICAgaWYgKG5vbUNvbG9yID09IG4uc3Ryb2tlQ29sb3IgJiYgenBhcmFtcy56bm9tLmluY2x1ZGVzKG4ubmFtZSkpIHtcbiAgICAgICAgICAgICAgICBmaW5kTm9kZUluZGV4KG4ubmFtZSwgdHJ1ZSkubmF0dXJlID0gZmluZE5vZGVJbmRleChuLm5hbWUsIHRydWUpLmRlZmF1bHROYXR1cmU7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtKG4ubmFtZSwgdCA9IG51bGwsIHR5cGVUcmFuc2Zvcm0gPSB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG4uc3Ryb2tlQ29sb3IgPSBjO1xuICAgICAgICAgICAgaWYgKGR2Q29sb3IgPT0gYyl7XG4gICAgICAgICAgICAgICAgdmFyIGR2bmFtZSA9IG4ubmFtZTtcbiAgICAgICAgICAgICAgICB6cGFyYW1zLnpkdi5wdXNoKGR2bmFtZSk7XG4gICAgICAgICAgICAgICAgaWYobi5ncm91cDEpeyAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBncm91cCBtZW1iZXJzaGlwcyBmcm9tIGR2J3NcbiAgICAgICAgICAgICAgICAgICAgbmdyb3VwMSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBkZWwoenBhcmFtcy56Z3JvdXAxLCAtMSwgZHZuYW1lKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmKG4uZ3JvdXAyKXtcbiAgICAgICAgICAgICAgICAgICAgbmdyb3VwMiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBkZWwoenBhcmFtcy56Z3JvdXAyLCAtMSwgZHZuYW1lKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY3NDb2xvciA9PSBjKSB6cGFyYW1zLnpjcm9zcy5wdXNoKG4ubmFtZSk7XG4gICAgICAgICAgICBlbHNlIGlmICh0aW1lQ29sb3IgPT0gYykgenBhcmFtcy56dGltZS5wdXNoKG4ubmFtZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChub21Db2xvciA9PSBjKSB7XG4gICAgICAgICAgICAgICAgenBhcmFtcy56bm9tLnB1c2gobi5uYW1lKTtcbiAgICAgICAgICAgICAgICBmaW5kTm9kZUluZGV4KG4ubmFtZSwgdHJ1ZSkubmF0dXJlID0gXCJub21pbmFsXCI7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtKG4ubmFtZSwgdCA9IG51bGwsIHR5cGVUcmFuc2Zvcm0gPSB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqIG5lZWRzIGRvYyAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJvcmRlclN0YXRlKCkge1xuICAgIHpwYXJhbXMuemR2Lmxlbmd0aCA+IDAgP1xuICAgICAgICAkKCcjZHZCdXR0b24gLnJlY3RDb2xvciBzdmcgY2lyY2xlJykuYXR0cignc3Ryb2tlJywgZHZDb2xvcikgOlxuICAgICAgICAkKCcjZHZCdXR0b24nKS5jc3MoJ2JvcmRlci1jb2xvcicsICcjY2NjJyk7XG4gICAgenBhcmFtcy56Y3Jvc3MubGVuZ3RoID4gMCA/XG4gICAgICAgICQoJyNjc0J1dHRvbiAucmVjdENvbG9yIHN2ZyBjaXJjbGUnKS5hdHRyKCdzdHJva2UnLCBjc0NvbG9yKSA6XG4gICAgICAgICQoJyNjc0J1dHRvbicpLmNzcygnYm9yZGVyLWNvbG9yJywgJyNjY2MnKTtcbiAgICB6cGFyYW1zLnp0aW1lLmxlbmd0aCA+IDAgP1xuICAgICAgICAkKCcjdGltZUJ1dHRvbiAucmVjdENvbG9yIHN2ZyBjaXJjbGUnKS5hdHRyKCdzdHJva2UnLCB0aW1lQ29sb3IpIDpcbiAgICAgICAgJCgnI3RpbWVCdXR0b24nKS5jc3MoJ2JvcmRlci1jb2xvcicsICcjY2NjJyk7XG4gICAgenBhcmFtcy56bm9tLmxlbmd0aCA+IDAgP1xuICAgICAgICAkKCcjbm9tQnV0dG9uIC5yZWN0Q29sb3Igc3ZnIGNpcmNsZScpLmF0dHIoJ3N0cm9rZScsIG5vbUNvbG9yKSA6XG4gICAgICAgICQoJyNub21CdXR0b24nKS5jc3MoJ2JvcmRlci1jb2xvcicsICcjY2NjJyk7XG4gICAgenBhcmFtcy56Z3JvdXAxLmxlbmd0aCA+IDAgP1xuICAgICAgICAkKCcjZ3IxQnV0dG9uIC5yZWN0Q29sb3Igc3ZnIGNpcmNsZScpLmF0dHIoJ3N0cm9rZScsIGdyMUNvbG9yKS5hdHRyKCdmaWxsJywgZ3IxQ29sb3IpLmF0dHIoJ2ZpbGwtb3BhY2l0eScsIDAuNikuYXR0cignc3Ryb2tlLW9wYWNpdHknLCAwKSA6XG4gICAgICAgICQoJyNncjFCdXR0b24nKS5jc3MoJ2JvcmRlci1jb2xvcicsICcjY2NjJyk7XG4gICAgenBhcmFtcy56Z3JvdXAyLmxlbmd0aCA+IDAgP1xuICAgICAgICAkKCcjZ3IyQnV0dG9uIC5yZWN0Q29sb3Igc3ZnIGNpcmNsZScpLmF0dHIoJ3N0cm9rZScsIGdyMkNvbG9yKS5hdHRyKCdmaWxsJywgZ3IyQ29sb3IpLmF0dHIoJ2ZpbGwtb3BhY2l0eScsIDAuNikuYXR0cignc3Ryb2tlLW9wYWNpdHknLCAwKSA6XG4gICAgICAgICQoJyNncjJCdXR0b24nKS5jc3MoJ2JvcmRlci1jb2xvcicsICcjY2NjJyk7XG59XG5cbi8qKiBuZWVkcyBkb2MgKi9cbmV4cG9ydCBmdW5jdGlvbiBzdWJzZXRTZWxlY3QoYnRuKSB7XG4gICAgaWYgKGRhdGF1cmwpIHtcbiAgICAgICAgenBhcmFtcy56ZGF0YXVybCA9IGRhdGF1cmw7XG4gICAgfVxuICAgIGlmIChkb3dubG9hZEluY29tcGxldGUoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgenBhcmFtcy56dmFycyA9IFtdO1xuICAgIHpwYXJhbXMuenBsb3QgPSBbXTtcbiAgICB2YXIgc3Vic2V0RW1wdHkgPSB0cnVlO1xuICAgIC8vIGlzIHRoaXMgdGhlIHNhbWUgYXMgelBvcCgpP1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbm9kZXMubGVuZ3RoOyBqKyspIHsgLy8gcG9wdWxhdGUgenZhcnMgYW5kIHpzdWJzZXQgYXJyYXlzXG4gICAgICAgIHpwYXJhbXMuenZhcnMucHVzaChub2Rlc1tqXS5uYW1lKTtcbiAgICAgICAgdmFyIHRlbXAgPSBub2Rlc1tqXS5pZDtcbiAgICAgICAgenBhcmFtcy56c3Vic2V0W2pdID0gYWxsTm9kZXNbdGVtcF0uc3Vic2V0cmFuZ2U7XG4gICAgICAgIGlmICh6cGFyYW1zLnpzdWJzZXRbal0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKHpwYXJhbXMuenN1YnNldFtqXVswXSAhPSBcIlwiKVxuICAgICAgICAgICAgICAgIHpwYXJhbXMuenN1YnNldFtqXVswXSA9IE51bWJlcih6cGFyYW1zLnpzdWJzZXRbal1bMF0pO1xuICAgICAgICAgICAgaWYgKHpwYXJhbXMuenN1YnNldFtqXVsxXSAhPSBcIlwiKVxuICAgICAgICAgICAgICAgIHpwYXJhbXMuenN1YnNldFtqXVsxXSA9IE51bWJlcih6cGFyYW1zLnpzdWJzZXRbal1bMV0pO1xuICAgICAgICB9XG4gICAgICAgIHpwYXJhbXMuenBsb3QucHVzaChhbGxOb2Rlc1t0ZW1wXS5wbG90dHlwZSk7XG4gICAgICAgIGlmICh6cGFyYW1zLnpzdWJzZXRbal1bMV0gIT0gXCJcIilcbiAgICAgICAgICAgIHN1YnNldEVtcHR5ID0gZmFsc2U7IC8vIG9ubHkgbmVlZCB0byBjaGVjayBvbmVcbiAgICB9XG5cbiAgICBpZiAoc3Vic2V0RW1wdHkgPT0gdHJ1ZSkge1xuICAgICAgICBhbGVydChcIldhcm5pbmc6IE5vIG5ldyBzdWJzZXQgc2VsZWN0ZWQuXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG91dHR5cGVzID0gW107XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBhbGxOb2Rlcy5sZW5ndGg7IGorKykge1xuICAgICAgICBvdXR0eXBlcy5wdXNoKHtcbiAgICAgICAgICAgIHZhcm5hbWVzVHlwZXM6IGFsbE5vZGVzW2pdLm5hbWUsXG4gICAgICAgICAgICBuYXR1cmU6IGFsbE5vZGVzW2pdLm5hdHVyZSxcbiAgICAgICAgICAgIG51bWNoYXI6IGFsbE5vZGVzW2pdLm51bWNoYXIsXG4gICAgICAgICAgICBiaW5hcnk6IGFsbE5vZGVzW2pdLmJpbmFyeSxcbiAgICAgICAgICAgIGludGVydmFsOiBhbGxOb2Rlc1tqXS5pbnRlcnZhbFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzZWxlY3RMYWRkYS5zdGFydCgpOyAvLyBzdGFydCBidXR0b24gbW90aW9uXG4gICAgbGV0IGpzb24gPSBtYWtlUmVxdWVzdChcbiAgICAgICAgUk9PS19TVkNfVVJMICsgJ3N1YnNldFNlbGVjdCcsXG4gICAgICAgIHt6ZGF0YXVybDogenBhcmFtcy56ZGF0YXVybCxcbiAgICAgICAgIHp2YXJzOiB6cGFyYW1zLnp2YXJzLFxuICAgICAgICAgenN1YnNldDogenBhcmFtcy56c3Vic2V0LFxuICAgICAgICAgenNlc3Npb25pZDogenBhcmFtcy56c2Vzc2lvbmlkLFxuICAgICAgICAgenBsb3Q6IHpwYXJhbXMuenBsb3QsXG4gICAgICAgICBjYWxsSGlzdG9yeTogY2FsbEhpc3RvcnksXG4gICAgICAgICB0eXBlU3R1ZmY6IG91dHR5cGVzfSk7XG4gICAgc2VsZWN0TGFkZGEuc3RvcCgpO1xuICAgIGlmICghanNvbikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgJChcIiNidG5WYXJpYWJsZXNcIikudHJpZ2dlcihcImNsaWNrXCIpOyAvLyBwcm9ncmFtbWF0aWMgY2xpY2tzXG4gICAgJChcIiNidG5Nb2RlbHNcIikudHJpZ2dlcihcImNsaWNrXCIpO1xuXG4gICAgdmFyIGdyYXlPdXRzID0gW107XG4gICAgdmFyIHJDYWxsID0gW107XG4gICAgckNhbGxbMF0gPSBqc29uLmNhbGw7XG5cbiAgICAvLyBzdG9yZSBjb250ZW50cyBvZiB0aGUgcHJlLXN1YnNldCBzcGFjZVxuICAgIHpQb3AoKTtcbiAgICB2YXIgbXlOb2RlcyA9IGpRdWVyeS5leHRlbmQodHJ1ZSwgW10sIGFsbE5vZGVzKTtcbiAgICB2YXIgbXlQYXJhbXMgPSBqUXVlcnkuZXh0ZW5kKHRydWUsIHt9LCB6cGFyYW1zKTtcbiAgICB2YXIgbXlUcmFucyA9IGpRdWVyeS5leHRlbmQodHJ1ZSwgW10sIHRyYW5zKTtcbiAgICB2YXIgbXlGb3JjZSA9IGpRdWVyeS5leHRlbmQodHJ1ZSwgW10sIGZvcmNldG9nZ2xlKTtcbiAgICB2YXIgbXlQcmVwcm9jZXNzID0galF1ZXJ5LmV4dGVuZCh0cnVlLCB7fSwgcHJlcHJvY2Vzcyk7XG4gICAgdmFyIG15TG9nID0galF1ZXJ5LmV4dGVuZCh0cnVlLCBbXSwgbG9nQXJyYXkpO1xuICAgIHZhciBteUhpc3RvcnkgPSBqUXVlcnkuZXh0ZW5kKHRydWUsIFtdLCBjYWxsSGlzdG9yeSk7XG5cbiAgICBzcGFjZXNbbXlzcGFjZV0gPSB7XG4gICAgICAgIFwiYWxsTm9kZXNcIjogbXlOb2RlcyxcbiAgICAgICAgXCJ6cGFyYW1zXCI6IG15UGFyYW1zLFxuICAgICAgICBcInRyYW5zXCI6IG15VHJhbnMsXG4gICAgICAgIFwiZm9yY2VcIjogbXlGb3JjZSxcbiAgICAgICAgXCJwcmVwcm9jZXNzXCI6IG15UHJlcHJvY2VzcyxcbiAgICAgICAgXCJsb2dBcnJheVwiOiBteUxvZyxcbiAgICAgICAgXCJjYWxsSGlzdG9yeVwiOiBteUhpc3RvcnlcbiAgICB9O1xuXG4gICAgLy8gcmVtb3ZlIHByZS1zdWJzZXQgc3ZnXG4gICAgdmFyIHNlbGVjdE1lID0gXCIjbVwiLmNvbmNhdChteXNwYWNlKTtcbiAgICBkMy5zZWxlY3Qoc2VsZWN0TWUpLmF0dHIoJ2NsYXNzJywgJ2l0ZW0nKTtcbiAgICBzZWxlY3RNZSA9IFwiI3doaXRlc3BhY2VcIi5jb25jYXQobXlzcGFjZSk7XG4gICAgZDMuc2VsZWN0KHNlbGVjdE1lKS5yZW1vdmUoKTtcblxuICAgIG15c3BhY2UgPSBzcGFjZXMubGVuZ3RoO1xuICAgIGNhbGxIaXN0b3J5LnB1c2goe1xuICAgICAgICBmdW5jOiBcInN1YnNldFwiLFxuICAgICAgICB6dmFyczogalF1ZXJ5LmV4dGVuZCh0cnVlLCBbXSwgenBhcmFtcy56dmFycyksXG4gICAgICAgIHpzdWJzZXQ6IGpRdWVyeS5leHRlbmQodHJ1ZSwgW10sIHpwYXJhbXMuenN1YnNldCksXG4gICAgICAgIHpwbG90OiBqUXVlcnkuZXh0ZW5kKHRydWUsIFtdLCB6cGFyYW1zLnpwbG90KVxuICAgIH0pO1xuXG4gICAgLy8gdGhpcyBpcyB0byBiZSB1c2VkIHRvIGdyYXkgb3V0IGFuZCByZW1vdmUgbGlzdGVuZXJzIGZvciB2YXJpYWJsZXMgdGhhdCBoYXZlIGJlZW4gc3Vic2V0dGVkIG91dCBvZiB0aGUgZGF0YVxuICAgIGZ1bmN0aW9uIHZhck91dCh2KSB7XG4gICAgICAgIC8vIGlmIGluIG5vZGVzLCByZW1vdmUgZ3JheSBvdXQgaW4gbGVmdCBwYW5lbFxuICAgICAgICAvLyBtYWtlIHVuY2xpY2thYmxlIGluIGxlZnQgcGFuZWxcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0TWUgPSB2W2ldLnJlcGxhY2UoL1xcVy9nLCBcIl9cIik7XG4gICAgICAgICAgICBieUlkKHNlbGVjdE1lKS5zdHlsZS5jb2xvciA9IGhleFRvUmdiYShncmF5Q29sb3IpO1xuICAgICAgICAgICAgc2VsZWN0TWUgPSBcInAjXCIuY29uY2F0KHNlbGVjdE1lKTtcbiAgICAgICAgICAgIGQzLnNlbGVjdChzZWxlY3RNZSlcbiAgICAgICAgICAgICAgICAub24oXCJjbGlja1wiLCBudWxsKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNob3dMb2coJ3N1YnNldCcsIHJDYWxsKTtcblxuICAgIGQzLnNlbGVjdChcIiNpbm5lcmNhcm91c2VsXCIpXG4gICAgICAgIC5hcHBlbmQoJ2RpdicpXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdpdGVtIGFjdGl2ZScpXG4gICAgICAgIC5hdHRyKCdpZCcsICgpID0+IFwibVwiLmNvbmNhdChteXNwYWNlLnRvU3RyaW5nKCkpKVxuICAgICAgICAuYXBwZW5kKCdzdmcnKVxuICAgICAgICAuYXR0cignaWQnLCAnd2hpdGVzcGFjZScpO1xuICAgIHN2ZyA9IGQzLnNlbGVjdChcIiN3aGl0ZXNwYWNlXCIpO1xuXG4gICAgZDMuanNvbihqc29uLnVybCwgZnVuY3Rpb24oZXJyb3IsIGpzb24pIHtcbiAgICAgICAgaWYgKGVycm9yKXtcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBqc29uZGF0YSA9IGdldFZhcmlhYmxlRGF0YShqc29uKTtcblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4ganNvbmRhdGEpIHtcbiAgICAgICAgICAgIHZhciBteUluZGV4ID0gZmluZE5vZGVJbmRleChrZXkpO1xuXG4gICAgICAgICAgICBhbGxOb2Rlc1tteUluZGV4XS5wbG90eCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGFsbE5vZGVzW215SW5kZXhdLnBsb3R5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgYWxsTm9kZXNbbXlJbmRleF0ucGxvdHZhbHVlcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGFsbE5vZGVzW215SW5kZXhdLnBsb3R0eXBlID0gXCJcIjtcblxuICAgICAgICAgICAgalF1ZXJ5LmV4dGVuZCh0cnVlLCBhbGxOb2Rlc1tteUluZGV4XSwganNvbmRhdGFba2V5XSk7XG4gICAgICAgICAgICBhbGxOb2Rlc1tteUluZGV4XS5zdWJzZXRwbG90ID0gZmFsc2U7XG4gICAgICAgICAgICBhbGxOb2Rlc1tteUluZGV4XS5zdWJzZXRyYW5nZSA9IFtcIlwiLCBcIlwiXTtcbiAgICAgICAgICAgIGFsbE5vZGVzW215SW5kZXhdLnNldHhwbG90ID0gZmFsc2U7XG4gICAgICAgICAgICBhbGxOb2Rlc1tteUluZGV4XS5zZXR4dmFscyA9IFtcIlwiLCBcIlwiXTtcblxuICAgICAgICAgICAgaWYgKGFsbE5vZGVzW215SW5kZXhdLnZhbGlkID09IDApIHtcbiAgICAgICAgICAgICAgICBncmF5T3V0cy5wdXNoKGFsbE5vZGVzW215SW5kZXhdLm5hbWUpO1xuICAgICAgICAgICAgICAgIGFsbE5vZGVzW215SW5kZXhdLmdyYXlvdXQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlUGxvdCgpO1xuICAgICAgICBsYXlvdXQobGF5b3V0QWRkKTtcbiAgICB9KTtcblxuICAgIHZhck91dChncmF5T3V0cyk7XG59XG5cbi8qKlxuICAgcmVtb3ZlcyBhbGwgdGhlIGNoaWxkcmVuIHN2Z3MgaW5zaWRlIHN1YnNldCBhbmQgc2V0eCBkaXZzXG4qL1xuZnVuY3Rpb24gcmVQbG90KCkge1xuICAgIGQzLnNlbGVjdCgnI3RhYjInKVxuICAgICAgICAuc2VsZWN0QWxsKCdzdmcnKVxuICAgICAgICAucmVtb3ZlKCk7XG4gICAgZDMuc2VsZWN0KCcjc2V0eCcpXG4gICAgICAgIC5zZWxlY3RBbGwoJ3N2ZycpXG4gICAgICAgIC5yZW1vdmUoKTtcbiAgICBhbGxOb2Rlcy5mb3JFYWNoKG4gPT4gbi5zZXR4cGxvdCA9IG4uc3Vic2V0cGxvdCA9IGZhbHNlKTtcbn1cblxuLy8gYWN0cyBhcyBpZiB0aGUgdXNlciBjbGlja2VkIGluIHdoaXRlc3BhY2UuIHVzZWZ1bCB3aGVuIHJlc3RhcnQoKSBpcyBvdXRzaWRlIG9mIHNjb3BlXG5leHBvcnQgbGV0IGZha2VDbGljayA9ICgpID0+IHtcbiAgICBsZXQgd3MgPSBcIiN3aGl0ZXNwYWNlXCIuY29uY2F0KG15c3BhY2UpO1xuICAgIC8vIGQzIGFuZCBwcm9ncmFtbWF0aWMgZXZlbnRzIGRvbid0IG1lc2ggd2VsbCwgaGVyZSdzIGEgU08gd29ya2Fyb3VuZCB0aGF0IGxvb2tzIGdvb2QgYnV0IHVzZXMganF1ZXJ5Li4uXG4gICAgalF1ZXJ5LmZuLmQzQ2xpY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5lYWNoKChpLCBlKSA9PiB7XG4gICAgICAgICAgICBsZXQgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJNb3VzZUV2ZW50c1wiKTtcbiAgICAgICAgICAgIGV2dC5pbml0TW91c2VFdmVudChcIm1vdXNlZG93blwiLCB0cnVlLCB0cnVlLCB3aW5kb3csIDAsIDAsIDAsIDAsIDAsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAwLCBudWxsKTtcbiAgICAgICAgICAgIGUuZGlzcGF0Y2hFdmVudChldnQpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgICQod3MpLmQzQ2xpY2soKTtcbiAgICBkMy5zZWxlY3Qod3MpXG4gICAgICAgIC5jbGFzc2VkKCdhY3RpdmUnLCBmYWxzZSk7XG59O1xuXG4vKipcbiAgIEVuZFNlc3Npb24oU2Vzc2lvbkNvbnRleHQpIHJldHVybnMgKFJlc3BvbnNlKSB7fVxuKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBlbmRzZXNzaW9uKCkge1xuICAgLy8gbWFrZVJlcXVlc3QoRDNNX1NWQ19VUkwgKyAnL2VuZHNlc3Npb24nLCBhcGlTZXNzaW9uKHpwYXJhbXMuenNlc3Npb25pZCkpO1xuICAgIGxldCByZXMgPSBhd2FpdCBtYWtlUmVxdWVzdChEM01fU1ZDX1VSTCArICcvZW5kc2Vzc2lvbicsIGFwaVNlc3Npb24oenBhcmFtcy56c2Vzc2lvbmlkKSk7XG4gICAgbGV0IG15c3RhdHVzID0gcmVzLnN0YXR1cy5jb2RlLnRvVXBwZXJDYXNlKCk7XG4gICAgaWYobXlzdGF0dXMgPT0gXCJPS1wiKSB7XG4gICAgICAgIGVuZF90YTNfc2VhcmNoKHRydWUsIFwiUHJvYmxlbSBtYXJrZWQgYXMgY29tcGxldGUuXCIpO1xuICAgIH1cbn1cblxuLyoqXG4gICBycGMgTGlzdFBpcGVsaW5lcyhQaXBlbGluZUxpc3RSZXF1ZXN0KSByZXR1cm5zIChQaXBlbGluZUxpc3RSZXN1bHQpIHt9XG4gICBwaXBlcyBpcyBhbiBhcnJheSBvZiBwaXBlbGluZSBJRHNcbiovXG5leHBvcnQgZnVuY3Rpb24gbGlzdHBpcGVsaW5lcygpIHtcbiAgICBsZXQgcmVzID0gbWFrZVJlcXVlc3QoRDNNX1NWQ19VUkwgKyAnL2xpc3RwaXBlbGluZXMnLCB7Y29udGV4dDogYXBpU2Vzc2lvbih6cGFyYW1zLnpzZXNzaW9uaWQpfSk7XG4gICAgaWYgKCFyZXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vaGFyZGNvZGVkIHBpcGVzIGZvciBub3dcbiAgICBsZXQgcGlwZXMgPSByZXMucGlwZWxpbmVJZHM7XG5cbiAgICAvKlxuICAgICAgcGlwZXMudW5zaGlmdChcInBsYWNlXCIpO1xuICAgICAgY29uc29sZS5sb2cocGlwZXMpO1xuICAgICAgZDMuc2VsZWN0KFwiI3Jlc3VsdHNcIikuc2VsZWN0QWxsKFwicFwiKVxuICAgICAgLmRhdGEocGlwZXMpXG4gICAgICAuZW50ZXIoKVxuICAgICAgLmFwcGVuZChcInBcIilcbiAgICAgIC5hdHRyKFwiaWRcIiwgXCJfcGlwZV9cIi5jb25jYXQpXG4gICAgICAudGV4dChkID0+IGQpXG4gICAgICAuYXR0cignY2xhc3MnLCAnaXRlbS1kZWZhdWx0JylcbiAgICAgIC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgaWYodGhpcy5jbGFzc05hbWU9PVwiaXRlbS1zZWxlY3RcIikge1xuICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgIGQzLnNlbGVjdChcIiNyZXN1bHRzXCIpLnNlbGVjdChcInAuaXRlbS1zZWxlY3RcIilcbiAgICAgIC5hdHRyKCdjbGFzcycsICdpdGVtLWRlZmF1bHQnKTtcbiAgICAgIGQzLnNlbGVjdCh0aGlzKS5hdHRyKCdjbGFzcycsXCJpdGVtLXNlbGVjdFwiKTtcbiAgICAgIH19KTtcblxuICAgICAgcGlwZXMuc2hpZnQoKTtcblxuXG4gICAgICBkMy5zZWxlY3QoXCIjc2V0eFJpZ2h0XCIpLnNlbGVjdEFsbChcInBcIilcbiAgICAgIC5kYXRhKHBpcGVzKVxuICAgICAgLmVudGVyKClcbiAgICAgIC5hcHBlbmQoXCJwXCIpXG4gICAgICAuYXR0cihcImlkXCIsIFwiX3NldHhwaXBlX1wiLmNvbmNhdClcbiAgICAgIC50ZXh0KGQgPT4gZClcbiAgICAgIC5hdHRyKCdjbGFzcycsICdpdGVtLWRlZmF1bHQnKVxuICAgICAgLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG4gICAgICBpZih0aGlzLmNsYXNzTmFtZT09XCJpdGVtLXNlbGVjdFwiKSB7XG4gICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgZDMuc2VsZWN0KFwiI3NldHhSaWdodFwiKS5zZWxlY3QoXCJwLml0ZW0tc2VsZWN0XCIpXG4gICAgICAuYXR0cignY2xhc3MnLCAnaXRlbS1kZWZhdWx0Jyk7XG4gICAgICBkMy5zZWxlY3QodGhpcykuYXR0cignY2xhc3MnLFwiaXRlbS1zZWxlY3RcIik7XG4gICAgICB9fSk7XG4gICAgKi9cbn1cblxuLyoqXG4gICBycGMgRXhlY3V0ZVBpcGVsaW5lKFBpcGVsaW5lRXhlY3V0ZVJlcXVlc3QpIHJldHVybnMgKHN0cmVhbSBQaXBlbGluZUV4ZWN1dGVSZXN1bHQpIHt9XG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGV4ZWN1dGVwaXBlbGluZSgpIHtcbiAgICBsZXQgY29udGV4dCA9IGFwaVNlc3Npb24oenBhcmFtcy56c2Vzc2lvbmlkKTtcbiAgICBsZXQgdGFibGVyb3cgPSBieUlkKCdzZXR4UmlnaHQnKS5xdWVyeVNlbGVjdG9yKCd0ci5pdGVtLXNlbGVjdCcpO1xuICAgIGlmKHRhYmxlcm93ID09IG51bGwpIHthbGVydChcIlBsZWFzZSBzZWxlY3QgYSBwaXBlbGluZSB0byBleGVjdXRlIG9uLlwiKTsgcmV0dXJuO31cbiAgICBsZXQgcGlwZWxpbmVJZD10YWJsZXJvdy5maXJzdENoaWxkLmlubmVyVGV4dDtcblxuICAgIHpQb3AoKTtcbiAgICB6cGFyYW1zLmNhbGxIaXN0b3J5ID0gY2FsbEhpc3Rvcnk7XG4gICAgbGV0IGpzb25vdXQgPSBKU09OLnN0cmluZ2lmeSh6cGFyYW1zKTtcblxuICAgIGxldCBwcmVkaWN0RmVhdHVyZXMgPSBhcGlGZWF0dXJlKHpwYXJhbXMuenZhcnMsXCI8PERBVEFfVVJJPj5cIik7XG4gICAgbGV0IGRhdGEgPSBbXTtcblxuICAgIC8vdGhpcyB3aWxsIGp1c3Qgc2V0IHpwYXJhbXMuenNldHggdG8gdGhlIG1lYW4sIHdoaWNoIGlzIGRlZmF1bHQgZm9yIHNldHggcGxvdHNcbiAgICAvL25vdGUgdGhhdCBpZiBzZXR4cGxvdCBpcyBtb2RpZmllZCwgaXQgd2lsbCBOT1QgPT0gXCJcIiBiZWNhdXNlIHpwYXJhbXMuenNldHggaXMgbW9kaWZpZWQgd2hlbiB0aGUgc2V0eCBwbG90IHNsaWRlciBpcyBtb3ZlZCBmb3IgdGhlIGZpcnN0IHRpbWVcbiAgICBmb3IobGV0IGkgPTA7IGk8enBhcmFtcy56dmFycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgbXlkYXRhID0gW107XG4gICAgICAgIGxldCBteW1lYW4gPSBhbGxOb2Rlc1tmaW5kTm9kZUluZGV4KHpwYXJhbXMuenZhcnNbaV0pXS5tZWFuO1xuICAgICAgICBpZih6cGFyYW1zLnpzZXR4W2ldWzBdPT1cIlwiKSB7XG4gICAgICAgICAgICBteWRhdGFbMF09bXltZWFuO1xuICAgICAgICB9IGVsc2UgaWYoenBhcmFtcy56c2V0eFtpXVswXSE9bXltZWFuKXtcbiAgICAgICAgICAgIG15ZGF0YVswXT16cGFyYW1zLnpzZXR4W2ldWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmKHpwYXJhbXMuenNldHhbaV1bMV09PVwiXCIpIHtcbiAgICAgICAgICAgIG15ZGF0YVsxXT1hbGxOb2Rlc1tmaW5kTm9kZUluZGV4KHpwYXJhbXMuenZhcnNbaV0pXS5tZWFuO1xuICAgICAgICB9IGVsc2UgaWYoenBhcmFtcy56c2V0eFtpXVsxXSE9bXltZWFuKXtcbiAgICAgICAgICAgIG15ZGF0YVsxXT16cGFyYW1zLnpzZXR4W2ldWzFdO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEucHVzaChteWRhdGEpO1xuICAgIH1cblxuICAgIG1ha2VSZXF1ZXN0KEQzTV9TVkNfVVJMICsgJy9leGVjdXRlcGlwZWxpbmUnLCB7Y29udGV4dCwgcGlwZWxpbmVJZCwgcHJlZGljdEZlYXR1cmVzLCBkYXRhfSk7XG59XG5cbi8qKlxuICAgY2FsbCB0byBkamFuZ28gdG8gdXBkYXRlIHRoZSBwcm9ibGVtIHNjaGVtYVxuICAgcnBjIFVwZGF0ZVByb2JsZW1TY2hlbWEoVXBkYXRlUHJvYmxlbVNjaGVtYVJlcXVlc3QpIHJldHVybnMgKFJlc3BvbnNlKSB7fVxuKi9cbmZ1bmN0aW9uIHVwZGF0ZVNjaGVtYSh0eXBlLCB1cGRhdGVzLCBsb29rdXApIHtcbiAgICBtYWtlUmVxdWVzdChcbiAgICAgICAgRDNNX1NWQ19VUkwgKyBcIi91cGRhdGVwcm9ibGVtc2NoZW1hXCIsXG4gICAgICAgIHtyZXBsYWNlUHJvYmxlbVNjaGVtYUZpZWxkOiB7W3R5cGVdOiBsb29rdXBbdXBkYXRlc1t0eXBlXV1bMV19LCBjb250ZXh0OiBhcGlTZXNzaW9uKHpwYXJhbXMuenNlc3Npb25pZCl9KTtcbn1cblxuLyoqXG4gICBmaW5kIHNvbWV0aGluZyBjZW50ZXJpc2ggdG8gdGhlIHZlcnRpY2VzIG9mIGEgY29udmV4IGh1bGxcbiAgIChzcGVjaWZpY2FsbHksIHRoZSBjZW50ZXIgb2YgdGhlIGJvdW5kaW5nIGJveClcbiovXG5mdW5jdGlvbiBqYW1lc2NlbnRyb2lkKGNvb3JkKSB7XG4gICAgdmFyIG1pbnggPSBjb29yZFswXVswXSxcbiAgICAgICAgbWF4eCA9IGNvb3JkWzBdWzBdLFxuICAgICAgICBtaW55ID0gY29vcmRbMF1bMV0sXG4gICAgICAgIG1heHkgPSBjb29yZFswXVsxXTtcbiAgICBmb3IodmFyIGogPSAxOyBqPGNvb3JkLmxlbmd0aDsgaisrKXtcbiAgICAgICAgaWYgKGNvb3JkW2pdWzBdIDwgbWlueCkgbWlueCA9IGNvb3JkW2pdWzBdO1xuICAgICAgICBpZiAoY29vcmRbal1bMV0gPCBtaW55KSBtaW55ID0gY29vcmRbal1bMV07XG4gICAgICAgIGlmIChjb29yZFtqXVswXSA+IG1heHgpIG1heHggPSBjb29yZFtqXVswXTtcbiAgICAgICAgaWYgKGNvb3JkW2pdWzFdID4gbWF4eSkgbWF4eSA9IGNvb3JkW2pdWzFdO1xuICAgIH07XG4gICAgICAgIHJldHVyblsobWlueCArIG1heHgpLzIsIChtaW55ICsgbWF4eSkvMl07XG59O1xuXG4vKipcbiAgIERlZmluZSBlYWNoIHBlYmJsZSByYWRpdXMuXG4gICBQcmVzZW50bHksIG1vc3QgcGViYmxlcyBhcmUgc2NhbGVkIHRvIHJhZGl1cyBzZXQgYnkgZ2xvYmFsIFJBRElVUy5cbiAgIE1lbWJlcnMgb2YgZ3JvdXBzIGFyZSBzY2FsZWQgZG93biBpZiBncm91cCBnZXRzIGxhcmdlLlxuKi9cbmZ1bmN0aW9uIHNldFBlYmJsZVJhZGl1cyhkKXtcbiAgICBpZiAoZC5ncm91cDEgfHwgZC5ncm91cDIpeyAvLyBpZiBhIG1lbWJlciBvZiBhIGdyb3VwLCBuZWVkIHRvIGNhbGN1bGF0ZSByYWRpdXMgc2l6ZVxuICAgICAgICB2YXIgdXBwZXJzaXplID0gN1xuICAgICAgICB2YXIgbmcxID0gKGQuZ3JvdXAxKSA/IHpwYXJhbXMuemdyb3VwMS5sZW5ndGggOiAxOyAvLyBzaXplIG9mIGdyb3VwMSwgaWYgYSBtZW1iZXIgb2YgZ3JvdXAgMVxuICAgICAgICB2YXIgbmcyID0gKGQuZ3JvdXAyKSA/IHpwYXJhbXMuemdyb3VwMi5sZW5ndGggOiAxOyAvLyBzaXplIG9mIGdyb3VwMiwgaWYgYSBtZW1iZXIgb2YgZ3JvdXAgMlxuICAgICAgICB2YXIgbWF4bmcgPSBNYXRoLm1heChuZzEsIG5nMik7IC8vIHNpemUgb2YgdGhlIGxhcmdlc3QgZ3JvdXAgdmFyaWFibGUgaXMgbWVtYmVyIG9mXG4gICAgICAgIHJldHVybiAobWF4bmc+dXBwZXJzaXplKSA/IFJBRElVUypNYXRoLnNxcnQodXBwZXJzaXplL21heG5nKSA6IFJBRElVUzsgLy8ga2VlcCB0b3RhbCBhcmVhIG9mIHBlYmJsZXMgYm91bmRlZCB0byBwaSAqIFJBRElVU14yICogdXBwZXJzaXplLCB0aHVzIHNocmlua2luZyByYWRpdXMgZm9yIHBlYmJsZXMgaW4gbGFyZ2VyIGdyb3Vwc1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBSQURJVVM7IC8vIG5vbmdyb3VwIG1lbWJlcnMgZ2V0IHRoZSBjb21tb24gZ2xvYmFsIHJhZGl1c1xuICAgIH1cbn07XG5cbi8qKlxuICAgRGVmaW5lIGVhY2ggcGViYmxlIGNoYXJnZS5cbiovXG5mdW5jdGlvbiBzZXRQZWJibGVDaGFyZ2UoZCl7XG4gICAgaWYoZC5ncm91cDEgfHwgZC5ncm91cDIpe1xuICAgICAgICBpZihkLmZvcmVmcm9udCl7Ly8gcGViYmxlcyBwYWNrZWQgaW4gZ3JvdXBzIHJlcGVsIG90aGVycyBvbiBtb3VzZW92ZXJcbiAgICAgICAgICAgIHJldHVybiAtMTAwMFxuICAgICAgICB9XG4gICAgICAgIHZhciB1cHBlcnNpemUgPSA3XG4gICAgICAgIHZhciBuZzEgPSAoZC5ncm91cDEpID8genBhcmFtcy56Z3JvdXAxLmxlbmd0aCA6IDE7ICAgICAgLy8gc2l6ZSBvZiBncm91cDEsIGlmIGEgbWVtYmVyIG9mIGdyb3VwIDFcbiAgICAgICAgdmFyIG5nMiA9IChkLmdyb3VwMikgPyB6cGFyYW1zLnpncm91cDIubGVuZ3RoIDogMTsgICAgICAvLyBzaXplIG9mIGdyb3VwMiwgaWYgYSBtZW1iZXIgb2YgZ3JvdXAgMlxuICAgICAgICB2YXIgbWF4bmcgPSBNYXRoLm1heChuZzEsbmcyKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzaXplIG9mIHRoZSBsYXJnZXN0IGdyb3VwIHZhcmlhYmxlIGlzIG1lbWJlciBvZlxuICAgICAgICByZXR1cm4gKG1heG5nPnVwcGVyc2l6ZSkgPyAtNDAwKih1cHBlcnNpemUvbWF4bmcpIDogLTQwMDsgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkZWNyZWFzZSBjaGFyZ2UgYXMgcGViYmxlcyBiZWNvbWUgc21hbGxlciwgc28gdGhleSBjYW4gcGFjayB0b2dldGhlclxuICAgIH1lbHNle1xuICAgICAgICByZXR1cm4gLTgwMDtcbiAgICB9XG59O1xuXG4vKiogbmVlZHMgZG9jICovXG5leHBvcnQgZnVuY3Rpb24gZXhwYW5kcmlnaHRwYW5lbCgpIHtcbiAgICBieUlkKCdyaWdodHBhbmVsJykuY2xhc3NMaXN0LmFkZChcImV4cGFuZHBhbmVsZnVsbFwiKTtcbiAgICBjb25zb2xlLmxvZyhcIkhFUkVcIik7XG59XG5cbi8qKiBuZWVkcyBkb2MgKi9cbmZ1bmN0aW9uIHRvZ2dsZVJpZ2h0QnV0dG9ucyhzZXQpIHtcbiAgICBmdW5jdGlvbiBzZXRXaWR0aHMoYnRucykge1xuICAgICAgICBsZXQgd2lkdGggPSBgJHsxMDAgLyBidG5zLmxlbmd0aH0lYDtcbiAgICAgICAgbGV0IGV4cGFuZHdpZHRoID0gJzM1JSc7XG4gICAgICAgIGxldCBzaHJpbmt3aWR0aCA9IGAkezY1IC8gKGJ0bnMubGVuZ3RoIC0gMSl9JWA7XG4gICAgICAgIGxldCBsaXMgPSBieUlkKCdyaWdodHBhbmVsJykucXVlcnlTZWxlY3RvckFsbChcIi5hY2NvcmRpb24gbGlcIik7XG4gICAgICAgIC8vIGhhcmRseSBldmVyIHJ1bnMgb24gdGhlIHBhZ2VcbiAgICAgICAgbGlzLmZvckVhY2gobGkgPT4ge1xuICAgICAgICAgICAgbGkuc3R5bGUud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIGxpLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3ZlcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGxpcy5mb3JFYWNoKGxpID0+IGxpLnN0eWxlLndpZHRoID0gc2hyaW5rd2lkdGgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGUud2lkdGggPSBleHBhbmR3aWR0aDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGkuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBsaXMuZm9yRWFjaChsaSA9PiBsaS5zdHlsZS53aWR0aCA9IHdpZHRoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgIH1cblxuICAgIGlmKHNldD09XCJ0YXNrc1wiKSB7XG4gICAgICAgIGJ5SWQoJ2J0bk1vZGVscycpLmNsYXNzTGlzdC5hZGQoXCJub3Nob3dcIik7XG4gICAgICAgIGJ5SWQoJ2J0blNldHgnKS5jbGFzc0xpc3QuYWRkKFwibm9zaG93XCIpO1xuICAgICAgICBieUlkKCdidG5SZXN1bHRzJykuY2xhc3NMaXN0LmFkZChcIm5vc2hvd1wiKTtcbiAgICAgICAgbGV0IGJ0bnMgPSBieUlkKCdyaWdodHBhbmVsYnV0dG9ucycpLnF1ZXJ5U2VsZWN0b3JBbGwoXCIuYnRuOm5vdCgubm9zaG93KVwiKTtcbiAgICAgICAgc2V0V2lkdGhzKGJ0bnMpO1xuICAgIH0gZWxzZSBpZiAoc2V0PT1cImFsbFwiKSB7XG4gICAgICAgIC8vIGZpcnN0IHJlbW92ZSBub3Nob3cgY2xhc3NcbiAgICAgICAgbGV0IGJ0bnMgPSBieUlkKCdyaWdodHBhbmVsYnV0dG9ucycpLnF1ZXJ5U2VsZWN0b3JBbGwoXCIubm9zaG93XCIpO1xuICAgICAgICBidG5zLmZvckVhY2goYiA9PiBiLmNsYXNzTGlzdC5yZW1vdmUoXCJub3Nob3dcIikpO1xuXG4gICAgICAgIC8vIGRyb3BwaW5nIG1vZGVscyBmb3IgSVNfRDNNX0RPTUFJTlxuICAgICAgICBieUlkKCdidG5Nb2RlbHMnKS5jbGFzc0xpc3QuYWRkKFwibm9zaG93XCIpO1xuXG4gICAgICAgIC8vIGlmIHN3YW5kaXZlLCBkcm9wcGluZyBzZXR4XG4gICAgICAgIGlmKHN3YW5kaXZlKVxuICAgICAgICAgICAgYnlJZCgnYnRuU2V0eCcpLmNsYXNzTGlzdC5hZGQoXCJub3Nob3dcIik7XG5cbiAgICAgICAgLy8gdGhlbiBzZWxlY3QgYWxsIHRoZSBidXR0b25zXG4gICAgICAgIGJ0bnMgPSBieUlkKCdyaWdodHBhbmVsYnV0dG9ucycpLnF1ZXJ5U2VsZWN0b3JBbGwoXCIuYnRuOm5vdCgubm9zaG93KVwiKTtcbiAgICAgICAgc2V0V2lkdGhzKGJ0bnMpO1xuICAgIH0gZWxzZSBpZihzZXQ9PVwibW9kZWxzXCIpIHtcbiAgICAgICAgYnlJZCgnYnRuTW9kZWxzJykuc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUnO1xuICAgICAgICBieUlkKCdidG5TZXR4Jykuc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUnO1xuICAgICAgICBieUlkKCdidG5SZXN1bHRzJykuc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUnO1xuXG4gICAgICAgIGJ5SWQoJ2J0blR5cGUnKS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICBieUlkKCdidG5TdWJ0eXBlJykuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgYnlJZCgnYnRuTWV0cmljcycpLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gLy8gICAgICAgYnlJZCgnYnRuT3V0cHV0cycpLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgfVxufVxuXG4vKiogbmVlZHMgZG9jICovXG5leHBvcnQgZnVuY3Rpb24gcmVzdWx0c3Bsb3Rpbml0KHBpZCwgZHZ2YWx1ZXMpIHtcbiAgICAvLyBwcmVzdW1hYmx5IHdlJ2xsIGJlIHJlYWRpbmcgaW4gcmVzdWx0cyBmcm9tIGEgcGF0aFxuICAgIC8vIGZvciBub3cgaXQncyBqdXN0IGhhcmRjb2RlZFxuICAgIGNvbnNvbGUubG9nKHBpZCk7XG4gICAgbGV0IHByZWRmaWxlID0gcGlkLnBpcGVsaW5lSW5mby5wcmVkaWN0UmVzdWx0RGF0YS5maWxlXzE7XG4gICAgbGV0IHByZWR2YWxzID0gW107XG5cbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgcHJlZGZpbGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcHJlZHZhbHMucHVzaChOdW1iZXIocHJlZGZpbGVbaV0ucHJlZHMpKTtcbiAgICB9XG5cbiAgICAvLyBvbmx5IGRvIHRoaXMgZm9yIGNsYXNzaWZpY2F0aW9uIHRhc2tzXG4gICAgaWYoZDNtVGFza1R5cGVbZDNtUHJvYmxlbURlc2NyaXB0aW9uLnRhc2tUeXBlXVsxXSA9PSBcIkNMQVNTSUZJQ0FUSU9OXCIpIHtcbiAgICAgICAgZ2VuY29uZmRhdGEoZHZ2YWx1ZXMsIHByZWR2YWxzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgeGRhdGEgPSBcIkFjdHVhbFwiO1xuICAgICAgICBsZXQgeWRhdGEgPSBcIlByZWRpY3RlZFwiO1xuICAgICAgICBiaXZhcmlhdGVQbG90KGR2dmFsdWVzLCBwcmVkdmFscywgeGRhdGEsIHlkYXRhKTtcbiAgICB9XG59XG5cbi8qKiBuZWVkcyBkb2MgKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5jb25mZGF0YSAoZHZ2YWx1ZXMsIHByZWR2YWxzKSB7XG4gICAgLy8gRk9SIFRFU1RJTkdcbiAgICBkdnZhbHVlcyA9IHByZWR2YWxzLnNsaWNlKDApO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBkdnZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcmFuZG9tbnVtYmVyID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKDIgLSAtMiArIDEpKSArIC0yO1xuICAgICAgICBkdnZhbHVlc1tpXSA9IGR2dmFsdWVzW2ldICsgcmFuZG9tbnVtYmVyO1xuICAgIH1cblxuICAgIC8vIGRvbmUgZm9yIHRlc3RpbmcuIGRyb3AgYWJvdmUgd2hlbiBkdnZhbHVlcyBhcmUgcmVhbCB2YWx1ZXMgcmV0dXJuZWQgYnkgUiB3aGVuIHBpcGVsaW5lIGlzIGNvbnN0cnVjdGVkXG5cbiAgICBmdW5jdGlvbiBvbmx5VW5pcXVlKHZhbHVlLCBpbmRleCwgc2VsZikge1xuICAgICAgICByZXR1cm4gc2VsZi5pbmRleE9mKHZhbHVlKSA9PT0gaW5kZXg7XG4gICAgfVxuXG4gICAgbGV0IG15Y291bnRzID0gW107XG4gICAgbGV0IG15cGFpcnMgPSBbXTtcblxuICAgIC8vIHRoaXMgc2hvdWxkIGV2ZW50dWFsbHkgYmUganVzdCByZWFkIGZyb20gdGhlIFVSSSBpbiBwaXBlbGluZVxuICAgLy8gbGV0IGR2dmFsdWVzID0gWzEsMSwxLDIsMywyLDMsMywzLDMsMywyLDMsMiwxLDIsMyw0LDRdO1xuICAgLy8gbGV0IHByZWR2YWxzID0gWzEsMiwzLDIsMywxLDMsMywzLDIsMiwxLDMsMywxLDIsMyw0LDNdO1xuXG4gICAgLy8gY29tYmluZSBhY3R1YWxzIGFuZCBwcmVkaWN0ZWQsIGFuZCBnZXQgYWxsIHVuaXF1ZSBlbGVtZW50c1xuICAgIGxldCBteXVuaXF1ZXMgPSBkdnZhbHVlcy5jb25jYXQocHJlZHZhbHMpO1xuICAgIG15dW5pcXVlcyA9IG15dW5pcXVlcy5maWx0ZXIob25seVVuaXF1ZSk7XG5cbiAgICAvLyBjcmVhdGUgdHdvIGFycmF5czogbXljb3VudHMgaW5pdGlhbGl6ZWQgdG8gMCwgbXlwYWlycyBoYXZlIGVsZW1lbnRzIHNldCB0byBhbGwgcG9zc2libGUgcGFpcnMgb2YgdW5pcXVlc1xuICAgIC8vIGxvb2tlZCBpbnRvIHNvbHV0aW9ucyBvdGhlciB0aGFuIG5lc3RlZCBmb3JzLCBidXQgSW50ZXJuZXQgc3VnZ2VzdCBwZXJmb3JtYW5jZSBpcyBqdXN0IGZpbmUgdGhpcyB3YXlcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgbXl1bmlxdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCB0ZW1wY291bnQgPSBbXTtcbiAgICAgICAgbGV0IHRlbXBwYWlyID0gW107XG4gICAgICAgIGZvcihsZXQgaiA9IDA7IGogPCBteXVuaXF1ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIG15Y291bnRzLnB1c2goMCk7XG4gICAgICAgICAgICBteXBhaXJzLnB1c2goK215dW5pcXVlc1tpXSsnLCcrbXl1bmlxdWVzW2pdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGxpbmUgdXAgYWN0dWFscyBhbmQgcHJlZGljdGVkLCBhbmQgaW5jcmVtZW50IG15Y291bnRzIGF0IGluZGV4IHdoZXJlIG15cGFpciBoYXMgYSBtYXRjaCBmb3IgdGhlICdhY3R1YWwscHJlZGljdGVkJ1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZHZ2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHRlbXBwYWlyID0gK2R2dmFsdWVzW2ldKycsJytwcmVkdmFsc1tpXTtcbiAgICAgICAgbGV0IG15aW5kZXggPSBteXBhaXJzLmluZGV4T2YodGVtcHBhaXIpO1xuICAgICAgICBteWNvdW50c1tteWluZGV4XSArPSAxO1xuICAgIH1cblxuICAgIGxldCBjb25mZGF0YSA9IFtdLCBzaXplID0gbXl1bmlxdWVzLmxlbmd0aDtcbiAgICAvLyBhbm90aGVyIGxvb3AuLi4gdGhpcyBidWlsZHMgdGhlIGFycmF5IG9mIGFycmF5cyBmcm9tIHRoZSBmbGF0IGFycmF5IG15Y291bnRzIGZvciBpbnB1dCB0byBjb25mdXNpb25zbWF0cml4IGZ1bmN0aW9uXG4gICAgd2hpbGUgKG15Y291bnRzLmxlbmd0aCA+IDApXG4gICAgICAgIGNvbmZkYXRhLnB1c2gobXljb3VudHMuc3BsaWNlKDAsIHNpemUpKTtcblxuICAgIGNvbmZ1c2lvbm1hdHJpeChjb25mZGF0YSwgbXl1bmlxdWVzKTtcbn1cblxuLyoqIG5lZWRzIGRvYyAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmZ1c2lvbm1hdHJpeChtYXRyaXhkYXRhLCBjbGFzc2VzKSB7XG4gICAgZDMuc2VsZWN0KFwiI3NldHhNaWRkbGVcIikuaHRtbChcIlwiKTtcbiAgICBkMy5zZWxlY3QoXCIjc2V0eE1pZGRsZVwiKS5zZWxlY3QoXCJzdmdcIikucmVtb3ZlKCk7XG5cbiAgICAvLyBhZGFwdGVkIGZyb20gdGhpcyBibG9jazogaHR0cHM6Ly9ibC5vY2tzLm9yZy9hcnBpdG5hcmVjaGFuaWEvZGJmMDNkOGVmN2ZmZmE0NDYzNzlkNTlkYjYzNTRiYWNcbiAgICBsZXQgbWFpbndpZHRoID0gYnlJZCgnbWFpbicpLmNsaWVudFdpZHRoO1xuICAgIGxldCBtYWluaGVpZ2h0ID0gYnlJZCgnbWFpbicpLmNsaWVudEhlaWdodDtcblxuICAgIGxldCBjb25kaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb25kaXYuaWQ9XCJjb25mdXNpb25jb250YWluZXJcIjtcbiAgICBjb25kaXYuc3R5bGUuZGlzcGxheT1cImlubGluZS1ibG9ja1wiO1xuICAgIGNvbmRpdi5zdHlsZS53aWR0aD0rKG1haW53aWR0aCouMjUpKydweCc7XG4gICAgY29uZGl2LnN0eWxlLm1hcmdpbkxlZnQ9JzIwcHgnO1xuICAgIGNvbmRpdi5zdHlsZS5oZWlnaHQ9KyhtYWluaGVpZ2h0Ki40KSsncHgnO1xuICAgIGNvbmRpdi5zdHlsZS5mbG9hdD1cImxlZnRcIjtcbiAgICBieUlkKCdzZXR4TWlkZGxlJykuYXBwZW5kQ2hpbGQoY29uZGl2KTtcblxuICAgIGxldCBsZWdkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBsZWdkaXYuaWQ9XCJjb25mdXNpb25sZWdlbmRcIjtcbiAgICBsZWdkaXYuc3R5bGUud2lkdGg9KyhtYWlud2lkdGgqLjA3KSsncHgnO1xuICAgIGxlZ2Rpdi5zdHlsZS5tYXJnaW5MZWZ0PScyMHB4JztcbiAgICBsZWdkaXYuc3R5bGUuaGVpZ2h0PSsobWFpbmhlaWdodCouNCkrJ3B4JztcbiAgICBsZWdkaXYuc3R5bGUuZGlzcGxheT1cImlubGluZS1ibG9ja1wiO1xuICAgIGJ5SWQoJ3NldHhNaWRkbGUnKS5hcHBlbmRDaGlsZChsZWdkaXYpO1xuXG4gICAgdmFyIG1hcmdpbiA9IHt0b3A6IDIwLCByaWdodDogMTAsIGJvdHRvbTogMCwgbGVmdDogNTB9O1xuICAgIGZ1bmN0aW9uIE1hdHJpeChvcHRpb25zKSB7XG4gICAgICAgIGxldCB3aWR0aCA9IG9wdGlvbnMud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0LFxuICAgICAgICBkYXRhID0gb3B0aW9ucy5kYXRhLFxuICAgICAgICBjb250YWluZXIgPSBvcHRpb25zLmNvbnRhaW5lcixcbiAgICAgICAgbGFiZWxzRGF0YSA9IG9wdGlvbnMubGFiZWxzLFxuICAgICAgICBzdGFydENvbG9yID0gb3B0aW9ucy5zdGFydF9jb2xvcixcbiAgICAgICAgZW5kQ29sb3IgPSBvcHRpb25zLmVuZF9jb2xvcjtcblxuICAgICAgICBsZXQgd2lkdGhMZWdlbmQgPSBvcHRpb25zLndpZHRoTGVnZW5kO1xuXG4gICAgICAgIGlmKCFkYXRhKXtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHBhc3MgZGF0YScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIUFycmF5LmlzQXJyYXkoZGF0YSkgfHwgIWRhdGEubGVuZ3RoIHx8ICFBcnJheS5pc0FycmF5KGRhdGFbMF0pKXtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSXQgc2hvdWxkIGJlIGEgMi1EIGFycmF5Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbWF4VmFsdWUgPSBkMy5tYXgoZGF0YSwgZnVuY3Rpb24obGF5ZXIpIHsgcmV0dXJuIGQzLm1heChsYXllciwgZnVuY3Rpb24oZCkgeyByZXR1cm4gZDsgfSk7IH0pO1xuICAgICAgICBsZXQgbWluVmFsdWUgPSBkMy5taW4oZGF0YSwgZnVuY3Rpb24obGF5ZXIpIHsgcmV0dXJuIGQzLm1pbihsYXllciwgZnVuY3Rpb24oZCkgeyByZXR1cm4gZDsgfSk7IH0pO1xuXG4gICAgICAgIGxldCBudW1yb3dzID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGxldCBudW1jb2xzID0gZGF0YVswXS5sZW5ndGg7XG5cbiAgICAgICAgbGV0IHN2ZyA9IGQzLnNlbGVjdChjb250YWluZXIpLmFwcGVuZChcInN2Z1wiKVxuICAgICAgICAuYXR0cihcIndpZHRoXCIsIHdpZHRoICsgbWFyZ2luLmxlZnQgKyBtYXJnaW4ucmlnaHQpXG4gICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGhlaWdodCArIG1hcmdpbi50b3AgKyBtYXJnaW4uYm90dG9tKVxuICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIG1hcmdpbi5sZWZ0ICsgXCIsXCIgKyBtYXJnaW4udG9wICsgXCIpXCIpO1xuXG4gICAgICAgIGxldCBiYWNrZ3JvdW5kID0gc3ZnLmFwcGVuZChcInJlY3RcIilcbiAgICAgICAgLnN0eWxlKFwic3Ryb2tlXCIsIFwiYmxhY2tcIilcbiAgICAgICAgLnN0eWxlKFwic3Ryb2tlLXdpZHRoXCIsIFwiMnB4XCIpXG4gICAgICAgIC5hdHRyKFwid2lkdGhcIiwgd2lkdGgpXG4gICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGhlaWdodCk7XG5cbiAgICAgICAgbGV0IHggPSBkMy5zY2FsZS5vcmRpbmFsKClcbiAgICAgICAgLmRvbWFpbihkMy5yYW5nZShudW1jb2xzKSlcbiAgICAgICAgLnJhbmdlQmFuZHMoWzAsIHdpZHRoXSk7XG5cbiAgICAgICAgbGV0IHkgPSBkMy5zY2FsZS5vcmRpbmFsKClcbiAgICAgICAgLmRvbWFpbihkMy5yYW5nZShudW1yb3dzKSlcbiAgICAgICAgLnJhbmdlQmFuZHMoWzAsIGhlaWdodF0pO1xuXG4gICAgICAgIGxldCBjb2xvck1hcCA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgIC5kb21haW4oW21pblZhbHVlLG1heFZhbHVlXSlcbiAgICAgICAgLnJhbmdlKFtzdGFydENvbG9yLCBlbmRDb2xvcl0pO1xuXG4gICAgICAgIGxldCByb3cgPSBzdmcuc2VsZWN0QWxsKFwiLnJvd1wiKVxuICAgICAgICAuZGF0YShkYXRhKVxuICAgICAgICAuZW50ZXIoKS5hcHBlbmQoXCJnXCIpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJyb3dcIilcbiAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZnVuY3Rpb24oZCwgaSkgeyByZXR1cm4gXCJ0cmFuc2xhdGUoMCxcIiArIHkoaSkgKyBcIilcIjsgfSk7XG5cbiAgICAgICAgbGV0IGNlbGwgPSByb3cuc2VsZWN0QWxsKFwiLmNlbGxcIilcbiAgICAgICAgLmRhdGEoZnVuY3Rpb24oZCkgeyByZXR1cm4gZDsgfSlcbiAgICAgICAgLmVudGVyKCkuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiY2VsbFwiKVxuICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBmdW5jdGlvbihkLCBpKSB7IHJldHVybiBcInRyYW5zbGF0ZShcIiArIHgoaSkgKyBcIiwgMClcIjsgfSk7XG5cbiAgICAgICAgY2VsbC5hcHBlbmQoJ3JlY3QnKVxuICAgICAgICAuYXR0cihcIndpZHRoXCIsIHgucmFuZ2VCYW5kKCkpXG4gICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIHkucmFuZ2VCYW5kKCkpXG4gICAgICAgIC5zdHlsZShcInN0cm9rZS13aWR0aFwiLCAwKTtcblxuICAgICAgICBjZWxsLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgLmF0dHIoXCJkeVwiLCBcIi4zMmVtXCIpXG4gICAgICAgIC5hdHRyKFwieFwiLCB4LnJhbmdlQmFuZCgpIC8gMilcbiAgICAgICAgLmF0dHIoXCJ5XCIsIHkucmFuZ2VCYW5kKCkgLyAyKVxuICAgICAgICAuYXR0cihcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpXG4gICAgICAgIC5zdHlsZShcImZpbGxcIiwgZnVuY3Rpb24oZCwgaSkgeyByZXR1cm4gZCA+PSBtYXhWYWx1ZS8yID8gJ3doaXRlJyA6ICdibGFjayc7IH0pXG4gICAgICAgIC50ZXh0KGZ1bmN0aW9uKGQsIGkpIHsgcmV0dXJuIGQ7IH0pO1xuXG4gICAgICAgIHJvdy5zZWxlY3RBbGwoXCIuY2VsbFwiKVxuICAgICAgICAuZGF0YShmdW5jdGlvbihkLCBpKSB7IHJldHVybiBkYXRhW2ldOyB9KVxuICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGNvbG9yTWFwKTtcblxuICAgICAgICAvLyB0aGlzIHBvcnRpb24gb2YgdGhlIGNvZGUgaXNuJ3QgYXMgcm9idXN0IHRvIHNpemluZy4gY29sdW1uIGxhYmVscyBub3QgcmVuZGVyaW5nIGluIHRoZSByaWdodCBwbGFjZVxuICAgICAgICBsZXQgbGFiZWxzID0gc3ZnLmFwcGVuZCgnZycpXG4gICAgICAgIC5hdHRyKCdjbGFzcycsIFwibGFiZWxzXCIpO1xuXG4gICAgICAgIGxldCBjb2x1bW5MYWJlbHMgPSBsYWJlbHMuc2VsZWN0QWxsKFwiLmNvbHVtbi1sYWJlbFwiKVxuICAgICAgICAuZGF0YShsYWJlbHNEYXRhKVxuICAgICAgICAuZW50ZXIoKS5hcHBlbmQoXCJnXCIpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJjb2x1bW4tbGFiZWxcIilcbiAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgIC8vIGxldCB0ZW1wID0gXCJ0cmFuc2xhdGUoXCIgKyB4KGkpICsgXCIsXCIgKyAoaGVpZ2h0KzIwKSArIFwiKVwiOyAvLyB0aGlzIGluIHBhcnRpY3VsYXIgbG9va3MgdG8gYmUgdGhlIGNhdXNlXG4gICAgICAgICAgICAvLyAgY29uc29sZS5sb2codGVtcCk7XG4gICAgICAgICAgICAgIHJldHVybiBcInRyYW5zbGF0ZShcIiArIHgoaSkgKyBcIixcIiArIChoZWlnaHQrMzApICsgXCIpXCI7IH0pO1xuXG4gICAgICAgIGNvbHVtbkxhYmVscy5hcHBlbmQoXCJsaW5lXCIpXG4gICAgICAgIC5zdHlsZShcInN0cm9rZVwiLCBcImJsYWNrXCIpXG4gICAgICAgIC5zdHlsZShcInN0cm9rZS13aWR0aFwiLCBcIjFweFwiKVxuICAgICAgICAuYXR0cihcIngxXCIsIHgucmFuZ2VCYW5kKCkgLyAyKVxuICAgICAgICAuYXR0cihcIngyXCIsIHgucmFuZ2VCYW5kKCkgLyAyKVxuICAgICAgICAuYXR0cihcInkxXCIsIDApXG4gICAgICAgIC5hdHRyKFwieTJcIiwgNSk7XG5cbiAgICAgICAgY29sdW1uTGFiZWxzLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgLmF0dHIoXCJ4XCIsIDMwKVxuICAgICAgICAuYXR0cihcInlcIiwgeS5yYW5nZUJhbmQoKSAvIDIpXG4gICAgICAgIC5hdHRyKFwiZHlcIiwgXCIuMjJlbVwiKVxuICAgICAgICAuYXR0cihcInRleHQtYW5jaG9yXCIsIFwiZW5kXCIpXG4gICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwicm90YXRlKC02MClcIilcbiAgICAgICAgLnRleHQoZnVuY3Rpb24oZCwgaSkgeyByZXR1cm4gZDsgfSk7XG5cbiAgICAgICAgbGV0IHJvd0xhYmVscyA9IGxhYmVscy5zZWxlY3RBbGwoXCIucm93LWxhYmVsXCIpXG4gICAgICAgIC5kYXRhKGxhYmVsc0RhdGEpXG4gICAgICAgIC5lbnRlcigpLmFwcGVuZChcImdcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInJvdy1sYWJlbFwiKVxuICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBmdW5jdGlvbihkLCBpKSB7IHJldHVybiBcInRyYW5zbGF0ZShcIiArIDAgKyBcIixcIiArIHkoaSkgKyBcIilcIjsgfSk7XG5cbiAgICAgICAgcm93TGFiZWxzLmFwcGVuZChcImxpbmVcIilcbiAgICAgICAgLnN0eWxlKFwic3Ryb2tlXCIsIFwiYmxhY2tcIilcbiAgICAgICAgLnN0eWxlKFwic3Ryb2tlLXdpZHRoXCIsIFwiMXB4XCIpXG4gICAgICAgIC5hdHRyKFwieDFcIiwgMClcbiAgICAgICAgLmF0dHIoXCJ4MlwiLCAtNSlcbiAgICAgICAgLmF0dHIoXCJ5MVwiLCB5LnJhbmdlQmFuZCgpIC8gMilcbiAgICAgICAgLmF0dHIoXCJ5MlwiLCB5LnJhbmdlQmFuZCgpIC8gMik7XG5cbiAgICAgICAgcm93TGFiZWxzLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgLmF0dHIoXCJ4XCIsIC04KVxuICAgICAgICAuYXR0cihcInlcIiwgeS5yYW5nZUJhbmQoKSAvIDIpXG4gICAgICAgIC5hdHRyKFwiZHlcIiwgXCIuMzJlbVwiKVxuICAgICAgICAuYXR0cihcInRleHQtYW5jaG9yXCIsIFwiZW5kXCIpXG4gICAgICAgIC50ZXh0KGZ1bmN0aW9uKGQsIGkpIHsgcmV0dXJuIGQ7IH0pO1xuXG4gICAgICAgIGxldCBrZXkgPSBkMy5zZWxlY3QoXCIjY29uZnVzaW9ubGVnZW5kXCIpXG4gICAgICAgIC5hcHBlbmQoXCJzdmdcIilcbiAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCB3aWR0aExlZ2VuZClcbiAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgaGVpZ2h0ICsgbWFyZ2luLnRvcCArIG1hcmdpbi5ib3R0b20pO1xuXG4gICAgICAgIGxldCBsZWdlbmQgPSBrZXlcbiAgICAgICAgLmFwcGVuZChcImRlZnNcIilcbiAgICAgICAgLmFwcGVuZChcInN2ZzpsaW5lYXJHcmFkaWVudFwiKVxuICAgICAgICAuYXR0cihcImlkXCIsIFwiZ3JhZGllbnRcIilcbiAgICAgICAgLmF0dHIoXCJ4MVwiLCBcIjEwMCVcIilcbiAgICAgICAgLmF0dHIoXCJ5MVwiLCBcIjAlXCIpXG4gICAgICAgIC5hdHRyKFwieDJcIiwgXCIxMDAlXCIpXG4gICAgICAgIC5hdHRyKFwieTJcIiwgXCIxMDAlXCIpXG4gICAgICAgIC5hdHRyKFwic3ByZWFkTWV0aG9kXCIsIFwicGFkXCIpO1xuXG4gICAgICAgIGxlZ2VuZFxuICAgICAgICAuYXBwZW5kKFwic3RvcFwiKVxuICAgICAgICAuYXR0cihcIm9mZnNldFwiLCBcIjAlXCIpXG4gICAgICAgIC5hdHRyKFwic3RvcC1jb2xvclwiLCBlbmRDb2xvcilcbiAgICAgICAgLmF0dHIoXCJzdG9wLW9wYWNpdHlcIiwgMSk7XG5cbiAgICAgICAgbGVnZW5kXG4gICAgICAgIC5hcHBlbmQoXCJzdG9wXCIpXG4gICAgICAgIC5hdHRyKFwib2Zmc2V0XCIsIFwiMTAwJVwiKVxuICAgICAgICAuYXR0cihcInN0b3AtY29sb3JcIiwgc3RhcnRDb2xvcilcbiAgICAgICAgLmF0dHIoXCJzdG9wLW9wYWNpdHlcIiwgMSk7XG5cbiAgICAgICAga2V5LmFwcGVuZChcInJlY3RcIilcbiAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCB3aWR0aExlZ2VuZC8yLTEwKVxuICAgICAgICAuYXR0cihcImhlaWdodFwiLCBoZWlnaHQpXG4gICAgICAgIC5zdHlsZShcImZpbGxcIiwgXCJ1cmwoI2dyYWRpZW50KVwiKVxuICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLFwiICsgbWFyZ2luLnRvcCArIFwiKVwiKTtcblxuICAgICAgICAvLyB0aGlzIHkgaXMgZm9yIHRoZSBsZWdlbmRcbiAgICAgICAgeSA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgIC5yYW5nZShbaGVpZ2h0LCAwXSlcbiAgICAgICAgLmRvbWFpbihbbWluVmFsdWUsIG1heFZhbHVlXSk7XG5cbiAgICAgICAgbGV0IHlBeGlzID0gZDMuc3ZnLmF4aXMoKVxuICAgICAgICAuc2NhbGUoeSlcbiAgICAgICAgLm9yaWVudChcInJpZ2h0XCIpO1xuXG4gICAgICAgIGtleVxuICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJ5IGF4aXNcIilcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDQxLFwiICsgbWFyZ2luLnRvcCArIFwiKVwiKVxuICAgICAgICAgICAgLmNhbGwoeUF4aXMpO1xuICAgIH1cblxuICAgIC8vIFRoZSB0YWJsZSBnZW5lcmF0aW9uIGZ1bmN0aW9uLiBVc2VkIGZvciB0aGUgdGFibGUgb2YgcGVyZm9ybWFuY2UgbWVhc3VyZXMsIG5vdCB0aGUgY29uZnVzaW9uIG1hdHJpeFxuICAgIGZ1bmN0aW9uIHRhYnVsYXRlKGRhdGEsIGNvbHVtbnMpIHtcbiAgICAgICAgdmFyIHRhYmxlID0gZDMuc2VsZWN0KFwiI3NldHhNaWRkbGVcIikuYXBwZW5kKFwidGFibGVcIilcbiAgICAgICAgLmF0dHIoXCJzdHlsZVwiLCBcIm1hcmdpbi1sZWZ0OiBcIiArIG1hcmdpbi5sZWZ0ICtcInB4XCIpLFxuICAgICAgICB0aGVhZCA9IHRhYmxlLmFwcGVuZChcInRoZWFkXCIpLFxuICAgICAgICB0Ym9keSA9IHRhYmxlLmFwcGVuZChcInRib2R5XCIpO1xuXG4gICAgICAgIC8vIGFwcGVuZCB0aGUgaGVhZGVyIHJvd1xuICAgICAgICB0aGVhZC5hcHBlbmQoXCJ0clwiKVxuICAgICAgICAuc2VsZWN0QWxsKFwidGhcIilcbiAgICAgICAgLmRhdGEoY29sdW1ucylcbiAgICAgICAgLmVudGVyKClcbiAgICAgICAgLmFwcGVuZChcInRoXCIpXG4gICAgICAgIC50ZXh0KGZ1bmN0aW9uKGNvbHVtbikgeyByZXR1cm4gY29sdW1uOyB9KTtcblxuICAgICAgICAvLyBjcmVhdGUgYSByb3cgZm9yIGVhY2ggb2JqZWN0IGluIHRoZSBkYXRhXG4gICAgICAgIHZhciByb3dzID0gdGJvZHkuc2VsZWN0QWxsKFwidHJcIilcbiAgICAgICAgLmRhdGEoZGF0YSlcbiAgICAgICAgLmVudGVyKClcbiAgICAgICAgLmFwcGVuZChcInRyXCIpO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBhIGNlbGwgaW4gZWFjaCByb3cgZm9yIGVhY2ggY29sdW1uXG4gICAgICAgIHZhciBjZWxscyA9IHJvd3Muc2VsZWN0QWxsKFwidGRcIilcbiAgICAgICAgLmRhdGEoZnVuY3Rpb24ocm93KSB7XG4gICAgICAgICAgICAgIHJldHVybiBjb2x1bW5zLm1hcChmdW5jdGlvbihjb2x1bW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7Y29sdW1uOiBjb2x1bW4sIHZhbHVlOiByb3dbY29sdW1uXX07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgLmVudGVyKClcbiAgICAgICAgLmFwcGVuZChcInRkXCIpXG4gICAgICAgIC5hdHRyKFwic3R5bGVcIiwgXCJmb250LWZhbWlseTogQ291cmllclwiKSAvLyBzZXRzIHRoZSBmb250IHN0eWxlXG4gICAgICAgIC5odG1sKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQudmFsdWU7IH0pO1xuXG4gICAgICAgIHJldHVybiB0YWJsZTtcbiAgICB9XG5cbiAgICAvLyB0aGlzIGNvZGUgaXMgYWxsIGZvciBwcm9kdWNpbmcgYSB0YWJsZSB3aXRoIHBlcmZvcm1hbmNlIG1lYXN1cmVzXG4gICAgLy92YXIgY29uZnVzaW9uTWF0cml4ID0gW1sxNjksIDEwXSxbNywgNDZdXTtcbiAgICB2YXIgdHAgPSBtYXRyaXhkYXRhWzBdWzBdO1xuICAgIHZhciBmbiA9IG1hdHJpeGRhdGFbMF1bMV07XG4gICAgdmFyIGZwID0gbWF0cml4ZGF0YVsxXVswXTtcbiAgICB2YXIgdG4gPSBtYXRyaXhkYXRhWzFdWzFdO1xuXG4gICAgdmFyIHAgPSB0cCArIGZuO1xuICAgIHZhciBuID0gZnAgKyB0bjtcblxuICAgIHZhciBhY2N1cmFjeSA9ICh0cCt0bikvKHArbik7XG4gICAgdmFyIGYxID0gMip0cC8oMip0cCtmcCtmbik7XG4gICAgdmFyIHByZWNpc2lvbiA9IHRwLyh0cCtmcCk7XG4gICAgdmFyIHJlY2FsbCA9IHRwLyh0cCtmbik7XG5cbiAgICBhY2N1cmFjeSA9IE1hdGgucm91bmQoYWNjdXJhY3kgKiAxMDApIC8gMTAwXG4gICAgZjEgPSBNYXRoLnJvdW5kKGYxICogMTAwKSAvIDEwMFxuICAgIHByZWNpc2lvbiA9IE1hdGgucm91bmQocHJlY2lzaW9uICogMTAwKSAvIDEwMFxuICAgIHJlY2FsbCA9IE1hdGgucm91bmQocmVjYWxsICogMTAwKSAvIDEwMFxuXG4gICAgdmFyIGNvbXB1dGVkRGF0YSA9IFtdO1xuICAgIGNvbXB1dGVkRGF0YS5wdXNoKHtcIkYxXCI6ZjEsIFwiUFJFQ0lTSU9OXCI6cHJlY2lzaW9uLFwiUkVDQUxMXCI6cmVjYWxsLFwiQUNDVVJBQ1lcIjphY2N1cmFjeX0pO1xuXG4gICAgTWF0cml4KHtcbiAgICAgICAgICAgY29udGFpbmVyIDogJyNjb25mdXNpb25jb250YWluZXInLFxuICAgICAgICAgICBkYXRhICAgICAgOiBtYXRyaXhkYXRhLFxuICAgICAgICAgICBsYWJlbHMgICAgOiBjbGFzc2VzLFxuICAgICAgICAgICBzdGFydF9jb2xvciA6ICcjZmZmZmZmJyxcbiAgICAgICAgICAgZW5kX2NvbG9yIDogJyNlNjdlMjInLFxuICAgICAgICAgICB3aWR0aCA6IG1haW53aWR0aCAqIC4xNSxcbiAgICAgICAgICAgaGVpZ2h0IDogbWFpbmhlaWdodCAqIC4yNSxcbiAgICAgICAgICAgd2lkdGhMZWdlbmQgOiBtYWlud2lkdGgqLjA1XG4gICAgICAgICAgIH0pO1xuXG4gICAgLy8gbm90IHJlbmRlcmluZyB0aGlzIHRhYmxlIGZvciByaWdodCBub3csIGxlZnQgYWxsIHRoZSBjb2RlIGluIHBsYWNlIHRob3VnaC4gbWF5YmUgd2UgdXNlIGl0IGV2ZW50dWFsbHlcbiAgICAvLyB2YXIgdGFibGUgPSB0YWJ1bGF0ZShjb21wdXRlZERhdGEsIFtcIkYxXCIsIFwiUFJFQ0lTSU9OXCIsXCJSRUNBTExcIixcIkFDQ1VSQUNZXCJdKTtcbn1cblxuLyoqXG4gICBzY2F0dGVycGxvdCBmdW5jdGlvbiB0byBnbyB0byBwbG90cy5qcyB0byBiZSByZXVzZWRcbiovXG5leHBvcnQgZnVuY3Rpb24gYml2YXJpYXRlUGxvdCh4X0F4aXMsIHlfQXhpcywgeF9BeGlzX25hbWUsIHlfQXhpc19uYW1lKSB7XG4gICAgZDMuc2VsZWN0KFwiI3NldHhNaWRkbGVcIikuaHRtbChcIlwiKTtcbiAgICBkMy5zZWxlY3QoXCIjc2V0eE1pZGRsZVwiKS5zZWxlY3QoXCJzdmdcIikucmVtb3ZlKCk7XG5cbiAgICBsZXQgbWFpbndpZHRoID0gYnlJZCgnbWFpbicpLmNsaWVudFdpZHRoO1xuICAgIGxldCBtYWluaGVpZ2h0ID0gYnlJZCgnbWFpbicpLmNsaWVudEhlaWdodDtcblxuICAgIC8vIHNjYXR0ZXIgcGxvdFxuICAgIGxldCBkYXRhX3Bsb3QgPSBbXTtcbiAgICB2YXIgbmFuQ291bnQgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeF9BeGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpc05hTih4X0F4aXNbaV0pIHx8IGlzTmFOKHlfQXhpc1tpXSkpIHtcbiAgICAgICAgICAgIG5hbkNvdW50Kys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbmV3TnVtYmVyMSA9IHhfQXhpc1tpXTtcbiAgICAgICAgICAgIHZhciBuZXdOdW1iZXIyID0geV9BeGlzW2ldO1xuICAgICAgICAgICAgZGF0YV9wbG90LnB1c2goe3hheGlzOiBuZXdOdW1iZXIxLCB5YXhpczogbmV3TnVtYmVyMiwgc2NvcmU6IE1hdGgucmFuZG9tKCkgKiAxMDB9KTtcblxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICB2YXIgbWFyZ2luID0ge3RvcDogMzUsIHJpZ2h0OiAzNSwgYm90dG9tOiAzNSwgbGVmdDogMzV9XG4gICAgLCB3aWR0aCA9IG1haW53aWR0aCouMjUtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0XG4gICAgLCBoZWlnaHQgPSBtYWlud2lkdGgqLjI1IC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b207XG4gICAgdmFyIHBhZGRpbmcgPSAxMDA7XG5cbiAgICB2YXIgbWluX3ggPSBkMy5taW4oZGF0YV9wbG90LCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YV9wbG90W2ldLnhheGlzO1xuICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICB2YXIgbWF4X3ggPSBkMy5tYXgoZGF0YV9wbG90LCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YV9wbG90W2ldLnhheGlzO1xuICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICB2YXIgYXZnX3ggPSAobWF4X3ggLSBtaW5feCkgLyAxMDtcbiAgICB2YXIgbWluX3kgPSBkMy5taW4oZGF0YV9wbG90LCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YV9wbG90W2ldLnlheGlzO1xuICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICB2YXIgbWF4X3kgPSBkMy5tYXgoZGF0YV9wbG90LCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YV9wbG90W2ldLnlheGlzO1xuICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICB2YXIgYXZnX3kgPSAobWF4X3kgLSBtaW5feSkgLyAxMDtcblxuICAgIHZhciB4U2NhbGUgPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgIC5kb21haW4oW21pbl94IC0gYXZnX3gsIG1heF94ICsgYXZnX3hdKVxuICAgIC5yYW5nZShbMCwgd2lkdGhdKTtcblxuICAgIHZhciB5U2NhbGUgPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgIC5kb21haW4oW21pbl95IC0gYXZnX3ksIG1heF95ICsgYXZnX3ldKVxuICAgIC5yYW5nZShbaGVpZ2h0LCAwXSk7XG5cbiAgICB2YXIgeEF4aXMgPSBkMy5zdmcuYXhpcygpXG4gICAgLnNjYWxlKHhTY2FsZSlcbiAgICAub3JpZW50KCdib3R0b20nKVxuICAgIC50aWNrU2l6ZSgtaGVpZ2h0KTtcblxuICAgIHZhciB5QXhpcyA9IGQzLnN2Zy5heGlzKClcbiAgICAuc2NhbGUoeVNjYWxlKVxuICAgIC5vcmllbnQoJ2xlZnQnKVxuICAgIC50aWNrcyg1KVxuICAgIC50aWNrU2l6ZSgtd2lkdGgpO1xuXG4gICAgdmFyIHpvb20gPSBkMy5iZWhhdmlvci56b29tKClcbiAgICAueCh4U2NhbGUpXG4gICAgLnkoeVNjYWxlKVxuICAgIC5zY2FsZUV4dGVudChbMSwgMTBdKVxuICAgIC5vbihcInpvb21cIiwgem9vbWVkKTtcblxuICAgIHZhciBjaGFydF9zY2F0dGVyID0gZDMuc2VsZWN0KCcjc2V0eE1pZGRsZScpXG4gICAgLmFwcGVuZCgnc3ZnOnN2ZycpXG4gICAgLmF0dHIoJ3dpZHRoJywgd2lkdGggKyBtYXJnaW4ucmlnaHQgKyBtYXJnaW4ubGVmdClcbiAgICAuYXR0cignaGVpZ2h0JywgaGVpZ2h0ICsgbWFyZ2luLnRvcCArIG1hcmdpbi5ib3R0b20pO1xuICAgIC8vIC5jYWxsKHpvb20pOyBkcm9wcGluZyB0aGlzIGZvciBub3csIHVudGlsIHRoZSBsaW5lIHpvb21zIHByb3Blcmx5XG5cbiAgICB2YXIgbWFpbjEgPSBjaGFydF9zY2F0dGVyLmFwcGVuZCgnZycpXG4gICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIG1hcmdpbi5sZWZ0ICsgJywnICsgbWFyZ2luLnRvcCArICcpJylcbiAgICAuYXR0cignd2lkdGgnLCB3aWR0aCsgbWFyZ2luLnJpZ2h0ICsgbWFyZ2luLmxlZnQpXG4gICAgLmF0dHIoJ2hlaWdodCcsIGhlaWdodCArIG1hcmdpbi50b3AgKyBtYXJnaW4uYm90dG9tKVxuICAgIC5hdHRyKCdjbGFzcycsICdtYWluJyk7XG5cbiAgICBsZXQgZ1ggPSBtYWluMS5hcHBlbmQoJ2cnKVxuICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsJyArIGhlaWdodCArICcpJylcbiAgICAuYXR0cignY2xhc3MnLCAneCBheGlzJylcbiAgICAuY2FsbCh4QXhpcyk7XG5cbiAgICBsZXQgZ1kgPSBtYWluMS5hcHBlbmQoJ2cnKVxuICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsMCknKVxuICAgIC5hdHRyKCdjbGFzcycsICd5IGF4aXMnKVxuICAgIC5jYWxsKHlBeGlzKTtcblxuICAgIHZhciBjbGlwID0gbWFpbjEuYXBwZW5kKFwiZGVmc1wiKS5hcHBlbmQoXCJzdmc6Y2xpcFBhdGhcIilcbiAgICAuYXR0cihcImlkXCIsIFwiY2xpcFwiKVxuICAgIC5hcHBlbmQoXCJzdmc6cmVjdFwiKVxuICAgIC5hdHRyKFwiaWRcIiwgXCJjbGlwLXJlY3RcIilcbiAgICAuYXR0cihcInhcIiwgXCIwXCIpXG4gICAgLmF0dHIoXCJ5XCIsIFwiMFwiKVxuICAgIC5hdHRyKCd3aWR0aCcsIHdpZHRoKVxuICAgIC5hdHRyKCdoZWlnaHQnLCBoZWlnaHQpO1xuXG4gICAgbWFpbjEuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xpcC1wYXRoXCIsIFwidXJsKCNjbGlwKVwiKVxuICAgIC5zZWxlY3RBbGwoXCJjaXJjbGVcIilcbiAgICAuZGF0YShkYXRhX3Bsb3QpXG4gICAgLmVudGVyKClcbiAgICAuYXBwZW5kKFwiY2lyY2xlXCIpXG4gICAgLmF0dHIoXCJjeFwiLCAoZCwgaSkgPT4geFNjYWxlKGRhdGFfcGxvdFtpXS54YXhpcykpXG4gICAgLmF0dHIoXCJjeVwiLCAoZCwgaSkgPT4geVNjYWxlKGRhdGFfcGxvdFtpXS55YXhpcykpXG4gICAgLmF0dHIoXCJyXCIsIDIpXG4gICAgLnN0eWxlKFwiZmlsbFwiLCBcIiNCNzFDMUNcIik7XG5cblxuICAgIGNoYXJ0X3NjYXR0ZXIuYXBwZW5kKFwidGV4dFwiKVxuICAgIC5hdHRyKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIikgIC8vIHRoaXMgbWFrZXMgaXQgZWFzeSB0byBjZW50cmUgdGhlIHRleHQgYXMgdGhlIHRyYW5zZm9ybSBpcyBhcHBsaWVkIHRvIHRoZSBhbmNob3JcbiAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIHBhZGRpbmcgLyA1ICsgXCIsXCIgKyAoaGVpZ2h0IC8gMikgKyBcIilyb3RhdGUoLTkwKVwiKSAgLy8gdGV4dCBpcyBkcmF3biBvZmYgdGhlIHNjcmVlbiB0b3AgbGVmdCwgbW92ZSBkb3duIGFuZCBvdXQgYW5kIHJvdGF0ZVxuICAgIC50ZXh0KHlfQXhpc19uYW1lKVxuICAgIC5zdHlsZShcImZpbGxcIiwgXCIjNDI0MjQyXCIpXG4gICAgLnN0eWxlKFwidGV4dC1pbmRlbnRcIixcIjIwcHhcIilcbiAgICAuc3R5bGUoXCJmb250LXNpemVcIixcIjEycHhcIilcbiAgICAuc3R5bGUoXCJmb250LXdlaWdodFwiLFwiYm9sZFwiKTtcblxuICAgIGNoYXJ0X3NjYXR0ZXIuYXBwZW5kKFwidGV4dFwiKVxuICAgIC5hdHRyKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIikgIC8vIHRoaXMgbWFrZXMgaXQgZWFzeSB0byBjZW50cmUgdGhlIHRleHQgYXMgdGhlIHRyYW5zZm9ybSBpcyBhcHBsaWVkIHRvIHRoZSBhbmNob3JcbiAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArICh3aWR0aCAvIDIpICsgXCIsXCIgKyAoaGVpZ2h0ICsgKHBhZGRpbmcgLyAyKSkgKyBcIilcIikgIC8vIGNlbnRyZSBiZWxvdyBheGlzXG4gICAgLnRleHQoeF9BeGlzX25hbWUpXG4gICAgLnN0eWxlKFwiZmlsbFwiLCBcIiM0MjQyNDJcIilcbiAgICAuc3R5bGUoXCJ0ZXh0LWluZGVudFwiLFwiMjBweFwiKVxuICAgIC5zdHlsZShcImZvbnQtc2l6ZVwiLFwiMTJweFwiKVxuICAgIC5zdHlsZShcImZvbnQtd2VpZ2h0XCIsXCJib2xkXCIpO1xuXG5cbiAgICBtYWluMS5hcHBlbmQoXCJsaW5lXCIpXG4gICAgLmF0dHIoXCJ4MVwiLCB4U2NhbGUobWluX3gpKVxuICAgIC5hdHRyKFwieTFcIiwgeVNjYWxlKG1pbl94KSlcbiAgICAuYXR0cihcIngyXCIsIHhTY2FsZShtYXhfeCkpXG4gICAgLmF0dHIoXCJ5MlwiLCB5U2NhbGUobWF4X3gpKVxuICAgIC5hdHRyKFwic3Ryb2tlLXdpZHRoXCIsIDIpXG4gICAgLmF0dHIoXCJzdHJva2VcIiwgXCJibGFja1wiKTtcblxuICAgIGZ1bmN0aW9uIHpvb21lZCgpIHtcbiAgICAgICAgdmFyIHBhblggPSBkMy5ldmVudC50cmFuc2xhdGVbMF07XG4gICAgICAgIHZhciBwYW5ZID0gZDMuZXZlbnQudHJhbnNsYXRlWzFdO1xuICAgICAgICB2YXIgc2NhbGUgPSBkMy5ldmVudC5zY2FsZTtcblxuICAgICAgICBwYW5YID0gcGFuWCA+IDEwID8gMTAgOiBwYW5YO1xuICAgICAgICB2YXIgbWF4WCA9IC0oc2NhbGUgLSAxKSAqIHdpZHRoIC0gMTA7XG4gICAgICAgIHBhblggPSBwYW5YIDwgbWF4WCA/IG1heFggOiBwYW5YO1xuXG4gICAgICAgIHBhblkgPSBwYW5ZID4gMTAgPyAxMCA6IHBhblk7XG4gICAgICAgIHZhciBtYXhZID0gLShzY2FsZSAtIDEpICogaGVpZ2h0IC0gMTA7XG4gICAgICAgIHBhblkgPSBwYW5ZIDwgbWF4WSA/IG1heFkgOiBwYW5ZO1xuXG4gICAgICAgIHpvb20udHJhbnNsYXRlKFtwYW5YLCBwYW5ZXSk7XG5cblxuICAgICAgICBtYWluMS5zZWxlY3QoXCIueC5heGlzXCIpLmNhbGwoeEF4aXMpO1xuICAgICAgICBtYWluMS5zZWxlY3QoXCIueS5heGlzXCIpLmNhbGwoeUF4aXMpO1xuICAgICAgICBtYWluMS5zZWxlY3RBbGwoXCJjaXJjbGVcIilcbiAgICAgICAgLmF0dHIoXCJjeFwiLCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImNpcmNsZSB4IFwiLHhTY2FsZSg1KSk7XG4gICAgICAgICAgICAgIHJldHVybiB4U2NhbGUoZGF0YV9wbG90W2ldLnhheGlzKTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoXCJjeVwiLCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgICByZXR1cm4geVNjYWxlKGRhdGFfcGxvdFtpXS55YXhpcyk7XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgIC5hdHRyKFwiclwiLCAyLjUpXG4gICAgICAgIC5zdHlsZShcImZpbGxcIiwgXCIjQjcxQzFDXCIpO1xuXG4gICAgICAgLy8gYmVsb3cgZG9lc24ndCB3b3JrLCBzbyBJJ20ganVzdCBkcm9wcGluZyB0aGUgem9vbVxuICAgICAgICBtYWluMS5zZWxlY3QoXCJsaW5lXCIpXG4gICAgICAgIC5hdHRyKFwieDFcIiwgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgICByZXR1cm4geFNjYWxlKG1pbl94KTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoXCJ5MVwiLCBmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB4U2NhbGUobWluX3gpO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAuYXR0cihcIngyXCIsIGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHhTY2FsZShtYXhfeCk7XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgIC5hdHRyKFwieTJcIiwgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgICByZXR1cm4geVNjYWxlKG1heF94KTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoXCJzdHJva2Utd2lkdGhcIiwgMilcbiAgICAgICAgLmF0dHIoXCJzdHJva2VcIiwgXCJibGFja1wiKTtcbiAgICB9XG4gICAgLy8gIGQzLnNlbGVjdChcIiNOQWNvdW50XCIpLnRleHQoXCJUaGVyZSBhcmUgXCIgKyBuYW5Db3VudCArIFwiIG51bWJlciBvZiBOQSB2YWx1ZXMgaW4gdGhlIHJlbGF0aW9uLlwiKTtcbn1cblxuLyoqIG5lZWRzIGRvYyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldHhUYWJsZShmZWF0dXJlcykge1xuICAgIGZ1bmN0aW9uIHRhYnVsYXRlKGRhdGEsIGNvbHVtbnMpIHtcbiAgICAgICAgdmFyIHRhYmxlID0gZDMuc2VsZWN0KCcjc2V0eFJpZ2h0Qm90dG9tTGVmdCcpLmFwcGVuZCgndGFibGUnKTtcbiAgICAgICAgdmFyIHRoZWFkID0gdGFibGUuYXBwZW5kKCd0aGVhZCcpO1xuICAgICAgICB2YXJcdHRib2R5ID0gdGFibGUuYXBwZW5kKCd0Ym9keScpO1xuXG4gICAgICAgIC8vIGFwcGVuZCB0aGUgaGVhZGVyIHJvd1xuICAgICAgICB0aGVhZC5hcHBlbmQoJ3RyJylcbiAgICAgICAgLnNlbGVjdEFsbCgndGgnKVxuICAgICAgICAuZGF0YShjb2x1bW5zKS5lbnRlcigpXG4gICAgICAgIC5hcHBlbmQoJ3RoJylcbiAgICAgICAgLnRleHQoZnVuY3Rpb24gKGNvbHVtbikgeyByZXR1cm4gY29sdW1uOyB9KTtcblxuICAgICAgICAvLyBjcmVhdGUgYSByb3cgZm9yIGVhY2ggb2JqZWN0IGluIHRoZSBkYXRhXG4gICAgICAgIHZhciByb3dzID0gdGJvZHkuc2VsZWN0QWxsKCd0cicpXG4gICAgICAgIC5kYXRhKGRhdGEpXG4gICAgICAgIC5lbnRlcigpXG4gICAgICAgIC5hcHBlbmQoJ3RyJyk7XG5cbiAgICAgICAgLy8gY3JlYXRlIGEgY2VsbCBpbiBlYWNoIHJvdyBmb3IgZWFjaCBjb2x1bW5cbiAgICAgICAgdmFyIGNlbGxzID0gcm93cy5zZWxlY3RBbGwoJ3RkJylcbiAgICAgICAgICAgIC5kYXRhKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sdW1ucy5tYXAoZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge2NvbHVtbjogY29sdW1uLCB2YWx1ZTogcm93W2NvbHVtbl19O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAuYXBwZW5kKCd0ZCcpXG4gICAgICAgICAgICAudGV4dChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC52YWx1ZTsgfSlcbiAgICAgICAgICAgIC5hdHRyKCdpZCcsZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJvd25hbWUgPSB0aGlzLnBhcmVudEVsZW1lbnQuZmlyc3RDaGlsZC5pbm5lclRleHQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJvd25hbWUgKyBkLmNvbHVtbjtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0YWJsZTtcbiAgICB9XG5cblxuICAgIGxldCBteWRhdGEgPSBbXTtcbiAgICBmb3IobGV0IGkgPSAwOyBpPGZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmKGFsbE5vZGVzW2ZpbmROb2RlSW5kZXgoZmVhdHVyZXNbaV0pXS52YWxpZD09MCkge1xuICAgICAgICAgICAgeHZhbD0wO1xuICAgICAgICAgICAgeDF2YWw9MDtcbiAgICAgICAgICAgIG15ZGF0YS5wdXNoKHtcIlZhcmlhYmxlc1wiOmZlYXR1cmVzW2ldLFwiRnJvbVwiOnh2YWwsIFwiVG9cIjp4MXZhbH0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbXlpID0gaSsxO1xuICAgICAgICBsZXQgbXlzdmcgPSBmZWF0dXJlc1tpXStcIl9zZXR4TGVmdF9cIitteWk7XG4gICAgICAgIGxldCB4dmFsID0gYnlJZChteXN2ZykucXVlcnlTZWxlY3RvcignLnh2YWwnKS5pbm5lckhUTUw7XG4gICAgICAgIGxldCB4MXZhbCA9IGJ5SWQobXlzdmcpLnF1ZXJ5U2VsZWN0b3IoJy54MXZhbCcpLmlubmVySFRNTDtcbiAgICAgICAgeHZhbCA9IHh2YWwuc3BsaXQoXCJ4OiBcIikucG9wKCk7XG4gICAgICAgIHgxdmFsID0geDF2YWwuc3BsaXQoXCJ4MTogXCIpLnBvcCgpO1xuICAgICAgICBjb25zb2xlLmxvZyh4dmFsKTtcbiAgICAgICAgY29uc29sZS5sb2cobXlzdmcpO1xuXG4gICAgICAgIG15ZGF0YS5wdXNoKHtcIlZhcmlhYmxlc1wiOmZlYXR1cmVzW2ldLFwiRnJvbVwiOnh2YWwsIFwiVG9cIjp4MXZhbH0pO1xuICAgIH1cblxuICAgIC8vIHJlbmRlciB0aGUgdGFibGUocylcbiAgICB0YWJ1bGF0ZShteWRhdGEsIFsnVmFyaWFibGVzJywgJ0Zyb20nLCAnVG8nXSk7IC8vIDIgY29sdW1uIHRhYmxlXG59XG5cbi8qKlxuICBycGMgRXhwb3J0UGlwZWxpbmUoUGlwZWxpbmVFeHBvcnRSZXF1ZXN0KSByZXR1cm5zIChSZXNwb25zZSkge31cbiovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZXhwb3J0cGlwZWxpbmUocGlwZWxpbmVJZCkge1xuICAgIGNvbnNvbGUubG9nKHBpcGVsaW5lSWQpO1xuICAgIGxldCByZXMgPSBhd2FpdCBtYWtlUmVxdWVzdChcbiAgICAgICAgRDNNX1NWQ19VUkwgKyAnZXhwb3J0cGlwZWxpbmUnLFxuICAgICAgICB7cGlwZWxpbmVJZCwgY29udGV4dDogYXBpU2Vzc2lvbih6cGFyYW1zLnpzZXNzaW9uaWQpLCBwaXBlbGluZUV4ZWNVcmk6ICc8PEVYRUNVVEFCTEVfVVJJPj4nfSk7XG4gICAgcmVzICYmIGNvbnNvbGUubG9nKGBFeGVjdXRhYmxlIGZvciAke3BpcGVsaW5lSWR9IGhhcyBiZWVuIHdyaXR0ZW5gKTtcbn1cblxuLyoqIG5lZWRzIGRvYyAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlbGV0ZXBpcGVsaW5lKCkge1xuICAgIGNvbnNvbGUubG9nKFwiREVMRVRFIENBTExFRFwiKTtcbn1cblxuLyoqXG4gICBEM00gQVBJIEhFTFBFUlNcbiAgIGJlY2F1c2UgdGhlc2UgZ2V0IGJ1aWx0IGluIHZhcmlvdXMgcGxhY2VzLCBwdWxsaW5nIHRoZW0gb3V0IGZvciBlYXN5IG1hbmlwdWxhdGlvblxuKi9cbmZ1bmN0aW9uIGFwaUZlYXR1cmUgKHZhcnMsIHVyaSkge1xuICAgIGxldCBvdXQgPSBbXTtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgdmFycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBvdXQucHVzaCh7ZmVhdHVyZUlkOnZhcnNbaV0sZGF0YVVyaTp1cml9KTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqIG5lZWRzIGRvYyAqL1xuZnVuY3Rpb24gYXBpRmVhdHVyZVNob3J0UGF0aCAodmFycywgdXJpKSB7XG4gICAgbGV0IG91dCA9IFtdO1xuICAgIGxldCBzaG9ydFVyaSA9IHVyaS5zdWJzdHJpbmcoMCwgdXJpLmxhc3RJbmRleE9mKFwiL1wiKSk7XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IHZhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgb3V0LnB1c2goe2ZlYXR1cmVJZDp2YXJzW2ldLGRhdGFVcmk6c2hvcnRVcml9KTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gICBzaWxseSBidXQgcGVyaGFwcyB1c2VmdWwgaWYgaW4gdGhlIGZ1dHVyZSBTZXNzaW9uQ29udGV4dCByZXF1aXJlcyBtb3JlIHRoaW5ncyAoYXMgc3VnZ2VzdCBieSBjb3JlKVxuKi9cbmZ1bmN0aW9uIGFwaVNlc3Npb24oY29udGV4dCkge1xuICAgIHJldHVybiB7c2Vzc2lvbl9pZDogY29udGV4dH07XG59XG5cblxuLyoqXG4gKiAgU2VuZCBhIHN0YXR1cyBtZXNzYWdlIHRvIHRoZSBUQTMgY29uc29sZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdGEzX3NlYXJjaF9tZXNzYWdlKHVzZXJfbXNnKXtcblxuICBsZXQgdGEzX3NlYXJjaF9tZXNzYWdlID0geydtZXNzYWdlJzogdXNlcl9tc2d9XG5cbiAgY29uc3QgZW5kX3NlYXJjaF91cmwgPSAndGEzLXNlYXJjaC9zZW5kLXJldmlld2VyLW1lc3NhZ2UnO1xuXG4gIHRyeSB7XG4gICAgICBsZXQgcmVzID0gbS5yZXF1ZXN0KGVuZF9zZWFyY2hfdXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB7bWV0aG9kOiAnUE9TVCcsIGRhdGE6IHRhM19zZWFyY2hfbWVzc2FnZX0pO1xuICAgICAgY29uc29sZS5sb2coJ3RhM19zZWFyY2hfbWVzc2FnZSBzdWNjZWVkZWQ6JyArIHJlcyk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5sb2coJ3RhM19zZWFyY2hfbWVzc2FnZSBmYWlsZWQ6ICcgKyBlcnIpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0ZXN0X21zZ190YTNfc2VhcmNoKCl7XG4gIC8vZW5kX3RhM19zZWFyY2godHJ1ZSwgJ2l0IHdvcmtlZCEnKTtcbiAgLy9lbmRfdGEzX3NlYXJjaChmYWxzZSwgJ2l0IGZhaWxlZCEnKTtcbiAgLy90YTNfc2VhcmNoX21lc3NhZ2UoJ2p1c3Qgc2VuZGluZyBhIG1lc3NhZ2UhJyk7XG59XG5cbi8qKlxuICogIEVuZCB0aGUgVEEzIHNlYXJjaC4gIFRoaXMgc2VuZHMgYSBtZXNzYWdlXG4gKiAgdG8gdGhlIHRhM19zZWFyY2ggY29uc29sZSBhcyB3ZWxsIGFzIG1lc3NhZ2VcbiAqICBmb3IgdGhlIGNvbnNvbGUgdG8gZXhpdCB3aXRoIGE6XG4gKiAgLSByZXR1cm4gY29kZSAwIGZvciBzdWNjZXNzXG4gKiAgLSByZXR1cm4gY29kZSAtMSBmb3IgZmFpbHVyZVxuICpcbiAqICA+IGlzX3N1Y2Nlc3MgLSBib29sZWFuXG4gKiAgPiB1c2VyX21zZyAtIHN0cmluZyBzZW50IHRvIHRoZSBjb25zb2xlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmRfdGEzX3NlYXJjaChpc19zdWNjZXNzLCB1c2VyX21zZyl7XG5cbiAgbGV0IGVuZF9zZWFyY2hfbXNnID0geydpc19zdWNjZXNzJzogaXNfc3VjY2VzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtZXNzYWdlJzogdXNlcl9tc2d9XG5cbiAgY29uc3QgZW5kX3NlYXJjaF91cmwgPSAndGEzLXNlYXJjaC9lbmQtc2VhcmNoJztcblxuICB0cnkge1xuICAgICAgbGV0IHJlcyA9IG0ucmVxdWVzdChlbmRfc2VhcmNoX3VybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAge21ldGhvZDogJ1BPU1QnLCBkYXRhOiBlbmRfc2VhcmNoX21zZ30pO1xuICAgICAgY29uc29sZS5sb2coJ2VuZF90YTNfc2VhcmNoIHN1Y2NlZWRlZDonICsgcmVzKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmxvZygnZW5kX3RhM19zZWFyY2ggZmFpbGVkOiAnICsgZXJyKTtcbiAgfVxuXG59XG5cbi8qKlxuICogIHJlY29yZCB1c2VyIG1ldGFkYXRhXG4gKi9cbmxldCByZWNvcmRlcl9jbnQgPSAwO1xuY29uc3Qgc2F2ZV93b3Jrc3BhY2VfdXJsID0gJy93b3Jrc3BhY2VzL3JlY29yZC11c2VyLXdvcmtzcGFjZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiByZWNvcmRfdXNlcl9tZXRhZGF0YSgpe1xuXG4gIC8vICgxKSBTZXQgZG9tYWluIGlkZW50aWZpZXI6IGRpZmZlcnMgZm9yIEQzTSwgRGF0YXZlcnNlLCBldGNcbiAgLy9cbiAgdmFyIGRvbWFpbl9pZGVudGlmaWVyID0gJ3Vua25vd24hJztcbiAgaWYgKElTX0QzTV9ET01BSU4peyAvLyBkb21haW4gc3BlY2lmaWMgaWRlbnRpZmllclxuICAgIGRvbWFpbl9pZGVudGlmaWVyID0gZG9tYWluSWRlbnRpZmllcjtcbiAgfS8qZWxzZSBpZiAoSVNfREFUQVZFUlNFX0RPTUFJTil7XG4gICAgZG9tYWluX2lkZW50aWZpZXIgPSAnVE9ETzogRFYgSURFTlRJRklFUic7XG4gIH1lbHNlIGlmIChJU19FVkVOVERBVEFfRE9NQUlOKXtcbiAgICBkb21haW5faWRlbnRpZmllciA9ICdUT0RPOiBFVkVOVERBVEEgSURFTlRJRklFUic7XG4gIH0qL1xuXG4gIGlmICh6cGFyYW1zID09IG51bGwpe1xuICAgIGNvbnNvbGUubG9nKCdObyB3b3Jrc3BhY2UgcmVjb3JkaW5nLiB6cGFyYW1zIG5vdCBkZWZpbmVkJyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChhbGxOb2RlcyA9PSBudWxsKXtcbiAgICBjb25zb2xlLmxvZygnTm8gd29ya3NwYWNlIHJlY29yZGluZy4genBhcmFtcyBub3QgZGVmaW5lZCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vICgyKSBGb3JtYXQgd29ya3NwYWNlIGRhdGFcbiAgLy9cbiAgbGV0IHdvcmtzcGFjZV9kYXRhID0geydhcHBfZG9tYWluJzogQVBQX0RPTUFJTixcbiAgICAgICAgICAgICAgICAgICAgICAgICdkb21haW5faWRlbnRpZmllcic6IGRvbWFpbl9pZGVudGlmaWVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2FsbG5vZGVzJzogYWxsTm9kZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAnenBhcmFtcyc6IHpwYXJhbXN9XG5cbiAgICAgICAgLy9jb25zb2xlLmxvZygnd29ya3NwYWNlX2RhdGE6ICcgKyB3b3Jrc3BhY2VfZGF0YSk7XG5cbiAgICAgIC8vICgzKSBTYXZlIHdvcmtzcGFjZSBkYXRhXG4gICAgICAvL1xuICAgICAgdHJ5IHtcbiAgICAgICAgICBsZXQgcmVzID0gbS5yZXF1ZXN0KHNhdmVfd29ya3NwYWNlX3VybCwge21ldGhvZDogJ1BPU1QnLCBkYXRhOiB3b3Jrc3BhY2VfZGF0YX0pO1xuICAgICAgICAgIHJlY29yZGVyX2NudCsrO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdTZXNzaW9uIHJlY29yZGVkOiAoY250OiAnICsgcmVjb3JkZXJfY250ICsgJykgJyArIHJlcyk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygncmVjb3JkX3VzZXJfbWV0YWRhdGEgZmFpbGVkOiAnICsgZXJyKTtcbiAgICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Fzc2V0cy9hcHAvYXBwLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1\n')},function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();\n\nexports.density = density;\nexports.bars = bars;\nexports.barsSubset = barsSubset;\nexports.densityNode = densityNode;\nexports.barsNode = barsNode;\nvar d3Color = \'#1f77b4\'; // d3\'s default blue\nvar selVarColor = exports.selVarColor = \'#fa8072\'; // d3.rgb("salmon");\n\n// function to use d3 to graph density plots with preprocessed data\nfunction density(node, div, priv) {\n    div = { subset: \'#tab2\', setxLeft: \'#setxLeft\', varSummary: \'#tab3\' }[div];\n    if (!div) return alert("Error: incorrect div selected for plots");\n\n    var _ref = [node.plotx, node.ploty],\n        xVals = _ref[0],\n        yVals = _ref[1];\n\n    if (priv && node.plotCI) {\n        var _map = [\'upperBound\', \'lowerBound\'].map(function (bound) {\n            return xVals.map(function (x, i) {\n                return { x: +x, y: +node.plotCI[bound][i] };\n            });\n        }),\n            _map2 = _slicedToArray(_map, 2),\n            _upperError = _map2[0],\n            _lowerError = _map2[1];\n\n        console.log(\'upperError\\n\', _upperError);\n    }\n\n    var tempWidth = d3.select(div).style("width");\n    var width = tempWidth.substring(0, tempWidth.length - 2);\n\n    var tw = document.getElementById(\'main\').offsetWidth;\n\n    var tempHeight = d3.select(div).style("height");\n    var height = tempHeight.substring(0, tempHeight.length - 2);\n    var margin = {\n        top: 20,\n        right: 20,\n        bottom: 53,\n        left: 10\n    };\n\n    // Need to fix automatic width and height settings for leftpanel (#tab2, #tab3)\n    if (div == "#tab3") {\n        width = 0.7 * (width - margin.left - margin.right), height = 0.3 * (height - margin.top - margin.bottom);\n    } else if (div == "#tab2") {\n        width = 200;\n        height = 120;\n    } else if (div == "#setxLeft") {\n        width = tw * .185 - margin.left - margin.right; //rightpanel.expand is 40 percent, setxLeft to 50 percent, toggle bar is 16px, padding, it\'s all about .185\n        height = width * .6; //height to width is .6\n    } else {\n        width = 0.35 * (width - margin.left - margin.right), height = 0.25 * (height - margin.top - margin.bottom);\n    };\n\n    var x = d3.scale.linear().domain([d3.min(xVals), d3.max(xVals)]).range([0, width]);\n    var invx = d3.scale.linear().range([d3.min(xVals), d3.max(xVals)]).domain([0, width]);\n    var y = d3.scale.linear().domain([d3.min(yVals), d3.max(yVals)]).range([height, 0]);\n    var xAxis = d3.svg.axis().scale(x).ticks(5).orient("bottom");\n    var yAxis = d3.svg.axis().scale(y).orient("left");\n    var brush = d3.svg.brush().x(x).extent(node.subsetrange).on("brush", brushed);\n    var brush2 = d3.svg.brush().x(x).on("brush", brushed2);\n    var area = d3.svg.area().interpolate("monotone").x(function (d) {\n        return x(d.x);\n    }).y0(height).y1(function (d) {\n        return y(d.y);\n    });\n    var line = d3.svg.line().x(function (d) {\n        return x(d.x);\n    }).y(function (d) {\n        return y(d.y);\n    }).interpolate("monotone");\n\n    // cumbersome to treat "tab3" differently, but works for now\n    // tab3, has an issue, that unless width height hardcoded, they grow with each additional graph.\n    if (div == "#tab3") {\n        var plotsvg = d3.select(div).selectAll("svg").remove();\n        plotsvg = d3.select(div).append("svg").attr("id", function () {\n            return node.name.toString().concat(div.substr(1));\n        }).style("width", 300) // set height to the height of #main.left\n        .style("height", 200).append("g").attr("transform", \'translate(\' + margin.left + \',\' + margin.top + \')\');\n    } else {\n        var plotsvg = d3.select(div).append("svg").attr("id", function () {\n            return node.name.toString().replace(/\\(|\\)/g, "").concat("_", div.substr(1), "_", node.id);\n        }).style("width", width + margin.left + margin.right) //setting height to the height of #main.left\n        .style("height", height + margin.top + margin.bottom).append("g").attr("transform", \'translate(\' + margin.left + \',\' + margin.top + \')\');\n    };\n    plotsvg.append("path").datum(xVals.map(function (x, i) {\n        return { x: +x, y: +node.ploty[i] };\n    })).attr("class", "area").attr("d", area);\n\n    //add upper bound\n    priv && node.plotCI && plotsvg.append("path").attr("class", "upperError").datum(upperError).attr("d", area);\n\n    //add lower bound\n    priv && node.plotCI && plotsvg.append("path").attr("class", "lowerError").datum(lowerError).attr("d", area);\n\n    plotsvg.append("g").attr("class", "x axis").attr("transform", "translate(0," + height + ")").call(xAxis);\n\n    plotsvg.append("text").attr("x", width / 2).attr("y", 0 - margin.top / 2).attr("text-anchor", "middle").style("font-size", "12px").text(node.name);\n\n    // add brush if subset\n    if (div == "#tab2") {\n        plotsvg.append("text").attr("id", "range").attr("x", 25).attr("y", height + 40).text(function () {\n            return "Range: ".concat(d3.min(xVals).toPrecision(4), " to ", d3.max(xVals).toPrecision(4));\n        });\n        plotsvg.append("g").attr("class", "x brush").call(brush).selectAll("rect").attr("height", height);\n    }\n\n    // add z lines and sliders setx\n    if (div == "#setxLeft") {\n        plotsvg.append("text").attr("id", "range") // this is bad practice, id is not unique\n        .attr(\'class\', \'xval\').attr("x", 25).attr("y", height + 40).text(function () {\n            return "x: ".concat((+node.mean).toPrecision(4));\n        });\n\n        plotsvg.append("text").attr("id", "range2") // this is bad practice, id is not unique\n        .attr(\'class\', \'x1val\').attr("x", 25).attr("y", height + 50).text(function (_) {\n            var returnval = "x1: ".concat((+node.mean).toPrecision(4));\n            return returnval;\n        });\n\n        // create tick marks at all zscores in the bounds of the data\n        var lineFunction = d3.svg.line().x(function (d) {\n            return d.x;\n        }).y(function (d) {\n            return d.y;\n        }).interpolate("linear");\n\n        var colSeq = ["#A2CD5A", "orange", "red"]; // will cycle through color sequence, and then repeat last color\n        var lineData = new Array();\n\n        var zLower = -1 * (d3.min(xVals) - node.mean) / node.sd; // zscore of lower bound\n        var zUpper = (d3.max(xVals) - node.mean) / node.sd; // zscore of upper bound\n\n        for (var i = 0; i < zUpper; i++) {\n            lineData = [{\n                "x": x(+node.mean + i * node.sd),\n                "y": height * .7\n            }, {\n                "x": x(+node.mean + i * node.sd),\n                "y": height * .9\n            }];\n            plotsvg.append("path").attr("d", lineFunction([lineData[0], lineData[1]])).attr("stroke", colSeq[d3.min([i, colSeq.length - 1])]).attr("stroke-width", 1.5).attr("fill", "none");\n        }\n\n        for (var i = 1; i < zLower; i++) {\n            lineData = [{\n                "x": x(+node.mean - i * node.sd),\n                "y": height * .7\n            }, {\n                "x": x(+node.mean - i * node.sd),\n                "y": height * .9\n            }];\n            plotsvg.append("path").attr("d", lineFunction([lineData[0], lineData[1]])).attr("stroke", colSeq[d3.min([i, colSeq.length - 1])]).attr("stroke-width", 1.5).attr("fill", "none");\n        }\n\n        // initialize slider components\n        var slideBox = plotsvg.append("g").attr("class", "x axis").attr("transform", "translate(0," + height * .8 + ")").call(d3.svg.axis().scale(x).ticks(0).orient("bottom"));\n        var slider = plotsvg.append("g").attr("class", "slider").call(brush);\n        var handle = slider.append("polygon").attr("class", "handle").attr("transform", "translate(0," + height * .7 + ")").attr("points", function (_) {\n            var s = 6;\n            var xnm = node.setxvals[0] == \'\' ? x(node.mean) : x(node.setxvals[0]);\n            return xnm - s + "," + -s + " " + (xnm + s) + "," + -s + " " + xnm + "," + s * 1.3;\n        });\n        var slider2 = plotsvg.append("g").attr("class", "slider").call(brush2);\n        var handle2 = slider2.append("polygon").attr("class", "handle").attr("transform", "translate(0," + height * .9 + ")").attr("points", function (_) {\n            var s = 6;\n            var xnm = node.setxvals[1] == \'\' ? x(node.mean) : x(node.setxvals[1]);\n            return xnm - s + "," + s + " " + (xnm + s) + "," + s + " " + xnm + "," + -s * 1.3;\n        });\n    }\n\n    // brushing functions\n    function brushed() {\n        if (div == "#tab2") {\n            plotsvg.select("text#range").text(function () {\n                return brush.empty() ? "Range: ".concat(d3.min(xVals).toPrecision(4), " to ", d3.max(xVals).toPrecision(4)) : "Range: ".concat(brush.extent()[0].toPrecision(4), " to ", brush.extent()[1].toPrecision(4));\n            });\n            node.subsetrange = brush.extent()[0].toPrecision(4) != brush.extent()[1].toPrecision(4) ? [brush.extent()[0].toPrecision(4), brush.extent()[1].toPrecision(4)] : ["", ""];\n        } else if (div == "#setxLeft") {\n            var value = brush.extent()[0];\n            var s = 6;\n            if (d3.event.sourceEvent) {\n                value = x.invert(d3.mouse(this)[0]);\n                brush.extent([value, value]);\n            }\n\n            // set x position of slider center\n            var xpos = x(value);\n            if (value > d3.max(xVals)) {\n                // dragged past max\n                xpos = x(d3.max(xVals));\n            } else if (value < d3.min(xVals)) {\n                // dragged past min\n                xpos = x(d3.min(xVals));\n            } else {\n                var m = +node.mean;\n                var sd = +node.sd;\n                var zScore = (value - m) / sd; // z-score\n                var zRound = Math.round(zScore); // nearest integer z-score\n                if (.1 > Math.abs(zRound - zScore)) // snap to integer z-score\n                    xpos = x(m + zRound * sd);\n            }\n\n            // create slider symbol and text\n            handle.attr("points", function (_) {\n                return xpos - s + "," + -s + " " + (xpos + s) + "," + -s + " " + xpos + "," + s * 1.3;\n            });\n            plotsvg.select("text#range").text(function (_) {\n                var returnval = "x: ".concat(invx(xpos).toPrecision(4));\n                var xval = invx(xpos).toPrecision(4);\n                var mycell = node.name + "From"; // hardcoded here\n                if (document.getElementById(mycell)) {\n                    document.getElementById(mycell).innerText = xval;\n                }\n                return returnval;\n            });\n            node.setxvals[0] = invx(xpos).toPrecision(4);\n        }\n    }\n\n    // certainly a more clever way to do this, but for now it\'s basically copied with brush and handle changes to brush2 and handle2 and #range to #range2 and setxvals[0] to setxvals[1]\n    function brushed2() {\n        var value = brush2.extent()[0];\n        var s = 6; // scaling for triangle shape\n\n        if (d3.event.sourceEvent) {\n            value = x.invert(d3.mouse(this)[0]);\n            brush2.extent([value, value]);\n        }\n\n        // set x position of slider center\n        var xpos = x(value);\n        if (value > d3.max(xVals)) {\n            // dragged past max\n            xpos = x(d3.max(xVals));\n        } else if (value < d3.min(xVals)) {\n            // dragged past min\n            xpos = x(d3.min(xVals));\n        } else {\n            var m = +node.mean;\n            var sd = +node.sd;\n            var zScore = (value - m) / sd; // z-score\n            var zRound = Math.round(zScore); // nearest integer z-score\n            if (.1 > Math.abs(zRound - zScore)) // snap to integer z-score\n                xpos = x(m + zRound * sd);\n        }\n\n        // create slider symbol and text\n        handle2.attr("points", function (_) {\n            return xpos - s + "," + s + " " + (xpos + s) + "," + s + " " + xpos + "," + -s * 1.3;\n        });\n        plotsvg.select("text#range2").text(function (_) {\n            var returnval = "x1: ".concat(invx(xpos).toPrecision(4));\n            var x1val = invx(xpos).toPrecision(4);\n            var mycell = node.name + "To"; // hardcoded here\n            if (document.getElementById(mycell)) {\n                document.getElementById(mycell).innerText = x1val;\n            }\n            return returnval;\n        });\n        node.setxvals[1] = invx(xpos).toPrecision(4);\n    }\n}\n\nfunction bars(node, div, priv) {\n    // Histogram spacing\n    var barPadding = .015; // Space between bars\n    var topScale = 1.2; // Multiplicative factor to assign space at top within graph - currently removed from implementation\n    var plotXaxis = true;\n\n    // Data\n    var keys = Object.keys(node.plotvalues);\n    var yVals = new Array();\n    var ciUpperVals = new Array();\n    var ciLowerVals = new Array();\n    var ciSize;\n\n    var xVals = new Array();\n    var yValKey = new Array();\n\n    if (node.nature == "nominal") {\n        var xi = 0;\n        for (var i = 0; i < keys.length; i++) {\n            if (node.plotvalues[keys[i]] == 0) continue;\n            yVals[xi] = node.plotvalues[keys[i]];\n            xVals[xi] = xi;\n            if (priv) {\n                if (node.plotvaluesCI) {\n                    ciLowerVals[xi] = node.plotValuesCI.lowerBound[keys[i]];\n                    ciUpperVals[xi] = node.plotValuesCI.upperBound[keys[i]];\n                }\n                ciSize = ciUpperVals[xi] - ciLowerVals[xi];\n            };\n\n            yValKey.push({\n                y: yVals[xi],\n                x: keys[i]\n            });\n            xi = xi + 1;\n        }\n        yValKey.sort(function (a, b) {\n            return b.y - a.y;\n        }); // array of objects, each object has y, the same as yVals, and x, the category\n        yVals.sort(function (a, b) {\n            return b - a;\n        }); // array of y values, the height of the bars\n        ciUpperVals.sort(function (a, b) {\n            return b.y - a.y;\n        }); // ?\n        ciLowerVals.sort(function (a, b) {\n            return b.y - a.y;\n        }); // ?\n    } else {\n        for (var i = 0; i < keys.length; i++) {\n            // console.log("plotvalues in bars");\n            yVals[i] = node.plotvalues[keys[i]];\n            xVals[i] = Number(keys[i]);\n            if (priv) {\n                if (node.plotvaluesCI) {\n                    ciLowerVals[i] = node.plotvaluesCI.lowerBound[keys[i]];\n                    ciUpperVals[i] = node.plotvaluesCI.upperBound[keys[i]];\n                }\n                ciSize = ciUpperVals[i] - ciLowerVals[i];\n            }\n        }\n    }\n\n    if (yVals.length > 15 & node.numchar == "numeric" || yVals.length > 5 & node.numchar == "character") plotXaxis = false;\n    var maxY = d3.max(yVals); // in the future, set maxY to the value of the maximum confidence limit\n    if (priv && node.plotvaluesCI) maxY = d3.max(ciUpperVals);\n    var minX = d3.min(xVals);\n    var maxX = d3.max(xVals);\n\n    var mydiv = void 0;\n    if (div == "setxLeft") mydiv = "#setxLeft";else if (div == "varSummary") mydiv = "#tab3";else return alert("Error: incorrect div selected for plots");\n\n    var tempWidth = d3.select(mydiv).style("width");\n    var width = tempWidth.substring(0, tempWidth.length - 2);\n    var tempHeight = d3.select(mydiv).style("height");\n    var height = tempHeight.substring(0, tempHeight.length - 2);\n\n    var margin = {\n        top: 20,\n        right: 20,\n        bottom: 53,\n        left: 10\n    };\n    var tw = document.getElementById(\'main\').offsetWidth;\n\n    // Need to fix automatic width and height settings for leftpanel (#tab2, #tab3)\n    if (mydiv == "#tab3") {\n        width = 0.7 * (width - margin.left - margin.right);\n        height = 0.3 * (height - margin.top - margin.bottom);\n    } else if (mydiv == "#setxLeft") {\n        //width = 200;\n        //height = 120;\n        width = tw * .185 - margin.left - margin.right; //rightpanel.expand is 40 percent, setxLeft to 50 percent, toggle bar is 16px, padding, it\'s all about .185\n        height = width * .6; //height to width is .6\n    } else {\n        width = 0.35 * (width - margin.left - margin.right);\n        height = 0.25 * (height - margin.top - margin.bottom);\n    };\n\n    if (priv && node.stabilityBin) {\n        var x = d3.scale.linear().domain([minX - 0.5, maxX + 1.5]).range([0, width]);\n    } else {\n        var x = d3.scale.linear().domain([minX - 0.5, maxX + 0.5]).range([0, width]);\n    }\n\n    var invx = d3.scale.linear().range([minX - 0.5, maxX + 0.5]).domain([0, width]);\n\n    var y = d3.scale.linear().domain([0, maxY]).range([0, height]);\n\n    var xAxis = d3.svg.axis().scale(x).ticks(yVals.length).orient("bottom");\n\n    var yAxis = d3.svg.axis().scale(y).orient("left");\n\n    var brush = d3.svg.brush().x(x).extent(function () {\n        return node.subsetrange.length == 1 ? [node.subsetrange[0], node.subsetrange[0]] : node.subsetrange;\n    }).on("brush", brushed);\n\n    var brush2 = d3.svg.brush().x(x).on("brush", brushed2);\n\n    // Create SVG element\n    // cumbersome to treat "tab3" differently, but works for now\n    // tab3, has an issue, that unless width height hardcoded, they grow with each additional graph.\n    if (mydiv == "#tab3") {\n        var plotsvg = d3.select(mydiv).selectAll("svg").remove();\n\n        var plotsvg = d3.select(mydiv).append("svg").attr("id", function () {\n            return node.name.toString().concat(mydiv.substr(1));\n        }).style("width", 300) //setting height to the height of #main.left\n        .style("height", 200).append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");\n    } else {\n        var plotsvg = d3.select(mydiv).append("svg").attr("id", function () {\n            var myname = node.name.toString();\n            myname = myname.replace(/\\(|\\)/g, "");\n            return myname.concat("_", mydiv.substr(1), "_", node.id);\n        }).style("width", width + margin.left + margin.right) //setting height to the height of #main.left\n        .style("height", height + margin.top + margin.bottom).append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");\n    };\n\n    var rectWidth = x(minX + 0.5 - 2 * barPadding); //the "width" is the coordinate of the end of the first bar\n\n    plotsvg.selectAll("rect").data(yVals).enter().append("rect").attr("x", function (d, i) {\n        return x(xVals[i] - 0.5 + barPadding);\n    }).attr("y", function (d) {\n        return y(maxY - d);\n    }).attr("width", rectWidth).attr("height", y).attr("fill", "#1f77b4");\n\n    // draw error bars, threshold line and extra bin\n    if (priv) {\n        if (yVals.length <= 20) {\n            plotsvg.selectAll("line").data(ciUpperVals).enter().append("line").style("stroke", "black").attr("x1", function (d, i) {\n                return x(xVals[i] - 0.5 + barPadding) + rectWidth / 2;\n            }).attr("y1", function (d) {\n                return y(maxY - d);\n            }).attr("x2", function (d, i) {\n                return x(xVals[i] - 0.5 + barPadding) + rectWidth / 2;\n            }).attr("y2", function (d) {\n                var y2 = y(maxY - d + ciSize);\n                return y2 >= y(maxY) ? y(maxY) : y2;\n            });\n\n            //draw top ticks on error bars\n            //need to fix the height of the graphs - the tops of error bars are getting cut off\n            plotsvg.selectAll(".topTick").data(ciUpperVals).enter().append("line").attr("class", "topTick").style("stroke", "black").attr("x1", function (d, i) {\n                if (yVals.length > 20) {\n                    return x(xVals[i] - 0.5 + barPadding); //make tick bigger to increase visibility\n                } else {\n                    return x(xVals[i] - 0.5 + barPadding) + 0.4 * rectWidth;\n                }\n            }).attr("y1", function (d) {\n                return y(maxY - d);\n            }).attr("x2", function (d, i) {\n                if (yVals.length > 20) {\n                    return x(xVals[i] - 0.5 + barPadding) + rectWidth; //make tick bigger to increase visibility\n                } else {\n                    return x(xVals[i] - 0.5 + barPadding) + 0.6 * rectWidth;\n                }\n            }).attr("y2", function (d) {\n                return y(maxY - d);\n            });\n\n            // draw bottom ticks of error bars\n            plotsvg.selectAll(".bottomTick").data(ciLowerVals).enter().append("line").attr("class", "bottomTick").style("stroke", "black").attr("x1", function (d, i) {\n                if (yVals.length > 20) {\n                    return x(xVals[i] - 0.5 + barPadding);\n                } else {\n                    return x(xVals[i] - 0.5 + barPadding) + 0.4 * rectWidth;\n                }\n            }).attr("y1", function (d) {\n                return y(maxY - d);\n            }).attr("x2", function (d, i) {\n                if (yVals.length > 20) {\n                    return x(xVals[i] - 0.5 + barPadding) + rectWidth;\n                } else {\n                    return x(xVals[i] - 0.5 + barPadding) + 0.6 * rectWidth;\n                }\n            }).attr("y2", function (d) {\n                return y(maxY - d);\n            });\n        } else {\n            plotsvg.selectAll(".denseError").data(yVals).enter().append("rect").attr("class", "denseError").attr("x", function (d, i) {\n                return x(xVals[i] - 0.5 + barPadding);\n            }).attr("y", function (d) {\n                return y(maxY - d) - .1 * y(d);\n            }).attr("width", rectWidth).attr("height", function (d) {\n                return y(maxY - d) + .1 * y(d) - (y(maxY - d) - .1 * y(d));\n            }).attr("fill", "silver");\n        }\n\n        //if statement for stability histograms\n        //extra stability bin\n        if (node.stabilityBin) {\n            plotsvg.append("rect").attr("x", x(maxX + 0.5 - barPadding)).attr("y", y(maxY) - node.stabilityBin).attr("width", rectWidth).attr("height", node.stabilityBin).attr("fill", "silver");\n        }\n\n        //threshold line\n        if (node.threshold) {\n            plotsvg.append("line").style("stroke", "black").attr("x1", x(minX - 0.5 + barPadding)).attr("y1", y(maxY) - node.threshold).attr("x2", function () {\n                console.log("stabilityBin");\n                console.log(node.stabilityBin);\n                if (node.stabilityBin) {\n                    return x(maxX + 0.5 - barPadding) + rectWidth;\n                } else {\n                    return x(maxX + 0.5 - barPadding);\n                }\n            }).attr("y2", y(maxY) - node.threshold);\n        }\n    }\n\n    if (plotXaxis) {\n        plotsvg.append("g").attr("class", "x axis").attr("transform", "translate(0," + height + ")").call(xAxis);\n    }\n\n    plotsvg.append("text").attr("x", width / 2).attr("y", 0 - margin.top / 2).attr("text-anchor", "middle").style("font-size", "12px").text(node.name);\n\n    if (mydiv == "#setxLeft") {\n        plotsvg.append("text").attr("id", "range") // bad practice, not unique\n        .attr(\'class\', \'xval\').attr("x", 25).attr("y", height + 40).text(function () {\n            if (node.nature === "nominal") {\n                var t = Math.round(yValKey.length / 2) - 1;\n                var mycell = node.name + "From"; // hardcoded here\n                if (document.getElementById(mycell)) {\n                    document.getElementById(mycell).innerText = yValKey[t].x;\n                }\n                return "x: " + yValKey[t].x;\n            } else {\n                var _mycell = node.name + "From"; // hardcoded here\n                if (document.getElementById(_mycell)) {\n                    document.getElementById(_mycell).innerText = (+node.mean).toPrecision(4).toString();\n                }\n                return "x: ".concat((+node.mean).toPrecision(4).toString());\n            }\n        });\n\n        plotsvg.append("text").attr("id", "range2") //bad practice, not unique\n        .attr(\'class\', \'x1val\').attr("x", 25).attr("y", height + 50).text(function () {\n            if (node.nature === "nominal") {\n                var t = Math.round(yValKey.length / 2) - 1;\n                return "x1: " + yValKey[t].x;\n            } else {\n                return "x1: ".concat((+node.mean).toPrecision(4).toString());\n            }\n        });\n\n        // create tick marks at all zscores in the bounds of the data\n        var lineFunction = d3.svg.line().x(function (d) {\n            return d.x;\n        }).y(function (d) {\n            return d.y;\n        }).interpolate("linear");\n\n        var colSeq = ["#A2CD5A", "orange", "red"]; // will cycle through color sequence, and then repeat last color\n        var lineData = new Array();\n\n        var zLower = -1 * (minX - node.mean) / node.sd; // zscore of lower bound\n        var zUpper = (maxX - node.mean) / node.sd; // zscore of upper bound\n\n        for (var i = 0; i < zUpper; i++) {\n            lineData = [{\n                "x": x(+node.mean + i * node.sd),\n                "y": height * .7\n            }, {\n                "x": x(+node.mean + i * node.sd),\n                "y": height * .9\n            }];\n            plotsvg.append("path").attr("d", lineFunction([lineData[0], lineData[1]])).attr("stroke", colSeq[d3.min([i, colSeq.length - 1])]).attr("stroke-width", 1.5).attr("fill", "none");\n        }\n\n        for (var i = 1; i < zLower; i++) {\n            lineData = [{\n                "x": x(+node.mean - i * node.sd),\n                "y": height * .7\n            }, {\n                "x": x(+node.mean - i * node.sd),\n                "y": height * .9\n            }];\n            plotsvg.append("path").attr("d", lineFunction([lineData[0], lineData[1]])).attr("stroke", colSeq[d3.min([i, colSeq.length - 1])]).attr("stroke-width", 1.5).attr("fill", "none");\n        }\n\n        for (var i = d3.min(xVals); i <= d3.max(xVals); i++) {\n            lineData = [{\n                "x": x(i),\n                "y": height * .75\n            }, {\n                "x": x(i),\n                "y": height * .85\n            }];\n            plotsvg.append("path").attr("d", lineFunction([lineData[0], lineData[1]])).attr("stroke", "black").attr("stroke-width", 1).attr("fill", "none");\n        }\n\n        // initialize slider components\n        var slideBox = plotsvg.append("g").attr("class", "x axis").attr("transform", "translate(0," + height * .8 + ")").call(d3.svg.axis().scale(x).ticks(0).orient("bottom"));\n\n        var slider = plotsvg.append("g").attr("class", "slider").call(brush);\n        var slider2 = plotsvg.append("g").attr("class", "slider").call(brush2);\n\n        var points = function points(i) {\n            return function (d) {\n                var xnm = void 0,\n                    s = 6;\n                if (node.setxvals[i] == \'\') {\n                    // if nominal, use the median frequency as the position for the setx slider\n                    xnm = node.nature == \'nominal\' ? x(Math.round(xVals.length / 2) - 1) : x(node.mean);\n                } else {\n                    xnm = x(node.setxvals[i]);\n                };\n                return xnm - s + \',\' + -s + \' \' + (xnm + s) + \',\' + -s + \' \' + xnm + \',\' + s * 1.3;\n            };\n        };\n        var handle = slider.append("polygon").attr("class", "handle").attr("transform", "translate(0," + height * .7 + ")").attr("points", points(0));\n        var handle2 = slider2.append("polygon").attr("class", "handle").attr("transform", "translate(0," + height * .9 + ")").attr("points", points(1));\n    }\n\n    function twoSF(x) {\n        var tsf = d3.format(".2r"); // format to two significant figures after the decimal place\n        return tsf(x).replace(/0+$/, "").replace(/\\.$/, ""); // trim trailing zeros after a period, and any orphaned period\n    }\n\n    // brushing functions\n    function brushed() {\n        var value = brush.extent()[0];\n        var s = 6;\n\n        if (d3.event.sourceEvent) {\n            value = x.invert(d3.mouse(this)[0]);\n            brush.extent([value, value]);\n        }\n\n        // set x position of slider center\n        var xpos = x(value);\n        if (value > maxX) {\n            // dragged past max\n            xpos = x(maxX);\n        } else if (value < minX) {\n            // dragged past min\n            xpos = x(minX);\n        } else {\n            var m = +node.mean;\n            var sd = +node.sd;\n            var zScore = (value - m) / sd; // z-score\n            var zRound = Math.round(zScore); // nearest integer z-score\n            if (.1 > Math.abs(Math.round(value) - value)) {\n                // snap to integer\n                xpos = x(Math.round(value));\n            } else if (.1 > Math.abs(zRound - zScore)) {\n                // snap to integer z-score\n                xpos = x(m + zRound * sd);\n            }\n        }\n\n        // create slider symbol and text\n        handle.attr("points", function (d) {\n            return xpos - s + "," + -s + " " + (xpos + s) + "," + -s + " " + xpos + "," + s * 1.3;\n        });\n        plotsvg.select("text#range").text(function () {\n            if (node.nature === "nominal") {\n                var mycell = node.name + "From"; // hardcoded here\n                if (document.getElementById(mycell)) {\n                    document.getElementById(mycell).innerText = yValKey[Math.round(invx(xpos))].x;\n                }\n                return "x: " + yValKey[Math.round(invx(xpos))].x;\n            } else {\n                var _mycell2 = node.name + "From"; // hardcoded here\n                if (document.getElementById(_mycell2)) {\n                    document.getElementById(_mycell2).innerText = +invx(xpos).toPrecision(4).toString();\n                }\n                return "x: ".concat(+invx(xpos).toPrecision(4).toString());\n            }\n        });\n        node.setxvals[0] = +invx(xpos).toPrecision(4);\n    }\n\n    // certainly a more clever way to do this, but for now it\'s basically copied with brush and handle changes to brush2 and handle2 and #range to #range2 and setxvals[0] to setxvals[1]\n    function brushed2() {\n        var value = brush2.extent()[0];\n        var s = 6; // scaling for triangle shape\n\n        if (d3.event.sourceEvent) {\n            value = x.invert(d3.mouse(this)[0]);\n            brush2.extent([value, value]);\n        }\n\n        // set x position of slider center\n        var xpos = x(value);\n        if (value > maxX) {\n            // dragged past max\n            xpos = x(maxX);\n        } else if (value < minX) {\n            // dragged past min\n            xpos = x(minX);\n        } else {\n            var m = +node.mean;\n            var sd = +node.sd;\n            var zScore = (value - m) / sd; // z-score\n            var zRound = Math.round(zScore); // nearest integer z-score\n            if (.1 > Math.abs(Math.round(value) - value)) {\n                // snap to integer\n                xpos = x(Math.round(value));\n            } else if (.1 > Math.abs(zRound - zScore)) {\n                // snap to integer z-score\n                xpos = x(m + zRound * sd);\n            }\n        }\n\n        // create slider symbol and text\n        handle2.attr("points", function (d) {\n            return xpos - s + "," + s + " " + (xpos + s) + "," + s + " " + xpos + "," + -s * 1.3;\n        });\n        plotsvg.select("text#range2").text(function () {\n            if (node.nature === "nominal") {\n                var mycell = node.name + "To"; // hardcoded here\n                if (document.getElementById(mycell)) {\n                    document.getElementById(mycell).innerText = yValKey[Math.round(invx(xpos))].x;\n                }\n                return "x1: " + yValKey[Math.round(invx(xpos))].x;\n            } else {\n                var _mycell3 = node.name + "To"; // hardcoded here\n                if (document.getElementById(_mycell3)) {\n                    document.getElementById(_mycell3).innerText = +invx(xpos).toPrecision(4).toString();\n                }\n                return "x1: ".concat(+invx(xpos).toPrecision(4).toString());\n            }\n        });\n        node.setxvals[1] = +invx(xpos).toPrecision(4);\n    }\n}\n\n// draws barplots in subset tab\nfunction barsSubset(node) {\n    // if untouched, set node.subsetrange to an empty array, meaning all values selected by default\n    if (node.subsetrange[0] == "" & node.subsetrange[1] == "") {\n        node.subsetrange = [];\n    }\n\n    // Histogram spacing\n    var barPadding = .015; // Space between bars\n    var topScale = 1.2; // Multiplicative factor to assign space at top within graph - currently removed from implementation\n    var plotXaxis = true;\n\n    // Variable name\n    var myname = node.name.toString();\n    myname = myname.replace(/\\(|\\)/g, "");\n\n    // Data\n    var keys = Object.keys(node.plotvalues);\n    var yVals = new Array();\n    var xVals = new Array();\n    var yValKey = new Array();\n\n    var xi = 0;\n    for (var i = 0; i < keys.length; i++) {\n        if (node.plotvalues[keys[i]] == 0) continue;\n        yVals[xi] = node.plotvalues[keys[i]];\n        xVals[xi] = xi;\n        yValKey.push({\n            y: yVals[xi],\n            x: keys[i]\n        });\n        xi = xi + 1;\n    }\n    if (node.nature === "nominal") {\n        // if nominal, orders bars left to right, highest frequency to lowest\n        yValKey.sort(function (a, b) {\n            return b.y - a.y;\n        }); // array of objects, each object has y, the same as yVals, and x, the category\n        yVals.sort(function (a, b) {\n            return b - a;\n        }); // array of y values, the height of the bars\n    }\n\n    plotXaxis = false;\n\n    var maxY = d3.max(yVals);\n    var minX = d3.min(xVals);\n    var maxX = d3.max(xVals);\n    var gname = ["subsetyes", "subsetno"];\n\n    var yVals2 = [];\n    var yVals1 = [];\n    for (i = 0; i < yVals.length; i++) {\n        yVals1.push({\n            y0: maxY - yVals[i],\n            y1: yVals[i],\n            col: d3Color\n        });\n        yVals2.push({\n            y0: 0,\n            y1: maxY - yVals[i],\n            col: "transparent"\n        });\n    }\n    var freqs = [yVals1, yVals2];\n\n    // y0 is the starting point\n    // y1 is the length of the bar\n\n    var mydiv = "#tab2";\n    var width = 200;\n    var height = 120;\n    var margin = {\n        top: 20,\n        right: 20,\n        bottom: 53,\n        left: 50\n    };\n\n    var x = d3.scale.linear().domain([minX - 0.5, maxX + 0.5]).range([0, width]);\n\n    var invx = d3.scale.linear().range([minX - 0.5, maxX + 0.5]).domain([0, width]);\n\n    var y = d3.scale.linear().domain([0, maxY]).range([0, height]);\n\n    var xAxis = d3.svg.axis().scale(x).ticks(yVals.length).orient("bottom");\n\n    var yAxis = d3.svg.axis().scale(y).orient("left");\n\n    //Create SVG element\n    var plotsvg = d3.select(mydiv).append("svg").attr("id", function () {\n        return myname.concat("_", mydiv.substr(1), "_", node.id);\n    }).style("width", width + margin.left + margin.right) //setting height to the height of #main.left\n    .style("height", height + margin.top + margin.bottom).append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");\n\n    var freq = plotsvg.selectAll("g.freq").data(freqs).enter().append("g").attr("class", "freq").attr("name", function (d, i) {\n        return myname.concat(gname[i]);\n    });\n\n    var rect = freq.selectAll("rect").data(Object).enter().append("rect").attr("class", "bar").attr("name", function (d, i) {\n        return xVals[i];\n    }).attr("x", function (d, i) {\n        return x(xVals[i] - 0.5 + barPadding);\n    }).attr("y", function (d) {\n        return y(d.y0);\n    }).attr("width", x(minX + 0.5 - 2 * barPadding)) // the "width" is the coordinate of the end of the first bar\n    .attr("height", function (d) {\n        return y(d.y1);\n    }).style("fill", function (d, i) {\n        if (node.subsetrange.length > 0 & d.col === d3Color & $.inArray(xVals[i].toString(), node.subsetrange) > -1) {\n            return selVarColor;\n        } else {\n            return d.col;\n        }\n    }).on("click", function () {\n        var selectMe = this;\n        var selectName = this.getAttribute("name");\n        if (this.parentNode.getAttribute("name") == myname.concat("subsetno")) {\n            selectMe = $(\'[name="\' + myname.concat("subsetyes") + \'"]\').children(\'[name="\' + selectName + \'"]\')[0];\n        }\n        d3.select(selectMe).style("fill", function (d, i) {\n            var myCol = "";\n            if (this.style.fill === selVarColor) {\n                var myindex = node.subsetrange.indexOf(this.getAttribute("name"));\n                node.subsetrange.splice(myindex, 1);\n                myCol = d3Color;\n            } else {\n                node.subsetrange.push(this.getAttribute("name"));\n                myCol = selVarColor;\n            }\n            return myCol;\n        });\n        plotsvg.select("text#selectrange").text(function () {\n            if (node.subsetrange.length == 0) {\n                return "Selected: all values";\n            } else {\n                var a = node.subsetrange;\n                var selecteds = new Array();\n                a.forEach(function (val) {\n                    selecteds.push(yValKey[val].x);\n                });\n                return "Selected: " + selecteds;\n            }\n        });\n    }).on("mouseover", function () {\n        var i = this.getAttribute("name");\n        plotsvg.select("text#mymouseover").text(function () {\n            return yValKey[i].x + ": " + yValKey[i].y;\n        });\n    }).on("mouseout", function () {\n        var i = this.getAttribute("name");\n        plotsvg.select("text#mymouseover").text(function () {\n            return "Value: Frequency";\n        });\n    });\n\n    if (plotXaxis) {\n        plotsvg.append("g").attr("class", "x axis").attr("transform", "translate(0," + height + ")").call(xAxis);\n    } else {\n        plotsvg.append("text").attr("id", "mymouseover").attr("x", 25).attr("y", height + 20).text(function () {\n            return "Value: Frequency";\n        });\n    }\n\n    plotsvg.append("text").attr("x", width / 2).attr("y", 0 - margin.top / 2).attr("text-anchor", "middle").style("font-size", "12px").text(myname);\n\n    plotsvg.append("text").attr("id", "selectrange").attr("x", 25).attr("y", height + 40).text(function () {\n        if (node.subsetrange.length == 0) return "Selected: all values";\n        var selecteds = new Array();\n        node.subsetrange.forEach(function (val) {\n            return selecteds.push(yValKey[val].x);\n        });\n        return "Selected: " + selecteds;\n    });\n}\n\nfunction densityNode(node, obj) {\n    var myname = node.name.toString().concat("nodeplot");\n\n    if (typeof obj === "undefined") {\n        var obj = document.getElementById(node.name.toString() + "biggroup");\n        // if obj contains an svg element, remove it. this removes any plot inside the node\n        if (d3.select(obj).selectAll("svg")[0].length > 0) d3.select(obj).selectAll("svg").remove();\n    }\n\n    var yVals = node.ploty;\n    var xVals = node.plotx;\n    // array of objects\n    var data2 = node.plotx.map(function (x, i) {\n        return { x: +x, y: +node.ploty[i] };\n    });\n\n    var width = 60; // hardcoded, should be set automatically\n    var height = 30;\n    var margin = {\n        top: 20,\n        right: 10,\n        bottom: 53,\n        left: 10\n    };\n\n    var x = d3.scale.linear().domain([d3.min(xVals), d3.max(xVals)]).range([0, width]);\n\n    var y = d3.scale.linear().domain([d3.min(yVals), d3.max(yVals)]).range([height, 0]);\n\n    var area = d3.svg.area().interpolate("monotone").x(function (d) {\n        return x(d.x);\n    }).y0(height).y1(function (d) {\n        return y(d.y);\n    });\n\n    var plotsvg = d3.select(obj).insert("svg", ":first-child").attr("x", -40) // NOTE: Not sure exactly why these numbers work, but these hardcoded values seem to position the plot inside g correctly.  this shouldn\'t be hardcoded in the future\n    .attr("y", -45).attr("id", function () {\n        return myname;\n    }).style("width", width).style("height", height).append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");\n\n    plotsvg.append("path").datum(data2).attr("class", "area").attr("d", area);\n}\n\nfunction barsNode(node, obj) {\n    var myname = node.name.toString().concat("nodeplot");\n\n    if (typeof obj === "undefined") {\n        var obj = document.getElementById(node.name.toString() + "biggroup");\n        // if obj contains an svg element, remove it. this removes any plot inside the node\n        if (d3.select(obj).selectAll("svg")[0].length > 0) {\n            d3.select(obj).selectAll("svg").remove();\n        }\n    }\n\n    // Histogram spacing\n    var barPadding = .015; // Space between bars\n    var topScale = 1.2; // Multiplicative factor to assign space at top within graph - currently removed from implementation\n\n    // Data\n    var keys = Object.keys(node.plotvalues);\n    var yVals = new Array();\n    var xVals = new Array();\n    var yValKey = new Array();\n\n    if (node.nature === "nominal") {\n        var xi = 0;\n        for (var i = 0; i < keys.length; i++) {\n            if (node.plotvalues[keys[i]] == 0) continue;\n            yVals[xi] = node.plotvalues[keys[i]];\n            xVals[xi] = xi;\n            yValKey.push({ y: yVals[xi], x: keys[i] });\n            xi = xi + 1;\n        }\n        yValKey.sort(function (a, b) {\n            return b.y - a.y;\n        }); // array of objects, each object has y, the same as yVals, and x, the category\n        yVals.sort(function (a, b) {\n            return b - a;\n        }); // array of y values, the height of the bars\n    } else {\n        for (var i = 0; i < keys.length; i++) {\n            yVals[i] = node.plotvalues[keys[i]];\n            xVals[i] = Number(keys[i]);\n        }\n    }\n\n    var maxY = d3.max(yVals);\n    var minX = d3.min(xVals);\n    var maxX = d3.max(xVals);\n\n    var width = 60;\n    var height = 30;\n    var margin = {\n        top: 20,\n        right: 10,\n        bottom: 53,\n        left: 10\n    };\n\n    var x = d3.scale.linear().domain([minX - 0.5, maxX + 0.5]).range([0, width]);\n\n    var invx = d3.scale.linear().range([minX - 0.5, maxX + 0.5]).domain([0, width]);\n\n    var y = d3.scale.linear().domain([0, maxY]).range([0, height]);\n\n    //Create SVG element\n    var plotsvg = d3.select(obj).insert("svg", ":first-child").attr("x", -40).attr("y", -45).attr("id", function () {\n        return myname;\n    }).style("width", width) // set height to the height of #main.left\n    .style("height", height).append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");\n\n    plotsvg.selectAll("rect").data(yVals).enter().append("rect").attr("x", function (d, i) {\n        return x(xVals[i] - 0.5 + barPadding);\n    }).attr("y", function (d) {\n        return y(maxY - d);\n    }).attr("width", x(minX + 0.5 - 2 * barPadding)) // the "width" is the coordinate of the end of the first bar\n    .attr("height", y).attr("fill", "#1f77b4");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvYXBwL3Bsb3RzLmpzP2JmMWYiXSwibmFtZXMiOlsiZGVuc2l0eSIsImJhcnMiLCJiYXJzU3Vic2V0IiwiZGVuc2l0eU5vZGUiLCJiYXJzTm9kZSIsImQzQ29sb3IiLCJzZWxWYXJDb2xvciIsIm5vZGUiLCJkaXYiLCJwcml2Iiwic3Vic2V0Iiwic2V0eExlZnQiLCJ2YXJTdW1tYXJ5IiwiYWxlcnQiLCJwbG90eCIsInBsb3R5IiwieFZhbHMiLCJ5VmFscyIsInBsb3RDSSIsIm1hcCIsIngiLCJpIiwieSIsImJvdW5kIiwidXBwZXJFcnJvciIsImxvd2VyRXJyb3IiLCJjb25zb2xlIiwibG9nIiwidGVtcFdpZHRoIiwiZDMiLCJzZWxlY3QiLCJzdHlsZSIsIndpZHRoIiwic3Vic3RyaW5nIiwibGVuZ3RoIiwidHciLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwib2Zmc2V0V2lkdGgiLCJ0ZW1wSGVpZ2h0IiwiaGVpZ2h0IiwibWFyZ2luIiwidG9wIiwicmlnaHQiLCJib3R0b20iLCJsZWZ0Iiwic2NhbGUiLCJsaW5lYXIiLCJkb21haW4iLCJtaW4iLCJtYXgiLCJyYW5nZSIsImludngiLCJ4QXhpcyIsInN2ZyIsImF4aXMiLCJ0aWNrcyIsIm9yaWVudCIsInlBeGlzIiwiYnJ1c2giLCJleHRlbnQiLCJzdWJzZXRyYW5nZSIsIm9uIiwiYnJ1c2hlZCIsImJydXNoMiIsImJydXNoZWQyIiwiYXJlYSIsImludGVycG9sYXRlIiwiZCIsInkwIiwieTEiLCJsaW5lIiwicGxvdHN2ZyIsInNlbGVjdEFsbCIsInJlbW92ZSIsImFwcGVuZCIsImF0dHIiLCJuYW1lIiwidG9TdHJpbmciLCJjb25jYXQiLCJzdWJzdHIiLCJyZXBsYWNlIiwiaWQiLCJkYXR1bSIsImNhbGwiLCJ0ZXh0IiwidG9QcmVjaXNpb24iLCJtZWFuIiwicmV0dXJudmFsIiwibGluZUZ1bmN0aW9uIiwiY29sU2VxIiwibGluZURhdGEiLCJBcnJheSIsInpMb3dlciIsInNkIiwielVwcGVyIiwic2xpZGVCb3giLCJzbGlkZXIiLCJoYW5kbGUiLCJzIiwieG5tIiwic2V0eHZhbHMiLCJzbGlkZXIyIiwiaGFuZGxlMiIsImVtcHR5IiwidmFsdWUiLCJldmVudCIsInNvdXJjZUV2ZW50IiwiaW52ZXJ0IiwibW91c2UiLCJ4cG9zIiwibSIsInpTY29yZSIsInpSb3VuZCIsIk1hdGgiLCJyb3VuZCIsImFicyIsInh2YWwiLCJteWNlbGwiLCJpbm5lclRleHQiLCJ4MXZhbCIsImJhclBhZGRpbmciLCJ0b3BTY2FsZSIsInBsb3RYYXhpcyIsImtleXMiLCJPYmplY3QiLCJwbG90dmFsdWVzIiwiY2lVcHBlclZhbHMiLCJjaUxvd2VyVmFscyIsImNpU2l6ZSIsInlWYWxLZXkiLCJuYXR1cmUiLCJ4aSIsInBsb3R2YWx1ZXNDSSIsInBsb3RWYWx1ZXNDSSIsImxvd2VyQm91bmQiLCJ1cHBlckJvdW5kIiwicHVzaCIsInNvcnQiLCJhIiwiYiIsIk51bWJlciIsIm51bWNoYXIiLCJtYXhZIiwibWluWCIsIm1heFgiLCJteWRpdiIsInN0YWJpbGl0eUJpbiIsIm15bmFtZSIsInJlY3RXaWR0aCIsImRhdGEiLCJlbnRlciIsInkyIiwidGhyZXNob2xkIiwidCIsInBvaW50cyIsInR3b1NGIiwidHNmIiwiZm9ybWF0IiwiZ25hbWUiLCJ5VmFsczIiLCJ5VmFsczEiLCJjb2wiLCJmcmVxcyIsImZyZXEiLCJyZWN0IiwiJCIsImluQXJyYXkiLCJzZWxlY3RNZSIsInNlbGVjdE5hbWUiLCJnZXRBdHRyaWJ1dGUiLCJwYXJlbnROb2RlIiwiY2hpbGRyZW4iLCJteUNvbCIsImZpbGwiLCJteWluZGV4IiwiaW5kZXhPZiIsInNwbGljZSIsInNlbGVjdGVkcyIsImZvckVhY2giLCJ2YWwiLCJvYmoiLCJkYXRhMiIsImluc2VydCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7UUFJZ0JBLE8sR0FBQUEsTztRQXFVQUMsSSxHQUFBQSxJO1FBK2hCQUMsVSxHQUFBQSxVO1FBNk5BQyxXLEdBQUFB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QURMLENBQ1VySSxLQURWLEVBRUtzSSxLQUZMLEdBR0s1RSxNQUhMLENBR1ksTUFIWixFQUlLQyxJQUpMLENBSVUsR0FKVixFQUllLFVBQUNSLENBQUQsRUFBSS9DLENBQUo7QUFBQSxlQUFXRCxFQUFFSixNQUFNSyxDQUFOLElBQVcsR0FBWCxHQUFpQm9HLFVBQW5CLENBQVg7QUFBQSxLQUpmLEVBS0s3QyxJQUxMLENBS1UsR0FMVixFQUtlO0FBQUEsZUFBTXRELEVBQUV5SCxPQUFPM0UsQ0FBVCxDQUFOO0FBQUEsS0FMZixFQU1LUSxJQU5MLENBTVUsT0FOVixFQU1tQnhELEVBQUU0SCxPQUFPLEdBQVAsR0FBYSxJQUFJdkIsVUFBbkIsQ0FObkIsRUFNbUQ7QUFObkQsS0FPSzdDLElBUEwsQ0FPVSxRQVBWLEVBT29CdEQsQ0FQcEIsRUFRS3NELElBUkwsQ0FRVSxNQVJWLEVBUWtCLFNBUmxCO0FBU0giLCJmaWxlIjoiMi5qcyIsInNvdXJjZXNDb250ZW50IjpbImxldCBkM0NvbG9yID0gJyMxZjc3YjQnOyAvLyBkMydzIGRlZmF1bHQgYmx1ZVxuZXhwb3J0IGxldCBzZWxWYXJDb2xvciA9ICcjZmE4MDcyJzsgLy8gZDMucmdiKFwic2FsbW9uXCIpO1xuXG4vLyBmdW5jdGlvbiB0byB1c2UgZDMgdG8gZ3JhcGggZGVuc2l0eSBwbG90cyB3aXRoIHByZXByb2Nlc3NlZCBkYXRhXG5leHBvcnQgZnVuY3Rpb24gZGVuc2l0eShub2RlLCBkaXYsIHByaXYpIHtcbiAgICBkaXYgPSB7c3Vic2V0OiAnI3RhYjInLCBzZXR4TGVmdDogJyNzZXR4TGVmdCcsIHZhclN1bW1hcnk6ICcjdGFiMyd9W2Rpdl07XG4gICAgaWYgKCFkaXYpXG4gICAgICAgIHJldHVybiBhbGVydChcIkVycm9yOiBpbmNvcnJlY3QgZGl2IHNlbGVjdGVkIGZvciBwbG90c1wiKTtcblxuICAgIGxldCBbeFZhbHMsIHlWYWxzXSA9IFtub2RlLnBsb3R4LCBub2RlLnBsb3R5XTtcbiAgICBpZiAocHJpdiAmJiBub2RlLnBsb3RDSSkge1xuICAgICAgICBsZXQgW3VwcGVyRXJyb3IsIGxvd2VyRXJyb3JdID0gWyd1cHBlckJvdW5kJywgJ2xvd2VyQm91bmQnXS5tYXAoXG4gICAgICAgICAgICBib3VuZCA9PiB4VmFscy5tYXAoKHgsIGkpID0+ICh7eDogK3gsIHk6ICtub2RlLnBsb3RDSVtib3VuZF1baV19KSkpO1xuICAgICAgICBjb25zb2xlLmxvZygndXBwZXJFcnJvclxcbicsIHVwcGVyRXJyb3IpO1xuICAgIH1cblxuICAgIHZhciB0ZW1wV2lkdGggPSBkMy5zZWxlY3QoZGl2KS5zdHlsZShcIndpZHRoXCIpO1xuICAgIHZhciB3aWR0aCA9IHRlbXBXaWR0aC5zdWJzdHJpbmcoMCwgKHRlbXBXaWR0aC5sZW5ndGggLSAyKSk7XG4gICAgXG4gICAgbGV0IHR3ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21haW4nKS5vZmZzZXRXaWR0aDtcbiAgICBcbiAgICB2YXIgdGVtcEhlaWdodCA9IGQzLnNlbGVjdChkaXYpLnN0eWxlKFwiaGVpZ2h0XCIpO1xuICAgIHZhciBoZWlnaHQgPSB0ZW1wSGVpZ2h0LnN1YnN0cmluZygwLCAodGVtcEhlaWdodC5sZW5ndGggLSAyKSk7XG4gICAgdmFyIG1hcmdpbiA9IHtcbiAgICAgICAgdG9wOiAyMCxcbiAgICAgICAgcmlnaHQ6IDIwLFxuICAgICAgICBib3R0b206IDUzLFxuICAgICAgICBsZWZ0OiAxMFxuICAgIH07XG5cbiAgICAvLyBOZWVkIHRvIGZpeCBhdXRvbWF0aWMgd2lkdGggYW5kIGhlaWdodCBzZXR0aW5ncyBmb3IgbGVmdHBhbmVsICgjdGFiMiwgI3RhYjMpXG4gICAgaWYgKGRpdiA9PSBcIiN0YWIzXCIpIHtcbiAgICAgICAgd2lkdGggPSAwLjcgKiAod2lkdGggLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodCksXG4gICAgICAgIGhlaWdodCA9IDAuMyAqIChoZWlnaHQgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbSk7XG4gICAgfSBlbHNlIGlmIChkaXYgPT0gXCIjdGFiMlwiKSB7XG4gICAgICAgIHdpZHRoID0gMjAwO1xuICAgICAgICBoZWlnaHQgPSAxMjA7XG4gICAgfSBlbHNlIGlmIChkaXYgPT0gXCIjc2V0eExlZnRcIikge1xuICAgICAgICB3aWR0aD10dyouMTg1LW1hcmdpbi5sZWZ0LW1hcmdpbi5yaWdodDsgLy9yaWdodHBhbmVsLmV4cGFuZCBpcyA0MCBwZXJjZW50LCBzZXR4TGVmdCB0byA1MCBwZXJjZW50LCB0b2dnbGUgYmFyIGlzIDE2cHgsIHBhZGRpbmcsIGl0J3MgYWxsIGFib3V0IC4xODVcbiAgICAgICAgaGVpZ2h0PXdpZHRoKi42OyAvL2hlaWdodCB0byB3aWR0aCBpcyAuNlxuICAgIH0gZWxzZSB7XG4gICAgICAgIHdpZHRoID0gMC4zNSAqICh3aWR0aCAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0KSxcbiAgICAgICAgaGVpZ2h0ID0gMC4yNSAqIChoZWlnaHQgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbSk7XG4gICAgfTtcblxuICAgIHZhciB4ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLmRvbWFpbihbZDMubWluKHhWYWxzKSwgZDMubWF4KHhWYWxzKV0pXG4gICAgICAgIC5yYW5nZShbMCwgd2lkdGhdKTtcbiAgICB2YXIgaW52eCA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgIC5yYW5nZShbZDMubWluKHhWYWxzKSwgZDMubWF4KHhWYWxzKV0pXG4gICAgICAgIC5kb21haW4oWzAsIHdpZHRoXSk7XG4gICAgdmFyIHkgPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAuZG9tYWluKFtkMy5taW4oeVZhbHMpLCBkMy5tYXgoeVZhbHMpXSlcbiAgICAgICAgLnJhbmdlKFtoZWlnaHQsIDBdKTtcbiAgICB2YXIgeEF4aXMgPSBkMy5zdmcuYXhpcygpXG4gICAgICAgIC5zY2FsZSh4KVxuICAgICAgICAudGlja3MoNSlcbiAgICAgICAgLm9yaWVudChcImJvdHRvbVwiKTtcbiAgICB2YXIgeUF4aXMgPSBkMy5zdmcuYXhpcygpXG4gICAgICAgIC5zY2FsZSh5KVxuICAgICAgICAub3JpZW50KFwibGVmdFwiKTtcbiAgICB2YXIgYnJ1c2ggPSBkMy5zdmcuYnJ1c2goKVxuICAgICAgICAueCh4KVxuICAgICAgICAuZXh0ZW50KG5vZGUuc3Vic2V0cmFuZ2UpXG4gICAgICAgIC5vbihcImJydXNoXCIsIGJydXNoZWQpO1xuICAgIHZhciBicnVzaDIgPSBkMy5zdmcuYnJ1c2goKVxuICAgICAgICAueCh4KVxuICAgICAgICAub24oXCJicnVzaFwiLCBicnVzaGVkMik7XG4gICAgdmFyIGFyZWEgPSBkMy5zdmcuYXJlYSgpXG4gICAgICAgIC5pbnRlcnBvbGF0ZShcIm1vbm90b25lXCIpXG4gICAgICAgIC54KGQgPT4geChkLngpKVxuICAgICAgICAueTAoaGVpZ2h0KVxuICAgICAgICAueTEoZCA9PiB5KGQueSkpO1xuICAgIHZhciBsaW5lID0gZDMuc3ZnLmxpbmUoKVxuICAgICAgICAueChkID0+IHgoZC54KSlcbiAgICAgICAgLnkoZCA9PiB5KGQueSkpXG4gICAgICAgIC5pbnRlcnBvbGF0ZShcIm1vbm90b25lXCIpO1xuXG4gICAgLy8gY3VtYmVyc29tZSB0byB0cmVhdCBcInRhYjNcIiBkaWZmZXJlbnRseSwgYnV0IHdvcmtzIGZvciBub3dcbiAgICAvLyB0YWIzLCBoYXMgYW4gaXNzdWUsIHRoYXQgdW5sZXNzIHdpZHRoIGhlaWdodCBoYXJkY29kZWQsIHRoZXkgZ3JvdyB3aXRoIGVhY2ggYWRkaXRpb25hbCBncmFwaC5cbiAgICBpZiAoZGl2ID09IFwiI3RhYjNcIikge1xuICAgICAgICB2YXIgcGxvdHN2ZyA9IGQzLnNlbGVjdChkaXYpXG4gICAgICAgICAgICAuc2VsZWN0QWxsKFwic3ZnXCIpXG4gICAgICAgICAgICAucmVtb3ZlKCk7XG4gICAgICAgIHBsb3RzdmcgPSBkMy5zZWxlY3QoZGl2KVxuICAgICAgICAgICAgLmFwcGVuZChcInN2Z1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCAoKSA9PiBub2RlLm5hbWUudG9TdHJpbmcoKS5jb25jYXQoZGl2LnN1YnN0cigxKSkpXG4gICAgICAgICAgICAuc3R5bGUoXCJ3aWR0aFwiLCAzMDApIC8vIHNldCBoZWlnaHQgdG8gdGhlIGhlaWdodCBvZiAjbWFpbi5sZWZ0XG4gICAgICAgICAgICAuc3R5bGUoXCJoZWlnaHRcIiwgMjAwKVxuICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIGB0cmFuc2xhdGUoJHttYXJnaW4ubGVmdH0sJHttYXJnaW4udG9wfSlgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcGxvdHN2ZyA9IGQzLnNlbGVjdChkaXYpXG4gICAgICAgICAgICAuYXBwZW5kKFwic3ZnXCIpXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsICgpID0+IG5vZGUubmFtZS50b1N0cmluZygpXG4gICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFwofFxcKS9nLCBcIlwiKVxuICAgICAgICAgICAgICAgICAgLmNvbmNhdChcIl9cIiwgZGl2LnN1YnN0cigxKSwgXCJfXCIsIG5vZGUuaWQpKVxuICAgICAgICAgICAgLnN0eWxlKFwid2lkdGhcIiwgd2lkdGggKyBtYXJnaW4ubGVmdCArIG1hcmdpbi5yaWdodCkgLy9zZXR0aW5nIGhlaWdodCB0byB0aGUgaGVpZ2h0IG9mICNtYWluLmxlZnRcbiAgICAgICAgICAgIC5zdHlsZShcImhlaWdodFwiLCBoZWlnaHQgKyBtYXJnaW4udG9wICsgbWFyZ2luLmJvdHRvbSlcbiAgICAgICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBgdHJhbnNsYXRlKCR7bWFyZ2luLmxlZnR9LCR7bWFyZ2luLnRvcH0pYCk7XG4gICAgfTtcbiAgICBwbG90c3ZnLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgLmRhdHVtKHhWYWxzLm1hcCgoeCwgaSkgPT4gKHt4OiAreCwgeTogK25vZGUucGxvdHlbaV19KSkpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJhcmVhXCIpXG4gICAgICAgIC5hdHRyKFwiZFwiLCBhcmVhKTtcblxuICAgIC8vYWRkIHVwcGVyIGJvdW5kXG4gICAgcHJpdiAmJiBub2RlLnBsb3RDSSAmJiBwbG90c3ZnLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInVwcGVyRXJyb3JcIilcbiAgICAgICAgLmRhdHVtKHVwcGVyRXJyb3IpXG4gICAgICAgIC5hdHRyKFwiZFwiLCBhcmVhKTtcblxuICAgIC8vYWRkIGxvd2VyIGJvdW5kXG4gICAgcHJpdiAmJiBub2RlLnBsb3RDSSAmJiBwbG90c3ZnLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImxvd2VyRXJyb3JcIilcbiAgICAgICAgLmRhdHVtKGxvd2VyRXJyb3IpXG4gICAgICAgIC5hdHRyKFwiZFwiLCBhcmVhKTtcblxuICAgIHBsb3RzdmcuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwieCBheGlzXCIpXG4gICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsXCIgKyBoZWlnaHQgKyBcIilcIilcbiAgICAgICAgLmNhbGwoeEF4aXMpO1xuXG4gICAgcGxvdHN2Zy5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgIC5hdHRyKFwieFwiLCAod2lkdGggLyAyKSlcbiAgICAgICAgLmF0dHIoXCJ5XCIsIDAgLSAobWFyZ2luLnRvcCAvIDIpKVxuICAgICAgICAuYXR0cihcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpXG4gICAgICAgIC5zdHlsZShcImZvbnQtc2l6ZVwiLCBcIjEycHhcIilcbiAgICAgICAgLnRleHQobm9kZS5uYW1lKTtcblxuICAgIC8vIGFkZCBicnVzaCBpZiBzdWJzZXRcbiAgICBpZiAoZGl2ID09IFwiI3RhYjJcIikge1xuICAgICAgICBwbG90c3ZnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgXCJyYW5nZVwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIDI1KVxuICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIGhlaWdodCArIDQwKVxuICAgICAgICAgICAgLnRleHQoKCkgPT4gXCJSYW5nZTogXCIuY29uY2F0KGQzLm1pbih4VmFscykudG9QcmVjaXNpb24oNCksIFwiIHRvIFwiLCBkMy5tYXgoeFZhbHMpLnRvUHJlY2lzaW9uKDQpKSk7XG4gICAgICAgIHBsb3RzdmcuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInggYnJ1c2hcIilcbiAgICAgICAgICAgIC5jYWxsKGJydXNoKVxuICAgICAgICAgICAgLnNlbGVjdEFsbChcInJlY3RcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGhlaWdodCk7XG4gICAgfVxuXG4gICAgLy8gYWRkIHogbGluZXMgYW5kIHNsaWRlcnMgc2V0eFxuICAgIGlmIChkaXYgPT0gXCIjc2V0eExlZnRcIikge1xuICAgICAgICBwbG90c3ZnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgXCJyYW5nZVwiKSAvLyB0aGlzIGlzIGJhZCBwcmFjdGljZSwgaWQgaXMgbm90IHVuaXF1ZVxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywneHZhbCcpXG4gICAgICAgICAgICAuYXR0cihcInhcIiwgMjUpXG4gICAgICAgICAgICAuYXR0cihcInlcIiwgaGVpZ2h0ICsgNDApXG4gICAgICAgICAgICAudGV4dCgoKSA9PiBcIng6IFwiLmNvbmNhdCgoK25vZGUubWVhbikudG9QcmVjaXNpb24oNCkpKTtcblxuICAgICAgICBwbG90c3ZnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgXCJyYW5nZTJcIikgLy8gdGhpcyBpcyBiYWQgcHJhY3RpY2UsIGlkIGlzIG5vdCB1bmlxdWVcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsJ3gxdmFsJylcbiAgICAgICAgICAgIC5hdHRyKFwieFwiLCAyNSlcbiAgICAgICAgICAgIC5hdHRyKFwieVwiLCBoZWlnaHQgKyA1MClcbiAgICAgICAgICAgIC50ZXh0KCBfID0+IHtcbiAgICAgICAgICAgICAgICAgIGxldCByZXR1cm52YWwgPSBcIngxOiBcIi5jb25jYXQoKCtub2RlLm1lYW4pLnRvUHJlY2lzaW9uKDQpKTtcbiAgICAgICAgICAgICAgIHJldHVybiByZXR1cm52YWx9KTtcbiAgICAgICAgXG5cbiAgICAgICAgLy8gY3JlYXRlIHRpY2sgbWFya3MgYXQgYWxsIHpzY29yZXMgaW4gdGhlIGJvdW5kcyBvZiB0aGUgZGF0YVxuICAgICAgICB2YXIgbGluZUZ1bmN0aW9uID0gZDMuc3ZnLmxpbmUoKVxuICAgICAgICAgICAgLngoZCA9PiBkLngpXG4gICAgICAgICAgICAueShkID0+IGQueSlcbiAgICAgICAgICAgIC5pbnRlcnBvbGF0ZShcImxpbmVhclwiKTtcblxuICAgICAgICB2YXIgY29sU2VxID0gW1wiI0EyQ0Q1QVwiLCBcIm9yYW5nZVwiLCBcInJlZFwiXTsgLy8gd2lsbCBjeWNsZSB0aHJvdWdoIGNvbG9yIHNlcXVlbmNlLCBhbmQgdGhlbiByZXBlYXQgbGFzdCBjb2xvclxuICAgICAgICB2YXIgbGluZURhdGEgPSBuZXcgQXJyYXk7XG5cbiAgICAgICAgdmFyIHpMb3dlciA9IC0xICogKGQzLm1pbih4VmFscykgLSBub2RlLm1lYW4pIC8gbm9kZS5zZDsgLy8genNjb3JlIG9mIGxvd2VyIGJvdW5kXG4gICAgICAgIHZhciB6VXBwZXIgPSAoZDMubWF4KHhWYWxzKSAtIG5vZGUubWVhbikgLyBub2RlLnNkOyAvLyB6c2NvcmUgb2YgdXBwZXIgYm91bmRcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHpVcHBlcjsgaSsrKSB7XG4gICAgICAgICAgICBsaW5lRGF0YSA9IFt7XG4gICAgICAgICAgICAgICAgXCJ4XCI6IHgoK25vZGUubWVhbiArIGkgKiBub2RlLnNkKSxcbiAgICAgICAgICAgICAgICBcInlcIjogaGVpZ2h0ICogLjdcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBcInhcIjogeCgrbm9kZS5tZWFuICsgaSAqIG5vZGUuc2QpLFxuICAgICAgICAgICAgICAgIFwieVwiOiBoZWlnaHQgKiAuOVxuICAgICAgICAgICAgfV07XG4gICAgICAgICAgICBwbG90c3ZnLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImRcIiwgbGluZUZ1bmN0aW9uKFtsaW5lRGF0YVswXSwgbGluZURhdGFbMV1dKSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInN0cm9rZVwiLCBjb2xTZXFbZDMubWluKFtpLCBjb2xTZXEubGVuZ3RoIC0gMV0pXSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInN0cm9rZS13aWR0aFwiLCAxLjUpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJmaWxsXCIsIFwibm9uZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgekxvd2VyOyBpKyspIHtcbiAgICAgICAgICAgIGxpbmVEYXRhID0gW3tcbiAgICAgICAgICAgICAgICBcInhcIjogeCgrbm9kZS5tZWFuIC0gaSAqIG5vZGUuc2QpLFxuICAgICAgICAgICAgICAgIFwieVwiOiBoZWlnaHQgKiAuN1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIFwieFwiOiB4KCtub2RlLm1lYW4gLSBpICogbm9kZS5zZCksXG4gICAgICAgICAgICAgICAgXCJ5XCI6IGhlaWdodCAqIC45XG4gICAgICAgICAgICB9XTtcbiAgICAgICAgICAgIHBsb3RzdmcuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiZFwiLCBsaW5lRnVuY3Rpb24oW2xpbmVEYXRhWzBdLCBsaW5lRGF0YVsxXV0pKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwic3Ryb2tlXCIsIGNvbFNlcVtkMy5taW4oW2ksIGNvbFNlcS5sZW5ndGggLSAxXSldKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwic3Ryb2tlLXdpZHRoXCIsIDEuNSlcbiAgICAgICAgICAgICAgICAuYXR0cihcImZpbGxcIiwgXCJub25lXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaW5pdGlhbGl6ZSBzbGlkZXIgY29tcG9uZW50c1xuICAgICAgICB2YXIgc2xpZGVCb3ggPSBwbG90c3ZnLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJ4IGF4aXNcIilcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsXCIgKyBoZWlnaHQgKiAuOCArIFwiKVwiKVxuICAgICAgICAgICAgLmNhbGwoZDMuc3ZnLmF4aXMoKVxuICAgICAgICAgICAgICAgICAgLnNjYWxlKHgpXG4gICAgICAgICAgICAgICAgICAudGlja3MoMClcbiAgICAgICAgICAgICAgICAgIC5vcmllbnQoXCJib3R0b21cIikpO1xuICAgICAgICB2YXIgc2xpZGVyID0gcGxvdHN2Zy5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwic2xpZGVyXCIpXG4gICAgICAgICAgICAuY2FsbChicnVzaCk7XG4gICAgICAgIHZhciBoYW5kbGUgPSBzbGlkZXIuYXBwZW5kKFwicG9seWdvblwiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImhhbmRsZVwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCxcIiArIGhlaWdodCAqIC43ICsgXCIpXCIpXG4gICAgICAgICAgICAuYXR0cihcInBvaW50c1wiLCBfID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgcyA9IDY7XG4gICAgICAgICAgICAgICAgbGV0IHhubSA9IG5vZGUuc2V0eHZhbHNbMF0gPT0gJycgPyB4KG5vZGUubWVhbikgOiB4KG5vZGUuc2V0eHZhbHNbMF0pO1xuICAgICAgICAgICAgICAgIHJldHVybiAoeG5tIC0gcykgKyBcIixcIiArICgtcykgKyBcIiBcIiArICh4bm0gKyBzKSArIFwiLFwiICsgKC1zKSArIFwiIFwiICsgeG5tICsgXCIsXCIgKyAocyAqIDEuMyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgdmFyIHNsaWRlcjIgPSBwbG90c3ZnLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJzbGlkZXJcIilcbiAgICAgICAgICAgIC5jYWxsKGJydXNoMik7XG4gICAgICAgIHZhciBoYW5kbGUyID0gc2xpZGVyMi5hcHBlbmQoXCJwb2x5Z29uXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiaGFuZGxlXCIpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLFwiICsgaGVpZ2h0ICogLjkgKyBcIilcIilcbiAgICAgICAgICAgIC5hdHRyKFwicG9pbnRzXCIsIF8gPT4ge1xuICAgICAgICAgICAgICAgIGxldCBzID0gNjtcbiAgICAgICAgICAgICAgICBsZXQgeG5tID0gbm9kZS5zZXR4dmFsc1sxXSA9PSAnJyA/IHgobm9kZS5tZWFuKSA6IHgobm9kZS5zZXR4dmFsc1sxXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh4bm0gLSBzKSArIFwiLFwiICsgcyArIFwiIFwiICsgKHhubSArIHMpICsgXCIsXCIgKyBzICsgXCIgXCIgKyB4bm0gKyBcIixcIiArICgtcyAqIDEuMyk7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBicnVzaGluZyBmdW5jdGlvbnNcbiAgICBmdW5jdGlvbiBicnVzaGVkKCkge1xuICAgICAgICBpZiAoZGl2ID09IFwiI3RhYjJcIikge1xuICAgICAgICAgICAgcGxvdHN2Zy5zZWxlY3QoXCJ0ZXh0I3JhbmdlXCIpXG4gICAgICAgICAgICAgICAgLnRleHQoKCkgPT4gYnJ1c2guZW1wdHkoKSA/XG4gICAgICAgICAgICAgICAgICAgIFwiUmFuZ2U6IFwiLmNvbmNhdChkMy5taW4oeFZhbHMpLnRvUHJlY2lzaW9uKDQpLCBcIiB0byBcIiwgZDMubWF4KHhWYWxzKS50b1ByZWNpc2lvbig0KSkgOlxuICAgICAgICAgICAgICAgICAgICBcIlJhbmdlOiBcIi5jb25jYXQoKGJydXNoLmV4dGVudCgpWzBdKS50b1ByZWNpc2lvbig0KSwgXCIgdG8gXCIsIChicnVzaC5leHRlbnQoKVsxXSkudG9QcmVjaXNpb24oNCkpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG5vZGUuc3Vic2V0cmFuZ2UgPSBicnVzaC5leHRlbnQoKVswXS50b1ByZWNpc2lvbig0KSAhPSBicnVzaC5leHRlbnQoKVsxXS50b1ByZWNpc2lvbig0KSA/XG4gICAgICAgICAgICAgICAgWyhicnVzaC5leHRlbnQoKVswXSkudG9QcmVjaXNpb24oNCksIChicnVzaC5leHRlbnQoKVsxXSkudG9QcmVjaXNpb24oNCldIDpcbiAgICAgICAgICAgICAgICBbXCJcIiwgXCJcIl07XG4gICAgICAgIH0gZWxzZSBpZiAoZGl2ID09IFwiI3NldHhMZWZ0XCIpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGJydXNoLmV4dGVudCgpWzBdO1xuICAgICAgICAgICAgdmFyIHMgPSA2O1xuICAgICAgICAgICAgaWYgKGQzLmV2ZW50LnNvdXJjZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB4LmludmVydChkMy5tb3VzZSh0aGlzKVswXSk7XG4gICAgICAgICAgICAgICAgYnJ1c2guZXh0ZW50KFt2YWx1ZSwgdmFsdWVdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc2V0IHggcG9zaXRpb24gb2Ygc2xpZGVyIGNlbnRlclxuICAgICAgICAgICAgdmFyIHhwb3MgPSB4KHZhbHVlKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA+IGQzLm1heCh4VmFscykpIHsgLy8gZHJhZ2dlZCBwYXN0IG1heFxuICAgICAgICAgICAgICAgIHhwb3MgPSB4KGQzLm1heCh4VmFscykpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA8IGQzLm1pbih4VmFscykpIHsgLy8gZHJhZ2dlZCBwYXN0IG1pblxuICAgICAgICAgICAgICAgIHhwb3MgPSB4KGQzLm1pbih4VmFscykpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgbSA9ICtub2RlLm1lYW47XG4gICAgICAgICAgICAgICAgdmFyIHNkID0gK25vZGUuc2Q7XG4gICAgICAgICAgICAgICAgdmFyIHpTY29yZSA9ICh2YWx1ZSAtIG0pIC8gc2Q7IC8vIHotc2NvcmVcbiAgICAgICAgICAgICAgICB2YXIgelJvdW5kID0gTWF0aC5yb3VuZCh6U2NvcmUpOyAvLyBuZWFyZXN0IGludGVnZXIgei1zY29yZVxuICAgICAgICAgICAgICAgIGlmICguMSA+IE1hdGguYWJzKHpSb3VuZCAtIHpTY29yZSkpIC8vIHNuYXAgdG8gaW50ZWdlciB6LXNjb3JlXG4gICAgICAgICAgICAgICAgICAgIHhwb3MgPSB4KG0gKyAoelJvdW5kICogc2QpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY3JlYXRlIHNsaWRlciBzeW1ib2wgYW5kIHRleHRcbiAgICAgICAgICAgIGhhbmRsZS5hdHRyKFwicG9pbnRzXCIsIF8gPT4gKHhwb3MgLSBzKSArIFwiLFwiICsgKC1zKSArIFwiIFwiICsgKHhwb3MgKyBzKSArIFwiLFwiICsgKC1zKSArIFwiIFwiICsgeHBvcyArIFwiLFwiICsgKHMgKiAxLjMpKTtcbiAgICAgICAgICAgIHBsb3Rzdmcuc2VsZWN0KFwidGV4dCNyYW5nZVwiKVxuICAgICAgICAgICAgLnRleHQoXyA9PiB7XG4gICAgICAgICAgICAgICAgICBsZXQgcmV0dXJudmFsID0gXCJ4OiBcIi5jb25jYXQoKGludngoeHBvcykpLnRvUHJlY2lzaW9uKDQpKTtcbiAgICAgICAgICAgICAgICAgIGxldCB4dmFsID0gaW52eCh4cG9zKS50b1ByZWNpc2lvbig0KTtcbiAgICAgICAgICAgICAgICAgIGxldCBteWNlbGwgPSBub2RlLm5hbWUrXCJGcm9tXCI7IC8vIGhhcmRjb2RlZCBoZXJlXG4gICAgICAgICAgICAgICAgICBpZihkb2N1bWVudC5nZXRFbGVtZW50QnlJZChteWNlbGwpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG15Y2VsbCkuaW5uZXJUZXh0PXh2YWw7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmV0dXJudmFsfSk7XG4gICAgICAgICAgICBub2RlLnNldHh2YWxzWzBdID0gKGludngoeHBvcykpLnRvUHJlY2lzaW9uKDQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2VydGFpbmx5IGEgbW9yZSBjbGV2ZXIgd2F5IHRvIGRvIHRoaXMsIGJ1dCBmb3Igbm93IGl0J3MgYmFzaWNhbGx5IGNvcGllZCB3aXRoIGJydXNoIGFuZCBoYW5kbGUgY2hhbmdlcyB0byBicnVzaDIgYW5kIGhhbmRsZTIgYW5kICNyYW5nZSB0byAjcmFuZ2UyIGFuZCBzZXR4dmFsc1swXSB0byBzZXR4dmFsc1sxXVxuICAgIGZ1bmN0aW9uIGJydXNoZWQyKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBicnVzaDIuZXh0ZW50KClbMF07XG4gICAgICAgIHZhciBzID0gNjsgLy8gc2NhbGluZyBmb3IgdHJpYW5nbGUgc2hhcGVcblxuICAgICAgICBpZiAoZDMuZXZlbnQuc291cmNlRXZlbnQpIHtcbiAgICAgICAgICAgIHZhbHVlID0geC5pbnZlcnQoZDMubW91c2UodGhpcylbMF0pO1xuICAgICAgICAgICAgYnJ1c2gyLmV4dGVudChbdmFsdWUsIHZhbHVlXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgeCBwb3NpdGlvbiBvZiBzbGlkZXIgY2VudGVyXG4gICAgICAgIHZhciB4cG9zID0geCh2YWx1ZSk7XG4gICAgICAgIGlmICh2YWx1ZSA+IGQzLm1heCh4VmFscykpIHsgLy8gZHJhZ2dlZCBwYXN0IG1heFxuICAgICAgICAgICAgeHBvcyA9IHgoZDMubWF4KHhWYWxzKSk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPCBkMy5taW4oeFZhbHMpKSB7IC8vIGRyYWdnZWQgcGFzdCBtaW5cbiAgICAgICAgICAgIHhwb3MgPSB4KGQzLm1pbih4VmFscykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG0gPSArbm9kZS5tZWFuO1xuICAgICAgICAgICAgdmFyIHNkID0gK25vZGUuc2Q7XG4gICAgICAgICAgICB2YXIgelNjb3JlID0gKHZhbHVlIC0gbSkgLyBzZDsgLy8gei1zY29yZVxuICAgICAgICAgICAgdmFyIHpSb3VuZCA9IE1hdGgucm91bmQoelNjb3JlKTsgLy8gbmVhcmVzdCBpbnRlZ2VyIHotc2NvcmVcbiAgICAgICAgICAgIGlmICguMSA+IE1hdGguYWJzKHpSb3VuZCAtIHpTY29yZSkpIC8vIHNuYXAgdG8gaW50ZWdlciB6LXNjb3JlXG4gICAgICAgICAgICAgICAgeHBvcyA9IHgobSArICh6Um91bmQgKiBzZCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JlYXRlIHNsaWRlciBzeW1ib2wgYW5kIHRleHRcbiAgICAgICAgaGFuZGxlMi5hdHRyKFwicG9pbnRzXCIsIF8gPT4gKHhwb3MgLSBzKSArIFwiLFwiICsgcyArIFwiIFwiICsgKHhwb3MgKyBzKSArIFwiLFwiICsgcyArIFwiIFwiICsgeHBvcyArIFwiLFwiICsgKC1zICogMS4zKSk7XG4gICAgICAgIHBsb3Rzdmcuc2VsZWN0KFwidGV4dCNyYW5nZTJcIilcbiAgICAgICAgLnRleHQoXyA9PiB7XG4gICAgICAgICAgICAgIGxldCByZXR1cm52YWwgPSBcIngxOiBcIi5jb25jYXQoKGludngoeHBvcykpLnRvUHJlY2lzaW9uKDQpKTtcbiAgICAgICAgICAgICAgbGV0IHgxdmFsID0gaW52eCh4cG9zKS50b1ByZWNpc2lvbig0KTtcbiAgICAgICAgICAgICAgbGV0IG15Y2VsbCA9IG5vZGUubmFtZStcIlRvXCI7IC8vIGhhcmRjb2RlZCBoZXJlXG4gICAgICAgICAgICAgIGlmKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG15Y2VsbCkpIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChteWNlbGwpLmlubmVyVGV4dD14MXZhbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmV0dXJudmFsfSk7XG4gICAgICAgIG5vZGUuc2V0eHZhbHNbMV0gPSAoaW52eCh4cG9zKSkudG9QcmVjaXNpb24oNCk7XG4gICAgICAgIFxuICAgICAgICBcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBiYXJzKG5vZGUsIGRpdiwgcHJpdikge1xuICAgIC8vIEhpc3RvZ3JhbSBzcGFjaW5nXG4gICAgdmFyIGJhclBhZGRpbmcgPSAuMDE1OyAvLyBTcGFjZSBiZXR3ZWVuIGJhcnNcbiAgICB2YXIgdG9wU2NhbGUgPSAxLjI7IC8vIE11bHRpcGxpY2F0aXZlIGZhY3RvciB0byBhc3NpZ24gc3BhY2UgYXQgdG9wIHdpdGhpbiBncmFwaCAtIGN1cnJlbnRseSByZW1vdmVkIGZyb20gaW1wbGVtZW50YXRpb25cbiAgICB2YXIgcGxvdFhheGlzID0gdHJ1ZTtcblxuICAgIC8vIERhdGFcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG5vZGUucGxvdHZhbHVlcyk7XG4gICAgdmFyIHlWYWxzID0gbmV3IEFycmF5O1xuICAgIHZhciBjaVVwcGVyVmFscyA9IG5ldyBBcnJheTtcbiAgICB2YXIgY2lMb3dlclZhbHMgPSBuZXcgQXJyYXk7XG4gICAgdmFyIGNpU2l6ZTtcblxuICAgIHZhciB4VmFscyA9IG5ldyBBcnJheTtcbiAgICB2YXIgeVZhbEtleSA9IG5ldyBBcnJheTtcblxuICAgIGlmIChub2RlLm5hdHVyZSA9PSBcIm5vbWluYWxcIikge1xuICAgICAgICB2YXIgeGkgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChub2RlLnBsb3R2YWx1ZXNba2V5c1tpXV0gPT0gMClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHlWYWxzW3hpXSA9IG5vZGUucGxvdHZhbHVlc1trZXlzW2ldXTtcbiAgICAgICAgICAgIHhWYWxzW3hpXSA9IHhpO1xuICAgICAgICAgICAgaWYgKHByaXYpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5wbG90dmFsdWVzQ0kpIHtcbiAgICAgICAgICAgICAgICAgICAgY2lMb3dlclZhbHNbeGldID0gbm9kZS5wbG90VmFsdWVzQ0kubG93ZXJCb3VuZFtrZXlzW2ldXTtcbiAgICAgICAgICAgICAgICAgICAgY2lVcHBlclZhbHNbeGldID0gbm9kZS5wbG90VmFsdWVzQ0kudXBwZXJCb3VuZFtrZXlzW2ldXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2lTaXplID0gY2lVcHBlclZhbHNbeGldIC0gY2lMb3dlclZhbHNbeGldO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgeVZhbEtleS5wdXNoKHtcbiAgICAgICAgICAgICAgICB5OiB5VmFsc1t4aV0sXG4gICAgICAgICAgICAgICAgeDoga2V5c1tpXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB4aSA9IHhpICsgMTtcbiAgICAgICAgfVxuICAgICAgICB5VmFsS2V5LnNvcnQoKGEsIGIpID0+IGIueSAtIGEueSk7IC8vIGFycmF5IG9mIG9iamVjdHMsIGVhY2ggb2JqZWN0IGhhcyB5LCB0aGUgc2FtZSBhcyB5VmFscywgYW5kIHgsIHRoZSBjYXRlZ29yeVxuICAgICAgICB5VmFscy5zb3J0KChhLCBiKSA9PiBiIC0gYSk7IC8vIGFycmF5IG9mIHkgdmFsdWVzLCB0aGUgaGVpZ2h0IG9mIHRoZSBiYXJzXG4gICAgICAgIGNpVXBwZXJWYWxzLnNvcnQoKGEsIGIpID0+IGIueSAtIGEueSk7IC8vID9cbiAgICAgICAgY2lMb3dlclZhbHMuc29ydCgoYSwgYikgPT4gYi55IC0gYS55KTsgLy8gP1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcInBsb3R2YWx1ZXMgaW4gYmFyc1wiKTtcbiAgICAgICAgICAgIHlWYWxzW2ldID0gbm9kZS5wbG90dmFsdWVzW2tleXNbaV1dO1xuICAgICAgICAgICAgeFZhbHNbaV0gPSBOdW1iZXIoa2V5c1tpXSk7XG4gICAgICAgICAgICBpZiAocHJpdikge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLnBsb3R2YWx1ZXNDSSkge1xuICAgICAgICAgICAgICAgICAgICBjaUxvd2VyVmFsc1tpXSA9IG5vZGUucGxvdHZhbHVlc0NJLmxvd2VyQm91bmRba2V5c1tpXV07XG4gICAgICAgICAgICAgICAgICAgIGNpVXBwZXJWYWxzW2ldID0gbm9kZS5wbG90dmFsdWVzQ0kudXBwZXJCb3VuZFtrZXlzW2ldXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2lTaXplID0gY2lVcHBlclZhbHNbaV0gLSBjaUxvd2VyVmFsc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICgoeVZhbHMubGVuZ3RoID4gMTUgJiBub2RlLm51bWNoYXIgPT0gXCJudW1lcmljXCIpIHx8ICh5VmFscy5sZW5ndGggPiA1ICYgbm9kZS5udW1jaGFyID09IFwiY2hhcmFjdGVyXCIpKVxuICAgICAgICBwbG90WGF4aXMgPSBmYWxzZTtcbiAgICB2YXIgbWF4WSA9IGQzLm1heCh5VmFscyk7IC8vIGluIHRoZSBmdXR1cmUsIHNldCBtYXhZIHRvIHRoZSB2YWx1ZSBvZiB0aGUgbWF4aW11bSBjb25maWRlbmNlIGxpbWl0XG4gICAgaWYgKHByaXYgJiYgbm9kZS5wbG90dmFsdWVzQ0kpIG1heFkgPSBkMy5tYXgoY2lVcHBlclZhbHMpO1xuICAgIHZhciBtaW5YID0gZDMubWluKHhWYWxzKTtcbiAgICB2YXIgbWF4WCA9IGQzLm1heCh4VmFscyk7XG5cbiAgICBsZXQgbXlkaXY7XG4gICAgaWYgKGRpdiA9PSBcInNldHhMZWZ0XCIpIG15ZGl2ID0gXCIjc2V0eExlZnRcIjtcbiAgICBlbHNlIGlmIChkaXYgPT0gXCJ2YXJTdW1tYXJ5XCIpIG15ZGl2ID0gXCIjdGFiM1wiO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGFsZXJ0KFwiRXJyb3I6IGluY29ycmVjdCBkaXYgc2VsZWN0ZWQgZm9yIHBsb3RzXCIpO1xuXG4gICAgdmFyIHRlbXBXaWR0aCA9IGQzLnNlbGVjdChteWRpdikuc3R5bGUoXCJ3aWR0aFwiKVxuICAgIHZhciB3aWR0aCA9IHRlbXBXaWR0aC5zdWJzdHJpbmcoMCwgKHRlbXBXaWR0aC5sZW5ndGggLSAyKSk7XG4gICAgdmFyIHRlbXBIZWlnaHQgPSBkMy5zZWxlY3QobXlkaXYpLnN0eWxlKFwiaGVpZ2h0XCIpXG4gICAgdmFyIGhlaWdodCA9IHRlbXBIZWlnaHQuc3Vic3RyaW5nKDAsICh0ZW1wSGVpZ2h0Lmxlbmd0aCAtIDIpKTtcblxuICAgIHZhciBtYXJnaW4gPSB7XG4gICAgICAgIHRvcDogMjAsXG4gICAgICAgIHJpZ2h0OiAyMCxcbiAgICAgICAgYm90dG9tOiA1MyxcbiAgICAgICAgbGVmdDogMTBcbiAgICB9O1xuICAgIGxldCB0dyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtYWluJykub2Zmc2V0V2lkdGg7XG5cbiAgICAvLyBOZWVkIHRvIGZpeCBhdXRvbWF0aWMgd2lkdGggYW5kIGhlaWdodCBzZXR0aW5ncyBmb3IgbGVmdHBhbmVsICgjdGFiMiwgI3RhYjMpXG4gICAgaWYgKG15ZGl2ID09IFwiI3RhYjNcIikge1xuICAgICAgICB3aWR0aCA9IDAuNyAqICh3aWR0aCAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0KTtcbiAgICAgICAgaGVpZ2h0ID0gMC4zICogKGhlaWdodCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tKTtcbiAgICB9IGVsc2UgaWYgKG15ZGl2ID09IFwiI3NldHhMZWZ0XCIpIHtcbiAgICAgICAgLy93aWR0aCA9IDIwMDtcbiAgICAgICAgLy9oZWlnaHQgPSAxMjA7XG4gICAgICAgIHdpZHRoPXR3Ki4xODUtbWFyZ2luLmxlZnQtbWFyZ2luLnJpZ2h0OyAvL3JpZ2h0cGFuZWwuZXhwYW5kIGlzIDQwIHBlcmNlbnQsIHNldHhMZWZ0IHRvIDUwIHBlcmNlbnQsIHRvZ2dsZSBiYXIgaXMgMTZweCwgcGFkZGluZywgaXQncyBhbGwgYWJvdXQgLjE4NVxuICAgICAgICBoZWlnaHQ9d2lkdGgqLjY7IC8vaGVpZ2h0IHRvIHdpZHRoIGlzIC42XG4gICAgfSBlbHNlIHtcbiAgICAgICAgd2lkdGggPSAwLjM1ICogKHdpZHRoIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQpO1xuICAgICAgICBoZWlnaHQgPSAwLjI1ICogKGhlaWdodCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tKTtcbiAgICB9O1xuXG4gICAgaWYgKHByaXYgJiYgbm9kZS5zdGFiaWxpdHlCaW4pIHtcbiAgICAgICAgdmFyIHggPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAgICAgLmRvbWFpbihbbWluWCAtIDAuNSwgbWF4WCArIDEuNV0pXG4gICAgICAgICAgICAucmFuZ2UoWzAsIHdpZHRoXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHggPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAgICAgLmRvbWFpbihbbWluWCAtIDAuNSwgbWF4WCArIDAuNV0pXG4gICAgICAgICAgICAucmFuZ2UoWzAsIHdpZHRoXSk7XG4gICAgfVxuXG4gICAgdmFyIGludnggPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAucmFuZ2UoW21pblggLSAwLjUsIG1heFggKyAwLjVdKVxuICAgICAgICAuZG9tYWluKFswLCB3aWR0aF0pO1xuXG4gICAgdmFyIHkgPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAuZG9tYWluKFswLCBtYXhZXSlcbiAgICAgICAgLnJhbmdlKFswLCBoZWlnaHRdKTtcblxuICAgIHZhciB4QXhpcyA9IGQzLnN2Zy5heGlzKClcbiAgICAgICAgLnNjYWxlKHgpXG4gICAgICAgIC50aWNrcyh5VmFscy5sZW5ndGgpXG4gICAgICAgIC5vcmllbnQoXCJib3R0b21cIik7XG5cbiAgICB2YXIgeUF4aXMgPSBkMy5zdmcuYXhpcygpXG4gICAgICAgIC5zY2FsZSh5KVxuICAgICAgICAub3JpZW50KFwibGVmdFwiKTtcblxuICAgIHZhciBicnVzaCA9IGQzLnN2Zy5icnVzaCgpXG4gICAgICAgIC54KHgpXG4gICAgICAgIC5leHRlbnQoKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUuc3Vic2V0cmFuZ2UubGVuZ3RoID09IDEgP1xuICAgICAgICAgICAgICAgIFtub2RlLnN1YnNldHJhbmdlWzBdLCBub2RlLnN1YnNldHJhbmdlWzBdXVxuICAgICAgICAgICAgICAgIDogbm9kZS5zdWJzZXRyYW5nZTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKFwiYnJ1c2hcIiwgYnJ1c2hlZCk7XG5cbiAgICB2YXIgYnJ1c2gyID0gZDMuc3ZnLmJydXNoKClcbiAgICAgICAgLngoeClcbiAgICAgICAgLm9uKFwiYnJ1c2hcIiwgYnJ1c2hlZDIpO1xuXG4gICAgLy8gQ3JlYXRlIFNWRyBlbGVtZW50XG4gICAgLy8gY3VtYmVyc29tZSB0byB0cmVhdCBcInRhYjNcIiBkaWZmZXJlbnRseSwgYnV0IHdvcmtzIGZvciBub3dcbiAgICAvLyB0YWIzLCBoYXMgYW4gaXNzdWUsIHRoYXQgdW5sZXNzIHdpZHRoIGhlaWdodCBoYXJkY29kZWQsIHRoZXkgZ3JvdyB3aXRoIGVhY2ggYWRkaXRpb25hbCBncmFwaC5cbiAgICBpZiAobXlkaXYgPT0gXCIjdGFiM1wiKSB7XG4gICAgICAgIHZhciBwbG90c3ZnID0gZDMuc2VsZWN0KG15ZGl2KVxuICAgICAgICAgICAgLnNlbGVjdEFsbChcInN2Z1wiKVxuICAgICAgICAgICAgLnJlbW92ZSgpO1xuXG4gICAgICAgIHZhciBwbG90c3ZnID0gZDMuc2VsZWN0KG15ZGl2KVxuICAgICAgICAgICAgLmFwcGVuZChcInN2Z1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCAoKSA9PiBub2RlLm5hbWUudG9TdHJpbmcoKS5jb25jYXQobXlkaXYuc3Vic3RyKDEpKSlcbiAgICAgICAgICAgIC5zdHlsZShcIndpZHRoXCIsIDMwMCkgLy9zZXR0aW5nIGhlaWdodCB0byB0aGUgaGVpZ2h0IG9mICNtYWluLmxlZnRcbiAgICAgICAgICAgIC5zdHlsZShcImhlaWdodFwiLCAyMDApXG4gICAgICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBtYXJnaW4ubGVmdCArIFwiLFwiICsgbWFyZ2luLnRvcCArIFwiKVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcGxvdHN2ZyA9IGQzLnNlbGVjdChteWRpdilcbiAgICAgICAgICAgIC5hcHBlbmQoXCJzdmdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIG15bmFtZSA9IG5vZGUubmFtZS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIG15bmFtZSA9IG15bmFtZS5yZXBsYWNlKC9cXCh8XFwpL2csIFwiXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBteW5hbWUuY29uY2F0KFwiX1wiLCBteWRpdi5zdWJzdHIoMSksIFwiX1wiLCBub2RlLmlkKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuc3R5bGUoXCJ3aWR0aFwiLCB3aWR0aCArIG1hcmdpbi5sZWZ0ICsgbWFyZ2luLnJpZ2h0KSAvL3NldHRpbmcgaGVpZ2h0IHRvIHRoZSBoZWlnaHQgb2YgI21haW4ubGVmdFxuICAgICAgICAgICAgLnN0eWxlKFwiaGVpZ2h0XCIsIGhlaWdodCArIG1hcmdpbi50b3AgKyBtYXJnaW4uYm90dG9tKVxuICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgbWFyZ2luLmxlZnQgKyBcIixcIiArIG1hcmdpbi50b3AgKyBcIilcIik7XG4gICAgfTtcblxuICAgIHZhciByZWN0V2lkdGggPSB4KG1pblggKyAwLjUgLSAyICogYmFyUGFkZGluZyk7IC8vdGhlIFwid2lkdGhcIiBpcyB0aGUgY29vcmRpbmF0ZSBvZiB0aGUgZW5kIG9mIHRoZSBmaXJzdCBiYXJcblxuICAgIHBsb3Rzdmcuc2VsZWN0QWxsKFwicmVjdFwiKVxuICAgICAgICAuZGF0YSh5VmFscylcbiAgICAgICAgLmVudGVyKClcbiAgICAgICAgLmFwcGVuZChcInJlY3RcIilcbiAgICAgICAgLmF0dHIoXCJ4XCIsIChkLCBpKSA9PiB4KHhWYWxzW2ldIC0gMC41ICsgYmFyUGFkZGluZykpXG4gICAgICAgIC5hdHRyKFwieVwiLCBkID0+IHkobWF4WSAtIGQpKVxuICAgICAgICAuYXR0cihcIndpZHRoXCIsIHJlY3RXaWR0aClcbiAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgeSlcbiAgICAgICAgLmF0dHIoXCJmaWxsXCIsIFwiIzFmNzdiNFwiKTtcblxuICAgIC8vIGRyYXcgZXJyb3IgYmFycywgdGhyZXNob2xkIGxpbmUgYW5kIGV4dHJhIGJpblxuICAgIGlmIChwcml2KSB7XG4gICAgICAgIGlmICh5VmFscy5sZW5ndGggPD0gMjApIHtcbiAgICAgICAgICAgIHBsb3Rzdmcuc2VsZWN0QWxsKFwibGluZVwiKVxuICAgICAgICAgICAgICAgIC5kYXRhKGNpVXBwZXJWYWxzKVxuICAgICAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAgICAgLmFwcGVuZChcImxpbmVcIilcbiAgICAgICAgICAgICAgICAuc3R5bGUoXCJzdHJva2VcIiwgXCJibGFja1wiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieDFcIiwgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geCh4VmFsc1tpXSAtIDAuNSArIGJhclBhZGRpbmcpICsgcmVjdFdpZHRoIC8gMlxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgIFx0LmF0dHIoXCJ5MVwiLCBkID0+IHkobWF4WSAtIGQpKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieDJcIiwgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geCh4VmFsc1tpXSAtIDAuNSArIGJhclBhZGRpbmcpICsgcmVjdFdpZHRoIC8gMlxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ5MlwiLCBkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHkyID0geShtYXhZIC0gZCArIGNpU2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB5MiA+PSB5KG1heFkpID8geShtYXhZKSA6IHkyO1xuICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy9kcmF3IHRvcCB0aWNrcyBvbiBlcnJvciBiYXJzXG4gICAgICAgICAgICAvL25lZWQgdG8gZml4IHRoZSBoZWlnaHQgb2YgdGhlIGdyYXBocyAtIHRoZSB0b3BzIG9mIGVycm9yIGJhcnMgYXJlIGdldHRpbmcgY3V0IG9mZlxuICAgICAgICAgICAgcGxvdHN2Zy5zZWxlY3RBbGwoXCIudG9wVGlja1wiKVxuICAgICAgICAgICAgICAgIC5kYXRhKGNpVXBwZXJWYWxzKVxuICAgICAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAgICAgLmFwcGVuZChcImxpbmVcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwidG9wVGlja1wiKVxuICAgICAgICAgICAgICAgIC5zdHlsZShcInN0cm9rZVwiLCBcImJsYWNrXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ4MVwiLCBmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh5VmFscy5sZW5ndGggPiAyMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHgoeFZhbHNbaV0gLSAwLjUgKyBiYXJQYWRkaW5nKSAvL21ha2UgdGljayBiaWdnZXIgdG8gaW5jcmVhc2UgdmlzaWJpbGl0eVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHgoeFZhbHNbaV0gLSAwLjUgKyBiYXJQYWRkaW5nKSArIDAuNCAqIHJlY3RXaWR0aFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInkxXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHkobWF4WSAtIGQpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ4MlwiLCBmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh5VmFscy5sZW5ndGggPiAyMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHgoeFZhbHNbaV0gLSAwLjUgKyBiYXJQYWRkaW5nKSArIHJlY3RXaWR0aCAvL21ha2UgdGljayBiaWdnZXIgdG8gaW5jcmVhc2UgdmlzaWJpbGl0eVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHgoeFZhbHNbaV0gLSAwLjUgKyBiYXJQYWRkaW5nKSArIDAuNiAqIHJlY3RXaWR0aFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInkyXCIsIGQgPT4geShtYXhZIC0gZCkpO1xuXG4gICAgICAgICAgICAvLyBkcmF3IGJvdHRvbSB0aWNrcyBvZiBlcnJvciBiYXJzXG4gICAgICAgICAgICBwbG90c3ZnLnNlbGVjdEFsbChcIi5ib3R0b21UaWNrXCIpXG4gICAgICAgICAgICAgICAgLmRhdGEoY2lMb3dlclZhbHMpXG4gICAgICAgICAgICAgICAgLmVudGVyKClcbiAgICAgICAgICAgICAgICAuYXBwZW5kKFwibGluZVwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJib3R0b21UaWNrXCIpXG4gICAgICAgICAgICAgICAgLnN0eWxlKFwic3Ryb2tlXCIsIFwiYmxhY2tcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcIngxXCIsIGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHlWYWxzLmxlbmd0aCA+IDIwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geCh4VmFsc1tpXSAtIDAuNSArIGJhclBhZGRpbmcpXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geCh4VmFsc1tpXSAtIDAuNSArIGJhclBhZGRpbmcpICsgMC40ICogcmVjdFdpZHRoXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieTFcIiwgZCA9PiB5KG1heFkgLSBkKSlcbiAgICAgICAgICAgICAgICAuYXR0cihcIngyXCIsIGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHlWYWxzLmxlbmd0aCA+IDIwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geCh4VmFsc1tpXSAtIDAuNSArIGJhclBhZGRpbmcpICsgcmVjdFdpZHRoXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geCh4VmFsc1tpXSAtIDAuNSArIGJhclBhZGRpbmcpICsgMC42ICogcmVjdFdpZHRoXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieTJcIiwgZCA9PiB5KG1heFkgLSBkKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwbG90c3ZnLnNlbGVjdEFsbChcIi5kZW5zZUVycm9yXCIpXG4gICAgICAgICAgICAgICAgLmRhdGEoeVZhbHMpXG4gICAgICAgICAgICAgICAgLmVudGVyKClcbiAgICAgICAgICAgICAgICAuYXBwZW5kKFwicmVjdFwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJkZW5zZUVycm9yXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIChkLCBpKSA9PiB4KHhWYWxzW2ldIC0gMC41ICsgYmFyUGFkZGluZykpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIGQgPT4geShtYXhZIC0gZCkgLSAuMSAqIHkoZCkpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCByZWN0V2lkdGgpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgZCA9PiAoeShtYXhZIC0gZCkgKyAuMSAqIHkoZCkpIC0gKHkobWF4WSAtIGQpIC0gLjEgKiB5KGQpKSlcbiAgICAgICAgICAgICAgICAuYXR0cihcImZpbGxcIiwgXCJzaWx2ZXJcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvL2lmIHN0YXRlbWVudCBmb3Igc3RhYmlsaXR5IGhpc3RvZ3JhbXNcbiAgICAgICAgLy9leHRyYSBzdGFiaWxpdHkgYmluXG4gICAgICAgIGlmIChub2RlLnN0YWJpbGl0eUJpbikge1xuICAgICAgICAgICAgcGxvdHN2Zy5hcHBlbmQoXCJyZWN0XCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIHgobWF4WCArIDAuNSAtIGJhclBhZGRpbmcpKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieVwiLCB5KG1heFkpIC0gbm9kZS5zdGFiaWxpdHlCaW4pXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCByZWN0V2lkdGgpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgbm9kZS5zdGFiaWxpdHlCaW4pXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJmaWxsXCIsIFwic2lsdmVyXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy90aHJlc2hvbGQgbGluZVxuICAgICAgICBpZiAobm9kZS50aHJlc2hvbGQpIHtcbiAgICAgICAgICAgIHBsb3RzdmcuYXBwZW5kKFwibGluZVwiKVxuICAgICAgICAgICAgICAgIC5zdHlsZShcInN0cm9rZVwiLCBcImJsYWNrXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ4MVwiLCB4KG1pblggLSAwLjUgKyBiYXJQYWRkaW5nKSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInkxXCIsIHkobWF4WSkgLSBub2RlLnRocmVzaG9sZClcbiAgICAgICAgICAgICAgICAuYXR0cihcIngyXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInN0YWJpbGl0eUJpblwiKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2cobm9kZS5zdGFiaWxpdHlCaW4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5zdGFiaWxpdHlCaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB4KG1heFggKyAwLjUgLSBiYXJQYWRkaW5nKSArIHJlY3RXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB4KG1heFggKyAwLjUgLSBiYXJQYWRkaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ5MlwiLCB5KG1heFkpIC0gbm9kZS50aHJlc2hvbGQpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocGxvdFhheGlzKSB7XG4gICAgICAgIHBsb3RzdmcuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInggYXhpc1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCxcIiArIGhlaWdodCArIFwiKVwiKVxuICAgICAgICAgICAgLmNhbGwoeEF4aXMpO1xuICAgIH1cblxuICAgIHBsb3RzdmcuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAuYXR0cihcInhcIiwgKHdpZHRoIC8gMikpXG4gICAgICAgIC5hdHRyKFwieVwiLCAwIC0gKG1hcmdpbi50b3AgLyAyKSlcbiAgICAgICAgLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKVxuICAgICAgICAuc3R5bGUoXCJmb250LXNpemVcIiwgXCIxMnB4XCIpXG4gICAgICAgIC50ZXh0KG5vZGUubmFtZSk7XG5cbiAgICBpZiAobXlkaXYgPT0gXCIjc2V0eExlZnRcIikge1xuICAgICAgICBwbG90c3ZnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgXCJyYW5nZVwiKSAvLyBiYWQgcHJhY3RpY2UsIG5vdCB1bmlxdWVcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsJ3h2YWwnKVxuICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIDI1KVxuICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIGhlaWdodCArIDQwKVxuICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubmF0dXJlID09PSBcIm5vbWluYWxcIikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IE1hdGgucm91bmQoeVZhbEtleS5sZW5ndGggLyAyKSAtIDE7XG4gICAgICAgICAgICAgICAgICAgIGxldCBteWNlbGwgPSBub2RlLm5hbWUrXCJGcm9tXCI7IC8vIGhhcmRjb2RlZCBoZXJlXG4gICAgICAgICAgICAgICAgICAgIGlmKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG15Y2VsbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG15Y2VsbCkuaW5uZXJUZXh0PXlWYWxLZXlbdF0ueDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFwieDogXCIgKyB5VmFsS2V5W3RdLngpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBteWNlbGwgPSBub2RlLm5hbWUrXCJGcm9tXCI7IC8vIGhhcmRjb2RlZCBoZXJlXG4gICAgICAgICAgICAgICAgICAgIGlmKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG15Y2VsbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG15Y2VsbCkuaW5uZXJUZXh0PSgrbm9kZS5tZWFuKS50b1ByZWNpc2lvbig0KS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoXCJ4OiBcIi5jb25jYXQoKCtub2RlLm1lYW4pLnRvUHJlY2lzaW9uKDQpLnRvU3RyaW5nKCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBwbG90c3ZnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgXCJyYW5nZTJcIikgLy9iYWQgcHJhY3RpY2UsIG5vdCB1bmlxdWVcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsJ3gxdmFsJylcbiAgICAgICAgICAgIC5hdHRyKFwieFwiLCAyNSlcbiAgICAgICAgICAgIC5hdHRyKFwieVwiLCBoZWlnaHQgKyA1MClcbiAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLm5hdHVyZSA9PT0gXCJub21pbmFsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBNYXRoLnJvdW5kKHlWYWxLZXkubGVuZ3RoIC8gMikgLSAxO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFwieDE6IFwiICsgeVZhbEtleVt0XS54KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFwieDE6IFwiLmNvbmNhdCgoK25vZGUubWVhbikudG9QcmVjaXNpb24oNCkudG9TdHJpbmcoKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGNyZWF0ZSB0aWNrIG1hcmtzIGF0IGFsbCB6c2NvcmVzIGluIHRoZSBib3VuZHMgb2YgdGhlIGRhdGFcbiAgICAgICAgdmFyIGxpbmVGdW5jdGlvbiA9IGQzLnN2Zy5saW5lKClcbiAgICAgICAgICAgIC54KGQgPT4gZC54KVxuICAgICAgICAgICAgLnkoZCA9PiBkLnkpXG4gICAgICAgICAgICAuaW50ZXJwb2xhdGUoXCJsaW5lYXJcIik7XG5cbiAgICAgICAgdmFyIGNvbFNlcSA9IFtcIiNBMkNENUFcIiwgXCJvcmFuZ2VcIiwgXCJyZWRcIl07IC8vIHdpbGwgY3ljbGUgdGhyb3VnaCBjb2xvciBzZXF1ZW5jZSwgYW5kIHRoZW4gcmVwZWF0IGxhc3QgY29sb3JcbiAgICAgICAgdmFyIGxpbmVEYXRhID0gbmV3IEFycmF5O1xuXG4gICAgICAgIHZhciB6TG93ZXIgPSAtMSAqIChtaW5YIC0gbm9kZS5tZWFuKSAvIG5vZGUuc2Q7IC8vIHpzY29yZSBvZiBsb3dlciBib3VuZFxuICAgICAgICB2YXIgelVwcGVyID0gKG1heFggLSBub2RlLm1lYW4pIC8gbm9kZS5zZDsgLy8genNjb3JlIG9mIHVwcGVyIGJvdW5kXG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB6VXBwZXI7IGkrKykge1xuICAgICAgICAgICAgbGluZURhdGEgPSBbe1xuICAgICAgICAgICAgICAgIFwieFwiOiB4KCtub2RlLm1lYW4gKyBpICogbm9kZS5zZCksXG4gICAgICAgICAgICAgICAgXCJ5XCI6IGhlaWdodCAqIC43XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgXCJ4XCI6IHgoK25vZGUubWVhbiArIGkgKiBub2RlLnNkKSxcbiAgICAgICAgICAgICAgICBcInlcIjogaGVpZ2h0ICogLjlcbiAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgcGxvdHN2Zy5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJkXCIsIGxpbmVGdW5jdGlvbihbbGluZURhdGFbMF0sIGxpbmVEYXRhWzFdXSkpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJzdHJva2VcIiwgY29sU2VxW2QzLm1pbihbaSwgY29sU2VxLmxlbmd0aCAtIDFdKV0pXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJzdHJva2Utd2lkdGhcIiwgMS41KVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiZmlsbFwiLCBcIm5vbmVcIik7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHpMb3dlcjsgaSsrKSB7XG4gICAgICAgICAgICBsaW5lRGF0YSA9IFt7XG4gICAgICAgICAgICAgICAgXCJ4XCI6IHgoK25vZGUubWVhbiAtIGkgKiBub2RlLnNkKSxcbiAgICAgICAgICAgICAgICBcInlcIjogaGVpZ2h0ICogLjdcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBcInhcIjogeCgrbm9kZS5tZWFuIC0gaSAqIG5vZGUuc2QpLFxuICAgICAgICAgICAgICAgIFwieVwiOiBoZWlnaHQgKiAuOVxuICAgICAgICAgICAgfV07XG4gICAgICAgICAgICBwbG90c3ZnLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImRcIiwgbGluZUZ1bmN0aW9uKFtsaW5lRGF0YVswXSwgbGluZURhdGFbMV1dKSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInN0cm9rZVwiLCBjb2xTZXFbZDMubWluKFtpLCBjb2xTZXEubGVuZ3RoIC0gMV0pXSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInN0cm9rZS13aWR0aFwiLCAxLjUpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJmaWxsXCIsIFwibm9uZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSBkMy5taW4oeFZhbHMpOyBpIDw9IGQzLm1heCh4VmFscyk7IGkrKykge1xuICAgICAgICAgICAgbGluZURhdGEgPSBbe1xuICAgICAgICAgICAgICAgIFwieFwiOiB4KGkpLFxuICAgICAgICAgICAgICAgIFwieVwiOiBoZWlnaHQgKiAuNzVcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBcInhcIjogeChpKSxcbiAgICAgICAgICAgICAgICBcInlcIjogaGVpZ2h0ICogLjg1XG4gICAgICAgICAgICB9XTtcbiAgICAgICAgICAgIHBsb3RzdmcuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiZFwiLCBsaW5lRnVuY3Rpb24oW2xpbmVEYXRhWzBdLCBsaW5lRGF0YVsxXV0pKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwic3Ryb2tlXCIsIFwiYmxhY2tcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcInN0cm9rZS13aWR0aFwiLCAxKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiZmlsbFwiLCBcIm5vbmVcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpbml0aWFsaXplIHNsaWRlciBjb21wb25lbnRzXG4gICAgICAgIHZhciBzbGlkZUJveCA9IHBsb3RzdmcuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInggYXhpc1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCxcIiArIGhlaWdodCAqIC44ICsgXCIpXCIpXG4gICAgICAgICAgICAuY2FsbChkMy5zdmcuYXhpcygpXG4gICAgICAgICAgICAgICAgICAuc2NhbGUoeClcbiAgICAgICAgICAgICAgICAgIC50aWNrcygwKVxuICAgICAgICAgICAgICAgICAgLm9yaWVudChcImJvdHRvbVwiKSk7XG5cbiAgICAgICAgdmFyIHNsaWRlciA9IHBsb3RzdmcuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInNsaWRlclwiKVxuICAgICAgICAgICAgLmNhbGwoYnJ1c2gpO1xuICAgICAgICB2YXIgc2xpZGVyMiA9IHBsb3RzdmcuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInNsaWRlclwiKVxuICAgICAgICAgICAgLmNhbGwoYnJ1c2gyKTtcblxuICAgICAgICBsZXQgcG9pbnRzID0gaSA9PiBkID0+IHtcbiAgICAgICAgICAgIGxldCB4bm0sIHMgPSA2O1xuICAgICAgICAgICAgaWYgKG5vZGUuc2V0eHZhbHNbaV0gPT0gJycpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBub21pbmFsLCB1c2UgdGhlIG1lZGlhbiBmcmVxdWVuY3kgYXMgdGhlIHBvc2l0aW9uIGZvciB0aGUgc2V0eCBzbGlkZXJcbiAgICAgICAgICAgICAgICB4bm0gPSBub2RlLm5hdHVyZSA9PSAnbm9taW5hbCcgPyB4KE1hdGgucm91bmQoeFZhbHMubGVuZ3RoIC8gMikgLSAxKSA6IHgobm9kZS5tZWFuKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgeG5tID0geChub2RlLnNldHh2YWxzW2ldKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gYCR7eG5tIC0gc30sJHstc30gJHt4bm0gKyBzfSwkey1zfSAke3hubX0sJHtzICogMS4zfWA7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBoYW5kbGUgPSBzbGlkZXIuYXBwZW5kKFwicG9seWdvblwiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImhhbmRsZVwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCxcIiArIGhlaWdodCAqIC43ICsgXCIpXCIpXG4gICAgICAgICAgICAuYXR0cihcInBvaW50c1wiLCBwb2ludHMoMCkpO1xuICAgICAgICB2YXIgaGFuZGxlMiA9IHNsaWRlcjIuYXBwZW5kKFwicG9seWdvblwiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImhhbmRsZVwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCxcIiArIGhlaWdodCAqIC45ICsgXCIpXCIpXG4gICAgICAgICAgICAuYXR0cihcInBvaW50c1wiLCBwb2ludHMoMSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHR3b1NGKHgpIHtcbiAgICAgICAgdmFyIHRzZiA9IGQzLmZvcm1hdChcIi4yclwiKTsgLy8gZm9ybWF0IHRvIHR3byBzaWduaWZpY2FudCBmaWd1cmVzIGFmdGVyIHRoZSBkZWNpbWFsIHBsYWNlXG4gICAgICAgIHJldHVybiB0c2YoeCkucmVwbGFjZSgvMCskLywgXCJcIikucmVwbGFjZSgvXFwuJC8sIFwiXCIpOyAvLyB0cmltIHRyYWlsaW5nIHplcm9zIGFmdGVyIGEgcGVyaW9kLCBhbmQgYW55IG9ycGhhbmVkIHBlcmlvZFxuICAgIH1cblxuICAgIC8vIGJydXNoaW5nIGZ1bmN0aW9uc1xuICAgIGZ1bmN0aW9uIGJydXNoZWQoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGJydXNoLmV4dGVudCgpWzBdO1xuICAgICAgICB2YXIgcyA9IDY7XG5cbiAgICAgICAgaWYgKGQzLmV2ZW50LnNvdXJjZUV2ZW50KSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHguaW52ZXJ0KGQzLm1vdXNlKHRoaXMpWzBdKTtcbiAgICAgICAgICAgIGJydXNoLmV4dGVudChbdmFsdWUsIHZhbHVlXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgeCBwb3NpdGlvbiBvZiBzbGlkZXIgY2VudGVyXG4gICAgICAgIHZhciB4cG9zID0geCh2YWx1ZSk7XG4gICAgICAgIGlmICh2YWx1ZSA+IG1heFgpIHsgLy8gZHJhZ2dlZCBwYXN0IG1heFxuICAgICAgICAgICAgeHBvcyA9IHgobWF4WCk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPCBtaW5YKSB7IC8vIGRyYWdnZWQgcGFzdCBtaW5cbiAgICAgICAgICAgIHhwb3MgPSB4KG1pblgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG0gPSArbm9kZS5tZWFuO1xuICAgICAgICAgICAgdmFyIHNkID0gK25vZGUuc2Q7XG4gICAgICAgICAgICB2YXIgelNjb3JlID0gKHZhbHVlIC0gbSkgLyBzZDsgLy8gei1zY29yZVxuICAgICAgICAgICAgdmFyIHpSb3VuZCA9IE1hdGgucm91bmQoelNjb3JlKTsgLy8gbmVhcmVzdCBpbnRlZ2VyIHotc2NvcmVcbiAgICAgICAgICAgIGlmICguMSA+IE1hdGguYWJzKE1hdGgucm91bmQodmFsdWUpIC0gdmFsdWUpKSB7IC8vIHNuYXAgdG8gaW50ZWdlclxuICAgICAgICAgICAgICAgIHhwb3MgPSB4KE1hdGgucm91bmQodmFsdWUpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoLjEgPiBNYXRoLmFicyh6Um91bmQgLSB6U2NvcmUpKSB7IC8vIHNuYXAgdG8gaW50ZWdlciB6LXNjb3JlXG4gICAgICAgICAgICAgICAgeHBvcyA9IHgobSArICh6Um91bmQgKiBzZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JlYXRlIHNsaWRlciBzeW1ib2wgYW5kIHRleHRcbiAgICAgICAgaGFuZGxlLmF0dHIoXCJwb2ludHNcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgcmV0dXJuICh4cG9zIC0gcykgKyBcIixcIiArICgtcykgKyBcIiBcIiArICh4cG9zICsgcykgKyBcIixcIiArICgtcykgKyBcIiBcIiArIHhwb3MgKyBcIixcIiArIChzICogMS4zKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHBsb3Rzdmcuc2VsZWN0KFwidGV4dCNyYW5nZVwiKVxuICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubmF0dXJlID09PSBcIm5vbWluYWxcIikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbXljZWxsID0gbm9kZS5uYW1lK1wiRnJvbVwiOyAvLyBoYXJkY29kZWQgaGVyZVxuICAgICAgICAgICAgICAgICAgICBpZihkb2N1bWVudC5nZXRFbGVtZW50QnlJZChteWNlbGwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChteWNlbGwpLmlubmVyVGV4dD15VmFsS2V5W01hdGgucm91bmQoaW52eCh4cG9zKSldLng7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcIng6IFwiICsgeVZhbEtleVtNYXRoLnJvdW5kKGludngoeHBvcykpXS54KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbXljZWxsID0gbm9kZS5uYW1lK1wiRnJvbVwiOyAvLyBoYXJkY29kZWQgaGVyZVxuICAgICAgICAgICAgICAgICAgICBpZihkb2N1bWVudC5nZXRFbGVtZW50QnlJZChteWNlbGwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChteWNlbGwpLmlubmVyVGV4dD0rKGludngoeHBvcykpLnRvUHJlY2lzaW9uKDQpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcIng6IFwiLmNvbmNhdCgrKGludngoeHBvcykpLnRvUHJlY2lzaW9uKDQpLnRvU3RyaW5nKCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgbm9kZS5zZXR4dmFsc1swXSA9ICsoaW52eCh4cG9zKSkudG9QcmVjaXNpb24oNCk7XG4gICAgfVxuXG4gICAgLy8gY2VydGFpbmx5IGEgbW9yZSBjbGV2ZXIgd2F5IHRvIGRvIHRoaXMsIGJ1dCBmb3Igbm93IGl0J3MgYmFzaWNhbGx5IGNvcGllZCB3aXRoIGJydXNoIGFuZCBoYW5kbGUgY2hhbmdlcyB0byBicnVzaDIgYW5kIGhhbmRsZTIgYW5kICNyYW5nZSB0byAjcmFuZ2UyIGFuZCBzZXR4dmFsc1swXSB0byBzZXR4dmFsc1sxXVxuICAgIGZ1bmN0aW9uIGJydXNoZWQyKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBicnVzaDIuZXh0ZW50KClbMF07XG4gICAgICAgIHZhciBzID0gNjsgLy8gc2NhbGluZyBmb3IgdHJpYW5nbGUgc2hhcGVcblxuICAgICAgICBpZiAoZDMuZXZlbnQuc291cmNlRXZlbnQpIHtcbiAgICAgICAgICAgIHZhbHVlID0geC5pbnZlcnQoZDMubW91c2UodGhpcylbMF0pO1xuICAgICAgICAgICAgYnJ1c2gyLmV4dGVudChbdmFsdWUsIHZhbHVlXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgeCBwb3NpdGlvbiBvZiBzbGlkZXIgY2VudGVyXG4gICAgICAgIHZhciB4cG9zID0geCh2YWx1ZSk7XG4gICAgICAgIGlmICh2YWx1ZSA+IG1heFgpIHsgLy8gZHJhZ2dlZCBwYXN0IG1heFxuICAgICAgICAgICAgeHBvcyA9IHgobWF4WCk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPCBtaW5YKSB7IC8vIGRyYWdnZWQgcGFzdCBtaW5cbiAgICAgICAgICAgIHhwb3MgPSB4KG1pblgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG0gPSArbm9kZS5tZWFuO1xuICAgICAgICAgICAgdmFyIHNkID0gK25vZGUuc2Q7XG4gICAgICAgICAgICB2YXIgelNjb3JlID0gKHZhbHVlIC0gbSkgLyBzZDsgLy8gei1zY29yZVxuICAgICAgICAgICAgdmFyIHpSb3VuZCA9IE1hdGgucm91bmQoelNjb3JlKTsgLy8gbmVhcmVzdCBpbnRlZ2VyIHotc2NvcmVcbiAgICAgICAgICAgIGlmICguMSA+IE1hdGguYWJzKE1hdGgucm91bmQodmFsdWUpIC0gdmFsdWUpKSB7IC8vIHNuYXAgdG8gaW50ZWdlclxuICAgICAgICAgICAgICAgIHhwb3MgPSB4KE1hdGgucm91bmQodmFsdWUpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoLjEgPiBNYXRoLmFicyh6Um91bmQgLSB6U2NvcmUpKSB7IC8vIHNuYXAgdG8gaW50ZWdlciB6LXNjb3JlXG4gICAgICAgICAgICAgICAgeHBvcyA9IHgobSArICh6Um91bmQgKiBzZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JlYXRlIHNsaWRlciBzeW1ib2wgYW5kIHRleHRcbiAgICAgICAgaGFuZGxlMi5hdHRyKFwicG9pbnRzXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHJldHVybiAoeHBvcyAtIHMpICsgXCIsXCIgKyBzICsgXCIgXCIgKyAoeHBvcyArIHMpICsgXCIsXCIgKyBzICsgXCIgXCIgKyB4cG9zICsgXCIsXCIgKyAoLXMgKiAxLjMpO1xuICAgICAgICB9KTtcbiAgICAgICAgcGxvdHN2Zy5zZWxlY3QoXCJ0ZXh0I3JhbmdlMlwiKVxuICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubmF0dXJlID09PSBcIm5vbWluYWxcIikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbXljZWxsID0gbm9kZS5uYW1lK1wiVG9cIjsgLy8gaGFyZGNvZGVkIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgaWYoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobXljZWxsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobXljZWxsKS5pbm5lclRleHQ9eVZhbEtleVtNYXRoLnJvdW5kKGludngoeHBvcykpXS54O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoXCJ4MTogXCIgKyB5VmFsS2V5W01hdGgucm91bmQoaW52eCh4cG9zKSldLngpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBteWNlbGwgPSBub2RlLm5hbWUrXCJUb1wiOyAvLyBoYXJkY29kZWQgaGVyZVxuICAgICAgICAgICAgICAgICAgICBpZihkb2N1bWVudC5nZXRFbGVtZW50QnlJZChteWNlbGwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChteWNlbGwpLmlubmVyVGV4dD0rKGludngoeHBvcykpLnRvUHJlY2lzaW9uKDQpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcIngxOiBcIi5jb25jYXQoKyhpbnZ4KHhwb3MpKS50b1ByZWNpc2lvbig0KS50b1N0cmluZygpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIG5vZGUuc2V0eHZhbHNbMV0gPSArKGludngoeHBvcykpLnRvUHJlY2lzaW9uKDQpO1xuICAgIH1cbn1cblxuLy8gZHJhd3MgYmFycGxvdHMgaW4gc3Vic2V0IHRhYlxuZXhwb3J0IGZ1bmN0aW9uIGJhcnNTdWJzZXQobm9kZSkge1xuICAgIC8vIGlmIHVudG91Y2hlZCwgc2V0IG5vZGUuc3Vic2V0cmFuZ2UgdG8gYW4gZW1wdHkgYXJyYXksIG1lYW5pbmcgYWxsIHZhbHVlcyBzZWxlY3RlZCBieSBkZWZhdWx0XG4gICAgaWYgKG5vZGUuc3Vic2V0cmFuZ2VbMF0gPT0gXCJcIiAmIG5vZGUuc3Vic2V0cmFuZ2VbMV0gPT0gXCJcIikge1xuICAgICAgICBub2RlLnN1YnNldHJhbmdlID0gW107XG4gICAgfVxuXG4gICAgLy8gSGlzdG9ncmFtIHNwYWNpbmdcbiAgICB2YXIgYmFyUGFkZGluZyA9IC4wMTU7IC8vIFNwYWNlIGJldHdlZW4gYmFyc1xuICAgIHZhciB0b3BTY2FsZSA9IDEuMjsgLy8gTXVsdGlwbGljYXRpdmUgZmFjdG9yIHRvIGFzc2lnbiBzcGFjZSBhdCB0b3Agd2l0aGluIGdyYXBoIC0gY3VycmVudGx5IHJlbW92ZWQgZnJvbSBpbXBsZW1lbnRhdGlvblxuICAgIHZhciBwbG90WGF4aXMgPSB0cnVlO1xuXG4gICAgLy8gVmFyaWFibGUgbmFtZVxuICAgIHZhciBteW5hbWUgPSBub2RlLm5hbWUudG9TdHJpbmcoKTtcbiAgICBteW5hbWUgPSBteW5hbWUucmVwbGFjZSgvXFwofFxcKS9nLCBcIlwiKTtcblxuICAgIC8vIERhdGFcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG5vZGUucGxvdHZhbHVlcyk7XG4gICAgdmFyIHlWYWxzID0gbmV3IEFycmF5O1xuICAgIHZhciB4VmFscyA9IG5ldyBBcnJheTtcbiAgICB2YXIgeVZhbEtleSA9IG5ldyBBcnJheTtcblxuICAgIHZhciB4aSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChub2RlLnBsb3R2YWx1ZXNba2V5c1tpXV0gPT0gMClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB5VmFsc1t4aV0gPSBub2RlLnBsb3R2YWx1ZXNba2V5c1tpXV07XG4gICAgICAgIHhWYWxzW3hpXSA9IHhpO1xuICAgICAgICB5VmFsS2V5LnB1c2goe1xuICAgICAgICAgICAgeTogeVZhbHNbeGldLFxuICAgICAgICAgICAgeDoga2V5c1tpXVxuICAgICAgICB9KTtcbiAgICAgICAgeGkgPSB4aSArIDE7XG4gICAgfVxuICAgIGlmIChub2RlLm5hdHVyZSA9PT0gXCJub21pbmFsXCIpIHsgLy8gaWYgbm9taW5hbCwgb3JkZXJzIGJhcnMgbGVmdCB0byByaWdodCwgaGlnaGVzdCBmcmVxdWVuY3kgdG8gbG93ZXN0XG4gICAgICAgIHlWYWxLZXkuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYi55IC0gYS55XG4gICAgICAgIH0pOyAvLyBhcnJheSBvZiBvYmplY3RzLCBlYWNoIG9iamVjdCBoYXMgeSwgdGhlIHNhbWUgYXMgeVZhbHMsIGFuZCB4LCB0aGUgY2F0ZWdvcnlcbiAgICAgICAgeVZhbHMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYiAtIGFcbiAgICAgICAgfSk7IC8vIGFycmF5IG9mIHkgdmFsdWVzLCB0aGUgaGVpZ2h0IG9mIHRoZSBiYXJzXG4gICAgfVxuXG4gICAgcGxvdFhheGlzID0gZmFsc2U7XG5cbiAgICB2YXIgbWF4WSA9IGQzLm1heCh5VmFscyk7XG4gICAgdmFyIG1pblggPSBkMy5taW4oeFZhbHMpO1xuICAgIHZhciBtYXhYID0gZDMubWF4KHhWYWxzKTtcbiAgICB2YXIgZ25hbWUgPSBbXCJzdWJzZXR5ZXNcIiwgXCJzdWJzZXRub1wiXTtcblxuICAgIHZhciB5VmFsczIgPSBbXTtcbiAgICB2YXIgeVZhbHMxID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IHlWYWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHlWYWxzMS5wdXNoKHtcbiAgICAgICAgICAgIHkwOiBtYXhZIC0geVZhbHNbaV0sXG4gICAgICAgICAgICB5MTogeVZhbHNbaV0sXG4gICAgICAgICAgICBjb2w6IGQzQ29sb3JcbiAgICAgICAgfSk7XG4gICAgICAgIHlWYWxzMi5wdXNoKHtcbiAgICAgICAgICAgIHkwOiAwLFxuICAgICAgICAgICAgeTE6IG1heFkgLSB5VmFsc1tpXSxcbiAgICAgICAgICAgIGNvbDogXCJ0cmFuc3BhcmVudFwiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgZnJlcXMgPSBbeVZhbHMxLCB5VmFsczJdO1xuXG4gICAgLy8geTAgaXMgdGhlIHN0YXJ0aW5nIHBvaW50XG4gICAgLy8geTEgaXMgdGhlIGxlbmd0aCBvZiB0aGUgYmFyXG5cbiAgICB2YXIgbXlkaXYgPSBcIiN0YWIyXCI7XG4gICAgdmFyIHdpZHRoID0gMjAwO1xuICAgIHZhciBoZWlnaHQgPSAxMjA7XG4gICAgdmFyIG1hcmdpbiA9IHtcbiAgICAgICAgdG9wOiAyMCxcbiAgICAgICAgcmlnaHQ6IDIwLFxuICAgICAgICBib3R0b206IDUzLFxuICAgICAgICBsZWZ0OiA1MFxuICAgIH07XG5cbiAgICB2YXIgeCA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgIC5kb21haW4oW21pblggLSAwLjUsIG1heFggKyAwLjVdKVxuICAgICAgICAucmFuZ2UoWzAsIHdpZHRoXSk7XG5cbiAgICB2YXIgaW52eCA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgIC5yYW5nZShbbWluWCAtIDAuNSwgbWF4WCArIDAuNV0pXG4gICAgICAgIC5kb21haW4oWzAsIHdpZHRoXSk7XG5cbiAgICB2YXIgeSA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgIC5kb21haW4oWzAsIG1heFldKVxuICAgICAgICAucmFuZ2UoWzAsIGhlaWdodF0pO1xuXG4gICAgdmFyIHhBeGlzID0gZDMuc3ZnLmF4aXMoKVxuICAgICAgICAuc2NhbGUoeClcbiAgICAgICAgLnRpY2tzKHlWYWxzLmxlbmd0aClcbiAgICAgICAgLm9yaWVudChcImJvdHRvbVwiKTtcblxuICAgIHZhciB5QXhpcyA9IGQzLnN2Zy5heGlzKClcbiAgICAgICAgLnNjYWxlKHkpXG4gICAgICAgIC5vcmllbnQoXCJsZWZ0XCIpO1xuXG4gICAgLy9DcmVhdGUgU1ZHIGVsZW1lbnRcbiAgICB2YXIgcGxvdHN2ZyA9IGQzLnNlbGVjdChteWRpdilcbiAgICAgICAgLmFwcGVuZChcInN2Z1wiKVxuICAgICAgICAuYXR0cihcImlkXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG15bmFtZS5jb25jYXQoXCJfXCIsIG15ZGl2LnN1YnN0cigxKSwgXCJfXCIsIG5vZGUuaWQpO1xuICAgICAgICB9KVxuICAgICAgICAuc3R5bGUoXCJ3aWR0aFwiLCB3aWR0aCArIG1hcmdpbi5sZWZ0ICsgbWFyZ2luLnJpZ2h0KSAvL3NldHRpbmcgaGVpZ2h0IHRvIHRoZSBoZWlnaHQgb2YgI21haW4ubGVmdFxuICAgICAgICAuc3R5bGUoXCJoZWlnaHRcIiwgaGVpZ2h0ICsgbWFyZ2luLnRvcCArIG1hcmdpbi5ib3R0b20pXG4gICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgbWFyZ2luLmxlZnQgKyBcIixcIiArIG1hcmdpbi50b3AgKyBcIilcIik7XG5cbiAgICB2YXIgZnJlcSA9IHBsb3Rzdmcuc2VsZWN0QWxsKFwiZy5mcmVxXCIpXG4gICAgICAgIC5kYXRhKGZyZXFzKVxuICAgICAgICAuZW50ZXIoKS5hcHBlbmQoXCJnXCIpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJmcmVxXCIpXG4gICAgICAgIC5hdHRyKFwibmFtZVwiLCBmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4gbXluYW1lLmNvbmNhdChnbmFtZVtpXSk7XG4gICAgICAgIH0pO1xuXG4gICAgdmFyIHJlY3QgPSBmcmVxLnNlbGVjdEFsbChcInJlY3RcIilcbiAgICAgICAgLmRhdGEoT2JqZWN0KVxuICAgICAgICAuZW50ZXIoKS5hcHBlbmQoXCJyZWN0XCIpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJiYXJcIilcbiAgICAgICAgLmF0dHIoXCJuYW1lXCIsIGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiB4VmFsc1tpXTtcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoXCJ4XCIsIGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiB4KHhWYWxzW2ldIC0gMC41ICsgYmFyUGFkZGluZyk7XG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKFwieVwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICByZXR1cm4geShkLnkwKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCB4KG1pblggKyAwLjUgLSAyICogYmFyUGFkZGluZykpIC8vIHRoZSBcIndpZHRoXCIgaXMgdGhlIGNvb3JkaW5hdGUgb2YgdGhlIGVuZCBvZiB0aGUgZmlyc3QgYmFyXG4gICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHJldHVybiB5KGQueTEpO1xuICAgICAgICB9KVxuICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgIGlmIChub2RlLnN1YnNldHJhbmdlLmxlbmd0aCA+IDAgJiBkLmNvbCA9PT0gZDNDb2xvciAmICQuaW5BcnJheSh4VmFsc1tpXS50b1N0cmluZygpLCBub2RlLnN1YnNldHJhbmdlKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbFZhckNvbG9yO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZC5jb2w7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdE1lID0gdGhpcztcbiAgICAgICAgICAgIHZhciBzZWxlY3ROYW1lID0gdGhpcy5nZXRBdHRyaWJ1dGUoXCJuYW1lXCIpO1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50Tm9kZS5nZXRBdHRyaWJ1dGUoXCJuYW1lXCIpID09IG15bmFtZS5jb25jYXQoXCJzdWJzZXRub1wiKSkge1xuICAgICAgICAgICAgICAgIHNlbGVjdE1lID0gJCgnW25hbWU9XCInICsgbXluYW1lLmNvbmNhdChcInN1YnNldHllc1wiKSArICdcIl0nKS5jaGlsZHJlbignW25hbWU9XCInICsgc2VsZWN0TmFtZSArICdcIl0nKVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGQzLnNlbGVjdChzZWxlY3RNZSlcbiAgICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG15Q29sID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc3R5bGUuZmlsbCA9PT0gc2VsVmFyQ29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBteWluZGV4ID0gbm9kZS5zdWJzZXRyYW5nZS5pbmRleE9mKHRoaXMuZ2V0QXR0cmlidXRlKFwibmFtZVwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnN1YnNldHJhbmdlLnNwbGljZShteWluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG15Q29sID0gZDNDb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc3Vic2V0cmFuZ2UucHVzaCh0aGlzLmdldEF0dHJpYnV0ZShcIm5hbWVcIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbXlDb2wgPSBzZWxWYXJDb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbXlDb2w7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwbG90c3ZnLnNlbGVjdChcInRleHQjc2VsZWN0cmFuZ2VcIilcbiAgICAgICAgICAgICAgICAudGV4dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuc3Vic2V0cmFuZ2UubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoXCJTZWxlY3RlZDogYWxsIHZhbHVlc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gbm9kZS5zdWJzZXRyYW5nZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZWxlY3RlZHMgPSBuZXcgQXJyYXk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhLmZvckVhY2goZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRzLnB1c2goeVZhbEtleVt2YWxdLngpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoXCJTZWxlY3RlZDogXCIgKyBzZWxlY3RlZHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSlcbiAgICAgICAgLm9uKFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGkgPSB0aGlzLmdldEF0dHJpYnV0ZShcIm5hbWVcIik7XG4gICAgICAgICAgICBwbG90c3ZnLnNlbGVjdChcInRleHQjbXltb3VzZW92ZXJcIilcbiAgICAgICAgICAgICAgICAudGV4dCgoKSA9PiB5VmFsS2V5W2ldLnggKyBcIjogXCIgKyB5VmFsS2V5W2ldLnkpO1xuICAgICAgICB9KVxuICAgICAgICAub24oXCJtb3VzZW91dFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpID0gdGhpcy5nZXRBdHRyaWJ1dGUoXCJuYW1lXCIpO1xuICAgICAgICAgICAgcGxvdHN2Zy5zZWxlY3QoXCJ0ZXh0I215bW91c2VvdmVyXCIpXG4gICAgICAgICAgICAgICAgLnRleHQoKCkgPT4gXCJWYWx1ZTogRnJlcXVlbmN5XCIpO1xuICAgICAgICB9KTtcblxuICAgIGlmIChwbG90WGF4aXMpIHtcbiAgICAgICAgcGxvdHN2Zy5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwieCBheGlzXCIpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLFwiICsgaGVpZ2h0ICsgXCIpXCIpXG4gICAgICAgICAgICAuY2FsbCh4QXhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcGxvdHN2Zy5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsIFwibXltb3VzZW92ZXJcIilcbiAgICAgICAgICAgIC5hdHRyKFwieFwiLCAyNSlcbiAgICAgICAgICAgIC5hdHRyKFwieVwiLCBoZWlnaHQgKyAyMClcbiAgICAgICAgICAgIC50ZXh0KCgpID0+IFwiVmFsdWU6IEZyZXF1ZW5jeVwiKTtcbiAgICB9XG5cbiAgICBwbG90c3ZnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgLmF0dHIoXCJ4XCIsICh3aWR0aCAvIDIpKVxuICAgICAgICAuYXR0cihcInlcIiwgMCAtIChtYXJnaW4udG9wIC8gMikpXG4gICAgICAgIC5hdHRyKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIilcbiAgICAgICAgLnN0eWxlKFwiZm9udC1zaXplXCIsIFwiMTJweFwiKVxuICAgICAgICAudGV4dChteW5hbWUpO1xuXG4gICAgcGxvdHN2Zy5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgIC5hdHRyKFwiaWRcIiwgXCJzZWxlY3RyYW5nZVwiKVxuICAgICAgICAuYXR0cihcInhcIiwgMjUpXG4gICAgICAgIC5hdHRyKFwieVwiLCBoZWlnaHQgKyA0MClcbiAgICAgICAgLnRleHQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKG5vZGUuc3Vic2V0cmFuZ2UubGVuZ3RoID09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiU2VsZWN0ZWQ6IGFsbCB2YWx1ZXNcIjtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZHMgPSBuZXcgQXJyYXk7XG4gICAgICAgICAgICBub2RlLnN1YnNldHJhbmdlLmZvckVhY2godmFsID0+ICBzZWxlY3RlZHMucHVzaCh5VmFsS2V5W3ZhbF0ueCkpO1xuICAgICAgICAgICAgcmV0dXJuIFwiU2VsZWN0ZWQ6IFwiICsgc2VsZWN0ZWRzO1xuICAgICAgICB9KTtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gZGVuc2l0eU5vZGUobm9kZSwgb2JqKSB7XG4gICAgdmFyIG15bmFtZSA9IG5vZGUubmFtZS50b1N0cmluZygpLmNvbmNhdChcIm5vZGVwbG90XCIpO1xuXG4gICAgaWYgKHR5cGVvZiBvYmogPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdmFyIG9iaiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG5vZGUubmFtZS50b1N0cmluZygpICsgXCJiaWdncm91cFwiKTtcbiAgICAgICAgLy8gaWYgb2JqIGNvbnRhaW5zIGFuIHN2ZyBlbGVtZW50LCByZW1vdmUgaXQuIHRoaXMgcmVtb3ZlcyBhbnkgcGxvdCBpbnNpZGUgdGhlIG5vZGVcbiAgICAgICAgaWYgKGQzLnNlbGVjdChvYmopLnNlbGVjdEFsbChcInN2Z1wiKVswXS5sZW5ndGggPiAwKVxuICAgICAgICAgICAgZDMuc2VsZWN0KG9iaikuc2VsZWN0QWxsKFwic3ZnXCIpLnJlbW92ZSgpO1xuICAgIH1cblxuICAgIHZhciB5VmFscyA9IG5vZGUucGxvdHk7XG4gICAgdmFyIHhWYWxzID0gbm9kZS5wbG90eDtcbiAgICAvLyBhcnJheSBvZiBvYmplY3RzXG4gICAgbGV0IGRhdGEyID0gbm9kZS5wbG90eC5tYXAoKHgsIGkpID0+ICh7eDogK3gsIHk6ICtub2RlLnBsb3R5W2ldfSkpO1xuXG4gICAgdmFyIHdpZHRoID0gNjA7IC8vIGhhcmRjb2RlZCwgc2hvdWxkIGJlIHNldCBhdXRvbWF0aWNhbGx5XG4gICAgdmFyIGhlaWdodCA9IDMwO1xuICAgIHZhciBtYXJnaW4gPSB7XG4gICAgICAgIHRvcDogMjAsXG4gICAgICAgIHJpZ2h0OiAxMCxcbiAgICAgICAgYm90dG9tOiA1MyxcbiAgICAgICAgbGVmdDogMTBcbiAgICB9O1xuXG4gICAgdmFyIHggPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAuZG9tYWluKFtkMy5taW4oeFZhbHMpLCBkMy5tYXgoeFZhbHMpXSlcbiAgICAgICAgLnJhbmdlKFswLCB3aWR0aF0pO1xuXG4gICAgdmFyIHkgPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAuZG9tYWluKFtkMy5taW4oeVZhbHMpLCBkMy5tYXgoeVZhbHMpXSlcbiAgICAgICAgLnJhbmdlKFtoZWlnaHQsIDBdKTtcblxuICAgIHZhciBhcmVhID0gZDMuc3ZnLmFyZWEoKVxuICAgICAgICAuaW50ZXJwb2xhdGUoXCJtb25vdG9uZVwiKVxuICAgICAgICAueChkID0+IHgoZC54KSlcbiAgICAgICAgLnkwKGhlaWdodClcbiAgICAgICAgLnkxKGQgPT4geShkLnkpKTtcblxuICAgIHZhciBwbG90c3ZnID0gZDMuc2VsZWN0KG9iailcbiAgICAgICAgLmluc2VydChcInN2Z1wiLCBcIjpmaXJzdC1jaGlsZFwiKVxuICAgICAgICAuYXR0cihcInhcIiwgLTQwKSAvLyBOT1RFOiBOb3Qgc3VyZSBleGFjdGx5IHdoeSB0aGVzZSBudW1iZXJzIHdvcmssIGJ1dCB0aGVzZSBoYXJkY29kZWQgdmFsdWVzIHNlZW0gdG8gcG9zaXRpb24gdGhlIHBsb3QgaW5zaWRlIGcgY29ycmVjdGx5LiAgdGhpcyBzaG91bGRuJ3QgYmUgaGFyZGNvZGVkIGluIHRoZSBmdXR1cmVcbiAgICAgICAgLmF0dHIoXCJ5XCIsIC00NSlcbiAgICAgICAgLmF0dHIoXCJpZFwiLCAoKSA9PiBteW5hbWUpXG4gICAgICAgIC5zdHlsZShcIndpZHRoXCIsIHdpZHRoKVxuICAgICAgICAuc3R5bGUoXCJoZWlnaHRcIiwgaGVpZ2h0KVxuICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIG1hcmdpbi5sZWZ0ICsgXCIsXCIgKyBtYXJnaW4udG9wICsgXCIpXCIpO1xuXG4gICAgcGxvdHN2Zy5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgIC5kYXR1bShkYXRhMilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImFyZWFcIilcbiAgICAgICAgLmF0dHIoXCJkXCIsIGFyZWEpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYmFyc05vZGUobm9kZSwgb2JqKSB7XG4gICAgdmFyIG15bmFtZSA9IG5vZGUubmFtZS50b1N0cmluZygpLmNvbmNhdChcIm5vZGVwbG90XCIpO1xuXG4gICAgaWYgKHR5cGVvZiBvYmogPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdmFyIG9iaiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG5vZGUubmFtZS50b1N0cmluZygpICsgXCJiaWdncm91cFwiKTtcbiAgICAgICAgLy8gaWYgb2JqIGNvbnRhaW5zIGFuIHN2ZyBlbGVtZW50LCByZW1vdmUgaXQuIHRoaXMgcmVtb3ZlcyBhbnkgcGxvdCBpbnNpZGUgdGhlIG5vZGVcbiAgICAgICAgaWYgKGQzLnNlbGVjdChvYmopLnNlbGVjdEFsbChcInN2Z1wiKVswXS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBkMy5zZWxlY3Qob2JqKS5zZWxlY3RBbGwoXCJzdmdcIikucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBIaXN0b2dyYW0gc3BhY2luZ1xuICAgIHZhciBiYXJQYWRkaW5nID0gLjAxNTsgLy8gU3BhY2UgYmV0d2VlbiBiYXJzXG4gICAgdmFyIHRvcFNjYWxlID0gMS4yOyAvLyBNdWx0aXBsaWNhdGl2ZSBmYWN0b3IgdG8gYXNzaWduIHNwYWNlIGF0IHRvcCB3aXRoaW4gZ3JhcGggLSBjdXJyZW50bHkgcmVtb3ZlZCBmcm9tIGltcGxlbWVudGF0aW9uXG5cbiAgICAvLyBEYXRhXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhub2RlLnBsb3R2YWx1ZXMpO1xuICAgIHZhciB5VmFscyA9IG5ldyBBcnJheTtcbiAgICB2YXIgeFZhbHMgPSBuZXcgQXJyYXk7XG4gICAgdmFyIHlWYWxLZXkgPSBuZXcgQXJyYXk7XG5cbiAgICBpZiAobm9kZS5uYXR1cmUgPT09IFwibm9taW5hbFwiKSB7XG4gICAgICAgIHZhciB4aSA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKG5vZGUucGxvdHZhbHVlc1trZXlzW2ldXSA9PSAwKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgeVZhbHNbeGldID0gbm9kZS5wbG90dmFsdWVzW2tleXNbaV1dO1xuICAgICAgICAgICAgeFZhbHNbeGldID0geGk7XG4gICAgICAgICAgICB5VmFsS2V5LnB1c2goe3k6IHlWYWxzW3hpXSwgeDoga2V5c1tpXX0pO1xuICAgICAgICAgICAgeGkgPSB4aSArIDE7XG4gICAgICAgIH1cbiAgICAgICAgeVZhbEtleS5zb3J0KChhLCBiKSA9PiBiLnkgLSBhLnkpOyAvLyBhcnJheSBvZiBvYmplY3RzLCBlYWNoIG9iamVjdCBoYXMgeSwgdGhlIHNhbWUgYXMgeVZhbHMsIGFuZCB4LCB0aGUgY2F0ZWdvcnlcbiAgICAgICAgeVZhbHMuc29ydCgoYSwgYikgPT4gYiAtIGEpOyAvLyBhcnJheSBvZiB5IHZhbHVlcywgdGhlIGhlaWdodCBvZiB0aGUgYmFyc1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgeVZhbHNbaV0gPSBub2RlLnBsb3R2YWx1ZXNba2V5c1tpXV07XG4gICAgICAgICAgICB4VmFsc1tpXSA9IE51bWJlcihrZXlzW2ldKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBtYXhZID0gZDMubWF4KHlWYWxzKTtcbiAgICB2YXIgbWluWCA9IGQzLm1pbih4VmFscyk7XG4gICAgdmFyIG1heFggPSBkMy5tYXgoeFZhbHMpO1xuXG4gICAgdmFyIHdpZHRoID0gNjA7XG4gICAgdmFyIGhlaWdodCA9IDMwO1xuICAgIHZhciBtYXJnaW4gPSB7XG4gICAgICAgIHRvcDogMjAsXG4gICAgICAgIHJpZ2h0OiAxMCxcbiAgICAgICAgYm90dG9tOiA1MyxcbiAgICAgICAgbGVmdDogMTBcbiAgICB9O1xuXG4gICAgdmFyIHggPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAuZG9tYWluKFttaW5YIC0gMC41LCBtYXhYICsgMC41XSlcbiAgICAgICAgLnJhbmdlKFswLCB3aWR0aF0pO1xuXG4gICAgdmFyIGludnggPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAucmFuZ2UoW21pblggLSAwLjUsIG1heFggKyAwLjVdKVxuICAgICAgICAuZG9tYWluKFswLCB3aWR0aF0pO1xuXG4gICAgdmFyIHkgPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAuZG9tYWluKFswLCBtYXhZXSlcbiAgICAgICAgLnJhbmdlKFswLCBoZWlnaHRdKTtcblxuICAgIC8vQ3JlYXRlIFNWRyBlbGVtZW50XG4gICAgdmFyIHBsb3RzdmcgPSBkMy5zZWxlY3Qob2JqKVxuICAgICAgICAuaW5zZXJ0KFwic3ZnXCIsIFwiOmZpcnN0LWNoaWxkXCIpXG4gICAgICAgIC5hdHRyKFwieFwiLCAtNDApXG4gICAgICAgIC5hdHRyKFwieVwiLCAtNDUpXG4gICAgICAgIC5hdHRyKFwiaWRcIiwgKCkgPT4gbXluYW1lKVxuICAgICAgICAuc3R5bGUoXCJ3aWR0aFwiLCB3aWR0aCkgLy8gc2V0IGhlaWdodCB0byB0aGUgaGVpZ2h0IG9mICNtYWluLmxlZnRcbiAgICAgICAgLnN0eWxlKFwiaGVpZ2h0XCIsIGhlaWdodClcbiAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBtYXJnaW4ubGVmdCArIFwiLFwiICsgbWFyZ2luLnRvcCArIFwiKVwiKTtcblxuICAgIHBsb3Rzdmcuc2VsZWN0QWxsKFwicmVjdFwiKVxuICAgICAgICAuZGF0YSh5VmFscylcbiAgICAgICAgLmVudGVyKClcbiAgICAgICAgLmFwcGVuZChcInJlY3RcIilcbiAgICAgICAgLmF0dHIoXCJ4XCIsIChkLCBpKSA9PiAgeCh4VmFsc1tpXSAtIDAuNSArIGJhclBhZGRpbmcpKVxuICAgICAgICAuYXR0cihcInlcIiwgZCA9PiAgeShtYXhZIC0gZCkpXG4gICAgICAgIC5hdHRyKFwid2lkdGhcIiwgeChtaW5YICsgMC41IC0gMiAqIGJhclBhZGRpbmcpKSAvLyB0aGUgXCJ3aWR0aFwiIGlzIHRoZSBjb29yZGluYXRlIG9mIHRoZSBlbmQgb2YgdGhlIGZpcnN0IGJhclxuICAgICAgICAuYXR0cihcImhlaWdodFwiLCB5KVxuICAgICAgICAuYXR0cihcImZpbGxcIiwgXCIjMWY3N2I0XCIpO1xufVxuXG5cblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYXNzZXRzL2FwcC9wbG90cy5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2\n')},function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.searchIndex = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mithril = __webpack_require__(0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _app = __webpack_require__(1);\n\nvar app = _interopRequireWildcard(_app);\n\nvar _plots = __webpack_require__(2);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar searchIndex = exports.searchIndex = void 0;\n\nvar search = function search(val) {\n    var all = app.allNodes;\n    if (val === '') {\n        exports.searchIndex = searchIndex = null;\n        return app.valueKey = all.map(function (n) {\n            return n.name;\n        });\n    }\n\n    var matches = [],\n        others = [],\n        match = function match(n, key) {\n        return n[key].toLowerCase().includes(val.toLowerCase());\n    };\n\n    all.forEach(function (n) {\n        return match(n, 'name') || match(n, 'labl') ? matches.push(n) : others.push(n);\n    });\n    exports.searchIndex = searchIndex = matches.length;\n    app.valueKey = matches.concat(others).map(function (n) {\n        return n.name;\n    });\n};\n\nvar Search = function () {\n    function Search() {\n        _classCallCheck(this, Search);\n    }\n\n    _createClass(Search, [{\n        key: 'view',\n        value: function view(vnode) {\n            vnode.attrs.oninput = _mithril2.default.withAttr('value', search);\n            return (0, _mithril2.default)('input#searchvar.form-control[style=margin-bottom: 5px; width: 100%]', vnode.attrs);\n        }\n    }]);\n\n    return Search;\n}();\n\nexports.default = Search;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvYXBwL3ZpZXdzL1NlYXJjaC5qcz8xMzc4Il0sIm5hbWVzIjpbImFwcCIsInNlYXJjaEluZGV4Iiwic2VhcmNoIiwiYWxsIiwiYWxsTm9kZXMiLCJ2YWwiLCJ2YWx1ZUtleSIsIm1hcCIsIm4iLCJuYW1lIiwibWF0Y2hlcyIsIm90aGVycyIsIm1hdGNoIiwia2V5IiwidG9Mb3dlckNhc2UiLCJpbmNsdWRlcyIsImZvckVhY2giLCJwdXNoIiwibGVuZ3RoIiwiY29uY2F0IiwiU2VhcmNoIiwidm5vZGUiLCJhdHRycyIsIm9uaW5wdXQiLCJ3aXRoQXR0ciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7Ozs7QUFFQTs7SUFBWUEsRzs7QUFDWjs7Ozs7Ozs7QUFFTyxJQUFJQywwQ0FBSjs7QUFFUCxJQUFJQyxTQUFTLFNBQVRBLE1BQVMsTUFBTztBQUNoQixRQUFJQyxNQUFNSCxJQUFJSSxRQUFkO0FBQ0EsUUFBSUMsUUFBUSxFQUFaLEVBQWdCO0FBQ1osZ0JBTEdKLFdBS0gsaUJBQWMsSUFBZDtBQUNBLGVBQU9ELElBQUlNLFFBQUosR0FBZUgsSUFBSUksR0FBSixDQUFRO0FBQUEsbUJBQUtDLEVBQUVDLElBQVA7QUFBQSxTQUFSLENBQXRCO0FBQ0g7O0FBTGUsUUFNWEMsT0FOVyxHQU1nQixFQU5oQjtBQUFBLFFBTUZDLE1BTkUsR0FNb0IsRUFOcEI7QUFBQSxRQU1NQyxLQU5OLEdBTXdCLFNBQWxCQSxLQUFrQixDQUFDSixDQUFELEVBQUlLLEdBQUo7QUFBQSxlQUFZTCxFQUFFSyxHQUFGLEVBQU9DLFdBQVAsR0FBcUJDLFFBQXJCLENBQThCVixJQUFJUyxXQUFKLEVBQTlCLENBQVo7QUFBQSxLQU54Qjs7QUFPaEJYLFFBQUlhLE9BQUosQ0FBWTtBQUFBLGVBQUtKLE1BQU1KLENBQU4sRUFBUyxNQUFULEtBQW9CSSxNQUFNSixDQUFOLEVBQVMsTUFBVCxDQUFwQixHQUF1Q0UsUUFBUU8sSUFBUixDQUFhVCxDQUFiLENBQXZDLEdBQXlERyxPQUFPTSxJQUFQLENBQVlULENBQVosQ0FBOUQ7QUFBQSxLQUFaO0FBQ0EsWUFWT1AsV0FVUCxpQkFBY1MsUUFBUVEsTUFBdEI7QUFDQWxCLFFBQUlNLFFBQUosR0FBZUksUUFDVlMsTUFEVSxDQUNIUixNQURHLEVBRVZKLEdBRlUsQ0FFTjtBQUFBLGVBQUtDLEVBQUVDLElBQVA7QUFBQSxLQUZNLENBQWY7QUFHSCxDQVpEOztJQWNNVyxNOzs7Ozs7OzZCQUNHQyxLLEVBQU87QUFDUkEsa0JBQU1DLEtBQU4sQ0FBWUMsT0FBWixHQUFzQixrQkFBRUMsUUFBRixDQUFXLE9BQVgsRUFBb0J0QixNQUFwQixDQUF0QjtBQUNBLG1CQUFPLHVCQUFFLHFFQUFGLEVBQXlFbUIsTUFBTUMsS0FBL0UsQ0FBUDtBQUNIOzs7Ozs7a0JBR1VGLE0iLCJmaWxlIjoiMy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuXG5pbXBvcnQgKiBhcyBhcHAgZnJvbSAnLi4vYXBwJztcbmltcG9ydCB7c2VsVmFyQ29sb3J9IGZyb20gJy4uL3Bsb3RzJztcblxuZXhwb3J0IGxldCBzZWFyY2hJbmRleDtcblxubGV0IHNlYXJjaCA9IHZhbCA9PiB7XG4gICAgbGV0IGFsbCA9IGFwcC5hbGxOb2RlcztcbiAgICBpZiAodmFsID09PSAnJykge1xuICAgICAgICBzZWFyY2hJbmRleCA9IG51bGw7XG4gICAgICAgIHJldHVybiBhcHAudmFsdWVLZXkgPSBhbGwubWFwKG4gPT4gbi5uYW1lKTtcbiAgICB9XG4gICAgbGV0IFttYXRjaGVzLCBvdGhlcnMsIG1hdGNoXSA9IFtbXSwgW10sIChuLCBrZXkpID0+IG5ba2V5XS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHZhbC50b0xvd2VyQ2FzZSgpKV07XG4gICAgYWxsLmZvckVhY2gobiA9PiBtYXRjaChuLCAnbmFtZScpIHx8IG1hdGNoKG4sICdsYWJsJykgPyBtYXRjaGVzLnB1c2gobikgOiBvdGhlcnMucHVzaChuKSk7XG4gICAgc2VhcmNoSW5kZXggPSBtYXRjaGVzLmxlbmd0aDtcbiAgICBhcHAudmFsdWVLZXkgPSBtYXRjaGVzXG4gICAgICAgIC5jb25jYXQob3RoZXJzKVxuICAgICAgICAubWFwKG4gPT4gbi5uYW1lKTtcbn07XG5cbmNsYXNzIFNlYXJjaCB7XG4gICAgdmlldyh2bm9kZSkge1xuICAgICAgICB2bm9kZS5hdHRycy5vbmlucHV0ID0gbS53aXRoQXR0cigndmFsdWUnLCBzZWFyY2gpO1xuICAgICAgICByZXR1cm4gbSgnaW5wdXQjc2VhcmNodmFyLmZvcm0tY29udHJvbFtzdHlsZT1tYXJnaW4tYm90dG9tOiA1cHg7IHdpZHRoOiAxMDAlXScsIHZub2RlLmF0dHJzKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNlYXJjaDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Fzc2V0cy9hcHAvdmlld3MvU2VhcmNoLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3\n")},function(module,exports){eval('var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function("return this")() || (1,eval)("this");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === "object")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it\'s\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzPzM2OTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUMiLCJmaWxlIjoiNC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBnO1xyXG5cclxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcclxuZyA9IChmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufSkoKTtcclxuXHJcbnRyeSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXHJcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLGV2YWwpKFwidGhpc1wiKTtcclxufSBjYXRjaChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZih0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKVxyXG5cdFx0ZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4\n')},function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\nexports.linechart = linechart;\nexports.explore = explore;\n\nvar _mithril = __webpack_require__(0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _app = __webpack_require__(1);\n\nvar app = _interopRequireWildcard(_app);\n\nvar _plots = __webpack_require__(2);\n\nvar plots = _interopRequireWildcard(_plots);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar $private = false;\n\nfunction heatmap(x_Axis_name, y_Axis_name) {\n    d3.select("#heatChart").select("svg").remove();\n    $(\'#heatchart\').html("");\n\n    var margin_heat = { top: 30, right: 10, bottom: 60, left: 60 },\n        width_heat = 500 - margin_heat.left - margin_heat.right,\n        height_heat = 300 - margin_heat.top - margin_heat.bottom;\n    var padding = 100;\n\n    var min_x = d3.min(data_plot, function (d, i) {\n        return data_plot[i].xaxis;\n    });\n    var max_x = d3.max(data_plot, function (d, i) {\n        return data_plot[i].xaxis;\n    });\n    var avg_x = (max_x - min_x) / 100;\n    var min_y = d3.min(data_plot, function (d, i) {\n        return data_plot[i].yaxis;\n    });\n    var max_y = d3.max(data_plot, function (d, i) {\n        return data_plot[i].yaxis;\n    });\n    var avg_y = (max_y - min_y) / 100;\n\n    var x = d3.scale.linear().domain([min_x - avg_x, max_x + avg_x]).range([0, width_heat]);\n\n    var y = d3.scale.linear().domain([min_y - avg_y, max_y + avg_y]).range([height_heat, 0]);\n\n    var z = d3.scale.linear().range(["#EF9A9A", "#EF5350"]);\n\n    // This could be inferred from the data if it weren\'t sparse.\n    var xStep = avg_x + 0.1,\n        yStep = avg_y + 0.2;\n    var svg_heat = d3.select("#heatchart").append("svg").attr("width", width_heat + margin_heat.left + margin_heat.right).attr("height", height_heat + margin_heat.top + margin_heat.bottom).append("g").attr("transform", "translate(" + margin_heat.left + "," + margin_heat.top + ")").style("background-color", "#FFEBEE");\n\n    // Compute the scale domains.\n    x.domain(d3.extent(data_plot, function (d, i) {\n        return data_plot[i].xaxis;\n    }));\n    y.domain(d3.extent(data_plot, function (d, i) {\n        return data_plot[i].yaxis;\n    }));\n    z.domain([0, d3.max(data_plot, function (d, i) {\n        return data_plot[i].score;\n    })]);\n\n    // Extend the x- and y-domain to fit the last bucket.\n    // For example, the y-bucket 3200 corresponds to values [3200, 3300].\n    x.domain([x.domain()[0], +x.domain()[1] + xStep]);\n    y.domain([y.domain()[0], y.domain()[1] + yStep]);\n\n    // Display the tiles for each non-zero bucket.\n    // See http://bl.ocks.org/3074470 for an alternative implementation.\n    svg_heat.selectAll(".tile").data(data_plot).enter().append("rect").attr("class", "tile").attr("x", function (d, i) {\n        return x(data_plot[i].xaxis);\n    }).attr("y", function (d, i) {\n        return y(data_plot[i].yaxis + yStep);\n    }).attr("width", 15).attr("height", 15).attr("dx", ".35em").attr("dy", ".35em").style("fill", function (d, i) {\n        return z(data_plot[i].score);\n    });\n\n    svg_heat.append("text").attr("class", "label").attr("x", width_heat + 20).attr("y", 10).attr("dy", ".35em").text("Count");\n\n    // Add an x-axis with label.\n    svg_heat.append("g").attr("class", "x axis").attr("transform", "translate(0," + height_heat + ")").call(d3.svg.axis().scale(x).ticks(5).tickSize(-height_heat).orient("bottom")).append("text").attr("class", "label").attr("x", width_heat).attr("y", -6).attr("text-anchor", "end").text("");\n\n    // Add a y-axis with label.\n    svg_heat.append("g").attr("class", "y axis").call(d3.svg.axis().scale(y).tickSize(-width_heat).orient("left")).append("text").attr("class", "label").attr("y", 6).attr("dy", ".71em").attr("text-anchor", "end").attr("transform", "rotate(-90)").text("");\n\n    svg_heat.append("text").attr("text-anchor", "middle") // this makes it easy to centre the text as the transform is applied to the anchor\n    .attr("transform", "translate(-40," + height_heat / 2 + ")rotate(-90)") // text is drawn off the screen top left, move down and out and rotate\n    .text(y_Axis_name).style("fill", "#424242").style("text-indent", "20px").style("font-size", "12px").style("font-weight", "bold");\n\n    svg_heat.append("text").attr("text-anchor", "middle") // this makes it easy to centre the text as the transform is applied to the anchor\n    .attr("transform", "translate(" + width_heat / 2 + "," + (height_heat + padding / 4) + ")") // centre below axis\n    .text(x_Axis_name).style("fill", "#424242").style("text-indent", "20px").style("font-size", "12px").style("font-weight", "bold");\n}\nvar data_plot = [];\n\nfunction bivariatePlot(x_Axis, y_Axis, x_Axis_name, y_Axis_name) {\n    app.byId(\'scatterplot\').style.display = \'block\';\n    app.byId(\'NAcount\').style.display = \'block\';\n    d3.select("#scatterplot").html("");\n    d3.select("#scatterplot").select("svg").remove();\n\n    app.byId(\'linechart\').style.display = \'none\';\n    d3.select("#heatchart").select("svg").remove();\n    d3.select("#linechart").select("svg").remove();\n    d3.select("#linechart").html("");\n    d3.select("#heatchart").html("");\n    // $("#NAcount").html("");\n\n    console.log("bivariate plot called");\n    // scatter plot\n\n    data_plot = [];\n    var nanCount = 0;\n    for (var i = 0; i < 1000; i++) {\n        if (isNaN(x_Axis[i]) || isNaN(y_Axis[i])) {\n            nanCount++;\n        } else {\n            var newNumber1 = x_Axis[i];\n            var newNumber2 = y_Axis[i];\n            data_plot.push({ xaxis: newNumber1, yaxis: newNumber2, score: Math.random() * 100 });\n        }\n    }\n\n    var margin = { top: 20, right: 15, bottom: 40, left: 60 },\n        width = 500 - margin.left - margin.right,\n        height = 280 - margin.top - margin.bottom,\n        padding = 100;\n\n    var min_x = d3.min(data_plot, function (_, i) {\n        return data_plot[i].xaxis;\n    });\n    var max_x = d3.max(data_plot, function (_, i) {\n        return data_plot[i].xaxis;\n    });\n    var avg_x = (max_x - min_x) / 10;\n    var min_y = d3.min(data_plot, function (d, i) {\n        return data_plot[i].yaxis;\n    });\n    var max_y = d3.max(data_plot, function (d, i) {\n        return data_plot[i].yaxis;\n    });\n    var avg_y = (max_y - min_y) / 10;\n\n    var xScale = d3.scale.linear().domain([min_x - avg_x, max_x + avg_x]).range([0, width]);\n\n    var yScale = d3.scale.linear().domain([min_y - avg_y, max_y + avg_y]).range([height, 0]);\n\n    var xAxis = d3.svg.axis().scale(xScale).orient(\'bottom\').tickSize(-height);\n\n    var yAxis = d3.svg.axis().scale(yScale).orient(\'left\').ticks(5).tickSize(-width);\n\n    var zoom = d3.behavior.zoom().x(xScale).y(yScale).scaleExtent([1, 10]).on("zoom", zoomed);\n\n    var chart_scatter = d3.select(\'#scatterplot\').append(\'svg:svg\').attr(\'width\', width + margin.right + margin.left).attr(\'height\', height + margin.top + margin.bottom).call(zoom);\n\n    var main1 = chart_scatter.append(\'g\').attr(\'transform\', \'translate(\' + margin.left + \',\' + margin.top + \')\').attr(\'width\', width + margin.right + margin.left).attr(\'height\', height + margin.top + margin.bottom).attr(\'class\', \'main\');\n\n    main1.append(\'g\').attr(\'transform\', \'translate(0,\' + height + \')\').attr(\'class\', \'x axis\').call(xAxis);\n\n    main1.append(\'g\').attr(\'transform\', \'translate(0,0)\').attr(\'class\', \'y axis\').call(yAxis);\n\n    var clip = main1.append("defs").append("svg:clipPath").attr("id", "clip").append("svg:rect").attr("id", "clip-rect").attr("x", "0").attr("y", "0").attr(\'width\', width).attr(\'height\', height);\n\n    main1.append("g").attr("clip-path", "url(#clip)").selectAll("circle").data(data_plot).enter().append("circle").attr("cx", function (d, i) {\n        return xScale(data_plot[i].xaxis);\n    }).attr("cy", function (d, i) {\n        return yScale(data_plot[i].yaxis);\n    }).attr("r", 2).style("fill", "#B71C1C");\n    chart_scatter.append("text").attr("text-anchor", "middle") // this makes it easy to centre the text as the transform is applied to the anchor\n    .attr("transform", "translate(" + padding / 5 + "," + height / 2 + ")rotate(-90)") // text is drawn off the screen top left, move down and out and rotate\n    .text(y_Axis_name).style("fill", "#424242").style("text-indent", "20px").style("font-size", "12px").style("font-weight", "bold");\n\n    chart_scatter.append("text").attr("text-anchor", "middle") // this makes it easy to centre the text as the transform is applied to the anchor\n    .attr("transform", "translate(" + width / 2 + "," + (height + padding / 2) + ")") // centre below axis\n    .text(x_Axis_name).style("fill", "#424242").style("text-indent", "20px").style("font-size", "12px").style("font-weight", "bold");\n\n    function zoomed() {\n        var panX = d3.event.translate[0];\n        var panY = d3.event.translate[1];\n        var scale = d3.event.scale;\n\n        panX = panX > 10 ? 10 : panX;\n        var maxX = -(scale - 1) * width - 10;\n        panX = panX < maxX ? maxX : panX;\n\n        panY = panY > 10 ? 10 : panY;\n        var maxY = -(scale - 1) * height - 10;\n        panY = panY < maxY ? maxY : panY;\n\n        zoom.translate([panX, panY]);\n\n        main1.select(".x.axis").call(xAxis);\n        main1.select(".y.axis").call(yAxis);\n        main1.selectAll("circle").attr("cx", function (_, i) {\n            return xScale(data_plot[i].xaxis);\n        }).attr("cy", function (_, i) {\n            return yScale(data_plot[i].yaxis);\n        }).attr("r", 2.5).style("fill", "#B71C1C");\n    }\n\n    //heatmap\n    d3.select("#NAcount").text("There are " + nanCount + " number of NA values in the relation.");\n    // document.getElementById(\'heatchart\').style.display = "block";\n    heatmap(x_Axis_name, y_Axis_name);\n}\n\nvar plotnamea = void 0,\n    plotnameb = void 0,\n    varn1 = void 0,\n    varn2 = void 0,\n    varsize1 = void 0,\n    varsize2 = void 0;\n\nfunction crossTabPlots(PlotNameA, PlotNameB) {\n    plotnamea = PlotNameA;\n    plotnameb = PlotNameB;\n    var mydiv = "#resultsView_tabular";\n\n    var plot_nodes = app.nodes.slice();\n    var margin_cross = { top: 30, right: 35, bottom: 40, left: 40 },\n        width_cross = 300 - margin_cross.left - margin_cross.right,\n        height_cross = 160 - margin_cross.top - margin_cross.bottom;\n\n    var padding_cross = 100;\n\n    for (var i = 0; i < plot_nodes.length; i++) {\n        if (plot_nodes[i].name === PlotNameA) {\n            if (plot_nodes[i].plottype === "continuous") {\n                density_cross(plot_nodes[i]);\n            } else if (plot_nodes[i].plottype === "bar") {\n                bar_cross(plot_nodes[i]);\n            }\n        } else if (plot_nodes[i].name === PlotNameB) {\n            if (plot_nodes[i].plottype === "continuous") {\n                density_cross(plot_nodes[i]);\n            } else if (plot_nodes[i].plottype === "bar") {\n                bar_cross(plot_nodes[i]);\n            }\n        }\n    }\n    d3.select(mydiv).append("g").attr("id", "btnDiv").style(\'font-size\', \'75%\').style("width", "280px").style("position", "relative").style("left", margin_cross.left + padding_cross / 2 + "px").style("top", "18px");\n\n    d3.select("#btnDiv")[0][0].innerHTML = [\'<h5>Data Selection</h5>\', \'<p>Enter the numbers for both plots respectively to specify the distribution of the cross-tabs.</p>\', \'<p id="boldstuff" style="color: #2a6496">Select between Equidistant and Equimass.</p>\'].join(\'\\n\');\n\n    d3.select("#btnDiv").append("input").attr({\n        id: "a",\n        placeholder: PlotNameA,\n        size: 20\n    });\n\n    // style both of the inputs at once\n    // more on HTML5 <input> at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input\n    d3.selectAll("input").attr({\n        "type": "text",\n        "size": 3,\n        "autofocus": "true",\n        "inputmode": "numeric"\n    }).style({\n        "text-align": "center",\n        "display": "inline-block",\n        "margin-right": "10px"\n    });\n\n    var btns = d3.select("#btnDiv").selectAll("button").data(["EQUIDISTANCE", "EQUIMASS"]);\n    btns = btns.enter().append("button").style("display", "inline-block");\n\n    // fill the buttons with the year from the data assigned to them\n    btns.each(function (d) {\n        this.innerText = d;\n    });\n\n    btns.on("click", getData);\n\n    d3.select(mydiv).append("g").attr("id", "btnDiv1").style(\'font-size\', \'75%\').style("width", "280px").style("position", "relative").style("left", margin_cross.left - padding_cross * 1.75 + "px").style("top", "50px");\n\n    d3.select("#btnDiv1").append("input").attr({\n        "id": "b",\n        "placeholder": PlotNameB,\n        "size": 20\n    });\n\n    // style both of the inputs at once\n    // more on HTML5 <input> at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input\n    d3.selectAll("input").attr({\n        "type": "text",\n        "size": 3,\n        "autofocus": "true",\n        "inputmode": "numeric"\n    }).style({\n        "text-align": "center",\n        "display": "inline-block",\n        "margin-right": "10px"\n    });\n\n    var btns1 = d3.select("#btnDiv1").selectAll("button").data(["EQUIDISTANCE", "EQUIMASS"]);\n    btns1 = btns1.enter().append("button").style("display", "inline-block");\n\n    // fill the buttons with the year from the data assigned to them\n    btns1.each(function (d) {\n        this.innerText = d;\n    });\n    btns1.on("click", getData1);\n\n    function getData() {\n        if (this.innerText === "EQUIDISTANCE") {\n            varn1 = \'equidistance\';\n            varsize1 = parseInt(d3.select("input#a")[0][0].value);\n            equidistance(PlotNameA, varsize1);\n        } else if (this.innerText === "EQUIMASS") {\n            varn1 = \'equimass\';\n            varsize1 = parseInt(d3.select("input#a")[0][0].value);\n            equimass(PlotNameA, varsize1);\n        }\n    }\n    function getData1() {\n        if (this.innerText === "EQUIDISTANCE") {\n            varn2 = \'equidistance\';\n            varsize2 = parseInt(d3.select("input#b")[0][0].value);\n            equidistance(PlotNameB, varsize2);\n        } else if (this.innerText === "EQUIMASS") {\n            varn2 = \'equimass\';\n            varsize2 = parseInt(d3.select("input#b")[0][0].value);\n            equimass(PlotNameB, varsize2);\n        }\n    }\n\n    /*\n      trail\n    */\n\n    // this is the function to add  the density plot if any\n    function density_cross(density_env, a, method_name) {\n        // setup the x_cord according to the size given by user\n\n        console.log("welcome to : " + density_env.name);\n        //var mydiv = "#resultsView_tabular";\n        var yVals = density_env.ploty;\n        var xVals = density_env.plotx;\n\n        // an array of objects\n\n        var data2 = [];\n        for (var i = 0; i < density_env.plotx.length; i++) {\n            data2.push({ x: density_env.plotx[i], y: density_env.ploty[i] });\n        }\n\n        data2.forEach(function (d) {\n            d.x = +d.x;\n            d.y = +d.y;\n        });\n        //  console.log(data2);\n\n        var min_x = d3.min(data2, function (d, i) {\n            return data2[i].x;\n        });\n        var max_x = d3.max(data2, function (d, i) {\n            return data2[i].x;\n        });\n        var avg_x = (max_x - min_x) / 10;\n        var min_y = d3.min(data2, function (d, i) {\n            return data2[i].y;\n        });\n        var max_y = d3.max(data2, function (d, i) {\n            return data2[i].y;\n        });\n        var avg_y = (max_y - min_y) / 10;\n        var x = d3.scale.linear().domain([d3.min(xVals), d3.max(xVals)]).range([0, width_cross]);\n\n        var invx = d3.scale.linear().range([d3.min(data2.map(function (d) {\n            return d.x;\n        })), d3.max(data2.map(function (d) {\n            return d.x;\n        }))]).domain([0, width_cross]);\n\n        var y = d3.scale.linear().domain([d3.min(data2.map(function (d) {\n            return d.y;\n        })), d3.max(data2.map(function (d) {\n            return d.y;\n        }))]).range([height_cross, 0]);\n\n        var xAxis = d3.svg.axis().scale(x).ticks(5).orient("bottom");\n\n        var yAxis = d3.svg.axis().scale(y).orient("left");\n\n        var area = d3.svg.area().interpolate("monotone").x(function (d) {\n            return x(d.x);\n        }).y0(height_cross - avg_y).y1(function (d) {\n            return y(d.y);\n        });\n\n        var line = d3.svg.line().x(function (d) {\n            return x(d.x);\n        }).y(function (d) {\n            return y(d.y);\n        }).interpolate("monotone");\n\n        var plotsvg = d3.select(mydiv).append("svg").attr("id", "plotsvg_id").style("width", width_cross + margin_cross.left + margin_cross.right) //setting height to the height of #main.left\n        .style("height", height_cross + margin_cross.top + margin_cross.bottom).style("margin-left", "20px").append("g").attr("transform", "translate(0," + margin_cross.top + ")");\n\n        plotsvg.append("path").attr("id", "path1").datum(data2).attr("class", "area").attr("d", area);\n        plotsvg.append("g").attr("class", "x axis").attr("transform", "translate(0," + height_cross + ")").call(xAxis);\n\n        plotsvg.append("text").attr("x", width_cross / 2).attr("y", margin_cross.top + padding_cross - 10).attr("text-anchor", "middle").text(density_env.name).style("text-indent", "20px").style("font-size", "12px").style("font-weight", "bold");\n\n        if (isNaN(a) || a === 0) {\n            console.log("do nothing #bar");\n            var upper_limit = d3.max(xVals);\n            var lower_limit = d3.min(xVals);\n\n            var z = 10;\n            //console.log(upper_limit +" and " + lower_limit);\n            var diff = upper_limit - lower_limit;\n            var buffer = diff / z;\n            var x_cord = [];\n            console.log("diff : " + diff);\n            console.log("buffer : " + buffer);\n            var push_data = lower_limit;\n            for (var i = 0; i < z - 1; i++) {\n                push_data = push_data + buffer;\n                x_cord.push(push_data);\n                //console.log("x_cord : " + x_cord);\n\n\n                plotsvg.append("line").attr("id", "line1").attr("x1", x(x_cord[i])).attr("x2", x(x_cord[i])).attr("y1", y(d3.min(yVals))).attr("y2", y(d3.max(yVals))).style("stroke", "#212121").style("stroke-dasharray", "3");\n            }\n        } else {\n            if (method_name === "equidistance") {\n\n                var upper_limit = d3.max(xVals);\n                var lower_limit = d3.min(xVals);\n\n                //console.log(upper_limit +" and " + lower_limit);\n                var diff = upper_limit - lower_limit;\n                var buffer = diff / a;\n                var x_cord = [];\n                console.log("diff : " + diff);\n                console.log("buffer : " + buffer);\n                var push_data = lower_limit;\n                for (var i = 0; i < a - 1; i++) {\n                    push_data = push_data + buffer;\n                    x_cord.push(push_data);\n                    // console.log("x_cord : " + x_cord);\n\n\n                    plotsvg.append("line").attr("id", "line1").attr("x1", x(x_cord[i])).attr("x2", x(x_cord[i])).attr("y1", y(d3.min(yVals))).attr("y2", y(d3.max(yVals))).style("stroke", "#0D47A1").style("stroke-dasharray", "4");\n                }\n            } else if (method_name === "equimass") // here we use the data from equimassCalculation to draw lines\n                {\n                    console.log(" density equimass called ");\n                    var temp = [];\n\n                    temp = equimassCalculation(density_env, a);\n                    console.log("temp for density : " + temp);\n                    for (var i = 1; i < a; i++) {\n                        plotsvg.append("line").attr("id", "line1").attr("x1", x(temp[i])).attr("x2", x(temp[i])).attr("y1", y(d3.min(yVals))).attr("y2", y(d3.max(yVals))).style("stroke", "#0D47A1").style("stroke-dasharray", "4");\n                    }\n                }\n        }\n    }\n\n    // this is the function to add the bar plot if any\n    function bar_cross(bar_env, a, method_name) {\n        console.log("welcome to : " + bar_env.name);\n\n        var barPadding = .015; // Space between bars\n        var topScale = 1.2; // Multiplicative factor to assign space at top within graph - currently removed from implementation\n        var plotXaxis = true;\n\n        // Data\n        var keys = Object.keys(bar_env.plotvalues);\n        var yVals = new Array();\n        var ciUpperVals = new Array();\n        var ciLowerVals = new Array();\n        var ciSize;\n\n        var xVals = new Array();\n        var yValKey = new Array();\n\n        // console.log(keys);\n\n        //    var mydiv = "#resultsView_tabular";\n\n\n        if (bar_env.nature === "nominal") {\n            var xi = 0;\n            for (var i = 0; i < keys.length; i++) {\n                if (bar_env.plotvalues[keys[i]] == 0) {\n                    continue;\n                }\n                yVals[xi] = bar_env.plotvalues[keys[i]];\n                xVals[xi] = xi;\n                if ($private) {\n                    if (bar_env.plotvaluesCI) {\n                        ciLowerVals[xi] = bar_env.plotValuesCI.lowerBound[keys[i]];\n                        ciUpperVals[xi] = bar_env.plotValuesCI.upperBound[keys[i]];\n                    }\n                    ciSize = ciUpperVals[xi] - ciLowerVals[xi];\n                }\n                ;\n\n                yValKey.push({ y: yVals[xi], x: keys[i] });\n                xi = xi + 1;\n            }\n            yValKey.sort(function (a, b) {\n                return b.y - a.y;\n            }); // array of objects, each object has y, the same as yVals, and x, the category\n            yVals.sort(function (a, b) {\n                return b - a;\n            }); // array of y values, the height of the bars\n            ciUpperVals.sort(function (a, b) {\n                return b.y - a.y;\n            }); // ?\n            ciLowerVals.sort(function (a, b) {\n                return b.y - a.y;\n            }); // ?\n        } else {\n            for (var i = 0; i < keys.length; i++) {\n                // console.log("plotvalues in bars");\n                //console.log(node);\n                yVals[i] = bar_env.plotvalues[keys[i]];\n                xVals[i] = Number(keys[i]);\n                if ($private) {\n                    if (bar_env.plotvaluesCI) {\n                        ciLowerVals[i] = bar_env.plotvaluesCI.lowerBound[keys[i]];\n                        ciUpperVals[i] = bar_env.plotvaluesCI.upperBound[keys[i]];\n                    }\n                    ciSize = ciUpperVals[i] - ciLowerVals[i];\n                }\n            }\n        }\n\n        if (yVals.length > 15 & bar_env.numchar === "numeric" | yVals.length > 5 & bar_env.numchar === "character") {\n            plotXaxis = false;\n        }\n        var minY = d3.min(yVals);\n        var maxY = d3.max(yVals); // in the future, set maxY to the value of the maximum confidence limit\n        var minX = d3.min(xVals);\n        var maxX = d3.max(xVals);\n        var x_1 = d3.scale.linear().domain([minX - 0.5, maxX + 0.5]).range([0, width_cross]);\n\n        var invx = d3.scale.linear().range([minX - 0.5, maxX + 0.5]).domain([0, width_cross]);\n\n        var y_1 = d3.scale.linear()\n        // .domain([0, maxY])\n        .domain([0, maxY]).range([0, height_cross]);\n\n        var xAxis = d3.svg.axis().scale(x_1).ticks(yVals.length).orient("bottom");\n\n        var yAxis = d3.svg.axis().scale(y_1).orient("left");\n\n        var plotsvg1 = d3.select(mydiv).append("svg").attr("id", "plotsvg1_id").style("width", width_cross + margin_cross.left + margin_cross.right) //setting height to the height of #main.left\n        .style("height", height_cross + margin_cross.top + margin_cross.bottom).style("margin-left", "20px").append("g").attr("transform", "translate(0," + margin_cross.top + ")");\n\n        var rectWidth = x_1(minX + 0.5 - 2 * barPadding); //the "width" is the coordinate of the end of the first bar\n\n        plotsvg1.selectAll("rect").data(yVals).enter().append("rect").attr("id", "path2").attr("x", function (d, i) {\n            return x_1(xVals[i] - 0.5 + barPadding);\n        }).attr("y", function (d) {\n            return y_1(maxY - d);\n        }).attr("width", rectWidth).attr("height", function (d) {\n            return y_1(d);\n        }).attr("fill", "#fa8072");\n\n        if (plotXaxis) {\n            plotsvg1.append("g").attr("class", "x axis").attr("transform", "translate(0," + height_cross + ")").call(xAxis);\n        }\n\n        plotsvg1.append("text").attr("x", width_cross / 2).attr("y", margin_cross.top + padding_cross - 10).attr("text-anchor", "middle").text(bar_env.name).style("text-indent", "20px").style("font-size", "12px").style("font-weight", "bold");\n\n        if (isNaN(a) || a === 0) {\n            console.log("do nothing #bar");\n            x_cord2 = equimass_bar(bar_env, keys.length);\n            //console.log("x_cord2 equidis : " + x_cord2);\n\n            console.log(" bar equimass called ");\n            for (var i = 0; i < keys.length - 1; i++) {\n                // console.log("x_cord1 actual: " + x_1(x_cord2[i]));\n                plotsvg1.append("line").attr("id", "line2").attr("x1", x_1(x_cord2[i])).attr("x2", x_1(x_cord2[i])).attr("y1", y_1(0)).attr("y2", y_1(maxY)).style("stroke", "#212121").style("stroke-dasharray", "4");\n            }\n        } else {\n            if (method_name === "equidistance") {\n                var upper_limit1 = maxX;\n                var lower_limit1 = minX;\n                var diff1 = upper_limit1 - lower_limit1;\n                var buffer1 = diff1 / a;\n                var x_cord1 = [];\n                console.log("diff1 : " + diff1);\n                console.log("buffer1 : " + buffer1);\n                var push_data1 = lower_limit1;\n                for (var i = 0; i < a - 1; i++) {\n                    push_data1 = push_data1 + buffer1;\n                    x_cord1.push(push_data1);\n                    //console.log("x_cord1 equidis : "+ x_cord1);\n                    // console.log("x_cord1 actual: " + x_1(x_cord1[i]));\n                    //console.log("maxY : "+ maxY);\n                    plotsvg1.append("line").attr("id", "line2").attr("x1", x_1(x_cord1[i])).attr("x2", x_1(x_cord1[i])).attr("y1", y_1(0)).attr("y2", y_1(maxY)).style("stroke", "#0D47A1").style("stroke-dasharray", "4");\n                }\n            } else if (method_name === "equimass") {\n                var x_cord2 = [];\n                x_cord2 = equimass_bar(bar_env, a);\n                //console.log("x_cord2 equidis : " + x_cord2);\n\n                console.log(" bar equimass called ");\n                for (var i = 0; i < a - 1; i++) {\n                    // console.log("x_cord1 actual: " + x_1(x_cord2[i]));\n                    plotsvg1.append("line").attr("id", "line2").attr("x1", x_1(x_cord2[i])).attr("x2", x_1(x_cord2[i])).attr("y1", y_1(0)).attr("y2", y_1(maxY)).style("stroke", "#0D47A1").style("stroke-dasharray", "4");\n                }\n            }\n        }\n    }\n\n    function equidistance(A, a) {\n        var method_name = "equidistance";\n\n        // json object to be sent to r server\n        var obj = new Object();\n        obj.plotNameA = A;\n        obj.equidistance = a;\n\n        //convert object to json string\n        var string = JSON.stringify(obj);\n\n        //convert string to Json Object\n        console.log(JSON.parse(string)); // this is your requirement.\n\n        for (var i = 0; i < plot_nodes.length; i++) {\n            if (plot_nodes[i].name === A) {\n                if (plot_nodes[i].plottype === "continuous") {\n                    $("#plotsvg_id").remove();\n                    density_cross(plot_nodes[i], a, method_name);\n                } else if (plot_nodes[i].plottype === "bar") {\n                    $("#plotsvg1_id").remove();\n                    // d3.select("#line2").remove();\n                    bar_cross(plot_nodes[i], a, method_name);\n                }\n            } else {\n                console.log("not found");\n            }\n        }\n    }\n    function equimass(A, a) //equimass function to call the plot function\n    {\n        var method_name = "equimass";\n\n        // json object to be sent to r server\n        var obj = new Object();\n        obj.plotNameA = A;\n        obj.equidistance = a;\n\n        //convert object to json string\n        var string = JSON.stringify(obj);\n\n        //convert string to Json Object\n        console.log(JSON.parse(string)); // this is your requirement.\n\n        for (var i = 0; i < plot_nodes.length; i++) {\n            if (plot_nodes[i].name === A) {\n                if (plot_nodes[i].plottype === "continuous") {\n                    $("#plotsvg_id").remove();\n                    //d3.select("#line1").remove();\n                    density_cross(plot_nodes[i], a, method_name);\n                } else if (plot_nodes[i].plottype === "bar") {\n                    $("#plotsvg1_id").remove();\n                    // d3.select("#line2").remove();\n                    bar_cross(plot_nodes[i], a, method_name);\n                }\n            } else {\n                console.log("not found");\n            }\n        }\n    }\n\n    function equimassCalculation(plot_ev, n) // here we find the coordinates using CDF values\n    {\n        //var n =v-1;\n        var arr_y = [];\n        var arr_x = [];\n\n        arr_y = plot_ev.cdfploty; // cdfploty data stored\n        arr_x = plot_ev.cdfplotx; // cdfplotx data stored\n\n        var Upper_limitY = d3.max(arr_y);\n        var Lower_limitY = d3.min(arr_y);\n        var diffy = Upper_limitY - Lower_limitY;\n        var e = diffy / n; // e is the variable to store the average distance between the points in the cdfy in order to divide the cdfy\n\n        console.log("Upper_limitY ;" + Upper_limitY);\n        console.log("Lower_limitX :" + Lower_limitY);\n        console.log("e " + e);\n\n        var arr_c = []; //array to store the cdfy divided coordinates data\n        var push_data = arr_y[0];\n        for (var i = 0; i < n; i++) {\n            push_data = push_data + e;\n            arr_c.push(push_data);\n        }\n\n        console.log("arr_c : " + arr_c);\n\n        var temp_cdfx = [];\n        var temp = [];\n        var store = [];\n\n        for (var i = 0; i < n; i++) //to get through each arr_c\n        {\n            console.log("test arcc_c" + arr_c[i]);\n            for (var j = 0; j < 50; j++) // to compare with cdfy or arr_y\n            {\n                if (arr_c[i] === arr_y[j]) {\n                    store.push({ val: i, coor1: j, coor2: j, diff1: 0.34, diff2: 0 }); // for testing purpose\n                }\n            }\n        }\n        for (var i = 0; i < n; i++) {\n            var diff_val1, diff_val2; // here the diff is not actual difference, it is the fraction of the distance from the two points\n            var x1, x2, x3, x4;\n            for (var j = 0; j < 50; j++) {\n                //  console.log(" j out"+ j );\n                if (arr_y[j] < arr_c[i] && arr_c[i] < arr_y[j + 1]) {\n                    x1 = arr_c[i];\n                    x2 = arr_c[i] - arr_y[j];\n                    x3 = arr_y[j + 1] - arr_c[i];\n                    x4 = arr_y[j + 1] - arr_y[j];\n                    console.log(" val1 : " + x1 + " val2 : " + arr_y[j] + " val3: " + arr_y[j + 1]);\n                    console.log(" x1-x2 : " + x2 + " x3-x1 : " + x3 + " x3-x2: " + x4);\n\n                    // console.log(" j in"+ j );\n\n                    diff_val1 = x2 / x4;\n                    diff_val2 = x3 / x4;\n                    console.log("diff_val1: " + diff_val1 + " diff_val2: " + diff_val2);\n                    store.push({ val: i, coor1: j, coor2: j + 1, diff1: diff_val1, diff2: diff_val2 });\n                }\n            }\n        }\n\n        for (var i = 0; i < n; i++) {\n            console.log(" store : " + store[i].val + " " + store[i].coor1 + " " + store[i].coor2 + " diff1 " + store[i].diff1 + " diff2 " + store[i].diff2);\n        }\n\n        for (var i = 0; i < n; i++) {\n            var y1, y2, y3, diffy1, diffy2;\n            y1 = store[i].val;\n            y2 = store[i].coor1;\n            y3 = store[i].coor2;\n            diffy1 = store[i].diff1;\n            diffy2 = store[i].diff2;\n\n            var x_coor1 = arr_x[y2];\n            var x_coor2 = arr_x[y3];\n\n            var x_diff = x_coor2 - x_coor1;\n\n            var distance1 = x_diff * diffy1;\n\n            var val_x = x_coor1 + distance1;\n\n            temp.push(val_x);\n            console.log(" val_x" + val_x);\n        }\n        return temp;\n    }\n\n    function equimass_bar(plot_ev, n) {\n        var keys = Object.keys(plot_ev.plotvalues);\n        var k = keys.length;\n        var temp = [];\n        var count = 0;\n\n        if (k < n) {\n            alert("error enter vaild size");\n            console.log("error enter vaild size");\n        } else {\n            while (k > 0) {\n                temp.push({ pos: count, val: k });\n                //console.log("k:"+ k+ " and n: "+count );\n                count++;\n                k--;\n                if (count >= n) {\n                    count = 0;\n                }\n            }\n\n            var temp2 = new Array(n);\n\n            for (var i = 0; i < temp2.length; i++) {\n                temp2[i] = 0;\n            }\n            for (var i = 0; i < keys.length; i++) {\n                keys[i] = (keys[i] + 5) / 10; // to get the increase in the actual values by 0.5 according to the xaxis in plot\n            }\n            for (var i = 0; i < n; i++) {\n                for (var j = 0; j < temp.length; j++) {\n                    if (temp[j].pos === i) {\n                        temp2[i] = temp2[i] + 1;\n                    }\n                }\n            }\n\n            for (var i = 0; i < temp.length; i++) {\n                console.log("n : " + temp[i].pos + " and k: " + temp[i].val);\n            }\n            console.log(" the divison of the bar plot : " + temp2);\n\n            var j = 0,\n                k = 0;\n            var temp_final = new Array(n);\n            for (var i = 0; i < keys.length; i++) {\n                temp2[j] = temp2[j] - 1;\n                if (temp2[j] === 0) {\n                    j++;\n                    temp_final[k] = keys[i];\n                    k++;\n                }\n            }\n            console.log("temp_final: " + temp_final);\n            return temp_final;\n        }\n    }\n}\n\nfunction linechart() {\n    document.getElementById(\'linechart\').style.display = "block";\n    d3.select("#lineChart").select("svg").remove();\n    $(\'#linechart\').html("");\n\n    var w_linechart = 500;\n    var h_linechart = 300;\n    var margin_linechart = { top: 20, right: 80, bottom: 30, left: 50 };\n    var width_linechart = w_linechart - margin_linechart.left - margin_linechart.right;\n    var height_linechart = h_linechart - margin_linechart.top - margin_linechart.bottom;\n\n    var svg = d3.select("#linechart").append("svg").attr("id", "chart").attr("width", w_linechart).attr("height", h_linechart);\n    var chart = svg.append("g").classed("display", true).attr("transform", "translate(" + margin_linechart.left + "," + margin_linechart.top + ")");\n    // var dateParser = d3.time.format("%Y/%m/%d").parse;\n    var x = d3.scale.linear().domain(d3.extent(data_plot, function (d) {\n\n        return d.xaxis;\n    })).range([0, width_linechart]);\n    var y = d3.scale.linear().domain([d3.min(data_plot, function (d) {\n        return d.yaxis;\n    }), d3.max(data_plot, function (d) {\n        return d.yaxis;\n    })]).range([height_linechart, 0]);\n    var xAxis = d3.svg.axis().scale(x).orient("bottom").ticks(5);\n    var yAxis = d3.svg.axis().scale(y).orient("left").ticks(5);\n    var line = d3.svg.line().x(function (d) {\n\n        return x(d.xaxis);\n    }).y(function (d) {\n        return y(d.yaxis);\n    });\n\n    function plot(params) {\n        this.append("g").classed("x axis", true).attr("transform", "translate(0," + height_linechart + ")").call(params.axis.x);\n        this.append("g").classed("y axis", true).attr("transform", "translate(0,0)").call(params.axis.y);\n        //enter()\n        this.selectAll(".trendline").data([params.data]).enter().append("path").classed("trendline", true);\n        this.selectAll(".point").data(params.data).enter().append("circle").classed("point", true).attr("r", 2);\n        //update\n        this.selectAll(".trendline").attr("d", function (d) {\n            return line(d);\n        });\n        this.selectAll(".point").attr("cx", function (d) {\n            var date = d.xaxis;\n            return x(date);\n        }).attr("cy", function (d) {\n            return y(d.yaxis);\n        }).style("color", "#EF5350");\n        //exit()\n        this.selectAll(".trendline").data([params.data]).exit().remove();\n        this.selectAll(".point").data(params.data).exit().remove();\n    }\n\n    plot.call(chart, {\n        data: data_plot,\n        axis: {\n            x: xAxis,\n            y: yAxis\n        }\n    });\n}\n\nvar zbreaks = [];\nvar zbreaks_tabular = [];\n\nfunction viz(m, json_vizexplore, model_name_set) {\n    console.log(\'testing....\', m, model_name_set);\n    d3.select("#tabular_1").style("display", "block");\n    d3.select("#plotA").html("");\n    d3.select("#plotB").html("");\n    d3.select("#SelectionData").html("");\n    console.log("Viz explore method called: " + model_name_set);\n\n    var get_data = [];\n    get_data = model_name_set.split("-");\n\n    var model_name1 = get_data[0] + "-" + get_data[1];\n    var model_name2 = get_data[1] + "-" + get_data[0];\n    var mym = +m.substr(5, 5) - 1;\n\n    function removeKids(parent) {\n        while (parent.firstChild) {\n            parent.removeChild(parent.firstChild);\n        }\n    }\n\n    var json = json_vizexplore;\n    // pipe in figures to right panel\n    var filelist = new Array();\n\n    // image added to the div\n    var x_axis = [];\n    var y_axis = [];\n    for (var i in json.plotdata) {\n        for (var j in json.plotdata[i].varname) {\n            if (json.plotdata[i].varname[j] === get_data[0]) {\n                for (var k in json.plotdata[i].data) {\n                    x_axis[k] = json.plotdata[i].data[k];\n                }\n            }\n            if (json.plotdata[i].varname[j] === get_data[1]) {\n                for (var k in json.plotdata[i].data) {\n                    y_axis[k] = json.plotdata[i].data[k];\n                }\n            }\n        }\n    }\n\n    document.getElementById(\'scatterplot\').style.display = "none";\n    bivariatePlot(x_axis, y_axis, get_data[0], get_data[1]);\n    crossTabPlots(get_data[0], get_data[1]);\n\n    var cork = [];\n    var corp = [];\n    var cors = [];\n    var var1 = [];\n    var var2 = [];\n    var table_obj = [];\n    var colnames = [];\n    var colvar = [];\n    var table_data = [];\n    var rowvar = [];\n    var rownames = [];\n    function crossTab_Table(json_my) {\n        var json1 = json_my;\n        // data for statistics\n        for (var i in json1.tabular) {\n            if (i == model_name1 || i == model_name2) {\n                for (var j in json1.tabular[i].colnames) {\n                    colnames.push(json1.tabular[i].colnames[j]);\n                }\n            }\n        }\n        for (var i in json1.tabular) {\n            if (i == model_name1 || i == model_name2) {\n                for (var k in json1.tabular[i].rownames) {\n                    rownames.push(json1.tabular[i].rownames[k]);\n                }\n            }\n        }\n        for (var i in json1.tabular) {\n            if (i == model_name1 || i == model_name2) {\n                for (var l in json1.tabular[i].rowvar) {\n                    rowvar.push(json1.tabular[i].rowvar[l]);\n                }\n            }\n        }\n        for (var i in json1.tabular) {\n            if (i == model_name1 || i == model_name2) {\n                for (var m in json1.tabular[i].colvar) {\n                    colvar.push(json1.tabular[i].colvar[m]);\n                }\n            }\n        }\n        for (var i in json1.tabular) {\n            if (i == model_name1 || i == model_name2) {\n                for (var n in json1.tabular[i].data) {\n                    table_data[n] = [];\n                    for (var a = 0; a < colnames.length; a++) {\n                        table_data[n].push(json1.tabular[i].data[n][a]);\n                    }\n                }\n            }\n        }\n        for (var p = 0; p < rownames.length; p++) {\n            // console.log(" row data : "+ p);\n            for (var l = 0; l < colnames.length; l++) {\n                table_obj.push({ rowname: rownames[p], colname: colnames[l], value: table_data[p][l] });\n            }\n        }\n        d3table1(table_obj);\n    }\n\n    // for the statistics\n    for (var key in json.statistical) {\n        if (key == model_name1 || key == model_name2) {\n            for (var a in json.statistical[key].cork) {\n                cork.push(json.statistical[key].cork[a]);\n            }\n        }\n    }\n    for (var key1 in json.statistical) {\n        if (key1 == model_name1 || key1 == model_name2) {\n            for (var b in json.statistical[key1].corp) {\n                corp.push(json.statistical[key1].corp[b]);\n            }\n        }\n    }\n    for (var key in json.statistical) {\n        if (key == model_name1 || key == model_name2) {\n            for (var c in json.statistical[key].cors) {\n                cors.push(json.statistical[key].cors[c]);\n            }\n        }\n    }\n    for (var key in json.statistical) {\n        if (key == model_name1 || key == model_name2) {\n            for (var d in json.statistical[key].var1) {\n                var1.push(json.statistical[key].var1[d]);\n            }\n        }\n    }\n    for (var key4 in json.statistical) {\n        if (key == model_name1 || key == model_name2) {\n            for (var e in json.statistical[key].var2) {\n                var2.push(json.statistical[key].var2[e]);\n            }\n        }\n    }\n    for (var i = 0; i < app.zparams.zvars.length; i++) {\n        // write the results table\n        var resultsArray = [];\n    }for (var key in json.tabular) {\n        if (key == "colnames") {\n            console.log("colnames found");\n            continue;\n        }\n        var obj = json.tabular[key];\n        resultsArray.push(obj);\n    }\n\n    function d3table1(data) {\n        d3.select("#tabular_2").style("display", "block");\n        d3.select("#tabular_1").style("display", "none");\n        var width = 120,\n            // width of svg\n        height = 160,\n            // height of svg\n        padding = 22; // space around the chart, not including labels\n\n        d3.select("#tabular_2").html("").style("background-color", "#fff").append("h5").text("CROSS-TABS ").style("color", "#424242");\n\n        var sv = d3.select("#tabular_2").append("svg").attr("width", "100%").attr("height", "100%").style("overflow", "visible");\n        var fo = sv.append(\'foreignObject\').attr("width", "100%").attr("height", "100%").style("padding", 10).attr("overflow", "visible");\n        var table = fo.append("xhtml:table").attr("class", "table").style("border-collapse", " collapse"),\n            th = table.append("tr").style("border", 1).text("_").style("color", "#fff");\n        for (var i = 0; i < colnames.length; i++) {\n            th.append("td").style("border-bottom", 1).style("text-align", "center").style("background-color", plots.selVarColor).append("b").text(colnames[i]);\n        }\n        for (var k = 0; k < rownames.length; k++) {\n            var pos = 0;\n            var tr = table.append("tr").style("margin-left", 20).style("background-color", "#BDBDBD").style("border", 1).style("text-align", "center").text(rownames[k]);\n            for (var m = 0; m < colnames.length; m++) {\n                for (var z = 0; z < data.length; z++) {\n                    if (rownames[k] === data[z].rowname && colnames[m] === data[z].colname) {\n                        tr.append("td").style("border", 1).style("text-align", "center").style("position", "relative").style("background-color", app.varColor).text(data[z].value);\n                    }\n                }\n            }\n        }\n    }\n    $(\'#selection\').click(function () {\n        console.log("this is selection");\n        d3.select("#tabular_2").html("");\n        d3.select("#tabular_2").style("display", "none");\n        d3.select("#tabular_1").style("display", "block");\n        d3.select("#plotA").html("");\n        d3.select("#plotB").html("");\n        d3.select("#SelectionData").html("");\n        crossTabPlots(get_data[0], get_data[1]);\n    });\n    $(\'#crossTabs\').click(function () {\n        console.log("this is crossTabs");\n        d3.select("#plotA").html("");\n        d3.select("#plotB").html("");\n        d3.select("#SelectionData").html("");\n        d3.select("#tabular_2").html("");\n        explore_crosstab(json);\n        estimateLadda.stop(); // stop spinner\n        estimated = true;\n    });\n\n    function explore_crosstab(btn) {\n        for (var key in app.zparams) {\n            if (app.zparams.hasOwnProperty(key)) {\n                // do something with `key\'\n                if (key === "zcrosstabs") {\n                    delete app.zparams[key];\n                }\n            }\n        }\n\n        function writeCrossTabsJson() {\n            var plotAval = varsize1,\n                plotBval = varsize2;\n            if (isNaN(plotAval)) {\n                plotAval = 10;\n            }\n            if (isNaN(plotBval)) {\n                plotBval = 10;\n            }\n            var jsondata = {\n                var1: {\n                    name: plotnamea,\n                    value: plotAval,\n                    buttonType: varn1\n                },\n                var2: {\n                    name: plotnameb,\n                    value: plotBval,\n                    buttonType: varn2\n                }\n            };\n            return JSON.stringify(jsondata);\n        }\n        app.zparams.zcrosstab.push(writeCrossTabsJson());\n        if (PRODUCTION && app.zparams.zsessionid == "") {\n            alert("Warning: Data download is not complete. Try again soon.");\n            return;\n        }\n        app.zPop();\n\n        // write links to file & run R CMD\n        app.zparams.callHistory = app.callHistory;\n        var jsonout = JSON.stringify(app.zparams);\n\n        urlcall = rappURL + "exploreapp"; //base.concat(jsonout);\n        var solajsonout = "solaJSON=" + jsonout;\n        console.log("POST out this: ", solajsonout);\n\n        function explore_crosstabSuccess(json) {\n            console.log("crossTabSuccess");\n            d3.json("rook/myresult2.json", function (error, json) {\n                if (error) return console.warn(error);\n                var jsondata = json;\n                console.log("explore DATA json: ", jsondata);\n                crossTab_Table(jsondata);\n            });\n        }\n        function explore_crosstabFail() {\n            estimateLadda.stop(); // stop spinner\n            estimated = true;\n        }\n        estimateLadda.start(); // start spinner\n        makeCorsRequest(urlcall, btn, explore_crosstabSuccess, explore_crosstabFail, solajsonout);\n    }\n\n    // data for the statistical div\n    var string1 = cork.toString();\n    var string3 = string1.substring(string1.indexOf(":"), string1.length);\n    var string2 = string1.substring(0, string1.indexOf("c"));\n    var string4 = corp.toString();\n    var string6 = string4.substring(string4.indexOf(":"), string4.length);\n    var string5 = string4.substring(0, string4.indexOf("c"));\n    var string7 = cors.toString();\n    var string9 = string7.substring(string7.indexOf(":"), string7.length);\n    var string8 = string7.substring(0, string7.indexOf("c"));\n    var statistical_data = [{ correlation: string2, value: string3 }, { correlation: string5, value: string6 }, { correlation: string8, value: string9 }];\n\n    function d3table(data) {\n        d3.select("#resultsView_statistics").html("").style("background-color", "#fff").append("h5").text("CORRELATION STATISTICS ").style("color", "#424242");\n        var table = d3.select("#resultsView_statistics").append("table").attr("class", "table").style("border-collapse", " collapse"),\n            th = table.append("tr").style("border", 1);\n        for (var i in Object.keys(data[0])) {\n            th.append("td").style("border-bottom", 1).style("text-align", "left").style("background-color", plots.selVarColor).append("b").text(Object.keys(data[0])[i]);\n        }\n        for (var row in data) {\n            var tr = table.append("tr").style("margin-left", 40).style("border", 1).style("text-align", "left");\n            for (var td in data[row]) {\n                tr.append("td").style("border", 1).style("text-align", "left").style("position", "relative").style("background-color", app.varColor).text(data[row][td]);\n            }\n        }\n    }\n    d3table(statistical_data);\n}\n\nfunction model_selection(model_selection_name, count_value, json) {\n    if (count_value % 2 == 0 && count_value != 0) {\n        d3.select("#modelView").append("span").text(\'\\xA0 \\xA0 \\xA0 \\xA0   \\xA0 \').style("margin-top", 0).style("white-space", "pre").style("display", "inline-block").style("float", "left").append("span").text("|").style("margin-top", 0).style("white-space", "pre").style("display", "inline-block").style("float", "left").append("span").text(\'\\xA0 \\xA0 \\xA0 \\xA0   \\xA0 \').style("margin-top", 0).style("white-space", "pre").style("display", "inline-block").style("float", "left");\n    }\n    d3.select("#modelView").append("span").text(\' \\xA0\').style("margin-top", 0).style("float", "left").style("display", "inline-block").style("white-space", "pre").style("overflow-y", "hidden").style("overflow-x", "scroll").append("button") // top stack for results\n    //      .append("xhtml:button")\n    .attr("class", "btn btn-outline-success").style("padding", "4px").attr("id", model_selection_name).text(model_selection_name).style(\'background-color\', function () {\n        var color1 = "#FFD54F";\n        return count == count1 ? plots.selVarColor : color1;\n    }).style("display", "inline-block").style("white-space", "pre").style("margin-top", 0).style("float", "left").on("click", function () {\n        var a = this.style.backgroundColor.replace(/\\s*/g, "");\n        var b = app.hexToRgba(plots.selVarColor).replace(/\\s*/g, "");\n        if (a.substr(0, 17) === b.substr(0, 17)) {\n            return; //escapes the function early if the displayed model is clicked\n        }\n        viz(this.id, json, model_selection_name);\n        d3.select("#modelView").selectAll("button").style(\'background-color\', "#FFD54F");\n        d3.select(this).style(\'background-color\', plots.selVarColor);\n    });\n}\n\nfunction showLog() {\n    if (app.logArray.length > 0) {\n        app.byId(\'logdiv\').setAttribute("style", "display:block");\n        d3.select("#collapseLog div.panel-body").selectAll("p").data(app.logArray).enter().append("p").text(function (d) {\n            return d;\n        });\n        return;\n    }\n    app.byId(\'logdiv\').setAttribute("style", "display:none");\n}\n\nvar count = 0;\nvar count1 = 0;\n\n/**\n   called by clicking \'Explore\' in explore mode\n*/\nasync function explore() {\n    if (app.downloadIncomplete()) {\n        return;\n    }\n\n    app.zPop();\n    console.log(\'zpop:\', app.zparams);\n\n    // write links to file & run R CMD\n    app.zparams.callHistory = app.callHistory;\n    app.estimateLadda.start(); // start spinner\n    var json = await app.makeRequest(ROOK_SVC_URL + \'exploreapp\', app.zparams);\n    app.estimated = true;\n    if (!json) {\n        return;\n    }\n    app.allResults.push(json);\n\n    d3.select(\'#rightpanel\').style(\'width\', \'75%\');\n\n    var parent = app.byId(\'rightContentArea\');\n    app.estimated || parent.removeChild(app.byId(\'resultsHolder\'));\n    d3.select("#modelView").html(\'\');\n    d3.select("#resultsView_statistics").html(\'\');\n\n    d3.select("#result_left").style("display", "block");\n    d3.select("#result_right").style("display", "block");\n    d3.select("#scatterplot").style("display", "block");\n    d3.select("#heatchart").style("display", "block");\n    d3.select("#modelView_Container").style("display", "block");\n    d3.select("#modelView").style("display", "block");\n    d3.select("#resultsView_tabular").style("display", "block");\n    d3.select("#resultsView_statistics").style("display", "block");\n\n    d3.select("#modelView").style(\'background-color\', app.hexToRgba(app.varColor)).style("overflow-y", "hidden").style("overflow-x", "scroll").append("span").style("white-space", "pre").style("margin-top", 0).style("float", "left").style("position", "relative").style("color", "#757575").text("MODEL SELECTION :  ");\n\n    // programmatic click on Results button\n    $("#btnBivariate").trigger("click");\n    var model_name = void 0;\n    for (var img in json.images) {\n        if (count === 0) {\n            model_name = img;\n        }\n        model_selection(img, count, json); // for entering all the variables\n        count++;\n    }\n    count1 = count - 1;\n    app.modelCount++;\n\n    var rCall = [];\n    rCall[0] = json.call;\n    app.logArray.push("explore: ".concat(rCall[0]));\n    showLog();\n    viz(model_name, json, model_name);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvYXBwL2V4cGxvcmUuanM/NzYxMCJdLCJuYW1lcyI6WyJsaW5lY2hhcnQiLCJleHBsb3JlIiwiYXBwIiwicGxvdHMiLCIkcHJpdmF0ZSIsImhlYXRtYXAiLCJ4X0F4aXNfbmFtZSIsInlfQXhpc19uYW1lIiwiZDMiLCJzZWxlY3QiLCJyZW1vdmUiLCIkIiwiaHRtbCIsIm1hcmdpbl9oZWF0IiwidG9wIiwicmlnaHQiLCJib3R0b20iLCJsZWZ0Iiwid2lkdGhfaGVhdCIsImhlaWdodF9oZWF0IiwicGFkZGluZyIsIm1pbl94IiwibWluIiwiZGF0YV9wbG90IiwiZCIsImkiLCJ4YXhpcyIsIm1heF94IiwibWF4IiwiYXZnX3giLCJtaW5feSIsInlheGlzIiwibWF4X3kiLCJhdmdfeSIsIngiLCJzY2FsZSIsImxpbmVhciIsImRvbWFpbiIsInJhbmdlIiwieSIsInoiLCJ4U3RlcCIsInlTdGVwIiwic3ZnX2hlYXQiLCJhcHBlbmQiLCJhdHRyIiwic3R5bGUiLCJleHRlbnQiLCJzY29yZSIsInNlbGVjdEFsbCIsImRhdGEiLCJlbnRlciIsInRleHQiLCJjYWxsIiwic3ZnIiwiYXhpcyIsInRpY2tzIiwidGlja1NpemUiLCJvcmllbnQiLCJiaXZhcmlhdGVQbG90IiwieF9BeGlzIiwieV9BeGlzIiwiYnlJZCIsImRpc3BsYXkiLCJjb25zb2xlIiwibG9nIiwibmFuQ291bnQiLCJpc05hTiIsIm5ld051bWJlcjEiLCJuZXdOdW1iZXIyIiwicHVzaCIsIk1hdGgiLCJyYW5kb20iLCJtYXJnaW4iLCJ3aWR0aCIsImhlaWdodCIsIl8iLCJ4U2NhbGUiLCJ5U2NhbGUiLCJ4QXhpcyIsInlBeGlzIiwiem9vbSIsImJlaGF2aW9yIiwic2NhbGVFeHRlbnQiLCJvbiIsInpvb21lZCIsImNoYXJ0X3NjYXR0ZXIiLCJtYWluMSIsImNsaXAiLCJwYW5YIiwiZXZlbnQiLCJ0cmFuc2xhdGUiLCJwYW5ZIiwibWF4WCIsIm1heFkiLCJwbG90bmFtZWEiLCJwbG90bmFtZWIiLCJ2YXJuMSIsInZhcm4yIiwidmFyc2l6ZTEiLCJ2YXJzaXplMiIsImNyb3NzVGFiUGxvdHMiLCJQbG90TmFtZUEiLCJQbG90TmFtZUIiLCJteWRpdiIsInBsb3Rfbm9kZXMiLCJub2RlcyIsInNsaWNlIiwibWFyZ2luX2Nyb3NzIiwid2lkdGhfY3Jvc3MiLCJoZWlnaHRfY3Jvc3MiLCJwYWRkaW5nX2Nyb3NzIiwibGVuZ3RoIiwibmFtZSIsInBsb3R0eXBlIiwiZGVuc2l0eV9jcm9zcyIsImJhcl9jcm9zcyIsImlubmVySFRNTCIsImpvaW4iLCJpZCIsInBsYWNlaG9sZGVyIiwic2l6ZSIsImJ0bnMiLCJlYWNoIiwiaW5uZXJUZXh0IiwiZ2V0RGF0YSIsImJ0bnMxIiwiZ2V0RGF0YTEiLCJwYXJzZUludCIsInZhbHVlIiwiZXF1aWRpc3RhbmNlIiwiZXF1aW1hc3MiLCJkZW5zaXR5X2VudiIsImEiLCJtZXRob2RfbmFtZSIsInlWYWxzIiwicGxvdHkiLCJ4VmFscyIsInBsb3R4IiwiZGF0YTIiLCJmb3JFYWNoIiwiaW52eCIsIm1hcCIsImFyZWEiLCJpbnRlcnBvbGF0ZSIsInkwIiwieTEiLCJsaW5lIiwicGxvdHN2ZyIsImRhdHVtIiwidXBwZXJfbGltaXQiLCJsb3dlcl9saW1pdCIsImRpZmYiLCJidWZmZXIiLCJ4X2NvcmQiLCJwdXNoX2RhdGEiLCJ0ZW1wIiwiZXF1aW1hc3NDYWxjdWxhdGlvbiIsImJhcl9lbnYiLCJiYXJQYWRkaW5nIiwidG9wU2NhbGUiLCJwbG90WGF4aXMiLCJrZXlzIiwiT2JqZWN0IiwicGxvdHZhbHVlcyIsIkFycmF5IiwiY2lVcHBlclZhbHMiLCJjaUxvd2VyVmFscyIsImNpU2l6ZSIsInlWYWxLZXkiLCJuYXR1cmUiLCJ4aSIsInBsb3R2YWx1ZXNDSSIsInBsb3RWYWx1ZXNDSSIsImxvd2VyQm91bmQiLCJ1cHBlckJvdW5kIiwic29ydCIsImIiLCJOdW1iZXIiLCJudW1jaGFyIiwibWluWSIsIm1pblgiLCJ4XzEiLCJ5XzEiLCJwbG90c3ZnMSIsInJlY3RXaWR0aCIsInhfY29yZDIiLCJlcXVpbWFzc19iYXIiLCJ1cHBlcl9saW1pdDEiLCJsb3dlcl9saW1pdDEiLCJkaWZmMSIsImJ1ZmZlcjEiLCJ4X2NvcmQxIiwicHVzaF9kYXRhMSIsIkEiLCJvYmoiLCJwbG90TmFtZUEiLCJzdHJpbmciLCJKU09OIiwic3RyaW5naWZ5IiwicGFyc2UiLCJwbG90X2V2IiwibiIsImFycl95IiwiYXJyX3giLCJjZGZwbG90eSIsImNkZnBsb3R4IiwiVXBwZXJfbGltaXRZIiwiTG93ZXJfbGltaXRZIiwiZGlmZnkiLCJlIiwiYXJyX2MiLCJ0ZW1wX2NkZngiLCJzdG9yZSIsImoiLCJ2YWwiLCJjb29yMSIsImNvb3IyIiwiZGlmZjIiLCJkaWZmX3ZhbDEiLCJkaWZmX3ZhbDIiLCJ4MSIsIngyIiwieDMiLCJ4NCIsInkyIiwieTMiLCJkaWZmeTEiLCJkaWZmeTIiLCJ4X2Nvb3IxIiwieF9jb29yMiIsInhfZGlmZiIsImRpc3RhbmNlMSIsInZhbF94IiwiayIsImNvdW50IiwiYWxlcnQiLCJwb3MiLCJ0ZW1wMiIsInRlbXBfZmluYWwiLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwid19saW5lY2hhcnQiLCJoX2xpbmVjaGFydCIsIm1hcmdpbl9saW5lY2hhcnQiLCJ3aWR0aF9saW5lY2hhcnQiLCJoZWlnaHRfbGluZWNoYXJ0IiwiY2hhcnQiLCJjbGFzc2VkIiwicGxvdCIsInBhcmFtcyIsImRhdGUiLCJleGl0IiwiemJyZWFrcyIsInpicmVha3NfdGFidWxhciIsInZpeiIsIm0iLCJqc29uX3ZpemV4cGxvcmUiLCJtb2RlbF9uYW1lX3NldCIsImdldF9kYXRhIiwic3BsaXQiLCJtb2RlbF9uYW1lMSIsIm1vZGVsX25hbWUyIiwibXltIiwic3Vic3RyIiwicmVtb3ZlS2lkcyIsInBhcmVudCIsImZpcnN0Q2hpbGQiLCJyZW1vdmVDaGlsZCIsImpzb24iLCJmaWxlbGlzdCIsInhfYXhpcyIsInlfYXhpcyIsInBsb3RkYXRhIiwidmFybmFtZSIsImNvcmsiLCJjb3JwIiwiY29ycyIsInZhcjEiLCJ2YXIyIiwidGFibGVfb2JqIiwiY29sbmFtZXMiLCJjb2x2YXIiLCJ0YWJsZV9kYXRhIiwicm93dmFyIiwicm93bmFtZXMiLCJjcm9zc1RhYl9UYWJsZSIsImpzb25fbXkiLCJqc29uMSIsInRhYnVsYXIiLCJsIiwicCIsInJvd25hbWUiLCJjb2xuYW1lIiwiZDN0YWJsZTEiLCJrZXkiLCJzdGF0aXN0aWNhbCIsImtleTEiLCJjIiwia2V5NCIsInpwYXJhbXMiLCJ6dmFycyIsInJlc3VsdHNBcnJheSIsInN2IiwiZm8iLCJ0YWJsZSIsInRoIiwic2VsVmFyQ29sb3IiLCJ0ciIsInZhckNvbG9yIiwiY2xpY2siLCJleHBsb3JlX2Nyb3NzdGFiIiwiZXN0aW1hdGVMYWRkYSIsInN0b3AiLCJlc3RpbWF0ZWQiLCJidG4iLCJoYXNPd25Qcm9wZXJ0eSIsIndyaXRlQ3Jvc3NUYWJzSnNvbiIsInBsb3RBdmFsIiwicGxvdEJ2YWwiLCJqc29uZGF0YSIsImJ1dHRvblR5cGUiLCJ6Y3Jvc3N0YWIiLCJQUk9EVUNUSU9OIiwienNlc3Npb25pZCIsInpQb3AiLCJjYWxsSGlzdG9yeSIsImpzb25vdXQiLCJ1cmxjYWxsIiwicmFwcFVSTCIsInNvbGFqc29ub3V0IiwiZXhwbG9yZV9jcm9zc3RhYlN1Y2Nlc3MiLCJlcnJvciIsIndhcm4iLCJleHBsb3JlX2Nyb3NzdGFiRmFpbCIsInN0YXJ0IiwibWFrZUNvcnNSZXF1ZXN0Iiwic3RyaW5nMSIsInRvU3RyaW5nIiwic3RyaW5nMyIsInN1YnN0cmluZyIsImluZGV4T2YiLCJzdHJpbmcyIiwic3RyaW5nNCIsInN0cmluZzYiLCJzdHJpbmc1Iiwic3RyaW5nNyIsInN0cmluZzkiLCJzdHJpbmc4Iiwic3RhdGlzdGljYWxfZGF0YSIsImNvcnJlbGF0aW9uIiwiZDN0YWJsZSIsInJvdyIsInRkIiwibW9kZWxfc2VsZWN0aW9uIiwibW9kZWxfc2VsZWN0aW9uX25hbWUiLCJjb3VudF92YWx1ZSIsImNvbG9yMSIsImNvdW50MSIsImJhY2tncm91bmRDb2xvciIsInJlcGxhY2UiLCJoZXhUb1JnYmEiLCJzaG93TG9nIiwibG9nQXJyYXkiLCJzZXRBdHRyaWJ1dGUiLCJkb3dubG9hZEluY29tcGxldGUiLCJtYWtlUmVxdWVzdCIsIlJPT0tfU1ZDX1VSTCIsImFsbFJlc3VsdHMiLCJ0cmlnZ2VyIiwibW9kZWxfbmFtZSIsImltZyIsImltYWdlcyIsIm1vZGVsQ291bnQiLCJyQ2FsbCIsImNvbmNhdCJdLCJtYXBwaW5ncyI6Ijs7Ozs7UUFpakNnQkEsUyxHQUFBQSxTO1FBb2ZNQyxPLEdBQUFBLE87O0FBcmlEdEI7Ozs7QUFFQTs7SUFBWUMsRzs7QUFDWjs7SUFBWUMsSzs7Ozs7O0FBRVosSUFBTUMsV0FBVyxLQUFqQjs7QUFFQSxTQUFTQyxPQUFULENBQWlCQyxXQUFqQixFQUE4QkMsV0FBOUIsRUFBMkM7QUFDdkNDLE9BQUdDLE1BQUgsQ0FBVSxZQUFWLEVBQXdCQSxNQUF4QixDQUErQixLQUEvQixFQUFzQ0MsTUFBdEM7QUFDQUMsTUFBRSxZQUFGLEVBQWdCQyxJQUFoQixDQUFxQixFQUFyQjs7QUFFQSxRQUFJQyxjQUFjLEVBQUNDLEtBQUssRUFBTixFQUFVQyxPQUFPLEVBQWpCLEVBQXFCQyxRQUFRLEVBQTdCLEVBQWlDQyxNQUFNLEVBQXZDLEVBQWxCO0FBQUEsUUFDSUMsYUFBYSxNQUFNTCxZQUFZSSxJQUFsQixHQUF5QkosWUFBWUUsS0FEdEQ7QUFBQSxRQUVJSSxjQUFjLE1BQU1OLFlBQVlDLEdBQWxCLEdBQXdCRCxZQUFZRyxNQUZ0RDtBQUdBLFFBQUlJLFVBQVUsR0FBZDs7QUFFQSxRQUFJQyxRQUFRYixHQUFHYyxHQUFILENBQU9DLFNBQVAsRUFBa0IsVUFBVUMsQ0FBVixFQUFhQyxDQUFiLEVBQWdCO0FBQzFDLGVBQU9GLFVBQVVFLENBQVYsRUFBYUMsS0FBcEI7QUFDSCxLQUZXLENBQVo7QUFHQSxRQUFJQyxRQUFRbkIsR0FBR29CLEdBQUgsQ0FBT0wsU0FBUCxFQUFrQixVQUFVQyxDQUFWLEVBQWFDLENBQWIsRUFBZ0I7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VyxPQVRYLEVBU29CLFNBVHBCLEVBVUtNLElBVkwsQ0FVVSxxQkFWVjs7QUFZQTtBQUNBekMsTUFBRSxlQUFGLEVBQW1Cc1csT0FBbkIsQ0FBMkIsT0FBM0I7QUFDQSxRQUFJQyxtQkFBSjtBQUNBLFNBQUssSUFBSUMsR0FBVCxJQUFnQnRHLEtBQUt1RyxNQUFyQixFQUE2QjtBQUN6QixZQUFJekksVUFBVSxDQUFkLEVBQWlCO0FBQ2J1SSx5QkFBYUMsR0FBYjtBQUNIO0FBQ0RqQix3QkFBZ0JpQixHQUFoQixFQUFxQnhJLEtBQXJCLEVBQTRCa0MsSUFBNUIsRUFKeUIsQ0FJVTtBQUNuQ2xDO0FBQ0g7QUFDRDJILGFBQVMzSCxRQUFRLENBQWpCO0FBQ0F6TyxRQUFJbVgsVUFBSjs7QUFFQSxRQUFJQyxRQUFRLEVBQVo7QUFDQUEsVUFBTSxDQUFOLElBQVd6RyxLQUFLeE4sSUFBaEI7QUFDQW5ELFFBQUl5VyxRQUFKLENBQWFyUyxJQUFiLENBQWtCLFlBQVlpVCxNQUFaLENBQW1CRCxNQUFNLENBQU4sQ0FBbkIsQ0FBbEI7QUFDQVo7QUFDQTNHLFFBQUltSCxVQUFKLEVBQWdCckcsSUFBaEIsRUFBc0JxRyxVQUF0QjtBQUNIIiwiZmlsZSI6IjUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbSBmcm9tICdtaXRocmlsJztcblxuaW1wb3J0ICogYXMgYXBwIGZyb20gJy4vYXBwJztcbmltcG9ydCAqIGFzIHBsb3RzIGZyb20gJy4vcGxvdHMnO1xuXG5jb25zdCAkcHJpdmF0ZSA9IGZhbHNlO1xuXG5mdW5jdGlvbiBoZWF0bWFwKHhfQXhpc19uYW1lLCB5X0F4aXNfbmFtZSkge1xuICAgIGQzLnNlbGVjdChcIiNoZWF0Q2hhcnRcIikuc2VsZWN0KFwic3ZnXCIpLnJlbW92ZSgpO1xuICAgICQoJyNoZWF0Y2hhcnQnKS5odG1sKFwiXCIpO1xuXG4gICAgdmFyIG1hcmdpbl9oZWF0ID0ge3RvcDogMzAsIHJpZ2h0OiAxMCwgYm90dG9tOiA2MCwgbGVmdDogNjB9LFxuICAgICAgICB3aWR0aF9oZWF0ID0gNTAwIC0gbWFyZ2luX2hlYXQubGVmdCAtIG1hcmdpbl9oZWF0LnJpZ2h0LFxuICAgICAgICBoZWlnaHRfaGVhdCA9IDMwMCAtIG1hcmdpbl9oZWF0LnRvcCAtIG1hcmdpbl9oZWF0LmJvdHRvbTtcbiAgICB2YXIgcGFkZGluZyA9IDEwMDtcblxuICAgIHZhciBtaW5feCA9IGQzLm1pbihkYXRhX3Bsb3QsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgIHJldHVybiBkYXRhX3Bsb3RbaV0ueGF4aXM7XG4gICAgfSk7XG4gICAgdmFyIG1heF94ID0gZDMubWF4KGRhdGFfcGxvdCwgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgcmV0dXJuIGRhdGFfcGxvdFtpXS54YXhpcztcbiAgICB9KTtcbiAgICB2YXIgYXZnX3ggPSAobWF4X3ggLSBtaW5feCkgLyAxMDA7XG4gICAgdmFyIG1pbl95ID0gZDMubWluKGRhdGFfcGxvdCwgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgcmV0dXJuIGRhdGFfcGxvdFtpXS55YXhpcztcbiAgICB9KTtcbiAgICB2YXIgbWF4X3kgPSBkMy5tYXgoZGF0YV9wbG90LCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICByZXR1cm4gZGF0YV9wbG90W2ldLnlheGlzO1xuICAgIH0pO1xuICAgIHZhciBhdmdfeSA9IChtYXhfeSAtIG1pbl95KSAvIDEwMDtcblxuICAgIHZhciB4ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLmRvbWFpbihbbWluX3ggLSBhdmdfeCwgbWF4X3ggKyBhdmdfeF0pXG4gICAgICAgIC5yYW5nZShbMCwgd2lkdGhfaGVhdF0pO1xuXG4gICAgdmFyIHkgPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAuZG9tYWluKFttaW5feSAtIGF2Z195LCBtYXhfeSArIGF2Z195XSlcbiAgICAgICAgLnJhbmdlKFtoZWlnaHRfaGVhdCwgMF0pO1xuXG4gICAgdmFyIHogPSBkMy5zY2FsZS5saW5lYXIoKS5yYW5nZShbXCIjRUY5QTlBXCIsIFwiI0VGNTM1MFwiXSk7XG5cbiAgICAvLyBUaGlzIGNvdWxkIGJlIGluZmVycmVkIGZyb20gdGhlIGRhdGEgaWYgaXQgd2VyZW4ndCBzcGFyc2UuXG4gICAgdmFyIHhTdGVwID0gYXZnX3grIDAuMSxcbiAgICAgICAgeVN0ZXAgPSBhdmdfeSArIDAuMjtcbiAgICB2YXIgc3ZnX2hlYXQgPSBkMy5zZWxlY3QoXCIjaGVhdGNoYXJ0XCIpLmFwcGVuZChcInN2Z1wiKVxuICAgICAgICAuYXR0cihcIndpZHRoXCIsIHdpZHRoX2hlYXQgKyBtYXJnaW5faGVhdC5sZWZ0ICsgbWFyZ2luX2hlYXQucmlnaHQpXG4gICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGhlaWdodF9oZWF0ICsgbWFyZ2luX2hlYXQudG9wICsgbWFyZ2luX2hlYXQuYm90dG9tKVxuICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIG1hcmdpbl9oZWF0LmxlZnQgKyBcIixcIiArIG1hcmdpbl9oZWF0LnRvcCsgXCIpXCIpXG4gICAgICAgIC5zdHlsZShcImJhY2tncm91bmQtY29sb3JcIiwgXCIjRkZFQkVFXCIpO1xuXG5cbiAgICAvLyBDb21wdXRlIHRoZSBzY2FsZSBkb21haW5zLlxuICAgIHguZG9tYWluKGQzLmV4dGVudChkYXRhX3Bsb3QsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgIHJldHVybiBkYXRhX3Bsb3RbaV0ueGF4aXM7XG4gICAgfSkpO1xuICAgIHkuZG9tYWluKGQzLmV4dGVudChkYXRhX3Bsb3QsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgIHJldHVybiBkYXRhX3Bsb3RbaV0ueWF4aXM7XG4gICAgfSkpO1xuICAgIHouZG9tYWluKFswLCBkMy5tYXgoZGF0YV9wbG90LCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICByZXR1cm4gZGF0YV9wbG90W2ldLnNjb3JlO1xuICAgIH0pXSk7XG5cbiAgICAvLyBFeHRlbmQgdGhlIHgtIGFuZCB5LWRvbWFpbiB0byBmaXQgdGhlIGxhc3QgYnVja2V0LlxuICAgIC8vIEZvciBleGFtcGxlLCB0aGUgeS1idWNrZXQgMzIwMCBjb3JyZXNwb25kcyB0byB2YWx1ZXMgWzMyMDAsIDMzMDBdLlxuICAgIHguZG9tYWluKFt4LmRvbWFpbigpWzBdLCAreC5kb21haW4oKVsxXSArIHhTdGVwXSk7XG4gICAgeS5kb21haW4oW3kuZG9tYWluKClbMF0sIHkuZG9tYWluKClbMV0gKyB5U3RlcF0pO1xuXG4gICAgLy8gRGlzcGxheSB0aGUgdGlsZXMgZm9yIGVhY2ggbm9uLXplcm8gYnVja2V0LlxuICAgIC8vIFNlZSBodHRwOi8vYmwub2Nrcy5vcmcvMzA3NDQ3MCBmb3IgYW4gYWx0ZXJuYXRpdmUgaW1wbGVtZW50YXRpb24uXG4gICAgc3ZnX2hlYXQuc2VsZWN0QWxsKFwiLnRpbGVcIilcbiAgICAgICAgLmRhdGEoZGF0YV9wbG90KVxuICAgICAgICAuZW50ZXIoKS5hcHBlbmQoXCJyZWN0XCIpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJ0aWxlXCIpXG4gICAgICAgIC5hdHRyKFwieFwiLCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIHgoZGF0YV9wbG90W2ldLnhheGlzKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoXCJ5XCIsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4geShkYXRhX3Bsb3RbaV0ueWF4aXMgKyB5U3RlcCApO1xuICAgICAgICB9KVxuICAgICAgICAuYXR0cihcIndpZHRoXCIsIDE1KVxuICAgICAgICAuYXR0cihcImhlaWdodFwiLCAxNSlcbiAgICAgICAgLmF0dHIoXCJkeFwiLCBcIi4zNWVtXCIpXG4gICAgICAgIC5hdHRyKFwiZHlcIiwgXCIuMzVlbVwiKVxuICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4geihkYXRhX3Bsb3RbaV0uc2NvcmUpO1xuICAgICAgICB9KTtcblxuXG4gICAgc3ZnX2hlYXQuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwibGFiZWxcIilcbiAgICAgICAgLmF0dHIoXCJ4XCIsIHdpZHRoX2hlYXQgKyAyMClcbiAgICAgICAgLmF0dHIoXCJ5XCIsIDEwKVxuICAgICAgICAuYXR0cihcImR5XCIsIFwiLjM1ZW1cIilcbiAgICAgICAgLnRleHQoXCJDb3VudFwiKTtcblxuICAgIC8vIEFkZCBhbiB4LWF4aXMgd2l0aCBsYWJlbC5cbiAgICBzdmdfaGVhdC5hcHBlbmQoXCJnXCIpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJ4IGF4aXNcIilcbiAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCxcIiArIGhlaWdodF9oZWF0ICsgXCIpXCIpXG4gICAgICAgIC5jYWxsKGQzLnN2Zy5heGlzKCkuc2NhbGUoeCkudGlja3MoNSkudGlja1NpemUoLWhlaWdodF9oZWF0KS5vcmllbnQoXCJib3R0b21cIikpXG4gICAgICAgIC5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJsYWJlbFwiKVxuICAgICAgICAuYXR0cihcInhcIiwgd2lkdGhfaGVhdClcbiAgICAgICAgLmF0dHIoXCJ5XCIsIC02KVxuICAgICAgICAuYXR0cihcInRleHQtYW5jaG9yXCIsIFwiZW5kXCIpXG4gICAgICAgIC50ZXh0KFwiXCIpO1xuXG4gICAgLy8gQWRkIGEgeS1heGlzIHdpdGggbGFiZWwuXG4gICAgc3ZnX2hlYXQuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwieSBheGlzXCIpXG4gICAgICAgIC5jYWxsKGQzLnN2Zy5heGlzKCkuc2NhbGUoeSkudGlja1NpemUoLXdpZHRoX2hlYXQpLm9yaWVudChcImxlZnRcIikpXG4gICAgICAgIC5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJsYWJlbFwiKVxuICAgICAgICAuYXR0cihcInlcIiwgNilcbiAgICAgICAgLmF0dHIoXCJkeVwiLCBcIi43MWVtXCIpXG4gICAgICAgIC5hdHRyKFwidGV4dC1hbmNob3JcIiwgXCJlbmRcIilcbiAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJyb3RhdGUoLTkwKVwiKVxuICAgICAgICAudGV4dChcIlwiKTtcblxuICAgIHN2Z19oZWF0LmFwcGVuZChcInRleHRcIilcbiAgICAgICAgLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKSAgLy8gdGhpcyBtYWtlcyBpdCBlYXN5IHRvIGNlbnRyZSB0aGUgdGV4dCBhcyB0aGUgdHJhbnNmb3JtIGlzIGFwcGxpZWQgdG8gdGhlIGFuY2hvclxuICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgtNDAsXCIgKyAoaGVpZ2h0X2hlYXQgLyAyKSArIFwiKXJvdGF0ZSgtOTApXCIpICAvLyB0ZXh0IGlzIGRyYXduIG9mZiB0aGUgc2NyZWVuIHRvcCBsZWZ0LCBtb3ZlIGRvd24gYW5kIG91dCBhbmQgcm90YXRlXG4gICAgICAgIC50ZXh0KHlfQXhpc19uYW1lKVxuICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIFwiIzQyNDI0MlwiKVxuICAgICAgICAuc3R5bGUoXCJ0ZXh0LWluZGVudFwiLFwiMjBweFwiKVxuICAgICAgICAuc3R5bGUoXCJmb250LXNpemVcIixcIjEycHhcIilcbiAgICAgICAgLnN0eWxlKFwiZm9udC13ZWlnaHRcIixcImJvbGRcIik7XG5cbiAgICBzdmdfaGVhdC5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgIC5hdHRyKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIikgIC8vIHRoaXMgbWFrZXMgaXQgZWFzeSB0byBjZW50cmUgdGhlIHRleHQgYXMgdGhlIHRyYW5zZm9ybSBpcyBhcHBsaWVkIHRvIHRoZSBhbmNob3JcbiAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyAod2lkdGhfaGVhdCAvIDIpICsgXCIsXCIgKyAoaGVpZ2h0X2hlYXQgKyBwYWRkaW5nIC8gNCkgKyBcIilcIikgIC8vIGNlbnRyZSBiZWxvdyBheGlzXG4gICAgICAgIC50ZXh0KHhfQXhpc19uYW1lKVxuICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIFwiIzQyNDI0MlwiKVxuICAgICAgICAuc3R5bGUoXCJ0ZXh0LWluZGVudFwiLFwiMjBweFwiKVxuICAgICAgICAuc3R5bGUoXCJmb250LXNpemVcIixcIjEycHhcIilcbiAgICAgICAgLnN0eWxlKFwiZm9udC13ZWlnaHRcIixcImJvbGRcIik7XG5cblxufVxudmFyIGRhdGFfcGxvdCA9IFtdO1xuXG5mdW5jdGlvbiBiaXZhcmlhdGVQbG90KHhfQXhpcywgeV9BeGlzLCB4X0F4aXNfbmFtZSwgeV9BeGlzX25hbWUpIHtcbiAgICBhcHAuYnlJZCgnc2NhdHRlcnBsb3QnKS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICBhcHAuYnlJZCgnTkFjb3VudCcpLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIGQzLnNlbGVjdChcIiNzY2F0dGVycGxvdFwiKS5odG1sKFwiXCIpO1xuICAgIGQzLnNlbGVjdChcIiNzY2F0dGVycGxvdFwiKS5zZWxlY3QoXCJzdmdcIikucmVtb3ZlKCk7XG5cbiAgICBhcHAuYnlJZCgnbGluZWNoYXJ0Jykuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBkMy5zZWxlY3QoXCIjaGVhdGNoYXJ0XCIpLnNlbGVjdChcInN2Z1wiKS5yZW1vdmUoKTtcbiAgICBkMy5zZWxlY3QoXCIjbGluZWNoYXJ0XCIpLnNlbGVjdChcInN2Z1wiKS5yZW1vdmUoKTtcbiAgICBkMy5zZWxlY3QoXCIjbGluZWNoYXJ0XCIpLmh0bWwoXCJcIik7XG4gICAgZDMuc2VsZWN0KFwiI2hlYXRjaGFydFwiKS5odG1sKFwiXCIpO1xuICAgIC8vICQoXCIjTkFjb3VudFwiKS5odG1sKFwiXCIpO1xuXG4gICAgY29uc29sZS5sb2coXCJiaXZhcmlhdGUgcGxvdCBjYWxsZWRcIik7XG4gICAgLy8gc2NhdHRlciBwbG90XG5cbiAgICBkYXRhX3Bsb3QgPSBbXTtcbiAgICBsZXQgbmFuQ291bnQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTAwMDsgaSsrKSB7XG4gICAgICAgIGlmIChpc05hTih4X0F4aXNbaV0pIHx8IGlzTmFOKHlfQXhpc1tpXSkpIHtcbiAgICAgICAgICAgIG5hbkNvdW50Kys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgbmV3TnVtYmVyMSA9IHhfQXhpc1tpXTtcbiAgICAgICAgICAgIGxldCBuZXdOdW1iZXIyID0geV9BeGlzW2ldO1xuICAgICAgICAgICAgZGF0YV9wbG90LnB1c2goe3hheGlzOiBuZXdOdW1iZXIxLCB5YXhpczogbmV3TnVtYmVyMiwgc2NvcmU6IE1hdGgucmFuZG9tKCkgKiAxMDB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxldCBtYXJnaW4gPSB7dG9wOiAyMCwgcmlnaHQ6IDE1LCBib3R0b206IDQwLCBsZWZ0OiA2MH0sXG4gICAgICAgIHdpZHRoID0gNTAwIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQsXG4gICAgICAgIGhlaWdodCA9IDI4MCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tLFxuICAgICAgICBwYWRkaW5nID0gMTAwO1xuXG4gICAgbGV0IG1pbl94ID0gZDMubWluKGRhdGFfcGxvdCwgKF8sIGkpID0+IGRhdGFfcGxvdFtpXS54YXhpcyk7XG4gICAgbGV0IG1heF94ID0gZDMubWF4KGRhdGFfcGxvdCwgKF8sIGkpID0+IGRhdGFfcGxvdFtpXS54YXhpcyk7XG4gICAgdmFyIGF2Z194ID0gKG1heF94IC0gbWluX3gpIC8gMTA7XG4gICAgdmFyIG1pbl95ID0gZDMubWluKGRhdGFfcGxvdCwgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgcmV0dXJuIGRhdGFfcGxvdFtpXS55YXhpcztcbiAgICB9KTtcbiAgICB2YXIgbWF4X3kgPSBkMy5tYXgoZGF0YV9wbG90LCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICByZXR1cm4gZGF0YV9wbG90W2ldLnlheGlzO1xuICAgIH0pO1xuICAgIHZhciBhdmdfeSA9IChtYXhfeSAtIG1pbl95KSAvIDEwO1xuXG4gICAgdmFyIHhTY2FsZSA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgIC5kb21haW4oW21pbl94IC0gYXZnX3gsIG1heF94ICsgYXZnX3hdKVxuICAgICAgICAucmFuZ2UoWzAsIHdpZHRoXSk7XG5cbiAgICB2YXIgeVNjYWxlID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLmRvbWFpbihbbWluX3kgLSBhdmdfeSwgbWF4X3kgKyBhdmdfeV0pXG4gICAgICAgIC5yYW5nZShbaGVpZ2h0LCAwXSk7XG5cbiAgICB2YXIgeEF4aXMgPSBkMy5zdmcuYXhpcygpXG4gICAgICAgIC5zY2FsZSh4U2NhbGUpXG4gICAgICAgIC5vcmllbnQoJ2JvdHRvbScpXG4gICAgICAgIC50aWNrU2l6ZSgtaGVpZ2h0KTtcblxuICAgIHZhciB5QXhpcyA9IGQzLnN2Zy5heGlzKClcbiAgICAgICAgLnNjYWxlKHlTY2FsZSlcbiAgICAgICAgLm9yaWVudCgnbGVmdCcpXG4gICAgICAgIC50aWNrcyg1KVxuICAgICAgICAudGlja1NpemUoLXdpZHRoKTtcblxuICAgIHZhciB6b29tID0gZDMuYmVoYXZpb3Iuem9vbSgpXG4gICAgICAgIC54KHhTY2FsZSlcbiAgICAgICAgLnkoeVNjYWxlKVxuICAgICAgICAuc2NhbGVFeHRlbnQoWzEsIDEwXSlcbiAgICAgICAgLm9uKFwiem9vbVwiLCB6b29tZWQpO1xuXG4gICAgdmFyIGNoYXJ0X3NjYXR0ZXIgPSBkMy5zZWxlY3QoJyNzY2F0dGVycGxvdCcpXG4gICAgICAgIC5hcHBlbmQoJ3N2ZzpzdmcnKVxuICAgICAgICAuYXR0cignd2lkdGgnLCB3aWR0aCArIG1hcmdpbi5yaWdodCArIG1hcmdpbi5sZWZ0KVxuICAgICAgICAuYXR0cignaGVpZ2h0JywgaGVpZ2h0ICsgbWFyZ2luLnRvcCArIG1hcmdpbi5ib3R0b20pXG4gICAgICAgIC5jYWxsKHpvb20pO1xuXG4gICAgdmFyIG1haW4xID0gY2hhcnRfc2NhdHRlci5hcHBlbmQoJ2cnKVxuICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgbWFyZ2luLmxlZnQgKyAnLCcgKyBtYXJnaW4udG9wICsgJyknKVxuICAgICAgICAuYXR0cignd2lkdGgnLCB3aWR0aCsgbWFyZ2luLnJpZ2h0ICsgbWFyZ2luLmxlZnQpXG4gICAgICAgIC5hdHRyKCdoZWlnaHQnLCBoZWlnaHQgKyBtYXJnaW4udG9wICsgbWFyZ2luLmJvdHRvbSlcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ21haW4nKTtcblxuICAgIG1haW4xLmFwcGVuZCgnZycpXG4gICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsJyArIGhlaWdodCArICcpJylcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3ggYXhpcycpXG4gICAgICAgIC5jYWxsKHhBeGlzKTtcblxuICAgIG1haW4xLmFwcGVuZCgnZycpXG4gICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsMCknKVxuICAgICAgICAuYXR0cignY2xhc3MnLCAneSBheGlzJylcbiAgICAgICAgLmNhbGwoeUF4aXMpO1xuXG4gICAgdmFyIGNsaXAgPSBtYWluMS5hcHBlbmQoXCJkZWZzXCIpLmFwcGVuZChcInN2ZzpjbGlwUGF0aFwiKVxuICAgICAgICAuYXR0cihcImlkXCIsIFwiY2xpcFwiKVxuICAgICAgICAuYXBwZW5kKFwic3ZnOnJlY3RcIilcbiAgICAgICAgLmF0dHIoXCJpZFwiLCBcImNsaXAtcmVjdFwiKVxuICAgICAgICAuYXR0cihcInhcIiwgXCIwXCIpXG4gICAgICAgIC5hdHRyKFwieVwiLCBcIjBcIilcbiAgICAgICAgLmF0dHIoJ3dpZHRoJywgd2lkdGgpXG4gICAgICAgIC5hdHRyKCdoZWlnaHQnLCBoZWlnaHQpO1xuXG4gICAgbWFpbjEuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xpcC1wYXRoXCIsIFwidXJsKCNjbGlwKVwiKVxuICAgICAgICAuc2VsZWN0QWxsKFwiY2lyY2xlXCIpXG4gICAgICAgIC5kYXRhKGRhdGFfcGxvdClcbiAgICAgICAgLmVudGVyKClcbiAgICAgICAgLmFwcGVuZChcImNpcmNsZVwiKVxuICAgICAgICAuYXR0cihcImN4XCIsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4geFNjYWxlKGRhdGFfcGxvdFtpXS54YXhpcyk7XG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKFwiY3lcIiwgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiB5U2NhbGUoZGF0YV9wbG90W2ldLnlheGlzKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoXCJyXCIsIDIpXG4gICAgICAgIC5zdHlsZShcImZpbGxcIiwgXCIjQjcxQzFDXCIpXG4gICAgO1xuICAgIGNoYXJ0X3NjYXR0ZXIuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAuYXR0cihcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpICAvLyB0aGlzIG1ha2VzIGl0IGVhc3kgdG8gY2VudHJlIHRoZSB0ZXh0IGFzIHRoZSB0cmFuc2Zvcm0gaXMgYXBwbGllZCB0byB0aGUgYW5jaG9yXG4gICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgcGFkZGluZyAvIDUgKyBcIixcIiArIChoZWlnaHQgLyAyKSArIFwiKXJvdGF0ZSgtOTApXCIpICAvLyB0ZXh0IGlzIGRyYXduIG9mZiB0aGUgc2NyZWVuIHRvcCBsZWZ0LCBtb3ZlIGRvd24gYW5kIG91dCBhbmQgcm90YXRlXG4gICAgICAgIC50ZXh0KHlfQXhpc19uYW1lKVxuICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIFwiIzQyNDI0MlwiKVxuICAgICAgICAuc3R5bGUoXCJ0ZXh0LWluZGVudFwiLFwiMjBweFwiKVxuICAgICAgICAuc3R5bGUoXCJmb250LXNpemVcIixcIjEycHhcIilcbiAgICAgICAgLnN0eWxlKFwiZm9udC13ZWlnaHRcIixcImJvbGRcIik7XG5cbiAgICBjaGFydF9zY2F0dGVyLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKSAgLy8gdGhpcyBtYWtlcyBpdCBlYXN5IHRvIGNlbnRyZSB0aGUgdGV4dCBhcyB0aGUgdHJhbnNmb3JtIGlzIGFwcGxpZWQgdG8gdGhlIGFuY2hvclxuICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArICh3aWR0aCAvIDIpICsgXCIsXCIgKyAoaGVpZ2h0ICsgKHBhZGRpbmcgLyAyKSkgKyBcIilcIikgIC8vIGNlbnRyZSBiZWxvdyBheGlzXG4gICAgICAgIC50ZXh0KHhfQXhpc19uYW1lKVxuICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIFwiIzQyNDI0MlwiKVxuICAgICAgICAuc3R5bGUoXCJ0ZXh0LWluZGVudFwiLFwiMjBweFwiKVxuICAgICAgICAuc3R5bGUoXCJmb250LXNpemVcIixcIjEycHhcIilcbiAgICAgICAgLnN0eWxlKFwiZm9udC13ZWlnaHRcIixcImJvbGRcIik7XG5cbiAgICBmdW5jdGlvbiB6b29tZWQoKSB7XG4gICAgICAgIHZhciBwYW5YID0gZDMuZXZlbnQudHJhbnNsYXRlWzBdO1xuICAgICAgICB2YXIgcGFuWSA9IGQzLmV2ZW50LnRyYW5zbGF0ZVsxXTtcbiAgICAgICAgdmFyIHNjYWxlID0gZDMuZXZlbnQuc2NhbGU7XG5cbiAgICAgICAgcGFuWCA9IHBhblggPiAxMCA/IDEwIDogcGFuWDtcbiAgICAgICAgdmFyIG1heFggPSAtKHNjYWxlIC0gMSkgKiB3aWR0aCAtIDEwO1xuICAgICAgICBwYW5YID0gcGFuWCA8IG1heFggPyBtYXhYIDogcGFuWDtcblxuICAgICAgICBwYW5ZID0gcGFuWSA+IDEwID8gMTAgOiBwYW5ZO1xuICAgICAgICB2YXIgbWF4WSA9IC0oc2NhbGUgLSAxKSAqIGhlaWdodCAtIDEwO1xuICAgICAgICBwYW5ZID0gcGFuWSA8IG1heFkgPyBtYXhZIDogcGFuWTtcblxuICAgICAgICB6b29tLnRyYW5zbGF0ZShbcGFuWCwgcGFuWV0pO1xuXG4gICAgICAgIG1haW4xLnNlbGVjdChcIi54LmF4aXNcIikuY2FsbCh4QXhpcyk7XG4gICAgICAgIG1haW4xLnNlbGVjdChcIi55LmF4aXNcIikuY2FsbCh5QXhpcyk7XG4gICAgICAgIG1haW4xLnNlbGVjdEFsbChcImNpcmNsZVwiKVxuICAgICAgICAgICAgLmF0dHIoXCJjeFwiLCAoXywgaSkgPT4geFNjYWxlKGRhdGFfcGxvdFtpXS54YXhpcykpXG4gICAgICAgICAgICAuYXR0cihcImN5XCIsIChfLCBpKSA9PiB5U2NhbGUoZGF0YV9wbG90W2ldLnlheGlzKSlcbiAgICAgICAgICAgIC5hdHRyKFwiclwiLCAyLjUpXG4gICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIFwiI0I3MUMxQ1wiKTtcbiAgICB9XG5cbiAgICAvL2hlYXRtYXBcbiAgICBkMy5zZWxlY3QoXCIjTkFjb3VudFwiKS50ZXh0KFwiVGhlcmUgYXJlIFwiICsgbmFuQ291bnQgKyBcIiBudW1iZXIgb2YgTkEgdmFsdWVzIGluIHRoZSByZWxhdGlvbi5cIik7XG4gICAgLy8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2hlYXRjaGFydCcpLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgaGVhdG1hcCh4X0F4aXNfbmFtZSwgeV9BeGlzX25hbWUpO1xufVxuXG5sZXQgcGxvdG5hbWVhLCBwbG90bmFtZWIsIHZhcm4xLCB2YXJuMiwgdmFyc2l6ZTEsIHZhcnNpemUyO1xuXG5mdW5jdGlvbiBjcm9zc1RhYlBsb3RzKFBsb3ROYW1lQSwgUGxvdE5hbWVCKSB7XG4gICAgcGxvdG5hbWVhID0gUGxvdE5hbWVBO1xuICAgIHBsb3RuYW1lYiA9IFBsb3ROYW1lQjtcbiAgICB2YXIgbXlkaXYgPSBcIiNyZXN1bHRzVmlld190YWJ1bGFyXCI7XG5cbiAgICB2YXIgcGxvdF9ub2RlcyA9IGFwcC5ub2Rlcy5zbGljZSgpO1xuICAgIHZhciBtYXJnaW5fY3Jvc3MgPSB7dG9wOiAzMCwgcmlnaHQ6IDM1LCBib3R0b206IDQwLCBsZWZ0OiA0MH0sXG4gICAgICAgIHdpZHRoX2Nyb3NzID0gMzAwIC0gbWFyZ2luX2Nyb3NzLmxlZnQgLSBtYXJnaW5fY3Jvc3MucmlnaHQsXG4gICAgICAgIGhlaWdodF9jcm9zcyA9IDE2MCAtIG1hcmdpbl9jcm9zcy50b3AgLSBtYXJnaW5fY3Jvc3MuYm90dG9tO1xuXG4gICAgdmFyIHBhZGRpbmdfY3Jvc3MgPSAxMDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBsb3Rfbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHBsb3Rfbm9kZXNbaV0ubmFtZSA9PT0gUGxvdE5hbWVBKSB7XG4gICAgICAgICAgICBpZiAocGxvdF9ub2Rlc1tpXS5wbG90dHlwZSA9PT0gXCJjb250aW51b3VzXCIpIHtcbiAgICAgICAgICAgICAgICBkZW5zaXR5X2Nyb3NzKHBsb3Rfbm9kZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGxvdF9ub2Rlc1tpXS5wbG90dHlwZSA9PT0gXCJiYXJcIikge1xuICAgICAgICAgICAgICAgIGJhcl9jcm9zcyhwbG90X25vZGVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChwbG90X25vZGVzW2ldLm5hbWUgPT09IFBsb3ROYW1lQikge1xuICAgICAgICAgICAgaWYgKHBsb3Rfbm9kZXNbaV0ucGxvdHR5cGUgPT09IFwiY29udGludW91c1wiKSB7XG4gICAgICAgICAgICAgICAgZGVuc2l0eV9jcm9zcyhwbG90X25vZGVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBsb3Rfbm9kZXNbaV0ucGxvdHR5cGUgPT09IFwiYmFyXCIpIHtcbiAgICAgICAgICAgICAgICBiYXJfY3Jvc3MocGxvdF9ub2Rlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZDMuc2VsZWN0KG15ZGl2KS5hcHBlbmQoXCJnXCIpXG4gICAgICAgIC5hdHRyKFwiaWRcIiwgXCJidG5EaXZcIilcbiAgICAgICAgLnN0eWxlKCdmb250LXNpemUnLCAnNzUlJylcbiAgICAgICAgLnN0eWxlKFwid2lkdGhcIiwgXCIyODBweFwiKVxuICAgICAgICAuc3R5bGUoXCJwb3NpdGlvblwiLFwicmVsYXRpdmVcIilcbiAgICAgICAgLnN0eWxlKFwibGVmdFwiLCAobWFyZ2luX2Nyb3NzLmxlZnQrIChwYWRkaW5nX2Nyb3NzLzIpKSArIFwicHhcIilcbiAgICAgICAgLnN0eWxlKFwidG9wXCIsIFwiMThweFwiKTtcblxuICAgIGQzLnNlbGVjdChcIiNidG5EaXZcIilbMF1bMF0uaW5uZXJIVE1MID1bXG4gICAgICAgICc8aDU+RGF0YSBTZWxlY3Rpb248L2g1PicsXG4gICAgICAgICc8cD5FbnRlciB0aGUgbnVtYmVycyBmb3IgYm90aCBwbG90cyByZXNwZWN0aXZlbHkgdG8gc3BlY2lmeSB0aGUgZGlzdHJpYnV0aW9uIG9mIHRoZSBjcm9zcy10YWJzLjwvcD4nLFxuICAgICAgICAnPHAgaWQ9XCJib2xkc3R1ZmZcIiBzdHlsZT1cImNvbG9yOiAjMmE2NDk2XCI+U2VsZWN0IGJldHdlZW4gRXF1aWRpc3RhbnQgYW5kIEVxdWltYXNzLjwvcD4nXG4gICAgXS5qb2luKCdcXG4nKTtcblxuICAgIGQzLnNlbGVjdChcIiNidG5EaXZcIilcbiAgICAgICAgLmFwcGVuZChcImlucHV0XCIpXG4gICAgICAgIC5hdHRyKHtcbiAgICAgICAgICAgIGlkOiBcImFcIixcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBQbG90TmFtZUEsXG4gICAgICAgICAgICBzaXplOiAyMFxuICAgICAgICB9KTtcblxuICAgIC8vIHN0eWxlIGJvdGggb2YgdGhlIGlucHV0cyBhdCBvbmNlXG4gICAgLy8gbW9yZSBvbiBIVE1MNSA8aW5wdXQ+IGF0IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudC9pbnB1dFxuICAgIGQzLnNlbGVjdEFsbChcImlucHV0XCIpXG4gICAgICAgIC5hdHRyKHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInRleHRcIixcbiAgICAgICAgICAgIFwic2l6ZVwiOiAzLFxuICAgICAgICAgICAgXCJhdXRvZm9jdXNcIjogXCJ0cnVlXCIsXG4gICAgICAgICAgICBcImlucHV0bW9kZVwiOiBcIm51bWVyaWNcIlxuICAgICAgICB9KVxuICAgICAgICAuc3R5bGUoe1xuICAgICAgICAgICAgXCJ0ZXh0LWFsaWduXCI6IFwiY2VudGVyXCIsXG4gICAgICAgICAgICBcImRpc3BsYXlcIjogXCJpbmxpbmUtYmxvY2tcIixcbiAgICAgICAgICAgIFwibWFyZ2luLXJpZ2h0XCI6IFwiMTBweFwiXG4gICAgICAgIH0pO1xuXG5cbiAgICB2YXIgYnRucyA9IGQzLnNlbGVjdChcIiNidG5EaXZcIikuc2VsZWN0QWxsKFwiYnV0dG9uXCIpLmRhdGEoW1wiRVFVSURJU1RBTkNFXCIsIFwiRVFVSU1BU1NcIl0pO1xuICAgIGJ0bnMgPSBidG5zLmVudGVyKCkuYXBwZW5kKFwiYnV0dG9uXCIpLnN0eWxlKFwiZGlzcGxheVwiLCBcImlubGluZS1ibG9ja1wiKTtcblxuICAgIC8vIGZpbGwgdGhlIGJ1dHRvbnMgd2l0aCB0aGUgeWVhciBmcm9tIHRoZSBkYXRhIGFzc2lnbmVkIHRvIHRoZW1cbiAgICBidG5zLmVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgdGhpcy5pbm5lclRleHQgPSBkO1xuICAgIH0pO1xuXG4gICAgYnRucy5vbihcImNsaWNrXCIsIGdldERhdGEpO1xuXG4gICAgZDMuc2VsZWN0KG15ZGl2KS5hcHBlbmQoXCJnXCIpXG4gICAgICAgIC5hdHRyKFwiaWRcIiwgXCJidG5EaXYxXCIpXG4gICAgICAgIC5zdHlsZSgnZm9udC1zaXplJywgJzc1JScpXG4gICAgICAgIC5zdHlsZShcIndpZHRoXCIsIFwiMjgwcHhcIilcbiAgICAgICAgLnN0eWxlKFwicG9zaXRpb25cIixcInJlbGF0aXZlXCIpXG4gICAgICAgIC5zdHlsZShcImxlZnRcIiwgKG1hcmdpbl9jcm9zcy5sZWZ0LShwYWRkaW5nX2Nyb3NzKjEuNzUpKSArIFwicHhcIilcbiAgICAgICAgLnN0eWxlKFwidG9wXCIsIFwiNTBweFwiKTtcblxuICAgIGQzLnNlbGVjdChcIiNidG5EaXYxXCIpXG4gICAgICAgIC5hcHBlbmQoXCJpbnB1dFwiKVxuICAgICAgICAuYXR0cih7XG4gICAgICAgICAgICBcImlkXCI6IFwiYlwiLFxuICAgICAgICAgICAgXCJwbGFjZWhvbGRlclwiOiBQbG90TmFtZUIsXG4gICAgICAgICAgICBcInNpemVcIjogMjBcbiAgICAgICAgfSk7XG5cbiAgICAvLyBzdHlsZSBib3RoIG9mIHRoZSBpbnB1dHMgYXQgb25jZVxuICAgIC8vIG1vcmUgb24gSFRNTDUgPGlucHV0PiBhdCBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvaW5wdXRcbiAgICBkMy5zZWxlY3RBbGwoXCJpbnB1dFwiKVxuICAgICAgICAuYXR0cih7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJ0ZXh0XCIsXG4gICAgICAgICAgICBcInNpemVcIjogMyxcbiAgICAgICAgICAgIFwiYXV0b2ZvY3VzXCI6IFwidHJ1ZVwiLFxuICAgICAgICAgICAgXCJpbnB1dG1vZGVcIjogXCJudW1lcmljXCJcbiAgICAgICAgfSlcbiAgICAgICAgLnN0eWxlKHtcbiAgICAgICAgICAgIFwidGV4dC1hbGlnblwiOiBcImNlbnRlclwiLFxuICAgICAgICAgICAgXCJkaXNwbGF5XCI6IFwiaW5saW5lLWJsb2NrXCIsXG4gICAgICAgICAgICBcIm1hcmdpbi1yaWdodFwiOiBcIjEwcHhcIlxuICAgICAgICB9KTtcblxuICAgIHZhciBidG5zMSA9IGQzLnNlbGVjdChcIiNidG5EaXYxXCIpLnNlbGVjdEFsbChcImJ1dHRvblwiKS5kYXRhKFtcIkVRVUlESVNUQU5DRVwiLCBcIkVRVUlNQVNTXCJdKTtcbiAgICBidG5zMSA9IGJ0bnMxLmVudGVyKCkuYXBwZW5kKFwiYnV0dG9uXCIpLnN0eWxlKFwiZGlzcGxheVwiLCBcImlubGluZS1ibG9ja1wiKTtcblxuICAgIC8vIGZpbGwgdGhlIGJ1dHRvbnMgd2l0aCB0aGUgeWVhciBmcm9tIHRoZSBkYXRhIGFzc2lnbmVkIHRvIHRoZW1cbiAgICBidG5zMS5lYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHRoaXMuaW5uZXJUZXh0ID0gZDtcbiAgICB9KTtcbiAgICBidG5zMS5vbihcImNsaWNrXCIsIGdldERhdGExKTtcblxuICAgIGZ1bmN0aW9uIGdldERhdGEoKSB7XG4gICAgICAgIGlmICh0aGlzLmlubmVyVGV4dCA9PT0gXCJFUVVJRElTVEFOQ0VcIikge1xuICAgICAgICAgICAgdmFybjEgPSAnZXF1aWRpc3RhbmNlJztcbiAgICAgICAgICAgIHZhcnNpemUxID0gcGFyc2VJbnQoZDMuc2VsZWN0KFwiaW5wdXQjYVwiKVswXVswXS52YWx1ZSk7XG4gICAgICAgICAgICBlcXVpZGlzdGFuY2UoUGxvdE5hbWVBLCB2YXJzaXplMSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5pbm5lclRleHQgPT09IFwiRVFVSU1BU1NcIikge1xuICAgICAgICAgICAgdmFybjEgPSAnZXF1aW1hc3MnO1xuICAgICAgICAgICAgdmFyc2l6ZTEgPSBwYXJzZUludChkMy5zZWxlY3QoXCJpbnB1dCNhXCIpWzBdWzBdLnZhbHVlKTtcbiAgICAgICAgICAgIGVxdWltYXNzKFBsb3ROYW1lQSwgdmFyc2l6ZTEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldERhdGExKCkge1xuICAgICAgICBpZiAodGhpcy5pbm5lclRleHQgPT09IFwiRVFVSURJU1RBTkNFXCIpIHtcbiAgICAgICAgICAgIHZhcm4yID0gJ2VxdWlkaXN0YW5jZSc7XG4gICAgICAgICAgICB2YXJzaXplMiA9IHBhcnNlSW50KGQzLnNlbGVjdChcImlucHV0I2JcIilbMF1bMF0udmFsdWUpO1xuICAgICAgICAgICAgZXF1aWRpc3RhbmNlKFBsb3ROYW1lQiwgdmFyc2l6ZTIpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaW5uZXJUZXh0ID09PSBcIkVRVUlNQVNTXCIpIHtcbiAgICAgICAgICAgIHZhcm4yID0gJ2VxdWltYXNzJztcbiAgICAgICAgICAgIHZhcnNpemUyID0gcGFyc2VJbnQoZDMuc2VsZWN0KFwiaW5wdXQjYlwiKVswXVswXS52YWx1ZSk7XG4gICAgICAgICAgICBlcXVpbWFzcyhQbG90TmFtZUIsIHZhcnNpemUyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICB0cmFpbFxuICAgICovXG5cbiAgICAvLyB0aGlzIGlzIHRoZSBmdW5jdGlvbiB0byBhZGQgIHRoZSBkZW5zaXR5IHBsb3QgaWYgYW55XG4gICAgZnVuY3Rpb24gZGVuc2l0eV9jcm9zcyhkZW5zaXR5X2VudixhLG1ldGhvZF9uYW1lKSB7XG4gICAgICAgIC8vIHNldHVwIHRoZSB4X2NvcmQgYWNjb3JkaW5nIHRvIHRoZSBzaXplIGdpdmVuIGJ5IHVzZXJcblxuICAgICAgICBjb25zb2xlLmxvZyhcIndlbGNvbWUgdG8gOiBcIiArIGRlbnNpdHlfZW52Lm5hbWUpO1xuICAgICAgICAvL3ZhciBteWRpdiA9IFwiI3Jlc3VsdHNWaWV3X3RhYnVsYXJcIjtcbiAgICAgICAgdmFyIHlWYWxzID0gZGVuc2l0eV9lbnYucGxvdHk7XG4gICAgICAgIHZhciB4VmFscyA9IGRlbnNpdHlfZW52LnBsb3R4O1xuXG4gICAgICAgIC8vIGFuIGFycmF5IG9mIG9iamVjdHNcblxuICAgICAgICB2YXIgZGF0YTIgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZW5zaXR5X2Vudi5wbG90eC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZGF0YTIucHVzaCh7eDogZGVuc2l0eV9lbnYucGxvdHhbaV0sIHk6IGRlbnNpdHlfZW52LnBsb3R5W2ldfSk7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhMi5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICBkLnggPSArZC54O1xuICAgICAgICAgICAgZC55ID0gK2QueTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vICBjb25zb2xlLmxvZyhkYXRhMik7XG5cbiAgICAgICAgdmFyIG1pbl94ID0gZDMubWluKGRhdGEyLCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGEyW2ldLng7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbWF4X3ggPSBkMy5tYXgoZGF0YTIsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTJbaV0ueDtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBhdmdfeCA9IChtYXhfeCAtIG1pbl94KSAvIDEwO1xuICAgICAgICB2YXIgbWluX3kgPSBkMy5taW4oZGF0YTIsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTJbaV0ueTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBtYXhfeSA9IGQzLm1heChkYXRhMiwgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhMltpXS55O1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGF2Z195ID0gKG1heF95IC0gbWluX3kpIC8gMTA7XG4gICAgICAgIHZhciB4ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgICAgIC5kb21haW4oW2QzLm1pbih4VmFscyksIGQzLm1heCh4VmFscyldKVxuICAgICAgICAgICAgLnJhbmdlKFswLCB3aWR0aF9jcm9zc10pO1xuXG4gICAgICAgIHZhciBpbnZ4ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgICAgIC5yYW5nZShbZDMubWluKGRhdGEyLm1hcChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkLng7XG4gICAgICAgICAgICB9KSksIGQzLm1heChkYXRhMi5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZC54O1xuICAgICAgICAgICAgfSkpXSlcbiAgICAgICAgICAgIC5kb21haW4oWzAsIHdpZHRoX2Nyb3NzXSk7XG5cbiAgICAgICAgdmFyIHkgPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAgICAgLmRvbWFpbihbZDMubWluKGRhdGEyLm1hcChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkLnk7XG4gICAgICAgICAgICB9KSksIGQzLm1heChkYXRhMi5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZC55O1xuICAgICAgICAgICAgfSkpXSlcbiAgICAgICAgICAgIC5yYW5nZShbaGVpZ2h0X2Nyb3NzLCAwXSk7XG5cblxuICAgICAgICB2YXIgeEF4aXMgPSBkMy5zdmcuYXhpcygpXG4gICAgICAgICAgICAuc2NhbGUoeClcbiAgICAgICAgICAgIC50aWNrcyg1KVxuICAgICAgICAgICAgLm9yaWVudChcImJvdHRvbVwiKTtcblxuICAgICAgICB2YXIgeUF4aXMgPSBkMy5zdmcuYXhpcygpXG4gICAgICAgICAgICAuc2NhbGUoeSlcbiAgICAgICAgICAgIC5vcmllbnQoXCJsZWZ0XCIpO1xuXG4gICAgICAgIHZhciBhcmVhID0gZDMuc3ZnLmFyZWEoKVxuICAgICAgICAgICAgLmludGVycG9sYXRlKFwibW9ub3RvbmVcIilcbiAgICAgICAgICAgIC54KGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHgoZC54KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAueTAoaGVpZ2h0X2Nyb3NzIC0gYXZnX3kpXG4gICAgICAgICAgICAueTEoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geShkLnkpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGxpbmUgPSBkMy5zdmcubGluZSgpXG4gICAgICAgICAgICAueChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB4KGQueCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnkoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geShkLnkpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5pbnRlcnBvbGF0ZShcIm1vbm90b25lXCIpO1xuXG4gICAgICAgIHZhciBwbG90c3ZnID0gZDMuc2VsZWN0KG15ZGl2KVxuICAgICAgICAgICAgLmFwcGVuZChcInN2Z1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBcInBsb3RzdmdfaWRcIilcbiAgICAgICAgICAgIC5zdHlsZShcIndpZHRoXCIsIHdpZHRoX2Nyb3NzICsgbWFyZ2luX2Nyb3NzLmxlZnQgKyBtYXJnaW5fY3Jvc3MucmlnaHQpIC8vc2V0dGluZyBoZWlnaHQgdG8gdGhlIGhlaWdodCBvZiAjbWFpbi5sZWZ0XG4gICAgICAgICAgICAuc3R5bGUoXCJoZWlnaHRcIiwgaGVpZ2h0X2Nyb3NzICsgbWFyZ2luX2Nyb3NzLnRvcCArIG1hcmdpbl9jcm9zcy5ib3R0b20pXG4gICAgICAgICAgICAuc3R5bGUoXCJtYXJnaW4tbGVmdFwiLFwiMjBweFwiKVxuICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsXCIgKyBtYXJnaW5fY3Jvc3MudG9wICsgXCIpXCIpO1xuXG5cbiAgICAgICAgcGxvdHN2Zy5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsIFwicGF0aDFcIilcbiAgICAgICAgICAgIC5kYXR1bShkYXRhMilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJhcmVhXCIpXG4gICAgICAgICAgICAuYXR0cihcImRcIiwgYXJlYSk7XG4gICAgICAgIHBsb3RzdmcuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInggYXhpc1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCxcIiArIChoZWlnaHRfY3Jvc3MgICkgKyBcIilcIilcbiAgICAgICAgICAgIC5jYWxsKHhBeGlzKTtcblxuICAgICAgICBwbG90c3ZnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgIC5hdHRyKFwieFwiLCAod2lkdGhfY3Jvc3MgLyAyKSlcbiAgICAgICAgICAgIC5hdHRyKFwieVwiLCAobWFyZ2luX2Nyb3NzLnRvcCArIHBhZGRpbmdfY3Jvc3MgLTEwKSlcbiAgICAgICAgICAgIC5hdHRyKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIilcbiAgICAgICAgICAgIC50ZXh0KGRlbnNpdHlfZW52Lm5hbWUpXG4gICAgICAgICAgICAuc3R5bGUoXCJ0ZXh0LWluZGVudFwiLFwiMjBweFwiKVxuICAgICAgICAgICAgLnN0eWxlKFwiZm9udC1zaXplXCIsXCIxMnB4XCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJmb250LXdlaWdodFwiLFwiYm9sZFwiKTtcblxuICAgICAgICBpZiAoaXNOYU4oYSkgfHwgYSA9PT0gMCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJkbyBub3RoaW5nICNiYXJcIilcbiAgICAgICAgICAgIHZhciB1cHBlcl9saW1pdCA9IGQzLm1heCh4VmFscyk7XG4gICAgICAgICAgICB2YXIgbG93ZXJfbGltaXQgPSBkMy5taW4oeFZhbHMpO1xuXG4gICAgICAgICAgICB2YXIgeiA9IDEwO1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyh1cHBlcl9saW1pdCArXCIgYW5kIFwiICsgbG93ZXJfbGltaXQpO1xuICAgICAgICAgICAgdmFyIGRpZmYgPSB1cHBlcl9saW1pdCAtIGxvd2VyX2xpbWl0O1xuICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IGRpZmYgLyB6O1xuICAgICAgICAgICAgdmFyIHhfY29yZCA9IFtdO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJkaWZmIDogXCIgKyBkaWZmKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiYnVmZmVyIDogXCIgKyBidWZmZXIpO1xuICAgICAgICAgICAgdmFyIHB1c2hfZGF0YSA9IGxvd2VyX2xpbWl0O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB6IC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcHVzaF9kYXRhID0gcHVzaF9kYXRhICsgYnVmZmVyO1xuICAgICAgICAgICAgICAgIHhfY29yZC5wdXNoKHB1c2hfZGF0YSk7XG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcInhfY29yZCA6IFwiICsgeF9jb3JkKTtcblxuXG4gICAgICAgICAgICAgICAgcGxvdHN2Zy5hcHBlbmQoXCJsaW5lXCIpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgXCJsaW5lMVwiKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcIngxXCIsIHgoeF9jb3JkW2ldKSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ4MlwiLCB4KHhfY29yZFtpXSkpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieTFcIiwgeShkMy5taW4oeVZhbHMpKSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ5MlwiLCB5KGQzLm1heCh5VmFscykpKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJzdHJva2VcIiwgXCIjMjEyMTIxXCIpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZShcInN0cm9rZS1kYXNoYXJyYXlcIiwgXCIzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKG1ldGhvZF9uYW1lID09PSBcImVxdWlkaXN0YW5jZVwiKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgdXBwZXJfbGltaXQgPSBkMy5tYXgoeFZhbHMpO1xuICAgICAgICAgICAgICAgIHZhciBsb3dlcl9saW1pdCA9IGQzLm1pbih4VmFscyk7XG5cblxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2codXBwZXJfbGltaXQgK1wiIGFuZCBcIiArIGxvd2VyX2xpbWl0KTtcbiAgICAgICAgICAgICAgICB2YXIgZGlmZiA9IHVwcGVyX2xpbWl0IC0gbG93ZXJfbGltaXQ7XG4gICAgICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IGRpZmYgLyBhO1xuICAgICAgICAgICAgICAgIHZhciB4X2NvcmQgPSBbXTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImRpZmYgOiBcIiArIGRpZmYpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiYnVmZmVyIDogXCIgKyBidWZmZXIpO1xuICAgICAgICAgICAgICAgIHZhciBwdXNoX2RhdGEgPSBsb3dlcl9saW1pdDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEgLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcHVzaF9kYXRhID0gcHVzaF9kYXRhICsgYnVmZmVyO1xuICAgICAgICAgICAgICAgICAgICB4X2NvcmQucHVzaChwdXNoX2RhdGEpO1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcInhfY29yZCA6IFwiICsgeF9jb3JkKTtcblxuXG4gICAgICAgICAgICAgICAgICAgIHBsb3RzdmcuYXBwZW5kKFwibGluZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBcImxpbmUxXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcIngxXCIsIHgoeF9jb3JkW2ldKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieDJcIiwgeCh4X2NvcmRbaV0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ5MVwiLCB5KGQzLm1pbih5VmFscykpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ5MlwiLCB5KGQzLm1heCh5VmFscykpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwic3Ryb2tlXCIsIFwiIzBENDdBMVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwic3Ryb2tlLWRhc2hhcnJheVwiLCBcIjRcIik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVsc2UgaWYgKG1ldGhvZF9uYW1lID09PSBcImVxdWltYXNzXCIpIC8vIGhlcmUgd2UgdXNlIHRoZSBkYXRhIGZyb20gZXF1aW1hc3NDYWxjdWxhdGlvbiB0byBkcmF3IGxpbmVzXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCIgZGVuc2l0eSBlcXVpbWFzcyBjYWxsZWQgXCIpO1xuICAgICAgICAgICAgICAgIHZhciB0ZW1wID0gW107XG5cbiAgICAgICAgICAgICAgICB0ZW1wID0gZXF1aW1hc3NDYWxjdWxhdGlvbihkZW5zaXR5X2VudiwgYSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJ0ZW1wIGZvciBkZW5zaXR5IDogXCIgKyB0ZW1wKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGE7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBwbG90c3ZnLmFwcGVuZChcImxpbmVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgXCJsaW5lMVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ4MVwiLCB4KHRlbXBbaV0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ4MlwiLCB4KHRlbXBbaV0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ5MVwiLCB5KGQzLm1pbih5VmFscykpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ5MlwiLCB5KGQzLm1heCh5VmFscykpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwic3Ryb2tlXCIsIFwiIzBENDdBMVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwic3Ryb2tlLWRhc2hhcnJheVwiLCBcIjRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvLyB0aGlzIGlzIHRoZSBmdW5jdGlvbiB0byBhZGQgdGhlIGJhciBwbG90IGlmIGFueVxuICAgIGZ1bmN0aW9uIGJhcl9jcm9zcyhiYXJfZW52LGEsbWV0aG9kX25hbWUpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJ3ZWxjb21lIHRvIDogXCIgKyBiYXJfZW52Lm5hbWUpO1xuXG4gICAgICAgIHZhciBiYXJQYWRkaW5nID0gLjAxNTsgIC8vIFNwYWNlIGJldHdlZW4gYmFyc1xuICAgICAgICB2YXIgdG9wU2NhbGUgPSAxLjI7ICAgICAgLy8gTXVsdGlwbGljYXRpdmUgZmFjdG9yIHRvIGFzc2lnbiBzcGFjZSBhdCB0b3Agd2l0aGluIGdyYXBoIC0gY3VycmVudGx5IHJlbW92ZWQgZnJvbSBpbXBsZW1lbnRhdGlvblxuICAgICAgICB2YXIgcGxvdFhheGlzID0gdHJ1ZTtcblxuICAgICAgICAvLyBEYXRhXG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYmFyX2Vudi5wbG90dmFsdWVzKTtcbiAgICAgICAgdmFyIHlWYWxzID0gbmV3IEFycmF5O1xuICAgICAgICB2YXIgY2lVcHBlclZhbHMgPSBuZXcgQXJyYXk7XG4gICAgICAgIHZhciBjaUxvd2VyVmFscyA9IG5ldyBBcnJheTtcbiAgICAgICAgdmFyIGNpU2l6ZTtcblxuICAgICAgICB2YXIgeFZhbHMgPSBuZXcgQXJyYXk7XG4gICAgICAgIHZhciB5VmFsS2V5ID0gbmV3IEFycmF5O1xuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGtleXMpO1xuXG4gICAgICAgIC8vICAgIHZhciBteWRpdiA9IFwiI3Jlc3VsdHNWaWV3X3RhYnVsYXJcIjtcblxuXG4gICAgICAgIGlmIChiYXJfZW52Lm5hdHVyZSA9PT0gXCJub21pbmFsXCIpIHtcbiAgICAgICAgICAgIHZhciB4aSA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoYmFyX2Vudi5wbG90dmFsdWVzW2tleXNbaV1dID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHlWYWxzW3hpXSA9IGJhcl9lbnYucGxvdHZhbHVlc1trZXlzW2ldXTtcbiAgICAgICAgICAgICAgICB4VmFsc1t4aV0gPSB4aTtcbiAgICAgICAgICAgICAgICBpZiAoJHByaXZhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJhcl9lbnYucGxvdHZhbHVlc0NJKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaUxvd2VyVmFsc1t4aV0gPSBiYXJfZW52LnBsb3RWYWx1ZXNDSS5sb3dlckJvdW5kW2tleXNbaV1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2lVcHBlclZhbHNbeGldID0gYmFyX2Vudi5wbG90VmFsdWVzQ0kudXBwZXJCb3VuZFtrZXlzW2ldXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjaVNpemUgPSBjaVVwcGVyVmFsc1t4aV0gLSBjaUxvd2VyVmFsc1t4aV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDtcblxuICAgICAgICAgICAgICAgIHlWYWxLZXkucHVzaCh7eTogeVZhbHNbeGldLCB4OiBrZXlzW2ldfSk7XG4gICAgICAgICAgICAgICAgeGkgPSB4aSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5VmFsS2V5LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYi55IC0gYS55XG4gICAgICAgICAgICB9KTsgLy8gYXJyYXkgb2Ygb2JqZWN0cywgZWFjaCBvYmplY3QgaGFzIHksIHRoZSBzYW1lIGFzIHlWYWxzLCBhbmQgeCwgdGhlIGNhdGVnb3J5XG4gICAgICAgICAgICB5VmFscy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGIgLSBhXG4gICAgICAgICAgICB9KTsgLy8gYXJyYXkgb2YgeSB2YWx1ZXMsIHRoZSBoZWlnaHQgb2YgdGhlIGJhcnNcbiAgICAgICAgICAgIGNpVXBwZXJWYWxzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYi55IC0gYS55XG4gICAgICAgICAgICB9KTsgLy8gP1xuICAgICAgICAgICAgY2lMb3dlclZhbHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBiLnkgLSBhLnlcbiAgICAgICAgICAgIH0pOyAvLyA/XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcInBsb3R2YWx1ZXMgaW4gYmFyc1wiKTtcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKG5vZGUpO1xuICAgICAgICAgICAgICAgIHlWYWxzW2ldID0gYmFyX2Vudi5wbG90dmFsdWVzW2tleXNbaV1dO1xuICAgICAgICAgICAgICAgIHhWYWxzW2ldID0gTnVtYmVyKGtleXNbaV0pO1xuICAgICAgICAgICAgICAgIGlmICgkcHJpdmF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmFyX2Vudi5wbG90dmFsdWVzQ0kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNpTG93ZXJWYWxzW2ldID0gYmFyX2Vudi5wbG90dmFsdWVzQ0kubG93ZXJCb3VuZFtrZXlzW2ldXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNpVXBwZXJWYWxzW2ldID0gYmFyX2Vudi5wbG90dmFsdWVzQ0kudXBwZXJCb3VuZFtrZXlzW2ldXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjaVNpemUgPSBjaVVwcGVyVmFsc1tpXSAtIGNpTG93ZXJWYWxzW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgoeVZhbHMubGVuZ3RoID4gMTUgJiBiYXJfZW52Lm51bWNoYXIgPT09IFwibnVtZXJpY1wiKSB8ICh5VmFscy5sZW5ndGggPiA1ICYgYmFyX2Vudi5udW1jaGFyID09PSBcImNoYXJhY3RlclwiKSkge1xuICAgICAgICAgICAgcGxvdFhheGlzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1pblk9ZDMubWluKHlWYWxzKTtcbiAgICAgICAgdmFyICBtYXhZID0gZDMubWF4KHlWYWxzKTsgLy8gaW4gdGhlIGZ1dHVyZSwgc2V0IG1heFkgdG8gdGhlIHZhbHVlIG9mIHRoZSBtYXhpbXVtIGNvbmZpZGVuY2UgbGltaXRcbiAgICAgICAgdmFyICBtaW5YID0gZDMubWluKHhWYWxzKTtcbiAgICAgICAgdmFyICBtYXhYID0gZDMubWF4KHhWYWxzKTtcbiAgICAgICAgdmFyICAgeF8xID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgICAgIC5kb21haW4oW21pblggLSAwLjUsIG1heFggKyAwLjVdKVxuICAgICAgICAgICAgLnJhbmdlKFswLCB3aWR0aF9jcm9zc10pO1xuXG4gICAgICAgIHZhciBpbnZ4ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgICAgIC5yYW5nZShbbWluWCAtIDAuNSwgbWF4WCArIDAuNV0pXG4gICAgICAgICAgICAuZG9tYWluKFswLCB3aWR0aF9jcm9zc10pO1xuXG4gICAgICAgIHZhciAgeV8xID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLy8gLmRvbWFpbihbMCwgbWF4WV0pXG4gICAgICAgICAgICAuZG9tYWluKFswLCBtYXhZXSlcbiAgICAgICAgICAgIC5yYW5nZShbMCwgaGVpZ2h0X2Nyb3NzXSk7XG5cbiAgICAgICAgdmFyIHhBeGlzID0gZDMuc3ZnLmF4aXMoKVxuICAgICAgICAgICAgLnNjYWxlKHhfMSlcbiAgICAgICAgICAgIC50aWNrcyh5VmFscy5sZW5ndGgpXG4gICAgICAgICAgICAub3JpZW50KFwiYm90dG9tXCIpO1xuXG4gICAgICAgIHZhciB5QXhpcyA9IGQzLnN2Zy5heGlzKClcbiAgICAgICAgICAgIC5zY2FsZSh5XzEpXG4gICAgICAgICAgICAub3JpZW50KFwibGVmdFwiKTtcblxuICAgICAgICB2YXIgICAgcGxvdHN2ZzEgPSBkMy5zZWxlY3QobXlkaXYpXG4gICAgICAgICAgICAuYXBwZW5kKFwic3ZnXCIpXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsXCJwbG90c3ZnMV9pZFwiKVxuICAgICAgICAgICAgLnN0eWxlKFwid2lkdGhcIiwgd2lkdGhfY3Jvc3MgKyBtYXJnaW5fY3Jvc3MubGVmdCArIG1hcmdpbl9jcm9zcy5yaWdodCkgLy9zZXR0aW5nIGhlaWdodCB0byB0aGUgaGVpZ2h0IG9mICNtYWluLmxlZnRcbiAgICAgICAgICAgIC5zdHlsZShcImhlaWdodFwiLCBoZWlnaHRfY3Jvc3MgKyBtYXJnaW5fY3Jvc3MudG9wICsgbWFyZ2luX2Nyb3NzLmJvdHRvbSlcbiAgICAgICAgICAgIC5zdHlsZShcIm1hcmdpbi1sZWZ0XCIsXCIyMHB4XCIpXG4gICAgICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCxcIiArIG1hcmdpbl9jcm9zcy50b3AgKyBcIilcIik7XG5cbiAgICAgICAgdmFyIHJlY3RXaWR0aCA9IHhfMShtaW5YICsgMC41IC0gMiAqIGJhclBhZGRpbmcpOyAvL3RoZSBcIndpZHRoXCIgaXMgdGhlIGNvb3JkaW5hdGUgb2YgdGhlIGVuZCBvZiB0aGUgZmlyc3QgYmFyXG5cbiAgICAgICAgcGxvdHN2ZzEuc2VsZWN0QWxsKFwicmVjdFwiKVxuXG4gICAgICAgICAgICAuZGF0YSh5VmFscylcbiAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAuYXBwZW5kKFwicmVjdFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJpZFwiLFwicGF0aDJcIilcbiAgICAgICAgICAgIC5hdHRyKFwieFwiLCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB4XzEoeFZhbHNbaV0gLSAwLjUgKyBiYXJQYWRkaW5nKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuYXR0cihcInlcIiwgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geV8xKG1heFkgLSBkKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIHJlY3RXaWR0aClcbiAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlfMShkKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuYXR0cihcImZpbGxcIiwgXCIjZmE4MDcyXCIpO1xuXG4gICAgICAgIGlmIChwbG90WGF4aXMpIHtcbiAgICAgICAgICAgIHBsb3RzdmcxLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwieCBheGlzXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCxcIiArIGhlaWdodF9jcm9zcyArIFwiKVwiKVxuICAgICAgICAgICAgICAgIC5jYWxsKHhBeGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBsb3RzdmcxLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgIC5hdHRyKFwieFwiLCAod2lkdGhfY3Jvc3MgLyAyKSlcbiAgICAgICAgICAgIC5hdHRyKFwieVwiLCBtYXJnaW5fY3Jvc3MudG9wICsgcGFkZGluZ19jcm9zcy0xMClcbiAgICAgICAgICAgIC5hdHRyKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIilcbiAgICAgICAgICAgIC50ZXh0KGJhcl9lbnYubmFtZSlcbiAgICAgICAgICAgIC5zdHlsZShcInRleHQtaW5kZW50XCIsXCIyMHB4XCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJmb250LXNpemVcIixcIjEycHhcIilcbiAgICAgICAgICAgIC5zdHlsZShcImZvbnQtd2VpZ2h0XCIsXCJib2xkXCIpO1xuXG4gICAgICAgIGlmKGlzTmFOKGEpfHwgYT09PTApIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZG8gbm90aGluZyAjYmFyXCIpO1xuICAgICAgICAgICAgeF9jb3JkMiA9IGVxdWltYXNzX2JhcihiYXJfZW52LCBrZXlzLmxlbmd0aCk7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwieF9jb3JkMiBlcXVpZGlzIDogXCIgKyB4X2NvcmQyKTtcblxuICAgICAgICAgICAgY29uc29sZS5sb2coXCIgYmFyIGVxdWltYXNzIGNhbGxlZCBcIik7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJ4X2NvcmQxIGFjdHVhbDogXCIgKyB4XzEoeF9jb3JkMltpXSkpO1xuICAgICAgICAgICAgICAgIHBsb3RzdmcxLmFwcGVuZChcImxpbmVcIilcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBcImxpbmUyXCIpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieDFcIiwgeF8xKHhfY29yZDJbaV0gKSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ4MlwiLCB4XzEoeF9jb3JkMltpXSApKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcInkxXCIsIHlfMSgwKSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ5MlwiLCB5XzEobWF4WSkpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZShcInN0cm9rZVwiLCBcIiMyMTIxMjFcIilcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwic3Ryb2tlLWRhc2hhcnJheVwiLCBcIjRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAobWV0aG9kX25hbWUgPT09IFwiZXF1aWRpc3RhbmNlXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgdXBwZXJfbGltaXQxID0gbWF4WDtcbiAgICAgICAgICAgICAgICB2YXIgbG93ZXJfbGltaXQxID0gbWluWDtcbiAgICAgICAgICAgICAgICB2YXIgZGlmZjEgPSB1cHBlcl9saW1pdDEgLSBsb3dlcl9saW1pdDE7XG4gICAgICAgICAgICAgICAgdmFyIGJ1ZmZlcjEgPSBkaWZmMSAvIGE7XG4gICAgICAgICAgICAgICAgdmFyIHhfY29yZDEgPSBbXTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImRpZmYxIDogXCIgKyBkaWZmMSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJidWZmZXIxIDogXCIgKyBidWZmZXIxKTtcbiAgICAgICAgICAgICAgICB2YXIgcHVzaF9kYXRhMSA9IGxvd2VyX2xpbWl0MTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEgLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcHVzaF9kYXRhMSA9IHB1c2hfZGF0YTEgKyBidWZmZXIxO1xuICAgICAgICAgICAgICAgICAgICB4X2NvcmQxLnB1c2gocHVzaF9kYXRhMSk7XG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJ4X2NvcmQxIGVxdWlkaXMgOiBcIisgeF9jb3JkMSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwieF9jb3JkMSBhY3R1YWw6IFwiICsgeF8xKHhfY29yZDFbaV0pKTtcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIm1heFkgOiBcIisgbWF4WSk7XG4gICAgICAgICAgICAgICAgICAgIHBsb3RzdmcxLmFwcGVuZChcImxpbmVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgXCJsaW5lMlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ4MVwiLCB4XzEoeF9jb3JkMVtpXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcIngyXCIsIHhfMSh4X2NvcmQxW2ldKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieTFcIiwgeV8xKDApKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ5MlwiLCB5XzEobWF4WSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJzdHJva2VcIiwgXCIjMEQ0N0ExXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJzdHJva2UtZGFzaGFycmF5XCIsIFwiNFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZF9uYW1lPT09XCJlcXVpbWFzc1wiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHhfY29yZDIgPSBbXTtcbiAgICAgICAgICAgICAgICB4X2NvcmQyID0gZXF1aW1hc3NfYmFyKGJhcl9lbnYsIGEpO1xuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJ4X2NvcmQyIGVxdWlkaXMgOiBcIiArIHhfY29yZDIpO1xuXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCIgYmFyIGVxdWltYXNzIGNhbGxlZCBcIik7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwieF9jb3JkMSBhY3R1YWw6IFwiICsgeF8xKHhfY29yZDJbaV0pKTtcbiAgICAgICAgICAgICAgICAgICAgcGxvdHN2ZzEuYXBwZW5kKFwibGluZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBcImxpbmUyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcIngxXCIsIHhfMSh4X2NvcmQyW2ldICkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcIngyXCIsIHhfMSh4X2NvcmQyW2ldICkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInkxXCIsIHlfMSgwKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieTJcIiwgeV8xKG1heFkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwic3Ryb2tlXCIsIFwiIzBENDdBMVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwic3Ryb2tlLWRhc2hhcnJheVwiLCBcIjRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXF1aWRpc3RhbmNlKEEsYSlcbiAgICB7XG4gICAgICAgIHZhciBtZXRob2RfbmFtZT0gXCJlcXVpZGlzdGFuY2VcIjtcblxuICAgICAgICAvLyBqc29uIG9iamVjdCB0byBiZSBzZW50IHRvIHIgc2VydmVyXG4gICAgICAgIHZhciBvYmogPSBuZXcgT2JqZWN0KCk7XG4gICAgICAgIG9iai5wbG90TmFtZUEgPSBBO1xuICAgICAgICBvYmouZXF1aWRpc3RhbmNlID0gYTtcblxuICAgICAgICAvL2NvbnZlcnQgb2JqZWN0IHRvIGpzb24gc3RyaW5nXG4gICAgICAgIHZhciBzdHJpbmcgPSBKU09OLnN0cmluZ2lmeShvYmopO1xuXG4gICAgICAgIC8vY29udmVydCBzdHJpbmcgdG8gSnNvbiBPYmplY3RcbiAgICAgICAgY29uc29sZS5sb2coSlNPTi5wYXJzZShzdHJpbmcpKTsgLy8gdGhpcyBpcyB5b3VyIHJlcXVpcmVtZW50LlxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGxvdF9ub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHBsb3Rfbm9kZXNbaV0ubmFtZSA9PT0gQSkge1xuICAgICAgICAgICAgICAgIGlmIChwbG90X25vZGVzW2ldLnBsb3R0eXBlID09PSBcImNvbnRpbnVvdXNcIikge1xuICAgICAgICAgICAgICAgICAgICAkKFwiI3Bsb3RzdmdfaWRcIikucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgIGRlbnNpdHlfY3Jvc3MocGxvdF9ub2Rlc1tpXSxhLG1ldGhvZF9uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocGxvdF9ub2Rlc1tpXS5wbG90dHlwZSA9PT0gXCJiYXJcIikge1xuICAgICAgICAgICAgICAgICAgICAkKFwiI3Bsb3RzdmcxX2lkXCIpLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBkMy5zZWxlY3QoXCIjbGluZTJcIikucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgIGJhcl9jcm9zcyhwbG90X25vZGVzW2ldLGEsbWV0aG9kX25hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJub3QgZm91bmRcIilcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBlcXVpbWFzcyhBLGEpIC8vZXF1aW1hc3MgZnVuY3Rpb24gdG8gY2FsbCB0aGUgcGxvdCBmdW5jdGlvblxuICAgIHtcbiAgICAgICAgdmFyIG1ldGhvZF9uYW1lPSBcImVxdWltYXNzXCI7XG5cbiAgICAgICAgLy8ganNvbiBvYmplY3QgdG8gYmUgc2VudCB0byByIHNlcnZlclxuICAgICAgICB2YXIgb2JqID0gbmV3IE9iamVjdCgpO1xuICAgICAgICBvYmoucGxvdE5hbWVBID0gQTtcbiAgICAgICAgb2JqLmVxdWlkaXN0YW5jZSA9IGE7XG5cbiAgICAgICAgLy9jb252ZXJ0IG9iamVjdCB0byBqc29uIHN0cmluZ1xuICAgICAgICB2YXIgc3RyaW5nID0gSlNPTi5zdHJpbmdpZnkob2JqKTtcblxuICAgICAgICAvL2NvbnZlcnQgc3RyaW5nIHRvIEpzb24gT2JqZWN0XG4gICAgICAgIGNvbnNvbGUubG9nKEpTT04ucGFyc2Uoc3RyaW5nKSk7IC8vIHRoaXMgaXMgeW91ciByZXF1aXJlbWVudC5cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBsb3Rfbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChwbG90X25vZGVzW2ldLm5hbWUgPT09IEEpIHtcbiAgICAgICAgICAgICAgICBpZiAocGxvdF9ub2Rlc1tpXS5wbG90dHlwZSA9PT0gXCJjb250aW51b3VzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgJChcIiNwbG90c3ZnX2lkXCIpLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICAvL2QzLnNlbGVjdChcIiNsaW5lMVwiKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgZGVuc2l0eV9jcm9zcyhwbG90X25vZGVzW2ldLGEsbWV0aG9kX25hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwbG90X25vZGVzW2ldLnBsb3R0eXBlID09PSBcImJhclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICQoXCIjcGxvdHN2ZzFfaWRcIikucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGQzLnNlbGVjdChcIiNsaW5lMlwiKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgYmFyX2Nyb3NzKHBsb3Rfbm9kZXNbaV0sYSxtZXRob2RfbmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIm5vdCBmb3VuZFwiKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXF1aW1hc3NDYWxjdWxhdGlvbihwbG90X2V2LG4pIC8vIGhlcmUgd2UgZmluZCB0aGUgY29vcmRpbmF0ZXMgdXNpbmcgQ0RGIHZhbHVlc1xuICAgIHtcbiAgICAgICAgLy92YXIgbiA9di0xO1xuICAgICAgICB2YXIgYXJyX3k9W107XG4gICAgICAgIHZhciBhcnJfeD1bXTtcblxuICAgICAgICBhcnJfeT1wbG90X2V2LmNkZnBsb3R5Oy8vIGNkZnBsb3R5IGRhdGEgc3RvcmVkXG4gICAgICAgIGFycl94PXBsb3RfZXYuY2RmcGxvdHg7Ly8gY2RmcGxvdHggZGF0YSBzdG9yZWRcblxuICAgICAgICB2YXIgVXBwZXJfbGltaXRZPSBkMy5tYXgoYXJyX3kpO1xuICAgICAgICB2YXIgTG93ZXJfbGltaXRZPWQzLm1pbihhcnJfeSk7XG4gICAgICAgIHZhciBkaWZmeT1VcHBlcl9saW1pdFktTG93ZXJfbGltaXRZO1xuICAgICAgICB2YXIgZT0oZGlmZnkpL247IC8vIGUgaXMgdGhlIHZhcmlhYmxlIHRvIHN0b3JlIHRoZSBhdmVyYWdlIGRpc3RhbmNlIGJldHdlZW4gdGhlIHBvaW50cyBpbiB0aGUgY2RmeSBpbiBvcmRlciB0byBkaXZpZGUgdGhlIGNkZnlcblxuICAgICAgICBjb25zb2xlLmxvZyhcIlVwcGVyX2xpbWl0WSA7XCIrVXBwZXJfbGltaXRZKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJMb3dlcl9saW1pdFggOlwiK0xvd2VyX2xpbWl0WSk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiZSBcIitlICk7XG5cbiAgICAgICAgdmFyIGFycl9jPVtdOyAvL2FycmF5IHRvIHN0b3JlIHRoZSBjZGZ5IGRpdmlkZWQgY29vcmRpbmF0ZXMgZGF0YVxuICAgICAgICB2YXIgcHVzaF9kYXRhPWFycl95WzBdO1xuICAgICAgICBmb3IodmFyIGk9MDtpPG47aSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBwdXNoX2RhdGE9cHVzaF9kYXRhK2U7XG4gICAgICAgICAgICBhcnJfYy5wdXNoKHB1c2hfZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zb2xlLmxvZyhcImFycl9jIDogXCIrIGFycl9jKTtcblxuICAgICAgICB2YXIgdGVtcF9jZGZ4PVtdO1xuICAgICAgICB2YXIgdGVtcD1bXTtcbiAgICAgICAgdmFyIHN0b3JlPVtdO1xuXG4gICAgICAgIGZvciAodmFyIGk9MDsgaTxuOyBpKyspLy90byBnZXQgdGhyb3VnaCBlYWNoIGFycl9jXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidGVzdCBhcmNjX2NcIiArIGFycl9jW2ldKTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgNTA7IGorKykvLyB0byBjb21wYXJlIHdpdGggY2RmeSBvciBhcnJfeVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChhcnJfY1tpXSA9PT0gYXJyX3lbal0pIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmUucHVzaCh7dmFsOiBpLCBjb29yMTogaiwgY29vcjI6IGosIGRpZmYxOiAwLjM0LCBkaWZmMjogMH0pOy8vIGZvciB0ZXN0aW5nIHB1cnBvc2VcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yKHZhciBpPTA7IGk8bjtpKyspIHtcbiAgICAgICAgICAgIHZhciBkaWZmX3ZhbDEsIGRpZmZfdmFsMjsvLyBoZXJlIHRoZSBkaWZmIGlzIG5vdCBhY3R1YWwgZGlmZmVyZW5jZSwgaXQgaXMgdGhlIGZyYWN0aW9uIG9mIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSB0d28gcG9pbnRzXG4gICAgICAgICAgICB2YXIgeDEsIHgyLCB4Myx4NDtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgNTA7IGorKykge1xuICAgICAgICAgICAgICAgIC8vICBjb25zb2xlLmxvZyhcIiBqIG91dFwiKyBqICk7XG4gICAgICAgICAgICAgICAgaWYgKGFycl95W2pdIDwgYXJyX2NbaV0gJiYgYXJyX2NbaV0gPCBhcnJfeVtqICsgMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgeDEgPSBhcnJfY1tpXTtcbiAgICAgICAgICAgICAgICAgICAgeDIgPSBhcnJfY1tpXS1hcnJfeVtqXTtcbiAgICAgICAgICAgICAgICAgICAgeDMgPSBhcnJfeVtqKzFdLWFycl9jW2ldO1xuICAgICAgICAgICAgICAgICAgICB4ND1hcnJfeVtqKzFdLWFycl95W2pdO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIiB2YWwxIDogXCIgK3gxICsgXCIgdmFsMiA6IFwiICsgYXJyX3lbal0gKyBcIiB2YWwzOiBcIiArIGFycl95W2orMV0pO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIiB4MS14MiA6IFwiICt4MiArIFwiIHgzLXgxIDogXCIgKyB4MyArIFwiIHgzLXgyOiBcIiArIHg0KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIiBqIGluXCIrIGogKTtcblxuICAgICAgICAgICAgICAgICAgICBkaWZmX3ZhbDEgPSB4Mi8geDQ7XG4gICAgICAgICAgICAgICAgICAgIGRpZmZfdmFsMiA9IHgzIC8geDQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZGlmZl92YWwxOiBcIisgZGlmZl92YWwxICsgIFwiIGRpZmZfdmFsMjogXCIrIGRpZmZfdmFsMik7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JlLnB1c2goe3ZhbDogaSwgY29vcjE6IGosIGNvb3IyOiBqICsgMSwgZGlmZjE6IGRpZmZfdmFsMSwgZGlmZjI6IGRpZmZfdmFsMn0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG5cbiAgICAgICAgZm9yKHZhciBpPTA7IGk8bjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIiBzdG9yZSA6IFwiICsgc3RvcmVbaV0udmFsICsgXCIgXCIgKyBzdG9yZVtpXS5jb29yMSArIFwiIFwiKyBzdG9yZVtpXS5jb29yMiArIFwiIGRpZmYxIFwiICsgc3RvcmVbaV0uZGlmZjEgKyBcIiBkaWZmMiBcIisgc3RvcmVbaV0uZGlmZjIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yKHZhciBpPTA7IGk8bjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgeTEseTIseTMsZGlmZnkxLGRpZmZ5MjtcbiAgICAgICAgICAgIHkxPXN0b3JlW2ldLnZhbDtcbiAgICAgICAgICAgIHkyPSBzdG9yZVtpXS5jb29yMTtcbiAgICAgICAgICAgIHkzPSBzdG9yZVtpXS5jb29yMjtcbiAgICAgICAgICAgIGRpZmZ5MT1zdG9yZVtpXS5kaWZmMTtcbiAgICAgICAgICAgIGRpZmZ5Mj1zdG9yZVtpXS5kaWZmMjtcblxuICAgICAgICAgICAgdmFyIHhfY29vcjE9IGFycl94W3kyXTtcbiAgICAgICAgICAgIHZhciB4X2Nvb3IyPWFycl94W3kzXTtcblxuICAgICAgICAgICAgdmFyIHhfZGlmZj14X2Nvb3IyLXhfY29vcjE7XG5cbiAgICAgICAgICAgIHZhciBkaXN0YW5jZTE9IHhfZGlmZipkaWZmeTE7XG5cbiAgICAgICAgICAgIHZhciB2YWxfeD14X2Nvb3IxK2Rpc3RhbmNlMTtcblxuICAgICAgICAgICAgdGVtcC5wdXNoKHZhbF94KTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiIHZhbF94XCIrIHZhbF94KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVtcDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlcXVpbWFzc19iYXIocGxvdF9ldixuKSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocGxvdF9ldi5wbG90dmFsdWVzKTtcbiAgICAgICAgdmFyIGsgPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgdmFyIHRlbXAgPSBbXTtcbiAgICAgICAgdmFyIGNvdW50ID0gMDtcblxuICAgICAgICBpZiAoayA8IG4pIHtcbiAgICAgICAgICAgIGFsZXJ0KFwiZXJyb3IgZW50ZXIgdmFpbGQgc2l6ZVwiKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZXJyb3IgZW50ZXIgdmFpbGQgc2l6ZVwiKVxuICAgICAgICB9XG5cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3aGlsZSAoayA+IDApIHtcbiAgICAgICAgICAgICAgICB0ZW1wLnB1c2goe3BvczogY291bnQsIHZhbDoga30pO1xuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJrOlwiKyBrKyBcIiBhbmQgbjogXCIrY291bnQgKTtcbiAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICAgIGstLTtcbiAgICAgICAgICAgICAgICBpZiAoY291bnQgPj0gbikge1xuICAgICAgICAgICAgICAgICAgICBjb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdGVtcDIgPSBuZXcgQXJyYXkobik7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGVtcDIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0ZW1wMltpXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBrZXlzW2ldID0gKGtleXNbaV0gKyA1KSAvIDEwOy8vIHRvIGdldCB0aGUgaW5jcmVhc2UgaW4gdGhlIGFjdHVhbCB2YWx1ZXMgYnkgMC41IGFjY29yZGluZyB0byB0aGUgeGF4aXMgaW4gcGxvdFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRlbXAubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRlbXBbal0ucG9zID09PSBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wMltpXSA9IHRlbXAyW2ldICsgMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZW1wLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJuIDogXCIgKyB0ZW1wW2ldLnBvcyArIFwiIGFuZCBrOiBcIiArIHRlbXBbaV0udmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiIHRoZSBkaXZpc29uIG9mIHRoZSBiYXIgcGxvdCA6IFwiICsgdGVtcDIpO1xuXG4gICAgICAgICAgICB2YXIgaiA9IDAsIGsgPSAwO1xuICAgICAgICAgICAgdmFyIHRlbXBfZmluYWwgPSBuZXcgQXJyYXkobik7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0ZW1wMltqXSA9IHRlbXAyW2pdIC0gMTtcbiAgICAgICAgICAgICAgICBpZiAodGVtcDJbal0gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgICAgICAgICB0ZW1wX2ZpbmFsW2tdID0ga2V5c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidGVtcF9maW5hbDogXCIgKyB0ZW1wX2ZpbmFsKTtcbiAgICAgICAgICAgIHJldHVybiB0ZW1wX2ZpbmFsO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbGluZWNoYXJ0KCkge1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsaW5lY2hhcnQnKS5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgIGQzLnNlbGVjdChcIiNsaW5lQ2hhcnRcIikuc2VsZWN0KFwic3ZnXCIpLnJlbW92ZSgpO1xuICAgICQoJyNsaW5lY2hhcnQnKS5odG1sKFwiXCIpO1xuXG4gICAgdmFyIHdfbGluZWNoYXJ0ID0gNTAwO1xuICAgIHZhciBoX2xpbmVjaGFydCA9IDMwMDtcbiAgICB2YXIgbWFyZ2luX2xpbmVjaGFydCA9IHt0b3A6IDIwLCByaWdodDogODAsIGJvdHRvbTogMzAsIGxlZnQ6IDUwfTtcbiAgICB2YXIgd2lkdGhfbGluZWNoYXJ0ID0gd19saW5lY2hhcnQgLSBtYXJnaW5fbGluZWNoYXJ0LmxlZnQgLSBtYXJnaW5fbGluZWNoYXJ0LnJpZ2h0O1xuICAgIHZhciBoZWlnaHRfbGluZWNoYXJ0ID0gaF9saW5lY2hhcnQgLSBtYXJnaW5fbGluZWNoYXJ0LnRvcCAtIG1hcmdpbl9saW5lY2hhcnQuYm90dG9tO1xuXG4gICAgdmFyIHN2ZyA9IGQzLnNlbGVjdChcIiNsaW5lY2hhcnRcIikuYXBwZW5kKFwic3ZnXCIpXG4gICAgICAgIC5hdHRyKFwiaWRcIiwgXCJjaGFydFwiKVxuICAgICAgICAuYXR0cihcIndpZHRoXCIsIHdfbGluZWNoYXJ0KVxuICAgICAgICAuYXR0cihcImhlaWdodFwiLCBoX2xpbmVjaGFydCk7XG4gICAgdmFyIGNoYXJ0ID0gc3ZnLmFwcGVuZChcImdcIilcbiAgICAgICAgLmNsYXNzZWQoXCJkaXNwbGF5XCIsIHRydWUpXG4gICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgbWFyZ2luX2xpbmVjaGFydC5sZWZ0ICsgXCIsXCIgKyBtYXJnaW5fbGluZWNoYXJ0LnRvcCArIFwiKVwiKTtcbiAgICAvLyB2YXIgZGF0ZVBhcnNlciA9IGQzLnRpbWUuZm9ybWF0KFwiJVkvJW0vJWRcIikucGFyc2U7XG4gICAgdmFyIHggPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAuZG9tYWluKGQzLmV4dGVudChkYXRhX3Bsb3QsIGZ1bmN0aW9uIChkKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBkLnhheGlzO1xuICAgICAgICB9KSlcbiAgICAgICAgLnJhbmdlKFswLCB3aWR0aF9saW5lY2hhcnRdKTtcbiAgICB2YXIgeSA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgIC5kb21haW4oW2QzLm1pbihkYXRhX3Bsb3QsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gZC55YXhpcztcbiAgICAgICAgfSksIGQzLm1heChkYXRhX3Bsb3QsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gZC55YXhpcztcbiAgICAgICAgfSldKVxuICAgICAgICAucmFuZ2UoW2hlaWdodF9saW5lY2hhcnQsIDBdKTtcbiAgICB2YXIgeEF4aXMgPSBkMy5zdmcuYXhpcygpXG4gICAgICAgIC5zY2FsZSh4KVxuICAgICAgICAub3JpZW50KFwiYm90dG9tXCIpXG4gICAgICAgIC50aWNrcyg1KVxuICAgIDtcbiAgICB2YXIgeUF4aXMgPSBkMy5zdmcuYXhpcygpXG4gICAgICAgIC5zY2FsZSh5KVxuICAgICAgICAub3JpZW50KFwibGVmdFwiKVxuICAgICAgICAudGlja3MoNSk7XG4gICAgdmFyIGxpbmUgPSBkMy5zdmcubGluZSgpXG4gICAgICAgIC54KGZ1bmN0aW9uIChkKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB4KGQueGF4aXMpO1xuICAgICAgICB9KVxuICAgICAgICAueShmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuIHkoZC55YXhpcyk7XG4gICAgICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gcGxvdChwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuY2xhc3NlZChcInggYXhpc1wiLCB0cnVlKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCxcIiArIGhlaWdodF9saW5lY2hhcnQgKyBcIilcIilcbiAgICAgICAgICAgIC5jYWxsKHBhcmFtcy5heGlzLngpO1xuICAgICAgICB0aGlzLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5jbGFzc2VkKFwieSBheGlzXCIsIHRydWUpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLDApXCIpXG4gICAgICAgICAgICAuY2FsbChwYXJhbXMuYXhpcy55KTtcbiAgICAgICAgLy9lbnRlcigpXG4gICAgICAgIHRoaXMuc2VsZWN0QWxsKFwiLnRyZW5kbGluZVwiKVxuICAgICAgICAgICAgLmRhdGEoW3BhcmFtcy5kYXRhXSlcbiAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAgICAgLmNsYXNzZWQoXCJ0cmVuZGxpbmVcIiwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuc2VsZWN0QWxsKFwiLnBvaW50XCIpXG4gICAgICAgICAgICAuZGF0YShwYXJhbXMuZGF0YSlcbiAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAuYXBwZW5kKFwiY2lyY2xlXCIpXG4gICAgICAgICAgICAuY2xhc3NlZChcInBvaW50XCIsIHRydWUpXG4gICAgICAgICAgICAuYXR0cihcInJcIiwgMik7XG4gICAgICAgIC8vdXBkYXRlXG4gICAgICAgIHRoaXMuc2VsZWN0QWxsKFwiLnRyZW5kbGluZVwiKVxuICAgICAgICAgICAgLmF0dHIoXCJkXCIsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpbmUoZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZWxlY3RBbGwoXCIucG9pbnRcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY3hcIiwgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0ZSA9IGQueGF4aXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHgoZGF0ZSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmF0dHIoXCJjeVwiLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB5KGQueWF4aXMpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5zdHlsZShcImNvbG9yXCIsIFwiI0VGNTM1MFwiKTtcbiAgICAgICAgLy9leGl0KClcbiAgICAgICAgdGhpcy5zZWxlY3RBbGwoXCIudHJlbmRsaW5lXCIpXG4gICAgICAgICAgICAuZGF0YShbcGFyYW1zLmRhdGFdKVxuICAgICAgICAgICAgLmV4aXQoKVxuICAgICAgICAgICAgLnJlbW92ZSgpO1xuICAgICAgICB0aGlzLnNlbGVjdEFsbChcIi5wb2ludFwiKVxuICAgICAgICAgICAgLmRhdGEocGFyYW1zLmRhdGEpXG4gICAgICAgICAgICAuZXhpdCgpXG4gICAgICAgICAgICAucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgcGxvdC5jYWxsKGNoYXJ0LCB7XG4gICAgICAgIGRhdGE6IGRhdGFfcGxvdCxcbiAgICAgICAgYXhpczoge1xuICAgICAgICAgICAgeDogeEF4aXMsXG4gICAgICAgICAgICB5OiB5QXhpc1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbnZhciB6YnJlYWtzPVtdO1xudmFyIHpicmVha3NfdGFidWxhcj1bXTtcblxuZnVuY3Rpb24gdml6KG0sIGpzb25fdml6ZXhwbG9yZSwgbW9kZWxfbmFtZV9zZXQpIHtcbiAgICBjb25zb2xlLmxvZygndGVzdGluZy4uLi4nLCBtLCBtb2RlbF9uYW1lX3NldCk7XG4gICAgZDMuc2VsZWN0KFwiI3RhYnVsYXJfMVwiKVxuICAgICAgICAuc3R5bGUoXCJkaXNwbGF5XCIsIFwiYmxvY2tcIik7XG4gICAgZDMuc2VsZWN0KFwiI3Bsb3RBXCIpLmh0bWwoXCJcIik7XG4gICAgZDMuc2VsZWN0KFwiI3Bsb3RCXCIpLmh0bWwoXCJcIik7XG4gICAgZDMuc2VsZWN0KFwiI1NlbGVjdGlvbkRhdGFcIikuaHRtbChcIlwiKTtcbiAgICBjb25zb2xlLmxvZyhcIlZpeiBleHBsb3JlIG1ldGhvZCBjYWxsZWQ6IFwiICsgbW9kZWxfbmFtZV9zZXQpO1xuXG4gICAgdmFyIGdldF9kYXRhID0gW107XG4gICAgZ2V0X2RhdGEgPSBtb2RlbF9uYW1lX3NldC5zcGxpdChcIi1cIik7XG5cbiAgICB2YXIgbW9kZWxfbmFtZTEgPSBnZXRfZGF0YVswXSArIFwiLVwiICsgZ2V0X2RhdGFbMV07XG4gICAgdmFyIG1vZGVsX25hbWUyID0gZ2V0X2RhdGFbMV0gKyBcIi1cIiArIGdldF9kYXRhWzBdO1xuICAgIHZhciBteW0gPSArbS5zdWJzdHIoNSwgNSkgLSAxO1xuXG4gICAgZnVuY3Rpb24gcmVtb3ZlS2lkcyhwYXJlbnQpIHtcbiAgICAgICAgd2hpbGUgKHBhcmVudC5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQocGFyZW50LmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGpzb24gPSBqc29uX3ZpemV4cGxvcmU7XG4gICAgLy8gcGlwZSBpbiBmaWd1cmVzIHRvIHJpZ2h0IHBhbmVsXG4gICAgdmFyIGZpbGVsaXN0ID0gbmV3IEFycmF5O1xuXG4gICAgLy8gaW1hZ2UgYWRkZWQgdG8gdGhlIGRpdlxuICAgIHZhciB4X2F4aXMgPSBbXTtcbiAgICB2YXIgeV9heGlzID0gW107XG4gICAgZm9yICh2YXIgaSBpbiBqc29uLnBsb3RkYXRhKSB7XG4gICAgICAgIGZvciAodmFyIGogaW4ganNvbi5wbG90ZGF0YVtpXS52YXJuYW1lKSB7XG4gICAgICAgICAgICBpZiAoanNvbi5wbG90ZGF0YVtpXS52YXJuYW1lW2pdID09PSBnZXRfZGF0YVswXSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgaW4ganNvbi5wbG90ZGF0YVtpXS5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHhfYXhpc1trXSA9IGpzb24ucGxvdGRhdGFbaV0uZGF0YVtrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoanNvbi5wbG90ZGF0YVtpXS52YXJuYW1lW2pdID09PSBnZXRfZGF0YVsxXSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgaW4ganNvbi5wbG90ZGF0YVtpXS5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHlfYXhpc1trXSA9IGpzb24ucGxvdGRhdGFbaV0uZGF0YVtrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2NhdHRlcnBsb3QnKS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgYml2YXJpYXRlUGxvdCh4X2F4aXMsIHlfYXhpcywgZ2V0X2RhdGFbMF0sIGdldF9kYXRhWzFdKTtcbiAgICBjcm9zc1RhYlBsb3RzKGdldF9kYXRhWzBdLCBnZXRfZGF0YVsxXSk7XG5cbiAgICB2YXIgY29yayA9IFtdO1xuICAgIHZhciBjb3JwID0gW107XG4gICAgdmFyIGNvcnMgPSBbXTtcbiAgICB2YXIgdmFyMSA9IFtdO1xuICAgIHZhciB2YXIyID0gW107XG4gICAgdmFyIHRhYmxlX29iaiA9IFtdO1xuICAgIHZhciBjb2xuYW1lcyA9IFtdO1xuICAgIHZhciBjb2x2YXIgPSBbXTtcbiAgICB2YXIgdGFibGVfZGF0YSA9IFtdO1xuICAgIHZhciByb3d2YXIgPSBbXTtcbiAgICB2YXIgcm93bmFtZXMgPSBbXTtcbiAgICBmdW5jdGlvbiBjcm9zc1RhYl9UYWJsZShqc29uX215KSB7XG4gICAgICAgIHZhciBqc29uMSA9IGpzb25fbXk7XG4gICAgICAgIC8vIGRhdGEgZm9yIHN0YXRpc3RpY3NcbiAgICAgICAgZm9yICh2YXIgaSBpbiBqc29uMS50YWJ1bGFyKSB7XG4gICAgICAgICAgICBpZiAoaSA9PSBtb2RlbF9uYW1lMSB8fCBpID09IG1vZGVsX25hbWUyKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiBpbiBqc29uMS50YWJ1bGFyW2ldLmNvbG5hbWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG5hbWVzLnB1c2goanNvbjEudGFidWxhcltpXS5jb2xuYW1lc1tqXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgaW4ganNvbjEudGFidWxhcikge1xuICAgICAgICAgICAgaWYgKGkgPT0gbW9kZWxfbmFtZTEgfHwgaSA9PSBtb2RlbF9uYW1lMikge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgaW4ganNvbjEudGFidWxhcltpXS5yb3duYW1lcykge1xuICAgICAgICAgICAgICAgICAgICByb3duYW1lcy5wdXNoKGpzb24xLnRhYnVsYXJbaV0ucm93bmFtZXNba10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpIGluIGpzb24xLnRhYnVsYXIpIHtcbiAgICAgICAgICAgIGlmIChpID09IG1vZGVsX25hbWUxIHx8IGkgPT0gbW9kZWxfbmFtZTIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBsIGluIGpzb24xLnRhYnVsYXJbaV0ucm93dmFyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd3Zhci5wdXNoKGpzb24xLnRhYnVsYXJbaV0ucm93dmFyW2xdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSBpbiBqc29uMS50YWJ1bGFyKSB7XG4gICAgICAgICAgICBpZiAoaSA9PSBtb2RlbF9uYW1lMSB8fCBpID09IG1vZGVsX25hbWUyKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbSBpbiBqc29uMS50YWJ1bGFyW2ldLmNvbHZhcikge1xuICAgICAgICAgICAgICAgICAgICBjb2x2YXIucHVzaChqc29uMS50YWJ1bGFyW2ldLmNvbHZhclttXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgaW4ganNvbjEudGFidWxhcikge1xuICAgICAgICAgICAgaWYgKGkgPT0gbW9kZWxfbmFtZTEgfHwgaSA9PSBtb2RlbF9uYW1lMikge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIG4gaW4ganNvbjEudGFidWxhcltpXS5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhYmxlX2RhdGFbbl0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYSA9IDA7IGEgPCBjb2xuYW1lcy5sZW5ndGg7IGErKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFibGVfZGF0YVtuXS5wdXNoKGpzb24xLnRhYnVsYXJbaV0uZGF0YVtuXVthXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgcCA9IDA7IHAgPCByb3duYW1lcy5sZW5ndGg7IHArKykgey8vIGNvbnNvbGUubG9nKFwiIHJvdyBkYXRhIDogXCIrIHApO1xuICAgICAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCBjb2xuYW1lcy5sZW5ndGg7IGwrKykge1xuICAgICAgICAgICAgICAgIHRhYmxlX29iai5wdXNoKHtyb3duYW1lOiByb3duYW1lc1twXSwgY29sbmFtZTogY29sbmFtZXNbbF0sIHZhbHVlOiB0YWJsZV9kYXRhW3BdW2xdfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZDN0YWJsZTEodGFibGVfb2JqKTtcbiAgICB9XG5cbiAgICAvLyBmb3IgdGhlIHN0YXRpc3RpY3NcbiAgICBmb3IgKHZhciBrZXkgaW4ganNvbi5zdGF0aXN0aWNhbCkge1xuICAgICAgICBpZiAoa2V5ID09IG1vZGVsX25hbWUxIHx8IGtleSA9PSBtb2RlbF9uYW1lMikge1xuICAgICAgICAgICAgZm9yICh2YXIgYSBpbiBqc29uLnN0YXRpc3RpY2FsW2tleV0uY29yaykge1xuICAgICAgICAgICAgICAgIGNvcmsucHVzaChqc29uLnN0YXRpc3RpY2FsW2tleV0uY29ya1thXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIga2V5MSBpbiBqc29uLnN0YXRpc3RpY2FsKSB7XG4gICAgICAgIGlmIChrZXkxID09IG1vZGVsX25hbWUxIHx8IGtleTEgPT0gbW9kZWxfbmFtZTIpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGIgaW4ganNvbi5zdGF0aXN0aWNhbFtrZXkxXS5jb3JwKSB7XG4gICAgICAgICAgICAgICAgY29ycC5wdXNoKGpzb24uc3RhdGlzdGljYWxba2V5MV0uY29ycFtiXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIga2V5IGluIGpzb24uc3RhdGlzdGljYWwpIHtcbiAgICAgICAgaWYgKGtleSA9PSBtb2RlbF9uYW1lMSB8fCBrZXkgPT0gbW9kZWxfbmFtZTIpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGMgaW4ganNvbi5zdGF0aXN0aWNhbFtrZXldLmNvcnMpIHtcbiAgICAgICAgICAgICAgICBjb3JzLnB1c2goanNvbi5zdGF0aXN0aWNhbFtrZXldLmNvcnNbY10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGtleSBpbiBqc29uLnN0YXRpc3RpY2FsKSB7XG4gICAgICAgIGlmIChrZXkgPT0gbW9kZWxfbmFtZTEgfHwga2V5ID09IG1vZGVsX25hbWUyKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBkIGluIGpzb24uc3RhdGlzdGljYWxba2V5XS52YXIxKSB7XG4gICAgICAgICAgICAgICAgdmFyMS5wdXNoKGpzb24uc3RhdGlzdGljYWxba2V5XS52YXIxW2RdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBrZXk0IGluIGpzb24uc3RhdGlzdGljYWwpIHtcbiAgICAgICAgaWYgKGtleSA9PSBtb2RlbF9uYW1lMSB8fCBrZXkgPT0gbW9kZWxfbmFtZTIpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGUgaW4ganNvbi5zdGF0aXN0aWNhbFtrZXldLnZhcjIpIHtcbiAgICAgICAgICAgICAgICB2YXIyLnB1c2goanNvbi5zdGF0aXN0aWNhbFtrZXldLnZhcjJbZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXBwLnpwYXJhbXMuenZhcnMubGVuZ3RoOyBpKyspXG4gICAgICAgIC8vIHdyaXRlIHRoZSByZXN1bHRzIHRhYmxlXG4gICAgICAgIHZhciByZXN1bHRzQXJyYXkgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4ganNvbi50YWJ1bGFyKSB7XG4gICAgICAgIGlmIChrZXkgPT0gXCJjb2xuYW1lc1wiKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImNvbG5hbWVzIGZvdW5kXCIpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9iaiA9IGpzb24udGFidWxhcltrZXldO1xuICAgICAgICByZXN1bHRzQXJyYXkucHVzaChvYmopO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGQzdGFibGUxKGRhdGEpIHtcbiAgICAgICAgZDMuc2VsZWN0KFwiI3RhYnVsYXJfMlwiKS5zdHlsZShcImRpc3BsYXlcIixcImJsb2NrXCIpO1xuICAgICAgICBkMy5zZWxlY3QoXCIjdGFidWxhcl8xXCIpLnN0eWxlKFwiZGlzcGxheVwiLFwibm9uZVwiKTtcbiAgICAgICAgdmFyIHdpZHRoID0gMTIwLCAgIC8vIHdpZHRoIG9mIHN2Z1xuICAgICAgICAgICAgaGVpZ2h0ID0gMTYwLCAgLy8gaGVpZ2h0IG9mIHN2Z1xuICAgICAgICAgICAgcGFkZGluZyA9IDIyOyAvLyBzcGFjZSBhcm91bmQgdGhlIGNoYXJ0LCBub3QgaW5jbHVkaW5nIGxhYmVsc1xuXG4gICAgICAgIGQzLnNlbGVjdChcIiN0YWJ1bGFyXzJcIilcbiAgICAgICAgICAgIC5odG1sKFwiXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJiYWNrZ3JvdW5kLWNvbG9yXCIsIFwiI2ZmZlwiKVxuICAgICAgICAgICAgLmFwcGVuZChcImg1XCIpXG4gICAgICAgICAgICAudGV4dChcIkNST1NTLVRBQlMgXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJjb2xvclwiLCBcIiM0MjQyNDJcIik7XG5cbiAgICAgICAgdmFyIHN2ID0gZDMuc2VsZWN0KFwiI3RhYnVsYXJfMlwiKS5hcHBlbmQoXCJzdmdcIikuYXR0cihcIndpZHRoXCIsIFwiMTAwJVwiKS5hdHRyKFwiaGVpZ2h0XCIsIFwiMTAwJVwiKS5zdHlsZShcIm92ZXJmbG93XCIsIFwidmlzaWJsZVwiKTtcbiAgICAgICAgdmFyIGZvID0gc3YuYXBwZW5kKCdmb3JlaWduT2JqZWN0JykuYXR0cihcIndpZHRoXCIsIFwiMTAwJVwiKS5hdHRyKFwiaGVpZ2h0XCIsIFwiMTAwJVwiKS5zdHlsZShcInBhZGRpbmdcIiwgMTApLmF0dHIoXCJvdmVyZmxvd1wiLCBcInZpc2libGVcIik7XG4gICAgICAgIHZhciB0YWJsZSA9IGZvLmFwcGVuZChcInhodG1sOnRhYmxlXCIpLmF0dHIoXCJjbGFzc1wiLCBcInRhYmxlXCIpLnN0eWxlKFwiYm9yZGVyLWNvbGxhcHNlXCIsIFwiIGNvbGxhcHNlXCIpLFxuICAgICAgICAgICAgdGggPSB0YWJsZS5hcHBlbmQoXCJ0clwiKS5zdHlsZShcImJvcmRlclwiLCAxKS50ZXh0KFwiX1wiKS5zdHlsZShcImNvbG9yXCIsIFwiI2ZmZlwiKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGguYXBwZW5kKFwidGRcIikuc3R5bGUoXCJib3JkZXItYm90dG9tXCIsIDEpLnN0eWxlKFwidGV4dC1hbGlnblwiLCBcImNlbnRlclwiKS5zdHlsZShcImJhY2tncm91bmQtY29sb3JcIiwgcGxvdHMuc2VsVmFyQ29sb3IpLmFwcGVuZChcImJcIikudGV4dChjb2xuYW1lc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCByb3duYW1lcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgdmFyIHBvcyA9IDA7XG4gICAgICAgICAgICB2YXIgdHIgPSB0YWJsZS5hcHBlbmQoXCJ0clwiKS5zdHlsZShcIm1hcmdpbi1sZWZ0XCIsIDIwKS5zdHlsZShcImJhY2tncm91bmQtY29sb3JcIiwgXCIjQkRCREJEXCIpLnN0eWxlKFwiYm9yZGVyXCIsIDEpLnN0eWxlKFwidGV4dC1hbGlnblwiLCBcImNlbnRlclwiKS50ZXh0KHJvd25hbWVzW2tdKTtcbiAgICAgICAgICAgIGZvciAodmFyIG0gPSAwOyBtIDwgY29sbmFtZXMubGVuZ3RoOyBtKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB6ID0gMDsgeiA8IGRhdGEubGVuZ3RoOyB6KyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvd25hbWVzW2tdID09PSBkYXRhW3pdLnJvd25hbWUgJiYgY29sbmFtZXNbbV0gPT09IGRhdGFbel0uY29sbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHIuYXBwZW5kKFwidGRcIikuc3R5bGUoXCJib3JkZXJcIiwgMSkuc3R5bGUoXCJ0ZXh0LWFsaWduXCIsIFwiY2VudGVyXCIpLnN0eWxlKFwicG9zaXRpb25cIiwgXCJyZWxhdGl2ZVwiKS5zdHlsZShcImJhY2tncm91bmQtY29sb3JcIiwgYXBwLnZhckNvbG9yKS50ZXh0KGRhdGFbel0udmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgICQoJyNzZWxlY3Rpb24nKS5jbGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJ0aGlzIGlzIHNlbGVjdGlvblwiKTtcbiAgICAgICAgZDMuc2VsZWN0KFwiI3RhYnVsYXJfMlwiKS5odG1sKFwiXCIpO1xuICAgICAgICBkMy5zZWxlY3QoXCIjdGFidWxhcl8yXCIpLnN0eWxlKFwiZGlzcGxheVwiLFwibm9uZVwiKTtcbiAgICAgICAgZDMuc2VsZWN0KFwiI3RhYnVsYXJfMVwiKS5zdHlsZShcImRpc3BsYXlcIixcImJsb2NrXCIpO1xuICAgICAgICBkMy5zZWxlY3QoXCIjcGxvdEFcIikuaHRtbChcIlwiKTtcbiAgICAgICAgZDMuc2VsZWN0KFwiI3Bsb3RCXCIpLmh0bWwoXCJcIik7XG4gICAgICAgIGQzLnNlbGVjdChcIiNTZWxlY3Rpb25EYXRhXCIpLmh0bWwoXCJcIik7XG4gICAgICAgIGNyb3NzVGFiUGxvdHMoZ2V0X2RhdGFbMF0sIGdldF9kYXRhWzFdKTtcbiAgICB9KTtcbiAgICAkKCcjY3Jvc3NUYWJzJykuY2xpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwidGhpcyBpcyBjcm9zc1RhYnNcIik7XG4gICAgICAgIGQzLnNlbGVjdChcIiNwbG90QVwiKS5odG1sKFwiXCIpO1xuICAgICAgICBkMy5zZWxlY3QoXCIjcGxvdEJcIikuaHRtbChcIlwiKTtcbiAgICAgICAgZDMuc2VsZWN0KFwiI1NlbGVjdGlvbkRhdGFcIikuaHRtbChcIlwiKTtcbiAgICAgICAgZDMuc2VsZWN0KFwiI3RhYnVsYXJfMlwiKS5odG1sKFwiXCIpO1xuICAgICAgICBleHBsb3JlX2Nyb3NzdGFiKGpzb24pO1xuICAgICAgICBlc3RpbWF0ZUxhZGRhLnN0b3AoKTsgIC8vIHN0b3Agc3Bpbm5lclxuICAgICAgICBlc3RpbWF0ZWQgPSB0cnVlO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gZXhwbG9yZV9jcm9zc3RhYihidG4pIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGFwcC56cGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYXBwLnpwYXJhbXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIC8vIGRvIHNvbWV0aGluZyB3aXRoIGBrZXknXG4gICAgICAgICAgICAgICAgaWYoa2V5PT09XCJ6Y3Jvc3N0YWJzXCIpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgYXBwLnpwYXJhbXNba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB3cml0ZUNyb3NzVGFic0pzb24oKSB7XG4gICAgICAgICAgICB2YXIgcGxvdEF2YWw9dmFyc2l6ZTEscGxvdEJ2YWw9dmFyc2l6ZTI7XG4gICAgICAgICAgICBpZihpc05hTihwbG90QXZhbCkpIHtcbiAgICAgICAgICAgICAgICBwbG90QXZhbD0xMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGlzTmFOKHBsb3RCdmFsKSl7cGxvdEJ2YWw9MTA7fVxuICAgICAgICAgICAgdmFyIGpzb25kYXRhID0ge1xuICAgICAgICAgICAgICAgIHZhcjE6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogcGxvdG5hbWVhLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcGxvdEF2YWwsXG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvblR5cGU6IHZhcm4xXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB2YXIyOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHBsb3RuYW1lYixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHBsb3RCdmFsLFxuICAgICAgICAgICAgICAgICAgICBidXR0b25UeXBlOiB2YXJuMlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoanNvbmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGFwcC56cGFyYW1zLnpjcm9zc3RhYi5wdXNoKHdyaXRlQ3Jvc3NUYWJzSnNvbigpKTtcbiAgICAgICAgaWYgKFBST0RVQ1RJT04gJiYgYXBwLnpwYXJhbXMuenNlc3Npb25pZCA9PSBcIlwiKSB7XG4gICAgICAgICAgICBhbGVydChcIldhcm5pbmc6IERhdGEgZG93bmxvYWQgaXMgbm90IGNvbXBsZXRlLiBUcnkgYWdhaW4gc29vbi5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYXBwLnpQb3AoKTtcblxuICAgICAgICAvLyB3cml0ZSBsaW5rcyB0byBmaWxlICYgcnVuIFIgQ01EXG4gICAgICAgIGFwcC56cGFyYW1zLmNhbGxIaXN0b3J5ID0gYXBwLmNhbGxIaXN0b3J5O1xuICAgICAgICB2YXIganNvbm91dCA9IEpTT04uc3RyaW5naWZ5KGFwcC56cGFyYW1zKTtcblxuICAgICAgICB1cmxjYWxsID0gcmFwcFVSTCArIFwiZXhwbG9yZWFwcFwiOyAvL2Jhc2UuY29uY2F0KGpzb25vdXQpO1xuICAgICAgICB2YXIgc29sYWpzb25vdXQgPSBcInNvbGFKU09OPVwiICsganNvbm91dDtcbiAgICAgICAgY29uc29sZS5sb2coXCJQT1NUIG91dCB0aGlzOiBcIiwgc29sYWpzb25vdXQpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGV4cGxvcmVfY3Jvc3N0YWJTdWNjZXNzKGpzb24pIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY3Jvc3NUYWJTdWNjZXNzXCIpO1xuICAgICAgICAgICAgZDMuanNvbihcInJvb2svbXlyZXN1bHQyLmpzb25cIiwgZnVuY3Rpb24gKGVycm9yLCBqc29uKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gY29uc29sZS53YXJuKGVycm9yKTtcbiAgICAgICAgICAgICAgICB2YXIganNvbmRhdGEgPSBqc29uO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZXhwbG9yZSBEQVRBIGpzb246IFwiLCBqc29uZGF0YSk7XG4gICAgICAgICAgICAgICAgY3Jvc3NUYWJfVGFibGUoanNvbmRhdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZXhwbG9yZV9jcm9zc3RhYkZhaWwoKSB7XG4gICAgICAgICAgICBlc3RpbWF0ZUxhZGRhLnN0b3AoKTsgIC8vIHN0b3Agc3Bpbm5lclxuICAgICAgICAgICAgZXN0aW1hdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlc3RpbWF0ZUxhZGRhLnN0YXJ0KCk7ICAvLyBzdGFydCBzcGlubmVyXG4gICAgICAgIG1ha2VDb3JzUmVxdWVzdCh1cmxjYWxsLCBidG4sIGV4cGxvcmVfY3Jvc3N0YWJTdWNjZXNzLCBleHBsb3JlX2Nyb3NzdGFiRmFpbCwgc29sYWpzb25vdXQpO1xuICAgIH1cblxuICAgIC8vIGRhdGEgZm9yIHRoZSBzdGF0aXN0aWNhbCBkaXZcbiAgICB2YXIgc3RyaW5nMSA9IGNvcmsudG9TdHJpbmcoKTtcbiAgICB2YXIgc3RyaW5nMyA9IHN0cmluZzEuc3Vic3RyaW5nKHN0cmluZzEuaW5kZXhPZihcIjpcIiksIHN0cmluZzEubGVuZ3RoKTtcbiAgICB2YXIgc3RyaW5nMiA9IHN0cmluZzEuc3Vic3RyaW5nKDAsIHN0cmluZzEuaW5kZXhPZihcImNcIikpO1xuICAgIHZhciBzdHJpbmc0ID0gY29ycC50b1N0cmluZygpO1xuICAgIHZhciBzdHJpbmc2ID0gc3RyaW5nNC5zdWJzdHJpbmcoc3RyaW5nNC5pbmRleE9mKFwiOlwiKSwgc3RyaW5nNC5sZW5ndGgpO1xuICAgIHZhciBzdHJpbmc1ID0gc3RyaW5nNC5zdWJzdHJpbmcoMCwgc3RyaW5nNC5pbmRleE9mKFwiY1wiKSk7XG4gICAgdmFyIHN0cmluZzcgPSBjb3JzLnRvU3RyaW5nKCk7XG4gICAgdmFyIHN0cmluZzkgPSBzdHJpbmc3LnN1YnN0cmluZyhzdHJpbmc3LmluZGV4T2YoXCI6XCIpLCBzdHJpbmc3Lmxlbmd0aCk7XG4gICAgdmFyIHN0cmluZzggPSBzdHJpbmc3LnN1YnN0cmluZygwLCBzdHJpbmc3LmluZGV4T2YoXCJjXCIpKTtcbiAgICB2YXIgc3RhdGlzdGljYWxfZGF0YSA9IFtcbiAgICAgICAge2NvcnJlbGF0aW9uOiBzdHJpbmcyLCB2YWx1ZTogc3RyaW5nM30sXG4gICAgICAgIHtjb3JyZWxhdGlvbjogc3RyaW5nNSwgdmFsdWU6IHN0cmluZzZ9LFxuICAgICAgICB7Y29ycmVsYXRpb246IHN0cmluZzgsIHZhbHVlOiBzdHJpbmc5fVxuICAgIF07XG5cbiAgICBmdW5jdGlvbiBkM3RhYmxlKGRhdGEpIHtcbiAgICAgICAgZDMuc2VsZWN0KFwiI3Jlc3VsdHNWaWV3X3N0YXRpc3RpY3NcIilcbiAgICAgICAgICAgIC5odG1sKFwiXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJiYWNrZ3JvdW5kLWNvbG9yXCIsIFwiI2ZmZlwiKVxuICAgICAgICAgICAgLmFwcGVuZChcImg1XCIpXG4gICAgICAgICAgICAudGV4dChcIkNPUlJFTEFUSU9OIFNUQVRJU1RJQ1MgXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJjb2xvclwiLCBcIiM0MjQyNDJcIik7XG4gICAgICAgIHZhciB0YWJsZSA9IGQzLnNlbGVjdChcIiNyZXN1bHRzVmlld19zdGF0aXN0aWNzXCIpLmFwcGVuZChcInRhYmxlXCIpLmF0dHIoXCJjbGFzc1wiLCBcInRhYmxlXCIpLnN0eWxlKFwiYm9yZGVyLWNvbGxhcHNlXCIsIFwiIGNvbGxhcHNlXCIpLFxuICAgICAgICAgICAgdGggPSB0YWJsZS5hcHBlbmQoXCJ0clwiKS5zdHlsZShcImJvcmRlclwiLCAxKTtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBPYmplY3Qua2V5cyhkYXRhWzBdKSkge1xuICAgICAgICAgICAgdGguYXBwZW5kKFwidGRcIikuc3R5bGUoXCJib3JkZXItYm90dG9tXCIsIDEpLnN0eWxlKFwidGV4dC1hbGlnblwiLCBcImxlZnRcIikuc3R5bGUoXCJiYWNrZ3JvdW5kLWNvbG9yXCIsIHBsb3RzLnNlbFZhckNvbG9yKS5hcHBlbmQoXCJiXCIpLnRleHQoT2JqZWN0LmtleXMoZGF0YVswXSlbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIHJvdyBpbiBkYXRhKSB7XG4gICAgICAgICAgICB2YXIgdHIgPSB0YWJsZS5hcHBlbmQoXCJ0clwiKS5zdHlsZShcIm1hcmdpbi1sZWZ0XCIsIDQwKS5zdHlsZShcImJvcmRlclwiLCAxKS5zdHlsZShcInRleHQtYWxpZ25cIiwgXCJsZWZ0XCIpO1xuICAgICAgICAgICAgZm9yICh2YXIgdGQgaW4gZGF0YVtyb3ddKVxuICAgICAgICAgICAgICAgIHRyLmFwcGVuZChcInRkXCIpLnN0eWxlKFwiYm9yZGVyXCIsIDEpLnN0eWxlKFwidGV4dC1hbGlnblwiLCBcImxlZnRcIikuc3R5bGUoXCJwb3NpdGlvblwiLCBcInJlbGF0aXZlXCIpLnN0eWxlKFwiYmFja2dyb3VuZC1jb2xvclwiLCBhcHAudmFyQ29sb3IpLnRleHQoZGF0YVtyb3ddW3RkXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZDN0YWJsZShzdGF0aXN0aWNhbF9kYXRhKTtcbn1cblxuXG5mdW5jdGlvbiBtb2RlbF9zZWxlY3Rpb24obW9kZWxfc2VsZWN0aW9uX25hbWUsIGNvdW50X3ZhbHVlLCBqc29uKSB7XG4gICAgaWYgKGNvdW50X3ZhbHVlICUgMiA9PSAwICYmIGNvdW50X3ZhbHVlICE9IDApIHtcbiAgICAgICAgZDMuc2VsZWN0KFwiI21vZGVsVmlld1wiKVxuICAgICAgICAgICAgLmFwcGVuZChcInNwYW5cIilcbiAgICAgICAgICAgIC50ZXh0KFwiXFx1MDBBMCBcXHUwMEEwIFxcdTAwQTAgXFx1MDBBMCAgIFxcdTAwQTAgXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJtYXJnaW4tdG9wXCIsIDApXG4gICAgICAgICAgICAuc3R5bGUoXCJ3aGl0ZS1zcGFjZVwiLCBcInByZVwiKVxuICAgICAgICAgICAgLnN0eWxlKFwiZGlzcGxheVwiLCBcImlubGluZS1ibG9ja1wiKVxuICAgICAgICAgICAgLnN0eWxlKFwiZmxvYXRcIiwgXCJsZWZ0XCIpXG4gICAgICAgICAgICAuYXBwZW5kKFwic3BhblwiKVxuICAgICAgICAgICAgLnRleHQoXCJ8XCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJtYXJnaW4tdG9wXCIsIDApXG4gICAgICAgICAgICAuc3R5bGUoXCJ3aGl0ZS1zcGFjZVwiLCBcInByZVwiKVxuICAgICAgICAgICAgLnN0eWxlKFwiZGlzcGxheVwiLCBcImlubGluZS1ibG9ja1wiKVxuICAgICAgICAgICAgLnN0eWxlKFwiZmxvYXRcIiwgXCJsZWZ0XCIpXG4gICAgICAgICAgICAuYXBwZW5kKFwic3BhblwiKVxuICAgICAgICAgICAgLnRleHQoXCJcXHUwMEEwIFxcdTAwQTAgXFx1MDBBMCBcXHUwMEEwICAgXFx1MDBBMCBcIilcbiAgICAgICAgICAgIC5zdHlsZShcIm1hcmdpbi10b3BcIiwgMClcbiAgICAgICAgICAgIC5zdHlsZShcIndoaXRlLXNwYWNlXCIsIFwicHJlXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJkaXNwbGF5XCIsIFwiaW5saW5lLWJsb2NrXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJmbG9hdFwiLCBcImxlZnRcIik7XG5cbiAgICB9XG4gICAgZDMuc2VsZWN0KFwiI21vZGVsVmlld1wiKVxuICAgICAgICAuYXBwZW5kKFwic3BhblwiKVxuICAgICAgICAudGV4dChcIiBcXHUwMEEwXCIpXG4gICAgICAgIC5zdHlsZShcIm1hcmdpbi10b3BcIiwgMClcbiAgICAgICAgLnN0eWxlKFwiZmxvYXRcIiwgXCJsZWZ0XCIpXG5cbiAgICAgICAgLnN0eWxlKFwiZGlzcGxheVwiLCBcImlubGluZS1ibG9ja1wiKVxuICAgICAgICAuc3R5bGUoXCJ3aGl0ZS1zcGFjZVwiLCBcInByZVwiKVxuICAgICAgICAuc3R5bGUoXCJvdmVyZmxvdy15XCIsIFwiaGlkZGVuXCIpXG4gICAgICAgIC5zdHlsZShcIm92ZXJmbG93LXhcIiwgXCJzY3JvbGxcIilcbiAgICAgICAgLmFwcGVuZChcImJ1dHRvblwiKS8vIHRvcCBzdGFjayBmb3IgcmVzdWx0c1xuICAgIC8vICAgICAgLmFwcGVuZChcInhodG1sOmJ1dHRvblwiKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsXCJidG4gYnRuLW91dGxpbmUtc3VjY2Vzc1wiKVxuICAgICAgICAuc3R5bGUoXCJwYWRkaW5nXCIsXCI0cHhcIilcbiAgICAgICAgLmF0dHIoXCJpZFwiLCBtb2RlbF9zZWxlY3Rpb25fbmFtZSlcbiAgICAgICAgLnRleHQobW9kZWxfc2VsZWN0aW9uX25hbWUpXG4gICAgICAgIC5zdHlsZSgnYmFja2dyb3VuZC1jb2xvcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGNvbG9yMSA9IFwiI0ZGRDU0RlwiO1xuICAgICAgICAgICAgcmV0dXJuIGNvdW50ID09IGNvdW50MSA/IHBsb3RzLnNlbFZhckNvbG9yIDogY29sb3IxO1xuICAgICAgICB9KVxuICAgICAgICAuc3R5bGUoXCJkaXNwbGF5XCIsIFwiaW5saW5lLWJsb2NrXCIpXG4gICAgICAgIC5zdHlsZShcIndoaXRlLXNwYWNlXCIsIFwicHJlXCIpXG4gICAgICAgIC5zdHlsZShcIm1hcmdpbi10b3BcIiwgMClcbiAgICAgICAgLnN0eWxlKFwiZmxvYXRcIiwgXCJsZWZ0XCIpXG4gICAgICAgIC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGEgPSB0aGlzLnN0eWxlLmJhY2tncm91bmRDb2xvci5yZXBsYWNlKC9cXHMqL2csIFwiXCIpO1xuICAgICAgICAgICAgdmFyIGIgPSBhcHAuaGV4VG9SZ2JhKHBsb3RzLnNlbFZhckNvbG9yKS5yZXBsYWNlKC9cXHMqL2csIFwiXCIpO1xuICAgICAgICAgICAgaWYgKGEuc3Vic3RyKDAsIDE3KSA9PT0gYi5zdWJzdHIoMCwgMTcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvL2VzY2FwZXMgdGhlIGZ1bmN0aW9uIGVhcmx5IGlmIHRoZSBkaXNwbGF5ZWQgbW9kZWwgaXMgY2xpY2tlZFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdml6KHRoaXMuaWQsIGpzb24sIG1vZGVsX3NlbGVjdGlvbl9uYW1lKTtcbiAgICAgICAgICAgIGQzLnNlbGVjdChcIiNtb2RlbFZpZXdcIilcbiAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKFwiYnV0dG9uXCIpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJywgXCIjRkZENTRGXCIpO1xuICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJywgcGxvdHMuc2VsVmFyQ29sb3IpO1xuICAgICAgICB9KTtcbn1cblxuZnVuY3Rpb24gc2hvd0xvZygpIHtcbiAgICBpZiAoYXBwLmxvZ0FycmF5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgYXBwLmJ5SWQoJ2xvZ2RpdicpLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIFwiZGlzcGxheTpibG9ja1wiKTtcbiAgICAgICAgZDMuc2VsZWN0KFwiI2NvbGxhcHNlTG9nIGRpdi5wYW5lbC1ib2R5XCIpLnNlbGVjdEFsbChcInBcIilcbiAgICAgICAgICAgIC5kYXRhKGFwcC5sb2dBcnJheSlcbiAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAuYXBwZW5kKFwicFwiKVxuICAgICAgICAgICAgLnRleHQoZCA9PiBkKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhcHAuYnlJZCgnbG9nZGl2Jykuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgXCJkaXNwbGF5Om5vbmVcIik7XG59XG5cbmxldCBjb3VudCA9IDA7XG5sZXQgY291bnQxID0gMDtcblxuLyoqXG4gICBjYWxsZWQgYnkgY2xpY2tpbmcgJ0V4cGxvcmUnIGluIGV4cGxvcmUgbW9kZVxuKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBleHBsb3JlKCkge1xuICAgIGlmIChhcHAuZG93bmxvYWRJbmNvbXBsZXRlKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGFwcC56UG9wKCk7XG4gICAgY29uc29sZS5sb2coJ3pwb3A6JywgYXBwLnpwYXJhbXMpO1xuXG4gICAgLy8gd3JpdGUgbGlua3MgdG8gZmlsZSAmIHJ1biBSIENNRFxuICAgIGFwcC56cGFyYW1zLmNhbGxIaXN0b3J5ID0gYXBwLmNhbGxIaXN0b3J5O1xuICAgIGFwcC5lc3RpbWF0ZUxhZGRhLnN0YXJ0KCk7IC8vIHN0YXJ0IHNwaW5uZXJcbiAgICBsZXQganNvbiA9IGF3YWl0IGFwcC5tYWtlUmVxdWVzdChST09LX1NWQ19VUkwgKyAnZXhwbG9yZWFwcCcsIGFwcC56cGFyYW1zKTtcbiAgICBhcHAuZXN0aW1hdGVkID0gdHJ1ZTtcbiAgICBpZiAoIWpzb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhcHAuYWxsUmVzdWx0cy5wdXNoKGpzb24pO1xuXG4gICAgZDMuc2VsZWN0KCcjcmlnaHRwYW5lbCcpXG4gICAgICAgIC5zdHlsZSgnd2lkdGgnLCAnNzUlJyk7XG5cbiAgICBsZXQgcGFyZW50ID0gYXBwLmJ5SWQoJ3JpZ2h0Q29udGVudEFyZWEnKTtcbiAgICBhcHAuZXN0aW1hdGVkIHx8IHBhcmVudC5yZW1vdmVDaGlsZChhcHAuYnlJZCgncmVzdWx0c0hvbGRlcicpKTtcbiAgICBkMy5zZWxlY3QoXCIjbW9kZWxWaWV3XCIpLmh0bWwoJycpO1xuICAgIGQzLnNlbGVjdChcIiNyZXN1bHRzVmlld19zdGF0aXN0aWNzXCIpLmh0bWwoJycpO1xuXG4gICAgZDMuc2VsZWN0KFwiI3Jlc3VsdF9sZWZ0XCIpXG4gICAgICAgIC5zdHlsZShcImRpc3BsYXlcIiwgXCJibG9ja1wiKTtcbiAgICBkMy5zZWxlY3QoXCIjcmVzdWx0X3JpZ2h0XCIpXG4gICAgICAgIC5zdHlsZShcImRpc3BsYXlcIiwgXCJibG9ja1wiKTtcbiAgICBkMy5zZWxlY3QoXCIjc2NhdHRlcnBsb3RcIilcbiAgICAgICAgLnN0eWxlKFwiZGlzcGxheVwiLCBcImJsb2NrXCIpO1xuICAgIGQzLnNlbGVjdChcIiNoZWF0Y2hhcnRcIilcbiAgICAgICAgLnN0eWxlKFwiZGlzcGxheVwiLCBcImJsb2NrXCIpO1xuICAgIGQzLnNlbGVjdChcIiNtb2RlbFZpZXdfQ29udGFpbmVyXCIpXG4gICAgICAgIC5zdHlsZShcImRpc3BsYXlcIiwgXCJibG9ja1wiKTtcbiAgICBkMy5zZWxlY3QoXCIjbW9kZWxWaWV3XCIpXG4gICAgICAgIC5zdHlsZShcImRpc3BsYXlcIiwgXCJibG9ja1wiKTtcbiAgICBkMy5zZWxlY3QoXCIjcmVzdWx0c1ZpZXdfdGFidWxhclwiKVxuICAgICAgICAuc3R5bGUoXCJkaXNwbGF5XCIsIFwiYmxvY2tcIik7XG4gICAgZDMuc2VsZWN0KFwiI3Jlc3VsdHNWaWV3X3N0YXRpc3RpY3NcIilcbiAgICAgICAgLnN0eWxlKFwiZGlzcGxheVwiLCBcImJsb2NrXCIpO1xuXG4gICAgZDMuc2VsZWN0KFwiI21vZGVsVmlld1wiKVxuICAgICAgICAuc3R5bGUoJ2JhY2tncm91bmQtY29sb3InLCBhcHAuaGV4VG9SZ2JhKGFwcC52YXJDb2xvcikpXG4gICAgICAgIC5zdHlsZShcIm92ZXJmbG93LXlcIiwgXCJoaWRkZW5cIilcbiAgICAgICAgLnN0eWxlKFwib3ZlcmZsb3cteFwiLCBcInNjcm9sbFwiKVxuICAgICAgICAuYXBwZW5kKFwic3BhblwiKVxuICAgICAgICAuc3R5bGUoXCJ3aGl0ZS1zcGFjZVwiLCBcInByZVwiKVxuICAgICAgICAuc3R5bGUoXCJtYXJnaW4tdG9wXCIsIDApXG4gICAgICAgIC5zdHlsZShcImZsb2F0XCIsIFwibGVmdFwiKVxuICAgICAgICAuc3R5bGUoXCJwb3NpdGlvblwiLCBcInJlbGF0aXZlXCIpXG4gICAgICAgIC5zdHlsZShcImNvbG9yXCIsIFwiIzc1NzU3NVwiKVxuICAgICAgICAudGV4dChcIk1PREVMIFNFTEVDVElPTiA6ICBcIik7XG5cbiAgICAvLyBwcm9ncmFtbWF0aWMgY2xpY2sgb24gUmVzdWx0cyBidXR0b25cbiAgICAkKFwiI2J0bkJpdmFyaWF0ZVwiKS50cmlnZ2VyKFwiY2xpY2tcIik7XG4gICAgbGV0IG1vZGVsX25hbWU7XG4gICAgZm9yIChsZXQgaW1nIGluIGpzb24uaW1hZ2VzKSB7XG4gICAgICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgbW9kZWxfbmFtZSA9IGltZztcbiAgICAgICAgfVxuICAgICAgICBtb2RlbF9zZWxlY3Rpb24oaW1nLCBjb3VudCwganNvbik7IC8vIGZvciBlbnRlcmluZyBhbGwgdGhlIHZhcmlhYmxlc1xuICAgICAgICBjb3VudCsrO1xuICAgIH1cbiAgICBjb3VudDEgPSBjb3VudCAtIDE7XG4gICAgYXBwLm1vZGVsQ291bnQrKztcblxuICAgIHZhciByQ2FsbCA9IFtdO1xuICAgIHJDYWxsWzBdID0ganNvbi5jYWxsO1xuICAgIGFwcC5sb2dBcnJheS5wdXNoKFwiZXhwbG9yZTogXCIuY29uY2F0KHJDYWxsWzBdKSk7XG4gICAgc2hvd0xvZygpO1xuICAgIHZpeihtb2RlbF9uYW1lLCBqc29uLCBtb2RlbF9uYW1lKTtcbn1cblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYXNzZXRzL2FwcC9leHBsb3JlLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5\n')},function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.getClasses = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mithril = __webpack_require__(0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _app = __webpack_require__(1);\n\nvar app = _interopRequireWildcard(_app);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar getClasses = exports.getClasses = function getClasses(cls, panel) {\n    return cls + (panel.closed ? '.closepanel' : panel.side === 'left' && app.lefttab === 'tab2' ? '.expandpanel' : '');\n};\n\nvar Panel = function () {\n    function Panel() {\n        _classCallCheck(this, Panel);\n    }\n\n    _createClass(Panel, [{\n        key: 'oninit',\n        value: function oninit(vnode) {\n            this.closed = false;\n        }\n    }, {\n        key: 'view',\n        value: function view(vnode) {\n            var _this = this;\n\n            var _vnode$attrs = vnode.attrs,\n                side = _vnode$attrs.side,\n                title = _vnode$attrs.title,\n                buttons = _vnode$attrs.buttons;\n\n            var dot = [_mithril2.default.trust('&#9679;'), (0, _mithril2.default)('br')];\n            return (0, _mithril2.default)(getClasses('#' + side + 'panel.sidepanel.container.clearfix', this), (0, _mithril2.default)('#toggle' + (side === 'left' ? 'L' : 'R') + 'panelicon.panelbar[style=height: 100%]', (0, _mithril2.default)('span', { onclick: function onclick(_) {\n                    return _this.closed = !_this.closed;\n                } }, dot, dot, dot, dot)), (0, _mithril2.default)('#' + side + 'paneltitle.panel-heading.text-center', (0, _mithril2.default)(\"h3.panel-title\", title)), (0, _mithril2.default)('ul' + (side === 'right' ? '#rightpanelbuttons' : '') + '.accordion', buttons.map(function (b) {\n                return (0, _mithril2.default)('li', b);\n            })), (0, _mithril2.default)(getClasses('.row-fluid', this), (0, _mithril2.default)('#' + side + 'panelcontent', (0, _mithril2.default)('#' + side + 'ContentArea[style=height: calc(100vh - 213px); overflow: auto]', vnode.children))));\n        }\n    }]);\n\n    return Panel;\n}();\n\nexports.default = Panel;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvYXBwL3ZpZXdzL1BhbmVsLmpzPzkyNGYiXSwibmFtZXMiOlsiYXBwIiwiZ2V0Q2xhc3NlcyIsImNscyIsInBhbmVsIiwiY2xvc2VkIiwic2lkZSIsImxlZnR0YWIiLCJQYW5lbCIsInZub2RlIiwiYXR0cnMiLCJ0aXRsZSIsImJ1dHRvbnMiLCJkb3QiLCJ0cnVzdCIsIm9uY2xpY2siLCJtYXAiLCJiIiwiY2hpbGRyZW4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOzs7O0FBRUE7O0lBQVlBLEc7Ozs7Ozs7O0FBRUwsSUFBSUMsa0NBQWEsU0FBYkEsVUFBYSxDQUFTQyxHQUFULEVBQWNDLEtBQWQsRUFBcUI7QUFDekMsV0FBT0QsT0FBT0MsTUFBTUMsTUFBTixHQUFlLGFBQWYsR0FDVEQsTUFBTUUsSUFBTixLQUFlLE1BQWYsSUFBeUJMLElBQUlNLE9BQUosS0FBZ0IsTUFBMUMsR0FBb0QsY0FBcEQsR0FDQSxFQUZHLENBQVA7QUFHSCxDQUpNOztJQU1EQyxLOzs7Ozs7OytCQUNLQyxLLEVBQU87QUFDVixpQkFBS0osTUFBTCxHQUFjLEtBQWQ7QUFDSDs7OzZCQUVJSSxLLEVBQU87QUFBQTs7QUFBQSwrQkFDcUJBLE1BQU1DLEtBRDNCO0FBQUEsZ0JBQ0hKLElBREcsZ0JBQ0hBLElBREc7QUFBQSxnQkFDR0ssS0FESCxnQkFDR0EsS0FESDtBQUFBLGdCQUNVQyxPQURWLGdCQUNVQSxPQURWOztBQUVSLGdCQUFNQyxNQUFNLENBQUMsa0JBQUVDLEtBQUYsQ0FBUSxTQUFSLENBQUQsRUFBcUIsdUJBQUUsSUFBRixDQUFyQixDQUFaO0FBQ0EsbUJBQU8sdUJBQ0haLGlCQUFlSSxJQUFmLHlDQUF5RCxJQUF6RCxDQURHLEVBRUgsb0NBQVlBLFNBQVMsTUFBVCxHQUFrQixHQUFsQixHQUF3QixHQUFwQyw4Q0FDRSx1QkFBRSxNQUFGLEVBQVUsRUFBQ1MsU0FBUztBQUFBLDJCQUFLLE1BQUtWLE1BQUwsR0FBYyxDQUFDLE1BQUtBLE1BQXpCO0FBQUEsaUJBQVYsRUFBVixFQUFzRFEsR0FBdEQsRUFBMkRBLEdBQTNELEVBQWdFQSxHQUFoRSxFQUFxRUEsR0FBckUsQ0FERixDQUZHLEVBSUgsNkJBQU1QLElBQU4sMkNBQ0UsdUJBQUUsZ0JBQUYsRUFBb0JLLEtBQXBCLENBREYsQ0FKRyxFQU1ILCtCQUFPTCxTQUFTLE9BQVQsR0FBbUIsb0JBQW5CLEdBQTBDLEVBQWpELGtCQUNFTSxRQUFRSSxHQUFSLENBQVk7QUFBQSx1QkFBSyx1QkFBRSxJQUFGLEVBQVFDLENBQVIsQ0FBTDtBQUFBLGFBQVosQ0FERixDQU5HLEVBUUgsdUJBQUVmLFdBQVcsWUFBWCxFQUF5QixJQUF6QixDQUFGLEVBQ0UsNkJBQU1JLElBQU4sbUJBQ0UsNkJBQU1BLElBQU4scUVBQTRFRyxNQUFNUyxRQUFsRixDQURGLENBREYsQ0FSRyxDQUFQO0FBV0g7Ozs7OztrQkFHVVYsSyIsImZpbGUiOiI2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCc7XG5cbmltcG9ydCAqIGFzIGFwcCBmcm9tICcuLi9hcHAnO1xuXG5leHBvcnQgbGV0IGdldENsYXNzZXMgPSBmdW5jdGlvbihjbHMsIHBhbmVsKSB7XG4gICAgcmV0dXJuIGNscyArIChwYW5lbC5jbG9zZWQgPyAnLmNsb3NlcGFuZWwnIDpcbiAgICAgICAgKHBhbmVsLnNpZGUgPT09ICdsZWZ0JyAmJiBhcHAubGVmdHRhYiA9PT0gJ3RhYjInKSA/ICcuZXhwYW5kcGFuZWwnIDpcbiAgICAgICAgJycpO1xufTtcblxuY2xhc3MgUGFuZWwge1xuICAgIG9uaW5pdCh2bm9kZSkge1xuICAgICAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZpZXcodm5vZGUpIHtcbiAgICAgICAgbGV0IHtzaWRlLCB0aXRsZSwgYnV0dG9uc30gPSB2bm9kZS5hdHRycztcbiAgICAgICAgY29uc3QgZG90ID0gW20udHJ1c3QoJyYjOTY3OTsnKSwgbSgnYnInKV07XG4gICAgICAgIHJldHVybiBtKFxuICAgICAgICAgICAgZ2V0Q2xhc3NlcyhgIyR7c2lkZX1wYW5lbC5zaWRlcGFuZWwuY29udGFpbmVyLmNsZWFyZml4YCwgdGhpcyksXG4gICAgICAgICAgICBtKGAjdG9nZ2xlJHtzaWRlID09PSAnbGVmdCcgPyAnTCcgOiAnUid9cGFuZWxpY29uLnBhbmVsYmFyW3N0eWxlPWhlaWdodDogMTAwJV1gLFxuICAgICAgICAgICAgICBtKCdzcGFuJywge29uY2xpY2s6IF8gPT4gdGhpcy5jbG9zZWQgPSAhdGhpcy5jbG9zZWR9LCBkb3QsIGRvdCwgZG90LCBkb3QpKSxcbiAgICAgICAgICAgIG0oYCMke3NpZGV9cGFuZWx0aXRsZS5wYW5lbC1oZWFkaW5nLnRleHQtY2VudGVyYCxcbiAgICAgICAgICAgICAgbShcImgzLnBhbmVsLXRpdGxlXCIsIHRpdGxlKSksXG4gICAgICAgICAgICBtKGB1bCR7c2lkZSA9PT0gJ3JpZ2h0JyA/ICcjcmlnaHRwYW5lbGJ1dHRvbnMnIDogJyd9LmFjY29yZGlvbmAsXG4gICAgICAgICAgICAgIGJ1dHRvbnMubWFwKGIgPT4gbSgnbGknLCBiKSkpLFxuICAgICAgICAgICAgbShnZXRDbGFzc2VzKCcucm93LWZsdWlkJywgdGhpcyksXG4gICAgICAgICAgICAgIG0oYCMke3NpZGV9cGFuZWxjb250ZW50YCxcbiAgICAgICAgICAgICAgICBtKGAjJHtzaWRlfUNvbnRlbnRBcmVhW3N0eWxlPWhlaWdodDogY2FsYygxMDB2aCAtIDIxM3B4KTsgb3ZlcmZsb3c6IGF1dG9dYCwgdm5vZGUuY2hpbGRyZW4pKSkpO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUGFuZWw7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9hc3NldHMvYXBwL3ZpZXdzL1BhbmVsLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.when = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mithril = __webpack_require__(0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _app = __webpack_require__(1);\n\nvar app = _interopRequireWildcard(_app);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar when = exports.when = function when(side, val) {\n    var y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'block';\n    var n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'none';\n\n    return app[side + 'tab'] === val ? y : n;\n};\n\nvar PanelButton = function () {\n    function PanelButton() {\n        _classCallCheck(this, PanelButton);\n    }\n\n    _createClass(PanelButton, [{\n        key: 'view',\n        value: function view(vnode) {\n            var _vnode$attrs = vnode.attrs,\n                id = _vnode$attrs.id,\n                id2 = _vnode$attrs.id2,\n                classes = _vnode$attrs.classes,\n                onclick = _vnode$attrs.onclick,\n                style = _vnode$attrs.style,\n                title = _vnode$attrs.title;\n\n            var left = id2 ? true : false;\n            id2 = id2 || id;\n            return (0, _mithril2.default)('button#' + id + '.btn.' + (classes || when(left ? 'left' : 'right', id2, 'active', 'btn-default')) + '[type=button]', {\n                onclick: onclick || function (_) {\n                    return left ? app.tabLeft(id2) : app.tabRight(id2);\n                },\n                style: style,\n                title: title }, vnode.children);\n        }\n    }]);\n\n    return PanelButton;\n}();\n\nexports.default = PanelButton;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvYXBwL3ZpZXdzL1BhbmVsQnV0dG9uLmpzP2M4NTciXSwibmFtZXMiOlsiYXBwIiwid2hlbiIsInNpZGUiLCJ2YWwiLCJ5IiwibiIsIlBhbmVsQnV0dG9uIiwidm5vZGUiLCJhdHRycyIsImlkIiwiaWQyIiwiY2xhc3NlcyIsIm9uY2xpY2siLCJzdHlsZSIsInRpdGxlIiwibGVmdCIsInRhYkxlZnQiLCJ0YWJSaWdodCIsImNoaWxkcmVuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTs7OztBQUVBOztJQUFZQSxHOzs7Ozs7OztBQUVMLElBQUlDLHNCQUFPLFNBQVBBLElBQU8sQ0FBU0MsSUFBVCxFQUFlQyxHQUFmLEVBQXlDO0FBQUEsUUFBckJDLENBQXFCLHVFQUFuQixPQUFtQjtBQUFBLFFBQVZDLENBQVUsdUVBQVIsTUFBUTs7QUFDdkQsV0FBT0wsSUFBSUUsT0FBTyxLQUFYLE1BQXNCQyxHQUF0QixHQUE0QkMsQ0FBNUIsR0FBZ0NDLENBQXZDO0FBQ0gsQ0FGTTs7SUFJREMsVzs7Ozs7Ozs2QkFDR0MsSyxFQUFPO0FBQUEsK0JBQ3dDQSxNQUFNQyxLQUQ5QztBQUFBLGdCQUNIQyxFQURHLGdCQUNIQSxFQURHO0FBQUEsZ0JBQ0NDLEdBREQsZ0JBQ0NBLEdBREQ7QUFBQSxnQkFDTUMsT0FETixnQkFDTUEsT0FETjtBQUFBLGdCQUNlQyxPQURmLGdCQUNlQSxPQURmO0FBQUEsZ0JBQ3dCQyxLQUR4QixnQkFDd0JBLEtBRHhCO0FBQUEsZ0JBQytCQyxLQUQvQixnQkFDK0JBLEtBRC9COztBQUVSLGdCQUFJQyxPQUFPTCxNQUFNLElBQU4sR0FBYSxLQUF4QjtBQUNBQSxrQkFBTUEsT0FBT0QsRUFBYjtBQUNBLG1CQUFPLG1DQUFZQSxFQUFaLGNBQXNCRSxXQUFXVixLQUFLYyxPQUFPLE1BQVAsR0FBZ0IsT0FBckIsRUFBOEJMLEdBQTlCLEVBQW1DLFFBQW5DLEVBQTZDLGFBQTdDLENBQWpDLHFCQUE2RztBQUNoSEUseUJBQVNBLFdBQVk7QUFBQSwyQkFBS0csT0FBT2YsSUFBSWdCLE9BQUosQ0FBWU4sR0FBWixDQUFQLEdBQTBCVixJQUFJaUIsUUFBSixDQUFhUCxHQUFiLENBQS9CO0FBQUEsaUJBRDJGO0FBRWhIRyx1QkFBT0EsS0FGeUc7QUFHaEhDLHVCQUFPQSxLQUh5RyxFQUE3RyxFQUlIUCxNQUFNVyxRQUpILENBQVA7QUFLSDs7Ozs7O2tCQUdVWixXIiwiZmlsZSI6IjcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbSBmcm9tICdtaXRocmlsJztcblxuaW1wb3J0ICogYXMgYXBwIGZyb20gJy4uL2FwcCc7XG5cbmV4cG9ydCBsZXQgd2hlbiA9IGZ1bmN0aW9uKHNpZGUsIHZhbCwgeT0nYmxvY2snLCBuPSdub25lJykge1xuICAgIHJldHVybiBhcHBbc2lkZSArICd0YWInXSA9PT0gdmFsID8geSA6IG47XG59O1xuXG5jbGFzcyBQYW5lbEJ1dHRvbiB7XG4gICAgdmlldyh2bm9kZSkge1xuICAgICAgICBsZXQge2lkLCBpZDIsIGNsYXNzZXMsIG9uY2xpY2ssIHN0eWxlLCB0aXRsZX0gPSB2bm9kZS5hdHRycztcbiAgICAgICAgbGV0IGxlZnQgPSBpZDIgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgIGlkMiA9IGlkMiB8fCBpZDtcbiAgICAgICAgcmV0dXJuIG0oYGJ1dHRvbiMke2lkfS5idG4uJHtjbGFzc2VzIHx8IHdoZW4obGVmdCA/ICdsZWZ0JyA6ICdyaWdodCcsIGlkMiwgJ2FjdGl2ZScsICdidG4tZGVmYXVsdCcpfVt0eXBlPWJ1dHRvbl1gLCB7XG4gICAgICAgICAgICBvbmNsaWNrOiBvbmNsaWNrIHx8IChfID0+IGxlZnQgPyBhcHAudGFiTGVmdChpZDIpIDogYXBwLnRhYlJpZ2h0KGlkMikpLFxuICAgICAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICAgICAgdGl0bGU6IHRpdGxlfSxcbiAgICAgICAgICAgIHZub2RlLmNoaWxkcmVuKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBhbmVsQnV0dG9uO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYXNzZXRzL2FwcC92aWV3cy9QYW5lbEJ1dHRvbi5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mithril = __webpack_require__(0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _app = __webpack_require__(1);\n\nvar app = _interopRequireWildcard(_app);\n\nvar _plots = __webpack_require__(2);\n\nvar plots = _interopRequireWildcard(_plots);\n\nvar _Search = __webpack_require__(3);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar PanelList = function () {\n    function PanelList() {\n        _classCallCheck(this, PanelList);\n    }\n\n    _createClass(PanelList, [{\n        key: 'view',\n        value: function view(vnode) {\n            var _vnode$attrs = vnode.attrs,\n                items = _vnode$attrs.items,\n                content = _vnode$attrs.content,\n                title = _vnode$attrs.title,\n                probDesc = _vnode$attrs.probDesc;\n\n            return (0, _mithril2.default)('#varList[style=display: block]', items.map(function (v, i) {\n                return (0, _mithril2.default)('p#' + v.replace(/\\W/g, '_'), {\n                    class: probDesc ? app.d3mProblemDescription[probDesc] === v ? 'item-select' : app.locktoggle ? 'item-default item-lineout' : 'item-default' : '',\n                    style: {\n                        'background-color': probDesc ? '' : app.zparams.zdv.includes(v) ? app.hexToRgba(app.dvColor) : app.zparams.znom.includes(v) ? app.hexToRgba(app.nomColor) : app.nodes.map(function (n) {\n                            return n.name;\n                        }).includes(v) ? app.hexToRgba(plots.selVarColor) : app.varColor,\n                        'border-color': '#000000',\n                        'border-style': !probDesc && _Search.searchIndex && i < _Search.searchIndex ? 'solid' : 'none'\n                    },\n                    onclick: probDesc || app.clickVar,\n                    onmouseover: function onmouseover() {\n                        $(this).popover('toggle');\n                        if (probDesc) return;\n                        $(\"body div.popover\").addClass(\"variables\");\n                        $(\"body div.popover div.popover-content\").addClass(\"form-horizontal\");\n                    },\n                    onmouseout: \"$(this).popover('toggle');\",\n                    'data-container': 'body',\n                    'data-content': content ? content(v) : app.popoverContent(app.findNodeIndex(v, true)),\n                    'data-html': 'true',\n                    'data-original-title': title,\n                    'data-placement': probDesc ? 'top' : 'right',\n                    'data-toggle': 'popover',\n                    'data-trigger': 'hover' }, v);\n            }));\n        }\n    }]);\n\n    return PanelList;\n}();\n\nexports.default = PanelList;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvYXBwL3ZpZXdzL1BhbmVsTGlzdC5qcz9mNjE3Il0sIm5hbWVzIjpbImFwcCIsInBsb3RzIiwiUGFuZWxMaXN0Iiwidm5vZGUiLCJhdHRycyIsIml0ZW1zIiwiY29udGVudCIsInRpdGxlIiwicHJvYkRlc2MiLCJtYXAiLCJ2IiwiaSIsInJlcGxhY2UiLCJjbGFzcyIsImQzbVByb2JsZW1EZXNjcmlwdGlvbiIsImxvY2t0b2dnbGUiLCJzdHlsZSIsInpwYXJhbXMiLCJ6ZHYiLCJpbmNsdWRlcyIsImhleFRvUmdiYSIsImR2Q29sb3IiLCJ6bm9tIiwibm9tQ29sb3IiLCJub2RlcyIsIm4iLCJuYW1lIiwic2VsVmFyQ29sb3IiLCJ2YXJDb2xvciIsIm9uY2xpY2siLCJjbGlja1ZhciIsIm9ubW91c2VvdmVyIiwiJCIsInBvcG92ZXIiLCJhZGRDbGFzcyIsIm9ubW91c2VvdXQiLCJwb3BvdmVyQ29udGVudCIsImZpbmROb2RlSW5kZXgiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7Ozs7QUFFQTs7SUFBWUEsRzs7QUFDWjs7SUFBWUMsSzs7QUFFWjs7Ozs7Ozs7SUFFTUMsUzs7Ozs7Ozs2QkFDR0MsSyxFQUFPO0FBQUEsK0JBQ2dDQSxNQUFNQyxLQUR0QztBQUFBLGdCQUNIQyxLQURHLGdCQUNIQSxLQURHO0FBQUEsZ0JBQ0lDLE9BREosZ0JBQ0lBLE9BREo7QUFBQSxnQkFDYUMsS0FEYixnQkFDYUEsS0FEYjtBQUFBLGdCQUNvQkMsUUFEcEIsZ0JBQ29CQSxRQURwQjs7QUFFUixtQkFBTyx1QkFDSCxnQ0FERyxFQUVISCxNQUFNSSxHQUFOLENBQVUsVUFBQ0MsQ0FBRCxFQUFJQyxDQUFKO0FBQUEsdUJBQ0EsOEJBQU9ELEVBQUVFLE9BQUYsQ0FBVSxLQUFWLEVBQWlCLEdBQWpCLENBQVAsRUFBZ0M7QUFDNUJDLDJCQUFPTCxXQUNGUixJQUFJYyxxQkFBSixDQUEwQk4sUUFBMUIsTUFBd0NFLENBQXhDLEdBQTRDLGFBQTVDLEdBQ0FWLElBQUllLFVBQUosR0FBaUIsMkJBQWpCLEdBQ0EsY0FIRSxHQUdnQixFQUpLO0FBSzVCQywyQkFBTztBQUNILDRDQUFvQlIsV0FBVyxFQUFYLEdBQ2hCUixJQUFJaUIsT0FBSixDQUFZQyxHQUFaLENBQWdCQyxRQUFoQixDQUF5QlQsQ0FBekIsSUFBOEJWLElBQUlvQixTQUFKLENBQWNwQixJQUFJcUIsT0FBbEIsQ0FBOUIsR0FDQXJCLElBQUlpQixPQUFKLENBQVlLLElBQVosQ0FBaUJILFFBQWpCLENBQTBCVCxDQUExQixJQUErQlYsSUFBSW9CLFNBQUosQ0FBY3BCLElBQUl1QixRQUFsQixDQUEvQixHQUNBdkIsSUFBSXdCLEtBQUosQ0FBVWYsR0FBVixDQUFjO0FBQUEsbUNBQUtnQixFQUFFQyxJQUFQO0FBQUEseUJBQWQsRUFBMkJQLFFBQTNCLENBQW9DVCxDQUFwQyxJQUF5Q1YsSUFBSW9CLFNBQUosQ0FBY25CLE1BQU0wQixXQUFwQixDQUF6QyxHQUNBM0IsSUFBSTRCLFFBTEw7QUFNSCx3Q0FBZ0IsU0FOYjtBQU9ILHdDQUFnQixDQUFDcEIsUUFBRCwyQkFBNEJHLHVCQUE1QixHQUE4QyxPQUE5QyxHQUF3RDtBQVByRSxxQkFMcUI7QUFjNUJrQiw2QkFBU3JCLFlBQVlSLElBQUk4QixRQWRHO0FBZTVCQyxpQ0FBYSx1QkFBVztBQUNwQkMsMEJBQUUsSUFBRixFQUFRQyxPQUFSLENBQWdCLFFBQWhCO0FBQ0EsNEJBQUl6QixRQUFKLEVBQWM7QUFDZHdCLDBCQUFFLGtCQUFGLEVBQ0tFLFFBREwsQ0FDYyxXQURkO0FBRUFGLDBCQUFFLHNDQUFGLEVBQ0tFLFFBREwsQ0FDYyxpQkFEZDtBQUVILHFCQXRCMkI7QUF1QjVCQyxnQ0FBWSw0QkF2QmdCO0FBd0I1QixzQ0FBa0IsTUF4QlU7QUF5QjVCLG9DQUFnQjdCLFVBQVVBLFFBQVFJLENBQVIsQ0FBVixHQUF1QlYsSUFBSW9DLGNBQUosQ0FBbUJwQyxJQUFJcUMsYUFBSixDQUFrQjNCLENBQWxCLEVBQXFCLElBQXJCLENBQW5CLENBekJYO0FBMEI1QixpQ0FBYSxNQTFCZTtBQTJCNUIsMkNBQXVCSCxLQTNCSztBQTRCNUIsc0NBQWtCQyxXQUFXLEtBQVgsR0FBbUIsT0E1QlQ7QUE2QjVCLG1DQUFlLFNBN0JhO0FBOEI1QixvQ0FBZ0IsT0E5QlksRUFBaEMsRUErQkVFLENBL0JGLENBREE7QUFBQSxhQUFWLENBRkcsQ0FBUDtBQW1DSDs7Ozs7O2tCQUdVUixTIiwiZmlsZSI6IjguanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbSBmcm9tICdtaXRocmlsJztcblxuaW1wb3J0ICogYXMgYXBwIGZyb20gJy4uL2FwcCc7XG5pbXBvcnQgKiBhcyBwbG90cyBmcm9tICcuLi9wbG90cyc7XG5cbmltcG9ydCB7c2VhcmNoSW5kZXh9IGZyb20gJy4vU2VhcmNoJztcblxuY2xhc3MgUGFuZWxMaXN0IHtcbiAgICB2aWV3KHZub2RlKSB7XG4gICAgICAgIGxldCB7aXRlbXMsIGNvbnRlbnQsIHRpdGxlLCBwcm9iRGVzY30gPSB2bm9kZS5hdHRycztcbiAgICAgICAgcmV0dXJuIG0oXG4gICAgICAgICAgICAnI3Zhckxpc3Rbc3R5bGU9ZGlzcGxheTogYmxvY2tdJyxcbiAgICAgICAgICAgIGl0ZW1zLm1hcCgodiwgaSkgPT5cbiAgICAgICAgICAgICAgICAgICAgICBtKGBwIyR7di5yZXBsYWNlKC9cXFcvZywgJ18nKX1gLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOiBwcm9iRGVzYyA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYXBwLmQzbVByb2JsZW1EZXNjcmlwdGlvbltwcm9iRGVzY10gPT09IHYgPyAnaXRlbS1zZWxlY3QnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHAubG9ja3RvZ2dsZSA/ICdpdGVtLWRlZmF1bHQgaXRlbS1saW5lb3V0JyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2l0ZW0tZGVmYXVsdCcpIDogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnYmFja2dyb3VuZC1jb2xvcic6IHByb2JEZXNjID8gJycgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcC56cGFyYW1zLnpkdi5pbmNsdWRlcyh2KSA/IGFwcC5oZXhUb1JnYmEoYXBwLmR2Q29sb3IpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHAuenBhcmFtcy56bm9tLmluY2x1ZGVzKHYpID8gYXBwLmhleFRvUmdiYShhcHAubm9tQ29sb3IpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHAubm9kZXMubWFwKG4gPT4gbi5uYW1lKS5pbmNsdWRlcyh2KSA/IGFwcC5oZXhUb1JnYmEocGxvdHMuc2VsVmFyQ29sb3IpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHAudmFyQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnYm9yZGVyLWNvbG9yJzogJyMwMDAwMDAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2JvcmRlci1zdHlsZSc6ICFwcm9iRGVzYyAmJiBzZWFyY2hJbmRleCAmJiBpIDwgc2VhcmNoSW5kZXggPyAnc29saWQnIDogJ25vbmUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9uY2xpY2s6IHByb2JEZXNjIHx8IGFwcC5jbGlja1ZhcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb25tb3VzZW92ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5wb3BvdmVyKCd0b2dnbGUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9iRGVzYykgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJChcImJvZHkgZGl2LnBvcG92ZXJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoXCJ2YXJpYWJsZXNcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKFwiYm9keSBkaXYucG9wb3ZlciBkaXYucG9wb3Zlci1jb250ZW50XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKFwiZm9ybS1ob3Jpem9udGFsXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBvbm1vdXNlb3V0OiBcIiQodGhpcykucG9wb3ZlcigndG9nZ2xlJyk7XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhLWNvbnRhaW5lcic6ICdib2R5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEtY29udGVudCc6IGNvbnRlbnQgPyBjb250ZW50KHYpIDogYXBwLnBvcG92ZXJDb250ZW50KGFwcC5maW5kTm9kZUluZGV4KHYsIHRydWUpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEtaHRtbCc6ICd0cnVlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEtb3JpZ2luYWwtdGl0bGUnOiB0aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEtcGxhY2VtZW50JzogcHJvYkRlc2MgPyAndG9wJyA6ICdyaWdodCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhLXRvZ2dsZSc6ICdwb3BvdmVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEtdHJpZ2dlcic6ICdob3Zlcid9LFxuICAgICAgICAgICAgICAgICAgICAgICAgdikpKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBhbmVsTGlzdDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Fzc2V0cy9hcHAvdmlld3MvUGFuZWxMaXN0LmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mithril = __webpack_require__(0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _app = __webpack_require__(1);\n\nvar app = _interopRequireWildcard(_app);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Subpanel = function () {\n    function Subpanel() {\n        _classCallCheck(this, Subpanel);\n    }\n\n    _createClass(Subpanel, [{\n        key: 'oninit',\n        value: function oninit(vnode) {\n            this.hide = false;\n        }\n    }, {\n        key: 'view',\n        value: function view(vnode) {\n            var _this = this;\n\n            var title = vnode.attrs.title;\n            var legend = title === 'Legend';\n            var target = 'collapse' + title;\n            var z = app.zparams;\n            return (0, _mithril2.default)('#' + (legend ? \"legend.legendary\" : \"logdiv.logbox\") + '.panel.panel-default', {\n                style: { display: legend && z.ztime.length + z.zcross.length + z.zdv.length + z.znom.length || !legend && app.logArray.length > 0 ? 'block' : 'none' } }, (0, _mithril2.default)(\".panel-heading\", (0, _mithril2.default)(\"h3.panel-title\", title, (0, _mithril2.default)('span.glyphicon.glyphicon-large.glyphicon-chevron-' + (this.hide ? 'up' : 'down') + '.pull-right[data-target=#' + target + '][data-toggle=collapse][href=#' + target + ']', {\n                style: 'cursor: pointer',\n                onclick: function onclick(_) {\n                    return _this.hide = !_this.hide;\n                } }))), (0, _mithril2.default)('#' + target + '.panel-collapse.collapse.in', (0, _mithril2.default)(\".panel-body\", !legend ? app.logArray.map(function (x) {\n                return (0, _mithril2.default)('p', x);\n            }) : vnode.attrs.buttons.map(function (x) {\n                return (0, _mithril2.default)('#' + x[0] + '.clearfix.' + (z[x[1]].length === 0 ? \"hide\" : \"show\"), (0, _mithril2.default)(\".rectColor\", (0, _mithril2.default)(\"svg[style=width: 20px; height: 20px]\", (0, _mithril2.default)(\"circle[cx=10][cy=10][fill=white][r=9][stroke=black][stroke-width=2]\"))), (0, _mithril2.default)(\".rectLabel\", x[2]));\n            }))));\n        }\n    }]);\n\n    return Subpanel;\n}();\n\nexports.default = Subpanel;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvYXBwL3ZpZXdzL1N1YnBhbmVsLmpzP2ViYWIiXSwibmFtZXMiOlsiYXBwIiwiU3VicGFuZWwiLCJ2bm9kZSIsImhpZGUiLCJ0aXRsZSIsImF0dHJzIiwibGVnZW5kIiwidGFyZ2V0IiwieiIsInpwYXJhbXMiLCJzdHlsZSIsImRpc3BsYXkiLCJ6dGltZSIsImxlbmd0aCIsInpjcm9zcyIsInpkdiIsInpub20iLCJsb2dBcnJheSIsIm9uY2xpY2siLCJtYXAiLCJ4IiwiYnV0dG9ucyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7OztBQUVBOztJQUFZQSxHOzs7Ozs7OztJQUVOQyxROzs7Ozs7OytCQUNLQyxLLEVBQU87QUFDVixpQkFBS0MsSUFBTCxHQUFZLEtBQVo7QUFDSDs7OzZCQUVJRCxLLEVBQU87QUFBQTs7QUFDUixnQkFBSUUsUUFBUUYsTUFBTUcsS0FBTixDQUFZRCxLQUF4QjtBQUNBLGdCQUFJRSxTQUFTRixVQUFVLFFBQXZCO0FBQ0EsZ0JBQUlHLFNBQVMsYUFBYUgsS0FBMUI7QUFDQSxnQkFBSUksSUFBSVIsSUFBSVMsT0FBWjtBQUNBLG1CQUFPLDhCQUFNSCxTQUFTLGtCQUFULEdBQThCLGVBQXBDLDRCQUEyRTtBQUM5RUksdUJBQU8sRUFBQ0MsU0FBU0wsVUFBVUUsRUFBRUksS0FBRixDQUFRQyxNQUFSLEdBQWlCTCxFQUFFTSxNQUFGLENBQVNELE1BQTFCLEdBQW1DTCxFQUFFTyxHQUFGLENBQU1GLE1BQXpDLEdBQWtETCxFQUFFUSxJQUFGLENBQU9ILE1BQW5FLElBQTZFLENBQUNQLE1BQUQsSUFBV04sSUFBSWlCLFFBQUosQ0FBYUosTUFBYixHQUFzQixDQUE5RyxHQUFrSCxPQUFsSCxHQUE0SCxNQUF0SSxFQUR1RSxFQUEzRSxFQUVFLHVCQUFFLGdCQUFGLEVBQ0UsdUJBQUUsZ0JBQUYsRUFDRVQsS0FERixFQUVFLDhFQUFzRCxLQUFLRCxJQUFMLEdBQVksSUFBWixHQUFrQixNQUF4RSxrQ0FBMEdJLE1BQTFHLHNDQUFpSkEsTUFBakosUUFBNEo7QUFDeEpHLHVCQUFPLGlCQURpSjtBQUV4SlEseUJBQVM7QUFBQSwyQkFBSyxNQUFLZixJQUFMLEdBQVksQ0FBQyxNQUFLQSxJQUF2QjtBQUFBLGlCQUYrSSxFQUE1SixDQUZGLENBREYsQ0FGRixFQVFFLDZCQUFNSSxNQUFOLGtDQUNFLHVCQUFFLGFBQUYsRUFBaUIsQ0FBQ0QsTUFBRCxHQUFVTixJQUFJaUIsUUFBSixDQUFhRSxHQUFiLENBQWlCO0FBQUEsdUJBQUssdUJBQUUsR0FBRixFQUFPQyxDQUFQLENBQUw7QUFBQSxhQUFqQixDQUFWLEdBQTZDbEIsTUFBTUcsS0FBTixDQUFZZ0IsT0FBWixDQUFvQkYsR0FBcEIsQ0FBd0IsYUFBSztBQUN2Rix1QkFBTyw2QkFBTUMsRUFBRSxDQUFGLENBQU4sbUJBQXVCWixFQUFFWSxFQUFFLENBQUYsQ0FBRixFQUFRUCxNQUFSLEtBQW1CLENBQW5CLEdBQXVCLE1BQXZCLEdBQWdDLE1BQXZELEdBQ0UsdUJBQUUsWUFBRixFQUNFLHVCQUFFLHNDQUFGLEVBQ0UsdUJBQUUscUVBQUYsQ0FERixDQURGLENBREYsRUFJRSx1QkFBRSxZQUFGLEVBQWdCTyxFQUFFLENBQUYsQ0FBaEIsQ0FKRixDQUFQO0FBSWlDLGFBTHlCLENBQTlELENBREYsQ0FSRixDQUFQO0FBZUg7Ozs7OztrQkFHVW5CLFEiLCJmaWxlIjoiOS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuXG5pbXBvcnQgKiBhcyBhcHAgZnJvbSAnLi4vYXBwJztcblxuY2xhc3MgU3VicGFuZWwge1xuICAgIG9uaW5pdCh2bm9kZSkge1xuICAgICAgICB0aGlzLmhpZGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2aWV3KHZub2RlKSB7XG4gICAgICAgIGxldCB0aXRsZSA9IHZub2RlLmF0dHJzLnRpdGxlO1xuICAgICAgICBsZXQgbGVnZW5kID0gdGl0bGUgPT09ICdMZWdlbmQnO1xuICAgICAgICBsZXQgdGFyZ2V0ID0gJ2NvbGxhcHNlJyArIHRpdGxlO1xuICAgICAgICBsZXQgeiA9IGFwcC56cGFyYW1zO1xuICAgICAgICByZXR1cm4gbShgIyR7bGVnZW5kID8gXCJsZWdlbmQubGVnZW5kYXJ5XCIgOiBcImxvZ2Rpdi5sb2dib3hcIn0ucGFuZWwucGFuZWwtZGVmYXVsdGAsIHtcbiAgICAgICAgICAgIHN0eWxlOiB7ZGlzcGxheTogbGVnZW5kICYmIHouenRpbWUubGVuZ3RoICsgei56Y3Jvc3MubGVuZ3RoICsgei56ZHYubGVuZ3RoICsgei56bm9tLmxlbmd0aCB8fCAhbGVnZW5kICYmIGFwcC5sb2dBcnJheS5sZW5ndGggPiAwID8gJ2Jsb2NrJyA6ICdub25lJ319LFxuICAgICAgICAgICAgICAgICBtKFwiLnBhbmVsLWhlYWRpbmdcIixcbiAgICAgICAgICAgICAgICAgICBtKFwiaDMucGFuZWwtdGl0bGVcIixcbiAgICAgICAgICAgICAgICAgICAgIHRpdGxlLFxuICAgICAgICAgICAgICAgICAgICAgbShgc3Bhbi5nbHlwaGljb24uZ2x5cGhpY29uLWxhcmdlLmdseXBoaWNvbi1jaGV2cm9uLSR7dGhpcy5oaWRlID8gJ3VwJzogJ2Rvd24nfS5wdWxsLXJpZ2h0W2RhdGEtdGFyZ2V0PSMke3RhcmdldH1dW2RhdGEtdG9nZ2xlPWNvbGxhcHNlXVtocmVmPSMke3RhcmdldH1dYCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiAnY3Vyc29yOiBwb2ludGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICBvbmNsaWNrOiBfID0+IHRoaXMuaGlkZSA9ICF0aGlzLmhpZGV9KSkpLFxuICAgICAgICAgICAgICAgICBtKGAjJHt0YXJnZXR9LnBhbmVsLWNvbGxhcHNlLmNvbGxhcHNlLmluYCxcbiAgICAgICAgICAgICAgICAgICBtKFwiLnBhbmVsLWJvZHlcIiwgIWxlZ2VuZCA/IGFwcC5sb2dBcnJheS5tYXAoeCA9PiBtKCdwJywgeCkpIDogdm5vZGUuYXR0cnMuYnV0dG9ucy5tYXAoeCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtKGAjJHt4WzBdfS5jbGVhcmZpeC4ke3pbeFsxXV0ubGVuZ3RoID09PSAwID8gXCJoaWRlXCIgOiBcInNob3dcIn1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKFwiLnJlY3RDb2xvclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0oXCJzdmdbc3R5bGU9d2lkdGg6IDIwcHg7IGhlaWdodDogMjBweF1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0oXCJjaXJjbGVbY3g9MTBdW2N5PTEwXVtmaWxsPXdoaXRlXVtyPTldW3N0cm9rZT1ibGFja11bc3Ryb2tlLXdpZHRoPTJdXCIpKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0oXCIucmVjdExhYmVsXCIsIHhbMl0pKTt9KSkpKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFN1YnBhbmVsO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYXNzZXRzL2FwcC92aWV3cy9TdWJwYW5lbC5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9\n")},function(module,exports){eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvY3NzL2FwcC5jc3M/MmY3ZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIxMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hc3NldHMvY3NzL2FwcC5jc3Ncbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///10\n")},function(module,exports){eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvcGtncy9MYWRkYS9kaXN0L2xhZGRhLXRoZW1lbGVzcy5taW4uY3NzP2E2ZTEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYXNzZXRzL3BrZ3MvTGFkZGEvZGlzdC9sYWRkYS10aGVtZWxlc3MubWluLmNzc1xuLy8gbW9kdWxlIGlkID0gMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///11\n")},function(module,exports){eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvcGtncy9ib290c3RyYXAvY3NzL2Jvb3RzdHJhcC10aGVtZS5taW4uY3NzP2ZiNzQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYXNzZXRzL3BrZ3MvYm9vdHN0cmFwL2Nzcy9ib290c3RyYXAtdGhlbWUubWluLmNzc1xuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///12\n")},function(module,exports){eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2hvcHNjb3RjaC9kaXN0L2Nzcy9ob3BzY290Y2guY3NzPzYyZmEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9ob3BzY290Y2gvZGlzdC9jc3MvaG9wc2NvdGNoLmNzc1xuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///13\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n__webpack_require__(10);\n\n__webpack_require__(12);\n\n__webpack_require__(11);\n\n__webpack_require__(13);\n\nvar _mithril = __webpack_require__(0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _app = __webpack_require__(1);\n\nvar app = _interopRequireWildcard(_app);\n\nvar _explore = __webpack_require__(5);\n\nvar exp = _interopRequireWildcard(_explore);\n\nvar _plots = __webpack_require__(2);\n\nvar plots = _interopRequireWildcard(_plots);\n\nvar _Panel = __webpack_require__(6);\n\nvar _Panel2 = _interopRequireDefault(_Panel);\n\nvar _PanelButton = __webpack_require__(7);\n\nvar _PanelButton2 = _interopRequireDefault(_PanelButton);\n\nvar _PanelList = __webpack_require__(8);\n\nvar _PanelList2 = _interopRequireDefault(_PanelList);\n\nvar _Search = __webpack_require__(3);\n\nvar _Search2 = _interopRequireDefault(_Search);\n\nvar _Subpanel = __webpack_require__(9);\n\nvar _Subpanel2 = _interopRequireDefault(_Subpanel);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction setBackgroundColor(color) {\n    return function () {\n        this.style['background-color'] = color;\n    };\n}\n\nfunction leftpanel() {\n    return (0, _mithril2.default)(_Panel2.default, { side: 'left',\n        title: 'Data Selection',\n        buttons: [(0, _mithril2.default)(_PanelButton2.default, { id: 'btnVariables',\n            id2: 'tab1',\n            title: 'Click variable name to add or remove the variable pebble from the modeling space.' }, 'Variables'), (0, _mithril2.default)(_PanelButton2.default, { id: 'btnSubset', id2: 'tab2' }, 'Subset'), (0, _mithril2.default)(_PanelButton2.default, { id: 'btnSelect',\n            classes: 'btn-default.ladda-button[data-spinner-color=#000000][data-style=zoom-in]',\n            onclick: function onclick(_) {\n                return app.subsetSelect('btnSelect');\n            },\n            style: 'display: ' + (app.subset ? 'block' : 'none') + '; float: right; margin-right: 10px',\n            title: 'Subset data by the intersection of all selected values.' }, (0, _mithril2.default)('span.ladda-label[style=pointer-events: none]', 'Select'))] }, (0, _mithril2.default)('#tab1[style=display: ' + (0, _PanelButton.when)('left', 'tab1') + '; padding: 0 8px; text-align: center]', (0, _mithril2.default)(_Search2.default, { placeholder: 'Search variables and labels' }), (0, _mithril2.default)(_PanelList2.default, { items: app.valueKey, title: 'Summary Statistics' })), (0, _mithril2.default)('#tab2[style=display: ' + (0, _PanelButton.when)('left', 'tab2') + '; margin-top: .5em]'), (0, _mithril2.default)('#tab3[style=height: 350px]', (0, _mithril2.default)('p[style=padding: .5em 1em; display: ' + (0, _PanelButton.when)('left', 'tab3') + ']', { title: \"Select a variable from within the visualization in the center panel to view its summary statistics.\" }, (0, _mithril2.default)('center', (0, _mithril2.default)('b', app.summary.name), (0, _mithril2.default)('br'), (0, _mithril2.default)('i', app.summary.labl)), (0, _mithril2.default)('table', app.summary.data.map(function (tr) {\n        return (0, _mithril2.default)('tr', tr.map(function (td) {\n            return (0, _mithril2.default)('td', { onmouseover: setBackgroundColor('aliceblue'), onmouseout: setBackgroundColor('f9f9f9') }, td);\n        }));\n    })))));\n}\n\nvar righttab = function righttab(id, btnId, task, title, probDesc) {\n    return (0, _mithril2.default)('#' + id + '[style=display: ' + (0, _PanelButton.when)('right', btnId) + '; padding: 6px 12px; text-align: center]', (0, _mithril2.default)(_PanelList2.default, { items: Object.keys(task || {}),\n        title: title + ' Description',\n        content: function content(v) {\n            return task[v][1];\n        },\n        probDesc: probDesc }));\n};\n\nfunction rightpanel(mode) {\n    return mode ? (0, _mithril2.default)(_Panel2.default, { side: 'right',\n        title: 'Result Exploration',\n        buttons: [(0, _mithril2.default)(_PanelButton2.default, { id: 'btnUnivariate' }, 'Univariate'), (0, _mithril2.default)(_PanelButton2.default, { id: 'btnBivariate' }, 'Bivariate')] }, (0, _mithril2.default)('#univariate[style=display: ' + (0, _PanelButton.when)('right', 'btnUnivariate') + ']'), (0, _mithril2.default)('#bivariate[style=display: ' + (0, _PanelButton.when)('right', 'btnBivariate') + ']'), (0, _mithril2.default)('#modelView_Container', { style: 'width: 100%; height: auto; background-color: white; float: left; overflow-x: auto; overflow-y: hidden; white-space: nowrap;' }, (0, _mithril2.default)('#modelView', { style: 'width: 100%; height: 100%; background-color: white; display: none; float: left; overflow: auto; margin-top: 2px;' })), (0, _mithril2.default)('#result_left[style=width: 50%; height: 90%; float:left;background-color: white; display:none; border-right:groove; border-bottom: groove; overflow:auto; white-space:nowrap]', (0, _mithril2.default)('#scatterplot.container3[style=width: 500px; height: 50%; background-color: white; display: none; overflow: auto]'), (0, _mithril2.default)('#heatchart.container4[style=width: 500px; height:60%; display: none; overflow: auto; background-color: #FFEBEE]'), (0, _mithril2.default)('h5#NAcount[style=margin-left: 20px; display: none]'), (0, _mithril2.default)('button#linechart_welcome.btn.btn-danger[type=button][style=display: block; margin: 0 auto; position: relative]', { onclick: exp.linechart }, 'Linechart'), (0, _mithril2.default)('#linechart.container4[width: 500px; height: 320px; background-color: white; display: none; overflow:auto')), (0, _mithril2.default)('#result_right[style=width: 50%; height: 90%; float: right; background-color: white; display:none; border-right: groove; border-bottom: groove; overflow: auto; white-space: nowrap]', (0, _mithril2.default)('.btn-group.btn-toggle.col-md-4.text-center[style=width:auto; height:10%; display:block; white-space:nowrap; margin-left:170px; position:relative]', (0, _mithril2.default)('button#selection.btn.btn-primary.active', 'Selection'), (0, _mithril2.default)('button#crossTabs.btn.btn-default', 'Cross-Tabs')), (0, _mithril2.default)('#resultsView_tabular.container1[style=width:100%; height:60%; background-color:white; display:block; float:left; overflow:auto; white-space:nowrap; border-right:groove; border-bottom:groove]'), (0, _mithril2.default)('#resultsView_statistics.container2[style=width:100%; height:40%; background-color:white; display:none; clear:left; float:right; overflow:auto; white-space:nowrap; border-right:groove; border-bottom:groove]')), (0, _mithril2.default)('#resultsHolder')) :\n    // mode == null (model mode)\n    (0, _mithril2.default)(_Panel2.default, { side: 'right',\n        title: 'Model Selection',\n        buttons: [(0, _mithril2.default)(_PanelButton2.default, { id: 'btnModels', style: 'width: 100%' }, 'Models'), (0, _mithril2.default)(_PanelButton2.default, { id: 'btnSetx', style: 'width: 100%' }, 'Set Covar.'), (0, _mithril2.default)(_PanelButton2.default, { id: 'btnResults', style: 'width: 100%' }, 'Results'), (0, _mithril2.default)(_PanelButton2.default, { id: 'btnType', style: 'width: 100%' }, 'Task Type'), (0, _mithril2.default)(_PanelButton2.default, { id: 'btnSubtype', style: 'width: 100%' }, 'Subtype'), (0, _mithril2.default)(_PanelButton2.default, { id: 'btnMetrics', style: 'width: 100%' }, 'Metrics')] },\n    //      m(Button, {id: 'btnOutputs', style: 'width: 100%'}, 'Output')]},\n    (0, _mithril2.default)('#results[style=display: ' + (0, _PanelButton.when)('right', 'btnResults') + '; margin-top: .5em]', (0, _mithril2.default)(\"#resultsView.container[style=float: right; overflow: auto; width: 80%; background-color: white; white-space: nowrap]\"), (0, _mithril2.default)('#modelView[style=display: none; float: left; width: 20%; background-color: white]'), (0, _mithril2.default)(\"p#resultsHolder[style=padding: .5em 1em]\")), (0, _mithril2.default)('#setx[style=display: ' + (0, _PanelButton.when)('right', 'btnSetx') + ']', (0, _mithril2.default)('#setxLeftAll[style=display:block; float: left; width: 30%; height:100%; background-color: white]', (0, _mithril2.default)('#setxLeft[style=display:block; float: left; width: 100%; height:95%; overflow:auto; background-color: white]')), (0, _mithril2.default)('#setxRightAll[style=display:block; float: left; width: 70%; height:100%; background-color: white]', (0, _mithril2.default)('#setxRightTop[style=display:block; float: left; width: 100%; height:65%; overflow:auto; background-color: white]', (0, _mithril2.default)('#setxMiddle[style=display:block; float: left; width: 70%; height:100%; background-color: white]'), (0, _mithril2.default)('#setxRight[style=display:block; float: right; width: 30%; height:100%; background-color: white]'))), (0, _mithril2.default)('#setxRightBottom[style=display:block; float: left; width: 100%; height:35%; overflow:auto; background-color: white]', (0, _mithril2.default)('#setxRightBottomLeft[style=display:block; float: left; width: 75%; height:100%; background-color: white]'), (0, _mithril2.default)('#setxRightBottomMiddle[style=display:block; float: left; width: 15%; height:100%; background-color: white]', (0, _mithril2.default)(_PanelButton2.default, { id: 'btnExecutePipe',\n        classes: 'btn-default.ladda-button[data-spinner-color=#000000][data-style=zoom-in]',\n        onclick: function onclick(_) {\n            return app.executepipeline('btnExecutePipe');\n        },\n        style: 'display:inline; float: left; margin-right: 10px',\n        title: 'Execute pipeline.' }, (0, _mithril2.default)('span.ladda-label[style=pointer-events: none]', 'Execute'))), (0, _mithril2.default)('#setxRightBottomRight[style=display:block; float: left; width: 10%; height:100%; background-color: white]'))), righttab('models', 'btnModels'), righttab('types', 'btnType', app.d3mTaskType, 'Task', 'taskType'), righttab('subtypes', 'btnSubtype', app.d3mTaskSubtype, 'Task Subtype', 'taskSubtype'), righttab('metrics', 'btnMetrics', app.d3mMetrics, 'Metric', 'metric'));\n    //      righttab('outputs', 'btnOutputs', app.d3mOutputType, 'Output', 'outputType'));\n}\n\nvar ticker = function ticker(mode) {\n    var link = function link(name) {\n        return (0, _mithril2.default)('a' + (name === mode ? '.active' : '') + '[href=/' + name + '][style=margin-right: 0.5em]', { oncreate: _mithril2.default.route.link }, name[0].toUpperCase() + name.slice(1));\n    };\n    return (0, _mithril2.default)('#ticker[style=background: #F9F9F9; bottom: 0; height: 40px; position: fixed; width: 100%; border-top: 1px solid #ADADAD]', link('model'), link('explore'), (0, _mithril2.default)(\"a#logID[href=somelink][target=_blank][style=margin-right: 0.5em]\", \"Replication\"),\n    // dev links...\n    (0, _mithril2.default)(\"a[href='/dev-raven-links'][target=_blank][style=margin-right: 0.5em]\", \"raven-links\"), (0, _mithril2.default)(\"a[style=margin-right: 0.5em]\", { onclick: app.record_user_metadata }, \"record-metadata\"));\n};\n\nvar Body = function () {\n    function Body() {\n        _classCallCheck(this, Body);\n    }\n\n    _createClass(Body, [{\n        key: 'oninit',\n        value: function oninit() {\n            this.about = false;\n            this.cite = false;\n            this.citeHidden = false;\n        }\n    }, {\n        key: 'oncreate',\n        value: function oncreate() {\n            var extract = function extract(name, key, offset, replace) {\n                key = key + '=';\n                var loc = window.location.toString();\n                var val = loc.indexOf(key) > 0 ? loc.substring(loc.indexOf(key) + offset) : '';\n                var idx = val.indexOf('&');\n                val = idx > 0 ? val.substring(0, idx) : val;\n                val = val.replace('#!/model', '');\n                console.log(name, ': ', val);\n                if (replace) val = val.replace(/%25/g, '%').replace(/%3A/g, ':').replace(/%2F/g, '/');\n                return val;\n            };\n            app.main(extract('fileid', 'dfId', 5), extract('hostname', 'host', 5), extract('ddiurl', 'ddiurl', 7, true), extract('dataurl', 'dataurl', 8, true), extract('apikey', 'key', 4));\n        }\n    }, {\n        key: 'view',\n        value: function view(vnode) {\n            var _this = this;\n\n            var mode = vnode.attrs.mode;\n\n            var explore = mode === 'explore';\n            app.is_results_mode = mode === 'results';\n\n            var _navBtn = function _navBtn(id, left, right, onclick, args, min) {\n                return (0, _mithril2.default)('button#' + id + '.btn.navbar-right', { onclick: onclick,\n                    style: { 'margin-left': left + 'em',\n                        'margin-right': right + 'em',\n                        'min-width': min } }, args);\n            };\n            var navBtn = function navBtn(id, left, right, onclick, args, min) {\n                return _navBtn(id + '.ladda-button[data-spinner-color=#000000][data-style=zoom-in]', left, right, onclick, args, min);\n            };\n            var navBtn1 = function navBtn1(id, onclick, args, title) {\n                return _navBtn(id + '.btn-default[title=' + title + ']', 2, 0, onclick, args);\n            };\n            var glyph = function glyph(icon, unstyled) {\n                return (0, _mithril2.default)('span.glyphicon.glyphicon-' + icon + (unstyled ? '' : '[style=color: #818181; font-size: 1em; pointer-events: none]'));\n            };\n            var transformation = function transformation(id, list) {\n                return (0, _mithril2.default)('ul#' + id, {\n                    style: { display: 'none', 'background-color': app.varColor },\n                    onclick: function onclick(evt) {\n                        // if interact is selected, show variable list again\n                        if ($(this).text() === 'interact(d,e)') {\n                            $('#tInput').val(tvar.concat('*'));\n                            selInteract = true;\n                            $(this).parent().fadeOut(100);\n                            $('#transSel').fadeIn(100);\n                            evt.stopPropagation();\n                            return;\n                        }\n\n                        var tvar = $('#tInput').val();\n                        var tfunc = $(this).text().replace(\"d\", \"_transvar0\");\n                        var tcall = $(this).text().replace(\"d\", tvar);\n                        $('#tInput').val(tcall);\n                        $(this).parent().fadeOut(100);\n                        evt.stopPropagation();\n                        transform(tvar, tfunc, typeTransform = false);\n                    }\n                }, list.map(function (x) {\n                    return (0, _mithril2.default)('li', x);\n                }));\n            };\n            var spaceBtn = function spaceBtn(id, onclick, title, icon) {\n                return (0, _mithril2.default)('button#' + id + '.btn.btn-default', { onclick: onclick, title: title }, glyph(icon, true));\n            };\n\n            return (0, _mithril2.default)('main', (0, _mithril2.default)(\"nav#navbar.navbar.navbar-default.navbar-fixed-top[role=navigation]\", { style: mode === 'explore' && 'background-image: -webkit-linear-gradient(top, #fff 0, rgb(227, 242, 254) 100%)' }, (0, _mithril2.default)(\"a.navbar-brand\", (0, _mithril2.default)(\"img[src=/static/images/TwoRavens.png][alt=TwoRavens][width=100][style=margin-left: 1em; margin-top: -0.5em]\", { onmouseover: function onmouseover(_) {\n                    return _this.about = true;\n                }, onmouseout: function onmouseout(_) {\n                    return _this.about = false;\n                } })), (0, _mithril2.default)('#navbarNav[style=padding: 0.5em]', (0, _mithril2.default)('#dataField.field[style=margin-top: 0.5em; text-align: center]', (0, _mithril2.default)('h4#dataName[style=display: inline]', { onclick: function onclick(_) {\n                    return _this.cite = _this.citeHidden = !_this.citeHidden;\n                },\n                onmouseout: function onmouseout(_) {\n                    return _this.citeHidden || (_this.cite = false);\n                },\n                onmouseover: function onmouseover(_) {\n                    return _this.cite = true;\n                } }, \"Dataset Name\"), (0, _mithril2.default)('#cite.panel.panel-default', { style: 'display: ' + (this.cite ? 'block' : 'none') + '; position: absolute; right: 50%; width: 380px; text-align: left; z-index: 50' }, (0, _mithril2.default)(\".panel-body\")), (0, _mithril2.default)('span', navBtn('btnEstimate.btn-success', 2, 1, explore ? exp.explore : app.estimate, (0, _mithril2.default)(\"span.ladda-label\", explore ? 'Explore' : 'Solve This Problem'), '150px'), navBtn('btnTA2.btn-default', .5, 1, function (_) {\n                return app.helpmaterials('manual');\n            }, ['Help Manual ', glyph('book')]), navBtn('btnTA2.btn-default', 2, .5, function (_) {\n                return app.helpmaterials('video');\n            }, ['Help Video ', glyph('expand')]), navBtn1(\"btnReset\", app.reset, glyph('repeat'), 'Reset'), navBtn1('btnEndSession', app.endsession, (0, _mithril2.default)(\"span.ladda-label\", 'Mark Problem Finished'), 'Mark Problem Finished')), (0, _mithril2.default)('#tInput', {\n                style: { display: 'none' },\n                onclick: function onclick(_) {\n                    if (byId('transSel').style.display !== 'none') {\n                        // if variable list is displayed when input is clicked...\n                        $('#transSel').fadeOut(100);\n                        return false;\n                    }\n                    if (byId('transList').style.display !== 'none') {\n                        // if function list is displayed when input is clicked...\n                        $('#transList').fadeOut(100);\n                        return false;\n                    }\n\n                    // highlight the text\n                    $(_this).select();\n                    var pos = $('#tInput').offset();\n                    pos.top += $('#tInput').width();\n                    $('#transSel').fadeIn(100);\n                    return false;\n                },\n                keyup: function keyup(evt) {\n                    var t = byId('transSel').style.display;\n                    var t1 = byId('transList').style.display;\n                    if (t !== 'none') {\n                        $('#transSel').fadeOut(100);\n                    } else if (t1 !== 'none') {\n                        $('#transList').fadeOut(100);\n                    }\n\n                    if (evt.keyCode == 13) {\n                        // keyup on Enter\n                        var _t = transParse($('#tInput').val());\n                        if (!_t) {\n                            return;\n                        }\n                        transform(_t.slice(0, _t.length - 1), _t[_t.length - 1], typeTransform = false);\n                    }\n                }\n            }), (0, _mithril2.default)('#transformations.transformTool', {\n                title: 'Construct transformations of existing variables using valid R syntax.\\n                              For example, assuming a variable named d, you can enter \"log(d)\" or \"d^2\".' }, transformation('transSel', ['a', 'b']), transformation('transList', app.transformList)))), (0, _mithril2.default)('#about.panel.panel-default[style=display: ' + (this.about ? 'block' : 'none') + '; left: 140px; position: absolute; width: 500px; z-index: 50]', (0, _mithril2.default)('.panel-body', 'TwoRavens v0.1 \"Dallas\" -- The Norse god Odin had two talking ravens as advisors, who would fly out into the world and report back all they observed. In the Norse, their names were \"Thought\" and \"Memory\". In our coming release, our thought-raven automatically advises on statistical model selection, while our memory-raven accumulates previous statistical models from Dataverse, to provide cummulative guidance and meta-analysis.'))), (0, _mithril2.default)('#main.left.carousel.slide.svg-leftpanel.svg-rightpanel[style=overflow: hidden]', (0, _mithril2.default)(\"#innercarousel.carousel-inner\", (0, _mithril2.default)('#m0.item.active', (0, _mithril2.default)('svg#whitespace'))), (0, _mithril2.default)(\"#spacetools.spaceTool[style=z-index: 16]\", spaceBtn('btnLock.active', app.lockDescription, 'Lock selection of problem description', 'pencil'), spaceBtn('btnJoin', function (_) {\n                var _ref;\n\n                var links = [];\n                if (explore) {\n                    var is_unique = function is_unique(n, n1) {\n                        return links.map(function (l) {\n                            return l.target === n1 && l.source === n;\n                        }).length == 0;\n                    };\n                    links = app.nodes.map(function (n) {\n                        return app.nodes.filter(function (n1) {\n                            return n !== n1 && is_unique(n, n1);\n                        }).map(function (n1) {\n                            return {\n                                left: false,\n                                right: false,\n                                target: n,\n                                source: n1\n                            };\n                        });\n                    });\n                } else {\n                    var dvs = app.nodes.filter(function (n) {\n                        return app.zparams.zdv.includes(n.name);\n                    });\n                    var ivs = app.nodes.filter(function (n) {\n                        return !dvs.includes(n);\n                    });\n                    links = dvs.map(function (dv) {\n                        return ivs.map(function (iv) {\n                            return {\n                                left: true,\n                                right: false,\n                                target: iv,\n                                source: dv\n                            };\n                        });\n                    });\n                }\n                app.restart((_ref = []).concat.apply(_ref, _toConsumableArray(links)));\n            }, 'Make all possible connections between nodes', 'link'), spaceBtn('btnDisconnect', function (_) {\n                return app.restart([]);\n            }, 'Delete all connections between nodes', 'remove-circle'), spaceBtn('btnForce', app.forceSwitch, 'Pin the variable pebbles to the page', 'pushpin'), spaceBtn('btnEraser', app.erase, 'Wipe all variables from the modeling space', 'magnet')), (0, _mithril2.default)(_Subpanel2.default, { title: \"Legend\",\n                buttons: [['timeButton', 'ztime', 'Time'], ['csButton', 'zcross', 'Cross Sec'], ['dvButton', 'zdv', 'Dep Var'], ['nomButton', 'znom', 'Nom Var'], ['gr1Button', 'zgroup1', 'Group 1'], ['gr2Button', 'zgroup2', 'Group 2']] }), (0, _mithril2.default)(_Subpanel2.default, { title: \"History\" }), ticker(mode), leftpanel(), rightpanel(mode)));\n        }\n    }]);\n\n    return Body;\n}();\n\n_mithril2.default.route(document.body, '/model', {\n    '/model': { render: function render() {\n            return (0, _mithril2.default)(Body);\n        } },\n    '/explore': { render: function render() {\n            return (0, _mithril2.default)(Body, { mode: 'explore' });\n        } },\n    '/results': { render: function render() {\n            return (0, _mithril2.default)(Body, { mode: 'results' });\n        } }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvYXBwL2luZGV4LmpzPzMzYmUiXSwibmFtZXMiOlsiYXBwIiwiZXhwIiwicGxvdHMiLCJzZXRCYWNrZ3JvdW5kQ29sb3IiLCJjb2xvciIsInN0eWxlIiwibGVmdHBhbmVsIiwic2lkZSIsInRpdGxlIiwiYnV0dG9ucyIsImlkIiwiaWQyIiwiY2xhc3NlcyIsIm9uY2xpY2siLCJzdWJzZXRTZWxlY3QiLCJzdWJzZXQiLCJwbGFjZWhvbGRlciIsIml0ZW1zIiwidmFsdWVLZXkiLCJzdW1tYXJ5IiwibmFtZSIsImxhYmwiLCJkYXRhIiwibWFwIiwidHIiLCJvbm1vdXNlb3ZlciIsIm9ubW91c2VvdXQiLCJ0ZCIsInJpZ2h0dGFiIiwiYnRuSWQiLCJ0YXNrIiwicHJvYkRlc2MiLCJPYmplY3QiLCJrZXlzIiwiY29udGVudCIsInYiLCJyaWdodHBhbmVsIiwibW9kZSIsImxpbmVjaGFydCIsImV4ZWN1dGVwaXBlbGluZSIsImQzbVRhc2tUeXBlIiwiZDNtVGFza1N1YnR5cGUiLCJkM21NZXRyaWNzIiwidGlja2VyIiwibGluayIsIm9uY3JlYXRlIiwicm91dGUiLCJ0b1VwcGVyQ2FzZSIsInNsaWNlIiwicmVjb3JkX3VzZXJfbWV0YWRhdGEiLCJCb2R5IiwiYWJvdXQiLCJjaXRlIiwiY2l0ZUhpZGRlbiIsImV4dHJhY3QiLCJrZXkiLCJvZmZzZXQiLCJyZXBsYWNlIiwibG9jIiwid2luZG93IiwibG9jYXRpb24iLCJ0b1N0cmluZyIsInZhbCIsImluZGV4T2YiLCJzdWJzdHJpbmciLCJpZHgiLCJjb25zb2xlIiwibG9nIiwibWFpbiIsInZub2RlIiwiYXR0cnMiLCJleHBsb3JlIiwiaXNfcmVzdWx0c19tb2RlIiwiX25hdkJ0biIsImxlZnQiLCJyaWdodCIsImFyZ3MiLCJtaW4iLCJuYXZCdG4iLCJuYXZCdG4xIiwiZ2x5cGgiLCJpY29uIiwidW5zdHlsZWQiLCJ0cmFuc2Zvcm1hdGlvbiIsImxpc3QiLCJkaXNwbGF5IiwidmFyQ29sb3IiLCJldnQiLCIkIiwidGV4dCIsInR2YXIiLCJjb25jYXQiLCJzZWxJbnRlcmFjdCIsInBhcmVudCIsImZhZGVPdXQiLCJmYWRlSW4iLCJzdG9wUHJvcGFnYXRpb24iLCJ0ZnVuYyIsInRjYWxsIiwidHJhbnNmb3JtIiwidHlwZVRyYW5zZm9ybSIsIngiLCJzcGFjZUJ0biIsImVzdGltYXRlIiwiaGVscG1hdGVyaWFscyIsInJlc2V0IiwiZW5kc2Vzc2lvbiIsImJ5SWQiLCJzZWxlY3QiLCJwb3MiLCJ0b3AiLCJ3aWR0aCIsImtleXVwIiwidCIsInQxIiwia2V5Q29kZSIsInRyYW5zUGFyc2UiLCJsZW5ndGgiLCJ0cmFuc2Zvcm1MaXN0IiwibG9ja0Rlc2NyaXB0aW9uIiwibGlua3MiLCJpc191bmlxdWUiLCJuIiwibjEiLCJsIiwidGFyZ2V0Iiwic291cmNlIiwibm9kZXMiLCJmaWx0ZXIiLCJkdnMiLCJ6cGFyYW1zIiwiemR2IiwiaW5jbHVkZXMiLCJpdnMiLCJpdiIsImR2IiwicmVzdGFydCIsImZvcmNlU3dpdGNoIiwiZXJhc2UiLCJkb2N1bWVudCIsImJvZHkiLCJyZW5kZXIiXSwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7OztBQUVBOztJQUFZQSxHOztBQUNaOztJQUFZQyxHOztBQUNaOztJQUFZQyxLOztBQUNaOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7OztBQUVBLFNBQVNDLGtCQUFULENBQTRCQyxLQUE1QixFQUFtQztBQUMvQixXQUFPLFlBQVc7QUFDZCxhQUFLQyxLQUFMLENBQVcsa0JBQVgsSUFBaUNELEtBQWpDO0FBQ0gsS0FGRDtBQUdIOztBQUVELFNBQVNFLFNBQVQsR0FBcUI7QUFDakIsV0FBTyx3Q0FFSCxFQUFDQyxNQUFNLE1BQVA7QUFDQ0MsZUFBTyxnQkFEUjtBQUVDQyxpQkFBUyxDQUNMLDhDQUNFLEVBQUNDLElBQUksY0FBTDtBQUNDQyxpQkFBSyxNQUROO0FBRUNILG1CQUFPLG1GQUZSLEVB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LEVBMkNFOEIsV0FBV0MsSUFBWCxDQTNDRixDQXBFRyxDQUFQO0FBZ0hIOzs7Ozs7QUFHTCxrQkFBRVMsS0FBRixDQUFRNkYsU0FBU0MsSUFBakIsRUFBdUIsUUFBdkIsRUFBaUM7QUFDN0IsY0FBVSxFQUFDQyxRQUFRO0FBQUEsbUJBQU0sdUJBQUUzRixJQUFGLENBQU47QUFBQSxTQUFULEVBRG1CO0FBRTdCLGdCQUFZLEVBQUMyRixRQUFRO0FBQUEsbUJBQU0sdUJBQUUzRixJQUFGLEVBQVEsRUFBQ2IsTUFBTSxTQUFQLEVBQVIsQ0FBTjtBQUFBLFNBQVQsRUFGaUI7QUFHN0IsZ0JBQVksRUFBQ3dHLFFBQVE7QUFBQSxtQkFBTSx1QkFBRTNGLElBQUYsRUFBUSxFQUFDYixNQUFNLFNBQVAsRUFBUixDQUFOO0FBQUEsU0FBVDtBQUhpQixDQUFqQyIsImZpbGUiOiIxNC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAnLi4vY3NzL2FwcC5jc3MnO1xuaW1wb3J0ICcuLi9wa2dzL2Jvb3RzdHJhcC9jc3MvYm9vdHN0cmFwLXRoZW1lLm1pbi5jc3MnO1xuaW1wb3J0ICcuLi9wa2dzL0xhZGRhL2Rpc3QvbGFkZGEtdGhlbWVsZXNzLm1pbi5jc3MnO1xuaW1wb3J0ICcuLi8uLi9ub2RlX21vZHVsZXMvaG9wc2NvdGNoL2Rpc3QvY3NzL2hvcHNjb3RjaC5jc3MnO1xuXG5pbXBvcnQgbSBmcm9tICdtaXRocmlsJztcblxuaW1wb3J0ICogYXMgYXBwIGZyb20gJy4vYXBwJztcbmltcG9ydCAqIGFzIGV4cCBmcm9tICcuL2V4cGxvcmUnO1xuaW1wb3J0ICogYXMgcGxvdHMgZnJvbSAnLi9wbG90cyc7XG5pbXBvcnQgUGFuZWwgZnJvbSAnLi92aWV3cy9QYW5lbCc7XG5pbXBvcnQgQnV0dG9uLCB7d2hlbn0gZnJvbSAnLi92aWV3cy9QYW5lbEJ1dHRvbic7XG5pbXBvcnQgTGlzdCBmcm9tICcuL3ZpZXdzL1BhbmVsTGlzdCc7XG5pbXBvcnQgU2VhcmNoIGZyb20gJy4vdmlld3MvU2VhcmNoJztcbmltcG9ydCBTdWJwYW5lbCBmcm9tICcuL3ZpZXdzL1N1YnBhbmVsJztcblxuZnVuY3Rpb24gc2V0QmFja2dyb3VuZENvbG9yKGNvbG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnN0eWxlWydiYWNrZ3JvdW5kLWNvbG9yJ10gPSBjb2xvcjtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBsZWZ0cGFuZWwoKSB7XG4gICAgcmV0dXJuIG0oXG4gICAgICAgIFBhbmVsLFxuICAgICAgICB7c2lkZTogJ2xlZnQnLFxuICAgICAgICAgdGl0bGU6ICdEYXRhIFNlbGVjdGlvbicsXG4gICAgICAgICBidXR0b25zOiBbXG4gICAgICAgICAgICAgbShCdXR0b24sXG4gICAgICAgICAgICAgICB7aWQ6ICdidG5WYXJpYWJsZXMnLFxuICAgICAgICAgICAgICAgIGlkMjogJ3RhYjEnLFxuICAgICAgICAgICAgICAgIHRpdGxlOiAnQ2xpY2sgdmFyaWFibGUgbmFtZSB0byBhZGQgb3IgcmVtb3ZlIHRoZSB2YXJpYWJsZSBwZWJibGUgZnJvbSB0aGUgbW9kZWxpbmcgc3BhY2UuJ30sXG4gICAgICAgICAgICAgICAnVmFyaWFibGVzJyksXG4gICAgICAgICAgICAgbShCdXR0b24sIHtpZDogJ2J0blN1YnNldCcsIGlkMjogJ3RhYjInfSwgJ1N1YnNldCcpLFxuICAgICAgICAgICAgIG0oQnV0dG9uLFxuICAgICAgICAgICAgICAge2lkOiAnYnRuU2VsZWN0JyxcbiAgICAgICAgICAgICAgICBjbGFzc2VzOiAnYnRuLWRlZmF1bHQubGFkZGEtYnV0dG9uW2RhdGEtc3Bpbm5lci1jb2xvcj0jMDAwMDAwXVtkYXRhLXN0eWxlPXpvb20taW5dJyxcbiAgICAgICAgICAgICAgICBvbmNsaWNrOiBfID0+IGFwcC5zdWJzZXRTZWxlY3QoJ2J0blNlbGVjdCcpLFxuICAgICAgICAgICAgICAgIHN0eWxlOiBgZGlzcGxheTogJHthcHAuc3Vic2V0ID8gJ2Jsb2NrJyA6ICdub25lJ307IGZsb2F0OiByaWdodDsgbWFyZ2luLXJpZ2h0OiAxMHB4YCxcbiAgICAgICAgICAgICAgICB0aXRsZTogJ1N1YnNldCBkYXRhIGJ5IHRoZSBpbnRlcnNlY3Rpb24gb2YgYWxsIHNlbGVjdGVkIHZhbHVlcy4nfSxcbiAgICAgICAgICAgICAgIG0oJ3NwYW4ubGFkZGEtbGFiZWxbc3R5bGU9cG9pbnRlci1ldmVudHM6IG5vbmVdJywgJ1NlbGVjdCcpKV19LFxuICAgICAgICBtKGAjdGFiMVtzdHlsZT1kaXNwbGF5OiAke3doZW4oJ2xlZnQnLCAndGFiMScpfTsgcGFkZGluZzogMCA4cHg7IHRleHQtYWxpZ246IGNlbnRlcl1gLFxuICAgICAgICAgIG0oU2VhcmNoLCB7cGxhY2Vob2xkZXI6ICdTZWFyY2ggdmFyaWFibGVzIGFuZCBsYWJlbHMnfSksXG4gICAgICAgICAgbShMaXN0LCB7aXRlbXM6IGFwcC52YWx1ZUtleSwgdGl0bGU6ICdTdW1tYXJ5IFN0YXRpc3RpY3MnfSkpLFxuICAgICAgICBtKGAjdGFiMltzdHlsZT1kaXNwbGF5OiAke3doZW4oJ2xlZnQnLCAndGFiMicpfTsgbWFyZ2luLXRvcDogLjVlbV1gKSxcbiAgICAgICAgbSgnI3RhYjNbc3R5bGU9aGVpZ2h0OiAzNTBweF0nLFxuICAgICAgICAgIG0oYHBbc3R5bGU9cGFkZGluZzogLjVlbSAxZW07IGRpc3BsYXk6ICR7d2hlbignbGVmdCcsICd0YWIzJyl9XWAsXG4gICAgICAgICAgICB7dGl0bGU6IFwiU2VsZWN0IGEgdmFyaWFibGUgZnJvbSB3aXRoaW4gdGhlIHZpc3VhbGl6YXRpb24gaW4gdGhlIGNlbnRlciBwYW5lbCB0byB2aWV3IGl0cyBzdW1tYXJ5IHN0YXRpc3RpY3MuXCJ9LFxuICAgICAgICAgICAgbSgnY2VudGVyJyxcbiAgICAgICAgICAgICAgbSgnYicsIGFwcC5zdW1tYXJ5Lm5hbWUpLFxuICAgICAgICAgICAgICBtKCdicicpLFxuICAgICAgICAgICAgICBtKCdpJywgYXBwLnN1bW1hcnkubGFibCkpLFxuICAgICAgICAgICAgbSgndGFibGUnLCBhcHAuc3VtbWFyeS5kYXRhLm1hcChcbiAgICAgICAgICAgICAgICB0ciA9PiBtKCd0cicsIHRyLm1hcChcbiAgICAgICAgICAgICAgICAgICAgdGQgPT4gbSgndGQnLCB7b25tb3VzZW92ZXI6IHNldEJhY2tncm91bmRDb2xvcignYWxpY2VibHVlJyksIG9ubW91c2VvdXQ6IHNldEJhY2tncm91bmRDb2xvcignZjlmOWY5Jyl9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRkKSkpKSkpKSk7XG59XG5cbmxldCByaWdodHRhYiA9IChpZCwgYnRuSWQsIHRhc2ssIHRpdGxlLCBwcm9iRGVzYykgPT4gbShcbiAgICBgIyR7aWR9W3N0eWxlPWRpc3BsYXk6ICR7d2hlbigncmlnaHQnLCBidG5JZCl9OyBwYWRkaW5nOiA2cHggMTJweDsgdGV4dC1hbGlnbjogY2VudGVyXWAsXG4gICAgbShMaXN0LFxuICAgICAge2l0ZW1zOiBPYmplY3Qua2V5cyh0YXNrIHx8IHt9KSxcbiAgICAgICB0aXRsZTogdGl0bGUgKyAnIERlc2NyaXB0aW9uJyxcbiAgICAgICBjb250ZW50OiB2ID0+IHRhc2tbdl1bMV0sXG4gICAgICAgcHJvYkRlc2M6IHByb2JEZXNjfSkpO1xuXG5mdW5jdGlvbiByaWdodHBhbmVsKG1vZGUpIHtcbiAgICByZXR1cm4gbW9kZSA/XG4gICAgICAgIG0oUGFuZWwsXG4gICAgICAgICAge3NpZGU6ICdyaWdodCcsXG4gICAgICAgICAgIHRpdGxlOiAnUmVzdWx0IEV4cGxvcmF0aW9uJyxcbiAgICAgICAgICAgYnV0dG9uczogW1xuICAgICAgICAgICAgICAgbShCdXR0b24sIHtpZDogJ2J0blVuaXZhcmlhdGUnfSwgJ1VuaXZhcmlhdGUnKSxcbiAgICAgICAgICAgICAgIG0oQnV0dG9uLCB7aWQ6ICdidG5CaXZhcmlhdGUnfSwgJ0JpdmFyaWF0ZScpXX0sXG4gICAgICAgICAgbShgI3VuaXZhcmlhdGVbc3R5bGU9ZGlzcGxheTogJHt3aGVuKCdyaWdodCcsICdidG5Vbml2YXJpYXRlJyl9XWApLFxuICAgICAgICAgIG0oYCNiaXZhcmlhdGVbc3R5bGU9ZGlzcGxheTogJHt3aGVuKCdyaWdodCcsICdidG5CaXZhcmlhdGUnKX1dYCksXG4gICAgICAgICAgbSgnI21vZGVsVmlld19Db250YWluZXInLCB7c3R5bGU6ICd3aWR0aDogMTAwJTsgaGVpZ2h0OiBhdXRvOyBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTsgZmxvYXQ6IGxlZnQ7IG92ZXJmbG93LXg6IGF1dG87IG92ZXJmbG93LXk6IGhpZGRlbjsgd2hpdGUtc3BhY2U6IG5vd3JhcDsnfSxcbiAgICAgICAgICAgIG0oJyNtb2RlbFZpZXcnLCB7c3R5bGU6ICd3aWR0aDogMTAwJTsgaGVpZ2h0OiAxMDAlOyBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTsgZGlzcGxheTogbm9uZTsgZmxvYXQ6IGxlZnQ7IG92ZXJmbG93OiBhdXRvOyBtYXJnaW4tdG9wOiAycHg7J30pKSxcbiAgICAgICAgICBtKCcjcmVzdWx0X2xlZnRbc3R5bGU9d2lkdGg6IDUwJTsgaGVpZ2h0OiA5MCU7IGZsb2F0OmxlZnQ7YmFja2dyb3VuZC1jb2xvcjogd2hpdGU7IGRpc3BsYXk6bm9uZTsgYm9yZGVyLXJpZ2h0Omdyb292ZTsgYm9yZGVyLWJvdHRvbTogZ3Jvb3ZlOyBvdmVyZmxvdzphdXRvOyB3aGl0ZS1zcGFjZTpub3dyYXBdJyxcbiAgICAgICAgICAgIG0oJyNzY2F0dGVycGxvdC5jb250YWluZXIzW3N0eWxlPXdpZHRoOiA1MDBweDsgaGVpZ2h0OiA1MCU7IGJhY2tncm91bmQtY29sb3I6IHdoaXRlOyBkaXNwbGF5OiBub25lOyBvdmVyZmxvdzogYXV0b10nKSxcbiAgICAgICAgICAgIG0oJyNoZWF0Y2hhcnQuY29udGFpbmVyNFtzdHlsZT13aWR0aDogNTAwcHg7IGhlaWdodDo2MCU7IGRpc3BsYXk6IG5vbmU7IG92ZXJmbG93OiBhdXRvOyBiYWNrZ3JvdW5kLWNvbG9yOiAjRkZFQkVFXScpLFxuICAgICAgICAgICAgbSgnaDUjTkFjb3VudFtzdHlsZT1tYXJnaW4tbGVmdDogMjBweDsgZGlzcGxheTogbm9uZV0nKSxcbiAgICAgICAgICAgIG0oJ2J1dHRvbiNsaW5lY2hhcnRfd2VsY29tZS5idG4uYnRuLWRhbmdlclt0eXBlPWJ1dHRvbl1bc3R5bGU9ZGlzcGxheTogYmxvY2s7IG1hcmdpbjogMCBhdXRvOyBwb3NpdGlvbjogcmVsYXRpdmVdJywge29uY2xpY2s6IGV4cC5saW5lY2hhcnR9LCAnTGluZWNoYXJ0JyksXG4gICAgICAgICAgICBtKCcjbGluZWNoYXJ0LmNvbnRhaW5lcjRbd2lkdGg6IDUwMHB4OyBoZWlnaHQ6IDMyMHB4OyBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTsgZGlzcGxheTogbm9uZTsgb3ZlcmZsb3c6YXV0bycpKSxcbiAgICAgICAgICBtKCcjcmVzdWx0X3JpZ2h0W3N0eWxlPXdpZHRoOiA1MCU7IGhlaWdodDogOTAlOyBmbG9hdDogcmlnaHQ7IGJhY2tncm91bmQtY29sb3I6IHdoaXRlOyBkaXNwbGF5Om5vbmU7IGJvcmRlci1yaWdodDogZ3Jvb3ZlOyBib3JkZXItYm90dG9tOiBncm9vdmU7IG92ZXJmbG93OiBhdXRvOyB3aGl0ZS1zcGFjZTogbm93cmFwXScsXG4gICAgICAgICAgICBtKCcuYnRuLWdyb3VwLmJ0bi10b2dnbGUuY29sLW1kLTQudGV4dC1jZW50ZXJbc3R5bGU9d2lkdGg6YXV0bzsgaGVpZ2h0OjEwJTsgZGlzcGxheTpibG9jazsgd2hpdGUtc3BhY2U6bm93cmFwOyBtYXJnaW4tbGVmdDoxNzBweDsgcG9zaXRpb246cmVsYXRpdmVdJyxcbiAgICAgICAgICAgICAgbSgnYnV0dG9uI3NlbGVjdGlvbi5idG4uYnRuLXByaW1hcnkuYWN0aXZlJywgJ1NlbGVjdGlvbicpLFxuICAgICAgICAgICAgICBtKCdidXR0b24jY3Jvc3NUYWJzLmJ0bi5idG4tZGVmYXVsdCcsICdDcm9zcy1UYWJzJykpLFxuICAgICAgICAgICAgbSgnI3Jlc3VsdHNWaWV3X3RhYnVsYXIuY29udGFpbmVyMVtzdHlsZT13aWR0aDoxMDAlOyBoZWlnaHQ6NjAlOyBiYWNrZ3JvdW5kLWNvbG9yOndoaXRlOyBkaXNwbGF5OmJsb2NrOyBmbG9hdDpsZWZ0OyBvdmVyZmxvdzphdXRvOyB3aGl0ZS1zcGFjZTpub3dyYXA7IGJvcmRlci1yaWdodDpncm9vdmU7IGJvcmRlci1ib3R0b206Z3Jvb3ZlXScpLFxuICAgICAgICAgICAgbSgnI3Jlc3VsdHNWaWV3X3N0YXRpc3RpY3MuY29udGFpbmVyMltzdHlsZT13aWR0aDoxMDAlOyBoZWlnaHQ6NDAlOyBiYWNrZ3JvdW5kLWNvbG9yOndoaXRlOyBkaXNwbGF5Om5vbmU7IGNsZWFyOmxlZnQ7IGZsb2F0OnJpZ2h0OyBvdmVyZmxvdzphdXRvOyB3aGl0ZS1zcGFjZTpub3dyYXA7IGJvcmRlci1yaWdodDpncm9vdmU7IGJvcmRlci1ib3R0b206Z3Jvb3ZlXScpKSxcbiAgICAgICAgICBtKCcjcmVzdWx0c0hvbGRlcicpKSA6XG4gICAgLy8gbW9kZSA9PSBudWxsIChtb2RlbCBtb2RlKVxuICAgIG0oUGFuZWwsXG4gICAgICB7c2lkZTogJ3JpZ2h0JyxcbiAgICAgICB0aXRsZTogJ01vZGVsIFNlbGVjdGlvbicsXG4gICAgICAgYnV0dG9uczogW1xuICAgICAgICAgICBtKEJ1dHRvbiwge2lkOiAnYnRuTW9kZWxzJywgc3R5bGU6ICd3aWR0aDogMTAwJSd9LCAnTW9kZWxzJyksXG4gICAgICAgICAgIG0oQnV0dG9uLCB7aWQ6ICdidG5TZXR4Jywgc3R5bGU6ICd3aWR0aDogMTAwJSd9LCAnU2V0IENvdmFyLicpLFxuICAgICAgICAgICBtKEJ1dHRvbiwge2lkOiAnYnRuUmVzdWx0cycsIHN0eWxlOiAnd2lkdGg6IDEwMCUnfSwgJ1Jlc3VsdHMnKSxcbiAgICAgICAgICAgbShCdXR0b24sIHtpZDogJ2J0blR5cGUnLCBzdHlsZTogJ3dpZHRoOiAxMDAlJ30sICdUYXNrIFR5cGUnKSxcbiAgICAgICAgICAgbShCdXR0b24sIHtpZDogJ2J0blN1YnR5cGUnLCBzdHlsZTogJ3dpZHRoOiAxMDAlJ30sICdTdWJ0eXBlJyksXG4gICAgICAgICAgIG0oQnV0dG9uLCB7aWQ6ICdidG5NZXRyaWNzJywgc3R5bGU6ICd3aWR0aDogMTAwJSd9LCAnTWV0cmljcycpXX0sXG4gICAgIC8vICAgICAgbShCdXR0b24sIHtpZDogJ2J0bk91dHB1dHMnLCBzdHlsZTogJ3dpZHRoOiAxMDAlJ30sICdPdXRwdXQnKV19LFxuICAgICAgbShgI3Jlc3VsdHNbc3R5bGU9ZGlzcGxheTogJHt3aGVuKCdyaWdodCcsICdidG5SZXN1bHRzJyl9OyBtYXJnaW4tdG9wOiAuNWVtXWAsXG4gICAgICAgIG0oXCIjcmVzdWx0c1ZpZXcuY29udGFpbmVyW3N0eWxlPWZsb2F0OiByaWdodDsgb3ZlcmZsb3c6IGF1dG87IHdpZHRoOiA4MCU7IGJhY2tncm91bmQtY29sb3I6IHdoaXRlOyB3aGl0ZS1zcGFjZTogbm93cmFwXVwiKSxcbiAgICAgICAgbSgnI21vZGVsVmlld1tzdHlsZT1kaXNwbGF5OiBub25lOyBmbG9hdDogbGVmdDsgd2lkdGg6IDIwJTsgYmFja2dyb3VuZC1jb2xvcjogd2hpdGVdJyksXG4gICAgICAgIG0oXCJwI3Jlc3VsdHNIb2xkZXJbc3R5bGU9cGFkZGluZzogLjVlbSAxZW1dXCIpKSxcbiAgICAgIG0oYCNzZXR4W3N0eWxlPWRpc3BsYXk6ICR7d2hlbigncmlnaHQnLCAnYnRuU2V0eCcpfV1gLFxuICAgICAgICBtKCcjc2V0eExlZnRBbGxbc3R5bGU9ZGlzcGxheTpibG9jazsgZmxvYXQ6IGxlZnQ7IHdpZHRoOiAzMCU7IGhlaWdodDoxMDAlOyBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZV0nLFxuICAgICAgICAgIG0oJyNzZXR4TGVmdFtzdHlsZT1kaXNwbGF5OmJsb2NrOyBmbG9hdDogbGVmdDsgd2lkdGg6IDEwMCU7IGhlaWdodDo5NSU7IG92ZXJmbG93OmF1dG87IGJhY2tncm91bmQtY29sb3I6IHdoaXRlXScpKSxcbiAgICAgICAgbSgnI3NldHhSaWdodEFsbFtzdHlsZT1kaXNwbGF5OmJsb2NrOyBmbG9hdDogbGVmdDsgd2lkdGg6IDcwJTsgaGVpZ2h0OjEwMCU7IGJhY2tncm91bmQtY29sb3I6IHdoaXRlXScsXG4gICAgICAgICAgbSgnI3NldHhSaWdodFRvcFtzdHlsZT1kaXNwbGF5OmJsb2NrOyBmbG9hdDogbGVmdDsgd2lkdGg6IDEwMCU7IGhlaWdodDo2NSU7IG92ZXJmbG93OmF1dG87IGJhY2tncm91bmQtY29sb3I6IHdoaXRlXScsXG4gICAgICAgICAgICBtKCcjc2V0eE1pZGRsZVtzdHlsZT1kaXNwbGF5OmJsb2NrOyBmbG9hdDogbGVmdDsgd2lkdGg6IDcwJTsgaGVpZ2h0OjEwMCU7IGJhY2tncm91bmQtY29sb3I6IHdoaXRlXScpLFxuICAgICAgICAgICAgbSgnI3NldHhSaWdodFtzdHlsZT1kaXNwbGF5OmJsb2NrOyBmbG9hdDogcmlnaHQ7IHdpZHRoOiAzMCU7IGhlaWdodDoxMDAlOyBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZV0nKSkpLFxuICAgICAgICBtKCcjc2V0eFJpZ2h0Qm90dG9tW3N0eWxlPWRpc3BsYXk6YmxvY2s7IGZsb2F0OiBsZWZ0OyB3aWR0aDogMTAwJTsgaGVpZ2h0OjM1JTsgb3ZlcmZsb3c6YXV0bzsgYmFja2dyb3VuZC1jb2xvcjogd2hpdGVdJyxcbiAgICAgICAgICBtKCcjc2V0eFJpZ2h0Qm90dG9tTGVmdFtzdHlsZT1kaXNwbGF5OmJsb2NrOyBmbG9hdDogbGVmdDsgd2lkdGg6IDc1JTsgaGVpZ2h0OjEwMCU7IGJhY2tncm91bmQtY29sb3I6IHdoaXRlXScpLFxuICAgICAgICAgIG0oJyNzZXR4UmlnaHRCb3R0b21NaWRkbGVbc3R5bGU9ZGlzcGxheTpibG9jazsgZmxvYXQ6IGxlZnQ7IHdpZHRoOiAxNSU7IGhlaWdodDoxMDAlOyBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZV0nLFxuICAgICAgICAgICAgbShCdXR0b24sXG4gICAgICAgICAgICAgIHtpZDogJ2J0bkV4ZWN1dGVQaXBlJyxcbiAgICAgICAgICAgICAgIGNsYXNzZXM6ICdidG4tZGVmYXVsdC5sYWRkYS1idXR0b25bZGF0YS1zcGlubmVyLWNvbG9yPSMwMDAwMDBdW2RhdGEtc3R5bGU9em9vbS1pbl0nLFxuICAgICAgICAgICAgICAgb25jbGljazogXyA9PiBhcHAuZXhlY3V0ZXBpcGVsaW5lKCdidG5FeGVjdXRlUGlwZScpLFxuICAgICAgICAgICAgICAgc3R5bGU6IGBkaXNwbGF5OmlubGluZTsgZmxvYXQ6IGxlZnQ7IG1hcmdpbi1yaWdodDogMTBweGAsXG4gICAgICAgICAgICAgICB0aXRsZTogJ0V4ZWN1dGUgcGlwZWxpbmUuJ30sXG4gICAgICAgICAgICAgIG0oJ3NwYW4ubGFkZGEtbGFiZWxbc3R5bGU9cG9pbnRlci1ldmVudHM6IG5vbmVdJywgJ0V4ZWN1dGUnKSkpLFxuICAgICAgICAgIG0oJyNzZXR4UmlnaHRCb3R0b21SaWdodFtzdHlsZT1kaXNwbGF5OmJsb2NrOyBmbG9hdDogbGVmdDsgd2lkdGg6IDEwJTsgaGVpZ2h0OjEwMCU7IGJhY2tncm91bmQtY29sb3I6IHdoaXRlXScpKSksXG4gICAgICByaWdodHRhYignbW9kZWxzJywgJ2J0bk1vZGVscycpLFxuICAgICAgcmlnaHR0YWIoJ3R5cGVzJywgJ2J0blR5cGUnLCBhcHAuZDNtVGFza1R5cGUsICdUYXNrJywgJ3Rhc2tUeXBlJyksXG4gICAgICByaWdodHRhYignc3VidHlwZXMnLCAnYnRuU3VidHlwZScsIGFwcC5kM21UYXNrU3VidHlwZSwgJ1Rhc2sgU3VidHlwZScsICd0YXNrU3VidHlwZScpLFxuICAgICAgcmlnaHR0YWIoJ21ldHJpY3MnLCAnYnRuTWV0cmljcycsIGFwcC5kM21NZXRyaWNzLCAnTWV0cmljJywgJ21ldHJpYycpKTtcbi8vICAgICAgcmlnaHR0YWIoJ291dHB1dHMnLCAnYnRuT3V0cHV0cycsIGFwcC5kM21PdXRwdXRUeXBlLCAnT3V0cHV0JywgJ291dHB1dFR5cGUnKSk7XG59XG5cbmxldCB0aWNrZXIgPSBtb2RlID0+IHtcbiAgICBsZXQgbGluayA9IG5hbWUgPT4gbShgYSR7bmFtZSA9PT0gbW9kZSA/ICcuYWN0aXZlJyA6ICcnfVtocmVmPS8ke25hbWV9XVtzdHlsZT1tYXJnaW4tcmlnaHQ6IDAuNWVtXWAsIHtvbmNyZWF0ZTogbS5yb3V0ZS5saW5rfSwgbmFtZVswXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKSk7XG4gICAgcmV0dXJuIG0oJyN0aWNrZXJbc3R5bGU9YmFja2dyb3VuZDogI0Y5RjlGOTsgYm90dG9tOiAwOyBoZWlnaHQ6IDQwcHg7IHBvc2l0aW9uOiBmaXhlZDsgd2lkdGg6IDEwMCU7IGJvcmRlci10b3A6IDFweCBzb2xpZCAjQURBREFEXScsXG4gICAgICAgIGxpbmsoJ21vZGVsJyksXG4gICAgICAgIGxpbmsoJ2V4cGxvcmUnKSxcbiAgICAgICAgbShcImEjbG9nSURbaHJlZj1zb21lbGlua11bdGFyZ2V0PV9ibGFua11bc3R5bGU9bWFyZ2luLXJpZ2h0OiAwLjVlbV1cIiwgXCJSZXBsaWNhdGlvblwiKSxcbiAgICAgICAgLy8gZGV2IGxpbmtzLi4uXG4gICAgICAgIG0oXCJhW2hyZWY9Jy9kZXYtcmF2ZW4tbGlua3MnXVt0YXJnZXQ9X2JsYW5rXVtzdHlsZT1tYXJnaW4tcmlnaHQ6IDAuNWVtXVwiLCBcInJhdmVuLWxpbmtzXCIpLFxuICAgICAgICBtKFwiYVtzdHlsZT1tYXJnaW4tcmlnaHQ6IDAuNWVtXVwiLFxuICAgICAgICAgIHtvbmNsaWNrOiBhcHAucmVjb3JkX3VzZXJfbWV0YWRhdGF9LFxuICAgICAgICAgIFwicmVjb3JkLW1ldGFkYXRhXCIpKTtcbn07XG5cbmNsYXNzIEJvZHkge1xuICAgIG9uaW5pdCgpIHtcbiAgICAgICAgdGhpcy5hYm91dCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNpdGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jaXRlSGlkZGVuID0gZmFsc2U7XG4gICAgfVxuXG4gICAgb25jcmVhdGUoKSB7XG4gICAgICAgIGxldCBleHRyYWN0ID0gKG5hbWUsIGtleSwgb2Zmc2V0LCByZXBsYWNlKSA9PiB7XG4gICAgICAgICAgICBrZXkgPSBrZXkgKyAnPSc7XG4gICAgICAgICAgICBsZXQgbG9jID0gd2luZG93LmxvY2F0aW9uLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBsZXQgdmFsID0gbG9jLmluZGV4T2Yoa2V5KSA+IDAgPyBsb2Muc3Vic3RyaW5nKGxvYy5pbmRleE9mKGtleSkgKyBvZmZzZXQpIDogJyc7XG4gICAgICAgICAgICBsZXQgaWR4ID0gdmFsLmluZGV4T2YoJyYnKTtcbiAgICAgICAgICAgIHZhbCA9IGlkeCA+IDAgPyB2YWwuc3Vic3RyaW5nKDAsIGlkeCkgOiB2YWw7XG4gICAgICAgICAgICB2YWwgPSB2YWwucmVwbGFjZSgnIyEvbW9kZWwnLCAnJyk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhuYW1lLCAnOiAnLCB2YWwpO1xuICAgICAgICAgICAgaWYgKHJlcGxhY2UpIHZhbCA9IHZhbFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8lMjUvZywgJyUnKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8lM0EvZywgJzonKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8lMkYvZywgJy8nKTtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH07XG4gICAgICAgIGFwcC5tYWluKFxuICAgICAgICAgICAgZXh0cmFjdCgnZmlsZWlkJywgJ2RmSWQnLCA1KSxcbiAgICAgICAgICAgIGV4dHJhY3QoJ2hvc3RuYW1lJywgJ2hvc3QnLCA1KSxcbiAgICAgICAgICAgIGV4dHJhY3QoJ2RkaXVybCcsICdkZGl1cmwnLCA3LCB0cnVlKSxcbiAgICAgICAgICAgIGV4dHJhY3QoJ2RhdGF1cmwnLCAnZGF0YXVybCcsIDgsIHRydWUpLFxuICAgICAgICAgICAgZXh0cmFjdCgnYXBpa2V5JywgJ2tleScsIDQpKTtcbiAgICB9XG5cbiAgICB2aWV3KHZub2RlKSB7XG4gICAgICAgIGxldCB7bW9kZX0gPSB2bm9kZS5hdHRycztcbiAgICAgICAgbGV0IGV4cGxvcmUgPSBtb2RlID09PSAnZXhwbG9yZSc7XG4gICAgICAgIGFwcC5pc19yZXN1bHRzX21vZGUgPSBtb2RlID09PSAncmVzdWx0cyc7XG5cbiAgICAgICAgbGV0IF9uYXZCdG4gPSAoaWQsIGxlZnQsIHJpZ2h0LCBvbmNsaWNrLCBhcmdzLCBtaW4pID0+IG0oXG4gICAgICAgICAgICBgYnV0dG9uIyR7aWR9LmJ0bi5uYXZiYXItcmlnaHRgLFxuICAgICAgICAgICAge29uY2xpY2s6IG9uY2xpY2ssXG4gICAgICAgICAgICAgc3R5bGU6IHsnbWFyZ2luLWxlZnQnOiBsZWZ0ICsgJ2VtJyxcbiAgICAgICAgICAgICAgICAgICAgICdtYXJnaW4tcmlnaHQnOiByaWdodCArICdlbScsXG4gICAgICAgICAgICAgICAgICAgICAnbWluLXdpZHRoJzogbWlufX0sXG4gICAgICAgICAgICBhcmdzKTtcbiAgICAgICAgbGV0IG5hdkJ0biA9IChpZCwgbGVmdCwgcmlnaHQsIG9uY2xpY2ssIGFyZ3MsIG1pbikgPT4gX25hdkJ0bihcbiAgICAgICAgICAgIGlkICsgJy5sYWRkYS1idXR0b25bZGF0YS1zcGlubmVyLWNvbG9yPSMwMDAwMDBdW2RhdGEtc3R5bGU9em9vbS1pbl0nLFxuICAgICAgICAgICAgbGVmdCwgcmlnaHQsIG9uY2xpY2ssIGFyZ3MsIG1pbik7XG4gICAgICAgIGxldCBuYXZCdG4xID0gKGlkLCBvbmNsaWNrLCBhcmdzLCB0aXRsZSkgPT4gX25hdkJ0bihcbiAgICAgICAgICAgIGAke2lkfS5idG4tZGVmYXVsdFt0aXRsZT0ke3RpdGxlfV1gLCAyLCAwLCBvbmNsaWNrLCBhcmdzKTtcbiAgICAgICAgbGV0IGdseXBoID0gKGljb24sIHVuc3R5bGVkKSA9PiBtKFxuICAgICAgICAgICAgYHNwYW4uZ2x5cGhpY29uLmdseXBoaWNvbi0ke2ljb259YCArICh1bnN0eWxlZCA/ICcnIDogJ1tzdHlsZT1jb2xvcjogIzgxODE4MTsgZm9udC1zaXplOiAxZW07IHBvaW50ZXItZXZlbnRzOiBub25lXScpKTtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWF0aW9uID0gKGlkLCBsaXN0KSA9PiBtKFxuICAgICAgICAgICAgYHVsIyR7aWR9YCwge1xuICAgICAgICAgICAgICAgIHN0eWxlOiB7ZGlzcGxheTogJ25vbmUnLCAnYmFja2dyb3VuZC1jb2xvcic6IGFwcC52YXJDb2xvcn0sXG4gICAgICAgICAgICAgICAgb25jbGljazogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGludGVyYWN0IGlzIHNlbGVjdGVkLCBzaG93IHZhcmlhYmxlIGxpc3QgYWdhaW5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCQodGhpcykudGV4dCgpID09PSAnaW50ZXJhY3QoZCxlKScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICQoJyN0SW5wdXQnKS52YWwodHZhci5jb25jYXQoJyonKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxJbnRlcmFjdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLnBhcmVudCgpLmZhZGVPdXQoMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICQoJyN0cmFuc1NlbCcpLmZhZGVJbigxMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHR2YXIgPSAkKCcjdElucHV0JykudmFsKCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0ZnVuYyA9ICQodGhpcykudGV4dCgpLnJlcGxhY2UoXCJkXCIsIFwiX3RyYW5zdmFyMFwiKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRjYWxsID0gJCh0aGlzKS50ZXh0KCkucmVwbGFjZShcImRcIiwgdHZhcik7XG4gICAgICAgICAgICAgICAgICAgICQoJyN0SW5wdXQnKS52YWwodGNhbGwpO1xuICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLnBhcmVudCgpLmZhZGVPdXQoMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm0odHZhciwgdGZ1bmMsIHR5cGVUcmFuc2Zvcm0gPSBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxpc3QubWFwKHggPT4gbSgnbGknLCB4KSkpO1xuICAgICAgICBsZXQgc3BhY2VCdG4gPSAoaWQsIG9uY2xpY2ssIHRpdGxlLCBpY29uKSA9PiBtKFxuICAgICAgICAgICAgYGJ1dHRvbiMke2lkfS5idG4uYnRuLWRlZmF1bHRgLCB7b25jbGljaywgdGl0bGV9LCBnbHlwaChpY29uLCB0cnVlKSk7XG5cbiAgICAgICAgcmV0dXJuIG0oXG4gICAgICAgICAgICAnbWFpbicsXG4gICAgICAgICAgICBtKFwibmF2I25hdmJhci5uYXZiYXIubmF2YmFyLWRlZmF1bHQubmF2YmFyLWZpeGVkLXRvcFtyb2xlPW5hdmlnYXRpb25dXCIsXG4gICAgICAgICAgICAgIHtzdHlsZTogbW9kZSA9PT0gJ2V4cGxvcmUnICYmICdiYWNrZ3JvdW5kLWltYWdlOiAtd2Via2l0LWxpbmVhci1ncmFkaWVudCh0b3AsICNmZmYgMCwgcmdiKDIyNywgMjQyLCAyNTQpIDEwMCUpJ30sXG4gICAgICAgICAgICAgIG0oXCJhLm5hdmJhci1icmFuZFwiLFxuICAgICAgICAgICAgICAgIG0oXCJpbWdbc3JjPS9zdGF0aWMvaW1hZ2VzL1R3b1JhdmVucy5wbmddW2FsdD1Ud29SYXZlbnNdW3dpZHRoPTEwMF1bc3R5bGU9bWFyZ2luLWxlZnQ6IDFlbTsgbWFyZ2luLXRvcDogLTAuNWVtXVwiLFxuICAgICAgICAgICAgICAgICAge29ubW91c2VvdmVyOiBfID0+IHRoaXMuYWJvdXQgPSB0cnVlLCBvbm1vdXNlb3V0OiBfID0+IHRoaXMuYWJvdXQgPSBmYWxzZX0pKSxcbiAgICAgICAgICAgICAgbSgnI25hdmJhck5hdltzdHlsZT1wYWRkaW5nOiAwLjVlbV0nLFxuICAgICAgICAgICAgICAgIG0oJyNkYXRhRmllbGQuZmllbGRbc3R5bGU9bWFyZ2luLXRvcDogMC41ZW07IHRleHQtYWxpZ246IGNlbnRlcl0nLFxuICAgICAgICAgICAgICAgICAgbSgnaDQjZGF0YU5hbWVbc3R5bGU9ZGlzcGxheTogaW5saW5lXScsXG4gICAgICAgICAgICAgICAgICAgIHtvbmNsaWNrOiBfID0+IHRoaXMuY2l0ZSA9IHRoaXMuY2l0ZUhpZGRlbiA9ICF0aGlzLmNpdGVIaWRkZW4sXG4gICAgICAgICAgICAgICAgICAgICBvbm1vdXNlb3V0OiBfID0+IHRoaXMuY2l0ZUhpZGRlbiB8fCAodGhpcy5jaXRlID0gZmFsc2UpLFxuICAgICAgICAgICAgICAgICAgICAgb25tb3VzZW92ZXI6IF8gPT4gdGhpcy5jaXRlID0gdHJ1ZX0sXG4gICAgICAgICAgICAgICAgICAgIFwiRGF0YXNldCBOYW1lXCIpLFxuICAgICAgICAgICAgICAgICAgbSgnI2NpdGUucGFuZWwucGFuZWwtZGVmYXVsdCcsXG4gICAgICAgICAgICAgICAgICAgIHtzdHlsZTogYGRpc3BsYXk6ICR7dGhpcy5jaXRlID8gJ2Jsb2NrJyA6ICdub25lJ307IHBvc2l0aW9uOiBhYnNvbHV0ZTsgcmlnaHQ6IDUwJTsgd2lkdGg6IDM4MHB4OyB0ZXh0LWFsaWduOiBsZWZ0OyB6LWluZGV4OiA1MGB9LFxuICAgICAgICAgICAgICAgICAgICBtKFwiLnBhbmVsLWJvZHlcIikpLFxuICAgICAgICAgICAgICAgICAgbSgnc3BhbicsXG4gICAgICAgICAgICAgICAgICAgIG5hdkJ0bignYnRuRXN0aW1hdGUuYnRuLXN1Y2Nlc3MnLCAyLCAxLCBleHBsb3JlID8gZXhwLmV4cGxvcmUgOiBhcHAuZXN0aW1hdGUsIG0oXCJzcGFuLmxhZGRhLWxhYmVsXCIsIGV4cGxvcmUgPyAnRXhwbG9yZScgOiAnU29sdmUgVGhpcyBQcm9ibGVtJyksICcxNTBweCcpLFxuICAgICAgICAgICAgICAgICAgICBuYXZCdG4oJ2J0blRBMi5idG4tZGVmYXVsdCcsIC41LCAxLCBfID0+IGFwcC5oZWxwbWF0ZXJpYWxzKCdtYW51YWwnKSwgWydIZWxwIE1hbnVhbCAnLCBnbHlwaCgnYm9vaycpXSksXG4gICAgICAgICAgICAgICAgICAgIG5hdkJ0bignYnRuVEEyLmJ0bi1kZWZhdWx0JywgMiwgLjUsIF8gPT4gYXBwLmhlbHBtYXRlcmlhbHMoJ3ZpZGVvJyksIFsnSGVscCBWaWRlbyAnLCBnbHlwaCgnZXhwYW5kJyldKSxcbiAgICAgICAgICAgICAgICAgICAgbmF2QnRuMShcImJ0blJlc2V0XCIsIGFwcC5yZXNldCwgZ2x5cGgoJ3JlcGVhdCcpLCAnUmVzZXQnKSxcbiAgICAgICAgICAgICAgICAgICAgbmF2QnRuMSgnYnRuRW5kU2Vzc2lvbicsIGFwcC5lbmRzZXNzaW9uLCBtKFwic3Bhbi5sYWRkYS1sYWJlbFwiLCAnTWFyayBQcm9ibGVtIEZpbmlzaGVkJyksICdNYXJrIFByb2JsZW0gRmluaXNoZWQnKSksXG4gICAgICAgICAgICAgICAgICBtKCcjdElucHV0Jywge1xuICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7ZGlzcGxheTogJ25vbmUnfSxcbiAgICAgICAgICAgICAgICAgICAgICBvbmNsaWNrOiBfID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJ5SWQoJ3RyYW5zU2VsJykuc3R5bGUuZGlzcGxheSAhPT0gJ25vbmUnKSB7IC8vIGlmIHZhcmlhYmxlIGxpc3QgaXMgZGlzcGxheWVkIHdoZW4gaW5wdXQgaXMgY2xpY2tlZC4uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJCgnI3RyYW5zU2VsJykuZmFkZU91dCgxMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChieUlkKCd0cmFuc0xpc3QnKS5zdHlsZS5kaXNwbGF5ICE9PSAnbm9uZScpIHsgLy8gaWYgZnVuY3Rpb24gbGlzdCBpcyBkaXNwbGF5ZWQgd2hlbiBpbnB1dCBpcyBjbGlja2VkLi4uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKCcjdHJhbnNMaXN0JykuZmFkZU91dCgxMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGlnaGxpZ2h0IHRoZSB0ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICQodGhpcykuc2VsZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwb3MgPSAkKCcjdElucHV0Jykub2Zmc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBvcy50b3AgKz0gJCgnI3RJbnB1dCcpLndpZHRoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICQoJyN0cmFuc1NlbCcpLmZhZGVJbigxMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICBrZXl1cDogZXZ0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHQgPSBieUlkKCd0cmFuc1NlbCcpLnN0eWxlLmRpc3BsYXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0MSA9IGJ5SWQoJ3RyYW5zTGlzdCcpLnN0eWxlLmRpc3BsYXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ICE9PSAnbm9uZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoJyN0cmFuc1NlbCcpLmZhZGVPdXQoMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0MSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKCcjdHJhbnNMaXN0JykuZmFkZU91dCgxMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2dC5rZXlDb2RlID09IDEzKSB7IC8vIGtleXVwIG9uIEVudGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdCA9IHRyYW5zUGFyc2UoJCgnI3RJbnB1dCcpLnZhbCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybSh0LnNsaWNlKDAsIHQubGVuZ3RoIC0gMSksIHRbdC5sZW5ndGggLSAxXSwgdHlwZVRyYW5zZm9ybSA9IGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgbSgnI3RyYW5zZm9ybWF0aW9ucy50cmFuc2Zvcm1Ub29sJywge1xuICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBgQ29uc3RydWN0IHRyYW5zZm9ybWF0aW9ucyBvZiBleGlzdGluZyB2YXJpYWJsZXMgdXNpbmcgdmFsaWQgUiBzeW50YXguXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGb3IgZXhhbXBsZSwgYXNzdW1pbmcgYSB2YXJpYWJsZSBuYW1lZCBkLCB5b3UgY2FuIGVudGVyIFwibG9nKGQpXCIgb3IgXCJkXjJcIi5gfSxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtYXRpb24oJ3RyYW5zU2VsJywgWydhJywgJ2InXSksXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybWF0aW9uKCd0cmFuc0xpc3QnLCBhcHAudHJhbnNmb3JtTGlzdCkpKSksXG4gICAgICAgICAgICAgIG0oYCNhYm91dC5wYW5lbC5wYW5lbC1kZWZhdWx0W3N0eWxlPWRpc3BsYXk6ICR7dGhpcy5hYm91dCA/ICdibG9jaycgOiAnbm9uZSd9OyBsZWZ0OiAxNDBweDsgcG9zaXRpb246IGFic29sdXRlOyB3aWR0aDogNTAwcHg7IHotaW5kZXg6IDUwXWAsXG4gICAgICAgICAgICAgICAgbSgnLnBhbmVsLWJvZHknLFxuICAgICAgICAgICAgICAgICAgJ1R3b1JhdmVucyB2MC4xIFwiRGFsbGFzXCIgLS0gVGhlIE5vcnNlIGdvZCBPZGluIGhhZCB0d28gdGFsa2luZyByYXZlbnMgYXMgYWR2aXNvcnMsIHdobyB3b3VsZCBmbHkgb3V0IGludG8gdGhlIHdvcmxkIGFuZCByZXBvcnQgYmFjayBhbGwgdGhleSBvYnNlcnZlZC4gSW4gdGhlIE5vcnNlLCB0aGVpciBuYW1lcyB3ZXJlIFwiVGhvdWdodFwiIGFuZCBcIk1lbW9yeVwiLiBJbiBvdXIgY29taW5nIHJlbGVhc2UsIG91ciB0aG91Z2h0LXJhdmVuIGF1dG9tYXRpY2FsbHkgYWR2aXNlcyBvbiBzdGF0aXN0aWNhbCBtb2RlbCBzZWxlY3Rpb24sIHdoaWxlIG91ciBtZW1vcnktcmF2ZW4gYWNjdW11bGF0ZXMgcHJldmlvdXMgc3RhdGlzdGljYWwgbW9kZWxzIGZyb20gRGF0YXZlcnNlLCB0byBwcm92aWRlIGN1bW11bGF0aXZlIGd1aWRhbmNlIGFuZCBtZXRhLWFuYWx5c2lzLicpKSksXG4gICAgICAgICAgICBtKGAjbWFpbi5sZWZ0LmNhcm91c2VsLnNsaWRlLnN2Zy1sZWZ0cGFuZWwuc3ZnLXJpZ2h0cGFuZWxbc3R5bGU9b3ZlcmZsb3c6IGhpZGRlbl1gLFxuICAgICAgICAgICAgICBtKFwiI2lubmVyY2Fyb3VzZWwuY2Fyb3VzZWwtaW5uZXJcIixcbiAgICAgICAgICAgICAgICBtKCcjbTAuaXRlbS5hY3RpdmUnLFxuICAgICAgICAgICAgICAgICAgbSgnc3ZnI3doaXRlc3BhY2UnKSkpLFxuICAgICAgICAgICAgICBtKFwiI3NwYWNldG9vbHMuc3BhY2VUb29sW3N0eWxlPXotaW5kZXg6IDE2XVwiLFxuICAgICAgICAgICAgICAgIHNwYWNlQnRuKCdidG5Mb2NrLmFjdGl2ZScsIGFwcC5sb2NrRGVzY3JpcHRpb24sICdMb2NrIHNlbGVjdGlvbiBvZiBwcm9ibGVtIGRlc2NyaXB0aW9uJywgJ3BlbmNpbCcpLFxuICAgICAgICAgICAgICAgIHNwYWNlQnRuKCdidG5Kb2luJywgXyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsaW5rcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXhwbG9yZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGlzX3VuaXF1ZSA9IChuLCBuMSkgPT4gbGlua3MubWFwKGwgPT4gbC50YXJnZXQgPT09IG4xICYmIGwuc291cmNlID09PSBuKS5sZW5ndGggPT0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtzID0gYXBwLm5vZGVzLm1hcChuID0+IGFwcC5ub2Rlcy5maWx0ZXIobjEgPT4gbiAhPT0gbjEgJiYgaXNfdW5pcXVlKG4sIG4xKSkubWFwKG4xID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IG4xLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkdnMgPSBhcHAubm9kZXMuZmlsdGVyKG4gPT4gYXBwLnpwYXJhbXMuemR2LmluY2x1ZGVzKG4ubmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGl2cyA9IGFwcC5ub2Rlcy5maWx0ZXIobiA9PiAhZHZzLmluY2x1ZGVzKG4pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtzID0gZHZzLm1hcChkdiA9PiBpdnMubWFwKGl2ID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBpdixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IGR2LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhcHAucmVzdGFydChbXS5jb25jYXQoLi4ubGlua3MpKTtcbiAgICAgICAgICAgICAgICB9LCAnTWFrZSBhbGwgcG9zc2libGUgY29ubmVjdGlvbnMgYmV0d2VlbiBub2RlcycsICdsaW5rJyksXG4gICAgICAgICAgICAgICAgc3BhY2VCdG4oJ2J0bkRpc2Nvbm5lY3QnLCBfID0+IGFwcC5yZXN0YXJ0KFtdKSwgJ0RlbGV0ZSBhbGwgY29ubmVjdGlvbnMgYmV0d2VlbiBub2RlcycsICdyZW1vdmUtY2lyY2xlJyksXG4gICAgICAgICAgICAgICAgc3BhY2VCdG4oJ2J0bkZvcmNlJywgYXBwLmZvcmNlU3dpdGNoLCAnUGluIHRoZSB2YXJpYWJsZSBwZWJibGVzIHRvIHRoZSBwYWdlJywgJ3B1c2hwaW4nKSxcbiAgICAgICAgICAgICAgICBzcGFjZUJ0bignYnRuRXJhc2VyJywgYXBwLmVyYXNlLCAnV2lwZSBhbGwgdmFyaWFibGVzIGZyb20gdGhlIG1vZGVsaW5nIHNwYWNlJywgJ21hZ25ldCcpKSxcbiAgICAgICAgICAgICAgbShTdWJwYW5lbCxcbiAgICAgICAgICAgICAgICB7dGl0bGU6IFwiTGVnZW5kXCIsXG4gICAgICAgICAgICAgICAgIGJ1dHRvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgIFsndGltZUJ1dHRvbicsICd6dGltZScsICdUaW1lJ10sXG4gICAgICAgICAgICAgICAgICAgICBbJ2NzQnV0dG9uJywgJ3pjcm9zcycsICdDcm9zcyBTZWMnXSxcbiAgICAgICAgICAgICAgICAgICAgIFsnZHZCdXR0b24nLCAnemR2JywgJ0RlcCBWYXInXSxcbiAgICAgICAgICAgICAgICAgICAgIFsnbm9tQnV0dG9uJywgJ3pub20nLCAnTm9tIFZhciddLFxuICAgICAgICAgICAgICAgICAgICAgWydncjFCdXR0b24nLCAnemdyb3VwMScsICdHcm91cCAxJ10sXG4gICAgICAgICAgICAgICAgICAgICBbJ2dyMkJ1dHRvbicsICd6Z3JvdXAyJywgJ0dyb3VwIDInXV19KSxcbiAgICAgICAgICAgICAgbShTdWJwYW5lbCwge3RpdGxlOiBcIkhpc3RvcnlcIn0pLFxuICAgICAgICAgICAgICB0aWNrZXIobW9kZSksXG4gICAgICAgICAgICAgIGxlZnRwYW5lbCgpLFxuICAgICAgICAgICAgICByaWdodHBhbmVsKG1vZGUpKSk7XG4gICAgfVxufVxuXG5tLnJvdXRlKGRvY3VtZW50LmJvZHksICcvbW9kZWwnLCB7XG4gICAgJy9tb2RlbCc6IHtyZW5kZXI6ICgpID0+IG0oQm9keSl9LFxuICAgICcvZXhwbG9yZSc6IHtyZW5kZXI6ICgpID0+IG0oQm9keSwge21vZGU6ICdleHBsb3JlJ30pfSxcbiAgICAnL3Jlc3VsdHMnOiB7cmVuZGVyOiAoKSA9PiBtKEJvZHksIHttb2RlOiAncmVzdWx0cyd9KX0sXG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Fzc2V0cy9hcHAvaW5kZXguanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///14\n")},function(module,exports,__webpack_require__){eval('/**! hopscotch - v0.3.1\n*\n* Copyright 2017 LinkedIn Corp. All rights reserved.\n*\n* Licensed under the Apache License, Version 2.0 (the "License");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*     http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an "AS IS" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n!function(a,b){ true?module.exports=b():"function"==typeof define&&define.amd?define(b):a.hopscotch=b()}(this,function(){"use strict";var a,b,c,d,e,f,g,h,i,j,k,l,m,n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(a){return typeof a}:function(a){return a&&"function"==typeof Symbol&&a.constructor===Symbol&&a!==Symbol.prototype?"symbol":typeof a},o="bubble_default",p=window.Sizzle||null,q="undefined",r=!1,s=("undefined"==typeof jQuery?"undefined":n(jQuery))!==q,t=!1,u=!1,v=/^[a-zA-Z]+[a-zA-Z0-9_-]*$/,w={left:"right",right:"left"};try{n(window.sessionStorage)!==q&&(t=!0,sessionStorage.setItem("hopscotch.test.storage","ok"),sessionStorage.removeItem("hopscotch.test.storage"),u=!0)}catch(x){}l={smoothScroll:!0,scrollDuration:1e3,scrollTopMargin:200,showCloseButton:!0,showPrevButton:!1,showNextButton:!0,bubbleWidth:280,bubblePadding:15,arrowWidth:20,skipIfNoElement:!0,isRtl:!1,cookieName:"hopscotch.tour.state"},Array.isArray||(Array.isArray=function(a){return"[object Array]"===Object.prototype.toString.call(a)}),k=function(){r&&m.startTour()},h={addClass:function(a,b){var c,d,e,f;if(a.className){for(d=b.split(/\\s+/),c=" "+a.className+" ",e=0,f=d.length;f>e;++e)c.indexOf(" "+d[e]+" ")<0&&(c+=d[e]+" ");a.className=c.replace(/^\\s+|\\s+$/g,"")}else a.className=b},removeClass:function(a,b){var c,d,e,f;for(d=b.split(/\\s+/),c=" "+a.className+" ",e=0,f=d.length;f>e;++e)c=c.replace(" "+d[e]+" "," ");a.className=c.replace(/^\\s+|\\s+$/g,"")},hasClass:function(a,b){var c;return a.className?(c=" "+a.className+" ",-1!==c.indexOf(" "+b+" ")):!1},getPixelValue:function(a){var b="undefined"==typeof a?"undefined":n(a);return"number"===b?a:"string"===b?parseInt(a,10):0},valOrDefault:function(a,b){return("undefined"==typeof a?"undefined":n(a))!==q?a:b},invokeCallbackArrayHelper:function(a){var b;return Array.isArray(a)&&(b=j[a[0]],"function"==typeof b)?b.apply(this,a.slice(1)):void 0},invokeCallbackArray:function(a){var b,c;if(Array.isArray(a)){if("string"==typeof a[0])return h.invokeCallbackArrayHelper(a);for(b=0,c=a.length;c>b;++b)h.invokeCallback(a[b])}},invokeCallback:function(a){return"function"==typeof a?a():"string"==typeof a&&j[a]?j[a]():h.invokeCallbackArray(a)},invokeEventCallbacks:function(a,b){var c,d,e=i[a];if(b)return this.invokeCallback(b);for(c=0,d=e.length;d>c;++c)this.invokeCallback(e[c].cb)},getScrollTop:function(){var a;return a=n(window.pageYOffset)!==q?window.pageYOffset:document.documentElement.scrollTop},getScrollLeft:function(){var a;return a=n(window.pageXOffset)!==q?window.pageXOffset:document.documentElement.scrollLeft},getWindowHeight:function(){return window.innerHeight||document.documentElement.clientHeight},addEvtListener:function(a,b,c){return a?a.addEventListener?a.addEventListener(b,c,!1):a.attachEvent("on"+b,c):void 0},removeEvtListener:function(a,b,c){return a?a.removeEventListener?a.removeEventListener(b,c,!1):a.detachEvent("on"+b,c):void 0},documentIsReady:function(){return"complete"===document.readyState},evtPreventDefault:function(a){a.preventDefault?a.preventDefault():event&&(event.returnValue=!1)},extend:function(a,b){var c;for(c in b)b.hasOwnProperty(c)&&(a[c]=b[c])},getStepTargetHelper:function(a){var b=document.getElementById(a);if(b)return b;if(s)return b=jQuery(a),b.length?b[0]:null;if(p)return b=new p(a),b.length?b[0]:null;if(document.querySelector)try{return document.querySelector(a)}catch(c){}return/^#[a-zA-Z][\\w-_:.]*$/.test(a)?document.getElementById(a.substring(1)):null},getStepTarget:function(a){var b;if(!a||!a.target)return null;if("string"==typeof a.target)return h.getStepTargetHelper(a.target);if(Array.isArray(a.target)){var c,d;for(c=0,d=a.target.length;d>c;c++)if("string"==typeof a.target[c]&&(b=h.getStepTargetHelper(a.target[c])))return b;return null}return a.target},getI18NString:function(a){return e[a]||d[a]},setState:function(a,b,c){var d,e="";if(t&&u)try{sessionStorage.setItem(a,b)}catch(f){u=!1,this.setState(a,b,c)}else t&&sessionStorage.removeItem(a),c&&(d=new Date,d.setTime(d.getTime()+24*c*60*60*1e3),e="; expires="+d.toGMTString()),document.cookie=a+"="+b+e+"; path=/"},getState:function(a){var b,c,d,e=a+"=",f=document.cookie.split(";");if(t&&(d=sessionStorage.getItem(a)))return d;for(b=0;b<f.length;b++){for(c=f[b];" "===c.charAt(0);)c=c.substring(1,c.length);if(0===c.indexOf(e)){d=c.substring(e.length,c.length);break}}return d},clearState:function(a){t?sessionStorage.removeItem(a):this.setState(a,"",-1)},normalizePlacement:function(a){!a.placement&&a.orientation&&(a.placement=a.orientation)},flipPlacement:function(a){if(a.isRtl&&!a._isFlipped){var b,c,d=["orientation","placement"];a.xOffset&&(a.xOffset=-1*this.getPixelValue(a.xOffset));for(c in d)b=d[c],a.hasOwnProperty(b)&&w.hasOwnProperty(a[b])&&(a[b]=w[a[b]]);a._isFlipped=!0}}},h.addEvtListener(window,"load",k),i={next:[],prev:[],start:[],end:[],show:[],error:[],close:[]},j={},d={stepNums:null,nextBtn:"Next",prevBtn:"Back",doneBtn:"Done",skipBtn:"Skip",closeTooltip:"Close"},e={},b=function(a){this.init(a)},b.prototype={isShowing:!1,currStep:void 0,setPosition:function(a){var b,c,d,e,f,g,i,j=h.getStepTarget(a),k=this.element,l=this.arrowEl,m=a.isRtl?"right":"left";if(h.flipPlacement(a),h.normalizePlacement(a),c=k.offsetWidth,b=k.offsetHeight,h.removeClass(k,"fade-in-down fade-in-up fade-in-left fade-in-right"),d=j.getBoundingClientRect(),i=a.isRtl?d.right-c:d.left,"top"===a.placement)e=d.top-b-this.opt.arrowWidth,f=i;else if("bottom"===a.placement)e=d.bottom+this.opt.arrowWidth,f=i;else if("left"===a.placement)e=d.top,f=d.left-c-this.opt.arrowWidth;else{if("right"!==a.placement)throw new Error("Bubble placement failed because step.placement is invalid or undefined!");e=d.top,f=d.right+this.opt.arrowWidth}g="center"!==a.arrowOffset?h.getPixelValue(a.arrowOffset):a.arrowOffset,g?"top"===a.placement||"bottom"===a.placement?(l.style.top="","center"===g?l.style[m]=Math.floor(c/2-l.offsetWidth/2)+"px":l.style[m]=g+"px"):("left"===a.placement||"right"===a.placement)&&(l.style[m]="","center"===g?l.style.top=Math.floor(b/2-l.offsetHeight/2)+"px":l.style.top=g+"px"):(l.style.top="",l.style[m]=""),"center"===a.xOffset?f=d.left+j.offsetWidth/2-c/2:f+=h.getPixelValue(a.xOffset),"center"===a.yOffset?e=d.top+j.offsetHeight/2-b/2:e+=h.getPixelValue(a.yOffset),a.fixedElement||(e+=h.getScrollTop(),f+=h.getScrollLeft()),k.style.position=a.fixedElement?"fixed":"absolute",k.style.top=e+"px",k.style.left=f+"px"},render:function(a,b,c){var d,e,g,i,j,k,l,n,p,q,r=this.element;if(a?this.currStep=a:this.currStep&&(a=this.currStep),this.opt.isTourBubble?(i=m.getCurrTour(),i&&(e=i.customData,d=i.customRenderer,a.isRtl=a.hasOwnProperty("isRtl")?a.isRtl:i.hasOwnProperty("isRtl")?i.isRtl:this.opt.isRtl,g=i.unsafe,Array.isArray(i.steps)&&(j=i.steps.length,k=this._getStepI18nNum(this._getStepNum(j-1)),n=this._getStepNum(b)===this._getStepNum(j-1)))):(e=a.customData,d=a.customRenderer,g=a.unsafe,a.isRtl=a.hasOwnProperty("isRtl")?a.isRtl:this.opt.isRtl),l=n?h.getI18NString("doneBtn"):a.showSkip?h.getI18NString("skipBtn"):h.getI18NString("nextBtn"),h.flipPlacement(a),h.normalizePlacement(a),this.placement=a.placement,q={i18n:{prevBtn:h.getI18NString("prevBtn"),nextBtn:l,closeTooltip:h.getI18NString("closeTooltip"),stepNum:this._getStepI18nNum(this._getStepNum(b)),numSteps:k},buttons:{showPrev:h.valOrDefault(a.showPrevButton,this.opt.showPrevButton)&&this._getStepNum(b)>0,showNext:h.valOrDefault(a.showNextButton,this.opt.showNextButton),showCTA:h.valOrDefault(a.showCTAButton&&a.ctaLabel,!1),ctaLabel:a.ctaLabel,showClose:h.valOrDefault(this.opt.showCloseButton,!0)},step:{num:b,isLast:h.valOrDefault(n,!1),title:a.title||"",content:a.content||"",isRtl:a.isRtl,placement:a.placement,padding:h.valOrDefault(a.padding,this.opt.bubblePadding),width:h.getPixelValue(a.width)||this.opt.bubbleWidth,customData:a.customData||{}},tour:{isTour:this.opt.isTourBubble,numSteps:j,unsafe:h.valOrDefault(g,!1),customData:e||{}}},"function"==typeof d)r.innerHTML=d(q);else if("string"==typeof d){if(!m.templates||"function"!=typeof m.templates[d])throw new Error(\'Bubble rendering failed - template "\'+d+\'" is not a function.\');r.innerHTML=m.templates[d](q)}else if(f)r.innerHTML=f(q);else{if(!m.templates||"function"!=typeof m.templates[o])throw new Error(\'Bubble rendering failed - template "\'+o+\'" is not a function.\');r.innerHTML=m.templates[o](q)}var s,t=r.children,u=t.length;for(p=0;u>p;p++)s=t[p],h.hasClass(s,"hopscotch-arrow")&&(this.arrowEl=s);return r.style.zIndex="number"==typeof a.zindex?a.zindex:"",this._setArrow(a.placement),this.hide(!1),this.setPosition(a),c&&c(!a.fixedElement),this},_getStepNum:function(a){var b,c,d=0,e=m.getSkippedStepsIndexes(),f=e.length;for(c=0;f>c;c++)b=e[c],a>b&&d++;return a-d},_getStepI18nNum:function(a){var b=h.getI18NString("stepNums");return b&&a<b.length?a=b[a]:a+=1,a},_setArrow:function(a){h.removeClass(this.arrowEl,"down up right left"),"top"===a?h.addClass(this.arrowEl,"down"):"bottom"===a?h.addClass(this.arrowEl,"up"):"left"===a?h.addClass(this.arrowEl,"right"):"right"===a&&h.addClass(this.arrowEl,"left")},_getArrowDirection:function(){return"top"===this.placement?"down":"bottom"===this.placement?"up":"left"===this.placement?"right":"right"===this.placement?"left":void 0},show:function(){var a=this,b="fade-in-"+this._getArrowDirection(),c=1e3;return h.removeClass(this.element,"hide"),h.addClass(this.element,b),setTimeout(function(){h.removeClass(a.element,"invisible")},50),setTimeout(function(){h.removeClass(a.element,b)},c),this.isShowing=!0,this},hide:function(a){var b=this.element;return a=h.valOrDefault(a,!0),b.style.top="",b.style.left="",a?(h.addClass(b,"hide"),h.removeClass(b,"invisible")):(h.removeClass(b,"hide"),h.addClass(b,"invisible")),h.removeClass(b,"animate fade-in-up fade-in-down fade-in-right fade-in-left"),this.isShowing=!1,this},destroy:function(){var a=this.element;a&&a.parentNode.removeChild(a),h.removeEvtListener(a,"click",this.clickCb)},_handleBubbleClick:function(a){function b(c){return c===a.currentTarget?null:h.hasClass(c,"hopscotch-cta")?"cta":h.hasClass(c,"hopscotch-next")?"next":h.hasClass(c,"hopscotch-prev")?"prev":h.hasClass(c,"hopscotch-close")?"close":b(c.parentElement)}var c;a=a||window.event;var d=a.target||a.srcElement;if(c=b(d),"cta"===c)this.opt.isTourBubble||m.getCalloutManager().removeCallout(this.currStep.id),this.currStep.onCTA&&h.invokeCallback(this.currStep.onCTA);else if("next"===c)m.nextStep(!0);else if("prev"===c)m.prevStep(!0);else if("close"===c){if(this.opt.isTourBubble){var e=m.getCurrStepNum(),f=m.getCurrTour(),g=e===f.steps.length-1;h.invokeEventCallbacks("close"),m.endTour(!0,g)}else this.opt.onClose&&h.invokeCallback(this.opt.onClose),this.opt.id&&!this.opt.isTourBubble?m.getCalloutManager().removeCallout(this.opt.id):this.destroy();h.evtPreventDefault(a)}},init:function(a){var b,c,d,e,f=document.createElement("div"),g=this,i=!1;this.element=f,e={showPrevButton:l.showPrevButton,showNextButton:l.showNextButton,bubbleWidth:l.bubbleWidth,bubblePadding:l.bubblePadding,arrowWidth:l.arrowWidth,isRtl:l.isRtl,showNumber:!0,isTourBubble:!0},a=("undefined"==typeof a?"undefined":n(a))===q?{}:a,h.extend(e,a),this.opt=e,f.className="hopscotch-bubble animated",e.isTourBubble?(d=m.getCurrTour(),d&&h.addClass(f,"tour-"+d.id)):h.addClass(f,"hopscotch-callout no-number"),b=function(){!i&&g.isShowing&&(i=!0,setTimeout(function(){g.setPosition(g.currStep),i=!1},100))},h.addEvtListener(window,"resize",b),this.clickCb=function(a){g._handleBubbleClick(a)},h.addEvtListener(f,"click",this.clickCb),this.hide(),h.documentIsReady()?document.body.appendChild(f):(document.addEventListener?(c=function(){document.removeEventListener("DOMContentLoaded",c),window.removeEventListener("load",c),document.body.appendChild(f)},document.addEventListener("DOMContentLoaded",c,!1)):(c=function(){"complete"===document.readyState&&(document.detachEvent("onreadystatechange",c),window.detachEvent("onload",c),document.body.appendChild(f))},document.attachEvent("onreadystatechange",c)),h.addEvtListener(window,"load",c))}},c=function(){var a={},c={};this.createCallout=function(d){var e;if(!d.id)throw new Error("Must specify a callout id.");if(!v.test(d.id))throw new Error("Callout ID is using an invalid format. Use alphanumeric, underscores, and/or hyphens only. First character must be a letter.");if(a[d.id])throw new Error("Callout by that id already exists. Please choose a unique id.");if(!h.getStepTarget(d))throw new Error("Must specify existing target element via \'target\' option.");return d.showNextButton=d.showPrevButton=!1,d.isTourBubble=!1,e=new b(d),a[d.id]=e,c[d.id]=d,e.render(d,null,function(){e.show(),d.onShow&&h.invokeCallback(d.onShow)}),e},this.getCallout=function(b){return a[b]},this.removeAllCallouts=function(){var b;for(b in a)a.hasOwnProperty(b)&&this.removeCallout(b)},this.removeCallout=function(b){var d=a[b];a[b]=null,c[b]=null,d&&d.destroy()},this.refreshCalloutPositions=function(){var b,d,e;for(b in a)a.hasOwnProperty(b)&&c.hasOwnProperty(b)&&(d=a[b],e=c[b],d&&e&&d.setPosition(e))}},a=function(a){var d,k,p,t,u,w,x,y,z=this,A={},B=[],C=function(a){return d&&d.element&&d.element.parentNode||(d=new b(p)),a&&h.extend(d.opt,{bubblePadding:E("bubblePadding"),bubbleWidth:E("bubbleWidth"),showNextButton:E("showNextButton"),showPrevButton:E("showPrevButton"),showCloseButton:E("showCloseButton"),arrowWidth:E("arrowWidth"),isRtl:E("isRtl")}),d},D=function(){d&&(d.destroy(),d=null)},E=function(a){return"undefined"==typeof p?l[a]:h.valOrDefault(p[a],l[a])},F=function(){var a;return a=!t||0>u||u>=t.steps.length?null:t.steps[u]},G=function(){z.nextStep()},H=function(a){var b,c,d,e,f,g,i=C(),j=i.element,k=h.getPixelValue(j.style.top),l=k+h.getPixelValue(j.offsetHeight),m=h.getStepTarget(F()),o=m.getBoundingClientRect(),p=o.top+h.getScrollTop(),r=o.bottom+h.getScrollTop(),t=p>k?k:p,u=l>r?l:r,v=h.getScrollTop(),w=v+h.getWindowHeight(),x=t-E("scrollTopMargin");t>=v&&(t<=v+E("scrollTopMargin")||w>=u)?a&&a():E("smoothScroll")?("undefined"==typeof YAHOO?"undefined":n(YAHOO))!==q&&n(YAHOO.env)!==q&&n(YAHOO.env.ua)!==q&&n(YAHOO.util)!==q&&n(YAHOO.util.Scroll)!==q?(b=YAHOO.env.ua.webkit?document.body:document.documentElement,d=YAHOO.util.Easing?YAHOO.util.Easing.easeOut:void 0,c=new YAHOO.util.Scroll(b,{scroll:{to:[0,x]}},E("scrollDuration")/1e3,d),c.onComplete.subscribe(a),c.animate()):s?jQuery("body, html").animate({scrollTop:x},E("scrollDuration"),a):(0>x&&(x=0),e=v>t?-1:1,f=Math.abs(v-x)/(E("scrollDuration")/10),(g=function(){var b=h.getScrollTop(),c=b+e*f;return e>0&&c>=x||0>e&&x>=c?(c=x,a&&a(),void window.scrollTo(0,c)):(window.scrollTo(0,c),h.getScrollTop()===b?void(a&&a()):void setTimeout(g,10))})()):(window.scrollTo(0,x),a&&a())},I=function P(a,b){var c,d,e;u+a>=0&&u+a<t.steps.length?(u+=a,d=F(),e=function(){c=h.getStepTarget(d),c?(A[u]&&delete A[u],b(u)):(A[u]=!0,h.invokeEventCallbacks("error"),P(a,b))},d.delay?setTimeout(e,d.delay):e()):b(-1)},J=function(a,b){var c,d,e,f,g=C(),i=this;if(g.hide(),a=h.valOrDefault(a,!0),c=F(),c.nextOnTargetClick&&h.removeEvtListener(h.getStepTarget(c),"click",G),d=c,e=b>0?d.multipage:u>0&&t.steps[u-1].multipage,f=function(c){var f;if(-1===c)return this.endTour(!0);if(a&&(f=b>0?h.invokeEventCallbacks("next",d.onNext):h.invokeEventCallbacks("prev",d.onPrev)),c===u){if(e)return void N();f=h.valOrDefault(f,!0),f?this.showStep(c):this.endTour(!1)}},!e&&E("skipIfNoElement"))I(b,function(a){f.call(i,a)});else if(u+b>=0&&u+b<t.steps.length){if(u+=b,c=F(),!h.getStepTarget(c)&&!e)return h.invokeEventCallbacks("error"),this.endTour(!0,!1);f.call(this,u)}else if(u+b===t.steps.length)return this.endTour();return this},K=function(a){var b,c,d,e={};for(b in a)a.hasOwnProperty(b)&&"id"!==b&&"steps"!==b&&(e[b]=a[b]);return y.call(this,e,!0),c=h.getState(E("cookieName")),c&&(d=c.split(":"),w=d[0],x=d[1],d.length>2&&(B=d[2].split(",")),x=parseInt(x,10)),this},L=function(a,b,c){var d,e;if(u=a||0,A=b||{},d=F(),e=h.getStepTarget(d))return void c(u);if(!e){if(h.invokeEventCallbacks("error"),A[u]=!0,E("skipIfNoElement"))return void I(1,c);u=-1,c(u)}},M=function(a){function b(){d.show(),h.invokeEventCallbacks("show",c.onShow)}var c=t.steps[a],d=C(),e=h.getStepTarget(c);u!==a&&F().nextOnTargetClick&&h.removeEvtListener(h.getStepTarget(F()),"click",G),u=a,d.hide(!1),d.render(c,a,function(a){a?H(b):b(),c.nextOnTargetClick&&h.addEvtListener(e,"click",G)}),N()},N=function(){var a=t.id+":"+u,b=m.getSkippedStepsIndexes();b&&b.length>0&&(a+=":"+b.join(",")),h.setState(E("cookieName"),a,1)},O=function(a){a&&this.configure(a)};this.getCalloutManager=function(){return("undefined"==typeof k?"undefined":n(k))===q&&(k=new c),k},this.startTour=function(a,b){var c,d,e={},f=this;if(!t){if(!a)throw new Error("Tour data is required for startTour.");if(!a.id||!v.test(a.id))throw new Error("Tour ID is using an invalid format. Use alphanumeric, underscores, and/or hyphens only. First character must be a letter.");t=a,K.call(this,a)}if(("undefined"==typeof b?"undefined":n(b))!==q){if(b>=t.steps.length)throw new Error("Specified step number out of bounds.");d=b}if(!h.documentIsReady())return r=!0,this;if("undefined"==typeof d&&t.id===w&&("undefined"==typeof x?"undefined":n(x))!==q){if(d=x,B.length>0)for(var g=0,i=B.length;i>g;g++)e[B[g]]=!0}else d||(d=0);return L(d,e,function(a){var b=-1!==a&&h.getStepTarget(t.steps[a]);return b?(h.invokeEventCallbacks("start"),c=C(),c.hide(!1),f.isActive=!0,void(h.getStepTarget(F())?f.showStep(a):(h.invokeEventCallbacks("error"),E("skipIfNoElement")&&f.nextStep(!1)))):void f.endTour(!1,!1)}),this},this.showStep=function(a){var b=t.steps[a],c=u;return h.getStepTarget(b)?(b.delay?setTimeout(function(){M(a)},b.delay):M(a),this):(u=a,h.invokeEventCallbacks("error"),void(u=c))},this.prevStep=function(a){return J.call(this,a,-1),this},this.nextStep=function(a){return J.call(this,a,1),this},this.endTour=function(a,b){var c,d=C();return a=h.valOrDefault(a,!0),b=h.valOrDefault(b,!0),t&&(c=F(),c&&c.nextOnTargetClick&&h.removeEvtListener(h.getStepTarget(c),"click",G)),u=0,x=void 0,d.hide(),a&&h.clearState(E("cookieName")),this.isActive&&(this.isActive=!1,t&&b&&h.invokeEventCallbacks("end")),this.removeCallbacks(null,!0),this.resetDefaultOptions(),D(),t=null,this},this.getCurrTour=function(){return t},this.getCurrTarget=function(){return h.getStepTarget(F())},this.getCurrStepNum=function(){return u},this.getSkippedStepsIndexes=function(){var a,b=[];for(a in A)b.push(a);return b},this.refreshBubblePosition=function(){var a=F();return a&&C().setPosition(a),this.getCalloutManager().refreshCalloutPositions(),this},this.listen=function(a,b,c){return a&&i[a].push({cb:b,fromTour:c}),this},this.unlisten=function(a,b){var c,d,e=i[a];for(c=0,d=e.length;d>c;++c)e[c].cb===b&&e.splice(c,1);return this},this.removeCallbacks=function(a,b){var c,d,e,f;for(f in i)if(!a||a===f)if(b)for(c=i[f],d=0,e=c.length;e>d;++d)c[d].fromTour&&(c.splice(d--,1),--e);else i[f]=[];return this},this.registerHelper=function(a,b){"string"==typeof a&&"function"==typeof b&&(j[a]=b)},this.unregisterHelper=function(a){j[a]=null},this.invokeHelper=function(a){var b,c,d=[];for(b=1,c=arguments.length;c>b;++b)d.push(arguments[b]);j[a]&&j[a].call(null,d)},this.setCookieName=function(a){return p.cookieName=a,this},this.resetDefaultOptions=function(){return p={},this},this.resetDefaultI18N=function(){return e={},this},this.getState=function(){return h.getState(E("cookieName"))},y=function(a,b){var c,d,f,g,i=["next","prev","start","end","show","error","close"];for(p||this.resetDefaultOptions(),h.extend(p,a),a&&h.extend(e,a.i18n),f=0,g=i.length;g>f;++f)d="on"+i[f].charAt(0).toUpperCase()+i[f].substring(1),a[d]&&this.listen(i[f],a[d],b);return c=C(!0),this},this.configure=function(a){return y.call(this,a,!1)},this.setRenderer=function(a){var b="undefined"==typeof a?"undefined":n(a);return"string"===b?(o=a,f=void 0):"function"===b&&(f=a),this},this.setEscaper=function(a){return"function"==typeof a&&(g=a),this},O.call(this,a)},m=new a,function(){var a={};a.escape=function(a){return g?g(a):null==a?"":(""+a).replace(new RegExp("[&<>\\"\']","g"),function(a){return"&"==a?"&amp;":"<"==a?"&lt;":">"==a?"&gt;":\'"\'==a?"&quot;":"\'"==a?"&#x27;":void 0})},this.templates=this.templates||{},this.templates.bubble_default=function(b){function c(b,c){return c?a.escape(b):b}var d,e="";a.escape,Array.prototype.join;e+="\\n";var f=b.i18n,g=b.buttons,h=b.step,i=b.tour;return e+=\'\\n<div class="hopscotch-bubble-container" style="width: \'+(null==(d=h.width)?"":d)+"px; padding: "+(null==(d=h.padding)?"":d)+\'px;">\\n  \',i.isTour&&(e+=\'<span class="hopscotch-bubble-number">\'+(null==(d=f.stepNum)?"":d)+"</span>"),e+=\'\\n  <div class="hopscotch-bubble-content">\\n    \',""!==h.title&&(e+=\'<h3 class="hopscotch-title">\'+(null==(d=c(h.title,i.unsafe))?"":d)+"</h3>"),e+="\\n    ",""!==h.content&&(e+=\'<div class="hopscotch-content">\'+(null==(d=c(h.content,i.unsafe))?"":d)+"</div>"),e+=\'\\n  </div>\\n  <div class="hopscotch-actions">\\n    \',g.showPrev&&(e+=\'<button class="hopscotch-nav-button prev hopscotch-prev">\'+(null==(d=f.prevBtn)?"":d)+"</button>"),e+="\\n    ",g.showCTA&&(e+=\'<button class="hopscotch-nav-button next hopscotch-cta">\'+(null==(d=g.ctaLabel)?"":d)+"</button>"),e+="\\n    ",g.showNext&&(e+=\'<button class="hopscotch-nav-button next hopscotch-next">\'+(null==(d=f.nextBtn)?"":d)+"</button>"),e+="\\n  </div>\\n  ",g.showClose&&(e+=\'<button class="hopscotch-bubble-close hopscotch-close">\'+(null==(d=f.closeTooltip)?"":d)+"</button>"),e+=\'\\n</div>\\n<div class="hopscotch-bubble-arrow-container hopscotch-arrow">\\n  <div class="hopscotch-bubble-arrow-border"></div>\\n  <div class="hopscotch-bubble-arrow"></div>\\n</div>\\n\'}}.call(m);var y=m;return y});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2hvcHNjb3RjaC9kaXN0L2pzL2hvcHNjb3RjaC5taW4uanM/Mzc0OSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUseUZBQXdJLGlCQUFpQixhQUFhLHdHQUF3RyxnQkFBZ0IsYUFBYSxvR0FBb0csaUtBQWlLLDJCQUEyQixJQUFJLG9KQUFvSixVQUFVLEdBQUcsMk5BQTJOLDJDQUEyQywyREFBMkQsZUFBZSxpQkFBaUIsSUFBSSx1QkFBdUIsWUFBWSxnQkFBZ0IsMERBQTBELElBQUksNkNBQTZDLHVDQUF1QyxtQkFBbUIsMkJBQTJCLFlBQVksMERBQTBELElBQUksa0NBQWtDLHVDQUF1Qyx3QkFBd0IsTUFBTSx3RUFBd0UsMkJBQTJCLDZDQUE2QyxtREFBbUQsNEJBQTRCLHVEQUF1RCx1Q0FBdUMsTUFBTSwwRkFBMEYsaUNBQWlDLFFBQVEscUJBQXFCLCtEQUErRCxtQkFBbUIsSUFBSSw0QkFBNEIsNEJBQTRCLHdGQUF3RixvQ0FBb0MsZUFBZSxtQ0FBbUMsbUJBQW1CLElBQUksaUNBQWlDLHlCQUF5QixNQUFNLHlGQUF5RiwwQkFBMEIsTUFBTSwwRkFBMEYsNEJBQTRCLGlFQUFpRSxnQ0FBZ0Msc0ZBQXNGLG1DQUFtQyw0RkFBNEYsNEJBQTRCLHVDQUF1QywrQkFBK0Isa0VBQWtFLHNCQUFzQixNQUFNLDRDQUE0QyxpQ0FBaUMsaUNBQWlDLGNBQWMsMkNBQTJDLDBDQUEwQyw4QkFBOEIsaUNBQWlDLFVBQVUsa0ZBQWtGLDJCQUEyQixNQUFNLDZCQUE2QixvRUFBb0UsNEJBQTRCLFFBQVEsMEJBQTBCLElBQUkscUZBQXFGLFlBQVksZ0JBQWdCLDJCQUEyQixrQkFBa0IsMEJBQTBCLFdBQVcsWUFBWSw0QkFBNEIsU0FBUywwQkFBMEIsOEZBQThGLHdEQUF3RCxTQUFTLHNC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RCxtQ0FBbUMsVUFBVSwrQkFBK0IsYUFBYSwyQkFBMkIsSUFBSSx5QkFBeUIsd0JBQXdCLGdDQUFnQywyQkFBMkIscUNBQXFDLFdBQVcsTUFBTSxrQ0FBa0MsV0FBVyxNQUFNLDBCQUEwQixtQ0FBbUMsaUJBQWlCLG1FQUFtRSxxRkFBcUYsSUFBSSx5RkFBeUYsb0JBQW9CLDRCQUE0Qix5QkFBeUIsOEJBQThCLDZDQUE2Qyw2REFBNkQsNkJBQTZCLHVDQUF1QyxnQkFBZ0Isb0JBQW9CLFNBQVMscUJBQXFCLCtFQUErRSxtQkFBbUIsY0FBYyxjQUFjLGdCQUFnQixnQkFBZ0IsU0FBUyxFQUFFLGtDQUFrQywyQ0FBMkMsZ0JBQWdCLHVCQUF1QixXQUFXLDhCQUE4QixRQUFRLDJDQUEyQyxrR0FBa0csMkNBQTJDLGltQ0FBaW1DLFNBQVMsUUFBUSxTQUFTIiwiZmlsZSI6IjE1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqISBob3BzY290Y2ggLSB2MC4zLjFcbipcbiogQ29weXJpZ2h0IDIwMTcgTGlua2VkSW4gQ29ycC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuIWZ1bmN0aW9uKGEsYil7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9YigpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoYik6YS5ob3BzY290Y2g9YigpfSh0aGlzLGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIGEsYixjLGQsZSxmLGcsaCxpLGosayxsLG0sbj1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24oYSl7cmV0dXJuIHR5cGVvZiBhfTpmdW5jdGlvbihhKXtyZXR1cm4gYSYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZhLmNvbnN0cnVjdG9yPT09U3ltYm9sJiZhIT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiBhfSxvPVwiYnViYmxlX2RlZmF1bHRcIixwPXdpbmRvdy5TaXp6bGV8fG51bGwscT1cInVuZGVmaW5lZFwiLHI9ITEscz0oXCJ1bmRlZmluZWRcIj09dHlwZW9mIGpRdWVyeT9cInVuZGVmaW5lZFwiOm4oalF1ZXJ5KSkhPT1xLHQ9ITEsdT0hMSx2PS9eW2EtekEtWl0rW2EtekEtWjAtOV8tXSokLyx3PXtsZWZ0OlwicmlnaHRcIixyaWdodDpcImxlZnRcIn07dHJ5e24od2luZG93LnNlc3Npb25TdG9yYWdlKSE9PXEmJih0PSEwLHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oXCJob3BzY290Y2gudGVzdC5zdG9yYWdlXCIsXCJva1wiKSxzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKFwiaG9wc2NvdGNoLnRlc3Quc3RvcmFnZVwiKSx1PSEwKX1jYXRjaCh4KXt9bD17c21vb3RoU2Nyb2xsOiEwLHNjcm9sbER1cmF0aW9uOjFlMyxzY3JvbGxUb3BNYXJnaW46MjAwLHNob3dDbG9zZUJ1dHRvbjohMCxzaG93UHJldkJ1dHRvbjohMSxzaG93TmV4dEJ1dHRvbjohMCxidWJibGVXaWR0aDoyODAsYnViYmxlUGFkZGluZzoxNSxhcnJvd1dpZHRoOjIwLHNraXBJZk5vRWxlbWVudDohMCxpc1J0bDohMSxjb29raWVOYW1lOlwiaG9wc2NvdGNoLnRvdXIuc3RhdGVcIn0sQXJyYXkuaXNBcnJheXx8KEFycmF5LmlzQXJyYXk9ZnVuY3Rpb24oYSl7cmV0dXJuXCJbb2JqZWN0IEFycmF5XVwiPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGEpfSksaz1mdW5jdGlvbigpe3ImJm0uc3RhcnRUb3VyKCl9LGg9e2FkZENsYXNzOmZ1bmN0aW9uKGEsYil7dmFyIGMsZCxlLGY7aWYoYS5jbGFzc05hbWUpe2ZvcihkPWIuc3BsaXQoL1xccysvKSxjPVwiIFwiK2EuY2xhc3NOYW1lK1wiIFwiLGU9MCxmPWQubGVuZ3RoO2Y+ZTsrK2UpYy5pbmRleE9mKFwiIFwiK2RbZV0rXCIgXCIpPDAmJihjKz1kW2VdK1wiIFwiKTthLmNsYXNzTmFtZT1jLnJlcGxhY2UoL15cXHMrfFxccyskL2csXCJcIil9ZWxzZSBhLmNsYXNzTmFtZT1ifSxyZW1vdmVDbGFzczpmdW5jdGlvbihhLGIpe3ZhciBjLGQsZSxmO2ZvcihkPWIuc3BsaXQoL1xccysvKSxjPVwiIFwiK2EuY2xhc3NOYW1lK1wiIFwiLGU9MCxmPWQubGVuZ3RoO2Y+ZTsrK2UpYz1jLnJlcGxhY2UoXCIgXCIrZFtlXStcIiBcIixcIiBcIik7YS5jbGFzc05hbWU9Yy5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLFwiXCIpfSxoYXNDbGFzczpmdW5jdGlvbihhLGIpe3ZhciBjO3JldHVybiBhLmNsYXNzTmFtZT8oYz1cIiBcIithLmNsYXNzTmFtZStcIiBcIiwtMSE9PWMuaW5kZXhPZihcIiBcIitiK1wiIFwiKSk6ITF9LGdldFBpeGVsVmFsdWU6ZnVuY3Rpb24oYSl7dmFyIGI9XCJ1bmRlZmluZWRcIj09dHlwZW9mIGE/XCJ1bmRlZmluZWRcIjpuKGEpO3JldHVyblwibnVtYmVyXCI9PT1iP2E6XCJzdHJpbmdcIj09PWI/cGFyc2VJbnQoYSwxMCk6MH0sdmFsT3JEZWZhdWx0OmZ1bmN0aW9uKGEsYil7cmV0dXJuKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBhP1widW5kZWZpbmVkXCI6bihhKSkhPT1xP2E6Yn0saW52b2tlQ2FsbGJhY2tBcnJheUhlbHBlcjpmdW5jdGlvbihhKXt2YXIgYjtyZXR1cm4gQXJyYXkuaXNBcnJheShhKSYmKGI9althWzBdXSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBiKT9iLmFwcGx5KHRoaXMsYS5zbGljZSgxKSk6dm9pZCAwfSxpbnZva2VDYWxsYmFja0FycmF5OmZ1bmN0aW9uKGEpe3ZhciBiLGM7aWYoQXJyYXkuaXNBcnJheShhKSl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGFbMF0pcmV0dXJuIGguaW52b2tlQ2FsbGJhY2tBcnJheUhlbHBlcihhKTtmb3IoYj0wLGM9YS5sZW5ndGg7Yz5iOysrYiloLmludm9rZUNhbGxiYWNrKGFbYl0pfX0saW52b2tlQ2FsbGJhY2s6ZnVuY3Rpb24oYSl7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgYT9hKCk6XCJzdHJpbmdcIj09dHlwZW9mIGEmJmpbYV0/althXSgpOmguaW52b2tlQ2FsbGJhY2tBcnJheShhKX0saW52b2tlRXZlbnRDYWxsYmFja3M6ZnVuY3Rpb24oYSxiKXt2YXIgYyxkLGU9aVthXTtpZihiKXJldHVybiB0aGlzLmludm9rZUNhbGxiYWNrKGIpO2ZvcihjPTAsZD1lLmxlbmd0aDtkPmM7KytjKXRoaXMuaW52b2tlQ2FsbGJhY2soZVtjXS5jYil9LGdldFNjcm9sbFRvcDpmdW5jdGlvbigpe3ZhciBhO3JldHVybiBhPW4od2luZG93LnBhZ2VZT2Zmc2V0KSE9PXE/d2luZG93LnBhZ2VZT2Zmc2V0OmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3B9LGdldFNjcm9sbExlZnQ6ZnVuY3Rpb24oKXt2YXIgYTtyZXR1cm4gYT1uKHdpbmRvdy5wYWdlWE9mZnNldCkhPT1xP3dpbmRvdy5wYWdlWE9mZnNldDpkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdH0sZ2V0V2luZG93SGVpZ2h0OmZ1bmN0aW9uKCl7cmV0dXJuIHdpbmRvdy5pbm5lckhlaWdodHx8ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodH0sYWRkRXZ0TGlzdGVuZXI6ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBhP2EuYWRkRXZlbnRMaXN0ZW5lcj9hLmFkZEV2ZW50TGlzdGVuZXIoYixjLCExKTphLmF0dGFjaEV2ZW50KFwib25cIitiLGMpOnZvaWQgMH0scmVtb3ZlRXZ0TGlzdGVuZXI6ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBhP2EucmVtb3ZlRXZlbnRMaXN0ZW5lcj9hLnJlbW92ZUV2ZW50TGlzdGVuZXIoYixjLCExKTphLmRldGFjaEV2ZW50KFwib25cIitiLGMpOnZvaWQgMH0sZG9jdW1lbnRJc1JlYWR5OmZ1bmN0aW9uKCl7cmV0dXJuXCJjb21wbGV0ZVwiPT09ZG9jdW1lbnQucmVhZHlTdGF0ZX0sZXZ0UHJldmVudERlZmF1bHQ6ZnVuY3Rpb24oYSl7YS5wcmV2ZW50RGVmYXVsdD9hLnByZXZlbnREZWZhdWx0KCk6ZXZlbnQmJihldmVudC5yZXR1cm5WYWx1ZT0hMSl9LGV4dGVuZDpmdW5jdGlvbihhLGIpe3ZhciBjO2ZvcihjIGluIGIpYi5oYXNPd25Qcm9wZXJ0eShjKSYmKGFbY109YltjXSl9LGdldFN0ZXBUYXJnZXRIZWxwZXI6ZnVuY3Rpb24oYSl7dmFyIGI9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYSk7aWYoYilyZXR1cm4gYjtpZihzKXJldHVybiBiPWpRdWVyeShhKSxiLmxlbmd0aD9iWzBdOm51bGw7aWYocClyZXR1cm4gYj1uZXcgcChhKSxiLmxlbmd0aD9iWzBdOm51bGw7aWYoZG9jdW1lbnQucXVlcnlTZWxlY3Rvcil0cnl7cmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYSl9Y2F0Y2goYyl7fXJldHVybi9eI1thLXpBLVpdW1xcdy1fOi5dKiQvLnRlc3QoYSk/ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYS5zdWJzdHJpbmcoMSkpOm51bGx9LGdldFN0ZXBUYXJnZXQ6ZnVuY3Rpb24oYSl7dmFyIGI7aWYoIWF8fCFhLnRhcmdldClyZXR1cm4gbnVsbDtpZihcInN0cmluZ1wiPT10eXBlb2YgYS50YXJnZXQpcmV0dXJuIGguZ2V0U3RlcFRhcmdldEhlbHBlcihhLnRhcmdldCk7aWYoQXJyYXkuaXNBcnJheShhLnRhcmdldCkpe3ZhciBjLGQ7Zm9yKGM9MCxkPWEudGFyZ2V0Lmxlbmd0aDtkPmM7YysrKWlmKFwic3RyaW5nXCI9PXR5cGVvZiBhLnRhcmdldFtjXSYmKGI9aC5nZXRTdGVwVGFyZ2V0SGVscGVyKGEudGFyZ2V0W2NdKSkpcmV0dXJuIGI7cmV0dXJuIG51bGx9cmV0dXJuIGEudGFyZ2V0fSxnZXRJMThOU3RyaW5nOmZ1bmN0aW9uKGEpe3JldHVybiBlW2FdfHxkW2FdfSxzZXRTdGF0ZTpmdW5jdGlvbihhLGIsYyl7dmFyIGQsZT1cIlwiO2lmKHQmJnUpdHJ5e3Nlc3Npb25TdG9yYWdlLnNldEl0ZW0oYSxiKX1jYXRjaChmKXt1PSExLHRoaXMuc2V0U3RhdGUoYSxiLGMpfWVsc2UgdCYmc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShhKSxjJiYoZD1uZXcgRGF0ZSxkLnNldFRpbWUoZC5nZXRUaW1lKCkrMjQqYyo2MCo2MCoxZTMpLGU9XCI7IGV4cGlyZXM9XCIrZC50b0dNVFN0cmluZygpKSxkb2N1bWVudC5jb29raWU9YStcIj1cIitiK2UrXCI7IHBhdGg9L1wifSxnZXRTdGF0ZTpmdW5jdGlvbihhKXt2YXIgYixjLGQsZT1hK1wiPVwiLGY9ZG9jdW1lbnQuY29va2llLnNwbGl0KFwiO1wiKTtpZih0JiYoZD1zZXNzaW9uU3RvcmFnZS5nZXRJdGVtKGEpKSlyZXR1cm4gZDtmb3IoYj0wO2I8Zi5sZW5ndGg7YisrKXtmb3IoYz1mW2JdO1wiIFwiPT09Yy5jaGFyQXQoMCk7KWM9Yy5zdWJzdHJpbmcoMSxjLmxlbmd0aCk7aWYoMD09PWMuaW5kZXhPZihlKSl7ZD1jLnN1YnN0cmluZyhlLmxlbmd0aCxjLmxlbmd0aCk7YnJlYWt9fXJldHVybiBkfSxjbGVhclN0YXRlOmZ1bmN0aW9uKGEpe3Q/c2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShhKTp0aGlzLnNldFN0YXRlKGEsXCJcIiwtMSl9LG5vcm1hbGl6ZVBsYWNlbWVudDpmdW5jdGlvbihhKXshYS5wbGFjZW1lbnQmJmEub3JpZW50YXRpb24mJihhLnBsYWNlbWVudD1hLm9yaWVudGF0aW9uKX0sZmxpcFBsYWNlbWVudDpmdW5jdGlvbihhKXtpZihhLmlzUnRsJiYhYS5faXNGbGlwcGVkKXt2YXIgYixjLGQ9W1wib3JpZW50YXRpb25cIixcInBsYWNlbWVudFwiXTthLnhPZmZzZXQmJihhLnhPZmZzZXQ9LTEqdGhpcy5nZXRQaXhlbFZhbHVlKGEueE9mZnNldCkpO2ZvcihjIGluIGQpYj1kW2NdLGEuaGFzT3duUHJvcGVydHkoYikmJncuaGFzT3duUHJvcGVydHkoYVtiXSkmJihhW2JdPXdbYVtiXV0pO2EuX2lzRmxpcHBlZD0hMH19fSxoLmFkZEV2dExpc3RlbmVyKHdpbmRvdyxcImxvYWRcIixrKSxpPXtuZXh0OltdLHByZXY6W10sc3RhcnQ6W10sZW5kOltdLHNob3c6W10sZXJyb3I6W10sY2xvc2U6W119LGo9e30sZD17c3RlcE51bXM6bnVsbCxuZXh0QnRuOlwiTmV4dFwiLHByZXZCdG46XCJCYWNrXCIsZG9uZUJ0bjpcIkRvbmVcIixza2lwQnRuOlwiU2tpcFwiLGNsb3NlVG9vbHRpcDpcIkNsb3NlXCJ9LGU9e30sYj1mdW5jdGlvbihhKXt0aGlzLmluaXQoYSl9LGIucHJvdG90eXBlPXtpc1Nob3dpbmc6ITEsY3VyclN0ZXA6dm9pZCAwLHNldFBvc2l0aW9uOmZ1bmN0aW9uKGEpe3ZhciBiLGMsZCxlLGYsZyxpLGo9aC5nZXRTdGVwVGFyZ2V0KGEpLGs9dGhpcy5lbGVtZW50LGw9dGhpcy5hcnJvd0VsLG09YS5pc1J0bD9cInJpZ2h0XCI6XCJsZWZ0XCI7aWYoaC5mbGlwUGxhY2VtZW50KGEpLGgubm9ybWFsaXplUGxhY2VtZW50KGEpLGM9ay5vZmZzZXRXaWR0aCxiPWsub2Zmc2V0SGVpZ2h0LGgucmVtb3ZlQ2xhc3MoayxcImZhZGUtaW4tZG93biBmYWRlLWluLXVwIGZhZGUtaW4tbGVmdCBmYWRlLWluLXJpZ2h0XCIpLGQ9ai5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxpPWEuaXNSdGw/ZC5yaWdodC1jOmQubGVmdCxcInRvcFwiPT09YS5wbGFjZW1lbnQpZT1kLnRvcC1iLXRoaXMub3B0LmFycm93V2lkdGgsZj1pO2Vsc2UgaWYoXCJib3R0b21cIj09PWEucGxhY2VtZW50KWU9ZC5ib3R0b20rdGhpcy5vcHQuYXJyb3dXaWR0aCxmPWk7ZWxzZSBpZihcImxlZnRcIj09PWEucGxhY2VtZW50KWU9ZC50b3AsZj1kLmxlZnQtYy10aGlzLm9wdC5hcnJvd1dpZHRoO2Vsc2V7aWYoXCJyaWdodFwiIT09YS5wbGFjZW1lbnQpdGhyb3cgbmV3IEVycm9yKFwiQnViYmxlIHBsYWNlbWVudCBmYWlsZWQgYmVjYXVzZSBzdGVwLnBsYWNlbWVudCBpcyBpbnZhbGlkIG9yIHVuZGVmaW5lZCFcIik7ZT1kLnRvcCxmPWQucmlnaHQrdGhpcy5vcHQuYXJyb3dXaWR0aH1nPVwiY2VudGVyXCIhPT1hLmFycm93T2Zmc2V0P2guZ2V0UGl4ZWxWYWx1ZShhLmFycm93T2Zmc2V0KTphLmFycm93T2Zmc2V0LGc/XCJ0b3BcIj09PWEucGxhY2VtZW50fHxcImJvdHRvbVwiPT09YS5wbGFjZW1lbnQ/KGwuc3R5bGUudG9wPVwiXCIsXCJjZW50ZXJcIj09PWc/bC5zdHlsZVttXT1NYXRoLmZsb29yKGMvMi1sLm9mZnNldFdpZHRoLzIpK1wicHhcIjpsLnN0eWxlW21dPWcrXCJweFwiKTooXCJsZWZ0XCI9PT1hLnBsYWNlbWVudHx8XCJyaWdodFwiPT09YS5wbGFjZW1lbnQpJiYobC5zdHlsZVttXT1cIlwiLFwiY2VudGVyXCI9PT1nP2wuc3R5bGUudG9wPU1hdGguZmxvb3IoYi8yLWwub2Zmc2V0SGVpZ2h0LzIpK1wicHhcIjpsLnN0eWxlLnRvcD1nK1wicHhcIik6KGwuc3R5bGUudG9wPVwiXCIsbC5zdHlsZVttXT1cIlwiKSxcImNlbnRlclwiPT09YS54T2Zmc2V0P2Y9ZC5sZWZ0K2oub2Zmc2V0V2lkdGgvMi1jLzI6Zis9aC5nZXRQaXhlbFZhbHVlKGEueE9mZnNldCksXCJjZW50ZXJcIj09PWEueU9mZnNldD9lPWQudG9wK2oub2Zmc2V0SGVpZ2h0LzItYi8yOmUrPWguZ2V0UGl4ZWxWYWx1ZShhLnlPZmZzZXQpLGEuZml4ZWRFbGVtZW50fHwoZSs9aC5nZXRTY3JvbGxUb3AoKSxmKz1oLmdldFNjcm9sbExlZnQoKSksay5zdHlsZS5wb3NpdGlvbj1hLmZpeGVkRWxlbWVudD9cImZpeGVkXCI6XCJhYnNvbHV0ZVwiLGsuc3R5bGUudG9wPWUrXCJweFwiLGsuc3R5bGUubGVmdD1mK1wicHhcIn0scmVuZGVyOmZ1bmN0aW9uKGEsYixjKXt2YXIgZCxlLGcsaSxqLGssbCxuLHAscSxyPXRoaXMuZWxlbWVudDtpZihhP3RoaXMuY3VyclN0ZXA9YTp0aGlzLmN1cnJTdGVwJiYoYT10aGlzLmN1cnJTdGVwKSx0aGlzLm9wdC5pc1RvdXJCdWJibGU/KGk9bS5nZXRDdXJyVG91cigpLGkmJihlPWkuY3VzdG9tRGF0YSxkPWkuY3VzdG9tUmVuZGVyZXIsYS5pc1J0bD1hLmhhc093blByb3BlcnR5KFwiaXNSdGxcIik/YS5pc1J0bDppLmhhc093blByb3BlcnR5KFwiaXNSdGxcIik/aS5pc1J0bDp0aGlzLm9wdC5pc1J0bCxnPWkudW5zYWZlLEFycmF5LmlzQXJyYXkoaS5zdGVwcykmJihqPWkuc3RlcHMubGVuZ3RoLGs9dGhpcy5fZ2V0U3RlcEkxOG5OdW0odGhpcy5fZ2V0U3RlcE51bShqLTEpKSxuPXRoaXMuX2dldFN0ZXBOdW0oYik9PT10aGlzLl9nZXRTdGVwTnVtKGotMSkpKSk6KGU9YS5jdXN0b21EYXRhLGQ9YS5jdXN0b21SZW5kZXJlcixnPWEudW5zYWZlLGEuaXNSdGw9YS5oYXNPd25Qcm9wZXJ0eShcImlzUnRsXCIpP2EuaXNSdGw6dGhpcy5vcHQuaXNSdGwpLGw9bj9oLmdldEkxOE5TdHJpbmcoXCJkb25lQnRuXCIpOmEuc2hvd1NraXA/aC5nZXRJMThOU3RyaW5nKFwic2tpcEJ0blwiKTpoLmdldEkxOE5TdHJpbmcoXCJuZXh0QnRuXCIpLGguZmxpcFBsYWNlbWVudChhKSxoLm5vcm1hbGl6ZVBsYWNlbWVudChhKSx0aGlzLnBsYWNlbWVudD1hLnBsYWNlbWVudCxxPXtpMThuOntwcmV2QnRuOmguZ2V0STE4TlN0cmluZyhcInByZXZCdG5cIiksbmV4dEJ0bjpsLGNsb3NlVG9vbHRpcDpoLmdldEkxOE5TdHJpbmcoXCJjbG9zZVRvb2x0aXBcIiksc3RlcE51bTp0aGlzLl9nZXRTdGVwSTE4bk51bSh0aGlzLl9nZXRTdGVwTnVtKGIpKSxudW1TdGVwczprfSxidXR0b25zOntzaG93UHJldjpoLnZhbE9yRGVmYXVsdChhLnNob3dQcmV2QnV0dG9uLHRoaXMub3B0LnNob3dQcmV2QnV0dG9uKSYmdGhpcy5fZ2V0U3RlcE51bShiKT4wLHNob3dOZXh0OmgudmFsT3JEZWZhdWx0KGEuc2hvd05leHRCdXR0b24sdGhpcy5vcHQuc2hvd05leHRCdXR0b24pLHNob3dDVEE6aC52YWxPckRlZmF1bHQoYS5zaG93Q1RBQnV0dG9uJiZhLmN0YUxhYmVsLCExKSxjdGFMYWJlbDphLmN0YUxhYmVsLHNob3dDbG9zZTpoLnZhbE9yRGVmYXVsdCh0aGlzLm9wdC5zaG93Q2xvc2VCdXR0b24sITApfSxzdGVwOntudW06Yixpc0xhc3Q6aC52YWxPckRlZmF1bHQobiwhMSksdGl0bGU6YS50aXRsZXx8XCJcIixjb250ZW50OmEuY29udGVudHx8XCJcIixpc1J0bDphLmlzUnRsLHBsYWNlbWVudDphLnBsYWNlbWVudCxwYWRkaW5nOmgudmFsT3JEZWZhdWx0KGEucGFkZGluZyx0aGlzLm9wdC5idWJibGVQYWRkaW5nKSx3aWR0aDpoLmdldFBpeGVsVmFsdWUoYS53aWR0aCl8fHRoaXMub3B0LmJ1YmJsZVdpZHRoLGN1c3RvbURhdGE6YS5jdXN0b21EYXRhfHx7fX0sdG91cjp7aXNUb3VyOnRoaXMub3B0LmlzVG91ckJ1YmJsZSxudW1TdGVwczpqLHVuc2FmZTpoLnZhbE9yRGVmYXVsdChnLCExKSxjdXN0b21EYXRhOmV8fHt9fX0sXCJmdW5jdGlvblwiPT10eXBlb2YgZClyLmlubmVySFRNTD1kKHEpO2Vsc2UgaWYoXCJzdHJpbmdcIj09dHlwZW9mIGQpe2lmKCFtLnRlbXBsYXRlc3x8XCJmdW5jdGlvblwiIT10eXBlb2YgbS50ZW1wbGF0ZXNbZF0pdGhyb3cgbmV3IEVycm9yKCdCdWJibGUgcmVuZGVyaW5nIGZhaWxlZCAtIHRlbXBsYXRlIFwiJytkKydcIiBpcyBub3QgYSBmdW5jdGlvbi4nKTtyLmlubmVySFRNTD1tLnRlbXBsYXRlc1tkXShxKX1lbHNlIGlmKGYpci5pbm5lckhUTUw9ZihxKTtlbHNle2lmKCFtLnRlbXBsYXRlc3x8XCJmdW5jdGlvblwiIT10eXBlb2YgbS50ZW1wbGF0ZXNbb10pdGhyb3cgbmV3IEVycm9yKCdCdWJibGUgcmVuZGVyaW5nIGZhaWxlZCAtIHRlbXBsYXRlIFwiJytvKydcIiBpcyBub3QgYSBmdW5jdGlvbi4nKTtyLmlubmVySFRNTD1tLnRlbXBsYXRlc1tvXShxKX12YXIgcyx0PXIuY2hpbGRyZW4sdT10Lmxlbmd0aDtmb3IocD0wO3U+cDtwKyspcz10W3BdLGguaGFzQ2xhc3MocyxcImhvcHNjb3RjaC1hcnJvd1wiKSYmKHRoaXMuYXJyb3dFbD1zKTtyZXR1cm4gci5zdHlsZS56SW5kZXg9XCJudW1iZXJcIj09dHlwZW9mIGEuemluZGV4P2EuemluZGV4OlwiXCIsdGhpcy5fc2V0QXJyb3coYS5wbGFjZW1lbnQpLHRoaXMuaGlkZSghMSksdGhpcy5zZXRQb3NpdGlvbihhKSxjJiZjKCFhLmZpeGVkRWxlbWVudCksdGhpc30sX2dldFN0ZXBOdW06ZnVuY3Rpb24oYSl7dmFyIGIsYyxkPTAsZT1tLmdldFNraXBwZWRTdGVwc0luZGV4ZXMoKSxmPWUubGVuZ3RoO2ZvcihjPTA7Zj5jO2MrKyliPWVbY10sYT5iJiZkKys7cmV0dXJuIGEtZH0sX2dldFN0ZXBJMThuTnVtOmZ1bmN0aW9uKGEpe3ZhciBiPWguZ2V0STE4TlN0cmluZyhcInN0ZXBOdW1zXCIpO3JldHVybiBiJiZhPGIubGVuZ3RoP2E9YlthXTphKz0xLGF9LF9zZXRBcnJvdzpmdW5jdGlvbihhKXtoLnJlbW92ZUNsYXNzKHRoaXMuYXJyb3dFbCxcImRvd24gdXAgcmlnaHQgbGVmdFwiKSxcInRvcFwiPT09YT9oLmFkZENsYXNzKHRoaXMuYXJyb3dFbCxcImRvd25cIik6XCJib3R0b21cIj09PWE/aC5hZGRDbGFzcyh0aGlzLmFycm93RWwsXCJ1cFwiKTpcImxlZnRcIj09PWE/aC5hZGRDbGFzcyh0aGlzLmFycm93RWwsXCJyaWdodFwiKTpcInJpZ2h0XCI9PT1hJiZoLmFkZENsYXNzKHRoaXMuYXJyb3dFbCxcImxlZnRcIil9LF9nZXRBcnJvd0RpcmVjdGlvbjpmdW5jdGlvbigpe3JldHVyblwidG9wXCI9PT10aGlzLnBsYWNlbWVudD9cImRvd25cIjpcImJvdHRvbVwiPT09dGhpcy5wbGFjZW1lbnQ/XCJ1cFwiOlwibGVmdFwiPT09dGhpcy5wbGFjZW1lbnQ/XCJyaWdodFwiOlwicmlnaHRcIj09PXRoaXMucGxhY2VtZW50P1wibGVmdFwiOnZvaWQgMH0sc2hvdzpmdW5jdGlvbigpe3ZhciBhPXRoaXMsYj1cImZhZGUtaW4tXCIrdGhpcy5fZ2V0QXJyb3dEaXJlY3Rpb24oKSxjPTFlMztyZXR1cm4gaC5yZW1vdmVDbGFzcyh0aGlzLmVsZW1lbnQsXCJoaWRlXCIpLGguYWRkQ2xhc3ModGhpcy5lbGVtZW50LGIpLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtoLnJlbW92ZUNsYXNzKGEuZWxlbWVudCxcImludmlzaWJsZVwiKX0sNTApLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtoLnJlbW92ZUNsYXNzKGEuZWxlbWVudCxiKX0sYyksdGhpcy5pc1Nob3dpbmc9ITAsdGhpc30saGlkZTpmdW5jdGlvbihhKXt2YXIgYj10aGlzLmVsZW1lbnQ7cmV0dXJuIGE9aC52YWxPckRlZmF1bHQoYSwhMCksYi5zdHlsZS50b3A9XCJcIixiLnN0eWxlLmxlZnQ9XCJcIixhPyhoLmFkZENsYXNzKGIsXCJoaWRlXCIpLGgucmVtb3ZlQ2xhc3MoYixcImludmlzaWJsZVwiKSk6KGgucmVtb3ZlQ2xhc3MoYixcImhpZGVcIiksaC5hZGRDbGFzcyhiLFwiaW52aXNpYmxlXCIpKSxoLnJlbW92ZUNsYXNzKGIsXCJhbmltYXRlIGZhZGUtaW4tdXAgZmFkZS1pbi1kb3duIGZhZGUtaW4tcmlnaHQgZmFkZS1pbi1sZWZ0XCIpLHRoaXMuaXNTaG93aW5nPSExLHRoaXN9LGRlc3Ryb3k6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmVsZW1lbnQ7YSYmYS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGEpLGgucmVtb3ZlRXZ0TGlzdGVuZXIoYSxcImNsaWNrXCIsdGhpcy5jbGlja0NiKX0sX2hhbmRsZUJ1YmJsZUNsaWNrOmZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGIoYyl7cmV0dXJuIGM9PT1hLmN1cnJlbnRUYXJnZXQ/bnVsbDpoLmhhc0NsYXNzKGMsXCJob3BzY290Y2gtY3RhXCIpP1wiY3RhXCI6aC5oYXNDbGFzcyhjLFwiaG9wc2NvdGNoLW5leHRcIik/XCJuZXh0XCI6aC5oYXNDbGFzcyhjLFwiaG9wc2NvdGNoLXByZXZcIik/XCJwcmV2XCI6aC5oYXNDbGFzcyhjLFwiaG9wc2NvdGNoLWNsb3NlXCIpP1wiY2xvc2VcIjpiKGMucGFyZW50RWxlbWVudCl9dmFyIGM7YT1hfHx3aW5kb3cuZXZlbnQ7dmFyIGQ9YS50YXJnZXR8fGEuc3JjRWxlbWVudDtpZihjPWIoZCksXCJjdGFcIj09PWMpdGhpcy5vcHQuaXNUb3VyQnViYmxlfHxtLmdldENhbGxvdXRNYW5hZ2VyKCkucmVtb3ZlQ2FsbG91dCh0aGlzLmN1cnJTdGVwLmlkKSx0aGlzLmN1cnJTdGVwLm9uQ1RBJiZoLmludm9rZUNhbGxiYWNrKHRoaXMuY3VyclN0ZXAub25DVEEpO2Vsc2UgaWYoXCJuZXh0XCI9PT1jKW0ubmV4dFN0ZXAoITApO2Vsc2UgaWYoXCJwcmV2XCI9PT1jKW0ucHJldlN0ZXAoITApO2Vsc2UgaWYoXCJjbG9zZVwiPT09Yyl7aWYodGhpcy5vcHQuaXNUb3VyQnViYmxlKXt2YXIgZT1tLmdldEN1cnJTdGVwTnVtKCksZj1tLmdldEN1cnJUb3VyKCksZz1lPT09Zi5zdGVwcy5sZW5ndGgtMTtoLmludm9rZUV2ZW50Q2FsbGJhY2tzKFwiY2xvc2VcIiksbS5lbmRUb3VyKCEwLGcpfWVsc2UgdGhpcy5vcHQub25DbG9zZSYmaC5pbnZva2VDYWxsYmFjayh0aGlzLm9wdC5vbkNsb3NlKSx0aGlzLm9wdC5pZCYmIXRoaXMub3B0LmlzVG91ckJ1YmJsZT9tLmdldENhbGxvdXRNYW5hZ2VyKCkucmVtb3ZlQ2FsbG91dCh0aGlzLm9wdC5pZCk6dGhpcy5kZXN0cm95KCk7aC5ldnRQcmV2ZW50RGVmYXVsdChhKX19LGluaXQ6ZnVuY3Rpb24oYSl7dmFyIGIsYyxkLGUsZj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLGc9dGhpcyxpPSExO3RoaXMuZWxlbWVudD1mLGU9e3Nob3dQcmV2QnV0dG9uOmwuc2hvd1ByZXZCdXR0b24sc2hvd05leHRCdXR0b246bC5zaG93TmV4dEJ1dHRvbixidWJibGVXaWR0aDpsLmJ1YmJsZVdpZHRoLGJ1YmJsZVBhZGRpbmc6bC5idWJibGVQYWRkaW5nLGFycm93V2lkdGg6bC5hcnJvd1dpZHRoLGlzUnRsOmwuaXNSdGwsc2hvd051bWJlcjohMCxpc1RvdXJCdWJibGU6ITB9LGE9KFwidW5kZWZpbmVkXCI9PXR5cGVvZiBhP1widW5kZWZpbmVkXCI6bihhKSk9PT1xP3t9OmEsaC5leHRlbmQoZSxhKSx0aGlzLm9wdD1lLGYuY2xhc3NOYW1lPVwiaG9wc2NvdGNoLWJ1YmJsZSBhbmltYXRlZFwiLGUuaXNUb3VyQnViYmxlPyhkPW0uZ2V0Q3VyclRvdXIoKSxkJiZoLmFkZENsYXNzKGYsXCJ0b3VyLVwiK2QuaWQpKTpoLmFkZENsYXNzKGYsXCJob3BzY290Y2gtY2FsbG91dCBuby1udW1iZXJcIiksYj1mdW5jdGlvbigpeyFpJiZnLmlzU2hvd2luZyYmKGk9ITAsc2V0VGltZW91dChmdW5jdGlvbigpe2cuc2V0UG9zaXRpb24oZy5jdXJyU3RlcCksaT0hMX0sMTAwKSl9LGguYWRkRXZ0TGlzdGVuZXIod2luZG93LFwicmVzaXplXCIsYiksdGhpcy5jbGlja0NiPWZ1bmN0aW9uKGEpe2cuX2hhbmRsZUJ1YmJsZUNsaWNrKGEpfSxoLmFkZEV2dExpc3RlbmVyKGYsXCJjbGlja1wiLHRoaXMuY2xpY2tDYiksdGhpcy5oaWRlKCksaC5kb2N1bWVudElzUmVhZHkoKT9kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGYpOihkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyPyhjPWZ1bmN0aW9uKCl7ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIixjKSx3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRcIixjKSxkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGYpfSxkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLGMsITEpKTooYz1mdW5jdGlvbigpe1wiY29tcGxldGVcIj09PWRvY3VtZW50LnJlYWR5U3RhdGUmJihkb2N1bWVudC5kZXRhY2hFdmVudChcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiLGMpLHdpbmRvdy5kZXRhY2hFdmVudChcIm9ubG9hZFwiLGMpLGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZikpfSxkb2N1bWVudC5hdHRhY2hFdmVudChcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiLGMpKSxoLmFkZEV2dExpc3RlbmVyKHdpbmRvdyxcImxvYWRcIixjKSl9fSxjPWZ1bmN0aW9uKCl7dmFyIGE9e30sYz17fTt0aGlzLmNyZWF0ZUNhbGxvdXQ9ZnVuY3Rpb24oZCl7dmFyIGU7aWYoIWQuaWQpdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBzcGVjaWZ5IGEgY2FsbG91dCBpZC5cIik7aWYoIXYudGVzdChkLmlkKSl0aHJvdyBuZXcgRXJyb3IoXCJDYWxsb3V0IElEIGlzIHVzaW5nIGFuIGludmFsaWQgZm9ybWF0LiBVc2UgYWxwaGFudW1lcmljLCB1bmRlcnNjb3JlcywgYW5kL29yIGh5cGhlbnMgb25seS4gRmlyc3QgY2hhcmFjdGVyIG11c3QgYmUgYSBsZXR0ZXIuXCIpO2lmKGFbZC5pZF0pdGhyb3cgbmV3IEVycm9yKFwiQ2FsbG91dCBieSB0aGF0IGlkIGFscmVhZHkgZXhpc3RzLiBQbGVhc2UgY2hvb3NlIGEgdW5pcXVlIGlkLlwiKTtpZighaC5nZXRTdGVwVGFyZ2V0KGQpKXRocm93IG5ldyBFcnJvcihcIk11c3Qgc3BlY2lmeSBleGlzdGluZyB0YXJnZXQgZWxlbWVudCB2aWEgJ3RhcmdldCcgb3B0aW9uLlwiKTtyZXR1cm4gZC5zaG93TmV4dEJ1dHRvbj1kLnNob3dQcmV2QnV0dG9uPSExLGQuaXNUb3VyQnViYmxlPSExLGU9bmV3IGIoZCksYVtkLmlkXT1lLGNbZC5pZF09ZCxlLnJlbmRlcihkLG51bGwsZnVuY3Rpb24oKXtlLnNob3coKSxkLm9uU2hvdyYmaC5pbnZva2VDYWxsYmFjayhkLm9uU2hvdyl9KSxlfSx0aGlzLmdldENhbGxvdXQ9ZnVuY3Rpb24oYil7cmV0dXJuIGFbYl19LHRoaXMucmVtb3ZlQWxsQ2FsbG91dHM9ZnVuY3Rpb24oKXt2YXIgYjtmb3IoYiBpbiBhKWEuaGFzT3duUHJvcGVydHkoYikmJnRoaXMucmVtb3ZlQ2FsbG91dChiKX0sdGhpcy5yZW1vdmVDYWxsb3V0PWZ1bmN0aW9uKGIpe3ZhciBkPWFbYl07YVtiXT1udWxsLGNbYl09bnVsbCxkJiZkLmRlc3Ryb3koKX0sdGhpcy5yZWZyZXNoQ2FsbG91dFBvc2l0aW9ucz1mdW5jdGlvbigpe3ZhciBiLGQsZTtmb3IoYiBpbiBhKWEuaGFzT3duUHJvcGVydHkoYikmJmMuaGFzT3duUHJvcGVydHkoYikmJihkPWFbYl0sZT1jW2JdLGQmJmUmJmQuc2V0UG9zaXRpb24oZSkpfX0sYT1mdW5jdGlvbihhKXt2YXIgZCxrLHAsdCx1LHcseCx5LHo9dGhpcyxBPXt9LEI9W10sQz1mdW5jdGlvbihhKXtyZXR1cm4gZCYmZC5lbGVtZW50JiZkLmVsZW1lbnQucGFyZW50Tm9kZXx8KGQ9bmV3IGIocCkpLGEmJmguZXh0ZW5kKGQub3B0LHtidWJibGVQYWRkaW5nOkUoXCJidWJibGVQYWRkaW5nXCIpLGJ1YmJsZVdpZHRoOkUoXCJidWJibGVXaWR0aFwiKSxzaG93TmV4dEJ1dHRvbjpFKFwic2hvd05leHRCdXR0b25cIiksc2hvd1ByZXZCdXR0b246RShcInNob3dQcmV2QnV0dG9uXCIpLHNob3dDbG9zZUJ1dHRvbjpFKFwic2hvd0Nsb3NlQnV0dG9uXCIpLGFycm93V2lkdGg6RShcImFycm93V2lkdGhcIiksaXNSdGw6RShcImlzUnRsXCIpfSksZH0sRD1mdW5jdGlvbigpe2QmJihkLmRlc3Ryb3koKSxkPW51bGwpfSxFPWZ1bmN0aW9uKGEpe3JldHVyblwidW5kZWZpbmVkXCI9PXR5cGVvZiBwP2xbYV06aC52YWxPckRlZmF1bHQocFthXSxsW2FdKX0sRj1mdW5jdGlvbigpe3ZhciBhO3JldHVybiBhPSF0fHwwPnV8fHU+PXQuc3RlcHMubGVuZ3RoP251bGw6dC5zdGVwc1t1XX0sRz1mdW5jdGlvbigpe3oubmV4dFN0ZXAoKX0sSD1mdW5jdGlvbihhKXt2YXIgYixjLGQsZSxmLGcsaT1DKCksaj1pLmVsZW1lbnQsaz1oLmdldFBpeGVsVmFsdWUoai5zdHlsZS50b3ApLGw9aytoLmdldFBpeGVsVmFsdWUoai5vZmZzZXRIZWlnaHQpLG09aC5nZXRTdGVwVGFyZ2V0KEYoKSksbz1tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLHA9by50b3AraC5nZXRTY3JvbGxUb3AoKSxyPW8uYm90dG9tK2guZ2V0U2Nyb2xsVG9wKCksdD1wPms/azpwLHU9bD5yP2w6cix2PWguZ2V0U2Nyb2xsVG9wKCksdz12K2guZ2V0V2luZG93SGVpZ2h0KCkseD10LUUoXCJzY3JvbGxUb3BNYXJnaW5cIik7dD49diYmKHQ8PXYrRShcInNjcm9sbFRvcE1hcmdpblwiKXx8dz49dSk/YSYmYSgpOkUoXCJzbW9vdGhTY3JvbGxcIik/KFwidW5kZWZpbmVkXCI9PXR5cGVvZiBZQUhPTz9cInVuZGVmaW5lZFwiOm4oWUFIT08pKSE9PXEmJm4oWUFIT08uZW52KSE9PXEmJm4oWUFIT08uZW52LnVhKSE9PXEmJm4oWUFIT08udXRpbCkhPT1xJiZuKFlBSE9PLnV0aWwuU2Nyb2xsKSE9PXE/KGI9WUFIT08uZW52LnVhLndlYmtpdD9kb2N1bWVudC5ib2R5OmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxkPVlBSE9PLnV0aWwuRWFzaW5nP1lBSE9PLnV0aWwuRWFzaW5nLmVhc2VPdXQ6dm9pZCAwLGM9bmV3IFlBSE9PLnV0aWwuU2Nyb2xsKGIse3Njcm9sbDp7dG86WzAseF19fSxFKFwic2Nyb2xsRHVyYXRpb25cIikvMWUzLGQpLGMub25Db21wbGV0ZS5zdWJzY3JpYmUoYSksYy5hbmltYXRlKCkpOnM/alF1ZXJ5KFwiYm9keSwgaHRtbFwiKS5hbmltYXRlKHtzY3JvbGxUb3A6eH0sRShcInNjcm9sbER1cmF0aW9uXCIpLGEpOigwPngmJih4PTApLGU9dj50Py0xOjEsZj1NYXRoLmFicyh2LXgpLyhFKFwic2Nyb2xsRHVyYXRpb25cIikvMTApLChnPWZ1bmN0aW9uKCl7dmFyIGI9aC5nZXRTY3JvbGxUb3AoKSxjPWIrZSpmO3JldHVybiBlPjAmJmM+PXh8fDA+ZSYmeD49Yz8oYz14LGEmJmEoKSx2b2lkIHdpbmRvdy5zY3JvbGxUbygwLGMpKTood2luZG93LnNjcm9sbFRvKDAsYyksaC5nZXRTY3JvbGxUb3AoKT09PWI/dm9pZChhJiZhKCkpOnZvaWQgc2V0VGltZW91dChnLDEwKSl9KSgpKTood2luZG93LnNjcm9sbFRvKDAseCksYSYmYSgpKX0sST1mdW5jdGlvbiBQKGEsYil7dmFyIGMsZCxlO3UrYT49MCYmdSthPHQuc3RlcHMubGVuZ3RoPyh1Kz1hLGQ9RigpLGU9ZnVuY3Rpb24oKXtjPWguZ2V0U3RlcFRhcmdldChkKSxjPyhBW3VdJiZkZWxldGUgQVt1XSxiKHUpKTooQVt1XT0hMCxoLmludm9rZUV2ZW50Q2FsbGJhY2tzKFwiZXJyb3JcIiksUChhLGIpKX0sZC5kZWxheT9zZXRUaW1lb3V0KGUsZC5kZWxheSk6ZSgpKTpiKC0xKX0sSj1mdW5jdGlvbihhLGIpe3ZhciBjLGQsZSxmLGc9QygpLGk9dGhpcztpZihnLmhpZGUoKSxhPWgudmFsT3JEZWZhdWx0KGEsITApLGM9RigpLGMubmV4dE9uVGFyZ2V0Q2xpY2smJmgucmVtb3ZlRXZ0TGlzdGVuZXIoaC5nZXRTdGVwVGFyZ2V0KGMpLFwiY2xpY2tcIixHKSxkPWMsZT1iPjA/ZC5tdWx0aXBhZ2U6dT4wJiZ0LnN0ZXBzW3UtMV0ubXVsdGlwYWdlLGY9ZnVuY3Rpb24oYyl7dmFyIGY7aWYoLTE9PT1jKXJldHVybiB0aGlzLmVuZFRvdXIoITApO2lmKGEmJihmPWI+MD9oLmludm9rZUV2ZW50Q2FsbGJhY2tzKFwibmV4dFwiLGQub25OZXh0KTpoLmludm9rZUV2ZW50Q2FsbGJhY2tzKFwicHJldlwiLGQub25QcmV2KSksYz09PXUpe2lmKGUpcmV0dXJuIHZvaWQgTigpO2Y9aC52YWxPckRlZmF1bHQoZiwhMCksZj90aGlzLnNob3dTdGVwKGMpOnRoaXMuZW5kVG91cighMSl9fSwhZSYmRShcInNraXBJZk5vRWxlbWVudFwiKSlJKGIsZnVuY3Rpb24oYSl7Zi5jYWxsKGksYSl9KTtlbHNlIGlmKHUrYj49MCYmdStiPHQuc3RlcHMubGVuZ3RoKXtpZih1Kz1iLGM9RigpLCFoLmdldFN0ZXBUYXJnZXQoYykmJiFlKXJldHVybiBoLmludm9rZUV2ZW50Q2FsbGJhY2tzKFwiZXJyb3JcIiksdGhpcy5lbmRUb3VyKCEwLCExKTtmLmNhbGwodGhpcyx1KX1lbHNlIGlmKHUrYj09PXQuc3RlcHMubGVuZ3RoKXJldHVybiB0aGlzLmVuZFRvdXIoKTtyZXR1cm4gdGhpc30sSz1mdW5jdGlvbihhKXt2YXIgYixjLGQsZT17fTtmb3IoYiBpbiBhKWEuaGFzT3duUHJvcGVydHkoYikmJlwiaWRcIiE9PWImJlwic3RlcHNcIiE9PWImJihlW2JdPWFbYl0pO3JldHVybiB5LmNhbGwodGhpcyxlLCEwKSxjPWguZ2V0U3RhdGUoRShcImNvb2tpZU5hbWVcIikpLGMmJihkPWMuc3BsaXQoXCI6XCIpLHc9ZFswXSx4PWRbMV0sZC5sZW5ndGg+MiYmKEI9ZFsyXS5zcGxpdChcIixcIikpLHg9cGFyc2VJbnQoeCwxMCkpLHRoaXN9LEw9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkLGU7aWYodT1hfHwwLEE9Ynx8e30sZD1GKCksZT1oLmdldFN0ZXBUYXJnZXQoZCkpcmV0dXJuIHZvaWQgYyh1KTtpZighZSl7aWYoaC5pbnZva2VFdmVudENhbGxiYWNrcyhcImVycm9yXCIpLEFbdV09ITAsRShcInNraXBJZk5vRWxlbWVudFwiKSlyZXR1cm4gdm9pZCBJKDEsYyk7dT0tMSxjKHUpfX0sTT1mdW5jdGlvbihhKXtmdW5jdGlvbiBiKCl7ZC5zaG93KCksaC5pbnZva2VFdmVudENhbGxiYWNrcyhcInNob3dcIixjLm9uU2hvdyl9dmFyIGM9dC5zdGVwc1thXSxkPUMoKSxlPWguZ2V0U3RlcFRhcmdldChjKTt1IT09YSYmRigpLm5leHRPblRhcmdldENsaWNrJiZoLnJlbW92ZUV2dExpc3RlbmVyKGguZ2V0U3RlcFRhcmdldChGKCkpLFwiY2xpY2tcIixHKSx1PWEsZC5oaWRlKCExKSxkLnJlbmRlcihjLGEsZnVuY3Rpb24oYSl7YT9IKGIpOmIoKSxjLm5leHRPblRhcmdldENsaWNrJiZoLmFkZEV2dExpc3RlbmVyKGUsXCJjbGlja1wiLEcpfSksTigpfSxOPWZ1bmN0aW9uKCl7dmFyIGE9dC5pZCtcIjpcIit1LGI9bS5nZXRTa2lwcGVkU3RlcHNJbmRleGVzKCk7YiYmYi5sZW5ndGg+MCYmKGErPVwiOlwiK2Iuam9pbihcIixcIikpLGguc2V0U3RhdGUoRShcImNvb2tpZU5hbWVcIiksYSwxKX0sTz1mdW5jdGlvbihhKXthJiZ0aGlzLmNvbmZpZ3VyZShhKX07dGhpcy5nZXRDYWxsb3V0TWFuYWdlcj1mdW5jdGlvbigpe3JldHVybihcInVuZGVmaW5lZFwiPT10eXBlb2Ygaz9cInVuZGVmaW5lZFwiOm4oaykpPT09cSYmKGs9bmV3IGMpLGt9LHRoaXMuc3RhcnRUb3VyPWZ1bmN0aW9uKGEsYil7dmFyIGMsZCxlPXt9LGY9dGhpcztpZighdCl7aWYoIWEpdGhyb3cgbmV3IEVycm9yKFwiVG91ciBkYXRhIGlzIHJlcXVpcmVkIGZvciBzdGFydFRvdXIuXCIpO2lmKCFhLmlkfHwhdi50ZXN0KGEuaWQpKXRocm93IG5ldyBFcnJvcihcIlRvdXIgSUQgaXMgdXNpbmcgYW4gaW52YWxpZCBmb3JtYXQuIFVzZSBhbHBoYW51bWVyaWMsIHVuZGVyc2NvcmVzLCBhbmQvb3IgaHlwaGVucyBvbmx5LiBGaXJzdCBjaGFyYWN0ZXIgbXVzdCBiZSBhIGxldHRlci5cIik7dD1hLEsuY2FsbCh0aGlzLGEpfWlmKChcInVuZGVmaW5lZFwiPT10eXBlb2YgYj9cInVuZGVmaW5lZFwiOm4oYikpIT09cSl7aWYoYj49dC5zdGVwcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiU3BlY2lmaWVkIHN0ZXAgbnVtYmVyIG91dCBvZiBib3VuZHMuXCIpO2Q9Yn1pZighaC5kb2N1bWVudElzUmVhZHkoKSlyZXR1cm4gcj0hMCx0aGlzO2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBkJiZ0LmlkPT09dyYmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiB4P1widW5kZWZpbmVkXCI6bih4KSkhPT1xKXtpZihkPXgsQi5sZW5ndGg+MClmb3IodmFyIGc9MCxpPUIubGVuZ3RoO2k+ZztnKyspZVtCW2ddXT0hMH1lbHNlIGR8fChkPTApO3JldHVybiBMKGQsZSxmdW5jdGlvbihhKXt2YXIgYj0tMSE9PWEmJmguZ2V0U3RlcFRhcmdldCh0LnN0ZXBzW2FdKTtyZXR1cm4gYj8oaC5pbnZva2VFdmVudENhbGxiYWNrcyhcInN0YXJ0XCIpLGM9QygpLGMuaGlkZSghMSksZi5pc0FjdGl2ZT0hMCx2b2lkKGguZ2V0U3RlcFRhcmdldChGKCkpP2Yuc2hvd1N0ZXAoYSk6KGguaW52b2tlRXZlbnRDYWxsYmFja3MoXCJlcnJvclwiKSxFKFwic2tpcElmTm9FbGVtZW50XCIpJiZmLm5leHRTdGVwKCExKSkpKTp2b2lkIGYuZW5kVG91cighMSwhMSl9KSx0aGlzfSx0aGlzLnNob3dTdGVwPWZ1bmN0aW9uKGEpe3ZhciBiPXQuc3RlcHNbYV0sYz11O3JldHVybiBoLmdldFN0ZXBUYXJnZXQoYik/KGIuZGVsYXk/c2V0VGltZW91dChmdW5jdGlvbigpe00oYSl9LGIuZGVsYXkpOk0oYSksdGhpcyk6KHU9YSxoLmludm9rZUV2ZW50Q2FsbGJhY2tzKFwiZXJyb3JcIiksdm9pZCh1PWMpKX0sdGhpcy5wcmV2U3RlcD1mdW5jdGlvbihhKXtyZXR1cm4gSi5jYWxsKHRoaXMsYSwtMSksdGhpc30sdGhpcy5uZXh0U3RlcD1mdW5jdGlvbihhKXtyZXR1cm4gSi5jYWxsKHRoaXMsYSwxKSx0aGlzfSx0aGlzLmVuZFRvdXI9ZnVuY3Rpb24oYSxiKXt2YXIgYyxkPUMoKTtyZXR1cm4gYT1oLnZhbE9yRGVmYXVsdChhLCEwKSxiPWgudmFsT3JEZWZhdWx0KGIsITApLHQmJihjPUYoKSxjJiZjLm5leHRPblRhcmdldENsaWNrJiZoLnJlbW92ZUV2dExpc3RlbmVyKGguZ2V0U3RlcFRhcmdldChjKSxcImNsaWNrXCIsRykpLHU9MCx4PXZvaWQgMCxkLmhpZGUoKSxhJiZoLmNsZWFyU3RhdGUoRShcImNvb2tpZU5hbWVcIikpLHRoaXMuaXNBY3RpdmUmJih0aGlzLmlzQWN0aXZlPSExLHQmJmImJmguaW52b2tlRXZlbnRDYWxsYmFja3MoXCJlbmRcIikpLHRoaXMucmVtb3ZlQ2FsbGJhY2tzKG51bGwsITApLHRoaXMucmVzZXREZWZhdWx0T3B0aW9ucygpLEQoKSx0PW51bGwsdGhpc30sdGhpcy5nZXRDdXJyVG91cj1mdW5jdGlvbigpe3JldHVybiB0fSx0aGlzLmdldEN1cnJUYXJnZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gaC5nZXRTdGVwVGFyZ2V0KEYoKSl9LHRoaXMuZ2V0Q3VyclN0ZXBOdW09ZnVuY3Rpb24oKXtyZXR1cm4gdX0sdGhpcy5nZXRTa2lwcGVkU3RlcHNJbmRleGVzPWZ1bmN0aW9uKCl7dmFyIGEsYj1bXTtmb3IoYSBpbiBBKWIucHVzaChhKTtyZXR1cm4gYn0sdGhpcy5yZWZyZXNoQnViYmxlUG9zaXRpb249ZnVuY3Rpb24oKXt2YXIgYT1GKCk7cmV0dXJuIGEmJkMoKS5zZXRQb3NpdGlvbihhKSx0aGlzLmdldENhbGxvdXRNYW5hZ2VyKCkucmVmcmVzaENhbGxvdXRQb3NpdGlvbnMoKSx0aGlzfSx0aGlzLmxpc3Rlbj1mdW5jdGlvbihhLGIsYyl7cmV0dXJuIGEmJmlbYV0ucHVzaCh7Y2I6Yixmcm9tVG91cjpjfSksdGhpc30sdGhpcy51bmxpc3Rlbj1mdW5jdGlvbihhLGIpe3ZhciBjLGQsZT1pW2FdO2ZvcihjPTAsZD1lLmxlbmd0aDtkPmM7KytjKWVbY10uY2I9PT1iJiZlLnNwbGljZShjLDEpO3JldHVybiB0aGlzfSx0aGlzLnJlbW92ZUNhbGxiYWNrcz1mdW5jdGlvbihhLGIpe3ZhciBjLGQsZSxmO2ZvcihmIGluIGkpaWYoIWF8fGE9PT1mKWlmKGIpZm9yKGM9aVtmXSxkPTAsZT1jLmxlbmd0aDtlPmQ7KytkKWNbZF0uZnJvbVRvdXImJihjLnNwbGljZShkLS0sMSksLS1lKTtlbHNlIGlbZl09W107cmV0dXJuIHRoaXN9LHRoaXMucmVnaXN0ZXJIZWxwZXI9ZnVuY3Rpb24oYSxiKXtcInN0cmluZ1wiPT10eXBlb2YgYSYmXCJmdW5jdGlvblwiPT10eXBlb2YgYiYmKGpbYV09Yil9LHRoaXMudW5yZWdpc3RlckhlbHBlcj1mdW5jdGlvbihhKXtqW2FdPW51bGx9LHRoaXMuaW52b2tlSGVscGVyPWZ1bmN0aW9uKGEpe3ZhciBiLGMsZD1bXTtmb3IoYj0xLGM9YXJndW1lbnRzLmxlbmd0aDtjPmI7KytiKWQucHVzaChhcmd1bWVudHNbYl0pO2pbYV0mJmpbYV0uY2FsbChudWxsLGQpfSx0aGlzLnNldENvb2tpZU5hbWU9ZnVuY3Rpb24oYSl7cmV0dXJuIHAuY29va2llTmFtZT1hLHRoaXN9LHRoaXMucmVzZXREZWZhdWx0T3B0aW9ucz1mdW5jdGlvbigpe3JldHVybiBwPXt9LHRoaXN9LHRoaXMucmVzZXREZWZhdWx0STE4Tj1mdW5jdGlvbigpe3JldHVybiBlPXt9LHRoaXN9LHRoaXMuZ2V0U3RhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gaC5nZXRTdGF0ZShFKFwiY29va2llTmFtZVwiKSl9LHk9ZnVuY3Rpb24oYSxiKXt2YXIgYyxkLGYsZyxpPVtcIm5leHRcIixcInByZXZcIixcInN0YXJ0XCIsXCJlbmRcIixcInNob3dcIixcImVycm9yXCIsXCJjbG9zZVwiXTtmb3IocHx8dGhpcy5yZXNldERlZmF1bHRPcHRpb25zKCksaC5leHRlbmQocCxhKSxhJiZoLmV4dGVuZChlLGEuaTE4biksZj0wLGc9aS5sZW5ndGg7Zz5mOysrZilkPVwib25cIitpW2ZdLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK2lbZl0uc3Vic3RyaW5nKDEpLGFbZF0mJnRoaXMubGlzdGVuKGlbZl0sYVtkXSxiKTtyZXR1cm4gYz1DKCEwKSx0aGlzfSx0aGlzLmNvbmZpZ3VyZT1mdW5jdGlvbihhKXtyZXR1cm4geS5jYWxsKHRoaXMsYSwhMSl9LHRoaXMuc2V0UmVuZGVyZXI9ZnVuY3Rpb24oYSl7dmFyIGI9XCJ1bmRlZmluZWRcIj09dHlwZW9mIGE/XCJ1bmRlZmluZWRcIjpuKGEpO3JldHVyblwic3RyaW5nXCI9PT1iPyhvPWEsZj12b2lkIDApOlwiZnVuY3Rpb25cIj09PWImJihmPWEpLHRoaXN9LHRoaXMuc2V0RXNjYXBlcj1mdW5jdGlvbihhKXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBhJiYoZz1hKSx0aGlzfSxPLmNhbGwodGhpcyxhKX0sbT1uZXcgYSxmdW5jdGlvbigpe3ZhciBhPXt9O2EuZXNjYXBlPWZ1bmN0aW9uKGEpe3JldHVybiBnP2coYSk6bnVsbD09YT9cIlwiOihcIlwiK2EpLnJlcGxhY2UobmV3IFJlZ0V4cChcIlsmPD5cXFwiJ11cIixcImdcIiksZnVuY3Rpb24oYSl7cmV0dXJuXCImXCI9PWE/XCImYW1wO1wiOlwiPFwiPT1hP1wiJmx0O1wiOlwiPlwiPT1hP1wiJmd0O1wiOidcIic9PWE/XCImcXVvdDtcIjpcIidcIj09YT9cIiYjeDI3O1wiOnZvaWQgMH0pfSx0aGlzLnRlbXBsYXRlcz10aGlzLnRlbXBsYXRlc3x8e30sdGhpcy50ZW1wbGF0ZXMuYnViYmxlX2RlZmF1bHQ9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhiLGMpe3JldHVybiBjP2EuZXNjYXBlKGIpOmJ9dmFyIGQsZT1cIlwiO2EuZXNjYXBlLEFycmF5LnByb3RvdHlwZS5qb2luO2UrPVwiXFxuXCI7dmFyIGY9Yi5pMThuLGc9Yi5idXR0b25zLGg9Yi5zdGVwLGk9Yi50b3VyO3JldHVybiBlKz0nXFxuPGRpdiBjbGFzcz1cImhvcHNjb3RjaC1idWJibGUtY29udGFpbmVyXCIgc3R5bGU9XCJ3aWR0aDogJysobnVsbD09KGQ9aC53aWR0aCk/XCJcIjpkKStcInB4OyBwYWRkaW5nOiBcIisobnVsbD09KGQ9aC5wYWRkaW5nKT9cIlwiOmQpKydweDtcIj5cXG4gICcsaS5pc1RvdXImJihlKz0nPHNwYW4gY2xhc3M9XCJob3BzY290Y2gtYnViYmxlLW51bWJlclwiPicrKG51bGw9PShkPWYuc3RlcE51bSk/XCJcIjpkKStcIjwvc3Bhbj5cIiksZSs9J1xcbiAgPGRpdiBjbGFzcz1cImhvcHNjb3RjaC1idWJibGUtY29udGVudFwiPlxcbiAgICAnLFwiXCIhPT1oLnRpdGxlJiYoZSs9JzxoMyBjbGFzcz1cImhvcHNjb3RjaC10aXRsZVwiPicrKG51bGw9PShkPWMoaC50aXRsZSxpLnVuc2FmZSkpP1wiXCI6ZCkrXCI8L2gzPlwiKSxlKz1cIlxcbiAgICBcIixcIlwiIT09aC5jb250ZW50JiYoZSs9JzxkaXYgY2xhc3M9XCJob3BzY290Y2gtY29udGVudFwiPicrKG51bGw9PShkPWMoaC5jb250ZW50LGkudW5zYWZlKSk/XCJcIjpkKStcIjwvZGl2PlwiKSxlKz0nXFxuICA8L2Rpdj5cXG4gIDxkaXYgY2xhc3M9XCJob3BzY290Y2gtYWN0aW9uc1wiPlxcbiAgICAnLGcuc2hvd1ByZXYmJihlKz0nPGJ1dHRvbiBjbGFzcz1cImhvcHNjb3RjaC1uYXYtYnV0dG9uIHByZXYgaG9wc2NvdGNoLXByZXZcIj4nKyhudWxsPT0oZD1mLnByZXZCdG4pP1wiXCI6ZCkrXCI8L2J1dHRvbj5cIiksZSs9XCJcXG4gICAgXCIsZy5zaG93Q1RBJiYoZSs9JzxidXR0b24gY2xhc3M9XCJob3BzY290Y2gtbmF2LWJ1dHRvbiBuZXh0IGhvcHNjb3RjaC1jdGFcIj4nKyhudWxsPT0oZD1nLmN0YUxhYmVsKT9cIlwiOmQpK1wiPC9idXR0b24+XCIpLGUrPVwiXFxuICAgIFwiLGcuc2hvd05leHQmJihlKz0nPGJ1dHRvbiBjbGFzcz1cImhvcHNjb3RjaC1uYXYtYnV0dG9uIG5leHQgaG9wc2NvdGNoLW5leHRcIj4nKyhudWxsPT0oZD1mLm5leHRCdG4pP1wiXCI6ZCkrXCI8L2J1dHRvbj5cIiksZSs9XCJcXG4gIDwvZGl2PlxcbiAgXCIsZy5zaG93Q2xvc2UmJihlKz0nPGJ1dHRvbiBjbGFzcz1cImhvcHNjb3RjaC1idWJibGUtY2xvc2UgaG9wc2NvdGNoLWNsb3NlXCI+JysobnVsbD09KGQ9Zi5jbG9zZVRvb2x0aXApP1wiXCI6ZCkrXCI8L2J1dHRvbj5cIiksZSs9J1xcbjwvZGl2PlxcbjxkaXYgY2xhc3M9XCJob3BzY290Y2gtYnViYmxlLWFycm93LWNvbnRhaW5lciBob3BzY290Y2gtYXJyb3dcIj5cXG4gIDxkaXYgY2xhc3M9XCJob3BzY290Y2gtYnViYmxlLWFycm93LWJvcmRlclwiPjwvZGl2PlxcbiAgPGRpdiBjbGFzcz1cImhvcHNjb3RjaC1idWJibGUtYXJyb3dcIj48L2Rpdj5cXG48L2Rpdj5cXG4nfX0uY2FsbChtKTt2YXIgeT1tO3JldHVybiB5fSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2hvcHNjb3RjaC9kaXN0L2pzL2hvcHNjb3RjaC5taW4uanNcbi8vIG1vZHVsZSBpZCA9IDE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///15\n')},function(module,exports){eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2Nlc3MvYnJvd3Nlci5qcz84MmU0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVUiLCJmaWxlIjoiMTYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Byb2Nlc3MvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///16\n")},function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    "use strict";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== "function") {\n        callback = new Function("" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."\n        // So if we\'re currently running a task, we\'ll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // "too much recursion" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can\'t be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage("", "*");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = "setImmediate$" + Math.random() + "$";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === "string" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener("message", onGlobalMessage, false);\n        } else {\n            global.attachEvent("onmessage", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, "*");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it\'s been called.\n            var script = doc.createElement("script");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don\'t get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === "[object process]") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && "onreadystatechange" in doc.createElement("script")) {\n        // For IE 68\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4), __webpack_require__(16)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanM/NGE4MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMsc0JBQXNCLEVBQUU7QUFDbEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiMTcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgdW5kZWZpbmVkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZiAoZ2xvYmFsLnNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5leHRIYW5kbGUgPSAxOyAvLyBTcGVjIHNheXMgZ3JlYXRlciB0aGFuIHplcm9cbiAgICB2YXIgdGFza3NCeUhhbmRsZSA9IHt9O1xuICAgIHZhciBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICB2YXIgZG9jID0gZ2xvYmFsLmRvY3VtZW50O1xuICAgIHZhciByZWdpc3RlckltbWVkaWF0ZTtcblxuICAgIGZ1bmN0aW9uIHNldEltbWVkaWF0ZShjYWxsYmFjaykge1xuICAgICAgLy8gQ2FsbGJhY2sgY2FuIGVpdGhlciBiZSBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBuZXcgRnVuY3Rpb24oXCJcIiArIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIC8vIENvcHkgZnVuY3Rpb24gYXJndW1lbnRzXG4gICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2kgKyAxXTtcbiAgICAgIH1cbiAgICAgIC8vIFN0b3JlIGFuZCByZWdpc3RlciB0aGUgdGFza1xuICAgICAgdmFyIHRhc2sgPSB7IGNhbGxiYWNrOiBjYWxsYmFjaywgYXJnczogYXJncyB9O1xuICAgICAgdGFza3NCeUhhbmRsZVtuZXh0SGFuZGxlXSA9IHRhc2s7XG4gICAgICByZWdpc3RlckltbWVkaWF0ZShuZXh0SGFuZGxlKTtcbiAgICAgIHJldHVybiBuZXh0SGFuZGxlKys7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaGFuZGxlKSB7XG4gICAgICAgIGRlbGV0ZSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuKHRhc2spIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gdGFzay5jYWxsYmFjaztcbiAgICAgICAgdmFyIGFyZ3MgPSB0YXNrLmFyZ3M7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuSWZQcmVzZW50KGhhbmRsZSkge1xuICAgICAgICAvLyBGcm9tIHRoZSBzcGVjOiBcIldhaXQgdW50aWwgYW55IGludm9jYXRpb25zIG9mIHRoaXMgYWxnb3JpdGhtIHN0YXJ0ZWQgYmVmb3JlIHRoaXMgb25lIGhhdmUgY29tcGxldGVkLlwiXG4gICAgICAgIC8vIFNvIGlmIHdlJ3JlIGN1cnJlbnRseSBydW5uaW5nIGEgdGFzaywgd2UnbGwgbmVlZCB0byBkZWxheSB0aGlzIGludm9jYXRpb24uXG4gICAgICAgIGlmIChjdXJyZW50bHlSdW5uaW5nQVRhc2spIHtcbiAgICAgICAgICAgIC8vIERlbGF5IGJ5IGRvaW5nIGEgc2V0VGltZW91dC4gc2V0SW1tZWRpYXRlIHdhcyB0cmllZCBpbnN0ZWFkLCBidXQgaW4gRmlyZWZveCA3IGl0IGdlbmVyYXRlZCBhXG4gICAgICAgICAgICAvLyBcInRvbyBtdWNoIHJlY3Vyc2lvblwiIGVycm9yLlxuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGFzayA9IHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICAgICAgICAgIGlmICh0YXNrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBydW4odGFzayk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbW1lZGlhdGUoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHsgcnVuSWZQcmVzZW50KGhhbmRsZSk7IH0pO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhblVzZVBvc3RNZXNzYWdlKCkge1xuICAgICAgICAvLyBUaGUgdGVzdCBhZ2FpbnN0IGBpbXBvcnRTY3JpcHRzYCBwcmV2ZW50cyB0aGlzIGltcGxlbWVudGF0aW9uIGZyb20gYmVpbmcgaW5zdGFsbGVkIGluc2lkZSBhIHdlYiB3b3JrZXIsXG4gICAgICAgIC8vIHdoZXJlIGBnbG9iYWwucG9zdE1lc3NhZ2VgIG1lYW5zIHNvbWV0aGluZyBjb21wbGV0ZWx5IGRpZmZlcmVudCBhbmQgY2FuJ3QgYmUgdXNlZCBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgICBpZiAoZ2xvYmFsLnBvc3RNZXNzYWdlICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cykge1xuICAgICAgICAgICAgdmFyIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG9sZE9uTWVzc2FnZSA9IGdsb2JhbC5vbm1lc3NhZ2U7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShcIlwiLCBcIipcIik7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gb2xkT25NZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgLy8gSW5zdGFsbHMgYW4gZXZlbnQgaGFuZGxlciBvbiBgZ2xvYmFsYCBmb3IgdGhlIGBtZXNzYWdlYCBldmVudDogc2VlXG4gICAgICAgIC8vICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vRE9NL3dpbmRvdy5wb3N0TWVzc2FnZVxuICAgICAgICAvLyAqIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL2NvbW1zLmh0bWwjY3Jvc3NEb2N1bWVudE1lc3NhZ2VzXG5cbiAgICAgICAgdmFyIG1lc3NhZ2VQcmVmaXggPSBcInNldEltbWVkaWF0ZSRcIiArIE1hdGgucmFuZG9tKCkgKyBcIiRcIjtcbiAgICAgICAgdmFyIG9uR2xvYmFsTWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlID09PSBnbG9iYWwgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZXZlbnQuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEuaW5kZXhPZihtZXNzYWdlUHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudCgrZXZlbnQuZGF0YS5zbGljZShtZXNzYWdlUHJlZml4Lmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFsLmF0dGFjaEV2ZW50KFwib25tZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKG1lc3NhZ2VQcmVmaXggKyBoYW5kbGUsIFwiKlwiKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZShoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBodG1sID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIDxzY3JpcHQ+IGVsZW1lbnQ7IGl0cyByZWFkeXN0YXRlY2hhbmdlIGV2ZW50IHdpbGwgYmUgZmlyZWQgYXN5bmNocm9ub3VzbHkgb25jZSBpdCBpcyBpbnNlcnRlZFxuICAgICAgICAgICAgLy8gaW50byB0aGUgZG9jdW1lbnQuIERvIHNvLCB0aHVzIHF1ZXVpbmcgdXAgdGhlIHRhc2suIFJlbWVtYmVyIHRvIGNsZWFuIHVwIG9uY2UgaXQncyBiZWVuIGNhbGxlZC5cbiAgICAgICAgICAgIHZhciBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaHRtbC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgICAgIHNjcmlwdCA9IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaHRtbC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBJZiBzdXBwb3J0ZWQsIHdlIHNob3VsZCBhdHRhY2ggdG8gdGhlIHByb3RvdHlwZSBvZiBnbG9iYWwsIHNpbmNlIHRoYXQgaXMgd2hlcmUgc2V0VGltZW91dCBldCBhbC4gbGl2ZS5cbiAgICB2YXIgYXR0YWNoVG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGdsb2JhbCk7XG4gICAgYXR0YWNoVG8gPSBhdHRhY2hUbyAmJiBhdHRhY2hUby5zZXRUaW1lb3V0ID8gYXR0YWNoVG8gOiBnbG9iYWw7XG5cbiAgICAvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IGUuZy4gYnJvd3NlcmlmeSBlbnZpcm9ubWVudHMuXG4gICAgaWYgKHt9LnRvU3RyaW5nLmNhbGwoZ2xvYmFsLnByb2Nlc3MpID09PSBcIltvYmplY3QgcHJvY2Vzc11cIikge1xuICAgICAgICAvLyBGb3IgTm9kZS5qcyBiZWZvcmUgMC45XG4gICAgICAgIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGNhblVzZVBvc3RNZXNzYWdlKCkpIHtcbiAgICAgICAgLy8gRm9yIG5vbi1JRTEwIG1vZGVybiBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChnbG9iYWwuTWVzc2FnZUNoYW5uZWwpIHtcbiAgICAgICAgLy8gRm9yIHdlYiB3b3JrZXJzLCB3aGVyZSBzdXBwb3J0ZWRcbiAgICAgICAgaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZG9jICYmIFwib25yZWFkeXN0YXRlY2hhbmdlXCIgaW4gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIikpIHtcbiAgICAgICAgLy8gRm9yIElFIDbigJM4XG4gICAgICAgIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBvbGRlciBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCk7XG4gICAgfVxuXG4gICAgYXR0YWNoVG8uc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlO1xuICAgIGF0dGFjaFRvLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG59KHR5cGVvZiBzZWxmID09PSBcInVuZGVmaW5lZFwiID8gdHlwZW9mIGdsb2JhbCA9PT0gXCJ1bmRlZmluZWRcIiA/IHRoaXMgOiBnbG9iYWwgOiBzZWxmKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///17\n')},function(module,exports,__webpack_require__){eval("var apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(17);\nexports.setImmediate = setImmediate;\nexports.clearImmediate = clearImmediate;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3RpbWVycy1icm93c2VyaWZ5L21haW4uanM/YjA4OCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjE4LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkge1xuICBpZiAodGltZW91dCkge1xuICAgIHRpbWVvdXQuY2xvc2UoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbCh3aW5kb3csIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBzZXRpbW1lZGlhdGUgYXR0YWNoZXMgaXRzZWxmIHRvIHRoZSBnbG9iYWwgb2JqZWN0XG5yZXF1aXJlKFwic2V0aW1tZWRpYXRlXCIpO1xuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qc1xuLy8gbW9kdWxlIGlkID0gMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///18\n")}]);