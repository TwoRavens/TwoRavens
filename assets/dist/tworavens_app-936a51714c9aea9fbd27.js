!function(Q){function I(B){if(F[B])return F[B].exports;var C=F[B]={i:B,l:!1,exports:{}};return Q[B].call(C.exports,C,C.exports,I),C.l=!0,C.exports}var F={};I.m=Q,I.c=F,I.i=function(Q){return Q},I.d=function(Q,F,B){I.o(Q,F)||Object.defineProperty(Q,F,{configurable:!1,enumerable:!0,get:B})},I.n=function(Q){var F=Q&&Q.__esModule?function(){return Q.default}:function(){return Q};return I.d(F,"a",F),F},I.o=function(Q,I){return Object.prototype.hasOwnProperty.call(Q,I)},I.p="",I(I.s=15)}([function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(setImmediate, global) {;(function() {\n"use strict"\nfunction Vnode(tag, key, attrs0, children, text, dom) {\n\treturn {tag: tag, key: key, attrs: attrs0, children: children, text: text, dom: dom, domSize: undefined, state: undefined, _state: undefined, events: undefined, instance: undefined, skip: false}\n}\nVnode.normalize = function(node) {\n\tif (Array.isArray(node)) return Vnode("[", undefined, undefined, Vnode.normalizeChildren(node), undefined, undefined)\n\tif (node != null && typeof node !== "object") return Vnode("#", undefined, undefined, node === false ? "" : node, undefined, undefined)\n\treturn node\n}\nVnode.normalizeChildren = function normalizeChildren(children) {\n\tfor (var i = 0; i < children.length; i++) {\n\t\tchildren[i] = Vnode.normalize(children[i])\n\t}\n\treturn children\n}\nvar selectorParser = /(?:(^|#|\\.)([^#\\.\\[\\]]+))|(\\[(.+?)(?:\\s*=\\s*("|\'|)((?:\\\\["\'\\]]|.)*?)\\5)?\\])/g\nvar selectorCache = {}\nvar hasOwn = {}.hasOwnProperty\nfunction compileSelector(selector) {\n\tvar match, tag = "div", classes = [], attrs = {}\n\twhile (match = selectorParser.exec(selector)) {\n\t\tvar type = match[1], value = match[2]\n\t\tif (type === "" && value !== "") tag = value\n\t\telse if (type === "#") attrs.id = value\n\t\telse if (type === ".") classes.push(value)\n\t\telse if (match[3][0] === "[") {\n\t\t\tvar attrValue = match[6]\n\t\t\tif (attrValue) attrValue = attrValue.replace(/\\\\(["\'])/g, "$1").replace(/\\\\\\\\/g, "\\\\")\n\t\t\tif (match[4] === "class") classes.push(attrValue)\n\t\t\telse attrs[match[4]] = attrValue === "" ? attrValue : attrValue || true\n\t\t}\n\t}\n\tif (classes.length > 0) attrs.className = classes.join(" ")\n\treturn selectorCache[selector] = {tag: tag, attrs: attrs}\n}\nfunction execSelector(state, attrs, children) {\n\tvar hasAttrs = false, childList, text\n\tvar className = attrs.className || attrs.class\n\tfor (var key in state.attrs) {\n\t\tif (hasOwn.call(state.attrs, key)) {\n\t\t\tattrs[key] = state.attrs[key]\n\t\t}\n\t}\n\tif (className !== undefined) {\n\t\tif (attrs.class !== undefined) {\n\t\t\tattrs.class = undefined\n\t\t\tattrs.className = className\n\t\t}\n\t\tif (state.attrs.className != null) {\n\t\t\tattrs.className = state.attrs.className + " " + className\n\t\t}\n\t}\n\tfor (var key in attrs) {\n\t\tif (hasOwn.call(attrs, key) && key !== "key") {\n\t\t\thasAttrs = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif (Array.isArray(children) && children.length === 1 && children[0] != null && children[0].tag === "#") {\n\t\ttext = children[0].children\n\t} else {\n\t\tchildList = children\n\t}\n\treturn Vnode(state.tag, attrs.key, hasAttrs ? attrs : undefined, childList, text)\n}\nfunction hyperscript(selector) {\n\t// Because sloppy mode sucks\n\tvar attrs = arguments[1], start = 2, children\n\tif (selector == null || typeof selector !== "string" && typeof selector !== "function" && typeof selector.view !== "function") {\n\t\tthrow Error("The selector must be either a string or a component.");\n\t}\n\tif (typeof selector === "string") {\n\t\tvar cached = selectorCache[selector] || compileSelector(selector)\n\t}\n\tif (attrs == null) {\n\t\tattrs = {}\n\t} else if (typeof attrs !== "object" || attrs.tag != null || Array.isArray(attrs)) {\n\t\tattrs = {}\n\t\tstart = 1\n\t}\n\tif (arguments.length === start + 1) {\n\t\tchildren = arguments[start]\n\t\tif (!Array.isArray(children)) children = [children]\n\t} else {\n\t\tchildren = []\n\t\twhile (start < arguments.length) children.push(arguments[start++])\n\t}\n\tvar normalized = Vnode.normalizeChildren(children)\n\tif (typeof selector === "string") {\n\t\treturn execSelector(cached, attrs, normalized)\n\t} else {\n\t\treturn Vnode(selector, attrs.key, attrs, normalized)\n\t}\n}\nhyperscript.trust = function(html) {\n\tif (html == null) html = ""\n\treturn Vnode("<", undefined, undefined, html, undefined, undefined)\n}\nhyperscript.fragment = function(attrs1, children) {\n\treturn Vnode("[", attrs1.key, attrs1, Vnode.normalizeChildren(children), undefined, undefined)\n}\nvar m = hyperscript\n/** @constructor */\nvar PromisePolyfill = function(executor) {\n\tif (!(this instanceof PromisePolyfill)) throw new Error("Promise must be called with `new`")\n\tif (typeof executor !== "function") throw new TypeError("executor must be a function")\n\tvar self = this, resolvers = [], rejectors = [], resolveCurrent = handler(resolvers, true), rejectCurrent = handler(rejectors, false)\n\tvar instance = self._instance = {resolvers: resolvers, rejectors: rejectors}\n\tvar callAsync = typeof setImmediate === "function" ? setImmediate : setTimeout\n\tfunction handler(list, shouldAbsorb) {\n\t\treturn function execute(value) {\n\t\t\tvar then\n\t\t\ttry {\n\t\t\t\tif (shouldAbsorb && value != null && (typeof value === "object" || typeof value === "function") && typeof (then = value.then) === "function") {\n\t\t\t\t\tif (value === self) throw new TypeError("Promise can\'t be resolved w/ itself")\n\t\t\t\t\texecuteOnce(then.bind(value))\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcallAsync(function() {\n\t\t\t\t\t\tif (!shouldAbsorb && list.length === 0) console.error("Possible unhandled promise rejection:", value)\n\t\t\t\t\t\tfor (var i = 0; i < list.length; i++) list[i](value)\n\t\t\t\t\t\tresolvers.length = 0, rejectors.length = 0\n\t\t\t\t\t\tinstance.state = shouldAbsorb\n\t\t\t\t\t\tinstance.retry = function() {execute(value)}\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (e) {\n\t\t\t\trejectCurrent(e)\n\t\t\t}\n\t\t}\n\t}\n\tfunction executeOnce(then) {\n\t\tvar runs = 0\n\t\tfunction run(fn) {\n\t\t\treturn function(value) {\n\t\t\t\tif (runs++ > 0) return\n\t\t\t\tfn(value)\n\t\t\t}\n\t\t}\n\t\tvar onerror = run(rejectCurrent)\n\t\ttry {then(run(resolveCurrent), onerror)} catch (e) {onerror(e)}\n\t}\n\texecuteOnce(executor)\n}\nPromisePolyfill.prototype.then = function(onFulfilled, onRejection) {\n\tvar self = this, instance = self._instance\n\tfunction handle(callback, list, next, state) {\n\t\tlist.push(function(value) {\n\t\t\tif (typeof callback !== "function") next(value)\n\t\t\telse try {resolveNext(callback(value))} catch (e) {if (rejectNext) rejectNext(e)}\n\t\t})\n\t\tif (typeof instance.retry === "function" && state === instance.state) instance.retry()\n\t}\n\tvar resolveNext, rejectNext\n\tvar promise = new PromisePolyfill(function(resolve, reject) {resolveNext = resolve, rejectNext = reject})\n\thandle(onFulfilled, instance.resolvers, resolveNext, true), handle(onRejection, instance.rejectors, rejectNext, false)\n\treturn promise\n}\nPromisePolyfill.prototype.catch = function(onRejection) {\n\treturn this.then(null, onRejection)\n}\nPromisePolyfill.resolve = function(value) {\n\tif (value instanceof PromisePolyfill) return value\n\treturn new PromisePolyfill(function(resolve) {resolve(value)})\n}\nPromisePolyfill.reject = function(value) {\n\treturn new PromisePolyfill(function(resolve, reject) {reject(value)})\n}\nPromisePolyfill.all = function(list) {\n\treturn new PromisePolyfill(function(resolve, reject) {\n\t\tvar total = list.length, count = 0, values = []\n\t\tif (list.length === 0) resolve([])\n\t\telse for (var i = 0; i < list.length; i++) {\n\t\t\t(function(i) {\n\t\t\t\tfunction consume(value) {\n\t\t\t\t\tcount++\n\t\t\t\t\tvalues[i] = value\n\t\t\t\t\tif (count === total) resolve(values)\n\t\t\t\t}\n\t\t\t\tif (list[i] != null && (typeof list[i] === "object" || typeof list[i] === "function") && typeof list[i].then === "function") {\n\t\t\t\t\tlist[i].then(consume, reject)\n\t\t\t\t}\n\t\t\t\telse consume(list[i])\n\t\t\t})(i)\n\t\t}\n\t})\n}\nPromisePolyfill.race = function(list) {\n\treturn new PromisePolyfill(function(resolve, reject) {\n\t\tfor (var i = 0; i < list.length; i++) {\n\t\t\tlist[i].then(resolve, reject)\n\t\t}\n\t})\n}\nif (typeof window !== "undefined") {\n\tif (typeof window.Promise === "undefined") window.Promise = PromisePolyfill\n\tvar PromisePolyfill = window.Promise\n} else if (typeof global !== "undefined") {\n\tif (typeof global.Promise === "undefined") global.Promise = PromisePolyfill\n\tvar PromisePolyfill = global.Promise\n} else {\n}\nvar buildQueryString = function(object) {\n\tif (Object.prototype.toString.call(object) !== "[object Object]") return ""\n\tvar args = []\n\tfor (var key0 in object) {\n\t\tdestructure(key0, object[key0])\n\t}\n\treturn args.join("&")\n\tfunction destructure(key0, value) {\n\t\tif (Array.isArray(value)) {\n\t\t\tfor (var i = 0; i < value.length; i++) {\n\t\t\t\tdestructure(key0 + "[" + i + "]", value[i])\n\t\t\t}\n\t\t}\n\t\telse if (Object.prototype.toString.call(value) === "[object Object]") {\n\t\t\tfor (var i in value) {\n\t\t\t\tdestructure(key0 + "[" + i + "]", value[i])\n\t\t\t}\n\t\t}\n\t\telse args.push(encodeURIComponent(key0) + (value != null && value !== "" ? "=" + encodeURIComponent(value) : ""))\n\t}\n}\nvar FILE_PROTOCOL_REGEX = new RegExp("^file://", "i")\nvar _8 = function($window, Promise) {\n\tvar callbackCount = 0\n\tvar oncompletion\n\tfunction setCompletionCallback(callback) {oncompletion = callback}\n\tfunction finalizer() {\n\t\tvar count = 0\n\t\tfunction complete() {if (--count === 0 && typeof oncompletion === "function") oncompletion()}\n\t\treturn function finalize(promise0) {\n\t\t\tvar then0 = promise0.then\n\t\t\tpromise0.then = function() {\n\t\t\t\tcount++\n\t\t\t\tvar next = then0.apply(promise0, arguments)\n\t\t\t\tnext.then(complete, function(e) {\n\t\t\t\t\tcomplete()\n\t\t\t\t\tif (count === 0) throw e\n\t\t\t\t})\n\t\t\t\treturn finalize(next)\n\t\t\t}\n\t\t\treturn promise0\n\t\t}\n\t}\n\tfunction normalize(args, extra) {\n\t\tif (typeof args === "string") {\n\t\t\tvar url = args\n\t\t\targs = extra || {}\n\t\t\tif (args.url == null) args.url = url\n\t\t}\n\t\treturn args\n\t}\n\tfunction request(args, extra) {\n\t\tvar finalize = finalizer()\n\t\targs = normalize(args, extra)\n\t\tvar promise0 = new Promise(function(resolve, reject) {\n\t\t\tif (args.method == null) args.method = "GET"\n\t\t\targs.method = args.method.toUpperCase()\n\t\t\tvar useBody = (args.method === "GET" || args.method === "TRACE") ? false : (typeof args.useBody === "boolean" ? args.useBody : true)\n\t\t\tif (typeof args.serialize !== "function") args.serialize = typeof FormData !== "undefined" && args.data instanceof FormData ? function(value) {return value} : JSON.stringify\n\t\t\tif (typeof args.deserialize !== "function") args.deserialize = deserialize\n\t\t\tif (typeof args.extract !== "function") args.extract = extract\n\t\t\targs.url = interpolate(args.url, args.data)\n\t\t\tif (useBody) args.data = args.serialize(args.data)\n\t\t\telse args.url = assemble(args.url, args.data)\n\t\t\tvar xhr = new $window.XMLHttpRequest(),\n\t\t\t\taborted = false,\n\t\t\t\t_abort = xhr.abort\n\t\t\txhr.abort = function abort() {\n\t\t\t\taborted = true\n\t\t\t\t_abort.call(xhr)\n\t\t\t}\n\t\t\txhr.open(args.method, args.url, typeof args.async === "boolean" ? args.async : true, typeof args.user === "string" ? args.user : undefined, typeof args.password === "string" ? args.password : undefined)\n\t\t\tif (args.serialize === JSON.stringify && useBody) {\n\t\t\t\txhr.setRequestHeader("Content-Type", "application/json; charset=utf-8")\n\t\t\t}\n\t\t\tif (args.deserialize === deserialize) {\n\t\t\t\txhr.setRequestHeader("Accept", "application/json, text/*")\n\t\t\t}\n\t\t\tif (args.withCredentials) xhr.withCredentials = args.withCredentials\n\t\t\tfor (var key in args.headers) if ({}.hasOwnProperty.call(args.headers, key)) {\n\t\t\t\txhr.setRequestHeader(key, args.headers[key])\n\t\t\t}\n\t\t\tif (typeof args.config === "function") xhr = args.config(xhr, args) || xhr\n\t\t\txhr.onreadystatechange = function() {\n\t\t\t\t// Don\'t throw errors on xhr.abort().\n\t\t\t\tif(aborted) return\n\t\t\t\tif (xhr.readyState === 4) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvar response = (args.extract !== extract) ? args.extract(xhr, args) : args.deserialize(args.extract(xhr, args))\n\t\t\t\t\t\tif ((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304 || FILE_PROTOCOL_REGEX.test(args.url)) {\n\t\t\t\t\t\t\tresolve(cast(args.type, response))\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tvar error = new Error(xhr.responseText)\n\t\t\t\t\t\t\tfor (var key in response) error[key] = response[key]\n\t\t\t\t\t\t\treject(error)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (e) {\n\t\t\t\t\t\treject(e)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (useBody && (args.data != null)) xhr.send(args.data)\n\t\t\telse xhr.send()\n\t\t})\n\t\treturn args.background === true ? promise0 : finalize(promise0)\n\t}\n\tfunction jsonp(args, extra) {\n\t\tvar finalize = finalizer()\n\t\targs = normalize(args, extra)\n\t\tvar promise0 = new Promise(function(resolve, reject) {\n\t\t\tvar callbackName = args.callbackName || "_mithril_" + Math.round(Math.random() * 1e16) + "_" + callbackCount++\n\t\t\tvar script = $window.document.createElement("script")\n\t\t\t$window[callbackName] = function(data) {\n\t\t\t\tscript.parentNode.removeChild(script)\n\t\t\t\tresolve(cast(args.type, data))\n\t\t\t\tdelete $window[callbackName]\n\t\t\t}\n\t\t\tscript.onerror = function() {\n\t\t\t\tscript.parentNode.removeChild(script)\n\t\t\t\treject(new Error("JSONP request failed"))\n\t\t\t\tdelete $window[callbackName]\n\t\t\t}\n\t\t\tif (args.data == null) args.data = {}\n\t\t\targs.url = interpolate(args.url, args.data)\n\t\t\targs.data[args.callbackKey || "callback"] = callbackName\n\t\t\tscript.src = assemble(args.url, args.data)\n\t\t\t$window.document.documentElement.appendChild(script)\n\t\t})\n\t\treturn args.background === true? promise0 : finalize(promise0)\n\t}\n\tfunction interpolate(url, data) {\n\t\tif (data == null) return url\n\t\tvar tokens = url.match(/:[^\\/]+/gi) || []\n\t\tfor (var i = 0; i < tokens.length; i++) {\n\t\t\tvar key = tokens[i].slice(1)\n\t\t\tif (data[key] != null) {\n\t\t\t\turl = url.replace(tokens[i], data[key])\n\t\t\t}\n\t\t}\n\t\treturn url\n\t}\n\tfunction assemble(url, data) {\n\t\tvar querystring = buildQueryString(data)\n\t\tif (querystring !== "") {\n\t\t\tvar prefix = url.indexOf("?") < 0 ? "?" : "&"\n\t\t\turl += prefix + querystring\n\t\t}\n\t\treturn url\n\t}\n\tfunction deserialize(data) {\n\t\ttry {return data !== "" ? JSON.parse(data) : null}\n\t\tcatch (e) {throw new Error(data)}\n\t}\n\tfunction extract(xhr) {return xhr.responseText}\n\tfunction cast(type0, data) {\n\t\tif (typeof type0 === "function") {\n\t\t\tif (Array.isArray(data)) {\n\t\t\t\tfor (var i = 0; i < data.length; i++) {\n\t\t\t\t\tdata[i] = new type0(data[i])\n\t\t\t\t}\n\t\t\t}\n\t\t\telse return new type0(data)\n\t\t}\n\t\treturn data\n\t}\n\treturn {request: request, jsonp: jsonp, setCompletionCallback: setCompletionCallback}\n}\nvar requestService = _8(window, PromisePolyfill)\nvar coreRenderer = function($window) {\n\tvar $doc = $window.document\n\tvar $emptyFragment = $doc.createDocumentFragment()\n\tvar nameSpace = {\n\t\tsvg: "http://www.w3.org/2000/svg",\n\t\tmath: "http://www.w3.org/1998/Math/MathML"\n\t}\n\tvar onevent\n\tfunction setEventCallback(callback) {return onevent = callback}\n\tfunction getNameSpace(vnode) {\n\t\treturn vnode.attrs && vnode.attrs.xmlns || nameSpace[vnode.tag]\n\t}\n\t//create\n\tfunction createNodes(parent, vnodes, start, end, hooks, nextSibling, ns) {\n\t\tfor (var i = start; i < end; i++) {\n\t\t\tvar vnode = vnodes[i]\n\t\t\tif (vnode != null) {\n\t\t\t\tcreateNode(parent, vnode, hooks, ns, nextSibling)\n\t\t\t}\n\t\t}\n\t}\n\tfunction createNode(parent, vnode, hooks, ns, nextSibling) {\n\t\tvar tag = vnode.tag\n\t\tif (typeof tag === "string") {\n\t\t\tvnode.state = {}\n\t\t\tif (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks)\n\t\t\tswitch (tag) {\n\t\t\t\tcase "#": return createText(parent, vnode, nextSibling)\n\t\t\t\tcase "<": return createHTML(parent, vnode, nextSibling)\n\t\t\t\tcase "[": return createFragment(parent, vnode, hooks, ns, nextSibling)\n\t\t\t\tdefault: return createElement(parent, vnode, hooks, ns, nextSibling)\n\t\t\t}\n\t\t}\n\t\telse return createComponent(parent, vnode, hooks, ns, nextSibling)\n\t}\n\tfunction createText(parent, vnode, nextSibling) {\n\t\tvnode.dom = $doc.createTextNode(vnode.children)\n\t\tinsertNode(parent, vnode.dom, nextSibling)\n\t\treturn vnode.dom\n\t}\n\tfunction createHTML(parent, vnode, nextSibling) {\n\t\tvar match1 = vnode.children.match(/^\\s*?<(\\w+)/im) || []\n\t\tvar parent1 = {caption: "table", thead: "table", tbody: "table", tfoot: "table", tr: "tbody", th: "tr", td: "tr", colgroup: "table", col: "colgroup"}[match1[1]] || "div"\n\t\tvar temp = $doc.createElement(parent1)\n\t\ttemp.innerHTML = vnode.children\n\t\tvnode.dom = temp.firstChild\n\t\tvnode.domSize = temp.childNodes.length\n\t\tvar fragment = $doc.createDocumentFragment()\n\t\tvar child\n\t\twhile (child = temp.firstChild) {\n\t\t\tfragment.appendChild(child)\n\t\t}\n\t\tinsertNode(parent, fragment, nextSibling)\n\t\treturn fragment\n\t}\n\tfunction createFragment(parent, vnode, hooks, ns, nextSibling) {\n\t\tvar fragment = $doc.createDocumentFragment()\n\t\tif (vnode.children != null) {\n\t\t\tvar children = vnode.children\n\t\t\tcreateNodes(fragment, children, 0, children.length, hooks, null, ns)\n\t\t}\n\t\tvnode.dom = fragment.firstChild\n\t\tvnode.domSize = fragment.childNodes.length\n\t\tinsertNode(parent, fragment, nextSibling)\n\t\treturn fragment\n\t}\n\tfunction createElement(parent, vnode, hooks, ns, nextSibling) {\n\t\tvar tag = vnode.tag\n\t\tvar attrs2 = vnode.attrs\n\t\tvar is = attrs2 && attrs2.is\n\t\tns = getNameSpace(vnode) || ns\n\t\tvar element = ns ?\n\t\t\tis ? $doc.createElementNS(ns, tag, {is: is}) : $doc.createElementNS(ns, tag) :\n\t\t\tis ? $doc.createElement(tag, {is: is}) : $doc.createElement(tag)\n\t\tvnode.dom = element\n\t\tif (attrs2 != null) {\n\t\t\tsetAttrs(vnode, attrs2, ns)\n\t\t}\n\t\tinsertNode(parent, element, nextSibling)\n\t\tif (vnode.attrs != null && vnode.attrs.contenteditable != null) {\n\t\t\tsetContentEditable(vnode)\n\t\t}\n\t\telse {\n\t\t\tif (vnode.text != null) {\n\t\t\t\tif (vnode.text !== "") element.textContent = vnode.text\n\t\t\t\telse vnode.children = [Vnode("#", undefined, undefined, vnode.text, undefined, undefined)]\n\t\t\t}\n\t\t\tif (vnode.children != null) {\n\t\t\t\tvar children = vnode.children\n\t\t\t\tcreateNodes(element, children, 0, children.length, hooks, null, ns)\n\t\t\t\tsetLateAttrs(vnode)\n\t\t\t}\n\t\t}\n\t\treturn element\n\t}\n\tfunction initComponent(vnode, hooks) {\n\t\tvar sentinel\n\t\tif (typeof vnode.tag.view === "function") {\n\t\t\tvnode.state = Object.create(vnode.tag)\n\t\t\tsentinel = vnode.state.view\n\t\t\tif (sentinel.$$reentrantLock$$ != null) return $emptyFragment\n\t\t\tsentinel.$$reentrantLock$$ = true\n\t\t} else {\n\t\t\tvnode.state = void 0\n\t\t\tsentinel = vnode.tag\n\t\t\tif (sentinel.$$reentrantLock$$ != null) return $emptyFragment\n\t\t\tsentinel.$$reentrantLock$$ = true\n\t\t\tvnode.state = (vnode.tag.prototype != null && typeof vnode.tag.prototype.view === "function") ? new vnode.tag(vnode) : vnode.tag(vnode)\n\t\t}\n\t\tvnode._state = vnode.state\n\t\tif (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks)\n\t\tinitLifecycle(vnode._state, vnode, hooks)\n\t\tvnode.instance = Vnode.normalize(vnode._state.view.call(vnode.state, vnode))\n\t\tif (vnode.instance === vnode) throw Error("A view cannot return the vnode it received as argument")\n\t\tsentinel.$$reentrantLock$$ = null\n\t}\n\tfunction createComponent(parent, vnode, hooks, ns, nextSibling) {\n\t\tinitComponent(vnode, hooks)\n\t\tif (vnode.instance != null) {\n\t\t\tvar element = createNode(parent, vnode.instance, hooks, ns, nextSibling)\n\t\t\tvnode.dom = vnode.instance.dom\n\t\t\tvnode.domSize = vnode.dom != null ? vnode.instance.domSize : 0\n\t\t\tinsertNode(parent, element, nextSibling)\n\t\t\treturn element\n\t\t}\n\t\telse {\n\t\t\tvnode.domSize = 0\n\t\t\treturn $emptyFragment\n\t\t}\n\t}\n\t//update\n\tfunction updateNodes(parent, old, vnodes, recycling, hooks, nextSibling, ns) {\n\t\tif (old === vnodes || old == null && vnodes == null) return\n\t\telse if (old == null) createNodes(parent, vnodes, 0, vnodes.length, hooks, nextSibling, ns)\n\t\telse if (vnodes == null) removeNodes(old, 0, old.length, vnodes)\n\t\telse {\n\t\t\tif (old.length === vnodes.length) {\n\t\t\t\tvar isUnkeyed = false\n\t\t\t\tfor (var i = 0; i < vnodes.length; i++) {\n\t\t\t\t\tif (vnodes[i] != null && old[i] != null) {\n\t\t\t\t\t\tisUnkeyed = vnodes[i].key == null && old[i].key == null\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (isUnkeyed) {\n\t\t\t\t\tfor (var i = 0; i < old.length; i++) {\n\t\t\t\t\t\tif (old[i] === vnodes[i]) continue\n\t\t\t\t\t\telse if (old[i] == null && vnodes[i] != null) createNode(parent, vnodes[i], hooks, ns, getNextSibling(old, i + 1, nextSibling))\n\t\t\t\t\t\telse if (vnodes[i] == null) removeNodes(old, i, i + 1, vnodes)\n\t\t\t\t\t\telse updateNode(parent, old[i], vnodes[i], hooks, getNextSibling(old, i + 1, nextSibling), recycling, ns)\n\t\t\t\t\t}\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\trecycling = recycling || isRecyclable(old, vnodes)\n\t\t\tif (recycling) {\n\t\t\t\tvar pool = old.pool\n\t\t\t\told = old.concat(old.pool)\n\t\t\t}\n\t\t\tvar oldStart = 0, start = 0, oldEnd = old.length - 1, end = vnodes.length - 1, map\n\t\t\twhile (oldEnd >= oldStart && end >= start) {\n\t\t\t\tvar o = old[oldStart], v = vnodes[start]\n\t\t\t\tif (o === v && !recycling) oldStart++, start++\n\t\t\t\telse if (o == null) oldStart++\n\t\t\t\telse if (v == null) start++\n\t\t\t\telse if (o.key === v.key) {\n\t\t\t\t\tvar shouldRecycle = (pool != null && oldStart >= old.length - pool.length) || ((pool == null) && recycling)\n\t\t\t\t\toldStart++, start++\n\t\t\t\t\tupdateNode(parent, o, v, hooks, getNextSibling(old, oldStart, nextSibling), shouldRecycle, ns)\n\t\t\t\t\tif (recycling && o.tag === v.tag) insertNode(parent, toFragment(o), nextSibling)\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tvar o = old[oldEnd]\n\t\t\t\t\tif (o === v && !recycling) oldEnd--, start++\n\t\t\t\t\telse if (o == null) oldEnd--\n\t\t\t\t\telse if (v == null) start++\n\t\t\t\t\telse if (o.key === v.key) {\n\t\t\t\t\t\tvar shouldRecycle = (pool != null && oldEnd >= old.length - pool.length) || ((pool == null) && recycling)\n\t\t\t\t\t\tupdateNode(parent, o, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), shouldRecycle, ns)\n\t\t\t\t\t\tif (recycling || start < end) insertNode(parent, toFragment(o), getNextSibling(old, oldStart, nextSibling))\n\t\t\t\t\t\toldEnd--, start++\n\t\t\t\t\t}\n\t\t\t\t\telse break\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (oldEnd >= oldStart && end >= start) {\n\t\t\t\tvar o = old[oldEnd], v = vnodes[end]\n\t\t\t\tif (o === v && !recycling) oldEnd--, end--\n\t\t\t\telse if (o == null) oldEnd--\n\t\t\t\telse if (v == null) end--\n\t\t\t\telse if (o.key === v.key) {\n\t\t\t\t\tvar shouldRecycle = (pool != null && oldEnd >= old.length - pool.length) || ((pool == null) && recycling)\n\t\t\t\t\tupdateNode(parent, o, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), shouldRecycle, ns)\n\t\t\t\t\tif (recycling && o.tag === v.tag) insertNode(parent, toFragment(o), nextSibling)\n\t\t\t\t\tif (o.dom != null) nextSibling = o.dom\n\t\t\t\t\toldEnd--, end--\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (!map) map = getKeyMap(old, oldEnd)\n\t\t\t\t\tif (v != null) {\n\t\t\t\t\t\tvar oldIndex = map[v.key]\n\t\t\t\t\t\tif (oldIndex != null) {\n\t\t\t\t\t\t\tvar movable = old[oldIndex]\n\t\t\t\t\t\t\tvar shouldRecycle = (pool != null && oldIndex >= old.length - pool.length) || ((pool == null) && recycling)\n\t\t\t\t\t\t\tupdateNode(parent, movable, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), recycling, ns)\n\t\t\t\t\t\t\tinsertNode(parent, toFragment(movable), nextSibling)\n\t\t\t\t\t\t\told[oldIndex].skip = true\n\t\t\t\t\t\t\tif (movable.dom != null) nextSibling = movable.dom\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tvar dom = createNode(parent, v, hooks, ns, nextSibling)\n\t\t\t\t\t\t\tnextSibling = dom\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tend--\n\t\t\t\t}\n\t\t\t\tif (end < start) break\n\t\t\t}\n\t\t\tcreateNodes(parent, vnodes, start, end + 1, hooks, nextSibling, ns)\n\t\t\tremoveNodes(old, oldStart, oldEnd + 1, vnodes)\n\t\t}\n\t}\n\tfunction updateNode(parent, old, vnode, hooks, nextSibling, recycling, ns) {\n\t\tvar oldTag = old.tag, tag = vnode.tag\n\t\tif (oldTag === tag) {\n\t\t\tvnode.state = old.state\n\t\t\tvnode._state = old._state\n\t\t\tvnode.events = old.events\n\t\t\tif (!recycling && shouldNotUpdate(vnode, old)) return\n\t\t\tif (typeof oldTag === "string") {\n\t\t\t\tif (vnode.attrs != null) {\n\t\t\t\t\tif (recycling) {\n\t\t\t\t\t\tvnode.state = {}\n\t\t\t\t\t\tinitLifecycle(vnode.attrs, vnode, hooks)\n\t\t\t\t\t}\n\t\t\t\t\telse updateLifecycle(vnode.attrs, vnode, hooks)\n\t\t\t\t}\n\t\t\t\tswitch (oldTag) {\n\t\t\t\t\tcase "#": updateText(old, vnode); break\n\t\t\t\t\tcase "<": updateHTML(parent, old, vnode, nextSibling); break\n\t\t\t\t\tcase "[": updateFragment(parent, old, vnode, recycling, hooks, nextSibling, ns); break\n\t\t\t\t\tdefault: updateElement(old, vnode, recycling, hooks, ns)\n\t\t\t\t}\n\t\t\t}\n\t\t\telse updateComponent(parent, old, vnode, hooks, nextSibling, recycling, ns)\n\t\t}\n\t\telse {\n\t\t\tremoveNode(old, null)\n\t\t\tcreateNode(parent, vnode, hooks, ns, nextSibling)\n\t\t}\n\t}\n\tfunction updateText(old, vnode) {\n\t\tif (old.children.toString() !== vnode.children.toString()) {\n\t\t\told.dom.nodeValue = vnode.children\n\t\t}\n\t\tvnode.dom = old.dom\n\t}\n\tfunction updateHTML(parent, old, vnode, nextSibling) {\n\t\tif (old.children !== vnode.children) {\n\t\t\ttoFragment(old)\n\t\t\tcreateHTML(parent, vnode, nextSibling)\n\t\t}\n\t\telse vnode.dom = old.dom, vnode.domSize = old.domSize\n\t}\n\tfunction updateFragment(parent, old, vnode, recycling, hooks, nextSibling, ns) {\n\t\tupdateNodes(parent, old.children, vnode.children, recycling, hooks, nextSibling, ns)\n\t\tvar domSize = 0, children = vnode.children\n\t\tvnode.dom = null\n\t\tif (children != null) {\n\t\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\t\tvar child = children[i]\n\t\t\t\tif (child != null && child.dom != null) {\n\t\t\t\t\tif (vnode.dom == null) vnode.dom = child.dom\n\t\t\t\t\tdomSize += child.domSize || 1\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (domSize !== 1) vnode.domSize = domSize\n\t\t}\n\t}\n\tfunction updateElement(old, vnode, recycling, hooks, ns) {\n\t\tvar element = vnode.dom = old.dom\n\t\tns = getNameSpace(vnode) || ns\n\t\tif (vnode.tag === "textarea") {\n\t\t\tif (vnode.attrs == null) vnode.attrs = {}\n\t\t\tif (vnode.text != null) {\n\t\t\t\tvnode.attrs.value = vnode.text //FIXME handle0 multiple children\n\t\t\t\tvnode.text = undefined\n\t\t\t}\n\t\t}\n\t\tupdateAttrs(vnode, old.attrs, vnode.attrs, ns)\n\t\tif (vnode.attrs != null && vnode.attrs.contenteditable != null) {\n\t\t\tsetContentEditable(vnode)\n\t\t}\n\t\telse if (old.text != null && vnode.text != null && vnode.text !== "") {\n\t\t\tif (old.text.toString() !== vnode.text.toString()) old.dom.firstChild.nodeValue = vnode.text\n\t\t}\n\t\telse {\n\t\t\tif (old.text != null) old.children = [Vnode("#", undefined, undefined, old.text, undefined, old.dom.firstChild)]\n\t\t\tif (vnode.text != null) vnode.children = [Vnode("#", undefined, undefined, vnode.text, undefined, undefined)]\n\t\t\tupdateNodes(element, old.children, vnode.children, recycling, hooks, null, ns)\n\t\t}\n\t}\n\tfunction updateComponent(parent, old, vnode, hooks, nextSibling, recycling, ns) {\n\t\tif (recycling) {\n\t\t\tinitComponent(vnode, hooks)\n\t\t} else {\n\t\t\tvnode.instance = Vnode.normalize(vnode._state.view.call(vnode.state, vnode))\n\t\t\tif (vnode.instance === vnode) throw Error("A view cannot return the vnode it received as argument")\n\t\t\tif (vnode.attrs != null) updateLifecycle(vnode.attrs, vnode, hooks)\n\t\t\tupdateLifecycle(vnode._state, vnode, hooks)\n\t\t}\n\t\tif (vnode.instance != null) {\n\t\t\tif (old.instance == null) createNode(parent, vnode.instance, hooks, ns, nextSibling)\n\t\t\telse updateNode(parent, old.instance, vnode.instance, hooks, nextSibling, recycling, ns)\n\t\t\tvnode.dom = vnode.instance.dom\n\t\t\tvnode.domSize = vnode.instance.domSize\n\t\t}\n\t\telse if (old.instance != null) {\n\t\t\tremoveNode(old.instance, null)\n\t\t\tvnode.dom = undefined\n\t\t\tvnode.domSize = 0\n\t\t}\n\t\telse {\n\t\t\tvnode.dom = old.dom\n\t\t\tvnode.domSize = old.domSize\n\t\t}\n\t}\n\tfunction isRecyclable(old, vnodes) {\n\t\tif (old.pool != null && Math.abs(old.pool.length - vnodes.length) <= Math.abs(old.length - vnodes.length)) {\n\t\t\tvar oldChildrenLength = old[0] && old[0].children && old[0].children.length || 0\n\t\t\tvar poolChildrenLength = old.pool[0] && old.pool[0].children && old.pool[0].children.length || 0\n\t\t\tvar vnodesChildrenLength = vnodes[0] && vnodes[0].children && vnodes[0].children.length || 0\n\t\t\tif (Math.abs(poolChildrenLength - vnodesChildrenLength) <= Math.abs(oldChildrenLength - vnodesChildrenLength)) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\tfunction getKeyMap(vnodes, end) {\n\t\tvar map = {}, i = 0\n\t\tfor (var i = 0; i < end; i++) {\n\t\t\tvar vnode = vnodes[i]\n\t\t\tif (vnode != null) {\n\t\t\t\tvar key2 = vnode.key\n\t\t\t\tif (key2 != null) map[key2] = i\n\t\t\t}\n\t\t}\n\t\treturn map\n\t}\n\tfunction toFragment(vnode) {\n\t\tvar count0 = vnode.domSize\n\t\tif (count0 != null || vnode.dom == null) {\n\t\t\tvar fragment = $doc.createDocumentFragment()\n\t\t\tif (count0 > 0) {\n\t\t\t\tvar dom = vnode.dom\n\t\t\t\twhile (--count0) fragment.appendChild(dom.nextSibling)\n\t\t\t\tfragment.insertBefore(dom, fragment.firstChild)\n\t\t\t}\n\t\t\treturn fragment\n\t\t}\n\t\telse return vnode.dom\n\t}\n\tfunction getNextSibling(vnodes, i, nextSibling) {\n\t\tfor (; i < vnodes.length; i++) {\n\t\t\tif (vnodes[i] != null && vnodes[i].dom != null) return vnodes[i].dom\n\t\t}\n\t\treturn nextSibling\n\t}\n\tfunction insertNode(parent, dom, nextSibling) {\n\t\tif (nextSibling && nextSibling.parentNode) parent.insertBefore(dom, nextSibling)\n\t\telse parent.appendChild(dom)\n\t}\n\tfunction setContentEditable(vnode) {\n\t\tvar children = vnode.children\n\t\tif (children != null && children.length === 1 && children[0].tag === "<") {\n\t\t\tvar content = children[0].children\n\t\t\tif (vnode.dom.innerHTML !== content) vnode.dom.innerHTML = content\n\t\t}\n\t\telse if (vnode.text != null || children != null && children.length !== 0) throw new Error("Child node of a contenteditable must be trusted")\n\t}\n\t//remove\n\tfunction removeNodes(vnodes, start, end, context) {\n\t\tfor (var i = start; i < end; i++) {\n\t\t\tvar vnode = vnodes[i]\n\t\t\tif (vnode != null) {\n\t\t\t\tif (vnode.skip) vnode.skip = false\n\t\t\t\telse removeNode(vnode, context)\n\t\t\t}\n\t\t}\n\t}\n\tfunction removeNode(vnode, context) {\n\t\tvar expected = 1, called = 0\n\t\tif (vnode.attrs && typeof vnode.attrs.onbeforeremove === "function") {\n\t\t\tvar result = vnode.attrs.onbeforeremove.call(vnode.state, vnode)\n\t\t\tif (result != null && typeof result.then === "function") {\n\t\t\t\texpected++\n\t\t\t\tresult.then(continuation, continuation)\n\t\t\t}\n\t\t}\n\t\tif (typeof vnode.tag !== "string" && typeof vnode._state.onbeforeremove === "function") {\n\t\t\tvar result = vnode._state.onbeforeremove.call(vnode.state, vnode)\n\t\t\tif (result != null && typeof result.then === "function") {\n\t\t\t\texpected++\n\t\t\t\tresult.then(continuation, continuation)\n\t\t\t}\n\t\t}\n\t\tcontinuation()\n\t\tfunction continuation() {\n\t\t\tif (++called === expected) {\n\t\t\t\tonremove(vnode)\n\t\t\t\tif (vnode.dom) {\n\t\t\t\t\tvar count0 = vnode.domSize || 1\n\t\t\t\t\tif (count0 > 1) {\n\t\t\t\t\t\tvar dom = vnode.dom\n\t\t\t\t\t\twhile (--count0) {\n\t\t\t\t\t\t\tremoveNodeFromDOM(dom.nextSibling)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tremoveNodeFromDOM(vnode.dom)\n\t\t\t\t\tif (context != null && vnode.domSize == null && !hasIntegrationMethods(vnode.attrs) && typeof vnode.tag === "string") { //TODO test custom elements\n\t\t\t\t\t\tif (!context.pool) context.pool = [vnode]\n\t\t\t\t\t\telse context.pool.push(vnode)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfunction removeNodeFromDOM(node) {\n\t\tvar parent = node.parentNode\n\t\tif (parent != null) parent.removeChild(node)\n\t}\n\tfunction onremove(vnode) {\n\t\tif (vnode.attrs && typeof vnode.attrs.onremove === "function") vnode.attrs.onremove.call(vnode.state, vnode)\n\t\tif (typeof vnode.tag !== "string" && typeof vnode._state.onremove === "function") vnode._state.onremove.call(vnode.state, vnode)\n\t\tif (vnode.instance != null) onremove(vnode.instance)\n\t\telse {\n\t\t\tvar children = vnode.children\n\t\t\tif (Array.isArray(children)) {\n\t\t\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\t\t\tvar child = children[i]\n\t\t\t\t\tif (child != null) onremove(child)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//attrs2\n\tfunction setAttrs(vnode, attrs2, ns) {\n\t\tfor (var key2 in attrs2) {\n\t\t\tsetAttr(vnode, key2, null, attrs2[key2], ns)\n\t\t}\n\t}\n\tfunction setAttr(vnode, key2, old, value, ns) {\n\t\tvar element = vnode.dom\n\t\tif (key2 === "key" || key2 === "is" || (old === value && !isFormAttribute(vnode, key2)) && typeof value !== "object" || typeof value === "undefined" || isLifecycleMethod(key2)) return\n\t\tvar nsLastIndex = key2.indexOf(":")\n\t\tif (nsLastIndex > -1 && key2.substr(0, nsLastIndex) === "xlink") {\n\t\t\telement.setAttributeNS("http://www.w3.org/1999/xlink", key2.slice(nsLastIndex + 1), value)\n\t\t}\n\t\telse if (key2[0] === "o" && key2[1] === "n" && typeof value === "function") updateEvent(vnode, key2, value)\n\t\telse if (key2 === "style") updateStyle(element, old, value)\n\t\telse if (key2 in element && !isAttribute(key2) && ns === undefined && !isCustomElement(vnode)) {\n\t\t\tif (key2 === "value") {\n\t\t\t\tvar normalized0 = "" + value // eslint-disable-line no-implicit-coercion\n\t\t\t\t//setting input[value] to same value by typing on focused element moves cursor to end in Chrome\n\t\t\t\tif ((vnode.tag === "input" || vnode.tag === "textarea") && vnode.dom.value === normalized0 && vnode.dom === $doc.activeElement) return\n\t\t\t\t//setting select[value] to same value while having select open blinks select dropdown in Chrome\n\t\t\t\tif (vnode.tag === "select") {\n\t\t\t\t\tif (value === null) {\n\t\t\t\t\t\tif (vnode.dom.selectedIndex === -1 && vnode.dom === $doc.activeElement) return\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (old !== null && vnode.dom.value === normalized0 && vnode.dom === $doc.activeElement) return\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//setting option[value] to same value while having select open blinks select dropdown in Chrome\n\t\t\t\tif (vnode.tag === "option" && old != null && vnode.dom.value === normalized0) return\n\t\t\t}\n\t\t\t// If you assign an input type1 that is not supported by IE 11 with an assignment expression, an error0 will occur.\n\t\t\tif (vnode.tag === "input" && key2 === "type") {\n\t\t\t\telement.setAttribute(key2, value)\n\t\t\t\treturn\n\t\t\t}\n\t\t\telement[key2] = value\n\t\t}\n\t\telse {\n\t\t\tif (typeof value === "boolean") {\n\t\t\t\tif (value) element.setAttribute(key2, "")\n\t\t\t\telse element.removeAttribute(key2)\n\t\t\t}\n\t\t\telse element.setAttribute(key2 === "className" ? "class" : key2, value)\n\t\t}\n\t}\n\tfunction setLateAttrs(vnode) {\n\t\tvar attrs2 = vnode.attrs\n\t\tif (vnode.tag === "select" && attrs2 != null) {\n\t\t\tif ("value" in attrs2) setAttr(vnode, "value", null, attrs2.value, undefined)\n\t\t\tif ("selectedIndex" in attrs2) setAttr(vnode, "selectedIndex", null, attrs2.selectedIndex, undefined)\n\t\t}\n\t}\n\tfunction updateAttrs(vnode, old, attrs2, ns) {\n\t\tif (attrs2 != null) {\n\t\t\tfor (var key2 in attrs2) {\n\t\t\t\tsetAttr(vnode, key2, old && old[key2], attrs2[key2], ns)\n\t\t\t}\n\t\t}\n\t\tif (old != null) {\n\t\t\tfor (var key2 in old) {\n\t\t\t\tif (attrs2 == null || !(key2 in attrs2)) {\n\t\t\t\t\tif (key2 === "className") key2 = "class"\n\t\t\t\t\tif (key2[0] === "o" && key2[1] === "n" && !isLifecycleMethod(key2)) updateEvent(vnode, key2, undefined)\n\t\t\t\t\telse if (key2 !== "key") vnode.dom.removeAttribute(key2)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfunction isFormAttribute(vnode, attr) {\n\t\treturn attr === "value" || attr === "checked" || attr === "selectedIndex" || attr === "selected" && vnode.dom === $doc.activeElement\n\t}\n\tfunction isLifecycleMethod(attr) {\n\t\treturn attr === "oninit" || attr === "oncreate" || attr === "onupdate" || attr === "onremove" || attr === "onbeforeremove" || attr === "onbeforeupdate"\n\t}\n\tfunction isAttribute(attr) {\n\t\treturn attr === "href" || attr === "list" || attr === "form" || attr === "width" || attr === "height"// || attr === "type"\n\t}\n\tfunction isCustomElement(vnode){\n\t\treturn vnode.attrs.is || vnode.tag.indexOf("-") > -1\n\t}\n\tfunction hasIntegrationMethods(source) {\n\t\treturn source != null && (source.oncreate || source.onupdate || source.onbeforeremove || source.onremove)\n\t}\n\t//style\n\tfunction updateStyle(element, old, style) {\n\t\tif (old === style) element.style.cssText = "", old = null\n\t\tif (style == null) element.style.cssText = ""\n\t\telse if (typeof style === "string") element.style.cssText = style\n\t\telse {\n\t\t\tif (typeof old === "string") element.style.cssText = ""\n\t\t\tfor (var key2 in style) {\n\t\t\t\telement.style[key2] = style[key2]\n\t\t\t}\n\t\t\tif (old != null && typeof old !== "string") {\n\t\t\t\tfor (var key2 in old) {\n\t\t\t\t\tif (!(key2 in style)) element.style[key2] = ""\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//event\n\tfunction updateEvent(vnode, key2, value) {\n\t\tvar element = vnode.dom\n\t\tvar callback = typeof onevent !== "function" ? value : function(e) {\n\t\t\tvar result = value.call(element, e)\n\t\t\tonevent.call(element, e)\n\t\t\treturn result\n\t\t}\n\t\tif (key2 in element) element[key2] = typeof value === "function" ? callback : null\n\t\telse {\n\t\t\tvar eventName = key2.slice(2)\n\t\t\tif (vnode.events === undefined) vnode.events = {}\n\t\t\tif (vnode.events[key2] === callback) return\n\t\t\tif (vnode.events[key2] != null) element.removeEventListener(eventName, vnode.events[key2], false)\n\t\t\tif (typeof value === "function") {\n\t\t\t\tvnode.events[key2] = callback\n\t\t\t\telement.addEventListener(eventName, vnode.events[key2], false)\n\t\t\t}\n\t\t}\n\t}\n\t//lifecycle\n\tfunction initLifecycle(source, vnode, hooks) {\n\t\tif (typeof source.oninit === "function") source.oninit.call(vnode.state, vnode)\n\t\tif (typeof source.oncreate === "function") hooks.push(source.oncreate.bind(vnode.state, vnode))\n\t}\n\tfunction updateLifecycle(source, vnode, hooks) {\n\t\tif (typeof source.onupdate === "function") hooks.push(source.onupdate.bind(vnode.state, vnode))\n\t}\n\tfunction shouldNotUpdate(vnode, old) {\n\t\tvar forceVnodeUpdate, forceComponentUpdate\n\t\tif (vnode.attrs != null && typeof vnode.attrs.onbeforeupdate === "function") forceVnodeUpdate = vnode.attrs.onbeforeupdate.call(vnode.state, vnode, old)\n\t\tif (typeof vnode.tag !== "string" && typeof vnode._state.onbeforeupdate === "function") forceComponentUpdate = vnode._state.onbeforeupdate.call(vnode.state, vnode, old)\n\t\tif (!(forceVnodeUpdate === undefined && forceComponentUpdate === undefined) && !forceVnodeUpdate && !forceComponentUpdate) {\n\t\t\tvnode.dom = old.dom\n\t\t\tvnode.domSize = old.domSize\n\t\t\tvnode.instance = old.instance\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\tfunction render(dom, vnodes) {\n\t\tif (!dom) throw new Error("Ensure the DOM element being passed to m.route/m.mount/m.render is not undefined.")\n\t\tvar hooks = []\n\t\tvar active = $doc.activeElement\n\t\tvar namespace = dom.namespaceURI\n\t\t// First time0 rendering into a node clears it out\n\t\tif (dom.vnodes == null) dom.textContent = ""\n\t\tif (!Array.isArray(vnodes)) vnodes = [vnodes]\n\t\tupdateNodes(dom, dom.vnodes, Vnode.normalizeChildren(vnodes), false, hooks, null, namespace === "http://www.w3.org/1999/xhtml" ? undefined : namespace)\n\t\tdom.vnodes = vnodes\n\t\tfor (var i = 0; i < hooks.length; i++) hooks[i]()\n\t\tif ($doc.activeElement !== active) active.focus()\n\t}\n\treturn {render: render, setEventCallback: setEventCallback}\n}\nfunction throttle(callback) {\n\t//60fps translates to 16.6ms, round it down since setTimeout requires int\n\tvar time = 16\n\tvar last = 0, pending = null\n\tvar timeout = typeof requestAnimationFrame === "function" ? requestAnimationFrame : setTimeout\n\treturn function() {\n\t\tvar now = Date.now()\n\t\tif (last === 0 || now - last >= time) {\n\t\t\tlast = now\n\t\t\tcallback()\n\t\t}\n\t\telse if (pending === null) {\n\t\t\tpending = timeout(function() {\n\t\t\t\tpending = null\n\t\t\t\tcallback()\n\t\t\t\tlast = Date.now()\n\t\t\t}, time - (now - last))\n\t\t}\n\t}\n}\nvar _11 = function($window) {\n\tvar renderService = coreRenderer($window)\n\trenderService.setEventCallback(function(e) {\n\t\tif (e.redraw === false) e.redraw = undefined\n\t\telse redraw()\n\t})\n\tvar callbacks = []\n\tfunction subscribe(key1, callback) {\n\t\tunsubscribe(key1)\n\t\tcallbacks.push(key1, throttle(callback))\n\t}\n\tfunction unsubscribe(key1) {\n\t\tvar index = callbacks.indexOf(key1)\n\t\tif (index > -1) callbacks.splice(index, 2)\n\t}\n\tfunction redraw() {\n\t\tfor (var i = 1; i < callbacks.length; i += 2) {\n\t\t\tcallbacks[i]()\n\t\t}\n\t}\n\treturn {subscribe: subscribe, unsubscribe: unsubscribe, redraw: redraw, render: renderService.render}\n}\nvar redrawService = _11(window)\nrequestService.setCompletionCallback(redrawService.redraw)\nvar _16 = function(redrawService0) {\n\treturn function(root, component) {\n\t\tif (component === null) {\n\t\t\tredrawService0.render(root, [])\n\t\t\tredrawService0.unsubscribe(root)\n\t\t\treturn\n\t\t}\n\t\t\n\t\tif (component.view == null && typeof component !== "function") throw new Error("m.mount(element, component) expects a component, not a vnode")\n\t\t\n\t\tvar run0 = function() {\n\t\t\tredrawService0.render(root, Vnode(component))\n\t\t}\n\t\tredrawService0.subscribe(root, run0)\n\t\tredrawService0.redraw()\n\t}\n}\nm.mount = _16(redrawService)\nvar Promise = PromisePolyfill\nvar parseQueryString = function(string) {\n\tif (string === "" || string == null) return {}\n\tif (string.charAt(0) === "?") string = string.slice(1)\n\tvar entries = string.split("&"), data0 = {}, counters = {}\n\tfor (var i = 0; i < entries.length; i++) {\n\t\tvar entry = entries[i].split("=")\n\t\tvar key5 = decodeURIComponent(entry[0])\n\t\tvar value = entry.length === 2 ? decodeURIComponent(entry[1]) : ""\n\t\tif (value === "true") value = true\n\t\telse if (value === "false") value = false\n\t\tvar levels = key5.split(/\\]\\[?|\\[/)\n\t\tvar cursor = data0\n\t\tif (key5.indexOf("[") > -1) levels.pop()\n\t\tfor (var j = 0; j < levels.length; j++) {\n\t\t\tvar level = levels[j], nextLevel = levels[j + 1]\n\t\t\tvar isNumber = nextLevel == "" || !isNaN(parseInt(nextLevel, 10))\n\t\t\tvar isValue = j === levels.length - 1\n\t\t\tif (level === "") {\n\t\t\t\tvar key5 = levels.slice(0, j).join()\n\t\t\t\tif (counters[key5] == null) counters[key5] = 0\n\t\t\t\tlevel = counters[key5]++\n\t\t\t}\n\t\t\tif (cursor[level] == null) {\n\t\t\t\tcursor[level] = isValue ? value : isNumber ? [] : {}\n\t\t\t}\n\t\t\tcursor = cursor[level]\n\t\t}\n\t}\n\treturn data0\n}\nvar coreRouter = function($window) {\n\tvar supportsPushState = typeof $window.history.pushState === "function"\n\tvar callAsync0 = typeof setImmediate === "function" ? setImmediate : setTimeout\n\tfunction normalize1(fragment0) {\n\t\tvar data = $window.location[fragment0].replace(/(?:%[a-f89][a-f0-9])+/gim, decodeURIComponent)\n\t\tif (fragment0 === "pathname" && data[0] !== "/") data = "/" + data\n\t\treturn data\n\t}\n\tvar asyncId\n\tfunction debounceAsync(callback0) {\n\t\treturn function() {\n\t\t\tif (asyncId != null) return\n\t\t\tasyncId = callAsync0(function() {\n\t\t\t\tasyncId = null\n\t\t\t\tcallback0()\n\t\t\t})\n\t\t}\n\t}\n\tfunction parsePath(path, queryData, hashData) {\n\t\tvar queryIndex = path.indexOf("?")\n\t\tvar hashIndex = path.indexOf("#")\n\t\tvar pathEnd = queryIndex > -1 ? queryIndex : hashIndex > -1 ? hashIndex : path.length\n\t\tif (queryIndex > -1) {\n\t\t\tvar queryEnd = hashIndex > -1 ? hashIndex : path.length\n\t\t\tvar queryParams = parseQueryString(path.slice(queryIndex + 1, queryEnd))\n\t\t\tfor (var key4 in queryParams) queryData[key4] = queryParams[key4]\n\t\t}\n\t\tif (hashIndex > -1) {\n\t\t\tvar hashParams = parseQueryString(path.slice(hashIndex + 1))\n\t\t\tfor (var key4 in hashParams) hashData[key4] = hashParams[key4]\n\t\t}\n\t\treturn path.slice(0, pathEnd)\n\t}\n\tvar router = {prefix: "#!"}\n\trouter.getPath = function() {\n\t\tvar type2 = router.prefix.charAt(0)\n\t\tswitch (type2) {\n\t\t\tcase "#": return normalize1("hash").slice(router.prefix.length)\n\t\t\tcase "?": return normalize1("search").slice(router.prefix.length) + normalize1("hash")\n\t\t\tdefault: return normalize1("pathname").slice(router.prefix.length) + normalize1("search") + normalize1("hash")\n\t\t}\n\t}\n\trouter.setPath = function(path, data, options) {\n\t\tvar queryData = {}, hashData = {}\n\t\tpath = parsePath(path, queryData, hashData)\n\t\tif (data != null) {\n\t\t\tfor (var key4 in data) queryData[key4] = data[key4]\n\t\t\tpath = path.replace(/:([^\\/]+)/g, function(match2, token) {\n\t\t\t\tdelete queryData[token]\n\t\t\t\treturn data[token]\n\t\t\t})\n\t\t}\n\t\tvar query = buildQueryString(queryData)\n\t\tif (query) path += "?" + query\n\t\tvar hash = buildQueryString(hashData)\n\t\tif (hash) path += "#" + hash\n\t\tif (supportsPushState) {\n\t\t\tvar state = options ? options.state : null\n\t\t\tvar title = options ? options.title : null\n\t\t\t$window.onpopstate()\n\t\t\tif (options && options.replace) $window.history.replaceState(state, title, router.prefix + path)\n\t\t\telse $window.history.pushState(state, title, router.prefix + path)\n\t\t}\n\t\telse $window.location.href = router.prefix + path\n\t}\n\trouter.defineRoutes = function(routes, resolve, reject) {\n\t\tfunction resolveRoute() {\n\t\t\tvar path = router.getPath()\n\t\t\tvar params = {}\n\t\t\tvar pathname = parsePath(path, params, params)\n\t\t\tvar state = $window.history.state\n\t\t\tif (state != null) {\n\t\t\t\tfor (var k in state) params[k] = state[k]\n\t\t\t}\n\t\t\tfor (var route0 in routes) {\n\t\t\t\tvar matcher = new RegExp("^" + route0.replace(/:[^\\/]+?\\.{3}/g, "(.*?)").replace(/:[^\\/]+/g, "([^\\\\/]+)") + "\\/?$")\n\t\t\t\tif (matcher.test(pathname)) {\n\t\t\t\t\tpathname.replace(matcher, function() {\n\t\t\t\t\t\tvar keys = route0.match(/:[^\\/]+/g) || []\n\t\t\t\t\t\tvar values = [].slice.call(arguments, 1, -2)\n\t\t\t\t\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\t\t\t\t\tparams[keys[i].replace(/:|\\./g, "")] = decodeURIComponent(values[i])\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresolve(routes[route0], params, path, route0)\n\t\t\t\t\t})\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\treject(path, params)\n\t\t}\n\t\tif (supportsPushState) $window.onpopstate = debounceAsync(resolveRoute)\n\t\telse if (router.prefix.charAt(0) === "#") $window.onhashchange = resolveRoute\n\t\tresolveRoute()\n\t}\n\treturn router\n}\nvar _20 = function($window, redrawService0) {\n\tvar routeService = coreRouter($window)\n\tvar identity = function(v) {return v}\n\tvar render1, component, attrs3, currentPath, lastUpdate\n\tvar route = function(root, defaultRoute, routes) {\n\t\tif (root == null) throw new Error("Ensure the DOM element that was passed to `m.route` is not undefined")\n\t\tvar run1 = function() {\n\t\t\tif (render1 != null) redrawService0.render(root, render1(Vnode(component, attrs3.key, attrs3)))\n\t\t}\n\t\tvar bail = function(path) {\n\t\t\tif (path !== defaultRoute) routeService.setPath(defaultRoute, null, {replace: true})\n\t\t\telse throw new Error("Could not resolve default route " + defaultRoute)\n\t\t}\n\t\trouteService.defineRoutes(routes, function(payload, params, path) {\n\t\t\tvar update = lastUpdate = function(routeResolver, comp) {\n\t\t\t\tif (update !== lastUpdate) return\n\t\t\t\tcomponent = comp != null && (typeof comp.view === "function" || typeof comp === "function")? comp : "div"\n\t\t\t\tattrs3 = params, currentPath = path, lastUpdate = null\n\t\t\t\trender1 = (routeResolver.render || identity).bind(routeResolver)\n\t\t\t\trun1()\n\t\t\t}\n\t\t\tif (payload.view || typeof payload === "function") update({}, payload)\n\t\t\telse {\n\t\t\t\tif (payload.onmatch) {\n\t\t\t\t\tPromise.resolve(payload.onmatch(params, path)).then(function(resolved) {\n\t\t\t\t\t\tupdate(payload, resolved)\n\t\t\t\t\t}, bail)\n\t\t\t\t}\n\t\t\t\telse update(payload, "div")\n\t\t\t}\n\t\t}, bail)\n\t\tredrawService0.subscribe(root, run1)\n\t}\n\troute.set = function(path, data, options) {\n\t\tif (lastUpdate != null) {\n\t\t\toptions = options || {}\n\t\t\toptions.replace = true\n\t\t}\n\t\tlastUpdate = null\n\t\trouteService.setPath(path, data, options)\n\t}\n\troute.get = function() {return currentPath}\n\troute.prefix = function(prefix0) {routeService.prefix = prefix0}\n\troute.link = function(vnode1) {\n\t\tvnode1.dom.setAttribute("href", routeService.prefix + vnode1.attrs.href)\n\t\tvnode1.dom.onclick = function(e) {\n\t\t\tif (e.ctrlKey || e.metaKey || e.shiftKey || e.which === 2) return\n\t\t\te.preventDefault()\n\t\t\te.redraw = false\n\t\t\tvar href = this.getAttribute("href")\n\t\t\tif (href.indexOf(routeService.prefix) === 0) href = href.slice(routeService.prefix.length)\n\t\t\troute.set(href, undefined, undefined)\n\t\t}\n\t}\n\troute.param = function(key3) {\n\t\tif(typeof attrs3 !== "undefined" && typeof key3 !== "undefined") return attrs3[key3]\n\t\treturn attrs3\n\t}\n\treturn route\n}\nm.route = _20(window, redrawService)\nm.withAttr = function(attrName, callback1, context) {\n\treturn function(e) {\n\t\tcallback1.call(context || this, attrName in e.currentTarget ? e.currentTarget[attrName] : e.currentTarget.getAttribute(attrName))\n\t}\n}\nvar _28 = coreRenderer(window)\nm.render = _28.render\nm.redraw = redrawService.redraw\nm.request = requestService.request\nm.jsonp = requestService.jsonp\nm.parseQueryString = parseQueryString\nm.buildQueryString = buildQueryString\nm.version = "1.1.3"\nm.vnode = Vnode\nif (true) module["exports"] = m\nelse window.m = m\n}());\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(18).setImmediate, __webpack_require__(5)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21pdGhyaWwvbWl0aHJpbC5qcz9iZDQyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLDZEQUFDO0FBQ0Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxP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QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QyxpQ0FBaUMsT0FBTztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsMkRBQTJEO0FBQzNELHFGQUFxRjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG1CQUFtQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0SEFBNEg7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QyxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsRUFBRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLGNBQWM7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsSSIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiOyhmdW5jdGlvbigpIHtcblwidXNlIHN0cmljdFwiXG5mdW5jdGlvbiBWbm9kZSh0YWcsIGtleSwgYXR0cnMwLCBjaGlsZHJlbiwgdGV4dCwgZG9tKSB7XG5cdHJldHVybiB7dGFnOiB0YWcsIGtleToga2V5LCBhdHRyczogYXR0cnMwLCBjaGlsZHJlbjogY2hpbGRyZW4sIHRleHQ6IHRleHQsIGRvbTogZG9tLCBkb21TaXplOiB1bmRlZmluZWQsIHN0YXRlOiB1bmRlZmluZWQsIF9zdGF0ZTogdW5kZWZpbmVkLCBldmVudHM6IHVuZGVmaW5lZCwgaW5zdGFuY2U6IHVuZGVmaW5lZCwgc2tpcDogZmFsc2V9XG59XG5Wbm9kZS5ub3JtYWxpemUgPSBmdW5jdGlvbihub2RlKSB7XG5cdGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSByZXR1cm4gVm5vZGUoXCJbXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBWbm9kZS5ub3JtYWxpemVDaGlsZHJlbihub2RlKSwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG5cdGlmIChub2RlICE9IG51bGwgJiYgdHlwZW9mIG5vZGUgIT09IFwib2JqZWN0XCIpIHJldHVybiBWbm9kZShcIiNcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG5vZGUgPT09IGZhbHNlID8gXCJcIiA6IG5vZGUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKVxuXHRyZXR1cm4gbm9kZVxufVxuVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4gPSBmdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbikge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0Y2hpbGRyZW5baV0gPSBWbm9kZS5ub3JtYWxpemUoY2hpbGRyZW5baV0pXG5cdH1cblx0cmV0dXJuIGNoaWxkcmVuXG59XG52YXIgc2VsZWN0b3JQYXJzZXIgPSAvKD86KF58I3xcXC4pKFteI1xcLlxcW1xcXV0rKSl8KFxcWyguKz8pKD86XFxzKj1cXHMqKFwifCd8KSgoPzpcXFxcW1wiJ1xcXV18LikqPylcXDUpP1xcXSkvZ1xudmFyIHNlbGVjdG9yQ2FjaGUgPSB7fVxudmFyIGhhc093biA9IHt9Lmhhc093blByb3BlcnR5XG5mdW5jdGlvbiBjb21waWxlU2VsZWN0b3Ioc2VsZWN0b3IpIHtcblx0dmFyIG1hdGNoLCB0YWcgPSBcImRpdlwiLCBjbGFzc2VzID0gW10sIGF0dHJzID0ge31cblx0d2hpbGUgKG1hdGNoID0gc2VsZWN0b3JQYXJzZXIuZXhlYyhzZWxlY3RvcikpIHtcblx0XHR2YXIgdHlwZSA9IG1hdGNoWzFdLCB2YWx1ZSA9IG1hdGNoWzJdXG5cdFx0aWYgKHR5cGUgPT09IFwiXCIgJiYgdmFsdWUgIT09IFwiXCIpIHRhZyA9IHZhbHVlXG5cdFx0ZWxzZSBpZiAodHlwZSA9PT0gXCIjXCIpIGF0dHJzLmlkID0gdmFsdWVcblx0XHRlbHNlIGlmICh0eXBlID09PSBcIi5cIikgY2xhc3Nlcy5wdXNoKHZhbHVlKVxuXHRcdGVsc2UgaWYgKG1hdGNoWzNdWzBdID09PSBcIltcIikge1xuXHRcdFx0dmFyIGF0dHJWYWx1ZSA9IG1hdGNoWzZdXG5cdFx0XHRpZiAoYXR0clZhbHVlKSBhdHRyVmFsdWUgPSBhdHRyVmFsdWUucmVwbGFjZSgvXFxcXChbXCInXSkvZywgXCIkMVwiKS5yZXBsYWNlKC9cXFxcXFxcXC9nLCBcIlxcXFxcIilcblx0XHRcdGlmIChtYXRjaFs0XSA9PT0gXCJjbGFzc1wiKSBjbGFzc2VzLnB1c2goYXR0clZhbHVlKVxuXHRcdFx0ZWxzZSBhdHRyc1ttYXRjaFs0XV0gPSBhdHRyVmFsdWUgPT09IFwiXCIgPyBhdHRyVmFsdWUgOiBhdHRyVmFsdWUgfHwgdHJ1ZVxuXHRcdH1cblx0fVxuXHRpZiAoY2xhc3Nlcy5sZW5ndGggPiAwKSBhdHRycy5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oXCIgXCIpXG5cdHJldHVybiBzZWxlY3RvckNhY2hlW3NlbGVjdG9yXSA9IHt0YWc6IHRhZywgYXR0cnM6IGF0dHJzfVxufVxuZnVuY3Rpb24gZXhlY1NlbGVjdG9yKHN0YXRlLCBhdHRycywgY2hpbGRyZW4pIHtcblx0dmFyIGhhc0F0dHJzID0gZmFsc2UsIGNoaWxkTGlzdCwgdGV4dFxuXHR2YXIgY2xhc3NOYW1lID0gYXR0cnMuY2xhc3NOYW1lIHx8IGF0dHJzLmNsYXNzXG5cdGZvciAodmFyIGtleSBpbiBzdGF0ZS5hdHRycykge1xuXHRcdGlmIChoYXNPd24uY2FsbChzdGF0ZS5hdHRycywga2V5KSkge1xuXHRcdFx0YXR0cnNba2V5XSA9IHN0YXRlLmF0dHJzW2tleV1cblx0XHR9XG5cdH1cblx0aWYgKGNsYXNzTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0aWYgKGF0dHJzLmNsYXNzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGF0dHJzLmNsYXNzID0gdW5kZWZpbmVkXG5cdFx0XHRhdHRycy5jbGFzc05hbWUgPSBjbGFzc05hbWVcblx0XHR9XG5cdFx0aWYgKHN0YXRlLmF0dHJzLmNsYXNzTmFtZSAhPSBudWxsKSB7XG5cdFx0XHRhdHRycy5jbGFzc05hbWUgPSBzdGF0ZS5hdHRycy5jbGFzc05hbWUgKyBcIiBcIiArIGNsYXNzTmFtZVxuXHRcdH1cblx0fVxuXHRmb3IgKHZhciBrZXkgaW4gYXR0cnMpIHtcblx0XHRpZiAoaGFzT3duLmNhbGwoYXR0cnMsIGtleSkgJiYga2V5ICE9PSBcImtleVwiKSB7XG5cdFx0XHRoYXNBdHRycyA9IHRydWVcblx0XHRcdGJyZWFrXG5cdFx0fVxuXHR9XG5cdGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJiBjaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgY2hpbGRyZW5bMF0gIT0gbnVsbCAmJiBjaGlsZHJlblswXS50YWcgPT09IFwiI1wiKSB7XG5cdFx0dGV4dCA9IGNoaWxkcmVuWzBdLmNoaWxkcmVuXG5cdH0gZWxzZSB7XG5cdFx0Y2hpbGRMaXN0ID0gY2hpbGRyZW5cblx0fVxuXHRyZXR1cm4gVm5vZGUoc3RhdGUudGFnLCBhdHRycy5rZXksIGhhc0F0dHJzID8gYXR0cnMgOiB1bmRlZmluZWQsIGNoaWxkTGlzdCwgdGV4dClcbn1cbmZ1bmN0aW9uIGh5cGVyc2NyaXB0KHNlbGVjdG9yKSB7XG5cdC8vIEJlY2F1c2Ugc2xvcHB5IG1vZGUgc3Vja3Ncblx0dmFyIGF0dHJzID0gYXJndW1lbnRzWzFdLCBzdGFydCA9IDIsIGNoaWxkcmVuXG5cdGlmIChzZWxlY3RvciA9PSBudWxsIHx8IHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygc2VsZWN0b3IgIT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygc2VsZWN0b3IudmlldyAhPT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0dGhyb3cgRXJyb3IoXCJUaGUgc2VsZWN0b3IgbXVzdCBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgYSBjb21wb25lbnQuXCIpO1xuXHR9XG5cdGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIpIHtcblx0XHR2YXIgY2FjaGVkID0gc2VsZWN0b3JDYWNoZVtzZWxlY3Rvcl0gfHwgY29tcGlsZVNlbGVjdG9yKHNlbGVjdG9yKVxuXHR9XG5cdGlmIChhdHRycyA9PSBudWxsKSB7XG5cdFx0YXR0cnMgPSB7fVxuXHR9IGVsc2UgaWYgKHR5cGVvZiBhdHRycyAhPT0gXCJvYmplY3RcIiB8fCBhdHRycy50YWcgIT0gbnVsbCB8fCBBcnJheS5pc0FycmF5KGF0dHJzKSkge1xuXHRcdGF0dHJzID0ge31cblx0XHRzdGFydCA9IDFcblx0fVxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gc3RhcnQgKyAxKSB7XG5cdFx0Y2hpbGRyZW4gPSBhcmd1bWVudHNbc3RhcnRdXG5cdFx0aWYgKCFBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkgY2hpbGRyZW4gPSBbY2hpbGRyZW5dXG5cdH0gZWxzZSB7XG5cdFx0Y2hpbGRyZW4gPSBbXVxuXHRcdHdoaWxlIChzdGFydCA8IGFyZ3VtZW50cy5sZW5ndGgpIGNoaWxkcmVuLnB1c2goYXJndW1lbnRzW3N0YXJ0KytdKVxuXHR9XG5cdHZhciBub3JtYWxpemVkID0gVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pXG5cdGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIpIHtcblx0XHRyZXR1cm4gZXhlY1NlbGVjdG9yKGNhY2hlZCwgYXR0cnMsIG5vcm1hbGl6ZWQpXG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIFZub2RlKHNlbGVjdG9yLCBhdHRycy5rZXksIGF0dHJzLCBub3JtYWxpemVkKVxuXHR9XG59XG5oeXBlcnNjcmlwdC50cnVzdCA9IGZ1bmN0aW9uKGh0bWwpIHtcblx0aWYgKGh0bWwgPT0gbnVsbCkgaHRtbCA9IFwiXCJcblx0cmV0dXJuIFZub2RlKFwiPFwiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaHRtbCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG59XG5oeXBlcnNjcmlwdC5mcmFnbWVudCA9IGZ1bmN0aW9uKGF0dHJzMSwgY2hpbGRyZW4pIHtcblx0cmV0dXJuIFZub2RlKFwiW1wiLCBhdHRyczEua2V5LCBhdHRyczEsIFZub2RlLm5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKSwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG59XG52YXIgbSA9IGh5cGVyc2NyaXB0XG4vKiogQGNvbnN0cnVjdG9yICovXG52YXIgUHJvbWlzZVBvbHlmaWxsID0gZnVuY3Rpb24oZXhlY3V0b3IpIHtcblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIFByb21pc2VQb2x5ZmlsbCkpIHRocm93IG5ldyBFcnJvcihcIlByb21pc2UgbXVzdCBiZSBjYWxsZWQgd2l0aCBgbmV3YFwiKVxuXHRpZiAodHlwZW9mIGV4ZWN1dG9yICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJleGVjdXRvciBtdXN0IGJlIGEgZnVuY3Rpb25cIilcblx0dmFyIHNlbGYgPSB0aGlzLCByZXNvbHZlcnMgPSBbXSwgcmVqZWN0b3JzID0gW10sIHJlc29sdmVDdXJyZW50ID0gaGFuZGxlcihyZXNvbHZlcnMsIHRydWUpLCByZWplY3RDdXJyZW50ID0gaGFuZGxlcihyZWplY3RvcnMsIGZhbHNlKVxuXHR2YXIgaW5zdGFuY2UgPSBzZWxmLl9pbnN0YW5jZSA9IHtyZXNvbHZlcnM6IHJlc29sdmVycywgcmVqZWN0b3JzOiByZWplY3RvcnN9XG5cdHZhciBjYWxsQXN5bmMgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBzZXRJbW1lZGlhdGUgOiBzZXRUaW1lb3V0XG5cdGZ1bmN0aW9uIGhhbmRsZXIobGlzdCwgc2hvdWxkQWJzb3JiKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGV4ZWN1dGUodmFsdWUpIHtcblx0XHRcdHZhciB0aGVuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAoc2hvdWxkQWJzb3JiICYmIHZhbHVlICE9IG51bGwgJiYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikgJiYgdHlwZW9mICh0aGVuID0gdmFsdWUudGhlbikgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdGlmICh2YWx1ZSA9PT0gc2VsZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByb21pc2UgY2FuJ3QgYmUgcmVzb2x2ZWQgdy8gaXRzZWxmXCIpXG5cdFx0XHRcdFx0ZXhlY3V0ZU9uY2UodGhlbi5iaW5kKHZhbHVlKSlcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRjYWxsQXN5bmMoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRpZiAoIXNob3VsZEFic29yYiAmJiBsaXN0Lmxlbmd0aCA9PT0gMCkgY29uc29sZS5lcnJvcihcIlBvc3NpYmxlIHVuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbjpcIiwgdmFsdWUpXG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIGxpc3RbaV0odmFsdWUpXG5cdFx0XHRcdFx0XHRyZXNvbHZlcnMubGVuZ3RoID0gMCwgcmVqZWN0b3JzLmxlbmd0aCA9IDBcblx0XHRcdFx0XHRcdGluc3RhbmNlLnN0YXRlID0gc2hvdWxkQWJzb3JiXG5cdFx0XHRcdFx0XHRpbnN0YW5jZS5yZXRyeSA9IGZ1bmN0aW9uKCkge2V4ZWN1dGUodmFsdWUpfVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGNhdGNoIChlKSB7XG5cdFx0XHRcdHJlamVjdEN1cnJlbnQoZSlcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gZXhlY3V0ZU9uY2UodGhlbikge1xuXHRcdHZhciBydW5zID0gMFxuXHRcdGZ1bmN0aW9uIHJ1bihmbikge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdGlmIChydW5zKysgPiAwKSByZXR1cm5cblx0XHRcdFx0Zm4odmFsdWUpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHZhciBvbmVycm9yID0gcnVuKHJlamVjdEN1cnJlbnQpXG5cdFx0dHJ5IHt0aGVuKHJ1bihyZXNvbHZlQ3VycmVudCksIG9uZXJyb3IpfSBjYXRjaCAoZSkge29uZXJyb3IoZSl9XG5cdH1cblx0ZXhlY3V0ZU9uY2UoZXhlY3V0b3IpXG59XG5Qcm9taXNlUG9seWZpbGwucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbihvbkZ1bGZpbGxlZCwgb25SZWplY3Rpb24pIHtcblx0dmFyIHNlbGYgPSB0aGlzLCBpbnN0YW5jZSA9IHNlbGYuX2luc3RhbmNlXG5cdGZ1bmN0aW9uIGhhbmRsZShjYWxsYmFjaywgbGlzdCwgbmV4dCwgc3RhdGUpIHtcblx0XHRsaXN0LnB1c2goZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikgbmV4dCh2YWx1ZSlcblx0XHRcdGVsc2UgdHJ5IHtyZXNvbHZlTmV4dChjYWxsYmFjayh2YWx1ZSkpfSBjYXRjaCAoZSkge2lmIChyZWplY3ROZXh0KSByZWplY3ROZXh0KGUpfVxuXHRcdH0pXG5cdFx0aWYgKHR5cGVvZiBpbnN0YW5jZS5yZXRyeSA9PT0gXCJmdW5jdGlvblwiICYmIHN0YXRlID09PSBpbnN0YW5jZS5zdGF0ZSkgaW5zdGFuY2UucmV0cnkoKVxuXHR9XG5cdHZhciByZXNvbHZlTmV4dCwgcmVqZWN0TmV4dFxuXHR2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlUG9seWZpbGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7cmVzb2x2ZU5leHQgPSByZXNvbHZlLCByZWplY3ROZXh0ID0gcmVqZWN0fSlcblx0aGFuZGxlKG9uRnVsZmlsbGVkLCBpbnN0YW5jZS5yZXNvbHZlcnMsIHJlc29sdmVOZXh0LCB0cnVlKSwgaGFuZGxlKG9uUmVqZWN0aW9uLCBpbnN0YW5jZS5yZWplY3RvcnMsIHJlamVjdE5leHQsIGZhbHNlKVxuXHRyZXR1cm4gcHJvbWlzZVxufVxuUHJvbWlzZVBvbHlmaWxsLnByb3RvdHlwZS5jYXRjaCA9IGZ1bmN0aW9uKG9uUmVqZWN0aW9uKSB7XG5cdHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3Rpb24pXG59XG5Qcm9taXNlUG9seWZpbGwucmVzb2x2ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2VQb2x5ZmlsbCkgcmV0dXJuIHZhbHVlXG5cdHJldHVybiBuZXcgUHJvbWlzZVBvbHlmaWxsKGZ1bmN0aW9uKHJlc29sdmUpIHtyZXNvbHZlKHZhbHVlKX0pXG59XG5Qcm9taXNlUG9seWZpbGwucmVqZWN0ID0gZnVuY3Rpb24odmFsdWUpIHtcblx0cmV0dXJuIG5ldyBQcm9taXNlUG9seWZpbGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7cmVqZWN0KHZhbHVlKX0pXG59XG5Qcm9taXNlUG9seWZpbGwuYWxsID0gZnVuY3Rpb24obGlzdCkge1xuXHRyZXR1cm4gbmV3IFByb21pc2VQb2x5ZmlsbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHR2YXIgdG90YWwgPSBsaXN0Lmxlbmd0aCwgY291bnQgPSAwLCB2YWx1ZXMgPSBbXVxuXHRcdGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkgcmVzb2x2ZShbXSlcblx0XHRlbHNlIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdFx0KGZ1bmN0aW9uKGkpIHtcblx0XHRcdFx0ZnVuY3Rpb24gY29uc3VtZSh2YWx1ZSkge1xuXHRcdFx0XHRcdGNvdW50Kytcblx0XHRcdFx0XHR2YWx1ZXNbaV0gPSB2YWx1ZVxuXHRcdFx0XHRcdGlmIChjb3VudCA9PT0gdG90YWwpIHJlc29sdmUodmFsdWVzKVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChsaXN0W2ldICE9IG51bGwgJiYgKHR5cGVvZiBsaXN0W2ldID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBsaXN0W2ldID09PSBcImZ1bmN0aW9uXCIpICYmIHR5cGVvZiBsaXN0W2ldLnRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdGxpc3RbaV0udGhlbihjb25zdW1lLCByZWplY3QpXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBjb25zdW1lKGxpc3RbaV0pXG5cdFx0XHR9KShpKVxuXHRcdH1cblx0fSlcbn1cblByb21pc2VQb2x5ZmlsbC5yYWNlID0gZnVuY3Rpb24obGlzdCkge1xuXHRyZXR1cm4gbmV3IFByb21pc2VQb2x5ZmlsbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHRcdGxpc3RbaV0udGhlbihyZXNvbHZlLCByZWplY3QpXG5cdFx0fVxuXHR9KVxufVxuaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcblx0aWYgKHR5cGVvZiB3aW5kb3cuUHJvbWlzZSA9PT0gXCJ1bmRlZmluZWRcIikgd2luZG93LlByb21pc2UgPSBQcm9taXNlUG9seWZpbGxcblx0dmFyIFByb21pc2VQb2x5ZmlsbCA9IHdpbmRvdy5Qcm9taXNlXG59IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcblx0aWYgKHR5cGVvZiBnbG9iYWwuUHJvbWlzZSA9PT0gXCJ1bmRlZmluZWRcIikgZ2xvYmFsLlByb21pc2UgPSBQcm9taXNlUG9seWZpbGxcblx0dmFyIFByb21pc2VQb2x5ZmlsbCA9IGdsb2JhbC5Qcm9taXNlXG59IGVsc2Uge1xufVxudmFyIGJ1aWxkUXVlcnlTdHJpbmcgPSBmdW5jdGlvbihvYmplY3QpIHtcblx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpICE9PSBcIltvYmplY3QgT2JqZWN0XVwiKSByZXR1cm4gXCJcIlxuXHR2YXIgYXJncyA9IFtdXG5cdGZvciAodmFyIGtleTAgaW4gb2JqZWN0KSB7XG5cdFx0ZGVzdHJ1Y3R1cmUoa2V5MCwgb2JqZWN0W2tleTBdKVxuXHR9XG5cdHJldHVybiBhcmdzLmpvaW4oXCImXCIpXG5cdGZ1bmN0aW9uIGRlc3RydWN0dXJlKGtleTAsIHZhbHVlKSB7XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGRlc3RydWN0dXJlKGtleTAgKyBcIltcIiArIGkgKyBcIl1cIiwgdmFsdWVbaV0pXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09IFwiW29iamVjdCBPYmplY3RdXCIpIHtcblx0XHRcdGZvciAodmFyIGkgaW4gdmFsdWUpIHtcblx0XHRcdFx0ZGVzdHJ1Y3R1cmUoa2V5MCArIFwiW1wiICsgaSArIFwiXVwiLCB2YWx1ZVtpXSlcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBhcmdzLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleTApICsgKHZhbHVlICE9IG51bGwgJiYgdmFsdWUgIT09IFwiXCIgPyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkgOiBcIlwiKSlcblx0fVxufVxudmFyIEZJTEVfUFJPVE9DT0xfUkVHRVggPSBuZXcgUmVnRXhwKFwiXmZpbGU6Ly9cIiwgXCJpXCIpXG52YXIgXzggPSBmdW5jdGlvbigkd2luZG93LCBQcm9taXNlKSB7XG5cdHZhciBjYWxsYmFja0NvdW50ID0gMFxuXHR2YXIgb25jb21wbGV0aW9uXG5cdGZ1bmN0aW9uIHNldENvbXBsZXRpb25DYWxsYmFjayhjYWxsYmFjaykge29uY29tcGxldGlvbiA9IGNhbGxiYWNrfVxuXHRmdW5jdGlvbiBmaW5hbGl6ZXIoKSB7XG5cdFx0dmFyIGNvdW50ID0gMFxuXHRcdGZ1bmN0aW9uIGNvbXBsZXRlKCkge2lmICgtLWNvdW50ID09PSAwICYmIHR5cGVvZiBvbmNvbXBsZXRpb24gPT09IFwiZnVuY3Rpb25cIikgb25jb21wbGV0aW9uKCl9XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGZpbmFsaXplKHByb21pc2UwKSB7XG5cdFx0XHR2YXIgdGhlbjAgPSBwcm9taXNlMC50aGVuXG5cdFx0XHRwcm9taXNlMC50aGVuID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNvdW50Kytcblx0XHRcdFx0dmFyIG5leHQgPSB0aGVuMC5hcHBseShwcm9taXNlMCwgYXJndW1lbnRzKVxuXHRcdFx0XHRuZXh0LnRoZW4oY29tcGxldGUsIGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0XHRjb21wbGV0ZSgpXG5cdFx0XHRcdFx0aWYgKGNvdW50ID09PSAwKSB0aHJvdyBlXG5cdFx0XHRcdH0pXG5cdFx0XHRcdHJldHVybiBmaW5hbGl6ZShuZXh0KVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHByb21pc2UwXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIG5vcm1hbGl6ZShhcmdzLCBleHRyYSkge1xuXHRcdGlmICh0eXBlb2YgYXJncyA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0dmFyIHVybCA9IGFyZ3Ncblx0XHRcdGFyZ3MgPSBleHRyYSB8fCB7fVxuXHRcdFx0aWYgKGFyZ3MudXJsID09IG51bGwpIGFyZ3MudXJsID0gdXJsXG5cdFx0fVxuXHRcdHJldHVybiBhcmdzXG5cdH1cblx0ZnVuY3Rpb24gcmVxdWVzdChhcmdzLCBleHRyYSkge1xuXHRcdHZhciBmaW5hbGl6ZSA9IGZpbmFsaXplcigpXG5cdFx0YXJncyA9IG5vcm1hbGl6ZShhcmdzLCBleHRyYSlcblx0XHR2YXIgcHJvbWlzZTAgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHRcdGlmIChhcmdzLm1ldGhvZCA9PSBudWxsKSBhcmdzLm1ldGhvZCA9IFwiR0VUXCJcblx0XHRcdGFyZ3MubWV0aG9kID0gYXJncy5tZXRob2QudG9VcHBlckNhc2UoKVxuXHRcdFx0dmFyIHVzZUJvZHkgPSAoYXJncy5tZXRob2QgPT09IFwiR0VUXCIgfHwgYXJncy5tZXRob2QgPT09IFwiVFJBQ0VcIikgPyBmYWxzZSA6ICh0eXBlb2YgYXJncy51c2VCb2R5ID09PSBcImJvb2xlYW5cIiA/IGFyZ3MudXNlQm9keSA6IHRydWUpXG5cdFx0XHRpZiAodHlwZW9mIGFyZ3Muc2VyaWFsaXplICE9PSBcImZ1bmN0aW9uXCIpIGFyZ3Muc2VyaWFsaXplID0gdHlwZW9mIEZvcm1EYXRhICE9PSBcInVuZGVmaW5lZFwiICYmIGFyZ3MuZGF0YSBpbnN0YW5jZW9mIEZvcm1EYXRhID8gZnVuY3Rpb24odmFsdWUpIHtyZXR1cm4gdmFsdWV9IDogSlNPTi5zdHJpbmdpZnlcblx0XHRcdGlmICh0eXBlb2YgYXJncy5kZXNlcmlhbGl6ZSAhPT0gXCJmdW5jdGlvblwiKSBhcmdzLmRlc2VyaWFsaXplID0gZGVzZXJpYWxpemVcblx0XHRcdGlmICh0eXBlb2YgYXJncy5leHRyYWN0ICE9PSBcImZ1bmN0aW9uXCIpIGFyZ3MuZXh0cmFjdCA9IGV4dHJhY3Rcblx0XHRcdGFyZ3MudXJsID0gaW50ZXJwb2xhdGUoYXJncy51cmwsIGFyZ3MuZGF0YSlcblx0XHRcdGlmICh1c2VCb2R5KSBhcmdzLmRhdGEgPSBhcmdzLnNlcmlhbGl6ZShhcmdzLmRhdGEpXG5cdFx0XHRlbHNlIGFyZ3MudXJsID0gYXNzZW1ibGUoYXJncy51cmwsIGFyZ3MuZGF0YSlcblx0XHRcdHZhciB4aHIgPSBuZXcgJHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpLFxuXHRcdFx0XHRhYm9ydGVkID0gZmFsc2UsXG5cdFx0XHRcdF9hYm9ydCA9IHhoci5hYm9ydFxuXHRcdFx0eGhyLmFib3J0ID0gZnVuY3Rpb24gYWJvcnQoKSB7XG5cdFx0XHRcdGFib3J0ZWQgPSB0cnVlXG5cdFx0XHRcdF9hYm9ydC5jYWxsKHhocilcblx0XHRcdH1cblx0XHRcdHhoci5vcGVuKGFyZ3MubWV0aG9kLCBhcmdzLnVybCwgdHlwZW9mIGFyZ3MuYXN5bmMgPT09IFwiYm9vbGVhblwiID8gYXJncy5hc3luYyA6IHRydWUsIHR5cGVvZiBhcmdzLnVzZXIgPT09IFwic3RyaW5nXCIgPyBhcmdzLnVzZXIgOiB1bmRlZmluZWQsIHR5cGVvZiBhcmdzLnBhc3N3b3JkID09PSBcInN0cmluZ1wiID8gYXJncy5wYXNzd29yZCA6IHVuZGVmaW5lZClcblx0XHRcdGlmIChhcmdzLnNlcmlhbGl6ZSA9PT0gSlNPTi5zdHJpbmdpZnkgJiYgdXNlQm9keSkge1xuXHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiLCBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIilcblx0XHRcdH1cblx0XHRcdGlmIChhcmdzLmRlc2VyaWFsaXplID09PSBkZXNlcmlhbGl6ZSkge1xuXHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkFjY2VwdFwiLCBcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvKlwiKVxuXHRcdFx0fVxuXHRcdFx0aWYgKGFyZ3Mud2l0aENyZWRlbnRpYWxzKSB4aHIud2l0aENyZWRlbnRpYWxzID0gYXJncy53aXRoQ3JlZGVudGlhbHNcblx0XHRcdGZvciAodmFyIGtleSBpbiBhcmdzLmhlYWRlcnMpIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFyZ3MuaGVhZGVycywga2V5KSkge1xuXHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIGFyZ3MuaGVhZGVyc1trZXldKVxuXHRcdFx0fVxuXHRcdFx0aWYgKHR5cGVvZiBhcmdzLmNvbmZpZyA9PT0gXCJmdW5jdGlvblwiKSB4aHIgPSBhcmdzLmNvbmZpZyh4aHIsIGFyZ3MpIHx8IHhoclxuXHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBEb24ndCB0aHJvdyBlcnJvcnMgb24geGhyLmFib3J0KCkuXG5cdFx0XHRcdGlmKGFib3J0ZWQpIHJldHVyblxuXHRcdFx0XHRpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0dmFyIHJlc3BvbnNlID0gKGFyZ3MuZXh0cmFjdCAhPT0gZXh0cmFjdCkgPyBhcmdzLmV4dHJhY3QoeGhyLCBhcmdzKSA6IGFyZ3MuZGVzZXJpYWxpemUoYXJncy5leHRyYWN0KHhociwgYXJncykpXG5cdFx0XHRcdFx0XHRpZiAoKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDApIHx8IHhoci5zdGF0dXMgPT09IDMwNCB8fCBGSUxFX1BST1RPQ09MX1JFR0VYLnRlc3QoYXJncy51cmwpKSB7XG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoY2FzdChhcmdzLnR5cGUsIHJlc3BvbnNlKSlcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR2YXIgZXJyb3IgPSBuZXcgRXJyb3IoeGhyLnJlc3BvbnNlVGV4dClcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIga2V5IGluIHJlc3BvbnNlKSBlcnJvcltrZXldID0gcmVzcG9uc2Vba2V5XVxuXHRcdFx0XHRcdFx0XHRyZWplY3QoZXJyb3IpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0XHRyZWplY3QoZSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICh1c2VCb2R5ICYmIChhcmdzLmRhdGEgIT0gbnVsbCkpIHhoci5zZW5kKGFyZ3MuZGF0YSlcblx0XHRcdGVsc2UgeGhyLnNlbmQoKVxuXHRcdH0pXG5cdFx0cmV0dXJuIGFyZ3MuYmFja2dyb3VuZCA9PT0gdHJ1ZSA/IHByb21pc2UwIDogZmluYWxpemUocHJvbWlzZTApXG5cdH1cblx0ZnVuY3Rpb24ganNvbnAoYXJncywgZXh0cmEpIHtcblx0XHR2YXIgZmluYWxpemUgPSBmaW5hbGl6ZXIoKVxuXHRcdGFyZ3MgPSBub3JtYWxpemUoYXJncywgZXh0cmEpXG5cdFx0dmFyIHByb21pc2UwID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0XHR2YXIgY2FsbGJhY2tOYW1lID0gYXJncy5jYWxsYmFja05hbWUgfHwgXCJfbWl0aHJpbF9cIiArIE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDFlMTYpICsgXCJfXCIgKyBjYWxsYmFja0NvdW50Kytcblx0XHRcdHZhciBzY3JpcHQgPSAkd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIilcblx0XHRcdCR3aW5kb3dbY2FsbGJhY2tOYW1lXSA9IGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdFx0c2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KVxuXHRcdFx0XHRyZXNvbHZlKGNhc3QoYXJncy50eXBlLCBkYXRhKSlcblx0XHRcdFx0ZGVsZXRlICR3aW5kb3dbY2FsbGJhY2tOYW1lXVxuXHRcdFx0fVxuXHRcdFx0c2NyaXB0Lm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KVxuXHRcdFx0XHRyZWplY3QobmV3IEVycm9yKFwiSlNPTlAgcmVxdWVzdCBmYWlsZWRcIikpXG5cdFx0XHRcdGRlbGV0ZSAkd2luZG93W2NhbGxiYWNrTmFtZV1cblx0XHRcdH1cblx0XHRcdGlmIChhcmdzLmRhdGEgPT0gbnVsbCkgYXJncy5kYXRhID0ge31cblx0XHRcdGFyZ3MudXJsID0gaW50ZXJwb2xhdGUoYXJncy51cmwsIGFyZ3MuZGF0YSlcblx0XHRcdGFyZ3MuZGF0YVthcmdzLmNhbGxiYWNrS2V5IHx8IFwiY2FsbGJhY2tcIl0gPSBjYWxsYmFja05hbWVcblx0XHRcdHNjcmlwdC5zcmMgPSBhc3NlbWJsZShhcmdzLnVybCwgYXJncy5kYXRhKVxuXHRcdFx0JHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoc2NyaXB0KVxuXHRcdH0pXG5cdFx0cmV0dXJuIGFyZ3MuYmFja2dyb3VuZCA9PT0gdHJ1ZT8gcHJvbWlzZTAgOiBmaW5hbGl6ZShwcm9taXNlMClcblx0fVxuXHRmdW5jdGlvbiBpbnRlcnBvbGF0ZSh1cmwsIGRhdGEpIHtcblx0XHRpZiAoZGF0YSA9PSBudWxsKSByZXR1cm4gdXJsXG5cdFx0dmFyIHRva2VucyA9IHVybC5tYXRjaCgvOlteXFwvXSsvZ2kpIHx8IFtdXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBrZXkgPSB0b2tlbnNbaV0uc2xpY2UoMSlcblx0XHRcdGlmIChkYXRhW2tleV0gIT0gbnVsbCkge1xuXHRcdFx0XHR1cmwgPSB1cmwucmVwbGFjZSh0b2tlbnNbaV0sIGRhdGFba2V5XSlcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHVybFxuXHR9XG5cdGZ1bmN0aW9uIGFzc2VtYmxlKHVybCwgZGF0YSkge1xuXHRcdHZhciBxdWVyeXN0cmluZyA9IGJ1aWxkUXVlcnlTdHJpbmcoZGF0YSlcblx0XHRpZiAocXVlcnlzdHJpbmcgIT09IFwiXCIpIHtcblx0XHRcdHZhciBwcmVmaXggPSB1cmwuaW5kZXhPZihcIj9cIikgPCAwID8gXCI/XCIgOiBcIiZcIlxuXHRcdFx0dXJsICs9IHByZWZpeCArIHF1ZXJ5c3RyaW5nXG5cdFx0fVxuXHRcdHJldHVybiB1cmxcblx0fVxuXHRmdW5jdGlvbiBkZXNlcmlhbGl6ZShkYXRhKSB7XG5cdFx0dHJ5IHtyZXR1cm4gZGF0YSAhPT0gXCJcIiA/IEpTT04ucGFyc2UoZGF0YSkgOiBudWxsfVxuXHRcdGNhdGNoIChlKSB7dGhyb3cgbmV3IEVycm9yKGRhdGEpfVxuXHR9XG5cdGZ1bmN0aW9uIGV4dHJhY3QoeGhyKSB7cmV0dXJuIHhoci5yZXNwb25zZVRleHR9XG5cdGZ1bmN0aW9uIGNhc3QodHlwZTAsIGRhdGEpIHtcblx0XHRpZiAodHlwZW9mIHR5cGUwID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGRhdGFbaV0gPSBuZXcgdHlwZTAoZGF0YVtpXSlcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSByZXR1cm4gbmV3IHR5cGUwKGRhdGEpXG5cdFx0fVxuXHRcdHJldHVybiBkYXRhXG5cdH1cblx0cmV0dXJuIHtyZXF1ZXN0OiByZXF1ZXN0LCBqc29ucDoganNvbnAsIHNldENvbXBsZXRpb25DYWxsYmFjazogc2V0Q29tcGxldGlvbkNhbGxiYWNrfVxufVxudmFyIHJlcXVlc3RTZXJ2aWNlID0gXzgod2luZG93LCBQcm9taXNlUG9seWZpbGwpXG52YXIgY29yZVJlbmRlcmVyID0gZnVuY3Rpb24oJHdpbmRvdykge1xuXHR2YXIgJGRvYyA9ICR3aW5kb3cuZG9jdW1lbnRcblx0dmFyICRlbXB0eUZyYWdtZW50ID0gJGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcblx0dmFyIG5hbWVTcGFjZSA9IHtcblx0XHRzdmc6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcblx0XHRtYXRoOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIlxuXHR9XG5cdHZhciBvbmV2ZW50XG5cdGZ1bmN0aW9uIHNldEV2ZW50Q2FsbGJhY2soY2FsbGJhY2spIHtyZXR1cm4gb25ldmVudCA9IGNhbGxiYWNrfVxuXHRmdW5jdGlvbiBnZXROYW1lU3BhY2Uodm5vZGUpIHtcblx0XHRyZXR1cm4gdm5vZGUuYXR0cnMgJiYgdm5vZGUuYXR0cnMueG1sbnMgfHwgbmFtZVNwYWNlW3Zub2RlLnRhZ11cblx0fVxuXHQvL2NyZWF0ZVxuXHRmdW5jdGlvbiBjcmVhdGVOb2RlcyhwYXJlbnQsIHZub2Rlcywgc3RhcnQsIGVuZCwgaG9va3MsIG5leHRTaWJsaW5nLCBucykge1xuXHRcdGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG5cdFx0XHR2YXIgdm5vZGUgPSB2bm9kZXNbaV1cblx0XHRcdGlmICh2bm9kZSAhPSBudWxsKSB7XG5cdFx0XHRcdGNyZWF0ZU5vZGUocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlTm9kZShwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKSB7XG5cdFx0dmFyIHRhZyA9IHZub2RlLnRhZ1xuXHRcdGlmICh0eXBlb2YgdGFnID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHR2bm9kZS5zdGF0ZSA9IHt9XG5cdFx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCkgaW5pdExpZmVjeWNsZSh2bm9kZS5hdHRycywgdm5vZGUsIGhvb2tzKVxuXHRcdFx0c3dpdGNoICh0YWcpIHtcblx0XHRcdFx0Y2FzZSBcIiNcIjogcmV0dXJuIGNyZWF0ZVRleHQocGFyZW50LCB2bm9kZSwgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdGNhc2UgXCI8XCI6IHJldHVybiBjcmVhdGVIVE1MKHBhcmVudCwgdm5vZGUsIG5leHRTaWJsaW5nKVxuXHRcdFx0XHRjYXNlIFwiW1wiOiByZXR1cm4gY3JlYXRlRnJhZ21lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdFx0ZGVmYXVsdDogcmV0dXJuIGNyZWF0ZUVsZW1lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSByZXR1cm4gY3JlYXRlQ29tcG9uZW50KHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlVGV4dChwYXJlbnQsIHZub2RlLCBuZXh0U2libGluZykge1xuXHRcdHZub2RlLmRvbSA9ICRkb2MuY3JlYXRlVGV4dE5vZGUodm5vZGUuY2hpbGRyZW4pXG5cdFx0aW5zZXJ0Tm9kZShwYXJlbnQsIHZub2RlLmRvbSwgbmV4dFNpYmxpbmcpXG5cdFx0cmV0dXJuIHZub2RlLmRvbVxuXHR9XG5cdGZ1bmN0aW9uIGNyZWF0ZUhUTUwocGFyZW50LCB2bm9kZSwgbmV4dFNpYmxpbmcpIHtcblx0XHR2YXIgbWF0Y2gxID0gdm5vZGUuY2hpbGRyZW4ubWF0Y2goL15cXHMqPzwoXFx3KykvaW0pIHx8IFtdXG5cdFx0dmFyIHBhcmVudDEgPSB7Y2FwdGlvbjogXCJ0YWJsZVwiLCB0aGVhZDogXCJ0YWJsZVwiLCB0Ym9keTogXCJ0YWJsZVwiLCB0Zm9vdDogXCJ0YWJsZVwiLCB0cjogXCJ0Ym9keVwiLCB0aDogXCJ0clwiLCB0ZDogXCJ0clwiLCBjb2xncm91cDogXCJ0YWJsZVwiLCBjb2w6IFwiY29sZ3JvdXBcIn1bbWF0Y2gxWzFdXSB8fCBcImRpdlwiXG5cdFx0dmFyIHRlbXAgPSAkZG9jLmNyZWF0ZUVsZW1lbnQocGFyZW50MSlcblx0XHR0ZW1wLmlubmVySFRNTCA9IHZub2RlLmNoaWxkcmVuXG5cdFx0dm5vZGUuZG9tID0gdGVtcC5maXJzdENoaWxkXG5cdFx0dm5vZGUuZG9tU2l6ZSA9IHRlbXAuY2hpbGROb2Rlcy5sZW5ndGhcblx0XHR2YXIgZnJhZ21lbnQgPSAkZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuXHRcdHZhciBjaGlsZFxuXHRcdHdoaWxlIChjaGlsZCA9IHRlbXAuZmlyc3RDaGlsZCkge1xuXHRcdFx0ZnJhZ21lbnQuYXBwZW5kQ2hpbGQoY2hpbGQpXG5cdFx0fVxuXHRcdGluc2VydE5vZGUocGFyZW50LCBmcmFnbWVudCwgbmV4dFNpYmxpbmcpXG5cdFx0cmV0dXJuIGZyYWdtZW50XG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlRnJhZ21lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZykge1xuXHRcdHZhciBmcmFnbWVudCA9ICRkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG5cdFx0aWYgKHZub2RlLmNoaWxkcmVuICE9IG51bGwpIHtcblx0XHRcdHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuXG5cdFx0XHRjcmVhdGVOb2RlcyhmcmFnbWVudCwgY2hpbGRyZW4sIDAsIGNoaWxkcmVuLmxlbmd0aCwgaG9va3MsIG51bGwsIG5zKVxuXHRcdH1cblx0XHR2bm9kZS5kb20gPSBmcmFnbWVudC5maXJzdENoaWxkXG5cdFx0dm5vZGUuZG9tU2l6ZSA9IGZyYWdtZW50LmNoaWxkTm9kZXMubGVuZ3RoXG5cdFx0aW5zZXJ0Tm9kZShwYXJlbnQsIGZyYWdtZW50LCBuZXh0U2libGluZylcblx0XHRyZXR1cm4gZnJhZ21lbnRcblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVFbGVtZW50KHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpIHtcblx0XHR2YXIgdGFnID0gdm5vZGUudGFnXG5cdFx0dmFyIGF0dHJzMiA9IHZub2RlLmF0dHJzXG5cdFx0dmFyIGlzID0gYXR0cnMyICYmIGF0dHJzMi5pc1xuXHRcdG5zID0gZ2V0TmFtZVNwYWNlKHZub2RlKSB8fCBuc1xuXHRcdHZhciBlbGVtZW50ID0gbnMgP1xuXHRcdFx0aXMgPyAkZG9jLmNyZWF0ZUVsZW1lbnROUyhucywgdGFnLCB7aXM6IGlzfSkgOiAkZG9jLmNyZWF0ZUVsZW1lbnROUyhucywgdGFnKSA6XG5cdFx0XHRpcyA/ICRkb2MuY3JlYXRlRWxlbWVudCh0YWcsIHtpczogaXN9KSA6ICRkb2MuY3JlYXRlRWxlbWVudCh0YWcpXG5cdFx0dm5vZGUuZG9tID0gZWxlbWVudFxuXHRcdGlmIChhdHRyczIgIT0gbnVsbCkge1xuXHRcdFx0c2V0QXR0cnModm5vZGUsIGF0dHJzMiwgbnMpXG5cdFx0fVxuXHRcdGluc2VydE5vZGUocGFyZW50LCBlbGVtZW50LCBuZXh0U2libGluZylcblx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCAmJiB2bm9kZS5hdHRycy5jb250ZW50ZWRpdGFibGUgIT0gbnVsbCkge1xuXHRcdFx0c2V0Q29udGVudEVkaXRhYmxlKHZub2RlKVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGlmICh2bm9kZS50ZXh0ICE9IG51bGwpIHtcblx0XHRcdFx0aWYgKHZub2RlLnRleHQgIT09IFwiXCIpIGVsZW1lbnQudGV4dENvbnRlbnQgPSB2bm9kZS50ZXh0XG5cdFx0XHRcdGVsc2Ugdm5vZGUuY2hpbGRyZW4gPSBbVm5vZGUoXCIjXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB2bm9kZS50ZXh0LCB1bmRlZmluZWQsIHVuZGVmaW5lZCldXG5cdFx0XHR9XG5cdFx0XHRpZiAodm5vZGUuY2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0XHR2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlblxuXHRcdFx0XHRjcmVhdGVOb2RlcyhlbGVtZW50LCBjaGlsZHJlbiwgMCwgY2hpbGRyZW4ubGVuZ3RoLCBob29rcywgbnVsbCwgbnMpXG5cdFx0XHRcdHNldExhdGVBdHRycyh2bm9kZSlcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGVsZW1lbnRcblx0fVxuXHRmdW5jdGlvbiBpbml0Q29tcG9uZW50KHZub2RlLCBob29rcykge1xuXHRcdHZhciBzZW50aW5lbFxuXHRcdGlmICh0eXBlb2Ygdm5vZGUudGFnLnZpZXcgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0dm5vZGUuc3RhdGUgPSBPYmplY3QuY3JlYXRlKHZub2RlLnRhZylcblx0XHRcdHNlbnRpbmVsID0gdm5vZGUuc3RhdGUudmlld1xuXHRcdFx0aWYgKHNlbnRpbmVsLiQkcmVlbnRyYW50TG9jayQkICE9IG51bGwpIHJldHVybiAkZW1wdHlGcmFnbWVudFxuXHRcdFx0c2VudGluZWwuJCRyZWVudHJhbnRMb2NrJCQgPSB0cnVlXG5cdFx0fSBlbHNlIHtcblx0XHRcdHZub2RlLnN0YXRlID0gdm9pZCAwXG5cdFx0XHRzZW50aW5lbCA9IHZub2RlLnRhZ1xuXHRcdFx0aWYgKHNlbnRpbmVsLiQkcmVlbnRyYW50TG9jayQkICE9IG51bGwpIHJldHVybiAkZW1wdHlGcmFnbWVudFxuXHRcdFx0c2VudGluZWwuJCRyZWVudHJhbnRMb2NrJCQgPSB0cnVlXG5cdFx0XHR2bm9kZS5zdGF0ZSA9ICh2bm9kZS50YWcucHJvdG90eXBlICE9IG51bGwgJiYgdHlwZW9mIHZub2RlLnRhZy5wcm90b3R5cGUudmlldyA9PT0gXCJmdW5jdGlvblwiKSA/IG5ldyB2bm9kZS50YWcodm5vZGUpIDogdm5vZGUudGFnKHZub2RlKVxuXHRcdH1cblx0XHR2bm9kZS5fc3RhdGUgPSB2bm9kZS5zdGF0ZVxuXHRcdGlmICh2bm9kZS5hdHRycyAhPSBudWxsKSBpbml0TGlmZWN5Y2xlKHZub2RlLmF0dHJzLCB2bm9kZSwgaG9va3MpXG5cdFx0aW5pdExpZmVjeWNsZSh2bm9kZS5fc3RhdGUsIHZub2RlLCBob29rcylcblx0XHR2bm9kZS5pbnN0YW5jZSA9IFZub2RlLm5vcm1hbGl6ZSh2bm9kZS5fc3RhdGUudmlldy5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSkpXG5cdFx0aWYgKHZub2RlLmluc3RhbmNlID09PSB2bm9kZSkgdGhyb3cgRXJyb3IoXCJBIHZpZXcgY2Fubm90IHJldHVybiB0aGUgdm5vZGUgaXQgcmVjZWl2ZWQgYXMgYXJndW1lbnRcIilcblx0XHRzZW50aW5lbC4kJHJlZW50cmFudExvY2skJCA9IG51bGxcblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVDb21wb25lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZykge1xuXHRcdGluaXRDb21wb25lbnQodm5vZGUsIGhvb2tzKVxuXHRcdGlmICh2bm9kZS5pbnN0YW5jZSAhPSBudWxsKSB7XG5cdFx0XHR2YXIgZWxlbWVudCA9IGNyZWF0ZU5vZGUocGFyZW50LCB2bm9kZS5pbnN0YW5jZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdHZub2RlLmRvbSA9IHZub2RlLmluc3RhbmNlLmRvbVxuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IHZub2RlLmRvbSAhPSBudWxsID8gdm5vZGUuaW5zdGFuY2UuZG9tU2l6ZSA6IDBcblx0XHRcdGluc2VydE5vZGUocGFyZW50LCBlbGVtZW50LCBuZXh0U2libGluZylcblx0XHRcdHJldHVybiBlbGVtZW50XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IDBcblx0XHRcdHJldHVybiAkZW1wdHlGcmFnbWVudFxuXHRcdH1cblx0fVxuXHQvL3VwZGF0ZVxuXHRmdW5jdGlvbiB1cGRhdGVOb2RlcyhwYXJlbnQsIG9sZCwgdm5vZGVzLCByZWN5Y2xpbmcsIGhvb2tzLCBuZXh0U2libGluZywgbnMpIHtcblx0XHRpZiAob2xkID09PSB2bm9kZXMgfHwgb2xkID09IG51bGwgJiYgdm5vZGVzID09IG51bGwpIHJldHVyblxuXHRcdGVsc2UgaWYgKG9sZCA9PSBudWxsKSBjcmVhdGVOb2RlcyhwYXJlbnQsIHZub2RlcywgMCwgdm5vZGVzLmxlbmd0aCwgaG9va3MsIG5leHRTaWJsaW5nLCBucylcblx0XHRlbHNlIGlmICh2bm9kZXMgPT0gbnVsbCkgcmVtb3ZlTm9kZXMob2xkLCAwLCBvbGQubGVuZ3RoLCB2bm9kZXMpXG5cdFx0ZWxzZSB7XG5cdFx0XHRpZiAob2xkLmxlbmd0aCA9PT0gdm5vZGVzLmxlbmd0aCkge1xuXHRcdFx0XHR2YXIgaXNVbmtleWVkID0gZmFsc2Vcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB2bm9kZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRpZiAodm5vZGVzW2ldICE9IG51bGwgJiYgb2xkW2ldICE9IG51bGwpIHtcblx0XHRcdFx0XHRcdGlzVW5rZXllZCA9IHZub2Rlc1tpXS5rZXkgPT0gbnVsbCAmJiBvbGRbaV0ua2V5ID09IG51bGxcblx0XHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChpc1Vua2V5ZWQpIHtcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG9sZC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0aWYgKG9sZFtpXSA9PT0gdm5vZGVzW2ldKSBjb250aW51ZVxuXHRcdFx0XHRcdFx0ZWxzZSBpZiAob2xkW2ldID09IG51bGwgJiYgdm5vZGVzW2ldICE9IG51bGwpIGNyZWF0ZU5vZGUocGFyZW50LCB2bm9kZXNbaV0sIGhvb2tzLCBucywgZ2V0TmV4dFNpYmxpbmcob2xkLCBpICsgMSwgbmV4dFNpYmxpbmcpKVxuXHRcdFx0XHRcdFx0ZWxzZSBpZiAodm5vZGVzW2ldID09IG51bGwpIHJlbW92ZU5vZGVzKG9sZCwgaSwgaSArIDEsIHZub2Rlcylcblx0XHRcdFx0XHRcdGVsc2UgdXBkYXRlTm9kZShwYXJlbnQsIG9sZFtpXSwgdm5vZGVzW2ldLCBob29rcywgZ2V0TmV4dFNpYmxpbmcob2xkLCBpICsgMSwgbmV4dFNpYmxpbmcpLCByZWN5Y2xpbmcsIG5zKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmVjeWNsaW5nID0gcmVjeWNsaW5nIHx8IGlzUmVjeWNsYWJsZShvbGQsIHZub2Rlcylcblx0XHRcdGlmIChyZWN5Y2xpbmcpIHtcblx0XHRcdFx0dmFyIHBvb2wgPSBvbGQucG9vbFxuXHRcdFx0XHRvbGQgPSBvbGQuY29uY2F0KG9sZC5wb29sKVxuXHRcdFx0fVxuXHRcdFx0dmFyIG9sZFN0YXJ0ID0gMCwgc3RhcnQgPSAwLCBvbGRFbmQgPSBvbGQubGVuZ3RoIC0gMSwgZW5kID0gdm5vZGVzLmxlbmd0aCAtIDEsIG1hcFxuXHRcdFx0d2hpbGUgKG9sZEVuZCA+PSBvbGRTdGFydCAmJiBlbmQgPj0gc3RhcnQpIHtcblx0XHRcdFx0dmFyIG8gPSBvbGRbb2xkU3RhcnRdLCB2ID0gdm5vZGVzW3N0YXJ0XVxuXHRcdFx0XHRpZiAobyA9PT0gdiAmJiAhcmVjeWNsaW5nKSBvbGRTdGFydCsrLCBzdGFydCsrXG5cdFx0XHRcdGVsc2UgaWYgKG8gPT0gbnVsbCkgb2xkU3RhcnQrK1xuXHRcdFx0XHRlbHNlIGlmICh2ID09IG51bGwpIHN0YXJ0Kytcblx0XHRcdFx0ZWxzZSBpZiAoby5rZXkgPT09IHYua2V5KSB7XG5cdFx0XHRcdFx0dmFyIHNob3VsZFJlY3ljbGUgPSAocG9vbCAhPSBudWxsICYmIG9sZFN0YXJ0ID49IG9sZC5sZW5ndGggLSBwb29sLmxlbmd0aCkgfHwgKChwb29sID09IG51bGwpICYmIHJlY3ljbGluZylcblx0XHRcdFx0XHRvbGRTdGFydCsrLCBzdGFydCsrXG5cdFx0XHRcdFx0dXBkYXRlTm9kZShwYXJlbnQsIG8sIHYsIGhvb2tzLCBnZXROZXh0U2libGluZyhvbGQsIG9sZFN0YXJ0LCBuZXh0U2libGluZyksIHNob3VsZFJlY3ljbGUsIG5zKVxuXHRcdFx0XHRcdGlmIChyZWN5Y2xpbmcgJiYgby50YWcgPT09IHYudGFnKSBpbnNlcnROb2RlKHBhcmVudCwgdG9GcmFnbWVudChvKSwgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0dmFyIG8gPSBvbGRbb2xkRW5kXVxuXHRcdFx0XHRcdGlmIChvID09PSB2ICYmICFyZWN5Y2xpbmcpIG9sZEVuZC0tLCBzdGFydCsrXG5cdFx0XHRcdFx0ZWxzZSBpZiAobyA9PSBudWxsKSBvbGRFbmQtLVxuXHRcdFx0XHRcdGVsc2UgaWYgKHYgPT0gbnVsbCkgc3RhcnQrK1xuXHRcdFx0XHRcdGVsc2UgaWYgKG8ua2V5ID09PSB2LmtleSkge1xuXHRcdFx0XHRcdFx0dmFyIHNob3VsZFJlY3ljbGUgPSAocG9vbCAhPSBudWxsICYmIG9sZEVuZCA+PSBvbGQubGVuZ3RoIC0gcG9vbC5sZW5ndGgpIHx8ICgocG9vbCA9PSBudWxsKSAmJiByZWN5Y2xpbmcpXG5cdFx0XHRcdFx0XHR1cGRhdGVOb2RlKHBhcmVudCwgbywgdiwgaG9va3MsIGdldE5leHRTaWJsaW5nKG9sZCwgb2xkRW5kICsgMSwgbmV4dFNpYmxpbmcpLCBzaG91bGRSZWN5Y2xlLCBucylcblx0XHRcdFx0XHRcdGlmIChyZWN5Y2xpbmcgfHwgc3RhcnQgPCBlbmQpIGluc2VydE5vZGUocGFyZW50LCB0b0ZyYWdtZW50KG8pLCBnZXROZXh0U2libGluZyhvbGQsIG9sZFN0YXJ0LCBuZXh0U2libGluZykpXG5cdFx0XHRcdFx0XHRvbGRFbmQtLSwgc3RhcnQrK1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIGJyZWFrXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHdoaWxlIChvbGRFbmQgPj0gb2xkU3RhcnQgJiYgZW5kID49IHN0YXJ0KSB7XG5cdFx0XHRcdHZhciBvID0gb2xkW29sZEVuZF0sIHYgPSB2bm9kZXNbZW5kXVxuXHRcdFx0XHRpZiAobyA9PT0gdiAmJiAhcmVjeWNsaW5nKSBvbGRFbmQtLSwgZW5kLS1cblx0XHRcdFx0ZWxzZSBpZiAobyA9PSBudWxsKSBvbGRFbmQtLVxuXHRcdFx0XHRlbHNlIGlmICh2ID09IG51bGwpIGVuZC0tXG5cdFx0XHRcdGVsc2UgaWYgKG8ua2V5ID09PSB2LmtleSkge1xuXHRcdFx0XHRcdHZhciBzaG91bGRSZWN5Y2xlID0gKHBvb2wgIT0gbnVsbCAmJiBvbGRFbmQgPj0gb2xkLmxlbmd0aCAtIHBvb2wubGVuZ3RoKSB8fCAoKHBvb2wgPT0gbnVsbCkgJiYgcmVjeWNsaW5nKVxuXHRcdFx0XHRcdHVwZGF0ZU5vZGUocGFyZW50LCBvLCB2LCBob29rcywgZ2V0TmV4dFNpYmxpbmcob2xkLCBvbGRFbmQgKyAxLCBuZXh0U2libGluZyksIHNob3VsZFJlY3ljbGUsIG5zKVxuXHRcdFx0XHRcdGlmIChyZWN5Y2xpbmcgJiYgby50YWcgPT09IHYudGFnKSBpbnNlcnROb2RlKHBhcmVudCwgdG9GcmFnbWVudChvKSwgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdFx0aWYgKG8uZG9tICE9IG51bGwpIG5leHRTaWJsaW5nID0gby5kb21cblx0XHRcdFx0XHRvbGRFbmQtLSwgZW5kLS1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRpZiAoIW1hcCkgbWFwID0gZ2V0S2V5TWFwKG9sZCwgb2xkRW5kKVxuXHRcdFx0XHRcdGlmICh2ICE9IG51bGwpIHtcblx0XHRcdFx0XHRcdHZhciBvbGRJbmRleCA9IG1hcFt2LmtleV1cblx0XHRcdFx0XHRcdGlmIChvbGRJbmRleCAhPSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBtb3ZhYmxlID0gb2xkW29sZEluZGV4XVxuXHRcdFx0XHRcdFx0XHR2YXIgc2hvdWxkUmVjeWNsZSA9IChwb29sICE9IG51bGwgJiYgb2xkSW5kZXggPj0gb2xkLmxlbmd0aCAtIHBvb2wubGVuZ3RoKSB8fCAoKHBvb2wgPT0gbnVsbCkgJiYgcmVjeWNsaW5nKVxuXHRcdFx0XHRcdFx0XHR1cGRhdGVOb2RlKHBhcmVudCwgbW92YWJsZSwgdiwgaG9va3MsIGdldE5leHRTaWJsaW5nKG9sZCwgb2xkRW5kICsgMSwgbmV4dFNpYmxpbmcpLCByZWN5Y2xpbmcsIG5zKVxuXHRcdFx0XHRcdFx0XHRpbnNlcnROb2RlKHBhcmVudCwgdG9GcmFnbWVudChtb3ZhYmxlKSwgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdFx0XHRcdG9sZFtvbGRJbmRleF0uc2tpcCA9IHRydWVcblx0XHRcdFx0XHRcdFx0aWYgKG1vdmFibGUuZG9tICE9IG51bGwpIG5leHRTaWJsaW5nID0gbW92YWJsZS5kb21cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR2YXIgZG9tID0gY3JlYXRlTm9kZShwYXJlbnQsIHYsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdFx0XHRcdG5leHRTaWJsaW5nID0gZG9tXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVuZC0tXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGVuZCA8IHN0YXJ0KSBicmVha1xuXHRcdFx0fVxuXHRcdFx0Y3JlYXRlTm9kZXMocGFyZW50LCB2bm9kZXMsIHN0YXJ0LCBlbmQgKyAxLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKVxuXHRcdFx0cmVtb3ZlTm9kZXMob2xkLCBvbGRTdGFydCwgb2xkRW5kICsgMSwgdm5vZGVzKVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVOb2RlKHBhcmVudCwgb2xkLCB2bm9kZSwgaG9va3MsIG5leHRTaWJsaW5nLCByZWN5Y2xpbmcsIG5zKSB7XG5cdFx0dmFyIG9sZFRhZyA9IG9sZC50YWcsIHRhZyA9IHZub2RlLnRhZ1xuXHRcdGlmIChvbGRUYWcgPT09IHRhZykge1xuXHRcdFx0dm5vZGUuc3RhdGUgPSBvbGQuc3RhdGVcblx0XHRcdHZub2RlLl9zdGF0ZSA9IG9sZC5fc3RhdGVcblx0XHRcdHZub2RlLmV2ZW50cyA9IG9sZC5ldmVudHNcblx0XHRcdGlmICghcmVjeWNsaW5nICYmIHNob3VsZE5vdFVwZGF0ZSh2bm9kZSwgb2xkKSkgcmV0dXJuXG5cdFx0XHRpZiAodHlwZW9mIG9sZFRhZyA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCkge1xuXHRcdFx0XHRcdGlmIChyZWN5Y2xpbmcpIHtcblx0XHRcdFx0XHRcdHZub2RlLnN0YXRlID0ge31cblx0XHRcdFx0XHRcdGluaXRMaWZlY3ljbGUodm5vZGUuYXR0cnMsIHZub2RlLCBob29rcylcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB1cGRhdGVMaWZlY3ljbGUodm5vZGUuYXR0cnMsIHZub2RlLCBob29rcylcblx0XHRcdFx0fVxuXHRcdFx0XHRzd2l0Y2ggKG9sZFRhZykge1xuXHRcdFx0XHRcdGNhc2UgXCIjXCI6IHVwZGF0ZVRleHQob2xkLCB2bm9kZSk7IGJyZWFrXG5cdFx0XHRcdFx0Y2FzZSBcIjxcIjogdXBkYXRlSFRNTChwYXJlbnQsIG9sZCwgdm5vZGUsIG5leHRTaWJsaW5nKTsgYnJlYWtcblx0XHRcdFx0XHRjYXNlIFwiW1wiOiB1cGRhdGVGcmFnbWVudChwYXJlbnQsIG9sZCwgdm5vZGUsIHJlY3ljbGluZywgaG9va3MsIG5leHRTaWJsaW5nLCBucyk7IGJyZWFrXG5cdFx0XHRcdFx0ZGVmYXVsdDogdXBkYXRlRWxlbWVudChvbGQsIHZub2RlLCByZWN5Y2xpbmcsIGhvb2tzLCBucylcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSB1cGRhdGVDb21wb25lbnQocGFyZW50LCBvbGQsIHZub2RlLCBob29rcywgbmV4dFNpYmxpbmcsIHJlY3ljbGluZywgbnMpXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0cmVtb3ZlTm9kZShvbGQsIG51bGwpXG5cdFx0XHRjcmVhdGVOb2RlKHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZVRleHQob2xkLCB2bm9kZSkge1xuXHRcdGlmIChvbGQuY2hpbGRyZW4udG9TdHJpbmcoKSAhPT0gdm5vZGUuY2hpbGRyZW4udG9TdHJpbmcoKSkge1xuXHRcdFx0b2xkLmRvbS5ub2RlVmFsdWUgPSB2bm9kZS5jaGlsZHJlblxuXHRcdH1cblx0XHR2bm9kZS5kb20gPSBvbGQuZG9tXG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlSFRNTChwYXJlbnQsIG9sZCwgdm5vZGUsIG5leHRTaWJsaW5nKSB7XG5cdFx0aWYgKG9sZC5jaGlsZHJlbiAhPT0gdm5vZGUuY2hpbGRyZW4pIHtcblx0XHRcdHRvRnJhZ21lbnQob2xkKVxuXHRcdFx0Y3JlYXRlSFRNTChwYXJlbnQsIHZub2RlLCBuZXh0U2libGluZylcblx0XHR9XG5cdFx0ZWxzZSB2bm9kZS5kb20gPSBvbGQuZG9tLCB2bm9kZS5kb21TaXplID0gb2xkLmRvbVNpemVcblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVGcmFnbWVudChwYXJlbnQsIG9sZCwgdm5vZGUsIHJlY3ljbGluZywgaG9va3MsIG5leHRTaWJsaW5nLCBucykge1xuXHRcdHVwZGF0ZU5vZGVzKHBhcmVudCwgb2xkLmNoaWxkcmVuLCB2bm9kZS5jaGlsZHJlbiwgcmVjeWNsaW5nLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKVxuXHRcdHZhciBkb21TaXplID0gMCwgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlblxuXHRcdHZub2RlLmRvbSA9IG51bGxcblx0XHRpZiAoY2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgY2hpbGQgPSBjaGlsZHJlbltpXVxuXHRcdFx0XHRpZiAoY2hpbGQgIT0gbnVsbCAmJiBjaGlsZC5kb20gIT0gbnVsbCkge1xuXHRcdFx0XHRcdGlmICh2bm9kZS5kb20gPT0gbnVsbCkgdm5vZGUuZG9tID0gY2hpbGQuZG9tXG5cdFx0XHRcdFx0ZG9tU2l6ZSArPSBjaGlsZC5kb21TaXplIHx8IDFcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGRvbVNpemUgIT09IDEpIHZub2RlLmRvbVNpemUgPSBkb21TaXplXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUVsZW1lbnQob2xkLCB2bm9kZSwgcmVjeWNsaW5nLCBob29rcywgbnMpIHtcblx0XHR2YXIgZWxlbWVudCA9IHZub2RlLmRvbSA9IG9sZC5kb21cblx0XHRucyA9IGdldE5hbWVTcGFjZSh2bm9kZSkgfHwgbnNcblx0XHRpZiAodm5vZGUudGFnID09PSBcInRleHRhcmVhXCIpIHtcblx0XHRcdGlmICh2bm9kZS5hdHRycyA9PSBudWxsKSB2bm9kZS5hdHRycyA9IHt9XG5cdFx0XHRpZiAodm5vZGUudGV4dCAhPSBudWxsKSB7XG5cdFx0XHRcdHZub2RlLmF0dHJzLnZhbHVlID0gdm5vZGUudGV4dCAvL0ZJWE1FIGhhbmRsZTAgbXVsdGlwbGUgY2hpbGRyZW5cblx0XHRcdFx0dm5vZGUudGV4dCA9IHVuZGVmaW5lZFxuXHRcdFx0fVxuXHRcdH1cblx0XHR1cGRhdGVBdHRycyh2bm9kZSwgb2xkLmF0dHJzLCB2bm9kZS5hdHRycywgbnMpXG5cdFx0aWYgKHZub2RlLmF0dHJzICE9IG51bGwgJiYgdm5vZGUuYXR0cnMuY29udGVudGVkaXRhYmxlICE9IG51bGwpIHtcblx0XHRcdHNldENvbnRlbnRFZGl0YWJsZSh2bm9kZSlcblx0XHR9XG5cdFx0ZWxzZSBpZiAob2xkLnRleHQgIT0gbnVsbCAmJiB2bm9kZS50ZXh0ICE9IG51bGwgJiYgdm5vZGUudGV4dCAhPT0gXCJcIikge1xuXHRcdFx0aWYgKG9sZC50ZXh0LnRvU3RyaW5nKCkgIT09IHZub2RlLnRleHQudG9TdHJpbmcoKSkgb2xkLmRvbS5maXJzdENoaWxkLm5vZGVWYWx1ZSA9IHZub2RlLnRleHRcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRpZiAob2xkLnRleHQgIT0gbnVsbCkgb2xkLmNoaWxkcmVuID0gW1Zub2RlKFwiI1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgb2xkLnRleHQsIHVuZGVmaW5lZCwgb2xkLmRvbS5maXJzdENoaWxkKV1cblx0XHRcdGlmICh2bm9kZS50ZXh0ICE9IG51bGwpIHZub2RlLmNoaWxkcmVuID0gW1Zub2RlKFwiI1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdm5vZGUudGV4dCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXVxuXHRcdFx0dXBkYXRlTm9kZXMoZWxlbWVudCwgb2xkLmNoaWxkcmVuLCB2bm9kZS5jaGlsZHJlbiwgcmVjeWNsaW5nLCBob29rcywgbnVsbCwgbnMpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUNvbXBvbmVudChwYXJlbnQsIG9sZCwgdm5vZGUsIGhvb2tzLCBuZXh0U2libGluZywgcmVjeWNsaW5nLCBucykge1xuXHRcdGlmIChyZWN5Y2xpbmcpIHtcblx0XHRcdGluaXRDb21wb25lbnQodm5vZGUsIGhvb2tzKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2bm9kZS5pbnN0YW5jZSA9IFZub2RlLm5vcm1hbGl6ZSh2bm9kZS5fc3RhdGUudmlldy5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSkpXG5cdFx0XHRpZiAodm5vZGUuaW5zdGFuY2UgPT09IHZub2RlKSB0aHJvdyBFcnJvcihcIkEgdmlldyBjYW5ub3QgcmV0dXJuIHRoZSB2bm9kZSBpdCByZWNlaXZlZCBhcyBhcmd1bWVudFwiKVxuXHRcdFx0aWYgKHZub2RlLmF0dHJzICE9IG51bGwpIHVwZGF0ZUxpZmVjeWNsZSh2bm9kZS5hdHRycywgdm5vZGUsIGhvb2tzKVxuXHRcdFx0dXBkYXRlTGlmZWN5Y2xlKHZub2RlLl9zdGF0ZSwgdm5vZGUsIGhvb2tzKVxuXHRcdH1cblx0XHRpZiAodm5vZGUuaW5zdGFuY2UgIT0gbnVsbCkge1xuXHRcdFx0aWYgKG9sZC5pbnN0YW5jZSA9PSBudWxsKSBjcmVhdGVOb2RlKHBhcmVudCwgdm5vZGUuaW5zdGFuY2UsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0XHRlbHNlIHVwZGF0ZU5vZGUocGFyZW50LCBvbGQuaW5zdGFuY2UsIHZub2RlLmluc3RhbmNlLCBob29rcywgbmV4dFNpYmxpbmcsIHJlY3ljbGluZywgbnMpXG5cdFx0XHR2bm9kZS5kb20gPSB2bm9kZS5pbnN0YW5jZS5kb21cblx0XHRcdHZub2RlLmRvbVNpemUgPSB2bm9kZS5pbnN0YW5jZS5kb21TaXplXG5cdFx0fVxuXHRcdGVsc2UgaWYgKG9sZC5pbnN0YW5jZSAhPSBudWxsKSB7XG5cdFx0XHRyZW1vdmVOb2RlKG9sZC5pbnN0YW5jZSwgbnVsbClcblx0XHRcdHZub2RlLmRvbSA9IHVuZGVmaW5lZFxuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IDBcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHR2bm9kZS5kb20gPSBvbGQuZG9tXG5cdFx0XHR2bm9kZS5kb21TaXplID0gb2xkLmRvbVNpemVcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gaXNSZWN5Y2xhYmxlKG9sZCwgdm5vZGVzKSB7XG5cdFx0aWYgKG9sZC5wb29sICE9IG51bGwgJiYgTWF0aC5hYnMob2xkLnBvb2wubGVuZ3RoIC0gdm5vZGVzLmxlbmd0aCkgPD0gTWF0aC5hYnMob2xkLmxlbmd0aCAtIHZub2Rlcy5sZW5ndGgpKSB7XG5cdFx0XHR2YXIgb2xkQ2hpbGRyZW5MZW5ndGggPSBvbGRbMF0gJiYgb2xkWzBdLmNoaWxkcmVuICYmIG9sZFswXS5jaGlsZHJlbi5sZW5ndGggfHwgMFxuXHRcdFx0dmFyIHBvb2xDaGlsZHJlbkxlbmd0aCA9IG9sZC5wb29sWzBdICYmIG9sZC5wb29sWzBdLmNoaWxkcmVuICYmIG9sZC5wb29sWzBdLmNoaWxkcmVuLmxlbmd0aCB8fCAwXG5cdFx0XHR2YXIgdm5vZGVzQ2hpbGRyZW5MZW5ndGggPSB2bm9kZXNbMF0gJiYgdm5vZGVzWzBdLmNoaWxkcmVuICYmIHZub2Rlc1swXS5jaGlsZHJlbi5sZW5ndGggfHwgMFxuXHRcdFx0aWYgKE1hdGguYWJzKHBvb2xDaGlsZHJlbkxlbmd0aCAtIHZub2Rlc0NoaWxkcmVuTGVuZ3RoKSA8PSBNYXRoLmFicyhvbGRDaGlsZHJlbkxlbmd0aCAtIHZub2Rlc0NoaWxkcmVuTGVuZ3RoKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2Vcblx0fVxuXHRmdW5jdGlvbiBnZXRLZXlNYXAodm5vZGVzLCBlbmQpIHtcblx0XHR2YXIgbWFwID0ge30sIGkgPSAwXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBlbmQ7IGkrKykge1xuXHRcdFx0dmFyIHZub2RlID0gdm5vZGVzW2ldXG5cdFx0XHRpZiAodm5vZGUgIT0gbnVsbCkge1xuXHRcdFx0XHR2YXIga2V5MiA9IHZub2RlLmtleVxuXHRcdFx0XHRpZiAoa2V5MiAhPSBudWxsKSBtYXBba2V5Ml0gPSBpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBtYXBcblx0fVxuXHRmdW5jdGlvbiB0b0ZyYWdtZW50KHZub2RlKSB7XG5cdFx0dmFyIGNvdW50MCA9IHZub2RlLmRvbVNpemVcblx0XHRpZiAoY291bnQwICE9IG51bGwgfHwgdm5vZGUuZG9tID09IG51bGwpIHtcblx0XHRcdHZhciBmcmFnbWVudCA9ICRkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG5cdFx0XHRpZiAoY291bnQwID4gMCkge1xuXHRcdFx0XHR2YXIgZG9tID0gdm5vZGUuZG9tXG5cdFx0XHRcdHdoaWxlICgtLWNvdW50MCkgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZG9tLm5leHRTaWJsaW5nKVxuXHRcdFx0XHRmcmFnbWVudC5pbnNlcnRCZWZvcmUoZG9tLCBmcmFnbWVudC5maXJzdENoaWxkKVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZyYWdtZW50XG5cdFx0fVxuXHRcdGVsc2UgcmV0dXJuIHZub2RlLmRvbVxuXHR9XG5cdGZ1bmN0aW9uIGdldE5leHRTaWJsaW5nKHZub2RlcywgaSwgbmV4dFNpYmxpbmcpIHtcblx0XHRmb3IgKDsgaSA8IHZub2Rlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKHZub2Rlc1tpXSAhPSBudWxsICYmIHZub2Rlc1tpXS5kb20gIT0gbnVsbCkgcmV0dXJuIHZub2Rlc1tpXS5kb21cblx0XHR9XG5cdFx0cmV0dXJuIG5leHRTaWJsaW5nXG5cdH1cblx0ZnVuY3Rpb24gaW5zZXJ0Tm9kZShwYXJlbnQsIGRvbSwgbmV4dFNpYmxpbmcpIHtcblx0XHRpZiAobmV4dFNpYmxpbmcgJiYgbmV4dFNpYmxpbmcucGFyZW50Tm9kZSkgcGFyZW50Lmluc2VydEJlZm9yZShkb20sIG5leHRTaWJsaW5nKVxuXHRcdGVsc2UgcGFyZW50LmFwcGVuZENoaWxkKGRvbSlcblx0fVxuXHRmdW5jdGlvbiBzZXRDb250ZW50RWRpdGFibGUodm5vZGUpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlblxuXHRcdGlmIChjaGlsZHJlbiAhPSBudWxsICYmIGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBjaGlsZHJlblswXS50YWcgPT09IFwiPFwiKSB7XG5cdFx0XHR2YXIgY29udGVudCA9IGNoaWxkcmVuWzBdLmNoaWxkcmVuXG5cdFx0XHRpZiAodm5vZGUuZG9tLmlubmVySFRNTCAhPT0gY29udGVudCkgdm5vZGUuZG9tLmlubmVySFRNTCA9IGNvbnRlbnRcblx0XHR9XG5cdFx0ZWxzZSBpZiAodm5vZGUudGV4dCAhPSBudWxsIHx8IGNoaWxkcmVuICE9IG51bGwgJiYgY2hpbGRyZW4ubGVuZ3RoICE9PSAwKSB0aHJvdyBuZXcgRXJyb3IoXCJDaGlsZCBub2RlIG9mIGEgY29udGVudGVkaXRhYmxlIG11c3QgYmUgdHJ1c3RlZFwiKVxuXHR9XG5cdC8vcmVtb3ZlXG5cdGZ1bmN0aW9uIHJlbW92ZU5vZGVzKHZub2Rlcywgc3RhcnQsIGVuZCwgY29udGV4dCkge1xuXHRcdGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG5cdFx0XHR2YXIgdm5vZGUgPSB2bm9kZXNbaV1cblx0XHRcdGlmICh2bm9kZSAhPSBudWxsKSB7XG5cdFx0XHRcdGlmICh2bm9kZS5za2lwKSB2bm9kZS5za2lwID0gZmFsc2Vcblx0XHRcdFx0ZWxzZSByZW1vdmVOb2RlKHZub2RlLCBjb250ZXh0KVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiByZW1vdmVOb2RlKHZub2RlLCBjb250ZXh0KSB7XG5cdFx0dmFyIGV4cGVjdGVkID0gMSwgY2FsbGVkID0gMFxuXHRcdGlmICh2bm9kZS5hdHRycyAmJiB0eXBlb2Ygdm5vZGUuYXR0cnMub25iZWZvcmVyZW1vdmUgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0dmFyIHJlc3VsdCA9IHZub2RlLmF0dHJzLm9uYmVmb3JlcmVtb3ZlLmNhbGwodm5vZGUuc3RhdGUsIHZub2RlKVxuXHRcdFx0aWYgKHJlc3VsdCAhPSBudWxsICYmIHR5cGVvZiByZXN1bHQudGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdGV4cGVjdGVkKytcblx0XHRcdFx0cmVzdWx0LnRoZW4oY29udGludWF0aW9uLCBjb250aW51YXRpb24pXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICh0eXBlb2Ygdm5vZGUudGFnICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiB2bm9kZS5fc3RhdGUub25iZWZvcmVyZW1vdmUgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0dmFyIHJlc3VsdCA9IHZub2RlLl9zdGF0ZS5vbmJlZm9yZXJlbW92ZS5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSlcblx0XHRcdGlmIChyZXN1bHQgIT0gbnVsbCAmJiB0eXBlb2YgcmVzdWx0LnRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRleHBlY3RlZCsrXG5cdFx0XHRcdHJlc3VsdC50aGVuKGNvbnRpbnVhdGlvbiwgY29udGludWF0aW9uKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRjb250aW51YXRpb24oKVxuXHRcdGZ1bmN0aW9uIGNvbnRpbnVhdGlvbigpIHtcblx0XHRcdGlmICgrK2NhbGxlZCA9PT0gZXhwZWN0ZWQpIHtcblx0XHRcdFx0b25yZW1vdmUodm5vZGUpXG5cdFx0XHRcdGlmICh2bm9kZS5kb20pIHtcblx0XHRcdFx0XHR2YXIgY291bnQwID0gdm5vZGUuZG9tU2l6ZSB8fCAxXG5cdFx0XHRcdFx0aWYgKGNvdW50MCA+IDEpIHtcblx0XHRcdFx0XHRcdHZhciBkb20gPSB2bm9kZS5kb21cblx0XHRcdFx0XHRcdHdoaWxlICgtLWNvdW50MCkge1xuXHRcdFx0XHRcdFx0XHRyZW1vdmVOb2RlRnJvbURPTShkb20ubmV4dFNpYmxpbmcpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJlbW92ZU5vZGVGcm9tRE9NKHZub2RlLmRvbSlcblx0XHRcdFx0XHRpZiAoY29udGV4dCAhPSBudWxsICYmIHZub2RlLmRvbVNpemUgPT0gbnVsbCAmJiAhaGFzSW50ZWdyYXRpb25NZXRob2RzKHZub2RlLmF0dHJzKSAmJiB0eXBlb2Ygdm5vZGUudGFnID09PSBcInN0cmluZ1wiKSB7IC8vVE9ETyB0ZXN0IGN1c3RvbSBlbGVtZW50c1xuXHRcdFx0XHRcdFx0aWYgKCFjb250ZXh0LnBvb2wpIGNvbnRleHQucG9vbCA9IFt2bm9kZV1cblx0XHRcdFx0XHRcdGVsc2UgY29udGV4dC5wb29sLnB1c2godm5vZGUpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHJlbW92ZU5vZGVGcm9tRE9NKG5vZGUpIHtcblx0XHR2YXIgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlXG5cdFx0aWYgKHBhcmVudCAhPSBudWxsKSBwYXJlbnQucmVtb3ZlQ2hpbGQobm9kZSlcblx0fVxuXHRmdW5jdGlvbiBvbnJlbW92ZSh2bm9kZSkge1xuXHRcdGlmICh2bm9kZS5hdHRycyAmJiB0eXBlb2Ygdm5vZGUuYXR0cnMub25yZW1vdmUgPT09IFwiZnVuY3Rpb25cIikgdm5vZGUuYXR0cnMub25yZW1vdmUuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpXG5cdFx0aWYgKHR5cGVvZiB2bm9kZS50YWcgIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHZub2RlLl9zdGF0ZS5vbnJlbW92ZSA9PT0gXCJmdW5jdGlvblwiKSB2bm9kZS5fc3RhdGUub25yZW1vdmUuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpXG5cdFx0aWYgKHZub2RlLmluc3RhbmNlICE9IG51bGwpIG9ucmVtb3ZlKHZub2RlLmluc3RhbmNlKVxuXHRcdGVsc2Uge1xuXHRcdFx0dmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW5cblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0dmFyIGNoaWxkID0gY2hpbGRyZW5baV1cblx0XHRcdFx0XHRpZiAoY2hpbGQgIT0gbnVsbCkgb25yZW1vdmUoY2hpbGQpXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0Ly9hdHRyczJcblx0ZnVuY3Rpb24gc2V0QXR0cnModm5vZGUsIGF0dHJzMiwgbnMpIHtcblx0XHRmb3IgKHZhciBrZXkyIGluIGF0dHJzMikge1xuXHRcdFx0c2V0QXR0cih2bm9kZSwga2V5MiwgbnVsbCwgYXR0cnMyW2tleTJdLCBucylcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gc2V0QXR0cih2bm9kZSwga2V5Miwgb2xkLCB2YWx1ZSwgbnMpIHtcblx0XHR2YXIgZWxlbWVudCA9IHZub2RlLmRvbVxuXHRcdGlmIChrZXkyID09PSBcImtleVwiIHx8IGtleTIgPT09IFwiaXNcIiB8fCAob2xkID09PSB2YWx1ZSAmJiAhaXNGb3JtQXR0cmlidXRlKHZub2RlLCBrZXkyKSkgJiYgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIiB8fCBpc0xpZmVjeWNsZU1ldGhvZChrZXkyKSkgcmV0dXJuXG5cdFx0dmFyIG5zTGFzdEluZGV4ID0ga2V5Mi5pbmRleE9mKFwiOlwiKVxuXHRcdGlmIChuc0xhc3RJbmRleCA+IC0xICYmIGtleTIuc3Vic3RyKDAsIG5zTGFzdEluZGV4KSA9PT0gXCJ4bGlua1wiKSB7XG5cdFx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZU5TKFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLCBrZXkyLnNsaWNlKG5zTGFzdEluZGV4ICsgMSksIHZhbHVlKVxuXHRcdH1cblx0XHRlbHNlIGlmIChrZXkyWzBdID09PSBcIm9cIiAmJiBrZXkyWzFdID09PSBcIm5cIiAmJiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikgdXBkYXRlRXZlbnQodm5vZGUsIGtleTIsIHZhbHVlKVxuXHRcdGVsc2UgaWYgKGtleTIgPT09IFwic3R5bGVcIikgdXBkYXRlU3R5bGUoZWxlbWVudCwgb2xkLCB2YWx1ZSlcblx0XHRlbHNlIGlmIChrZXkyIGluIGVsZW1lbnQgJiYgIWlzQXR0cmlidXRlKGtleTIpICYmIG5zID09PSB1bmRlZmluZWQgJiYgIWlzQ3VzdG9tRWxlbWVudCh2bm9kZSkpIHtcblx0XHRcdGlmIChrZXkyID09PSBcInZhbHVlXCIpIHtcblx0XHRcdFx0dmFyIG5vcm1hbGl6ZWQwID0gXCJcIiArIHZhbHVlIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8taW1wbGljaXQtY29lcmNpb25cblx0XHRcdFx0Ly9zZXR0aW5nIGlucHV0W3ZhbHVlXSB0byBzYW1lIHZhbHVlIGJ5IHR5cGluZyBvbiBmb2N1c2VkIGVsZW1lbnQgbW92ZXMgY3Vyc29yIHRvIGVuZCBpbiBDaHJvbWVcblx0XHRcdFx0aWYgKCh2bm9kZS50YWcgPT09IFwiaW5wdXRcIiB8fCB2bm9kZS50YWcgPT09IFwidGV4dGFyZWFcIikgJiYgdm5vZGUuZG9tLnZhbHVlID09PSBub3JtYWxpemVkMCAmJiB2bm9kZS5kb20gPT09ICRkb2MuYWN0aXZlRWxlbWVudCkgcmV0dXJuXG5cdFx0XHRcdC8vc2V0dGluZyBzZWxlY3RbdmFsdWVdIHRvIHNhbWUgdmFsdWUgd2hpbGUgaGF2aW5nIHNlbGVjdCBvcGVuIGJsaW5rcyBzZWxlY3QgZHJvcGRvd24gaW4gQ2hyb21lXG5cdFx0XHRcdGlmICh2bm9kZS50YWcgPT09IFwic2VsZWN0XCIpIHtcblx0XHRcdFx0XHRpZiAodmFsdWUgPT09IG51bGwpIHtcblx0XHRcdFx0XHRcdGlmICh2bm9kZS5kb20uc2VsZWN0ZWRJbmRleCA9PT0gLTEgJiYgdm5vZGUuZG9tID09PSAkZG9jLmFjdGl2ZUVsZW1lbnQpIHJldHVyblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpZiAob2xkICE9PSBudWxsICYmIHZub2RlLmRvbS52YWx1ZSA9PT0gbm9ybWFsaXplZDAgJiYgdm5vZGUuZG9tID09PSAkZG9jLmFjdGl2ZUVsZW1lbnQpIHJldHVyblxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHQvL3NldHRpbmcgb3B0aW9uW3ZhbHVlXSB0byBzYW1lIHZhbHVlIHdoaWxlIGhhdmluZyBzZWxlY3Qgb3BlbiBibGlua3Mgc2VsZWN0IGRyb3Bkb3duIGluIENocm9tZVxuXHRcdFx0XHRpZiAodm5vZGUudGFnID09PSBcIm9wdGlvblwiICYmIG9sZCAhPSBudWxsICYmIHZub2RlLmRvbS52YWx1ZSA9PT0gbm9ybWFsaXplZDApIHJldHVyblxuXHRcdFx0fVxuXHRcdFx0Ly8gSWYgeW91IGFzc2lnbiBhbiBpbnB1dCB0eXBlMSB0aGF0IGlzIG5vdCBzdXBwb3J0ZWQgYnkgSUUgMTEgd2l0aCBhbiBhc3NpZ25tZW50IGV4cHJlc3Npb24sIGFuIGVycm9yMCB3aWxsIG9jY3VyLlxuXHRcdFx0aWYgKHZub2RlLnRhZyA9PT0gXCJpbnB1dFwiICYmIGtleTIgPT09IFwidHlwZVwiKSB7XG5cdFx0XHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleTIsIHZhbHVlKVxuXHRcdFx0XHRyZXR1cm5cblx0XHRcdH1cblx0XHRcdGVsZW1lbnRba2V5Ml0gPSB2YWx1ZVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiKSB7XG5cdFx0XHRcdGlmICh2YWx1ZSkgZWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5MiwgXCJcIilcblx0XHRcdFx0ZWxzZSBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShrZXkyKVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSBlbGVtZW50LnNldEF0dHJpYnV0ZShrZXkyID09PSBcImNsYXNzTmFtZVwiID8gXCJjbGFzc1wiIDoga2V5MiwgdmFsdWUpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHNldExhdGVBdHRycyh2bm9kZSkge1xuXHRcdHZhciBhdHRyczIgPSB2bm9kZS5hdHRyc1xuXHRcdGlmICh2bm9kZS50YWcgPT09IFwic2VsZWN0XCIgJiYgYXR0cnMyICE9IG51bGwpIHtcblx0XHRcdGlmIChcInZhbHVlXCIgaW4gYXR0cnMyKSBzZXRBdHRyKHZub2RlLCBcInZhbHVlXCIsIG51bGwsIGF0dHJzMi52YWx1ZSwgdW5kZWZpbmVkKVxuXHRcdFx0aWYgKFwic2VsZWN0ZWRJbmRleFwiIGluIGF0dHJzMikgc2V0QXR0cih2bm9kZSwgXCJzZWxlY3RlZEluZGV4XCIsIG51bGwsIGF0dHJzMi5zZWxlY3RlZEluZGV4LCB1bmRlZmluZWQpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUF0dHJzKHZub2RlLCBvbGQsIGF0dHJzMiwgbnMpIHtcblx0XHRpZiAoYXR0cnMyICE9IG51bGwpIHtcblx0XHRcdGZvciAodmFyIGtleTIgaW4gYXR0cnMyKSB7XG5cdFx0XHRcdHNldEF0dHIodm5vZGUsIGtleTIsIG9sZCAmJiBvbGRba2V5Ml0sIGF0dHJzMltrZXkyXSwgbnMpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChvbGQgIT0gbnVsbCkge1xuXHRcdFx0Zm9yICh2YXIga2V5MiBpbiBvbGQpIHtcblx0XHRcdFx0aWYgKGF0dHJzMiA9PSBudWxsIHx8ICEoa2V5MiBpbiBhdHRyczIpKSB7XG5cdFx0XHRcdFx0aWYgKGtleTIgPT09IFwiY2xhc3NOYW1lXCIpIGtleTIgPSBcImNsYXNzXCJcblx0XHRcdFx0XHRpZiAoa2V5MlswXSA9PT0gXCJvXCIgJiYga2V5MlsxXSA9PT0gXCJuXCIgJiYgIWlzTGlmZWN5Y2xlTWV0aG9kKGtleTIpKSB1cGRhdGVFdmVudCh2bm9kZSwga2V5MiwgdW5kZWZpbmVkKVxuXHRcdFx0XHRcdGVsc2UgaWYgKGtleTIgIT09IFwia2V5XCIpIHZub2RlLmRvbS5yZW1vdmVBdHRyaWJ1dGUoa2V5Milcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBpc0Zvcm1BdHRyaWJ1dGUodm5vZGUsIGF0dHIpIHtcblx0XHRyZXR1cm4gYXR0ciA9PT0gXCJ2YWx1ZVwiIHx8IGF0dHIgPT09IFwiY2hlY2tlZFwiIHx8IGF0dHIgPT09IFwic2VsZWN0ZWRJbmRleFwiIHx8IGF0dHIgPT09IFwic2VsZWN0ZWRcIiAmJiB2bm9kZS5kb20gPT09ICRkb2MuYWN0aXZlRWxlbWVudFxuXHR9XG5cdGZ1bmN0aW9uIGlzTGlmZWN5Y2xlTWV0aG9kKGF0dHIpIHtcblx0XHRyZXR1cm4gYXR0ciA9PT0gXCJvbmluaXRcIiB8fCBhdHRyID09PSBcIm9uY3JlYXRlXCIgfHwgYXR0ciA9PT0gXCJvbnVwZGF0ZVwiIHx8IGF0dHIgPT09IFwib25yZW1vdmVcIiB8fCBhdHRyID09PSBcIm9uYmVmb3JlcmVtb3ZlXCIgfHwgYXR0ciA9PT0gXCJvbmJlZm9yZXVwZGF0ZVwiXG5cdH1cblx0ZnVuY3Rpb24gaXNBdHRyaWJ1dGUoYXR0cikge1xuXHRcdHJldHVybiBhdHRyID09PSBcImhyZWZcIiB8fCBhdHRyID09PSBcImxpc3RcIiB8fCBhdHRyID09PSBcImZvcm1cIiB8fCBhdHRyID09PSBcIndpZHRoXCIgfHwgYXR0ciA9PT0gXCJoZWlnaHRcIi8vIHx8IGF0dHIgPT09IFwidHlwZVwiXG5cdH1cblx0ZnVuY3Rpb24gaXNDdXN0b21FbGVtZW50KHZub2RlKXtcblx0XHRyZXR1cm4gdm5vZGUuYXR0cnMuaXMgfHwgdm5vZGUudGFnLmluZGV4T2YoXCItXCIpID4gLTFcblx0fVxuXHRmdW5jdGlvbiBoYXNJbnRlZ3JhdGlvbk1ldGhvZHMoc291cmNlKSB7XG5cdFx0cmV0dXJuIHNvdXJjZSAhPSBudWxsICYmIChzb3VyY2Uub25jcmVhdGUgfHwgc291cmNlLm9udXBkYXRlIHx8IHNvdXJjZS5vbmJlZm9yZXJlbW92ZSB8fCBzb3VyY2Uub25yZW1vdmUpXG5cdH1cblx0Ly9zdHlsZVxuXHRmdW5jdGlvbiB1cGRhdGVTdHlsZShlbGVtZW50LCBvbGQsIHN0eWxlKSB7XG5cdFx0aWYgKG9sZCA9PT0gc3R5bGUpIGVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IFwiXCIsIG9sZCA9IG51bGxcblx0XHRpZiAoc3R5bGUgPT0gbnVsbCkgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gXCJcIlxuXHRcdGVsc2UgaWYgKHR5cGVvZiBzdHlsZSA9PT0gXCJzdHJpbmdcIikgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gc3R5bGVcblx0XHRlbHNlIHtcblx0XHRcdGlmICh0eXBlb2Ygb2xkID09PSBcInN0cmluZ1wiKSBlbGVtZW50LnN0eWxlLmNzc1RleHQgPSBcIlwiXG5cdFx0XHRmb3IgKHZhciBrZXkyIGluIHN0eWxlKSB7XG5cdFx0XHRcdGVsZW1lbnQuc3R5bGVba2V5Ml0gPSBzdHlsZVtrZXkyXVxuXHRcdFx0fVxuXHRcdFx0aWYgKG9sZCAhPSBudWxsICYmIHR5cGVvZiBvbGQgIT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0Zm9yICh2YXIga2V5MiBpbiBvbGQpIHtcblx0XHRcdFx0XHRpZiAoIShrZXkyIGluIHN0eWxlKSkgZWxlbWVudC5zdHlsZVtrZXkyXSA9IFwiXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHQvL2V2ZW50XG5cdGZ1bmN0aW9uIHVwZGF0ZUV2ZW50KHZub2RlLCBrZXkyLCB2YWx1ZSkge1xuXHRcdHZhciBlbGVtZW50ID0gdm5vZGUuZG9tXG5cdFx0dmFyIGNhbGxiYWNrID0gdHlwZW9mIG9uZXZlbnQgIT09IFwiZnVuY3Rpb25cIiA/IHZhbHVlIDogZnVuY3Rpb24oZSkge1xuXHRcdFx0dmFyIHJlc3VsdCA9IHZhbHVlLmNhbGwoZWxlbWVudCwgZSlcblx0XHRcdG9uZXZlbnQuY2FsbChlbGVtZW50LCBlKVxuXHRcdFx0cmV0dXJuIHJlc3VsdFxuXHRcdH1cblx0XHRpZiAoa2V5MiBpbiBlbGVtZW50KSBlbGVtZW50W2tleTJdID0gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBjYWxsYmFjayA6IG51bGxcblx0XHRlbHNlIHtcblx0XHRcdHZhciBldmVudE5hbWUgPSBrZXkyLnNsaWNlKDIpXG5cdFx0XHRpZiAodm5vZGUuZXZlbnRzID09PSB1bmRlZmluZWQpIHZub2RlLmV2ZW50cyA9IHt9XG5cdFx0XHRpZiAodm5vZGUuZXZlbnRzW2tleTJdID09PSBjYWxsYmFjaykgcmV0dXJuXG5cdFx0XHRpZiAodm5vZGUuZXZlbnRzW2tleTJdICE9IG51bGwpIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIHZub2RlLmV2ZW50c1trZXkyXSwgZmFsc2UpXG5cdFx0XHRpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0dm5vZGUuZXZlbnRzW2tleTJdID0gY2FsbGJhY2tcblx0XHRcdFx0ZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgdm5vZGUuZXZlbnRzW2tleTJdLCBmYWxzZSlcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0Ly9saWZlY3ljbGVcblx0ZnVuY3Rpb24gaW5pdExpZmVjeWNsZShzb3VyY2UsIHZub2RlLCBob29rcykge1xuXHRcdGlmICh0eXBlb2Ygc291cmNlLm9uaW5pdCA9PT0gXCJmdW5jdGlvblwiKSBzb3VyY2Uub25pbml0LmNhbGwodm5vZGUuc3RhdGUsIHZub2RlKVxuXHRcdGlmICh0eXBlb2Ygc291cmNlLm9uY3JlYXRlID09PSBcImZ1bmN0aW9uXCIpIGhvb2tzLnB1c2goc291cmNlLm9uY3JlYXRlLmJpbmQodm5vZGUuc3RhdGUsIHZub2RlKSlcblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVMaWZlY3ljbGUoc291cmNlLCB2bm9kZSwgaG9va3MpIHtcblx0XHRpZiAodHlwZW9mIHNvdXJjZS5vbnVwZGF0ZSA9PT0gXCJmdW5jdGlvblwiKSBob29rcy5wdXNoKHNvdXJjZS5vbnVwZGF0ZS5iaW5kKHZub2RlLnN0YXRlLCB2bm9kZSkpXG5cdH1cblx0ZnVuY3Rpb24gc2hvdWxkTm90VXBkYXRlKHZub2RlLCBvbGQpIHtcblx0XHR2YXIgZm9yY2VWbm9kZVVwZGF0ZSwgZm9yY2VDb21wb25lbnRVcGRhdGVcblx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCAmJiB0eXBlb2Ygdm5vZGUuYXR0cnMub25iZWZvcmV1cGRhdGUgPT09IFwiZnVuY3Rpb25cIikgZm9yY2VWbm9kZVVwZGF0ZSA9IHZub2RlLmF0dHJzLm9uYmVmb3JldXBkYXRlLmNhbGwodm5vZGUuc3RhdGUsIHZub2RlLCBvbGQpXG5cdFx0aWYgKHR5cGVvZiB2bm9kZS50YWcgIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHZub2RlLl9zdGF0ZS5vbmJlZm9yZXVwZGF0ZSA9PT0gXCJmdW5jdGlvblwiKSBmb3JjZUNvbXBvbmVudFVwZGF0ZSA9IHZub2RlLl9zdGF0ZS5vbmJlZm9yZXVwZGF0ZS5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSwgb2xkKVxuXHRcdGlmICghKGZvcmNlVm5vZGVVcGRhdGUgPT09IHVuZGVmaW5lZCAmJiBmb3JjZUNvbXBvbmVudFVwZGF0ZSA9PT0gdW5kZWZpbmVkKSAmJiAhZm9yY2VWbm9kZVVwZGF0ZSAmJiAhZm9yY2VDb21wb25lbnRVcGRhdGUpIHtcblx0XHRcdHZub2RlLmRvbSA9IG9sZC5kb21cblx0XHRcdHZub2RlLmRvbVNpemUgPSBvbGQuZG9tU2l6ZVxuXHRcdFx0dm5vZGUuaW5zdGFuY2UgPSBvbGQuaW5zdGFuY2Vcblx0XHRcdHJldHVybiB0cnVlXG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZVxuXHR9XG5cdGZ1bmN0aW9uIHJlbmRlcihkb20sIHZub2Rlcykge1xuXHRcdGlmICghZG9tKSB0aHJvdyBuZXcgRXJyb3IoXCJFbnN1cmUgdGhlIERPTSBlbGVtZW50IGJlaW5nIHBhc3NlZCB0byBtLnJvdXRlL20ubW91bnQvbS5yZW5kZXIgaXMgbm90IHVuZGVmaW5lZC5cIilcblx0XHR2YXIgaG9va3MgPSBbXVxuXHRcdHZhciBhY3RpdmUgPSAkZG9jLmFjdGl2ZUVsZW1lbnRcblx0XHR2YXIgbmFtZXNwYWNlID0gZG9tLm5hbWVzcGFjZVVSSVxuXHRcdC8vIEZpcnN0IHRpbWUwIHJlbmRlcmluZyBpbnRvIGEgbm9kZSBjbGVhcnMgaXQgb3V0XG5cdFx0aWYgKGRvbS52bm9kZXMgPT0gbnVsbCkgZG9tLnRleHRDb250ZW50ID0gXCJcIlxuXHRcdGlmICghQXJyYXkuaXNBcnJheSh2bm9kZXMpKSB2bm9kZXMgPSBbdm5vZGVzXVxuXHRcdHVwZGF0ZU5vZGVzKGRvbSwgZG9tLnZub2RlcywgVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4odm5vZGVzKSwgZmFsc2UsIGhvb2tzLCBudWxsLCBuYW1lc3BhY2UgPT09IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiID8gdW5kZWZpbmVkIDogbmFtZXNwYWNlKVxuXHRcdGRvbS52bm9kZXMgPSB2bm9kZXNcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSBob29rc1tpXSgpXG5cdFx0aWYgKCRkb2MuYWN0aXZlRWxlbWVudCAhPT0gYWN0aXZlKSBhY3RpdmUuZm9jdXMoKVxuXHR9XG5cdHJldHVybiB7cmVuZGVyOiByZW5kZXIsIHNldEV2ZW50Q2FsbGJhY2s6IHNldEV2ZW50Q2FsbGJhY2t9XG59XG5mdW5jdGlvbiB0aHJvdHRsZShjYWxsYmFjaykge1xuXHQvLzYwZnBzIHRyYW5zbGF0ZXMgdG8gMTYuNm1zLCByb3VuZCBpdCBkb3duIHNpbmNlIHNldFRpbWVvdXQgcmVxdWlyZXMgaW50XG5cdHZhciB0aW1lID0gMTZcblx0dmFyIGxhc3QgPSAwLCBwZW5kaW5nID0gbnVsbFxuXHR2YXIgdGltZW91dCA9IHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09IFwiZnVuY3Rpb25cIiA/IHJlcXVlc3RBbmltYXRpb25GcmFtZSA6IHNldFRpbWVvdXRcblx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBub3cgPSBEYXRlLm5vdygpXG5cdFx0aWYgKGxhc3QgPT09IDAgfHwgbm93IC0gbGFzdCA+PSB0aW1lKSB7XG5cdFx0XHRsYXN0ID0gbm93XG5cdFx0XHRjYWxsYmFjaygpXG5cdFx0fVxuXHRcdGVsc2UgaWYgKHBlbmRpbmcgPT09IG51bGwpIHtcblx0XHRcdHBlbmRpbmcgPSB0aW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRwZW5kaW5nID0gbnVsbFxuXHRcdFx0XHRjYWxsYmFjaygpXG5cdFx0XHRcdGxhc3QgPSBEYXRlLm5vdygpXG5cdFx0XHR9LCB0aW1lIC0gKG5vdyAtIGxhc3QpKVxuXHRcdH1cblx0fVxufVxudmFyIF8xMSA9IGZ1bmN0aW9uKCR3aW5kb3cpIHtcblx0dmFyIHJlbmRlclNlcnZpY2UgPSBjb3JlUmVuZGVyZXIoJHdpbmRvdylcblx0cmVuZGVyU2VydmljZS5zZXRFdmVudENhbGxiYWNrKGZ1bmN0aW9uKGUpIHtcblx0XHRpZiAoZS5yZWRyYXcgPT09IGZhbHNlKSBlLnJlZHJhdyA9IHVuZGVmaW5lZFxuXHRcdGVsc2UgcmVkcmF3KClcblx0fSlcblx0dmFyIGNhbGxiYWNrcyA9IFtdXG5cdGZ1bmN0aW9uIHN1YnNjcmliZShrZXkxLCBjYWxsYmFjaykge1xuXHRcdHVuc3Vic2NyaWJlKGtleTEpXG5cdFx0Y2FsbGJhY2tzLnB1c2goa2V5MSwgdGhyb3R0bGUoY2FsbGJhY2spKVxuXHR9XG5cdGZ1bmN0aW9uIHVuc3Vic2NyaWJlKGtleTEpIHtcblx0XHR2YXIgaW5kZXggPSBjYWxsYmFja3MuaW5kZXhPZihrZXkxKVxuXHRcdGlmIChpbmRleCA+IC0xKSBjYWxsYmFja3Muc3BsaWNlKGluZGV4LCAyKVxuXHR9XG5cdGZ1bmN0aW9uIHJlZHJhdygpIHtcblx0XHRmb3IgKHZhciBpID0gMTsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkgKz0gMikge1xuXHRcdFx0Y2FsbGJhY2tzW2ldKClcblx0XHR9XG5cdH1cblx0cmV0dXJuIHtzdWJzY3JpYmU6IHN1YnNjcmliZSwgdW5zdWJzY3JpYmU6IHVuc3Vic2NyaWJlLCByZWRyYXc6IHJlZHJhdywgcmVuZGVyOiByZW5kZXJTZXJ2aWNlLnJlbmRlcn1cbn1cbnZhciByZWRyYXdTZXJ2aWNlID0gXzExKHdpbmRvdylcbnJlcXVlc3RTZXJ2aWNlLnNldENvbXBsZXRpb25DYWxsYmFjayhyZWRyYXdTZXJ2aWNlLnJlZHJhdylcbnZhciBfMTYgPSBmdW5jdGlvbihyZWRyYXdTZXJ2aWNlMCkge1xuXHRyZXR1cm4gZnVuY3Rpb24ocm9vdCwgY29tcG9uZW50KSB7XG5cdFx0aWYgKGNvbXBvbmVudCA9PT0gbnVsbCkge1xuXHRcdFx0cmVkcmF3U2VydmljZTAucmVuZGVyKHJvb3QsIFtdKVxuXHRcdFx0cmVkcmF3U2VydmljZTAudW5zdWJzY3JpYmUocm9vdClcblx0XHRcdHJldHVyblxuXHRcdH1cblx0XHRcblx0XHRpZiAoY29tcG9uZW50LnZpZXcgPT0gbnVsbCAmJiB0eXBlb2YgY29tcG9uZW50ICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcihcIm0ubW91bnQoZWxlbWVudCwgY29tcG9uZW50KSBleHBlY3RzIGEgY29tcG9uZW50LCBub3QgYSB2bm9kZVwiKVxuXHRcdFxuXHRcdHZhciBydW4wID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZWRyYXdTZXJ2aWNlMC5yZW5kZXIocm9vdCwgVm5vZGUoY29tcG9uZW50KSlcblx0XHR9XG5cdFx0cmVkcmF3U2VydmljZTAuc3Vic2NyaWJlKHJvb3QsIHJ1bjApXG5cdFx0cmVkcmF3U2VydmljZTAucmVkcmF3KClcblx0fVxufVxubS5tb3VudCA9IF8xNihyZWRyYXdTZXJ2aWNlKVxudmFyIFByb21pc2UgPSBQcm9taXNlUG9seWZpbGxcbnZhciBwYXJzZVF1ZXJ5U3RyaW5nID0gZnVuY3Rpb24oc3RyaW5nKSB7XG5cdGlmIChzdHJpbmcgPT09IFwiXCIgfHwgc3RyaW5nID09IG51bGwpIHJldHVybiB7fVxuXHRpZiAoc3RyaW5nLmNoYXJBdCgwKSA9PT0gXCI/XCIpIHN0cmluZyA9IHN0cmluZy5zbGljZSgxKVxuXHR2YXIgZW50cmllcyA9IHN0cmluZy5zcGxpdChcIiZcIiksIGRhdGEwID0ge30sIGNvdW50ZXJzID0ge31cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGVudHJ5ID0gZW50cmllc1tpXS5zcGxpdChcIj1cIilcblx0XHR2YXIga2V5NSA9IGRlY29kZVVSSUNvbXBvbmVudChlbnRyeVswXSlcblx0XHR2YXIgdmFsdWUgPSBlbnRyeS5sZW5ndGggPT09IDIgPyBkZWNvZGVVUklDb21wb25lbnQoZW50cnlbMV0pIDogXCJcIlxuXHRcdGlmICh2YWx1ZSA9PT0gXCJ0cnVlXCIpIHZhbHVlID0gdHJ1ZVxuXHRcdGVsc2UgaWYgKHZhbHVlID09PSBcImZhbHNlXCIpIHZhbHVlID0gZmFsc2Vcblx0XHR2YXIgbGV2ZWxzID0ga2V5NS5zcGxpdCgvXFxdXFxbP3xcXFsvKVxuXHRcdHZhciBjdXJzb3IgPSBkYXRhMFxuXHRcdGlmIChrZXk1LmluZGV4T2YoXCJbXCIpID4gLTEpIGxldmVscy5wb3AoKVxuXHRcdGZvciAodmFyIGogPSAwOyBqIDwgbGV2ZWxzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHR2YXIgbGV2ZWwgPSBsZXZlbHNbal0sIG5leHRMZXZlbCA9IGxldmVsc1tqICsgMV1cblx0XHRcdHZhciBpc051bWJlciA9IG5leHRMZXZlbCA9PSBcIlwiIHx8ICFpc05hTihwYXJzZUludChuZXh0TGV2ZWwsIDEwKSlcblx0XHRcdHZhciBpc1ZhbHVlID0gaiA9PT0gbGV2ZWxzLmxlbmd0aCAtIDFcblx0XHRcdGlmIChsZXZlbCA9PT0gXCJcIikge1xuXHRcdFx0XHR2YXIga2V5NSA9IGxldmVscy5zbGljZSgwLCBqKS5qb2luKClcblx0XHRcdFx0aWYgKGNvdW50ZXJzW2tleTVdID09IG51bGwpIGNvdW50ZXJzW2tleTVdID0gMFxuXHRcdFx0XHRsZXZlbCA9IGNvdW50ZXJzW2tleTVdKytcblx0XHRcdH1cblx0XHRcdGlmIChjdXJzb3JbbGV2ZWxdID09IG51bGwpIHtcblx0XHRcdFx0Y3Vyc29yW2xldmVsXSA9IGlzVmFsdWUgPyB2YWx1ZSA6IGlzTnVtYmVyID8gW10gOiB7fVxuXHRcdFx0fVxuXHRcdFx0Y3Vyc29yID0gY3Vyc29yW2xldmVsXVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gZGF0YTBcbn1cbnZhciBjb3JlUm91dGVyID0gZnVuY3Rpb24oJHdpbmRvdykge1xuXHR2YXIgc3VwcG9ydHNQdXNoU3RhdGUgPSB0eXBlb2YgJHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSA9PT0gXCJmdW5jdGlvblwiXG5cdHZhciBjYWxsQXN5bmMwID0gdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiID8gc2V0SW1tZWRpYXRlIDogc2V0VGltZW91dFxuXHRmdW5jdGlvbiBub3JtYWxpemUxKGZyYWdtZW50MCkge1xuXHRcdHZhciBkYXRhID0gJHdpbmRvdy5sb2NhdGlvbltmcmFnbWVudDBdLnJlcGxhY2UoLyg/OiVbYS1mODldW2EtZjAtOV0pKy9naW0sIGRlY29kZVVSSUNvbXBvbmVudClcblx0XHRpZiAoZnJhZ21lbnQwID09PSBcInBhdGhuYW1lXCIgJiYgZGF0YVswXSAhPT0gXCIvXCIpIGRhdGEgPSBcIi9cIiArIGRhdGFcblx0XHRyZXR1cm4gZGF0YVxuXHR9XG5cdHZhciBhc3luY0lkXG5cdGZ1bmN0aW9uIGRlYm91bmNlQXN5bmMoY2FsbGJhY2swKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKGFzeW5jSWQgIT0gbnVsbCkgcmV0dXJuXG5cdFx0XHRhc3luY0lkID0gY2FsbEFzeW5jMChmdW5jdGlvbigpIHtcblx0XHRcdFx0YXN5bmNJZCA9IG51bGxcblx0XHRcdFx0Y2FsbGJhY2swKClcblx0XHRcdH0pXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHBhcnNlUGF0aChwYXRoLCBxdWVyeURhdGEsIGhhc2hEYXRhKSB7XG5cdFx0dmFyIHF1ZXJ5SW5kZXggPSBwYXRoLmluZGV4T2YoXCI/XCIpXG5cdFx0dmFyIGhhc2hJbmRleCA9IHBhdGguaW5kZXhPZihcIiNcIilcblx0XHR2YXIgcGF0aEVuZCA9IHF1ZXJ5SW5kZXggPiAtMSA/IHF1ZXJ5SW5kZXggOiBoYXNoSW5kZXggPiAtMSA/IGhhc2hJbmRleCA6IHBhdGgubGVuZ3RoXG5cdFx0aWYgKHF1ZXJ5SW5kZXggPiAtMSkge1xuXHRcdFx0dmFyIHF1ZXJ5RW5kID0gaGFzaEluZGV4ID4gLTEgPyBoYXNoSW5kZXggOiBwYXRoLmxlbmd0aFxuXHRcdFx0dmFyIHF1ZXJ5UGFyYW1zID0gcGFyc2VRdWVyeVN0cmluZyhwYXRoLnNsaWNlKHF1ZXJ5SW5kZXggKyAxLCBxdWVyeUVuZCkpXG5cdFx0XHRmb3IgKHZhciBrZXk0IGluIHF1ZXJ5UGFyYW1zKSBxdWVyeURhdGFba2V5NF0gPSBxdWVyeVBhcmFtc1trZXk0XVxuXHRcdH1cblx0XHRpZiAoaGFzaEluZGV4ID4gLTEpIHtcblx0XHRcdHZhciBoYXNoUGFyYW1zID0gcGFyc2VRdWVyeVN0cmluZyhwYXRoLnNsaWNlKGhhc2hJbmRleCArIDEpKVxuXHRcdFx0Zm9yICh2YXIga2V5NCBpbiBoYXNoUGFyYW1zKSBoYXNoRGF0YVtrZXk0XSA9IGhhc2hQYXJhbXNba2V5NF1cblx0XHR9XG5cdFx0cmV0dXJuIHBhdGguc2xpY2UoMCwgcGF0aEVuZClcblx0fVxuXHR2YXIgcm91dGVyID0ge3ByZWZpeDogXCIjIVwifVxuXHRyb3V0ZXIuZ2V0UGF0aCA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0eXBlMiA9IHJvdXRlci5wcmVmaXguY2hhckF0KDApXG5cdFx0c3dpdGNoICh0eXBlMikge1xuXHRcdFx0Y2FzZSBcIiNcIjogcmV0dXJuIG5vcm1hbGl6ZTEoXCJoYXNoXCIpLnNsaWNlKHJvdXRlci5wcmVmaXgubGVuZ3RoKVxuXHRcdFx0Y2FzZSBcIj9cIjogcmV0dXJuIG5vcm1hbGl6ZTEoXCJzZWFyY2hcIikuc2xpY2Uocm91dGVyLnByZWZpeC5sZW5ndGgpICsgbm9ybWFsaXplMShcImhhc2hcIilcblx0XHRcdGRlZmF1bHQ6IHJldHVybiBub3JtYWxpemUxKFwicGF0aG5hbWVcIikuc2xpY2Uocm91dGVyLnByZWZpeC5sZW5ndGgpICsgbm9ybWFsaXplMShcInNlYXJjaFwiKSArIG5vcm1hbGl6ZTEoXCJoYXNoXCIpXG5cdFx0fVxuXHR9XG5cdHJvdXRlci5zZXRQYXRoID0gZnVuY3Rpb24ocGF0aCwgZGF0YSwgb3B0aW9ucykge1xuXHRcdHZhciBxdWVyeURhdGEgPSB7fSwgaGFzaERhdGEgPSB7fVxuXHRcdHBhdGggPSBwYXJzZVBhdGgocGF0aCwgcXVlcnlEYXRhLCBoYXNoRGF0YSlcblx0XHRpZiAoZGF0YSAhPSBudWxsKSB7XG5cdFx0XHRmb3IgKHZhciBrZXk0IGluIGRhdGEpIHF1ZXJ5RGF0YVtrZXk0XSA9IGRhdGFba2V5NF1cblx0XHRcdHBhdGggPSBwYXRoLnJlcGxhY2UoLzooW15cXC9dKykvZywgZnVuY3Rpb24obWF0Y2gyLCB0b2tlbikge1xuXHRcdFx0XHRkZWxldGUgcXVlcnlEYXRhW3Rva2VuXVxuXHRcdFx0XHRyZXR1cm4gZGF0YVt0b2tlbl1cblx0XHRcdH0pXG5cdFx0fVxuXHRcdHZhciBxdWVyeSA9IGJ1aWxkUXVlcnlTdHJpbmcocXVlcnlEYXRhKVxuXHRcdGlmIChxdWVyeSkgcGF0aCArPSBcIj9cIiArIHF1ZXJ5XG5cdFx0dmFyIGhhc2ggPSBidWlsZFF1ZXJ5U3RyaW5nKGhhc2hEYXRhKVxuXHRcdGlmIChoYXNoKSBwYXRoICs9IFwiI1wiICsgaGFzaFxuXHRcdGlmIChzdXBwb3J0c1B1c2hTdGF0ZSkge1xuXHRcdFx0dmFyIHN0YXRlID0gb3B0aW9ucyA/IG9wdGlvbnMuc3RhdGUgOiBudWxsXG5cdFx0XHR2YXIgdGl0bGUgPSBvcHRpb25zID8gb3B0aW9ucy50aXRsZSA6IG51bGxcblx0XHRcdCR3aW5kb3cub25wb3BzdGF0ZSgpXG5cdFx0XHRpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlcGxhY2UpICR3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoc3RhdGUsIHRpdGxlLCByb3V0ZXIucHJlZml4ICsgcGF0aClcblx0XHRcdGVsc2UgJHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZShzdGF0ZSwgdGl0bGUsIHJvdXRlci5wcmVmaXggKyBwYXRoKVxuXHRcdH1cblx0XHRlbHNlICR3aW5kb3cubG9jYXRpb24uaHJlZiA9IHJvdXRlci5wcmVmaXggKyBwYXRoXG5cdH1cblx0cm91dGVyLmRlZmluZVJvdXRlcyA9IGZ1bmN0aW9uKHJvdXRlcywgcmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0ZnVuY3Rpb24gcmVzb2x2ZVJvdXRlKCkge1xuXHRcdFx0dmFyIHBhdGggPSByb3V0ZXIuZ2V0UGF0aCgpXG5cdFx0XHR2YXIgcGFyYW1zID0ge31cblx0XHRcdHZhciBwYXRobmFtZSA9IHBhcnNlUGF0aChwYXRoLCBwYXJhbXMsIHBhcmFtcylcblx0XHRcdHZhciBzdGF0ZSA9ICR3aW5kb3cuaGlzdG9yeS5zdGF0ZVxuXHRcdFx0aWYgKHN0YXRlICE9IG51bGwpIHtcblx0XHRcdFx0Zm9yICh2YXIgayBpbiBzdGF0ZSkgcGFyYW1zW2tdID0gc3RhdGVba11cblx0XHRcdH1cblx0XHRcdGZvciAodmFyIHJvdXRlMCBpbiByb3V0ZXMpIHtcblx0XHRcdFx0dmFyIG1hdGNoZXIgPSBuZXcgUmVnRXhwKFwiXlwiICsgcm91dGUwLnJlcGxhY2UoLzpbXlxcL10rP1xcLnszfS9nLCBcIiguKj8pXCIpLnJlcGxhY2UoLzpbXlxcL10rL2csIFwiKFteXFxcXC9dKylcIikgKyBcIlxcLz8kXCIpXG5cdFx0XHRcdGlmIChtYXRjaGVyLnRlc3QocGF0aG5hbWUpKSB7XG5cdFx0XHRcdFx0cGF0aG5hbWUucmVwbGFjZShtYXRjaGVyLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHZhciBrZXlzID0gcm91dGUwLm1hdGNoKC86W15cXC9dKy9nKSB8fCBbXVxuXHRcdFx0XHRcdFx0dmFyIHZhbHVlcyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxLCAtMilcblx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRwYXJhbXNba2V5c1tpXS5yZXBsYWNlKC86fFxcLi9nLCBcIlwiKV0gPSBkZWNvZGVVUklDb21wb25lbnQodmFsdWVzW2ldKVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmVzb2x2ZShyb3V0ZXNbcm91dGUwXSwgcGFyYW1zLCBwYXRoLCByb3V0ZTApXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmVqZWN0KHBhdGgsIHBhcmFtcylcblx0XHR9XG5cdFx0aWYgKHN1cHBvcnRzUHVzaFN0YXRlKSAkd2luZG93Lm9ucG9wc3RhdGUgPSBkZWJvdW5jZUFzeW5jKHJlc29sdmVSb3V0ZSlcblx0XHRlbHNlIGlmIChyb3V0ZXIucHJlZml4LmNoYXJBdCgwKSA9PT0gXCIjXCIpICR3aW5kb3cub25oYXNoY2hhbmdlID0gcmVzb2x2ZVJvdXRlXG5cdFx0cmVzb2x2ZVJvdXRlKClcblx0fVxuXHRyZXR1cm4gcm91dGVyXG59XG52YXIgXzIwID0gZnVuY3Rpb24oJHdpbmRvdywgcmVkcmF3U2VydmljZTApIHtcblx0dmFyIHJvdXRlU2VydmljZSA9IGNvcmVSb3V0ZXIoJHdpbmRvdylcblx0dmFyIGlkZW50aXR5ID0gZnVuY3Rpb24odikge3JldHVybiB2fVxuXHR2YXIgcmVuZGVyMSwgY29tcG9uZW50LCBhdHRyczMsIGN1cnJlbnRQYXRoLCBsYXN0VXBkYXRlXG5cdHZhciByb3V0ZSA9IGZ1bmN0aW9uKHJvb3QsIGRlZmF1bHRSb3V0ZSwgcm91dGVzKSB7XG5cdFx0aWYgKHJvb3QgPT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKFwiRW5zdXJlIHRoZSBET00gZWxlbWVudCB0aGF0IHdhcyBwYXNzZWQgdG8gYG0ucm91dGVgIGlzIG5vdCB1bmRlZmluZWRcIilcblx0XHR2YXIgcnVuMSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKHJlbmRlcjEgIT0gbnVsbCkgcmVkcmF3U2VydmljZTAucmVuZGVyKHJvb3QsIHJlbmRlcjEoVm5vZGUoY29tcG9uZW50LCBhdHRyczMua2V5LCBhdHRyczMpKSlcblx0XHR9XG5cdFx0dmFyIGJhaWwgPSBmdW5jdGlvbihwYXRoKSB7XG5cdFx0XHRpZiAocGF0aCAhPT0gZGVmYXVsdFJvdXRlKSByb3V0ZVNlcnZpY2Uuc2V0UGF0aChkZWZhdWx0Um91dGUsIG51bGwsIHtyZXBsYWNlOiB0cnVlfSlcblx0XHRcdGVsc2UgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IHJlc29sdmUgZGVmYXVsdCByb3V0ZSBcIiArIGRlZmF1bHRSb3V0ZSlcblx0XHR9XG5cdFx0cm91dGVTZXJ2aWNlLmRlZmluZVJvdXRlcyhyb3V0ZXMsIGZ1bmN0aW9uKHBheWxvYWQsIHBhcmFtcywgcGF0aCkge1xuXHRcdFx0dmFyIHVwZGF0ZSA9IGxhc3RVcGRhdGUgPSBmdW5jdGlvbihyb3V0ZVJlc29sdmVyLCBjb21wKSB7XG5cdFx0XHRcdGlmICh1cGRhdGUgIT09IGxhc3RVcGRhdGUpIHJldHVyblxuXHRcdFx0XHRjb21wb25lbnQgPSBjb21wICE9IG51bGwgJiYgKHR5cGVvZiBjb21wLnZpZXcgPT09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgY29tcCA9PT0gXCJmdW5jdGlvblwiKT8gY29tcCA6IFwiZGl2XCJcblx0XHRcdFx0YXR0cnMzID0gcGFyYW1zLCBjdXJyZW50UGF0aCA9IHBhdGgsIGxhc3RVcGRhdGUgPSBudWxsXG5cdFx0XHRcdHJlbmRlcjEgPSAocm91dGVSZXNvbHZlci5yZW5kZXIgfHwgaWRlbnRpdHkpLmJpbmQocm91dGVSZXNvbHZlcilcblx0XHRcdFx0cnVuMSgpXG5cdFx0XHR9XG5cdFx0XHRpZiAocGF5bG9hZC52aWV3IHx8IHR5cGVvZiBwYXlsb2FkID09PSBcImZ1bmN0aW9uXCIpIHVwZGF0ZSh7fSwgcGF5bG9hZClcblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRpZiAocGF5bG9hZC5vbm1hdGNoKSB7XG5cdFx0XHRcdFx0UHJvbWlzZS5yZXNvbHZlKHBheWxvYWQub25tYXRjaChwYXJhbXMsIHBhdGgpKS50aGVuKGZ1bmN0aW9uKHJlc29sdmVkKSB7XG5cdFx0XHRcdFx0XHR1cGRhdGUocGF5bG9hZCwgcmVzb2x2ZWQpXG5cdFx0XHRcdFx0fSwgYmFpbClcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHVwZGF0ZShwYXlsb2FkLCBcImRpdlwiKVxuXHRcdFx0fVxuXHRcdH0sIGJhaWwpXG5cdFx0cmVkcmF3U2VydmljZTAuc3Vic2NyaWJlKHJvb3QsIHJ1bjEpXG5cdH1cblx0cm91dGUuc2V0ID0gZnVuY3Rpb24ocGF0aCwgZGF0YSwgb3B0aW9ucykge1xuXHRcdGlmIChsYXN0VXBkYXRlICE9IG51bGwpIHtcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cdFx0XHRvcHRpb25zLnJlcGxhY2UgPSB0cnVlXG5cdFx0fVxuXHRcdGxhc3RVcGRhdGUgPSBudWxsXG5cdFx0cm91dGVTZXJ2aWNlLnNldFBhdGgocGF0aCwgZGF0YSwgb3B0aW9ucylcblx0fVxuXHRyb3V0ZS5nZXQgPSBmdW5jdGlvbigpIHtyZXR1cm4gY3VycmVudFBhdGh9XG5cdHJvdXRlLnByZWZpeCA9IGZ1bmN0aW9uKHByZWZpeDApIHtyb3V0ZVNlcnZpY2UucHJlZml4ID0gcHJlZml4MH1cblx0cm91dGUubGluayA9IGZ1bmN0aW9uKHZub2RlMSkge1xuXHRcdHZub2RlMS5kb20uc2V0QXR0cmlidXRlKFwiaHJlZlwiLCByb3V0ZVNlcnZpY2UucHJlZml4ICsgdm5vZGUxLmF0dHJzLmhyZWYpXG5cdFx0dm5vZGUxLmRvbS5vbmNsaWNrID0gZnVuY3Rpb24oZSkge1xuXHRcdFx0aWYgKGUuY3RybEtleSB8fCBlLm1ldGFLZXkgfHwgZS5zaGlmdEtleSB8fCBlLndoaWNoID09PSAyKSByZXR1cm5cblx0XHRcdGUucHJldmVudERlZmF1bHQoKVxuXHRcdFx0ZS5yZWRyYXcgPSBmYWxzZVxuXHRcdFx0dmFyIGhyZWYgPSB0aGlzLmdldEF0dHJpYnV0ZShcImhyZWZcIilcblx0XHRcdGlmIChocmVmLmluZGV4T2Yocm91dGVTZXJ2aWNlLnByZWZpeCkgPT09IDApIGhyZWYgPSBocmVmLnNsaWNlKHJvdXRlU2VydmljZS5wcmVmaXgubGVuZ3RoKVxuXHRcdFx0cm91dGUuc2V0KGhyZWYsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKVxuXHRcdH1cblx0fVxuXHRyb3V0ZS5wYXJhbSA9IGZ1bmN0aW9uKGtleTMpIHtcblx0XHRpZih0eXBlb2YgYXR0cnMzICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBrZXkzICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gYXR0cnMzW2tleTNdXG5cdFx0cmV0dXJuIGF0dHJzM1xuXHR9XG5cdHJldHVybiByb3V0ZVxufVxubS5yb3V0ZSA9IF8yMCh3aW5kb3csIHJlZHJhd1NlcnZpY2UpXG5tLndpdGhBdHRyID0gZnVuY3Rpb24oYXR0ck5hbWUsIGNhbGxiYWNrMSwgY29udGV4dCkge1xuXHRyZXR1cm4gZnVuY3Rpb24oZSkge1xuXHRcdGNhbGxiYWNrMS5jYWxsKGNvbnRleHQgfHwgdGhpcywgYXR0ck5hbWUgaW4gZS5jdXJyZW50VGFyZ2V0ID8gZS5jdXJyZW50VGFyZ2V0W2F0dHJOYW1lXSA6IGUuY3VycmVudFRhcmdldC5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpKVxuXHR9XG59XG52YXIgXzI4ID0gY29yZVJlbmRlcmVyKHdpbmRvdylcbm0ucmVuZGVyID0gXzI4LnJlbmRlclxubS5yZWRyYXcgPSByZWRyYXdTZXJ2aWNlLnJlZHJhd1xubS5yZXF1ZXN0ID0gcmVxdWVzdFNlcnZpY2UucmVxdWVzdFxubS5qc29ucCA9IHJlcXVlc3RTZXJ2aWNlLmpzb25wXG5tLnBhcnNlUXVlcnlTdHJpbmcgPSBwYXJzZVF1ZXJ5U3RyaW5nXG5tLmJ1aWxkUXVlcnlTdHJpbmcgPSBidWlsZFF1ZXJ5U3RyaW5nXG5tLnZlcnNpb24gPSBcIjEuMS4zXCJcbm0udm5vZGUgPSBWbm9kZVxuaWYgKHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIpIG1vZHVsZVtcImV4cG9ydHNcIl0gPSBtXG5lbHNlIHdpbmRvdy5tID0gbVxufSgpKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbWl0aHJpbC9taXRocmlsLmpzXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n')},function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\nexports.fakeClick = exports.hexToRgba = exports.popoverContent = exports.summary = exports.mytour3 = exports.mytour = exports.step = exports.restart = exports.reset = exports.byId = exports.estimateLadda = exports.d3mProblemDescription = exports.d3mMetrics = exports.d3mTaskSubtype = exports.d3mTaskType = exports.domainIdentifier = exports.callHistory = exports.links = exports.nodes = exports.allResults = exports.allNodes = exports.valueKey = exports.modelCount = exports.disco = exports.zparams = exports.logArray = exports.locktoggle = exports.transformList = exports.righttab = exports.summaryHold = exports.subset = exports.lefttab = exports.timeColor = exports.varColor = exports.nomColor = exports.gr2Color = exports.gr1Color = exports.dvColor = exports.csColor = exports.cdb = exports.task2_finished = exports.task1_finished = exports.is_results_mode = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();\n\nvar _arguments = arguments;\nexports.set_explore_mode = set_explore_mode;\nexports.set_righttab = set_righttab;\nexports.main = main;\nexports.findNodeIndex = findNodeIndex;\nexports.findNode = findNode;\nexports.clickVar = clickVar;\nexports.getVariableData = getVariableData;\nexports.forceSwitch = forceSwitch;\nexports.helpmaterials = helpmaterials;\nexports.lockDescription = lockDescription;\nexports.zPop = zPop;\nexports.downloadIncomplete = downloadIncomplete;\nexports.estimate = estimate;\nexports.ta2stuff = ta2stuff;\nexports.makeRequest = makeRequest;\nexports.legend = legend;\nexports.erase = erase;\nexports.tabLeft = tabLeft;\nexports.tabRight = tabRight;\nexports.panelPlots = panelPlots;\nexports.borderState = borderState;\nexports.subsetSelect = subsetSelect;\nexports.endsession = endsession;\nexports.deletepipelines = deletepipelines;\nexports.cancelpipelines = cancelpipelines;\nexports.listpipelines = listpipelines;\nexports.executepipeline = executepipeline;\nexports.expandrightpanel = expandrightpanel;\nexports.btnWidths = btnWidths;\nexports.resultsplotinit = resultsplotinit;\nexports.genconfdata = genconfdata;\nexports.confusionmatrix = confusionmatrix;\nexports.bivariatePlot = bivariatePlot;\nexports.setxTable = setxTable;\nexports.exportpipeline = exportpipeline;\nexports.deletepipeline = deletepipeline;\nexports.ta3_search_message = ta3_search_message;\nexports.test_msg_ta3_search = test_msg_ta3_search;\nexports.end_ta3_search = end_ta3_search;\nexports.record_user_metadata = record_user_metadata;\nexports.showPredPlot = showPredPlot;\nexports.showGenPreds = showGenPreds;\nexports.discovery = discovery;\nexports.probDiscView = probDiscView;\nexports.submitDiscProb = submitDiscProb;\nexports.saveDisc = saveDisc;\n\nvar _hopscotch = __webpack_require__(4);\n\nvar _hopscotch2 = _interopRequireDefault(_hopscotch);\n\nvar _mithril = __webpack_require__(0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _plots = __webpack_require__(2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// hostname default - the app will use it to obtain the variable metadata\n// (ddi) and pre-processed data info if the file id is supplied as an\n// argument (for ex., gui.html?dfId=17), but hostname isn\'t.\n// Edit it to suit your installation.\n// (NOTE that if the file id isn\'t supplied, the app will default to the\n// local files specified below!)\n// NEW: it is also possible now to supply complete urls for the ddi and\n// the tab-delimited data file; the parameters are ddiurl and dataurl.\n// These new parameters are optional. If they are not supplied, the app\n// will go the old route - will try to cook standard dataverse urls\n// for both the data and metadata, if the file id is supplied; or the\n// local files if nothing is supplied.\n\n//-------------------------------------------------\n// NOTE: global variables are now set in the index.html file.\n//    Developers, see /template/index.html\n//-------------------------------------------------\n\nvar is_results_mode = exports.is_results_mode = false;\nvar task1_finished = exports.task1_finished = false;\nvar task2_finished = exports.task2_finished = false;\n\nvar is_explore_mode = false;\nfunction set_explore_mode(val) {\n    is_explore_mode = val;\n}\n\n// for debugging - if not in PRODUCTION, prints args\nvar cdb = exports.cdb = function cdb(_) {\n    var _console;\n\n    return PRODUCTION || (_console = console).log.apply(_console, _arguments);\n};\n\nvar k = 4; // strength parameter for group attraction/repulsion\nvar tutorial_mode = true;\nvar first_load = true;\n\n// initial color scale used to establish the initial colors of nodes\n// allNodes.push() below establishes a field for the master node array allNodes called "nodeCol" and assigns a color from this scale to that field\n// everything there after should refer to the nodeCol and not the color scale, this enables us to update colors and pass the variable type to R based on its coloring\nvar colors = d3.scale.category20();\nvar csColor = exports.csColor = \'#419641\';\nvar dvColor = exports.dvColor = \'#28a4c9\';\nvar gr1Color = exports.gr1Color = \'#14bdcc\'; // initially was #24a4c9\', but that is dvColor, and we track some properties by color assuming them unique\nvar gr1Opacity = [0, 1];\nvar gr2Color = exports.gr2Color = \'#ffcccc\';\nvar gr2Opacity = [0, 1];\n\nvar grayColor = \'#c0c0c0\';\nvar nomColor = exports.nomColor = \'#ff6600\';\nvar varColor = exports.varColor = \'#f0f8ff\'; // d3.rgb("aliceblue");\nvar taggedColor = \'#f5f5f5\'; // d3.rgb("whitesmoke");\nvar timeColor = exports.timeColor = \'#2d6ca2\';\n\nvar lefttab = exports.lefttab = \'tab1\'; // current tab in left panel\nvar subset = exports.subset = false;\nvar summaryHold = exports.summaryHold = false;\n\nvar righttab = exports.righttab = \'btnModels\'; // current tab in right panel\nfunction set_righttab(val) {\n    exports.righttab = righttab = val;\n}\n\n// transformation toolbar options\nvar t = void 0,\n    typeTransform = void 0;\nvar transformList = exports.transformList = \'log(d) exp(d) d^2 sqrt(d) interact(d,e)\'.split(\' \');\nvar transformVar = \'\';\n\n// var list for each space contain variables in original data\n// plus trans in that space\nvar trans = [];\nvar preprocess = {}; // hold pre-processed data\nvar spaces = [];\n\n// layout function constants\nvar layoutAdd = "add";\nvar layoutMove = "move";\n\n// radius of circle\nvar RADIUS = 40;\n\n// cx, cy, r values for indicator lights\nvar ind1 = [(RADIUS + 30) * Math.cos(1.3), -1 * (RADIUS + 30) * Math.sin(1.3), 5];\nvar ind2 = [(RADIUS + 30) * Math.cos(1.1), -1 * (RADIUS + 30) * Math.sin(1.1), 5];\n\n// space index\nvar myspace = 0;\n\nvar forcetoggle = ["true"];\nvar locktoggle = exports.locktoggle = true;\nvar priv = true;\n\n// swandive is our graceful fail for d3m\n// swandive set to true if task is in failset\nvar swandive = false;\nvar failset = ["TIMESERIESFORECASTING", "GRAPHMATCHING", "LINKPREDICTION", "timeSeriesForecasting", "graphMatching", "linkPrediction"];\n\n// object that contains all information about the returned pipelines\nvar allPipelineInfo = {};\n\nvar logArray = exports.logArray = [];\nvar zparams = exports.zparams = {\n    zdata: [],\n    zedges: [],\n    ztime: [],\n    znom: [],\n    zcross: [],\n    zmodel: "",\n    zvars: [],\n    zdv: [],\n    zgroup1: [],\n    zgroup2: [], // hard coding to two groups for present experiments, but will eventually make zgroup array of arrays, with zgroup.lenght the number of groups\n    zdataurl: "",\n    zd3mdata: "", //these take the place of zdataurl for d3m, because data is in two placees. eventually will generalize\n    zd3mtarget: "",\n    zsubset: [],\n    zsetx: [],\n    zmodelcount: 0,\n    zplot: [],\n    zsessionid: "",\n    zdatacite: \'...\',\n    zcrosstab: [],\n    zusername: \'\'\n};\n\nvar disco = exports.disco = [];\n\nvar modelCount = exports.modelCount = 0;\nvar valueKey = exports.valueKey = [];\nvar allNodes = exports.allNodes = [];\nvar allResults = exports.allResults = [];\nvar nodes = exports.nodes = [];\nvar links = exports.links = [];\nvar mods = {};\nvar estimated = false;\nvar rightClickLast = false;\nvar selInteract = false;\nvar callHistory = exports.callHistory = []; // transform and subset calls\nvar mytarget = \'\';\n\nvar configurations = {};\nvar datadocument = {};\n\nvar domainIdentifier = exports.domainIdentifier = null; // available throughout apps js; used for saving workspace\n\n// eventually read this from the schema with real descriptions\n// metrics, tasks, and subtasks as specified in D3M schemas\n// MEAN SQUARED ERROR IS SET TO SAME AS RMSE. MSE is in schema but not proto\nvar d3mTaskType = exports.d3mTaskType = {\n    taskTypeUndefined: ["description", "TASK_TYPE_UNDEFINED", 0],\n    classification: ["description", "CLASSIFICATION", 1],\n    regression: ["description", "REGRESSION", 2],\n    clustering: ["description", "CLUSTERING", 3],\n    linkPrediction: ["description", "LINK_PREDICTION", 4],\n    vertexNomination: ["description", "VERTEX_NOMINATION", 5],\n    communityDetection: ["description", "COMMUNITY_DETECTION", 6],\n    graphClustering: ["description", "GRAPH_CLUSTERING", 7],\n    graphMatching: ["description", "GRAPH_MATCHING", 8],\n    timeSeriesForecasting: ["description", "TIME_SERIES_FORECASTING", 9],\n    collaborativeFiltering: ["description", "COLLABORATIVE_FILTERING", 10]\n};\n\nvar d3mTaskSubtype = exports.d3mTaskSubtype = {\n    taskSubtypeUndefined: ["description", "TASK_SUBTYPE_UNDEFINED", 0],\n    subtypeNone: ["description", "NONE", 1],\n    binary: ["description", "BINARY", 2],\n    multiClass: ["description", "MULTICLASS", 3],\n    multiLabel: ["description", "MULTILABEL", 4],\n    univariate: ["description", "UNIVARIATE", 5],\n    multivariate: ["description", "MULTIVARIATE", 6],\n    overlapping: ["description", "OVERLAPPING", 7],\n    nonOverlapping: ["description", "NONOVERLAPPING", 8]\n};\n/*export let d3mOutputType = {\n    outputUndefined:["description","OUTPUT_TYPE_UNDEFINED ", 0],\n    predictionsFile:["description","PREDICTIONS_FILE",1],\n    scoresFile:["description","SCORES_FILE",2]\n}; */\nvar d3mMetrics = exports.d3mMetrics = {\n    metricUndefined: ["description", "METRIC_UNDEFINED", 0],\n    executionTime: ["description", "EXECUTION_TIME", 1],\n    accuracy: ["description", "ACCURACY", 2],\n    f1: ["description", "F1", 3],\n    f1Micro: ["description", "F1_MICRO", 4],\n    f1Macro: ["description", "F1_MACRO", 5],\n    rocAuc: ["description", "ROC_AUC", 6],\n    rocAucMicro: ["description", "ROC_AUC_MICRO", 7],\n    rocAucMacro: ["description", "ROC_AUC_MACRO", 8],\n    meanSquaredError: ["description", "MEAN_SQUARED_ERROR", 9],\n    rootMeanSquaredError: ["description", "ROOT_MEAN_SQUARED_ERROR", 10],\n    rootMeanSquaredErrorAvg: ["description", "ROOT_MEAN_SQUARED_ERROR_AVG", 11],\n    meanAbsoluteError: ["description", "MEAN_ABSOLUTE_ERROR", 12],\n    rSquared: ["description", "R_SQUARED", 13],\n    normalizedMutualInformation: ["description", "NORMALIZED_MUTUAL_INFORMATION", 14],\n    jaccardSimilarityScore: ["description", "JACCARD_SIMILARITY_SCORE", 15]\n};\n\nvar d3mProblemDescription = exports.d3mProblemDescription = {\n    taskType: "taskTypeUndefined",\n    taskSubtype: "taskSubtypeUndefined",\n    //   outputType: [3,"DEFAULT"],\n    metric: "metricUndefined",\n    taskDescription: ""\n};\n\nvar svg = void 0,\n    width = void 0,\n    height = void 0,\n    div = void 0,\n    selectLadda = void 0;\nvar estimateLadda = exports.estimateLadda = void 0;\n\n// arcs for denoting pebble characteristics\nvar arc = function arc(start, end) {\n    return d3.svg.arc().innerRadius(RADIUS + 5).outerRadius(RADIUS + 20).startAngle(start).endAngle(end);\n};\nvar _ref = [arc(0, 3.2), arc(0, 1), arc(1.1, 2.2), arc(2.3, 3.3), arc(4.3, 5.3)],\n    arc0 = _ref[0],\n    arc1 = _ref[1],\n    arc2 = _ref[2],\n    arc3 = _ref[3],\n    arc4 = _ref[4];\n\nvar arcInd = function arcInd(arclimits) {\n    return d3.svg.arc().innerRadius(RADIUS + 22).outerRadius(RADIUS + 37).startAngle(arclimits[0]).endAngle(arclimits[1]);\n};\n\nvar arcInd1Limits = [0, 0.3],\n    arcInd2Limits = [0.35, 0.65];\nvar _ref2 = [arcInd(arcInd1Limits), arcInd(arcInd2Limits)],\n    arcInd1 = _ref2[0],\n    arcInd2 = _ref2[1];\nvar byId = exports.byId = function byId(id) {\n    return document.getElementById(id);\n};\n\n/**\n   page reload linked to btnReset\n*/\nvar reset = exports.reset = function reloadPage() {\n    location.reload();\n};\nvar _restart = void 0;\n\nexports.restart = _restart;\nvar dataurl = \'\';\n\nvar step = exports.step = function step(target, placement, title, content) {\n    return {\n        target: target,\n        placement: placement,\n        title: title,\n        content: content,\n        showCTAButton: true,\n        ctaLabel: \'Disable these messages\',\n        onCTA: function onCTA() {\n            _hopscotch2.default.endTour(true);\n            tutorial_mode = false;\n        }\n    };\n};\n\nvar mytour = exports.mytour = {\n    id: "dataset_launch",\n    i18n: { doneBtn: \'Ok\' },\n    showCloseButton: true,\n    scrollDuration: 300,\n    onEnd: function onEnd() {\n        return first_load = false;\n    },\n    steps: [step("dataName", "bottom", "Welcome to TwoRavens Solver", \'<p>This tool can guide you to solve an empirical problem in the dataset above.</p>\\n                      <p>These messages will teach you the steps to take to find and submit a solution.</p>\'), step("btnReset", "bottom", "Restart Any Problem Here", \'<p>You can always start a problem over by using this reset button.</p>\'), step("btnSubset", "right", "Start Task 1", \'<p>This Problem Discovery button allows you to start Task 1 - Problem Discovery.</p>\\n                     <p>Generally, as a tip, the Green button is the next button you need to press to move the current task forward.</p>\\n                     <p>Click this button to see a list of problems that have been discovered in the dataset.</p>\\n                     <p>You can mark which ones you agree may be interesting, and then submit the table as an answer.</p>\'),\n    //step("btnSelect", "right", "Complete Task 1",\n    //     `<p>This submission button marks Task 1 - Problem Discovery, as complete.</p>\n    //     <p>Click this button to save the check marked problems in the table below as potentially interesting or relevant.</p>\n    //     <p>Generally, as a tip, the Green button is the next button you need to press to move the current task forward.</p>`),\n    step("btnEstimate", "left", "Solve Task 2", \'<p>This generally is the important step to follow for Task 2 - Build a Model.</p>\\n                      <p>Generally, as a tip, the Green button is the next button you need to press to move the current task forward, and this button will be Green when Task 1 is completed and Task 2 started.</p>\\n                      <p>Click this Solve button to tell the tool to find a solution to the problem, using the variables presented in the center panel.</p>\'), step(mytarget + \'biggroup\', "left", "Target Variable", \'This is the variable, \' + mytarget + \', we are trying to predict.\\n                      This center panel graphically represents the problem currently being attempted.\'), step("gr1hull", "right", "Explanation Set", "This set of variables can potentially predict the target."), step("displacement", "right", "Variable List", \'<p>Click on any variable name here if you wish to remove it from the problem solution.</p>\\n                      <p>You likely do not need to adjust the problem representation in the center panel.</p>\'), step("btnEndSession", "bottom", "Finish Problem", "If the solution reported back seems acceptable, then finish this problem by clicking this End Session button.")]\n};\n\nvar mytour3 = exports.mytour3 = {\n    id: "dataset_launch",\n    i18n: { doneBtn: \'Ok\' },\n    showCloseButton: true,\n    scrollDuration: 300,\n    onEnd: function onEnd() {\n        return first_load = false;\n    },\n    steps: [step("btnSelect", "right", "Complete Task 1", \'<p>This submission button marks Task 1 - Problem Discovery, as complete.</p>\\n                     <p>Click this button to save the check marked problems in the table below as potentially interesting or relevant.</p>\\n                     <p>Generally, as a tip, the Green button is the next button you need to press to move the current task forward.</p>\')]\n};\n\n/**\n  called by main\n  Loads all external data in the following order (logic is not included):\n  1. Retrieve the configuration information\n  2. Set \'configurations\'\n  3. Read the problem schema and set \'d3mProblemDescription\'\n  4. Read the data document and set \'datadocument\'\n  5. Read in zelig models (not for d3m)\n  6. Read in zeligchoice models (not for d3m)\n  7. Start the user session\n  8. Read preprocess data or (if necessary) run preprocess\n  9. Build allNodes[] using preprocessed information\n  10. Add datadocument information to allNodes (when in IS_D3M_DOMAIN)\n  11. Call layout() and start up\n*/\nasync function load(hold, lablArray, d3mRootPath, d3mDataName, d3mPreprocess, d3mData, d3mPS, d3mDS, pURL) {\n    if (!IS_D3M_DOMAIN) {\n        return;\n    }\n\n    // 1. Retrieve the configuration information\n    var res = await _mithril2.default.request({\n        method: "POST",\n        url: "/config/d3m-config/json/latest"\n    });\n    console.log(res);\n    // 2. Set \'configurations\'\n    configurations = JSON.parse(JSON.stringify(res)); // this is just copying res\n    d3mRootPath = configurations.training_data_root.replace(/\\/data/, \'\');\n    d3mDataName = configurations.name;\n\n    // scopes at app.js level; used for saving workspace\n    exports.domainIdentifier = domainIdentifier = { name: configurations.name,\n        source_url: configurations.config_url,\n        description: \'D3M config file\' };\n    //id: configurations.id};\n\n    d3mPS = "/config/d3m-config/get-problem-schema/json";\n    d3mDS = "/config/d3m-config/get-dataset-schema/json";\n    console.log("Configurations: ", configurations);\n    d3mPreprocess = pURL = \'rook-custom/rook-files/\' + d3mDataName + \'/preprocess/preprocess.json\';\n\n    // 3. Read the problem schema and set \'d3mProblemDescription\'\n    // ...and make a call to start the session with TA2. if we get this far, data are guaranteed to exist for the frontend\n\n    res = await _mithril2.default.request("/config/d3m-config/get-problem-data-file-info");\n    // The result of this call is similar to below:\n    // example:\n    /*  {\n             "success":true,\n             "data":{\n                "learningData.csv":{\n                   "exists":true,\n                   "size":11654,\n                   "path":"/inputs/dataset_TRAIN/tables/learningData.csv"\n                },\n                "learningData.csv.gz":{\n                   "exists":false,\n                   "size":-1,\n                   "path":"/inputs/dataset_TRAIN/tables/learningData.csv.gz"\n                }\n             }\n          }\n    */\n\n    // Loop through the response above and\n    // pick the first "path" where "exists" is true\n    //\n    // Note: if data files have "exists" as false, stay as default which is null\n    //\n    var set_d3m_data_path = function set_d3m_data_path(field, val) {\n        return res.data[field].exists ? res.data[field].path : res.data[field + \'.gz\'].exists ? res.data[field + \'.gz\'].path : val;\n    };\n\n    zparams.zd3mdata = d3mData = set_d3m_data_path(\'learningData.csv\', d3mData);\n    zparams.zd3mtarget = set_d3m_data_path(\'learningData.csv\', d3mData);\n\n    // If this is the D3M domain; d3mData MUST be set to an actual value\n    //\n    if (IS_D3M_DOMAIN && d3mData == null) {\n        var d3m_path_err = \'NO VALID d3mData path!! \' + JSON.stringify(res);\n        console.log(d3m_path_err);\n        alert(\'debug (be more graceful): \' + d3m_path_err);\n    }\n\n    // hardcoding this, once get-problem-data-file-info is revised this hardcode can go away and use the previous two LOC\n    //  zparams.zd3mdata = d3mData = d3mRootPath+"/dataset_TRAIN/tables/learningData.csv";\n    //  zparams.zd3mtarget = d3mRootPath+"/dataset_TRAIN/tables/learningData.csv";\n\n    res = await _mithril2.default.request(d3mPS);\n    console.log("prob schema data: ", res);\n\n    mytarget = res.inputs.data[0].targets[0].colName; // easier way to access target name?\n    if (typeof res.about.taskType !== \'undefined\') {\n        d3mProblemDescription.taskType = res.about.taskType;\n    }\n    if (typeof res.about.taskSubType !== \'undefined\') {\n        d3mProblemDescription.taskSubtype = res.about.taskSubType;\n    }\n    if (typeof res.inputs.performanceMetrics[0].metric !== \'undefined\') {\n        d3mProblemDescription.metric = res.inputs.performanceMetrics[0].metric;\n    }\n    if (typeof res.descriptionFile !== \'undefined\') {\n        d3mProblemDescription.taskDescription = res.descriptionFile;\n    }\n    //   d3mProblemDescription.outputType = res.expectedOutputs.predictionsFile;\n\n    byId("btnType").click();\n\n    // making it case insensitive because the case seems to disagree all too often\n    if (failset.includes(d3mProblemDescription.taskType.toUpperCase())) {\n        swandive = true;\n    }\n\n    // 4. Read the data document and set \'datadocument\'\n    datadocument = await _mithril2.default.request(d3mDS);\n\n    // if no columns in the datadocument, go to swandive\n    if (typeof datadocument.dataResources[0].columns === \'undefined\') {\n        swandive = true;\n    }\n\n    if (IS_D3M_DOMAIN) {\n        var datasetName = datadocument.about.datasetName; // Use "datasetName" field in dataset document\n        zparams.zdata = datasetName.charAt(0).toUpperCase() + datasetName.slice(1); // Make sure to capitalize;\n        var cite = "No citation provided";\n        if (typeof datadocument.about.citation !== \'undefined\') {\n            cite = datadocument.about.citation;\n        }\n        //console.log(cite);\n        //let newcite = cite.match(/{\\s*[\\w\\.]+\\s*}/g).map(function(x) { return x.match(/[\\w\\.]+/)[0]; });\n        //console.log(newcite);\n        /*\n        // clean citation\n        zparams.zdatacite = cite\n            .replace(/\\&/g, "and")\n            .replace(/\\;/g, ",")\n            .replace(/\\%/g, "-");\n        // fill in citation in header\n        $(\'#cite div.panel-body\').text(zparams.zdatacite);\n        */\n    } else {\n        // Note: presently xml is no longer being read from Dataverse metadata anywhere\n        var temp = xml.documentElement.getElementsByTagName("fileName");\n        zparams.zdata = temp[0].childNodes[0].nodeValue;\n        var _cite = xml.documentElement.getElementsByTagName("biblCit");\n        // clean citation so POST is valid json\n        zparams.zdatacite = _cite[0].childNodes[0].nodeValue.replace(/\\&/g, "and").replace(/\\;/g, ",").replace(/\\%/g, "-");\n        // fill in citation in header\n        $(\'#cite div.panel-body\').text(zparams.zdatacite);\n    }\n    // drop file extension\n    var dataname = IS_D3M_DOMAIN ? zparams.zdata : zparams.zdata.replace(/\\.(.*)/, \'\');\n    d3.select("#dataName").html(dataname);\n    // put dataset name, from meta-data, into page title\n    d3.select("title").html("TwoRavens " + dataname);\n\n    // if swandive, we have to set valueKey here so that left panel can populate.\n    if (swandive) {\n        //    let mydataRes = datadocument.dataResources;\n        //  for (let i = 0; i < mydataRes.length; i++) {\n        //       valueKey.push(mydataRes[i].resFormat[0]);\n        //  }\n        // end session if neither trainData nor trainTargets?\n        // valueKey.length === 0 && alert("no trainData or trainTargest in data description file. valueKey length is 0");\n        // perhaps allow users to unlock and select things?\n        byId(\'btnLock\').classList.add(\'noshow\');\n        byId(\'btnForce\').classList.add(\'noshow\');\n        byId(\'btnEraser\').classList.add(\'noshow\');\n        byId(\'btnSubset\').classList.add(\'noshow\');\n        byId(\'main\').style.backgroundColor = \'grey\';\n        byId(\'whitespace\').style.backgroundColor = \'grey\';\n    }\n    console.log("data schema data: ", datadocument);\n\n    // 5. Read in zelig models (not for d3m)\n    // 6. Read in zeligchoice models (not for d3m)\n    if (!IS_D3M_DOMAIN) {\n        var _arr = [\'zelig5models\', \'zelig5choicemodels\'];\n\n        var _loop = async function _loop() {\n            var field = _arr[_i];\n            try {\n                res = await _mithril2.default.request(\'data/\' + field + \'.json\');\n                cdb(field + \' json: \', res);\n                res[field].filter(function (key) {\n                    return res[field].hasOwnProperty(key);\n                }).forEach(function (key) {\n                    return mods[key.name[0]] = key.description[0];\n                });\n            } catch (_) {\n                console.log("can\'t load " + field);\n            }\n        };\n\n        for (var _i = 0; _i < _arr.length; _i++) {\n            await _loop();\n        }\n    }\n    // 7. Start the user session\n    // rpc StartSession(SessionRequest) returns (SessionResponse) {}\n    res = await makeRequest(D3M_SVC_URL + \'/startsession\', { user_agent: \'some agent\', version: \'some version\' });\n    if (res) {\n        if (res.responseInfo.status.code != "OK") {\n            var user_err_msg = "Failed to StartSession with TA2! status code: " + res.responseInfo.status.code;\n            alert(user_err_msg);\n            end_ta3_search(false, user_err_msg);\n        } else {\n            zparams.zsessionid = res.context.sessionId;\n        }\n    }\n\n    // hopscotch tutorial\n    if (tutorial_mode) {\n        console.log(\'Starting Hopscotch Tour\');\n        _hopscotch2.default.startTour(mytour, 0);\n        console.log(\'Ending Hopscotch Tour\');\n    }\n\n    // 8. read preprocess data or (if necessary) run preprocess\n    // NOTE: preprocess.json is now guaranteed to exist...\n    var read = function read(res) {\n        priv = res.dataset.private || priv;\n        Object.keys(res.variables).forEach(function (k) {\n            return preprocess[k] = res.variables[k];\n        });\n        return res;\n    };\n    try {\n        console.log(\'attempt to read preprocess file (which may not exist): \' + pURL);\n        res = read((await _mithril2.default.request(pURL)));\n    } catch (_) {\n        console.log("Ok, preprocess not found, try to RUN THE PREPROCESSAPP");\n        var url = ROOK_SVC_URL + \'preprocessapp\';\n        var json_input;\n        if (IS_D3M_DOMAIN) {\n            // For D3M inputs, change the preprocess input data\n            //\n            json_input = JSON.stringify({ data: d3mData, datastub: d3mDataName });\n        } else {\n            json_input = JSON.stringify({ data: dataloc, target: targetloc, datastub: datastub });\n        }\n\n        console.log(\'json_input: \', json_input);\n        console.log(\'url: \', url);\n        var data = new FormData();\n        try {\n            res = read((await _mithril2.default.request({ method: \'POST\', url: url, data: json_input })));\n        } catch (_) {\n            console.log(\'preprocess failed\');\n            alert(\'preprocess failed. ending user session.\');\n            endsession();\n        }\n    }\n\n    console.log("is this preprocess?");\n    console.log(res);\n    console.log(preprocess);\n\n    // 9. Build allNodes[] using preprocessed information\n    var vars = Object.keys(preprocess);\n    // temporary values for hold that correspond to histogram bins\n    hold = [.6, .2, .9, .8, .1, .3, .4];\n    for (var i = 0; i < vars.length; i++) {\n        // valueKey[i] = vars[i].attributes.name.nodeValue;\n        // lablArray[i] = varsXML[i].getElementsByTagName("labl").length == 0 ?\n        // "no label" :\n        // varsXML[i].getElementsByTagName("labl")[0].childNodes[0].nodeValue;\n        // let datasetcount = d3.layout.histogram()\n        //     .bins(barnumber).frequency(false)\n        //     ([0, 0, 0, 0, 0]);\n        valueKey[i] = vars[i];\n        lablArray[i] = "no label";\n        // contains all the preprocessed data we have for the variable, as well as UI data pertinent to that variable,\n        // such as setx values (if the user has selected them) and pebble coordinates\n        var obj = {\n            id: i,\n            reflexive: false,\n            name: valueKey[i],\n            labl: lablArray[i],\n            data: [5, 15, 20, 0, 5, 15, 20],\n            count: hold,\n            nodeCol: colors(i),\n            baseCol: colors(i),\n            strokeColor: _plots.selVarColor,\n            strokeWidth: "1",\n            subsetplot: false,\n            subsetrange: ["", ""],\n            setxplot: false,\n            setxvals: ["", ""],\n            grayout: false,\n            group1: false,\n            group2: false,\n            forefront: false\n        };\n        jQuery.extend(true, obj, preprocess[valueKey[i]]);\n        allNodes.push(obj);\n    }\n\n    // 10. Add datadocument information to allNodes (when in IS_D3M_DOMAIN)\n    if (!swandive) {\n        var datavars = datadocument.dataResources[0].columns;\n        datavars.forEach(function (v, i) {\n            var myi = findNodeIndex(v.colName);\n            allNodes[myi] = Object.assign(allNodes[myi], { d3mDescription: v });\n        });\n        console.log(allNodes);\n    }\n\n    // 10b. Call problem discovery\n    // Requires that `res` built in 8. above still exists.  Should make this better.\n    if (!swandive) {\n        exports.disco = disco = discovery(res);\n        console.log(disco);\n    }\n\n    // 11. Call layout() and start up\n    layout(false, true);\n    IS_D3M_DOMAIN ? zPop() : dataDownload();\n}\n\n/**\n   called on app start\n   @param {string} fileid\n   @param {string} hostname\n   @param {string} ddiurl\n   @param {string} dataurl\n   @param {string} apikey\n*/\nfunction main(fileid, hostname, ddiurl, dataurl, apikey) {\n    if (PRODUCTION && fileid === \'\') {\n        var msg = \'Error: No fileid has been provided.\';\n        alert(msg);\n        throw new Error(msg);\n    }\n\n    var dataverseurl = hostname ? \'https://\' + hostname : PRODUCTION ? DATAVERSE_URL : \'http://localhost:8080\';\n    // if file id supplied, assume we are dealing with dataverse and cook a standard dataverse data access url\n    // with the fileid supplied and the hostname we have supplied or configured\n    dataurl = fileid && !dataurl ? dataverseurl + \'/api/access/datafile/\' + fileid + \'?key=\' + apikey : dataurl;\n    cdb(\'--dataurl: \' + dataurl);\n    cdb(\'--dataverseurl: \' + dataverseurl);\n\n    var tempWidth = d3.select(\'#main.left\').style(\'width\');\n    width = tempWidth.substring(0, tempWidth.length - 2);\n    height = $(window).height() - 120; // hard code header, footer, and bottom margin\n\n    exports.estimateLadda = estimateLadda = Ladda.create(byId("btnEstimate"));\n    selectLadda = Ladda.create(byId("btnSelect"));\n    svg = d3.select("#whitespace");\n\n    // indicators for showing membership above arcs\n    // let indicator = (degree) => d3.svg.circle()\n    //     .cx( RADIUS )//(RADIUS+35) * Math.sin(degree))\n    //     .cy( RADIUS )//(RADIUS+35) * Math.cos(degree))\n    //     .r(3);\n    // ind1 = indicator(1);\n    // ind2 = indicator(1.2);\n\n    // from .csv\n    var hold = [],\n        lablArray = [];\n\n    // assume locations are consistent based on d3m directory structure\n\n    var d3mRootPath = \'\';\n    var d3mDataName = \'\';\n    var d3mData = null;\n    var d3mPreprocess = \'\';\n    var d3mPS = \'\';\n    var d3mDS = \'\';\n\n    // default to Fearon Laitin\n    var data = \'data/\' + (false ? \'PUMS5small\' : \'fearonLaitin\');\n    var metadataurl = ddiurl || (fileid ? dataverseurl + \'/api/meta/datafile/\' + fileid : data + \'.xml\');\n    // read pre-processed metadata and data\n    var pURL = dataurl ? dataurl + \'&format=prep\' : data + \'.json\';\n\n    if (IS_D3M_DOMAIN) {\n        pURL = d3mPreprocess;\n    } else if (!PRODUCTION) {\n        zparams.zdataurl = \'data/fearonLaitin.tsv\';\n    }\n\n    load(hold, lablArray, d3mRootPath, d3mDataName, d3mPreprocess, d3mData, d3mPS, d3mDS, pURL);\n}\n\nvar $fill = function $fill(obj, op, d1, d2) {\n    return d3.select(obj).transition().attr(\'fill-opacity\', op).delay(d1).duration(d2);\n};\nvar fill = function fill(d, id, op, d1, d2) {\n    return $fill(\'#\' + id + d.id, op, d1, d2);\n};\nvar fillThis = function fillThis(self, op, d1, d2) {\n    return $fill(self, op, d1, d2);\n};\n\n/**\n   deletes the item at index from array.\n   if object is provided, deletes first instance of object from array.\n   @param {Object[]} arr - array\n   @param {number} idx - index\n   @param {Object} [obj] - object\n*/\nfunction del(arr, idx, obj) {\n    idx = obj ? arr.indexOf(obj) : idx;\n    idx > -1 && arr.splice(idx, 1);\n}\n\n/** needs doc */\nfunction zparamsReset(text) {\n    \'zdv zcross ztime znom\'.split(\' \').forEach(function (x) {\n        return del(zparams[x], -1, text);\n    });\n}\n\n/** needs doc */\nfunction layout(v, v2) {\n    var myValues = [];\n    exports.nodes = nodes = [];\n    exports.links = links = [];\n\n    svg.append("svg:defs").append("svg:marker").attr("id", "group1-arrow").attr(\'viewBox\', \'0 -5 15 15\').attr("refX", 2.5).attr("refY", 0).attr("markerWidth", 3).attr("markerHeight", 3).attr("orient", "auto").append("path").attr(\'d\', \'M0,-5L10,0L0,5\').style("fill", gr1Color);\n    svg.append("svg:defs").append("svg:marker").attr("id", "group2-arrow").attr(\'viewBox\', \'0 -5 15 15\').attr("refX", 2.5).attr("refY", 0).attr("markerWidth", 3).attr("markerHeight", 3).attr("orient", "auto").append("path").attr(\'d\', \'M0,-5L10,0L0,5\').style("fill", gr2Color);\n    svg.append(\'svg:defs\').append(\'svg:marker\').attr(\'id\', \'circle\').classed(\'circle_start\', true).attr(\'viewBox\', \'-6 -6 12 12\').attr(\'refX\', 1).attr(\'refY\', 1).attr(\'markerWidth\', 4).attr(\'markerHeight\', 4).attr(\'orient\', \'auto\').append(\'svg:path\').attr(\'d\', \'M 0, 0  m -5, 0  a 5,5 0 1,0 10,0  a 5,5 0 1,0 -10,0\').style(\'fill\', \'#000\');\n\n    var line = svg.append("line").style(\'fill\', \'none\').style(\'stroke\', gr1Color).style(\'stroke-width\', 5).attr("marker-end", "url(#group1-arrow)");\n\n    var line2 = svg.append("line").style(\'fill\', \'none\').style(\'stroke\', gr2Color).style(\'stroke-width\', 5).attr("marker-end", "url(#group2-arrow)");;\n\n    var visbackground = d3.select("#whitespace").append("svg").attr("width", width).attr("height", height);\n\n    visbackground.append("path") // note lines, are behind group hulls of which there is a white and colored semi transparent layer\n    .attr("id", \'gr1background\').style("fill", \'#ffffff\').style("stroke", \'#ffffff\').style("stroke-width", 2.5 * RADIUS).style(\'stroke-linejoin\', \'round\').style("opacity", 1);\n\n    var vis2background = d3.select("#whitespace").append("svg").attr("width", width).attr("height", height);\n\n    vis2background.append("path").attr("id", \'gr1background\').style("fill", \'#ffffff\').style("stroke", \'#ffffff\').style("stroke-width", 2.5 * RADIUS).style(\'stroke-linejoin\', \'round\').style("opacity", 1);\n\n    var vis = d3.select("#whitespace").append("svg").attr("width", width).attr("height", height);\n\n    vis.append("path").attr("id", \'gr1hull\').style("fill", gr1Color).style("stroke", gr1Color).style("stroke-width", 2.5 * RADIUS).style(\'stroke-linejoin\', \'round\');\n\n    var vis2 = d3.select("#whitespace").append("svg").attr("width", width).attr("height", height);\n\n    vis2.append("path").style("fill", gr2Color).style("stroke", gr2Color).style("stroke-width", 2.5 * RADIUS).style(\'stroke-linejoin\', \'round\');\n\n    if (v == layoutAdd || v == layoutMove) {\n        for (var j = 0; j < zparams.zvars.length; j++) {\n            var ii = findNodeIndex(zparams.zvars[j]);\n            if (allNodes[ii].grayout) continue;\n            nodes.push(allNodes[ii]);\n            var selectMe = zparams.zvars[j].replace(/\\W/g, "_");\n            selectMe = "#".concat(selectMe);\n            d3.select(selectMe).style(\'background-color\', function () {\n                return hexToRgba(nodes[j].strokeColor);\n            });\n        }\n\n        for (var j = 0; j < zparams.zedges.length; j++) {\n            var mysrc = nodeIndex(zparams.zedges[j][0]);\n            var mytgt = nodeIndex(zparams.zedges[j][1]);\n            links.push({\n                source: nodes[mysrc],\n                target: nodes[mytgt],\n                left: false,\n                right: true\n            });\n        }\n    } else {\n        if (IS_D3M_DOMAIN) {\n            //nodes = [findNode(mytarget)];               // Only add dependent variable on startup\n            exports.nodes = nodes = allNodes.slice(1, allNodes.length); // Add all but first variable on startup (assumes 0 position is d3m index variable)\n            for (var _j = 0; _j < nodes.length; _j++) {\n                //populate zvars array\n                if (nodes[_j].name != mytarget) {\n                    nodes[_j].group1 = true;\n                    zparams.zgroup1.push(nodes[_j].name); // write all names (except d3m index and the dependent variable) to zgroup1 array\n                };\n            };\n        } else if (allNodes.length > 2) {\n            exports.nodes = nodes = [allNodes[0], allNodes[1], allNodes[2]];\n            exports.links = links = [{\n                source: nodes[1],\n                target: nodes[0],\n                left: false,\n                right: true\n            }, {\n                source: nodes[0],\n                target: nodes[2],\n                left: false,\n                right: true\n            }];\n        } else if (allNodes.length === 2) {\n            exports.nodes = nodes = [allNodes[0], allNodes[1]];\n            exports.links = links = [{\n                source: nodes[1],\n                target: nodes[0],\n                left: false,\n                right: true\n            }];\n        } else if (allNodes.length === 1) {\n            exports.nodes = nodes = [allNodes[0]];\n        } else {\n            alert("There are zero variables in the metadata.");\n            return;\n        }\n    }\n\n    panelPlots(); // after nodes is populated, add subset and (if !IS_D3M_DOMAIN) setx panels\n\n    var force = d3.layout.force().nodes(nodes).links(links).size([width, height]).linkDistance(150).charge(-800).on(\'tick\', tick);\n\n    // define arrow markers for graph links\n    svg.append(\'svg:defs\').append(\'svg:marker\').attr(\'id\', \'end-arrow\').attr(\'viewBox\', \'0 -5 10 10\').attr(\'refX\', 6).attr(\'markerWidth\', 3).attr(\'markerHeight\', 3).attr(\'orient\', \'auto\').append(\'svg:path\').attr(\'d\', \'M0,-5L10,0L0,5\').style(\'fill\', \'#000\');\n\n    svg.append(\'svg:defs\').append(\'svg:marker\').attr(\'id\', \'start-arrow\').attr(\'viewBox\', \'0 -5 10 10\').attr(\'refX\', 4).attr(\'markerWidth\', 3).attr(\'markerHeight\', 3).attr(\'orient\', \'auto\').append(\'svg:path\').attr(\'d\', \'M10,-5L0,0L10,5\').style(\'fill\', \'#000\');\n\n    // line displayed when dragging new nodes\n    var drag_line = svg.append(\'svg:path\').attr(\'class\', \'link dragline hidden\').attr(\'d\', \'M0,0L0,0\');\n\n    // handles to link and node element groups\n    var path = svg.append(\'svg:g\').selectAll(\'path\'),\n        circle = svg.append(\'svg:g\').selectAll(\'g\');\n    //line = svg.append(\'svg:g\').selectAll(\'line\');\n\n    // mouse event vars\n    var selected_node = null,\n        selected_link = null,\n        mousedown_link = null,\n        mousedown_node = null,\n        mouseup_node = null;\n\n    function resetMouseVars() {\n        mousedown_node = null;\n        mouseup_node = null;\n        mousedown_link = null;\n    }\n\n    // update force layout (called automatically each iteration)\n    function tick() {\n        function findcoords(findnames, allnames, coords, lengthen) {\n            var fcoords = new Array(findnames.length); // found coordinates\n            var addlocation = 0;\n            if (findnames.length > 0) {\n                for (var j = 0; j < findnames.length; j++) {\n                    addlocation = allnames.indexOf(findnames[j]);\n                    fcoords[j] = coords[addlocation];\n                };\n            };\n\n            if (lengthen) {\n                // d3.geom.hull returns null for two points, and fails if three points are in a line,\n                // so this puts a couple points slightly off the line for two points, or around a singleton.\n                if (fcoords.length == 2) {\n                    var deltax = fcoords[0][0] - fcoords[1][0];\n                    var deltay = fcoords[0][1] - fcoords[1][1];\n                    fcoords.push([(fcoords[0][0] + fcoords[1][0]) / 2 + deltay / 20, (fcoords[0][1] + fcoords[1][1]) / 2 + deltax / 20]);\n                    fcoords.push([(fcoords[0][0] + fcoords[1][0]) / 2 - deltay / 20, (fcoords[0][1] + fcoords[1][1]) / 2 - deltax / 20]);\n                }\n                if (fcoords.length == 1) {\n                    var delta = RADIUS * 0.2;\n                    fcoords.push([fcoords[0][0] + delta, fcoords[0][1]]);\n                    fcoords.push([fcoords[0][0] - delta, fcoords[0][1]]);\n                    fcoords.push([fcoords[0][0], fcoords[0][1] + delta]);\n                    fcoords.push([fcoords[0][0], fcoords[0][1] - delta]);\n                }\n            }\n            return fcoords;\n        };\n\n        // d3.geom.hull returns null for two points, and fails if three points are in a line,\n        // so this puts a couple points slightly off the line for two points, or around a singleton.\n        function lengthencoords(coords) {\n            if (coords.length == 2) {\n                var deltax = coords[0][0] - coords[1][0];\n                var deltay = coords[0][1] - coords[1][1];\n                coords.push([(coords[0][0] + coords[1][0]) / 2 + deltay / 20, (coords[0][1] + coords[1][1]) / 2 + deltax / 20]);\n                coords.push([(coords[0][0] + coords[1][0]) / 2 - deltay / 20, (coords[0][1] + coords[1][1]) / 2 - deltax / 20]);\n            }\n            if (coords.length == 1) {\n                var delta = RADIUS * 0.2;\n                coords.push([coords[0][0] + delta, coords[0][1]]);\n                coords.push([coords[0][0] - delta, coords[0][1]]);\n                coords.push([coords[0][0], coords[0][1] + delta]);\n                coords.push([coords[0][0], coords[0][1] - delta]);\n            }\n            return coords;\n        };\n\n        var coords = nodes.map(function (d) {\n            return [d.x, d.y];\n        });\n        var gr1coords = findcoords(zparams.zgroup1, zparams.zvars, coords, true);\n        var gr2coords = findcoords(zparams.zgroup2, zparams.zvars, coords, true);\n        var depcoords = findcoords(zparams.zdv, zparams.zvars, coords, false);\n\n        // draw convex hull around independent variables, if three or more coordinates given\n        // note, d3.geom.hull returns null if shorter coordinate set than 3,\n        // so findcoords() function has option to lengthen the coordinates returned to bypass this\n        if (gr1coords.length > 2) {\n            line.style("opacity", 1);\n            visbackground.style("opacity", 1);\n            vis.style("opacity", 0.3);\n            var myhull = d3.geom.hull(gr1coords);\n\n            vis.selectAll("path").data([myhull]) // returns null if less than three coordinates\n            .attr("d", function (d) {\n                return "M" + d.join("L") + "Z";\n            });\n            visbackground.selectAll("path").data([myhull]) // returns null if less than three coordinates\n            .attr("d", function (d) {\n                return "M" + d.join("L") + "Z";\n            });\n\n            //var p = d3.geom.polygon(indcoords).centroid();  // Seems to go strange sometimes\n            var p = jamescentroid(gr1coords);\n\n            if (depcoords.length > 0) {\n                var q = depcoords[0]; // Note, only using first dep var currently\n                //var r = findboundary(p,q,gr1coords);        // An approach to find the exact boundary, not presently working\n                var ldeltaX = q[0] - p[0],\n                    ldeltaY = q[1] - p[1],\n                    ldist = Math.sqrt(ldeltaX * ldeltaX + ldeltaY * ldeltaY),\n                    lnormX = 0,\n                    lnormY = 0,\n                    lsourcePadding = RADIUS + 7,\n                    ltargetPadding = RADIUS + 10;\n\n                if (ldist > 0) {\n                    lnormX = ldeltaX / ldist;\n                    lnormY = ldeltaY / ldist;\n                };\n\n                line.attr("x1", p[0] + lsourcePadding * lnormX) // or r[0] if findboundary works\n                .attr("y1", p[1] + lsourcePadding * lnormY) // or r[1] if findboundary works\n                .attr("x2", q[0] - ltargetPadding * lnormX).attr("y2", q[1] - ltargetPadding * lnormY);\n            };\n\n            // group members attract each other, repulse non-group members\n            nodes.forEach(function (n) {\n                var sign = n.group1 ? 1 : -1; //was: Math.sign( zparams.zgroup1.indexOf(n.name) +0.5 );  // 1 if n in group, -1 if n not in group;\n                var ldeltaX = p[0] - n.x,\n                    ldeltaY = p[1] - n.y,\n                    ldist = Math.sqrt(ldeltaX * ldeltaX + ldeltaY * ldeltaY);\n                lnormX = 0, lnormY = 0;\n\n                if (ldist > 0) {\n                    lnormX = ldeltaX / ldist;\n                    lnormY = ldeltaY / ldist;\n                };\n\n                n.x += Math.min(lnormX, ldeltaX / 100) * k * sign * force.alpha();\n                n.y += Math.min(lnormY, ldeltaY / 100) * k * sign * force.alpha();\n            });\n        } else {\n            visbackground.style("opacity", 0);\n            vis.style("opacity", 0);\n            line.style("opacity", 0);\n        };\n\n        if (gr2coords.length > 2) {\n            line2.style("opacity", 1);\n            vis2background.style("opacity", 1);\n            vis2.style("opacity", 0.3);\n            var myhull = d3.geom.hull(gr2coords);\n            vis2.selectAll("path").data([myhull]) // returns null if less than three coordinates\n            .attr("d", function (d) {\n                return "M" + d.join("L") + "Z";\n            });\n            vis2background.selectAll("path").data([myhull]) // returns null if less than three coordinates\n            .attr("d", function (d) {\n                return "M" + d.join("L") + "Z";\n            });\n\n            //var p = d3.geom.polygon(indcoords).centroid();  // Seems to go strange sometimes\n            var p = jamescentroid(gr2coords);\n\n            if (depcoords.length > 0) {\n                var q = depcoords[0]; // Note, only using first dep var currently\n                var ldeltaX = q[0] - p[0],\n                    ldeltaY = q[1] - p[1],\n                    ldist = Math.sqrt(ldeltaX * ldeltaX + ldeltaY * ldeltaY),\n                    lnormX = ldeltaX / ldist,\n                    lnormY = ldeltaY / ldist,\n                    lsourcePadding = RADIUS + 7,\n                    ltargetPadding = RADIUS + 10;\n\n                line2.attr("x1", p[0] + lsourcePadding * lnormX).attr("y1", p[1] + lsourcePadding * lnormY).attr("x2", q[0] - ltargetPadding * lnormX).attr("y2", q[1] - ltargetPadding * lnormY);\n            };\n\n            // group members attract each other, repulse non-group members\n            nodes.forEach(function (n) {\n                var sign = n.group2 ? 1 : -1; // was: Math.sign( zparams.zgroup2.indexOf(n.name) +0.5 );  // 1 if n in group, -1 if n not in group;\n                var ldeltaX = p[0] - n.x,\n                    ldeltaY = p[1] - n.y,\n                    ldist = Math.sqrt(ldeltaX * ldeltaX + ldeltaY * ldeltaY),\n                    lnormX = 0,\n                    lnormY = 0;\n\n                if (ldist > 0) {\n                    lnormX = ldeltaX / ldist;\n                    lnormY = ldeltaY / ldist;\n                };\n\n                n.x += Math.min(lnormX, ldeltaX / 100) * k * sign * force.alpha();\n                n.y += Math.min(lnormY, ldeltaY / 100) * k * sign * force.alpha();\n            });\n        } else {\n            vis2background.style("opacity", 0);\n            vis2.style("opacity", 0);\n            line2.style("opacity", 0);\n        };\n\n        // draw directed edges with proper padding from node centers\n        path.attr(\'d\', function (d) {\n            var deltaX = d.target.x - d.source.x,\n                deltaY = d.target.y - d.source.y,\n                dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY),\n                normX = deltaX / dist,\n                normY = deltaY / dist,\n                sourcePadding = d.left ? RADIUS + 5 : RADIUS,\n                targetPadding = d.right ? RADIUS + 5 : RADIUS,\n                sourceX = d.source.x + sourcePadding * normX,\n                sourceY = d.source.y + sourcePadding * normY,\n                targetX = d.target.x - targetPadding * normX,\n                targetY = d.target.y - targetPadding * normY;\n            return \'M\' + sourceX + \',\' + sourceY + \'L\' + targetX + \',\' + targetY;\n        });\n\n        circle.attr(\'transform\', function (d) {\n            return \'translate(\' + d.x + \',\' + d.y + \')\';\n        });\n\n        circle.selectAll(\'circle\') // Shrink/expand pebbles that join/leave groups\n        .transition().duration(100).attr(\'r\', function (d) {\n            return setPebbleRadius(d);\n        });\n    }\n\n    d3.select("#models").selectAll("p") // models tab\n    //  d3.select("#Display_content")\n    .on("click", function () {\n        var myColor = d3.select(this).style(\'background-color\');\n        d3.select("#models").selectAll("p").style(\'background-color\', varColor);\n        d3.select(this).style(\'background-color\', function (d) {\n            if (d3.rgb(myColor).toString() === varColor.toString()) {\n                zparams.zmodel = d.toString();\n                return hexToRgba(_plots.selVarColor);\n            } else {\n                zparams.zmodel = \'\';\n                return varColor;\n            }\n        });\n        _restart();\n    });\n\n    d3.select("#types").selectAll("p") // models tab\n    //  d3.select("#Display_content")\n    .on("click", function () {\n        if (locktoggle) return;\n        if (this.className == "item-select") {\n            return;\n        } else {\n            d3.select("#types").select("p.item-select").attr(\'class\', \'item-default\');\n            d3mProblemDescription.taskType = this.innerHTML.toString();\n            d3.select(this).attr(\'class\', "item-select");\n        }\n        _restart();\n        setProblemDefinition("taskType", d3mProblemDescription, d3mTaskType);\n    });\n\n    d3.select("#subtypes").selectAll("p").on("click", function () {\n        if (locktoggle) return;\n        if (this.className == "item-select") {\n            return;\n        } else {\n            d3.select("#subtypes").select("p.item-select").attr(\'class\', \'item-default\');\n            d3mProblemDescription.taskSubtype = this.innerHTML.toString();\n            d3.select(this).attr(\'class\', "item-select");\n        }\n        _restart();\n        setProblemDefinition("taskSubtype", d3mProblemDescription, d3mTaskSubtype);\n    });\n\n    d3.select("#metrics").selectAll("p").on("click", function () {\n        if (locktoggle) return;\n        if (this.className == "item-select") {\n            return;\n            // d3mProblemDescription.metric = ["",""];\n            // this.className="item-default";\n        } else {\n            d3.select("#metrics").select("p.item-select").attr(\'class\', \'item-default\');\n            d3mProblemDescription.metric = this.innerHTML.toString();\n            d3.select(this).attr(\'class\', "item-select");\n        }\n        _restart();\n        setProblemDefinition("metric", d3mProblemDescription, d3mMetrics);\n    });\n\n    /*  d3.select("#outputs").selectAll("p")\n      .on("click", function() {\n          if(locktoggle) return;\n          if(this.className=="item-select") {\n              return;\n          } else {\n              d3.select("#outputs").select("p.item-select")\n              .attr(\'class\', \'item-default\');\n              d3mProblemDescription.outputType = this.innerHTML.toString();\n              d3.select(this).attr(\'class\',"item-select");\n          }\n          restart();\n          setProblemDefinition("outputType", d3mProblemDescription, d3mOutputType);\n          });\n          */\n\n    // update graph (called when needed)\n    exports.restart = _restart = function restart($links) {\n        exports.links = links = $links || links;\n        // nodes.id is pegged to allNodes, i.e. the order in which variables are read in\n        // nodes.index is floating and depends on updates to nodes.  a variables index changes when new variables are added.\n        circle.call(force.drag);\n        if (forcetoggle[0] == "true") {\n            force.gravity(0.1);\n            force.charge(function (d) {\n                return setPebbleCharge(d);\n            });\n            force.start();\n            force.linkStrength(1);\n            k = 4; // strength parameter for group attraction/repulsion\n            if (zparams.zgroup1.length > 0 & zparams.zgroup2.length > 0) {\n                // scale down by number of active groups\n                k = 2.5;\n            }\n        } else {\n            force.gravity(0);\n            force.charge(0);\n            force.linkStrength(0);\n            k = 0;\n        }\n        force.resume();\n\n        // path (link) group\n        path = path.data(links);\n\n        var marker = function marker(side) {\n            return function (x) {\n                var kind = side === \'left\' ? \'start\' : \'end\';\n                return is_explore_mode ? \'url(#circle)\' : x[side] ? \'url(#\' + kind + \'-arrow)\' : \'\';\n            };\n        };\n\n        // update existing links\n        // VJD: dashed links between pebbles are "selected". this is disabled for now\n        path.classed(\'selected\', function (x) {\n            return null;\n        }).style(\'marker-start\', marker(\'left\')).style(\'marker-end\', marker(\'right\'));\n\n        // add new links\n        path.enter().append(\'svg:path\').attr(\'class\', \'link\').classed(\'selected\', function (x) {\n            return null;\n        }).style(\'marker-start\', marker(\'left\')).style(\'marker-end\', marker(\'right\')).on(\'mousedown\', function (d) {\n            // do we ever need to select a link? make it delete..\n            var obj = JSON.stringify(d);\n            for (var j = 0; j < links.length; j++) {\n                if (obj === JSON.stringify(links[j])) del(links, j);\n            }\n        });\n\n        // remove old links\n        path.exit().remove();\n\n        // circle (node) group\n        circle = circle.data(nodes, function (x) {\n            return x.id;\n        });\n\n        // update existing nodes (reflexive & selected visual states)\n        // d3.rgb is the function adjusting the color here\n        circle.selectAll(\'circle\').classed(\'reflexive\', function (x) {\n            return x.reflexive;\n        }).style(\'fill\', function (x) {\n            return d3.rgb(x.nodeCol);\n        }).style(\'stroke\', function (x) {\n            return d3.rgb(x.strokeColor);\n        }).style(\'stroke-width\', function (x) {\n            return x.strokeWidth;\n        });\n\n        // add new nodes\n        var g = circle.enter().append(\'svg:g\').attr(\'id\', function (x) {\n            return x.name + \'biggroup\';\n        });\n\n        // add plot\n        g.each(function (d) {\n            d3.select(this);\n            if (d.plottype == \'continuous\') (0, _plots.densityNode)(d, this);else if (d.plottype == \'bar\') (0, _plots.barsNode)(d, this);\n        });\n\n        var append = function append(str, attr) {\n            return function (x) {\n                return str + x[attr || \'id\'];\n            };\n        };\n\n        g.append("path").attr("id", append(\'dvArc\')).attr("d", arc3).style("fill", dvColor).attr("fill-opacity", 0).on(\'mouseover\', function (d) {\n            fillThis(this, .3, 0, 100);\n            fill(d, \'dvText\', .9, 0, 100);\n        }).on(\'mouseout\', function (d) {\n            fillThis(this, 0, 100, 500);\n            fill(d, \'dvText\', 0, 100, 500);\n        }).on(\'click\', function (d) {\n            setColors(d, dvColor);\n            legend(dvColor);\n            _restart();\n            d.group1 = d.group2 = false;\n        });\n\n        g.append("text").attr("id", append(\'dvText\')).attr("x", 6).attr("dy", 11.5).attr("fill-opacity", 0).append("textPath").attr("xlink:href", append(\'#dvArc\')).text("Dep Var");\n\n        g.append("path").attr("id", append(\'nomArc\')).attr("d", arc4).style("fill", nomColor).attr("fill-opacity", 0).on(\'mouseover\', function (d) {\n            if (d.defaultNumchar == "character") return;\n            fillThis(this, .3, 0, 100);\n            fill(d, "nomText", .9, 0, 100);\n        }).on(\'mouseout\', function (d) {\n            if (d.defaultNumchar == "character") return;\n            fillThis(this, 0, 100, 500);\n            fill(d, "nomText", 0, 100, 500);\n        }).on(\'click\', function (d) {\n            if (d.defaultNumchar == "character") return;\n            setColors(d, nomColor);\n            legend(nomColor);\n            _restart();\n        });\n\n        g.append("text").attr("id", append("nomText")).attr("x", 6).attr("dy", 11.5).attr("fill-opacity", 0).append("textPath").attr("xlink:href", append("#nomArc")).text("Nominal");\n\n        g.append("path").attr("id", append(\'grArc\')).attr("d", arc1).style("fill", gr1Color).attr("fill-opacity", 0).on(\'mouseover\', function (d) {\n            fill(d, "gr1indicator", .3, 0, 100);\n            fill(d, "gr2indicator", .3, 0, 100);\n            fillThis(this, .3, 0, 100);\n            fill(d, \'grText\', .9, 0, 100);\n        }).on(\'mouseout\', function (d) {\n            fill(d, "gr1indicator", 0, 100, 500);\n            fill(d, "gr2indicator", 0, 100, 500);\n            fillThis(this, 0, 100, 500);\n            fill(d, \'grText\', 0, 100, 500);\n        }).on(\'click\', function (d) {\n            //d.group1 = !d.group1;      // This might be easier, but currently set in setColors()\n            setColors(d, gr1Color);\n            legend(gr1Color);\n            _restart();\n        });\n\n        g.append("path").attr("id", append(\'gr1indicator\')).attr("d", arcInd1).style("fill", gr1Color) // something like: zparams.zgroup1.indexOf(node.name) > -1  ?  #FFFFFF : gr1Color)\n        .attr("fill-opacity", 0).on(\'mouseover\', function (d) {\n            fillThis(this, .3, 0, 100);\n            fill(d, "grArc", .1, 0, 100);\n            fill(d, \'grText\', .9, 0, 100);\n        }).on(\'mouseout\', function (d) {\n            fillThis(this, 0, 100, 500);\n            fill(d, "grArc", 0, 100, 500);\n            fill(d, \'grText\', 0, 100, 500);\n        }).on(\'click\', function (d) {\n            //d.group1 = !d.group1;      // This might be easier, but currently set in setColors()\n            setColors(d, gr1Color);\n            legend(gr1Color);\n            _restart();\n        });\n\n        g.append("path").attr("id", append(\'gr2indicator\')).attr("d", arcInd2).style("fill", gr2Color) // something like: zparams.zgroup1.indexOf(node.name) > -1  ?  #FFFFFF : gr1Color)\n        .attr("fill-opacity", 0).on(\'mouseover\', function (d) {\n            fillThis(this, .3, 0, 100);\n            fill(d, "grArc", .1, 0, 100);\n            fill(d, \'grText\', .9, 0, 100);\n        }).on(\'mouseout\', function (d) {\n            fillThis(this, 0, 100, 500);\n            fill(d, "grArc", 0, 100, 500);\n            fill(d, \'grText\', 0, 100, 500);\n        }).on(\'click\', function (d) {\n            //d.group2 = !d.group2;      // This might be easier, but currently set in setColors()\n            setColors(d, gr2Color);\n            legend(gr2Color);\n            _restart();\n        });\n\n        g.append("text").attr("id", append(\'grText\')).attr("x", 6).attr("dy", 11.5).attr("fill-opacity", 0).append("textPath").attr("xlink:href", append(\'#grArc\')).text("Groups");\n\n        g.append(\'svg:circle\').attr(\'class\', \'node\').attr(\'r\', function (d) {\n            return setPebbleRadius(d);\n        }).style(\'pointer-events\', \'inherit\').style(\'fill\', function (d) {\n            return d.nodeCol;\n        }).style(\'opacity\', "0.5").style(\'stroke\', function (d) {\n            return d3.rgb(d.strokeColor).toString();\n        }).classed(\'reflexive\', function (d) {\n            return d.reflexive;\n        }).on(\'dblclick\', function (_) {\n            d3.event.stopPropagation(); // stop click from bubbling\n            exports.summaryHold = summaryHold = true;\n        }).on(\'contextmenu\', function (d) {\n            // right click on node\n            d3.event.preventDefault();\n            d3.event.stopPropagation();\n\n            rightClickLast = true;\n            mousedown_node = d;\n            selected_node = mousedown_node === selected_node ? null : mousedown_node;\n            selected_link = null;\n\n            // reposition drag line\n            drag_line.style(\'marker-end\', is_explore_mode ? \'url(#end-marker)\' : \'url(#end-arrow)\').classed(\'hidden\', false).attr(\'d\', \'M\' + mousedown_node.x + \',\' + mousedown_node.y + \'L\' + mousedown_node.x + \',\' + mousedown_node.y);\n\n            svg.on(\'mousemove\', mousemove);\n            _restart();\n        }).on(\'mouseup\', function (d) {\n            d3.event.stopPropagation();\n\n            if (rightClickLast) {\n                rightClickLast = false;\n                return;\n            }\n            if (!mousedown_node) return;\n\n            // needed by FF\n            drag_line.classed(\'hidden\', true).style(\'marker-end\', \'\');\n\n            // check for drag-to-self\n            mouseup_node = d;\n            if (mouseup_node === mousedown_node) {\n                resetMouseVars();\n                return;\n            }\n\n            // unenlarge target node\n            d3.select(this).attr(\'transform\', \'\');\n\n            // add link to graph (update if exists)\n            // NB: links are strictly source < target; arrows separately specified by booleans\n            var source, target, direction;\n            if (mousedown_node.id < mouseup_node.id) {\n                source = mousedown_node;\n                target = mouseup_node;\n                direction = \'right\';\n            } else {\n                source = mouseup_node;\n                target = mousedown_node;\n                direction = \'left\';\n            }\n\n            var link = links.filter(function (x) {\n                return x.source == source && x.target == target;\n            })[0];\n            if (link) {\n                link[direction] = true;\n            } else {\n                link = {\n                    source: source,\n                    target: target,\n                    left: false,\n                    right: false\n                };\n                link[direction] = true;\n                links.push(link);\n            }\n\n            // select new link\n            selected_link = link;\n            selected_node = null;\n            svg.on(\'mousemove\', null);\n\n            resetMouseVars();\n            _restart();\n        });\n\n        // show node names\n        g.append(\'svg:text\').attr(\'x\', 0).attr(\'y\', 15).attr(\'class\', \'id\').text(function (d) {\n            return d.name;\n        });\n\n        // show summary stats on mouseover\n        // SVG doesn\'t support text wrapping, use html instead\n        g.selectAll("circle.node").on("mouseover", function (d) {\n            tabLeft(\'tab3\');\n            varSummary(d);\n            d.forefront = true;\n\n            byId(\'transformations\').setAttribute(\'style\', \'display:block\');\n            byId("transSel").selectedIndex = d.id;\n            transformVar = valueKey[d.id];\n\n            fill(d, "dvArc", .1, 0, 100);\n            fill(d, "dvText", .5, 0, 100);\n            fill(d, "grArc", .1, 0, 100);\n            fill(d, "grText", .5, 0, 100);\n            //fill(d, "gr1indicator", .1, 0, 100);\n            //fill(d, "gr1indicatorText", .1, 0, 100);\n            //fill(d, "gr2indicator", .1, 0, 100);\n            //fill(d, "gr2indicatorText", .1, 0, 100);\n\n            if (d.defaultNumchar == "numeric") {\n                fill(d, "nomArc", .1, 0, 100);\n                fill(d, "nomText", .5, 0, 100);\n            }\n            fill(d, "csArc", .1, 0, 100);\n            fill(d, "csText", .5, 0, 100);\n            fill(d, "timeArc", .1, 0, 100);\n            fill(d, "timeText", .5, 0, 100);\n\n            _mithril2.default.redraw();\n        }).on(\'mouseout\', function (d) {\n            d.forefront = false;\n            summaryHold || tabLeft(subset ? \'tab2\' : \'tab1\');\n            \'csArc csText timeArc timeText dvArc dvText nomArc nomText grArc grText\'.split(\' \').map(function (x) {\n                return fill(d, x, 0, 100, 500);\n            });\n            _mithril2.default.redraw();\n        });\n\n        // the transformation variable list is silently updated as pebbles are added/removed\n        d3.select("#transSel").selectAll(\'li\').remove();\n\n        d3.select("#transSel").selectAll(\'li\').data(nodes.map(function (x) {\n            return x.name;\n        })) // set to variables in model space as they\'re added\n        .enter().append("li").text(function (d) {\n            return d;\n        });\n\n        if (!IS_D3M_DOMAIN) {\n            $(\'#transSel li\').click(function (evt) {\n                // if \'interaction\' is the selected function, don\'t show the function list again\n                if (selInteract) {\n                    var n = $(\'#tInput\').val().concat($(this).text());\n                    $(\'#tInput\').val(n);\n                    evt.stopPropagation();\n                    var t = transParse(n = n);\n                    if (!t) return;\n                    $(this).parent().fadeOut(100);\n                    transform(n = t.slice(0, t.length - 1), t = t[t.length - 1], typeTransform = false);\n                    return;\n                }\n\n                $(\'#tInput\').val($(this).text());\n                $(this).parent().fadeOut(100);\n                $(\'#transList\').fadeIn(100);\n                evt.stopPropagation();\n            });\n        };\n\n        // remove old nodes\n        circle.exit().remove();\n        force.start();\n\n        // save workspaces\n        console.log(\'ok ws\');\n        record_user_metadata();\n    };\n\n    function mousedown(d) {\n        // prevent I-bar on drag\n        d3.event.preventDefault();\n        // because :active only works in WebKit?\n        svg.classed(\'active\', true);\n        if (d3.event.ctrlKey || mousedown_node || mousedown_link) return;\n        _restart();\n    }\n\n    function mousemove(d) {\n        if (!mousedown_node) return;\n        // update drag line\n        drag_line.attr(\'d\', \'M\' + mousedown_node.x + \',\' + mousedown_node.y + \'L\' + d3.mouse(this)[0] + \',\' + d3.mouse(this)[1]);\n    }\n\n    function mouseup(d) {\n        if (mousedown_node) {\n            drag_line.classed(\'hidden\', true).style(\'marker-end\', \'\');\n        }\n        // because :active only works in WebKit?\n        svg.classed(\'active\', false);\n        // clear mouse event vars\n        resetMouseVars();\n    }\n\n    // app starts here\n    svg.attr(\'id\', function () {\n        return "whitespace".concat(myspace);\n    }).attr(\'height\', height).on(\'mousedown\', function () {\n        mousedown(this);\n    }).on(\'mouseup\', function () {\n        mouseup(this);\n    });\n\n    d3.select(window).on(\'click\', function () {\n        // all clicks will bubble here unless event.stopPropagation()\n        $(\'#transList\').fadeOut(100);\n        $(\'#transSel\').fadeOut(100);\n    });\n\n    _restart(); // initializes force.layout()\n    fakeClick();\n\n    if (v2 & IS_D3M_DOMAIN) {\n        var click_ev = document.createEvent("MouseEvents");\n        // initialize the event\n        click_ev.initEvent("click", true /* bubble */, true /* cancelable */);\n        // trigger the event\n        var clickID = "dvArc" + findNodeIndex(mytarget);\n        byId(clickID).dispatchEvent(click_ev);\n    }\n}\n\n/** needs doc */\nfunction find($nodes, name) {\n    for (var i in $nodes) {\n        if ($nodes[i].name == name) return $nodes[i].id;\n    }\n}\n\n/**\n   returns id\n*/\nfunction findNodeIndex(name, whole) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n        for (var _iterator = allNodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var node = _step.value;\n\n            if (node.name === name) return whole ? node : node.id;\n        }\n    } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n            }\n        } finally {\n            if (_didIteratorError) {\n                throw _iteratorError;\n            }\n        }\n    }\n}\n\n/** needs doc */\nfunction nodeIndex(nodeName) {\n    for (var i in nodes) {\n        if (nodes[i].name === nodeName) return i;\n    }\n}\n\n/** needs doc */\nfunction findNode(name) {\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n        for (var _iterator2 = allNodes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var n = _step2.value;\n\n            if (n.name === name) return n;\n        }\n    } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                _iterator2.return();\n            }\n        } finally {\n            if (_didIteratorError2) {\n                throw _iteratorError2;\n            }\n        }\n    }\n}\n\n/** needs doc */\nfunction updateNode(id) {\n    var node = findNode(id);\n    if (node.grayout) return false;\n\n    var name = node.name;\n    var names = function names() {\n        return nodes.map(function (n) {\n            return n.name;\n        });\n    };\n    if (names().includes(name)) {\n        del(nodes, node.index);\n        links.filter(function (l) {\n            return l.source === node || l.target === node;\n        }).forEach(function (l) {\n            return del(links, -1, l);\n        });\n        zparamsReset(name);\n\n        // remove node name from group lists\n        node.group1 && del(zparams.zgroup1, -1, name);\n        node.group2 && del(zparams.zgroup2, -1, name);\n        node.group1 = node.group2 = false;\n\n        // node reset - perhaps this will become a hard reset back to all original allNode values?\n        node.nodeCol = node.baseCol;\n        node.strokeColor = _plots.selVarColor;\n        node.strokeWidth = \'1\';\n\n        borderState();\n    } else {\n        nodes.push(node);\n    }\n    zparams.zvars = names();\n    return true;\n}\n\n/**\n   every time a variable in leftpanel is clicked, nodes updates and background color changes\n*/\nfunction clickVar(elem) {\n    if (updateNode(elem.target.id)) {\n        // panelPlots(); is this necessary?\n        _restart();\n    }\n}\n\n/**\n  Retrieve the variable list from the preprocess data.\n  This helps handle the new format and (temporarily)\n  the older format in PRODUCTION (rp 8.14.2017)\n  "new" response:\n  {\n  "dataset" : {...}\n  "variables" : {\n  "var1" : {...},\n  (etc)\n  }\n  }\n  "old" response:\n  {\n  "var1" : {...},\n  (etc)\n  }\n*/\nfunction getVariableData(json) {\n    return json.hasOwnProperty(\'variables\') ? json.variables : json;\n}\n\n/**\n   called by force button\n*/\nfunction forceSwitch() {\n    forcetoggle = [forcetoggle[0] == \'true\' ? \'false\' : \'true\'];\n    if (forcetoggle[0] === "false") {\n        byId(\'btnForce\').setAttribute("class", "btn active");\n    } else {\n        byId(\'btnForce\').setAttribute("class", "btn btn-default");\n        fakeClick();\n    }\n}\n\n/** needs doc */\nfunction helpmaterials(type) {\n    if (type == "video") {\n        var win = window.open("http://2ra.vn/demos/d3mintegrationdemo.mp4", \'_blank\');\n        win.focus();\n    } else {\n        var win = window.open("http://2ra.vn/papers/tworavens-d3mguide.pdf", \'_blank\');\n        win.focus();\n    }\n    console.log(type);\n}\n\n/** needs doc */\nfunction lockDescription() {\n    exports.locktoggle = locktoggle = locktoggle ? false : true;\n    var temp = void 0;\n    var i = void 0;\n    if (!locktoggle) {\n        byId(\'btnLock\').setAttribute("class", "btn btn-default");\n        temp = byId(\'rightContentArea\').querySelectorAll("p.item-lineout");\n        for (i = 0; i < temp.length; i++) {\n            temp[i].classList.remove("item-lineout");\n        }\n    } else {\n        byId(\'btnLock\').setAttribute("class", "btn active");\n        temp = byId(\'metrics\').querySelectorAll("p.item-default");\n        console.log(temp);\n        for (i = 0; i < temp.length; i++) {\n            temp[i].classList.add("item-lineout");\n        }\n        temp = byId(\'types\').querySelectorAll("p.item-default");\n        for (i = 0; i < temp.length; i++) {\n            temp[i].classList.add("item-lineout");\n        }\n        temp = byId(\'subtypes\').querySelectorAll("p.item-default");\n        for (i = 0; i < temp.length; i++) {\n            temp[i].classList.add("item-lineout");\n        }\n        /*    temp = byId(\'outputs\').querySelectorAll("p.item-default");\n            for (i = 0; i < temp.length; i++) {\n                temp[i].classList.add("item-lineout");\n            }  */\n        fakeClick();\n    }\n}\n\n/** needs doc */\nfunction zPop() {\n    if (dataurl) zparams.zdataurl = dataurl;\n    zparams.zmodelcount = modelCount;\n    zparams.zedges = [];\n    zparams.zvars = [];\n    zparams.znature = [];\n    for (var j = 0; j < nodes.length; j++) {\n        //populate zvars array\n        zparams.zvars.push(nodes[j].name);\n        zparams.znature.push(nodes[j].nature);\n        var temp = nodes[j].id;\n        zparams.zsetx[j] = allNodes[temp].setxvals;\n        zparams.zsubset[j] = allNodes[temp].subsetrange;\n    }\n    for (var _j2 = 0; _j2 < links.length; _j2++) {\n        //populate zedges array\n        //correct the source target ordering for Zelig\n        var srctgt = links[_j2].left == false ? [links[_j2].source.name, links[_j2].target.name] : [links[_j2].target.name, links[_j2].source.name];\n        zparams.zedges.push(srctgt);\n    }\n}\n\nfunction tabulate(data, columns, divid) {\n    var table = d3.select(divid).append(\'table\');\n    var thead = table.append(\'thead\');\n    var tbody = table.append(\'tbody\');\n\n    // append the header row\n    thead.append(\'tr\').selectAll(\'th\').data(columns).enter().append(\'th\').text(function (column) {\n        return column;\n    });\n\n    // create a row for each object in the data\n    var rows = tbody.selectAll(\'tr\').data(data).enter().append(\'tr\').attr(\'class\', function (d, i) {\n        if (i == 0) return \'item-select\';else return \'item-default\';\n    });\n\n    // create a cell in each row for each column\n    var cells = rows.selectAll(\'td\').data(function (row) {\n        return columns.map(function (column) {\n            return { column: column, value: row[column] };\n        });\n    }).enter().append(\'td\').text(function (d) {\n        return d.value;\n    }).on("click", function (d) {\n        var myrow = this.parentElement;\n        if (myrow.className == "item-select") {\n            return;\n        } else {\n            d3.select(divid).select("tr.item-select").attr(\'class\', \'item-default\');\n            d3.select(myrow).attr(\'class\', "item-select");\n            document.getElementById("tab2input").value = disco[myrow.rowIndex - 1].description;\n            if (divid == \'#setxRight\') {\n                resultsplotinit(myrow.firstChild.innerText);\n            }\n        }\n    });\n\n    // this is code to add a checkbox to each row of the table\n    if (divid == \'#tab2\') {\n        d3.select(divid).selectAll("tr").append("input").attr("type", "checkbox").attr("checked", true).style("float", "right");\n    }\n\n    return table;\n}\n\nfunction onPipelineCreate(PipelineCreateResult, rookpipe) {\n    // rpc GetExecutePipelineResults(PipelineExecuteResultsRequest) returns (stream PipelineExecuteResult) {}\n    estimateLadda.stop(); // stop spinner\n    console.log(PipelineCreateResult);\n\n    // change status of buttons for estimating problem and marking problem as finished\n    $("#btnEstimate").removeClass("btn-success");\n    $("#btnEstimate").addClass("btn-default");\n    $("#btnEndSession").removeClass("btn-default");\n    $("#btnEndSession").addClass("btn-success");\n\n    var context = apiSession(zparams.zsessionid);\n    for (var i = 0; i < PipelineCreateResult.length; i++) {\n        if (PipelineCreateResult[i].pipelineId in allPipelineInfo) {\n            allPipelineInfo[PipelineCreateResult[i].pipelineId] = Object.assign(allPipelineInfo[PipelineCreateResult[i].pipelineId], PipelineCreateResult[i]);\n        } else {\n            allPipelineInfo[PipelineCreateResult[i].pipelineId] = PipelineCreateResult[i];\n        }\n    }\n    console.log(allPipelineInfo);\n    // to get all pipeline ids: Object.keys(allPipelineInfo)\n\n    var resultstable = [];\n\n    for (var key in allPipelineInfo) {\n        // this will NOT report the pipeline to user if pipeline has failed, if pipeline is still running, or if it has not completed\n        if (allPipelineInfo[key].responseInfo.status.details == "Pipeline Failed") {\n            continue;\n        }\n        if (allPipelineInfo[key].progressInfo == "RUNNING") {\n            continue;\n        }\n\n        var myid = "";\n        var mymetric = "";\n        var myval = "";\n        console.log(key);\n        console.log(allPipelineInfo[key].progressInfo);\n        var myscores = [];\n        if (allPipelineInfo[key].progressInfo == "COMPLETED") {\n            myscores = allPipelineInfo[key].pipelineInfo.scores;\n            for (var i = 0; i < myscores.length; i++) {\n                //if(i==0) {myid=key;}\n                //   else myid="";\n                myid = key;\n                mymetric = myscores[i].metric;\n                myval = +myscores[i].value.toFixed(3);\n                resultstable.push({ "PipelineID": myid, "Metric": mymetric, "Score": myval });\n            }\n        } else {\n            // if progressInfo is not "COMPLETED"\n            continue;\n        }\n    }\n\n    console.log(resultstable);\n    // render the tables\n    tabulate(resultstable, [\'PipelineID\', \'Metric\', \'Score\'], \'#results\');\n    tabulate(resultstable, [\'PipelineID\', \'Metric\', \'Score\'], \'#setxRight\');\n    /////////////////////////\n\n    toggleRightButtons("all");\n    if (IS_D3M_DOMAIN) {\n        byId("btnResults").click();\n    };\n\n    //adding rookpipe to allPipelineInfo\n    allPipelineInfo.rookpipe = rookpipe;\n\n    // this initializes the results windows using the first pipeline\n    if (!swandive) {\n        resultsplotinit(resultstable[0].PipelineID);\n    }\n    // VJD: these two functions are built and (I believe) functioning as intended. These exercise two core API calls that are currently unnecessary\n    //exportpipeline(resultstable[1].PipelineID);\n    //listpipelines();\n\n    // VJD: this is a third core API call that is currently unnecessary\n    //let pipelineid = PipelineCreateResult.pipelineid;\n    // getexecutepipelineresults is the third to be called\n    //  makeRequest(D3M_SVC_URL + \'/getexecutepipelineresults\', {context, pipeline_ids: Object.keys(allPipelineInfo)});\n}\n\nfunction CreatePipelineData(predictors, depvar, aux) {\n    var context = apiSession(zparams.zsessionid);\n    var uriCsv = zparams.zd3mdata;\n    var uriJson = uriCsv.substring(0, uriCsv.lastIndexOf("/tables")) + "/datasetDoc.json";\n    var targetFeatures = [{ \'resource_id\': "0", \'feature_name\': depvar[0] }];\n    var predictFeatures = [];\n    for (var i = 0; i < predictors.length; i++) {\n        predictFeatures[i] = { \'resource_id\': "0", \'feature_name\': predictors[i] };\n    }\n    if (typeof aux === "undefined") {\n        //default behavior for creating pipeline data\n        return {\n            context: context,\n            dataset_uri: uriJson, // uriCsv is also valid, but not currently accepted by ISI TA2\n            task: d3mTaskType[d3mProblemDescription.taskType][1],\n            taskSubtype: d3mTaskSubtype[d3mProblemDescription.taskSubtype][1],\n            taskDescription: d3mProblemDescription.taskDescription,\n            output: "OUTPUT_TYPE_UNDEFINED", // valid values will come in future API\n            metrics: [d3mMetrics[d3mProblemDescription.metric][1]],\n            targetFeatures: targetFeatures,\n            /* Example:\n              "targetFeatures": [\n              {\n                  "resource_id": "0",\n                  "feature_name": "At_bats"\n              }\n              ],\n            */\n            predictFeatures: predictFeatures,\n            /* Example:\n              "predictReatures": [\n              {\n                "resource_id": "0",\n                "feature_name": "RBIs"\n              }\n              ],\n            */\n            maxPipelines: 5 //user to specify this eventually?\n        };\n    } else {\n        //creating pipeline data for problem discovery using aux inputs\n        return {\n            context: context,\n            dataset_uri: uriJson, // uriCsv is also valid, but not currently accepted by ISI TA2\n            task: aux.task,\n            taskSubtype: "TASK_SUBTYPE_UNDEFINED",\n            taskDescription: aux.description,\n            output: "OUTPUT_TYPE_UNDEFINED",\n            metrics: [aux.metrics],\n            targetFeatures: targetFeatures,\n            predictFeatures: predictFeatures,\n            maxPipelines: 1\n        };\n    }\n}\n\nfunction downloadIncomplete() {\n    if (PRODUCTION && zparams.zsessionid === \'\') {\n        alert(\'Warning: Data download is not complete. Try again soon.\');\n        return true;\n    }\n    return false;\n}\n\n/**\n    called by clicking \'Solve This Problem\' in model mode\n*/\nasync function estimate(btn) {\n    if (!IS_D3M_DOMAIN) {\n        if (downloadIncomplete()) {\n            return;\n        }\n\n        zPop();\n        // write links to file & run R CMD\n        // package the output as JSON\n        // add call history and package the zparams object as JSON\n        zparams.callHistory = callHistory;\n        zparams.allVars = valueKey.slice(10, 25); // because the URL is too long...\n\n        /* UNUSED\n        var selectorurlcall = ROOK_SVC_URL + "selectorapp";\n        function selectorSuccess(btn, json) {\n            d3.select("#ticker")\n                .text("Suggested variables and percent improvement on RMSE: " + json.vars);\n            cdb("selectorSuccess: ", json);\n        }\n        function selectorFail(btn) {\n            alert("Selector Fail");\n        }\n        */\n\n        estimateLadda.start(); // start spinner\n        var json = await makeRequest(ROOK_SVC_URL + \'zeligapp\', zparams);\n        if (!json) {\n            estimated = true;\n        } else {\n            var modCol = function modCol() {\n                d3.select("#modelView").selectAll("p").style(\'background-color\', hexToRgba(varColor));\n            };\n\n            allResults.push(json);\n            if (!estimated) byId("results").removeChild(byId("resultsHolder"));\n\n            estimated = true;\n            d3.select("#results").style("display", "block");\n\n            d3.select("#resultsView").style("display", "block");\n\n            d3.select("#modelView").style("display", "block");\n\n            // programmatic click on Results button\n            $("#btnResults").trigger("click");\n\n            var model = "Model".concat(exports.modelCount = modelCount = modelCount + 1);\n\n            modCol();\n\n            d3.select("#modelView").insert("p", ":first-child") // top stack for results\n            .attr("id", model).text(model).style(\'background-color\', hexToRgba(_plots.selVarColor)).on("click", function () {\n                var a = this.style.backgroundColor.replace(/\\s*/g, "");\n                var b = hexToRgba(_plots.selVarColor).replace(/\\s*/g, "");\n                if (a.substr(0, 17) == b.substr(0, 17)) return; // escape function if displayed model is clicked\n                modCol();\n                d3.select(this).style(\'background-color\', hexToRgba(_plots.selVarColor));\n                viz(this.id);\n            });\n\n            var rCall = [json.call];\n            showLog(\'estimate\', rCall);\n\n            viz(model);\n        }\n    } else if (swandive) {\n        // IS_D3M_DOMAIN and swandive is true\n        zPop();\n        zparams.callHistory = callHistory;\n\n        var myvki = valueKey.indexOf(mytarget);\n        if (myvki != -1) {\n            del(valueKey, myvki);\n        }\n\n        estimateLadda.start(); // start spinner\n        var res = await makeRequest(D3M_SVC_URL + \'/CreatePipelines\', CreatePipelineData(valueKey, mytarget));\n        res && onPipelineCreate(res);\n    } else {\n        // we are in IS_D3M_DOMAIN no swandive\n        // rpc CreatePipelines(PipelineCreateRequest) returns (stream PipelineCreateResult) {}\n        zPop();\n        zparams.callHistory = callHistory;\n\n        // pipelineapp is a rook application that returns the dependent variable, the DV values, and the predictors. can think of it was a way to translate the potentially complex grammar from the UI\n\n        estimateLadda.start(); // start spinner\n        var rookpipe = await makeRequest(ROOK_SVC_URL + \'pipelineapp\', zparams);\n        if (!rookpipe) {\n            estimated = true;\n        } else {\n            console.log(rookpipe);\n            setxTable(rookpipe.predictors);\n            //     let dvvals = res.dvvalues;\n            //    let dvvar = res.depvar[0];\n            var _res = await makeRequest(D3M_SVC_URL + \'/CreatePipelines\', CreatePipelineData(rookpipe.predictors, rookpipe.depvar));\n            //   res = await makeRequest(ROOK_SVC_URL + \'createpipeline\', zparams);\n            _res && onPipelineCreate(_res, rookpipe);\n        }\n    }\n    exports.task2_finished = task2_finished = true;\n}\n\n/** needs doc */\nfunction ta2stuff() {\n    console.log(d3mProblemDescription);\n}\n\n/** needs doc */\nasync function dataDownload() {\n    zPop();\n    // write links to file & run R CMD\n\n    // package the output as JSON\n    // add call history and package the zparams object as JSON\n    var res = await makeRequest(ROOK_SVC_URL + \'dataapp\', zparams);\n    if (!res) {\n        return;\n    }\n\n    zparams.zsessionid = res.sessionid[0];\n    // set link URL\n    byId("logID").href = \'\' + (PRODUCTION ? ROOK_SVC_URL + \'log_dir/log_\' : \'rook/log_\') + zparams.zsessionid + \'.txt\';\n}\n\n/** needs doc */\nfunction viz(mym) {\n    mym = +mym.substr(5, 5) - 1;\n\n    var removeKids = function removeKids(parent) {\n        while (parent.firstChild) {\n            parent.removeChild(parent.firstChild);\n        }\n    };\n    removeKids(byId("resultsView"));\n\n    var json = allResults[mym];\n\n    // pipe in figures to right panel\n    var filelist = new Array();\n    for (var i in json.images) {\n        var zfig = document.createElement("img");\n        zfig.setAttribute("src", json.images[i]);\n        zfig.setAttribute(\'width\', 200);\n        zfig.setAttribute(\'height\', 200);\n        byId("resultsView").appendChild(zfig);\n    }\n\n    // write the results table\n    var resultsArray = [];\n    for (var key in json.sumInfo) {\n        if (key == \'colnames\') continue;\n        resultsArray.push(json.sumInfo[key]);\n    }\n\n    var table = d3.select("#resultsView").append("p").append("table");\n\n    var thead = table.append("thead");\n    thead.append("tr").selectAll("th").data(json.sumInfo.colnames).enter().append("th").text(function (d) {\n        return d;\n    });\n\n    var tbody = table.append("tbody");\n    tbody.selectAll("tr").data(resultsArray).enter().append("tr").selectAll("td").data(function (d) {\n        return d;\n    }).enter().append("td").text(function (d) {\n        var myNum = Number(d);\n        if (isNaN(myNum)) return d;\n        return myNum.toPrecision(3);\n    }).on("mouseover", function () {\n        d3.select(this).style("background-color", "aliceblue");\n    }) // for no discernable reason\n    .on("mouseout", function () {\n        d3.select(this).style("background-color", "#F9F9F9");\n    }); //(but maybe we\'ll think of one)\n\n    d3.select("#resultsView").append("p").html(function () {\n        return "<b>Formula: </b>".concat(json.call[0]);\n    });\n\n    _mithril2.default.redraw();\n}\n\n/**\n   parses the transformation input.\n   variable names are often nested inside one another, e.g., ethwar, war, wars, and so this is handled\n*/\nfunction transParse(n) {\n    var out2 = [];\n    var t2 = n;\n    var k2 = 0;\n    var subMe2 = "_transvar".concat(k2);\n    var indexed = [];\n\n    // out2 is all matched variables, indexed is an array, each element is an object that contains the matched variables starting index and finishing index.  e.g., n="wars+2", out2=[war, wars], indexed=[{0,2},{0,3}]\n    for (var i in valueKey) {\n        var m2 = n.match(valueKey[i]);\n        if (m2 != null) out2.push(m2[0]);\n\n        var re = new RegExp(valueKey[i], "g");\n        var s = n.search(re);\n        if (s != -1) indexed.push({ from: s, to: s + valueKey[i].length });\n    }\n\n    // nested loop not good, but indexed is not likely to be very large.\n    // if a variable is nested, it is removed from out2\n    // notice, loop is backwards so that index changes don\'t affect the splice\n    cdb("indexed ", indexed);\n    for (var i = indexed.length - 1; i > -1; i--) {\n        for (var j = indexed.length - 1; j > -1; j--) {\n            if (i === j) continue;\n            if (indexed[i].from >= indexed[j].from & indexed[i].to <= indexed[j].to) {\n                cdb(i, " is nested in ", j);\n                del(out2, i);\n            }\n        }\n    }\n\n    for (var i in out2) {\n        t2 = t2.replace(out2[i], subMe2); //something that\'ll never be a variable name\n        k2 = k2 + 1;\n        subMe2 = "_transvar".concat(k2);\n    }\n\n    if (out2.length > 0) {\n        out2.push(t2);\n        cdb("new out ", out2);\n        return out2;\n    } else {\n        alert("No variable name found. Perhaps check your spelling?");\n        return null;\n    }\n}\n\n/**\n   n = name of column/node\n   t = selected transformation\n*/\nasync function transform(n, t, typeTransform) {\n    if (downloadIncomplete()) {\n        return;\n    }\n\n    if (!typeTransform) t = t.replace("+", "_plus_"); // can\'t send the plus operator\n\n    cdb(\'name of col: \' + n);\n    cdb(\'transformation: \' + t);\n\n    var btn = byId(\'btnEstimate\');\n\n    // find the node by name\n    var myn = findNodeIndex(n[0], true);\n\n    if (typeof myn === "undefined") {\n        myn = findNodeIndex(n, true);\n    }\n\n    var outtypes = {\n        varnamesTypes: n,\n        interval: myn.interval,\n        numchar: myn.numchar,\n        nature: myn.nature,\n        binary: myn.binary\n    };\n\n    cdb(myn);\n    // if typeTransform but we already have the metadata\n    if (typeTransform) {\n        if (myn.nature == "nominal" & typeof myn.plotvalues !== "undefined") {\n            myn.plottype = "bar";\n            (0, _plots.barsNode)(myn);\n            panelPlots();\n            return;\n        } else if (myn.nature != "nominal" & typeof myn.plotx !== "undefined") {\n            myn.plottype = "continuous";\n            (0, _plots.densityNode)(myn);\n            panelPlots();\n            return;\n        }\n    }\n\n    estimateLadda.start(); // start spinner\n    var json = await makeRequest(ROOK_SVC_URL + \'transformapp\', { zdataurl: dataurl,\n        zvars: myn.name,\n        zsessionid: zparams.zsessionid,\n        transform: t,\n        callHistory: callHistory,\n        typeTransform: typeTransform,\n        typeStuff: outtypes });\n    if (!json) {\n        return;\n    }\n\n    // Is this a typeTransform?\n    if (json.typeTransform[0]) {\n        // Yes. We\'re updating an existing node\n        d3.json(json.url, function (err, data) {\n            if (err) return console.warn(err);\n            var node = void 0;\n            for (var key in data) {\n                node = findNodeIndex(key, true);\n                if (!node) continue;\n                jQuery.extend(true, node, data[key]);\n                node.plottype === "continuous" ? (0, _plots.densityNode)(node) : node.plottype === "bar" ? (0, _plots.barsNode)(node) : null;\n            }\n            fakeClick();\n            panelPlots();\n            node && cdb(node);\n        });\n    } else {\n        /* No, we have a new node here--e.g. the transformed column\n           example response: {\n           "call":["t_year_2"],\n           "url":["data/preprocessSubset_BACCBC78-7DD9-4482-B31D-6EB01C3A0C95.txt"],\n           "trans":["year","_transvar0^2"],\n           "typeTransform":[false]\n           }\n        */\n        callHistory.push({\n            func: "transform",\n            zvars: n,\n            transform: t\n        });\n\n        var subseted = false;\n        var rCall = [];\n\n        rCall[0] = json.call;\n        var newVar = rCall[0][0];\n\n        trans.push(newVar);\n\n        // Read the preprocess file containing values\n        // for the transformed variable\n        //\n        d3.json(json.url, function (error, json) {\n            if (error) return console.warn(error);\n\n            var jsondata = getVariableData(json);\n\n            for (var key in jsondata) {\n                var myIndex = findNodeIndex(key);\n                if (typeof myIndex !== "undefined") {\n                    alert("Invalid transformation: this variable name already exists.");\n                    return;\n                }\n                // add transformed variable to the current space\n                var i = allNodes.length; // get new index\n                var obj1 = {\n                    id: i,\n                    reflexive: false,\n                    name: key,\n                    labl: "transformlabel",\n                    data: [5, 15, 20, 0, 5, 15, 20],\n                    count: [.6, .2, .9, .8, .1, .3, .4],\n                    nodeCol: colors(i),\n                    baseCol: colors(i),\n                    strokeColor: _plots.selVarColor,\n                    strokeWidth: "1",\n                    subsetplot: false,\n                    subsetrange: ["", ""],\n                    setxplot: false,\n                    setxvals: ["", ""],\n                    grayout: false,\n                    defaultInterval: jsondata[key].interval,\n                    defaultNumchar: jsondata[key].numchar,\n                    defaultNature: jsondata[key].nature,\n                    defaultBinary: jsondata[key].binary\n                };\n\n                jQuery.extend(true, obj1, jsondata[key]);\n                allNodes.push(obj1);\n\n                valueKey.push(newVar);\n                nodes.push(allNodes[i]);\n                fakeClick();\n                panelPlots();\n\n                if (allNodes[i].plottype === "continuous") {\n                    (0, _plots.densityNode)(allNodes[i]);\n                } else if (allNodes[i].plottype === "bar") {\n                    (0, _plots.barsNode)(allNodes[i]);\n                }\n\n                _mithril2.default.redraw();\n            }\n        });\n\n        showLog(\'transform\', rCall);\n    }\n}\n\nasync function makeRequest(url, data) {\n    console.log(\'url:\', url);\n    console.log(\'POST:\', data);\n    var res = void 0;\n    try {\n        res = await _mithril2.default.request(url, { method: \'POST\', data: data });\n        console.log(\'response:\', res);\n        if (Object.keys(res)[0] === \'warning\') {\n            alert(\'Warning: \' + res.warning);\n            end_ta3_search(false, res.warning);\n        }\n    } catch (err) {\n        end_ta3_search(false, err);\n        cdb(err);\n        alert(\'Error: call to \' + url + \' failed\');\n    }\n\n    /*\n     // call end_ta3_search if status != OK\n     // status may be in different places for different calls though, and this is not worth doing at the moment\n     let myreg = /d3m-service/g;\n     let isd3mcall = myreg.test(url);\n     if(isd3mcall) {\n         let mystatus = res.responseInfo.status.code.toUpperCase();\n         if(mystatus != "OK") {\n             end_ta3_search(false, "grpc response status not ok");\n         }\n     }\n     */\n\n    if (!IS_D3M_DOMAIN) {\n        estimateLadda.stop(); // estimateLadda is being stopped in onPipelineCreate in D3M\n    };\n    selectLadda.stop();\n    return res;\n}\n\n/** needs doc */\nfunction legend() {\n    borderState();\n    _mithril2.default.redraw();\n}\n\n/**\n   programmatically deselect every selected variable\n*/\nfunction erase() {\n    [\'#leftpanel\', \'#rightpanel\'].forEach(function (id) {\n        return d3.select(id).attr(\'class\', \'sidepanel container clearfix\');\n    });\n    tabLeft(\'tab1\');\n    $("#varList").children().each(function () {\n        if (zparams.zdv.concat(zparams.znom, zparams.zvars).includes(this.id)) clickVar({ target: this });\n    });\n}\n\n/** needs doc */\nfunction tabLeft(tab) {\n    byId(\'tab1\').style.display = \'none\';\n    byId(\'tab2\').style.display = \'none\';\n    byId(\'tab3\').style.display = \'none\';\n    byId(tab).style.display = \'block\';\n    if (tab != \'tab3\') {\n        exports.subset = subset = tab == \'tab2\';\n        exports.summaryHold = summaryHold = false;\n    }\n    exports.lefttab = lefttab = tab;\n}\n\n/** needs doc */\nfunction tabRight(tab) {\n    var select = function select(cls) {\n        var panel = d3.select("#rightpanel");\n        return cls ? panel.attr(\'class\', cls) : panel.attr(\'class\');\n    };\n    var cls = "sidepanel container clearfix";\n    var toggleR = function toggleR(full) {\n        select(function () {\n            return cls + this.getAttribute("class") === cls ? \'\' : cls + \' expandpanel\' + full;\n        });\n    };\n    if (tab === "btnModels") select(cls);else if (tab === "btnSetx") righttab === "btnSetx" || select() === cls && toggleR(\'full\');else if (tab === "btnResults") !estimated ? select(cls) : righttab === "btnResults" || select() === cls && toggleR();else if (tab === "btnUnivariate") select(cls);\n\n    if (tab == "btnType" || tab == "btnSubtype" || tab == "btnMetrics") {\n        document.getElementById("rightpanel").classList.remove("expandpanelfull");\n    }\n    exports.righttab = righttab = tab;\n}\n\nvar summary = exports.summary = { data: [] };\n\n/** needs doc */\nfunction varSummary(d) {\n    var t1 = \'Mean:, Median:, Most Freq:, Occurrences:, Median Freq:, Occurrences:, Least Freq:, Occurrences:, Std Dev:, Minimum:, Maximum:, Invalid:, Valid:, Uniques:, Herfindahl\'.split(\', \');\n\n    var rint = d3.format(\'r\');\n    var str = function str(x, p) {\n        return (+x).toPrecision(p || 4).toString();\n    };\n    var t2 = priv && d.meanCI ? [str(d.mean, 2) + \' (\' + str(d.meanCI.lowerBound, 2) + \' - \' + str(d.meanCI.upperBound, 2) + \')\', str(d.median), d.mode, rint(d.freqmode), d.mid, rint(d.freqmid), d.fewest, rint(d.freqfewest), str(d.sd), str(d.min), str(d.max), rint(d.invalid), rint(d.valid), rint(d.uniques), str(d.herfindahl)] : [str(d.mean), str(d.median), d.mode, rint(d.freqmode), d.mid, rint(d.freqmid), d.fewest, rint(d.freqfewest), str(d.sd), str(d.min), str(d.max), rint(d.invalid), rint(d.valid), rint(d.uniques), str(d.herfindahl)];\n\n    summary.data = [];\n    t1.forEach(function (e, i) {\n        return !t2[i].includes(\'NaN\') && t2[i] != \'NA\' && t2[i] != \'\' && summary.data.push([e, t2[i]]);\n    });\n\n    summary.name = d.name;\n    summary.labl = d.labl;\n\n    d3.select(\'#tab3\').selectAll(\'svg\').remove();\n\n    if (!d.plottype) return;\n    d.plottype == \'continuous\' ? (0, _plots.density)(d, \'varSummary\', priv) : d.plottype == "bar" ? (0, _plots.bars)(d, \'varSummary\', priv) : d3.select("#tab3") // no graph to draw, but still need to remove previous graph\n    .selectAll("svg").remove();\n}\n\nvar popoverContent = exports.popoverContent = function popoverContent(d) {\n    if (swandive) return;\n    var text = \'\';\n    var _ref3 = [d3.format(\'r\'), function (val, int) {\n        return (+val).toPrecision(int).toString();\n    }],\n        rint = _ref3[0],\n        prec = _ref3[1];\n\n    var div = function div(field, name, val) {\n        if (field != \'NA\') text += \'<div class=\\\'form-group\\\'><label class=\\\'col-sm-4 control-label\\\'>\' + name + \'</label><div class=\\\'col-sm-6\\\'><p class=\\\'form-control-static\\\'>\' + (val || field) + \'</p></div></div>\';\n    };\n    d.labl != \'\' && div(d.labl, \'Label\');\n    div(d.mean, \'Mean\', priv && d.meanCI ? prec(d.mean, 2) + \' (\' + prec(d.meanCI.lowerBound, 2) + \' - \' + prec(d.meanCI.upperBound, 2) + \')\' : prec(d.mean, 4));\n    div(d.median, \'Median\', prec(d.median, 4));\n    div(d.mode, \'Most Freq\');\n    div(d.freqmode, \'Occurrences\', rint(d.freqmode));\n    div(d.mid, \'Median Freq\');\n    div(d.freqmid, \'Occurrences\', rint(d.freqmid));\n    div(d.fewest, \'Least Freq\');\n    div(d.freqfewest, \'Occurrences\', rint(d.freqfewest));\n    div(d.sd, \'Stand Dev\', prec(d.sd, 4));\n    div(d.max, \'Maximum\', prec(d.max, 4));\n    div(d.min, \'Minimum\', prec(d.min, 4));\n    div(d.invalid, \'Invalid\', rint(d.invalid));\n    div(d.valid, \'Valid\', rint(d.valid));\n    div(d.uniques, \'Uniques\', rint(d.uniques));\n    div(d.herfindahl, \'Herfindahl\', prec(d.herfindahl, 4));\n    return text;\n};\n\n/** needs doc */\nfunction panelPlots() {\n\n    if (IS_D3M_DOMAIN) {}\n    //    byId(\'btnSubset\').classList.add(\'noshow\');\n\n    // build arrays from nodes in main\n    var vars = [];\n    var ids = [];\n    nodes.forEach(function (n) {\n        vars.push(n.name.replace(/\\(|\\)/g, \'\'));\n        ids.push(n.id);\n    });\n\n    //remove all plots, could be smarter here\n    d3.select(\'#setxLeft\').selectAll(\'svg\').remove();\n    d3.select(\'#tab2\').selectAll(\'svg\').remove();\n    for (var i = 0; i < vars.length; i++) {\n        if (allNodes[ids[i]].valid == 0) // this was a silent error... very frustrating...\n            continue;\n        var node = allNodes[ids[i]];\n        node.setxplot = false;\n        node.subsetplot = false;\n        if (node.plottype === "continuous" & node.setxplot == false) {\n            node.setxplot = true;\n            (0, _plots.density)(node, div = "setxLeft", priv);\n            node.subsetplot = true;\n            (0, _plots.density)(node, div = "subset", priv);\n        } else if (node.plottype === "bar" & node.setxplot == false) {\n            node.setxplot = true;\n            (0, _plots.bars)(node, div = "setxLeft", priv);\n            node.subsetplot = true;\n            (0, _plots.barsSubset)(node);\n        }\n    }\n\n    d3.select("#setxLeft").selectAll("svg").each(function () {\n        d3.select(this);\n        var regstr = /(.+)_setxLeft_(\\d+)/;\n        var myname = regstr.exec(this.id);\n        var nodeid = myname[2];\n        myname = myname[1];\n        if (!vars.includes(myname)) {\n            allNodes[nodeid].setxplot = false;\n            var temp = "#".concat(myname, "_setxLeft_", nodeid);\n            d3.select(temp).remove();\n            allNodes[nodeid].subsetplot = false;\n            temp = "#".concat(myname, "_tab2_", nodeid);\n            d3.select(temp).remove();\n        }\n    });\n\n    // just removing all the subset plots here, because using this button for problem discover\n    d3.select(\'#tab2\').selectAll(\'svg\').remove();\n}\n\n/**\n   converts color codes\n*/\nvar hexToRgba = exports.hexToRgba = function hexToRgba(hex) {\n    var int = parseInt(hex.replace(\'#\', \'\'), 16);\n    return \'rgba(\' + [int >> 16 & 255, int >> 8 & 255, int & 255, \'0.5\'].join(\',\') + \')\';\n};\n\n/**\n   takes node and color and updates zparams\n*/\nfunction setColors(n, c) {\n    if (n.strokeWidth == \'1\') {\n        if (c == gr1Color) {\n            var tempindex = zparams.zgroup1.indexOf(n.name);\n            if (tempindex > -1) {\n                n.group1 = false;\n                del(zparams.zgroup1, tempindex);\n            } else {\n                n.group1 = true;\n                zparams.zgroup1.push(n.name);\n            };\n        } else if (c == gr2Color) {\n            var tempindex = zparams.zgroup2.indexOf(n.name);\n            if (tempindex > -1) {\n                n.group2 = false;\n                del(zparams.zgroup2, tempindex);\n            } else {\n                n.group2 = true;\n                zparams.zgroup2.push(n.name);\n            };\n        } else {\n            // adding time, cs, dv, nom to node with no stroke\n            n.strokeWidth = \'4\';\n            n.strokeColor = c;\n            n.nodeCol = taggedColor;\n            var push = function push(_ref4) {\n                var _ref5 = _slicedToArray(_ref4, 2),\n                    color = _ref5[0],\n                    key = _ref5[1];\n\n                if (color != c) return;\n                zparams[key] = Array.isArray(zparams[key]) ? zparams[key] : [];\n                zparams[key].push(n.name);\n                if (key == \'znom\') {\n                    findNodeIndex(n.name, true).nature = "nominal";\n                    transform(n.name, t = null, typeTransform = true);\n                }\n                if (key == \'zdv\') {\n                    // remove group memberships from dv\'s\n                    if (n.group1) {\n                        n.group1 = false;\n                        del(zparams.zgroup1, -1, n.name);\n                    };\n                    if (n.group2) {\n                        n.group2 = false;\n                        del(zparams.zgroup2, -1, n.name);\n                    };\n                }\n            };\n            [[dvColor, \'zdv\'], [csColor, \'zcross\'], [timeColor, \'ztime\'], [nomColor, \'znom\']].forEach(push);\n        }\n    } else if (n.strokeWidth == \'4\') {\n        if (c == n.strokeColor) {\n            // deselecting time, cs, dv, nom\n            n.strokeWidth = \'1\';\n            n.strokeColor = _plots.selVarColor;\n            n.nodeCol = colors(n.id);\n            zparamsReset(n.name);\n            if (nomColor == c && zparams.znom.includes(n.name)) {\n                findNodeIndex(n.name, true).nature = findNodeIndex(n.name, true).defaultNature;\n                transform(n.name, t = null, typeTransform = true);\n            }\n        } else {\n            // deselecting time, cs, dv, nom AND changing it to time, cs, dv, nom\n            zparamsReset(n.name);\n            if (nomColor == n.strokeColor && zparams.znom.includes(n.name)) {\n                findNodeIndex(n.name, true).nature = findNodeIndex(n.name, true).defaultNature;\n                transform(n.name, t = null, typeTransform = true);\n            }\n            n.strokeColor = c;\n            if (dvColor == c) {\n                var dvname = n.name;\n                zparams.zdv.push(dvname);\n                if (n.group1) {\n                    // remove group memberships from dv\'s\n                    ngroup1 = false;\n                    del(zparams.zgroup1, -1, dvname);\n                };\n                if (n.group2) {\n                    ngroup2 = false;\n                    del(zparams.zgroup2, -1, dvname);\n                };\n            } else if (csColor == c) zparams.zcross.push(n.name);else if (timeColor == c) zparams.ztime.push(n.name);else if (nomColor == c) {\n                zparams.znom.push(n.name);\n                findNodeIndex(n.name, true).nature = "nominal";\n                transform(n.name, t = null, typeTransform = true);\n            }\n        }\n    }\n}\n\n/** needs doc */\nfunction borderState() {\n    zparams.zdv.length > 0 ? $(\'#dvButton .rectColor svg circle\').attr(\'stroke\', dvColor) : $(\'#dvButton\').css(\'border-color\', \'#ccc\');\n    zparams.zcross.length > 0 ? $(\'#csButton .rectColor svg circle\').attr(\'stroke\', csColor) : $(\'#csButton\').css(\'border-color\', \'#ccc\');\n    zparams.ztime.length > 0 ? $(\'#timeButton .rectColor svg circle\').attr(\'stroke\', timeColor) : $(\'#timeButton\').css(\'border-color\', \'#ccc\');\n    zparams.znom.length > 0 ? $(\'#nomButton .rectColor svg circle\').attr(\'stroke\', nomColor) : $(\'#nomButton\').css(\'border-color\', \'#ccc\');\n    zparams.zgroup1.length > 0 ? $(\'#gr1Button .rectColor svg circle\').attr(\'stroke\', gr1Color).attr(\'fill\', gr1Color).attr(\'fill-opacity\', 0.6).attr(\'stroke-opacity\', 0) : $(\'#gr1Button\').css(\'border-color\', \'#ccc\');\n    zparams.zgroup2.length > 0 ? $(\'#gr2Button .rectColor svg circle\').attr(\'stroke\', gr2Color).attr(\'fill\', gr2Color).attr(\'fill-opacity\', 0.6).attr(\'stroke-opacity\', 0) : $(\'#gr2Button\').css(\'border-color\', \'#ccc\');\n}\n\n/** needs doc */\nfunction subsetSelect(btn) {\n    if (dataurl) {\n        zparams.zdataurl = dataurl;\n    }\n    if (downloadIncomplete()) {\n        return;\n    }\n\n    zparams.zvars = [];\n    zparams.zplot = [];\n    var subsetEmpty = true;\n    // is this the same as zPop()?\n    for (var j = 0; j < nodes.length; j++) {\n        // populate zvars and zsubset arrays\n        zparams.zvars.push(nodes[j].name);\n        var temp = nodes[j].id;\n        zparams.zsubset[j] = allNodes[temp].subsetrange;\n        if (zparams.zsubset[j].length > 0) {\n            if (zparams.zsubset[j][0] != "") zparams.zsubset[j][0] = Number(zparams.zsubset[j][0]);\n            if (zparams.zsubset[j][1] != "") zparams.zsubset[j][1] = Number(zparams.zsubset[j][1]);\n        }\n        zparams.zplot.push(allNodes[temp].plottype);\n        if (zparams.zsubset[j][1] != "") subsetEmpty = false; // only need to check one\n    }\n\n    if (subsetEmpty == true) {\n        alert("Warning: No new subset selected.");\n        return;\n    }\n\n    var outtypes = [];\n    for (var j = 0; j < allNodes.length; j++) {\n        outtypes.push({\n            varnamesTypes: allNodes[j].name,\n            nature: allNodes[j].nature,\n            numchar: allNodes[j].numchar,\n            binary: allNodes[j].binary,\n            interval: allNodes[j].interval\n        });\n    }\n\n    selectLadda.start(); // start button motion\n    var json = makeRequest(ROOK_SVC_URL + \'subsetSelect\', { zdataurl: zparams.zdataurl,\n        zvars: zparams.zvars,\n        zsubset: zparams.zsubset,\n        zsessionid: zparams.zsessionid,\n        zplot: zparams.zplot,\n        callHistory: callHistory,\n        typeStuff: outtypes });\n    selectLadda.stop();\n    if (!json) {\n        return;\n    }\n\n    $("#btnVariables").trigger("click"); // programmatic clicks\n    $("#btnModels").trigger("click");\n\n    var grayOuts = [];\n    var rCall = [];\n    rCall[0] = json.call;\n\n    // store contents of the pre-subset space\n    zPop();\n    var myNodes = jQuery.extend(true, [], allNodes);\n    var myParams = jQuery.extend(true, {}, zparams);\n    var myTrans = jQuery.extend(true, [], trans);\n    var myForce = jQuery.extend(true, [], forcetoggle);\n    var myPreprocess = jQuery.extend(true, {}, preprocess);\n    var myLog = jQuery.extend(true, [], logArray);\n    var myHistory = jQuery.extend(true, [], callHistory);\n\n    spaces[myspace] = {\n        "allNodes": myNodes,\n        "zparams": myParams,\n        "trans": myTrans,\n        "force": myForce,\n        "preprocess": myPreprocess,\n        "logArray": myLog,\n        "callHistory": myHistory\n    };\n\n    // remove pre-subset svg\n    var selectMe = "#m".concat(myspace);\n    d3.select(selectMe).attr(\'class\', \'item\');\n    selectMe = "#whitespace".concat(myspace);\n    d3.select(selectMe).remove();\n\n    myspace = spaces.length;\n    callHistory.push({\n        func: "subset",\n        zvars: jQuery.extend(true, [], zparams.zvars),\n        zsubset: jQuery.extend(true, [], zparams.zsubset),\n        zplot: jQuery.extend(true, [], zparams.zplot)\n    });\n\n    // this is to be used to gray out and remove listeners for variables that have been subsetted out of the data\n    function varOut(v) {\n        // if in nodes, remove gray out in left panel\n        // make unclickable in left panel\n        for (var i = 0; i < v.length; i++) {\n            var selectMe = v[i].replace(/\\W/g, "_");\n            byId(selectMe).style.color = hexToRgba(grayColor);\n            selectMe = "p#".concat(selectMe);\n            d3.select(selectMe).on("click", null);\n        }\n    }\n\n    showLog(\'subset\', rCall);\n\n    d3.select("#innercarousel").append(\'div\').attr(\'class\', \'item active\').attr(\'id\', function () {\n        return "m".concat(myspace.toString());\n    }).append(\'svg\').attr(\'id\', \'whitespace\');\n    svg = d3.select("#whitespace");\n\n    d3.json(json.url, function (error, json) {\n        if (error) {\n            return console.warn(error);\n        }\n        var jsondata = getVariableData(json);\n\n        for (var key in jsondata) {\n            var myIndex = findNodeIndex(key);\n\n            allNodes[myIndex].plotx = undefined;\n            allNodes[myIndex].ploty = undefined;\n            allNodes[myIndex].plotvalues = undefined;\n            allNodes[myIndex].plottype = "";\n\n            jQuery.extend(true, allNodes[myIndex], jsondata[key]);\n            allNodes[myIndex].subsetplot = false;\n            allNodes[myIndex].subsetrange = ["", ""];\n            allNodes[myIndex].setxplot = false;\n            allNodes[myIndex].setxvals = ["", ""];\n\n            if (allNodes[myIndex].valid == 0) {\n                grayOuts.push(allNodes[myIndex].name);\n                allNodes[myIndex].grayout = true;\n            }\n        }\n        rePlot();\n        layout(layoutAdd);\n    });\n\n    varOut(grayOuts);\n}\n\n/**\n   removes all the children svgs inside subset and setx divs\n*/\nfunction rePlot() {\n    d3.select(\'#tab2\').selectAll(\'svg\').remove();\n    d3.select(\'#setx\').selectAll(\'svg\').remove();\n    allNodes.forEach(function (n) {\n        return n.setxplot = n.subsetplot = false;\n    });\n}\n\n// acts as if the user clicked in whitespace. useful when restart() is outside of scope\nvar fakeClick = exports.fakeClick = function fakeClick() {\n    var ws = "#whitespace".concat(myspace);\n    // d3 and programmatic events don\'t mesh well, here\'s a SO workaround that looks good but uses jquery...\n    jQuery.fn.d3Click = function () {\n        this.each(function (i, e) {\n            var evt = document.createEvent("MouseEvents");\n            evt.initMouseEvent("mousedown", true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);\n            e.dispatchEvent(evt);\n        });\n    };\n    $(ws).d3Click();\n    d3.select(ws).classed(\'active\', false);\n};\n\n/**\n   EndSession(SessionContext) returns (Response) {}\n*/\nasync function endsession() {\n\n    var table = document.getElementById("results").getElementsByTagName(\'table\')[0];\n    if (typeof table === \'undefined\') {\n        alert("No pipelines exist. Cannot mark problem as complete.");\n        return;\n    }\n\n    var selected = "none";\n\n    //there\'s a cleaner way to do this...\n    for (var i = 1, row; row = table.rows[i]; i++) {\n        //skipping the header\n        if (row.className == \'item-select\') {\n            selected = row.cells[0].innerHTML;\n        }\n    }\n\n    // calling exportpipeline\n    var end = await exportpipeline(selected);\n\n    // makeRequest(D3M_SVC_URL + \'/endsession\', apiSession(zparams.zsessionid));\n    var res = await makeRequest(D3M_SVC_URL + \'/endsession\', apiSession(zparams.zsessionid));\n    var mystatus = res.status.code.toUpperCase();\n    if (mystatus == "OK") {\n        end_ta3_search(true, "Problem marked as complete.");\n    }\n}\n\n/**\n    rpc DeletePipelines(PipelineDeleteRequest) returns (PipelineListResult) {}\n    pipes is an array of pipeline IDs\n*/\nfunction deletepipelines(pipes) {\n    var res = makeRequest(D3M_SVC_URL + \'/DeletePipelines\', { context: apiSession(zparams.zsessionid), deletePipelineIds: pipes });\n    if (!res) {\n        return;\n    }\n}\n\n/**\n    rpc DeletePipelines(PipelineDeleteRequest) returns (PipelineListResult) {}\n    pipes is an array of pipeline IDs\n*/\nfunction cancelpipelines(pipes) {\n    var res = makeRequest(D3M_SVC_URL + \'/CancelPipelines\', { context: apiSession(zparams.zsessionid), cancelPipelineIds: pipes });\n    if (!res) {\n        return;\n    }\n}\n\n/**\n   rpc ListPipelines(PipelineListRequest) returns (PipelineListResult) {}\n   pipes is an array of pipeline IDs\n*/\nfunction listpipelines() {\n    var res = makeRequest(D3M_SVC_URL + \'/listpipelines\', { context: apiSession(zparams.zsessionid) });\n    if (!res) {\n        return;\n    }\n\n    //hardcoded pipes for now\n    var pipes = res.pipelineIds;\n\n    /*\n      pipes.unshift("place");\n      console.log(pipes);\n      d3.select("#results").selectAll("p")\n      .data(pipes)\n      .enter()\n      .append("p")\n      .attr("id", "_pipe_".concat)\n      .text(d => d)\n      .attr(\'class\', \'item-default\')\n      .on("click", function() {\n      if(this.className=="item-select") {\n      return;\n      } else {\n      d3.select("#results").select("p.item-select")\n      .attr(\'class\', \'item-default\');\n      d3.select(this).attr(\'class\',"item-select");\n      }});\n       pipes.shift();\n        d3.select("#setxRight").selectAll("p")\n      .data(pipes)\n      .enter()\n      .append("p")\n      .attr("id", "_setxpipe_".concat)\n      .text(d => d)\n      .attr(\'class\', \'item-default\')\n      .on("click", function() {\n      if(this.className=="item-select") {\n      return;\n      } else {\n      d3.select("#setxRight").select("p.item-select")\n      .attr(\'class\', \'item-default\');\n      d3.select(this).attr(\'class\',"item-select");\n      }});\n    */\n}\n\n/**\n   rpc ExecutePipeline(PipelineExecuteRequest) returns (stream PipelineExecuteResult) {}\n*/\nasync function executepipeline() {\n    var context = apiSession(zparams.zsessionid);\n    var tablerow = byId(\'setxRight\').querySelector(\'tr.item-select\');\n    if (tablerow == null) {\n        alert("Please select a pipeline to execute on.");return;\n    }\n    var pipelineId = tablerow.firstChild.innerText;\n\n    zPop();\n    zparams.callHistory = callHistory;\n\n    var data = [];\n\n    //this will just set zparams.zsetx to the mean, which is default for setx plots\n    //note that if setxplot is modified, it will NOT == "" because zparams.zsetx is modified when the setx plot slider is moved for the first time\n    for (var i = 0; i < zparams.zvars.length; i++) {\n        var mydata = [];\n        mydata[0] = zparams.zvars[i];\n        var mymean = allNodes[findNodeIndex(zparams.zvars[i])].mean;\n        if (zparams.zsetx[i][0] == "") {\n            mydata[1] = mymean;\n        } else if (zparams.zsetx[i][0] != mymean) {\n            mydata[1] = zparams.zsetx[i][0];\n        }\n        if (zparams.zsetx[i][1] == "") {\n            mydata[2] = allNodes[findNodeIndex(zparams.zvars[i])].mean;\n        } else if (zparams.zsetx[i][1] != mymean) {\n            mydata[2] = zparams.zsetx[i][1];\n        }\n        data.push(mydata);\n    }\n\n    var temp = { context: context, pipelineId: pipelineId, data: data };\n    temp = JSON.stringify(temp);\n    console.log(temp);\n    var res = await makeRequest(D3M_SVC_URL + \'/ExecutePipeline\', { context: context, pipelineId: pipelineId, data: data });\n    // I think we want to do this here, but will wait for ISI image to test against\n    // if(res.progressInfo=="COMPLETED") {\n    res && addPredictions(res);\n    // }\n}\n\nfunction addPredictions(res) {\n    function tabulate(data, columns) {\n        var table = d3.select(\'#setxLeftBottomRightBottom\').append(\'table\');\n        var thead = table.append(\'thead\');\n        var tbody = table.append(\'tbody\');\n\n        // append the header row\n        thead.append(\'tr\').selectAll(\'th\').data(columns).enter().append(\'th\').text(function (column) {\n            return column;\n        });\n\n        // create a row for each object in the data\n        var rows = tbody.selectAll(\'tr\').data(data).enter().append(\'tr\');\n\n        // create a cell in each row for each column\n        var cells = rows.selectAll(\'td\').data(function (row) {\n            return columns.map(function (column) {\n                return { column: column, value: row[column] };\n            });\n        }).enter().append(\'td\').text(function (d) {\n            return d.value;\n        }).attr(\'id\', function (d, i) {\n            var rowname = this.parentElement.firstChild.innerText;\n            return rowname + d.column;\n        });\n\n        return table;\n    }\n\n    // this is what ISI should look like, and the test server eventually, so just remove the following line when it\'s up\n    res = res.grpcResp[0];\n\n    console.log(res);\n    var allPreds = res.resultData.data;\n    var predvals = [];\n\n    for (var i = 0; i < allPreds.length; i++) {\n        predvals.push(allPreds[i]["preds"]);\n    }\n\n    var mydata = [];\n    mydata.push({ " ": "Pred 1", "E(Y|X1)": predvals[0], "E(Y|X2)": predvals[1] });\n\n    // render the table(s)\n    tabulate(mydata, [\' \', \'E(Y|X1)\', \'E(Y|X2)\']); // 2 column table\n}\n\n/**\n    call to django to update the problem definition in the problem document\n    rpc SetProblemDoc(SetProblemDocRequest) returns (Response) {}\n*/\nfunction setProblemDefinition(type, updates, lookup) {\n    makeRequest(D3M_SVC_URL + "/SetProblemDoc", { replaceProblemSchemaField: _defineProperty({}, type, lookup[updates[type]][1]), context: apiSession(zparams.zsessionid) });\n}\n\n/**\n   find something centerish to the vertices of a convex hull\n   (specifically, the center of the bounding box)\n*/\nfunction jamescentroid(coord) {\n    var minx = coord[0][0],\n        maxx = coord[0][0],\n        miny = coord[0][1],\n        maxy = coord[0][1];\n    for (var j = 1; j < coord.length; j++) {\n        if (coord[j][0] < minx) minx = coord[j][0];\n        if (coord[j][1] < miny) miny = coord[j][1];\n        if (coord[j][0] > maxx) maxx = coord[j][0];\n        if (coord[j][1] > maxy) maxy = coord[j][1];\n    };\n    return [(minx + maxx) / 2, (miny + maxy) / 2];\n};\n\n/**\n   Define each pebble radius.\n   Presently, most pebbles are scaled to radius set by global RADIUS.\n   Members of groups are scaled down if group gets large.\n*/\nfunction setPebbleRadius(d) {\n    if (d.group1 || d.group2) {\n        // if a member of a group, need to calculate radius size\n        var uppersize = 7;\n        var ng1 = d.group1 ? zparams.zgroup1.length : 1; // size of group1, if a member of group 1\n        var ng2 = d.group2 ? zparams.zgroup2.length : 1; // size of group2, if a member of group 2\n        var maxng = Math.max(ng1, ng2); // size of the largest group variable is member of\n        return maxng > uppersize ? RADIUS * Math.sqrt(uppersize / maxng) : RADIUS; // keep total area of pebbles bounded to pi * RADIUS^2 * uppersize, thus shrinking radius for pebbles in larger groups\n    } else {\n        return RADIUS; // nongroup members get the common global radius\n    }\n};\n\n/**\n   Define each pebble charge.\n*/\nfunction setPebbleCharge(d) {\n    if (d.group1 || d.group2) {\n        if (d.forefront) {\n            // pebbles packed in groups repel others on mouseover\n            return -1000;\n        }\n        var uppersize = 7;\n        var ng1 = d.group1 ? zparams.zgroup1.length : 1; // size of group1, if a member of group 1\n        var ng2 = d.group2 ? zparams.zgroup2.length : 1; // size of group2, if a member of group 2\n        var maxng = Math.max(ng1, ng2); // size of the largest group variable is member of\n        return maxng > uppersize ? -400 * (uppersize / maxng) : -400; // decrease charge as pebbles become smaller, so they can pack together\n    } else {\n        return -800;\n    }\n};\n\n/** needs doc */\nfunction expandrightpanel() {\n    byId(\'rightpanel\').classList.add("expandpanelfull");\n}\n\nfunction btnWidths(btns) {\n    var width = 100 / btns.length + \'%\';\n    var expandwidth = \'35%\';\n    var shrinkwidth = 65 / (btns.length - 1) + \'%\';\n    var lis = byId(\'rightpanel\').querySelectorAll(".accordion li");\n    // hardly ever runs on the page\n    lis.forEach(function (li) {\n        li.style.width = width;\n        li.addEventListener(\'mouseover\', function () {\n            lis.forEach(function (li) {\n                return li.style.width = shrinkwidth;\n            });\n            this.style.width = expandwidth;\n        });\n        li.addEventListener(\'mouseout\', function () {\n            return lis.forEach(function (li) {\n                return li.style.width = width;\n            });\n        });\n    });\n}\n\n/** needs doc */\nfunction toggleRightButtons(set) {\n    if (set == "all") {\n        // first remove noshow class\n        console.log(byId(\'rightpanelbuttons\'));\n\n        var btns = byId(\'rightpanelbuttons\').querySelectorAll(".noshow");\n        console.log(btns);\n        btns.forEach(function (b) {\n            return b.classList.remove("noshow");\n        });\n        console.log(btns);\n\n        console.log(byId(\'btnModels\'));\n        // dropping models for IS_D3M_DOMAIN\n        if (!IS_D3M_DOMAIN) {\n            byId(\'btnModels\').classList.add("noshow"); // JH: doesn\'t appear to exist in D3M mode\n        };\n\n        // if swandive, dropping setx\n        if (swandive) byId(\'btnSetx\').classList.add("noshow");\n\n        // then select all the buttons\n        btns = byId(\'rightpanelbuttons\').querySelectorAll(".btn:not(.noshow)");\n        btnWidths(btns);\n    } else if (set == "models") {\n        byId(\'btnModels\').style.display = \'inline\';\n        byId(\'btnSetx\').style.display = \'inline\';\n        byId(\'btnResults\').style.display = \'inline\';\n        byId(\'btnType\').style.display = \'none\';\n        byId(\'btnSubtype\').style.display = \'none\';\n        byId(\'btnMetrics\').style.display = \'none\';\n        // byId(\'btnOutputs\').style.display = \'none\';\n    }\n}\n\n/** needs doc */\nfunction resultsplotinit(pid) {\n    console.log(pid);\n    pid = allPipelineInfo[pid];\n    var mydv = allPipelineInfo.rookpipe.depvar[0];\n    var dvvalues = allPipelineInfo.rookpipe.dvvalues;\n    // let predfile = pid.pipelineInfo.predictResultData.file_1;\n\n    if (pid.pipelineInfo.predictResultData.success == false) {\n        byId(\'btnSetx\').classList.add("noshow");\n        return;\n    }\n\n    var allPreds = pid.pipelineInfo.predictResultData.data;\n    console.log(Object.keys(allPreds[1]));\n    var predvals = [];\n\n    var mydvI = Object.keys(allPreds[1]).indexOf(mydv);\n    if (mydvI > -1) {\n        for (var i = 0; i < allPreds.length; i++) {\n            predvals.push(allPreds[i][mydv]);\n        }\n    } else if (Object.keys(allPreds[1]).indexOf("preds") > -1) {\n        for (var _i2 = 0; _i2 < allPreds.length; _i2++) {\n            predvals.push(allPreds[_i2]["preds"]);\n        }\n    } else {\n        alert("DV does not match. No Results window.");\n        return;\n    }\n\n    console.log(predvals);\n\n    // only do this for classification tasks\n    if (d3mTaskType[d3mProblemDescription.taskType][1] == "CLASSIFICATION") {\n        genconfdata(dvvalues, predvals);\n    } else {\n        var xdata = "Actual";\n        var ydata = "Predicted";\n        bivariatePlot(dvvalues, predvals, xdata, ydata);\n    }\n\n    // add the list of predictors into setxLeftTopLeft\n    d3.select("#setxLeftTopLeft").selectAll("p").data(allPipelineInfo.rookpipe.predictors).enter().append("p").text(function (d) {\n        return d;\n    }).attr(\'id\', function (d) {\n        return "sx_" + d;\n    }).attr(\'class\', "item-default").on("click", function () {\n        if (this.className == "item-select") {\n            return;\n        } else {\n            d3.select("#setxLeftTopLeft").select("p.item-select").attr(\'class\', \'item-default\');\n            d3.select(this).attr(\'class\', "item-select");\n            singlePlot(this.id.slice(3)); // drops that sx_\n        }\n    });\n}\n\n/** needs doc */\nfunction genconfdata(dvvalues, predvals) {\n\n    function onlyUnique(value, index, self) {\n        return self.indexOf(value) === index;\n    }\n\n    var mycounts = [];\n    var mypairs = [];\n\n    // combine actuals and predicted, and get all unique elements\n    var myuniques = dvvalues.concat(predvals);\n    myuniques = myuniques.filter(onlyUnique);\n\n    // create two arrays: mycounts initialized to 0, mypairs have elements set to all possible pairs of uniques\n    // looked into solutions other than nested fors, but Internet suggest performance is just fine this way\n    for (var i = 0; i < myuniques.length; i++) {\n        var tempcount = [];\n        var temppair = [];\n        for (var j = 0; j < myuniques.length; j++) {\n            mycounts.push(0);\n            mypairs.push(+myuniques[i] + \',\' + myuniques[j]);\n        }\n    }\n\n    // line up actuals and predicted, and increment mycounts at index where mypair has a match for the \'actual,predicted\'\n    for (var _i3 = 0; _i3 < dvvalues.length; _i3++) {\n        var _temppair = +dvvalues[_i3] + \',\' + predvals[_i3];\n        var myindex = mypairs.indexOf(_temppair);\n        mycounts[myindex] += 1;\n    }\n\n    var confdata = [],\n        size = myuniques.length;\n    // another loop... this builds the array of arrays from the flat array mycounts for input to confusionsmatrix function\n    while (mycounts.length > 0) {\n        confdata.push(mycounts.splice(0, size));\n    }confusionmatrix(confdata, myuniques);\n}\n\n/** needs doc */\nfunction confusionmatrix(matrixdata, classes) {\n    d3.select("#setxLeftPlot").html("");\n    d3.select("#setxLeftPlot").select("svg").remove();\n\n    // adapted from this block: https://bl.ocks.org/arpitnarechania/dbf03d8ef7fffa446379d59db6354bac\n    var mainwidth = byId(\'main\').clientWidth;\n    var mainheight = byId(\'main\').clientHeight;\n\n    var condiv = document.createElement(\'div\');\n    condiv.id = "confusioncontainer";\n    condiv.style.display = "inline-block";\n    condiv.style.width = +(mainwidth * .25) + \'px\';\n    condiv.style.marginLeft = \'20px\';\n    condiv.style.height = +(mainheight * .4) + \'px\';\n    condiv.style.float = "left";\n    byId(\'setxLeftPlot\').appendChild(condiv);\n\n    var legdiv = document.createElement(\'div\');\n    legdiv.id = "confusionlegend";\n    legdiv.style.width = +(mainwidth * .07) + \'px\';\n    legdiv.style.marginLeft = \'20px\';\n    legdiv.style.height = +(mainheight * .4) + \'px\';\n    legdiv.style.display = "inline-block";\n    byId(\'setxLeftPlot\').appendChild(legdiv);\n\n    var margin = { top: 20, right: 10, bottom: 0, left: 50 };\n    function Matrix(options) {\n        var width = options.width,\n            height = options.height,\n            data = options.data,\n            container = options.container,\n            labelsData = options.labels,\n            startColor = options.start_color,\n            endColor = options.end_color;\n\n        var widthLegend = options.widthLegend;\n\n        if (!data) {\n            throw new Error(\'Please pass data\');\n        }\n\n        if (!Array.isArray(data) || !data.length || !Array.isArray(data[0])) {\n            throw new Error(\'It should be a 2-D array\');\n        }\n\n        var maxValue = d3.max(data, function (layer) {\n            return d3.max(layer, function (d) {\n                return d;\n            });\n        });\n        var minValue = d3.min(data, function (layer) {\n            return d3.min(layer, function (d) {\n                return d;\n            });\n        });\n\n        var numrows = data.length;\n        var numcols = data[0].length;\n\n        var svg = d3.select(container).append("svg").attr("width", width + margin.left + margin.right).attr("height", height + margin.top + margin.bottom).append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");\n\n        var background = svg.append("rect").style("stroke", "black").style("stroke-width", "2px").attr("width", width).attr("height", height);\n\n        var x = d3.scale.ordinal().domain(d3.range(numcols)).rangeBands([0, width]);\n\n        var y = d3.scale.ordinal().domain(d3.range(numrows)).rangeBands([0, height]);\n\n        var colorMap = d3.scale.linear().domain([minValue, maxValue]).range([startColor, endColor]);\n\n        var row = svg.selectAll(".row").data(data).enter().append("g").attr("class", "row").attr("transform", function (d, i) {\n            return "translate(0," + y(i) + ")";\n        });\n\n        var cell = row.selectAll(".cell").data(function (d) {\n            return d;\n        }).enter().append("g").attr("class", "cell").attr("transform", function (d, i) {\n            return "translate(" + x(i) + ", 0)";\n        });\n\n        cell.append(\'rect\').attr("width", x.rangeBand()).attr("height", y.rangeBand()).style("stroke-width", 0);\n\n        cell.append("text").attr("dy", ".32em").attr("x", x.rangeBand() / 2).attr("y", y.rangeBand() / 2).attr("text-anchor", "middle").style("fill", function (d, i) {\n            return d >= maxValue / 2 ? \'white\' : \'black\';\n        }).text(function (d, i) {\n            return d;\n        });\n\n        row.selectAll(".cell").data(function (d, i) {\n            return data[i];\n        }).style("fill", colorMap);\n\n        // this portion of the code isn\'t as robust to sizing. column labels not rendering in the right place\n        var labels = svg.append(\'g\').attr(\'class\', "labels");\n\n        var columnLabels = labels.selectAll(".column-label").data(labelsData).enter().append("g").attr("class", "column-label").attr("transform", function (d, i) {\n            // let temp = "translate(" + x(i) + "," + (height+20) + ")"; // this in particular looks to be the cause\n            //  console.log(temp);\n            return "translate(" + x(i) + "," + (height + 30) + ")";\n        });\n\n        columnLabels.append("line").style("stroke", "black").style("stroke-width", "1px").attr("x1", x.rangeBand() / 2).attr("x2", x.rangeBand() / 2).attr("y1", 0).attr("y2", 5);\n\n        columnLabels.append("text").attr("x", 30).attr("y", y.rangeBand() / 2).attr("dy", ".22em").attr("text-anchor", "end").attr("transform", "rotate(-60)").text(function (d, i) {\n            return d;\n        });\n\n        var rowLabels = labels.selectAll(".row-label").data(labelsData).enter().append("g").attr("class", "row-label").attr("transform", function (d, i) {\n            return "translate(" + 0 + "," + y(i) + ")";\n        });\n\n        rowLabels.append("line").style("stroke", "black").style("stroke-width", "1px").attr("x1", 0).attr("x2", -5).attr("y1", y.rangeBand() / 2).attr("y2", y.rangeBand() / 2);\n\n        rowLabels.append("text").attr("x", -8).attr("y", y.rangeBand() / 2).attr("dy", ".32em").attr("text-anchor", "end").text(function (d, i) {\n            return d;\n        });\n\n        var key = d3.select("#confusionlegend").append("svg").attr("width", widthLegend).attr("height", height + margin.top + margin.bottom);\n\n        var legend = key.append("defs").append("svg:linearGradient").attr("id", "gradient").attr("x1", "100%").attr("y1", "0%").attr("x2", "100%").attr("y2", "100%").attr("spreadMethod", "pad");\n\n        legend.append("stop").attr("offset", "0%").attr("stop-color", endColor).attr("stop-opacity", 1);\n\n        legend.append("stop").attr("offset", "100%").attr("stop-color", startColor).attr("stop-opacity", 1);\n\n        key.append("rect").attr("width", widthLegend / 2 - 10).attr("height", height).style("fill", "url(#gradient)").attr("transform", "translate(0," + margin.top + ")");\n\n        // this y is for the legend\n        y = d3.scale.linear().range([height, 0]).domain([minValue, maxValue]);\n\n        var yAxis = d3.svg.axis().scale(y).orient("right");\n\n        key.append("g").attr("class", "y axis").attr("transform", "translate(41," + margin.top + ")").call(yAxis);\n    }\n\n    // The table generation function. Used for the table of performance measures, not the confusion matrix\n    function tabulate(data, columns) {\n        var table = d3.select("#setxLeftPlot").append("table").attr("style", "margin-left: " + margin.left + "px"),\n            thead = table.append("thead"),\n            tbody = table.append("tbody");\n\n        // append the header row\n        thead.append("tr").selectAll("th").data(columns).enter().append("th").text(function (column) {\n            return column;\n        });\n\n        // create a row for each object in the data\n        var rows = tbody.selectAll("tr").data(data).enter().append("tr");\n\n        // create a cell in each row for each column\n        var cells = rows.selectAll("td").data(function (row) {\n            return columns.map(function (column) {\n                return { column: column, value: row[column] };\n            });\n        }).enter().append("td").attr("style", "font-family: Courier") // sets the font style\n        .html(function (d) {\n            return d.value;\n        });\n\n        return table;\n    }\n\n    // this code is all for producing a table with performance measures\n    //var confusionMatrix = [[169, 10],[7, 46]];\n    var tp = matrixdata[0][0];\n    var fn = matrixdata[0][1];\n    var fp = matrixdata[1][0];\n    var tn = matrixdata[1][1];\n\n    var p = tp + fn;\n    var n = fp + tn;\n\n    var accuracy = (tp + tn) / (p + n);\n    var f1 = 2 * tp / (2 * tp + fp + fn);\n    var precision = tp / (tp + fp);\n    var recall = tp / (tp + fn);\n\n    accuracy = Math.round(accuracy * 100) / 100;\n    f1 = Math.round(f1 * 100) / 100;\n    precision = Math.round(precision * 100) / 100;\n    recall = Math.round(recall * 100) / 100;\n\n    var computedData = [];\n    computedData.push({ "F1": f1, "PRECISION": precision, "RECALL": recall, "ACCURACY": accuracy });\n\n    Matrix({\n        container: \'#confusioncontainer\',\n        data: matrixdata,\n        labels: classes,\n        start_color: \'#ffffff\',\n        end_color: \'#e67e22\',\n        width: mainwidth * .15,\n        height: mainheight * .25,\n        widthLegend: mainwidth * .05\n    });\n\n    // not rendering this table for right now, left all the code in place though. maybe we use it eventually\n    // var table = tabulate(computedData, ["F1", "PRECISION","RECALL","ACCURACY"]);\n}\n\n/**\n   scatterplot function to go to plots.js to be reused\n*/\nfunction bivariatePlot(x_Axis, y_Axis, x_Axis_name, y_Axis_name) {\n    d3.select("#setxLeftPlot").html("");\n    d3.select("#setxLeftPlot").select("svg").remove();\n\n    x_Axis = x_Axis.map(Number);\n    y_Axis = y_Axis.map(Number);\n\n    console.log(x_Axis);\n    console.log(y_Axis);\n\n    var mainwidth = byId(\'main\').clientWidth;\n    var mainheight = byId(\'main\').clientHeight;\n\n    // scatter plot\n    var data_plot = [];\n    var nanCount = 0;\n    for (var i = 0; i < x_Axis.length; i++) {\n        if (isNaN(x_Axis[i]) || isNaN(y_Axis[i])) {\n            nanCount++;\n        } else {\n            var newNumber1 = x_Axis[i];\n            var newNumber2 = y_Axis[i];\n            data_plot.push({ xaxis: newNumber1, yaxis: newNumber2, score: Math.random() * 100 });\n        }\n    }\n\n    var margin = { top: 35, right: 35, bottom: 35, left: 35 },\n        width = mainwidth * .25 - margin.left - margin.right,\n        height = mainwidth * .25 - margin.top - margin.bottom;\n    var padding = 100;\n\n    var min_x = d3.min(data_plot, function (d, i) {\n        return data_plot[i].xaxis;\n    });\n    var max_x = d3.max(data_plot, function (d, i) {\n        return data_plot[i].xaxis;\n    });\n    var avg_x = (max_x - min_x) / 10;\n    var min_y = d3.min(data_plot, function (d, i) {\n        return data_plot[i].yaxis;\n    });\n    var max_y = d3.max(data_plot, function (d, i) {\n        return data_plot[i].yaxis;\n    });\n    var avg_y = (max_y - min_y) / 10;\n\n    var xScale = d3.scale.linear().domain([min_x - avg_x, max_x + avg_x]).range([0, width]);\n\n    var yScale = d3.scale.linear().domain([min_y - avg_y, max_y + avg_y]).range([height, 0]);\n\n    var xAxis = d3.svg.axis().scale(xScale).orient(\'bottom\').tickSize(-height);\n\n    var yAxis = d3.svg.axis().scale(yScale).orient(\'left\').ticks(5).tickSize(-width);\n\n    var zoom = d3.behavior.zoom().x(xScale).y(yScale).scaleExtent([1, 10]).on("zoom", zoomed);\n\n    var chart_scatter = d3.select(\'#setxLeftPlot\').append(\'svg:svg\').attr(\'width\', width + margin.right + margin.left).attr(\'height\', height + margin.top + margin.bottom);\n    // .call(zoom); dropping this for now, until the line zooms properly\n\n    var main1 = chart_scatter.append(\'g\').attr(\'transform\', \'translate(\' + margin.left + \',\' + margin.top + \')\').attr(\'width\', width + margin.right + margin.left).attr(\'height\', height + margin.top + margin.bottom).attr(\'class\', \'main\');\n\n    var gX = main1.append(\'g\').attr(\'transform\', \'translate(0,\' + height + \')\').attr(\'class\', \'x axis\').call(xAxis);\n\n    var gY = main1.append(\'g\').attr(\'transform\', \'translate(0,0)\').attr(\'class\', \'y axis\').call(yAxis);\n\n    var clip = main1.append("defs").append("svg:clipPath").attr("id", "clip").append("svg:rect").attr("id", "clip-rect").attr("x", "0").attr("y", "0").attr(\'width\', width).attr(\'height\', height);\n\n    main1.append("g").attr("clip-path", "url(#clip)").selectAll("circle").data(data_plot).enter().append("circle").attr("cx", function (d, i) {\n        return xScale(data_plot[i].xaxis);\n    }).attr("cy", function (d, i) {\n        return yScale(data_plot[i].yaxis);\n    }).attr("r", 2).style("fill", "#B71C1C");\n\n    chart_scatter.append("text").attr("text-anchor", "middle") // this makes it easy to centre the text as the transform is applied to the anchor\n    .attr("transform", "translate(" + padding / 5 + "," + height / 2 + ")rotate(-90)") // text is drawn off the screen top left, move down and out and rotate\n    .text(y_Axis_name).style("fill", "#424242").style("text-indent", "20px").style("font-size", "12px").style("font-weight", "bold");\n\n    chart_scatter.append("text").attr("text-anchor", "middle") // this makes it easy to centre the text as the transform is applied to the anchor\n    .attr("transform", "translate(" + width / 2 + "," + (height + padding / 2) + ")") // centre below axis\n    .text(x_Axis_name).style("fill", "#424242").style("text-indent", "20px").style("font-size", "12px").style("font-weight", "bold");\n\n    main1.append("line").attr("x1", xScale(min_x)).attr("y1", yScale(min_x)).attr("x2", xScale(max_x)).attr("y2", yScale(max_x)).attr("stroke-width", 2).attr("stroke", "black");\n\n    function zoomed() {\n        var panX = d3.event.translate[0];\n        var panY = d3.event.translate[1];\n        var scale = d3.event.scale;\n\n        panX = panX > 10 ? 10 : panX;\n        var maxX = -(scale - 1) * width - 10;\n        panX = panX < maxX ? maxX : panX;\n\n        panY = panY > 10 ? 10 : panY;\n        var maxY = -(scale - 1) * height - 10;\n        panY = panY < maxY ? maxY : panY;\n\n        zoom.translate([panX, panY]);\n\n        main1.select(".x.axis").call(xAxis);\n        main1.select(".y.axis").call(yAxis);\n        main1.selectAll("circle").attr("cx", function (d, i) {\n            console.log("circle x ", xScale(5));\n            return xScale(data_plot[i].xaxis);\n        }).attr("cy", function (d, i) {\n            return yScale(data_plot[i].yaxis);\n        }).attr("r", 2.5).style("fill", "#B71C1C");\n\n        // below doesn\'t work, so I\'m just dropping the zoom\n        main1.select("line").attr("x1", function (d, i) {\n            return xScale(min_x);\n        }).attr("y1", function (d, i) {\n            return xScale(min_x);\n        }).attr("x2", function (d, i) {\n            return xScale(max_x);\n        }).attr("y2", function (d, i) {\n            return yScale(max_x);\n        }).attr("stroke-width", 2).attr("stroke", "black");\n    }\n    //  d3.select("#NAcount").text("There are " + nanCount + " number of NA values in the relation.");\n}\n\n/** needs doc */\nfunction setxTable(features) {\n    function tabulate(data, columns) {\n        var table = d3.select(\'#setxLeftBottomLeft\').append(\'table\');\n        var thead = table.append(\'thead\');\n        var tbody = table.append(\'tbody\');\n\n        // append the header row\n        thead.append(\'tr\').selectAll(\'th\').data(columns).enter().append(\'th\').text(function (column) {\n            return column;\n        });\n\n        // create a row for each object in the data\n        var rows = tbody.selectAll(\'tr\').data(data).enter().append(\'tr\');\n\n        // create a cell in each row for each column\n        var cells = rows.selectAll(\'td\').data(function (row) {\n            return columns.map(function (column) {\n                return { column: column, value: row[column] };\n            });\n        }).enter().append(\'td\').text(function (d) {\n            return d.value;\n        }).attr(\'id\', function (d, i) {\n            var rowname = this.parentElement.firstChild.innerText;\n            return rowname + d.column;\n        });\n\n        return table;\n    }\n\n    var mydata = [];\n    for (var i = 0; i < features.length; i++) {\n        var myi = findNodeIndex(features[i]); //i+1;                                // This was set as (i+1), but should be allnodes position, not features position\n\n        if (allNodes[myi].valid == 0) {\n            xval = 0;\n            x1val = 0;\n            mydata.push({ "Variables": features[i], "From": xval, "To": x1val });\n            continue;\n        }\n\n        var mysvg = features[i] + "_setxLeft_" + myi;\n        //console.log(mysvg);\n        var xval = byId(mysvg).querySelector(\'.xval\').innerHTML;\n        var x1val = byId(mysvg).querySelector(\'.x1val\').innerHTML;\n        xval = xval.split("x: ").pop();\n        x1val = x1val.split("x1: ").pop();\n\n        mydata.push({ "Variables": features[i], "From": xval, "To": x1val });\n    }\n\n    // render the table(s)\n    tabulate(mydata, [\'Variables\', \'From\', \'To\']); // 2 column table\n}\n\n/**\n  rpc ExportPipeline(PipelineExportRequest) returns (Response) {}\n*/\n\nasync function exportpipeline(pipelineId) {\n    var temp = { pipelineId: pipelineId, context: apiSession(zparams.zsessionid), pipelineExecUri: \'<<EXECUTABLE_URI>>\' };\n\n    var res = await makeRequest(D3M_SVC_URL + \'/exportpipeline\', { pipelineId: pipelineId, context: apiSession(zparams.zsessionid), pipelineExecUri: \'<<EXECUTABLE_URI>>\' });\n\n    // we need standardized status messages...\n    var mystatus = res.status;\n    if (typeof mystatus !== \'undefined\') {\n        if (mystatus.code == "FAILED_PRECONDITION") {\n            alert("TA2 has not written the executable.");\n        } else {\n            console.log(\'Executable for \' + pipelineId + \' has been written\');\n        }\n    }\n    return res;\n}\n\n/** needs doc */\nfunction deletepipeline() {\n    console.log("DELETE CALLED");\n}\n\n/**\n   D3M API HELPERS\n   because these get built in various places, pulling them out for easy manipulation\n*/\nfunction apiFeature(vars, uri) {\n    var out = [];\n    for (var i = 0; i < vars.length; i++) {\n        out.push({ featureId: vars[i], dataUri: uri });\n    }\n    return out;\n}\n\n/** needs doc */\nfunction apiFeatureShortPath(vars, uri) {\n    var out = [];\n    var shortUri = uri.substring(0, uri.lastIndexOf("/"));\n    for (var i = 0; i < vars.length; i++) {\n        out.push({ featureId: vars[i], dataUri: shortUri });\n    }\n    return out;\n}\n\n/**\n   silly but perhaps useful if in the future SessionContext requires more things (as suggest by core)\n*/\nfunction apiSession(context) {\n    return { session_id: context };\n}\n\n/**\n *  Send a status message to the TA3 console\n */\nfunction ta3_search_message(user_msg) {\n\n    var ta3_search_message = { \'message\': user_msg };\n\n    var end_search_url = \'ta3-search/send-reviewer-message\';\n\n    try {\n        var res = _mithril2.default.request(end_search_url, { method: \'POST\', data: ta3_search_message });\n        console.log(\'ta3_search_message succeeded:\' + res);\n    } catch (err) {\n        console.log(\'ta3_search_message failed: \' + err);\n    }\n}\n\nfunction test_msg_ta3_search() {}\n//end_ta3_search(true, \'it worked!\');\n//end_ta3_search(false, \'it failed!\');\n//ta3_search_message(\'just sending a message!\');\n\n\n/**\n *  End the TA3 search.  This sends a message\n *  to the ta3_search console as well as message\n *  for the console to exit with a:\n *  - return code 0 for success\n *  - return code -1 for failure\n *\n *  > is_success - boolean\n *  > user_msg - string sent to the console\n */\nfunction end_ta3_search(is_success, user_msg) {\n\n    var end_search_msg = { \'is_success\': is_success,\n        \'message\': user_msg };\n\n    var end_search_url = \'ta3-search/end-search\';\n\n    try {\n        var res = _mithril2.default.request(end_search_url, { method: \'POST\', data: end_search_msg });\n        console.log(\'end_ta3_search succeeded:\' + res);\n    } catch (err) {\n        console.log(\'end_ta3_search failed: \' + err);\n    }\n}\n\n/**\n *  record user metadata\n */\nvar recorder_cnt = 0;\nvar save_workspace_url = \'/workspaces/record-user-workspace\';\n\nfunction record_user_metadata() {\n\n    // turning off for now\n    return;\n\n    // (1) Set domain identifier: differs for D3M, Dataverse, etc\n    //\n    var domain_identifier = \'unknown!\';\n    if (IS_D3M_DOMAIN) {\n        // domain specific identifier\n        domain_identifier = domainIdentifier;\n    } /*else if (IS_DATAVERSE_DOMAIN){\n       domain_identifier = \'TODO: DV IDENTIFIER\';\n      }else if (IS_EVENTDATA_DOMAIN){\n       domain_identifier = \'TODO: EVENTDATA IDENTIFIER\';\n      }*/\n\n    if (zparams == null) {\n        console.log(\'No workspace recording. zparams not defined\');\n        return;\n    }\n    if (allNodes == null) {\n        console.log(\'No workspace recording. zparams not defined\');\n        return;\n    }\n\n    // (2) Format workspace data\n    //\n    var workspace_data = { \'app_domain\': APP_DOMAIN,\n        \'domain_identifier\': domain_identifier,\n        \'allnodes\': allNodes,\n        \'zparams\': zparams\n\n        //console.log(\'workspace_data: \' + workspace_data);\n\n        // (3) Save workspace data\n        //\n    };try {\n        var res = _mithril2.default.request(save_workspace_url, { method: \'POST\', data: workspace_data });\n        recorder_cnt++;\n        console.log(\'Session recorded: (cnt: \' + recorder_cnt + \') \' + res);\n    } catch (err) {\n        console.log(\'record_user_metadata failed: \' + err);\n    }\n}\n\nfunction showPredPlot(btn) {\n    if (document.getElementById("setxLeftGen").style.display == "none") return;\n    document.getElementById("setxLeftPlot").style.display = "block";\n    document.getElementById("setxLeftGen").style.display = "none";\n}\n\nfunction showGenPreds(btn) {\n    if (document.getElementById("setxLeftPlot").style.display == "none") return;\n    document.getElementById("setxLeftPlot").style.display = "none";\n    document.getElementById("setxLeftGen").style.display = "block";\n}\n\nfunction singlePlot(pred) {\n    d3.select(\'#setxLeftTopRight\').selectAll(\'svg\').remove();\n    var i = findNodeIndex(pred);\n    var node = allNodes[i];\n    node.setxplot = false;\n    node.subsetplot = false;\n    if (node.plottype === "continuous" & node.setxplot == false) {\n        node.setxplot = true;\n        (0, _plots.density)(node, div = "setxLeftTopRight", priv);\n    } else if (node.plottype === "bar" & node.setxplot == false) {\n        node.setxplot = true;\n        (0, _plots.bars)(node, div = "setxLeftTopRight", priv);\n    }\n}\n\nfunction discovery(preprocess_file) {\n\n    console.log("entering disco");\n    var extract = preprocess_file.dataset.discovery;\n    console.log(extract);\n    var disco = [];\n    var names = [];\n    var vars = Object.keys(preprocess);\n    for (var i = 0; i < extract.length; i++) {\n        names[i] = "Problem" + (i + 1);\n        var current_target = extract[i]["target"];\n        var j = findNodeIndex(current_target);\n        var node = allNodes[j];\n        var current_predictors = extract[i]["predictors"];\n        var current_task = node.plottype === "bar" ? \'classification\' : \'regression\';\n        var current_rating = 3;\n        var current_description = current_target + " is predicted by " + current_predictors.join(" and ");\n        var current_metric = node.plottype === "bar" ? \'f1Macro\' : \'meanSquaredError\';\n        var current_disco = { target: current_target, predictors: current_predictors, task: current_task, rating: current_rating, description: current_description, metric: current_metric };\n        //jQuery.extend(true, current_disco, names);\n        disco[i] = current_disco;\n    };\n    /* Problem Array of the Form:\n        [1: {target:"Home_runs",\n            predictors:["Walks","RBIs"],\n            task:"regression",\n            rating:5,\n            description: "Home_runs is predicted by Walks and RBIs",\n            metric: "meanSquaredError"\n        },2:{...}]\n    */\n    return disco;\n}\n\nfunction probDiscView(btn) {\n    tabLeft(btn);\n    console.log(disco);\n\n    if (btn == \'tab1\') {\n        document.getElementById("leftpanel").classList.remove("expandpanelfull");\n        document.getElementById("btnSelect").style.display = "none";\n        document.getElementById("tab2a").style.display = "none";\n        return;\n    }\n    document.getElementById("leftpanel").classList.toggle("expandpanelfull");\n    if (document.getElementById("btnSelect").style.display == "none") {\n        document.getElementById("btnSelect").style.display = "block";\n    }\n\n    if (document.getElementById("leftpanel").classList.contains("expandpanelfull")) {\n        document.getElementById("tab2a").style.display = "block";\n    }\n\n    if (document.getElementById("tab2").hasChildNodes()) return; // return if this has already been clicked, if childNodes have already been added\n\n    var myprobs = disco; // discovery();  Function requires argument.  Don\'t presently need to call function again.\n    var probtable = [];\n    for (var i = 0; i < myprobs.length; i++) {\n        var mypredictors = myprobs[i].predictors.join();\n        probtable.push({ "Target": myprobs[i].target, "Predictors": mypredictors, "Task": myprobs[i].task, "Metric": myprobs[i].metric });\n    }\n    tabulate(probtable, [\'Target\', \'Predictors\', \'Task\', \'Metric\'], \'#tab2\');\n\n    document.getElementById("tab2input").value = myprobs[0].description;\n}\n\nasync function submitDiscProb(btn) {\n\n    var table = document.getElementById("tab2").getElementsByTagName(\'table\')[0];\n    console.log(table);\n    var checked = [];\n\n    for (var i = 1, row; row = table.rows[i]; i++) {\n        //skipping the header\n        checked.push(row.getElementsByTagName("input")[0].checked); // boolean array\n    }\n\n    for (var _i4 = 0; _i4 < disco.length; _i4++) {\n        if (!checked[_i4]) continue;\n        //createpipeline call\n        console.log(disco);\n        var aux = { "task": d3mTaskType[disco[_i4].task][1], "metrics": d3mMetrics[disco[_i4].metric][1], "description": disco[_i4].description };\n        console.log(aux);\n        // VJD: this is the code to ask TA2 for a single pipeline, to check viability. However, TA2s might not actually handle \'maxpipelines\', making this take a very long time to run. Bypassing this for now\n        //  let res = await makeRequest(D3M_SVC_URL + \'/CreatePipelines\', CreatePipelineData(disco[i].predictors, [disco[i].target], aux)); // creating a single pipeline for a discovered problem, to check viability\n        //  if(res) { // have to check if the response went through ok, this just checks if res exists\n        var res = await makeRequest(D3M_SVC_URL + \'/write-user-problem\', CreatePipelineData(disco[_i4].predictors, [disco[_i4].target], aux));\n        //  }\n    }\n\n    // change status of buttons for estimating problem and marking problem as finished\n    $("#btnSelect").removeClass("btn-success");\n    $("#btnSelect").addClass("btn-default");\n    $("#btnSubset").removeClass("btn-success");\n    $("#btnSubset").addClass("btn-default");\n    exports.task1_finished = task1_finished = true;\n    if (!task2_finished) {\n        $("#btnEstimate").removeClass("btn-default");\n        $("#btnEstimate").addClass("btn-success");\n    };\n}\n\nfunction saveDisc(btn) {\n    var table = document.getElementById("tab2").getElementsByTagName(\'table\')[0];\n    var newtext = document.getElementById("tab2input").value;\n    for (var i = 1, row; row = table.rows[i]; i++) {\n        //skipping the header\n        if (row.className == \'item-select\') {\n            disco[i - 1].description = newtext;\n        }\n    }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvYXBwL2FwcC5qcz9mNTEyIl0sIm5hbWVzIjpbInNldF9leHBsb3JlX21vZGUiLCJzZXRfcmlnaHR0YWIiLCJtYWluIiwiZmluZE5vZGVJbmRleCIsImZpbmROb2RlIiwiY2xpY2tWYXIiLCJnZXRWYXJpYWJsZURhdGEiLCJmb3JjZVN3aXRjaCIsImhlbHBtYXRlcmlhbHMiLCJsb2NrRGVzY3JpcHRpb24iLCJ6UG9wIiwiZG93bmxvYWRJbmNvbXBsZXRlIiwiZXN0aW1hdGUiLCJ0YTJzdHVmZiIsIm1ha2VSZXF1ZXN0IiwibGVnZW5kIiwiZXJhc2UiLCJ0YWJMZWZ0IiwidGFiUmlnaHQiLCJwYW5lbFBsb3RzIiwiYm9yZGVyU3RhdGUiLCJzdWJzZXRTZWxlY3QiLCJlbmRzZXNzaW9uIiwiZGVsZXRlcGlwZWxpbmVzIiwiY2FuY2VscGlwZWxpbmVzIiwibGlzdHBpcGVsaW5lcyIsImV4ZWN1dGVwaXBlbGluZSIsImV4cGFuZHJpZ2h0cGFuZWwiLCJidG5XaWR0aHMiLCJyZXN1bHRzcGxvdGluaXQiLCJnZW5jb25mZGF0YSIsImNvbmZ1c2lvbm1hdHJpeCIsImJpdmFyaWF0ZVBsb3QiLCJzZXR4VGFibGUiLCJleHBvcnRwaXBlbGluZSIsImRlbGV0ZXBpcGVsaW5lIiwidGEzX3NlYXJjaF9tZXNzYWdlIiwidGVzdF9tc2dfdGEzX3NlYXJjaCIsImVuZF90YTNfc2VhcmNoIiwicmVjb3JkX3VzZXJfbWV0YWRhdGEiLCJzaG93UHJlZFBsb3QiLCJzaG93R2VuUHJlZHMiLCJkaXNjb3ZlcnkiLCJwcm9iRGlzY1ZpZXciLCJzdWJtaXREaXNjUHJvYiIsInNhdmVEaXNjIiwiaXNfcmVzdWx0c19tb2RlIiwidGFzazFfZmluaXNoZWQiLCJ0YXNrMl9maW5pc2hlZCIsImlzX2V4cGxvcmVfbW9kZSIsInZhbCIsImNkYiIsIlBST0RVQ1RJT04iLCJsb2ciLCJrIiwidHV0b3JpYWxfbW9kZSIsImZpcnN0X2xvYWQiLCJjb2xvcnMiLCJkMyIsInNjYWxlIiwiY2F0ZWdvcnkyMCIsImNzQ29sb3IiLCJkdkNvbG9yIiwiZ3IxQ29sb3IiLCJncjFPcGFjaXR5IiwiZ3IyQ29sb3IiLCJncjJPcGFjaXR5IiwiZ3JheUNvbG9yIiwibm9tQ29sb3IiLCJ2YXJDb2xvciIsInRhZ2dlZENvbG9yIiwidGltZUNvbG9yIiwibGVmdHRhYiIsInN1YnNldCIsInN1bW1hcnlIb2xkIiwicmlnaHR0YWIiLCJ0IiwidHlwZVRyYW5zZm9ybSIsInRyYW5zZm9ybUxpc3QiLCJzcGxpdCIsInRyYW5zZm9ybVZhciIsInRyYW5zIiwicHJlcHJvY2VzcyIsInNwYWNlcyIsImxheW91dEFkZCIsImxheW91dE1vdmUiLCJSQURJVVMiLCJpbmQxIiwiTWF0aCIsImNvcyIsInNpbiIsImluZDIiLCJteXNwYWNlIiwiZm9yY2V0b2dnbGUiLCJsb2NrdG9nZ2xlIiwicHJpdiIsInN3YW5kaXZlIiwiZmFpbHNldCIsImFsbFBpcGVsaW5lSW5mbyIsImxvZ0FycmF5IiwienBhcmFtcyIsInpkYXRhIiwiemVkZ2VzIiwienRpbWUiLCJ6bm9tIiwiemNyb3NzIiwiem1vZGVsIiwienZhcnMiLCJ6ZHYiLCJ6Z3JvdXAxIiwiemdyb3VwMiIsInpkYXRhdXJsIiwiemQzbWRhdGEiLCJ6ZDNtdGFyZ2V0IiwienN1YnNldCIsInpzZXR4Iiwiem1vZGVsY291bnQiLCJ6cGxvdCIsInpzZXNzaW9uaWQiLCJ6ZGF0YWNpdGUiLCJ6Y3Jvc3N0YWIiLCJ6dXNlcm5hbWUiLCJkaXNjbyIsIm1vZGVsQ291bnQiLCJ2YWx1ZUtleSIsImFsbE5vZGVzIiwiYWxsUmVzdWx0cyIsIm5vZGVzIiwibGlua3MiLCJtb2RzIiwiZXN0aW1hdGVkIiwicmlnaHRDbGlja0xhc3QiLCJzZWxJbnRlcmFjdCIsImNhbGxIaXN0b3J5IiwibXl0YXJnZXQiLCJjb25maWd1cmF0aW9ucyIsImRhdGFkb2N1bWVudCIsImRvbWFpbklkZW50aWZpZXIiLCJkM21UYXNrVHlwZSIsInRhc2tUeXBlVW5kZWZpbmVkIiwiY2xhc3NpZmljYXRpb24iLCJyZWdyZXNzaW9uIiwiY2x1c3RlcmluZyIsImxpbmtQcmVkaWN0aW9uIiwidmVydGV4Tm9taW5hdGlvbiIsImNvbW11bml0eURldGVjdGlvbiIsImdyYXBoQ2x1c3RlcmluZyIsImdyYXBoTWF0Y2hpbmciLCJ0aW1lU2VyaWVzRm9yZWNhc3RpbmciLCJjb2xsYWJvcmF0aXZlRmlsdGVyaW5nIiwiZDNtVGFza1N1YnR5cGUiLCJ0YXNrU3VidHlwZVVuZGVmaW5lZCIsInN1YnR5cGVOb25lIiwiYmluYXJ5IiwibXVsdGlDbGFzcyIsIm11bHRpTGFiZWwiLCJ1bml2YXJpYXRlIiwibXVsdGl2YXJpYXRlIiwib3ZlcmxhcHBpbmciLCJub25PdmVybGFwcGluZyIsImQzbU1ldHJpY3MiLCJtZXRyaWNVbmRlZmluZWQiLCJleGVjdXRpb25UaW1lIiwiYWNjdXJhY3kiLCJmMSIsImYxTWljcm8iLCJmMU1hY3JvIiwicm9jQXVjIiwicm9jQXVjTWljcm8iLCJyb2NBdWNNYWNybyIsIm1lYW5TcXVhcmVkRXJyb3IiLCJyb290TWVhblNxdWFyZWRFcnJvciIsInJvb3RNZWFuU3F1YXJlZEVycm9yQXZnIiwibWVhbkFic29sdXRlRXJyb3IiLCJyU3F1YXJlZCIsIm5vcm1hbGl6ZWRNdXR1YWxJbmZvcm1hdGlvbiIsImphY2NhcmRTaW1pbGFyaXR5U2NvcmUiLCJkM21Qcm9ibGVtRGVzY3JpcHRpb24iLCJ0YXNrVHlwZSIsInRhc2tTdWJ0eXBlIiwibWV0cmljIiwidGFza0Rlc2NyaXB0aW9uIiwic3ZnIiwid2lkdGgiLCJoZWlnaHQiLCJkaXYiLCJzZWxlY3RMYWRkYSIsImVzdGltYXRlTGFkZGEiLCJhcmMiLCJzdGFydCIsImVuZCIsImlubmVyUmFkaXVzIiwib3V0ZXJSYWRpdXMiLCJzdGFydEFuZ2xlIiwiZW5kQW5nbGUiLCJhcmMwIiwiYXJjMSIsImFyYzIiLCJhcmMzIiwiYXJjNCIsImFyY0luZCIsImFyY2xpbWl0cyIsImFyY0luZDFMaW1pdHMiLCJhcmNJbmQyTGltaXRzIiwiYXJjSW5kMSIsImFyY0luZDIiLCJieUlkIiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsImlkIiwicmVzZXQiLCJyZWxvYWRQYWdlIiwibG9jYXRpb24iLCJyZWxvYWQiLCJyZXN0YXJ0IiwiZGF0YXVybCIsInN0ZXAiLCJ0YXJnZXQiLCJwbGFjZW1lbnQiLCJ0aXRsZSIsImNvbnRlbnQiLCJzaG93Q1RBQnV0dG9uIiwiY3RhTGFiZWwiLCJvbkNUQSIsImVuZFRvdXIiLCJteXRvdXIiLCJpMThuIiwiZG9uZUJ0biIsInNob3dDbG9zZUJ1dHRvbiIsInNjcm9sbER1cmF0aW9uIiwib25FbmQiLCJzdGVwcyIsIm15dG91cjMiLCJsb2FkIiwiaG9sZCIsImxhYmxBcnJheSIsImQzbVJvb3RQYXRoIiwiZDNtRGF0YU5hbWUiLCJkM21QcmVwcm9jZXNzIiwiZDNtRGF0YSIsImQzbVBTIiwiZDNtRFMiLCJwVVJMIiwiSVNfRDNNX0RPTUFJTiIsInJlcyIsInJlcXVlc3QiLCJtZXRob2QiLCJ1cmwiLCJjb25zb2xlIiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5IiwidHJhaW5pbmdfZGF0YV9yb290IiwicmVwbGFjZSIsIm5hbWUiLCJzb3VyY2VfdXJsIiwiY29uZmlnX3VybCIsImRlc2NyaXB0aW9uIiwic2V0X2QzbV9kYXRhX3BhdGgiLCJmaWVsZCIsImRhdGEiLCJleGlzdHMiLCJwYXRoIiwiZDNtX3BhdGhfZXJyIiwiYWxlcnQiLCJpbnB1dHMiLCJ0YXJnZXRzIiwiY29sTmFtZSIsImFib3V0IiwidGFza1N1YlR5cGUiLCJwZXJmb3JtYW5jZU1ldHJpY3MiLCJkZXNjcmlwdGlvbkZpbGUiLCJjbGljayIsImluY2x1ZGVzIiwidG9VcHBlckNhc2UiLCJkYXRhUmVzb3VyY2VzIiwiY29sdW1ucyIsImRhdGFzZXROYW1lIiwiY2hhckF0Iiwic2xpY2UiLCJjaXRlIiwiY2l0YXRpb24iLCJ0ZW1wIiwieG1sIiwiZG9jdW1lbnRFbGVtZW50IiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJjaGlsZE5vZGVzIiwibm9kZVZhbHVlIiwiJCIsInRleHQiLCJkYXRhbmFtZSIsInNlbGVjdCIsImh0bWwiLCJjbGFzc0xpc3QiLCJhZGQiLCJzdHlsZSIsImJhY2tncm91bmRDb2xvciIsImZpbHRlciIsImhhc093blByb3BlcnR5Iiwia2V5IiwiZm9yRWFjaCIsIl8iLCJEM01fU1ZDX1VSTCIsInVzZXJfYWdlbnQiLCJ2ZXJzaW9uIiwicmVzcG9uc2VJbmZvIiwic3RhdHVzIiwiY29kZSIsInVzZXJfZXJyX21zZyIsImNvbnRleHQiLCJzZXNzaW9uSWQiLCJzdGFydFRvdXIiLCJyZWFkIiwiZGF0YXNldCIsInByaXZhdGUiLCJPYmplY3QiLCJrZXlzIiwidmFyaWFibGVzIiwiUk9PS19TVkNfVVJMIiwianNvbl9pbnB1dCIsImRhdGFzdHViIiwiZGF0YWxvYyIsInRhcmdldGxvYyIsIkZvcm1EYXRhIiwidmFycyIsImkiLCJsZW5ndGgiLCJvYmoiLCJyZWZsZXhpdmUiLCJsYWJsIiwiY291bnQiLCJub2RlQ29sIiwiYmFzZUNvbCIsInN0cm9rZUNvbG9yIiwic3Ryb2tlV2lkdGgiLCJzdWJzZXRwbG90Iiwic3Vic2V0cmFuZ2UiLCJzZXR4cGxvdCIsInNldHh2YWxzIiwiZ3JheW91dCIsImdyb3VwMSIsImdyb3VwMiIsImZvcmVmcm9udCIsImpRdWVyeSIsImV4dGVuZCIsInB1c2giLCJkYXRhdmFycyIsInYiLCJteWkiLCJhc3NpZ24iLCJkM21EZXNjcmlwdGlvbiIsImxheW91dCIsImRhdGFEb3dubG9hZCIsImZpbGVpZCIsImhvc3RuYW1lIiwiZGRpdXJsIiwiYXBpa2V5IiwibXNnIiwiRXJyb3IiLCJkYXRhdmVyc2V1cmwiLCJEQVRBVkVSU0VfVVJMIiwidGVtcFdpZHRoIiwic3Vic3RyaW5nIiwid2luZG93IiwiTGFkZGEiLCJjcmVhdGUiLCJtZXRhZGF0YXVybCIsIiRmaWxsIiwib3AiLCJkMSIsImQyIiwidHJhbnNpdGlvbiIsImF0dHIiLCJkZWxheSIsImR1cmF0aW9uIiwiZmlsbCIsImQiLCJmaWxsVGhpcyIsInNlbGYiLCJkZWwiLCJhcnIiLCJpZHgiLCJpbmRleE9mIiwic3BsaWNlIiwienBhcmFtc1Jlc2V0IiwieCIsInYyIiwibXlWYWx1ZXMiLCJhcHBlbmQiLCJjbGFzc2VkIiwibGluZSIsImxpbmUyIiwidmlzYmFja2dyb3VuZCIsInZpczJiYWNrZ3JvdW5kIiwidmlzIiwidmlzMiIsImoiLCJpaSIsInNlbGVjdE1lIiwiY29uY2F0IiwiaGV4VG9SZ2JhIiwibXlzcmMiLCJub2RlSW5kZXgiLCJteXRndCIsInNvdXJjZSIsImxlZnQiLCJyaWdodCIsImZvcmNlIiwic2l6ZSIsImxpbmtEaXN0YW5jZSIsImNoYXJnZSIsIm9uIiwidGljayIsImRyYWdfbGluZSIsInNlbGVjdEFsbCIsImNpcmNsZSIsInNlbGVjdGVkX25vZGUiLCJzZWxlY3RlZF9saW5rIiwibW91c2Vkb3duX2xpbmsiLCJtb3VzZWRvd25fbm9kZSIsIm1vdXNldXBfbm9kZSIsInJlc2V0TW91c2VWYXJzIiwiZmluZGNvb3JkcyIsImZpbmRuYW1lcyIsImFsbG5hbWVzIiwiY29vcmRzIiwibGVuZ3RoZW4iLCJmY29vcmRzIiwiQXJyYXkiLCJhZGRsb2NhdGlvbiIsImRlbHRheCIsImRlbHRheSIsImRlbHRhIiwibGVuZ3RoZW5jb29yZHMiLCJtYXAiLCJ5IiwiZ3IxY29vcmRzIiwiZ3IyY29vcmRzIiwiZGVwY29vcmRzIiwibXlodWxsIiwiZ2VvbSIsImh1bGwiLCJqb2luIiwicCIsImphbWVzY2VudHJvaWQiLCJxIiwibGRlbHRhWCIsImxkZWx0YVkiLCJsZGlzdCIsInNxcnQiLCJsbm9ybVgiLCJsbm9ybVkiLCJsc291cmNlUGFkZGluZyIsImx0YXJnZXRQYWRkaW5nIiwic2lnbiIsIm4iLCJtaW4iLCJhbHBoYSIsImRlbHRhWCIsImRlbHRhWSIsImRpc3QiLCJub3JtWCIsIm5vcm1ZIiwic291cmNlUGFkZGluZyIsInRhcmdldFBhZGRpbmciLCJzb3VyY2VYIiwic291cmNlWSIsInRhcmdldFgiLCJ0YXJnZXRZIiwic2V0UGViYmxlUmFkaXVzIiwibXlDb2xvciIsInJnYiIsInRvU3RyaW5nIiwiY2xhc3NOYW1lIiwiaW5uZXJIVE1MIiwic2V0UHJvYmxlbURlZmluaXRpb24iLCIkbGlua3MiLCJjYWxsIiwiZHJhZyIsImdyYXZpdHkiLCJzZXRQZWJibGVDaGFyZ2UiLCJsaW5rU3RyZW5ndGgiLCJyZXN1bWUiLCJtYXJrZXIiLCJraW5kIiwic2lkZSIsImVudGVyIiwiZXhpdCIsInJlbW92ZSIsImciLCJlYWNoIiwicGxvdHR5cGUiLCJzdHIiLCJzZXRDb2xvcnMiLCJkZWZhdWx0TnVtY2hhciIsImV2ZW50Iiwic3RvcFByb3BhZ2F0aW9uIiwicHJldmVudERlZmF1bHQiLCJtb3VzZW1vdmUiLCJkaXJlY3Rpb24iLCJsaW5rIiwidmFyU3VtbWFyeSIsInNldEF0dHJpYnV0ZSIsInNlbGVjdGVkSW5kZXgiLCJyZWRyYXciLCJldnQiLCJ0cmFuc1BhcnNlIiwicGFyZW50IiwiZmFkZU91dCIsInRyYW5zZm9ybSIsImZhZGVJbiIsIm1vdXNlZG93biIsImN0cmxLZXkiLCJtb3VzZSIsIm1vdXNldXAiLCJmYWtlQ2xpY2siLCJjbGlja19ldiIsImNyZWF0ZUV2ZW50IiwiaW5pdEV2ZW50IiwiY2xpY2tJRCIsImRpc3BhdGNoRXZlbnQiLCJmaW5kIiwiJG5vZGVzIiwid2hvbGUiLCJub2RlIiwibm9kZU5hbWUiLCJ1cGRhdGVOb2RlIiwibmFtZXMiLCJpbmRleCIsImwiLCJlbGVtIiwianNvbiIsInR5cGUiLCJ3aW4iLCJvcGVuIiwiZm9jdXMiLCJxdWVyeVNlbGVjdG9yQWxsIiwiem5hdHVyZSIsIm5hdHVyZSIsInNyY3RndCIsInRhYnVsYXRlIiwiZGl2aWQiLCJ0YWJsZSIsInRoZWFkIiwidGJvZHkiLCJjb2x1bW4iLCJyb3dzIiwiY2VsbHMiLCJyb3ciLCJ2YWx1ZSIsIm15cm93IiwicGFyZW50RWxlbWVudCIsInJvd0luZGV4IiwiZmlyc3RDaGlsZCIsImlubmVyVGV4dCIsIm9uUGlwZWxpbmVDcmVhdGUiLCJQaXBlbGluZUNyZWF0ZVJlc3VsdCIsInJvb2twaXBlIiwic3RvcCIsInJlbW92ZUNsYXNzIiwiYWRkQ2xhc3MiLCJhcGlTZXNzaW9uIiwicGlwZWxpbmVJZCIsInJlc3VsdHN0YWJsZSIsImRldGFpbHMiLCJwcm9ncmVzc0luZm8iLCJteWlkIiwibXltZXRyaWMiLCJteXZhbCIsIm15c2NvcmVzIiwicGlwZWxpbmVJbmZvIiwic2NvcmVzIiwidG9GaXhlZCIsInRvZ2dsZVJpZ2h0QnV0dG9ucyIsIlBpcGVsaW5lSUQiLCJDcmVhdGVQaXBlbGluZURhdGEiLCJwcmVkaWN0b3JzIiwiZGVwdmFyIiwiYXV4IiwidXJpQ3N2IiwidXJpSnNvbiIsImxhc3RJbmRleE9mIiwidGFyZ2V0RmVhdHVyZXMiLCJwcmVkaWN0RmVhdHVyZXMiLCJkYXRhc2V0X3VyaSIsInRhc2siLCJvdXRwdXQiLCJtZXRyaWNzIiwibWF4UGlwZWxpbmVzIiwiYnRuIiwiYWxsVmFycyIsIm1vZENvbCIsInJlbW92ZUNoaWxkIiwidHJpZ2dlciIsIm1vZGVsIiwiaW5zZXJ0IiwiYSIsImIiLCJzdWJzdHIiLCJ2aXoiLCJyQ2FsbCIsInNob3dMb2ciLCJteXZraSIsInNlc3Npb25pZCIsImhyZWYiLCJteW0iLCJyZW1vdmVLaWRzIiwiZmlsZWxpc3QiLCJpbWFnZXMiLCJ6ZmlnIiwiY3JlYXRlRWxlbWVudCIsImFwcGVuZENoaWxkIiwicmVzdWx0c0FycmF5Iiwic3VtSW5mbyIsImNvbG5hbWVzIiwibXlOdW0iLCJOdW1iZXIiLCJpc05hTiIsInRvUHJlY2lzaW9uIiwib3V0MiIsInQyIiwiazIiLCJzdWJNZTIiLCJpbmRleGVkIiwibTIiLCJtYXRjaCIsInJlIiwiUmVnRXhwIiwicyIsInNlYXJjaCIsImZyb20iLCJ0byIsIm15biIsIm91dHR5cGVzIiwidmFybmFtZXNUeXBlcyIsImludGVydmFsIiwibnVtY2hhciIsInBsb3R2YWx1ZXMiLCJwbG90eCIsInR5cGVTdHVmZiIsImVyciIsIndhcm4iLCJmdW5jIiwic3Vic2V0ZWQiLCJuZXdWYXIiLCJlcnJvciIsImpzb25kYXRhIiwibXlJbmRleCIsIm9iajEiLCJkZWZhdWx0SW50ZXJ2YWwiLCJkZWZhdWx0TmF0dXJlIiwiZGVmYXVsdEJpbmFyeSIsIndhcm5pbmciLCJjaGlsZHJlbiIsInRhYiIsImRpc3BsYXkiLCJwYW5lbCIsImNscyIsInRvZ2dsZVIiLCJnZXRBdHRyaWJ1dGUiLCJmdWxsIiwic3VtbWFyeSIsInQxIiwicmludCIsImZvcm1hdCIsIm1lYW5DSSIsIm1lYW4iLCJsb3dlckJvdW5kIiwidXBwZXJCb3VuZCIsIm1lZGlhbiIsIm1vZGUiLCJmcmVxbW9kZSIsIm1pZCIsImZyZXFtaWQiLCJmZXdlc3QiLCJmcmVxZmV3ZXN0Iiwic2QiLCJtYXgiLCJpbnZhbGlkIiwidmFsaWQiLCJ1bmlxdWVzIiwiaGVyZmluZGFobCIsImUiLCJwb3BvdmVyQ29udGVudCIsImludCIsInByZWMiLCJpZHMiLCJyZWdzdHIiLCJteW5hbWUiLCJleGVjIiwibm9kZWlkIiwicGFyc2VJbnQiLCJoZXgiLCJjIiwidGVtcGluZGV4IiwiY29sb3IiLCJpc0FycmF5IiwiZHZuYW1lIiwibmdyb3VwMSIsIm5ncm91cDIiLCJjc3MiLCJzdWJzZXRFbXB0eSIsImdyYXlPdXRzIiwibXlOb2RlcyIsIm15UGFyYW1zIiwibXlUcmFucyIsIm15Rm9yY2UiLCJteVByZXByb2Nlc3MiLCJteUxvZyIsIm15SGlzdG9yeSIsInZhck91dCIsInVuZGVmaW5lZCIsInBsb3R5IiwicmVQbG90Iiwid3MiLCJmbiIsImQzQ2xpY2siLCJpbml0TW91c2VFdmVudCIsInNlbGVjdGVkIiwibXlzdGF0dXMiLCJwaXBlcyIsImRlbGV0ZVBpcGVsaW5lSWRzIiwiY2FuY2VsUGlwZWxpbmVJZHMiLCJwaXBlbGluZUlkcyIsInRhYmxlcm93IiwicXVlcnlTZWxlY3RvciIsIm15ZGF0YSIsIm15bWVhbiIsImFkZFByZWRpY3Rpb25zIiwicm93bmFtZSIsImdycGNSZXNwIiwiYWxsUHJlZHMiLCJyZXN1bHREYXRhIiwicHJlZHZhbHMiLCJ1cGRhdGVzIiwibG9va3VwIiwicmVwbGFjZVByb2JsZW1TY2hlbWFGaWVsZCIsImNvb3JkIiwibWlueCIsIm1heHgiLCJtaW55IiwibWF4eSIsInVwcGVyc2l6ZSIsIm5nMSIsIm5nMiIsIm1heG5nIiwiYnRucyIsImV4cGFuZHdpZHRoIiwic2hyaW5rd2lkdGgiLCJsaXMiLCJsaSIsImFkZEV2ZW50TGlzdGVuZXIiLCJzZXQiLCJwaWQiLCJteWR2IiwiZHZ2YWx1ZXMiLCJwcmVkaWN0UmVzdWx0RGF0YSIsInN1Y2Nlc3MiLCJteWR2SSIsInhkYXRhIiwieWRhdGEiLCJzaW5nbGVQbG90Iiwib25seVVuaXF1ZSIsIm15Y291bnRzIiwibXlwYWlycyIsIm15dW5pcXVlcyIsInRlbXBjb3VudCIsInRlbXBwYWlyIiwibXlpbmRleCIsImNvbmZkYXRhIiwibWF0cml4ZGF0YSIsImNsYXNzZXMiLCJtYWlud2lkdGgiLCJjbGllbnRXaWR0aCIsIm1haW5oZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJjb25kaXYiLCJtYXJnaW5MZWZ0IiwiZmxvYXQiLCJsZWdkaXYiLCJtYXJnaW4iLCJ0b3AiLCJib3R0b20iLCJNYXRyaXgiLCJvcHRpb25zIiwiY29udGFpbmVyIiwibGFiZWxzRGF0YSIsImxhYmVscyIsInN0YXJ0Q29sb3IiLCJzdGFydF9jb2xvciIsImVuZENvbG9yIiwiZW5kX2NvbG9yIiwid2lkdGhMZWdlbmQiLCJtYXhWYWx1ZSIsImxheWVyIiwibWluVmFsdWUiLCJudW1yb3dzIiwibnVtY29scyIsImJhY2tncm91bmQiLCJvcmRpbmFsIiwiZG9tYWluIiwicmFuZ2UiLCJyYW5nZUJhbmRzIiwiY29sb3JNYXAiLCJsaW5lYXIiLCJjZWxsIiwicmFuZ2VCYW5kIiwiY29sdW1uTGFiZWxzIiwicm93TGFiZWxzIiwieUF4aXMiLCJheGlzIiwib3JpZW50IiwidHAiLCJmcCIsInRuIiwicHJlY2lzaW9uIiwicmVjYWxsIiwicm91bmQiLCJjb21wdXRlZERhdGEiLCJ4X0F4aXMiLCJ5X0F4aXMiLCJ4X0F4aXNfbmFtZSIsInlfQXhpc19uYW1lIiwiZGF0YV9wbG90IiwibmFuQ291bnQiLCJuZXdOdW1iZXIxIiwibmV3TnVtYmVyMiIsInhheGlzIiwieWF4aXMiLCJzY29yZSIsInJhbmRvbSIsInBhZGRpbmciLCJtaW5feCIsIm1heF94IiwiYXZnX3giLCJtaW5feSIsIm1heF95IiwiYXZnX3kiLCJ4U2NhbGUiLCJ5U2NhbGUiLCJ4QXhpcyIsInRpY2tTaXplIiwidGlja3MiLCJ6b29tIiwiYmVoYXZpb3IiLCJzY2FsZUV4dGVudCIsInpvb21lZCIsImNoYXJ0X3NjYXR0ZXIiLCJtYWluMSIsImdYIiwiZ1kiLCJjbGlwIiwicGFuWCIsInRyYW5zbGF0ZSIsInBhblkiLCJtYXhYIiwibWF4WSIsImZlYXR1cmVzIiwieHZhbCIsIngxdmFsIiwibXlzdmciLCJwb3AiLCJwaXBlbGluZUV4ZWNVcmkiLCJhcGlGZWF0dXJlIiwidXJpIiwib3V0IiwiZmVhdHVyZUlkIiwiZGF0YVVyaSIsImFwaUZlYXR1cmVTaG9ydFBhdGgiLCJzaG9ydFVyaSIsInNlc3Npb25faWQiLCJ1c2VyX21zZyIsImVuZF9zZWFyY2hfdXJsIiwiaXNfc3VjY2VzcyIsImVuZF9zZWFyY2hfbXNnIiwicmVjb3JkZXJfY250Iiwic2F2ZV93b3Jrc3BhY2VfdXJsIiwiZG9tYWluX2lkZW50aWZpZXIiLCJ3b3Jrc3BhY2VfZGF0YSIsIkFQUF9ET01BSU4iLCJwcmVkIiwicHJlcHJvY2Vzc19maWxlIiwiZXh0cmFjdCIsImN1cnJlbnRfdGFyZ2V0IiwiY3VycmVudF9wcmVkaWN0b3JzIiwiY3VycmVudF90YXNrIiwiY3VycmVudF9yYXRpbmciLCJjdXJyZW50X2Rlc2NyaXB0aW9uIiwiY3VycmVudF9tZXRyaWMiLCJjdXJyZW50X2Rpc2NvIiwicmF0aW5nIiwidG9nZ2xlIiwiY29udGFpbnMiLCJoYXNDaGlsZE5vZGVzIiwibXlwcm9icyIsInByb2J0YWJsZSIsIm15cHJlZGljdG9ycyIsImNoZWNrZWQiLCJuZXd0ZXh0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7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LENBQTlELENBQVo7QUFDQSxRQUFJcW1CLFVBQVVuckIsU0FBU0MsY0FBVCxDQUF3QixXQUF4QixFQUFxQ3FWLEtBQW5EO0FBQ0EsU0FBSyxJQUFJaE8sSUFBSSxDQUFSLEVBQVcrTixHQUFoQixFQUFxQkEsTUFBTU4sTUFBTUksSUFBTixDQUFXN04sQ0FBWCxDQUEzQixFQUEwQ0EsR0FBMUMsRUFBK0M7QUFBRTtBQUM3QyxZQUFHK04sSUFBSTNFLFNBQUosSUFBZSxhQUFsQixFQUFnQztBQUM1Qi9WLGtCQUFNMk0sSUFBRSxDQUFSLEVBQVdwRSxXQUFYLEdBQXVCaW9CLE9BQXZCO0FBQ0g7QUFDSjtBQUVKIiwiZmlsZSI6IjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgaG9wc2NvdGNoIGZyb20gJ2hvcHNjb3RjaCc7XG5pbXBvcnQgbSBmcm9tICdtaXRocmlsJztcbmltcG9ydCB7YmFycywgYmFyc05vZGUsIGJhcnNTdWJzZXQsIGRlbnNpdHksIGRlbnNpdHlOb2RlLCBzZWxWYXJDb2xvcn0gZnJvbSAnLi9wbG90cy5qcyc7XG5cbi8vIGhvc3RuYW1lIGRlZmF1bHQgLSB0aGUgYXBwIHdpbGwgdXNlIGl0IHRvIG9idGFpbiB0aGUgdmFyaWFibGUgbWV0YWRhdGFcbi8vIChkZGkpIGFuZCBwcmUtcHJvY2Vzc2VkIGRhdGEgaW5mbyBpZiB0aGUgZmlsZSBpZCBpcyBzdXBwbGllZCBhcyBhblxuLy8gYXJndW1lbnQgKGZvciBleC4sIGd1aS5odG1sP2RmSWQ9MTcpLCBidXQgaG9zdG5hbWUgaXNuJ3QuXG4vLyBFZGl0IGl0IHRvIHN1aXQgeW91ciBpbnN0YWxsYXRpb24uXG4vLyAoTk9URSB0aGF0IGlmIHRoZSBmaWxlIGlkIGlzbid0IHN1cHBsaWVkLCB0aGUgYXBwIHdpbGwgZGVmYXVsdCB0byB0aGVcbi8vIGxvY2FsIGZpbGVzIHNwZWNpZmllZCBiZWxvdyEpXG4vLyBORVc6IGl0IGlzIGFsc28gcG9zc2libGUgbm93IHRvIHN1cHBseSBjb21wbGV0ZSB1cmxzIGZvciB0aGUgZGRpIGFuZFxuLy8gdGhlIHRhYi1kZWxpbWl0ZWQgZGF0YSBmaWxlOyB0aGUgcGFyYW1ldGVycyBhcmUgZGRpdXJsIGFuZCBkYXRhdXJsLlxuLy8gVGhlc2UgbmV3IHBhcmFtZXRlcnMgYXJlIG9wdGlvbmFsLiBJZiB0aGV5IGFyZSBub3Qgc3VwcGxpZWQsIHRoZSBhcHBcbi8vIHdpbGwgZ28gdGhlIG9sZCByb3V0ZSAtIHdpbGwgdHJ5IHRvIGNvb2sgc3RhbmRhcmQgZGF0YXZlcnNlIHVybHNcbi8vIGZvciBib3RoIHRoZSBkYXRhIGFuZCBtZXRhZGF0YSwgaWYgdGhlIGZpbGUgaWQgaXMgc3VwcGxpZWQ7IG9yIHRoZVxuLy8gbG9jYWwgZmlsZXMgaWYgbm90aGluZyBpcyBzdXBwbGllZC5cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBOT1RFOiBnbG9iYWwgdmFyaWFibGVzIGFyZSBub3cgc2V0IGluIHRoZSBpbmRleC5odG1sIGZpbGUuXG4vLyAgICBEZXZlbG9wZXJzLCBzZWUgL3RlbXBsYXRlL2luZGV4Lmh0bWxcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgbGV0IGlzX3Jlc3VsdHNfbW9kZSA9IGZhbHNlO1xuZXhwb3J0IGxldCB0YXNrMV9maW5pc2hlZCA9IGZhbHNlO1xuZXhwb3J0IGxldCB0YXNrMl9maW5pc2hlZCA9IGZhbHNlO1xuXG5sZXQgaXNfZXhwbG9yZV9tb2RlID0gZmFsc2U7XG5leHBvcnQgZnVuY3Rpb24gc2V0X2V4cGxvcmVfbW9kZSh2YWwpIHtcbiAgICBpc19leHBsb3JlX21vZGUgPSB2YWw7XG59XG5cbi8vIGZvciBkZWJ1Z2dpbmcgLSBpZiBub3QgaW4gUFJPRFVDVElPTiwgcHJpbnRzIGFyZ3NcbmV4cG9ydCBsZXQgY2RiID0gXyA9PiBQUk9EVUNUSU9OIHx8IGNvbnNvbGUubG9nKC4uLmFyZ3VtZW50cyk7XG5cbmxldCBrID0gNDsgLy8gc3RyZW5ndGggcGFyYW1ldGVyIGZvciBncm91cCBhdHRyYWN0aW9uL3JlcHVsc2lvblxubGV0IHR1dG9yaWFsX21vZGUgPSB0cnVlO1xubGV0IGZpcnN0X2xvYWQgPSB0cnVlO1xuXG4vLyBpbml0aWFsIGNvbG9yIHNjYWxlIHVzZWQgdG8gZXN0YWJsaXNoIHRoZSBpbml0aWFsIGNvbG9ycyBvZiBub2Rlc1xuLy8gYWxsTm9kZXMucHVzaCgpIGJlbG93IGVzdGFibGlzaGVzIGEgZmllbGQgZm9yIHRoZSBtYXN0ZXIgbm9kZSBhcnJheSBhbGxOb2RlcyBjYWxsZWQgXCJub2RlQ29sXCIgYW5kIGFzc2lnbnMgYSBjb2xvciBmcm9tIHRoaXMgc2NhbGUgdG8gdGhhdCBmaWVsZFxuLy8gZXZlcnl0aGluZyB0aGVyZSBhZnRlciBzaG91bGQgcmVmZXIgdG8gdGhlIG5vZGVDb2wgYW5kIG5vdCB0aGUgY29sb3Igc2NhbGUsIHRoaXMgZW5hYmxlcyB1cyB0byB1cGRhdGUgY29sb3JzIGFuZCBwYXNzIHRoZSB2YXJpYWJsZSB0eXBlIHRvIFIgYmFzZWQgb24gaXRzIGNvbG9yaW5nXG5sZXQgY29sb3JzID0gZDMuc2NhbGUuY2F0ZWdvcnkyMCgpO1xuZXhwb3J0IGxldCBjc0NvbG9yID0gJyM0MTk2NDEnO1xuZXhwb3J0IGxldCBkdkNvbG9yID0gJyMyOGE0YzknO1xuZXhwb3J0IGxldCBncjFDb2xvciA9ICcjMTRiZGNjJzsgIC8vIGluaXRpYWxseSB3YXMgIzI0YTRjOScsIGJ1dCB0aGF0IGlzIGR2Q29sb3IsIGFuZCB3ZSB0cmFjayBzb21lIHByb3BlcnRpZXMgYnkgY29sb3IgYXNzdW1pbmcgdGhlbSB1bmlxdWVcbmxldCBncjFPcGFjaXR5ID0gWzAsMV07XG5leHBvcnQgbGV0IGdyMkNvbG9yID0gJyNmZmNjY2MnO1xubGV0IGdyMk9wYWNpdHkgPSBbMCwxXTtcblxubGV0IGdyYXlDb2xvciA9ICcjYzBjMGMwJztcbmV4cG9ydCBsZXQgbm9tQ29sb3IgPSAnI2ZmNjYwMCc7XG5leHBvcnQgbGV0IHZhckNvbG9yID0gJyNmMGY4ZmYnOyAvLyBkMy5yZ2IoXCJhbGljZWJsdWVcIik7XG5sZXQgdGFnZ2VkQ29sb3IgPSAnI2Y1ZjVmNSc7IC8vIGQzLnJnYihcIndoaXRlc21va2VcIik7XG5leHBvcnQgbGV0IHRpbWVDb2xvciA9ICcjMmQ2Y2EyJztcblxuZXhwb3J0IGxldCBsZWZ0dGFiID0gJ3RhYjEnOyAvLyBjdXJyZW50IHRhYiBpbiBsZWZ0IHBhbmVsXG5leHBvcnQgbGV0IHN1YnNldCA9IGZhbHNlO1xuZXhwb3J0IGxldCBzdW1tYXJ5SG9sZCA9IGZhbHNlO1xuXG5leHBvcnQgbGV0IHJpZ2h0dGFiID0gJ2J0bk1vZGVscyc7IC8vIGN1cnJlbnQgdGFiIGluIHJpZ2h0IHBhbmVsXG5leHBvcnQgZnVuY3Rpb24gc2V0X3JpZ2h0dGFiKHZhbCkge1xuICAgIHJpZ2h0dGFiID0gdmFsO1xufVxuXG4vLyB0cmFuc2Zvcm1hdGlvbiB0b29sYmFyIG9wdGlvbnNcbmxldCB0LCB0eXBlVHJhbnNmb3JtO1xuZXhwb3J0IGxldCB0cmFuc2Zvcm1MaXN0ID0gJ2xvZyhkKSBleHAoZCkgZF4yIHNxcnQoZCkgaW50ZXJhY3QoZCxlKScuc3BsaXQoJyAnKTtcbmxldCB0cmFuc2Zvcm1WYXIgPSAnJztcblxuLy8gdmFyIGxpc3QgZm9yIGVhY2ggc3BhY2UgY29udGFpbiB2YXJpYWJsZXMgaW4gb3JpZ2luYWwgZGF0YVxuLy8gcGx1cyB0cmFucyBpbiB0aGF0IHNwYWNlXG5sZXQgdHJhbnMgPSBbXTtcbmxldCBwcmVwcm9jZXNzID0ge307IC8vIGhvbGQgcHJlLXByb2Nlc3NlZCBkYXRhXG5sZXQgc3BhY2VzID0gW107XG5cbi8vIGxheW91dCBmdW5jdGlvbiBjb25zdGFudHNcbmNvbnN0IGxheW91dEFkZCA9IFwiYWRkXCI7XG5jb25zdCBsYXlvdXRNb3ZlID0gXCJtb3ZlXCI7XG5cbi8vIHJhZGl1cyBvZiBjaXJjbGVcbmNvbnN0IFJBRElVUyA9IDQwO1xuXG4vLyBjeCwgY3ksIHIgdmFsdWVzIGZvciBpbmRpY2F0b3IgbGlnaHRzXG5sZXQgaW5kMSA9IFsoUkFESVVTKzMwKSAqIE1hdGguY29zKDEuMyksIC0xKihSQURJVVMrMzApICogTWF0aC5zaW4oMS4zKSwgNV07XG5sZXQgaW5kMiA9IFsoUkFESVVTKzMwKSAqIE1hdGguY29zKDEuMSksIC0xKihSQURJVVMrMzApICogTWF0aC5zaW4oMS4xKSwgNV07XG5cbi8vIHNwYWNlIGluZGV4XG5sZXQgbXlzcGFjZSA9IDA7XG5cbmxldCBmb3JjZXRvZ2dsZSA9IFtcInRydWVcIl07XG5leHBvcnQgbGV0IGxvY2t0b2dnbGUgPSB0cnVlO1xubGV0IHByaXYgPSB0cnVlO1xuXG4vLyBzd2FuZGl2ZSBpcyBvdXIgZ3JhY2VmdWwgZmFpbCBmb3IgZDNtXG4vLyBzd2FuZGl2ZSBzZXQgdG8gdHJ1ZSBpZiB0YXNrIGlzIGluIGZhaWxzZXRcbmxldCBzd2FuZGl2ZSA9IGZhbHNlO1xubGV0IGZhaWxzZXQgPSBbXCJUSU1FU0VSSUVTRk9SRUNBU1RJTkdcIixcIkdSQVBITUFUQ0hJTkdcIixcIkxJTktQUkVESUNUSU9OXCIsXCJ0aW1lU2VyaWVzRm9yZWNhc3RpbmdcIixcImdyYXBoTWF0Y2hpbmdcIixcImxpbmtQcmVkaWN0aW9uXCJdO1xuXG4vLyBvYmplY3QgdGhhdCBjb250YWlucyBhbGwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHJldHVybmVkIHBpcGVsaW5lc1xubGV0IGFsbFBpcGVsaW5lSW5mbyA9IHt9O1xuXG5leHBvcnQgbGV0IGxvZ0FycmF5ID0gW107XG5leHBvcnQgbGV0IHpwYXJhbXMgPSB7XG4gICAgemRhdGE6IFtdLFxuICAgIHplZGdlczogW10sXG4gICAgenRpbWU6IFtdLFxuICAgIHpub206IFtdLFxuICAgIHpjcm9zczogW10sXG4gICAgem1vZGVsOiBcIlwiLFxuICAgIHp2YXJzOiBbXSxcbiAgICB6ZHY6IFtdLFxuICAgIHpncm91cDE6IFtdLFxuICAgIHpncm91cDI6IFtdLCAgICAgICAvLyBoYXJkIGNvZGluZyB0byB0d28gZ3JvdXBzIGZvciBwcmVzZW50IGV4cGVyaW1lbnRzLCBidXQgd2lsbCBldmVudHVhbGx5IG1ha2Ugemdyb3VwIGFycmF5IG9mIGFycmF5cywgd2l0aCB6Z3JvdXAubGVuZ2h0IHRoZSBudW1iZXIgb2YgZ3JvdXBzXG4gICAgemRhdGF1cmw6IFwiXCIsXG4gICAgemQzbWRhdGE6IFwiXCIsIC8vdGhlc2UgdGFrZSB0aGUgcGxhY2Ugb2YgemRhdGF1cmwgZm9yIGQzbSwgYmVjYXVzZSBkYXRhIGlzIGluIHR3byBwbGFjZWVzLiBldmVudHVhbGx5IHdpbGwgZ2VuZXJhbGl6ZVxuICAgIHpkM210YXJnZXQ6IFwiXCIsXG4gICAgenN1YnNldDogW10sXG4gICAgenNldHg6IFtdLFxuICAgIHptb2RlbGNvdW50OiAwLFxuICAgIHpwbG90OiBbXSxcbiAgICB6c2Vzc2lvbmlkOiBcIlwiLFxuICAgIHpkYXRhY2l0ZTogJy4uLicsXG4gICAgemNyb3NzdGFiOiBbXSxcbiAgICB6dXNlcm5hbWU6ICcnLFxufTtcblxuZXhwb3J0IGxldCBkaXNjbyA9IFtdO1xuXG5leHBvcnQgbGV0IG1vZGVsQ291bnQgPSAwO1xuZXhwb3J0IGxldCB2YWx1ZUtleSA9IFtdO1xuZXhwb3J0IGxldCBhbGxOb2RlcyA9IFtdO1xuZXhwb3J0IGxldCBhbGxSZXN1bHRzID0gW107XG5leHBvcnQgbGV0IG5vZGVzID0gW107XG5leHBvcnQgbGV0IGxpbmtzID0gW107XG5sZXQgbW9kcyA9IHt9O1xubGV0IGVzdGltYXRlZCA9IGZhbHNlO1xubGV0IHJpZ2h0Q2xpY2tMYXN0ID0gZmFsc2U7XG5sZXQgc2VsSW50ZXJhY3QgPSBmYWxzZTtcbmV4cG9ydCBsZXQgY2FsbEhpc3RvcnkgPSBbXTsgLy8gdHJhbnNmb3JtIGFuZCBzdWJzZXQgY2FsbHNcbmxldCBteXRhcmdldCA9ICcnO1xuXG5sZXQgY29uZmlndXJhdGlvbnMgPSB7fTtcbmxldCBkYXRhZG9jdW1lbnQgPSB7fTtcblxuZXhwb3J0IGxldCBkb21haW5JZGVudGlmaWVyID0gbnVsbDsgLy8gYXZhaWxhYmxlIHRocm91Z2hvdXQgYXBwcyBqczsgdXNlZCBmb3Igc2F2aW5nIHdvcmtzcGFjZVxuXG4vLyBldmVudHVhbGx5IHJlYWQgdGhpcyBmcm9tIHRoZSBzY2hlbWEgd2l0aCByZWFsIGRlc2NyaXB0aW9uc1xuLy8gbWV0cmljcywgdGFza3MsIGFuZCBzdWJ0YXNrcyBhcyBzcGVjaWZpZWQgaW4gRDNNIHNjaGVtYXNcbi8vIE1FQU4gU1FVQVJFRCBFUlJPUiBJUyBTRVQgVE8gU0FNRSBBUyBSTVNFLiBNU0UgaXMgaW4gc2NoZW1hIGJ1dCBub3QgcHJvdG9cbmV4cG9ydCBsZXQgZDNtVGFza1R5cGUgPSB7XG4gICAgdGFza1R5cGVVbmRlZmluZWQ6IFtcImRlc2NyaXB0aW9uXCIsIFwiVEFTS19UWVBFX1VOREVGSU5FRFwiLCAwXSxcbiAgICBjbGFzc2lmaWNhdGlvbjogW1wiZGVzY3JpcHRpb25cIiwgXCJDTEFTU0lGSUNBVElPTlwiICwgMV0sXG4gICAgcmVncmVzc2lvbjogW1wiZGVzY3JpcHRpb25cIiwgXCJSRUdSRVNTSU9OXCIgLCAyXSxcbiAgICBjbHVzdGVyaW5nOiBbXCJkZXNjcmlwdGlvblwiLCBcIkNMVVNURVJJTkdcIiwgM10sXG4gICAgbGlua1ByZWRpY3Rpb246IFtcImRlc2NyaXB0aW9uXCIsIFwiTElOS19QUkVESUNUSU9OXCIgLCA0XSxcbiAgICB2ZXJ0ZXhOb21pbmF0aW9uOiBbXCJkZXNjcmlwdGlvblwiLCBcIlZFUlRFWF9OT01JTkFUSU9OXCIgLCA1XSxcbiAgICBjb21tdW5pdHlEZXRlY3Rpb246IFtcImRlc2NyaXB0aW9uXCIsIFwiQ09NTVVOSVRZX0RFVEVDVElPTlwiICwgNl0sXG4gICAgZ3JhcGhDbHVzdGVyaW5nOiBbXCJkZXNjcmlwdGlvblwiLCBcIkdSQVBIX0NMVVNURVJJTkdcIiAsIDddLFxuICAgIGdyYXBoTWF0Y2hpbmc6IFtcImRlc2NyaXB0aW9uXCIsIFwiR1JBUEhfTUFUQ0hJTkdcIiAsIDhdLFxuICAgIHRpbWVTZXJpZXNGb3JlY2FzdGluZzogW1wiZGVzY3JpcHRpb25cIiwgXCJUSU1FX1NFUklFU19GT1JFQ0FTVElOR1wiICwgOV0sXG4gICAgY29sbGFib3JhdGl2ZUZpbHRlcmluZzogW1wiZGVzY3JpcHRpb25cIiwgXCJDT0xMQUJPUkFUSVZFX0ZJTFRFUklOR1wiICwgMTBdXG59O1xuXG5leHBvcnQgbGV0IGQzbVRhc2tTdWJ0eXBlID0ge1xuICAgIHRhc2tTdWJ0eXBlVW5kZWZpbmVkOltcImRlc2NyaXB0aW9uXCIsIFwiVEFTS19TVUJUWVBFX1VOREVGSU5FRFwiLCAwXSxcbiAgICBzdWJ0eXBlTm9uZTpbXCJkZXNjcmlwdGlvblwiLFwiTk9ORVwiLDFdLFxuICAgIGJpbmFyeTpbXCJkZXNjcmlwdGlvblwiLCBcIkJJTkFSWVwiICwgMl0sXG4gICAgbXVsdGlDbGFzczpbXCJkZXNjcmlwdGlvblwiLCBcIk1VTFRJQ0xBU1NcIiAsIDNdLFxuICAgIG11bHRpTGFiZWw6W1wiZGVzY3JpcHRpb25cIiwgXCJNVUxUSUxBQkVMXCIgLCA0XSxcbiAgICB1bml2YXJpYXRlOltcImRlc2NyaXB0aW9uXCIsIFwiVU5JVkFSSUFURVwiICwgNV0sXG4gICAgbXVsdGl2YXJpYXRlOltcImRlc2NyaXB0aW9uXCIsIFwiTVVMVElWQVJJQVRFXCIgLCA2XSxcbiAgICBvdmVybGFwcGluZzpbXCJkZXNjcmlwdGlvblwiLCBcIk9WRVJMQVBQSU5HXCIgLCA3XSxcbiAgICBub25PdmVybGFwcGluZzpbXCJkZXNjcmlwdGlvblwiLCBcIk5PTk9WRVJMQVBQSU5HXCIgLCA4XVxufTtcbi8qZXhwb3J0IGxldCBkM21PdXRwdXRUeXBlID0ge1xuICAgIG91dHB1dFVuZGVmaW5lZDpbXCJkZXNjcmlwdGlvblwiLFwiT1VUUFVUX1RZUEVfVU5ERUZJTkVEIFwiLCAwXSxcbiAgICBwcmVkaWN0aW9uc0ZpbGU6W1wiZGVzY3JpcHRpb25cIixcIlBSRURJQ1RJT05TX0ZJTEVcIiwxXSxcbiAgICBzY29yZXNGaWxlOltcImRlc2NyaXB0aW9uXCIsXCJTQ09SRVNfRklMRVwiLDJdXG59OyAqL1xuZXhwb3J0IGxldCBkM21NZXRyaWNzID0ge1xuICAgIG1ldHJpY1VuZGVmaW5lZDpbXCJkZXNjcmlwdGlvblwiLCBcIk1FVFJJQ19VTkRFRklORURcIiAsIDBdLFxuICAgIGV4ZWN1dGlvblRpbWU6W1wiZGVzY3JpcHRpb25cIiwgXCJFWEVDVVRJT05fVElNRVwiLCAxXSxcbiAgICBhY2N1cmFjeSA6IFtcImRlc2NyaXB0aW9uXCIsIFwiQUNDVVJBQ1lcIiAsIDJdLFxuICAgIGYxOltcImRlc2NyaXB0aW9uXCIsIFwiRjFcIiAsIDNdLFxuICAgIGYxTWljcm86W1wiZGVzY3JpcHRpb25cIiwgXCJGMV9NSUNST1wiICwgNF0sXG4gICAgZjFNYWNybzpbXCJkZXNjcmlwdGlvblwiLCBcIkYxX01BQ1JPXCIgLCA1XSxcbiAgICByb2NBdWM6W1wiZGVzY3JpcHRpb25cIiwgXCJST0NfQVVDXCIgLCA2XSxcbiAgICByb2NBdWNNaWNybzpbXCJkZXNjcmlwdGlvblwiLCBcIlJPQ19BVUNfTUlDUk9cIiAsIDddLFxuICAgIHJvY0F1Y01hY3JvOltcImRlc2NyaXB0aW9uXCIsIFwiUk9DX0FVQ19NQUNST1wiICwgOF0sXG4gICAgbWVhblNxdWFyZWRFcnJvcjpbXCJkZXNjcmlwdGlvblwiLCBcIk1FQU5fU1FVQVJFRF9FUlJPUlwiLCA5XSxcbiAgICByb290TWVhblNxdWFyZWRFcnJvcjpbXCJkZXNjcmlwdGlvblwiLCBcIlJPT1RfTUVBTl9TUVVBUkVEX0VSUk9SXCIgLCAxMF0sXG4gICAgcm9vdE1lYW5TcXVhcmVkRXJyb3JBdmc6W1wiZGVzY3JpcHRpb25cIiwgXCJST09UX01FQU5fU1FVQVJFRF9FUlJPUl9BVkdcIiAsIDExXSxcbiAgICBtZWFuQWJzb2x1dGVFcnJvcjpbXCJkZXNjcmlwdGlvblwiLCBcIk1FQU5fQUJTT0xVVEVfRVJST1JcIiAsIDEyXSxcbiAgICByU3F1YXJlZDpbXCJkZXNjcmlwdGlvblwiLCBcIlJfU1FVQVJFRFwiICwgMTNdLFxuICAgIG5vcm1hbGl6ZWRNdXR1YWxJbmZvcm1hdGlvbjpbXCJkZXNjcmlwdGlvblwiLCBcIk5PUk1BTElaRURfTVVUVUFMX0lORk9STUFUSU9OXCIgLCAxNF0sXG4gICAgamFjY2FyZFNpbWlsYXJpdHlTY29yZTpbXCJkZXNjcmlwdGlvblwiLCBcIkpBQ0NBUkRfU0lNSUxBUklUWV9TQ09SRVwiICwgMTVdXG59O1xuXG5leHBvcnQgbGV0IGQzbVByb2JsZW1EZXNjcmlwdGlvbiA9IHtcbiAgICB0YXNrVHlwZTogXCJ0YXNrVHlwZVVuZGVmaW5lZFwiLFxuICAgIHRhc2tTdWJ0eXBlOiBcInRhc2tTdWJ0eXBlVW5kZWZpbmVkXCIsXG4gLy8gICBvdXRwdXRUeXBlOiBbMyxcIkRFRkFVTFRcIl0sXG4gICAgbWV0cmljOiBcIm1ldHJpY1VuZGVmaW5lZFwiLFxuICAgIHRhc2tEZXNjcmlwdGlvbjogXCJcIlxufTtcblxubGV0IHN2Zywgd2lkdGgsIGhlaWdodCwgZGl2LCBzZWxlY3RMYWRkYTtcbmV4cG9ydCBsZXQgZXN0aW1hdGVMYWRkYTtcblxuLy8gYXJjcyBmb3IgZGVub3RpbmcgcGViYmxlIGNoYXJhY3RlcmlzdGljc1xuY29uc3QgYXJjID0gKHN0YXJ0LCBlbmQpID0+IGQzLnN2Zy5hcmMoKVxuICAgIC5pbm5lclJhZGl1cyhSQURJVVMgKyA1KVxuICAgIC5vdXRlclJhZGl1cyhSQURJVVMgKyAyMClcbiAgICAuc3RhcnRBbmdsZShzdGFydClcbiAgICAuZW5kQW5nbGUoZW5kKTtcbmNvbnN0IFthcmMwLCBhcmMxLCBhcmMyLCBhcmMzLCBhcmM0XSA9IFthcmMoMCwgMy4yKSwgYXJjKDAsIDEpLCBhcmMoMS4xLCAyLjIpLCBhcmMoMi4zLCAzLjMpLCBhcmMoNC4zLCA1LjMpXTtcbmNvbnN0IGFyY0luZCA9IChhcmNsaW1pdHMpID0+IGQzLnN2Zy5hcmMoKVxuICAgIC5pbm5lclJhZGl1cyhSQURJVVMgKyAyMilcbiAgICAub3V0ZXJSYWRpdXMoUkFESVVTICsgMzcpXG4gICAgLnN0YXJ0QW5nbGUoYXJjbGltaXRzWzBdKVxuICAgIC5lbmRBbmdsZShhcmNsaW1pdHNbMV0pO1xuXG5jb25zdCBbYXJjSW5kMUxpbWl0cywgYXJjSW5kMkxpbWl0c10gPSBbWzAsIDAuM10sIFswLjM1LCAwLjY1XV07XG5jb25zdCBbYXJjSW5kMSwgYXJjSW5kMl0gPSBbYXJjSW5kKGFyY0luZDFMaW1pdHMpLCBhcmNJbmQoYXJjSW5kMkxpbWl0cyldO1xuXG5leHBvcnQgbGV0IGJ5SWQgPSBpZCA9PiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XG5cbi8qKlxuICAgcGFnZSByZWxvYWQgbGlua2VkIHRvIGJ0blJlc2V0XG4qL1xuZXhwb3J0IGNvbnN0IHJlc2V0ID0gZnVuY3Rpb24gcmVsb2FkUGFnZSgpIHtcbiAgICBsb2NhdGlvbi5yZWxvYWQoKTtcbn07XG5leHBvcnQgbGV0IHJlc3RhcnQ7XG5cbmxldCBkYXRhdXJsID0gJyc7XG5cbmV4cG9ydCBsZXQgc3RlcCA9ICh0YXJnZXQsIHBsYWNlbWVudCwgdGl0bGUsIGNvbnRlbnQpID0+ICh7XG4gICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgICAgICB0aXRsZSxcbiAgICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgICBzaG93Q1RBQnV0dG9uOiB0cnVlLFxuICAgICAgICAgICAgY3RhTGFiZWw6ICdEaXNhYmxlIHRoZXNlIG1lc3NhZ2VzJyxcbiAgICAgICAgICAgIG9uQ1RBOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaG9wc2NvdGNoLmVuZFRvdXIodHJ1ZSk7XG4gICAgICAgICAgICAgICAgdHV0b3JpYWxfbW9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG5cbmV4cG9ydCBsZXQgbXl0b3VyID0ge1xuICAgICAgICAgICAgaWQ6IFwiZGF0YXNldF9sYXVuY2hcIixcbiAgICAgICAgICAgIGkxOG46IHtkb25lQnRuOidPayd9LFxuICAgICAgICAgICAgc2hvd0Nsb3NlQnV0dG9uOiB0cnVlLFxuICAgICAgICAgICAgc2Nyb2xsRHVyYXRpb246IDMwMCxcbiAgICAgICAgICAgIG9uRW5kOiAoKSA9PiBmaXJzdF9sb2FkID0gZmFsc2UsXG4gICAgICAgICAgICBzdGVwczogW1xuICAgICAgICAgICAgICAgIHN0ZXAoXCJkYXRhTmFtZVwiLCBcImJvdHRvbVwiLCBcIldlbGNvbWUgdG8gVHdvUmF2ZW5zIFNvbHZlclwiLFxuICAgICAgICAgICAgICAgICAgICAgYDxwPlRoaXMgdG9vbCBjYW4gZ3VpZGUgeW91IHRvIHNvbHZlIGFuIGVtcGlyaWNhbCBwcm9ibGVtIGluIHRoZSBkYXRhc2V0IGFib3ZlLjwvcD5cbiAgICAgICAgICAgICAgICAgICAgICA8cD5UaGVzZSBtZXNzYWdlcyB3aWxsIHRlYWNoIHlvdSB0aGUgc3RlcHMgdG8gdGFrZSB0byBmaW5kIGFuZCBzdWJtaXQgYSBzb2x1dGlvbi48L3A+YCksXG4gICAgICAgICAgICAgICAgc3RlcChcImJ0blJlc2V0XCIsIFwiYm90dG9tXCIsIFwiUmVzdGFydCBBbnkgUHJvYmxlbSBIZXJlXCIsXG4gICAgICAgICAgICAgICAgICAgICAnPHA+WW91IGNhbiBhbHdheXMgc3RhcnQgYSBwcm9ibGVtIG92ZXIgYnkgdXNpbmcgdGhpcyByZXNldCBidXR0b24uPC9wPicpLFxuICAgICAgICAgICAgICAgIHN0ZXAoXCJidG5TdWJzZXRcIiwgXCJyaWdodFwiLCBcIlN0YXJ0IFRhc2sgMVwiLFxuICAgICAgICAgICAgICAgICAgICAgYDxwPlRoaXMgUHJvYmxlbSBEaXNjb3ZlcnkgYnV0dG9uIGFsbG93cyB5b3UgdG8gc3RhcnQgVGFzayAxIC0gUHJvYmxlbSBEaXNjb3ZlcnkuPC9wPlxuICAgICAgICAgICAgICAgICAgICAgPHA+R2VuZXJhbGx5LCBhcyBhIHRpcCwgdGhlIEdyZWVuIGJ1dHRvbiBpcyB0aGUgbmV4dCBidXR0b24geW91IG5lZWQgdG8gcHJlc3MgdG8gbW92ZSB0aGUgY3VycmVudCB0YXNrIGZvcndhcmQuPC9wPlxuICAgICAgICAgICAgICAgICAgICAgPHA+Q2xpY2sgdGhpcyBidXR0b24gdG8gc2VlIGEgbGlzdCBvZiBwcm9ibGVtcyB0aGF0IGhhdmUgYmVlbiBkaXNjb3ZlcmVkIGluIHRoZSBkYXRhc2V0LjwvcD5cbiAgICAgICAgICAgICAgICAgICAgIDxwPllvdSBjYW4gbWFyayB3aGljaCBvbmVzIHlvdSBhZ3JlZSBtYXkgYmUgaW50ZXJlc3RpbmcsIGFuZCB0aGVuIHN1Ym1pdCB0aGUgdGFibGUgYXMgYW4gYW5zd2VyLjwvcD5gKSxcbiAgICAgICAgICAgICAgICAvL3N0ZXAoXCJidG5TZWxlY3RcIiwgXCJyaWdodFwiLCBcIkNvbXBsZXRlIFRhc2sgMVwiLFxuICAgICAgICAgICAgICAgIC8vICAgICBgPHA+VGhpcyBzdWJtaXNzaW9uIGJ1dHRvbiBtYXJrcyBUYXNrIDEgLSBQcm9ibGVtIERpc2NvdmVyeSwgYXMgY29tcGxldGUuPC9wPlxuICAgICAgICAgICAgICAgIC8vICAgICA8cD5DbGljayB0aGlzIGJ1dHRvbiB0byBzYXZlIHRoZSBjaGVjayBtYXJrZWQgcHJvYmxlbXMgaW4gdGhlIHRhYmxlIGJlbG93IGFzIHBvdGVudGlhbGx5IGludGVyZXN0aW5nIG9yIHJlbGV2YW50LjwvcD5cbiAgICAgICAgICAgICAgICAvLyAgICAgPHA+R2VuZXJhbGx5LCBhcyBhIHRpcCwgdGhlIEdyZWVuIGJ1dHRvbiBpcyB0aGUgbmV4dCBidXR0b24geW91IG5lZWQgdG8gcHJlc3MgdG8gbW92ZSB0aGUgY3VycmVudCB0YXNrIGZvcndhcmQuPC9wPmApLFxuICAgICAgICAgICAgICAgIHN0ZXAoXCJidG5Fc3RpbWF0ZVwiLCBcImxlZnRcIiwgXCJTb2x2ZSBUYXNrIDJcIixcbiAgICAgICAgICAgICAgICAgICAgIGA8cD5UaGlzIGdlbmVyYWxseSBpcyB0aGUgaW1wb3J0YW50IHN0ZXAgdG8gZm9sbG93IGZvciBUYXNrIDIgLSBCdWlsZCBhIE1vZGVsLjwvcD5cbiAgICAgICAgICAgICAgICAgICAgICA8cD5HZW5lcmFsbHksIGFzIGEgdGlwLCB0aGUgR3JlZW4gYnV0dG9uIGlzIHRoZSBuZXh0IGJ1dHRvbiB5b3UgbmVlZCB0byBwcmVzcyB0byBtb3ZlIHRoZSBjdXJyZW50IHRhc2sgZm9yd2FyZCwgYW5kIHRoaXMgYnV0dG9uIHdpbGwgYmUgR3JlZW4gd2hlbiBUYXNrIDEgaXMgY29tcGxldGVkIGFuZCBUYXNrIDIgc3RhcnRlZC48L3A+XG4gICAgICAgICAgICAgICAgICAgICAgPHA+Q2xpY2sgdGhpcyBTb2x2ZSBidXR0b24gdG8gdGVsbCB0aGUgdG9vbCB0byBmaW5kIGEgc29sdXRpb24gdG8gdGhlIHByb2JsZW0sIHVzaW5nIHRoZSB2YXJpYWJsZXMgcHJlc2VudGVkIGluIHRoZSBjZW50ZXIgcGFuZWwuPC9wPmApLFxuICAgICAgICAgICAgICAgIHN0ZXAobXl0YXJnZXQgKyAnYmlnZ3JvdXAnLCBcImxlZnRcIiwgXCJUYXJnZXQgVmFyaWFibGVcIixcbiAgICAgICAgICAgICAgICAgICAgIGBUaGlzIGlzIHRoZSB2YXJpYWJsZSwgJHtteXRhcmdldH0sIHdlIGFyZSB0cnlpbmcgdG8gcHJlZGljdC5cbiAgICAgICAgICAgICAgICAgICAgICBUaGlzIGNlbnRlciBwYW5lbCBncmFwaGljYWxseSByZXByZXNlbnRzIHRoZSBwcm9ibGVtIGN1cnJlbnRseSBiZWluZyBhdHRlbXB0ZWQuYCksXG4gICAgICAgICAgICAgICAgc3RlcChcImdyMWh1bGxcIiwgXCJyaWdodFwiLCBcIkV4cGxhbmF0aW9uIFNldFwiLCBcIlRoaXMgc2V0IG9mIHZhcmlhYmxlcyBjYW4gcG90ZW50aWFsbHkgcHJlZGljdCB0aGUgdGFyZ2V0LlwiKSxcbiAgICAgICAgICAgICAgICBzdGVwKFwiZGlzcGxhY2VtZW50XCIsIFwicmlnaHRcIiwgXCJWYXJpYWJsZSBMaXN0XCIsXG4gICAgICAgICAgICAgICAgICAgICBgPHA+Q2xpY2sgb24gYW55IHZhcmlhYmxlIG5hbWUgaGVyZSBpZiB5b3Ugd2lzaCB0byByZW1vdmUgaXQgZnJvbSB0aGUgcHJvYmxlbSBzb2x1dGlvbi48L3A+XG4gICAgICAgICAgICAgICAgICAgICAgPHA+WW91IGxpa2VseSBkbyBub3QgbmVlZCB0byBhZGp1c3QgdGhlIHByb2JsZW0gcmVwcmVzZW50YXRpb24gaW4gdGhlIGNlbnRlciBwYW5lbC48L3A+YCksXG4gICAgICAgICAgICAgICAgc3RlcChcImJ0bkVuZFNlc3Npb25cIiwgXCJib3R0b21cIiwgXCJGaW5pc2ggUHJvYmxlbVwiLFxuICAgICAgICAgICAgICAgICAgICAgXCJJZiB0aGUgc29sdXRpb24gcmVwb3J0ZWQgYmFjayBzZWVtcyBhY2NlcHRhYmxlLCB0aGVuIGZpbmlzaCB0aGlzIHByb2JsZW0gYnkgY2xpY2tpbmcgdGhpcyBFbmQgU2Vzc2lvbiBidXR0b24uXCIpLFxuICAgICAgICAgICAgXVxuICAgICAgICB9O1xuXG5cbmV4cG9ydCBsZXQgbXl0b3VyMyA9IHtcbiAgICAgICAgICAgIGlkOiBcImRhdGFzZXRfbGF1bmNoXCIsXG4gICAgICAgICAgICBpMThuOiB7ZG9uZUJ0bjonT2snfSxcbiAgICAgICAgICAgIHNob3dDbG9zZUJ1dHRvbjogdHJ1ZSxcbiAgICAgICAgICAgIHNjcm9sbER1cmF0aW9uOiAzMDAsXG4gICAgICAgICAgICBvbkVuZDogKCkgPT4gZmlyc3RfbG9hZCA9IGZhbHNlLFxuICAgICAgICAgICAgc3RlcHM6IFtcbiAgICAgICAgICAgICAgICBzdGVwKFwiYnRuU2VsZWN0XCIsIFwicmlnaHRcIiwgXCJDb21wbGV0ZSBUYXNrIDFcIixcbiAgICAgICAgICAgICAgICAgICAgIGA8cD5UaGlzIHN1Ym1pc3Npb24gYnV0dG9uIG1hcmtzIFRhc2sgMSAtIFByb2JsZW0gRGlzY292ZXJ5LCBhcyBjb21wbGV0ZS48L3A+XG4gICAgICAgICAgICAgICAgICAgICA8cD5DbGljayB0aGlzIGJ1dHRvbiB0byBzYXZlIHRoZSBjaGVjayBtYXJrZWQgcHJvYmxlbXMgaW4gdGhlIHRhYmxlIGJlbG93IGFzIHBvdGVudGlhbGx5IGludGVyZXN0aW5nIG9yIHJlbGV2YW50LjwvcD5cbiAgICAgICAgICAgICAgICAgICAgIDxwPkdlbmVyYWxseSwgYXMgYSB0aXAsIHRoZSBHcmVlbiBidXR0b24gaXMgdGhlIG5leHQgYnV0dG9uIHlvdSBuZWVkIHRvIHByZXNzIHRvIG1vdmUgdGhlIGN1cnJlbnQgdGFzayBmb3J3YXJkLjwvcD5gKSxcbiAgICAgICAgICAgIF1cbiAgICAgICAgfTtcblxuLyoqXG4gIGNhbGxlZCBieSBtYWluXG4gIExvYWRzIGFsbCBleHRlcm5hbCBkYXRhIGluIHRoZSBmb2xsb3dpbmcgb3JkZXIgKGxvZ2ljIGlzIG5vdCBpbmNsdWRlZCk6XG4gIDEuIFJldHJpZXZlIHRoZSBjb25maWd1cmF0aW9uIGluZm9ybWF0aW9uXG4gIDIuIFNldCAnY29uZmlndXJhdGlvbnMnXG4gIDMuIFJlYWQgdGhlIHByb2JsZW0gc2NoZW1hIGFuZCBzZXQgJ2QzbVByb2JsZW1EZXNjcmlwdGlvbidcbiAgNC4gUmVhZCB0aGUgZGF0YSBkb2N1bWVudCBhbmQgc2V0ICdkYXRhZG9jdW1lbnQnXG4gIDUuIFJlYWQgaW4gemVsaWcgbW9kZWxzIChub3QgZm9yIGQzbSlcbiAgNi4gUmVhZCBpbiB6ZWxpZ2Nob2ljZSBtb2RlbHMgKG5vdCBmb3IgZDNtKVxuICA3LiBTdGFydCB0aGUgdXNlciBzZXNzaW9uXG4gIDguIFJlYWQgcHJlcHJvY2VzcyBkYXRhIG9yIChpZiBuZWNlc3NhcnkpIHJ1biBwcmVwcm9jZXNzXG4gIDkuIEJ1aWxkIGFsbE5vZGVzW10gdXNpbmcgcHJlcHJvY2Vzc2VkIGluZm9ybWF0aW9uXG4gIDEwLiBBZGQgZGF0YWRvY3VtZW50IGluZm9ybWF0aW9uIHRvIGFsbE5vZGVzICh3aGVuIGluIElTX0QzTV9ET01BSU4pXG4gIDExLiBDYWxsIGxheW91dCgpIGFuZCBzdGFydCB1cFxuKi9cbmFzeW5jIGZ1bmN0aW9uIGxvYWQoaG9sZCwgbGFibEFycmF5LCBkM21Sb290UGF0aCwgZDNtRGF0YU5hbWUsIGQzbVByZXByb2Nlc3MsIGQzbURhdGEsIGQzbVBTLCBkM21EUywgcFVSTCkge1xuICAgIGlmICghSVNfRDNNX0RPTUFJTikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gMS4gUmV0cmlldmUgdGhlIGNvbmZpZ3VyYXRpb24gaW5mb3JtYXRpb25cbiAgICBsZXQgcmVzID0gYXdhaXQgbS5yZXF1ZXN0KHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgdXJsOiBcIi9jb25maWcvZDNtLWNvbmZpZy9qc29uL2xhdGVzdFwiXG4gICAgfSk7XG4gICAgY29uc29sZS5sb2cocmVzKTtcbiAgICAvLyAyLiBTZXQgJ2NvbmZpZ3VyYXRpb25zJ1xuICAgIGNvbmZpZ3VyYXRpb25zID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShyZXMpKTsgLy8gdGhpcyBpcyBqdXN0IGNvcHlpbmcgcmVzXG4gICAgZDNtUm9vdFBhdGggPSBjb25maWd1cmF0aW9ucy50cmFpbmluZ19kYXRhX3Jvb3QucmVwbGFjZSgvXFwvZGF0YS8sJycpO1xuICAgIGQzbURhdGFOYW1lID0gY29uZmlndXJhdGlvbnMubmFtZTtcblxuICAgIC8vIHNjb3BlcyBhdCBhcHAuanMgbGV2ZWw7IHVzZWQgZm9yIHNhdmluZyB3b3Jrc3BhY2VcbiAgICBkb21haW5JZGVudGlmaWVyID0ge25hbWU6IGNvbmZpZ3VyYXRpb25zLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VfdXJsOiBjb25maWd1cmF0aW9ucy5jb25maWdfdXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246ICdEM00gY29uZmlnIGZpbGUnfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vaWQ6IGNvbmZpZ3VyYXRpb25zLmlkfTtcblxuICAgIGQzbVBTID0gXCIvY29uZmlnL2QzbS1jb25maWcvZ2V0LXByb2JsZW0tc2NoZW1hL2pzb25cIjtcbiAgICBkM21EUyA9IFwiL2NvbmZpZy9kM20tY29uZmlnL2dldC1kYXRhc2V0LXNjaGVtYS9qc29uXCI7XG4gICAgY29uc29sZS5sb2coXCJDb25maWd1cmF0aW9uczogXCIsIGNvbmZpZ3VyYXRpb25zKTtcbiAgICBkM21QcmVwcm9jZXNzID0gcFVSTCA9IGByb29rLWN1c3RvbS9yb29rLWZpbGVzLyR7ZDNtRGF0YU5hbWV9L3ByZXByb2Nlc3MvcHJlcHJvY2Vzcy5qc29uYDtcblxuICAgIC8vIDMuIFJlYWQgdGhlIHByb2JsZW0gc2NoZW1hIGFuZCBzZXQgJ2QzbVByb2JsZW1EZXNjcmlwdGlvbidcbiAgICAvLyAuLi5hbmQgbWFrZSBhIGNhbGwgdG8gc3RhcnQgdGhlIHNlc3Npb24gd2l0aCBUQTIuIGlmIHdlIGdldCB0aGlzIGZhciwgZGF0YSBhcmUgZ3VhcmFudGVlZCB0byBleGlzdCBmb3IgdGhlIGZyb250ZW5kXG5cbiAgICByZXMgPSBhd2FpdCBtLnJlcXVlc3QoXCIvY29uZmlnL2QzbS1jb25maWcvZ2V0LXByb2JsZW0tZGF0YS1maWxlLWluZm9cIik7XG4gICAgLy8gVGhlIHJlc3VsdCBvZiB0aGlzIGNhbGwgaXMgc2ltaWxhciB0byBiZWxvdzpcbiAgICAvLyBleGFtcGxlOlxuICAgIC8qICB7XG4gICAgICAgICAgICAgXCJzdWNjZXNzXCI6dHJ1ZSxcbiAgICAgICAgICAgICBcImRhdGFcIjp7XG4gICAgICAgICAgICAgICAgXCJsZWFybmluZ0RhdGEuY3N2XCI6e1xuICAgICAgICAgICAgICAgICAgIFwiZXhpc3RzXCI6dHJ1ZSxcbiAgICAgICAgICAgICAgICAgICBcInNpemVcIjoxMTY1NCxcbiAgICAgICAgICAgICAgICAgICBcInBhdGhcIjpcIi9pbnB1dHMvZGF0YXNldF9UUkFJTi90YWJsZXMvbGVhcm5pbmdEYXRhLmNzdlwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImxlYXJuaW5nRGF0YS5jc3YuZ3pcIjp7XG4gICAgICAgICAgICAgICAgICAgXCJleGlzdHNcIjpmYWxzZSxcbiAgICAgICAgICAgICAgICAgICBcInNpemVcIjotMSxcbiAgICAgICAgICAgICAgICAgICBcInBhdGhcIjpcIi9pbnB1dHMvZGF0YXNldF9UUkFJTi90YWJsZXMvbGVhcm5pbmdEYXRhLmNzdi5nelwiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgKi9cblxuICAgIC8vIExvb3AgdGhyb3VnaCB0aGUgcmVzcG9uc2UgYWJvdmUgYW5kXG4gICAgLy8gcGljayB0aGUgZmlyc3QgXCJwYXRoXCIgd2hlcmUgXCJleGlzdHNcIiBpcyB0cnVlXG4gICAgLy9cbiAgICAvLyBOb3RlOiBpZiBkYXRhIGZpbGVzIGhhdmUgXCJleGlzdHNcIiBhcyBmYWxzZSwgc3RheSBhcyBkZWZhdWx0IHdoaWNoIGlzIG51bGxcbiAgICAvL1xuICAgIGxldCBzZXRfZDNtX2RhdGFfcGF0aCA9IChmaWVsZCwgdmFsKSA9PiByZXMuZGF0YVtmaWVsZF0uZXhpc3RzID8gcmVzLmRhdGFbZmllbGRdLnBhdGggOlxuICAgICAgICByZXMuZGF0YVtmaWVsZCArICcuZ3onXS5leGlzdHMgPyByZXMuZGF0YVtmaWVsZCArICcuZ3onXS5wYXRoIDpcbiAgICAgICAgdmFsO1xuXG4gICAgenBhcmFtcy56ZDNtZGF0YSA9IGQzbURhdGEgPSBzZXRfZDNtX2RhdGFfcGF0aCgnbGVhcm5pbmdEYXRhLmNzdicsIGQzbURhdGEpO1xuICAgIHpwYXJhbXMuemQzbXRhcmdldCA9IHNldF9kM21fZGF0YV9wYXRoKCdsZWFybmluZ0RhdGEuY3N2JywgZDNtRGF0YSk7XG5cbiAgICAvLyBJZiB0aGlzIGlzIHRoZSBEM00gZG9tYWluOyBkM21EYXRhIE1VU1QgYmUgc2V0IHRvIGFuIGFjdHVhbCB2YWx1ZVxuICAgIC8vXG4gICAgaWYgKChJU19EM01fRE9NQUlOKSYmKGQzbURhdGEgPT0gbnVsbCkpe1xuICAgICAgICBjb25zdCBkM21fcGF0aF9lcnIgPSAnTk8gVkFMSUQgZDNtRGF0YSBwYXRoISEgJyArIEpTT04uc3RyaW5naWZ5KHJlcylcbiAgICAgICAgY29uc29sZS5sb2coZDNtX3BhdGhfZXJyKTtcbiAgICAgICAgYWxlcnQoJ2RlYnVnIChiZSBtb3JlIGdyYWNlZnVsKTogJyArIGQzbV9wYXRoX2Vycik7XG4gICAgfVxuXG4gICAgLy8gaGFyZGNvZGluZyB0aGlzLCBvbmNlIGdldC1wcm9ibGVtLWRhdGEtZmlsZS1pbmZvIGlzIHJldmlzZWQgdGhpcyBoYXJkY29kZSBjYW4gZ28gYXdheSBhbmQgdXNlIHRoZSBwcmV2aW91cyB0d28gTE9DXG4gIC8vICB6cGFyYW1zLnpkM21kYXRhID0gZDNtRGF0YSA9IGQzbVJvb3RQYXRoK1wiL2RhdGFzZXRfVFJBSU4vdGFibGVzL2xlYXJuaW5nRGF0YS5jc3ZcIjtcbiAgLy8gIHpwYXJhbXMuemQzbXRhcmdldCA9IGQzbVJvb3RQYXRoK1wiL2RhdGFzZXRfVFJBSU4vdGFibGVzL2xlYXJuaW5nRGF0YS5jc3ZcIjtcblxuICAgIHJlcyA9IGF3YWl0IG0ucmVxdWVzdChkM21QUyk7XG4gICAgY29uc29sZS5sb2coXCJwcm9iIHNjaGVtYSBkYXRhOiBcIiwgcmVzKTtcblxuICAgIG15dGFyZ2V0ID0gcmVzLmlucHV0cy5kYXRhWzBdLnRhcmdldHNbMF0uY29sTmFtZTsgLy8gZWFzaWVyIHdheSB0byBhY2Nlc3MgdGFyZ2V0IG5hbWU/XG4gICAgaWYgKHR5cGVvZiByZXMuYWJvdXQudGFza1R5cGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGQzbVByb2JsZW1EZXNjcmlwdGlvbi50YXNrVHlwZT1yZXMuYWJvdXQudGFza1R5cGU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcmVzLmFib3V0LnRhc2tTdWJUeXBlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBkM21Qcm9ibGVtRGVzY3JpcHRpb24udGFza1N1YnR5cGU9cmVzLmFib3V0LnRhc2tTdWJUeXBlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHJlcy5pbnB1dHMucGVyZm9ybWFuY2VNZXRyaWNzWzBdLm1ldHJpYyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZDNtUHJvYmxlbURlc2NyaXB0aW9uLm1ldHJpYyA9IHJlcy5pbnB1dHMucGVyZm9ybWFuY2VNZXRyaWNzWzBdLm1ldHJpYztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiByZXMuZGVzY3JpcHRpb25GaWxlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBkM21Qcm9ibGVtRGVzY3JpcHRpb24udGFza0Rlc2NyaXB0aW9uID0gcmVzLmRlc2NyaXB0aW9uRmlsZTtcbiAgICB9XG4gLy8gICBkM21Qcm9ibGVtRGVzY3JpcHRpb24ub3V0cHV0VHlwZSA9IHJlcy5leHBlY3RlZE91dHB1dHMucHJlZGljdGlvbnNGaWxlO1xuXG4gICAgYnlJZChcImJ0blR5cGVcIikuY2xpY2soKTtcblxuICAgIC8vIG1ha2luZyBpdCBjYXNlIGluc2Vuc2l0aXZlIGJlY2F1c2UgdGhlIGNhc2Ugc2VlbXMgdG8gZGlzYWdyZWUgYWxsIHRvbyBvZnRlblxuICAgIGlmIChmYWlsc2V0LmluY2x1ZGVzKGQzbVByb2JsZW1EZXNjcmlwdGlvbi50YXNrVHlwZS50b1VwcGVyQ2FzZSgpKSkge1xuICAgICAgICBzd2FuZGl2ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gNC4gUmVhZCB0aGUgZGF0YSBkb2N1bWVudCBhbmQgc2V0ICdkYXRhZG9jdW1lbnQnXG4gICAgZGF0YWRvY3VtZW50ID0gYXdhaXQgbS5yZXF1ZXN0KGQzbURTKTtcblxuICAgIC8vIGlmIG5vIGNvbHVtbnMgaW4gdGhlIGRhdGFkb2N1bWVudCwgZ28gdG8gc3dhbmRpdmVcbiAgICBpZih0eXBlb2YgZGF0YWRvY3VtZW50LmRhdGFSZXNvdXJjZXNbMF0uY29sdW1ucyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgc3dhbmRpdmUgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChJU19EM01fRE9NQUlOKSB7XG4gICAgICAgIGxldCBkYXRhc2V0TmFtZSA9IGRhdGFkb2N1bWVudC5hYm91dC5kYXRhc2V0TmFtZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgXCJkYXRhc2V0TmFtZVwiIGZpZWxkIGluIGRhdGFzZXQgZG9jdW1lbnRcbiAgICAgICAgenBhcmFtcy56ZGF0YSA9IGRhdGFzZXROYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgZGF0YXNldE5hbWUuc2xpY2UoMSk7IC8vIE1ha2Ugc3VyZSB0byBjYXBpdGFsaXplO1xuICAgICAgICBsZXQgY2l0ZSA9IFwiTm8gY2l0YXRpb24gcHJvdmlkZWRcIjtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhZG9jdW1lbnQuYWJvdXQuY2l0YXRpb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBjaXRlID0gZGF0YWRvY3VtZW50LmFib3V0LmNpdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIC8vY29uc29sZS5sb2coY2l0ZSk7XG4gICAgICAgIC8vbGV0IG5ld2NpdGUgPSBjaXRlLm1hdGNoKC97XFxzKltcXHdcXC5dK1xccyp9L2cpLm1hcChmdW5jdGlvbih4KSB7IHJldHVybiB4Lm1hdGNoKC9bXFx3XFwuXSsvKVswXTsgfSk7XG4gICAgICAgIC8vY29uc29sZS5sb2cobmV3Y2l0ZSk7XG4gICAgICAgIC8qXG4gICAgICAgIC8vIGNsZWFuIGNpdGF0aW9uXG4gICAgICAgIHpwYXJhbXMuemRhdGFjaXRlID0gY2l0ZVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcJi9nLCBcImFuZFwiKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcOy9nLCBcIixcIilcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXCUvZywgXCItXCIpO1xuICAgICAgICAvLyBmaWxsIGluIGNpdGF0aW9uIGluIGhlYWRlclxuICAgICAgICAkKCcjY2l0ZSBkaXYucGFuZWwtYm9keScpLnRleHQoenBhcmFtcy56ZGF0YWNpdGUpO1xuICAgICAgICAqL1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm90ZTogcHJlc2VudGx5IHhtbCBpcyBubyBsb25nZXIgYmVpbmcgcmVhZCBmcm9tIERhdGF2ZXJzZSBtZXRhZGF0YSBhbnl3aGVyZVxuICAgICAgICBsZXQgdGVtcCA9IHhtbC5kb2N1bWVudEVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJmaWxlTmFtZVwiKTtcbiAgICAgICAgenBhcmFtcy56ZGF0YSA9IHRlbXBbMF0uY2hpbGROb2Rlc1swXS5ub2RlVmFsdWU7XG4gICAgICAgIGxldCBjaXRlID0geG1sLmRvY3VtZW50RWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImJpYmxDaXRcIik7XG4gICAgICAgIC8vIGNsZWFuIGNpdGF0aW9uIHNvIFBPU1QgaXMgdmFsaWQganNvblxuICAgICAgICB6cGFyYW1zLnpkYXRhY2l0ZSA9IGNpdGVbMF0uY2hpbGROb2Rlc1swXS5ub2RlVmFsdWVcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXCYvZywgXCJhbmRcIilcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXDsvZywgXCIsXCIpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFwlL2csIFwiLVwiKTtcbiAgICAgICAgLy8gZmlsbCBpbiBjaXRhdGlvbiBpbiBoZWFkZXJcbiAgICAgICAgJCgnI2NpdGUgZGl2LnBhbmVsLWJvZHknKS50ZXh0KHpwYXJhbXMuemRhdGFjaXRlKTtcbiAgICB9XG4gICAgLy8gZHJvcCBmaWxlIGV4dGVuc2lvblxuICAgIGxldCBkYXRhbmFtZSA9IElTX0QzTV9ET01BSU4gPyB6cGFyYW1zLnpkYXRhIDogenBhcmFtcy56ZGF0YS5yZXBsYWNlKC9cXC4oLiopLywgJycpO1xuICAgIGQzLnNlbGVjdChcIiNkYXRhTmFtZVwiKS5odG1sKGRhdGFuYW1lKTtcbiAgICAvLyBwdXQgZGF0YXNldCBuYW1lLCBmcm9tIG1ldGEtZGF0YSwgaW50byBwYWdlIHRpdGxlXG4gICAgZDMuc2VsZWN0KFwidGl0bGVcIikuaHRtbChcIlR3b1JhdmVucyBcIiArIGRhdGFuYW1lKTtcblxuICAgIC8vIGlmIHN3YW5kaXZlLCB3ZSBoYXZlIHRvIHNldCB2YWx1ZUtleSBoZXJlIHNvIHRoYXQgbGVmdCBwYW5lbCBjYW4gcG9wdWxhdGUuXG4gICAgaWYgKHN3YW5kaXZlKSB7XG4gICAgLy8gICAgbGV0IG15ZGF0YVJlcyA9IGRhdGFkb2N1bWVudC5kYXRhUmVzb3VyY2VzO1xuICAgICAgLy8gIGZvciAobGV0IGkgPSAwOyBpIDwgbXlkYXRhUmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgIC8vICAgICAgIHZhbHVlS2V5LnB1c2gobXlkYXRhUmVzW2ldLnJlc0Zvcm1hdFswXSk7XG4gICAgICAvLyAgfVxuICAgICAgICAvLyBlbmQgc2Vzc2lvbiBpZiBuZWl0aGVyIHRyYWluRGF0YSBub3IgdHJhaW5UYXJnZXRzP1xuICAgICAgIC8vIHZhbHVlS2V5Lmxlbmd0aCA9PT0gMCAmJiBhbGVydChcIm5vIHRyYWluRGF0YSBvciB0cmFpblRhcmdlc3QgaW4gZGF0YSBkZXNjcmlwdGlvbiBmaWxlLiB2YWx1ZUtleSBsZW5ndGggaXMgMFwiKTtcbiAgICAgICAgLy8gcGVyaGFwcyBhbGxvdyB1c2VycyB0byB1bmxvY2sgYW5kIHNlbGVjdCB0aGluZ3M/XG4gICAgICAgIGJ5SWQoJ2J0bkxvY2snKS5jbGFzc0xpc3QuYWRkKCdub3Nob3cnKTtcbiAgICAgICAgYnlJZCgnYnRuRm9yY2UnKS5jbGFzc0xpc3QuYWRkKCdub3Nob3cnKTtcbiAgICAgICAgYnlJZCgnYnRuRXJhc2VyJykuY2xhc3NMaXN0LmFkZCgnbm9zaG93Jyk7XG4gICAgICAgIGJ5SWQoJ2J0blN1YnNldCcpLmNsYXNzTGlzdC5hZGQoJ25vc2hvdycpO1xuICAgICAgICBieUlkKCdtYWluJykuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ2dyZXknO1xuICAgICAgICBieUlkKCd3aGl0ZXNwYWNlJykuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ2dyZXknO1xuICAgIH1cbiAgICBjb25zb2xlLmxvZyhcImRhdGEgc2NoZW1hIGRhdGE6IFwiLCBkYXRhZG9jdW1lbnQpO1xuXG4gICAgLy8gNS4gUmVhZCBpbiB6ZWxpZyBtb2RlbHMgKG5vdCBmb3IgZDNtKVxuICAgIC8vIDYuIFJlYWQgaW4gemVsaWdjaG9pY2UgbW9kZWxzIChub3QgZm9yIGQzbSlcbiAgICBpZiAoIUlTX0QzTV9ET01BSU4pe1xuICAgICAgZm9yIChsZXQgZmllbGQgb2YgWyd6ZWxpZzVtb2RlbHMnLCAnemVsaWc1Y2hvaWNlbW9kZWxzJ10pIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXMgPSBhd2FpdCBtLnJlcXVlc3QoYGRhdGEvJHtmaWVsZH0uanNvbmApO1xuICAgICAgICAgICAgICBjZGIoZmllbGQgKyAnIGpzb246ICcsIHJlcyk7XG4gICAgICAgICAgICAgIHJlc1tmaWVsZF1cbiAgICAgICAgICAgICAgICAgIC5maWx0ZXIoa2V5ID0+IHJlc1tmaWVsZF0uaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgICAgICAgIC5mb3JFYWNoKGtleSA9PiBtb2RzW2tleS5uYW1lWzBdXSA9IGtleS5kZXNjcmlwdGlvblswXSk7XG4gICAgICAgICAgfSBjYXRjaChfKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY2FuJ3QgbG9hZCBcIiArIGZpZWxkKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIDcuIFN0YXJ0IHRoZSB1c2VyIHNlc3Npb25cbiAgICAvLyBycGMgU3RhcnRTZXNzaW9uKFNlc3Npb25SZXF1ZXN0KSByZXR1cm5zIChTZXNzaW9uUmVzcG9uc2UpIHt9XG4gICAgcmVzID0gYXdhaXQgbWFrZVJlcXVlc3QoRDNNX1NWQ19VUkwgKyAnL3N0YXJ0c2Vzc2lvbicsIHt1c2VyX2FnZW50OiAnc29tZSBhZ2VudCcsIHZlcnNpb246ICdzb21lIHZlcnNpb24nfSk7XG4gICAgaWYgKHJlcykge1xuICAgICAgaWYgKHJlcy5yZXNwb25zZUluZm8uc3RhdHVzLmNvZGUgIT0gXCJPS1wiKXtcbiAgICAgICAgY29uc3QgdXNlcl9lcnJfbXNnID0gXCJGYWlsZWQgdG8gU3RhcnRTZXNzaW9uIHdpdGggVEEyISBzdGF0dXMgY29kZTogXCIgKyByZXMucmVzcG9uc2VJbmZvLnN0YXR1cy5jb2RlO1xuICAgICAgICBhbGVydCh1c2VyX2Vycl9tc2cpO1xuICAgICAgICBlbmRfdGEzX3NlYXJjaChmYWxzZSwgdXNlcl9lcnJfbXNnKTtcbiAgICAgIH1lbHNle1xuICAgICAgICB6cGFyYW1zLnpzZXNzaW9uaWQgPSByZXMuY29udGV4dC5zZXNzaW9uSWQ7XG4gICAgICB9XG4gICAgfVxuXG5cbiAgICAvLyBob3BzY290Y2ggdHV0b3JpYWxcbiAgICBpZiAodHV0b3JpYWxfbW9kZSkge1xuICAgICAgICBjb25zb2xlLmxvZygnU3RhcnRpbmcgSG9wc2NvdGNoIFRvdXInKTtcbiAgICAgICAgaG9wc2NvdGNoLnN0YXJ0VG91cihteXRvdXIsMCk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdFbmRpbmcgSG9wc2NvdGNoIFRvdXInKTtcbiAgICB9XG5cbiAgICAvLyA4LiByZWFkIHByZXByb2Nlc3MgZGF0YSBvciAoaWYgbmVjZXNzYXJ5KSBydW4gcHJlcHJvY2Vzc1xuICAgIC8vIE5PVEU6IHByZXByb2Nlc3MuanNvbiBpcyBub3cgZ3VhcmFudGVlZCB0byBleGlzdC4uLlxuICAgIGxldCByZWFkID0gcmVzID0+IHtcbiAgICAgICAgcHJpdiA9IHJlcy5kYXRhc2V0LnByaXZhdGUgfHwgcHJpdjtcbiAgICAgICAgT2JqZWN0LmtleXMocmVzLnZhcmlhYmxlcykuZm9yRWFjaChrID0+IHByZXByb2Nlc3Nba10gPSByZXMudmFyaWFibGVzW2tdKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdhdHRlbXB0IHRvIHJlYWQgcHJlcHJvY2VzcyBmaWxlICh3aGljaCBtYXkgbm90IGV4aXN0KTogJyArIHBVUkwpO1xuICAgICAgICByZXMgPSByZWFkKGF3YWl0IG0ucmVxdWVzdChwVVJMKSk7XG4gICAgfSBjYXRjaChfKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiT2ssIHByZXByb2Nlc3Mgbm90IGZvdW5kLCB0cnkgdG8gUlVOIFRIRSBQUkVQUk9DRVNTQVBQXCIpO1xuICAgICAgICBsZXQgdXJsID0gUk9PS19TVkNfVVJMICsgJ3ByZXByb2Nlc3NhcHAnO1xuICAgICAgICB2YXIganNvbl9pbnB1dDtcbiAgICAgICAgaWYgKElTX0QzTV9ET01BSU4pe1xuICAgICAgICAgIC8vIEZvciBEM00gaW5wdXRzLCBjaGFuZ2UgdGhlIHByZXByb2Nlc3MgaW5wdXQgZGF0YVxuICAgICAgICAgIC8vXG4gICAgICAgICAganNvbl9pbnB1dCA9IEpTT04uc3RyaW5naWZ5KHtkYXRhOiBkM21EYXRhLCBkYXRhc3R1YjogZDNtRGF0YU5hbWV9KTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICBqc29uX2lucHV0ID0gSlNPTi5zdHJpbmdpZnkoe2RhdGE6IGRhdGFsb2MsIHRhcmdldDogdGFyZ2V0bG9jLCBkYXRhc3R1YjogZGF0YXN0dWJ9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUubG9nKCdqc29uX2lucHV0OiAnLCBqc29uX2lucHV0KTtcbiAgICAgICAgY29uc29sZS5sb2coJ3VybDogJywgdXJsKTtcbiAgICAgICAgbGV0IGRhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlcyA9IHJlYWQoYXdhaXQgbS5yZXF1ZXN0KHttZXRob2Q6ICdQT1NUJywgdXJsOiB1cmwsIGRhdGE6IGpzb25faW5wdXR9KSk7XG4gICAgICAgIH0gY2F0Y2goXykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ3ByZXByb2Nlc3MgZmFpbGVkJyk7XG4gICAgICAgICAgICBhbGVydCgncHJlcHJvY2VzcyBmYWlsZWQuIGVuZGluZyB1c2VyIHNlc3Npb24uJyk7XG4gICAgICAgICAgICBlbmRzZXNzaW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZyhcImlzIHRoaXMgcHJlcHJvY2Vzcz9cIilcbiAgICBjb25zb2xlLmxvZyhyZXMpO1xuICAgIGNvbnNvbGUubG9nKHByZXByb2Nlc3MpO1xuXG4gICAgLy8gOS4gQnVpbGQgYWxsTm9kZXNbXSB1c2luZyBwcmVwcm9jZXNzZWQgaW5mb3JtYXRpb25cbiAgICBsZXQgdmFycyA9IE9iamVjdC5rZXlzKHByZXByb2Nlc3MpO1xuICAgIC8vIHRlbXBvcmFyeSB2YWx1ZXMgZm9yIGhvbGQgdGhhdCBjb3JyZXNwb25kIHRvIGhpc3RvZ3JhbSBiaW5zXG4gICAgaG9sZCA9IFsuNiwgLjIsIC45LCAuOCwgLjEsIC4zLCAuNF07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIHZhbHVlS2V5W2ldID0gdmFyc1tpXS5hdHRyaWJ1dGVzLm5hbWUubm9kZVZhbHVlO1xuICAgICAgICAvLyBsYWJsQXJyYXlbaV0gPSB2YXJzWE1MW2ldLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwibGFibFwiKS5sZW5ndGggPT0gMCA/XG4gICAgICAgIC8vIFwibm8gbGFiZWxcIiA6XG4gICAgICAgIC8vIHZhcnNYTUxbaV0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJsYWJsXCIpWzBdLmNoaWxkTm9kZXNbMF0ubm9kZVZhbHVlO1xuICAgICAgICAvLyBsZXQgZGF0YXNldGNvdW50ID0gZDMubGF5b3V0Lmhpc3RvZ3JhbSgpXG4gICAgICAgIC8vICAgICAuYmlucyhiYXJudW1iZXIpLmZyZXF1ZW5jeShmYWxzZSlcbiAgICAgICAgLy8gICAgIChbMCwgMCwgMCwgMCwgMF0pO1xuICAgICAgICB2YWx1ZUtleVtpXSA9IHZhcnNbaV07XG4gICAgICAgIGxhYmxBcnJheVtpXSA9IFwibm8gbGFiZWxcIjtcbiAgICAgICAgLy8gY29udGFpbnMgYWxsIHRoZSBwcmVwcm9jZXNzZWQgZGF0YSB3ZSBoYXZlIGZvciB0aGUgdmFyaWFibGUsIGFzIHdlbGwgYXMgVUkgZGF0YSBwZXJ0aW5lbnQgdG8gdGhhdCB2YXJpYWJsZSxcbiAgICAgICAgLy8gc3VjaCBhcyBzZXR4IHZhbHVlcyAoaWYgdGhlIHVzZXIgaGFzIHNlbGVjdGVkIHRoZW0pIGFuZCBwZWJibGUgY29vcmRpbmF0ZXNcbiAgICAgICAgbGV0IG9iaiA9IHtcbiAgICAgICAgICAgIGlkOiBpLFxuICAgICAgICAgICAgcmVmbGV4aXZlOiBmYWxzZSxcbiAgICAgICAgICAgIG5hbWU6IHZhbHVlS2V5W2ldLFxuICAgICAgICAgICAgbGFibDogbGFibEFycmF5W2ldLFxuICAgICAgICAgICAgZGF0YTogWzUsIDE1LCAyMCwgMCwgNSwgMTUsIDIwXSxcbiAgICAgICAgICAgIGNvdW50OiBob2xkLFxuICAgICAgICAgICAgbm9kZUNvbDogY29sb3JzKGkpLFxuICAgICAgICAgICAgYmFzZUNvbDogY29sb3JzKGkpLFxuICAgICAgICAgICAgc3Ryb2tlQ29sb3I6IHNlbFZhckNvbG9yLFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IFwiMVwiLFxuICAgICAgICAgICAgc3Vic2V0cGxvdDogZmFsc2UsXG4gICAgICAgICAgICBzdWJzZXRyYW5nZTogW1wiXCIsIFwiXCJdLFxuICAgICAgICAgICAgc2V0eHBsb3Q6IGZhbHNlLFxuICAgICAgICAgICAgc2V0eHZhbHM6IFtcIlwiLCBcIlwiXSxcbiAgICAgICAgICAgIGdyYXlvdXQ6IGZhbHNlLFxuICAgICAgICAgICAgZ3JvdXAxOiBmYWxzZSxcbiAgICAgICAgICAgIGdyb3VwMjogZmFsc2UsXG4gICAgICAgICAgICBmb3JlZnJvbnQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIGpRdWVyeS5leHRlbmQodHJ1ZSwgb2JqLCBwcmVwcm9jZXNzW3ZhbHVlS2V5W2ldXSk7XG4gICAgICAgIGFsbE5vZGVzLnB1c2gob2JqKTtcbiAgICB9XG5cbiAgICAvLyAxMC4gQWRkIGRhdGFkb2N1bWVudCBpbmZvcm1hdGlvbiB0byBhbGxOb2RlcyAod2hlbiBpbiBJU19EM01fRE9NQUlOKVxuICAgIGlmKCFzd2FuZGl2ZSkge1xuICAgICAgICBsZXQgZGF0YXZhcnMgPSBkYXRhZG9jdW1lbnQuZGF0YVJlc291cmNlc1swXS5jb2x1bW5zO1xuICAgICAgICBkYXRhdmFycy5mb3JFYWNoKCh2LCBpKSA9PiB7XG4gICAgICAgICAgICBsZXQgbXlpID0gZmluZE5vZGVJbmRleCh2LmNvbE5hbWUpO1xuICAgICAgICAgICAgYWxsTm9kZXNbbXlpXSA9IE9iamVjdC5hc3NpZ24oYWxsTm9kZXNbbXlpXSwge2QzbURlc2NyaXB0aW9uOiB2fSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zb2xlLmxvZyhhbGxOb2Rlcyk7XG4gICAgfVxuXG4gICAgLy8gMTBiLiBDYWxsIHByb2JsZW0gZGlzY292ZXJ5XG4gICAgLy8gUmVxdWlyZXMgdGhhdCBgcmVzYCBidWlsdCBpbiA4LiBhYm92ZSBzdGlsbCBleGlzdHMuICBTaG91bGQgbWFrZSB0aGlzIGJldHRlci5cbiAgICBpZighc3dhbmRpdmUpIHtcbiAgICAgICAgZGlzY28gPSBkaXNjb3ZlcnkocmVzKTtcbiAgICAgICAgY29uc29sZS5sb2coZGlzY28pO1xuXG4gICAgfVxuXG4gICAgLy8gMTEuIENhbGwgbGF5b3V0KCkgYW5kIHN0YXJ0IHVwXG4gICAgbGF5b3V0KGZhbHNlLCB0cnVlKTtcbiAgICBJU19EM01fRE9NQUlOID8gelBvcCgpIDogZGF0YURvd25sb2FkKCk7XG59XG5cbi8qKlxuICAgY2FsbGVkIG9uIGFwcCBzdGFydFxuICAgQHBhcmFtIHtzdHJpbmd9IGZpbGVpZFxuICAgQHBhcmFtIHtzdHJpbmd9IGhvc3RuYW1lXG4gICBAcGFyYW0ge3N0cmluZ30gZGRpdXJsXG4gICBAcGFyYW0ge3N0cmluZ30gZGF0YXVybFxuICAgQHBhcmFtIHtzdHJpbmd9IGFwaWtleVxuKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWluKGZpbGVpZCwgaG9zdG5hbWUsIGRkaXVybCwgZGF0YXVybCwgYXBpa2V5KSB7XG4gICAgaWYgKFBST0RVQ1RJT04gJiYgZmlsZWlkID09PSAnJykge1xuICAgICAgICBsZXQgbXNnID0gJ0Vycm9yOiBObyBmaWxlaWQgaGFzIGJlZW4gcHJvdmlkZWQuJztcbiAgICAgICAgYWxlcnQobXNnKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxuXG4gICAgbGV0IGRhdGF2ZXJzZXVybCA9IGhvc3RuYW1lID8gJ2h0dHBzOi8vJyArIGhvc3RuYW1lIDpcbiAgICAgICAgUFJPRFVDVElPTiA/IERBVEFWRVJTRV9VUkwgOlxuICAgICAgICAnaHR0cDovL2xvY2FsaG9zdDo4MDgwJztcbiAgICAvLyBpZiBmaWxlIGlkIHN1cHBsaWVkLCBhc3N1bWUgd2UgYXJlIGRlYWxpbmcgd2l0aCBkYXRhdmVyc2UgYW5kIGNvb2sgYSBzdGFuZGFyZCBkYXRhdmVyc2UgZGF0YSBhY2Nlc3MgdXJsXG4gICAgLy8gd2l0aCB0aGUgZmlsZWlkIHN1cHBsaWVkIGFuZCB0aGUgaG9zdG5hbWUgd2UgaGF2ZSBzdXBwbGllZCBvciBjb25maWd1cmVkXG4gICAgZGF0YXVybCA9IGZpbGVpZCAmJiAhZGF0YXVybCA/IGAke2RhdGF2ZXJzZXVybH0vYXBpL2FjY2Vzcy9kYXRhZmlsZS8ke2ZpbGVpZH0/a2V5PSR7YXBpa2V5fWAgOiBkYXRhdXJsO1xuICAgIGNkYignLS1kYXRhdXJsOiAnICsgZGF0YXVybCk7XG4gICAgY2RiKCctLWRhdGF2ZXJzZXVybDogJyArIGRhdGF2ZXJzZXVybCk7XG5cbiAgICBsZXQgdGVtcFdpZHRoID0gZDMuc2VsZWN0KCcjbWFpbi5sZWZ0Jykuc3R5bGUoJ3dpZHRoJyk7XG4gICAgd2lkdGggPSB0ZW1wV2lkdGguc3Vic3RyaW5nKDAsIHRlbXBXaWR0aC5sZW5ndGggLSAyKTtcbiAgICBoZWlnaHQgPSAkKHdpbmRvdykuaGVpZ2h0KCkgLSAxMjA7IC8vIGhhcmQgY29kZSBoZWFkZXIsIGZvb3RlciwgYW5kIGJvdHRvbSBtYXJnaW5cblxuICAgIGVzdGltYXRlTGFkZGEgPSBMYWRkYS5jcmVhdGUoYnlJZChcImJ0bkVzdGltYXRlXCIpKTtcbiAgICBzZWxlY3RMYWRkYSA9IExhZGRhLmNyZWF0ZShieUlkKFwiYnRuU2VsZWN0XCIpKTtcbiAgICBzdmcgPSBkMy5zZWxlY3QoXCIjd2hpdGVzcGFjZVwiKTtcblxuICAgIC8vIGluZGljYXRvcnMgZm9yIHNob3dpbmcgbWVtYmVyc2hpcCBhYm92ZSBhcmNzXG4gICAgLy8gbGV0IGluZGljYXRvciA9IChkZWdyZWUpID0+IGQzLnN2Zy5jaXJjbGUoKVxuICAgIC8vICAgICAuY3goIFJBRElVUyApLy8oUkFESVVTKzM1KSAqIE1hdGguc2luKGRlZ3JlZSkpXG4gICAgLy8gICAgIC5jeSggUkFESVVTICkvLyhSQURJVVMrMzUpICogTWF0aC5jb3MoZGVncmVlKSlcbiAgICAvLyAgICAgLnIoMyk7XG4gICAgLy8gaW5kMSA9IGluZGljYXRvcigxKTtcbiAgICAvLyBpbmQyID0gaW5kaWNhdG9yKDEuMik7XG5cbiAgICAvLyBmcm9tIC5jc3ZcbiAgICBsZXQgW2hvbGQsIGxhYmxBcnJheV0gPSBbW10sIFtdXTtcblxuICAgIC8vIGFzc3VtZSBsb2NhdGlvbnMgYXJlIGNvbnNpc3RlbnQgYmFzZWQgb24gZDNtIGRpcmVjdG9yeSBzdHJ1Y3R1cmVcbiAgICBsZXQgZDNtUm9vdFBhdGggPSAnJztcbiAgICBsZXQgZDNtRGF0YU5hbWUgPSAnJztcbiAgICBsZXQgZDNtRGF0YSA9IG51bGw7XG4gICAgbGV0IGQzbVByZXByb2Nlc3MgPSAnJztcbiAgICBsZXQgZDNtUFMgPSAnJztcbiAgICBsZXQgZDNtRFMgPSAnJztcblxuICAgIC8vIGRlZmF1bHQgdG8gRmVhcm9uIExhaXRpblxuICAgIGxldCBkYXRhID0gJ2RhdGEvJyArIChmYWxzZSA/ICdQVU1TNXNtYWxsJyA6ICdmZWFyb25MYWl0aW4nKTtcbiAgICBsZXQgbWV0YWRhdGF1cmwgPSBkZGl1cmwgfHwgKGZpbGVpZCA/IGAke2RhdGF2ZXJzZXVybH0vYXBpL21ldGEvZGF0YWZpbGUvJHtmaWxlaWR9YCA6IGRhdGEgKyAnLnhtbCcpO1xuICAgIC8vIHJlYWQgcHJlLXByb2Nlc3NlZCBtZXRhZGF0YSBhbmQgZGF0YVxuICAgIGxldCBwVVJMID0gZGF0YXVybCA/IGAke2RhdGF1cmx9JmZvcm1hdD1wcmVwYCA6IGRhdGEgKyAnLmpzb24nO1xuXG4gICAgaWYgKElTX0QzTV9ET01BSU4pIHtcbiAgICAgICAgcFVSTCA9IGQzbVByZXByb2Nlc3M7XG4gICAgfSBlbHNlIGlmICghUFJPRFVDVElPTikge1xuICAgICAgICB6cGFyYW1zLnpkYXRhdXJsID0gJ2RhdGEvZmVhcm9uTGFpdGluLnRzdic7XG4gICAgfVxuXG4gICAgbG9hZChob2xkLCBsYWJsQXJyYXksIGQzbVJvb3RQYXRoLCBkM21EYXRhTmFtZSwgZDNtUHJlcHJvY2VzcywgZDNtRGF0YSwgZDNtUFMsIGQzbURTLCBwVVJMKTtcbn1cblxubGV0ICRmaWxsID0gKG9iaiwgb3AsIGQxLCBkMikgPT4gZDMuc2VsZWN0KG9iaikudHJhbnNpdGlvbigpXG4gICAgLmF0dHIoJ2ZpbGwtb3BhY2l0eScsIG9wKVxuICAgIC5kZWxheShkMSlcbiAgICAuZHVyYXRpb24oZDIpO1xubGV0IGZpbGwgPSAoZCwgaWQsIG9wLCBkMSwgZDIpID0+ICRmaWxsKCcjJyArIGlkICsgZC5pZCwgb3AsIGQxLCBkMik7XG5sZXQgZmlsbFRoaXMgPSAoc2VsZiwgb3AsIGQxLCBkMikgPT4gJGZpbGwoc2VsZiwgb3AsIGQxLCBkMik7XG5cbi8qKlxuICAgZGVsZXRlcyB0aGUgaXRlbSBhdCBpbmRleCBmcm9tIGFycmF5LlxuICAgaWYgb2JqZWN0IGlzIHByb3ZpZGVkLCBkZWxldGVzIGZpcnN0IGluc3RhbmNlIG9mIG9iamVjdCBmcm9tIGFycmF5LlxuICAgQHBhcmFtIHtPYmplY3RbXX0gYXJyIC0gYXJyYXlcbiAgIEBwYXJhbSB7bnVtYmVyfSBpZHggLSBpbmRleFxuICAgQHBhcmFtIHtPYmplY3R9IFtvYmpdIC0gb2JqZWN0XG4qL1xuZnVuY3Rpb24gZGVsKGFyciwgaWR4LCBvYmopIHtcbiAgICBpZHggPSBvYmogPyBhcnIuaW5kZXhPZihvYmopIDogaWR4O1xuICAgIGlkeCA+IC0xICYmIGFyci5zcGxpY2UoaWR4LCAxKTtcbn1cblxuLyoqIG5lZWRzIGRvYyAqL1xuZnVuY3Rpb24genBhcmFtc1Jlc2V0KHRleHQpIHtcbiAgICAnemR2IHpjcm9zcyB6dGltZSB6bm9tJy5zcGxpdCgnICcpLmZvckVhY2goeCA9PiBkZWwoenBhcmFtc1t4XSwgLTEsIHRleHQpKTtcbn1cblxuLyoqIG5lZWRzIGRvYyAqL1xuZnVuY3Rpb24gbGF5b3V0KHYsIHYyKSB7XG4gICAgdmFyIG15VmFsdWVzID0gW107XG4gICAgbm9kZXMgPSBbXTtcbiAgICBsaW5rcyA9IFtdO1xuXG4gICAgc3ZnLmFwcGVuZChcInN2ZzpkZWZzXCIpLmFwcGVuZChcInN2ZzptYXJrZXJcIilcbiAgICAgICAgLmF0dHIoXCJpZFwiLCBcImdyb3VwMS1hcnJvd1wiKVxuICAgICAgICAuYXR0cigndmlld0JveCcsICcwIC01IDE1IDE1JylcbiAgICAgICAgLmF0dHIoXCJyZWZYXCIsIDIuNSlcbiAgICAgICAgLmF0dHIoXCJyZWZZXCIsIDApXG4gICAgICAgIC5hdHRyKFwibWFya2VyV2lkdGhcIiwgMylcbiAgICAgICAgLmF0dHIoXCJtYXJrZXJIZWlnaHRcIiwgMylcbiAgICAgICAgLmF0dHIoXCJvcmllbnRcIiwgXCJhdXRvXCIpXG4gICAgICAgIC5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgIC5hdHRyKCdkJywgJ00wLC01TDEwLDBMMCw1JylcbiAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBncjFDb2xvcik7XG4gICAgc3ZnLmFwcGVuZChcInN2ZzpkZWZzXCIpLmFwcGVuZChcInN2ZzptYXJrZXJcIilcbiAgICAgICAgLmF0dHIoXCJpZFwiLCBcImdyb3VwMi1hcnJvd1wiKVxuICAgICAgICAuYXR0cigndmlld0JveCcsICcwIC01IDE1IDE1JylcbiAgICAgICAgLmF0dHIoXCJyZWZYXCIsIDIuNSlcbiAgICAgICAgLmF0dHIoXCJyZWZZXCIsIDApXG4gICAgICAgIC5hdHRyKFwibWFya2VyV2lkdGhcIiwgMylcbiAgICAgICAgLmF0dHIoXCJtYXJrZXJIZWlnaHRcIiwgMylcbiAgICAgICAgLmF0dHIoXCJvcmllbnRcIiwgXCJhdXRvXCIpXG4gICAgICAgIC5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgIC5hdHRyKCdkJywgJ00wLC01TDEwLDBMMCw1JylcbiAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBncjJDb2xvcik7XG4gICAgc3ZnLmFwcGVuZCgnc3ZnOmRlZnMnKS5hcHBlbmQoJ3N2ZzptYXJrZXInKVxuICAgICAgICAuYXR0cignaWQnLCAnY2lyY2xlJylcbiAgICAgICAgLmNsYXNzZWQoJ2NpcmNsZV9zdGFydCcsIHRydWUpXG4gICAgICAgIC5hdHRyKCd2aWV3Qm94JywgJy02IC02IDEyIDEyJylcbiAgICAgICAgLmF0dHIoJ3JlZlgnLCAxKVxuICAgICAgICAuYXR0cigncmVmWScsIDEpXG4gICAgICAgIC5hdHRyKCdtYXJrZXJXaWR0aCcsIDQpXG4gICAgICAgIC5hdHRyKCdtYXJrZXJIZWlnaHQnLCA0KVxuICAgICAgICAuYXR0cignb3JpZW50JywgJ2F1dG8nKVxuICAgICAgICAuYXBwZW5kKCdzdmc6cGF0aCcpXG4gICAgICAgIC5hdHRyKCdkJywgJ00gMCwgMCAgbSAtNSwgMCAgYSA1LDUgMCAxLDAgMTAsMCAgYSA1LDUgMCAxLDAgLTEwLDAnKVxuICAgICAgICAuc3R5bGUoJ2ZpbGwnLCAnIzAwMCcpO1xuXG4gICAgdmFyIGxpbmUgPSBzdmcuYXBwZW5kKFwibGluZVwiKVxuICAgICAgICAuc3R5bGUoJ2ZpbGwnLCAnbm9uZScpXG4gICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgZ3IxQ29sb3IpXG4gICAgICAgIC5zdHlsZSgnc3Ryb2tlLXdpZHRoJywgNSlcbiAgICAgICAgLmF0dHIoXCJtYXJrZXItZW5kXCIsIFwidXJsKCNncm91cDEtYXJyb3cpXCIpO1xuXG4gICAgdmFyIGxpbmUyID0gc3ZnLmFwcGVuZChcImxpbmVcIilcbiAgICAgICAgLnN0eWxlKCdmaWxsJywgJ25vbmUnKVxuICAgICAgICAuc3R5bGUoJ3N0cm9rZScsIGdyMkNvbG9yKVxuICAgICAgICAuc3R5bGUoJ3N0cm9rZS13aWR0aCcsIDUpXG4gICAgICAgIC5hdHRyKFwibWFya2VyLWVuZFwiLCBcInVybCgjZ3JvdXAyLWFycm93KVwiKTs7XG5cbiAgICB2YXIgdmlzYmFja2dyb3VuZCA9IGQzLnNlbGVjdChcIiN3aGl0ZXNwYWNlXCIpLmFwcGVuZChcInN2Z1wiKVxuICAgICAgICAuYXR0cihcIndpZHRoXCIsIHdpZHRoKVxuICAgICAgICAuYXR0cihcImhlaWdodFwiLCBoZWlnaHQpO1xuXG4gICAgdmlzYmFja2dyb3VuZC5hcHBlbmQoXCJwYXRoXCIpIC8vIG5vdGUgbGluZXMsIGFyZSBiZWhpbmQgZ3JvdXAgaHVsbHMgb2Ygd2hpY2ggdGhlcmUgaXMgYSB3aGl0ZSBhbmQgY29sb3JlZCBzZW1pIHRyYW5zcGFyZW50IGxheWVyXG4gICAgICAgIC5hdHRyKFwiaWRcIiwgJ2dyMWJhY2tncm91bmQnKVxuICAgICAgICAuc3R5bGUoXCJmaWxsXCIsICcjZmZmZmZmJylcbiAgICAgICAgLnN0eWxlKFwic3Ryb2tlXCIsICcjZmZmZmZmJylcbiAgICAgICAgLnN0eWxlKFwic3Ryb2tlLXdpZHRoXCIsIDIuNSpSQURJVVMpXG4gICAgICAgIC5zdHlsZSgnc3Ryb2tlLWxpbmVqb2luJywncm91bmQnKVxuICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDEpO1xuXG4gICAgdmFyIHZpczJiYWNrZ3JvdW5kID0gZDMuc2VsZWN0KFwiI3doaXRlc3BhY2VcIikuYXBwZW5kKFwic3ZnXCIpXG4gICAgICAgIC5hdHRyKFwid2lkdGhcIiwgd2lkdGgpXG4gICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGhlaWdodCk7XG5cbiAgICB2aXMyYmFja2dyb3VuZC5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgIC5hdHRyKFwiaWRcIiwgJ2dyMWJhY2tncm91bmQnKVxuICAgICAgICAuc3R5bGUoXCJmaWxsXCIsICcjZmZmZmZmJylcbiAgICAgICAgLnN0eWxlKFwic3Ryb2tlXCIsICcjZmZmZmZmJylcbiAgICAgICAgLnN0eWxlKFwic3Ryb2tlLXdpZHRoXCIsIDIuNSpSQURJVVMpXG4gICAgICAgIC5zdHlsZSgnc3Ryb2tlLWxpbmVqb2luJywncm91bmQnKVxuICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDEpO1xuXG4gICAgdmFyIHZpcyA9IGQzLnNlbGVjdChcIiN3aGl0ZXNwYWNlXCIpLmFwcGVuZChcInN2Z1wiKVxuICAgICAgICAuYXR0cihcIndpZHRoXCIsIHdpZHRoKVxuICAgICAgICAuYXR0cihcImhlaWdodFwiLCBoZWlnaHQpO1xuXG4gICAgdmlzLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgLmF0dHIoXCJpZFwiLCAnZ3IxaHVsbCcpXG4gICAgICAgIC5zdHlsZShcImZpbGxcIiwgZ3IxQ29sb3IpXG4gICAgICAgIC5zdHlsZShcInN0cm9rZVwiLCBncjFDb2xvcilcbiAgICAgICAgLnN0eWxlKFwic3Ryb2tlLXdpZHRoXCIsIDIuNSpSQURJVVMpXG4gICAgICAgIC5zdHlsZSgnc3Ryb2tlLWxpbmVqb2luJywncm91bmQnKTtcblxuICAgIHZhciB2aXMyID0gZDMuc2VsZWN0KFwiI3doaXRlc3BhY2VcIikuYXBwZW5kKFwic3ZnXCIpXG4gICAgICAgIC5hdHRyKFwid2lkdGhcIiwgd2lkdGgpXG4gICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGhlaWdodCk7XG5cbiAgICB2aXMyLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBncjJDb2xvcilcbiAgICAgICAgLnN0eWxlKFwic3Ryb2tlXCIsIGdyMkNvbG9yKVxuICAgICAgICAuc3R5bGUoXCJzdHJva2Utd2lkdGhcIiwgMi41KlJBRElVUylcbiAgICAgICAgLnN0eWxlKCdzdHJva2UtbGluZWpvaW4nLCdyb3VuZCcpO1xuXG4gICAgaWYgKHYgPT0gbGF5b3V0QWRkIHx8IHYgPT0gbGF5b3V0TW92ZSkge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHpwYXJhbXMuenZhcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBpaSA9IGZpbmROb2RlSW5kZXgoenBhcmFtcy56dmFyc1tqXSk7XG4gICAgICAgICAgICBpZiAoYWxsTm9kZXNbaWldLmdyYXlvdXQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBub2Rlcy5wdXNoKGFsbE5vZGVzW2lpXSk7XG4gICAgICAgICAgICB2YXIgc2VsZWN0TWUgPSB6cGFyYW1zLnp2YXJzW2pdLnJlcGxhY2UoL1xcVy9nLCBcIl9cIik7XG4gICAgICAgICAgICBzZWxlY3RNZSA9IFwiI1wiLmNvbmNhdChzZWxlY3RNZSk7XG4gICAgICAgICAgICBkMy5zZWxlY3Qoc2VsZWN0TWUpLnN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJywgKCkgPT4gaGV4VG9SZ2JhKG5vZGVzW2pdLnN0cm9rZUNvbG9yKSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHpwYXJhbXMuemVkZ2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgbXlzcmMgPSBub2RlSW5kZXgoenBhcmFtcy56ZWRnZXNbal1bMF0pO1xuICAgICAgICAgICAgdmFyIG15dGd0ID0gbm9kZUluZGV4KHpwYXJhbXMuemVkZ2VzW2pdWzFdKTtcbiAgICAgICAgICAgIGxpbmtzLnB1c2goe1xuICAgICAgICAgICAgICAgIHNvdXJjZTogbm9kZXNbbXlzcmNdLFxuICAgICAgICAgICAgICAgIHRhcmdldDogbm9kZXNbbXl0Z3RdLFxuICAgICAgICAgICAgICAgIGxlZnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmKElTX0QzTV9ET01BSU4pIHtcbiAgICAgICAgICAgIC8vbm9kZXMgPSBbZmluZE5vZGUobXl0YXJnZXQpXTsgICAgICAgICAgICAgICAvLyBPbmx5IGFkZCBkZXBlbmRlbnQgdmFyaWFibGUgb24gc3RhcnR1cFxuICAgICAgICAgICAgbm9kZXMgPSBhbGxOb2Rlcy5zbGljZSgxLGFsbE5vZGVzLmxlbmd0aCk7ICAgIC8vIEFkZCBhbGwgYnV0IGZpcnN0IHZhcmlhYmxlIG9uIHN0YXJ0dXAgKGFzc3VtZXMgMCBwb3NpdGlvbiBpcyBkM20gaW5kZXggdmFyaWFibGUpXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG5vZGVzLmxlbmd0aDsgaisrKSB7IC8vcG9wdWxhdGUgenZhcnMgYXJyYXlcbiAgICAgICAgICAgICAgICBpZiAobm9kZXNbal0ubmFtZSAhPSBteXRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICBub2Rlc1tqXS5ncm91cDEgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB6cGFyYW1zLnpncm91cDEucHVzaChub2Rlc1tqXS5uYW1lKTsgIC8vIHdyaXRlIGFsbCBuYW1lcyAoZXhjZXB0IGQzbSBpbmRleCBhbmQgdGhlIGRlcGVuZGVudCB2YXJpYWJsZSkgdG8gemdyb3VwMSBhcnJheVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGFsbE5vZGVzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIG5vZGVzID0gW2FsbE5vZGVzWzBdLCBhbGxOb2Rlc1sxXSwgYWxsTm9kZXNbMl1dO1xuICAgICAgICAgICAgbGlua3MgPSBbe1xuICAgICAgICAgICAgICAgIHNvdXJjZTogbm9kZXNbMV0sXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBub2Rlc1swXSxcbiAgICAgICAgICAgICAgICBsZWZ0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICByaWdodDogdHJ1ZVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHNvdXJjZTogbm9kZXNbMF0sXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBub2Rlc1syXSxcbiAgICAgICAgICAgICAgICBsZWZ0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICByaWdodDogdHJ1ZVxuICAgICAgICAgICAgfV07XG4gICAgICAgIH0gZWxzZSBpZiAoYWxsTm9kZXMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICBub2RlcyA9IFthbGxOb2Rlc1swXSwgYWxsTm9kZXNbMV1dO1xuICAgICAgICAgICAgbGlua3MgPSBbe1xuICAgICAgICAgICAgICAgIHNvdXJjZTogbm9kZXNbMV0sXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBub2Rlc1swXSxcbiAgICAgICAgICAgICAgICBsZWZ0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICByaWdodDogdHJ1ZVxuICAgICAgICAgICAgfV07XG4gICAgICAgIH0gZWxzZSBpZiAoYWxsTm9kZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBub2RlcyA9IFthbGxOb2Rlc1swXV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbGVydChcIlRoZXJlIGFyZSB6ZXJvIHZhcmlhYmxlcyBpbiB0aGUgbWV0YWRhdGEuXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcGFuZWxQbG90cygpOyAvLyBhZnRlciBub2RlcyBpcyBwb3B1bGF0ZWQsIGFkZCBzdWJzZXQgYW5kIChpZiAhSVNfRDNNX0RPTUFJTikgc2V0eCBwYW5lbHNcblxuICAgIHZhciBmb3JjZSA9IGQzLmxheW91dC5mb3JjZSgpXG4gICAgICAgIC5ub2Rlcyhub2RlcylcbiAgICAgICAgLmxpbmtzKGxpbmtzKVxuICAgICAgICAuc2l6ZShbd2lkdGgsIGhlaWdodF0pXG4gICAgICAgIC5saW5rRGlzdGFuY2UoMTUwKVxuICAgICAgICAuY2hhcmdlKC04MDApXG4gICAgICAgIC5vbigndGljaycsIHRpY2spO1xuXG4gICAgLy8gZGVmaW5lIGFycm93IG1hcmtlcnMgZm9yIGdyYXBoIGxpbmtzXG4gICAgc3ZnLmFwcGVuZCgnc3ZnOmRlZnMnKS5hcHBlbmQoJ3N2ZzptYXJrZXInKVxuICAgICAgICAuYXR0cignaWQnLCAnZW5kLWFycm93JylcbiAgICAgICAgLmF0dHIoJ3ZpZXdCb3gnLCAnMCAtNSAxMCAxMCcpXG4gICAgICAgIC5hdHRyKCdyZWZYJywgNilcbiAgICAgICAgLmF0dHIoJ21hcmtlcldpZHRoJywgMylcbiAgICAgICAgLmF0dHIoJ21hcmtlckhlaWdodCcsIDMpXG4gICAgICAgIC5hdHRyKCdvcmllbnQnLCAnYXV0bycpXG4gICAgICAgIC5hcHBlbmQoJ3N2ZzpwYXRoJylcbiAgICAgICAgLmF0dHIoJ2QnLCAnTTAsLTVMMTAsMEwwLDUnKVxuICAgICAgICAuc3R5bGUoJ2ZpbGwnLCAnIzAwMCcpO1xuXG4gICAgc3ZnLmFwcGVuZCgnc3ZnOmRlZnMnKS5hcHBlbmQoJ3N2ZzptYXJrZXInKVxuICAgICAgICAuYXR0cignaWQnLCAnc3RhcnQtYXJyb3cnKVxuICAgICAgICAuYXR0cigndmlld0JveCcsICcwIC01IDEwIDEwJylcbiAgICAgICAgLmF0dHIoJ3JlZlgnLCA0KVxuICAgICAgICAuYXR0cignbWFya2VyV2lkdGgnLCAzKVxuICAgICAgICAuYXR0cignbWFya2VySGVpZ2h0JywgMylcbiAgICAgICAgLmF0dHIoJ29yaWVudCcsICdhdXRvJylcbiAgICAgICAgLmFwcGVuZCgnc3ZnOnBhdGgnKVxuICAgICAgICAuYXR0cignZCcsICdNMTAsLTVMMCwwTDEwLDUnKVxuICAgICAgICAuc3R5bGUoJ2ZpbGwnLCAnIzAwMCcpO1xuXG4gICAgLy8gbGluZSBkaXNwbGF5ZWQgd2hlbiBkcmFnZ2luZyBuZXcgbm9kZXNcbiAgICB2YXIgZHJhZ19saW5lID0gc3ZnLmFwcGVuZCgnc3ZnOnBhdGgnKVxuICAgICAgICAuYXR0cignY2xhc3MnLCAnbGluayBkcmFnbGluZSBoaWRkZW4nKVxuICAgICAgICAuYXR0cignZCcsICdNMCwwTDAsMCcpO1xuXG4gICAgLy8gaGFuZGxlcyB0byBsaW5rIGFuZCBub2RlIGVsZW1lbnQgZ3JvdXBzXG4gICAgdmFyIHBhdGggPSBzdmcuYXBwZW5kKCdzdmc6ZycpLnNlbGVjdEFsbCgncGF0aCcpLFxuICAgICAgICBjaXJjbGUgPSBzdmcuYXBwZW5kKCdzdmc6ZycpLnNlbGVjdEFsbCgnZycpO1xuICAgICAgICAvL2xpbmUgPSBzdmcuYXBwZW5kKCdzdmc6ZycpLnNlbGVjdEFsbCgnbGluZScpO1xuXG4gICAgLy8gbW91c2UgZXZlbnQgdmFyc1xuICAgIHZhciBzZWxlY3RlZF9ub2RlID0gbnVsbCxcbiAgICAgICAgc2VsZWN0ZWRfbGluayA9IG51bGwsXG4gICAgICAgIG1vdXNlZG93bl9saW5rID0gbnVsbCxcbiAgICAgICAgbW91c2Vkb3duX25vZGUgPSBudWxsLFxuICAgICAgICBtb3VzZXVwX25vZGUgPSBudWxsO1xuXG4gICAgZnVuY3Rpb24gcmVzZXRNb3VzZVZhcnMoKSB7XG4gICAgICAgIG1vdXNlZG93bl9ub2RlID0gbnVsbDtcbiAgICAgICAgbW91c2V1cF9ub2RlID0gbnVsbDtcbiAgICAgICAgbW91c2Vkb3duX2xpbmsgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSBmb3JjZSBsYXlvdXQgKGNhbGxlZCBhdXRvbWF0aWNhbGx5IGVhY2ggaXRlcmF0aW9uKVxuICAgIGZ1bmN0aW9uIHRpY2soKSB7XG4gICAgICAgIGZ1bmN0aW9uIGZpbmRjb29yZHMoZmluZG5hbWVzLGFsbG5hbWVzLGNvb3JkcyxsZW5ndGhlbil7XG4gICAgICAgICAgICB2YXIgZmNvb3JkcyA9IG5ldyBBcnJheShmaW5kbmFtZXMubGVuZ3RoKTsgICAvLyBmb3VuZCBjb29yZGluYXRlc1xuICAgICAgICAgICAgdmFyIGFkZGxvY2F0aW9uID0gMDtcbiAgICAgICAgICAgIGlmKGZpbmRuYW1lcy5sZW5ndGg+MCl7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBmaW5kbmFtZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkbG9jYXRpb24gPSBhbGxuYW1lcy5pbmRleE9mKGZpbmRuYW1lc1tqXSk7XG4gICAgICAgICAgICAgICAgICAgIGZjb29yZHNbal0gPSBjb29yZHNbYWRkbG9jYXRpb25dO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZihsZW5ndGhlbil7XG4gICAgICAgICAgICAgICAgLy8gZDMuZ2VvbS5odWxsIHJldHVybnMgbnVsbCBmb3IgdHdvIHBvaW50cywgYW5kIGZhaWxzIGlmIHRocmVlIHBvaW50cyBhcmUgaW4gYSBsaW5lLFxuICAgICAgICAgICAgICAgIC8vIHNvIHRoaXMgcHV0cyBhIGNvdXBsZSBwb2ludHMgc2xpZ2h0bHkgb2ZmIHRoZSBsaW5lIGZvciB0d28gcG9pbnRzLCBvciBhcm91bmQgYSBzaW5nbGV0b24uXG4gICAgICAgICAgICAgICAgaWYgKGZjb29yZHMubGVuZ3RoID09IDIpe1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVsdGF4ID0gZmNvb3Jkc1swXVswXS0gZmNvb3Jkc1sxXVswXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlbHRheSA9IGZjb29yZHNbMF1bMV0tIGZjb29yZHNbMV1bMV07XG4gICAgICAgICAgICAgICAgICAgIGZjb29yZHMucHVzaChbKGZjb29yZHNbMF1bMF0gKyBmY29vcmRzWzFdWzBdKS8yICsgZGVsdGF5LzIwLCAoZmNvb3Jkc1swXVsxXSsgZmNvb3Jkc1sxXVsxXSkvMiArIGRlbHRheC8yMF0pO1xuICAgICAgICAgICAgICAgICAgICBmY29vcmRzLnB1c2goWyhmY29vcmRzWzBdWzBdICsgZmNvb3Jkc1sxXVswXSkvMiAtIGRlbHRheS8yMCwgKGZjb29yZHNbMF1bMV0rIGZjb29yZHNbMV1bMV0pLzIgLSBkZWx0YXgvMjBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZjb29yZHMubGVuZ3RoID09IDEpe1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVsdGEgPSBSQURJVVMgKiAwLjI7XG4gICAgICAgICAgICAgICAgICAgIGZjb29yZHMucHVzaChbZmNvb3Jkc1swXVswXSArIGRlbHRhLCBmY29vcmRzWzBdWzFdXSk7XG4gICAgICAgICAgICAgICAgICAgIGZjb29yZHMucHVzaChbZmNvb3Jkc1swXVswXSAtIGRlbHRhLCBmY29vcmRzWzBdWzFdXSk7XG4gICAgICAgICAgICAgICAgICAgIGZjb29yZHMucHVzaChbZmNvb3Jkc1swXVswXSwgZmNvb3Jkc1swXVsxXSArIGRlbHRhXSk7XG4gICAgICAgICAgICAgICAgICAgIGZjb29yZHMucHVzaChbZmNvb3Jkc1swXVswXSwgZmNvb3Jkc1swXVsxXSAtIGRlbHRhXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChmY29vcmRzKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBkMy5nZW9tLmh1bGwgcmV0dXJucyBudWxsIGZvciB0d28gcG9pbnRzLCBhbmQgZmFpbHMgaWYgdGhyZWUgcG9pbnRzIGFyZSBpbiBhIGxpbmUsXG4gICAgICAgIC8vIHNvIHRoaXMgcHV0cyBhIGNvdXBsZSBwb2ludHMgc2xpZ2h0bHkgb2ZmIHRoZSBsaW5lIGZvciB0d28gcG9pbnRzLCBvciBhcm91bmQgYSBzaW5nbGV0b24uXG4gICAgICAgIGZ1bmN0aW9uIGxlbmd0aGVuY29vcmRzKGNvb3Jkcyl7XG4gICAgICAgICAgICBpZiAoY29vcmRzLmxlbmd0aCA9PSAyKXtcbiAgICAgICAgICAgICAgICB2YXIgZGVsdGF4ID0gY29vcmRzWzBdWzBdLSBjb29yZHNbMV1bMF07XG4gICAgICAgICAgICAgICAgdmFyIGRlbHRheSA9IGNvb3Jkc1swXVsxXS0gY29vcmRzWzFdWzFdO1xuICAgICAgICAgICAgICAgIGNvb3Jkcy5wdXNoKFsoY29vcmRzWzBdWzBdICsgY29vcmRzWzFdWzBdKS8yICsgZGVsdGF5LzIwLCAoY29vcmRzWzBdWzFdKyBjb29yZHNbMV1bMV0pLzIgKyBkZWx0YXgvMjBdKTtcbiAgICAgICAgICAgICAgICBjb29yZHMucHVzaChbKGNvb3Jkc1swXVswXSArIGNvb3Jkc1sxXVswXSkvMiAtIGRlbHRheS8yMCwgKGNvb3Jkc1swXVsxXSsgY29vcmRzWzFdWzFdKS8yIC0gZGVsdGF4LzIwXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29vcmRzLmxlbmd0aCA9PSAxKXtcbiAgICAgICAgICAgICAgICB2YXIgZGVsdGEgPSBSQURJVVMgKiAwLjI7XG4gICAgICAgICAgICAgICAgY29vcmRzLnB1c2goW2Nvb3Jkc1swXVswXSArIGRlbHRhLCBjb29yZHNbMF1bMV1dKTtcbiAgICAgICAgICAgICAgICBjb29yZHMucHVzaChbY29vcmRzWzBdWzBdIC0gZGVsdGEsIGNvb3Jkc1swXVsxXV0pO1xuICAgICAgICAgICAgICAgIGNvb3Jkcy5wdXNoKFtjb29yZHNbMF1bMF0sIGNvb3Jkc1swXVsxXSArIGRlbHRhXSk7XG4gICAgICAgICAgICAgICAgY29vcmRzLnB1c2goW2Nvb3Jkc1swXVswXSwgY29vcmRzWzBdWzFdIC0gZGVsdGFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoY29vcmRzKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgY29vcmRzID0gbm9kZXMubWFwKGZ1bmN0aW9uKGQpIHsgIHJldHVybiBbIGQueCwgZC55XTsgfSk7XG4gICAgICAgIHZhciBncjFjb29yZHMgPSBmaW5kY29vcmRzKHpwYXJhbXMuemdyb3VwMSwgenBhcmFtcy56dmFycywgY29vcmRzLCB0cnVlKTtcbiAgICAgICAgdmFyIGdyMmNvb3JkcyA9IGZpbmRjb29yZHMoenBhcmFtcy56Z3JvdXAyLCB6cGFyYW1zLnp2YXJzLCBjb29yZHMsIHRydWUpO1xuICAgICAgICB2YXIgZGVwY29vcmRzID0gZmluZGNvb3Jkcyh6cGFyYW1zLnpkdiwgenBhcmFtcy56dmFycywgY29vcmRzLCBmYWxzZSk7XG5cbiAgICAgICAgLy8gZHJhdyBjb252ZXggaHVsbCBhcm91bmQgaW5kZXBlbmRlbnQgdmFyaWFibGVzLCBpZiB0aHJlZSBvciBtb3JlIGNvb3JkaW5hdGVzIGdpdmVuXG4gICAgICAgIC8vIG5vdGUsIGQzLmdlb20uaHVsbCByZXR1cm5zIG51bGwgaWYgc2hvcnRlciBjb29yZGluYXRlIHNldCB0aGFuIDMsXG4gICAgICAgIC8vIHNvIGZpbmRjb29yZHMoKSBmdW5jdGlvbiBoYXMgb3B0aW9uIHRvIGxlbmd0aGVuIHRoZSBjb29yZGluYXRlcyByZXR1cm5lZCB0byBieXBhc3MgdGhpc1xuICAgICAgICBpZihncjFjb29yZHMubGVuZ3RoID4gMil7XG4gICAgICAgICAgICBsaW5lLnN0eWxlKFwib3BhY2l0eVwiLCAxKTtcbiAgICAgICAgICAgIHZpc2JhY2tncm91bmQuc3R5bGUoXCJvcGFjaXR5XCIsIDEpO1xuICAgICAgICAgICAgdmlzLnN0eWxlKFwib3BhY2l0eVwiLCAwLjMpO1xuICAgICAgICAgICAgdmFyIG15aHVsbCA9IGQzLmdlb20uaHVsbChncjFjb29yZHMpO1xuXG4gICAgICAgICAgICB2aXMuc2VsZWN0QWxsKFwicGF0aFwiKVxuICAgICAgICAgICAgICAgIC5kYXRhKFtteWh1bGxdKSAgIC8vIHJldHVybnMgbnVsbCBpZiBsZXNzIHRoYW4gdGhyZWUgY29vcmRpbmF0ZXNcbiAgICAgICAgICAgICAgICAuYXR0cihcImRcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gXCJNXCIgKyBkLmpvaW4oXCJMXCIpICsgXCJaXCI7IH0pO1xuICAgICAgICAgICAgdmlzYmFja2dyb3VuZC5zZWxlY3RBbGwoXCJwYXRoXCIpXG4gICAgICAgICAgICAgICAgLmRhdGEoW215aHVsbF0pICAgLy8gcmV0dXJucyBudWxsIGlmIGxlc3MgdGhhbiB0aHJlZSBjb29yZGluYXRlc1xuICAgICAgICAgICAgICAgIC5hdHRyKFwiZFwiLCBmdW5jdGlvbihkKSB7IHJldHVybiBcIk1cIiArIGQuam9pbihcIkxcIikgKyBcIlpcIjsgfSk7XG5cbiAgICAgICAgICAgIC8vdmFyIHAgPSBkMy5nZW9tLnBvbHlnb24oaW5kY29vcmRzKS5jZW50cm9pZCgpOyAgLy8gU2VlbXMgdG8gZ28gc3RyYW5nZSBzb21ldGltZXNcbiAgICAgICAgICAgIHZhciBwID0gamFtZXNjZW50cm9pZChncjFjb29yZHMpO1xuXG4gICAgICAgICAgICBpZihkZXBjb29yZHMubGVuZ3RoPjApe1xuICAgICAgICAgICAgICAgIHZhciBxID0gZGVwY29vcmRzWzBdOyAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3RlLCBvbmx5IHVzaW5nIGZpcnN0IGRlcCB2YXIgY3VycmVudGx5XG4gICAgICAgICAgICAgICAgLy92YXIgciA9IGZpbmRib3VuZGFyeShwLHEsZ3IxY29vcmRzKTsgICAgICAgIC8vIEFuIGFwcHJvYWNoIHRvIGZpbmQgdGhlIGV4YWN0IGJvdW5kYXJ5LCBub3QgcHJlc2VudGx5IHdvcmtpbmdcbiAgICAgICAgICAgICAgICB2YXIgbGRlbHRhWCA9IHFbMF0gLSBwWzBdLFxuICAgICAgICAgICAgICAgICAgICBsZGVsdGFZID0gcVsxXSAtIHBbMV0sXG4gICAgICAgICAgICAgICAgICAgIGxkaXN0ID0gTWF0aC5zcXJ0KGxkZWx0YVggKiBsZGVsdGFYICsgbGRlbHRhWSAqIGxkZWx0YVkpLFxuICAgICAgICAgICAgICAgICAgICBsbm9ybVggPSAwLFxuICAgICAgICAgICAgICAgICAgICBsbm9ybVkgPSAwLFxuICAgICAgICAgICAgICAgICAgICBsc291cmNlUGFkZGluZyA9IFJBRElVUyArIDcsXG4gICAgICAgICAgICAgICAgICAgIGx0YXJnZXRQYWRkaW5nID0gUkFESVVTICsgMTA7XG5cbiAgICAgICAgICAgICAgICBpZiAobGRpc3QgPiAwKXtcbiAgICAgICAgICAgICAgICAgICAgbG5vcm1YID0gbGRlbHRhWCAvIGxkaXN0O1xuICAgICAgICAgICAgICAgICAgICBsbm9ybVkgPSBsZGVsdGFZIC8gbGRpc3Q7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGxpbmUuYXR0cihcIngxXCIsIHBbMF0gKyAobHNvdXJjZVBhZGRpbmcgKiBsbm9ybVgpKSAgIC8vIG9yIHJbMF0gaWYgZmluZGJvdW5kYXJ5IHdvcmtzXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieTFcIiwgcFsxXSArIChsc291cmNlUGFkZGluZyAqIGxub3JtWSkpICAgLy8gb3IgclsxXSBpZiBmaW5kYm91bmRhcnkgd29ya3NcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ4MlwiLCBxWzBdLSAobHRhcmdldFBhZGRpbmcgKiBsbm9ybVgpKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcInkyXCIsIHFbMV0tIChsdGFyZ2V0UGFkZGluZyAqIGxub3JtWSkpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gZ3JvdXAgbWVtYmVycyBhdHRyYWN0IGVhY2ggb3RoZXIsIHJlcHVsc2Ugbm9uLWdyb3VwIG1lbWJlcnNcbiAgICAgICAgICAgIG5vZGVzLmZvckVhY2gobiA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIHNpZ24gPSAobi5ncm91cDEpID8gMSA6IC0xOyAgICAvL3dhczogTWF0aC5zaWduKCB6cGFyYW1zLnpncm91cDEuaW5kZXhPZihuLm5hbWUpICswLjUgKTsgIC8vIDEgaWYgbiBpbiBncm91cCwgLTEgaWYgbiBub3QgaW4gZ3JvdXA7XG4gICAgICAgICAgICAgICAgdmFyIGxkZWx0YVggPSBwWzBdIC0gbi54LFxuICAgICAgICAgICAgICAgICAgICBsZGVsdGFZID0gcFsxXSAtIG4ueSxcbiAgICAgICAgICAgICAgICAgICAgbGRpc3QgPSBNYXRoLnNxcnQobGRlbHRhWCAqIGxkZWx0YVggKyBsZGVsdGFZICogbGRlbHRhWSk7XG4gICAgICAgICAgICAgICAgICAgIGxub3JtWCA9IDAsXG4gICAgICAgICAgICAgICAgICAgIGxub3JtWSA9IDA7XG5cbiAgICAgICAgICAgICAgICBpZiAobGRpc3QgPiAwKXtcbiAgICAgICAgICAgICAgICAgICAgbG5vcm1YID0gbGRlbHRhWCAvIGxkaXN0O1xuICAgICAgICAgICAgICAgICAgICBsbm9ybVkgPSBsZGVsdGFZIC8gbGRpc3Q7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIG4ueCArPSBNYXRoLm1pbihsbm9ybVggLCBsZGVsdGFYLzEwMCApICogayAqIHNpZ24gICAqIGZvcmNlLmFscGhhKCk7XG4gICAgICAgICAgICAgICAgbi55ICs9IE1hdGgubWluKGxub3JtWSAsIGxkZWx0YVkvMTAwICkgKiBrICogc2lnbiAgICogZm9yY2UuYWxwaGEoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2aXNiYWNrZ3JvdW5kLnN0eWxlKFwib3BhY2l0eVwiLCAwKTtcbiAgICAgICAgICAgIHZpcy5zdHlsZShcIm9wYWNpdHlcIiwgMCk7XG4gICAgICAgICAgICBsaW5lLnN0eWxlKFwib3BhY2l0eVwiLCAwKTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZihncjJjb29yZHMubGVuZ3RoID4gMil7XG4gICAgICAgICAgICBsaW5lMi5zdHlsZShcIm9wYWNpdHlcIiwgMSk7XG4gICAgICAgICAgICB2aXMyYmFja2dyb3VuZC5zdHlsZShcIm9wYWNpdHlcIiwgMSk7XG4gICAgICAgICAgICB2aXMyLnN0eWxlKFwib3BhY2l0eVwiLCAwLjMpO1xuICAgICAgICAgICAgdmFyIG15aHVsbCA9IGQzLmdlb20uaHVsbChncjJjb29yZHMpO1xuICAgICAgICAgICAgdmlzMi5zZWxlY3RBbGwoXCJwYXRoXCIpXG4gICAgICAgICAgICAgICAgLmRhdGEoW215aHVsbF0pICAgLy8gcmV0dXJucyBudWxsIGlmIGxlc3MgdGhhbiB0aHJlZSBjb29yZGluYXRlc1xuICAgICAgICAgICAgICAgIC5hdHRyKFwiZFwiLCBmdW5jdGlvbihkKSB7IHJldHVybiBcIk1cIiArIGQuam9pbihcIkxcIikgKyBcIlpcIjsgfSk7XG4gICAgICAgICAgICB2aXMyYmFja2dyb3VuZC5zZWxlY3RBbGwoXCJwYXRoXCIpXG4gICAgICAgICAgICAgICAgLmRhdGEoW215aHVsbF0pICAgLy8gcmV0dXJucyBudWxsIGlmIGxlc3MgdGhhbiB0aHJlZSBjb29yZGluYXRlc1xuICAgICAgICAgICAgICAgIC5hdHRyKFwiZFwiLCBmdW5jdGlvbihkKSB7IHJldHVybiBcIk1cIiArIGQuam9pbihcIkxcIikgKyBcIlpcIjsgfSk7XG5cbiAgICAgICAgICAgIC8vdmFyIHAgPSBkMy5nZW9tLnBvbHlnb24oaW5kY29vcmRzKS5jZW50cm9pZCgpOyAgLy8gU2VlbXMgdG8gZ28gc3RyYW5nZSBzb21ldGltZXNcbiAgICAgICAgICAgIHZhciBwID0gamFtZXNjZW50cm9pZChncjJjb29yZHMpO1xuXG4gICAgICAgICAgICBpZihkZXBjb29yZHMubGVuZ3RoPjApe1xuICAgICAgICAgICAgICAgIHZhciBxID0gZGVwY29vcmRzWzBdOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90ZSwgb25seSB1c2luZyBmaXJzdCBkZXAgdmFyIGN1cnJlbnRseVxuICAgICAgICAgICAgICAgIHZhciBsZGVsdGFYID0gcVswXSAtIHBbMF0sXG4gICAgICAgICAgICAgICAgICAgIGxkZWx0YVkgPSBxWzFdIC0gcFsxXSxcbiAgICAgICAgICAgICAgICAgICAgbGRpc3QgPSBNYXRoLnNxcnQobGRlbHRhWCAqIGxkZWx0YVggKyBsZGVsdGFZICogbGRlbHRhWSksXG4gICAgICAgICAgICAgICAgICAgIGxub3JtWCA9IGxkZWx0YVggLyBsZGlzdCxcbiAgICAgICAgICAgICAgICAgICAgbG5vcm1ZID0gbGRlbHRhWSAvIGxkaXN0LFxuICAgICAgICAgICAgICAgICAgICBsc291cmNlUGFkZGluZyA9IFJBRElVUyArIDcsXG4gICAgICAgICAgICAgICAgICAgIGx0YXJnZXRQYWRkaW5nID0gUkFESVVTICsgMTA7XG5cbiAgICAgICAgICAgICAgICBsaW5lMi5hdHRyKFwieDFcIiwgcFswXSArIChsc291cmNlUGFkZGluZyAqIGxub3JtWCkpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieTFcIiwgcFsxXSArIChsc291cmNlUGFkZGluZyAqIGxub3JtWSkpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieDJcIiwgcVswXS0gKGx0YXJnZXRQYWRkaW5nICogbG5vcm1YKSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ5MlwiLCBxWzFdLSAobHRhcmdldFBhZGRpbmcgKiBsbm9ybVkpKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIGdyb3VwIG1lbWJlcnMgYXR0cmFjdCBlYWNoIG90aGVyLCByZXB1bHNlIG5vbi1ncm91cCBtZW1iZXJzXG4gICAgICAgICAgICBub2Rlcy5mb3JFYWNoKG4gPT4ge1xuICAgICAgICAgICAgICAgIHZhciBzaWduID0gKG4uZ3JvdXAyKSA/IDEgOiAtMTsgIC8vIHdhczogTWF0aC5zaWduKCB6cGFyYW1zLnpncm91cDIuaW5kZXhPZihuLm5hbWUpICswLjUgKTsgIC8vIDEgaWYgbiBpbiBncm91cCwgLTEgaWYgbiBub3QgaW4gZ3JvdXA7XG4gICAgICAgICAgICAgICAgdmFyIGxkZWx0YVggPSBwWzBdIC0gbi54LFxuICAgICAgICAgICAgICAgICAgICBsZGVsdGFZID0gcFsxXSAtIG4ueSxcbiAgICAgICAgICAgICAgICAgICAgbGRpc3QgPSBNYXRoLnNxcnQobGRlbHRhWCAqIGxkZWx0YVggKyBsZGVsdGFZICogbGRlbHRhWSksXG4gICAgICAgICAgICAgICAgICAgIGxub3JtWCA9IDAsXG4gICAgICAgICAgICAgICAgICAgIGxub3JtWSA9IDA7XG5cbiAgICAgICAgICAgICAgICBpZiAobGRpc3QgPiAwKXtcbiAgICAgICAgICAgICAgICAgICAgbG5vcm1YID0gbGRlbHRhWCAvIGxkaXN0O1xuICAgICAgICAgICAgICAgICAgICBsbm9ybVkgPSBsZGVsdGFZIC8gbGRpc3Q7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIG4ueCArPSBNYXRoLm1pbihsbm9ybVggLCBsZGVsdGFYLzEwMCApICogayAqIHNpZ24gICAqIGZvcmNlLmFscGhhKCk7XG4gICAgICAgICAgICAgICAgbi55ICs9IE1hdGgubWluKGxub3JtWSAsIGxkZWx0YVkvMTAwICkgKiBrICogc2lnbiAgICogZm9yY2UuYWxwaGEoKTtcbiAgICAgICAgICAgIH0pO1xuXG5cbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICB2aXMyYmFja2dyb3VuZC5zdHlsZShcIm9wYWNpdHlcIiwgMCk7XG4gICAgICAgICAgICB2aXMyLnN0eWxlKFwib3BhY2l0eVwiLCAwKTtcbiAgICAgICAgICAgIGxpbmUyLnN0eWxlKFwib3BhY2l0eVwiLCAwKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBkcmF3IGRpcmVjdGVkIGVkZ2VzIHdpdGggcHJvcGVyIHBhZGRpbmcgZnJvbSBub2RlIGNlbnRlcnNcbiAgICAgICAgcGF0aC5hdHRyKCdkJywgZCA9PiB7XG4gICAgICAgICAgICB2YXIgZGVsdGFYID0gZC50YXJnZXQueCAtIGQuc291cmNlLngsXG4gICAgICAgICAgICAgICAgZGVsdGFZID0gZC50YXJnZXQueSAtIGQuc291cmNlLnksXG4gICAgICAgICAgICAgICAgZGlzdCA9IE1hdGguc3FydChkZWx0YVggKiBkZWx0YVggKyBkZWx0YVkgKiBkZWx0YVkpLFxuICAgICAgICAgICAgICAgIG5vcm1YID0gZGVsdGFYIC8gZGlzdCxcbiAgICAgICAgICAgICAgICBub3JtWSA9IGRlbHRhWSAvIGRpc3QsXG4gICAgICAgICAgICAgICAgc291cmNlUGFkZGluZyA9IGQubGVmdCA/IFJBRElVUyArIDUgOiBSQURJVVMsXG4gICAgICAgICAgICAgICAgdGFyZ2V0UGFkZGluZyA9IGQucmlnaHQgPyBSQURJVVMgKyA1IDogUkFESVVTLFxuICAgICAgICAgICAgICAgIHNvdXJjZVggPSBkLnNvdXJjZS54ICsgKHNvdXJjZVBhZGRpbmcgKiBub3JtWCksXG4gICAgICAgICAgICAgICAgc291cmNlWSA9IGQuc291cmNlLnkgKyAoc291cmNlUGFkZGluZyAqIG5vcm1ZKSxcbiAgICAgICAgICAgICAgICB0YXJnZXRYID0gZC50YXJnZXQueCAtICh0YXJnZXRQYWRkaW5nICogbm9ybVgpLFxuICAgICAgICAgICAgICAgIHRhcmdldFkgPSBkLnRhcmdldC55IC0gKHRhcmdldFBhZGRpbmcgKiBub3JtWSk7XG4gICAgICAgICAgICByZXR1cm4gYE0ke3NvdXJjZVh9LCR7c291cmNlWX1MJHt0YXJnZXRYfSwke3RhcmdldFl9YDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY2lyY2xlLmF0dHIoJ3RyYW5zZm9ybScsIGQgPT4gJ3RyYW5zbGF0ZSgnICsgZC54ICsgJywnICsgZC55ICsgJyknKTtcblxuICAgICAgICBjaXJjbGUuc2VsZWN0QWxsKCdjaXJjbGUnKSAgICAgICAgICAgLy8gU2hyaW5rL2V4cGFuZCBwZWJibGVzIHRoYXQgam9pbi9sZWF2ZSBncm91cHNcbiAgICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgIC5kdXJhdGlvbigxMDApXG4gICAgICAgICAgICAuYXR0cigncicsIGQgPT4gc2V0UGViYmxlUmFkaXVzKGQpKTtcblxuICAgIH1cblxuICAgIGQzLnNlbGVjdChcIiNtb2RlbHNcIikuc2VsZWN0QWxsKFwicFwiKSAvLyBtb2RlbHMgdGFiXG4gICAgICAgIC8vICBkMy5zZWxlY3QoXCIjRGlzcGxheV9jb250ZW50XCIpXG4gICAgICAgIC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIG15Q29sb3IgPSBkMy5zZWxlY3QodGhpcykuc3R5bGUoJ2JhY2tncm91bmQtY29sb3InKTtcbiAgICAgICAgICAgIGQzLnNlbGVjdChcIiNtb2RlbHNcIikuc2VsZWN0QWxsKFwicFwiKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnYmFja2dyb3VuZC1jb2xvcicsIHZhckNvbG9yKTtcbiAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnYmFja2dyb3VuZC1jb2xvcicsIGQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZDMucmdiKG15Q29sb3IpLnRvU3RyaW5nKCkgPT09IHZhckNvbG9yLnRvU3RyaW5nKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHpwYXJhbXMuem1vZGVsID0gZC50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhleFRvUmdiYShzZWxWYXJDb2xvcik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB6cGFyYW1zLnptb2RlbCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhckNvbG9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXN0YXJ0KCk7XG4gICAgICAgIH0pO1xuXG4gICAgZDMuc2VsZWN0KFwiI3R5cGVzXCIpLnNlbGVjdEFsbChcInBcIikgLy8gbW9kZWxzIHRhYlxuICAgIC8vICBkMy5zZWxlY3QoXCIjRGlzcGxheV9jb250ZW50XCIpXG4gICAgLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmKGxvY2t0b2dnbGUpIHJldHVybjtcbiAgICAgICAgaWYodGhpcy5jbGFzc05hbWU9PVwiaXRlbS1zZWxlY3RcIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZDMuc2VsZWN0KFwiI3R5cGVzXCIpLnNlbGVjdChcInAuaXRlbS1zZWxlY3RcIilcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdpdGVtLWRlZmF1bHQnKTtcbiAgICAgICAgICAgIGQzbVByb2JsZW1EZXNjcmlwdGlvbi50YXNrVHlwZSA9IHRoaXMuaW5uZXJIVE1MLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuYXR0cignY2xhc3MnLFwiaXRlbS1zZWxlY3RcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdGFydCgpO1xuICAgICAgICBzZXRQcm9ibGVtRGVmaW5pdGlvbihcInRhc2tUeXBlXCIsIGQzbVByb2JsZW1EZXNjcmlwdGlvbiwgZDNtVGFza1R5cGUpO1xuICAgICAgICB9KTtcblxuICAgIGQzLnNlbGVjdChcIiNzdWJ0eXBlc1wiKS5zZWxlY3RBbGwoXCJwXCIpXG4gICAgLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmKGxvY2t0b2dnbGUpIHJldHVybjtcbiAgICAgICAgaWYodGhpcy5jbGFzc05hbWU9PVwiaXRlbS1zZWxlY3RcIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZDMuc2VsZWN0KFwiI3N1YnR5cGVzXCIpLnNlbGVjdChcInAuaXRlbS1zZWxlY3RcIilcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdpdGVtLWRlZmF1bHQnKTtcbiAgICAgICAgICAgIGQzbVByb2JsZW1EZXNjcmlwdGlvbi50YXNrU3VidHlwZSA9IHRoaXMuaW5uZXJIVE1MLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuYXR0cignY2xhc3MnLFwiaXRlbS1zZWxlY3RcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdGFydCgpO1xuICAgICAgICBzZXRQcm9ibGVtRGVmaW5pdGlvbihcInRhc2tTdWJ0eXBlXCIsIGQzbVByb2JsZW1EZXNjcmlwdGlvbiwgZDNtVGFza1N1YnR5cGUpO1xuICAgICAgICB9KTtcblxuICAgIGQzLnNlbGVjdChcIiNtZXRyaWNzXCIpLnNlbGVjdEFsbChcInBcIilcbiAgICAub24oXCJjbGlja1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYobG9ja3RvZ2dsZSkgcmV0dXJuO1xuICAgICAgICBpZih0aGlzLmNsYXNzTmFtZT09XCJpdGVtLXNlbGVjdFwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBkM21Qcm9ibGVtRGVzY3JpcHRpb24ubWV0cmljID0gW1wiXCIsXCJcIl07XG4gICAgICAgICAgICAvLyB0aGlzLmNsYXNzTmFtZT1cIml0ZW0tZGVmYXVsdFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZDMuc2VsZWN0KFwiI21ldHJpY3NcIikuc2VsZWN0KFwicC5pdGVtLXNlbGVjdFwiKVxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2l0ZW0tZGVmYXVsdCcpO1xuICAgICAgICAgICAgZDNtUHJvYmxlbURlc2NyaXB0aW9uLm1ldHJpYyA9IHRoaXMuaW5uZXJIVE1MLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuYXR0cignY2xhc3MnLFwiaXRlbS1zZWxlY3RcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdGFydCgpO1xuICAgICAgICBzZXRQcm9ibGVtRGVmaW5pdGlvbihcIm1ldHJpY1wiLCBkM21Qcm9ibGVtRGVzY3JpcHRpb24sIGQzbU1ldHJpY3MpO1xuICAgICAgICB9KTtcblxuICAvKiAgZDMuc2VsZWN0KFwiI291dHB1dHNcIikuc2VsZWN0QWxsKFwicFwiKVxuICAgIC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZihsb2NrdG9nZ2xlKSByZXR1cm47XG4gICAgICAgIGlmKHRoaXMuY2xhc3NOYW1lPT1cIml0ZW0tc2VsZWN0XCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGQzLnNlbGVjdChcIiNvdXRwdXRzXCIpLnNlbGVjdChcInAuaXRlbS1zZWxlY3RcIilcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdpdGVtLWRlZmF1bHQnKTtcbiAgICAgICAgICAgIGQzbVByb2JsZW1EZXNjcmlwdGlvbi5vdXRwdXRUeXBlID0gdGhpcy5pbm5lckhUTUwudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5hdHRyKCdjbGFzcycsXCJpdGVtLXNlbGVjdFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXN0YXJ0KCk7XG4gICAgICAgIHNldFByb2JsZW1EZWZpbml0aW9uKFwib3V0cHV0VHlwZVwiLCBkM21Qcm9ibGVtRGVzY3JpcHRpb24sIGQzbU91dHB1dFR5cGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgKi9cblxuICAgIC8vIHVwZGF0ZSBncmFwaCAoY2FsbGVkIHdoZW4gbmVlZGVkKVxuICAgIHJlc3RhcnQgPSBmdW5jdGlvbigkbGlua3MpIHtcbiAgICAgICAgbGlua3MgPSAkbGlua3MgfHwgbGlua3M7XG4gICAgICAgIC8vIG5vZGVzLmlkIGlzIHBlZ2dlZCB0byBhbGxOb2RlcywgaS5lLiB0aGUgb3JkZXIgaW4gd2hpY2ggdmFyaWFibGVzIGFyZSByZWFkIGluXG4gICAgICAgIC8vIG5vZGVzLmluZGV4IGlzIGZsb2F0aW5nIGFuZCBkZXBlbmRzIG9uIHVwZGF0ZXMgdG8gbm9kZXMuICBhIHZhcmlhYmxlcyBpbmRleCBjaGFuZ2VzIHdoZW4gbmV3IHZhcmlhYmxlcyBhcmUgYWRkZWQuXG4gICAgICAgIGNpcmNsZS5jYWxsKGZvcmNlLmRyYWcpO1xuICAgICAgICBpZiAoZm9yY2V0b2dnbGVbMF0gPT0gXCJ0cnVlXCIpIHtcbiAgICAgICAgICAgIGZvcmNlLmdyYXZpdHkoMC4xKTtcbiAgICAgICAgICAgIGZvcmNlLmNoYXJnZShkID0+IHNldFBlYmJsZUNoYXJnZShkKSk7XG4gICAgICAgICAgICBmb3JjZS5zdGFydCgpO1xuICAgICAgICAgICAgZm9yY2UubGlua1N0cmVuZ3RoKDEpO1xuICAgICAgICAgICAgayA9IDQ7IC8vIHN0cmVuZ3RoIHBhcmFtZXRlciBmb3IgZ3JvdXAgYXR0cmFjdGlvbi9yZXB1bHNpb25cbiAgICAgICAgICAgIGlmICgoenBhcmFtcy56Z3JvdXAxLmxlbmd0aCA+IDApICYgKHpwYXJhbXMuemdyb3VwMi5sZW5ndGggPiAwICkpIHsgLy8gc2NhbGUgZG93biBieSBudW1iZXIgb2YgYWN0aXZlIGdyb3Vwc1xuICAgICAgICAgICAgICAgIGsgPSAyLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3JjZS5ncmF2aXR5KDApO1xuICAgICAgICAgICAgZm9yY2UuY2hhcmdlKDApO1xuICAgICAgICAgICAgZm9yY2UubGlua1N0cmVuZ3RoKDApO1xuICAgICAgICAgICAgayA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yY2UucmVzdW1lKCk7XG5cbiAgICAgICAgLy8gcGF0aCAobGluaykgZ3JvdXBcbiAgICAgICAgcGF0aCA9IHBhdGguZGF0YShsaW5rcyk7XG5cbiAgICAgICAgbGV0IG1hcmtlciA9IHNpZGUgPT4geCA9PiB7XG4gICAgICAgICAgICBsZXQga2luZCA9IHNpZGUgPT09ICdsZWZ0JyA/ICdzdGFydCcgOiAnZW5kJztcbiAgICAgICAgICAgIHJldHVybiBpc19leHBsb3JlX21vZGUgPyAndXJsKCNjaXJjbGUpJyA6XG4gICAgICAgICAgICAgICAgeFtzaWRlXSA/IGB1cmwoIyR7a2luZH0tYXJyb3cpYCA6XG4gICAgICAgICAgICAgICAgJyc7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gdXBkYXRlIGV4aXN0aW5nIGxpbmtzXG4gICAgICAgIC8vIFZKRDogZGFzaGVkIGxpbmtzIGJldHdlZW4gcGViYmxlcyBhcmUgXCJzZWxlY3RlZFwiLiB0aGlzIGlzIGRpc2FibGVkIGZvciBub3dcbiAgICAgICAgcGF0aC5jbGFzc2VkKCdzZWxlY3RlZCcsIHggPT4gbnVsbClcbiAgICAgICAgICAgIC5zdHlsZSgnbWFya2VyLXN0YXJ0JywgbWFya2VyKCdsZWZ0JykpXG4gICAgICAgICAgICAuc3R5bGUoJ21hcmtlci1lbmQnLCBtYXJrZXIoJ3JpZ2h0JykpO1xuXG4gICAgICAgIC8vIGFkZCBuZXcgbGlua3NcbiAgICAgICAgcGF0aC5lbnRlcigpLmFwcGVuZCgnc3ZnOnBhdGgnKVxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2xpbmsnKVxuICAgICAgICAgICAgLmNsYXNzZWQoJ3NlbGVjdGVkJywgeCA9PiBudWxsKVxuICAgICAgICAgICAgLnN0eWxlKCdtYXJrZXItc3RhcnQnLCBtYXJrZXIoJ2xlZnQnKSlcbiAgICAgICAgICAgIC5zdHlsZSgnbWFya2VyLWVuZCcsIG1hcmtlcigncmlnaHQnKSlcbiAgICAgICAgICAgIC5vbignbW91c2Vkb3duJywgZnVuY3Rpb24oZCkgeyAvLyBkbyB3ZSBldmVyIG5lZWQgdG8gc2VsZWN0IGEgbGluaz8gbWFrZSBpdCBkZWxldGUuLlxuICAgICAgICAgICAgICAgIHZhciBvYmogPSBKU09OLnN0cmluZ2lmeShkKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxpbmtzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmogPT09IEpTT04uc3RyaW5naWZ5KGxpbmtzW2pdKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbChsaW5rcywgaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gcmVtb3ZlIG9sZCBsaW5rc1xuICAgICAgICBwYXRoLmV4aXQoKS5yZW1vdmUoKTtcblxuICAgICAgICAvLyBjaXJjbGUgKG5vZGUpIGdyb3VwXG4gICAgICAgIGNpcmNsZSA9IGNpcmNsZS5kYXRhKG5vZGVzLCB4ID0+IHguaWQpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSBleGlzdGluZyBub2RlcyAocmVmbGV4aXZlICYgc2VsZWN0ZWQgdmlzdWFsIHN0YXRlcylcbiAgICAgICAgLy8gZDMucmdiIGlzIHRoZSBmdW5jdGlvbiBhZGp1c3RpbmcgdGhlIGNvbG9yIGhlcmVcbiAgICAgICAgY2lyY2xlLnNlbGVjdEFsbCgnY2lyY2xlJylcbiAgICAgICAgICAgIC5jbGFzc2VkKCdyZWZsZXhpdmUnLCB4ID0+IHgucmVmbGV4aXZlKVxuICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgeCA9PiBkMy5yZ2IoeC5ub2RlQ29sKSlcbiAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgeCA9PiBkMy5yZ2IoeC5zdHJva2VDb2xvcikpXG4gICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZS13aWR0aCcsIHggPT4geC5zdHJva2VXaWR0aCk7XG5cbiAgICAgICAgLy8gYWRkIG5ldyBub2Rlc1xuICAgICAgICBsZXQgZyA9IGNpcmNsZS5lbnRlcigpXG4gICAgICAgICAgICAuYXBwZW5kKCdzdmc6ZycpXG4gICAgICAgICAgICAuYXR0cignaWQnLCB4ID0+IHgubmFtZSArICdiaWdncm91cCcpO1xuXG4gICAgICAgIC8vIGFkZCBwbG90XG4gICAgICAgIGcuZWFjaChmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICBkMy5zZWxlY3QodGhpcyk7XG4gICAgICAgICAgICBpZiAoZC5wbG90dHlwZSA9PSAnY29udGludW91cycpIGRlbnNpdHlOb2RlKGQsIHRoaXMpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZC5wbG90dHlwZSA9PSAnYmFyJykgYmFyc05vZGUoZCwgdGhpcyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGxldCBhcHBlbmQgPSAoc3RyLCBhdHRyKSA9PiB4ID0+IHN0ciArIHhbYXR0ciB8fCAnaWQnXTtcblxuICAgICAgICBnLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgYXBwZW5kKCdkdkFyYycpKVxuICAgICAgICAgICAgLmF0dHIoXCJkXCIsIGFyYzMpXG4gICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGR2Q29sb3IpXG4gICAgICAgICAgICAuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgZmlsbFRoaXModGhpcywgLjMsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgZmlsbChkLCAnZHZUZXh0JywgLjksIDAsIDEwMCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICBmaWxsVGhpcyh0aGlzLCAwLCAxMDAsIDUwMCk7XG4gICAgICAgICAgICAgICAgZmlsbChkLCAnZHZUZXh0JywgMCwgMTAwLCA1MDApO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignY2xpY2snLCBkID0+IHtcbiAgICAgICAgICAgICAgICBzZXRDb2xvcnMoZCwgZHZDb2xvcik7XG4gICAgICAgICAgICAgICAgbGVnZW5kKGR2Q29sb3IpO1xuICAgICAgICAgICAgICAgIHJlc3RhcnQoKTtcbiAgICAgICAgICAgICAgICBkLmdyb3VwMSA9IGQuZ3JvdXAyID0gZmFsc2U7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgYXBwZW5kKCdkdlRleHQnKSlcbiAgICAgICAgICAgIC5hdHRyKFwieFwiLCA2KVxuICAgICAgICAgICAgLmF0dHIoXCJkeVwiLCAxMS41KVxuICAgICAgICAgICAgLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgIC5hcHBlbmQoXCJ0ZXh0UGF0aFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ4bGluazpocmVmXCIsIGFwcGVuZCgnI2R2QXJjJykpXG4gICAgICAgICAgICAudGV4dChcIkRlcCBWYXJcIik7XG5cbiAgICAgICAgZy5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsIGFwcGVuZCgnbm9tQXJjJykpXG4gICAgICAgICAgICAuYXR0cihcImRcIiwgYXJjNClcbiAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgbm9tQ29sb3IpXG4gICAgICAgICAgICAuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGQuZGVmYXVsdE51bWNoYXIgPT0gXCJjaGFyYWN0ZXJcIikgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGZpbGxUaGlzKHRoaXMsIC4zLCAwLCAxMDApO1xuICAgICAgICAgICAgICAgIGZpbGwoZCwgXCJub21UZXh0XCIsIC45LCAwLCAxMDApO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGQuZGVmYXVsdE51bWNoYXIgPT0gXCJjaGFyYWN0ZXJcIikgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGZpbGxUaGlzKHRoaXMsIDAsIDEwMCwgNTAwKTtcbiAgICAgICAgICAgICAgICBmaWxsKGQsIFwibm9tVGV4dFwiLCAwLCAxMDAsIDUwMCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdjbGljaycsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZC5kZWZhdWx0TnVtY2hhciA9PSBcImNoYXJhY3RlclwiKSByZXR1cm47XG4gICAgICAgICAgICAgICAgc2V0Q29sb3JzKGQsIG5vbUNvbG9yKTtcbiAgICAgICAgICAgICAgICBsZWdlbmQobm9tQ29sb3IpO1xuICAgICAgICAgICAgICAgIHJlc3RhcnQoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIGcuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBhcHBlbmQoXCJub21UZXh0XCIpKVxuICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIDYpXG4gICAgICAgICAgICAuYXR0cihcImR5XCIsIDExLjUpXG4gICAgICAgICAgICAuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgLmFwcGVuZChcInRleHRQYXRoXCIpXG4gICAgICAgICAgICAuYXR0cihcInhsaW5rOmhyZWZcIiwgYXBwZW5kKFwiI25vbUFyY1wiKSlcbiAgICAgICAgICAgIC50ZXh0KFwiTm9taW5hbFwiKTtcblxuICAgICAgICBnLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgYXBwZW5kKCdnckFyYycpKVxuICAgICAgICAgICAgLmF0dHIoXCJkXCIsIGFyYzEpXG4gICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsICBncjFDb2xvcilcbiAgICAgICAgICAgIC5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICBmaWxsKGQsIFwiZ3IxaW5kaWNhdG9yXCIsIC4zLCAwLCAxMDApO1xuICAgICAgICAgICAgICAgIGZpbGwoZCwgXCJncjJpbmRpY2F0b3JcIiwgLjMsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgZmlsbFRoaXModGhpcywgLjMsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgZmlsbChkLCAnZ3JUZXh0JywgLjksIDAsIDEwMCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICBmaWxsKGQsIFwiZ3IxaW5kaWNhdG9yXCIsIDAsIDEwMCwgNTAwKTtcbiAgICAgICAgICAgICAgICBmaWxsKGQsIFwiZ3IyaW5kaWNhdG9yXCIsIDAsIDEwMCwgNTAwKTtcbiAgICAgICAgICAgICAgICBmaWxsVGhpcyh0aGlzLCAwLCAxMDAsIDUwMCk7XG4gICAgICAgICAgICAgICAgZmlsbChkLCAnZ3JUZXh0JywgMCwgMTAwLCA1MDApO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignY2xpY2snLCBkID0+IHtcbiAgICAgICAgICAgICAgICAvL2QuZ3JvdXAxID0gIWQuZ3JvdXAxOyAgICAgIC8vIFRoaXMgbWlnaHQgYmUgZWFzaWVyLCBidXQgY3VycmVudGx5IHNldCBpbiBzZXRDb2xvcnMoKVxuICAgICAgICAgICAgICAgIHNldENvbG9ycyhkLCBncjFDb2xvcik7XG4gICAgICAgICAgICAgICAgbGVnZW5kKGdyMUNvbG9yKTtcbiAgICAgICAgICAgICAgICByZXN0YXJ0KCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBnLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgYXBwZW5kKCdncjFpbmRpY2F0b3InKSlcbiAgICAgICAgICAgIC5hdHRyKFwiZFwiLCBhcmNJbmQxKVxuICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBncjFDb2xvcikgIC8vIHNvbWV0aGluZyBsaWtlOiB6cGFyYW1zLnpncm91cDEuaW5kZXhPZihub2RlLm5hbWUpID4gLTEgID8gICNGRkZGRkYgOiBncjFDb2xvcilcbiAgICAgICAgICAgIC5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICBmaWxsVGhpcyh0aGlzLCAuMywgMCwgMTAwKTtcbiAgICAgICAgICAgICAgICBmaWxsKGQsIFwiZ3JBcmNcIiwgLjEsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgZmlsbChkLCAnZ3JUZXh0JywgLjksIDAsIDEwMCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICBmaWxsVGhpcyh0aGlzLCAwLCAxMDAsIDUwMCk7XG4gICAgICAgICAgICAgICAgZmlsbChkLCBcImdyQXJjXCIsIDAsIDEwMCwgNTAwKTtcbiAgICAgICAgICAgICAgICBmaWxsKGQsICdnclRleHQnLCAwLCAxMDAsIDUwMCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdjbGljaycsIGQgPT4ge1xuICAgICAgICAgICAgICAgIC8vZC5ncm91cDEgPSAhZC5ncm91cDE7ICAgICAgLy8gVGhpcyBtaWdodCBiZSBlYXNpZXIsIGJ1dCBjdXJyZW50bHkgc2V0IGluIHNldENvbG9ycygpXG4gICAgICAgICAgICAgICAgc2V0Q29sb3JzKGQsIGdyMUNvbG9yKTtcbiAgICAgICAgICAgICAgICBsZWdlbmQoZ3IxQ29sb3IpO1xuICAgICAgICAgICAgICAgIHJlc3RhcnQoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICBnLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgYXBwZW5kKCdncjJpbmRpY2F0b3InKSlcbiAgICAgICAgICAgIC5hdHRyKFwiZFwiLCBhcmNJbmQyKVxuICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBncjJDb2xvcikgIC8vIHNvbWV0aGluZyBsaWtlOiB6cGFyYW1zLnpncm91cDEuaW5kZXhPZihub2RlLm5hbWUpID4gLTEgID8gICNGRkZGRkYgOiBncjFDb2xvcilcbiAgICAgICAgICAgIC5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICBmaWxsVGhpcyh0aGlzLCAuMywgMCwgMTAwKTtcbiAgICAgICAgICAgICAgICBmaWxsKGQsIFwiZ3JBcmNcIiwgLjEsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgZmlsbChkLCAnZ3JUZXh0JywgLjksIDAsIDEwMCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICBmaWxsVGhpcyh0aGlzLCAwLCAxMDAsIDUwMCk7XG4gICAgICAgICAgICAgICAgZmlsbChkLCBcImdyQXJjXCIsIDAsIDEwMCwgNTAwKTtcbiAgICAgICAgICAgICAgICBmaWxsKGQsICdnclRleHQnLCAwLCAxMDAsIDUwMCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdjbGljaycsIGQgPT4ge1xuICAgICAgICAgICAgICAgIC8vZC5ncm91cDIgPSAhZC5ncm91cDI7ICAgICAgLy8gVGhpcyBtaWdodCBiZSBlYXNpZXIsIGJ1dCBjdXJyZW50bHkgc2V0IGluIHNldENvbG9ycygpXG4gICAgICAgICAgICAgICAgc2V0Q29sb3JzKGQsIGdyMkNvbG9yKTtcbiAgICAgICAgICAgICAgICBsZWdlbmQoZ3IyQ29sb3IpO1xuICAgICAgICAgICAgICAgIHJlc3RhcnQoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIGcuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBhcHBlbmQoJ2dyVGV4dCcpKVxuICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIDYpXG4gICAgICAgICAgICAuYXR0cihcImR5XCIsIDExLjUpXG4gICAgICAgICAgICAuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgLmFwcGVuZChcInRleHRQYXRoXCIpXG4gICAgICAgICAgICAuYXR0cihcInhsaW5rOmhyZWZcIiwgYXBwZW5kKCcjZ3JBcmMnKSlcbiAgICAgICAgICAgIC50ZXh0KFwiR3JvdXBzXCIpO1xuXG4gICAgICAgIGcuYXBwZW5kKCdzdmc6Y2lyY2xlJylcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdub2RlJylcbiAgICAgICAgICAgIC5hdHRyKCdyJywgZCA9PiBzZXRQZWJibGVSYWRpdXMoZCkpXG4gICAgICAgICAgICAuc3R5bGUoJ3BvaW50ZXItZXZlbnRzJywgJ2luaGVyaXQnKVxuICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgZCA9PiBkLm5vZGVDb2wpXG4gICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCBcIjAuNVwiKVxuICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCBkID0+IGQzLnJnYihkLnN0cm9rZUNvbG9yKS50b1N0cmluZygpKVxuICAgICAgICAgICAgLmNsYXNzZWQoJ3JlZmxleGl2ZScsIGQgPT4gZC5yZWZsZXhpdmUpXG4gICAgICAgICAgICAub24oJ2RibGNsaWNrJywgZnVuY3Rpb24oXykge1xuICAgICAgICAgICAgICAgIGQzLmV2ZW50LnN0b3BQcm9wYWdhdGlvbigpOyAvLyBzdG9wIGNsaWNrIGZyb20gYnViYmxpbmdcbiAgICAgICAgICAgICAgICBzdW1tYXJ5SG9sZCA9IHRydWU7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdjb250ZXh0bWVudScsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAvLyByaWdodCBjbGljayBvbiBub2RlXG4gICAgICAgICAgICAgICAgZDMuZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBkMy5ldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAgICAgICAgIHJpZ2h0Q2xpY2tMYXN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBtb3VzZWRvd25fbm9kZSA9IGQ7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRfbm9kZSA9IG1vdXNlZG93bl9ub2RlID09PSBzZWxlY3RlZF9ub2RlID8gbnVsbCA6IG1vdXNlZG93bl9ub2RlO1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkX2xpbmsgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgLy8gcmVwb3NpdGlvbiBkcmFnIGxpbmVcbiAgICAgICAgICAgICAgICBkcmFnX2xpbmVcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdtYXJrZXItZW5kJywgaXNfZXhwbG9yZV9tb2RlPyAndXJsKCNlbmQtbWFya2VyKScgOiAndXJsKCNlbmQtYXJyb3cpJylcbiAgICAgICAgICAgICAgICAgICAgLmNsYXNzZWQoJ2hpZGRlbicsIGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignZCcsICdNJyArIG1vdXNlZG93bl9ub2RlLnggKyAnLCcgKyBtb3VzZWRvd25fbm9kZS55ICsgJ0wnICsgbW91c2Vkb3duX25vZGUueCArICcsJyArIG1vdXNlZG93bl9ub2RlLnkpO1xuXG4gICAgICAgICAgICAgICAgc3ZnLm9uKCdtb3VzZW1vdmUnLCBtb3VzZW1vdmUpO1xuICAgICAgICAgICAgICAgIHJlc3RhcnQoKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ21vdXNldXAnLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgZDMuZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAocmlnaHRDbGlja0xhc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRDbGlja0xhc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIW1vdXNlZG93bl9ub2RlKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICAvLyBuZWVkZWQgYnkgRkZcbiAgICAgICAgICAgICAgICBkcmFnX2xpbmVcbiAgICAgICAgICAgICAgICAgICAgLmNsYXNzZWQoJ2hpZGRlbicsIHRydWUpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnbWFya2VyLWVuZCcsICcnKTtcblxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciBkcmFnLXRvLXNlbGZcbiAgICAgICAgICAgICAgICBtb3VzZXVwX25vZGUgPSBkO1xuICAgICAgICAgICAgICAgIGlmIChtb3VzZXVwX25vZGUgPT09IG1vdXNlZG93bl9ub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc2V0TW91c2VWYXJzKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyB1bmVubGFyZ2UgdGFyZ2V0IG5vZGVcbiAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuYXR0cigndHJhbnNmb3JtJywgJycpO1xuXG4gICAgICAgICAgICAgICAgLy8gYWRkIGxpbmsgdG8gZ3JhcGggKHVwZGF0ZSBpZiBleGlzdHMpXG4gICAgICAgICAgICAgICAgLy8gTkI6IGxpbmtzIGFyZSBzdHJpY3RseSBzb3VyY2UgPCB0YXJnZXQ7IGFycm93cyBzZXBhcmF0ZWx5IHNwZWNpZmllZCBieSBib29sZWFuc1xuICAgICAgICAgICAgICAgIHZhciBzb3VyY2UsIHRhcmdldCwgZGlyZWN0aW9uO1xuICAgICAgICAgICAgICAgIGlmIChtb3VzZWRvd25fbm9kZS5pZCA8IG1vdXNldXBfbm9kZS5pZCkge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2UgPSBtb3VzZWRvd25fbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gbW91c2V1cF9ub2RlO1xuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSAncmlnaHQnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZSA9IG1vdXNldXBfbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gbW91c2Vkb3duX25vZGU7XG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9ICdsZWZ0JztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsZXQgbGluayA9IGxpbmtzLmZpbHRlcih4ID0+IHguc291cmNlID09IHNvdXJjZSAmJiB4LnRhcmdldCA9PSB0YXJnZXQpWzBdO1xuICAgICAgICAgICAgICAgIGlmIChsaW5rKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmtbZGlyZWN0aW9uXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGluayA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBsaW5rW2RpcmVjdGlvbl0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBsaW5rcy5wdXNoKGxpbmspO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHNlbGVjdCBuZXcgbGlua1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkX2xpbmsgPSBsaW5rO1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkX25vZGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIHN2Zy5vbignbW91c2Vtb3ZlJywgbnVsbCk7XG5cbiAgICAgICAgICAgICAgICByZXNldE1vdXNlVmFycygpO1xuICAgICAgICAgICAgICAgIHJlc3RhcnQoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHNob3cgbm9kZSBuYW1lc1xuICAgICAgICBnLmFwcGVuZCgnc3ZnOnRleHQnKVxuICAgICAgICAgICAgLmF0dHIoJ3gnLCAwKVxuICAgICAgICAgICAgLmF0dHIoJ3knLCAxNSlcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdpZCcpXG4gICAgICAgICAgICAudGV4dChkID0+IGQubmFtZSk7XG5cbiAgICAgICAgLy8gc2hvdyBzdW1tYXJ5IHN0YXRzIG9uIG1vdXNlb3ZlclxuICAgICAgICAvLyBTVkcgZG9lc24ndCBzdXBwb3J0IHRleHQgd3JhcHBpbmcsIHVzZSBodG1sIGluc3RlYWRcbiAgICAgICAgZy5zZWxlY3RBbGwoXCJjaXJjbGUubm9kZVwiKVxuICAgICAgICAgICAgLm9uKFwibW91c2VvdmVyXCIsIGQgPT4ge1xuICAgICAgICAgICAgICAgIHRhYkxlZnQoJ3RhYjMnKTtcbiAgICAgICAgICAgICAgICB2YXJTdW1tYXJ5KGQpO1xuICAgICAgICAgICAgICAgIGQuZm9yZWZyb250ID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIGJ5SWQoJ3RyYW5zZm9ybWF0aW9ucycpLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnZGlzcGxheTpibG9jaycpO1xuICAgICAgICAgICAgICAgIGJ5SWQoXCJ0cmFuc1NlbFwiKS5zZWxlY3RlZEluZGV4ID0gZC5pZDtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1WYXIgPSB2YWx1ZUtleVtkLmlkXTtcblxuICAgICAgICAgICAgICAgIGZpbGwoZCwgXCJkdkFyY1wiLCAuMSwgMCwgMTAwKTtcbiAgICAgICAgICAgICAgICBmaWxsKGQsIFwiZHZUZXh0XCIsIC41LCAwLCAxMDApO1xuICAgICAgICAgICAgICAgIGZpbGwoZCwgXCJnckFyY1wiLCAuMSwgMCwgMTAwKTtcbiAgICAgICAgICAgICAgICBmaWxsKGQsIFwiZ3JUZXh0XCIsIC41LCAwLCAxMDApO1xuICAgICAgICAgICAgICAgIC8vZmlsbChkLCBcImdyMWluZGljYXRvclwiLCAuMSwgMCwgMTAwKTtcbiAgICAgICAgICAgICAgICAvL2ZpbGwoZCwgXCJncjFpbmRpY2F0b3JUZXh0XCIsIC4xLCAwLCAxMDApO1xuICAgICAgICAgICAgICAgIC8vZmlsbChkLCBcImdyMmluZGljYXRvclwiLCAuMSwgMCwgMTAwKTtcbiAgICAgICAgICAgICAgICAvL2ZpbGwoZCwgXCJncjJpbmRpY2F0b3JUZXh0XCIsIC4xLCAwLCAxMDApO1xuXG4gICAgICAgICAgICAgICAgaWYgKGQuZGVmYXVsdE51bWNoYXIgPT0gXCJudW1lcmljXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsbChkLCBcIm5vbUFyY1wiLCAuMSwgMCwgMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgZmlsbChkLCBcIm5vbVRleHRcIiwgLjUsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbGwoZCwgXCJjc0FyY1wiLCAuMSwgMCwgMTAwKTtcbiAgICAgICAgICAgICAgICBmaWxsKGQsIFwiY3NUZXh0XCIsIC41LCAwLCAxMDApO1xuICAgICAgICAgICAgICAgIGZpbGwoZCwgXCJ0aW1lQXJjXCIsIC4xLCAwLCAxMDApO1xuICAgICAgICAgICAgICAgIGZpbGwoZCwgXCJ0aW1lVGV4dFwiLCAuNSwgMCwgMTAwKTtcblxuICAgICAgICAgICAgICAgIG0ucmVkcmF3KCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGQgPT4ge1xuICAgICAgICAgICAgICAgIGQuZm9yZWZyb250ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc3VtbWFyeUhvbGQgfHwgdGFiTGVmdChzdWJzZXQgPyAndGFiMicgOiAndGFiMScpO1xuICAgICAgICAgICAgICAgICdjc0FyYyBjc1RleHQgdGltZUFyYyB0aW1lVGV4dCBkdkFyYyBkdlRleHQgbm9tQXJjIG5vbVRleHQgZ3JBcmMgZ3JUZXh0Jy5zcGxpdCgnICcpLm1hcCh4ID0+IGZpbGwoZCwgeCwgMCwgMTAwLCA1MDApKTtcbiAgICAgICAgICAgICAgICBtLnJlZHJhdygpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gdGhlIHRyYW5zZm9ybWF0aW9uIHZhcmlhYmxlIGxpc3QgaXMgc2lsZW50bHkgdXBkYXRlZCBhcyBwZWJibGVzIGFyZSBhZGRlZC9yZW1vdmVkXG4gICAgICAgIGQzLnNlbGVjdChcIiN0cmFuc1NlbFwiKVxuICAgICAgICAgICAgLnNlbGVjdEFsbCgnbGknKVxuICAgICAgICAgICAgLnJlbW92ZSgpO1xuXG4gICAgICAgIGQzLnNlbGVjdChcIiN0cmFuc1NlbFwiKVxuICAgICAgICAgICAgLnNlbGVjdEFsbCgnbGknKVxuICAgICAgICAgICAgLmRhdGEobm9kZXMubWFwKHggPT4geC5uYW1lKSkgLy8gc2V0IHRvIHZhcmlhYmxlcyBpbiBtb2RlbCBzcGFjZSBhcyB0aGV5J3JlIGFkZGVkXG4gICAgICAgICAgICAuZW50ZXIoKVxuICAgICAgICAgICAgLmFwcGVuZChcImxpXCIpXG4gICAgICAgICAgICAudGV4dChkID0+IGQpO1xuXG4gICAgICAgIGlmKCFJU19EM01fRE9NQUlOKXtcbiAgICAgICAgICAgICQoJyN0cmFuc1NlbCBsaScpLmNsaWNrKGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgICAgICAgIC8vIGlmICdpbnRlcmFjdGlvbicgaXMgdGhlIHNlbGVjdGVkIGZ1bmN0aW9uLCBkb24ndCBzaG93IHRoZSBmdW5jdGlvbiBsaXN0IGFnYWluXG4gICAgICAgICAgICAgICAgaWYgKHNlbEludGVyYWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gJCgnI3RJbnB1dCcpLnZhbCgpLmNvbmNhdCgkKHRoaXMpLnRleHQoKSk7XG4gICAgICAgICAgICAgICAgICAgICQoJyN0SW5wdXQnKS52YWwobik7XG4gICAgICAgICAgICAgICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSB0cmFuc1BhcnNlKG4gPSBuKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0KSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICQodGhpcykucGFyZW50KCkuZmFkZU91dCgxMDApO1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm0obiA9IHQuc2xpY2UoMCwgdC5sZW5ndGggLSAxKSwgdCA9IHRbdC5sZW5ndGggLSAxXSwgdHlwZVRyYW5zZm9ybSA9IGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICQoJyN0SW5wdXQnKS52YWwoJCh0aGlzKS50ZXh0KCkpO1xuICAgICAgICAgICAgICAgICQodGhpcykucGFyZW50KCkuZmFkZU91dCgxMDApO1xuICAgICAgICAgICAgICAgICQoJyN0cmFuc0xpc3QnKS5mYWRlSW4oMTAwKTtcbiAgICAgICAgICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyByZW1vdmUgb2xkIG5vZGVzXG4gICAgICAgIGNpcmNsZS5leGl0KCkucmVtb3ZlKCk7XG4gICAgICAgIGZvcmNlLnN0YXJ0KCk7XG5cbiAgICAgICAgLy8gc2F2ZSB3b3Jrc3BhY2VzXG4gICAgICAgIGNvbnNvbGUubG9nKCdvayB3cycpO1xuICAgICAgICByZWNvcmRfdXNlcl9tZXRhZGF0YSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vdXNlZG93bihkKSB7XG4gICAgICAgIC8vIHByZXZlbnQgSS1iYXIgb24gZHJhZ1xuICAgICAgICBkMy5ldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAvLyBiZWNhdXNlIDphY3RpdmUgb25seSB3b3JrcyBpbiBXZWJLaXQ/XG4gICAgICAgIHN2Zy5jbGFzc2VkKCdhY3RpdmUnLCB0cnVlKTtcbiAgICAgICAgaWYgKGQzLmV2ZW50LmN0cmxLZXkgfHwgbW91c2Vkb3duX25vZGUgfHwgbW91c2Vkb3duX2xpbmspIHJldHVybjtcbiAgICAgICAgcmVzdGFydCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vdXNlbW92ZShkKSB7XG4gICAgICAgIGlmICghbW91c2Vkb3duX25vZGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIHVwZGF0ZSBkcmFnIGxpbmVcbiAgICAgICAgZHJhZ19saW5lLmF0dHIoJ2QnLCAnTScgKyBtb3VzZWRvd25fbm9kZS54ICsgJywnICsgbW91c2Vkb3duX25vZGUueSArICdMJyArIGQzLm1vdXNlKHRoaXMpWzBdICsgJywnICsgZDMubW91c2UodGhpcylbMV0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vdXNldXAoZCkge1xuICAgICAgICBpZiAobW91c2Vkb3duX25vZGUpIHtcbiAgICAgICAgICAgIGRyYWdfbGluZVxuICAgICAgICAgICAgICAgIC5jbGFzc2VkKCdoaWRkZW4nLCB0cnVlKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnbWFya2VyLWVuZCcsICcnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBiZWNhdXNlIDphY3RpdmUgb25seSB3b3JrcyBpbiBXZWJLaXQ/XG4gICAgICAgIHN2Zy5jbGFzc2VkKCdhY3RpdmUnLCBmYWxzZSk7XG4gICAgICAgIC8vIGNsZWFyIG1vdXNlIGV2ZW50IHZhcnNcbiAgICAgICAgcmVzZXRNb3VzZVZhcnMoKTtcbiAgICB9XG5cbiAgICAvLyBhcHAgc3RhcnRzIGhlcmVcbiAgICBzdmcuYXR0cignaWQnLCAoKSA9PiBcIndoaXRlc3BhY2VcIi5jb25jYXQobXlzcGFjZSkpXG4gICAgICAgIC5hdHRyKCdoZWlnaHQnLCBoZWlnaHQpXG4gICAgICAgIC5vbignbW91c2Vkb3duJywgZnVuY3Rpb24oKSB7bW91c2Vkb3duKHRoaXMpO30pXG4gICAgICAgIC5vbignbW91c2V1cCcsIGZ1bmN0aW9uKCkge21vdXNldXAodGhpcyk7fSk7XG5cbiAgICBkMy5zZWxlY3Qod2luZG93KVxuICAgICAgICAub24oJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgICAgLy8gYWxsIGNsaWNrcyB3aWxsIGJ1YmJsZSBoZXJlIHVubGVzcyBldmVudC5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgICAgICAgJCgnI3RyYW5zTGlzdCcpLmZhZGVPdXQoMTAwKTtcbiAgICAgICAgICAgICQoJyN0cmFuc1NlbCcpLmZhZGVPdXQoMTAwKTtcbiAgICAgICAgfSk7XG5cbiAgICByZXN0YXJ0KCk7IC8vIGluaXRpYWxpemVzIGZvcmNlLmxheW91dCgpXG4gICAgZmFrZUNsaWNrKCk7XG5cbiAgICBpZih2MiAmIElTX0QzTV9ET01BSU4pIHtcbiAgICAgICAgdmFyIGNsaWNrX2V2ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJNb3VzZUV2ZW50c1wiKTtcbiAgICAgICAgLy8gaW5pdGlhbGl6ZSB0aGUgZXZlbnRcbiAgICAgICAgY2xpY2tfZXYuaW5pdEV2ZW50KFwiY2xpY2tcIiwgdHJ1ZSAvKiBidWJibGUgKi8sIHRydWUgLyogY2FuY2VsYWJsZSAqLyk7XG4gICAgICAgIC8vIHRyaWdnZXIgdGhlIGV2ZW50XG4gICAgICAgIGxldCBjbGlja0lEID0gXCJkdkFyY1wiK2ZpbmROb2RlSW5kZXgobXl0YXJnZXQpO1xuICAgICAgICBieUlkKGNsaWNrSUQpLmRpc3BhdGNoRXZlbnQoY2xpY2tfZXYpO1xuICAgIH1cbn1cblxuXG4vKiogbmVlZHMgZG9jICovXG5mdW5jdGlvbiBmaW5kKCRub2RlcywgbmFtZSkge1xuICAgIGZvciAobGV0IGkgaW4gJG5vZGVzKVxuICAgICAgICBpZiAoJG5vZGVzW2ldLm5hbWUgPT0gbmFtZSkgcmV0dXJuICRub2Rlc1tpXS5pZDtcbn1cblxuLyoqXG4gICByZXR1cm5zIGlkXG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmROb2RlSW5kZXgobmFtZSwgd2hvbGUpIHtcbiAgICBmb3IgKGxldCBub2RlIG9mIGFsbE5vZGVzKVxuICAgICAgICBpZiAobm9kZS5uYW1lID09PSBuYW1lKSByZXR1cm4gd2hvbGUgPyBub2RlIDogbm9kZS5pZDtcbn1cblxuLyoqIG5lZWRzIGRvYyAqL1xuZnVuY3Rpb24gbm9kZUluZGV4KG5vZGVOYW1lKSB7XG4gICAgZm9yIChsZXQgaSBpbiBub2RlcylcbiAgICAgICAgaWYgKG5vZGVzW2ldLm5hbWUgPT09IG5vZGVOYW1lKSByZXR1cm4gaTtcbn1cblxuLyoqIG5lZWRzIGRvYyAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmROb2RlKG5hbWUpIHtcbiAgICBmb3IgKGxldCBuIG9mIGFsbE5vZGVzKVxuICAgICAgICBpZiAobi5uYW1lID09PSBuYW1lKVxuICAgICAgICAgICAgcmV0dXJuIG47XG59XG5cbi8qKiBuZWVkcyBkb2MgKi9cbmZ1bmN0aW9uIHVwZGF0ZU5vZGUoaWQpIHtcbiAgICBsZXQgbm9kZSA9IGZpbmROb2RlKGlkKTtcbiAgICBpZiAobm9kZS5ncmF5b3V0KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICBsZXQgbmFtZSA9IG5vZGUubmFtZTtcbiAgICBsZXQgbmFtZXMgPSAoKSA9PiBub2Rlcy5tYXAobiA9PiBuLm5hbWUpO1xuICAgIGlmIChuYW1lcygpLmluY2x1ZGVzKG5hbWUpKSB7XG4gICAgICAgIGRlbChub2Rlcywgbm9kZS5pbmRleCk7XG4gICAgICAgIGxpbmtzXG4gICAgICAgICAgICAuZmlsdGVyKGwgPT4gbC5zb3VyY2UgPT09IG5vZGUgfHwgbC50YXJnZXQgPT09IG5vZGUpXG4gICAgICAgICAgICAuZm9yRWFjaChsID0+IGRlbChsaW5rcywgLTEsIGwpKTtcbiAgICAgICAgenBhcmFtc1Jlc2V0KG5hbWUpO1xuXG4gICAgICAgIC8vIHJlbW92ZSBub2RlIG5hbWUgZnJvbSBncm91cCBsaXN0c1xuICAgICAgICBub2RlLmdyb3VwMSAmJiBkZWwoenBhcmFtcy56Z3JvdXAxLCAtMSwgbmFtZSk7XG4gICAgICAgIG5vZGUuZ3JvdXAyICYmIGRlbCh6cGFyYW1zLnpncm91cDIsIC0xLCBuYW1lKTtcbiAgICAgICAgbm9kZS5ncm91cDEgPSBub2RlLmdyb3VwMiA9IGZhbHNlO1xuXG4gICAgICAgIC8vIG5vZGUgcmVzZXQgLSBwZXJoYXBzIHRoaXMgd2lsbCBiZWNvbWUgYSBoYXJkIHJlc2V0IGJhY2sgdG8gYWxsIG9yaWdpbmFsIGFsbE5vZGUgdmFsdWVzP1xuICAgICAgICBub2RlLm5vZGVDb2wgPSBub2RlLmJhc2VDb2w7XG4gICAgICAgIG5vZGUuc3Ryb2tlQ29sb3IgPSBzZWxWYXJDb2xvcjtcbiAgICAgICAgbm9kZS5zdHJva2VXaWR0aCA9ICcxJztcblxuICAgICAgICBib3JkZXJTdGF0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgfVxuICAgIHpwYXJhbXMuenZhcnMgPSBuYW1lcygpO1xuICAgIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAgIGV2ZXJ5IHRpbWUgYSB2YXJpYWJsZSBpbiBsZWZ0cGFuZWwgaXMgY2xpY2tlZCwgbm9kZXMgdXBkYXRlcyBhbmQgYmFja2dyb3VuZCBjb2xvciBjaGFuZ2VzXG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGNsaWNrVmFyKGVsZW0pIHtcbiAgICBpZiAodXBkYXRlTm9kZShlbGVtLnRhcmdldC5pZCkpIHtcbiAgICAgICAgLy8gcGFuZWxQbG90cygpOyBpcyB0aGlzIG5lY2Vzc2FyeT9cbiAgICAgICAgcmVzdGFydCgpO1xuICAgIH1cbn1cblxuLyoqXG4gIFJldHJpZXZlIHRoZSB2YXJpYWJsZSBsaXN0IGZyb20gdGhlIHByZXByb2Nlc3MgZGF0YS5cbiAgVGhpcyBoZWxwcyBoYW5kbGUgdGhlIG5ldyBmb3JtYXQgYW5kICh0ZW1wb3JhcmlseSlcbiAgdGhlIG9sZGVyIGZvcm1hdCBpbiBQUk9EVUNUSU9OIChycCA4LjE0LjIwMTcpXG4gIFwibmV3XCIgcmVzcG9uc2U6XG4gIHtcbiAgXCJkYXRhc2V0XCIgOiB7Li4ufVxuICBcInZhcmlhYmxlc1wiIDoge1xuICBcInZhcjFcIiA6IHsuLi59LFxuICAoZXRjKVxuICB9XG4gIH1cbiAgXCJvbGRcIiByZXNwb25zZTpcbiAge1xuICBcInZhcjFcIiA6IHsuLi59LFxuICAoZXRjKVxuICB9XG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFZhcmlhYmxlRGF0YShqc29uKSB7XG4gICAgcmV0dXJuIGpzb24uaGFzT3duUHJvcGVydHkoJ3ZhcmlhYmxlcycpID8ganNvbi52YXJpYWJsZXMgOiBqc29uO1xufVxuXG4vKipcbiAgIGNhbGxlZCBieSBmb3JjZSBidXR0b25cbiovXG5leHBvcnQgZnVuY3Rpb24gZm9yY2VTd2l0Y2goKSB7XG4gICAgZm9yY2V0b2dnbGUgPSBbZm9yY2V0b2dnbGVbMF0gPT0gJ3RydWUnID8gJ2ZhbHNlJyA6ICd0cnVlJ107XG4gICAgaWYgKGZvcmNldG9nZ2xlWzBdID09PSBcImZhbHNlXCIpIHtcbiAgICAgICAgYnlJZCgnYnRuRm9yY2UnKS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImJ0biBhY3RpdmVcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYnlJZCgnYnRuRm9yY2UnKS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImJ0biBidG4tZGVmYXVsdFwiKTtcbiAgICAgICAgZmFrZUNsaWNrKCk7XG4gICAgfVxufVxuXG4vKiogbmVlZHMgZG9jICovXG5leHBvcnQgZnVuY3Rpb24gaGVscG1hdGVyaWFscyh0eXBlKSB7XG4gICAgaWYodHlwZT09XCJ2aWRlb1wiKXtcbiAgICAgICAgdmFyIHdpbiA9IHdpbmRvdy5vcGVuKFwiaHR0cDovLzJyYS52bi9kZW1vcy9kM21pbnRlZ3JhdGlvbmRlbW8ubXA0XCIsICdfYmxhbmsnKTtcbiAgICAgICAgd2luLmZvY3VzKCk7XG4gICAgfWVsc2V7XG4gICAgICAgIHZhciB3aW4gPSB3aW5kb3cub3BlbihcImh0dHA6Ly8ycmEudm4vcGFwZXJzL3R3b3JhdmVucy1kM21ndWlkZS5wZGZcIiwgJ19ibGFuaycpO1xuICAgICAgICB3aW4uZm9jdXMoKTtcbiAgICB9XG4gICAgY29uc29sZS5sb2codHlwZSk7XG59XG5cbi8qKiBuZWVkcyBkb2MgKi9cbmV4cG9ydCBmdW5jdGlvbiBsb2NrRGVzY3JpcHRpb24oKSB7XG4gICAgbG9ja3RvZ2dsZSA9IGxvY2t0b2dnbGUgPyBmYWxzZSA6IHRydWU7XG4gICAgbGV0IHRlbXA7XG4gICAgbGV0IGk7XG4gICAgaWYgKCFsb2NrdG9nZ2xlKSB7XG4gICAgICAgIGJ5SWQoJ2J0bkxvY2snKS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImJ0biBidG4tZGVmYXVsdFwiKTtcbiAgICAgICAgdGVtcCA9IGJ5SWQoJ3JpZ2h0Q29udGVudEFyZWEnKS5xdWVyeVNlbGVjdG9yQWxsKFwicC5pdGVtLWxpbmVvdXRcIik7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0ZW1wLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0ZW1wW2ldLmNsYXNzTGlzdC5yZW1vdmUoXCJpdGVtLWxpbmVvdXRcIik7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBieUlkKCdidG5Mb2NrJykuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJidG4gYWN0aXZlXCIpO1xuICAgICAgICB0ZW1wID0gYnlJZCgnbWV0cmljcycpLnF1ZXJ5U2VsZWN0b3JBbGwoXCJwLml0ZW0tZGVmYXVsdFwiKTtcbiAgICAgICAgY29uc29sZS5sb2codGVtcCk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0ZW1wLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0ZW1wW2ldLmNsYXNzTGlzdC5hZGQoXCJpdGVtLWxpbmVvdXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGVtcCA9IGJ5SWQoJ3R5cGVzJykucXVlcnlTZWxlY3RvckFsbChcInAuaXRlbS1kZWZhdWx0XCIpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGVtcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGVtcFtpXS5jbGFzc0xpc3QuYWRkKFwiaXRlbS1saW5lb3V0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHRlbXAgPSBieUlkKCdzdWJ0eXBlcycpLnF1ZXJ5U2VsZWN0b3JBbGwoXCJwLml0ZW0tZGVmYXVsdFwiKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRlbXAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRlbXBbaV0uY2xhc3NMaXN0LmFkZChcIml0ZW0tbGluZW91dFwiKTtcbiAgICAgICAgfVxuICAgIC8qICAgIHRlbXAgPSBieUlkKCdvdXRwdXRzJykucXVlcnlTZWxlY3RvckFsbChcInAuaXRlbS1kZWZhdWx0XCIpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGVtcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGVtcFtpXS5jbGFzc0xpc3QuYWRkKFwiaXRlbS1saW5lb3V0XCIpO1xuICAgICAgICB9ICAqL1xuICAgICAgICBmYWtlQ2xpY2soKTtcbiAgICB9XG59XG5cbi8qKiBuZWVkcyBkb2MgKi9cbmV4cG9ydCBmdW5jdGlvbiB6UG9wKCkge1xuICAgIGlmIChkYXRhdXJsKSB6cGFyYW1zLnpkYXRhdXJsID0gZGF0YXVybDtcbiAgICB6cGFyYW1zLnptb2RlbGNvdW50ID0gbW9kZWxDb3VudDtcbiAgICB6cGFyYW1zLnplZGdlcyA9IFtdO1xuICAgIHpwYXJhbXMuenZhcnMgPSBbXTtcbiAgICB6cGFyYW1zLnpuYXR1cmUgPSBbXTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IG5vZGVzLmxlbmd0aDsgaisrKSB7IC8vcG9wdWxhdGUgenZhcnMgYXJyYXlcbiAgICAgICAgenBhcmFtcy56dmFycy5wdXNoKG5vZGVzW2pdLm5hbWUpO1xuICAgICAgICB6cGFyYW1zLnpuYXR1cmUucHVzaChub2Rlc1tqXS5uYXR1cmUpO1xuICAgICAgICBsZXQgdGVtcCA9IG5vZGVzW2pdLmlkO1xuICAgICAgICB6cGFyYW1zLnpzZXR4W2pdID0gYWxsTm9kZXNbdGVtcF0uc2V0eHZhbHM7XG4gICAgICAgIHpwYXJhbXMuenN1YnNldFtqXSA9IGFsbE5vZGVzW3RlbXBdLnN1YnNldHJhbmdlO1xuICAgIH1cbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxpbmtzLmxlbmd0aDsgaisrKSB7IC8vcG9wdWxhdGUgemVkZ2VzIGFycmF5XG4gICAgICAgIC8vY29ycmVjdCB0aGUgc291cmNlIHRhcmdldCBvcmRlcmluZyBmb3IgWmVsaWdcbiAgICAgICAgbGV0IHNyY3RndCA9IGxpbmtzW2pdLmxlZnQgPT0gZmFsc2UgP1xuICAgICAgICAgICAgW2xpbmtzW2pdLnNvdXJjZS5uYW1lLCBsaW5rc1tqXS50YXJnZXQubmFtZV0gOlxuICAgICAgICAgICAgW2xpbmtzW2pdLnRhcmdldC5uYW1lLCBsaW5rc1tqXS5zb3VyY2UubmFtZV07XG4gICAgICAgIHpwYXJhbXMuemVkZ2VzLnB1c2goc3JjdGd0KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHRhYnVsYXRlKGRhdGEsIGNvbHVtbnMsIGRpdmlkKSB7XG4gICAgdmFyIHRhYmxlID0gZDMuc2VsZWN0KGRpdmlkKS5hcHBlbmQoJ3RhYmxlJyk7XG4gICAgdmFyIHRoZWFkID0gdGFibGUuYXBwZW5kKCd0aGVhZCcpO1xuICAgIHZhclx0dGJvZHkgPSB0YWJsZS5hcHBlbmQoJ3Rib2R5Jyk7XG5cbiAgICAvLyBhcHBlbmQgdGhlIGhlYWRlciByb3dcbiAgICB0aGVhZC5hcHBlbmQoJ3RyJylcbiAgICAgICAgLnNlbGVjdEFsbCgndGgnKVxuICAgICAgICAuZGF0YShjb2x1bW5zKS5lbnRlcigpXG4gICAgICAgIC5hcHBlbmQoJ3RoJylcbiAgICAgICAgLnRleHQoZnVuY3Rpb24gKGNvbHVtbikgeyByZXR1cm4gY29sdW1uOyB9KTtcblxuICAgIC8vIGNyZWF0ZSBhIHJvdyBmb3IgZWFjaCBvYmplY3QgaW4gdGhlIGRhdGFcbiAgICB2YXIgcm93cyA9IHRib2R5LnNlbGVjdEFsbCgndHInKVxuICAgICAgICAuZGF0YShkYXRhKVxuICAgICAgICAuZW50ZXIoKVxuICAgICAgICAuYXBwZW5kKCd0cicpXG4gICAgICAgIC5hdHRyKCdjbGFzcycsZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICBpZihpPT0wKSByZXR1cm4gJ2l0ZW0tc2VsZWN0JztcbiAgICAgICAgICAgIGVsc2UgcmV0dXJuICdpdGVtLWRlZmF1bHQnO1xuICAgICAgICB9KTtcblxuICAgIC8vIGNyZWF0ZSBhIGNlbGwgaW4gZWFjaCByb3cgZm9yIGVhY2ggY29sdW1uXG4gICAgdmFyIGNlbGxzID0gcm93cy5zZWxlY3RBbGwoJ3RkJylcbiAgICAgICAgLmRhdGEoZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAgICAgcmV0dXJuIGNvbHVtbnMubWFwKGZ1bmN0aW9uIChjb2x1bW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge2NvbHVtbjogY29sdW1uLCB2YWx1ZTogcm93W2NvbHVtbl19O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5lbnRlcigpXG4gICAgICAgIC5hcHBlbmQoJ3RkJylcbiAgICAgICAgLnRleHQoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkLnZhbHVlO1xuICAgICAgICB9KVxuICAgICAgICAub24oXCJjbGlja1wiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICBsZXQgbXlyb3cgPSB0aGlzLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICBpZihteXJvdy5jbGFzc05hbWU9PVwiaXRlbS1zZWxlY3RcIikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KGRpdmlkKS5zZWxlY3QoXCJ0ci5pdGVtLXNlbGVjdFwiKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnaXRlbS1kZWZhdWx0Jyk7XG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KG15cm93KS5hdHRyKCdjbGFzcycsXCJpdGVtLXNlbGVjdFwiKTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInRhYjJpbnB1dFwiKS52YWx1ZT1kaXNjb1sobXlyb3cucm93SW5kZXgpLTFdLmRlc2NyaXB0aW9uO1xuICAgICAgICAgICAgICAgIGlmKGRpdmlkPT0nI3NldHhSaWdodCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c3Bsb3Rpbml0KG15cm93LmZpcnN0Q2hpbGQuaW5uZXJUZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9fSk7XG5cbiAgICAvLyB0aGlzIGlzIGNvZGUgdG8gYWRkIGEgY2hlY2tib3ggdG8gZWFjaCByb3cgb2YgdGhlIHRhYmxlXG4gICAgaWYoZGl2aWQ9PScjdGFiMicpIHtcbiAgICAgIGQzLnNlbGVjdChkaXZpZCkuc2VsZWN0QWxsKFwidHJcIilcbiAgICAgIC5hcHBlbmQoXCJpbnB1dFwiKVxuICAgICAgICAuYXR0cihcInR5cGVcIiwgXCJjaGVja2JveFwiKVxuICAgICAgICAuYXR0cihcImNoZWNrZWRcIix0cnVlKVxuICAgICAgICAgLnN0eWxlKFwiZmxvYXRcIixcInJpZ2h0XCIpO1xuICAgIH1cblxuICAgIHJldHVybiB0YWJsZTtcblxufVxuXG5mdW5jdGlvbiBvblBpcGVsaW5lQ3JlYXRlKFBpcGVsaW5lQ3JlYXRlUmVzdWx0LCByb29rcGlwZSkge1xuICAgIC8vIHJwYyBHZXRFeGVjdXRlUGlwZWxpbmVSZXN1bHRzKFBpcGVsaW5lRXhlY3V0ZVJlc3VsdHNSZXF1ZXN0KSByZXR1cm5zIChzdHJlYW0gUGlwZWxpbmVFeGVjdXRlUmVzdWx0KSB7fVxuICAgIGVzdGltYXRlTGFkZGEuc3RvcCgpOyAvLyBzdG9wIHNwaW5uZXJcbiAgICBjb25zb2xlLmxvZyhQaXBlbGluZUNyZWF0ZVJlc3VsdCk7XG5cbiAgICAvLyBjaGFuZ2Ugc3RhdHVzIG9mIGJ1dHRvbnMgZm9yIGVzdGltYXRpbmcgcHJvYmxlbSBhbmQgbWFya2luZyBwcm9ibGVtIGFzIGZpbmlzaGVkXG4gICAgJChcIiNidG5Fc3RpbWF0ZVwiKS5yZW1vdmVDbGFzcyhcImJ0bi1zdWNjZXNzXCIpO1xuICAgICQoXCIjYnRuRXN0aW1hdGVcIikuYWRkQ2xhc3MoXCJidG4tZGVmYXVsdFwiKTtcbiAgICAkKFwiI2J0bkVuZFNlc3Npb25cIikucmVtb3ZlQ2xhc3MoXCJidG4tZGVmYXVsdFwiKTtcbiAgICAkKFwiI2J0bkVuZFNlc3Npb25cIikuYWRkQ2xhc3MoXCJidG4tc3VjY2Vzc1wiKTtcblxuICAgIGxldCBjb250ZXh0ID0gYXBpU2Vzc2lvbih6cGFyYW1zLnpzZXNzaW9uaWQpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpPFBpcGVsaW5lQ3JlYXRlUmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmKFBpcGVsaW5lQ3JlYXRlUmVzdWx0W2ldLnBpcGVsaW5lSWQgaW4gYWxsUGlwZWxpbmVJbmZvKSB7XG4gICAgICAgICAgICBhbGxQaXBlbGluZUluZm9bUGlwZWxpbmVDcmVhdGVSZXN1bHRbaV0ucGlwZWxpbmVJZF09T2JqZWN0LmFzc2lnbihhbGxQaXBlbGluZUluZm9bUGlwZWxpbmVDcmVhdGVSZXN1bHRbaV0ucGlwZWxpbmVJZF0sUGlwZWxpbmVDcmVhdGVSZXN1bHRbaV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWxsUGlwZWxpbmVJbmZvW1BpcGVsaW5lQ3JlYXRlUmVzdWx0W2ldLnBpcGVsaW5lSWRdPVBpcGVsaW5lQ3JlYXRlUmVzdWx0W2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnNvbGUubG9nKGFsbFBpcGVsaW5lSW5mbyk7XG4gICAgLy8gdG8gZ2V0IGFsbCBwaXBlbGluZSBpZHM6IE9iamVjdC5rZXlzKGFsbFBpcGVsaW5lSW5mbylcblxuICAgIGxldCByZXN1bHRzdGFibGUgPSBbXTtcblxuXG4gICAgZm9yKHZhciBrZXkgaW4gYWxsUGlwZWxpbmVJbmZvKSB7XG4gICAgICAgIC8vIHRoaXMgd2lsbCBOT1QgcmVwb3J0IHRoZSBwaXBlbGluZSB0byB1c2VyIGlmIHBpcGVsaW5lIGhhcyBmYWlsZWQsIGlmIHBpcGVsaW5lIGlzIHN0aWxsIHJ1bm5pbmcsIG9yIGlmIGl0IGhhcyBub3QgY29tcGxldGVkXG4gICAgICAgIGlmKGFsbFBpcGVsaW5lSW5mb1trZXldLnJlc3BvbnNlSW5mby5zdGF0dXMuZGV0YWlscyA9PSBcIlBpcGVsaW5lIEZhaWxlZFwiKSAge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYoYWxsUGlwZWxpbmVJbmZvW2tleV0ucHJvZ3Jlc3NJbmZvID09IFwiUlVOTklOR1wiKSAge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbXlpZCA9IFwiXCI7XG4gICAgICAgIGxldCBteW1ldHJpYyA9IFwiXCI7XG4gICAgICAgIGxldCBteXZhbCA9IFwiXCI7XG4gICAgICAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICAgIGNvbnNvbGUubG9nKGFsbFBpcGVsaW5lSW5mb1trZXldLnByb2dyZXNzSW5mbylcbiAgICAgICAgbGV0IG15c2NvcmVzID0gW107XG4gICAgICAgIGlmKGFsbFBpcGVsaW5lSW5mb1trZXldLnByb2dyZXNzSW5mbyA9PSBcIkNPTVBMRVRFRFwiKXtcbiAgICAgICAgICAgIG15c2NvcmVzID0gYWxsUGlwZWxpbmVJbmZvW2tleV0ucGlwZWxpbmVJbmZvLnNjb3JlcztcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBteXNjb3Jlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vaWYoaT09MCkge215aWQ9a2V5O31cbiAgICAgICAgICAgICAgICAvLyAgIGVsc2UgbXlpZD1cIlwiO1xuICAgICAgICAgICAgICAgIG15aWQ9a2V5O1xuICAgICAgICAgICAgICAgIG15bWV0cmljPW15c2NvcmVzW2ldLm1ldHJpYztcbiAgICAgICAgICAgICAgICBteXZhbD0rbXlzY29yZXNbaV0udmFsdWUudG9GaXhlZCgzKTtcbiAgICAgICAgICAgICAgICByZXN1bHRzdGFibGUucHVzaCh7XCJQaXBlbGluZUlEXCI6bXlpZCxcIk1ldHJpY1wiOm15bWV0cmljLCBcIlNjb3JlXCI6bXl2YWx9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHsgLy8gaWYgcHJvZ3Jlc3NJbmZvIGlzIG5vdCBcIkNPTVBMRVRFRFwiXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKHJlc3VsdHN0YWJsZSk7XG4gICAgLy8gcmVuZGVyIHRoZSB0YWJsZXNcbiAgICB0YWJ1bGF0ZShyZXN1bHRzdGFibGUsIFsnUGlwZWxpbmVJRCcsICdNZXRyaWMnLCAnU2NvcmUnXSwgJyNyZXN1bHRzJyk7XG4gICAgdGFidWxhdGUocmVzdWx0c3RhYmxlLCBbJ1BpcGVsaW5lSUQnLCAnTWV0cmljJywgJ1Njb3JlJ10sICcjc2V0eFJpZ2h0Jyk7XG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgdG9nZ2xlUmlnaHRCdXR0b25zKFwiYWxsXCIpO1xuICAgIGlmIChJU19EM01fRE9NQUlOKXtcbiAgICAgICAgYnlJZChcImJ0blJlc3VsdHNcIikuY2xpY2soKTtcbiAgICB9O1xuXG4gICAgLy9hZGRpbmcgcm9va3BpcGUgdG8gYWxsUGlwZWxpbmVJbmZvXG4gICAgYWxsUGlwZWxpbmVJbmZvLnJvb2twaXBlPXJvb2twaXBlO1xuXG4gICAgLy8gdGhpcyBpbml0aWFsaXplcyB0aGUgcmVzdWx0cyB3aW5kb3dzIHVzaW5nIHRoZSBmaXJzdCBwaXBlbGluZVxuICAgIGlmKCFzd2FuZGl2ZSkge1xuICAgICAgICByZXN1bHRzcGxvdGluaXQocmVzdWx0c3RhYmxlWzBdLlBpcGVsaW5lSUQpO1xuICAgIH1cbiAgICAvLyBWSkQ6IHRoZXNlIHR3byBmdW5jdGlvbnMgYXJlIGJ1aWx0IGFuZCAoSSBiZWxpZXZlKSBmdW5jdGlvbmluZyBhcyBpbnRlbmRlZC4gVGhlc2UgZXhlcmNpc2UgdHdvIGNvcmUgQVBJIGNhbGxzIHRoYXQgYXJlIGN1cnJlbnRseSB1bm5lY2Vzc2FyeVxuICAgIC8vZXhwb3J0cGlwZWxpbmUocmVzdWx0c3RhYmxlWzFdLlBpcGVsaW5lSUQpO1xuICAgIC8vbGlzdHBpcGVsaW5lcygpO1xuXG4gICAgLy8gVkpEOiB0aGlzIGlzIGEgdGhpcmQgY29yZSBBUEkgY2FsbCB0aGF0IGlzIGN1cnJlbnRseSB1bm5lY2Vzc2FyeVxuICAgIC8vbGV0IHBpcGVsaW5laWQgPSBQaXBlbGluZUNyZWF0ZVJlc3VsdC5waXBlbGluZWlkO1xuICAgIC8vIGdldGV4ZWN1dGVwaXBlbGluZXJlc3VsdHMgaXMgdGhlIHRoaXJkIHRvIGJlIGNhbGxlZFxuICAvLyAgbWFrZVJlcXVlc3QoRDNNX1NWQ19VUkwgKyAnL2dldGV4ZWN1dGVwaXBlbGluZXJlc3VsdHMnLCB7Y29udGV4dCwgcGlwZWxpbmVfaWRzOiBPYmplY3Qua2V5cyhhbGxQaXBlbGluZUluZm8pfSk7XG59XG5cbmZ1bmN0aW9uIENyZWF0ZVBpcGVsaW5lRGF0YShwcmVkaWN0b3JzLCBkZXB2YXIsIGF1eCkge1xuICAgIGxldCBjb250ZXh0ID0gYXBpU2Vzc2lvbih6cGFyYW1zLnpzZXNzaW9uaWQpO1xuICAgIGxldCB1cmlDc3YgPSB6cGFyYW1zLnpkM21kYXRhO1xuICAgIGxldCB1cmlKc29uID0gdXJpQ3N2LnN1YnN0cmluZygwLCB1cmlDc3YubGFzdEluZGV4T2YoXCIvdGFibGVzXCIpKSArIFwiL2RhdGFzZXREb2MuanNvblwiO1xuICAgIGxldCB0YXJnZXRGZWF0dXJlcyA9IFt7ICdyZXNvdXJjZV9pZCc6IFwiMFwiLCAnZmVhdHVyZV9uYW1lJzogZGVwdmFyWzBdIH1dO1xuICAgIGxldCBwcmVkaWN0RmVhdHVyZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByZWRpY3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcHJlZGljdEZlYXR1cmVzW2ldID0geyAncmVzb3VyY2VfaWQnOiBcIjBcIiwgJ2ZlYXR1cmVfbmFtZSc6IHByZWRpY3RvcnNbaV0gfTtcbiAgICB9XG4gICAgaWYodHlwZW9mIGF1eD09PVwidW5kZWZpbmVkXCIpIHsgLy9kZWZhdWx0IGJlaGF2aW9yIGZvciBjcmVhdGluZyBwaXBlbGluZSBkYXRhXG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgZGF0YXNldF91cmk6IHVyaUpzb24sICAgLy8gdXJpQ3N2IGlzIGFsc28gdmFsaWQsIGJ1dCBub3QgY3VycmVudGx5IGFjY2VwdGVkIGJ5IElTSSBUQTJcbiAgICAgICAgdGFzazogZDNtVGFza1R5cGVbZDNtUHJvYmxlbURlc2NyaXB0aW9uLnRhc2tUeXBlXVsxXSxcbiAgICAgICAgdGFza1N1YnR5cGU6IGQzbVRhc2tTdWJ0eXBlW2QzbVByb2JsZW1EZXNjcmlwdGlvbi50YXNrU3VidHlwZV1bMV0sXG4gICAgICAgIHRhc2tEZXNjcmlwdGlvbjogZDNtUHJvYmxlbURlc2NyaXB0aW9uLnRhc2tEZXNjcmlwdGlvbixcbiAgICAgICAgb3V0cHV0OiBcIk9VVFBVVF9UWVBFX1VOREVGSU5FRFwiLCAgLy8gdmFsaWQgdmFsdWVzIHdpbGwgY29tZSBpbiBmdXR1cmUgQVBJXG4gICAgICAgIG1ldHJpY3M6IFtkM21NZXRyaWNzW2QzbVByb2JsZW1EZXNjcmlwdGlvbi5tZXRyaWNdWzFdXSxcbiAgICAgICAgdGFyZ2V0RmVhdHVyZXMsXG4gICAgICAgIC8qIEV4YW1wbGU6XG4gICAgICAgICAgXCJ0YXJnZXRGZWF0dXJlc1wiOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgICBcInJlc291cmNlX2lkXCI6IFwiMFwiLFxuICAgICAgICAgICAgICBcImZlYXR1cmVfbmFtZVwiOiBcIkF0X2JhdHNcIlxuICAgICAgICAgIH1cbiAgICAgICAgICBdLFxuICAgICAgICAqL1xuICAgICAgICBwcmVkaWN0RmVhdHVyZXMsXG4gICAgICAgIC8qIEV4YW1wbGU6XG4gICAgICAgICAgXCJwcmVkaWN0UmVhdHVyZXNcIjogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIFwicmVzb3VyY2VfaWRcIjogXCIwXCIsXG4gICAgICAgICAgICBcImZlYXR1cmVfbmFtZVwiOiBcIlJCSXNcIlxuICAgICAgICAgIH1cbiAgICAgICAgICBdLFxuICAgICAgICAqL1xuICAgICAgICBtYXhQaXBlbGluZXM6IDUgLy91c2VyIHRvIHNwZWNpZnkgdGhpcyBldmVudHVhbGx5P1xuICAgIH07fVxuICAgIGVsc2UgeyAvL2NyZWF0aW5nIHBpcGVsaW5lIGRhdGEgZm9yIHByb2JsZW0gZGlzY292ZXJ5IHVzaW5nIGF1eCBpbnB1dHNcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgZGF0YXNldF91cmk6IHVyaUpzb24sICAgLy8gdXJpQ3N2IGlzIGFsc28gdmFsaWQsIGJ1dCBub3QgY3VycmVudGx5IGFjY2VwdGVkIGJ5IElTSSBUQTJcbiAgICAgICAgdGFzazogYXV4LnRhc2ssXG4gICAgICAgIHRhc2tTdWJ0eXBlOiBcIlRBU0tfU1VCVFlQRV9VTkRFRklORURcIixcbiAgICAgICAgdGFza0Rlc2NyaXB0aW9uOiBhdXguZGVzY3JpcHRpb24sXG4gICAgICAgIG91dHB1dDogXCJPVVRQVVRfVFlQRV9VTkRFRklORURcIixcbiAgICAgICAgbWV0cmljczogW2F1eC5tZXRyaWNzXSxcbiAgICAgICAgdGFyZ2V0RmVhdHVyZXMsXG4gICAgICAgIHByZWRpY3RGZWF0dXJlcyxcbiAgICAgICAgbWF4UGlwZWxpbmVzOiAxXG4gICAgICAgIH07XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZG93bmxvYWRJbmNvbXBsZXRlKCkge1xuICAgIGlmIChQUk9EVUNUSU9OICYmIHpwYXJhbXMuenNlc3Npb25pZCA9PT0gJycpIHtcbiAgICAgICAgYWxlcnQoJ1dhcm5pbmc6IERhdGEgZG93bmxvYWQgaXMgbm90IGNvbXBsZXRlLiBUcnkgYWdhaW4gc29vbi4nKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gICAgY2FsbGVkIGJ5IGNsaWNraW5nICdTb2x2ZSBUaGlzIFByb2JsZW0nIGluIG1vZGVsIG1vZGVcbiovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZXN0aW1hdGUoYnRuKSB7XG4gICAgaWYgKCFJU19EM01fRE9NQUlOKXtcbiAgICAgICAgaWYgKGRvd25sb2FkSW5jb21wbGV0ZSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB6UG9wKCk7XG4gICAgICAgIC8vIHdyaXRlIGxpbmtzIHRvIGZpbGUgJiBydW4gUiBDTURcbiAgICAgICAgLy8gcGFja2FnZSB0aGUgb3V0cHV0IGFzIEpTT05cbiAgICAgICAgLy8gYWRkIGNhbGwgaGlzdG9yeSBhbmQgcGFja2FnZSB0aGUgenBhcmFtcyBvYmplY3QgYXMgSlNPTlxuICAgICAgICB6cGFyYW1zLmNhbGxIaXN0b3J5ID0gY2FsbEhpc3Rvcnk7XG4gICAgICAgIHpwYXJhbXMuYWxsVmFycyA9IHZhbHVlS2V5LnNsaWNlKDEwLCAyNSk7IC8vIGJlY2F1c2UgdGhlIFVSTCBpcyB0b28gbG9uZy4uLlxuXG4gICAgICAgIC8qIFVOVVNFRFxuICAgICAgICB2YXIgc2VsZWN0b3J1cmxjYWxsID0gUk9PS19TVkNfVVJMICsgXCJzZWxlY3RvcmFwcFwiO1xuICAgICAgICBmdW5jdGlvbiBzZWxlY3RvclN1Y2Nlc3MoYnRuLCBqc29uKSB7XG4gICAgICAgICAgICBkMy5zZWxlY3QoXCIjdGlja2VyXCIpXG4gICAgICAgICAgICAgICAgLnRleHQoXCJTdWdnZXN0ZWQgdmFyaWFibGVzIGFuZCBwZXJjZW50IGltcHJvdmVtZW50IG9uIFJNU0U6IFwiICsganNvbi52YXJzKTtcbiAgICAgICAgICAgIGNkYihcInNlbGVjdG9yU3VjY2VzczogXCIsIGpzb24pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNlbGVjdG9yRmFpbChidG4pIHtcbiAgICAgICAgICAgIGFsZXJ0KFwiU2VsZWN0b3IgRmFpbFwiKTtcbiAgICAgICAgfVxuICAgICAgICAqL1xuXG4gICAgICAgIGVzdGltYXRlTGFkZGEuc3RhcnQoKTsgLy8gc3RhcnQgc3Bpbm5lclxuICAgICAgICBsZXQganNvbiA9IGF3YWl0IG1ha2VSZXF1ZXN0KFJPT0tfU1ZDX1VSTCArICd6ZWxpZ2FwcCcsIHpwYXJhbXMpO1xuICAgICAgICBpZiAoIWpzb24pIHtcbiAgICAgICAgICAgIGVzdGltYXRlZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbGxSZXN1bHRzLnB1c2goanNvbik7XG4gICAgICAgICAgICBpZiAoIWVzdGltYXRlZCkgYnlJZChcInJlc3VsdHNcIikucmVtb3ZlQ2hpbGQoYnlJZChcInJlc3VsdHNIb2xkZXJcIikpO1xuXG4gICAgICAgICAgICBlc3RpbWF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgZDMuc2VsZWN0KFwiI3Jlc3VsdHNcIilcbiAgICAgICAgICAgICAgICAuc3R5bGUoXCJkaXNwbGF5XCIsIFwiYmxvY2tcIik7XG5cbiAgICAgICAgICAgIGQzLnNlbGVjdChcIiNyZXN1bHRzVmlld1wiKVxuICAgICAgICAgICAgICAgIC5zdHlsZShcImRpc3BsYXlcIiwgXCJibG9ja1wiKTtcblxuICAgICAgICAgICAgZDMuc2VsZWN0KFwiI21vZGVsVmlld1wiKVxuICAgICAgICAgICAgICAgIC5zdHlsZShcImRpc3BsYXlcIiwgXCJibG9ja1wiKTtcblxuXG4gICAgICAgICAgICAvLyBwcm9ncmFtbWF0aWMgY2xpY2sgb24gUmVzdWx0cyBidXR0b25cbiAgICAgICAgICAgICQoXCIjYnRuUmVzdWx0c1wiKS50cmlnZ2VyKFwiY2xpY2tcIik7XG5cbiAgICAgICAgICAgIGxldCBtb2RlbCA9IFwiTW9kZWxcIi5jb25jYXQobW9kZWxDb3VudCA9IG1vZGVsQ291bnQgKyAxKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gbW9kQ29sKCkge1xuICAgICAgICAgICAgICAgIGQzLnNlbGVjdChcIiNtb2RlbFZpZXdcIilcbiAgICAgICAgICAgICAgICAgICAgLnNlbGVjdEFsbChcInBcIilcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJywgaGV4VG9SZ2JhKHZhckNvbG9yKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtb2RDb2woKTtcblxuICAgICAgICAgICAgZDMuc2VsZWN0KFwiI21vZGVsVmlld1wiKVxuICAgICAgICAgICAgICAgIC5pbnNlcnQoXCJwXCIsIFwiOmZpcnN0LWNoaWxkXCIpIC8vIHRvcCBzdGFjayBmb3IgcmVzdWx0c1xuICAgICAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgbW9kZWwpXG4gICAgICAgICAgICAgICAgLnRleHQobW9kZWwpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJywgaGV4VG9SZ2JhKHNlbFZhckNvbG9yKSlcbiAgICAgICAgICAgICAgICAub24oXCJjbGlja1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSB0aGlzLnN0eWxlLmJhY2tncm91bmRDb2xvci5yZXBsYWNlKC9cXHMqL2csIFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IGhleFRvUmdiYShzZWxWYXJDb2xvcikucmVwbGFjZSgvXFxzKi9nLCBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGEuc3Vic3RyKDAsIDE3KSA9PSBiLnN1YnN0cigwLCAxNykpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIGVzY2FwZSBmdW5jdGlvbiBpZiBkaXNwbGF5ZWQgbW9kZWwgaXMgY2xpY2tlZFxuICAgICAgICAgICAgICAgICAgICBtb2RDb2woKTtcbiAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ2JhY2tncm91bmQtY29sb3InLCBoZXhUb1JnYmEoc2VsVmFyQ29sb3IpKTtcbiAgICAgICAgICAgICAgICAgICAgdml6KHRoaXMuaWQpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBsZXQgckNhbGwgPSBbanNvbi5jYWxsXTtcbiAgICAgICAgICAgIHNob3dMb2coJ2VzdGltYXRlJywgckNhbGwpO1xuXG4gICAgICAgICAgICB2aXoobW9kZWwpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChzd2FuZGl2ZSkgeyAvLyBJU19EM01fRE9NQUlOIGFuZCBzd2FuZGl2ZSBpcyB0cnVlXG4gICAgICAgIHpQb3AoKTtcbiAgICAgICAgenBhcmFtcy5jYWxsSGlzdG9yeSA9IGNhbGxIaXN0b3J5O1xuXG4gICAgICAgIGxldCBteXZraSA9IHZhbHVlS2V5LmluZGV4T2YobXl0YXJnZXQpO1xuICAgICAgICBpZihteXZraSAhPSAtMSkge1xuICAgICAgICAgICAgZGVsKHZhbHVlS2V5LCBteXZraSk7XG4gICAgICAgIH1cblxuICAgICAgICBlc3RpbWF0ZUxhZGRhLnN0YXJ0KCk7IC8vIHN0YXJ0IHNwaW5uZXJcbiAgICAgICAgbGV0IHJlcyA9IGF3YWl0IG1ha2VSZXF1ZXN0KEQzTV9TVkNfVVJMICsgJy9DcmVhdGVQaXBlbGluZXMnLCBDcmVhdGVQaXBlbGluZURhdGEodmFsdWVLZXksIG15dGFyZ2V0KSk7XG4gICAgICAgIHJlcyAmJiBvblBpcGVsaW5lQ3JlYXRlKHJlcyk7XG4gICAgfSBlbHNlIHsgLy8gd2UgYXJlIGluIElTX0QzTV9ET01BSU4gbm8gc3dhbmRpdmVcbiAgICAgICAgLy8gcnBjIENyZWF0ZVBpcGVsaW5lcyhQaXBlbGluZUNyZWF0ZVJlcXVlc3QpIHJldHVybnMgKHN0cmVhbSBQaXBlbGluZUNyZWF0ZVJlc3VsdCkge31cbiAgICAgICAgelBvcCgpO1xuICAgICAgICB6cGFyYW1zLmNhbGxIaXN0b3J5ID0gY2FsbEhpc3Rvcnk7XG5cbiAgICAgICAgLy8gcGlwZWxpbmVhcHAgaXMgYSByb29rIGFwcGxpY2F0aW9uIHRoYXQgcmV0dXJucyB0aGUgZGVwZW5kZW50IHZhcmlhYmxlLCB0aGUgRFYgdmFsdWVzLCBhbmQgdGhlIHByZWRpY3RvcnMuIGNhbiB0aGluayBvZiBpdCB3YXMgYSB3YXkgdG8gdHJhbnNsYXRlIHRoZSBwb3RlbnRpYWxseSBjb21wbGV4IGdyYW1tYXIgZnJvbSB0aGUgVUlcblxuICAgICAgICBlc3RpbWF0ZUxhZGRhLnN0YXJ0KCk7IC8vIHN0YXJ0IHNwaW5uZXJcbiAgICAgICAgbGV0IHJvb2twaXBlID0gYXdhaXQgbWFrZVJlcXVlc3QoUk9PS19TVkNfVVJMICsgJ3BpcGVsaW5lYXBwJywgenBhcmFtcyk7XG4gICAgICAgIGlmICghcm9va3BpcGUpIHtcbiAgICAgICAgICAgIGVzdGltYXRlZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKHJvb2twaXBlKTtcbiAgICAgICAgICAgIHNldHhUYWJsZShyb29rcGlwZS5wcmVkaWN0b3JzKTtcbiAgICAgICAvLyAgICAgbGV0IGR2dmFscyA9IHJlcy5kdnZhbHVlcztcbiAgICAgICAgLy8gICAgbGV0IGR2dmFyID0gcmVzLmRlcHZhclswXTtcbiAgICAgICAgICBsZXQgcmVzID0gYXdhaXQgbWFrZVJlcXVlc3QoRDNNX1NWQ19VUkwgKyAnL0NyZWF0ZVBpcGVsaW5lcycsIENyZWF0ZVBpcGVsaW5lRGF0YShyb29rcGlwZS5wcmVkaWN0b3JzLCByb29rcGlwZS5kZXB2YXIpKTtcbiAgICAgICAgIC8vICAgcmVzID0gYXdhaXQgbWFrZVJlcXVlc3QoUk9PS19TVkNfVVJMICsgJ2NyZWF0ZXBpcGVsaW5lJywgenBhcmFtcyk7XG4gICAgICAgICAgICByZXMgJiYgb25QaXBlbGluZUNyZWF0ZShyZXMsIHJvb2twaXBlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0YXNrMl9maW5pc2hlZCA9IHRydWU7XG59XG5cbi8qKiBuZWVkcyBkb2MgKi9cbmV4cG9ydCBmdW5jdGlvbiB0YTJzdHVmZigpIHtcbiAgICBjb25zb2xlLmxvZyhkM21Qcm9ibGVtRGVzY3JpcHRpb24pO1xufVxuXG4vKiogbmVlZHMgZG9jICovXG5hc3luYyBmdW5jdGlvbiBkYXRhRG93bmxvYWQoKSB7XG4gICAgelBvcCgpO1xuICAgIC8vIHdyaXRlIGxpbmtzIHRvIGZpbGUgJiBydW4gUiBDTURcblxuICAgIC8vIHBhY2thZ2UgdGhlIG91dHB1dCBhcyBKU09OXG4gICAgLy8gYWRkIGNhbGwgaGlzdG9yeSBhbmQgcGFja2FnZSB0aGUgenBhcmFtcyBvYmplY3QgYXMgSlNPTlxuICAgIGxldCByZXMgPSBhd2FpdCBtYWtlUmVxdWVzdChST09LX1NWQ19VUkwgKyAnZGF0YWFwcCcsIHpwYXJhbXMpO1xuICAgIGlmICghcmVzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB6cGFyYW1zLnpzZXNzaW9uaWQgPSByZXMuc2Vzc2lvbmlkWzBdO1xuICAgIC8vIHNldCBsaW5rIFVSTFxuICAgIGJ5SWQoXCJsb2dJRFwiKS5ocmVmID0gYCR7UFJPRFVDVElPTiA/IFJPT0tfU1ZDX1VSTCArICdsb2dfZGlyL2xvZ18nIDogJ3Jvb2svbG9nXycgfSR7enBhcmFtcy56c2Vzc2lvbmlkfS50eHRgO1xufVxuXG4vKiogbmVlZHMgZG9jICovXG5mdW5jdGlvbiB2aXoobXltKSB7XG4gICAgbXltID0gK215bS5zdWJzdHIoNSwgNSkgLSAxO1xuXG4gICAgbGV0IHJlbW92ZUtpZHMgPSBwYXJlbnQgPT4ge1xuICAgICAgICB3aGlsZSAocGFyZW50LmZpcnN0Q2hpbGQpXG4gICAgICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQocGFyZW50LmZpcnN0Q2hpbGQpO1xuICAgIH07XG4gICAgcmVtb3ZlS2lkcyhieUlkKFwicmVzdWx0c1ZpZXdcIikpO1xuXG4gICAgbGV0IGpzb24gPSBhbGxSZXN1bHRzW215bV07XG5cbiAgICAvLyBwaXBlIGluIGZpZ3VyZXMgdG8gcmlnaHQgcGFuZWxcbiAgICB2YXIgZmlsZWxpc3QgPSBuZXcgQXJyYXk7XG4gICAgZm9yICh2YXIgaSBpbiBqc29uLmltYWdlcykge1xuICAgICAgICB2YXIgemZpZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG4gICAgICAgIHpmaWcuc2V0QXR0cmlidXRlKFwic3JjXCIsIGpzb24uaW1hZ2VzW2ldKTtcbiAgICAgICAgemZpZy5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgMjAwKTtcbiAgICAgICAgemZpZy5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIDIwMCk7XG4gICAgICAgIGJ5SWQoXCJyZXN1bHRzVmlld1wiKS5hcHBlbmRDaGlsZCh6ZmlnKTtcbiAgICB9XG5cbiAgICAvLyB3cml0ZSB0aGUgcmVzdWx0cyB0YWJsZVxuICAgIHZhciByZXN1bHRzQXJyYXkgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4ganNvbi5zdW1JbmZvKSB7XG4gICAgICAgIGlmIChrZXkgPT0gJ2NvbG5hbWVzJylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICByZXN1bHRzQXJyYXkucHVzaChqc29uLnN1bUluZm9ba2V5XSk7XG4gICAgfVxuXG4gICAgdmFyIHRhYmxlID0gZDMuc2VsZWN0KFwiI3Jlc3VsdHNWaWV3XCIpXG4gICAgICAgIC5hcHBlbmQoXCJwXCIpXG4gICAgICAgIC5hcHBlbmQoXCJ0YWJsZVwiKTtcblxuICAgIHZhciB0aGVhZCA9IHRhYmxlLmFwcGVuZChcInRoZWFkXCIpO1xuICAgIHRoZWFkLmFwcGVuZChcInRyXCIpXG4gICAgICAgIC5zZWxlY3RBbGwoXCJ0aFwiKVxuICAgICAgICAuZGF0YShqc29uLnN1bUluZm8uY29sbmFtZXMpXG4gICAgICAgIC5lbnRlcigpXG4gICAgICAgIC5hcHBlbmQoXCJ0aFwiKVxuICAgICAgICAudGV4dChkID0+IGQpO1xuXG4gICAgdmFyIHRib2R5ID0gdGFibGUuYXBwZW5kKFwidGJvZHlcIik7XG4gICAgdGJvZHkuc2VsZWN0QWxsKFwidHJcIilcbiAgICAgICAgLmRhdGEocmVzdWx0c0FycmF5KVxuICAgICAgICAuZW50ZXIoKS5hcHBlbmQoXCJ0clwiKVxuICAgICAgICAuc2VsZWN0QWxsKFwidGRcIilcbiAgICAgICAgLmRhdGEoZCA9PiBkKVxuICAgICAgICAuZW50ZXIoKS5hcHBlbmQoXCJ0ZFwiKVxuICAgICAgICAudGV4dChmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICB2YXIgbXlOdW0gPSBOdW1iZXIoZCk7XG4gICAgICAgICAgICBpZiAoaXNOYU4obXlOdW0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgICAgcmV0dXJuIG15TnVtLnRvUHJlY2lzaW9uKDMpO1xuICAgICAgICB9KVxuICAgICAgICAub24oXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuc3R5bGUoXCJiYWNrZ3JvdW5kLWNvbG9yXCIsIFwiYWxpY2VibHVlXCIpO1xuICAgICAgICB9KSAvLyBmb3Igbm8gZGlzY2VybmFibGUgcmVhc29uXG4gICAgICAgIC5vbihcIm1vdXNlb3V0XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnN0eWxlKFwiYmFja2dyb3VuZC1jb2xvclwiLCBcIiNGOUY5RjlcIik7XG4gICAgICAgIH0pOyAvLyhidXQgbWF5YmUgd2UnbGwgdGhpbmsgb2Ygb25lKVxuXG4gICAgZDMuc2VsZWN0KFwiI3Jlc3VsdHNWaWV3XCIpXG4gICAgICAgIC5hcHBlbmQoXCJwXCIpXG4gICAgICAgIC5odG1sKCgpID0+IFwiPGI+Rm9ybXVsYTogPC9iPlwiLmNvbmNhdChqc29uLmNhbGxbMF0pKTtcblxuICAgIG0ucmVkcmF3KCk7XG59XG5cbi8qKlxuICAgcGFyc2VzIHRoZSB0cmFuc2Zvcm1hdGlvbiBpbnB1dC5cbiAgIHZhcmlhYmxlIG5hbWVzIGFyZSBvZnRlbiBuZXN0ZWQgaW5zaWRlIG9uZSBhbm90aGVyLCBlLmcuLCBldGh3YXIsIHdhciwgd2FycywgYW5kIHNvIHRoaXMgaXMgaGFuZGxlZFxuKi9cbmZ1bmN0aW9uIHRyYW5zUGFyc2Uobikge1xuICAgIHZhciBvdXQyID0gW107XG4gICAgdmFyIHQyID0gbjtcbiAgICB2YXIgazIgPSAwO1xuICAgIHZhciBzdWJNZTIgPSBcIl90cmFuc3ZhclwiLmNvbmNhdChrMik7XG4gICAgdmFyIGluZGV4ZWQgPSBbXTtcblxuICAgIC8vIG91dDIgaXMgYWxsIG1hdGNoZWQgdmFyaWFibGVzLCBpbmRleGVkIGlzIGFuIGFycmF5LCBlYWNoIGVsZW1lbnQgaXMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIG1hdGNoZWQgdmFyaWFibGVzIHN0YXJ0aW5nIGluZGV4IGFuZCBmaW5pc2hpbmcgaW5kZXguICBlLmcuLCBuPVwid2FycysyXCIsIG91dDI9W3dhciwgd2Fyc10sIGluZGV4ZWQ9W3swLDJ9LHswLDN9XVxuICAgIGZvciAodmFyIGkgaW4gdmFsdWVLZXkpIHtcbiAgICAgICAgdmFyIG0yID0gbi5tYXRjaCh2YWx1ZUtleVtpXSk7XG4gICAgICAgIGlmIChtMiAhPSBudWxsKVxuICAgICAgICAgICAgb3V0Mi5wdXNoKG0yWzBdKTtcblxuICAgICAgICB2YXIgcmUgPSBuZXcgUmVnRXhwKHZhbHVlS2V5W2ldLCBcImdcIik7XG4gICAgICAgIHZhciBzID0gbi5zZWFyY2gocmUpO1xuICAgICAgICBpZiAocyAhPSAtMSlcbiAgICAgICAgICAgIGluZGV4ZWQucHVzaCh7ZnJvbTogcywgdG86IHMgKyB2YWx1ZUtleVtpXS5sZW5ndGh9KTtcbiAgICB9XG5cbiAgICAvLyBuZXN0ZWQgbG9vcCBub3QgZ29vZCwgYnV0IGluZGV4ZWQgaXMgbm90IGxpa2VseSB0byBiZSB2ZXJ5IGxhcmdlLlxuICAgIC8vIGlmIGEgdmFyaWFibGUgaXMgbmVzdGVkLCBpdCBpcyByZW1vdmVkIGZyb20gb3V0MlxuICAgIC8vIG5vdGljZSwgbG9vcCBpcyBiYWNrd2FyZHMgc28gdGhhdCBpbmRleCBjaGFuZ2VzIGRvbid0IGFmZmVjdCB0aGUgc3BsaWNlXG4gICAgY2RiKFwiaW5kZXhlZCBcIiwgaW5kZXhlZCk7XG4gICAgZm9yICh2YXIgaSA9IGluZGV4ZWQubGVuZ3RoIC0gMTsgaSA+IC0xOyBpLS0pIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IGluZGV4ZWQubGVuZ3RoIC0gMTsgaiA+IC0xOyBqLS0pIHtcbiAgICAgICAgICAgIGlmIChpID09PSBqKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKChpbmRleGVkW2ldLmZyb20gPj0gaW5kZXhlZFtqXS5mcm9tKSAmIChpbmRleGVkW2ldLnRvIDw9IGluZGV4ZWRbal0udG8pKSB7XG4gICAgICAgICAgICAgICAgY2RiKGksIFwiIGlzIG5lc3RlZCBpbiBcIiwgaik7XG4gICAgICAgICAgICAgICAgZGVsKG91dDIsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSBpbiBvdXQyKSB7XG4gICAgICAgIHQyID0gdDIucmVwbGFjZShvdXQyW2ldLCBzdWJNZTIpOyAvL3NvbWV0aGluZyB0aGF0J2xsIG5ldmVyIGJlIGEgdmFyaWFibGUgbmFtZVxuICAgICAgICBrMiA9IGsyICsgMTtcbiAgICAgICAgc3ViTWUyID0gXCJfdHJhbnN2YXJcIi5jb25jYXQoazIpO1xuICAgIH1cblxuICAgIGlmIChvdXQyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgb3V0Mi5wdXNoKHQyKTtcbiAgICAgICAgY2RiKFwibmV3IG91dCBcIiwgb3V0Mik7XG4gICAgICAgIHJldHVybiAob3V0Mik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYWxlcnQoXCJObyB2YXJpYWJsZSBuYW1lIGZvdW5kLiBQZXJoYXBzIGNoZWNrIHlvdXIgc3BlbGxpbmc/XCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cbi8qKlxuICAgbiA9IG5hbWUgb2YgY29sdW1uL25vZGVcbiAgIHQgPSBzZWxlY3RlZCB0cmFuc2Zvcm1hdGlvblxuKi9cbmFzeW5jIGZ1bmN0aW9uIHRyYW5zZm9ybShuLCB0LCB0eXBlVHJhbnNmb3JtKSB7XG4gICAgaWYgKGRvd25sb2FkSW5jb21wbGV0ZSgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXR5cGVUcmFuc2Zvcm0pXG4gICAgICAgIHQgPSB0LnJlcGxhY2UoXCIrXCIsIFwiX3BsdXNfXCIpOyAvLyBjYW4ndCBzZW5kIHRoZSBwbHVzIG9wZXJhdG9yXG5cbiAgICBjZGIoJ25hbWUgb2YgY29sOiAnICsgbik7XG4gICAgY2RiKCd0cmFuc2Zvcm1hdGlvbjogJyArIHQpO1xuXG4gICAgdmFyIGJ0biA9IGJ5SWQoJ2J0bkVzdGltYXRlJyk7XG5cbiAgICAvLyBmaW5kIHRoZSBub2RlIGJ5IG5hbWVcbiAgICB2YXIgbXluID0gZmluZE5vZGVJbmRleChuWzBdLCB0cnVlKTtcblxuICAgIGlmICh0eXBlb2YgbXluID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIG15biA9IGZpbmROb2RlSW5kZXgobiwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgdmFyIG91dHR5cGVzID0ge1xuICAgICAgICB2YXJuYW1lc1R5cGVzOiBuLFxuICAgICAgICBpbnRlcnZhbDogbXluLmludGVydmFsLFxuICAgICAgICBudW1jaGFyOiBteW4ubnVtY2hhcixcbiAgICAgICAgbmF0dXJlOiBteW4ubmF0dXJlLFxuICAgICAgICBiaW5hcnk6IG15bi5iaW5hcnlcbiAgICB9O1xuXG4gICAgY2RiKG15bik7XG4gICAgLy8gaWYgdHlwZVRyYW5zZm9ybSBidXQgd2UgYWxyZWFkeSBoYXZlIHRoZSBtZXRhZGF0YVxuICAgIGlmICh0eXBlVHJhbnNmb3JtKSB7XG4gICAgICAgIGlmIChteW4ubmF0dXJlID09IFwibm9taW5hbFwiICYgdHlwZW9mIG15bi5wbG90dmFsdWVzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBteW4ucGxvdHR5cGUgPSBcImJhclwiO1xuICAgICAgICAgICAgYmFyc05vZGUobXluKTtcbiAgICAgICAgICAgIHBhbmVsUGxvdHMoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmIChteW4ubmF0dXJlICE9IFwibm9taW5hbFwiICYgdHlwZW9mIG15bi5wbG90eCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgbXluLnBsb3R0eXBlID0gXCJjb250aW51b3VzXCI7XG4gICAgICAgICAgICBkZW5zaXR5Tm9kZShteW4pO1xuICAgICAgICAgICAgcGFuZWxQbG90cygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZXN0aW1hdGVMYWRkYS5zdGFydCgpOyAvLyBzdGFydCBzcGlubmVyXG4gICAgbGV0IGpzb24gPSBhd2FpdCBtYWtlUmVxdWVzdChcbiAgICAgICAgUk9PS19TVkNfVVJMICsgJ3RyYW5zZm9ybWFwcCcsXG4gICAgICAgIHt6ZGF0YXVybDogZGF0YXVybCxcbiAgICAgICAgIHp2YXJzOiBteW4ubmFtZSxcbiAgICAgICAgIHpzZXNzaW9uaWQ6IHpwYXJhbXMuenNlc3Npb25pZCxcbiAgICAgICAgIHRyYW5zZm9ybTogdCxcbiAgICAgICAgIGNhbGxIaXN0b3J5OiBjYWxsSGlzdG9yeSxcbiAgICAgICAgIHR5cGVUcmFuc2Zvcm06IHR5cGVUcmFuc2Zvcm0sXG4gICAgICAgICB0eXBlU3R1ZmY6IG91dHR5cGVzfSk7XG4gICAgaWYgKCFqc29uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJcyB0aGlzIGEgdHlwZVRyYW5zZm9ybT9cbiAgICBpZiAoanNvbi50eXBlVHJhbnNmb3JtWzBdKSB7XG4gICAgICAgIC8vIFllcy4gV2UncmUgdXBkYXRpbmcgYW4gZXhpc3Rpbmcgbm9kZVxuICAgICAgICBkMy5qc29uKGpzb24udXJsLCAoZXJyLCBkYXRhKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKVxuICAgICAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oZXJyKTtcbiAgICAgICAgICAgIGxldCBub2RlO1xuICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIGRhdGEpIHtcbiAgICAgICAgICAgICAgICBub2RlID0gZmluZE5vZGVJbmRleChrZXksIHRydWUpO1xuXHRcdCAgICAgICAgICAgIGlmICghbm9kZSlcblx0XHQgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgalF1ZXJ5LmV4dGVuZCh0cnVlLCBub2RlLCBkYXRhW2tleV0pO1xuICAgICAgICAgICAgICAgIG5vZGUucGxvdHR5cGUgPT09IFwiY29udGludW91c1wiID8gZGVuc2l0eU5vZGUobm9kZSkgOlxuICAgICAgICAgICAgICAgICAgICBub2RlLnBsb3R0eXBlID09PSBcImJhclwiID8gYmFyc05vZGUobm9kZSkgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmFrZUNsaWNrKCk7XG4gICAgICAgICAgICBwYW5lbFBsb3RzKCk7XG4gICAgICAgICAgICBub2RlICYmIGNkYihub2RlKTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLyogTm8sIHdlIGhhdmUgYSBuZXcgbm9kZSBoZXJlLS1lLmcuIHRoZSB0cmFuc2Zvcm1lZCBjb2x1bW5cbiAgICAgICAgICAgZXhhbXBsZSByZXNwb25zZToge1xuICAgICAgICAgICBcImNhbGxcIjpbXCJ0X3llYXJfMlwiXSxcbiAgICAgICAgICAgXCJ1cmxcIjpbXCJkYXRhL3ByZXByb2Nlc3NTdWJzZXRfQkFDQ0JDNzgtN0REOS00NDgyLUIzMUQtNkVCMDFDM0EwQzk1LnR4dFwiXSxcbiAgICAgICAgICAgXCJ0cmFuc1wiOltcInllYXJcIixcIl90cmFuc3ZhcjBeMlwiXSxcbiAgICAgICAgICAgXCJ0eXBlVHJhbnNmb3JtXCI6W2ZhbHNlXVxuICAgICAgICAgICB9XG4gICAgICAgICovXG4gICAgICAgIGNhbGxIaXN0b3J5LnB1c2goe1xuICAgICAgICAgICAgZnVuYzogXCJ0cmFuc2Zvcm1cIixcbiAgICAgICAgICAgIHp2YXJzOiBuLFxuICAgICAgICAgICAgdHJhbnNmb3JtOiB0XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBzdWJzZXRlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgckNhbGwgPSBbXTtcblxuICAgICAgICByQ2FsbFswXSA9IGpzb24uY2FsbDtcbiAgICAgICAgdmFyIG5ld1ZhciA9IHJDYWxsWzBdWzBdO1xuXG4gICAgICAgIHRyYW5zLnB1c2gobmV3VmFyKTtcblxuICAgICAgICAvLyBSZWFkIHRoZSBwcmVwcm9jZXNzIGZpbGUgY29udGFpbmluZyB2YWx1ZXNcbiAgICAgICAgLy8gZm9yIHRoZSB0cmFuc2Zvcm1lZCB2YXJpYWJsZVxuICAgICAgICAvL1xuICAgICAgICBkMy5qc29uKGpzb24udXJsLCBmdW5jdGlvbihlcnJvciwganNvbikge1xuICAgICAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gY29uc29sZS53YXJuKGVycm9yKTtcblxuICAgICAgICAgICAgdmFyIGpzb25kYXRhID0gZ2V0VmFyaWFibGVEYXRhKGpzb24pO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4ganNvbmRhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgbXlJbmRleCA9IGZpbmROb2RlSW5kZXgoa2V5KTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG15SW5kZXggIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxlcnQoXCJJbnZhbGlkIHRyYW5zZm9ybWF0aW9uOiB0aGlzIHZhcmlhYmxlIG5hbWUgYWxyZWFkeSBleGlzdHMuXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGFkZCB0cmFuc2Zvcm1lZCB2YXJpYWJsZSB0byB0aGUgY3VycmVudCBzcGFjZVxuICAgICAgICAgICAgICAgIHZhciBpID0gYWxsTm9kZXMubGVuZ3RoOyAgLy8gZ2V0IG5ldyBpbmRleFxuICAgICAgICAgICAgICAgIHZhciBvYmoxID0ge1xuICAgICAgICAgICAgICAgICAgICBpZDogaSxcbiAgICAgICAgICAgICAgICAgICAgcmVmbGV4aXZlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZToga2V5LFxuICAgICAgICAgICAgICAgICAgICBsYWJsOiBcInRyYW5zZm9ybWxhYmVsXCIsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IFs1LCAxNSwgMjAsIDAsIDUsIDE1LCAyMF0sXG4gICAgICAgICAgICAgICAgICAgIGNvdW50OiBbLjYsIC4yLCAuOSwgLjgsIC4xLCAuMywgLjRdLFxuICAgICAgICAgICAgICAgICAgICBub2RlQ29sOiBjb2xvcnMoaSksXG4gICAgICAgICAgICAgICAgICAgIGJhc2VDb2w6IGNvbG9ycyhpKSxcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlQ29sb3I6IHNlbFZhckNvbG9yLFxuICAgICAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogXCIxXCIsXG4gICAgICAgICAgICAgICAgICAgIHN1YnNldHBsb3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBzdWJzZXRyYW5nZTogW1wiXCIsIFwiXCJdLFxuICAgICAgICAgICAgICAgICAgICBzZXR4cGxvdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHNldHh2YWxzOiBbXCJcIiwgXCJcIl0sXG4gICAgICAgICAgICAgICAgICAgIGdyYXlvdXQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0SW50ZXJ2YWw6IGpzb25kYXRhW2tleV0uaW50ZXJ2YWwsXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHROdW1jaGFyOiBqc29uZGF0YVtrZXldLm51bWNoYXIsXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHROYXR1cmU6IGpzb25kYXRhW2tleV0ubmF0dXJlLFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0QmluYXJ5OiBqc29uZGF0YVtrZXldLmJpbmFyeVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBqUXVlcnkuZXh0ZW5kKHRydWUsIG9iajEsIGpzb25kYXRhW2tleV0pO1xuICAgICAgICAgICAgICAgIGFsbE5vZGVzLnB1c2gob2JqMSk7XG5cbiAgICAgICAgICAgICAgICB2YWx1ZUtleS5wdXNoKG5ld1Zhcik7XG4gICAgICAgICAgICAgICAgbm9kZXMucHVzaChhbGxOb2Rlc1tpXSk7XG4gICAgICAgICAgICAgICAgZmFrZUNsaWNrKCk7XG4gICAgICAgICAgICAgICAgcGFuZWxQbG90cygpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGFsbE5vZGVzW2ldLnBsb3R0eXBlID09PSBcImNvbnRpbnVvdXNcIikge1xuICAgICAgICAgICAgICAgICAgICBkZW5zaXR5Tm9kZShhbGxOb2Rlc1tpXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhbGxOb2Rlc1tpXS5wbG90dHlwZSA9PT0gXCJiYXJcIikge1xuICAgICAgICAgICAgICAgICAgICBiYXJzTm9kZShhbGxOb2Rlc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbS5yZWRyYXcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgc2hvd0xvZygndHJhbnNmb3JtJywgckNhbGwpO1xuICAgIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG1ha2VSZXF1ZXN0KHVybCwgZGF0YSkge1xuICAgIGNvbnNvbGUubG9nKCd1cmw6JywgdXJsKTtcbiAgICBjb25zb2xlLmxvZygnUE9TVDonLCBkYXRhKTtcbiAgICBsZXQgcmVzO1xuICAgIHRyeSB7XG4gICAgICAgIHJlcyA9IGF3YWl0IG0ucmVxdWVzdCh1cmwsIHttZXRob2Q6ICdQT1NUJywgZGF0YTogZGF0YX0pO1xuICAgICAgICBjb25zb2xlLmxvZygncmVzcG9uc2U6JywgcmVzKTtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHJlcylbMF0gPT09ICd3YXJuaW5nJykge1xuICAgICAgICAgICAgYWxlcnQoJ1dhcm5pbmc6ICcgKyByZXMud2FybmluZyk7XG4gICAgICAgICAgICBlbmRfdGEzX3NlYXJjaChmYWxzZSwgcmVzLndhcm5pbmcpO1xuICAgICAgICB9XG4gICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgZW5kX3RhM19zZWFyY2goZmFsc2UsIGVycik7XG4gICAgICAgIGNkYihlcnIpO1xuICAgICAgICBhbGVydChgRXJyb3I6IGNhbGwgdG8gJHt1cmx9IGZhaWxlZGApO1xuICAgIH1cblxuICAgLypcbiAgICAvLyBjYWxsIGVuZF90YTNfc2VhcmNoIGlmIHN0YXR1cyAhPSBPS1xuICAgIC8vIHN0YXR1cyBtYXkgYmUgaW4gZGlmZmVyZW50IHBsYWNlcyBmb3IgZGlmZmVyZW50IGNhbGxzIHRob3VnaCwgYW5kIHRoaXMgaXMgbm90IHdvcnRoIGRvaW5nIGF0IHRoZSBtb21lbnRcbiAgICBsZXQgbXlyZWcgPSAvZDNtLXNlcnZpY2UvZztcbiAgICBsZXQgaXNkM21jYWxsID0gbXlyZWcudGVzdCh1cmwpO1xuICAgIGlmKGlzZDNtY2FsbCkge1xuICAgICAgICBsZXQgbXlzdGF0dXMgPSByZXMucmVzcG9uc2VJbmZvLnN0YXR1cy5jb2RlLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIGlmKG15c3RhdHVzICE9IFwiT0tcIikge1xuICAgICAgICAgICAgZW5kX3RhM19zZWFyY2goZmFsc2UsIFwiZ3JwYyByZXNwb25zZSBzdGF0dXMgbm90IG9rXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgICovXG5cbiAgICBpZiAoIUlTX0QzTV9ET01BSU4pe1xuICAgICAgICBlc3RpbWF0ZUxhZGRhLnN0b3AoKTsgICAgLy8gZXN0aW1hdGVMYWRkYSBpcyBiZWluZyBzdG9wcGVkIGluIG9uUGlwZWxpbmVDcmVhdGUgaW4gRDNNXG4gICAgfTtcbiAgICBzZWxlY3RMYWRkYS5zdG9wKCk7XG4gICAgcmV0dXJuIHJlcztcbn1cblxuLyoqIG5lZWRzIGRvYyAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxlZ2VuZCgpIHtcbiAgICBib3JkZXJTdGF0ZSgpO1xuICAgIG0ucmVkcmF3KCk7XG59XG5cbi8qKlxuICAgcHJvZ3JhbW1hdGljYWxseSBkZXNlbGVjdCBldmVyeSBzZWxlY3RlZCB2YXJpYWJsZVxuKi9cbmV4cG9ydCBmdW5jdGlvbiBlcmFzZSgpIHtcbiAgICBbJyNsZWZ0cGFuZWwnLCAnI3JpZ2h0cGFuZWwnXS5mb3JFYWNoKGlkID0+IGQzLnNlbGVjdChpZCkuYXR0cignY2xhc3MnLCAnc2lkZXBhbmVsIGNvbnRhaW5lciBjbGVhcmZpeCcpKTtcbiAgICB0YWJMZWZ0KCd0YWIxJyk7XG4gICAgJChcIiN2YXJMaXN0XCIpLmNoaWxkcmVuKCkuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHpwYXJhbXMuemR2LmNvbmNhdCh6cGFyYW1zLnpub20sIHpwYXJhbXMuenZhcnMpLmluY2x1ZGVzKHRoaXMuaWQpKVxuICAgICAgICAgICAgY2xpY2tWYXIoe3RhcmdldDogdGhpc30pO1xuICAgIH0pO1xufVxuXG4vKiogbmVlZHMgZG9jICovXG5leHBvcnQgZnVuY3Rpb24gdGFiTGVmdCh0YWIpIHtcbiAgICBieUlkKCd0YWIxJykuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBieUlkKCd0YWIyJykuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBieUlkKCd0YWIzJykuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBieUlkKHRhYikuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgaWYgKHRhYiAhPSAndGFiMycpIHtcbiAgICAgICAgc3Vic2V0ID0gdGFiID09ICd0YWIyJztcbiAgICAgICAgc3VtbWFyeUhvbGQgPSBmYWxzZTtcbiAgICB9XG4gICAgbGVmdHRhYiA9IHRhYjtcbn1cblxuXG4vKiogbmVlZHMgZG9jICovXG5leHBvcnQgZnVuY3Rpb24gdGFiUmlnaHQodGFiKSB7XG4gICAgbGV0IHNlbGVjdCA9IGNscyA9PiB7XG4gICAgICAgIGxldCBwYW5lbCA9IGQzLnNlbGVjdChcIiNyaWdodHBhbmVsXCIpO1xuICAgICAgICByZXR1cm4gY2xzID8gcGFuZWwuYXR0cignY2xhc3MnLCBjbHMpIDogcGFuZWwuYXR0cignY2xhc3MnKTtcbiAgICB9O1xuICAgIGxldCBjbHMgPSBcInNpZGVwYW5lbCBjb250YWluZXIgY2xlYXJmaXhcIjtcbiAgICBsZXQgdG9nZ2xlUiA9IGZ1bGwgPT4ge1xuICAgICAgICBzZWxlY3QoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gY2xzICsgdGhpcy5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSA9PT0gY2xzID8gJycgOiBjbHMgKyAnIGV4cGFuZHBhbmVsJyArIGZ1bGw7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgaWYgKHRhYiA9PT0gXCJidG5Nb2RlbHNcIikgc2VsZWN0KGNscyk7XG4gICAgZWxzZSBpZiAodGFiID09PSBcImJ0blNldHhcIikgcmlnaHR0YWIgPT09IFwiYnRuU2V0eFwiIHx8IHNlbGVjdCgpID09PSBjbHMgJiYgdG9nZ2xlUignZnVsbCcpO1xuICAgIGVsc2UgaWYgKHRhYiA9PT0gXCJidG5SZXN1bHRzXCIpICFlc3RpbWF0ZWQgPyBzZWxlY3QoY2xzKSA6XG4gICAgICAgIHJpZ2h0dGFiID09PSBcImJ0blJlc3VsdHNcIiB8fCBzZWxlY3QoKSA9PT0gY2xzICYmIHRvZ2dsZVIoKTtcbiAgICBlbHNlIGlmICh0YWIgPT09IFwiYnRuVW5pdmFyaWF0ZVwiKSBzZWxlY3QoY2xzKTtcblxuICAgIGlmKHRhYj09XCJidG5UeXBlXCIgfHwgdGFiPT1cImJ0blN1YnR5cGVcIiB8fCB0YWI9PVwiYnRuTWV0cmljc1wiKSB7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicmlnaHRwYW5lbFwiKS5jbGFzc0xpc3QucmVtb3ZlKFwiZXhwYW5kcGFuZWxmdWxsXCIpO1xuICAgIH1cbiAgICByaWdodHRhYiA9IHRhYjtcbn1cblxuZXhwb3J0IGxldCBzdW1tYXJ5ID0ge2RhdGE6IFtdfTtcblxuLyoqIG5lZWRzIGRvYyAqL1xuZnVuY3Rpb24gdmFyU3VtbWFyeShkKSB7XG4gICAgbGV0IHQxID0gJ01lYW46LCBNZWRpYW46LCBNb3N0IEZyZXE6LCBPY2N1cnJlbmNlczosIE1lZGlhbiBGcmVxOiwgT2NjdXJyZW5jZXM6LCBMZWFzdCBGcmVxOiwgT2NjdXJyZW5jZXM6LCBTdGQgRGV2OiwgTWluaW11bTosIE1heGltdW06LCBJbnZhbGlkOiwgVmFsaWQ6LCBVbmlxdWVzOiwgSGVyZmluZGFobCcuc3BsaXQoJywgJyk7XG5cbiAgICBsZXQgcmludCA9IGQzLmZvcm1hdCgncicpO1xuICAgIGxldCBzdHIgPSAoeCwgcCkgPT4gKCt4KS50b1ByZWNpc2lvbihwIHx8IDQpLnRvU3RyaW5nKCk7XG4gICAgbGV0IHQyID0gcHJpdiAmJiBkLm1lYW5DSSA/XG4gICAgICAgIFtzdHIoZC5tZWFuLCAyKSArICcgKCcgKyBzdHIoZC5tZWFuQ0kubG93ZXJCb3VuZCwgMikgKyAnIC0gJyArIHN0cihkLm1lYW5DSS51cHBlckJvdW5kLCAyKSArICcpJyxcbiAgICAgICAgIHN0cihkLm1lZGlhbiksIGQubW9kZSwgcmludChkLmZyZXFtb2RlKSwgZC5taWQsIHJpbnQoZC5mcmVxbWlkKSwgZC5mZXdlc3QsIHJpbnQoZC5mcmVxZmV3ZXN0KSxcbiAgICAgICAgIHN0cihkLnNkKSwgc3RyKGQubWluKSwgc3RyKGQubWF4KSwgcmludChkLmludmFsaWQpLCByaW50KGQudmFsaWQpLCByaW50KGQudW5pcXVlcyksIHN0cihkLmhlcmZpbmRhaGwpXSA6XG4gICAgICAgIFtzdHIoZC5tZWFuKSwgc3RyKGQubWVkaWFuKSwgZC5tb2RlLCByaW50KGQuZnJlcW1vZGUpLCBkLm1pZCwgcmludChkLmZyZXFtaWQpLCBkLmZld2VzdCwgcmludChkLmZyZXFmZXdlc3QpLFxuICAgICAgICAgc3RyKGQuc2QpLCBzdHIoZC5taW4pLCBzdHIoZC5tYXgpLCByaW50KGQuaW52YWxpZCksIHJpbnQoZC52YWxpZCksIHJpbnQoZC51bmlxdWVzKSwgc3RyKGQuaGVyZmluZGFobCldO1xuXG4gICAgc3VtbWFyeS5kYXRhID0gW107XG4gICAgdDEuZm9yRWFjaCgoZSwgaSkgPT4gIXQyW2ldLmluY2x1ZGVzKCdOYU4nKSAmJiB0MltpXSAhPSAnTkEnICYmIHQyW2ldICE9ICcnICYmIHN1bW1hcnkuZGF0YS5wdXNoKFtlLCB0MltpXV0pKTtcblxuICAgIHN1bW1hcnkubmFtZSA9IGQubmFtZTtcbiAgICBzdW1tYXJ5LmxhYmwgPSBkLmxhYmw7XG5cbiAgICBkMy5zZWxlY3QoJyN0YWIzJylcbiAgICAgICAgLnNlbGVjdEFsbCgnc3ZnJylcbiAgICAgICAgLnJlbW92ZSgpO1xuXG4gICAgaWYgKCFkLnBsb3R0eXBlKVxuICAgICAgICByZXR1cm47XG4gICAgZC5wbG90dHlwZSA9PSAnY29udGludW91cycgPyBkZW5zaXR5KGQsICd2YXJTdW1tYXJ5JywgcHJpdikgOlxuICAgICAgICBkLnBsb3R0eXBlID09IFwiYmFyXCIgPyBiYXJzKGQsICd2YXJTdW1tYXJ5JywgcHJpdikgOlxuICAgICAgICBkMy5zZWxlY3QoXCIjdGFiM1wiKSAvLyBubyBncmFwaCB0byBkcmF3LCBidXQgc3RpbGwgbmVlZCB0byByZW1vdmUgcHJldmlvdXMgZ3JhcGhcbiAgICAgICAgLnNlbGVjdEFsbChcInN2Z1wiKVxuICAgICAgICAucmVtb3ZlKCk7XG59XG5cbmV4cG9ydCBsZXQgcG9wb3ZlckNvbnRlbnQgPSBkID0+IHtcbiAgICBpZihzd2FuZGl2ZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCB0ZXh0ID0gJyc7XG4gICAgbGV0IFtyaW50LCBwcmVjXSA9IFtkMy5mb3JtYXQoJ3InKSwgKHZhbCwgaW50KSA9PiAoK3ZhbCkudG9QcmVjaXNpb24oaW50KS50b1N0cmluZygpXTtcbiAgICBsZXQgZGl2ID0gKGZpZWxkLCBuYW1lLCB2YWwpID0+IHtcbiAgICAgICAgaWYgKGZpZWxkICE9ICdOQScpIHRleHQgKz0gYDxkaXYgY2xhc3M9J2Zvcm0tZ3JvdXAnPjxsYWJlbCBjbGFzcz0nY29sLXNtLTQgY29udHJvbC1sYWJlbCc+JHtuYW1lfTwvbGFiZWw+PGRpdiBjbGFzcz0nY29sLXNtLTYnPjxwIGNsYXNzPSdmb3JtLWNvbnRyb2wtc3RhdGljJz4ke3ZhbCB8fCBmaWVsZH08L3A+PC9kaXY+PC9kaXY+YDtcbiAgICB9O1xuICAgIGQubGFibCAhPSAnJyAmJiBkaXYoZC5sYWJsLCAnTGFiZWwnKTtcbiAgICBkaXYoZC5tZWFuLCAnTWVhbicsIHByaXYgJiYgZC5tZWFuQ0kgP1xuICAgICAgICBgJHtwcmVjKGQubWVhbiwgMil9ICgke3ByZWMoZC5tZWFuQ0kubG93ZXJCb3VuZCwgMil9IC0gJHtwcmVjKGQubWVhbkNJLnVwcGVyQm91bmQsIDIpfSlgIDpcbiAgICAgICAgcHJlYyhkLm1lYW4sIDQpKTtcbiAgICBkaXYoZC5tZWRpYW4sICdNZWRpYW4nLCBwcmVjKGQubWVkaWFuLCA0KSk7XG4gICAgZGl2KGQubW9kZSwgJ01vc3QgRnJlcScpO1xuICAgIGRpdihkLmZyZXFtb2RlLCAnT2NjdXJyZW5jZXMnLCAgcmludChkLmZyZXFtb2RlKSk7XG4gICAgZGl2KGQubWlkLCAnTWVkaWFuIEZyZXEnKTtcbiAgICBkaXYoZC5mcmVxbWlkLCAnT2NjdXJyZW5jZXMnLCByaW50KGQuZnJlcW1pZCkpO1xuICAgIGRpdihkLmZld2VzdCwgJ0xlYXN0IEZyZXEnKTtcbiAgICBkaXYoZC5mcmVxZmV3ZXN0LCAnT2NjdXJyZW5jZXMnLCByaW50KGQuZnJlcWZld2VzdCkpO1xuICAgIGRpdihkLnNkLCAnU3RhbmQgRGV2JywgcHJlYyhkLnNkLCA0KSk7XG4gICAgZGl2KGQubWF4LCAnTWF4aW11bScsIHByZWMoZC5tYXgsIDQpKTtcbiAgICBkaXYoZC5taW4sICdNaW5pbXVtJywgcHJlYyhkLm1pbiwgNCkpO1xuICAgIGRpdihkLmludmFsaWQsICdJbnZhbGlkJywgcmludChkLmludmFsaWQpKTtcbiAgICBkaXYoZC52YWxpZCwgJ1ZhbGlkJywgcmludChkLnZhbGlkKSk7XG4gICAgZGl2KGQudW5pcXVlcywgJ1VuaXF1ZXMnLCByaW50KGQudW5pcXVlcykpO1xuICAgIGRpdihkLmhlcmZpbmRhaGwsICdIZXJmaW5kYWhsJywgcHJlYyhkLmhlcmZpbmRhaGwsIDQpKTtcbiAgICByZXR1cm4gdGV4dDtcbn1cblxuLyoqIG5lZWRzIGRvYyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhbmVsUGxvdHMoKSB7XG5cbiAgICBpZihJU19EM01fRE9NQUlOKSB7XG4gICAgLy8gICAgYnlJZCgnYnRuU3Vic2V0JykuY2xhc3NMaXN0LmFkZCgnbm9zaG93Jyk7XG4gICAgfVxuICAgIC8vIGJ1aWxkIGFycmF5cyBmcm9tIG5vZGVzIGluIG1haW5cbiAgICBsZXQgdmFycyA9IFtdO1xuICAgIGxldCBpZHMgPSBbXTtcbiAgICBub2Rlcy5mb3JFYWNoKG4gPT4ge1xuICAgICAgICB2YXJzLnB1c2gobi5uYW1lLnJlcGxhY2UoL1xcKHxcXCkvZywgJycpKTtcbiAgICAgICAgaWRzLnB1c2gobi5pZCk7XG4gICAgfSk7XG5cbiAgICAvL3JlbW92ZSBhbGwgcGxvdHMsIGNvdWxkIGJlIHNtYXJ0ZXIgaGVyZVxuICAgIGQzLnNlbGVjdCgnI3NldHhMZWZ0Jykuc2VsZWN0QWxsKCdzdmcnKS5yZW1vdmUoKTtcbiAgICBkMy5zZWxlY3QoJyN0YWIyJykuc2VsZWN0QWxsKCdzdmcnKS5yZW1vdmUoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYoYWxsTm9kZXNbaWRzW2ldXS52YWxpZD09MCkgLy8gdGhpcyB3YXMgYSBzaWxlbnQgZXJyb3IuLi4gdmVyeSBmcnVzdHJhdGluZy4uLlxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGxldCBub2RlID0gYWxsTm9kZXNbaWRzW2ldXTtcbiAgICAgICAgbm9kZS5zZXR4cGxvdCA9IGZhbHNlO1xuICAgICAgICBub2RlLnN1YnNldHBsb3QgPSBmYWxzZTtcbiAgICAgICAgaWYgKG5vZGUucGxvdHR5cGUgPT09IFwiY29udGludW91c1wiICYgbm9kZS5zZXR4cGxvdCA9PSBmYWxzZSkge1xuICAgICAgICAgICAgbm9kZS5zZXR4cGxvdCA9IHRydWU7XG4gICAgICAgICAgICBkZW5zaXR5KG5vZGUsIGRpdiA9IFwic2V0eExlZnRcIiwgcHJpdik7XG4gICAgICAgICAgICBub2RlLnN1YnNldHBsb3QgPSB0cnVlO1xuICAgICAgICAgICAgZGVuc2l0eShub2RlLCBkaXYgPSBcInN1YnNldFwiLCBwcml2KTtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlLnBsb3R0eXBlID09PSBcImJhclwiICYgbm9kZS5zZXR4cGxvdCA9PSBmYWxzZSkge1xuICAgICAgICAgICAgbm9kZS5zZXR4cGxvdCA9IHRydWU7XG4gICAgICAgICAgICBiYXJzKG5vZGUsIGRpdiA9IFwic2V0eExlZnRcIiwgcHJpdik7XG4gICAgICAgICAgICBub2RlLnN1YnNldHBsb3QgPSB0cnVlO1xuICAgICAgICAgICAgYmFyc1N1YnNldChub2RlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgICAgICBkMy5zZWxlY3QoXCIjc2V0eExlZnRcIikuc2VsZWN0QWxsKFwic3ZnXCIpXG4gICAgICAgIC5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpO1xuICAgICAgICAgICAgICB2YXIgcmVnc3RyID0gLyguKylfc2V0eExlZnRfKFxcZCspLztcbiAgICAgICAgICAgICAgdmFyIG15bmFtZSA9IHJlZ3N0ci5leGVjKHRoaXMuaWQpO1xuICAgICAgICAgICAgICB2YXIgbm9kZWlkID0gbXluYW1lWzJdO1xuICAgICAgICAgICAgICBteW5hbWUgPSBteW5hbWVbMV07XG4gICAgICAgICAgICAgIGlmICghdmFycy5pbmNsdWRlcyhteW5hbWUpKSB7XG4gICAgICAgICAgICAgIGFsbE5vZGVzW25vZGVpZF0uc2V0eHBsb3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgbGV0IHRlbXAgPSBcIiNcIi5jb25jYXQobXluYW1lLCBcIl9zZXR4TGVmdF9cIiwgbm9kZWlkKTtcbiAgICAgICAgICAgICAgZDMuc2VsZWN0KHRlbXApXG4gICAgICAgICAgICAgIC5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgYWxsTm9kZXNbbm9kZWlkXS5zdWJzZXRwbG90ID0gZmFsc2U7XG4gICAgICAgICAgICAgIHRlbXAgPSBcIiNcIi5jb25jYXQobXluYW1lLCBcIl90YWIyX1wiLCBub2RlaWQpO1xuICAgICAgICAgICAgICBkMy5zZWxlY3QodGVtcClcbiAgICAgICAgICAgICAgLnJlbW92ZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIC8vIGp1c3QgcmVtb3ZpbmcgYWxsIHRoZSBzdWJzZXQgcGxvdHMgaGVyZSwgYmVjYXVzZSB1c2luZyB0aGlzIGJ1dHRvbiBmb3IgcHJvYmxlbSBkaXNjb3ZlclxuICAgICAgICAgICAgICBkMy5zZWxlY3QoJyN0YWIyJykuc2VsZWN0QWxsKCdzdmcnKS5yZW1vdmUoKTtcbn1cblxuLyoqXG4gICBjb252ZXJ0cyBjb2xvciBjb2Rlc1xuKi9cbmV4cG9ydCBsZXQgaGV4VG9SZ2JhID0gaGV4ID0+IHtcbiAgICBsZXQgaW50ID0gcGFyc2VJbnQoaGV4LnJlcGxhY2UoJyMnLCAnJyksIDE2KTtcbiAgICByZXR1cm4gYHJnYmEoJHtbKGludCA+PiAxNikgJiAyNTUsIChpbnQgPj4gOCkgJiAyNTUsIGludCAmIDI1NSwgJzAuNSddLmpvaW4oJywnKX0pYDtcbn07XG5cbi8qKlxuICAgdGFrZXMgbm9kZSBhbmQgY29sb3IgYW5kIHVwZGF0ZXMgenBhcmFtc1xuKi9cbmZ1bmN0aW9uIHNldENvbG9ycyhuLCBjKSB7XG4gICAgaWYgKG4uc3Ryb2tlV2lkdGggPT0gJzEnKSB7XG4gICAgICAgIGlmIChjID09IGdyMUNvbG9yKXtcbiAgICAgICAgICAgIHZhciB0ZW1waW5kZXggPSB6cGFyYW1zLnpncm91cDEuaW5kZXhPZihuLm5hbWUpO1xuICAgICAgICAgICAgaWYgKHRlbXBpbmRleCA+IC0xKXtcbiAgICAgICAgICAgICAgICBuLmdyb3VwMSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGRlbCh6cGFyYW1zLnpncm91cDEsIHRlbXBpbmRleCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG4uZ3JvdXAxID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB6cGFyYW1zLnpncm91cDEucHVzaChuLm5hbWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChjID09IGdyMkNvbG9yKXtcbiAgICAgICAgICAgIHZhciB0ZW1waW5kZXggPSB6cGFyYW1zLnpncm91cDIuaW5kZXhPZihuLm5hbWUpO1xuICAgICAgICAgICAgaWYgKHRlbXBpbmRleCA+IC0xKXtcbiAgICAgICAgICAgICAgICBuLmdyb3VwMiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGRlbCh6cGFyYW1zLnpncm91cDIsIHRlbXBpbmRleCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG4uZ3JvdXAyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB6cGFyYW1zLnpncm91cDIucHVzaChuLm5hbWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYWRkaW5nIHRpbWUsIGNzLCBkdiwgbm9tIHRvIG5vZGUgd2l0aCBubyBzdHJva2VcbiAgICAgICAgbi5zdHJva2VXaWR0aCA9ICc0JztcbiAgICAgICAgbi5zdHJva2VDb2xvciA9IGM7XG4gICAgICAgIG4ubm9kZUNvbCA9IHRhZ2dlZENvbG9yO1xuICAgICAgICBsZXQgcHVzaCA9IChbY29sb3IsIGtleV0pID0+IHtcbiAgICAgICAgICAgIGlmIChjb2xvciAhPSBjKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHpwYXJhbXNba2V5XSA9IEFycmF5LmlzQXJyYXkoenBhcmFtc1trZXldKSA/IHpwYXJhbXNba2V5XSA6IFtdO1xuICAgICAgICAgICAgenBhcmFtc1trZXldLnB1c2gobi5uYW1lKTtcbiAgICAgICAgICAgIGlmIChrZXkgPT0gJ3pub20nKSB7XG4gICAgICAgICAgICAgICAgZmluZE5vZGVJbmRleChuLm5hbWUsIHRydWUpLm5hdHVyZSA9IFwibm9taW5hbFwiO1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybShuLm5hbWUsIHQgPSBudWxsLCB0eXBlVHJhbnNmb3JtID0gdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoa2V5ID09ICd6ZHYnKXsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGdyb3VwIG1lbWJlcnNoaXBzIGZyb20gZHYnc1xuICAgICAgICAgICAgICAgIGlmKG4uZ3JvdXAxKXtcbiAgICAgICAgICAgICAgICAgICAgbi5ncm91cDEgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZGVsKHpwYXJhbXMuemdyb3VwMSwgLTEsIG4ubmFtZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZihuLmdyb3VwMil7XG4gICAgICAgICAgICAgICAgICAgIG4uZ3JvdXAyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGRlbCh6cGFyYW1zLnpncm91cDIsIC0xLCBuLm5hbWUpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFtbZHZDb2xvciwgJ3pkdiddLCBbY3NDb2xvciwgJ3pjcm9zcyddLCBbdGltZUNvbG9yLCAnenRpbWUnXSwgW25vbUNvbG9yLCAnem5vbSddXS5mb3JFYWNoKHB1c2gpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChuLnN0cm9rZVdpZHRoID09ICc0Jykge1xuICAgICAgICBpZiAoYyA9PSBuLnN0cm9rZUNvbG9yKSB7IC8vIGRlc2VsZWN0aW5nIHRpbWUsIGNzLCBkdiwgbm9tXG4gICAgICAgICAgICBuLnN0cm9rZVdpZHRoID0gJzEnO1xuICAgICAgICAgICAgbi5zdHJva2VDb2xvciA9IHNlbFZhckNvbG9yO1xuICAgICAgICAgICAgbi5ub2RlQ29sID0gY29sb3JzKG4uaWQpO1xuICAgICAgICAgICAgenBhcmFtc1Jlc2V0KG4ubmFtZSk7XG4gICAgICAgICAgICBpZiAobm9tQ29sb3IgPT0gYyAmJiB6cGFyYW1zLnpub20uaW5jbHVkZXMobi5uYW1lKSkge1xuICAgICAgICAgICAgICAgIGZpbmROb2RlSW5kZXgobi5uYW1lLCB0cnVlKS5uYXR1cmUgPSBmaW5kTm9kZUluZGV4KG4ubmFtZSwgdHJ1ZSkuZGVmYXVsdE5hdHVyZTtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm0obi5uYW1lLCB0ID0gbnVsbCwgdHlwZVRyYW5zZm9ybSA9IHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgeyAvLyBkZXNlbGVjdGluZyB0aW1lLCBjcywgZHYsIG5vbSBBTkQgY2hhbmdpbmcgaXQgdG8gdGltZSwgY3MsIGR2LCBub21cbiAgICAgICAgICAgIHpwYXJhbXNSZXNldChuLm5hbWUpO1xuICAgICAgICAgICAgaWYgKG5vbUNvbG9yID09IG4uc3Ryb2tlQ29sb3IgJiYgenBhcmFtcy56bm9tLmluY2x1ZGVzKG4ubmFtZSkpIHtcbiAgICAgICAgICAgICAgICBmaW5kTm9kZUluZGV4KG4ubmFtZSwgdHJ1ZSkubmF0dXJlID0gZmluZE5vZGVJbmRleChuLm5hbWUsIHRydWUpLmRlZmF1bHROYXR1cmU7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtKG4ubmFtZSwgdCA9IG51bGwsIHR5cGVUcmFuc2Zvcm0gPSB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG4uc3Ryb2tlQ29sb3IgPSBjO1xuICAgICAgICAgICAgaWYgKGR2Q29sb3IgPT0gYyl7XG4gICAgICAgICAgICAgICAgdmFyIGR2bmFtZSA9IG4ubmFtZTtcbiAgICAgICAgICAgICAgICB6cGFyYW1zLnpkdi5wdXNoKGR2bmFtZSk7XG4gICAgICAgICAgICAgICAgaWYobi5ncm91cDEpeyAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBncm91cCBtZW1iZXJzaGlwcyBmcm9tIGR2J3NcbiAgICAgICAgICAgICAgICAgICAgbmdyb3VwMSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBkZWwoenBhcmFtcy56Z3JvdXAxLCAtMSwgZHZuYW1lKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmKG4uZ3JvdXAyKXtcbiAgICAgICAgICAgICAgICAgICAgbmdyb3VwMiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBkZWwoenBhcmFtcy56Z3JvdXAyLCAtMSwgZHZuYW1lKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY3NDb2xvciA9PSBjKSB6cGFyYW1zLnpjcm9zcy5wdXNoKG4ubmFtZSk7XG4gICAgICAgICAgICBlbHNlIGlmICh0aW1lQ29sb3IgPT0gYykgenBhcmFtcy56dGltZS5wdXNoKG4ubmFtZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChub21Db2xvciA9PSBjKSB7XG4gICAgICAgICAgICAgICAgenBhcmFtcy56bm9tLnB1c2gobi5uYW1lKTtcbiAgICAgICAgICAgICAgICBmaW5kTm9kZUluZGV4KG4ubmFtZSwgdHJ1ZSkubmF0dXJlID0gXCJub21pbmFsXCI7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtKG4ubmFtZSwgdCA9IG51bGwsIHR5cGVUcmFuc2Zvcm0gPSB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqIG5lZWRzIGRvYyAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJvcmRlclN0YXRlKCkge1xuICAgIHpwYXJhbXMuemR2Lmxlbmd0aCA+IDAgP1xuICAgICAgICAkKCcjZHZCdXR0b24gLnJlY3RDb2xvciBzdmcgY2lyY2xlJykuYXR0cignc3Ryb2tlJywgZHZDb2xvcikgOlxuICAgICAgICAkKCcjZHZCdXR0b24nKS5jc3MoJ2JvcmRlci1jb2xvcicsICcjY2NjJyk7XG4gICAgenBhcmFtcy56Y3Jvc3MubGVuZ3RoID4gMCA/XG4gICAgICAgICQoJyNjc0J1dHRvbiAucmVjdENvbG9yIHN2ZyBjaXJjbGUnKS5hdHRyKCdzdHJva2UnLCBjc0NvbG9yKSA6XG4gICAgICAgICQoJyNjc0J1dHRvbicpLmNzcygnYm9yZGVyLWNvbG9yJywgJyNjY2MnKTtcbiAgICB6cGFyYW1zLnp0aW1lLmxlbmd0aCA+IDAgP1xuICAgICAgICAkKCcjdGltZUJ1dHRvbiAucmVjdENvbG9yIHN2ZyBjaXJjbGUnKS5hdHRyKCdzdHJva2UnLCB0aW1lQ29sb3IpIDpcbiAgICAgICAgJCgnI3RpbWVCdXR0b24nKS5jc3MoJ2JvcmRlci1jb2xvcicsICcjY2NjJyk7XG4gICAgenBhcmFtcy56bm9tLmxlbmd0aCA+IDAgP1xuICAgICAgICAkKCcjbm9tQnV0dG9uIC5yZWN0Q29sb3Igc3ZnIGNpcmNsZScpLmF0dHIoJ3N0cm9rZScsIG5vbUNvbG9yKSA6XG4gICAgICAgICQoJyNub21CdXR0b24nKS5jc3MoJ2JvcmRlci1jb2xvcicsICcjY2NjJyk7XG4gICAgenBhcmFtcy56Z3JvdXAxLmxlbmd0aCA+IDAgP1xuICAgICAgICAkKCcjZ3IxQnV0dG9uIC5yZWN0Q29sb3Igc3ZnIGNpcmNsZScpLmF0dHIoJ3N0cm9rZScsIGdyMUNvbG9yKS5hdHRyKCdmaWxsJywgZ3IxQ29sb3IpLmF0dHIoJ2ZpbGwtb3BhY2l0eScsIDAuNikuYXR0cignc3Ryb2tlLW9wYWNpdHknLCAwKSA6XG4gICAgICAgICQoJyNncjFCdXR0b24nKS5jc3MoJ2JvcmRlci1jb2xvcicsICcjY2NjJyk7XG4gICAgenBhcmFtcy56Z3JvdXAyLmxlbmd0aCA+IDAgP1xuICAgICAgICAkKCcjZ3IyQnV0dG9uIC5yZWN0Q29sb3Igc3ZnIGNpcmNsZScpLmF0dHIoJ3N0cm9rZScsIGdyMkNvbG9yKS5hdHRyKCdmaWxsJywgZ3IyQ29sb3IpLmF0dHIoJ2ZpbGwtb3BhY2l0eScsIDAuNikuYXR0cignc3Ryb2tlLW9wYWNpdHknLCAwKSA6XG4gICAgICAgICQoJyNncjJCdXR0b24nKS5jc3MoJ2JvcmRlci1jb2xvcicsICcjY2NjJyk7XG59XG5cbi8qKiBuZWVkcyBkb2MgKi9cbmV4cG9ydCBmdW5jdGlvbiBzdWJzZXRTZWxlY3QoYnRuKSB7XG4gICAgaWYgKGRhdGF1cmwpIHtcbiAgICAgICAgenBhcmFtcy56ZGF0YXVybCA9IGRhdGF1cmw7XG4gICAgfVxuICAgIGlmIChkb3dubG9hZEluY29tcGxldGUoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgenBhcmFtcy56dmFycyA9IFtdO1xuICAgIHpwYXJhbXMuenBsb3QgPSBbXTtcbiAgICB2YXIgc3Vic2V0RW1wdHkgPSB0cnVlO1xuICAgIC8vIGlzIHRoaXMgdGhlIHNhbWUgYXMgelBvcCgpP1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbm9kZXMubGVuZ3RoOyBqKyspIHsgLy8gcG9wdWxhdGUgenZhcnMgYW5kIHpzdWJzZXQgYXJyYXlzXG4gICAgICAgIHpwYXJhbXMuenZhcnMucHVzaChub2Rlc1tqXS5uYW1lKTtcbiAgICAgICAgdmFyIHRlbXAgPSBub2Rlc1tqXS5pZDtcbiAgICAgICAgenBhcmFtcy56c3Vic2V0W2pdID0gYWxsTm9kZXNbdGVtcF0uc3Vic2V0cmFuZ2U7XG4gICAgICAgIGlmICh6cGFyYW1zLnpzdWJzZXRbal0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKHpwYXJhbXMuenN1YnNldFtqXVswXSAhPSBcIlwiKVxuICAgICAgICAgICAgICAgIHpwYXJhbXMuenN1YnNldFtqXVswXSA9IE51bWJlcih6cGFyYW1zLnpzdWJzZXRbal1bMF0pO1xuICAgICAgICAgICAgaWYgKHpwYXJhbXMuenN1YnNldFtqXVsxXSAhPSBcIlwiKVxuICAgICAgICAgICAgICAgIHpwYXJhbXMuenN1YnNldFtqXVsxXSA9IE51bWJlcih6cGFyYW1zLnpzdWJzZXRbal1bMV0pO1xuICAgICAgICB9XG4gICAgICAgIHpwYXJhbXMuenBsb3QucHVzaChhbGxOb2Rlc1t0ZW1wXS5wbG90dHlwZSk7XG4gICAgICAgIGlmICh6cGFyYW1zLnpzdWJzZXRbal1bMV0gIT0gXCJcIilcbiAgICAgICAgICAgIHN1YnNldEVtcHR5ID0gZmFsc2U7IC8vIG9ubHkgbmVlZCB0byBjaGVjayBvbmVcbiAgICB9XG5cbiAgICBpZiAoc3Vic2V0RW1wdHkgPT0gdHJ1ZSkge1xuICAgICAgICBhbGVydChcIldhcm5pbmc6IE5vIG5ldyBzdWJzZXQgc2VsZWN0ZWQuXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG91dHR5cGVzID0gW107XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBhbGxOb2Rlcy5sZW5ndGg7IGorKykge1xuICAgICAgICBvdXR0eXBlcy5wdXNoKHtcbiAgICAgICAgICAgIHZhcm5hbWVzVHlwZXM6IGFsbE5vZGVzW2pdLm5hbWUsXG4gICAgICAgICAgICBuYXR1cmU6IGFsbE5vZGVzW2pdLm5hdHVyZSxcbiAgICAgICAgICAgIG51bWNoYXI6IGFsbE5vZGVzW2pdLm51bWNoYXIsXG4gICAgICAgICAgICBiaW5hcnk6IGFsbE5vZGVzW2pdLmJpbmFyeSxcbiAgICAgICAgICAgIGludGVydmFsOiBhbGxOb2Rlc1tqXS5pbnRlcnZhbFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzZWxlY3RMYWRkYS5zdGFydCgpOyAvLyBzdGFydCBidXR0b24gbW90aW9uXG4gICAgbGV0IGpzb24gPSBtYWtlUmVxdWVzdChcbiAgICAgICAgUk9PS19TVkNfVVJMICsgJ3N1YnNldFNlbGVjdCcsXG4gICAgICAgIHt6ZGF0YXVybDogenBhcmFtcy56ZGF0YXVybCxcbiAgICAgICAgIHp2YXJzOiB6cGFyYW1zLnp2YXJzLFxuICAgICAgICAgenN1YnNldDogenBhcmFtcy56c3Vic2V0LFxuICAgICAgICAgenNlc3Npb25pZDogenBhcmFtcy56c2Vzc2lvbmlkLFxuICAgICAgICAgenBsb3Q6IHpwYXJhbXMuenBsb3QsXG4gICAgICAgICBjYWxsSGlzdG9yeTogY2FsbEhpc3RvcnksXG4gICAgICAgICB0eXBlU3R1ZmY6IG91dHR5cGVzfSk7XG4gICAgc2VsZWN0TGFkZGEuc3RvcCgpO1xuICAgIGlmICghanNvbikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgJChcIiNidG5WYXJpYWJsZXNcIikudHJpZ2dlcihcImNsaWNrXCIpOyAvLyBwcm9ncmFtbWF0aWMgY2xpY2tzXG4gICAgJChcIiNidG5Nb2RlbHNcIikudHJpZ2dlcihcImNsaWNrXCIpO1xuXG4gICAgdmFyIGdyYXlPdXRzID0gW107XG4gICAgdmFyIHJDYWxsID0gW107XG4gICAgckNhbGxbMF0gPSBqc29uLmNhbGw7XG5cbiAgICAvLyBzdG9yZSBjb250ZW50cyBvZiB0aGUgcHJlLXN1YnNldCBzcGFjZVxuICAgIHpQb3AoKTtcbiAgICB2YXIgbXlOb2RlcyA9IGpRdWVyeS5leHRlbmQodHJ1ZSwgW10sIGFsbE5vZGVzKTtcbiAgICB2YXIgbXlQYXJhbXMgPSBqUXVlcnkuZXh0ZW5kKHRydWUsIHt9LCB6cGFyYW1zKTtcbiAgICB2YXIgbXlUcmFucyA9IGpRdWVyeS5leHRlbmQodHJ1ZSwgW10sIHRyYW5zKTtcbiAgICB2YXIgbXlGb3JjZSA9IGpRdWVyeS5leHRlbmQodHJ1ZSwgW10sIGZvcmNldG9nZ2xlKTtcbiAgICB2YXIgbXlQcmVwcm9jZXNzID0galF1ZXJ5LmV4dGVuZCh0cnVlLCB7fSwgcHJlcHJvY2Vzcyk7XG4gICAgdmFyIG15TG9nID0galF1ZXJ5LmV4dGVuZCh0cnVlLCBbXSwgbG9nQXJyYXkpO1xuICAgIHZhciBteUhpc3RvcnkgPSBqUXVlcnkuZXh0ZW5kKHRydWUsIFtdLCBjYWxsSGlzdG9yeSk7XG5cbiAgICBzcGFjZXNbbXlzcGFjZV0gPSB7XG4gICAgICAgIFwiYWxsTm9kZXNcIjogbXlOb2RlcyxcbiAgICAgICAgXCJ6cGFyYW1zXCI6IG15UGFyYW1zLFxuICAgICAgICBcInRyYW5zXCI6IG15VHJhbnMsXG4gICAgICAgIFwiZm9yY2VcIjogbXlGb3JjZSxcbiAgICAgICAgXCJwcmVwcm9jZXNzXCI6IG15UHJlcHJvY2VzcyxcbiAgICAgICAgXCJsb2dBcnJheVwiOiBteUxvZyxcbiAgICAgICAgXCJjYWxsSGlzdG9yeVwiOiBteUhpc3RvcnlcbiAgICB9O1xuXG4gICAgLy8gcmVtb3ZlIHByZS1zdWJzZXQgc3ZnXG4gICAgdmFyIHNlbGVjdE1lID0gXCIjbVwiLmNvbmNhdChteXNwYWNlKTtcbiAgICBkMy5zZWxlY3Qoc2VsZWN0TWUpLmF0dHIoJ2NsYXNzJywgJ2l0ZW0nKTtcbiAgICBzZWxlY3RNZSA9IFwiI3doaXRlc3BhY2VcIi5jb25jYXQobXlzcGFjZSk7XG4gICAgZDMuc2VsZWN0KHNlbGVjdE1lKS5yZW1vdmUoKTtcblxuICAgIG15c3BhY2UgPSBzcGFjZXMubGVuZ3RoO1xuICAgIGNhbGxIaXN0b3J5LnB1c2goe1xuICAgICAgICBmdW5jOiBcInN1YnNldFwiLFxuICAgICAgICB6dmFyczogalF1ZXJ5LmV4dGVuZCh0cnVlLCBbXSwgenBhcmFtcy56dmFycyksXG4gICAgICAgIHpzdWJzZXQ6IGpRdWVyeS5leHRlbmQodHJ1ZSwgW10sIHpwYXJhbXMuenN1YnNldCksXG4gICAgICAgIHpwbG90OiBqUXVlcnkuZXh0ZW5kKHRydWUsIFtdLCB6cGFyYW1zLnpwbG90KVxuICAgIH0pO1xuXG4gICAgLy8gdGhpcyBpcyB0byBiZSB1c2VkIHRvIGdyYXkgb3V0IGFuZCByZW1vdmUgbGlzdGVuZXJzIGZvciB2YXJpYWJsZXMgdGhhdCBoYXZlIGJlZW4gc3Vic2V0dGVkIG91dCBvZiB0aGUgZGF0YVxuICAgIGZ1bmN0aW9uIHZhck91dCh2KSB7XG4gICAgICAgIC8vIGlmIGluIG5vZGVzLCByZW1vdmUgZ3JheSBvdXQgaW4gbGVmdCBwYW5lbFxuICAgICAgICAvLyBtYWtlIHVuY2xpY2thYmxlIGluIGxlZnQgcGFuZWxcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0TWUgPSB2W2ldLnJlcGxhY2UoL1xcVy9nLCBcIl9cIik7XG4gICAgICAgICAgICBieUlkKHNlbGVjdE1lKS5zdHlsZS5jb2xvciA9IGhleFRvUmdiYShncmF5Q29sb3IpO1xuICAgICAgICAgICAgc2VsZWN0TWUgPSBcInAjXCIuY29uY2F0KHNlbGVjdE1lKTtcbiAgICAgICAgICAgIGQzLnNlbGVjdChzZWxlY3RNZSlcbiAgICAgICAgICAgICAgICAub24oXCJjbGlja1wiLCBudWxsKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNob3dMb2coJ3N1YnNldCcsIHJDYWxsKTtcblxuICAgIGQzLnNlbGVjdChcIiNpbm5lcmNhcm91c2VsXCIpXG4gICAgICAgIC5hcHBlbmQoJ2RpdicpXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdpdGVtIGFjdGl2ZScpXG4gICAgICAgIC5hdHRyKCdpZCcsICgpID0+IFwibVwiLmNvbmNhdChteXNwYWNlLnRvU3RyaW5nKCkpKVxuICAgICAgICAuYXBwZW5kKCdzdmcnKVxuICAgICAgICAuYXR0cignaWQnLCAnd2hpdGVzcGFjZScpO1xuICAgIHN2ZyA9IGQzLnNlbGVjdChcIiN3aGl0ZXNwYWNlXCIpO1xuXG4gICAgZDMuanNvbihqc29uLnVybCwgZnVuY3Rpb24oZXJyb3IsIGpzb24pIHtcbiAgICAgICAgaWYgKGVycm9yKXtcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBqc29uZGF0YSA9IGdldFZhcmlhYmxlRGF0YShqc29uKTtcblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4ganNvbmRhdGEpIHtcbiAgICAgICAgICAgIHZhciBteUluZGV4ID0gZmluZE5vZGVJbmRleChrZXkpO1xuXG4gICAgICAgICAgICBhbGxOb2Rlc1tteUluZGV4XS5wbG90eCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGFsbE5vZGVzW215SW5kZXhdLnBsb3R5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgYWxsTm9kZXNbbXlJbmRleF0ucGxvdHZhbHVlcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGFsbE5vZGVzW215SW5kZXhdLnBsb3R0eXBlID0gXCJcIjtcblxuICAgICAgICAgICAgalF1ZXJ5LmV4dGVuZCh0cnVlLCBhbGxOb2Rlc1tteUluZGV4XSwganNvbmRhdGFba2V5XSk7XG4gICAgICAgICAgICBhbGxOb2Rlc1tteUluZGV4XS5zdWJzZXRwbG90ID0gZmFsc2U7XG4gICAgICAgICAgICBhbGxOb2Rlc1tteUluZGV4XS5zdWJzZXRyYW5nZSA9IFtcIlwiLCBcIlwiXTtcbiAgICAgICAgICAgIGFsbE5vZGVzW215SW5kZXhdLnNldHhwbG90ID0gZmFsc2U7XG4gICAgICAgICAgICBhbGxOb2Rlc1tteUluZGV4XS5zZXR4dmFscyA9IFtcIlwiLCBcIlwiXTtcblxuICAgICAgICAgICAgaWYgKGFsbE5vZGVzW215SW5kZXhdLnZhbGlkID09IDApIHtcbiAgICAgICAgICAgICAgICBncmF5T3V0cy5wdXNoKGFsbE5vZGVzW215SW5kZXhdLm5hbWUpO1xuICAgICAgICAgICAgICAgIGFsbE5vZGVzW215SW5kZXhdLmdyYXlvdXQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlUGxvdCgpO1xuICAgICAgICBsYXlvdXQobGF5b3V0QWRkKTtcbiAgICB9KTtcblxuICAgIHZhck91dChncmF5T3V0cyk7XG59XG5cbi8qKlxuICAgcmVtb3ZlcyBhbGwgdGhlIGNoaWxkcmVuIHN2Z3MgaW5zaWRlIHN1YnNldCBhbmQgc2V0eCBkaXZzXG4qL1xuZnVuY3Rpb24gcmVQbG90KCkge1xuICAgIGQzLnNlbGVjdCgnI3RhYjInKVxuICAgICAgICAuc2VsZWN0QWxsKCdzdmcnKVxuICAgICAgICAucmVtb3ZlKCk7XG4gICAgZDMuc2VsZWN0KCcjc2V0eCcpXG4gICAgICAgIC5zZWxlY3RBbGwoJ3N2ZycpXG4gICAgICAgIC5yZW1vdmUoKTtcbiAgICBhbGxOb2Rlcy5mb3JFYWNoKG4gPT4gbi5zZXR4cGxvdCA9IG4uc3Vic2V0cGxvdCA9IGZhbHNlKTtcbn1cblxuLy8gYWN0cyBhcyBpZiB0aGUgdXNlciBjbGlja2VkIGluIHdoaXRlc3BhY2UuIHVzZWZ1bCB3aGVuIHJlc3RhcnQoKSBpcyBvdXRzaWRlIG9mIHNjb3BlXG5leHBvcnQgbGV0IGZha2VDbGljayA9ICgpID0+IHtcbiAgICBsZXQgd3MgPSBcIiN3aGl0ZXNwYWNlXCIuY29uY2F0KG15c3BhY2UpO1xuICAgIC8vIGQzIGFuZCBwcm9ncmFtbWF0aWMgZXZlbnRzIGRvbid0IG1lc2ggd2VsbCwgaGVyZSdzIGEgU08gd29ya2Fyb3VuZCB0aGF0IGxvb2tzIGdvb2QgYnV0IHVzZXMganF1ZXJ5Li4uXG4gICAgalF1ZXJ5LmZuLmQzQ2xpY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5lYWNoKChpLCBlKSA9PiB7XG4gICAgICAgICAgICBsZXQgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJNb3VzZUV2ZW50c1wiKTtcbiAgICAgICAgICAgIGV2dC5pbml0TW91c2VFdmVudChcIm1vdXNlZG93blwiLCB0cnVlLCB0cnVlLCB3aW5kb3csIDAsIDAsIDAsIDAsIDAsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAwLCBudWxsKTtcbiAgICAgICAgICAgIGUuZGlzcGF0Y2hFdmVudChldnQpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgICQod3MpLmQzQ2xpY2soKTtcbiAgICBkMy5zZWxlY3Qod3MpXG4gICAgICAgIC5jbGFzc2VkKCdhY3RpdmUnLCBmYWxzZSk7XG59O1xuXG4vKipcbiAgIEVuZFNlc3Npb24oU2Vzc2lvbkNvbnRleHQpIHJldHVybnMgKFJlc3BvbnNlKSB7fVxuKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBlbmRzZXNzaW9uKCkge1xuXG4gICAgbGV0IHRhYmxlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJyZXN1bHRzXCIpLmdldEVsZW1lbnRzQnlUYWdOYW1lKCd0YWJsZScpWzBdO1xuICAgIGlmKHR5cGVvZiB0YWJsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgYWxlcnQoXCJObyBwaXBlbGluZXMgZXhpc3QuIENhbm5vdCBtYXJrIHByb2JsZW0gYXMgY29tcGxldGUuXCIpXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgc2VsZWN0ZWQgPSBcIm5vbmVcIjtcblxuIC8vdGhlcmUncyBhIGNsZWFuZXIgd2F5IHRvIGRvIHRoaXMuLi5cbiAgICBmb3IgKGxldCBpID0gMSwgcm93OyByb3cgPSB0YWJsZS5yb3dzW2ldOyBpKyspIHsgLy9za2lwcGluZyB0aGUgaGVhZGVyXG4gICAgICAgIGlmKHJvdy5jbGFzc05hbWU9PSdpdGVtLXNlbGVjdCcpe1xuICAgICAgICAgICAgc2VsZWN0ZWQ9cm93LmNlbGxzWzBdLmlubmVySFRNTDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNhbGxpbmcgZXhwb3J0cGlwZWxpbmVcbiAgICBsZXQgZW5kID0gYXdhaXQgZXhwb3J0cGlwZWxpbmUoc2VsZWN0ZWQpO1xuXG4gICAvLyBtYWtlUmVxdWVzdChEM01fU1ZDX1VSTCArICcvZW5kc2Vzc2lvbicsIGFwaVNlc3Npb24oenBhcmFtcy56c2Vzc2lvbmlkKSk7XG4gICAgbGV0IHJlcyA9IGF3YWl0IG1ha2VSZXF1ZXN0KEQzTV9TVkNfVVJMICsgJy9lbmRzZXNzaW9uJywgYXBpU2Vzc2lvbih6cGFyYW1zLnpzZXNzaW9uaWQpKTtcbiAgICBsZXQgbXlzdGF0dXMgPSByZXMuc3RhdHVzLmNvZGUudG9VcHBlckNhc2UoKTtcbiAgICBpZihteXN0YXR1cyA9PSBcIk9LXCIpIHtcbiAgICAgICAgZW5kX3RhM19zZWFyY2godHJ1ZSwgXCJQcm9ibGVtIG1hcmtlZCBhcyBjb21wbGV0ZS5cIik7XG4gICAgfVxufVxuXG4vKipcbiAgICBycGMgRGVsZXRlUGlwZWxpbmVzKFBpcGVsaW5lRGVsZXRlUmVxdWVzdCkgcmV0dXJucyAoUGlwZWxpbmVMaXN0UmVzdWx0KSB7fVxuICAgIHBpcGVzIGlzIGFuIGFycmF5IG9mIHBpcGVsaW5lIElEc1xuKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWxldGVwaXBlbGluZXMocGlwZXMpIHtcbiAgICBsZXQgcmVzID0gbWFrZVJlcXVlc3QoRDNNX1NWQ19VUkwgKyAnL0RlbGV0ZVBpcGVsaW5lcycsIHtjb250ZXh0OiBhcGlTZXNzaW9uKHpwYXJhbXMuenNlc3Npb25pZCksIGRlbGV0ZVBpcGVsaW5lSWRzOiBwaXBlc30pO1xuICAgIGlmICghcmVzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG59XG5cbi8qKlxuICAgIHJwYyBEZWxldGVQaXBlbGluZXMoUGlwZWxpbmVEZWxldGVSZXF1ZXN0KSByZXR1cm5zIChQaXBlbGluZUxpc3RSZXN1bHQpIHt9XG4gICAgcGlwZXMgaXMgYW4gYXJyYXkgb2YgcGlwZWxpbmUgSURzXG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbmNlbHBpcGVsaW5lcyhwaXBlcykge1xuICAgIGxldCByZXMgPSBtYWtlUmVxdWVzdChEM01fU1ZDX1VSTCArICcvQ2FuY2VsUGlwZWxpbmVzJywge2NvbnRleHQ6IGFwaVNlc3Npb24oenBhcmFtcy56c2Vzc2lvbmlkKSwgY2FuY2VsUGlwZWxpbmVJZHM6IHBpcGVzfSk7XG4gICAgaWYgKCFyZXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbn1cblxuLyoqXG4gICBycGMgTGlzdFBpcGVsaW5lcyhQaXBlbGluZUxpc3RSZXF1ZXN0KSByZXR1cm5zIChQaXBlbGluZUxpc3RSZXN1bHQpIHt9XG4gICBwaXBlcyBpcyBhbiBhcnJheSBvZiBwaXBlbGluZSBJRHNcbiovXG5leHBvcnQgZnVuY3Rpb24gbGlzdHBpcGVsaW5lcygpIHtcbiAgICBsZXQgcmVzID0gbWFrZVJlcXVlc3QoRDNNX1NWQ19VUkwgKyAnL2xpc3RwaXBlbGluZXMnLCB7Y29udGV4dDogYXBpU2Vzc2lvbih6cGFyYW1zLnpzZXNzaW9uaWQpfSk7XG4gICAgaWYgKCFyZXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vaGFyZGNvZGVkIHBpcGVzIGZvciBub3dcbiAgICBsZXQgcGlwZXMgPSByZXMucGlwZWxpbmVJZHM7XG5cbiAgICAvKlxuICAgICAgcGlwZXMudW5zaGlmdChcInBsYWNlXCIpO1xuICAgICAgY29uc29sZS5sb2cocGlwZXMpO1xuICAgICAgZDMuc2VsZWN0KFwiI3Jlc3VsdHNcIikuc2VsZWN0QWxsKFwicFwiKVxuICAgICAgLmRhdGEocGlwZXMpXG4gICAgICAuZW50ZXIoKVxuICAgICAgLmFwcGVuZChcInBcIilcbiAgICAgIC5hdHRyKFwiaWRcIiwgXCJfcGlwZV9cIi5jb25jYXQpXG4gICAgICAudGV4dChkID0+IGQpXG4gICAgICAuYXR0cignY2xhc3MnLCAnaXRlbS1kZWZhdWx0JylcbiAgICAgIC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgaWYodGhpcy5jbGFzc05hbWU9PVwiaXRlbS1zZWxlY3RcIikge1xuICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgIGQzLnNlbGVjdChcIiNyZXN1bHRzXCIpLnNlbGVjdChcInAuaXRlbS1zZWxlY3RcIilcbiAgICAgIC5hdHRyKCdjbGFzcycsICdpdGVtLWRlZmF1bHQnKTtcbiAgICAgIGQzLnNlbGVjdCh0aGlzKS5hdHRyKCdjbGFzcycsXCJpdGVtLXNlbGVjdFwiKTtcbiAgICAgIH19KTtcblxuICAgICAgcGlwZXMuc2hpZnQoKTtcblxuXG4gICAgICBkMy5zZWxlY3QoXCIjc2V0eFJpZ2h0XCIpLnNlbGVjdEFsbChcInBcIilcbiAgICAgIC5kYXRhKHBpcGVzKVxuICAgICAgLmVudGVyKClcbiAgICAgIC5hcHBlbmQoXCJwXCIpXG4gICAgICAuYXR0cihcImlkXCIsIFwiX3NldHhwaXBlX1wiLmNvbmNhdClcbiAgICAgIC50ZXh0KGQgPT4gZClcbiAgICAgIC5hdHRyKCdjbGFzcycsICdpdGVtLWRlZmF1bHQnKVxuICAgICAgLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG4gICAgICBpZih0aGlzLmNsYXNzTmFtZT09XCJpdGVtLXNlbGVjdFwiKSB7XG4gICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgZDMuc2VsZWN0KFwiI3NldHhSaWdodFwiKS5zZWxlY3QoXCJwLml0ZW0tc2VsZWN0XCIpXG4gICAgICAuYXR0cignY2xhc3MnLCAnaXRlbS1kZWZhdWx0Jyk7XG4gICAgICBkMy5zZWxlY3QodGhpcykuYXR0cignY2xhc3MnLFwiaXRlbS1zZWxlY3RcIik7XG4gICAgICB9fSk7XG4gICAgKi9cbn1cblxuLyoqXG4gICBycGMgRXhlY3V0ZVBpcGVsaW5lKFBpcGVsaW5lRXhlY3V0ZVJlcXVlc3QpIHJldHVybnMgKHN0cmVhbSBQaXBlbGluZUV4ZWN1dGVSZXN1bHQpIHt9XG4qL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGV4ZWN1dGVwaXBlbGluZSgpIHtcbiAgICBsZXQgY29udGV4dCA9IGFwaVNlc3Npb24oenBhcmFtcy56c2Vzc2lvbmlkKTtcbiAgICBsZXQgdGFibGVyb3cgPSBieUlkKCdzZXR4UmlnaHQnKS5xdWVyeVNlbGVjdG9yKCd0ci5pdGVtLXNlbGVjdCcpO1xuICAgIGlmKHRhYmxlcm93ID09IG51bGwpIHthbGVydChcIlBsZWFzZSBzZWxlY3QgYSBwaXBlbGluZSB0byBleGVjdXRlIG9uLlwiKTsgcmV0dXJuO31cbiAgICBsZXQgcGlwZWxpbmVJZD10YWJsZXJvdy5maXJzdENoaWxkLmlubmVyVGV4dDtcblxuICAgIHpQb3AoKTtcbiAgICB6cGFyYW1zLmNhbGxIaXN0b3J5ID0gY2FsbEhpc3Rvcnk7XG5cbiAgICBsZXQgZGF0YSA9IFtdO1xuXG4gICAgLy90aGlzIHdpbGwganVzdCBzZXQgenBhcmFtcy56c2V0eCB0byB0aGUgbWVhbiwgd2hpY2ggaXMgZGVmYXVsdCBmb3Igc2V0eCBwbG90c1xuICAgIC8vbm90ZSB0aGF0IGlmIHNldHhwbG90IGlzIG1vZGlmaWVkLCBpdCB3aWxsIE5PVCA9PSBcIlwiIGJlY2F1c2UgenBhcmFtcy56c2V0eCBpcyBtb2RpZmllZCB3aGVuIHRoZSBzZXR4IHBsb3Qgc2xpZGVyIGlzIG1vdmVkIGZvciB0aGUgZmlyc3QgdGltZVxuICAgIGZvcihsZXQgaSA9MDsgaTx6cGFyYW1zLnp2YXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBteWRhdGEgPSBbXTtcbiAgICAgICAgbXlkYXRhWzBdID0genBhcmFtcy56dmFyc1tpXTtcbiAgICAgICAgbGV0IG15bWVhbiA9IGFsbE5vZGVzW2ZpbmROb2RlSW5kZXgoenBhcmFtcy56dmFyc1tpXSldLm1lYW47XG4gICAgICAgIGlmKHpwYXJhbXMuenNldHhbaV1bMF09PVwiXCIpIHtcbiAgICAgICAgICAgIG15ZGF0YVsxXT1teW1lYW47XG4gICAgICAgIH0gZWxzZSBpZih6cGFyYW1zLnpzZXR4W2ldWzBdIT1teW1lYW4pe1xuICAgICAgICAgICAgbXlkYXRhWzFdPXpwYXJhbXMuenNldHhbaV1bMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYoenBhcmFtcy56c2V0eFtpXVsxXT09XCJcIikge1xuICAgICAgICAgICAgbXlkYXRhWzJdPWFsbE5vZGVzW2ZpbmROb2RlSW5kZXgoenBhcmFtcy56dmFyc1tpXSldLm1lYW47XG4gICAgICAgIH0gZWxzZSBpZih6cGFyYW1zLnpzZXR4W2ldWzFdIT1teW1lYW4pe1xuICAgICAgICAgICAgbXlkYXRhWzJdPXpwYXJhbXMuenNldHhbaV1bMV07XG4gICAgICAgIH1cbiAgICAgICAgZGF0YS5wdXNoKG15ZGF0YSk7XG4gICAgfVxuXG4gICAgbGV0IHRlbXAgPSB7Y29udGV4dCwgcGlwZWxpbmVJZCwgZGF0YX07XG4gICAgdGVtcCA9IEpTT04uc3RyaW5naWZ5KHRlbXApO1xuICAgIGNvbnNvbGUubG9nKHRlbXApO1xuICAgIGxldCByZXMgPSBhd2FpdCBtYWtlUmVxdWVzdChEM01fU1ZDX1VSTCArICcvRXhlY3V0ZVBpcGVsaW5lJywge2NvbnRleHQsIHBpcGVsaW5lSWQsIGRhdGF9KTtcbiAgICAvLyBJIHRoaW5rIHdlIHdhbnQgdG8gZG8gdGhpcyBoZXJlLCBidXQgd2lsbCB3YWl0IGZvciBJU0kgaW1hZ2UgdG8gdGVzdCBhZ2FpbnN0XG4gICAvLyBpZihyZXMucHJvZ3Jlc3NJbmZvPT1cIkNPTVBMRVRFRFwiKSB7XG4gICAgICAgIHJlcyAmJiBhZGRQcmVkaWN0aW9ucyhyZXMpO1xuICAgLy8gfVxufVxuXG5mdW5jdGlvbiBhZGRQcmVkaWN0aW9ucyhyZXMpIHtcbiAgICBmdW5jdGlvbiB0YWJ1bGF0ZShkYXRhLCBjb2x1bW5zKSB7XG4gICAgICAgIHZhciB0YWJsZSA9IGQzLnNlbGVjdCgnI3NldHhMZWZ0Qm90dG9tUmlnaHRCb3R0b20nKS5hcHBlbmQoJ3RhYmxlJyk7XG4gICAgICAgIHZhciB0aGVhZCA9IHRhYmxlLmFwcGVuZCgndGhlYWQnKTtcbiAgICAgICAgdmFyICAgIHRib2R5ID0gdGFibGUuYXBwZW5kKCd0Ym9keScpO1xuXG4gICAgICAgIC8vIGFwcGVuZCB0aGUgaGVhZGVyIHJvd1xuICAgICAgICB0aGVhZC5hcHBlbmQoJ3RyJylcbiAgICAgICAgLnNlbGVjdEFsbCgndGgnKVxuICAgICAgICAuZGF0YShjb2x1bW5zKS5lbnRlcigpXG4gICAgICAgIC5hcHBlbmQoJ3RoJylcbiAgICAgICAgLnRleHQoZnVuY3Rpb24gKGNvbHVtbikgeyByZXR1cm4gY29sdW1uOyB9KTtcblxuICAgICAgICAvLyBjcmVhdGUgYSByb3cgZm9yIGVhY2ggb2JqZWN0IGluIHRoZSBkYXRhXG4gICAgICAgIHZhciByb3dzID0gdGJvZHkuc2VsZWN0QWxsKCd0cicpXG4gICAgICAgIC5kYXRhKGRhdGEpXG4gICAgICAgIC5lbnRlcigpXG4gICAgICAgIC5hcHBlbmQoJ3RyJyk7XG5cbiAgICAgICAgLy8gY3JlYXRlIGEgY2VsbCBpbiBlYWNoIHJvdyBmb3IgZWFjaCBjb2x1bW5cbiAgICAgICAgdmFyIGNlbGxzID0gcm93cy5zZWxlY3RBbGwoJ3RkJylcbiAgICAgICAgICAgIC5kYXRhKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sdW1ucy5tYXAoZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge2NvbHVtbjogY29sdW1uLCB2YWx1ZTogcm93W2NvbHVtbl19O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAuYXBwZW5kKCd0ZCcpXG4gICAgICAgICAgICAudGV4dChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC52YWx1ZTsgfSlcbiAgICAgICAgICAgIC5hdHRyKCdpZCcsZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJvd25hbWUgPSB0aGlzLnBhcmVudEVsZW1lbnQuZmlyc3RDaGlsZC5pbm5lclRleHQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJvd25hbWUgKyBkLmNvbHVtbjtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0YWJsZTtcbiAgICB9XG5cbiAgICAvLyB0aGlzIGlzIHdoYXQgSVNJIHNob3VsZCBsb29rIGxpa2UsIGFuZCB0aGUgdGVzdCBzZXJ2ZXIgZXZlbnR1YWxseSwgc28ganVzdCByZW1vdmUgdGhlIGZvbGxvd2luZyBsaW5lIHdoZW4gaXQncyB1cFxuICAgIHJlcyA9IHJlcy5ncnBjUmVzcFswXTtcblxuICAgIGNvbnNvbGUubG9nKHJlcyk7XG4gICAgbGV0IGFsbFByZWRzID0gcmVzLnJlc3VsdERhdGEuZGF0YTtcbiAgICBsZXQgcHJlZHZhbHMgPSBbXTtcblxuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBhbGxQcmVkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwcmVkdmFscy5wdXNoKGFsbFByZWRzW2ldW1wicHJlZHNcIl0pO1xuICAgIH1cblxuICAgIGxldCBteWRhdGEgPSBbXTtcbiAgICBteWRhdGEucHVzaCh7XCIgXCI6XCJQcmVkIDFcIixcIkUoWXxYMSlcIjpwcmVkdmFsc1swXSwgXCJFKFl8WDIpXCI6cHJlZHZhbHNbMV19KTtcblxuICAgIC8vIHJlbmRlciB0aGUgdGFibGUocylcbiAgICB0YWJ1bGF0ZShteWRhdGEsIFsnICcsICdFKFl8WDEpJywgJ0UoWXxYMiknXSk7IC8vIDIgY29sdW1uIHRhYmxlXG5cbn1cblxuLyoqXG4gICAgY2FsbCB0byBkamFuZ28gdG8gdXBkYXRlIHRoZSBwcm9ibGVtIGRlZmluaXRpb24gaW4gdGhlIHByb2JsZW0gZG9jdW1lbnRcbiAgICBycGMgU2V0UHJvYmxlbURvYyhTZXRQcm9ibGVtRG9jUmVxdWVzdCkgcmV0dXJucyAoUmVzcG9uc2UpIHt9XG4qL1xuZnVuY3Rpb24gc2V0UHJvYmxlbURlZmluaXRpb24odHlwZSwgdXBkYXRlcywgbG9va3VwKSB7XG4gICAgbWFrZVJlcXVlc3QoXG4gICAgICAgIEQzTV9TVkNfVVJMICsgXCIvU2V0UHJvYmxlbURvY1wiLFxuICAgICAgICB7cmVwbGFjZVByb2JsZW1TY2hlbWFGaWVsZDoge1t0eXBlXTogbG9va3VwW3VwZGF0ZXNbdHlwZV1dWzFdfSwgY29udGV4dDogYXBpU2Vzc2lvbih6cGFyYW1zLnpzZXNzaW9uaWQpfSk7XG59XG5cbi8qKlxuICAgZmluZCBzb21ldGhpbmcgY2VudGVyaXNoIHRvIHRoZSB2ZXJ0aWNlcyBvZiBhIGNvbnZleCBodWxsXG4gICAoc3BlY2lmaWNhbGx5LCB0aGUgY2VudGVyIG9mIHRoZSBib3VuZGluZyBib3gpXG4qL1xuZnVuY3Rpb24gamFtZXNjZW50cm9pZChjb29yZCkge1xuICAgIHZhciBtaW54ID0gY29vcmRbMF1bMF0sXG4gICAgICAgIG1heHggPSBjb29yZFswXVswXSxcbiAgICAgICAgbWlueSA9IGNvb3JkWzBdWzFdLFxuICAgICAgICBtYXh5ID0gY29vcmRbMF1bMV07XG4gICAgZm9yKHZhciBqID0gMTsgajxjb29yZC5sZW5ndGg7IGorKyl7XG4gICAgICAgIGlmIChjb29yZFtqXVswXSA8IG1pbngpIG1pbnggPSBjb29yZFtqXVswXTtcbiAgICAgICAgaWYgKGNvb3JkW2pdWzFdIDwgbWlueSkgbWlueSA9IGNvb3JkW2pdWzFdO1xuICAgICAgICBpZiAoY29vcmRbal1bMF0gPiBtYXh4KSBtYXh4ID0gY29vcmRbal1bMF07XG4gICAgICAgIGlmIChjb29yZFtqXVsxXSA+IG1heHkpIG1heHkgPSBjb29yZFtqXVsxXTtcbiAgICB9O1xuICAgICAgICByZXR1cm5bKG1pbnggKyBtYXh4KS8yLCAobWlueSArIG1heHkpLzJdO1xufTtcblxuLyoqXG4gICBEZWZpbmUgZWFjaCBwZWJibGUgcmFkaXVzLlxuICAgUHJlc2VudGx5LCBtb3N0IHBlYmJsZXMgYXJlIHNjYWxlZCB0byByYWRpdXMgc2V0IGJ5IGdsb2JhbCBSQURJVVMuXG4gICBNZW1iZXJzIG9mIGdyb3VwcyBhcmUgc2NhbGVkIGRvd24gaWYgZ3JvdXAgZ2V0cyBsYXJnZS5cbiovXG5mdW5jdGlvbiBzZXRQZWJibGVSYWRpdXMoZCl7XG4gICAgaWYgKGQuZ3JvdXAxIHx8IGQuZ3JvdXAyKXsgLy8gaWYgYSBtZW1iZXIgb2YgYSBncm91cCwgbmVlZCB0byBjYWxjdWxhdGUgcmFkaXVzIHNpemVcbiAgICAgICAgdmFyIHVwcGVyc2l6ZSA9IDdcbiAgICAgICAgdmFyIG5nMSA9IChkLmdyb3VwMSkgPyB6cGFyYW1zLnpncm91cDEubGVuZ3RoIDogMTsgLy8gc2l6ZSBvZiBncm91cDEsIGlmIGEgbWVtYmVyIG9mIGdyb3VwIDFcbiAgICAgICAgdmFyIG5nMiA9IChkLmdyb3VwMikgPyB6cGFyYW1zLnpncm91cDIubGVuZ3RoIDogMTsgLy8gc2l6ZSBvZiBncm91cDIsIGlmIGEgbWVtYmVyIG9mIGdyb3VwIDJcbiAgICAgICAgdmFyIG1heG5nID0gTWF0aC5tYXgobmcxLCBuZzIpOyAvLyBzaXplIG9mIHRoZSBsYXJnZXN0IGdyb3VwIHZhcmlhYmxlIGlzIG1lbWJlciBvZlxuICAgICAgICByZXR1cm4gKG1heG5nPnVwcGVyc2l6ZSkgPyBSQURJVVMqTWF0aC5zcXJ0KHVwcGVyc2l6ZS9tYXhuZykgOiBSQURJVVM7IC8vIGtlZXAgdG90YWwgYXJlYSBvZiBwZWJibGVzIGJvdW5kZWQgdG8gcGkgKiBSQURJVVNeMiAqIHVwcGVyc2l6ZSwgdGh1cyBzaHJpbmtpbmcgcmFkaXVzIGZvciBwZWJibGVzIGluIGxhcmdlciBncm91cHNcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUkFESVVTOyAvLyBub25ncm91cCBtZW1iZXJzIGdldCB0aGUgY29tbW9uIGdsb2JhbCByYWRpdXNcbiAgICB9XG59O1xuXG4vKipcbiAgIERlZmluZSBlYWNoIHBlYmJsZSBjaGFyZ2UuXG4qL1xuZnVuY3Rpb24gc2V0UGViYmxlQ2hhcmdlKGQpe1xuICAgIGlmKGQuZ3JvdXAxIHx8IGQuZ3JvdXAyKXtcbiAgICAgICAgaWYoZC5mb3JlZnJvbnQpey8vIHBlYmJsZXMgcGFja2VkIGluIGdyb3VwcyByZXBlbCBvdGhlcnMgb24gbW91c2VvdmVyXG4gICAgICAgICAgICByZXR1cm4gLTEwMDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHVwcGVyc2l6ZSA9IDc7XG4gICAgICAgIHZhciBuZzEgPSAoZC5ncm91cDEpID8genBhcmFtcy56Z3JvdXAxLmxlbmd0aCA6IDE7ICAgICAgLy8gc2l6ZSBvZiBncm91cDEsIGlmIGEgbWVtYmVyIG9mIGdyb3VwIDFcbiAgICAgICAgdmFyIG5nMiA9IChkLmdyb3VwMikgPyB6cGFyYW1zLnpncm91cDIubGVuZ3RoIDogMTsgICAgICAvLyBzaXplIG9mIGdyb3VwMiwgaWYgYSBtZW1iZXIgb2YgZ3JvdXAgMlxuICAgICAgICB2YXIgbWF4bmcgPSBNYXRoLm1heChuZzEsbmcyKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzaXplIG9mIHRoZSBsYXJnZXN0IGdyb3VwIHZhcmlhYmxlIGlzIG1lbWJlciBvZlxuICAgICAgICByZXR1cm4gKG1heG5nPnVwcGVyc2l6ZSkgPyAtNDAwKih1cHBlcnNpemUvbWF4bmcpIDogLTQwMDsgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkZWNyZWFzZSBjaGFyZ2UgYXMgcGViYmxlcyBiZWNvbWUgc21hbGxlciwgc28gdGhleSBjYW4gcGFjayB0b2dldGhlclxuICAgIH1lbHNle1xuICAgICAgICByZXR1cm4gLTgwMDtcbiAgICB9XG59O1xuXG4vKiogbmVlZHMgZG9jICovXG5leHBvcnQgZnVuY3Rpb24gZXhwYW5kcmlnaHRwYW5lbCgpIHtcbiAgICBieUlkKCdyaWdodHBhbmVsJykuY2xhc3NMaXN0LmFkZChcImV4cGFuZHBhbmVsZnVsbFwiKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJ0bldpZHRocyhidG5zKSB7XG4gICAgbGV0IHdpZHRoID0gYCR7MTAwIC8gYnRucy5sZW5ndGh9JWA7XG4gICAgbGV0IGV4cGFuZHdpZHRoID0gJzM1JSc7XG4gICAgbGV0IHNocmlua3dpZHRoID0gYCR7NjUgLyAoYnRucy5sZW5ndGggLSAxKX0lYDtcbiAgICBsZXQgbGlzID0gYnlJZCgncmlnaHRwYW5lbCcpLnF1ZXJ5U2VsZWN0b3JBbGwoXCIuYWNjb3JkaW9uIGxpXCIpO1xuICAgIC8vIGhhcmRseSBldmVyIHJ1bnMgb24gdGhlIHBhZ2VcbiAgICBsaXMuZm9yRWFjaChsaSA9PiB7XG4gICAgICAgIGxpLnN0eWxlLndpZHRoID0gd2lkdGg7XG4gICAgICAgIGxpLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3ZlcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbGlzLmZvckVhY2gobGkgPT4gbGkuc3R5bGUud2lkdGggPSBzaHJpbmt3aWR0aCk7XG4gICAgICAgICAgICB0aGlzLnN0eWxlLndpZHRoID0gZXhwYW5kd2lkdGg7XG4gICAgICAgIH0pO1xuICAgICAgICBsaS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsICgpID0+IGxpcy5mb3JFYWNoKGxpID0+IGxpLnN0eWxlLndpZHRoID0gd2lkdGgpKTtcbiAgICB9KTtcbn1cblxuLyoqIG5lZWRzIGRvYyAqL1xuZnVuY3Rpb24gdG9nZ2xlUmlnaHRCdXR0b25zKHNldCkge1xuICAgIGlmIChzZXQ9PVwiYWxsXCIpIHtcbiAgICAgICAgLy8gZmlyc3QgcmVtb3ZlIG5vc2hvdyBjbGFzc1xuICAgICAgICBjb25zb2xlLmxvZyhieUlkKCdyaWdodHBhbmVsYnV0dG9ucycpKVxuXG4gICAgICAgIGxldCBidG5zID0gYnlJZCgncmlnaHRwYW5lbGJ1dHRvbnMnKS5xdWVyeVNlbGVjdG9yQWxsKFwiLm5vc2hvd1wiKTtcbiAgICAgICAgY29uc29sZS5sb2coYnRucyk7XG4gICAgICAgIGJ0bnMuZm9yRWFjaChiID0+IGIuY2xhc3NMaXN0LnJlbW92ZShcIm5vc2hvd1wiKSk7XG4gICAgICAgIGNvbnNvbGUubG9nKGJ0bnMpO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKGJ5SWQoJ2J0bk1vZGVscycpKVxuICAgICAgICAvLyBkcm9wcGluZyBtb2RlbHMgZm9yIElTX0QzTV9ET01BSU5cbiAgICAgICAgaWYgKCFJU19EM01fRE9NQUlOKXtcbiAgICAgICAgICAgIGJ5SWQoJ2J0bk1vZGVscycpLmNsYXNzTGlzdC5hZGQoXCJub3Nob3dcIik7ICAgICAvLyBKSDogZG9lc24ndCBhcHBlYXIgdG8gZXhpc3QgaW4gRDNNIG1vZGVcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBpZiBzd2FuZGl2ZSwgZHJvcHBpbmcgc2V0eFxuICAgICAgICBpZihzd2FuZGl2ZSlcbiAgICAgICAgICAgIGJ5SWQoJ2J0blNldHgnKS5jbGFzc0xpc3QuYWRkKFwibm9zaG93XCIpO1xuXG4gICAgICAgIC8vIHRoZW4gc2VsZWN0IGFsbCB0aGUgYnV0dG9uc1xuICAgICAgICBidG5zID0gYnlJZCgncmlnaHRwYW5lbGJ1dHRvbnMnKS5xdWVyeVNlbGVjdG9yQWxsKFwiLmJ0bjpub3QoLm5vc2hvdylcIik7XG4gICAgICAgIGJ0bldpZHRocyhidG5zKTtcbiAgICB9IGVsc2UgaWYgKHNldD09XCJtb2RlbHNcIikge1xuICAgICAgICBieUlkKCdidG5Nb2RlbHMnKS5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZSc7XG4gICAgICAgIGJ5SWQoJ2J0blNldHgnKS5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZSc7XG4gICAgICAgIGJ5SWQoJ2J0blJlc3VsdHMnKS5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZSc7XG4gICAgICAgIGJ5SWQoJ2J0blR5cGUnKS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICBieUlkKCdidG5TdWJ0eXBlJykuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgYnlJZCgnYnRuTWV0cmljcycpLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIC8vIGJ5SWQoJ2J0bk91dHB1dHMnKS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIH1cbn1cblxuLyoqIG5lZWRzIGRvYyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc3VsdHNwbG90aW5pdChwaWQpIHtcbiAgICBjb25zb2xlLmxvZyhwaWQpO1xuICAgIHBpZCA9IGFsbFBpcGVsaW5lSW5mb1twaWRdO1xuICAgIGxldCBteWR2ID0gYWxsUGlwZWxpbmVJbmZvLnJvb2twaXBlLmRlcHZhclswXTtcbiAgICBsZXQgZHZ2YWx1ZXM9IGFsbFBpcGVsaW5lSW5mby5yb29rcGlwZS5kdnZhbHVlcztcbiAgIC8vIGxldCBwcmVkZmlsZSA9IHBpZC5waXBlbGluZUluZm8ucHJlZGljdFJlc3VsdERhdGEuZmlsZV8xO1xuXG4gICBpZihwaWQucGlwZWxpbmVJbmZvLnByZWRpY3RSZXN1bHREYXRhLnN1Y2Nlc3M9PWZhbHNlKSB7XG4gICAgICAgIGJ5SWQoJ2J0blNldHgnKS5jbGFzc0xpc3QuYWRkKFwibm9zaG93XCIpXG4gICAgICAgcmV0dXJuO1xuICAgfVxuXG4gICAgbGV0IGFsbFByZWRzID0gcGlkLnBpcGVsaW5lSW5mby5wcmVkaWN0UmVzdWx0RGF0YS5kYXRhO1xuICAgIGNvbnNvbGUubG9nKE9iamVjdC5rZXlzKGFsbFByZWRzWzFdKSk7XG4gICAgbGV0IHByZWR2YWxzID0gW107XG5cbiAgICBsZXQgbXlkdkkgPSBPYmplY3Qua2V5cyhhbGxQcmVkc1sxXSkuaW5kZXhPZihteWR2KTtcbiAgICBpZiAoIG15ZHZJID4gLTEpIHtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGFsbFByZWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwcmVkdmFscy5wdXNoKGFsbFByZWRzW2ldW215ZHZdKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoT2JqZWN0LmtleXMoYWxsUHJlZHNbMV0pLmluZGV4T2YoXCJwcmVkc1wiKSA+IC0xKSB7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBhbGxQcmVkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcHJlZHZhbHMucHVzaChhbGxQcmVkc1tpXVtcInByZWRzXCJdKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGFsZXJ0KFwiRFYgZG9lcyBub3QgbWF0Y2guIE5vIFJlc3VsdHMgd2luZG93LlwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKHByZWR2YWxzKTtcblxuICAgIC8vIG9ubHkgZG8gdGhpcyBmb3IgY2xhc3NpZmljYXRpb24gdGFza3NcbiAgICBpZihkM21UYXNrVHlwZVtkM21Qcm9ibGVtRGVzY3JpcHRpb24udGFza1R5cGVdWzFdID09IFwiQ0xBU1NJRklDQVRJT05cIikge1xuICAgICAgICBnZW5jb25mZGF0YShkdnZhbHVlcywgcHJlZHZhbHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCB4ZGF0YSA9IFwiQWN0dWFsXCI7XG4gICAgICAgIGxldCB5ZGF0YSA9IFwiUHJlZGljdGVkXCI7XG4gICAgICAgIGJpdmFyaWF0ZVBsb3QoZHZ2YWx1ZXMsIHByZWR2YWxzLCB4ZGF0YSwgeWRhdGEpO1xuICAgIH1cblxuICAgIC8vIGFkZCB0aGUgbGlzdCBvZiBwcmVkaWN0b3JzIGludG8gc2V0eExlZnRUb3BMZWZ0XG4gICAgZDMuc2VsZWN0KFwiI3NldHhMZWZ0VG9wTGVmdFwiKS5zZWxlY3RBbGwoXCJwXCIpXG4gICAgICAgIC5kYXRhKGFsbFBpcGVsaW5lSW5mby5yb29rcGlwZS5wcmVkaWN0b3JzKVxuICAgICAgICAuZW50ZXIoKVxuICAgICAgICAuYXBwZW5kKFwicFwiKVxuICAgICAgICAudGV4dChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZDsgfSlcbiAgICAgICAgLmF0dHIoJ2lkJyxmdW5jdGlvbihkKSB7IHJldHVybiBcInN4X1wiK2Q7IH0pXG4gICAgICAgIC5hdHRyKCdjbGFzcycsXCJpdGVtLWRlZmF1bHRcIilcbiAgICAgICAgLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmKHRoaXMuY2xhc3NOYW1lPT1cIml0ZW0tc2VsZWN0XCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGQzLnNlbGVjdChcIiNzZXR4TGVmdFRvcExlZnRcIikuc2VsZWN0KFwicC5pdGVtLXNlbGVjdFwiKVxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2l0ZW0tZGVmYXVsdCcpO1xuICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmF0dHIoJ2NsYXNzJyxcIml0ZW0tc2VsZWN0XCIpO1xuICAgICAgICAgICAgc2luZ2xlUGxvdCh0aGlzLmlkLnNsaWNlKDMpKTsgLy8gZHJvcHMgdGhhdCBzeF9cbiAgICAgICAgfVxuICAgICAgICB9KTtcbn1cblxuLyoqIG5lZWRzIGRvYyAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmNvbmZkYXRhIChkdnZhbHVlcywgcHJlZHZhbHMpIHtcblxuICAgIGZ1bmN0aW9uIG9ubHlVbmlxdWUodmFsdWUsIGluZGV4LCBzZWxmKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmluZGV4T2YodmFsdWUpID09PSBpbmRleDtcbiAgICB9XG5cbiAgICBsZXQgbXljb3VudHMgPSBbXTtcbiAgICBsZXQgbXlwYWlycyA9IFtdO1xuXG4gICAgLy8gY29tYmluZSBhY3R1YWxzIGFuZCBwcmVkaWN0ZWQsIGFuZCBnZXQgYWxsIHVuaXF1ZSBlbGVtZW50c1xuICAgIGxldCBteXVuaXF1ZXMgPSBkdnZhbHVlcy5jb25jYXQocHJlZHZhbHMpO1xuICAgIG15dW5pcXVlcyA9IG15dW5pcXVlcy5maWx0ZXIob25seVVuaXF1ZSk7XG5cbiAgICAvLyBjcmVhdGUgdHdvIGFycmF5czogbXljb3VudHMgaW5pdGlhbGl6ZWQgdG8gMCwgbXlwYWlycyBoYXZlIGVsZW1lbnRzIHNldCB0byBhbGwgcG9zc2libGUgcGFpcnMgb2YgdW5pcXVlc1xuICAgIC8vIGxvb2tlZCBpbnRvIHNvbHV0aW9ucyBvdGhlciB0aGFuIG5lc3RlZCBmb3JzLCBidXQgSW50ZXJuZXQgc3VnZ2VzdCBwZXJmb3JtYW5jZSBpcyBqdXN0IGZpbmUgdGhpcyB3YXlcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgbXl1bmlxdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCB0ZW1wY291bnQgPSBbXTtcbiAgICAgICAgbGV0IHRlbXBwYWlyID0gW107XG4gICAgICAgIGZvcihsZXQgaiA9IDA7IGogPCBteXVuaXF1ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIG15Y291bnRzLnB1c2goMCk7XG4gICAgICAgICAgICBteXBhaXJzLnB1c2goK215dW5pcXVlc1tpXSsnLCcrbXl1bmlxdWVzW2pdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGxpbmUgdXAgYWN0dWFscyBhbmQgcHJlZGljdGVkLCBhbmQgaW5jcmVtZW50IG15Y291bnRzIGF0IGluZGV4IHdoZXJlIG15cGFpciBoYXMgYSBtYXRjaCBmb3IgdGhlICdhY3R1YWwscHJlZGljdGVkJ1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZHZ2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHRlbXBwYWlyID0gK2R2dmFsdWVzW2ldKycsJytwcmVkdmFsc1tpXTtcbiAgICAgICAgbGV0IG15aW5kZXggPSBteXBhaXJzLmluZGV4T2YodGVtcHBhaXIpO1xuICAgICAgICBteWNvdW50c1tteWluZGV4XSArPSAxO1xuICAgIH1cblxuICAgIGxldCBjb25mZGF0YSA9IFtdLCBzaXplID0gbXl1bmlxdWVzLmxlbmd0aDtcbiAgICAvLyBhbm90aGVyIGxvb3AuLi4gdGhpcyBidWlsZHMgdGhlIGFycmF5IG9mIGFycmF5cyBmcm9tIHRoZSBmbGF0IGFycmF5IG15Y291bnRzIGZvciBpbnB1dCB0byBjb25mdXNpb25zbWF0cml4IGZ1bmN0aW9uXG4gICAgd2hpbGUgKG15Y291bnRzLmxlbmd0aCA+IDApXG4gICAgICAgIGNvbmZkYXRhLnB1c2gobXljb3VudHMuc3BsaWNlKDAsIHNpemUpKTtcblxuICAgIGNvbmZ1c2lvbm1hdHJpeChjb25mZGF0YSwgbXl1bmlxdWVzKTtcbn1cblxuLyoqIG5lZWRzIGRvYyAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmZ1c2lvbm1hdHJpeChtYXRyaXhkYXRhLCBjbGFzc2VzKSB7XG4gICAgZDMuc2VsZWN0KFwiI3NldHhMZWZ0UGxvdFwiKS5odG1sKFwiXCIpO1xuICAgIGQzLnNlbGVjdChcIiNzZXR4TGVmdFBsb3RcIikuc2VsZWN0KFwic3ZnXCIpLnJlbW92ZSgpO1xuXG4gICAgLy8gYWRhcHRlZCBmcm9tIHRoaXMgYmxvY2s6IGh0dHBzOi8vYmwub2Nrcy5vcmcvYXJwaXRuYXJlY2hhbmlhL2RiZjAzZDhlZjdmZmZhNDQ2Mzc5ZDU5ZGI2MzU0YmFjXG4gICAgbGV0IG1haW53aWR0aCA9IGJ5SWQoJ21haW4nKS5jbGllbnRXaWR0aDtcbiAgICBsZXQgbWFpbmhlaWdodCA9IGJ5SWQoJ21haW4nKS5jbGllbnRIZWlnaHQ7XG5cbiAgICBsZXQgY29uZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29uZGl2LmlkPVwiY29uZnVzaW9uY29udGFpbmVyXCI7XG4gICAgY29uZGl2LnN0eWxlLmRpc3BsYXk9XCJpbmxpbmUtYmxvY2tcIjtcbiAgICBjb25kaXYuc3R5bGUud2lkdGg9KyhtYWlud2lkdGgqLjI1KSsncHgnO1xuICAgIGNvbmRpdi5zdHlsZS5tYXJnaW5MZWZ0PScyMHB4JztcbiAgICBjb25kaXYuc3R5bGUuaGVpZ2h0PSsobWFpbmhlaWdodCouNCkrJ3B4JztcbiAgICBjb25kaXYuc3R5bGUuZmxvYXQ9XCJsZWZ0XCI7XG4gICAgYnlJZCgnc2V0eExlZnRQbG90JykuYXBwZW5kQ2hpbGQoY29uZGl2KTtcblxuICAgIGxldCBsZWdkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBsZWdkaXYuaWQ9XCJjb25mdXNpb25sZWdlbmRcIjtcbiAgICBsZWdkaXYuc3R5bGUud2lkdGg9KyhtYWlud2lkdGgqLjA3KSsncHgnO1xuICAgIGxlZ2Rpdi5zdHlsZS5tYXJnaW5MZWZ0PScyMHB4JztcbiAgICBsZWdkaXYuc3R5bGUuaGVpZ2h0PSsobWFpbmhlaWdodCouNCkrJ3B4JztcbiAgICBsZWdkaXYuc3R5bGUuZGlzcGxheT1cImlubGluZS1ibG9ja1wiO1xuICAgIGJ5SWQoJ3NldHhMZWZ0UGxvdCcpLmFwcGVuZENoaWxkKGxlZ2Rpdik7XG5cbiAgICB2YXIgbWFyZ2luID0ge3RvcDogMjAsIHJpZ2h0OiAxMCwgYm90dG9tOiAwLCBsZWZ0OiA1MH07XG4gICAgZnVuY3Rpb24gTWF0cml4KG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IHdpZHRoID0gb3B0aW9ucy53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQsXG4gICAgICAgIGRhdGEgPSBvcHRpb25zLmRhdGEsXG4gICAgICAgIGNvbnRhaW5lciA9IG9wdGlvbnMuY29udGFpbmVyLFxuICAgICAgICBsYWJlbHNEYXRhID0gb3B0aW9ucy5sYWJlbHMsXG4gICAgICAgIHN0YXJ0Q29sb3IgPSBvcHRpb25zLnN0YXJ0X2NvbG9yLFxuICAgICAgICBlbmRDb2xvciA9IG9wdGlvbnMuZW5kX2NvbG9yO1xuXG4gICAgICAgIGxldCB3aWR0aExlZ2VuZCA9IG9wdGlvbnMud2lkdGhMZWdlbmQ7XG5cbiAgICAgICAgaWYoIWRhdGEpe1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgcGFzcyBkYXRhJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZighQXJyYXkuaXNBcnJheShkYXRhKSB8fCAhZGF0YS5sZW5ndGggfHwgIUFycmF5LmlzQXJyYXkoZGF0YVswXSkpe1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJdCBzaG91bGQgYmUgYSAyLUQgYXJyYXknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBtYXhWYWx1ZSA9IGQzLm1heChkYXRhLCBmdW5jdGlvbihsYXllcikgeyByZXR1cm4gZDMubWF4KGxheWVyLCBmdW5jdGlvbihkKSB7IHJldHVybiBkOyB9KTsgfSk7XG4gICAgICAgIGxldCBtaW5WYWx1ZSA9IGQzLm1pbihkYXRhLCBmdW5jdGlvbihsYXllcikgeyByZXR1cm4gZDMubWluKGxheWVyLCBmdW5jdGlvbihkKSB7IHJldHVybiBkOyB9KTsgfSk7XG5cbiAgICAgICAgbGV0IG51bXJvd3MgPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgbGV0IG51bWNvbHMgPSBkYXRhWzBdLmxlbmd0aDtcblxuICAgICAgICBsZXQgc3ZnID0gZDMuc2VsZWN0KGNvbnRhaW5lcikuYXBwZW5kKFwic3ZnXCIpXG4gICAgICAgIC5hdHRyKFwid2lkdGhcIiwgd2lkdGggKyBtYXJnaW4ubGVmdCArIG1hcmdpbi5yaWdodClcbiAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgaGVpZ2h0ICsgbWFyZ2luLnRvcCArIG1hcmdpbi5ib3R0b20pXG4gICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgbWFyZ2luLmxlZnQgKyBcIixcIiArIG1hcmdpbi50b3AgKyBcIilcIik7XG5cbiAgICAgICAgbGV0IGJhY2tncm91bmQgPSBzdmcuYXBwZW5kKFwicmVjdFwiKVxuICAgICAgICAuc3R5bGUoXCJzdHJva2VcIiwgXCJibGFja1wiKVxuICAgICAgICAuc3R5bGUoXCJzdHJva2Utd2lkdGhcIiwgXCIycHhcIilcbiAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCB3aWR0aClcbiAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgaGVpZ2h0KTtcblxuICAgICAgICBsZXQgeCA9IGQzLnNjYWxlLm9yZGluYWwoKVxuICAgICAgICAuZG9tYWluKGQzLnJhbmdlKG51bWNvbHMpKVxuICAgICAgICAucmFuZ2VCYW5kcyhbMCwgd2lkdGhdKTtcblxuICAgICAgICBsZXQgeSA9IGQzLnNjYWxlLm9yZGluYWwoKVxuICAgICAgICAuZG9tYWluKGQzLnJhbmdlKG51bXJvd3MpKVxuICAgICAgICAucmFuZ2VCYW5kcyhbMCwgaGVpZ2h0XSk7XG5cbiAgICAgICAgbGV0IGNvbG9yTWFwID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLmRvbWFpbihbbWluVmFsdWUsbWF4VmFsdWVdKVxuICAgICAgICAucmFuZ2UoW3N0YXJ0Q29sb3IsIGVuZENvbG9yXSk7XG5cbiAgICAgICAgbGV0IHJvdyA9IHN2Zy5zZWxlY3RBbGwoXCIucm93XCIpXG4gICAgICAgIC5kYXRhKGRhdGEpXG4gICAgICAgIC5lbnRlcigpLmFwcGVuZChcImdcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInJvd1wiKVxuICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBmdW5jdGlvbihkLCBpKSB7IHJldHVybiBcInRyYW5zbGF0ZSgwLFwiICsgeShpKSArIFwiKVwiOyB9KTtcblxuICAgICAgICBsZXQgY2VsbCA9IHJvdy5zZWxlY3RBbGwoXCIuY2VsbFwiKVxuICAgICAgICAuZGF0YShmdW5jdGlvbihkKSB7IHJldHVybiBkOyB9KVxuICAgICAgICAuZW50ZXIoKS5hcHBlbmQoXCJnXCIpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJjZWxsXCIpXG4gICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uKGQsIGkpIHsgcmV0dXJuIFwidHJhbnNsYXRlKFwiICsgeChpKSArIFwiLCAwKVwiOyB9KTtcblxuICAgICAgICBjZWxsLmFwcGVuZCgncmVjdCcpXG4gICAgICAgIC5hdHRyKFwid2lkdGhcIiwgeC5yYW5nZUJhbmQoKSlcbiAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgeS5yYW5nZUJhbmQoKSlcbiAgICAgICAgLnN0eWxlKFwic3Ryb2tlLXdpZHRoXCIsIDApO1xuXG4gICAgICAgIGNlbGwuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAuYXR0cihcImR5XCIsIFwiLjMyZW1cIilcbiAgICAgICAgLmF0dHIoXCJ4XCIsIHgucmFuZ2VCYW5kKCkgLyAyKVxuICAgICAgICAuYXR0cihcInlcIiwgeS5yYW5nZUJhbmQoKSAvIDIpXG4gICAgICAgIC5hdHRyKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIilcbiAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBmdW5jdGlvbihkLCBpKSB7IHJldHVybiBkID49IG1heFZhbHVlLzIgPyAnd2hpdGUnIDogJ2JsYWNrJzsgfSlcbiAgICAgICAgLnRleHQoZnVuY3Rpb24oZCwgaSkgeyByZXR1cm4gZDsgfSk7XG5cbiAgICAgICAgcm93LnNlbGVjdEFsbChcIi5jZWxsXCIpXG4gICAgICAgIC5kYXRhKGZ1bmN0aW9uKGQsIGkpIHsgcmV0dXJuIGRhdGFbaV07IH0pXG4gICAgICAgIC5zdHlsZShcImZpbGxcIiwgY29sb3JNYXApO1xuXG4gICAgICAgIC8vIHRoaXMgcG9ydGlvbiBvZiB0aGUgY29kZSBpc24ndCBhcyByb2J1c3QgdG8gc2l6aW5nLiBjb2x1bW4gbGFiZWxzIG5vdCByZW5kZXJpbmcgaW4gdGhlIHJpZ2h0IHBsYWNlXG4gICAgICAgIGxldCBsYWJlbHMgPSBzdmcuYXBwZW5kKCdnJylcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgXCJsYWJlbHNcIik7XG5cbiAgICAgICAgbGV0IGNvbHVtbkxhYmVscyA9IGxhYmVscy5zZWxlY3RBbGwoXCIuY29sdW1uLWxhYmVsXCIpXG4gICAgICAgIC5kYXRhKGxhYmVsc0RhdGEpXG4gICAgICAgIC5lbnRlcigpLmFwcGVuZChcImdcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImNvbHVtbi1sYWJlbFwiKVxuICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICAgLy8gbGV0IHRlbXAgPSBcInRyYW5zbGF0ZShcIiArIHgoaSkgKyBcIixcIiArIChoZWlnaHQrMjApICsgXCIpXCI7IC8vIHRoaXMgaW4gcGFydGljdWxhciBsb29rcyB0byBiZSB0aGUgY2F1c2VcbiAgICAgICAgICAgIC8vICBjb25zb2xlLmxvZyh0ZW1wKTtcbiAgICAgICAgICAgICAgcmV0dXJuIFwidHJhbnNsYXRlKFwiICsgeChpKSArIFwiLFwiICsgKGhlaWdodCszMCkgKyBcIilcIjsgfSk7XG5cbiAgICAgICAgY29sdW1uTGFiZWxzLmFwcGVuZChcImxpbmVcIilcbiAgICAgICAgLnN0eWxlKFwic3Ryb2tlXCIsIFwiYmxhY2tcIilcbiAgICAgICAgLnN0eWxlKFwic3Ryb2tlLXdpZHRoXCIsIFwiMXB4XCIpXG4gICAgICAgIC5hdHRyKFwieDFcIiwgeC5yYW5nZUJhbmQoKSAvIDIpXG4gICAgICAgIC5hdHRyKFwieDJcIiwgeC5yYW5nZUJhbmQoKSAvIDIpXG4gICAgICAgIC5hdHRyKFwieTFcIiwgMClcbiAgICAgICAgLmF0dHIoXCJ5MlwiLCA1KTtcblxuICAgICAgICBjb2x1bW5MYWJlbHMuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAuYXR0cihcInhcIiwgMzApXG4gICAgICAgIC5hdHRyKFwieVwiLCB5LnJhbmdlQmFuZCgpIC8gMilcbiAgICAgICAgLmF0dHIoXCJkeVwiLCBcIi4yMmVtXCIpXG4gICAgICAgIC5hdHRyKFwidGV4dC1hbmNob3JcIiwgXCJlbmRcIilcbiAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJyb3RhdGUoLTYwKVwiKVxuICAgICAgICAudGV4dChmdW5jdGlvbihkLCBpKSB7IHJldHVybiBkOyB9KTtcblxuICAgICAgICBsZXQgcm93TGFiZWxzID0gbGFiZWxzLnNlbGVjdEFsbChcIi5yb3ctbGFiZWxcIilcbiAgICAgICAgLmRhdGEobGFiZWxzRGF0YSlcbiAgICAgICAgLmVudGVyKCkuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwicm93LWxhYmVsXCIpXG4gICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uKGQsIGkpIHsgcmV0dXJuIFwidHJhbnNsYXRlKFwiICsgMCArIFwiLFwiICsgeShpKSArIFwiKVwiOyB9KTtcblxuICAgICAgICByb3dMYWJlbHMuYXBwZW5kKFwibGluZVwiKVxuICAgICAgICAuc3R5bGUoXCJzdHJva2VcIiwgXCJibGFja1wiKVxuICAgICAgICAuc3R5bGUoXCJzdHJva2Utd2lkdGhcIiwgXCIxcHhcIilcbiAgICAgICAgLmF0dHIoXCJ4MVwiLCAwKVxuICAgICAgICAuYXR0cihcIngyXCIsIC01KVxuICAgICAgICAuYXR0cihcInkxXCIsIHkucmFuZ2VCYW5kKCkgLyAyKVxuICAgICAgICAuYXR0cihcInkyXCIsIHkucmFuZ2VCYW5kKCkgLyAyKTtcblxuICAgICAgICByb3dMYWJlbHMuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAuYXR0cihcInhcIiwgLTgpXG4gICAgICAgIC5hdHRyKFwieVwiLCB5LnJhbmdlQmFuZCgpIC8gMilcbiAgICAgICAgLmF0dHIoXCJkeVwiLCBcIi4zMmVtXCIpXG4gICAgICAgIC5hdHRyKFwidGV4dC1hbmNob3JcIiwgXCJlbmRcIilcbiAgICAgICAgLnRleHQoZnVuY3Rpb24oZCwgaSkgeyByZXR1cm4gZDsgfSk7XG5cbiAgICAgICAgbGV0IGtleSA9IGQzLnNlbGVjdChcIiNjb25mdXNpb25sZWdlbmRcIilcbiAgICAgICAgLmFwcGVuZChcInN2Z1wiKVxuICAgICAgICAuYXR0cihcIndpZHRoXCIsIHdpZHRoTGVnZW5kKVxuICAgICAgICAuYXR0cihcImhlaWdodFwiLCBoZWlnaHQgKyBtYXJnaW4udG9wICsgbWFyZ2luLmJvdHRvbSk7XG5cbiAgICAgICAgbGV0IGxlZ2VuZCA9IGtleVxuICAgICAgICAuYXBwZW5kKFwiZGVmc1wiKVxuICAgICAgICAuYXBwZW5kKFwic3ZnOmxpbmVhckdyYWRpZW50XCIpXG4gICAgICAgIC5hdHRyKFwiaWRcIiwgXCJncmFkaWVudFwiKVxuICAgICAgICAuYXR0cihcIngxXCIsIFwiMTAwJVwiKVxuICAgICAgICAuYXR0cihcInkxXCIsIFwiMCVcIilcbiAgICAgICAgLmF0dHIoXCJ4MlwiLCBcIjEwMCVcIilcbiAgICAgICAgLmF0dHIoXCJ5MlwiLCBcIjEwMCVcIilcbiAgICAgICAgLmF0dHIoXCJzcHJlYWRNZXRob2RcIiwgXCJwYWRcIik7XG5cbiAgICAgICAgbGVnZW5kXG4gICAgICAgIC5hcHBlbmQoXCJzdG9wXCIpXG4gICAgICAgIC5hdHRyKFwib2Zmc2V0XCIsIFwiMCVcIilcbiAgICAgICAgLmF0dHIoXCJzdG9wLWNvbG9yXCIsIGVuZENvbG9yKVxuICAgICAgICAuYXR0cihcInN0b3Atb3BhY2l0eVwiLCAxKTtcblxuICAgICAgICBsZWdlbmRcbiAgICAgICAgLmFwcGVuZChcInN0b3BcIilcbiAgICAgICAgLmF0dHIoXCJvZmZzZXRcIiwgXCIxMDAlXCIpXG4gICAgICAgIC5hdHRyKFwic3RvcC1jb2xvclwiLCBzdGFydENvbG9yKVxuICAgICAgICAuYXR0cihcInN0b3Atb3BhY2l0eVwiLCAxKTtcblxuICAgICAgICBrZXkuYXBwZW5kKFwicmVjdFwiKVxuICAgICAgICAuYXR0cihcIndpZHRoXCIsIHdpZHRoTGVnZW5kLzItMTApXG4gICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGhlaWdodClcbiAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBcInVybCgjZ3JhZGllbnQpXCIpXG4gICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsXCIgKyBtYXJnaW4udG9wICsgXCIpXCIpO1xuXG4gICAgICAgIC8vIHRoaXMgeSBpcyBmb3IgdGhlIGxlZ2VuZFxuICAgICAgICB5ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLnJhbmdlKFtoZWlnaHQsIDBdKVxuICAgICAgICAuZG9tYWluKFttaW5WYWx1ZSwgbWF4VmFsdWVdKTtcblxuICAgICAgICBsZXQgeUF4aXMgPSBkMy5zdmcuYXhpcygpXG4gICAgICAgIC5zY2FsZSh5KVxuICAgICAgICAub3JpZW50KFwicmlnaHRcIik7XG5cbiAgICAgICAga2V5XG4gICAgICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInkgYXhpc1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoNDEsXCIgKyBtYXJnaW4udG9wICsgXCIpXCIpXG4gICAgICAgICAgICAuY2FsbCh5QXhpcyk7XG4gICAgfVxuXG4gICAgLy8gVGhlIHRhYmxlIGdlbmVyYXRpb24gZnVuY3Rpb24uIFVzZWQgZm9yIHRoZSB0YWJsZSBvZiBwZXJmb3JtYW5jZSBtZWFzdXJlcywgbm90IHRoZSBjb25mdXNpb24gbWF0cml4XG4gICAgZnVuY3Rpb24gdGFidWxhdGUoZGF0YSwgY29sdW1ucykge1xuICAgICAgICB2YXIgdGFibGUgPSBkMy5zZWxlY3QoXCIjc2V0eExlZnRQbG90XCIpLmFwcGVuZChcInRhYmxlXCIpXG4gICAgICAgIC5hdHRyKFwic3R5bGVcIiwgXCJtYXJnaW4tbGVmdDogXCIgKyBtYXJnaW4ubGVmdCArXCJweFwiKSxcbiAgICAgICAgdGhlYWQgPSB0YWJsZS5hcHBlbmQoXCJ0aGVhZFwiKSxcbiAgICAgICAgdGJvZHkgPSB0YWJsZS5hcHBlbmQoXCJ0Ym9keVwiKTtcblxuICAgICAgICAvLyBhcHBlbmQgdGhlIGhlYWRlciByb3dcbiAgICAgICAgdGhlYWQuYXBwZW5kKFwidHJcIilcbiAgICAgICAgLnNlbGVjdEFsbChcInRoXCIpXG4gICAgICAgIC5kYXRhKGNvbHVtbnMpXG4gICAgICAgIC5lbnRlcigpXG4gICAgICAgIC5hcHBlbmQoXCJ0aFwiKVxuICAgICAgICAudGV4dChmdW5jdGlvbihjb2x1bW4pIHsgcmV0dXJuIGNvbHVtbjsgfSk7XG5cbiAgICAgICAgLy8gY3JlYXRlIGEgcm93IGZvciBlYWNoIG9iamVjdCBpbiB0aGUgZGF0YVxuICAgICAgICB2YXIgcm93cyA9IHRib2R5LnNlbGVjdEFsbChcInRyXCIpXG4gICAgICAgIC5kYXRhKGRhdGEpXG4gICAgICAgIC5lbnRlcigpXG4gICAgICAgIC5hcHBlbmQoXCJ0clwiKTtcblxuICAgICAgICAvLyBjcmVhdGUgYSBjZWxsIGluIGVhY2ggcm93IGZvciBlYWNoIGNvbHVtblxuICAgICAgICB2YXIgY2VsbHMgPSByb3dzLnNlbGVjdEFsbChcInRkXCIpXG4gICAgICAgIC5kYXRhKGZ1bmN0aW9uKHJvdykge1xuICAgICAgICAgICAgICByZXR1cm4gY29sdW1ucy5tYXAoZnVuY3Rpb24oY29sdW1uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge2NvbHVtbjogY29sdW1uLCB2YWx1ZTogcm93W2NvbHVtbl19O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgIC5lbnRlcigpXG4gICAgICAgIC5hcHBlbmQoXCJ0ZFwiKVxuICAgICAgICAuYXR0cihcInN0eWxlXCIsIFwiZm9udC1mYW1pbHk6IENvdXJpZXJcIikgLy8gc2V0cyB0aGUgZm9udCBzdHlsZVxuICAgICAgICAuaHRtbChmdW5jdGlvbihkKSB7IHJldHVybiBkLnZhbHVlOyB9KTtcblxuICAgICAgICByZXR1cm4gdGFibGU7XG4gICAgfVxuXG4gICAgLy8gdGhpcyBjb2RlIGlzIGFsbCBmb3IgcHJvZHVjaW5nIGEgdGFibGUgd2l0aCBwZXJmb3JtYW5jZSBtZWFzdXJlc1xuICAgIC8vdmFyIGNvbmZ1c2lvbk1hdHJpeCA9IFtbMTY5LCAxMF0sWzcsIDQ2XV07XG4gICAgdmFyIHRwID0gbWF0cml4ZGF0YVswXVswXTtcbiAgICB2YXIgZm4gPSBtYXRyaXhkYXRhWzBdWzFdO1xuICAgIHZhciBmcCA9IG1hdHJpeGRhdGFbMV1bMF07XG4gICAgdmFyIHRuID0gbWF0cml4ZGF0YVsxXVsxXTtcblxuICAgIHZhciBwID0gdHAgKyBmbjtcbiAgICB2YXIgbiA9IGZwICsgdG47XG5cbiAgICB2YXIgYWNjdXJhY3kgPSAodHArdG4pLyhwK24pO1xuICAgIHZhciBmMSA9IDIqdHAvKDIqdHArZnArZm4pO1xuICAgIHZhciBwcmVjaXNpb24gPSB0cC8odHArZnApO1xuICAgIHZhciByZWNhbGwgPSB0cC8odHArZm4pO1xuXG4gICAgYWNjdXJhY3kgPSBNYXRoLnJvdW5kKGFjY3VyYWN5ICogMTAwKSAvIDEwMDtcbiAgICBmMSA9IE1hdGgucm91bmQoZjEgKiAxMDApIC8gMTAwO1xuICAgIHByZWNpc2lvbiA9IE1hdGgucm91bmQocHJlY2lzaW9uICogMTAwKSAvIDEwMDtcbiAgICByZWNhbGwgPSBNYXRoLnJvdW5kKHJlY2FsbCAqIDEwMCkgLyAxMDA7XG5cbiAgICB2YXIgY29tcHV0ZWREYXRhID0gW107XG4gICAgY29tcHV0ZWREYXRhLnB1c2goe1wiRjFcIjpmMSwgXCJQUkVDSVNJT05cIjpwcmVjaXNpb24sXCJSRUNBTExcIjpyZWNhbGwsXCJBQ0NVUkFDWVwiOmFjY3VyYWN5fSk7XG5cbiAgICBNYXRyaXgoe1xuICAgICAgICAgICBjb250YWluZXIgOiAnI2NvbmZ1c2lvbmNvbnRhaW5lcicsXG4gICAgICAgICAgIGRhdGEgICAgICA6IG1hdHJpeGRhdGEsXG4gICAgICAgICAgIGxhYmVscyAgICA6IGNsYXNzZXMsXG4gICAgICAgICAgIHN0YXJ0X2NvbG9yIDogJyNmZmZmZmYnLFxuICAgICAgICAgICBlbmRfY29sb3IgOiAnI2U2N2UyMicsXG4gICAgICAgICAgIHdpZHRoIDogbWFpbndpZHRoICogLjE1LFxuICAgICAgICAgICBoZWlnaHQgOiBtYWluaGVpZ2h0ICogLjI1LFxuICAgICAgICAgICB3aWR0aExlZ2VuZCA6IG1haW53aWR0aCouMDVcbiAgICAgICAgICAgfSk7XG5cbiAgICAvLyBub3QgcmVuZGVyaW5nIHRoaXMgdGFibGUgZm9yIHJpZ2h0IG5vdywgbGVmdCBhbGwgdGhlIGNvZGUgaW4gcGxhY2UgdGhvdWdoLiBtYXliZSB3ZSB1c2UgaXQgZXZlbnR1YWxseVxuICAgIC8vIHZhciB0YWJsZSA9IHRhYnVsYXRlKGNvbXB1dGVkRGF0YSwgW1wiRjFcIiwgXCJQUkVDSVNJT05cIixcIlJFQ0FMTFwiLFwiQUNDVVJBQ1lcIl0pO1xufVxuXG4vKipcbiAgIHNjYXR0ZXJwbG90IGZ1bmN0aW9uIHRvIGdvIHRvIHBsb3RzLmpzIHRvIGJlIHJldXNlZFxuKi9cbmV4cG9ydCBmdW5jdGlvbiBiaXZhcmlhdGVQbG90KHhfQXhpcywgeV9BeGlzLCB4X0F4aXNfbmFtZSwgeV9BeGlzX25hbWUpIHtcbiAgICBkMy5zZWxlY3QoXCIjc2V0eExlZnRQbG90XCIpLmh0bWwoXCJcIik7XG4gICAgZDMuc2VsZWN0KFwiI3NldHhMZWZ0UGxvdFwiKS5zZWxlY3QoXCJzdmdcIikucmVtb3ZlKCk7XG5cbiAgICB4X0F4aXM9eF9BeGlzLm1hcChOdW1iZXIpO1xuICAgIHlfQXhpcz15X0F4aXMubWFwKE51bWJlcik7XG5cbiAgICBjb25zb2xlLmxvZyh4X0F4aXMpO1xuICAgIGNvbnNvbGUubG9nKHlfQXhpcyk7XG5cbiAgICBsZXQgbWFpbndpZHRoID0gYnlJZCgnbWFpbicpLmNsaWVudFdpZHRoO1xuICAgIGxldCBtYWluaGVpZ2h0ID0gYnlJZCgnbWFpbicpLmNsaWVudEhlaWdodDtcblxuICAgIC8vIHNjYXR0ZXIgcGxvdFxuICAgIGxldCBkYXRhX3Bsb3QgPSBbXTtcbiAgICB2YXIgbmFuQ291bnQgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeF9BeGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpc05hTih4X0F4aXNbaV0pIHx8IGlzTmFOKHlfQXhpc1tpXSkpIHtcbiAgICAgICAgICAgIG5hbkNvdW50Kys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbmV3TnVtYmVyMSA9IHhfQXhpc1tpXTtcbiAgICAgICAgICAgIHZhciBuZXdOdW1iZXIyID0geV9BeGlzW2ldO1xuICAgICAgICAgICAgZGF0YV9wbG90LnB1c2goe3hheGlzOiBuZXdOdW1iZXIxLCB5YXhpczogbmV3TnVtYmVyMiwgc2NvcmU6IE1hdGgucmFuZG9tKCkgKiAxMDB9KTtcblxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICB2YXIgbWFyZ2luID0ge3RvcDogMzUsIHJpZ2h0OiAzNSwgYm90dG9tOiAzNSwgbGVmdDogMzV9XG4gICAgLCB3aWR0aCA9IG1haW53aWR0aCouMjUtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0XG4gICAgLCBoZWlnaHQgPSBtYWlud2lkdGgqLjI1IC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b207XG4gICAgdmFyIHBhZGRpbmcgPSAxMDA7XG5cbiAgICB2YXIgbWluX3ggPSBkMy5taW4oZGF0YV9wbG90LCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YV9wbG90W2ldLnhheGlzO1xuICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICB2YXIgbWF4X3ggPSBkMy5tYXgoZGF0YV9wbG90LCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YV9wbG90W2ldLnhheGlzO1xuICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICB2YXIgYXZnX3ggPSAobWF4X3ggLSBtaW5feCkgLyAxMDtcbiAgICB2YXIgbWluX3kgPSBkMy5taW4oZGF0YV9wbG90LCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YV9wbG90W2ldLnlheGlzO1xuICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICB2YXIgbWF4X3kgPSBkMy5tYXgoZGF0YV9wbG90LCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YV9wbG90W2ldLnlheGlzO1xuICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICB2YXIgYXZnX3kgPSAobWF4X3kgLSBtaW5feSkgLyAxMDtcblxuICAgIHZhciB4U2NhbGUgPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgIC5kb21haW4oW21pbl94IC0gYXZnX3gsIG1heF94ICsgYXZnX3hdKVxuICAgIC5yYW5nZShbMCwgd2lkdGhdKTtcblxuICAgIHZhciB5U2NhbGUgPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgIC5kb21haW4oW21pbl95IC0gYXZnX3ksIG1heF95ICsgYXZnX3ldKVxuICAgIC5yYW5nZShbaGVpZ2h0LCAwXSk7XG5cbiAgICB2YXIgeEF4aXMgPSBkMy5zdmcuYXhpcygpXG4gICAgLnNjYWxlKHhTY2FsZSlcbiAgICAub3JpZW50KCdib3R0b20nKVxuICAgIC50aWNrU2l6ZSgtaGVpZ2h0KTtcblxuICAgIHZhciB5QXhpcyA9IGQzLnN2Zy5heGlzKClcbiAgICAuc2NhbGUoeVNjYWxlKVxuICAgIC5vcmllbnQoJ2xlZnQnKVxuICAgIC50aWNrcyg1KVxuICAgIC50aWNrU2l6ZSgtd2lkdGgpO1xuXG4gICAgdmFyIHpvb20gPSBkMy5iZWhhdmlvci56b29tKClcbiAgICAueCh4U2NhbGUpXG4gICAgLnkoeVNjYWxlKVxuICAgIC5zY2FsZUV4dGVudChbMSwgMTBdKVxuICAgIC5vbihcInpvb21cIiwgem9vbWVkKTtcblxuICAgIHZhciBjaGFydF9zY2F0dGVyID0gZDMuc2VsZWN0KCcjc2V0eExlZnRQbG90JylcbiAgICAuYXBwZW5kKCdzdmc6c3ZnJylcbiAgICAuYXR0cignd2lkdGgnLCB3aWR0aCArIG1hcmdpbi5yaWdodCArIG1hcmdpbi5sZWZ0KVxuICAgIC5hdHRyKCdoZWlnaHQnLCBoZWlnaHQgKyBtYXJnaW4udG9wICsgbWFyZ2luLmJvdHRvbSk7XG4gICAgLy8gLmNhbGwoem9vbSk7IGRyb3BwaW5nIHRoaXMgZm9yIG5vdywgdW50aWwgdGhlIGxpbmUgem9vbXMgcHJvcGVybHlcblxuICAgIHZhciBtYWluMSA9IGNoYXJ0X3NjYXR0ZXIuYXBwZW5kKCdnJylcbiAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgbWFyZ2luLmxlZnQgKyAnLCcgKyBtYXJnaW4udG9wICsgJyknKVxuICAgIC5hdHRyKCd3aWR0aCcsIHdpZHRoKyBtYXJnaW4ucmlnaHQgKyBtYXJnaW4ubGVmdClcbiAgICAuYXR0cignaGVpZ2h0JywgaGVpZ2h0ICsgbWFyZ2luLnRvcCArIG1hcmdpbi5ib3R0b20pXG4gICAgLmF0dHIoJ2NsYXNzJywgJ21haW4nKTtcblxuICAgIGxldCBnWCA9IG1haW4xLmFwcGVuZCgnZycpXG4gICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwnICsgaGVpZ2h0ICsgJyknKVxuICAgIC5hdHRyKCdjbGFzcycsICd4IGF4aXMnKVxuICAgIC5jYWxsKHhBeGlzKTtcblxuICAgIGxldCBnWSA9IG1haW4xLmFwcGVuZCgnZycpXG4gICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwwKScpXG4gICAgLmF0dHIoJ2NsYXNzJywgJ3kgYXhpcycpXG4gICAgLmNhbGwoeUF4aXMpO1xuXG4gICAgdmFyIGNsaXAgPSBtYWluMS5hcHBlbmQoXCJkZWZzXCIpLmFwcGVuZChcInN2ZzpjbGlwUGF0aFwiKVxuICAgIC5hdHRyKFwiaWRcIiwgXCJjbGlwXCIpXG4gICAgLmFwcGVuZChcInN2ZzpyZWN0XCIpXG4gICAgLmF0dHIoXCJpZFwiLCBcImNsaXAtcmVjdFwiKVxuICAgIC5hdHRyKFwieFwiLCBcIjBcIilcbiAgICAuYXR0cihcInlcIiwgXCIwXCIpXG4gICAgLmF0dHIoJ3dpZHRoJywgd2lkdGgpXG4gICAgLmF0dHIoJ2hlaWdodCcsIGhlaWdodCk7XG5cbiAgICBtYWluMS5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGlwLXBhdGhcIiwgXCJ1cmwoI2NsaXApXCIpXG4gICAgLnNlbGVjdEFsbChcImNpcmNsZVwiKVxuICAgIC5kYXRhKGRhdGFfcGxvdClcbiAgICAuZW50ZXIoKVxuICAgIC5hcHBlbmQoXCJjaXJjbGVcIilcbiAgICAuYXR0cihcImN4XCIsIChkLCBpKSA9PiB4U2NhbGUoZGF0YV9wbG90W2ldLnhheGlzKSlcbiAgICAuYXR0cihcImN5XCIsIChkLCBpKSA9PiB5U2NhbGUoZGF0YV9wbG90W2ldLnlheGlzKSlcbiAgICAuYXR0cihcInJcIiwgMilcbiAgICAuc3R5bGUoXCJmaWxsXCIsIFwiI0I3MUMxQ1wiKTtcblxuXG4gICAgY2hhcnRfc2NhdHRlci5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKSAgLy8gdGhpcyBtYWtlcyBpdCBlYXN5IHRvIGNlbnRyZSB0aGUgdGV4dCBhcyB0aGUgdHJhbnNmb3JtIGlzIGFwcGxpZWQgdG8gdGhlIGFuY2hvclxuICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgcGFkZGluZyAvIDUgKyBcIixcIiArIChoZWlnaHQgLyAyKSArIFwiKXJvdGF0ZSgtOTApXCIpICAvLyB0ZXh0IGlzIGRyYXduIG9mZiB0aGUgc2NyZWVuIHRvcCBsZWZ0LCBtb3ZlIGRvd24gYW5kIG91dCBhbmQgcm90YXRlXG4gICAgLnRleHQoeV9BeGlzX25hbWUpXG4gICAgLnN0eWxlKFwiZmlsbFwiLCBcIiM0MjQyNDJcIilcbiAgICAuc3R5bGUoXCJ0ZXh0LWluZGVudFwiLFwiMjBweFwiKVxuICAgIC5zdHlsZShcImZvbnQtc2l6ZVwiLFwiMTJweFwiKVxuICAgIC5zdHlsZShcImZvbnQtd2VpZ2h0XCIsXCJib2xkXCIpO1xuXG4gICAgY2hhcnRfc2NhdHRlci5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKSAgLy8gdGhpcyBtYWtlcyBpdCBlYXN5IHRvIGNlbnRyZSB0aGUgdGV4dCBhcyB0aGUgdHJhbnNmb3JtIGlzIGFwcGxpZWQgdG8gdGhlIGFuY2hvclxuICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgKHdpZHRoIC8gMikgKyBcIixcIiArIChoZWlnaHQgKyAocGFkZGluZyAvIDIpKSArIFwiKVwiKSAgLy8gY2VudHJlIGJlbG93IGF4aXNcbiAgICAudGV4dCh4X0F4aXNfbmFtZSlcbiAgICAuc3R5bGUoXCJmaWxsXCIsIFwiIzQyNDI0MlwiKVxuICAgIC5zdHlsZShcInRleHQtaW5kZW50XCIsXCIyMHB4XCIpXG4gICAgLnN0eWxlKFwiZm9udC1zaXplXCIsXCIxMnB4XCIpXG4gICAgLnN0eWxlKFwiZm9udC13ZWlnaHRcIixcImJvbGRcIik7XG5cblxuICAgIG1haW4xLmFwcGVuZChcImxpbmVcIilcbiAgICAuYXR0cihcIngxXCIsIHhTY2FsZShtaW5feCkpXG4gICAgLmF0dHIoXCJ5MVwiLCB5U2NhbGUobWluX3gpKVxuICAgIC5hdHRyKFwieDJcIiwgeFNjYWxlKG1heF94KSlcbiAgICAuYXR0cihcInkyXCIsIHlTY2FsZShtYXhfeCkpXG4gICAgLmF0dHIoXCJzdHJva2Utd2lkdGhcIiwgMilcbiAgICAuYXR0cihcInN0cm9rZVwiLCBcImJsYWNrXCIpO1xuXG4gICAgZnVuY3Rpb24gem9vbWVkKCkge1xuICAgICAgICB2YXIgcGFuWCA9IGQzLmV2ZW50LnRyYW5zbGF0ZVswXTtcbiAgICAgICAgdmFyIHBhblkgPSBkMy5ldmVudC50cmFuc2xhdGVbMV07XG4gICAgICAgIHZhciBzY2FsZSA9IGQzLmV2ZW50LnNjYWxlO1xuXG4gICAgICAgIHBhblggPSBwYW5YID4gMTAgPyAxMCA6IHBhblg7XG4gICAgICAgIHZhciBtYXhYID0gLShzY2FsZSAtIDEpICogd2lkdGggLSAxMDtcbiAgICAgICAgcGFuWCA9IHBhblggPCBtYXhYID8gbWF4WCA6IHBhblg7XG5cbiAgICAgICAgcGFuWSA9IHBhblkgPiAxMCA/IDEwIDogcGFuWTtcbiAgICAgICAgdmFyIG1heFkgPSAtKHNjYWxlIC0gMSkgKiBoZWlnaHQgLSAxMDtcbiAgICAgICAgcGFuWSA9IHBhblkgPCBtYXhZID8gbWF4WSA6IHBhblk7XG5cbiAgICAgICAgem9vbS50cmFuc2xhdGUoW3BhblgsIHBhblldKTtcblxuXG4gICAgICAgIG1haW4xLnNlbGVjdChcIi54LmF4aXNcIikuY2FsbCh4QXhpcyk7XG4gICAgICAgIG1haW4xLnNlbGVjdChcIi55LmF4aXNcIikuY2FsbCh5QXhpcyk7XG4gICAgICAgIG1haW4xLnNlbGVjdEFsbChcImNpcmNsZVwiKVxuICAgICAgICAuYXR0cihcImN4XCIsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY2lyY2xlIHggXCIseFNjYWxlKDUpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHhTY2FsZShkYXRhX3Bsb3RbaV0ueGF4aXMpO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAuYXR0cihcImN5XCIsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB5U2NhbGUoZGF0YV9wbG90W2ldLnlheGlzKTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoXCJyXCIsIDIuNSlcbiAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBcIiNCNzFDMUNcIik7XG5cbiAgICAgICAvLyBiZWxvdyBkb2Vzbid0IHdvcmssIHNvIEknbSBqdXN0IGRyb3BwaW5nIHRoZSB6b29tXG4gICAgICAgIG1haW4xLnNlbGVjdChcImxpbmVcIilcbiAgICAgICAgLmF0dHIoXCJ4MVwiLCBmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB4U2NhbGUobWluX3gpO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAuYXR0cihcInkxXCIsIGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHhTY2FsZShtaW5feCk7XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgIC5hdHRyKFwieDJcIiwgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgICByZXR1cm4geFNjYWxlKG1heF94KTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoXCJ5MlwiLCBmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB5U2NhbGUobWF4X3gpO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAuYXR0cihcInN0cm9rZS13aWR0aFwiLCAyKVxuICAgICAgICAuYXR0cihcInN0cm9rZVwiLCBcImJsYWNrXCIpO1xuICAgIH1cbiAgICAvLyAgZDMuc2VsZWN0KFwiI05BY291bnRcIikudGV4dChcIlRoZXJlIGFyZSBcIiArIG5hbkNvdW50ICsgXCIgbnVtYmVyIG9mIE5BIHZhbHVlcyBpbiB0aGUgcmVsYXRpb24uXCIpO1xufVxuXG4vKiogbmVlZHMgZG9jICovXG5leHBvcnQgZnVuY3Rpb24gc2V0eFRhYmxlKGZlYXR1cmVzKSB7XG4gICAgZnVuY3Rpb24gdGFidWxhdGUoZGF0YSwgY29sdW1ucykge1xuICAgICAgICB2YXIgdGFibGUgPSBkMy5zZWxlY3QoJyNzZXR4TGVmdEJvdHRvbUxlZnQnKS5hcHBlbmQoJ3RhYmxlJyk7XG4gICAgICAgIHZhciB0aGVhZCA9IHRhYmxlLmFwcGVuZCgndGhlYWQnKTtcbiAgICAgICAgdmFyXHR0Ym9keSA9IHRhYmxlLmFwcGVuZCgndGJvZHknKTtcblxuICAgICAgICAvLyBhcHBlbmQgdGhlIGhlYWRlciByb3dcbiAgICAgICAgdGhlYWQuYXBwZW5kKCd0cicpXG4gICAgICAgIC5zZWxlY3RBbGwoJ3RoJylcbiAgICAgICAgLmRhdGEoY29sdW1ucykuZW50ZXIoKVxuICAgICAgICAuYXBwZW5kKCd0aCcpXG4gICAgICAgIC50ZXh0KGZ1bmN0aW9uIChjb2x1bW4pIHsgcmV0dXJuIGNvbHVtbjsgfSk7XG5cbiAgICAgICAgLy8gY3JlYXRlIGEgcm93IGZvciBlYWNoIG9iamVjdCBpbiB0aGUgZGF0YVxuICAgICAgICB2YXIgcm93cyA9IHRib2R5LnNlbGVjdEFsbCgndHInKVxuICAgICAgICAuZGF0YShkYXRhKVxuICAgICAgICAuZW50ZXIoKVxuICAgICAgICAuYXBwZW5kKCd0cicpO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBhIGNlbGwgaW4gZWFjaCByb3cgZm9yIGVhY2ggY29sdW1uXG4gICAgICAgIHZhciBjZWxscyA9IHJvd3Muc2VsZWN0QWxsKCd0ZCcpXG4gICAgICAgICAgICAuZGF0YShmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbHVtbnMubWFwKGZ1bmN0aW9uIChjb2x1bW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtjb2x1bW46IGNvbHVtbiwgdmFsdWU6IHJvd1tjb2x1bW5dfTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZW50ZXIoKVxuICAgICAgICAgICAgLmFwcGVuZCgndGQnKVxuICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQudmFsdWU7IH0pXG4gICAgICAgICAgICAuYXR0cignaWQnLGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgIGxldCByb3duYW1lID0gdGhpcy5wYXJlbnRFbGVtZW50LmZpcnN0Q2hpbGQuaW5uZXJUZXh0O1xuICAgICAgICAgICAgICAgIHJldHVybiByb3duYW1lICsgZC5jb2x1bW47XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGFibGU7XG4gICAgfVxuXG4gICAgbGV0IG15ZGF0YSA9IFtdO1xuICAgIGZvcihsZXQgaSA9IDA7IGk8ZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG15aSA9IGZpbmROb2RlSW5kZXgoZmVhdHVyZXNbaV0pOyAvL2krMTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgd2FzIHNldCBhcyAoaSsxKSwgYnV0IHNob3VsZCBiZSBhbGxub2RlcyBwb3NpdGlvbiwgbm90IGZlYXR1cmVzIHBvc2l0aW9uXG5cbiAgICAgICAgaWYoYWxsTm9kZXNbbXlpXS52YWxpZD09MCkge1xuICAgICAgICAgICAgeHZhbD0wO1xuICAgICAgICAgICAgeDF2YWw9MDtcbiAgICAgICAgICAgIG15ZGF0YS5wdXNoKHtcIlZhcmlhYmxlc1wiOmZlYXR1cmVzW2ldLFwiRnJvbVwiOnh2YWwsIFwiVG9cIjp4MXZhbH0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbXlzdmcgPSBmZWF0dXJlc1tpXStcIl9zZXR4TGVmdF9cIitteWk7XG4gICAgICAgIC8vY29uc29sZS5sb2cobXlzdmcpO1xuICAgICAgICBsZXQgeHZhbCA9IGJ5SWQobXlzdmcpLnF1ZXJ5U2VsZWN0b3IoJy54dmFsJykuaW5uZXJIVE1MO1xuICAgICAgICBsZXQgeDF2YWwgPSBieUlkKG15c3ZnKS5xdWVyeVNlbGVjdG9yKCcueDF2YWwnKS5pbm5lckhUTUw7XG4gICAgICAgIHh2YWwgPSB4dmFsLnNwbGl0KFwieDogXCIpLnBvcCgpO1xuICAgICAgICB4MXZhbCA9IHgxdmFsLnNwbGl0KFwieDE6IFwiKS5wb3AoKTtcblxuICAgICAgICBteWRhdGEucHVzaCh7XCJWYXJpYWJsZXNcIjpmZWF0dXJlc1tpXSxcIkZyb21cIjp4dmFsLCBcIlRvXCI6eDF2YWx9KTtcbiAgICB9XG5cbiAgICAvLyByZW5kZXIgdGhlIHRhYmxlKHMpXG4gICAgdGFidWxhdGUobXlkYXRhLCBbJ1ZhcmlhYmxlcycsICdGcm9tJywgJ1RvJ10pOyAvLyAyIGNvbHVtbiB0YWJsZVxufVxuXG4vKipcbiAgcnBjIEV4cG9ydFBpcGVsaW5lKFBpcGVsaW5lRXhwb3J0UmVxdWVzdCkgcmV0dXJucyAoUmVzcG9uc2UpIHt9XG4qL1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZXhwb3J0cGlwZWxpbmUocGlwZWxpbmVJZCkge1xuICAgIGxldCB0ZW1wID0ge3BpcGVsaW5lSWQsIGNvbnRleHQ6IGFwaVNlc3Npb24oenBhcmFtcy56c2Vzc2lvbmlkKSwgcGlwZWxpbmVFeGVjVXJpOiAnPDxFWEVDVVRBQkxFX1VSST4+J307XG5cbiAgICBsZXQgcmVzID0gYXdhaXQgbWFrZVJlcXVlc3QoXG4gICAgICAgIEQzTV9TVkNfVVJMICsgJy9leHBvcnRwaXBlbGluZScsXG4gICAgICAgIHtwaXBlbGluZUlkLCBjb250ZXh0OiBhcGlTZXNzaW9uKHpwYXJhbXMuenNlc3Npb25pZCksIHBpcGVsaW5lRXhlY1VyaTogJzw8RVhFQ1VUQUJMRV9VUkk+Pid9KTtcblxuICAgIC8vIHdlIG5lZWQgc3RhbmRhcmRpemVkIHN0YXR1cyBtZXNzYWdlcy4uLlxuICAgIGxldCBteXN0YXR1cyA9IHJlcy5zdGF0dXM7XG4gICAgaWYgKHR5cGVvZiBteXN0YXR1cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZihteXN0YXR1cy5jb2RlPT1cIkZBSUxFRF9QUkVDT05ESVRJT05cIikge1xuICAgICAgICBhbGVydChcIlRBMiBoYXMgbm90IHdyaXR0ZW4gdGhlIGV4ZWN1dGFibGUuXCIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coYEV4ZWN1dGFibGUgZm9yICR7cGlwZWxpbmVJZH0gaGFzIGJlZW4gd3JpdHRlbmApO1xuICAgIH19XG4gICAgcmV0dXJuIHJlcztcbn1cblxuLyoqIG5lZWRzIGRvYyAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlbGV0ZXBpcGVsaW5lKCkge1xuICAgIGNvbnNvbGUubG9nKFwiREVMRVRFIENBTExFRFwiKTtcbn1cblxuLyoqXG4gICBEM00gQVBJIEhFTFBFUlNcbiAgIGJlY2F1c2UgdGhlc2UgZ2V0IGJ1aWx0IGluIHZhcmlvdXMgcGxhY2VzLCBwdWxsaW5nIHRoZW0gb3V0IGZvciBlYXN5IG1hbmlwdWxhdGlvblxuKi9cbmZ1bmN0aW9uIGFwaUZlYXR1cmUgKHZhcnMsIHVyaSkge1xuICAgIGxldCBvdXQgPSBbXTtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgdmFycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBvdXQucHVzaCh7ZmVhdHVyZUlkOnZhcnNbaV0sZGF0YVVyaTp1cml9KTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqIG5lZWRzIGRvYyAqL1xuZnVuY3Rpb24gYXBpRmVhdHVyZVNob3J0UGF0aCAodmFycywgdXJpKSB7XG4gICAgbGV0IG91dCA9IFtdO1xuICAgIGxldCBzaG9ydFVyaSA9IHVyaS5zdWJzdHJpbmcoMCwgdXJpLmxhc3RJbmRleE9mKFwiL1wiKSk7XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IHZhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgb3V0LnB1c2goe2ZlYXR1cmVJZDp2YXJzW2ldLGRhdGFVcmk6c2hvcnRVcml9KTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gICBzaWxseSBidXQgcGVyaGFwcyB1c2VmdWwgaWYgaW4gdGhlIGZ1dHVyZSBTZXNzaW9uQ29udGV4dCByZXF1aXJlcyBtb3JlIHRoaW5ncyAoYXMgc3VnZ2VzdCBieSBjb3JlKVxuKi9cbmZ1bmN0aW9uIGFwaVNlc3Npb24oY29udGV4dCkge1xuICAgIHJldHVybiB7c2Vzc2lvbl9pZDogY29udGV4dH07XG59XG5cblxuLyoqXG4gKiAgU2VuZCBhIHN0YXR1cyBtZXNzYWdlIHRvIHRoZSBUQTMgY29uc29sZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdGEzX3NlYXJjaF9tZXNzYWdlKHVzZXJfbXNnKXtcblxuICBsZXQgdGEzX3NlYXJjaF9tZXNzYWdlID0geydtZXNzYWdlJzogdXNlcl9tc2d9XG5cbiAgY29uc3QgZW5kX3NlYXJjaF91cmwgPSAndGEzLXNlYXJjaC9zZW5kLXJldmlld2VyLW1lc3NhZ2UnO1xuXG4gIHRyeSB7XG4gICAgICBsZXQgcmVzID0gbS5yZXF1ZXN0KGVuZF9zZWFyY2hfdXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB7bWV0aG9kOiAnUE9TVCcsIGRhdGE6IHRhM19zZWFyY2hfbWVzc2FnZX0pO1xuICAgICAgY29uc29sZS5sb2coJ3RhM19zZWFyY2hfbWVzc2FnZSBzdWNjZWVkZWQ6JyArIHJlcyk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5sb2coJ3RhM19zZWFyY2hfbWVzc2FnZSBmYWlsZWQ6ICcgKyBlcnIpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0ZXN0X21zZ190YTNfc2VhcmNoKCl7XG4gIC8vZW5kX3RhM19zZWFyY2godHJ1ZSwgJ2l0IHdvcmtlZCEnKTtcbiAgLy9lbmRfdGEzX3NlYXJjaChmYWxzZSwgJ2l0IGZhaWxlZCEnKTtcbiAgLy90YTNfc2VhcmNoX21lc3NhZ2UoJ2p1c3Qgc2VuZGluZyBhIG1lc3NhZ2UhJyk7XG59XG5cbi8qKlxuICogIEVuZCB0aGUgVEEzIHNlYXJjaC4gIFRoaXMgc2VuZHMgYSBtZXNzYWdlXG4gKiAgdG8gdGhlIHRhM19zZWFyY2ggY29uc29sZSBhcyB3ZWxsIGFzIG1lc3NhZ2VcbiAqICBmb3IgdGhlIGNvbnNvbGUgdG8gZXhpdCB3aXRoIGE6XG4gKiAgLSByZXR1cm4gY29kZSAwIGZvciBzdWNjZXNzXG4gKiAgLSByZXR1cm4gY29kZSAtMSBmb3IgZmFpbHVyZVxuICpcbiAqICA+IGlzX3N1Y2Nlc3MgLSBib29sZWFuXG4gKiAgPiB1c2VyX21zZyAtIHN0cmluZyBzZW50IHRvIHRoZSBjb25zb2xlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmRfdGEzX3NlYXJjaChpc19zdWNjZXNzLCB1c2VyX21zZyl7XG5cbiAgbGV0IGVuZF9zZWFyY2hfbXNnID0geydpc19zdWNjZXNzJzogaXNfc3VjY2VzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtZXNzYWdlJzogdXNlcl9tc2d9XG5cbiAgY29uc3QgZW5kX3NlYXJjaF91cmwgPSAndGEzLXNlYXJjaC9lbmQtc2VhcmNoJztcblxuICB0cnkge1xuICAgICAgbGV0IHJlcyA9IG0ucmVxdWVzdChlbmRfc2VhcmNoX3VybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAge21ldGhvZDogJ1BPU1QnLCBkYXRhOiBlbmRfc2VhcmNoX21zZ30pO1xuICAgICAgY29uc29sZS5sb2coJ2VuZF90YTNfc2VhcmNoIHN1Y2NlZWRlZDonICsgcmVzKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmxvZygnZW5kX3RhM19zZWFyY2ggZmFpbGVkOiAnICsgZXJyKTtcbiAgfVxuXG59XG5cbi8qKlxuICogIHJlY29yZCB1c2VyIG1ldGFkYXRhXG4gKi9cbmxldCByZWNvcmRlcl9jbnQgPSAwO1xuY29uc3Qgc2F2ZV93b3Jrc3BhY2VfdXJsID0gJy93b3Jrc3BhY2VzL3JlY29yZC11c2VyLXdvcmtzcGFjZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiByZWNvcmRfdXNlcl9tZXRhZGF0YSgpe1xuXG4gIC8vIHR1cm5pbmcgb2ZmIGZvciBub3dcbiAgcmV0dXJuO1xuXG4gIC8vICgxKSBTZXQgZG9tYWluIGlkZW50aWZpZXI6IGRpZmZlcnMgZm9yIEQzTSwgRGF0YXZlcnNlLCBldGNcbiAgLy9cbiAgdmFyIGRvbWFpbl9pZGVudGlmaWVyID0gJ3Vua25vd24hJztcbiAgaWYgKElTX0QzTV9ET01BSU4peyAvLyBkb21haW4gc3BlY2lmaWMgaWRlbnRpZmllclxuICAgIGRvbWFpbl9pZGVudGlmaWVyID0gZG9tYWluSWRlbnRpZmllcjtcbiAgfS8qZWxzZSBpZiAoSVNfREFUQVZFUlNFX0RPTUFJTil7XG4gICAgZG9tYWluX2lkZW50aWZpZXIgPSAnVE9ETzogRFYgSURFTlRJRklFUic7XG4gIH1lbHNlIGlmIChJU19FVkVOVERBVEFfRE9NQUlOKXtcbiAgICBkb21haW5faWRlbnRpZmllciA9ICdUT0RPOiBFVkVOVERBVEEgSURFTlRJRklFUic7XG4gIH0qL1xuXG4gIGlmICh6cGFyYW1zID09IG51bGwpe1xuICAgIGNvbnNvbGUubG9nKCdObyB3b3Jrc3BhY2UgcmVjb3JkaW5nLiB6cGFyYW1zIG5vdCBkZWZpbmVkJyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChhbGxOb2RlcyA9PSBudWxsKXtcbiAgICBjb25zb2xlLmxvZygnTm8gd29ya3NwYWNlIHJlY29yZGluZy4genBhcmFtcyBub3QgZGVmaW5lZCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vICgyKSBGb3JtYXQgd29ya3NwYWNlIGRhdGFcbiAgLy9cbiAgbGV0IHdvcmtzcGFjZV9kYXRhID0geydhcHBfZG9tYWluJzogQVBQX0RPTUFJTixcbiAgICAgICAgICAgICAgICAgICAgICAgICdkb21haW5faWRlbnRpZmllcic6IGRvbWFpbl9pZGVudGlmaWVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2FsbG5vZGVzJzogYWxsTm9kZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAnenBhcmFtcyc6IHpwYXJhbXN9XG5cbiAgICAgICAgLy9jb25zb2xlLmxvZygnd29ya3NwYWNlX2RhdGE6ICcgKyB3b3Jrc3BhY2VfZGF0YSk7XG5cbiAgICAgIC8vICgzKSBTYXZlIHdvcmtzcGFjZSBkYXRhXG4gICAgICAvL1xuICAgICAgdHJ5IHtcbiAgICAgICAgICBsZXQgcmVzID0gbS5yZXF1ZXN0KHNhdmVfd29ya3NwYWNlX3VybCwge21ldGhvZDogJ1BPU1QnLCBkYXRhOiB3b3Jrc3BhY2VfZGF0YX0pO1xuICAgICAgICAgIHJlY29yZGVyX2NudCsrO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdTZXNzaW9uIHJlY29yZGVkOiAoY250OiAnICsgcmVjb3JkZXJfY250ICsgJykgJyArIHJlcyk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygncmVjb3JkX3VzZXJfbWV0YWRhdGEgZmFpbGVkOiAnICsgZXJyKTtcbiAgICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNob3dQcmVkUGxvdCAoYnRuKSB7XG4gICAgaWYoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzZXR4TGVmdEdlblwiKS5zdHlsZS5kaXNwbGF5PT1cIm5vbmVcIilcbiAgICAgICAgcmV0dXJuO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2V0eExlZnRQbG90XCIpLnN0eWxlLmRpc3BsYXk9XCJibG9ja1wiO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2V0eExlZnRHZW5cIikuc3R5bGUuZGlzcGxheT1cIm5vbmVcIjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNob3dHZW5QcmVkcyAoYnRuKSB7XG4gICAgaWYoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzZXR4TGVmdFBsb3RcIikuc3R5bGUuZGlzcGxheT09XCJub25lXCIpXG4gICAgICAgIHJldHVybjtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNldHhMZWZ0UGxvdFwiKS5zdHlsZS5kaXNwbGF5PVwibm9uZVwiO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2V0eExlZnRHZW5cIikuc3R5bGUuZGlzcGxheT1cImJsb2NrXCI7XG59XG5cbmZ1bmN0aW9uIHNpbmdsZVBsb3QocHJlZCkge1xuICAgIGQzLnNlbGVjdCgnI3NldHhMZWZ0VG9wUmlnaHQnKS5zZWxlY3RBbGwoJ3N2ZycpLnJlbW92ZSgpO1xuICAgIGxldCBpID0gZmluZE5vZGVJbmRleChwcmVkKTtcbiAgICBsZXQgbm9kZSA9IGFsbE5vZGVzW2ldO1xuICAgIG5vZGUuc2V0eHBsb3QgPSBmYWxzZTtcbiAgICAgICAgbm9kZS5zdWJzZXRwbG90ID0gZmFsc2U7XG4gICAgICAgIGlmIChub2RlLnBsb3R0eXBlID09PSBcImNvbnRpbnVvdXNcIiAmIG5vZGUuc2V0eHBsb3QgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG5vZGUuc2V0eHBsb3QgPSB0cnVlO1xuICAgICAgICAgICAgZGVuc2l0eShub2RlLCBkaXYgPSBcInNldHhMZWZ0VG9wUmlnaHRcIiwgcHJpdik7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS5wbG90dHlwZSA9PT0gXCJiYXJcIiAmIG5vZGUuc2V0eHBsb3QgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG5vZGUuc2V0eHBsb3QgPSB0cnVlO1xuICAgICAgICAgICAgYmFycyhub2RlLCBkaXYgPSBcInNldHhMZWZ0VG9wUmlnaHRcIiwgcHJpdik7XG4gICAgICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpc2NvdmVyeShwcmVwcm9jZXNzX2ZpbGUpIHtcblxuICAgIGNvbnNvbGUubG9nKFwiZW50ZXJpbmcgZGlzY29cIik7XG4gICAgbGV0IGV4dHJhY3QgPSBwcmVwcm9jZXNzX2ZpbGUuZGF0YXNldC5kaXNjb3Zlcnk7XG4gICAgY29uc29sZS5sb2coZXh0cmFjdCk7XG4gICAgbGV0IGRpc2NvID0gW107XG4gICAgbGV0IG5hbWVzID0gW107XG4gICAgbGV0IHZhcnMgPSBPYmplY3Qua2V5cyhwcmVwcm9jZXNzKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV4dHJhY3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbmFtZXNbaV0gPSBcIlByb2JsZW1cIiArIChpICsgMSk7XG4gICAgICAgIGxldCBjdXJyZW50X3RhcmdldCA9IGV4dHJhY3RbaV1bXCJ0YXJnZXRcIl07XG4gICAgICAgIGxldCBqID0gZmluZE5vZGVJbmRleChjdXJyZW50X3RhcmdldCk7XG4gICAgICAgIGxldCBub2RlID0gYWxsTm9kZXNbal07XG4gICAgICAgIGxldCBjdXJyZW50X3ByZWRpY3RvcnMgPSBleHRyYWN0W2ldW1wicHJlZGljdG9yc1wiXTtcbiAgICAgICAgbGV0IGN1cnJlbnRfdGFzayA9IG5vZGUucGxvdHR5cGUgPT09IFwiYmFyXCIgPyAnY2xhc3NpZmljYXRpb24nIDogJ3JlZ3Jlc3Npb24nO1xuICAgICAgICBsZXQgY3VycmVudF9yYXRpbmcgPSAzO1xuICAgICAgICBsZXQgY3VycmVudF9kZXNjcmlwdGlvbiA9IGN1cnJlbnRfdGFyZ2V0ICsgXCIgaXMgcHJlZGljdGVkIGJ5IFwiICsgY3VycmVudF9wcmVkaWN0b3JzLmpvaW4oXCIgYW5kIFwiKTtcbiAgICAgICAgbGV0IGN1cnJlbnRfbWV0cmljID0gbm9kZS5wbG90dHlwZSA9PT0gXCJiYXJcIiA/ICdmMU1hY3JvJyA6ICdtZWFuU3F1YXJlZEVycm9yJztcbiAgICAgICAgbGV0IGN1cnJlbnRfZGlzY28gPSB7dGFyZ2V0OiBjdXJyZW50X3RhcmdldCwgcHJlZGljdG9yczogY3VycmVudF9wcmVkaWN0b3JzLCB0YXNrOiBjdXJyZW50X3Rhc2ssIHJhdGluZzogY3VycmVudF9yYXRpbmcsIGRlc2NyaXB0aW9uOiBjdXJyZW50X2Rlc2NyaXB0aW9uLCBtZXRyaWM6IGN1cnJlbnRfbWV0cmljfTtcbiAgICAgICAgLy9qUXVlcnkuZXh0ZW5kKHRydWUsIGN1cnJlbnRfZGlzY28sIG5hbWVzKTtcbiAgICAgICAgZGlzY29baV0gPSBjdXJyZW50X2Rpc2NvO1xuICAgIH07XG4gICAgLyogUHJvYmxlbSBBcnJheSBvZiB0aGUgRm9ybTpcbiAgICAgICAgWzE6IHt0YXJnZXQ6XCJIb21lX3J1bnNcIixcbiAgICAgICAgICAgIHByZWRpY3RvcnM6W1wiV2Fsa3NcIixcIlJCSXNcIl0sXG4gICAgICAgICAgICB0YXNrOlwicmVncmVzc2lvblwiLFxuICAgICAgICAgICAgcmF0aW5nOjUsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJIb21lX3J1bnMgaXMgcHJlZGljdGVkIGJ5IFdhbGtzIGFuZCBSQklzXCIsXG4gICAgICAgICAgICBtZXRyaWM6IFwibWVhblNxdWFyZWRFcnJvclwiXG4gICAgICAgIH0sMjp7Li4ufV1cbiAgICAqL1xuICAgIHJldHVybiBkaXNjbztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByb2JEaXNjVmlldyhidG4pIHtcbiAgICB0YWJMZWZ0KGJ0bik7XG4gICAgY29uc29sZS5sb2coZGlzY28pO1xuXG4gICAgaWYoYnRuPT0ndGFiMScpIHtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJsZWZ0cGFuZWxcIikuY2xhc3NMaXN0LnJlbW92ZShcImV4cGFuZHBhbmVsZnVsbFwiKTtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJidG5TZWxlY3RcIikuc3R5bGUuZGlzcGxheT1cIm5vbmVcIjtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ0YWIyYVwiKS5zdHlsZS5kaXNwbGF5PVwibm9uZVwiO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibGVmdHBhbmVsXCIpLmNsYXNzTGlzdC50b2dnbGUoXCJleHBhbmRwYW5lbGZ1bGxcIik7XG4gICAgaWYoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJidG5TZWxlY3RcIikuc3R5bGUuZGlzcGxheT09XCJub25lXCIpe1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImJ0blNlbGVjdFwiKS5zdHlsZS5kaXNwbGF5PVwiYmxvY2tcIjtcbiAgICB9XG5cbiAgICBpZihkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImxlZnRwYW5lbFwiKS5jbGFzc0xpc3QuY29udGFpbnMoXCJleHBhbmRwYW5lbGZ1bGxcIikpIHtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ0YWIyYVwiKS5zdHlsZS5kaXNwbGF5PVwiYmxvY2tcIjtcbiAgICB9XG5cbiAgICBpZihkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInRhYjJcIikuaGFzQ2hpbGROb2RlcygpKSByZXR1cm47IC8vIHJldHVybiBpZiB0aGlzIGhhcyBhbHJlYWR5IGJlZW4gY2xpY2tlZCwgaWYgY2hpbGROb2RlcyBoYXZlIGFscmVhZHkgYmVlbiBhZGRlZFxuXG4gICAgbGV0IG15cHJvYnMgPSBkaXNjbzsgIC8vIGRpc2NvdmVyeSgpOyAgRnVuY3Rpb24gcmVxdWlyZXMgYXJndW1lbnQuICBEb24ndCBwcmVzZW50bHkgbmVlZCB0byBjYWxsIGZ1bmN0aW9uIGFnYWluLlxuICAgIGxldCBwcm9idGFibGUgPSBbXTtcbiAgICBmb3IobGV0IGkgPSAwOyBpPG15cHJvYnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG15cHJlZGljdG9ycyA9IG15cHJvYnNbaV0ucHJlZGljdG9ycy5qb2luKCk7XG4gICAgICAgIHByb2J0YWJsZS5wdXNoKHtcIlRhcmdldFwiOm15cHJvYnNbaV0udGFyZ2V0LFwiUHJlZGljdG9yc1wiOm15cHJlZGljdG9ycywgXCJUYXNrXCI6bXlwcm9ic1tpXS50YXNrLCBcIk1ldHJpY1wiOm15cHJvYnNbaV0ubWV0cmljfSk7XG4gICAgfVxuICAgIHRhYnVsYXRlKHByb2J0YWJsZSwgWydUYXJnZXQnLCAnUHJlZGljdG9ycycsICdUYXNrJywnTWV0cmljJ10sICcjdGFiMicpO1xuXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ0YWIyaW5wdXRcIikudmFsdWU9bXlwcm9ic1swXS5kZXNjcmlwdGlvbjtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHN1Ym1pdERpc2NQcm9iKGJ0bikge1xuXG4gICAgbGV0IHRhYmxlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ0YWIyXCIpLmdldEVsZW1lbnRzQnlUYWdOYW1lKCd0YWJsZScpWzBdO1xuICAgIGNvbnNvbGUubG9nKHRhYmxlKTtcbiAgICBsZXQgY2hlY2tlZCA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDEsIHJvdzsgcm93ID0gdGFibGUucm93c1tpXTsgaSsrKSB7IC8vc2tpcHBpbmcgdGhlIGhlYWRlclxuICAgICAgICBjaGVja2VkLnB1c2gocm93LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaW5wdXRcIilbMF0uY2hlY2tlZCk7IC8vIGJvb2xlYW4gYXJyYXlcbiAgICB9XG5cbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgZGlzY28ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYoIWNoZWNrZWRbaV0pIGNvbnRpbnVlO1xuICAgICAgICAvL2NyZWF0ZXBpcGVsaW5lIGNhbGxcbiAgICAgICAgY29uc29sZS5sb2coZGlzY28pO1xuICAgICAgICBsZXQgYXV4ID0ge1widGFza1wiOmQzbVRhc2tUeXBlW2Rpc2NvW2ldLnRhc2tdWzFdLCBcIm1ldHJpY3NcIjpkM21NZXRyaWNzW2Rpc2NvW2ldLm1ldHJpY11bMV0sIFwiZGVzY3JpcHRpb25cIjpkaXNjb1tpXS5kZXNjcmlwdGlvbn07XG4gICAgICAgIGNvbnNvbGUubG9nKGF1eCk7XG4gICAgICAgIC8vIFZKRDogdGhpcyBpcyB0aGUgY29kZSB0byBhc2sgVEEyIGZvciBhIHNpbmdsZSBwaXBlbGluZSwgdG8gY2hlY2sgdmlhYmlsaXR5LiBIb3dldmVyLCBUQTJzIG1pZ2h0IG5vdCBhY3R1YWxseSBoYW5kbGUgJ21heHBpcGVsaW5lcycsIG1ha2luZyB0aGlzIHRha2UgYSB2ZXJ5IGxvbmcgdGltZSB0byBydW4uIEJ5cGFzc2luZyB0aGlzIGZvciBub3dcbiAgICAgIC8vICBsZXQgcmVzID0gYXdhaXQgbWFrZVJlcXVlc3QoRDNNX1NWQ19VUkwgKyAnL0NyZWF0ZVBpcGVsaW5lcycsIENyZWF0ZVBpcGVsaW5lRGF0YShkaXNjb1tpXS5wcmVkaWN0b3JzLCBbZGlzY29baV0udGFyZ2V0XSwgYXV4KSk7IC8vIGNyZWF0aW5nIGEgc2luZ2xlIHBpcGVsaW5lIGZvciBhIGRpc2NvdmVyZWQgcHJvYmxlbSwgdG8gY2hlY2sgdmlhYmlsaXR5XG4gICAgICAvLyAgaWYocmVzKSB7IC8vIGhhdmUgdG8gY2hlY2sgaWYgdGhlIHJlc3BvbnNlIHdlbnQgdGhyb3VnaCBvaywgdGhpcyBqdXN0IGNoZWNrcyBpZiByZXMgZXhpc3RzXG4gICAgICAgICAgICBsZXQgcmVzID0gYXdhaXQgbWFrZVJlcXVlc3QoRDNNX1NWQ19VUkwgKyAnL3dyaXRlLXVzZXItcHJvYmxlbScsIENyZWF0ZVBpcGVsaW5lRGF0YShkaXNjb1tpXS5wcmVkaWN0b3JzLCBbZGlzY29baV0udGFyZ2V0XSwgYXV4KSk7XG4gICAgICAvLyAgfVxuICAgIH1cblxuICAgIC8vIGNoYW5nZSBzdGF0dXMgb2YgYnV0dG9ucyBmb3IgZXN0aW1hdGluZyBwcm9ibGVtIGFuZCBtYXJraW5nIHByb2JsZW0gYXMgZmluaXNoZWRcbiAgICAkKFwiI2J0blNlbGVjdFwiKS5yZW1vdmVDbGFzcyhcImJ0bi1zdWNjZXNzXCIpO1xuICAgICQoXCIjYnRuU2VsZWN0XCIpLmFkZENsYXNzKFwiYnRuLWRlZmF1bHRcIik7XG4gICAgJChcIiNidG5TdWJzZXRcIikucmVtb3ZlQ2xhc3MoXCJidG4tc3VjY2Vzc1wiKTtcbiAgICAkKFwiI2J0blN1YnNldFwiKS5hZGRDbGFzcyhcImJ0bi1kZWZhdWx0XCIpO1xuICAgIHRhc2sxX2ZpbmlzaGVkID0gdHJ1ZTtcbiAgICBpZighKHRhc2syX2ZpbmlzaGVkKSl7XG4gICAgICAgICQoXCIjYnRuRXN0aW1hdGVcIikucmVtb3ZlQ2xhc3MoXCJidG4tZGVmYXVsdFwiKTtcbiAgICAgICAgJChcIiNidG5Fc3RpbWF0ZVwiKS5hZGRDbGFzcyhcImJ0bi1zdWNjZXNzXCIpO1xuICAgIH07XG5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNhdmVEaXNjKGJ0bikge1xuICAgIGxldCB0YWJsZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidGFiMlwiKS5nZXRFbGVtZW50c0J5VGFnTmFtZSgndGFibGUnKVswXTtcbiAgICBsZXQgbmV3dGV4dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidGFiMmlucHV0XCIpLnZhbHVlO1xuICAgIGZvciAobGV0IGkgPSAxLCByb3c7IHJvdyA9IHRhYmxlLnJvd3NbaV07IGkrKykgeyAvL3NraXBwaW5nIHRoZSBoZWFkZXJcbiAgICAgICAgaWYocm93LmNsYXNzTmFtZT09J2l0ZW0tc2VsZWN0Jyl7XG4gICAgICAgICAgICBkaXNjb1tpLTFdLmRlc2NyaXB0aW9uPW5ld3RleHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Fzc2V0cy9hcHAvYXBwLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1\n')},function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();\n\nexports.density = density;\nexports.bars = bars;\nexports.barsSubset = barsSubset;\nexports.densityNode = densityNode;\nexports.barsNode = barsNode;\nvar d3Color = \'#1f77b4\'; // d3\'s default blue\nvar selVarColor = exports.selVarColor = \'#fa8072\'; // d3.rgb("salmon");\n\n// function to use d3 to graph density plots with preprocessed data\nfunction density(node, div, priv) {\n    div = { subset: \'#tab2\', setxLeft: \'#setxLeft\', setxLeftTopRight: \'#setxLeftTopRight\', varSummary: \'#tab3\' }[div];\n    if (!div) return alert("Error: incorrect div selected for plots");\n\n    var _ref = [node.plotx, node.ploty],\n        xVals = _ref[0],\n        yVals = _ref[1];\n\n    if (priv && node.plotCI) {\n        var _map = [\'upperBound\', \'lowerBound\'].map(function (bound) {\n            return xVals.map(function (x, i) {\n                return { x: +x, y: +node.plotCI[bound][i] };\n            });\n        }),\n            _map2 = _slicedToArray(_map, 2),\n            _upperError = _map2[0],\n            _lowerError = _map2[1];\n\n        console.log(\'upperError\\n\', _upperError);\n    }\n\n    var tempWidth = d3.select(div).style("width");\n    var width = tempWidth.substring(0, tempWidth.length - 2);\n\n    var tw = document.getElementById(\'main\').offsetWidth;\n\n    var tempHeight = d3.select(div).style("height");\n    var height = tempHeight.substring(0, tempHeight.length - 2);\n    var margin = {\n        top: 20,\n        right: 20,\n        bottom: 53,\n        left: 10\n    };\n\n    // Need to fix automatic width and height settings for leftpanel (#tab2, #tab3)\n    if (div == "#tab3") {\n        width = 0.7 * (width - margin.left - margin.right), height = 0.3 * (height - margin.top - margin.bottom);\n    } else if (div == "#tab2") {\n        width = 200;\n        height = 120;\n    } else if (div == "#setxLeft" || div == "#setxLeftTopRight") {\n        width = tw * .185 - margin.left - margin.right; //rightpanel.expand is 40 percent, setxLeft to 50 percent, toggle bar is 16px, padding, it\'s all about .185\n        height = width * .6; //height to width is .6\n    } else {\n        width = 0.35 * (width - margin.left - margin.right), height = 0.25 * (height - margin.top - margin.bottom);\n    };\n\n    var x = d3.scale.linear().domain([d3.min(xVals), d3.max(xVals)]).range([0, width]);\n    var invx = d3.scale.linear().range([d3.min(xVals), d3.max(xVals)]).domain([0, width]);\n    var y = d3.scale.linear().domain([d3.min(yVals), d3.max(yVals)]).range([height, 0]);\n    var xAxis = d3.svg.axis().scale(x).ticks(5).orient("bottom");\n    var yAxis = d3.svg.axis().scale(y).orient("left");\n    var brush = d3.svg.brush().x(x).extent(node.subsetrange).on("brush", brushed);\n    var brush2 = d3.svg.brush().x(x).on("brush", brushed2);\n    var area = d3.svg.area().interpolate("monotone").x(function (d) {\n        return x(d.x);\n    }).y0(height).y1(function (d) {\n        return y(d.y);\n    });\n    var line = d3.svg.line().x(function (d) {\n        return x(d.x);\n    }).y(function (d) {\n        return y(d.y);\n    }).interpolate("monotone");\n\n    // cumbersome to treat "tab3" differently, but works for now\n    // tab3, has an issue, that unless width height hardcoded, they grow with each additional graph.\n    if (div == "#tab3") {\n        var plotsvg = d3.select(div).selectAll("svg").remove();\n        plotsvg = d3.select(div).append("svg").attr("id", function () {\n            return node.name.toString().concat(div.substr(1));\n        }).style("width", 300) // set height to the height of #main.left\n        .style("height", 200).append("g").attr("transform", \'translate(\' + margin.left + \',\' + margin.top + \')\');\n    } else {\n        var plotsvg = d3.select(div).append("svg").attr("id", function () {\n            return node.name.toString().replace(/\\(|\\)/g, "").concat("_", div.substr(1), "_", node.id);\n        }).style("width", width + margin.left + margin.right) //setting height to the height of #main.left\n        .style("height", height + margin.top + margin.bottom).append("g").attr("transform", \'translate(\' + margin.left + \',\' + margin.top + \')\');\n    };\n    plotsvg.append("path").datum(xVals.map(function (x, i) {\n        return { x: +x, y: +node.ploty[i] };\n    })).attr("class", "area").attr("d", area);\n\n    //add upper bound\n    priv && node.plotCI && plotsvg.append("path").attr("class", "upperError").datum(upperError).attr("d", area);\n\n    //add lower bound\n    priv && node.plotCI && plotsvg.append("path").attr("class", "lowerError").datum(lowerError).attr("d", area);\n\n    plotsvg.append("g").attr("class", "x axis").attr("transform", "translate(0," + height + ")").call(xAxis);\n\n    plotsvg.append("text").attr("x", width / 2).attr("y", 0 - margin.top / 2).attr("text-anchor", "middle").style("font-size", "12px").text(node.name);\n\n    // add brush if subset\n    if (div == "#tab2") {\n        plotsvg.append("text").attr("id", "range").attr("x", 25).attr("y", height + 40).text(function () {\n            return "Range: ".concat(d3.min(xVals).toPrecision(4), " to ", d3.max(xVals).toPrecision(4));\n        });\n        plotsvg.append("g").attr("class", "x brush").call(brush).selectAll("rect").attr("height", height);\n    }\n\n    // add z lines and sliders setx\n    if (div == "#setxLeft" || div == "#setxLeftTopRight") {\n        plotsvg.append("text").attr("id", "range") // this is bad practice, id is not unique\n        .attr(\'class\', \'xval\').attr("x", 25).attr("y", height + 40).text(function () {\n            return "x: ".concat((+node.mean).toPrecision(4));\n        });\n\n        plotsvg.append("text").attr("id", "range2") // this is bad practice, id is not unique\n        .attr(\'class\', \'x1val\').attr("x", 25).attr("y", height + 50).text(function (_) {\n            var returnval = "x1: ".concat((+node.mean).toPrecision(4));\n            return returnval;\n        });\n\n        // create tick marks at all zscores in the bounds of the data\n        var lineFunction = d3.svg.line().x(function (d) {\n            return d.x;\n        }).y(function (d) {\n            return d.y;\n        }).interpolate("linear");\n\n        var colSeq = ["#A2CD5A", "orange", "red"]; // will cycle through color sequence, and then repeat last color\n        var lineData = new Array();\n\n        var zLower = -1 * (d3.min(xVals) - node.mean) / node.sd; // zscore of lower bound\n        var zUpper = (d3.max(xVals) - node.mean) / node.sd; // zscore of upper bound\n\n        for (var i = 0; i < zUpper; i++) {\n            lineData = [{\n                "x": x(+node.mean + i * node.sd),\n                "y": height * .7\n            }, {\n                "x": x(+node.mean + i * node.sd),\n                "y": height * .9\n            }];\n            plotsvg.append("path").attr("d", lineFunction([lineData[0], lineData[1]])).attr("stroke", colSeq[d3.min([i, colSeq.length - 1])]).attr("stroke-width", 1.5).attr("fill", "none");\n        }\n\n        for (var i = 1; i < zLower; i++) {\n            lineData = [{\n                "x": x(+node.mean - i * node.sd),\n                "y": height * .7\n            }, {\n                "x": x(+node.mean - i * node.sd),\n                "y": height * .9\n            }];\n            plotsvg.append("path").attr("d", lineFunction([lineData[0], lineData[1]])).attr("stroke", colSeq[d3.min([i, colSeq.length - 1])]).attr("stroke-width", 1.5).attr("fill", "none");\n        }\n\n        // initialize slider components\n        var slideBox = plotsvg.append("g").attr("class", "x axis").attr("transform", "translate(0," + height * .8 + ")").call(d3.svg.axis().scale(x).ticks(0).orient("bottom"));\n        var slider = plotsvg.append("g").attr("class", "slider").call(brush);\n        var handle = slider.append("polygon").attr("class", "handle").attr("transform", "translate(0," + height * .7 + ")").attr("points", function (_) {\n            var s = 6;\n            var xnm = node.setxvals[0] == \'\' ? x(node.mean) : x(node.setxvals[0]);\n            return xnm - s + "," + -s + " " + (xnm + s) + "," + -s + " " + xnm + "," + s * 1.3;\n        });\n        var slider2 = plotsvg.append("g").attr("class", "slider").call(brush2);\n        var handle2 = slider2.append("polygon").attr("class", "handle").attr("transform", "translate(0," + height * .9 + ")").attr("points", function (_) {\n            var s = 6;\n            var xnm = node.setxvals[1] == \'\' ? x(node.mean) : x(node.setxvals[1]);\n            return xnm - s + "," + s + " " + (xnm + s) + "," + s + " " + xnm + "," + -s * 1.3;\n        });\n    }\n\n    // brushing functions\n    function brushed() {\n        if (div == "#tab2") {\n            plotsvg.select("text#range").text(function () {\n                return brush.empty() ? "Range: ".concat(d3.min(xVals).toPrecision(4), " to ", d3.max(xVals).toPrecision(4)) : "Range: ".concat(brush.extent()[0].toPrecision(4), " to ", brush.extent()[1].toPrecision(4));\n            });\n            node.subsetrange = brush.extent()[0].toPrecision(4) != brush.extent()[1].toPrecision(4) ? [brush.extent()[0].toPrecision(4), brush.extent()[1].toPrecision(4)] : ["", ""];\n        } else if (div == "#setxLeft" || div == "#setxLeftTopRight") {\n            var value = brush.extent()[0];\n            var s = 6;\n            if (d3.event.sourceEvent) {\n                value = x.invert(d3.mouse(this)[0]);\n                brush.extent([value, value]);\n            }\n\n            // set x position of slider center\n            var xpos = x(value);\n            if (value > d3.max(xVals)) {\n                // dragged past max\n                xpos = x(d3.max(xVals));\n            } else if (value < d3.min(xVals)) {\n                // dragged past min\n                xpos = x(d3.min(xVals));\n            } else {\n                var m = +node.mean;\n                var sd = +node.sd;\n                var zScore = (value - m) / sd; // z-score\n                var zRound = Math.round(zScore); // nearest integer z-score\n                if (.1 > Math.abs(zRound - zScore)) // snap to integer z-score\n                    xpos = x(m + zRound * sd);\n            }\n\n            // create slider symbol and text\n            handle.attr("points", function (_) {\n                return xpos - s + "," + -s + " " + (xpos + s) + "," + -s + " " + xpos + "," + s * 1.3;\n            });\n            plotsvg.select("text#range").text(function (_) {\n                var returnval = "x: ".concat(invx(xpos).toPrecision(4));\n                var xval = invx(xpos).toPrecision(4);\n                var mycell = node.name + "From"; // hardcoded here\n                if (document.getElementById(mycell)) {\n                    document.getElementById(mycell).innerText = xval;\n                }\n                return returnval;\n            });\n            node.setxvals[0] = invx(xpos).toPrecision(4);\n        }\n    }\n\n    // certainly a more clever way to do this, but for now it\'s basically copied with brush and handle changes to brush2 and handle2 and #range to #range2 and setxvals[0] to setxvals[1]\n    function brushed2() {\n        var value = brush2.extent()[0];\n        var s = 6; // scaling for triangle shape\n\n        if (d3.event.sourceEvent) {\n            value = x.invert(d3.mouse(this)[0]);\n            brush2.extent([value, value]);\n        }\n\n        // set x position of slider center\n        var xpos = x(value);\n        if (value > d3.max(xVals)) {\n            // dragged past max\n            xpos = x(d3.max(xVals));\n        } else if (value < d3.min(xVals)) {\n            // dragged past min\n            xpos = x(d3.min(xVals));\n        } else {\n            var m = +node.mean;\n            var sd = +node.sd;\n            var zScore = (value - m) / sd; // z-score\n            var zRound = Math.round(zScore); // nearest integer z-score\n            if (.1 > Math.abs(zRound - zScore)) // snap to integer z-score\n                xpos = x(m + zRound * sd);\n        }\n\n        // create slider symbol and text\n        handle2.attr("points", function (_) {\n            return xpos - s + "," + s + " " + (xpos + s) + "," + s + " " + xpos + "," + -s * 1.3;\n        });\n        plotsvg.select("text#range2").text(function (_) {\n            var returnval = "x1: ".concat(invx(xpos).toPrecision(4));\n            var x1val = invx(xpos).toPrecision(4);\n            var mycell = node.name + "To"; // hardcoded here\n            if (document.getElementById(mycell)) {\n                document.getElementById(mycell).innerText = x1val;\n            }\n            return returnval;\n        });\n        node.setxvals[1] = invx(xpos).toPrecision(4);\n    }\n}\n\nfunction bars(node, div, priv) {\n    // Histogram spacing\n    var barPadding = .015; // Space between bars\n    var topScale = 1.2; // Multiplicative factor to assign space at top within graph - currently removed from implementation\n    var plotXaxis = true;\n\n    // Data\n    var keys = Object.keys(node.plotvalues);\n    var yVals = new Array();\n    var ciUpperVals = new Array();\n    var ciLowerVals = new Array();\n    var ciSize;\n\n    var xVals = new Array();\n    var yValKey = new Array();\n\n    if (node.nature == "nominal") {\n        var xi = 0;\n        for (var i = 0; i < keys.length; i++) {\n            if (node.plotvalues[keys[i]] == 0) continue;\n            yVals[xi] = node.plotvalues[keys[i]];\n            xVals[xi] = xi;\n            if (priv) {\n                if (node.plotvaluesCI) {\n                    ciLowerVals[xi] = node.plotValuesCI.lowerBound[keys[i]];\n                    ciUpperVals[xi] = node.plotValuesCI.upperBound[keys[i]];\n                }\n                ciSize = ciUpperVals[xi] - ciLowerVals[xi];\n            };\n\n            yValKey.push({\n                y: yVals[xi],\n                x: keys[i]\n            });\n            xi = xi + 1;\n        }\n        yValKey.sort(function (a, b) {\n            return b.y - a.y;\n        }); // array of objects, each object has y, the same as yVals, and x, the category\n        yVals.sort(function (a, b) {\n            return b - a;\n        }); // array of y values, the height of the bars\n        ciUpperVals.sort(function (a, b) {\n            return b.y - a.y;\n        }); // ?\n        ciLowerVals.sort(function (a, b) {\n            return b.y - a.y;\n        }); // ?\n    } else {\n        for (var i = 0; i < keys.length; i++) {\n            // console.log("plotvalues in bars");\n            yVals[i] = node.plotvalues[keys[i]];\n            xVals[i] = Number(keys[i]);\n            if (priv) {\n                if (node.plotvaluesCI) {\n                    ciLowerVals[i] = node.plotvaluesCI.lowerBound[keys[i]];\n                    ciUpperVals[i] = node.plotvaluesCI.upperBound[keys[i]];\n                }\n                ciSize = ciUpperVals[i] - ciLowerVals[i];\n            }\n        }\n    }\n\n    if (yVals.length > 15 & node.numchar == "numeric" || yVals.length > 5 & node.numchar == "character") plotXaxis = false;\n    var maxY = d3.max(yVals); // in the future, set maxY to the value of the maximum confidence limit\n    if (priv && node.plotvaluesCI) maxY = d3.max(ciUpperVals);\n    var minX = d3.min(xVals);\n    var maxX = d3.max(xVals);\n\n    var mydiv = void 0;\n    if (div == "setxLeft") mydiv = "#setxLeft";else if (div == "varSummary") mydiv = "#tab3";else if (div == "setxLeftTopRight") mydiv = "#setxLeftTopRight";else return alert("Error: incorrect div selected for plots");\n\n    var tempWidth = d3.select(mydiv).style("width");\n    var width = tempWidth.substring(0, tempWidth.length - 2);\n    var tempHeight = d3.select(mydiv).style("height");\n    var height = tempHeight.substring(0, tempHeight.length - 2);\n\n    var margin = {\n        top: 20,\n        right: 20,\n        bottom: 53,\n        left: 10\n    };\n    var tw = document.getElementById(\'main\').offsetWidth;\n\n    // Need to fix automatic width and height settings for leftpanel (#tab2, #tab3)\n    if (mydiv == "#tab3") {\n        width = 0.7 * (width - margin.left - margin.right);\n        height = 0.3 * (height - margin.top - margin.bottom);\n    } else if (mydiv == "#setxLeft" || mydiv == "#setxLeftTopRight") {\n        //width = 200;\n        //height = 120;\n        width = tw * .185 - margin.left - margin.right; //rightpanel.expand is 40 percent, setxLeft to 50 percent, toggle bar is 16px, padding, it\'s all about .185\n        height = width * .6; //height to width is .6\n    } else {\n        width = 0.35 * (width - margin.left - margin.right);\n        height = 0.25 * (height - margin.top - margin.bottom);\n    };\n\n    if (priv && node.stabilityBin) {\n        var x = d3.scale.linear().domain([minX - 0.5, maxX + 1.5]).range([0, width]);\n    } else {\n        var x = d3.scale.linear().domain([minX - 0.5, maxX + 0.5]).range([0, width]);\n    }\n\n    var invx = d3.scale.linear().range([minX - 0.5, maxX + 0.5]).domain([0, width]);\n\n    var y = d3.scale.linear().domain([0, maxY]).range([0, height]);\n\n    var xAxis = d3.svg.axis().scale(x).ticks(yVals.length).orient("bottom");\n\n    var yAxis = d3.svg.axis().scale(y).orient("left");\n\n    var brush = d3.svg.brush().x(x).extent(function () {\n        return node.subsetrange.length == 1 ? [node.subsetrange[0], node.subsetrange[0]] : node.subsetrange;\n    }).on("brush", brushed);\n\n    var brush2 = d3.svg.brush().x(x).on("brush", brushed2);\n\n    // Create SVG element\n    // cumbersome to treat "tab3" differently, but works for now\n    // tab3, has an issue, that unless width height hardcoded, they grow with each additional graph.\n    if (mydiv == "#tab3") {\n        var plotsvg = d3.select(mydiv).selectAll("svg").remove();\n\n        var plotsvg = d3.select(mydiv).append("svg").attr("id", function () {\n            return node.name.toString().concat(mydiv.substr(1));\n        }).style("width", 300) //setting height to the height of #main.left\n        .style("height", 200).append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");\n    } else {\n        var plotsvg = d3.select(mydiv).append("svg").attr("id", function () {\n            var myname = node.name.toString();\n            myname = myname.replace(/\\(|\\)/g, "");\n            return myname.concat("_", mydiv.substr(1), "_", node.id);\n        }).style("width", width + margin.left + margin.right) //setting height to the height of #main.left\n        .style("height", height + margin.top + margin.bottom).append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");\n    };\n\n    var rectWidth = x(minX + 0.5 - 2 * barPadding); //the "width" is the coordinate of the end of the first bar\n\n    plotsvg.selectAll("rect").data(yVals).enter().append("rect").attr("x", function (d, i) {\n        return x(xVals[i] - 0.5 + barPadding);\n    }).attr("y", function (d) {\n        return y(maxY - d);\n    }).attr("width", rectWidth).attr("height", y).attr("fill", "#1f77b4");\n\n    // draw error bars, threshold line and extra bin\n    if (priv) {\n        if (yVals.length <= 20) {\n            plotsvg.selectAll("line").data(ciUpperVals).enter().append("line").style("stroke", "black").attr("x1", function (d, i) {\n                return x(xVals[i] - 0.5 + barPadding) + rectWidth / 2;\n            }).attr("y1", function (d) {\n                return y(maxY - d);\n            }).attr("x2", function (d, i) {\n                return x(xVals[i] - 0.5 + barPadding) + rectWidth / 2;\n            }).attr("y2", function (d) {\n                var y2 = y(maxY - d + ciSize);\n                return y2 >= y(maxY) ? y(maxY) : y2;\n            });\n\n            //draw top ticks on error bars\n            //need to fix the height of the graphs - the tops of error bars are getting cut off\n            plotsvg.selectAll(".topTick").data(ciUpperVals).enter().append("line").attr("class", "topTick").style("stroke", "black").attr("x1", function (d, i) {\n                if (yVals.length > 20) {\n                    return x(xVals[i] - 0.5 + barPadding); //make tick bigger to increase visibility\n                } else {\n                    return x(xVals[i] - 0.5 + barPadding) + 0.4 * rectWidth;\n                }\n            }).attr("y1", function (d) {\n                return y(maxY - d);\n            }).attr("x2", function (d, i) {\n                if (yVals.length > 20) {\n                    return x(xVals[i] - 0.5 + barPadding) + rectWidth; //make tick bigger to increase visibility\n                } else {\n                    return x(xVals[i] - 0.5 + barPadding) + 0.6 * rectWidth;\n                }\n            }).attr("y2", function (d) {\n                return y(maxY - d);\n            });\n\n            // draw bottom ticks of error bars\n            plotsvg.selectAll(".bottomTick").data(ciLowerVals).enter().append("line").attr("class", "bottomTick").style("stroke", "black").attr("x1", function (d, i) {\n                if (yVals.length > 20) {\n                    return x(xVals[i] - 0.5 + barPadding);\n                } else {\n                    return x(xVals[i] - 0.5 + barPadding) + 0.4 * rectWidth;\n                }\n            }).attr("y1", function (d) {\n                return y(maxY - d);\n            }).attr("x2", function (d, i) {\n                if (yVals.length > 20) {\n                    return x(xVals[i] - 0.5 + barPadding) + rectWidth;\n                } else {\n                    return x(xVals[i] - 0.5 + barPadding) + 0.6 * rectWidth;\n                }\n            }).attr("y2", function (d) {\n                return y(maxY - d);\n            });\n        } else {\n            plotsvg.selectAll(".denseError").data(yVals).enter().append("rect").attr("class", "denseError").attr("x", function (d, i) {\n                return x(xVals[i] - 0.5 + barPadding);\n            }).attr("y", function (d) {\n                return y(maxY - d) - .1 * y(d);\n            }).attr("width", rectWidth).attr("height", function (d) {\n                return y(maxY - d) + .1 * y(d) - (y(maxY - d) - .1 * y(d));\n            }).attr("fill", "silver");\n        }\n\n        //if statement for stability histograms\n        //extra stability bin\n        if (node.stabilityBin) {\n            plotsvg.append("rect").attr("x", x(maxX + 0.5 - barPadding)).attr("y", y(maxY) - node.stabilityBin).attr("width", rectWidth).attr("height", node.stabilityBin).attr("fill", "silver");\n        }\n\n        //threshold line\n        if (node.threshold) {\n            plotsvg.append("line").style("stroke", "black").attr("x1", x(minX - 0.5 + barPadding)).attr("y1", y(maxY) - node.threshold).attr("x2", function () {\n                console.log("stabilityBin");\n                console.log(node.stabilityBin);\n                if (node.stabilityBin) {\n                    return x(maxX + 0.5 - barPadding) + rectWidth;\n                } else {\n                    return x(maxX + 0.5 - barPadding);\n                }\n            }).attr("y2", y(maxY) - node.threshold);\n        }\n    }\n\n    if (plotXaxis) {\n        plotsvg.append("g").attr("class", "x axis").attr("transform", "translate(0," + height + ")").call(xAxis);\n    }\n\n    plotsvg.append("text").attr("x", width / 2).attr("y", 0 - margin.top / 2).attr("text-anchor", "middle").style("font-size", "12px").text(node.name);\n\n    if (mydiv == "#setxLeft" || mydiv == "#setxLeftTopRight") {\n        plotsvg.append("text").attr("id", "range") // bad practice, not unique\n        .attr(\'class\', \'xval\').attr("x", 25).attr("y", height + 40).text(function () {\n            if (node.nature === "nominal") {\n                var t = Math.round(yValKey.length / 2) - 1;\n                var mycell = node.name + "From"; // hardcoded here\n                if (document.getElementById(mycell)) {\n                    document.getElementById(mycell).innerText = yValKey[t].x;\n                }\n                return "x: " + yValKey[t].x;\n            } else {\n                var _mycell = node.name + "From"; // hardcoded here\n                if (document.getElementById(_mycell)) {\n                    document.getElementById(_mycell).innerText = (+node.mean).toPrecision(4).toString();\n                }\n                return "x: ".concat((+node.mean).toPrecision(4).toString());\n            }\n        });\n\n        plotsvg.append("text").attr("id", "range2") //bad practice, not unique\n        .attr(\'class\', \'x1val\').attr("x", 25).attr("y", height + 50).text(function () {\n            if (node.nature === "nominal") {\n                var t = Math.round(yValKey.length / 2) - 1;\n                return "x1: " + yValKey[t].x;\n            } else {\n                return "x1: ".concat((+node.mean).toPrecision(4).toString());\n            }\n        });\n\n        // create tick marks at all zscores in the bounds of the data\n        var lineFunction = d3.svg.line().x(function (d) {\n            return d.x;\n        }).y(function (d) {\n            return d.y;\n        }).interpolate("linear");\n\n        var colSeq = ["#A2CD5A", "orange", "red"]; // will cycle through color sequence, and then repeat last color\n        var lineData = new Array();\n\n        var zLower = -1 * (minX - node.mean) / node.sd; // zscore of lower bound\n        var zUpper = (maxX - node.mean) / node.sd; // zscore of upper bound\n\n        for (var i = 0; i < zUpper; i++) {\n            lineData = [{\n                "x": x(+node.mean + i * node.sd),\n                "y": height * .7\n            }, {\n                "x": x(+node.mean + i * node.sd),\n                "y": height * .9\n            }];\n            plotsvg.append("path").attr("d", lineFunction([lineData[0], lineData[1]])).attr("stroke", colSeq[d3.min([i, colSeq.length - 1])]).attr("stroke-width", 1.5).attr("fill", "none");\n        }\n\n        for (var i = 1; i < zLower; i++) {\n            lineData = [{\n                "x": x(+node.mean - i * node.sd),\n                "y": height * .7\n            }, {\n                "x": x(+node.mean - i * node.sd),\n                "y": height * .9\n            }];\n            plotsvg.append("path").attr("d", lineFunction([lineData[0], lineData[1]])).attr("stroke", colSeq[d3.min([i, colSeq.length - 1])]).attr("stroke-width", 1.5).attr("fill", "none");\n        }\n\n        for (var i = d3.min(xVals); i <= d3.max(xVals); i++) {\n            lineData = [{\n                "x": x(i),\n                "y": height * .75\n            }, {\n                "x": x(i),\n                "y": height * .85\n            }];\n            plotsvg.append("path").attr("d", lineFunction([lineData[0], lineData[1]])).attr("stroke", "black").attr("stroke-width", 1).attr("fill", "none");\n        }\n\n        // initialize slider components\n        var slideBox = plotsvg.append("g").attr("class", "x axis").attr("transform", "translate(0," + height * .8 + ")").call(d3.svg.axis().scale(x).ticks(0).orient("bottom"));\n\n        var slider = plotsvg.append("g").attr("class", "slider").call(brush);\n        var slider2 = plotsvg.append("g").attr("class", "slider").call(brush2);\n\n        var points = function points(i) {\n            return function (d) {\n                var xnm = void 0,\n                    s = 6;\n                if (node.setxvals[i] == \'\') {\n                    // if nominal, use the median frequency as the position for the setx slider\n                    xnm = node.nature == \'nominal\' ? x(Math.round(xVals.length / 2) - 1) : x(node.mean);\n                } else {\n                    xnm = x(node.setxvals[i]);\n                };\n                return xnm - s + \',\' + -s + \' \' + (xnm + s) + \',\' + -s + \' \' + xnm + \',\' + s * 1.3;\n            };\n        };\n        var handle = slider.append("polygon").attr("class", "handle").attr("transform", "translate(0," + height * .7 + ")").attr("points", points(0));\n        var handle2 = slider2.append("polygon").attr("class", "handle").attr("transform", "translate(0," + height * .9 + ")").attr("points", points(1));\n    }\n\n    function twoSF(x) {\n        var tsf = d3.format(".2r"); // format to two significant figures after the decimal place\n        return tsf(x).replace(/0+$/, "").replace(/\\.$/, ""); // trim trailing zeros after a period, and any orphaned period\n    }\n\n    // brushing functions\n    function brushed() {\n        var value = brush.extent()[0];\n        var s = 6;\n\n        if (d3.event.sourceEvent) {\n            value = x.invert(d3.mouse(this)[0]);\n            brush.extent([value, value]);\n        }\n\n        // set x position of slider center\n        var xpos = x(value);\n        if (value > maxX) {\n            // dragged past max\n            xpos = x(maxX);\n        } else if (value < minX) {\n            // dragged past min\n            xpos = x(minX);\n        } else {\n            var m = +node.mean;\n            var sd = +node.sd;\n            var zScore = (value - m) / sd; // z-score\n            var zRound = Math.round(zScore); // nearest integer z-score\n            if (.1 > Math.abs(Math.round(value) - value)) {\n                // snap to integer\n                xpos = x(Math.round(value));\n            } else if (.1 > Math.abs(zRound - zScore)) {\n                // snap to integer z-score\n                xpos = x(m + zRound * sd);\n            }\n        }\n\n        // create slider symbol and text\n        handle.attr("points", function (d) {\n            return xpos - s + "," + -s + " " + (xpos + s) + "," + -s + " " + xpos + "," + s * 1.3;\n        });\n        plotsvg.select("text#range").text(function () {\n            if (node.nature === "nominal") {\n                var mycell = node.name + "From"; // hardcoded here\n                if (document.getElementById(mycell)) {\n                    document.getElementById(mycell).innerText = yValKey[Math.round(invx(xpos))].x;\n                }\n                return "x: " + yValKey[Math.round(invx(xpos))].x;\n            } else {\n                var _mycell2 = node.name + "From"; // hardcoded here\n                if (document.getElementById(_mycell2)) {\n                    document.getElementById(_mycell2).innerText = +invx(xpos).toPrecision(4).toString();\n                }\n                return "x: ".concat(+invx(xpos).toPrecision(4).toString());\n            }\n        });\n        node.setxvals[0] = +invx(xpos).toPrecision(4);\n    }\n\n    // certainly a more clever way to do this, but for now it\'s basically copied with brush and handle changes to brush2 and handle2 and #range to #range2 and setxvals[0] to setxvals[1]\n    function brushed2() {\n        var value = brush2.extent()[0];\n        var s = 6; // scaling for triangle shape\n\n        if (d3.event.sourceEvent) {\n            value = x.invert(d3.mouse(this)[0]);\n            brush2.extent([value, value]);\n        }\n\n        // set x position of slider center\n        var xpos = x(value);\n        if (value > maxX) {\n            // dragged past max\n            xpos = x(maxX);\n        } else if (value < minX) {\n            // dragged past min\n            xpos = x(minX);\n        } else {\n            var m = +node.mean;\n            var sd = +node.sd;\n            var zScore = (value - m) / sd; // z-score\n            var zRound = Math.round(zScore); // nearest integer z-score\n            if (.1 > Math.abs(Math.round(value) - value)) {\n                // snap to integer\n                xpos = x(Math.round(value));\n            } else if (.1 > Math.abs(zRound - zScore)) {\n                // snap to integer z-score\n                xpos = x(m + zRound * sd);\n            }\n        }\n\n        // create slider symbol and text\n        handle2.attr("points", function (d) {\n            return xpos - s + "," + s + " " + (xpos + s) + "," + s + " " + xpos + "," + -s * 1.3;\n        });\n        plotsvg.select("text#range2").text(function () {\n            if (node.nature === "nominal") {\n                var mycell = node.name + "To"; // hardcoded here\n                if (document.getElementById(mycell)) {\n                    document.getElementById(mycell).innerText = yValKey[Math.round(invx(xpos))].x;\n                }\n                return "x1: " + yValKey[Math.round(invx(xpos))].x;\n            } else {\n                var _mycell3 = node.name + "To"; // hardcoded here\n                if (document.getElementById(_mycell3)) {\n                    document.getElementById(_mycell3).innerText = +invx(xpos).toPrecision(4).toString();\n                }\n                return "x1: ".concat(+invx(xpos).toPrecision(4).toString());\n            }\n        });\n        node.setxvals[1] = +invx(xpos).toPrecision(4);\n    }\n}\n\n// draws barplots in subset tab\nfunction barsSubset(node) {\n    // if untouched, set node.subsetrange to an empty array, meaning all values selected by default\n    if (node.subsetrange[0] == "" & node.subsetrange[1] == "") {\n        node.subsetrange = [];\n    }\n\n    // Histogram spacing\n    var barPadding = .015; // Space between bars\n    var topScale = 1.2; // Multiplicative factor to assign space at top within graph - currently removed from implementation\n    var plotXaxis = true;\n\n    // Variable name\n    var myname = node.name.toString();\n    myname = myname.replace(/\\(|\\)/g, "");\n\n    // Data\n    var keys = Object.keys(node.plotvalues);\n    var yVals = new Array();\n    var xVals = new Array();\n    var yValKey = new Array();\n\n    var xi = 0;\n    for (var i = 0; i < keys.length; i++) {\n        if (node.plotvalues[keys[i]] == 0) continue;\n        yVals[xi] = node.plotvalues[keys[i]];\n        xVals[xi] = xi;\n        yValKey.push({\n            y: yVals[xi],\n            x: keys[i]\n        });\n        xi = xi + 1;\n    }\n    if (node.nature === "nominal") {\n        // if nominal, orders bars left to right, highest frequency to lowest\n        yValKey.sort(function (a, b) {\n            return b.y - a.y;\n        }); // array of objects, each object has y, the same as yVals, and x, the category\n        yVals.sort(function (a, b) {\n            return b - a;\n        }); // array of y values, the height of the bars\n    }\n\n    plotXaxis = false;\n\n    var maxY = d3.max(yVals);\n    var minX = d3.min(xVals);\n    var maxX = d3.max(xVals);\n    var gname = ["subsetyes", "subsetno"];\n\n    var yVals2 = [];\n    var yVals1 = [];\n    for (i = 0; i < yVals.length; i++) {\n        yVals1.push({\n            y0: maxY - yVals[i],\n            y1: yVals[i],\n            col: d3Color\n        });\n        yVals2.push({\n            y0: 0,\n            y1: maxY - yVals[i],\n            col: "transparent"\n        });\n    }\n    var freqs = [yVals1, yVals2];\n\n    // y0 is the starting point\n    // y1 is the length of the bar\n\n    var mydiv = "#tab2";\n    var width = 200;\n    var height = 120;\n    var margin = {\n        top: 20,\n        right: 20,\n        bottom: 53,\n        left: 50\n    };\n\n    var x = d3.scale.linear().domain([minX - 0.5, maxX + 0.5]).range([0, width]);\n\n    var invx = d3.scale.linear().range([minX - 0.5, maxX + 0.5]).domain([0, width]);\n\n    var y = d3.scale.linear().domain([0, maxY]).range([0, height]);\n\n    var xAxis = d3.svg.axis().scale(x).ticks(yVals.length).orient("bottom");\n\n    var yAxis = d3.svg.axis().scale(y).orient("left");\n\n    //Create SVG element\n    var plotsvg = d3.select(mydiv).append("svg").attr("id", function () {\n        return myname.concat("_", mydiv.substr(1), "_", node.id);\n    }).style("width", width + margin.left + margin.right) //setting height to the height of #main.left\n    .style("height", height + margin.top + margin.bottom).append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");\n\n    var freq = plotsvg.selectAll("g.freq").data(freqs).enter().append("g").attr("class", "freq").attr("name", function (d, i) {\n        return myname.concat(gname[i]);\n    });\n\n    var rect = freq.selectAll("rect").data(Object).enter().append("rect").attr("class", "bar").attr("name", function (d, i) {\n        return xVals[i];\n    }).attr("x", function (d, i) {\n        return x(xVals[i] - 0.5 + barPadding);\n    }).attr("y", function (d) {\n        return y(d.y0);\n    }).attr("width", x(minX + 0.5 - 2 * barPadding)) // the "width" is the coordinate of the end of the first bar\n    .attr("height", function (d) {\n        return y(d.y1);\n    }).style("fill", function (d, i) {\n        if (node.subsetrange.length > 0 & d.col === d3Color & $.inArray(xVals[i].toString(), node.subsetrange) > -1) {\n            return selVarColor;\n        } else {\n            return d.col;\n        }\n    }).on("click", function () {\n        var selectMe = this;\n        var selectName = this.getAttribute("name");\n        if (this.parentNode.getAttribute("name") == myname.concat("subsetno")) {\n            selectMe = $(\'[name="\' + myname.concat("subsetyes") + \'"]\').children(\'[name="\' + selectName + \'"]\')[0];\n        }\n        d3.select(selectMe).style("fill", function (d, i) {\n            var myCol = "";\n            if (this.style.fill === selVarColor) {\n                var myindex = node.subsetrange.indexOf(this.getAttribute("name"));\n                node.subsetrange.splice(myindex, 1);\n                myCol = d3Color;\n            } else {\n                node.subsetrange.push(this.getAttribute("name"));\n                myCol = selVarColor;\n            }\n            return myCol;\n        });\n        plotsvg.select("text#selectrange").text(function () {\n            if (node.subsetrange.length == 0) {\n                return "Selected: all values";\n            } else {\n                var a = node.subsetrange;\n                var selecteds = new Array();\n                a.forEach(function (val) {\n                    selecteds.push(yValKey[val].x);\n                });\n                return "Selected: " + selecteds;\n            }\n        });\n    }).on("mouseover", function () {\n        var i = this.getAttribute("name");\n        plotsvg.select("text#mymouseover").text(function () {\n            return yValKey[i].x + ": " + yValKey[i].y;\n        });\n    }).on("mouseout", function () {\n        var i = this.getAttribute("name");\n        plotsvg.select("text#mymouseover").text(function () {\n            return "Value: Frequency";\n        });\n    });\n\n    if (plotXaxis) {\n        plotsvg.append("g").attr("class", "x axis").attr("transform", "translate(0," + height + ")").call(xAxis);\n    } else {\n        plotsvg.append("text").attr("id", "mymouseover").attr("x", 25).attr("y", height + 20).text(function () {\n            return "Value: Frequency";\n        });\n    }\n\n    plotsvg.append("text").attr("x", width / 2).attr("y", 0 - margin.top / 2).attr("text-anchor", "middle").style("font-size", "12px").text(myname);\n\n    plotsvg.append("text").attr("id", "selectrange").attr("x", 25).attr("y", height + 40).text(function () {\n        if (node.subsetrange.length == 0) return "Selected: all values";\n        var selecteds = new Array();\n        node.subsetrange.forEach(function (val) {\n            return selecteds.push(yValKey[val].x);\n        });\n        return "Selected: " + selecteds;\n    });\n}\n\nfunction densityNode(node, obj) {\n    var myname = node.name.toString().concat("nodeplot");\n\n    if (typeof obj === "undefined") {\n        var obj = document.getElementById(node.name.toString() + "biggroup");\n        // if obj contains an svg element, remove it. this removes any plot inside the node\n        if (d3.select(obj).selectAll("svg")[0].length > 0) d3.select(obj).selectAll("svg").remove();\n    }\n\n    var yVals = node.ploty;\n    var xVals = node.plotx;\n    // array of objects\n    var data2 = node.plotx.map(function (x, i) {\n        return { x: +x, y: +node.ploty[i] };\n    });\n\n    var width = 60; // hardcoded, should be set automatically\n    var height = 30;\n    var margin = {\n        top: 20,\n        right: 10,\n        bottom: 53,\n        left: 10\n    };\n\n    var x = d3.scale.linear().domain([d3.min(xVals), d3.max(xVals)]).range([0, width]);\n\n    var y = d3.scale.linear().domain([d3.min(yVals), d3.max(yVals)]).range([height, 0]);\n\n    var area = d3.svg.area().interpolate("monotone").x(function (d) {\n        return x(d.x);\n    }).y0(height).y1(function (d) {\n        return y(d.y);\n    });\n\n    var plotsvg = d3.select(obj).insert("svg", ":first-child").attr("x", -40) // NOTE: Not sure exactly why these numbers work, but these hardcoded values seem to position the plot inside g correctly.  this shouldn\'t be hardcoded in the future\n    .attr("y", -45).attr("id", function () {\n        return myname;\n    }).style("width", width).style("height", height).append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");\n\n    plotsvg.append("path").datum(data2).attr("class", "area").attr("d", area);\n}\n\nfunction barsNode(node, obj) {\n    var myname = node.name.toString().concat("nodeplot");\n\n    if (typeof obj === "undefined") {\n        var obj = document.getElementById(node.name.toString() + "biggroup");\n        // if obj contains an svg element, remove it. this removes any plot inside the node\n        if (d3.select(obj).selectAll("svg")[0].length > 0) {\n            d3.select(obj).selectAll("svg").remove();\n        }\n    }\n\n    // Histogram spacing\n    var barPadding = .015; // Space between bars\n    var topScale = 1.2; // Multiplicative factor to assign space at top within graph - currently removed from implementation\n\n    // Data\n    var keys = Object.keys(node.plotvalues);\n    var yVals = new Array();\n    var xVals = new Array();\n    var yValKey = new Array();\n\n    if (node.nature === "nominal") {\n        var xi = 0;\n        for (var i = 0; i < keys.length; i++) {\n            if (node.plotvalues[keys[i]] == 0) continue;\n            yVals[xi] = node.plotvalues[keys[i]];\n            xVals[xi] = xi;\n            yValKey.push({ y: yVals[xi], x: keys[i] });\n            xi = xi + 1;\n        }\n        yValKey.sort(function (a, b) {\n            return b.y - a.y;\n        }); // array of objects, each object has y, the same as yVals, and x, the category\n        yVals.sort(function (a, b) {\n            return b - a;\n        }); // array of y values, the height of the bars\n    } else {\n        for (var i = 0; i < keys.length; i++) {\n            yVals[i] = node.plotvalues[keys[i]];\n            xVals[i] = Number(keys[i]);\n        }\n    }\n\n    var maxY = d3.max(yVals);\n    var minX = d3.min(xVals);\n    var maxX = d3.max(xVals);\n\n    var width = 60;\n    var height = 30;\n    var margin = {\n        top: 20,\n        right: 10,\n        bottom: 53,\n        left: 10\n    };\n\n    var x = d3.scale.linear().domain([minX - 0.5, maxX + 0.5]).range([0, width]);\n\n    var invx = d3.scale.linear().range([minX - 0.5, maxX + 0.5]).domain([0, width]);\n\n    var y = d3.scale.linear().domain([0, maxY]).range([0, height]);\n\n    //Create SVG element\n    var plotsvg = d3.select(obj).insert("svg", ":first-child").attr("x", -40).attr("y", -45).attr("id", function () {\n        return myname;\n    }).style("width", width) // set height to the height of #main.left\n    .style("height", height).append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");\n\n    plotsvg.selectAll("rect").data(yVals).enter().append("rect").attr("x", function (d, i) {\n        return x(xVals[i] - 0.5 + barPadding);\n    }).attr("y", function (d) {\n        return y(maxY - d);\n    }).attr("width", x(minX + 0.5 - 2 * barPadding)) // the "width" is the coordinate of the end of the first bar\n    .attr("height", y).attr("fill", "#1f77b4");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvYXBwL3Bsb3RzLmpzP2JmMWYiXSwibmFtZXMiOlsiZGVuc2l0eSIsImJhcnMiLCJiYXJzU3Vic2V0IiwiZGVuc2l0eU5vZGUiLCJiYXJzTm9kZSIsImQzQ29sb3IiLCJzZWxWYXJDb2xvciIsIm5vZGUiLCJkaXYiLCJwcml2Iiwic3Vic2V0Iiwic2V0eExlZnQiLCJzZXR4TGVmdFRvcFJpZ2h0IiwidmFyU3VtbWFyeSIsImFsZXJ0IiwicGxvdHgiLCJwbG90eSIsInhWYWxzIiwieVZhbHMiLCJwbG90Q0kiLCJtYXAiLCJ4IiwiaSIsInkiLCJib3VuZCIsInVwcGVyRXJyb3IiLCJsb3dlckVycm9yIiwiY29uc29sZSIsImxvZyIsInRlbXBXaWR0aCIsImQzIiwic2VsZWN0Iiwic3R5bGUiLCJ3aWR0aCIsInN1YnN0cmluZyIsImxlbmd0aCIsInR3IiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsIm9mZnNldFdpZHRoIiwidGVtcEhlaWdodCIsImhlaWdodCIsIm1hcmdpbiIsInRvcCIsInJpZ2h0IiwiYm90dG9tIiwibGVmdCIsInNjYWxlIiwibGluZWFyIiwiZG9tYWluIiwibWluIiwibWF4IiwicmFuZ2UiLCJpbnZ4IiwieEF4aXMiLCJzdmciLCJheGlzIiwidGlja3MiLCJvcmllbnQiLCJ5QXhpcyIsImJydXNoIiwiZXh0ZW50Iiwic3Vic2V0cmFuZ2UiLCJvbiIsImJydXNoZWQiLCJicnVzaDIiLCJicnVzaGVkMiIsImFyZWEiLCJpbnRlcnBvbGF0ZSIsImQiLCJ5MCIsInkxIiwibGluZSIsInBsb3RzdmciLCJzZWxlY3RBbGwiLCJyZW1vdmUiLCJhcHBlbmQiLCJhdHRyIiwibmFtZSIsInRvU3RyaW5nIiwiY29uY2F0Iiwic3Vic3RyIiwicmVwbGFjZSIsImlkIiwiZGF0dW0iLCJjYWxsIiwidGV4dCIsInRvUHJlY2lzaW9uIiwibWVhbiIsInJldHVybnZhbCIsImxpbmVGdW5jdGlvbiIsImNvbFNlcSIsImxpbmVEYXRhIiwiQXJyYXkiLCJ6TG93ZXIiLCJzZCIsInpVcHBlciIsInNsaWRlQm94Iiwic2xpZGVyIiwiaGFuZGxlIiwicyIsInhubSIsInNldHh2YWxzIiwic2xpZGVyMiIsImhhbmRsZTIiLCJlbXB0eSIsInZhbHVlIiwiZXZlbnQiLCJzb3VyY2VFdmVudCIsImludmVydCIsIm1vdXNlIiwieHBvcyIsIm0iLCJ6U2NvcmUiLCJ6Um91bmQiLCJNYXRoIiwicm91bmQiLCJhYnMiLCJ4dmFsIiwibXljZWxsIiwiaW5uZXJUZXh0IiwieDF2YWwiLCJiYXJQYWRkaW5nIiwidG9wU2NhbGUiLCJwbG90WGF4aXMiLCJrZXlzIiwiT2JqZWN0IiwicGxvdHZhbHVlcyIsImNpVXBwZXJWYWxzIiwiY2lMb3dlclZhbHMiLCJjaVNpemUiLCJ5VmFsS2V5IiwibmF0dXJlIiwieGkiLCJwbG90dmFsdWVzQ0kiLCJwbG90VmFsdWVzQ0kiLCJsb3dlckJvdW5kIiwidXBwZXJCb3VuZCIsInB1c2giLCJzb3J0IiwiYSIsImIiLCJOdW1iZXIiLCJudW1jaGFyIiwibWF4WSIsIm1pblgiLCJtYXhYIiwibXlkaXYiLCJzdGFiaWxpdHlCaW4iLCJteW5hbWUiLCJyZWN0V2lkdGgiLCJkYXRhIiwiZW50ZXIiLCJ5MiIsInRocmVzaG9sZCIsInQiLCJwb2ludHMiLCJ0d29TRiIsInRzZiIsImZvcm1hdCIsImduYW1lIiwieVZhbHMyIiwieVZhbHMxIiwiY29sIiwiZnJlcXMiLCJmcmVxIiwicmVjdCIsIiQiLCJpbkFycmF5Iiwic2VsZWN0TWUiLCJzZWxlY3ROYW1lIiwiZ2V0QXR0cmlidXRlIiwicGFyZW50Tm9kZSIsImNoaWxkcmVuIiwibXlDb2wiLCJmaWxsIiwibXlpbmRleCIsImluZGV4T2YiLCJzcGxpY2UiLCJzZWxlY3RlZHMiLCJmb3JFYWNoIiwidmFsIiwib2JqIiwiZGF0YTIiLCJpbnNlcnQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O1FBSWdCQSxPLEdBQUFBLE87UUFxVUFDLEksR0FBQUEsSTtRQWdpQkFDLFUsR0FB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TVRELEtBTlMsQ0FNSCxRQU5HLEVBTU9TLE1BTlAsRUFPVG1DLE1BUFMsQ0FPRixHQVBFLEVBUVRDLElBUlMsQ0FRSixXQVJJLEVBUVMsZUFBZW5DLE9BQU9JLElBQXRCLEdBQTZCLEdBQTdCLEdBQW1DSixPQUFPQyxHQUExQyxHQUFnRCxHQVJ6RCxDQUFkOztBQVVBOEIsWUFBUUMsU0FBUixDQUFrQixNQUFsQixFQUNLNkUsSUFETCxDQUNVckksS0FEVixFQUVLc0ksS0FGTCxHQUdLNUUsTUFITCxDQUdZLE1BSFosRUFJS0MsSUFKTCxDQUlVLEdBSlYsRUFJZSxVQUFDUixDQUFELEVBQUkvQyxDQUFKO0FBQUEsZUFBV0QsRUFBRUosTUFBTUssQ0FBTixJQUFXLEdBQVgsR0FBaUJvRyxVQUFuQixDQUFYO0FBQUEsS0FKZixFQUtLN0MsSUFMTCxDQUtVLEdBTFYsRUFLZTtBQUFBLGVBQU10RCxFQUFFeUgsT0FBTzNFLENBQVQsQ0FBTjtBQUFBLEtBTGYsRUFNS1EsSUFOTCxDQU1VLE9BTlYsRUFNbUJ4RCxFQUFFNEgsT0FBTyxHQUFQLEdBQWEsSUFBSXZCLFVBQW5CLENBTm5CLEVBTW1EO0FBTm5ELEtBT0s3QyxJQVBMLENBT1UsUUFQVixFQU9vQnRELENBUHBCLEVBUUtzRCxJQVJMLENBUVUsTUFSVixFQVFrQixTQVJsQjtBQVNIIiwiZmlsZSI6IjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJsZXQgZDNDb2xvciA9ICcjMWY3N2I0JzsgLy8gZDMncyBkZWZhdWx0IGJsdWVcbmV4cG9ydCBsZXQgc2VsVmFyQ29sb3IgPSAnI2ZhODA3Mic7IC8vIGQzLnJnYihcInNhbG1vblwiKTtcblxuLy8gZnVuY3Rpb24gdG8gdXNlIGQzIHRvIGdyYXBoIGRlbnNpdHkgcGxvdHMgd2l0aCBwcmVwcm9jZXNzZWQgZGF0YVxuZXhwb3J0IGZ1bmN0aW9uIGRlbnNpdHkobm9kZSwgZGl2LCBwcml2KSB7XG4gICAgZGl2ID0ge3N1YnNldDogJyN0YWIyJywgc2V0eExlZnQ6ICcjc2V0eExlZnQnLCBzZXR4TGVmdFRvcFJpZ2h0OiAnI3NldHhMZWZ0VG9wUmlnaHQnLCB2YXJTdW1tYXJ5OiAnI3RhYjMnfVtkaXZdO1xuICAgIGlmICghZGl2KVxuICAgICAgICByZXR1cm4gYWxlcnQoXCJFcnJvcjogaW5jb3JyZWN0IGRpdiBzZWxlY3RlZCBmb3IgcGxvdHNcIik7XG5cbiAgICBsZXQgW3hWYWxzLCB5VmFsc10gPSBbbm9kZS5wbG90eCwgbm9kZS5wbG90eV07XG4gICAgaWYgKHByaXYgJiYgbm9kZS5wbG90Q0kpIHtcbiAgICAgICAgbGV0IFt1cHBlckVycm9yLCBsb3dlckVycm9yXSA9IFsndXBwZXJCb3VuZCcsICdsb3dlckJvdW5kJ10ubWFwKFxuICAgICAgICAgICAgYm91bmQgPT4geFZhbHMubWFwKCh4LCBpKSA9PiAoe3g6ICt4LCB5OiArbm9kZS5wbG90Q0lbYm91bmRdW2ldfSkpKTtcbiAgICAgICAgY29uc29sZS5sb2coJ3VwcGVyRXJyb3JcXG4nLCB1cHBlckVycm9yKTtcbiAgICB9XG5cbiAgICB2YXIgdGVtcFdpZHRoID0gZDMuc2VsZWN0KGRpdikuc3R5bGUoXCJ3aWR0aFwiKTtcbiAgICB2YXIgd2lkdGggPSB0ZW1wV2lkdGguc3Vic3RyaW5nKDAsICh0ZW1wV2lkdGgubGVuZ3RoIC0gMikpO1xuICAgIFxuICAgIGxldCB0dyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtYWluJykub2Zmc2V0V2lkdGg7XG4gICAgXG4gICAgdmFyIHRlbXBIZWlnaHQgPSBkMy5zZWxlY3QoZGl2KS5zdHlsZShcImhlaWdodFwiKTtcbiAgICB2YXIgaGVpZ2h0ID0gdGVtcEhlaWdodC5zdWJzdHJpbmcoMCwgKHRlbXBIZWlnaHQubGVuZ3RoIC0gMikpO1xuICAgIHZhciBtYXJnaW4gPSB7XG4gICAgICAgIHRvcDogMjAsXG4gICAgICAgIHJpZ2h0OiAyMCxcbiAgICAgICAgYm90dG9tOiA1MyxcbiAgICAgICAgbGVmdDogMTBcbiAgICB9O1xuXG4gICAgLy8gTmVlZCB0byBmaXggYXV0b21hdGljIHdpZHRoIGFuZCBoZWlnaHQgc2V0dGluZ3MgZm9yIGxlZnRwYW5lbCAoI3RhYjIsICN0YWIzKVxuICAgIGlmIChkaXYgPT0gXCIjdGFiM1wiKSB7XG4gICAgICAgIHdpZHRoID0gMC43ICogKHdpZHRoIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQpLFxuICAgICAgICBoZWlnaHQgPSAwLjMgKiAoaGVpZ2h0IC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b20pO1xuICAgIH0gZWxzZSBpZiAoZGl2ID09IFwiI3RhYjJcIikge1xuICAgICAgICB3aWR0aCA9IDIwMDtcbiAgICAgICAgaGVpZ2h0ID0gMTIwO1xuICAgIH0gZWxzZSBpZiAoZGl2ID09IFwiI3NldHhMZWZ0XCIgfHwgZGl2ID09IFwiI3NldHhMZWZ0VG9wUmlnaHRcIikge1xuICAgICAgICB3aWR0aD10dyouMTg1LW1hcmdpbi5sZWZ0LW1hcmdpbi5yaWdodDsgLy9yaWdodHBhbmVsLmV4cGFuZCBpcyA0MCBwZXJjZW50LCBzZXR4TGVmdCB0byA1MCBwZXJjZW50LCB0b2dnbGUgYmFyIGlzIDE2cHgsIHBhZGRpbmcsIGl0J3MgYWxsIGFib3V0IC4xODVcbiAgICAgICAgaGVpZ2h0PXdpZHRoKi42OyAvL2hlaWdodCB0byB3aWR0aCBpcyAuNlxuICAgIH0gZWxzZSB7XG4gICAgICAgIHdpZHRoID0gMC4zNSAqICh3aWR0aCAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0KSxcbiAgICAgICAgaGVpZ2h0ID0gMC4yNSAqIChoZWlnaHQgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbSk7XG4gICAgfTtcblxuICAgIHZhciB4ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLmRvbWFpbihbZDMubWluKHhWYWxzKSwgZDMubWF4KHhWYWxzKV0pXG4gICAgICAgIC5yYW5nZShbMCwgd2lkdGhdKTtcbiAgICB2YXIgaW52eCA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgIC5yYW5nZShbZDMubWluKHhWYWxzKSwgZDMubWF4KHhWYWxzKV0pXG4gICAgICAgIC5kb21haW4oWzAsIHdpZHRoXSk7XG4gICAgdmFyIHkgPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAuZG9tYWluKFtkMy5taW4oeVZhbHMpLCBkMy5tYXgoeVZhbHMpXSlcbiAgICAgICAgLnJhbmdlKFtoZWlnaHQsIDBdKTtcbiAgICB2YXIgeEF4aXMgPSBkMy5zdmcuYXhpcygpXG4gICAgICAgIC5zY2FsZSh4KVxuICAgICAgICAudGlja3MoNSlcbiAgICAgICAgLm9yaWVudChcImJvdHRvbVwiKTtcbiAgICB2YXIgeUF4aXMgPSBkMy5zdmcuYXhpcygpXG4gICAgICAgIC5zY2FsZSh5KVxuICAgICAgICAub3JpZW50KFwibGVmdFwiKTtcbiAgICB2YXIgYnJ1c2ggPSBkMy5zdmcuYnJ1c2goKVxuICAgICAgICAueCh4KVxuICAgICAgICAuZXh0ZW50KG5vZGUuc3Vic2V0cmFuZ2UpXG4gICAgICAgIC5vbihcImJydXNoXCIsIGJydXNoZWQpO1xuICAgIHZhciBicnVzaDIgPSBkMy5zdmcuYnJ1c2goKVxuICAgICAgICAueCh4KVxuICAgICAgICAub24oXCJicnVzaFwiLCBicnVzaGVkMik7XG4gICAgdmFyIGFyZWEgPSBkMy5zdmcuYXJlYSgpXG4gICAgICAgIC5pbnRlcnBvbGF0ZShcIm1vbm90b25lXCIpXG4gICAgICAgIC54KGQgPT4geChkLngpKVxuICAgICAgICAueTAoaGVpZ2h0KVxuICAgICAgICAueTEoZCA9PiB5KGQueSkpO1xuICAgIHZhciBsaW5lID0gZDMuc3ZnLmxpbmUoKVxuICAgICAgICAueChkID0+IHgoZC54KSlcbiAgICAgICAgLnkoZCA9PiB5KGQueSkpXG4gICAgICAgIC5pbnRlcnBvbGF0ZShcIm1vbm90b25lXCIpO1xuXG4gICAgLy8gY3VtYmVyc29tZSB0byB0cmVhdCBcInRhYjNcIiBkaWZmZXJlbnRseSwgYnV0IHdvcmtzIGZvciBub3dcbiAgICAvLyB0YWIzLCBoYXMgYW4gaXNzdWUsIHRoYXQgdW5sZXNzIHdpZHRoIGhlaWdodCBoYXJkY29kZWQsIHRoZXkgZ3JvdyB3aXRoIGVhY2ggYWRkaXRpb25hbCBncmFwaC5cbiAgICBpZiAoZGl2ID09IFwiI3RhYjNcIikge1xuICAgICAgICB2YXIgcGxvdHN2ZyA9IGQzLnNlbGVjdChkaXYpXG4gICAgICAgICAgICAuc2VsZWN0QWxsKFwic3ZnXCIpXG4gICAgICAgICAgICAucmVtb3ZlKCk7XG4gICAgICAgIHBsb3RzdmcgPSBkMy5zZWxlY3QoZGl2KVxuICAgICAgICAgICAgLmFwcGVuZChcInN2Z1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCAoKSA9PiBub2RlLm5hbWUudG9TdHJpbmcoKS5jb25jYXQoZGl2LnN1YnN0cigxKSkpXG4gICAgICAgICAgICAuc3R5bGUoXCJ3aWR0aFwiLCAzMDApIC8vIHNldCBoZWlnaHQgdG8gdGhlIGhlaWdodCBvZiAjbWFpbi5sZWZ0XG4gICAgICAgICAgICAuc3R5bGUoXCJoZWlnaHRcIiwgMjAwKVxuICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIGB0cmFuc2xhdGUoJHttYXJnaW4ubGVmdH0sJHttYXJnaW4udG9wfSlgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcGxvdHN2ZyA9IGQzLnNlbGVjdChkaXYpXG4gICAgICAgICAgICAuYXBwZW5kKFwic3ZnXCIpXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsICgpID0+IG5vZGUubmFtZS50b1N0cmluZygpXG4gICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFwofFxcKS9nLCBcIlwiKVxuICAgICAgICAgICAgICAgICAgLmNvbmNhdChcIl9cIiwgZGl2LnN1YnN0cigxKSwgXCJfXCIsIG5vZGUuaWQpKVxuICAgICAgICAgICAgLnN0eWxlKFwid2lkdGhcIiwgd2lkdGggKyBtYXJnaW4ubGVmdCArIG1hcmdpbi5yaWdodCkgLy9zZXR0aW5nIGhlaWdodCB0byB0aGUgaGVpZ2h0IG9mICNtYWluLmxlZnRcbiAgICAgICAgICAgIC5zdHlsZShcImhlaWdodFwiLCBoZWlnaHQgKyBtYXJnaW4udG9wICsgbWFyZ2luLmJvdHRvbSlcbiAgICAgICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBgdHJhbnNsYXRlKCR7bWFyZ2luLmxlZnR9LCR7bWFyZ2luLnRvcH0pYCk7XG4gICAgfTtcbiAgICBwbG90c3ZnLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgLmRhdHVtKHhWYWxzLm1hcCgoeCwgaSkgPT4gKHt4OiAreCwgeTogK25vZGUucGxvdHlbaV19KSkpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJhcmVhXCIpXG4gICAgICAgIC5hdHRyKFwiZFwiLCBhcmVhKTtcblxuICAgIC8vYWRkIHVwcGVyIGJvdW5kXG4gICAgcHJpdiAmJiBub2RlLnBsb3RDSSAmJiBwbG90c3ZnLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInVwcGVyRXJyb3JcIilcbiAgICAgICAgLmRhdHVtKHVwcGVyRXJyb3IpXG4gICAgICAgIC5hdHRyKFwiZFwiLCBhcmVhKTtcblxuICAgIC8vYWRkIGxvd2VyIGJvdW5kXG4gICAgcHJpdiAmJiBub2RlLnBsb3RDSSAmJiBwbG90c3ZnLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImxvd2VyRXJyb3JcIilcbiAgICAgICAgLmRhdHVtKGxvd2VyRXJyb3IpXG4gICAgICAgIC5hdHRyKFwiZFwiLCBhcmVhKTtcblxuICAgIHBsb3RzdmcuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwieCBheGlzXCIpXG4gICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsXCIgKyBoZWlnaHQgKyBcIilcIilcbiAgICAgICAgLmNhbGwoeEF4aXMpO1xuXG4gICAgcGxvdHN2Zy5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgIC5hdHRyKFwieFwiLCAod2lkdGggLyAyKSlcbiAgICAgICAgLmF0dHIoXCJ5XCIsIDAgLSAobWFyZ2luLnRvcCAvIDIpKVxuICAgICAgICAuYXR0cihcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpXG4gICAgICAgIC5zdHlsZShcImZvbnQtc2l6ZVwiLCBcIjEycHhcIilcbiAgICAgICAgLnRleHQobm9kZS5uYW1lKTtcblxuICAgIC8vIGFkZCBicnVzaCBpZiBzdWJzZXRcbiAgICBpZiAoZGl2ID09IFwiI3RhYjJcIikge1xuICAgICAgICBwbG90c3ZnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgXCJyYW5nZVwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIDI1KVxuICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIGhlaWdodCArIDQwKVxuICAgICAgICAgICAgLnRleHQoKCkgPT4gXCJSYW5nZTogXCIuY29uY2F0KGQzLm1pbih4VmFscykudG9QcmVjaXNpb24oNCksIFwiIHRvIFwiLCBkMy5tYXgoeFZhbHMpLnRvUHJlY2lzaW9uKDQpKSk7XG4gICAgICAgIHBsb3RzdmcuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInggYnJ1c2hcIilcbiAgICAgICAgICAgIC5jYWxsKGJydXNoKVxuICAgICAgICAgICAgLnNlbGVjdEFsbChcInJlY3RcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGhlaWdodCk7XG4gICAgfVxuXG4gICAgLy8gYWRkIHogbGluZXMgYW5kIHNsaWRlcnMgc2V0eFxuICAgIGlmIChkaXYgPT0gXCIjc2V0eExlZnRcIiB8fCBkaXYgPT0gXCIjc2V0eExlZnRUb3BSaWdodFwiKSB7XG4gICAgICAgIHBsb3RzdmcuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBcInJhbmdlXCIpIC8vIHRoaXMgaXMgYmFkIHByYWN0aWNlLCBpZCBpcyBub3QgdW5pcXVlXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCd4dmFsJylcbiAgICAgICAgICAgIC5hdHRyKFwieFwiLCAyNSlcbiAgICAgICAgICAgIC5hdHRyKFwieVwiLCBoZWlnaHQgKyA0MClcbiAgICAgICAgICAgIC50ZXh0KCgpID0+IFwieDogXCIuY29uY2F0KCgrbm9kZS5tZWFuKS50b1ByZWNpc2lvbig0KSkpO1xuXG4gICAgICAgIHBsb3RzdmcuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBcInJhbmdlMlwiKSAvLyB0aGlzIGlzIGJhZCBwcmFjdGljZSwgaWQgaXMgbm90IHVuaXF1ZVxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywneDF2YWwnKVxuICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIDI1KVxuICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIGhlaWdodCArIDUwKVxuICAgICAgICAgICAgLnRleHQoIF8gPT4ge1xuICAgICAgICAgICAgICAgICAgbGV0IHJldHVybnZhbCA9IFwieDE6IFwiLmNvbmNhdCgoK25vZGUubWVhbikudG9QcmVjaXNpb24oNCkpO1xuICAgICAgICAgICAgICAgcmV0dXJuIHJldHVybnZhbH0pO1xuICAgICAgICBcblxuICAgICAgICAvLyBjcmVhdGUgdGljayBtYXJrcyBhdCBhbGwgenNjb3JlcyBpbiB0aGUgYm91bmRzIG9mIHRoZSBkYXRhXG4gICAgICAgIHZhciBsaW5lRnVuY3Rpb24gPSBkMy5zdmcubGluZSgpXG4gICAgICAgICAgICAueChkID0+IGQueClcbiAgICAgICAgICAgIC55KGQgPT4gZC55KVxuICAgICAgICAgICAgLmludGVycG9sYXRlKFwibGluZWFyXCIpO1xuXG4gICAgICAgIHZhciBjb2xTZXEgPSBbXCIjQTJDRDVBXCIsIFwib3JhbmdlXCIsIFwicmVkXCJdOyAvLyB3aWxsIGN5Y2xlIHRocm91Z2ggY29sb3Igc2VxdWVuY2UsIGFuZCB0aGVuIHJlcGVhdCBsYXN0IGNvbG9yXG4gICAgICAgIHZhciBsaW5lRGF0YSA9IG5ldyBBcnJheTtcblxuICAgICAgICB2YXIgekxvd2VyID0gLTEgKiAoZDMubWluKHhWYWxzKSAtIG5vZGUubWVhbikgLyBub2RlLnNkOyAvLyB6c2NvcmUgb2YgbG93ZXIgYm91bmRcbiAgICAgICAgdmFyIHpVcHBlciA9IChkMy5tYXgoeFZhbHMpIC0gbm9kZS5tZWFuKSAvIG5vZGUuc2Q7IC8vIHpzY29yZSBvZiB1cHBlciBib3VuZFxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgelVwcGVyOyBpKyspIHtcbiAgICAgICAgICAgIGxpbmVEYXRhID0gW3tcbiAgICAgICAgICAgICAgICBcInhcIjogeCgrbm9kZS5tZWFuICsgaSAqIG5vZGUuc2QpLFxuICAgICAgICAgICAgICAgIFwieVwiOiBoZWlnaHQgKiAuN1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIFwieFwiOiB4KCtub2RlLm1lYW4gKyBpICogbm9kZS5zZCksXG4gICAgICAgICAgICAgICAgXCJ5XCI6IGhlaWdodCAqIC45XG4gICAgICAgICAgICB9XTtcbiAgICAgICAgICAgIHBsb3RzdmcuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiZFwiLCBsaW5lRnVuY3Rpb24oW2xpbmVEYXRhWzBdLCBsaW5lRGF0YVsxXV0pKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwic3Ryb2tlXCIsIGNvbFNlcVtkMy5taW4oW2ksIGNvbFNlcS5sZW5ndGggLSAxXSldKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwic3Ryb2tlLXdpZHRoXCIsIDEuNSlcbiAgICAgICAgICAgICAgICAuYXR0cihcImZpbGxcIiwgXCJub25lXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB6TG93ZXI7IGkrKykge1xuICAgICAgICAgICAgbGluZURhdGEgPSBbe1xuICAgICAgICAgICAgICAgIFwieFwiOiB4KCtub2RlLm1lYW4gLSBpICogbm9kZS5zZCksXG4gICAgICAgICAgICAgICAgXCJ5XCI6IGhlaWdodCAqIC43XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgXCJ4XCI6IHgoK25vZGUubWVhbiAtIGkgKiBub2RlLnNkKSxcbiAgICAgICAgICAgICAgICBcInlcIjogaGVpZ2h0ICogLjlcbiAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgcGxvdHN2Zy5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJkXCIsIGxpbmVGdW5jdGlvbihbbGluZURhdGFbMF0sIGxpbmVEYXRhWzFdXSkpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJzdHJva2VcIiwgY29sU2VxW2QzLm1pbihbaSwgY29sU2VxLmxlbmd0aCAtIDFdKV0pXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJzdHJva2Utd2lkdGhcIiwgMS41KVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiZmlsbFwiLCBcIm5vbmVcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpbml0aWFsaXplIHNsaWRlciBjb21wb25lbnRzXG4gICAgICAgIHZhciBzbGlkZUJveCA9IHBsb3RzdmcuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInggYXhpc1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCxcIiArIGhlaWdodCAqIC44ICsgXCIpXCIpXG4gICAgICAgICAgICAuY2FsbChkMy5zdmcuYXhpcygpXG4gICAgICAgICAgICAgICAgICAuc2NhbGUoeClcbiAgICAgICAgICAgICAgICAgIC50aWNrcygwKVxuICAgICAgICAgICAgICAgICAgLm9yaWVudChcImJvdHRvbVwiKSk7XG4gICAgICAgIHZhciBzbGlkZXIgPSBwbG90c3ZnLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJzbGlkZXJcIilcbiAgICAgICAgICAgIC5jYWxsKGJydXNoKTtcbiAgICAgICAgdmFyIGhhbmRsZSA9IHNsaWRlci5hcHBlbmQoXCJwb2x5Z29uXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiaGFuZGxlXCIpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLFwiICsgaGVpZ2h0ICogLjcgKyBcIilcIilcbiAgICAgICAgICAgIC5hdHRyKFwicG9pbnRzXCIsIF8gPT4ge1xuICAgICAgICAgICAgICAgIGxldCBzID0gNjtcbiAgICAgICAgICAgICAgICBsZXQgeG5tID0gbm9kZS5zZXR4dmFsc1swXSA9PSAnJyA/IHgobm9kZS5tZWFuKSA6IHgobm9kZS5zZXR4dmFsc1swXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh4bm0gLSBzKSArIFwiLFwiICsgKC1zKSArIFwiIFwiICsgKHhubSArIHMpICsgXCIsXCIgKyAoLXMpICsgXCIgXCIgKyB4bm0gKyBcIixcIiArIChzICogMS4zKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB2YXIgc2xpZGVyMiA9IHBsb3RzdmcuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInNsaWRlclwiKVxuICAgICAgICAgICAgLmNhbGwoYnJ1c2gyKTtcbiAgICAgICAgdmFyIGhhbmRsZTIgPSBzbGlkZXIyLmFwcGVuZChcInBvbHlnb25cIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJoYW5kbGVcIilcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsXCIgKyBoZWlnaHQgKiAuOSArIFwiKVwiKVxuICAgICAgICAgICAgLmF0dHIoXCJwb2ludHNcIiwgXyA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHMgPSA2O1xuICAgICAgICAgICAgICAgIGxldCB4bm0gPSBub2RlLnNldHh2YWxzWzFdID09ICcnID8geChub2RlLm1lYW4pIDogeChub2RlLnNldHh2YWxzWzFdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHhubSAtIHMpICsgXCIsXCIgKyBzICsgXCIgXCIgKyAoeG5tICsgcykgKyBcIixcIiArIHMgKyBcIiBcIiArIHhubSArIFwiLFwiICsgKC1zICogMS4zKTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIGJydXNoaW5nIGZ1bmN0aW9uc1xuICAgIGZ1bmN0aW9uIGJydXNoZWQoKSB7XG4gICAgICAgIGlmIChkaXYgPT0gXCIjdGFiMlwiKSB7XG4gICAgICAgICAgICBwbG90c3ZnLnNlbGVjdChcInRleHQjcmFuZ2VcIilcbiAgICAgICAgICAgICAgICAudGV4dCgoKSA9PiBicnVzaC5lbXB0eSgpID9cbiAgICAgICAgICAgICAgICAgICAgXCJSYW5nZTogXCIuY29uY2F0KGQzLm1pbih4VmFscykudG9QcmVjaXNpb24oNCksIFwiIHRvIFwiLCBkMy5tYXgoeFZhbHMpLnRvUHJlY2lzaW9uKDQpKSA6XG4gICAgICAgICAgICAgICAgICAgIFwiUmFuZ2U6IFwiLmNvbmNhdCgoYnJ1c2guZXh0ZW50KClbMF0pLnRvUHJlY2lzaW9uKDQpLCBcIiB0byBcIiwgKGJydXNoLmV4dGVudCgpWzFdKS50b1ByZWNpc2lvbig0KSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgbm9kZS5zdWJzZXRyYW5nZSA9IGJydXNoLmV4dGVudCgpWzBdLnRvUHJlY2lzaW9uKDQpICE9IGJydXNoLmV4dGVudCgpWzFdLnRvUHJlY2lzaW9uKDQpID9cbiAgICAgICAgICAgICAgICBbKGJydXNoLmV4dGVudCgpWzBdKS50b1ByZWNpc2lvbig0KSwgKGJydXNoLmV4dGVudCgpWzFdKS50b1ByZWNpc2lvbig0KV0gOlxuICAgICAgICAgICAgICAgIFtcIlwiLCBcIlwiXTtcbiAgICAgICAgfSBlbHNlIGlmIChkaXYgPT0gXCIjc2V0eExlZnRcIiB8fCBkaXYgPT0gXCIjc2V0eExlZnRUb3BSaWdodFwiKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBicnVzaC5leHRlbnQoKVswXTtcbiAgICAgICAgICAgIHZhciBzID0gNjtcbiAgICAgICAgICAgIGlmIChkMy5ldmVudC5zb3VyY2VFdmVudCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0geC5pbnZlcnQoZDMubW91c2UodGhpcylbMF0pO1xuICAgICAgICAgICAgICAgIGJydXNoLmV4dGVudChbdmFsdWUsIHZhbHVlXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNldCB4IHBvc2l0aW9uIG9mIHNsaWRlciBjZW50ZXJcbiAgICAgICAgICAgIHZhciB4cG9zID0geCh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAodmFsdWUgPiBkMy5tYXgoeFZhbHMpKSB7IC8vIGRyYWdnZWQgcGFzdCBtYXhcbiAgICAgICAgICAgICAgICB4cG9zID0geChkMy5tYXgoeFZhbHMpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPCBkMy5taW4oeFZhbHMpKSB7IC8vIGRyYWdnZWQgcGFzdCBtaW5cbiAgICAgICAgICAgICAgICB4cG9zID0geChkMy5taW4oeFZhbHMpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIG0gPSArbm9kZS5tZWFuO1xuICAgICAgICAgICAgICAgIHZhciBzZCA9ICtub2RlLnNkO1xuICAgICAgICAgICAgICAgIHZhciB6U2NvcmUgPSAodmFsdWUgLSBtKSAvIHNkOyAvLyB6LXNjb3JlXG4gICAgICAgICAgICAgICAgdmFyIHpSb3VuZCA9IE1hdGgucm91bmQoelNjb3JlKTsgLy8gbmVhcmVzdCBpbnRlZ2VyIHotc2NvcmVcbiAgICAgICAgICAgICAgICBpZiAoLjEgPiBNYXRoLmFicyh6Um91bmQgLSB6U2NvcmUpKSAvLyBzbmFwIHRvIGludGVnZXIgei1zY29yZVxuICAgICAgICAgICAgICAgICAgICB4cG9zID0geChtICsgKHpSb3VuZCAqIHNkKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNyZWF0ZSBzbGlkZXIgc3ltYm9sIGFuZCB0ZXh0XG4gICAgICAgICAgICBoYW5kbGUuYXR0cihcInBvaW50c1wiLCBfID0+ICh4cG9zIC0gcykgKyBcIixcIiArICgtcykgKyBcIiBcIiArICh4cG9zICsgcykgKyBcIixcIiArICgtcykgKyBcIiBcIiArIHhwb3MgKyBcIixcIiArIChzICogMS4zKSk7XG4gICAgICAgICAgICBwbG90c3ZnLnNlbGVjdChcInRleHQjcmFuZ2VcIilcbiAgICAgICAgICAgIC50ZXh0KF8gPT4ge1xuICAgICAgICAgICAgICAgICAgbGV0IHJldHVybnZhbCA9IFwieDogXCIuY29uY2F0KChpbnZ4KHhwb3MpKS50b1ByZWNpc2lvbig0KSk7XG4gICAgICAgICAgICAgICAgICBsZXQgeHZhbCA9IGludngoeHBvcykudG9QcmVjaXNpb24oNCk7XG4gICAgICAgICAgICAgICAgICBsZXQgbXljZWxsID0gbm9kZS5uYW1lK1wiRnJvbVwiOyAvLyBoYXJkY29kZWQgaGVyZVxuICAgICAgICAgICAgICAgICAgaWYoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobXljZWxsKSkge1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChteWNlbGwpLmlubmVyVGV4dD14dmFsO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldHVybnZhbH0pO1xuICAgICAgICAgICAgbm9kZS5zZXR4dmFsc1swXSA9IChpbnZ4KHhwb3MpKS50b1ByZWNpc2lvbig0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNlcnRhaW5seSBhIG1vcmUgY2xldmVyIHdheSB0byBkbyB0aGlzLCBidXQgZm9yIG5vdyBpdCdzIGJhc2ljYWxseSBjb3BpZWQgd2l0aCBicnVzaCBhbmQgaGFuZGxlIGNoYW5nZXMgdG8gYnJ1c2gyIGFuZCBoYW5kbGUyIGFuZCAjcmFuZ2UgdG8gI3JhbmdlMiBhbmQgc2V0eHZhbHNbMF0gdG8gc2V0eHZhbHNbMV1cbiAgICBmdW5jdGlvbiBicnVzaGVkMigpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYnJ1c2gyLmV4dGVudCgpWzBdO1xuICAgICAgICB2YXIgcyA9IDY7IC8vIHNjYWxpbmcgZm9yIHRyaWFuZ2xlIHNoYXBlXG5cbiAgICAgICAgaWYgKGQzLmV2ZW50LnNvdXJjZUV2ZW50KSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHguaW52ZXJ0KGQzLm1vdXNlKHRoaXMpWzBdKTtcbiAgICAgICAgICAgIGJydXNoMi5leHRlbnQoW3ZhbHVlLCB2YWx1ZV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0IHggcG9zaXRpb24gb2Ygc2xpZGVyIGNlbnRlclxuICAgICAgICB2YXIgeHBvcyA9IHgodmFsdWUpO1xuICAgICAgICBpZiAodmFsdWUgPiBkMy5tYXgoeFZhbHMpKSB7IC8vIGRyYWdnZWQgcGFzdCBtYXhcbiAgICAgICAgICAgIHhwb3MgPSB4KGQzLm1heCh4VmFscykpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlIDwgZDMubWluKHhWYWxzKSkgeyAvLyBkcmFnZ2VkIHBhc3QgbWluXG4gICAgICAgICAgICB4cG9zID0geChkMy5taW4oeFZhbHMpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBtID0gK25vZGUubWVhbjtcbiAgICAgICAgICAgIHZhciBzZCA9ICtub2RlLnNkO1xuICAgICAgICAgICAgdmFyIHpTY29yZSA9ICh2YWx1ZSAtIG0pIC8gc2Q7IC8vIHotc2NvcmVcbiAgICAgICAgICAgIHZhciB6Um91bmQgPSBNYXRoLnJvdW5kKHpTY29yZSk7IC8vIG5lYXJlc3QgaW50ZWdlciB6LXNjb3JlXG4gICAgICAgICAgICBpZiAoLjEgPiBNYXRoLmFicyh6Um91bmQgLSB6U2NvcmUpKSAvLyBzbmFwIHRvIGludGVnZXIgei1zY29yZVxuICAgICAgICAgICAgICAgIHhwb3MgPSB4KG0gKyAoelJvdW5kICogc2QpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNyZWF0ZSBzbGlkZXIgc3ltYm9sIGFuZCB0ZXh0XG4gICAgICAgIGhhbmRsZTIuYXR0cihcInBvaW50c1wiLCBfID0+ICh4cG9zIC0gcykgKyBcIixcIiArIHMgKyBcIiBcIiArICh4cG9zICsgcykgKyBcIixcIiArIHMgKyBcIiBcIiArIHhwb3MgKyBcIixcIiArICgtcyAqIDEuMykpO1xuICAgICAgICBwbG90c3ZnLnNlbGVjdChcInRleHQjcmFuZ2UyXCIpXG4gICAgICAgIC50ZXh0KF8gPT4ge1xuICAgICAgICAgICAgICBsZXQgcmV0dXJudmFsID0gXCJ4MTogXCIuY29uY2F0KChpbnZ4KHhwb3MpKS50b1ByZWNpc2lvbig0KSk7XG4gICAgICAgICAgICAgIGxldCB4MXZhbCA9IGludngoeHBvcykudG9QcmVjaXNpb24oNCk7XG4gICAgICAgICAgICAgIGxldCBteWNlbGwgPSBub2RlLm5hbWUrXCJUb1wiOyAvLyBoYXJkY29kZWQgaGVyZVxuICAgICAgICAgICAgICBpZihkb2N1bWVudC5nZXRFbGVtZW50QnlJZChteWNlbGwpKSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobXljZWxsKS5pbm5lclRleHQ9eDF2YWw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJldHVybnZhbH0pO1xuICAgICAgICBub2RlLnNldHh2YWxzWzFdID0gKGludngoeHBvcykpLnRvUHJlY2lzaW9uKDQpO1xuICAgICAgICBcbiAgICAgICAgXG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYmFycyhub2RlLCBkaXYsIHByaXYpIHtcbiAgICAvLyBIaXN0b2dyYW0gc3BhY2luZ1xuICAgIHZhciBiYXJQYWRkaW5nID0gLjAxNTsgLy8gU3BhY2UgYmV0d2VlbiBiYXJzXG4gICAgdmFyIHRvcFNjYWxlID0gMS4yOyAvLyBNdWx0aXBsaWNhdGl2ZSBmYWN0b3IgdG8gYXNzaWduIHNwYWNlIGF0IHRvcCB3aXRoaW4gZ3JhcGggLSBjdXJyZW50bHkgcmVtb3ZlZCBmcm9tIGltcGxlbWVudGF0aW9uXG4gICAgdmFyIHBsb3RYYXhpcyA9IHRydWU7XG5cbiAgICAvLyBEYXRhXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhub2RlLnBsb3R2YWx1ZXMpO1xuICAgIHZhciB5VmFscyA9IG5ldyBBcnJheTtcbiAgICB2YXIgY2lVcHBlclZhbHMgPSBuZXcgQXJyYXk7XG4gICAgdmFyIGNpTG93ZXJWYWxzID0gbmV3IEFycmF5O1xuICAgIHZhciBjaVNpemU7XG5cbiAgICB2YXIgeFZhbHMgPSBuZXcgQXJyYXk7XG4gICAgdmFyIHlWYWxLZXkgPSBuZXcgQXJyYXk7XG5cbiAgICBpZiAobm9kZS5uYXR1cmUgPT0gXCJub21pbmFsXCIpIHtcbiAgICAgICAgdmFyIHhpID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5wbG90dmFsdWVzW2tleXNbaV1dID09IDApXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB5VmFsc1t4aV0gPSBub2RlLnBsb3R2YWx1ZXNba2V5c1tpXV07XG4gICAgICAgICAgICB4VmFsc1t4aV0gPSB4aTtcbiAgICAgICAgICAgIGlmIChwcml2KSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUucGxvdHZhbHVlc0NJKSB7XG4gICAgICAgICAgICAgICAgICAgIGNpTG93ZXJWYWxzW3hpXSA9IG5vZGUucGxvdFZhbHVlc0NJLmxvd2VyQm91bmRba2V5c1tpXV07XG4gICAgICAgICAgICAgICAgICAgIGNpVXBwZXJWYWxzW3hpXSA9IG5vZGUucGxvdFZhbHVlc0NJLnVwcGVyQm91bmRba2V5c1tpXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNpU2l6ZSA9IGNpVXBwZXJWYWxzW3hpXSAtIGNpTG93ZXJWYWxzW3hpXTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHlWYWxLZXkucHVzaCh7XG4gICAgICAgICAgICAgICAgeTogeVZhbHNbeGldLFxuICAgICAgICAgICAgICAgIHg6IGtleXNbaV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgeGkgPSB4aSArIDE7XG4gICAgICAgIH1cbiAgICAgICAgeVZhbEtleS5zb3J0KChhLCBiKSA9PiBiLnkgLSBhLnkpOyAvLyBhcnJheSBvZiBvYmplY3RzLCBlYWNoIG9iamVjdCBoYXMgeSwgdGhlIHNhbWUgYXMgeVZhbHMsIGFuZCB4LCB0aGUgY2F0ZWdvcnlcbiAgICAgICAgeVZhbHMuc29ydCgoYSwgYikgPT4gYiAtIGEpOyAvLyBhcnJheSBvZiB5IHZhbHVlcywgdGhlIGhlaWdodCBvZiB0aGUgYmFyc1xuICAgICAgICBjaVVwcGVyVmFscy5zb3J0KChhLCBiKSA9PiBiLnkgLSBhLnkpOyAvLyA/XG4gICAgICAgIGNpTG93ZXJWYWxzLnNvcnQoKGEsIGIpID0+IGIueSAtIGEueSk7IC8vID9cbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJwbG90dmFsdWVzIGluIGJhcnNcIik7XG4gICAgICAgICAgICB5VmFsc1tpXSA9IG5vZGUucGxvdHZhbHVlc1trZXlzW2ldXTtcbiAgICAgICAgICAgIHhWYWxzW2ldID0gTnVtYmVyKGtleXNbaV0pO1xuICAgICAgICAgICAgaWYgKHByaXYpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5wbG90dmFsdWVzQ0kpIHtcbiAgICAgICAgICAgICAgICAgICAgY2lMb3dlclZhbHNbaV0gPSBub2RlLnBsb3R2YWx1ZXNDSS5sb3dlckJvdW5kW2tleXNbaV1dO1xuICAgICAgICAgICAgICAgICAgICBjaVVwcGVyVmFsc1tpXSA9IG5vZGUucGxvdHZhbHVlc0NJLnVwcGVyQm91bmRba2V5c1tpXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNpU2l6ZSA9IGNpVXBwZXJWYWxzW2ldIC0gY2lMb3dlclZhbHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoKHlWYWxzLmxlbmd0aCA+IDE1ICYgbm9kZS5udW1jaGFyID09IFwibnVtZXJpY1wiKSB8fCAoeVZhbHMubGVuZ3RoID4gNSAmIG5vZGUubnVtY2hhciA9PSBcImNoYXJhY3RlclwiKSlcbiAgICAgICAgcGxvdFhheGlzID0gZmFsc2U7XG4gICAgdmFyIG1heFkgPSBkMy5tYXgoeVZhbHMpOyAvLyBpbiB0aGUgZnV0dXJlLCBzZXQgbWF4WSB0byB0aGUgdmFsdWUgb2YgdGhlIG1heGltdW0gY29uZmlkZW5jZSBsaW1pdFxuICAgIGlmIChwcml2ICYmIG5vZGUucGxvdHZhbHVlc0NJKSBtYXhZID0gZDMubWF4KGNpVXBwZXJWYWxzKTtcbiAgICB2YXIgbWluWCA9IGQzLm1pbih4VmFscyk7XG4gICAgdmFyIG1heFggPSBkMy5tYXgoeFZhbHMpO1xuXG4gICAgbGV0IG15ZGl2O1xuICAgIGlmIChkaXYgPT0gXCJzZXR4TGVmdFwiKSBteWRpdiA9IFwiI3NldHhMZWZ0XCI7XG4gICAgZWxzZSBpZiAoZGl2ID09IFwidmFyU3VtbWFyeVwiKSBteWRpdiA9IFwiI3RhYjNcIjtcbiAgICBlbHNlIGlmIChkaXYgPT0gXCJzZXR4TGVmdFRvcFJpZ2h0XCIpIG15ZGl2ID0gXCIjc2V0eExlZnRUb3BSaWdodFwiO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGFsZXJ0KFwiRXJyb3I6IGluY29ycmVjdCBkaXYgc2VsZWN0ZWQgZm9yIHBsb3RzXCIpO1xuXG4gICAgdmFyIHRlbXBXaWR0aCA9IGQzLnNlbGVjdChteWRpdikuc3R5bGUoXCJ3aWR0aFwiKVxuICAgIHZhciB3aWR0aCA9IHRlbXBXaWR0aC5zdWJzdHJpbmcoMCwgKHRlbXBXaWR0aC5sZW5ndGggLSAyKSk7XG4gICAgdmFyIHRlbXBIZWlnaHQgPSBkMy5zZWxlY3QobXlkaXYpLnN0eWxlKFwiaGVpZ2h0XCIpXG4gICAgdmFyIGhlaWdodCA9IHRlbXBIZWlnaHQuc3Vic3RyaW5nKDAsICh0ZW1wSGVpZ2h0Lmxlbmd0aCAtIDIpKTtcblxuICAgIHZhciBtYXJnaW4gPSB7XG4gICAgICAgIHRvcDogMjAsXG4gICAgICAgIHJpZ2h0OiAyMCxcbiAgICAgICAgYm90dG9tOiA1MyxcbiAgICAgICAgbGVmdDogMTBcbiAgICB9O1xuICAgIGxldCB0dyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtYWluJykub2Zmc2V0V2lkdGg7XG5cbiAgICAvLyBOZWVkIHRvIGZpeCBhdXRvbWF0aWMgd2lkdGggYW5kIGhlaWdodCBzZXR0aW5ncyBmb3IgbGVmdHBhbmVsICgjdGFiMiwgI3RhYjMpXG4gICAgaWYgKG15ZGl2ID09IFwiI3RhYjNcIikge1xuICAgICAgICB3aWR0aCA9IDAuNyAqICh3aWR0aCAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0KTtcbiAgICAgICAgaGVpZ2h0ID0gMC4zICogKGhlaWdodCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tKTtcbiAgICB9IGVsc2UgaWYgKG15ZGl2ID09IFwiI3NldHhMZWZ0XCIgfHwgbXlkaXY9PVwiI3NldHhMZWZ0VG9wUmlnaHRcIikge1xuICAgICAgICAvL3dpZHRoID0gMjAwO1xuICAgICAgICAvL2hlaWdodCA9IDEyMDtcbiAgICAgICAgd2lkdGg9dHcqLjE4NS1tYXJnaW4ubGVmdC1tYXJnaW4ucmlnaHQ7IC8vcmlnaHRwYW5lbC5leHBhbmQgaXMgNDAgcGVyY2VudCwgc2V0eExlZnQgdG8gNTAgcGVyY2VudCwgdG9nZ2xlIGJhciBpcyAxNnB4LCBwYWRkaW5nLCBpdCdzIGFsbCBhYm91dCAuMTg1XG4gICAgICAgIGhlaWdodD13aWR0aCouNjsgLy9oZWlnaHQgdG8gd2lkdGggaXMgLjZcbiAgICB9IGVsc2Uge1xuICAgICAgICB3aWR0aCA9IDAuMzUgKiAod2lkdGggLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodCk7XG4gICAgICAgIGhlaWdodCA9IDAuMjUgKiAoaGVpZ2h0IC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b20pO1xuICAgIH07XG5cbiAgICBpZiAocHJpdiAmJiBub2RlLnN0YWJpbGl0eUJpbikge1xuICAgICAgICB2YXIgeCA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgICAgICAuZG9tYWluKFttaW5YIC0gMC41LCBtYXhYICsgMS41XSlcbiAgICAgICAgICAgIC5yYW5nZShbMCwgd2lkdGhdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgeCA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgICAgICAuZG9tYWluKFttaW5YIC0gMC41LCBtYXhYICsgMC41XSlcbiAgICAgICAgICAgIC5yYW5nZShbMCwgd2lkdGhdKTtcbiAgICB9XG5cbiAgICB2YXIgaW52eCA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgIC5yYW5nZShbbWluWCAtIDAuNSwgbWF4WCArIDAuNV0pXG4gICAgICAgIC5kb21haW4oWzAsIHdpZHRoXSk7XG5cbiAgICB2YXIgeSA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgIC5kb21haW4oWzAsIG1heFldKVxuICAgICAgICAucmFuZ2UoWzAsIGhlaWdodF0pO1xuXG4gICAgdmFyIHhBeGlzID0gZDMuc3ZnLmF4aXMoKVxuICAgICAgICAuc2NhbGUoeClcbiAgICAgICAgLnRpY2tzKHlWYWxzLmxlbmd0aClcbiAgICAgICAgLm9yaWVudChcImJvdHRvbVwiKTtcblxuICAgIHZhciB5QXhpcyA9IGQzLnN2Zy5heGlzKClcbiAgICAgICAgLnNjYWxlKHkpXG4gICAgICAgIC5vcmllbnQoXCJsZWZ0XCIpO1xuXG4gICAgdmFyIGJydXNoID0gZDMuc3ZnLmJydXNoKClcbiAgICAgICAgLngoeClcbiAgICAgICAgLmV4dGVudCgoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5zdWJzZXRyYW5nZS5sZW5ndGggPT0gMSA/XG4gICAgICAgICAgICAgICAgW25vZGUuc3Vic2V0cmFuZ2VbMF0sIG5vZGUuc3Vic2V0cmFuZ2VbMF1dXG4gICAgICAgICAgICAgICAgOiBub2RlLnN1YnNldHJhbmdlO1xuICAgICAgICB9KVxuICAgICAgICAub24oXCJicnVzaFwiLCBicnVzaGVkKTtcblxuICAgIHZhciBicnVzaDIgPSBkMy5zdmcuYnJ1c2goKVxuICAgICAgICAueCh4KVxuICAgICAgICAub24oXCJicnVzaFwiLCBicnVzaGVkMik7XG5cbiAgICAvLyBDcmVhdGUgU1ZHIGVsZW1lbnRcbiAgICAvLyBjdW1iZXJzb21lIHRvIHRyZWF0IFwidGFiM1wiIGRpZmZlcmVudGx5LCBidXQgd29ya3MgZm9yIG5vd1xuICAgIC8vIHRhYjMsIGhhcyBhbiBpc3N1ZSwgdGhhdCB1bmxlc3Mgd2lkdGggaGVpZ2h0IGhhcmRjb2RlZCwgdGhleSBncm93IHdpdGggZWFjaCBhZGRpdGlvbmFsIGdyYXBoLlxuICAgIGlmIChteWRpdiA9PSBcIiN0YWIzXCIpIHtcbiAgICAgICAgdmFyIHBsb3RzdmcgPSBkMy5zZWxlY3QobXlkaXYpXG4gICAgICAgICAgICAuc2VsZWN0QWxsKFwic3ZnXCIpXG4gICAgICAgICAgICAucmVtb3ZlKCk7XG5cbiAgICAgICAgdmFyIHBsb3RzdmcgPSBkMy5zZWxlY3QobXlkaXYpXG4gICAgICAgICAgICAuYXBwZW5kKFwic3ZnXCIpXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsICgpID0+IG5vZGUubmFtZS50b1N0cmluZygpLmNvbmNhdChteWRpdi5zdWJzdHIoMSkpKVxuICAgICAgICAgICAgLnN0eWxlKFwid2lkdGhcIiwgMzAwKSAvL3NldHRpbmcgaGVpZ2h0IHRvIHRoZSBoZWlnaHQgb2YgI21haW4ubGVmdFxuICAgICAgICAgICAgLnN0eWxlKFwiaGVpZ2h0XCIsIDIwMClcbiAgICAgICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIG1hcmdpbi5sZWZ0ICsgXCIsXCIgKyBtYXJnaW4udG9wICsgXCIpXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwbG90c3ZnID0gZDMuc2VsZWN0KG15ZGl2KVxuICAgICAgICAgICAgLmFwcGVuZChcInN2Z1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgbXluYW1lID0gbm9kZS5uYW1lLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgbXluYW1lID0gbXluYW1lLnJlcGxhY2UoL1xcKHxcXCkvZywgXCJcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG15bmFtZS5jb25jYXQoXCJfXCIsIG15ZGl2LnN1YnN0cigxKSwgXCJfXCIsIG5vZGUuaWQpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5zdHlsZShcIndpZHRoXCIsIHdpZHRoICsgbWFyZ2luLmxlZnQgKyBtYXJnaW4ucmlnaHQpIC8vc2V0dGluZyBoZWlnaHQgdG8gdGhlIGhlaWdodCBvZiAjbWFpbi5sZWZ0XG4gICAgICAgICAgICAuc3R5bGUoXCJoZWlnaHRcIiwgaGVpZ2h0ICsgbWFyZ2luLnRvcCArIG1hcmdpbi5ib3R0b20pXG4gICAgICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBtYXJnaW4ubGVmdCArIFwiLFwiICsgbWFyZ2luLnRvcCArIFwiKVwiKTtcbiAgICB9O1xuXG4gICAgdmFyIHJlY3RXaWR0aCA9IHgobWluWCArIDAuNSAtIDIgKiBiYXJQYWRkaW5nKTsgLy90aGUgXCJ3aWR0aFwiIGlzIHRoZSBjb29yZGluYXRlIG9mIHRoZSBlbmQgb2YgdGhlIGZpcnN0IGJhclxuXG4gICAgcGxvdHN2Zy5zZWxlY3RBbGwoXCJyZWN0XCIpXG4gICAgICAgIC5kYXRhKHlWYWxzKVxuICAgICAgICAuZW50ZXIoKVxuICAgICAgICAuYXBwZW5kKFwicmVjdFwiKVxuICAgICAgICAuYXR0cihcInhcIiwgKGQsIGkpID0+IHgoeFZhbHNbaV0gLSAwLjUgKyBiYXJQYWRkaW5nKSlcbiAgICAgICAgLmF0dHIoXCJ5XCIsIGQgPT4geShtYXhZIC0gZCkpXG4gICAgICAgIC5hdHRyKFwid2lkdGhcIiwgcmVjdFdpZHRoKVxuICAgICAgICAuYXR0cihcImhlaWdodFwiLCB5KVxuICAgICAgICAuYXR0cihcImZpbGxcIiwgXCIjMWY3N2I0XCIpO1xuXG4gICAgLy8gZHJhdyBlcnJvciBiYXJzLCB0aHJlc2hvbGQgbGluZSBhbmQgZXh0cmEgYmluXG4gICAgaWYgKHByaXYpIHtcbiAgICAgICAgaWYgKHlWYWxzLmxlbmd0aCA8PSAyMCkge1xuICAgICAgICAgICAgcGxvdHN2Zy5zZWxlY3RBbGwoXCJsaW5lXCIpXG4gICAgICAgICAgICAgICAgLmRhdGEoY2lVcHBlclZhbHMpXG4gICAgICAgICAgICAgICAgLmVudGVyKClcbiAgICAgICAgICAgICAgICAuYXBwZW5kKFwibGluZVwiKVxuICAgICAgICAgICAgICAgIC5zdHlsZShcInN0cm9rZVwiLCBcImJsYWNrXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ4MVwiLCBmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB4KHhWYWxzW2ldIC0gMC41ICsgYmFyUGFkZGluZykgKyByZWN0V2lkdGggLyAyXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgXHQuYXR0cihcInkxXCIsIGQgPT4geShtYXhZIC0gZCkpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ4MlwiLCBmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB4KHhWYWxzW2ldIC0gMC41ICsgYmFyUGFkZGluZykgKyByZWN0V2lkdGggLyAyXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInkyXCIsIGQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgeTIgPSB5KG1heFkgLSBkICsgY2lTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHkyID49IHkobWF4WSkgPyB5KG1heFkpIDogeTI7XG4gICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvL2RyYXcgdG9wIHRpY2tzIG9uIGVycm9yIGJhcnNcbiAgICAgICAgICAgIC8vbmVlZCB0byBmaXggdGhlIGhlaWdodCBvZiB0aGUgZ3JhcGhzIC0gdGhlIHRvcHMgb2YgZXJyb3IgYmFycyBhcmUgZ2V0dGluZyBjdXQgb2ZmXG4gICAgICAgICAgICBwbG90c3ZnLnNlbGVjdEFsbChcIi50b3BUaWNrXCIpXG4gICAgICAgICAgICAgICAgLmRhdGEoY2lVcHBlclZhbHMpXG4gICAgICAgICAgICAgICAgLmVudGVyKClcbiAgICAgICAgICAgICAgICAuYXBwZW5kKFwibGluZVwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJ0b3BUaWNrXCIpXG4gICAgICAgICAgICAgICAgLnN0eWxlKFwic3Ryb2tlXCIsIFwiYmxhY2tcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcIngxXCIsIGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHlWYWxzLmxlbmd0aCA+IDIwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geCh4VmFsc1tpXSAtIDAuNSArIGJhclBhZGRpbmcpIC8vbWFrZSB0aWNrIGJpZ2dlciB0byBpbmNyZWFzZSB2aXNpYmlsaXR5XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geCh4VmFsc1tpXSAtIDAuNSArIGJhclBhZGRpbmcpICsgMC40ICogcmVjdFdpZHRoXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieTFcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geShtYXhZIC0gZCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuYXR0cihcIngyXCIsIGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHlWYWxzLmxlbmd0aCA+IDIwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geCh4VmFsc1tpXSAtIDAuNSArIGJhclBhZGRpbmcpICsgcmVjdFdpZHRoIC8vbWFrZSB0aWNrIGJpZ2dlciB0byBpbmNyZWFzZSB2aXNpYmlsaXR5XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geCh4VmFsc1tpXSAtIDAuNSArIGJhclBhZGRpbmcpICsgMC42ICogcmVjdFdpZHRoXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieTJcIiwgZCA9PiB5KG1heFkgLSBkKSk7XG5cbiAgICAgICAgICAgIC8vIGRyYXcgYm90dG9tIHRpY2tzIG9mIGVycm9yIGJhcnNcbiAgICAgICAgICAgIHBsb3Rzdmcuc2VsZWN0QWxsKFwiLmJvdHRvbVRpY2tcIilcbiAgICAgICAgICAgICAgICAuZGF0YShjaUxvd2VyVmFscylcbiAgICAgICAgICAgICAgICAuZW50ZXIoKVxuICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJsaW5lXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImJvdHRvbVRpY2tcIilcbiAgICAgICAgICAgICAgICAuc3R5bGUoXCJzdHJva2VcIiwgXCJibGFja1wiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieDFcIiwgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoeVZhbHMubGVuZ3RoID4gMjApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB4KHhWYWxzW2ldIC0gMC41ICsgYmFyUGFkZGluZylcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB4KHhWYWxzW2ldIC0gMC41ICsgYmFyUGFkZGluZykgKyAwLjQgKiByZWN0V2lkdGhcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ5MVwiLCBkID0+IHkobWF4WSAtIGQpKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieDJcIiwgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoeVZhbHMubGVuZ3RoID4gMjApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB4KHhWYWxzW2ldIC0gMC41ICsgYmFyUGFkZGluZykgKyByZWN0V2lkdGhcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB4KHhWYWxzW2ldIC0gMC41ICsgYmFyUGFkZGluZykgKyAwLjYgKiByZWN0V2lkdGhcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ5MlwiLCBkID0+IHkobWF4WSAtIGQpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBsb3Rzdmcuc2VsZWN0QWxsKFwiLmRlbnNlRXJyb3JcIilcbiAgICAgICAgICAgICAgICAuZGF0YSh5VmFscylcbiAgICAgICAgICAgICAgICAuZW50ZXIoKVxuICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJyZWN0XCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImRlbnNlRXJyb3JcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcInhcIiwgKGQsIGkpID0+IHgoeFZhbHNbaV0gLSAwLjUgKyBiYXJQYWRkaW5nKSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInlcIiwgZCA9PiB5KG1heFkgLSBkKSAtIC4xICogeShkKSlcbiAgICAgICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIHJlY3RXaWR0aClcbiAgICAgICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCBkID0+ICh5KG1heFkgLSBkKSArIC4xICogeShkKSkgLSAoeShtYXhZIC0gZCkgLSAuMSAqIHkoZCkpKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiZmlsbFwiLCBcInNpbHZlclwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vaWYgc3RhdGVtZW50IGZvciBzdGFiaWxpdHkgaGlzdG9ncmFtc1xuICAgICAgICAvL2V4dHJhIHN0YWJpbGl0eSBiaW5cbiAgICAgICAgaWYgKG5vZGUuc3RhYmlsaXR5QmluKSB7XG4gICAgICAgICAgICBwbG90c3ZnLmFwcGVuZChcInJlY3RcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcInhcIiwgeChtYXhYICsgMC41IC0gYmFyUGFkZGluZykpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIHkobWF4WSkgLSBub2RlLnN0YWJpbGl0eUJpbilcbiAgICAgICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIHJlY3RXaWR0aClcbiAgICAgICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCBub2RlLnN0YWJpbGl0eUJpbilcbiAgICAgICAgICAgICAgICAuYXR0cihcImZpbGxcIiwgXCJzaWx2ZXJcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvL3RocmVzaG9sZCBsaW5lXG4gICAgICAgIGlmIChub2RlLnRocmVzaG9sZCkge1xuICAgICAgICAgICAgcGxvdHN2Zy5hcHBlbmQoXCJsaW5lXCIpXG4gICAgICAgICAgICAgICAgLnN0eWxlKFwic3Ryb2tlXCIsIFwiYmxhY2tcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcIngxXCIsIHgobWluWCAtIDAuNSArIGJhclBhZGRpbmcpKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieTFcIiwgeShtYXhZKSAtIG5vZGUudGhyZXNob2xkKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieDJcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwic3RhYmlsaXR5QmluXCIpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhub2RlLnN0YWJpbGl0eUJpbik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnN0YWJpbGl0eUJpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHgobWF4WCArIDAuNSAtIGJhclBhZGRpbmcpICsgcmVjdFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHgobWF4WCArIDAuNSAtIGJhclBhZGRpbmcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInkyXCIsIHkobWF4WSkgLSBub2RlLnRocmVzaG9sZClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwbG90WGF4aXMpIHtcbiAgICAgICAgcGxvdHN2Zy5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwieCBheGlzXCIpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLFwiICsgaGVpZ2h0ICsgXCIpXCIpXG4gICAgICAgICAgICAuY2FsbCh4QXhpcyk7XG4gICAgfVxuXG4gICAgcGxvdHN2Zy5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgIC5hdHRyKFwieFwiLCAod2lkdGggLyAyKSlcbiAgICAgICAgLmF0dHIoXCJ5XCIsIDAgLSAobWFyZ2luLnRvcCAvIDIpKVxuICAgICAgICAuYXR0cihcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpXG4gICAgICAgIC5zdHlsZShcImZvbnQtc2l6ZVwiLCBcIjEycHhcIilcbiAgICAgICAgLnRleHQobm9kZS5uYW1lKTtcblxuICAgIGlmIChteWRpdiA9PSBcIiNzZXR4TGVmdFwiIHx8IG15ZGl2PT1cIiNzZXR4TGVmdFRvcFJpZ2h0XCIpIHtcbiAgICAgICAgcGxvdHN2Zy5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsIFwicmFuZ2VcIikgLy8gYmFkIHByYWN0aWNlLCBub3QgdW5pcXVlXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCd4dmFsJylcbiAgICAgICAgICAgIC5hdHRyKFwieFwiLCAyNSlcbiAgICAgICAgICAgIC5hdHRyKFwieVwiLCBoZWlnaHQgKyA0MClcbiAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLm5hdHVyZSA9PT0gXCJub21pbmFsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBNYXRoLnJvdW5kKHlWYWxLZXkubGVuZ3RoIC8gMikgLSAxO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbXljZWxsID0gbm9kZS5uYW1lK1wiRnJvbVwiOyAvLyBoYXJkY29kZWQgaGVyZVxuICAgICAgICAgICAgICAgICAgICBpZihkb2N1bWVudC5nZXRFbGVtZW50QnlJZChteWNlbGwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChteWNlbGwpLmlubmVyVGV4dD15VmFsS2V5W3RdLng7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcIng6IFwiICsgeVZhbEtleVt0XS54KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbXljZWxsID0gbm9kZS5uYW1lK1wiRnJvbVwiOyAvLyBoYXJkY29kZWQgaGVyZVxuICAgICAgICAgICAgICAgICAgICBpZihkb2N1bWVudC5nZXRFbGVtZW50QnlJZChteWNlbGwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChteWNlbGwpLmlubmVyVGV4dD0oK25vZGUubWVhbikudG9QcmVjaXNpb24oNCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFwieDogXCIuY29uY2F0KCgrbm9kZS5tZWFuKS50b1ByZWNpc2lvbig0KS50b1N0cmluZygpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgcGxvdHN2Zy5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsIFwicmFuZ2UyXCIpIC8vYmFkIHByYWN0aWNlLCBub3QgdW5pcXVlXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCd4MXZhbCcpXG4gICAgICAgICAgICAuYXR0cihcInhcIiwgMjUpXG4gICAgICAgICAgICAuYXR0cihcInlcIiwgaGVpZ2h0ICsgNTApXG4gICAgICAgICAgICAudGV4dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5uYXR1cmUgPT09IFwibm9taW5hbFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gTWF0aC5yb3VuZCh5VmFsS2V5Lmxlbmd0aCAvIDIpIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcIngxOiBcIiArIHlWYWxLZXlbdF0ueCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcIngxOiBcIi5jb25jYXQoKCtub2RlLm1lYW4pLnRvUHJlY2lzaW9uKDQpLnRvU3RyaW5nKCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAvLyBjcmVhdGUgdGljayBtYXJrcyBhdCBhbGwgenNjb3JlcyBpbiB0aGUgYm91bmRzIG9mIHRoZSBkYXRhXG4gICAgICAgIHZhciBsaW5lRnVuY3Rpb24gPSBkMy5zdmcubGluZSgpXG4gICAgICAgICAgICAueChkID0+IGQueClcbiAgICAgICAgICAgIC55KGQgPT4gZC55KVxuICAgICAgICAgICAgLmludGVycG9sYXRlKFwibGluZWFyXCIpO1xuXG4gICAgICAgIHZhciBjb2xTZXEgPSBbXCIjQTJDRDVBXCIsIFwib3JhbmdlXCIsIFwicmVkXCJdOyAvLyB3aWxsIGN5Y2xlIHRocm91Z2ggY29sb3Igc2VxdWVuY2UsIGFuZCB0aGVuIHJlcGVhdCBsYXN0IGNvbG9yXG4gICAgICAgIHZhciBsaW5lRGF0YSA9IG5ldyBBcnJheTtcblxuICAgICAgICB2YXIgekxvd2VyID0gLTEgKiAobWluWCAtIG5vZGUubWVhbikgLyBub2RlLnNkOyAvLyB6c2NvcmUgb2YgbG93ZXIgYm91bmRcbiAgICAgICAgdmFyIHpVcHBlciA9IChtYXhYIC0gbm9kZS5tZWFuKSAvIG5vZGUuc2Q7IC8vIHpzY29yZSBvZiB1cHBlciBib3VuZFxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgelVwcGVyOyBpKyspIHtcbiAgICAgICAgICAgIGxpbmVEYXRhID0gW3tcbiAgICAgICAgICAgICAgICBcInhcIjogeCgrbm9kZS5tZWFuICsgaSAqIG5vZGUuc2QpLFxuICAgICAgICAgICAgICAgIFwieVwiOiBoZWlnaHQgKiAuN1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIFwieFwiOiB4KCtub2RlLm1lYW4gKyBpICogbm9kZS5zZCksXG4gICAgICAgICAgICAgICAgXCJ5XCI6IGhlaWdodCAqIC45XG4gICAgICAgICAgICB9XTtcbiAgICAgICAgICAgIHBsb3RzdmcuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiZFwiLCBsaW5lRnVuY3Rpb24oW2xpbmVEYXRhWzBdLCBsaW5lRGF0YVsxXV0pKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwic3Ryb2tlXCIsIGNvbFNlcVtkMy5taW4oW2ksIGNvbFNlcS5sZW5ndGggLSAxXSldKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwic3Ryb2tlLXdpZHRoXCIsIDEuNSlcbiAgICAgICAgICAgICAgICAuYXR0cihcImZpbGxcIiwgXCJub25lXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB6TG93ZXI7IGkrKykge1xuICAgICAgICAgICAgbGluZURhdGEgPSBbe1xuICAgICAgICAgICAgICAgIFwieFwiOiB4KCtub2RlLm1lYW4gLSBpICogbm9kZS5zZCksXG4gICAgICAgICAgICAgICAgXCJ5XCI6IGhlaWdodCAqIC43XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgXCJ4XCI6IHgoK25vZGUubWVhbiAtIGkgKiBub2RlLnNkKSxcbiAgICAgICAgICAgICAgICBcInlcIjogaGVpZ2h0ICogLjlcbiAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgcGxvdHN2Zy5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJkXCIsIGxpbmVGdW5jdGlvbihbbGluZURhdGFbMF0sIGxpbmVEYXRhWzFdXSkpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJzdHJva2VcIiwgY29sU2VxW2QzLm1pbihbaSwgY29sU2VxLmxlbmd0aCAtIDFdKV0pXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJzdHJva2Utd2lkdGhcIiwgMS41KVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiZmlsbFwiLCBcIm5vbmVcIik7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gZDMubWluKHhWYWxzKTsgaSA8PSBkMy5tYXgoeFZhbHMpOyBpKyspIHtcbiAgICAgICAgICAgIGxpbmVEYXRhID0gW3tcbiAgICAgICAgICAgICAgICBcInhcIjogeChpKSxcbiAgICAgICAgICAgICAgICBcInlcIjogaGVpZ2h0ICogLjc1XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgXCJ4XCI6IHgoaSksXG4gICAgICAgICAgICAgICAgXCJ5XCI6IGhlaWdodCAqIC44NVxuICAgICAgICAgICAgfV07XG4gICAgICAgICAgICBwbG90c3ZnLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImRcIiwgbGluZUZ1bmN0aW9uKFtsaW5lRGF0YVswXSwgbGluZURhdGFbMV1dKSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInN0cm9rZVwiLCBcImJsYWNrXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJzdHJva2Utd2lkdGhcIiwgMSlcbiAgICAgICAgICAgICAgICAuYXR0cihcImZpbGxcIiwgXCJub25lXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaW5pdGlhbGl6ZSBzbGlkZXIgY29tcG9uZW50c1xuICAgICAgICB2YXIgc2xpZGVCb3ggPSBwbG90c3ZnLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJ4IGF4aXNcIilcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsXCIgKyBoZWlnaHQgKiAuOCArIFwiKVwiKVxuICAgICAgICAgICAgLmNhbGwoZDMuc3ZnLmF4aXMoKVxuICAgICAgICAgICAgICAgICAgLnNjYWxlKHgpXG4gICAgICAgICAgICAgICAgICAudGlja3MoMClcbiAgICAgICAgICAgICAgICAgIC5vcmllbnQoXCJib3R0b21cIikpO1xuXG4gICAgICAgIHZhciBzbGlkZXIgPSBwbG90c3ZnLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJzbGlkZXJcIilcbiAgICAgICAgICAgIC5jYWxsKGJydXNoKTtcbiAgICAgICAgdmFyIHNsaWRlcjIgPSBwbG90c3ZnLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJzbGlkZXJcIilcbiAgICAgICAgICAgIC5jYWxsKGJydXNoMik7XG5cbiAgICAgICAgbGV0IHBvaW50cyA9IGkgPT4gZCA9PiB7XG4gICAgICAgICAgICBsZXQgeG5tLCBzID0gNjtcbiAgICAgICAgICAgIGlmIChub2RlLnNldHh2YWxzW2ldID09ICcnKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgbm9taW5hbCwgdXNlIHRoZSBtZWRpYW4gZnJlcXVlbmN5IGFzIHRoZSBwb3NpdGlvbiBmb3IgdGhlIHNldHggc2xpZGVyXG4gICAgICAgICAgICAgICAgeG5tID0gbm9kZS5uYXR1cmUgPT0gJ25vbWluYWwnID8geChNYXRoLnJvdW5kKHhWYWxzLmxlbmd0aCAvIDIpIC0gMSkgOiB4KG5vZGUubWVhbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHhubSA9IHgobm9kZS5zZXR4dmFsc1tpXSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGAke3hubSAtIHN9LCR7LXN9ICR7eG5tICsgc30sJHstc30gJHt4bm19LCR7cyAqIDEuM31gO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgaGFuZGxlID0gc2xpZGVyLmFwcGVuZChcInBvbHlnb25cIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJoYW5kbGVcIilcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsXCIgKyBoZWlnaHQgKiAuNyArIFwiKVwiKVxuICAgICAgICAgICAgLmF0dHIoXCJwb2ludHNcIiwgcG9pbnRzKDApKTtcbiAgICAgICAgdmFyIGhhbmRsZTIgPSBzbGlkZXIyLmFwcGVuZChcInBvbHlnb25cIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJoYW5kbGVcIilcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsXCIgKyBoZWlnaHQgKiAuOSArIFwiKVwiKVxuICAgICAgICAgICAgLmF0dHIoXCJwb2ludHNcIiwgcG9pbnRzKDEpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0d29TRih4KSB7XG4gICAgICAgIHZhciB0c2YgPSBkMy5mb3JtYXQoXCIuMnJcIik7IC8vIGZvcm1hdCB0byB0d28gc2lnbmlmaWNhbnQgZmlndXJlcyBhZnRlciB0aGUgZGVjaW1hbCBwbGFjZVxuICAgICAgICByZXR1cm4gdHNmKHgpLnJlcGxhY2UoLzArJC8sIFwiXCIpLnJlcGxhY2UoL1xcLiQvLCBcIlwiKTsgLy8gdHJpbSB0cmFpbGluZyB6ZXJvcyBhZnRlciBhIHBlcmlvZCwgYW5kIGFueSBvcnBoYW5lZCBwZXJpb2RcbiAgICB9XG5cbiAgICAvLyBicnVzaGluZyBmdW5jdGlvbnNcbiAgICBmdW5jdGlvbiBicnVzaGVkKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBicnVzaC5leHRlbnQoKVswXTtcbiAgICAgICAgdmFyIHMgPSA2O1xuXG4gICAgICAgIGlmIChkMy5ldmVudC5zb3VyY2VFdmVudCkge1xuICAgICAgICAgICAgdmFsdWUgPSB4LmludmVydChkMy5tb3VzZSh0aGlzKVswXSk7XG4gICAgICAgICAgICBicnVzaC5leHRlbnQoW3ZhbHVlLCB2YWx1ZV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0IHggcG9zaXRpb24gb2Ygc2xpZGVyIGNlbnRlclxuICAgICAgICB2YXIgeHBvcyA9IHgodmFsdWUpO1xuICAgICAgICBpZiAodmFsdWUgPiBtYXhYKSB7IC8vIGRyYWdnZWQgcGFzdCBtYXhcbiAgICAgICAgICAgIHhwb3MgPSB4KG1heFgpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlIDwgbWluWCkgeyAvLyBkcmFnZ2VkIHBhc3QgbWluXG4gICAgICAgICAgICB4cG9zID0geChtaW5YKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBtID0gK25vZGUubWVhbjtcbiAgICAgICAgICAgIHZhciBzZCA9ICtub2RlLnNkO1xuICAgICAgICAgICAgdmFyIHpTY29yZSA9ICh2YWx1ZSAtIG0pIC8gc2Q7IC8vIHotc2NvcmVcbiAgICAgICAgICAgIHZhciB6Um91bmQgPSBNYXRoLnJvdW5kKHpTY29yZSk7IC8vIG5lYXJlc3QgaW50ZWdlciB6LXNjb3JlXG4gICAgICAgICAgICBpZiAoLjEgPiBNYXRoLmFicyhNYXRoLnJvdW5kKHZhbHVlKSAtIHZhbHVlKSkgeyAvLyBzbmFwIHRvIGludGVnZXJcbiAgICAgICAgICAgICAgICB4cG9zID0geChNYXRoLnJvdW5kKHZhbHVlKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKC4xID4gTWF0aC5hYnMoelJvdW5kIC0gelNjb3JlKSkgeyAvLyBzbmFwIHRvIGludGVnZXIgei1zY29yZVxuICAgICAgICAgICAgICAgIHhwb3MgPSB4KG0gKyAoelJvdW5kICogc2QpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNyZWF0ZSBzbGlkZXIgc3ltYm9sIGFuZCB0ZXh0XG4gICAgICAgIGhhbmRsZS5hdHRyKFwicG9pbnRzXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHJldHVybiAoeHBvcyAtIHMpICsgXCIsXCIgKyAoLXMpICsgXCIgXCIgKyAoeHBvcyArIHMpICsgXCIsXCIgKyAoLXMpICsgXCIgXCIgKyB4cG9zICsgXCIsXCIgKyAocyAqIDEuMyk7XG4gICAgICAgIH0pO1xuICAgICAgICBwbG90c3ZnLnNlbGVjdChcInRleHQjcmFuZ2VcIilcbiAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLm5hdHVyZSA9PT0gXCJub21pbmFsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG15Y2VsbCA9IG5vZGUubmFtZStcIkZyb21cIjsgLy8gaGFyZGNvZGVkIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgaWYoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobXljZWxsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobXljZWxsKS5pbm5lclRleHQ9eVZhbEtleVtNYXRoLnJvdW5kKGludngoeHBvcykpXS54O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoXCJ4OiBcIiArIHlWYWxLZXlbTWF0aC5yb3VuZChpbnZ4KHhwb3MpKV0ueCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG15Y2VsbCA9IG5vZGUubmFtZStcIkZyb21cIjsgLy8gaGFyZGNvZGVkIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgaWYoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobXljZWxsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobXljZWxsKS5pbm5lclRleHQ9KyhpbnZ4KHhwb3MpKS50b1ByZWNpc2lvbig0KS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoXCJ4OiBcIi5jb25jYXQoKyhpbnZ4KHhwb3MpKS50b1ByZWNpc2lvbig0KS50b1N0cmluZygpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIG5vZGUuc2V0eHZhbHNbMF0gPSArKGludngoeHBvcykpLnRvUHJlY2lzaW9uKDQpO1xuICAgIH1cblxuICAgIC8vIGNlcnRhaW5seSBhIG1vcmUgY2xldmVyIHdheSB0byBkbyB0aGlzLCBidXQgZm9yIG5vdyBpdCdzIGJhc2ljYWxseSBjb3BpZWQgd2l0aCBicnVzaCBhbmQgaGFuZGxlIGNoYW5nZXMgdG8gYnJ1c2gyIGFuZCBoYW5kbGUyIGFuZCAjcmFuZ2UgdG8gI3JhbmdlMiBhbmQgc2V0eHZhbHNbMF0gdG8gc2V0eHZhbHNbMV1cbiAgICBmdW5jdGlvbiBicnVzaGVkMigpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYnJ1c2gyLmV4dGVudCgpWzBdO1xuICAgICAgICB2YXIgcyA9IDY7IC8vIHNjYWxpbmcgZm9yIHRyaWFuZ2xlIHNoYXBlXG5cbiAgICAgICAgaWYgKGQzLmV2ZW50LnNvdXJjZUV2ZW50KSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHguaW52ZXJ0KGQzLm1vdXNlKHRoaXMpWzBdKTtcbiAgICAgICAgICAgIGJydXNoMi5leHRlbnQoW3ZhbHVlLCB2YWx1ZV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0IHggcG9zaXRpb24gb2Ygc2xpZGVyIGNlbnRlclxuICAgICAgICB2YXIgeHBvcyA9IHgodmFsdWUpO1xuICAgICAgICBpZiAodmFsdWUgPiBtYXhYKSB7IC8vIGRyYWdnZWQgcGFzdCBtYXhcbiAgICAgICAgICAgIHhwb3MgPSB4KG1heFgpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlIDwgbWluWCkgeyAvLyBkcmFnZ2VkIHBhc3QgbWluXG4gICAgICAgICAgICB4cG9zID0geChtaW5YKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBtID0gK25vZGUubWVhbjtcbiAgICAgICAgICAgIHZhciBzZCA9ICtub2RlLnNkO1xuICAgICAgICAgICAgdmFyIHpTY29yZSA9ICh2YWx1ZSAtIG0pIC8gc2Q7IC8vIHotc2NvcmVcbiAgICAgICAgICAgIHZhciB6Um91bmQgPSBNYXRoLnJvdW5kKHpTY29yZSk7IC8vIG5lYXJlc3QgaW50ZWdlciB6LXNjb3JlXG4gICAgICAgICAgICBpZiAoLjEgPiBNYXRoLmFicyhNYXRoLnJvdW5kKHZhbHVlKSAtIHZhbHVlKSkgeyAvLyBzbmFwIHRvIGludGVnZXJcbiAgICAgICAgICAgICAgICB4cG9zID0geChNYXRoLnJvdW5kKHZhbHVlKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKC4xID4gTWF0aC5hYnMoelJvdW5kIC0gelNjb3JlKSkgeyAvLyBzbmFwIHRvIGludGVnZXIgei1zY29yZVxuICAgICAgICAgICAgICAgIHhwb3MgPSB4KG0gKyAoelJvdW5kICogc2QpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNyZWF0ZSBzbGlkZXIgc3ltYm9sIGFuZCB0ZXh0XG4gICAgICAgIGhhbmRsZTIuYXR0cihcInBvaW50c1wiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICByZXR1cm4gKHhwb3MgLSBzKSArIFwiLFwiICsgcyArIFwiIFwiICsgKHhwb3MgKyBzKSArIFwiLFwiICsgcyArIFwiIFwiICsgeHBvcyArIFwiLFwiICsgKC1zICogMS4zKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHBsb3Rzdmcuc2VsZWN0KFwidGV4dCNyYW5nZTJcIilcbiAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLm5hdHVyZSA9PT0gXCJub21pbmFsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG15Y2VsbCA9IG5vZGUubmFtZStcIlRvXCI7IC8vIGhhcmRjb2RlZCBoZXJlXG4gICAgICAgICAgICAgICAgICAgIGlmKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG15Y2VsbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG15Y2VsbCkuaW5uZXJUZXh0PXlWYWxLZXlbTWF0aC5yb3VuZChpbnZ4KHhwb3MpKV0ueDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFwieDE6IFwiICsgeVZhbEtleVtNYXRoLnJvdW5kKGludngoeHBvcykpXS54KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbXljZWxsID0gbm9kZS5uYW1lK1wiVG9cIjsgLy8gaGFyZGNvZGVkIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgaWYoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobXljZWxsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobXljZWxsKS5pbm5lclRleHQ9KyhpbnZ4KHhwb3MpKS50b1ByZWNpc2lvbig0KS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoXCJ4MTogXCIuY29uY2F0KCsoaW52eCh4cG9zKSkudG9QcmVjaXNpb24oNCkudG9TdHJpbmcoKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBub2RlLnNldHh2YWxzWzFdID0gKyhpbnZ4KHhwb3MpKS50b1ByZWNpc2lvbig0KTtcbiAgICB9XG59XG5cbi8vIGRyYXdzIGJhcnBsb3RzIGluIHN1YnNldCB0YWJcbmV4cG9ydCBmdW5jdGlvbiBiYXJzU3Vic2V0KG5vZGUpIHtcbiAgICAvLyBpZiB1bnRvdWNoZWQsIHNldCBub2RlLnN1YnNldHJhbmdlIHRvIGFuIGVtcHR5IGFycmF5LCBtZWFuaW5nIGFsbCB2YWx1ZXMgc2VsZWN0ZWQgYnkgZGVmYXVsdFxuICAgIGlmIChub2RlLnN1YnNldHJhbmdlWzBdID09IFwiXCIgJiBub2RlLnN1YnNldHJhbmdlWzFdID09IFwiXCIpIHtcbiAgICAgICAgbm9kZS5zdWJzZXRyYW5nZSA9IFtdO1xuICAgIH1cblxuICAgIC8vIEhpc3RvZ3JhbSBzcGFjaW5nXG4gICAgdmFyIGJhclBhZGRpbmcgPSAuMDE1OyAvLyBTcGFjZSBiZXR3ZWVuIGJhcnNcbiAgICB2YXIgdG9wU2NhbGUgPSAxLjI7IC8vIE11bHRpcGxpY2F0aXZlIGZhY3RvciB0byBhc3NpZ24gc3BhY2UgYXQgdG9wIHdpdGhpbiBncmFwaCAtIGN1cnJlbnRseSByZW1vdmVkIGZyb20gaW1wbGVtZW50YXRpb25cbiAgICB2YXIgcGxvdFhheGlzID0gdHJ1ZTtcblxuICAgIC8vIFZhcmlhYmxlIG5hbWVcbiAgICB2YXIgbXluYW1lID0gbm9kZS5uYW1lLnRvU3RyaW5nKCk7XG4gICAgbXluYW1lID0gbXluYW1lLnJlcGxhY2UoL1xcKHxcXCkvZywgXCJcIik7XG5cbiAgICAvLyBEYXRhXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhub2RlLnBsb3R2YWx1ZXMpO1xuICAgIHZhciB5VmFscyA9IG5ldyBBcnJheTtcbiAgICB2YXIgeFZhbHMgPSBuZXcgQXJyYXk7XG4gICAgdmFyIHlWYWxLZXkgPSBuZXcgQXJyYXk7XG5cbiAgICB2YXIgeGkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAobm9kZS5wbG90dmFsdWVzW2tleXNbaV1dID09IDApXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgeVZhbHNbeGldID0gbm9kZS5wbG90dmFsdWVzW2tleXNbaV1dO1xuICAgICAgICB4VmFsc1t4aV0gPSB4aTtcbiAgICAgICAgeVZhbEtleS5wdXNoKHtcbiAgICAgICAgICAgIHk6IHlWYWxzW3hpXSxcbiAgICAgICAgICAgIHg6IGtleXNbaV1cbiAgICAgICAgfSk7XG4gICAgICAgIHhpID0geGkgKyAxO1xuICAgIH1cbiAgICBpZiAobm9kZS5uYXR1cmUgPT09IFwibm9taW5hbFwiKSB7IC8vIGlmIG5vbWluYWwsIG9yZGVycyBiYXJzIGxlZnQgdG8gcmlnaHQsIGhpZ2hlc3QgZnJlcXVlbmN5IHRvIGxvd2VzdFxuICAgICAgICB5VmFsS2V5LnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGIueSAtIGEueVxuICAgICAgICB9KTsgLy8gYXJyYXkgb2Ygb2JqZWN0cywgZWFjaCBvYmplY3QgaGFzIHksIHRoZSBzYW1lIGFzIHlWYWxzLCBhbmQgeCwgdGhlIGNhdGVnb3J5XG4gICAgICAgIHlWYWxzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGIgLSBhXG4gICAgICAgIH0pOyAvLyBhcnJheSBvZiB5IHZhbHVlcywgdGhlIGhlaWdodCBvZiB0aGUgYmFyc1xuICAgIH1cblxuICAgIHBsb3RYYXhpcyA9IGZhbHNlO1xuXG4gICAgdmFyIG1heFkgPSBkMy5tYXgoeVZhbHMpO1xuICAgIHZhciBtaW5YID0gZDMubWluKHhWYWxzKTtcbiAgICB2YXIgbWF4WCA9IGQzLm1heCh4VmFscyk7XG4gICAgdmFyIGduYW1lID0gW1wic3Vic2V0eWVzXCIsIFwic3Vic2V0bm9cIl07XG5cbiAgICB2YXIgeVZhbHMyID0gW107XG4gICAgdmFyIHlWYWxzMSA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCB5VmFscy5sZW5ndGg7IGkrKykge1xuICAgICAgICB5VmFsczEucHVzaCh7XG4gICAgICAgICAgICB5MDogbWF4WSAtIHlWYWxzW2ldLFxuICAgICAgICAgICAgeTE6IHlWYWxzW2ldLFxuICAgICAgICAgICAgY29sOiBkM0NvbG9yXG4gICAgICAgIH0pO1xuICAgICAgICB5VmFsczIucHVzaCh7XG4gICAgICAgICAgICB5MDogMCxcbiAgICAgICAgICAgIHkxOiBtYXhZIC0geVZhbHNbaV0sXG4gICAgICAgICAgICBjb2w6IFwidHJhbnNwYXJlbnRcIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmFyIGZyZXFzID0gW3lWYWxzMSwgeVZhbHMyXTtcblxuICAgIC8vIHkwIGlzIHRoZSBzdGFydGluZyBwb2ludFxuICAgIC8vIHkxIGlzIHRoZSBsZW5ndGggb2YgdGhlIGJhclxuXG4gICAgdmFyIG15ZGl2ID0gXCIjdGFiMlwiO1xuICAgIHZhciB3aWR0aCA9IDIwMDtcbiAgICB2YXIgaGVpZ2h0ID0gMTIwO1xuICAgIHZhciBtYXJnaW4gPSB7XG4gICAgICAgIHRvcDogMjAsXG4gICAgICAgIHJpZ2h0OiAyMCxcbiAgICAgICAgYm90dG9tOiA1MyxcbiAgICAgICAgbGVmdDogNTBcbiAgICB9O1xuXG4gICAgdmFyIHggPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAuZG9tYWluKFttaW5YIC0gMC41LCBtYXhYICsgMC41XSlcbiAgICAgICAgLnJhbmdlKFswLCB3aWR0aF0pO1xuXG4gICAgdmFyIGludnggPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAucmFuZ2UoW21pblggLSAwLjUsIG1heFggKyAwLjVdKVxuICAgICAgICAuZG9tYWluKFswLCB3aWR0aF0pO1xuXG4gICAgdmFyIHkgPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAuZG9tYWluKFswLCBtYXhZXSlcbiAgICAgICAgLnJhbmdlKFswLCBoZWlnaHRdKTtcblxuICAgIHZhciB4QXhpcyA9IGQzLnN2Zy5heGlzKClcbiAgICAgICAgLnNjYWxlKHgpXG4gICAgICAgIC50aWNrcyh5VmFscy5sZW5ndGgpXG4gICAgICAgIC5vcmllbnQoXCJib3R0b21cIik7XG5cbiAgICB2YXIgeUF4aXMgPSBkMy5zdmcuYXhpcygpXG4gICAgICAgIC5zY2FsZSh5KVxuICAgICAgICAub3JpZW50KFwibGVmdFwiKTtcblxuICAgIC8vQ3JlYXRlIFNWRyBlbGVtZW50XG4gICAgdmFyIHBsb3RzdmcgPSBkMy5zZWxlY3QobXlkaXYpXG4gICAgICAgIC5hcHBlbmQoXCJzdmdcIilcbiAgICAgICAgLmF0dHIoXCJpZFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBteW5hbWUuY29uY2F0KFwiX1wiLCBteWRpdi5zdWJzdHIoMSksIFwiX1wiLCBub2RlLmlkKTtcbiAgICAgICAgfSlcbiAgICAgICAgLnN0eWxlKFwid2lkdGhcIiwgd2lkdGggKyBtYXJnaW4ubGVmdCArIG1hcmdpbi5yaWdodCkgLy9zZXR0aW5nIGhlaWdodCB0byB0aGUgaGVpZ2h0IG9mICNtYWluLmxlZnRcbiAgICAgICAgLnN0eWxlKFwiaGVpZ2h0XCIsIGhlaWdodCArIG1hcmdpbi50b3AgKyBtYXJnaW4uYm90dG9tKVxuICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIG1hcmdpbi5sZWZ0ICsgXCIsXCIgKyBtYXJnaW4udG9wICsgXCIpXCIpO1xuXG4gICAgdmFyIGZyZXEgPSBwbG90c3ZnLnNlbGVjdEFsbChcImcuZnJlcVwiKVxuICAgICAgICAuZGF0YShmcmVxcylcbiAgICAgICAgLmVudGVyKCkuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiZnJlcVwiKVxuICAgICAgICAuYXR0cihcIm5hbWVcIiwgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIG15bmFtZS5jb25jYXQoZ25hbWVbaV0pO1xuICAgICAgICB9KTtcblxuICAgIHZhciByZWN0ID0gZnJlcS5zZWxlY3RBbGwoXCJyZWN0XCIpXG4gICAgICAgIC5kYXRhKE9iamVjdClcbiAgICAgICAgLmVudGVyKCkuYXBwZW5kKFwicmVjdFwiKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiYmFyXCIpXG4gICAgICAgIC5hdHRyKFwibmFtZVwiLCBmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4geFZhbHNbaV07XG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKFwieFwiLCBmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4geCh4VmFsc1tpXSAtIDAuNSArIGJhclBhZGRpbmcpO1xuICAgICAgICB9KVxuICAgICAgICAuYXR0cihcInlcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgcmV0dXJuIHkoZC55MCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKFwid2lkdGhcIiwgeChtaW5YICsgMC41IC0gMiAqIGJhclBhZGRpbmcpKSAvLyB0aGUgXCJ3aWR0aFwiIGlzIHRoZSBjb29yZGluYXRlIG9mIHRoZSBlbmQgb2YgdGhlIGZpcnN0IGJhclxuICAgICAgICAuYXR0cihcImhlaWdodFwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICByZXR1cm4geShkLnkxKTtcbiAgICAgICAgfSlcbiAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5zdWJzZXRyYW5nZS5sZW5ndGggPiAwICYgZC5jb2wgPT09IGQzQ29sb3IgJiAkLmluQXJyYXkoeFZhbHNbaV0udG9TdHJpbmcoKSwgbm9kZS5zdWJzZXRyYW5nZSkgPiAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxWYXJDb2xvcjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGQuY29sO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAub24oXCJjbGlja1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RNZSA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgc2VsZWN0TmFtZSA9IHRoaXMuZ2V0QXR0cmlidXRlKFwibmFtZVwiKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudE5vZGUuZ2V0QXR0cmlidXRlKFwibmFtZVwiKSA9PSBteW5hbWUuY29uY2F0KFwic3Vic2V0bm9cIikpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RNZSA9ICQoJ1tuYW1lPVwiJyArIG15bmFtZS5jb25jYXQoXCJzdWJzZXR5ZXNcIikgKyAnXCJdJykuY2hpbGRyZW4oJ1tuYW1lPVwiJyArIHNlbGVjdE5hbWUgKyAnXCJdJylbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkMy5zZWxlY3Qoc2VsZWN0TWUpXG4gICAgICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBteUNvbCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0eWxlLmZpbGwgPT09IHNlbFZhckNvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbXlpbmRleCA9IG5vZGUuc3Vic2V0cmFuZ2UuaW5kZXhPZih0aGlzLmdldEF0dHJpYnV0ZShcIm5hbWVcIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5zdWJzZXRyYW5nZS5zcGxpY2UobXlpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBteUNvbCA9IGQzQ29sb3I7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnN1YnNldHJhbmdlLnB1c2godGhpcy5nZXRBdHRyaWJ1dGUoXCJuYW1lXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG15Q29sID0gc2VsVmFyQ29sb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG15Q29sO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcGxvdHN2Zy5zZWxlY3QoXCJ0ZXh0I3NlbGVjdHJhbmdlXCIpXG4gICAgICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnN1YnNldHJhbmdlLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFwiU2VsZWN0ZWQ6IGFsbCB2YWx1ZXNcIik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IG5vZGUuc3Vic2V0cmFuZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZWN0ZWRzID0gbmV3IEFycmF5O1xuICAgICAgICAgICAgICAgICAgICAgICAgYS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkcy5wdXNoKHlWYWxLZXlbdmFsXS54KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFwiU2VsZWN0ZWQ6IFwiICsgc2VsZWN0ZWRzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0pXG4gICAgICAgIC5vbihcIm1vdXNlb3ZlclwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpID0gdGhpcy5nZXRBdHRyaWJ1dGUoXCJuYW1lXCIpO1xuICAgICAgICAgICAgcGxvdHN2Zy5zZWxlY3QoXCJ0ZXh0I215bW91c2VvdmVyXCIpXG4gICAgICAgICAgICAgICAgLnRleHQoKCkgPT4geVZhbEtleVtpXS54ICsgXCI6IFwiICsgeVZhbEtleVtpXS55KTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKFwibW91c2VvdXRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaSA9IHRoaXMuZ2V0QXR0cmlidXRlKFwibmFtZVwiKTtcbiAgICAgICAgICAgIHBsb3Rzdmcuc2VsZWN0KFwidGV4dCNteW1vdXNlb3ZlclwiKVxuICAgICAgICAgICAgICAgIC50ZXh0KCgpID0+IFwiVmFsdWU6IEZyZXF1ZW5jeVwiKTtcbiAgICAgICAgfSk7XG5cbiAgICBpZiAocGxvdFhheGlzKSB7XG4gICAgICAgIHBsb3RzdmcuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInggYXhpc1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCxcIiArIGhlaWdodCArIFwiKVwiKVxuICAgICAgICAgICAgLmNhbGwoeEF4aXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHBsb3RzdmcuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBcIm15bW91c2VvdmVyXCIpXG4gICAgICAgICAgICAuYXR0cihcInhcIiwgMjUpXG4gICAgICAgICAgICAuYXR0cihcInlcIiwgaGVpZ2h0ICsgMjApXG4gICAgICAgICAgICAudGV4dCgoKSA9PiBcIlZhbHVlOiBGcmVxdWVuY3lcIik7XG4gICAgfVxuXG4gICAgcGxvdHN2Zy5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgIC5hdHRyKFwieFwiLCAod2lkdGggLyAyKSlcbiAgICAgICAgLmF0dHIoXCJ5XCIsIDAgLSAobWFyZ2luLnRvcCAvIDIpKVxuICAgICAgICAuYXR0cihcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpXG4gICAgICAgIC5zdHlsZShcImZvbnQtc2l6ZVwiLCBcIjEycHhcIilcbiAgICAgICAgLnRleHQobXluYW1lKTtcblxuICAgIHBsb3RzdmcuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAuYXR0cihcImlkXCIsIFwic2VsZWN0cmFuZ2VcIilcbiAgICAgICAgLmF0dHIoXCJ4XCIsIDI1KVxuICAgICAgICAuYXR0cihcInlcIiwgaGVpZ2h0ICsgNDApXG4gICAgICAgIC50ZXh0KCgpID0+IHtcbiAgICAgICAgICAgIGlmIChub2RlLnN1YnNldHJhbmdlLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBcIlNlbGVjdGVkOiBhbGwgdmFsdWVzXCI7XG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWRzID0gbmV3IEFycmF5O1xuICAgICAgICAgICAgbm9kZS5zdWJzZXRyYW5nZS5mb3JFYWNoKHZhbCA9PiAgc2VsZWN0ZWRzLnB1c2goeVZhbEtleVt2YWxdLngpKTtcbiAgICAgICAgICAgIHJldHVybiBcIlNlbGVjdGVkOiBcIiArIHNlbGVjdGVkcztcbiAgICAgICAgfSk7XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGRlbnNpdHlOb2RlKG5vZGUsIG9iaikge1xuICAgIHZhciBteW5hbWUgPSBub2RlLm5hbWUudG9TdHJpbmcoKS5jb25jYXQoXCJub2RlcGxvdFwiKTtcblxuICAgIGlmICh0eXBlb2Ygb2JqID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHZhciBvYmogPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChub2RlLm5hbWUudG9TdHJpbmcoKSArIFwiYmlnZ3JvdXBcIik7XG4gICAgICAgIC8vIGlmIG9iaiBjb250YWlucyBhbiBzdmcgZWxlbWVudCwgcmVtb3ZlIGl0LiB0aGlzIHJlbW92ZXMgYW55IHBsb3QgaW5zaWRlIHRoZSBub2RlXG4gICAgICAgIGlmIChkMy5zZWxlY3Qob2JqKS5zZWxlY3RBbGwoXCJzdmdcIilbMF0ubGVuZ3RoID4gMClcbiAgICAgICAgICAgIGQzLnNlbGVjdChvYmopLnNlbGVjdEFsbChcInN2Z1wiKS5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICB2YXIgeVZhbHMgPSBub2RlLnBsb3R5O1xuICAgIHZhciB4VmFscyA9IG5vZGUucGxvdHg7XG4gICAgLy8gYXJyYXkgb2Ygb2JqZWN0c1xuICAgIGxldCBkYXRhMiA9IG5vZGUucGxvdHgubWFwKCh4LCBpKSA9PiAoe3g6ICt4LCB5OiArbm9kZS5wbG90eVtpXX0pKTtcblxuICAgIHZhciB3aWR0aCA9IDYwOyAvLyBoYXJkY29kZWQsIHNob3VsZCBiZSBzZXQgYXV0b21hdGljYWxseVxuICAgIHZhciBoZWlnaHQgPSAzMDtcbiAgICB2YXIgbWFyZ2luID0ge1xuICAgICAgICB0b3A6IDIwLFxuICAgICAgICByaWdodDogMTAsXG4gICAgICAgIGJvdHRvbTogNTMsXG4gICAgICAgIGxlZnQ6IDEwXG4gICAgfTtcblxuICAgIHZhciB4ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLmRvbWFpbihbZDMubWluKHhWYWxzKSwgZDMubWF4KHhWYWxzKV0pXG4gICAgICAgIC5yYW5nZShbMCwgd2lkdGhdKTtcblxuICAgIHZhciB5ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLmRvbWFpbihbZDMubWluKHlWYWxzKSwgZDMubWF4KHlWYWxzKV0pXG4gICAgICAgIC5yYW5nZShbaGVpZ2h0LCAwXSk7XG5cbiAgICB2YXIgYXJlYSA9IGQzLnN2Zy5hcmVhKClcbiAgICAgICAgLmludGVycG9sYXRlKFwibW9ub3RvbmVcIilcbiAgICAgICAgLngoZCA9PiB4KGQueCkpXG4gICAgICAgIC55MChoZWlnaHQpXG4gICAgICAgIC55MShkID0+IHkoZC55KSk7XG5cbiAgICB2YXIgcGxvdHN2ZyA9IGQzLnNlbGVjdChvYmopXG4gICAgICAgIC5pbnNlcnQoXCJzdmdcIiwgXCI6Zmlyc3QtY2hpbGRcIilcbiAgICAgICAgLmF0dHIoXCJ4XCIsIC00MCkgLy8gTk9URTogTm90IHN1cmUgZXhhY3RseSB3aHkgdGhlc2UgbnVtYmVycyB3b3JrLCBidXQgdGhlc2UgaGFyZGNvZGVkIHZhbHVlcyBzZWVtIHRvIHBvc2l0aW9uIHRoZSBwbG90IGluc2lkZSBnIGNvcnJlY3RseS4gIHRoaXMgc2hvdWxkbid0IGJlIGhhcmRjb2RlZCBpbiB0aGUgZnV0dXJlXG4gICAgICAgIC5hdHRyKFwieVwiLCAtNDUpXG4gICAgICAgIC5hdHRyKFwiaWRcIiwgKCkgPT4gbXluYW1lKVxuICAgICAgICAuc3R5bGUoXCJ3aWR0aFwiLCB3aWR0aClcbiAgICAgICAgLnN0eWxlKFwiaGVpZ2h0XCIsIGhlaWdodClcbiAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBtYXJnaW4ubGVmdCArIFwiLFwiICsgbWFyZ2luLnRvcCArIFwiKVwiKTtcblxuICAgIHBsb3RzdmcuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAuZGF0dW0oZGF0YTIpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJhcmVhXCIpXG4gICAgICAgIC5hdHRyKFwiZFwiLCBhcmVhKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJhcnNOb2RlKG5vZGUsIG9iaikge1xuICAgIHZhciBteW5hbWUgPSBub2RlLm5hbWUudG9TdHJpbmcoKS5jb25jYXQoXCJub2RlcGxvdFwiKTtcblxuICAgIGlmICh0eXBlb2Ygb2JqID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHZhciBvYmogPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChub2RlLm5hbWUudG9TdHJpbmcoKSArIFwiYmlnZ3JvdXBcIik7XG4gICAgICAgIC8vIGlmIG9iaiBjb250YWlucyBhbiBzdmcgZWxlbWVudCwgcmVtb3ZlIGl0LiB0aGlzIHJlbW92ZXMgYW55IHBsb3QgaW5zaWRlIHRoZSBub2RlXG4gICAgICAgIGlmIChkMy5zZWxlY3Qob2JqKS5zZWxlY3RBbGwoXCJzdmdcIilbMF0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZDMuc2VsZWN0KG9iaikuc2VsZWN0QWxsKFwic3ZnXCIpLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gSGlzdG9ncmFtIHNwYWNpbmdcbiAgICB2YXIgYmFyUGFkZGluZyA9IC4wMTU7IC8vIFNwYWNlIGJldHdlZW4gYmFyc1xuICAgIHZhciB0b3BTY2FsZSA9IDEuMjsgLy8gTXVsdGlwbGljYXRpdmUgZmFjdG9yIHRvIGFzc2lnbiBzcGFjZSBhdCB0b3Agd2l0aGluIGdyYXBoIC0gY3VycmVudGx5IHJlbW92ZWQgZnJvbSBpbXBsZW1lbnRhdGlvblxuXG4gICAgLy8gRGF0YVxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMobm9kZS5wbG90dmFsdWVzKTtcbiAgICB2YXIgeVZhbHMgPSBuZXcgQXJyYXk7XG4gICAgdmFyIHhWYWxzID0gbmV3IEFycmF5O1xuICAgIHZhciB5VmFsS2V5ID0gbmV3IEFycmF5O1xuXG4gICAgaWYgKG5vZGUubmF0dXJlID09PSBcIm5vbWluYWxcIikge1xuICAgICAgICB2YXIgeGkgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChub2RlLnBsb3R2YWx1ZXNba2V5c1tpXV0gPT0gMClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHlWYWxzW3hpXSA9IG5vZGUucGxvdHZhbHVlc1trZXlzW2ldXTtcbiAgICAgICAgICAgIHhWYWxzW3hpXSA9IHhpO1xuICAgICAgICAgICAgeVZhbEtleS5wdXNoKHt5OiB5VmFsc1t4aV0sIHg6IGtleXNbaV19KTtcbiAgICAgICAgICAgIHhpID0geGkgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHlWYWxLZXkuc29ydCgoYSwgYikgPT4gYi55IC0gYS55KTsgLy8gYXJyYXkgb2Ygb2JqZWN0cywgZWFjaCBvYmplY3QgaGFzIHksIHRoZSBzYW1lIGFzIHlWYWxzLCBhbmQgeCwgdGhlIGNhdGVnb3J5XG4gICAgICAgIHlWYWxzLnNvcnQoKGEsIGIpID0+IGIgLSBhKTsgLy8gYXJyYXkgb2YgeSB2YWx1ZXMsIHRoZSBoZWlnaHQgb2YgdGhlIGJhcnNcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHlWYWxzW2ldID0gbm9kZS5wbG90dmFsdWVzW2tleXNbaV1dO1xuICAgICAgICAgICAgeFZhbHNbaV0gPSBOdW1iZXIoa2V5c1tpXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbWF4WSA9IGQzLm1heCh5VmFscyk7XG4gICAgdmFyIG1pblggPSBkMy5taW4oeFZhbHMpO1xuICAgIHZhciBtYXhYID0gZDMubWF4KHhWYWxzKTtcblxuICAgIHZhciB3aWR0aCA9IDYwO1xuICAgIHZhciBoZWlnaHQgPSAzMDtcbiAgICB2YXIgbWFyZ2luID0ge1xuICAgICAgICB0b3A6IDIwLFxuICAgICAgICByaWdodDogMTAsXG4gICAgICAgIGJvdHRvbTogNTMsXG4gICAgICAgIGxlZnQ6IDEwXG4gICAgfTtcblxuICAgIHZhciB4ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLmRvbWFpbihbbWluWCAtIDAuNSwgbWF4WCArIDAuNV0pXG4gICAgICAgIC5yYW5nZShbMCwgd2lkdGhdKTtcblxuICAgIHZhciBpbnZ4ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLnJhbmdlKFttaW5YIC0gMC41LCBtYXhYICsgMC41XSlcbiAgICAgICAgLmRvbWFpbihbMCwgd2lkdGhdKTtcblxuICAgIHZhciB5ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLmRvbWFpbihbMCwgbWF4WV0pXG4gICAgICAgIC5yYW5nZShbMCwgaGVpZ2h0XSk7XG5cbiAgICAvL0NyZWF0ZSBTVkcgZWxlbWVudFxuICAgIHZhciBwbG90c3ZnID0gZDMuc2VsZWN0KG9iailcbiAgICAgICAgLmluc2VydChcInN2Z1wiLCBcIjpmaXJzdC1jaGlsZFwiKVxuICAgICAgICAuYXR0cihcInhcIiwgLTQwKVxuICAgICAgICAuYXR0cihcInlcIiwgLTQ1KVxuICAgICAgICAuYXR0cihcImlkXCIsICgpID0+IG15bmFtZSlcbiAgICAgICAgLnN0eWxlKFwid2lkdGhcIiwgd2lkdGgpIC8vIHNldCBoZWlnaHQgdG8gdGhlIGhlaWdodCBvZiAjbWFpbi5sZWZ0XG4gICAgICAgIC5zdHlsZShcImhlaWdodFwiLCBoZWlnaHQpXG4gICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgbWFyZ2luLmxlZnQgKyBcIixcIiArIG1hcmdpbi50b3AgKyBcIilcIik7XG5cbiAgICBwbG90c3ZnLnNlbGVjdEFsbChcInJlY3RcIilcbiAgICAgICAgLmRhdGEoeVZhbHMpXG4gICAgICAgIC5lbnRlcigpXG4gICAgICAgIC5hcHBlbmQoXCJyZWN0XCIpXG4gICAgICAgIC5hdHRyKFwieFwiLCAoZCwgaSkgPT4gIHgoeFZhbHNbaV0gLSAwLjUgKyBiYXJQYWRkaW5nKSlcbiAgICAgICAgLmF0dHIoXCJ5XCIsIGQgPT4gIHkobWF4WSAtIGQpKVxuICAgICAgICAuYXR0cihcIndpZHRoXCIsIHgobWluWCArIDAuNSAtIDIgKiBiYXJQYWRkaW5nKSkgLy8gdGhlIFwid2lkdGhcIiBpcyB0aGUgY29vcmRpbmF0ZSBvZiB0aGUgZW5kIG9mIHRoZSBmaXJzdCBiYXJcbiAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgeSlcbiAgICAgICAgLmF0dHIoXCJmaWxsXCIsIFwiIzFmNzdiNFwiKTtcbn1cblxuXG5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Fzc2V0cy9hcHAvcGxvdHMuanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2\n')},function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.searchIndex = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mithril = __webpack_require__(0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _app = __webpack_require__(1);\n\nvar app = _interopRequireWildcard(_app);\n\nvar _plots = __webpack_require__(2);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar searchIndex = exports.searchIndex = void 0;\n\nvar search = function search(val) {\n    var all = app.allNodes;\n    if (val === '') {\n        exports.searchIndex = searchIndex = null;\n        return app.valueKey = all.map(function (n) {\n            return n.name;\n        });\n    }\n\n    var matches = [],\n        others = [],\n        match = function match(n, key) {\n        return n[key].toLowerCase().includes(val.toLowerCase());\n    };\n\n    all.forEach(function (n) {\n        return match(n, 'name') || match(n, 'labl') ? matches.push(n) : others.push(n);\n    });\n    exports.searchIndex = searchIndex = matches.length;\n    app.valueKey = matches.concat(others).map(function (n) {\n        return n.name;\n    });\n};\n\nvar Search = function () {\n    function Search() {\n        _classCallCheck(this, Search);\n    }\n\n    _createClass(Search, [{\n        key: 'view',\n        value: function view(vnode) {\n            vnode.attrs.oninput = _mithril2.default.withAttr('value', search);\n            return (0, _mithril2.default)('input#searchvar.form-control[style=margin-bottom: 5px; width: 100%]', vnode.attrs);\n        }\n    }]);\n\n    return Search;\n}();\n\nexports.default = Search;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvYXBwL3ZpZXdzL1NlYXJjaC5qcz8xMzc4Il0sIm5hbWVzIjpbImFwcCIsInNlYXJjaEluZGV4Iiwic2VhcmNoIiwiYWxsIiwiYWxsTm9kZXMiLCJ2YWwiLCJ2YWx1ZUtleSIsIm1hcCIsIm4iLCJuYW1lIiwibWF0Y2hlcyIsIm90aGVycyIsIm1hdGNoIiwia2V5IiwidG9Mb3dlckNhc2UiLCJpbmNsdWRlcyIsImZvckVhY2giLCJwdXNoIiwibGVuZ3RoIiwiY29uY2F0IiwiU2VhcmNoIiwidm5vZGUiLCJhdHRycyIsIm9uaW5wdXQiLCJ3aXRoQXR0ciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7Ozs7QUFFQTs7SUFBWUEsRzs7QUFDWjs7Ozs7Ozs7QUFFTyxJQUFJQywwQ0FBSjs7QUFFUCxJQUFJQyxTQUFTLFNBQVRBLE1BQVMsTUFBTztBQUNoQixRQUFJQyxNQUFNSCxJQUFJSSxRQUFkO0FBQ0EsUUFBSUMsUUFBUSxFQUFaLEVBQWdCO0FBQ1osZ0JBTEdKLFdBS0gsaUJBQWMsSUFBZDtBQUNBLGVBQU9ELElBQUlNLFFBQUosR0FBZUgsSUFBSUksR0FBSixDQUFRO0FBQUEsbUJBQUtDLEVBQUVDLElBQVA7QUFBQSxTQUFSLENBQXRCO0FBQ0g7O0FBTGUsUUFNWEMsT0FOVyxHQU1nQixFQU5oQjtBQUFBLFFBTUZDLE1BTkUsR0FNb0IsRUFOcEI7QUFBQSxRQU1NQyxLQU5OLEdBTXdCLFNBQWxCQSxLQUFrQixDQUFDSixDQUFELEVBQUlLLEdBQUo7QUFBQSxlQUFZTCxFQUFFSyxHQUFGLEVBQU9DLFdBQVAsR0FBcUJDLFFBQXJCLENBQThCVixJQUFJUyxXQUFKLEVBQTlCLENBQVo7QUFBQSxLQU54Qjs7QUFPaEJYLFFBQUlhLE9BQUosQ0FBWTtBQUFBLGVBQUtKLE1BQU1KLENBQU4sRUFBUyxNQUFULEtBQW9CSSxNQUFNSixDQUFOLEVBQVMsTUFBVCxDQUFwQixHQUF1Q0UsUUFBUU8sSUFBUixDQUFhVCxDQUFiLENBQXZDLEdBQXlERyxPQUFPTSxJQUFQLENBQVlULENBQVosQ0FBOUQ7QUFBQSxLQUFaO0FBQ0EsWUFWT1AsV0FVUCxpQkFBY1MsUUFBUVEsTUFBdEI7QUFDQWxCLFFBQUlNLFFBQUosR0FBZUksUUFDVlMsTUFEVSxDQUNIUixNQURHLEVBRVZKLEdBRlUsQ0FFTjtBQUFBLGVBQUtDLEVBQUVDLElBQVA7QUFBQSxLQUZNLENBQWY7QUFHSCxDQVpEOztJQWNNVyxNOzs7Ozs7OzZCQUNHQyxLLEVBQU87QUFDUkEsa0JBQU1DLEtBQU4sQ0FBWUMsT0FBWixHQUFzQixrQkFBRUMsUUFBRixDQUFXLE9BQVgsRUFBb0J0QixNQUFwQixDQUF0QjtBQUNBLG1CQUFPLHVCQUFFLHFFQUFGLEVBQXlFbUIsTUFBTUMsS0FBL0UsQ0FBUDtBQUNIOzs7Ozs7a0JBR1VGLE0iLCJmaWxlIjoiMy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuXG5pbXBvcnQgKiBhcyBhcHAgZnJvbSAnLi4vYXBwJztcbmltcG9ydCB7c2VsVmFyQ29sb3J9IGZyb20gJy4uL3Bsb3RzJztcblxuZXhwb3J0IGxldCBzZWFyY2hJbmRleDtcblxubGV0IHNlYXJjaCA9IHZhbCA9PiB7XG4gICAgbGV0IGFsbCA9IGFwcC5hbGxOb2RlcztcbiAgICBpZiAodmFsID09PSAnJykge1xuICAgICAgICBzZWFyY2hJbmRleCA9IG51bGw7XG4gICAgICAgIHJldHVybiBhcHAudmFsdWVLZXkgPSBhbGwubWFwKG4gPT4gbi5uYW1lKTtcbiAgICB9XG4gICAgbGV0IFttYXRjaGVzLCBvdGhlcnMsIG1hdGNoXSA9IFtbXSwgW10sIChuLCBrZXkpID0+IG5ba2V5XS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHZhbC50b0xvd2VyQ2FzZSgpKV07XG4gICAgYWxsLmZvckVhY2gobiA9PiBtYXRjaChuLCAnbmFtZScpIHx8IG1hdGNoKG4sICdsYWJsJykgPyBtYXRjaGVzLnB1c2gobikgOiBvdGhlcnMucHVzaChuKSk7XG4gICAgc2VhcmNoSW5kZXggPSBtYXRjaGVzLmxlbmd0aDtcbiAgICBhcHAudmFsdWVLZXkgPSBtYXRjaGVzXG4gICAgICAgIC5jb25jYXQob3RoZXJzKVxuICAgICAgICAubWFwKG4gPT4gbi5uYW1lKTtcbn07XG5cbmNsYXNzIFNlYXJjaCB7XG4gICAgdmlldyh2bm9kZSkge1xuICAgICAgICB2bm9kZS5hdHRycy5vbmlucHV0ID0gbS53aXRoQXR0cigndmFsdWUnLCBzZWFyY2gpO1xuICAgICAgICByZXR1cm4gbSgnaW5wdXQjc2VhcmNodmFyLmZvcm0tY29udHJvbFtzdHlsZT1tYXJnaW4tYm90dG9tOiA1cHg7IHdpZHRoOiAxMDAlXScsIHZub2RlLmF0dHJzKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNlYXJjaDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Fzc2V0cy9hcHAvdmlld3MvU2VhcmNoLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3\n")},function(module,exports,__webpack_require__){eval('/**! hopscotch - v0.3.1\n*\n* Copyright 2017 LinkedIn Corp. All rights reserved.\n*\n* Licensed under the Apache License, Version 2.0 (the "License");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*     http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an "AS IS" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n!function(a,b){ true?module.exports=b():"function"==typeof define&&define.amd?define(b):a.hopscotch=b()}(this,function(){"use strict";var a,b,c,d,e,f,g,h,i,j,k,l,m,n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(a){return typeof a}:function(a){return a&&"function"==typeof Symbol&&a.constructor===Symbol&&a!==Symbol.prototype?"symbol":typeof a},o="bubble_default",p=window.Sizzle||null,q="undefined",r=!1,s=("undefined"==typeof jQuery?"undefined":n(jQuery))!==q,t=!1,u=!1,v=/^[a-zA-Z]+[a-zA-Z0-9_-]*$/,w={left:"right",right:"left"};try{n(window.sessionStorage)!==q&&(t=!0,sessionStorage.setItem("hopscotch.test.storage","ok"),sessionStorage.removeItem("hopscotch.test.storage"),u=!0)}catch(x){}l={smoothScroll:!0,scrollDuration:1e3,scrollTopMargin:200,showCloseButton:!0,showPrevButton:!1,showNextButton:!0,bubbleWidth:280,bubblePadding:15,arrowWidth:20,skipIfNoElement:!0,isRtl:!1,cookieName:"hopscotch.tour.state"},Array.isArray||(Array.isArray=function(a){return"[object Array]"===Object.prototype.toString.call(a)}),k=function(){r&&m.startTour()},h={addClass:function(a,b){var c,d,e,f;if(a.className){for(d=b.split(/\\s+/),c=" "+a.className+" ",e=0,f=d.length;f>e;++e)c.indexOf(" "+d[e]+" ")<0&&(c+=d[e]+" ");a.className=c.replace(/^\\s+|\\s+$/g,"")}else a.className=b},removeClass:function(a,b){var c,d,e,f;for(d=b.split(/\\s+/),c=" "+a.className+" ",e=0,f=d.length;f>e;++e)c=c.replace(" "+d[e]+" "," ");a.className=c.replace(/^\\s+|\\s+$/g,"")},hasClass:function(a,b){var c;return a.className?(c=" "+a.className+" ",-1!==c.indexOf(" "+b+" ")):!1},getPixelValue:function(a){var b="undefined"==typeof a?"undefined":n(a);return"number"===b?a:"string"===b?parseInt(a,10):0},valOrDefault:function(a,b){return("undefined"==typeof a?"undefined":n(a))!==q?a:b},invokeCallbackArrayHelper:function(a){var b;return Array.isArray(a)&&(b=j[a[0]],"function"==typeof b)?b.apply(this,a.slice(1)):void 0},invokeCallbackArray:function(a){var b,c;if(Array.isArray(a)){if("string"==typeof a[0])return h.invokeCallbackArrayHelper(a);for(b=0,c=a.length;c>b;++b)h.invokeCallback(a[b])}},invokeCallback:function(a){return"function"==typeof a?a():"string"==typeof a&&j[a]?j[a]():h.invokeCallbackArray(a)},invokeEventCallbacks:function(a,b){var c,d,e=i[a];if(b)return this.invokeCallback(b);for(c=0,d=e.length;d>c;++c)this.invokeCallback(e[c].cb)},getScrollTop:function(){var a;return a=n(window.pageYOffset)!==q?window.pageYOffset:document.documentElement.scrollTop},getScrollLeft:function(){var a;return a=n(window.pageXOffset)!==q?window.pageXOffset:document.documentElement.scrollLeft},getWindowHeight:function(){return window.innerHeight||document.documentElement.clientHeight},addEvtListener:function(a,b,c){return a?a.addEventListener?a.addEventListener(b,c,!1):a.attachEvent("on"+b,c):void 0},removeEvtListener:function(a,b,c){return a?a.removeEventListener?a.removeEventListener(b,c,!1):a.detachEvent("on"+b,c):void 0},documentIsReady:function(){return"complete"===document.readyState},evtPreventDefault:function(a){a.preventDefault?a.preventDefault():event&&(event.returnValue=!1)},extend:function(a,b){var c;for(c in b)b.hasOwnProperty(c)&&(a[c]=b[c])},getStepTargetHelper:function(a){var b=document.getElementById(a);if(b)return b;if(s)return b=jQuery(a),b.length?b[0]:null;if(p)return b=new p(a),b.length?b[0]:null;if(document.querySelector)try{return document.querySelector(a)}catch(c){}return/^#[a-zA-Z][\\w-_:.]*$/.test(a)?document.getElementById(a.substring(1)):null},getStepTarget:function(a){var b;if(!a||!a.target)return null;if("string"==typeof a.target)return h.getStepTargetHelper(a.target);if(Array.isArray(a.target)){var c,d;for(c=0,d=a.target.length;d>c;c++)if("string"==typeof a.target[c]&&(b=h.getStepTargetHelper(a.target[c])))return b;return null}return a.target},getI18NString:function(a){return e[a]||d[a]},setState:function(a,b,c){var d,e="";if(t&&u)try{sessionStorage.setItem(a,b)}catch(f){u=!1,this.setState(a,b,c)}else t&&sessionStorage.removeItem(a),c&&(d=new Date,d.setTime(d.getTime()+24*c*60*60*1e3),e="; expires="+d.toGMTString()),document.cookie=a+"="+b+e+"; path=/"},getState:function(a){var b,c,d,e=a+"=",f=document.cookie.split(";");if(t&&(d=sessionStorage.getItem(a)))return d;for(b=0;b<f.length;b++){for(c=f[b];" "===c.charAt(0);)c=c.substring(1,c.length);if(0===c.indexOf(e)){d=c.substring(e.length,c.length);break}}return d},clearState:function(a){t?sessionStorage.removeItem(a):this.setState(a,"",-1)},normalizePlacement:function(a){!a.placement&&a.orientation&&(a.placement=a.orientation)},flipPlacement:function(a){if(a.isRtl&&!a._isFlipped){var b,c,d=["orientation","placement"];a.xOffset&&(a.xOffset=-1*this.getPixelValue(a.xOffset));for(c in d)b=d[c],a.hasOwnProperty(b)&&w.hasOwnProperty(a[b])&&(a[b]=w[a[b]]);a._isFlipped=!0}}},h.addEvtListener(window,"load",k),i={next:[],prev:[],start:[],end:[],show:[],error:[],close:[]},j={},d={stepNums:null,nextBtn:"Next",prevBtn:"Back",doneBtn:"Done",skipBtn:"Skip",closeTooltip:"Close"},e={},b=function(a){this.init(a)},b.prototype={isShowing:!1,currStep:void 0,setPosition:function(a){var b,c,d,e,f,g,i,j=h.getStepTarget(a),k=this.element,l=this.arrowEl,m=a.isRtl?"right":"left";if(h.flipPlacement(a),h.normalizePlacement(a),c=k.offsetWidth,b=k.offsetHeight,h.removeClass(k,"fade-in-down fade-in-up fade-in-left fade-in-right"),d=j.getBoundingClientRect(),i=a.isRtl?d.right-c:d.left,"top"===a.placement)e=d.top-b-this.opt.arrowWidth,f=i;else if("bottom"===a.placement)e=d.bottom+this.opt.arrowWidth,f=i;else if("left"===a.placement)e=d.top,f=d.left-c-this.opt.arrowWidth;else{if("right"!==a.placement)throw new Error("Bubble placement failed because step.placement is invalid or undefined!");e=d.top,f=d.right+this.opt.arrowWidth}g="center"!==a.arrowOffset?h.getPixelValue(a.arrowOffset):a.arrowOffset,g?"top"===a.placement||"bottom"===a.placement?(l.style.top="","center"===g?l.style[m]=Math.floor(c/2-l.offsetWidth/2)+"px":l.style[m]=g+"px"):("left"===a.placement||"right"===a.placement)&&(l.style[m]="","center"===g?l.style.top=Math.floor(b/2-l.offsetHeight/2)+"px":l.style.top=g+"px"):(l.style.top="",l.style[m]=""),"center"===a.xOffset?f=d.left+j.offsetWidth/2-c/2:f+=h.getPixelValue(a.xOffset),"center"===a.yOffset?e=d.top+j.offsetHeight/2-b/2:e+=h.getPixelValue(a.yOffset),a.fixedElement||(e+=h.getScrollTop(),f+=h.getScrollLeft()),k.style.position=a.fixedElement?"fixed":"absolute",k.style.top=e+"px",k.style.left=f+"px"},render:function(a,b,c){var d,e,g,i,j,k,l,n,p,q,r=this.element;if(a?this.currStep=a:this.currStep&&(a=this.currStep),this.opt.isTourBubble?(i=m.getCurrTour(),i&&(e=i.customData,d=i.customRenderer,a.isRtl=a.hasOwnProperty("isRtl")?a.isRtl:i.hasOwnProperty("isRtl")?i.isRtl:this.opt.isRtl,g=i.unsafe,Array.isArray(i.steps)&&(j=i.steps.length,k=this._getStepI18nNum(this._getStepNum(j-1)),n=this._getStepNum(b)===this._getStepNum(j-1)))):(e=a.customData,d=a.customRenderer,g=a.unsafe,a.isRtl=a.hasOwnProperty("isRtl")?a.isRtl:this.opt.isRtl),l=n?h.getI18NString("doneBtn"):a.showSkip?h.getI18NString("skipBtn"):h.getI18NString("nextBtn"),h.flipPlacement(a),h.normalizePlacement(a),this.placement=a.placement,q={i18n:{prevBtn:h.getI18NString("prevBtn"),nextBtn:l,closeTooltip:h.getI18NString("closeTooltip"),stepNum:this._getStepI18nNum(this._getStepNum(b)),numSteps:k},buttons:{showPrev:h.valOrDefault(a.showPrevButton,this.opt.showPrevButton)&&this._getStepNum(b)>0,showNext:h.valOrDefault(a.showNextButton,this.opt.showNextButton),showCTA:h.valOrDefault(a.showCTAButton&&a.ctaLabel,!1),ctaLabel:a.ctaLabel,showClose:h.valOrDefault(this.opt.showCloseButton,!0)},step:{num:b,isLast:h.valOrDefault(n,!1),title:a.title||"",content:a.content||"",isRtl:a.isRtl,placement:a.placement,padding:h.valOrDefault(a.padding,this.opt.bubblePadding),width:h.getPixelValue(a.width)||this.opt.bubbleWidth,customData:a.customData||{}},tour:{isTour:this.opt.isTourBubble,numSteps:j,unsafe:h.valOrDefault(g,!1),customData:e||{}}},"function"==typeof d)r.innerHTML=d(q);else if("string"==typeof d){if(!m.templates||"function"!=typeof m.templates[d])throw new Error(\'Bubble rendering failed - template "\'+d+\'" is not a function.\');r.innerHTML=m.templates[d](q)}else if(f)r.innerHTML=f(q);else{if(!m.templates||"function"!=typeof m.templates[o])throw new Error(\'Bubble rendering failed - template "\'+o+\'" is not a function.\');r.innerHTML=m.templates[o](q)}var s,t=r.children,u=t.length;for(p=0;u>p;p++)s=t[p],h.hasClass(s,"hopscotch-arrow")&&(this.arrowEl=s);return r.style.zIndex="number"==typeof a.zindex?a.zindex:"",this._setArrow(a.placement),this.hide(!1),this.setPosition(a),c&&c(!a.fixedElement),this},_getStepNum:function(a){var b,c,d=0,e=m.getSkippedStepsIndexes(),f=e.length;for(c=0;f>c;c++)b=e[c],a>b&&d++;return a-d},_getStepI18nNum:function(a){var b=h.getI18NString("stepNums");return b&&a<b.length?a=b[a]:a+=1,a},_setArrow:function(a){h.removeClass(this.arrowEl,"down up right left"),"top"===a?h.addClass(this.arrowEl,"down"):"bottom"===a?h.addClass(this.arrowEl,"up"):"left"===a?h.addClass(this.arrowEl,"right"):"right"===a&&h.addClass(this.arrowEl,"left")},_getArrowDirection:function(){return"top"===this.placement?"down":"bottom"===this.placement?"up":"left"===this.placement?"right":"right"===this.placement?"left":void 0},show:function(){var a=this,b="fade-in-"+this._getArrowDirection(),c=1e3;return h.removeClass(this.element,"hide"),h.addClass(this.element,b),setTimeout(function(){h.removeClass(a.element,"invisible")},50),setTimeout(function(){h.removeClass(a.element,b)},c),this.isShowing=!0,this},hide:function(a){var b=this.element;return a=h.valOrDefault(a,!0),b.style.top="",b.style.left="",a?(h.addClass(b,"hide"),h.removeClass(b,"invisible")):(h.removeClass(b,"hide"),h.addClass(b,"invisible")),h.removeClass(b,"animate fade-in-up fade-in-down fade-in-right fade-in-left"),this.isShowing=!1,this},destroy:function(){var a=this.element;a&&a.parentNode.removeChild(a),h.removeEvtListener(a,"click",this.clickCb)},_handleBubbleClick:function(a){function b(c){return c===a.currentTarget?null:h.hasClass(c,"hopscotch-cta")?"cta":h.hasClass(c,"hopscotch-next")?"next":h.hasClass(c,"hopscotch-prev")?"prev":h.hasClass(c,"hopscotch-close")?"close":b(c.parentElement)}var c;a=a||window.event;var d=a.target||a.srcElement;if(c=b(d),"cta"===c)this.opt.isTourBubble||m.getCalloutManager().removeCallout(this.currStep.id),this.currStep.onCTA&&h.invokeCallback(this.currStep.onCTA);else if("next"===c)m.nextStep(!0);else if("prev"===c)m.prevStep(!0);else if("close"===c){if(this.opt.isTourBubble){var e=m.getCurrStepNum(),f=m.getCurrTour(),g=e===f.steps.length-1;h.invokeEventCallbacks("close"),m.endTour(!0,g)}else this.opt.onClose&&h.invokeCallback(this.opt.onClose),this.opt.id&&!this.opt.isTourBubble?m.getCalloutManager().removeCallout(this.opt.id):this.destroy();h.evtPreventDefault(a)}},init:function(a){var b,c,d,e,f=document.createElement("div"),g=this,i=!1;this.element=f,e={showPrevButton:l.showPrevButton,showNextButton:l.showNextButton,bubbleWidth:l.bubbleWidth,bubblePadding:l.bubblePadding,arrowWidth:l.arrowWidth,isRtl:l.isRtl,showNumber:!0,isTourBubble:!0},a=("undefined"==typeof a?"undefined":n(a))===q?{}:a,h.extend(e,a),this.opt=e,f.className="hopscotch-bubble animated",e.isTourBubble?(d=m.getCurrTour(),d&&h.addClass(f,"tour-"+d.id)):h.addClass(f,"hopscotch-callout no-number"),b=function(){!i&&g.isShowing&&(i=!0,setTimeout(function(){g.setPosition(g.currStep),i=!1},100))},h.addEvtListener(window,"resize",b),this.clickCb=function(a){g._handleBubbleClick(a)},h.addEvtListener(f,"click",this.clickCb),this.hide(),h.documentIsReady()?document.body.appendChild(f):(document.addEventListener?(c=function(){document.removeEventListener("DOMContentLoaded",c),window.removeEventListener("load",c),document.body.appendChild(f)},document.addEventListener("DOMContentLoaded",c,!1)):(c=function(){"complete"===document.readyState&&(document.detachEvent("onreadystatechange",c),window.detachEvent("onload",c),document.body.appendChild(f))},document.attachEvent("onreadystatechange",c)),h.addEvtListener(window,"load",c))}},c=function(){var a={},c={};this.createCallout=function(d){var e;if(!d.id)throw new Error("Must specify a callout id.");if(!v.test(d.id))throw new Error("Callout ID is using an invalid format. Use alphanumeric, underscores, and/or hyphens only. First character must be a letter.");if(a[d.id])throw new Error("Callout by that id already exists. Please choose a unique id.");if(!h.getStepTarget(d))throw new Error("Must specify existing target element via \'target\' option.");return d.showNextButton=d.showPrevButton=!1,d.isTourBubble=!1,e=new b(d),a[d.id]=e,c[d.id]=d,e.render(d,null,function(){e.show(),d.onShow&&h.invokeCallback(d.onShow)}),e},this.getCallout=function(b){return a[b]},this.removeAllCallouts=function(){var b;for(b in a)a.hasOwnProperty(b)&&this.removeCallout(b)},this.removeCallout=function(b){var d=a[b];a[b]=null,c[b]=null,d&&d.destroy()},this.refreshCalloutPositions=function(){var b,d,e;for(b in a)a.hasOwnProperty(b)&&c.hasOwnProperty(b)&&(d=a[b],e=c[b],d&&e&&d.setPosition(e))}},a=function(a){var d,k,p,t,u,w,x,y,z=this,A={},B=[],C=function(a){return d&&d.element&&d.element.parentNode||(d=new b(p)),a&&h.extend(d.opt,{bubblePadding:E("bubblePadding"),bubbleWidth:E("bubbleWidth"),showNextButton:E("showNextButton"),showPrevButton:E("showPrevButton"),showCloseButton:E("showCloseButton"),arrowWidth:E("arrowWidth"),isRtl:E("isRtl")}),d},D=function(){d&&(d.destroy(),d=null)},E=function(a){return"undefined"==typeof p?l[a]:h.valOrDefault(p[a],l[a])},F=function(){var a;return a=!t||0>u||u>=t.steps.length?null:t.steps[u]},G=function(){z.nextStep()},H=function(a){var b,c,d,e,f,g,i=C(),j=i.element,k=h.getPixelValue(j.style.top),l=k+h.getPixelValue(j.offsetHeight),m=h.getStepTarget(F()),o=m.getBoundingClientRect(),p=o.top+h.getScrollTop(),r=o.bottom+h.getScrollTop(),t=p>k?k:p,u=l>r?l:r,v=h.getScrollTop(),w=v+h.getWindowHeight(),x=t-E("scrollTopMargin");t>=v&&(t<=v+E("scrollTopMargin")||w>=u)?a&&a():E("smoothScroll")?("undefined"==typeof YAHOO?"undefined":n(YAHOO))!==q&&n(YAHOO.env)!==q&&n(YAHOO.env.ua)!==q&&n(YAHOO.util)!==q&&n(YAHOO.util.Scroll)!==q?(b=YAHOO.env.ua.webkit?document.body:document.documentElement,d=YAHOO.util.Easing?YAHOO.util.Easing.easeOut:void 0,c=new YAHOO.util.Scroll(b,{scroll:{to:[0,x]}},E("scrollDuration")/1e3,d),c.onComplete.subscribe(a),c.animate()):s?jQuery("body, html").animate({scrollTop:x},E("scrollDuration"),a):(0>x&&(x=0),e=v>t?-1:1,f=Math.abs(v-x)/(E("scrollDuration")/10),(g=function(){var b=h.getScrollTop(),c=b+e*f;return e>0&&c>=x||0>e&&x>=c?(c=x,a&&a(),void window.scrollTo(0,c)):(window.scrollTo(0,c),h.getScrollTop()===b?void(a&&a()):void setTimeout(g,10))})()):(window.scrollTo(0,x),a&&a())},I=function P(a,b){var c,d,e;u+a>=0&&u+a<t.steps.length?(u+=a,d=F(),e=function(){c=h.getStepTarget(d),c?(A[u]&&delete A[u],b(u)):(A[u]=!0,h.invokeEventCallbacks("error"),P(a,b))},d.delay?setTimeout(e,d.delay):e()):b(-1)},J=function(a,b){var c,d,e,f,g=C(),i=this;if(g.hide(),a=h.valOrDefault(a,!0),c=F(),c.nextOnTargetClick&&h.removeEvtListener(h.getStepTarget(c),"click",G),d=c,e=b>0?d.multipage:u>0&&t.steps[u-1].multipage,f=function(c){var f;if(-1===c)return this.endTour(!0);if(a&&(f=b>0?h.invokeEventCallbacks("next",d.onNext):h.invokeEventCallbacks("prev",d.onPrev)),c===u){if(e)return void N();f=h.valOrDefault(f,!0),f?this.showStep(c):this.endTour(!1)}},!e&&E("skipIfNoElement"))I(b,function(a){f.call(i,a)});else if(u+b>=0&&u+b<t.steps.length){if(u+=b,c=F(),!h.getStepTarget(c)&&!e)return h.invokeEventCallbacks("error"),this.endTour(!0,!1);f.call(this,u)}else if(u+b===t.steps.length)return this.endTour();return this},K=function(a){var b,c,d,e={};for(b in a)a.hasOwnProperty(b)&&"id"!==b&&"steps"!==b&&(e[b]=a[b]);return y.call(this,e,!0),c=h.getState(E("cookieName")),c&&(d=c.split(":"),w=d[0],x=d[1],d.length>2&&(B=d[2].split(",")),x=parseInt(x,10)),this},L=function(a,b,c){var d,e;if(u=a||0,A=b||{},d=F(),e=h.getStepTarget(d))return void c(u);if(!e){if(h.invokeEventCallbacks("error"),A[u]=!0,E("skipIfNoElement"))return void I(1,c);u=-1,c(u)}},M=function(a){function b(){d.show(),h.invokeEventCallbacks("show",c.onShow)}var c=t.steps[a],d=C(),e=h.getStepTarget(c);u!==a&&F().nextOnTargetClick&&h.removeEvtListener(h.getStepTarget(F()),"click",G),u=a,d.hide(!1),d.render(c,a,function(a){a?H(b):b(),c.nextOnTargetClick&&h.addEvtListener(e,"click",G)}),N()},N=function(){var a=t.id+":"+u,b=m.getSkippedStepsIndexes();b&&b.length>0&&(a+=":"+b.join(",")),h.setState(E("cookieName"),a,1)},O=function(a){a&&this.configure(a)};this.getCalloutManager=function(){return("undefined"==typeof k?"undefined":n(k))===q&&(k=new c),k},this.startTour=function(a,b){var c,d,e={},f=this;if(!t){if(!a)throw new Error("Tour data is required for startTour.");if(!a.id||!v.test(a.id))throw new Error("Tour ID is using an invalid format. Use alphanumeric, underscores, and/or hyphens only. First character must be a letter.");t=a,K.call(this,a)}if(("undefined"==typeof b?"undefined":n(b))!==q){if(b>=t.steps.length)throw new Error("Specified step number out of bounds.");d=b}if(!h.documentIsReady())return r=!0,this;if("undefined"==typeof d&&t.id===w&&("undefined"==typeof x?"undefined":n(x))!==q){if(d=x,B.length>0)for(var g=0,i=B.length;i>g;g++)e[B[g]]=!0}else d||(d=0);return L(d,e,function(a){var b=-1!==a&&h.getStepTarget(t.steps[a]);return b?(h.invokeEventCallbacks("start"),c=C(),c.hide(!1),f.isActive=!0,void(h.getStepTarget(F())?f.showStep(a):(h.invokeEventCallbacks("error"),E("skipIfNoElement")&&f.nextStep(!1)))):void f.endTour(!1,!1)}),this},this.showStep=function(a){var b=t.steps[a],c=u;return h.getStepTarget(b)?(b.delay?setTimeout(function(){M(a)},b.delay):M(a),this):(u=a,h.invokeEventCallbacks("error"),void(u=c))},this.prevStep=function(a){return J.call(this,a,-1),this},this.nextStep=function(a){return J.call(this,a,1),this},this.endTour=function(a,b){var c,d=C();return a=h.valOrDefault(a,!0),b=h.valOrDefault(b,!0),t&&(c=F(),c&&c.nextOnTargetClick&&h.removeEvtListener(h.getStepTarget(c),"click",G)),u=0,x=void 0,d.hide(),a&&h.clearState(E("cookieName")),this.isActive&&(this.isActive=!1,t&&b&&h.invokeEventCallbacks("end")),this.removeCallbacks(null,!0),this.resetDefaultOptions(),D(),t=null,this},this.getCurrTour=function(){return t},this.getCurrTarget=function(){return h.getStepTarget(F())},this.getCurrStepNum=function(){return u},this.getSkippedStepsIndexes=function(){var a,b=[];for(a in A)b.push(a);return b},this.refreshBubblePosition=function(){var a=F();return a&&C().setPosition(a),this.getCalloutManager().refreshCalloutPositions(),this},this.listen=function(a,b,c){return a&&i[a].push({cb:b,fromTour:c}),this},this.unlisten=function(a,b){var c,d,e=i[a];for(c=0,d=e.length;d>c;++c)e[c].cb===b&&e.splice(c,1);return this},this.removeCallbacks=function(a,b){var c,d,e,f;for(f in i)if(!a||a===f)if(b)for(c=i[f],d=0,e=c.length;e>d;++d)c[d].fromTour&&(c.splice(d--,1),--e);else i[f]=[];return this},this.registerHelper=function(a,b){"string"==typeof a&&"function"==typeof b&&(j[a]=b)},this.unregisterHelper=function(a){j[a]=null},this.invokeHelper=function(a){var b,c,d=[];for(b=1,c=arguments.length;c>b;++b)d.push(arguments[b]);j[a]&&j[a].call(null,d)},this.setCookieName=function(a){return p.cookieName=a,this},this.resetDefaultOptions=function(){return p={},this},this.resetDefaultI18N=function(){return e={},this},this.getState=function(){return h.getState(E("cookieName"))},y=function(a,b){var c,d,f,g,i=["next","prev","start","end","show","error","close"];for(p||this.resetDefaultOptions(),h.extend(p,a),a&&h.extend(e,a.i18n),f=0,g=i.length;g>f;++f)d="on"+i[f].charAt(0).toUpperCase()+i[f].substring(1),a[d]&&this.listen(i[f],a[d],b);return c=C(!0),this},this.configure=function(a){return y.call(this,a,!1)},this.setRenderer=function(a){var b="undefined"==typeof a?"undefined":n(a);return"string"===b?(o=a,f=void 0):"function"===b&&(f=a),this},this.setEscaper=function(a){return"function"==typeof a&&(g=a),this},O.call(this,a)},m=new a,function(){var a={};a.escape=function(a){return g?g(a):null==a?"":(""+a).replace(new RegExp("[&<>\\"\']","g"),function(a){return"&"==a?"&amp;":"<"==a?"&lt;":">"==a?"&gt;":\'"\'==a?"&quot;":"\'"==a?"&#x27;":void 0})},this.templates=this.templates||{},this.templates.bubble_default=function(b){function c(b,c){return c?a.escape(b):b}var d,e="";a.escape,Array.prototype.join;e+="\\n";var f=b.i18n,g=b.buttons,h=b.step,i=b.tour;return e+=\'\\n<div class="hopscotch-bubble-container" style="width: \'+(null==(d=h.width)?"":d)+"px; padding: "+(null==(d=h.padding)?"":d)+\'px;">\\n  \',i.isTour&&(e+=\'<span class="hopscotch-bubble-number">\'+(null==(d=f.stepNum)?"":d)+"</span>"),e+=\'\\n  <div class="hopscotch-bubble-content">\\n    \',""!==h.title&&(e+=\'<h3 class="hopscotch-title">\'+(null==(d=c(h.title,i.unsafe))?"":d)+"</h3>"),e+="\\n    ",""!==h.content&&(e+=\'<div class="hopscotch-content">\'+(null==(d=c(h.content,i.unsafe))?"":d)+"</div>"),e+=\'\\n  </div>\\n  <div class="hopscotch-actions">\\n    \',g.showPrev&&(e+=\'<button class="hopscotch-nav-button prev hopscotch-prev">\'+(null==(d=f.prevBtn)?"":d)+"</button>"),e+="\\n    ",g.showCTA&&(e+=\'<button class="hopscotch-nav-button next hopscotch-cta">\'+(null==(d=g.ctaLabel)?"":d)+"</button>"),e+="\\n    ",g.showNext&&(e+=\'<button class="hopscotch-nav-button next hopscotch-next">\'+(null==(d=f.nextBtn)?"":d)+"</button>"),e+="\\n  </div>\\n  ",g.showClose&&(e+=\'<button class="hopscotch-bubble-close hopscotch-close">\'+(null==(d=f.closeTooltip)?"":d)+"</button>"),e+=\'\\n</div>\\n<div class="hopscotch-bubble-arrow-container hopscotch-arrow">\\n  <div class="hopscotch-bubble-arrow-border"></div>\\n  <div class="hopscotch-bubble-arrow"></div>\\n</div>\\n\'}}.call(m);var y=m;return y});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2hvcHNjb3RjaC9kaXN0L2pzL2hvcHNjb3RjaC5taW4uanM/Mzc0OSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUseUZBQXdJLGlCQUFpQixhQUFhLHdHQUF3RyxnQkFBZ0IsYUFBYSxvR0FBb0csaUtBQWlLLDJCQUEyQixJQUFJLG9KQUFvSixVQUFVLEdBQUcsMk5BQTJOLDJDQUEyQywyREFBMkQsZUFBZSxpQkFBaUIsSUFBSSx1QkFBdUIsWUFBWSxnQkFBZ0IsMERBQTBELElBQUksNkNBQTZDLHVDQUF1QyxtQkFBbUIsMkJBQTJCLFlBQVksMERBQTBELElBQUksa0NBQWtDLHVDQUF1Qyx3QkFBd0IsTUFBTSx3RUFBd0UsMkJBQTJCLDZDQUE2QyxtREFBbUQsNEJBQTRCLHVEQUF1RCx1Q0FBdUMsTUFBTSwwRkFBMEYsaUNBQWlDLFFBQVEscUJBQXFCLCtEQUErRCxtQkFBbUIsSUFBSSw0QkFBNEIsNEJBQTRCLHdGQUF3RixvQ0FBb0MsZUFBZSxtQ0FBbUMsbUJBQW1CLElBQUksaUNBQWlDLHlCQUF5QixNQUFNLHlGQUF5RiwwQkFBMEIsTUFBTSwwRkFBMEYsNEJBQTRCLGlFQUFpRSxnQ0FBZ0Msc0ZBQXNGLG1DQUFtQyw0RkFBNEYsNEJBQTRCLHVDQUF1QywrQkFBK0Isa0VBQWtFLHNCQUFzQixNQUFNLDRDQUE0QyxpQ0FBaUMsaUNBQWlDLGNBQWMsMkNBQTJDLDBDQUEwQyw4QkFBOEIsaUNBQWlDLFVBQVUsa0ZBQWtGLDJCQUEyQixNQUFNLDZCQUE2QixvRUFBb0UsNEJBQTRCLFFBQVEsMEJBQTBCLElBQUkscUZBQXFGLFlBQVksZ0JBQWdCLDJCQUEyQixrQkFBa0IsMEJBQTBCLFdBQVcsWUFBWSw0QkFBNEIsU0FBUywwQkFBMEIsOEZBQThGLHdEQUF3RCxTQUFTLHNC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RCxtQ0FBbUMsVUFBVSwrQkFBK0IsYUFBYSwyQkFBMkIsSUFBSSx5QkFBeUIsd0JBQXdCLGdDQUFnQywyQkFBMkIscUNBQXFDLFdBQVcsTUFBTSxrQ0FBa0MsV0FBVyxNQUFNLDBCQUEwQixtQ0FBbUMsaUJBQWlCLG1FQUFtRSxxRkFBcUYsSUFBSSx5RkFBeUYsb0JBQW9CLDRCQUE0Qix5QkFBeUIsOEJBQThCLDZDQUE2Qyw2REFBNkQsNkJBQTZCLHVDQUF1QyxnQkFBZ0Isb0JBQW9CLFNBQVMscUJBQXFCLCtFQUErRSxtQkFBbUIsY0FBYyxjQUFjLGdCQUFnQixnQkFBZ0IsU0FBUyxFQUFFLGtDQUFrQywyQ0FBMkMsZ0JBQWdCLHVCQUF1QixXQUFXLDhCQUE4QixRQUFRLDJDQUEyQyxrR0FBa0csMkNBQTJDLGltQ0FBaW1DLFNBQVMsUUFBUSxTQUFTIiwiZmlsZSI6IjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiohIGhvcHNjb3RjaCAtIHYwLjMuMVxuKlxuKiBDb3B5cmlnaHQgMjAxNyBMaW5rZWRJbiBDb3JwLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG4hZnVuY3Rpb24oYSxiKXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz1iKCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShiKTphLmhvcHNjb3RjaD1iKCl9KHRoaXMsZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjt2YXIgYSxiLGMsZCxlLGYsZyxoLGksaixrLGwsbSxuPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbihhKXtyZXR1cm4gdHlwZW9mIGF9OmZ1bmN0aW9uKGEpe3JldHVybiBhJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJmEuY29uc3RydWN0b3I9PT1TeW1ib2wmJmEhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIGF9LG89XCJidWJibGVfZGVmYXVsdFwiLHA9d2luZG93LlNpenpsZXx8bnVsbCxxPVwidW5kZWZpbmVkXCIscj0hMSxzPShcInVuZGVmaW5lZFwiPT10eXBlb2YgalF1ZXJ5P1widW5kZWZpbmVkXCI6bihqUXVlcnkpKSE9PXEsdD0hMSx1PSExLHY9L15bYS16QS1aXStbYS16QS1aMC05Xy1dKiQvLHc9e2xlZnQ6XCJyaWdodFwiLHJpZ2h0OlwibGVmdFwifTt0cnl7bih3aW5kb3cuc2Vzc2lvblN0b3JhZ2UpIT09cSYmKHQ9ITAsc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShcImhvcHNjb3RjaC50ZXN0LnN0b3JhZ2VcIixcIm9rXCIpLHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0oXCJob3BzY290Y2gudGVzdC5zdG9yYWdlXCIpLHU9ITApfWNhdGNoKHgpe31sPXtzbW9vdGhTY3JvbGw6ITAsc2Nyb2xsRHVyYXRpb246MWUzLHNjcm9sbFRvcE1hcmdpbjoyMDAsc2hvd0Nsb3NlQnV0dG9uOiEwLHNob3dQcmV2QnV0dG9uOiExLHNob3dOZXh0QnV0dG9uOiEwLGJ1YmJsZVdpZHRoOjI4MCxidWJibGVQYWRkaW5nOjE1LGFycm93V2lkdGg6MjAsc2tpcElmTm9FbGVtZW50OiEwLGlzUnRsOiExLGNvb2tpZU5hbWU6XCJob3BzY290Y2gudG91ci5zdGF0ZVwifSxBcnJheS5pc0FycmF5fHwoQXJyYXkuaXNBcnJheT1mdW5jdGlvbihhKXtyZXR1cm5cIltvYmplY3QgQXJyYXldXCI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYSl9KSxrPWZ1bmN0aW9uKCl7ciYmbS5zdGFydFRvdXIoKX0saD17YWRkQ2xhc3M6ZnVuY3Rpb24oYSxiKXt2YXIgYyxkLGUsZjtpZihhLmNsYXNzTmFtZSl7Zm9yKGQ9Yi5zcGxpdCgvXFxzKy8pLGM9XCIgXCIrYS5jbGFzc05hbWUrXCIgXCIsZT0wLGY9ZC5sZW5ndGg7Zj5lOysrZSljLmluZGV4T2YoXCIgXCIrZFtlXStcIiBcIik8MCYmKGMrPWRbZV0rXCIgXCIpO2EuY2xhc3NOYW1lPWMucmVwbGFjZSgvXlxccyt8XFxzKyQvZyxcIlwiKX1lbHNlIGEuY2xhc3NOYW1lPWJ9LHJlbW92ZUNsYXNzOmZ1bmN0aW9uKGEsYil7dmFyIGMsZCxlLGY7Zm9yKGQ9Yi5zcGxpdCgvXFxzKy8pLGM9XCIgXCIrYS5jbGFzc05hbWUrXCIgXCIsZT0wLGY9ZC5sZW5ndGg7Zj5lOysrZSljPWMucmVwbGFjZShcIiBcIitkW2VdK1wiIFwiLFwiIFwiKTthLmNsYXNzTmFtZT1jLnJlcGxhY2UoL15cXHMrfFxccyskL2csXCJcIil9LGhhc0NsYXNzOmZ1bmN0aW9uKGEsYil7dmFyIGM7cmV0dXJuIGEuY2xhc3NOYW1lPyhjPVwiIFwiK2EuY2xhc3NOYW1lK1wiIFwiLC0xIT09Yy5pbmRleE9mKFwiIFwiK2IrXCIgXCIpKTohMX0sZ2V0UGl4ZWxWYWx1ZTpmdW5jdGlvbihhKXt2YXIgYj1cInVuZGVmaW5lZFwiPT10eXBlb2YgYT9cInVuZGVmaW5lZFwiOm4oYSk7cmV0dXJuXCJudW1iZXJcIj09PWI/YTpcInN0cmluZ1wiPT09Yj9wYXJzZUludChhLDEwKTowfSx2YWxPckRlZmF1bHQ6ZnVuY3Rpb24oYSxiKXtyZXR1cm4oXCJ1bmRlZmluZWRcIj09dHlwZW9mIGE/XCJ1bmRlZmluZWRcIjpuKGEpKSE9PXE/YTpifSxpbnZva2VDYWxsYmFja0FycmF5SGVscGVyOmZ1bmN0aW9uKGEpe3ZhciBiO3JldHVybiBBcnJheS5pc0FycmF5KGEpJiYoYj1qW2FbMF1dLFwiZnVuY3Rpb25cIj09dHlwZW9mIGIpP2IuYXBwbHkodGhpcyxhLnNsaWNlKDEpKTp2b2lkIDB9LGludm9rZUNhbGxiYWNrQXJyYXk6ZnVuY3Rpb24oYSl7dmFyIGIsYztpZihBcnJheS5pc0FycmF5KGEpKXtpZihcInN0cmluZ1wiPT10eXBlb2YgYVswXSlyZXR1cm4gaC5pbnZva2VDYWxsYmFja0FycmF5SGVscGVyKGEpO2ZvcihiPTAsYz1hLmxlbmd0aDtjPmI7KytiKWguaW52b2tlQ2FsbGJhY2soYVtiXSl9fSxpbnZva2VDYWxsYmFjazpmdW5jdGlvbihhKXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBhP2EoKTpcInN0cmluZ1wiPT10eXBlb2YgYSYmalthXT9qW2FdKCk6aC5pbnZva2VDYWxsYmFja0FycmF5KGEpfSxpbnZva2VFdmVudENhbGxiYWNrczpmdW5jdGlvbihhLGIpe3ZhciBjLGQsZT1pW2FdO2lmKGIpcmV0dXJuIHRoaXMuaW52b2tlQ2FsbGJhY2soYik7Zm9yKGM9MCxkPWUubGVuZ3RoO2Q+YzsrK2MpdGhpcy5pbnZva2VDYWxsYmFjayhlW2NdLmNiKX0sZ2V0U2Nyb2xsVG9wOmZ1bmN0aW9uKCl7dmFyIGE7cmV0dXJuIGE9bih3aW5kb3cucGFnZVlPZmZzZXQpIT09cT93aW5kb3cucGFnZVlPZmZzZXQ6ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcH0sZ2V0U2Nyb2xsTGVmdDpmdW5jdGlvbigpe3ZhciBhO3JldHVybiBhPW4od2luZG93LnBhZ2VYT2Zmc2V0KSE9PXE/d2luZG93LnBhZ2VYT2Zmc2V0OmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0fSxnZXRXaW5kb3dIZWlnaHQ6ZnVuY3Rpb24oKXtyZXR1cm4gd2luZG93LmlubmVySGVpZ2h0fHxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0fSxhZGRFdnRMaXN0ZW5lcjpmdW5jdGlvbihhLGIsYyl7cmV0dXJuIGE/YS5hZGRFdmVudExpc3RlbmVyP2EuYWRkRXZlbnRMaXN0ZW5lcihiLGMsITEpOmEuYXR0YWNoRXZlbnQoXCJvblwiK2IsYyk6dm9pZCAwfSxyZW1vdmVFdnRMaXN0ZW5lcjpmdW5jdGlvbihhLGIsYyl7cmV0dXJuIGE/YS5yZW1vdmVFdmVudExpc3RlbmVyP2EucmVtb3ZlRXZlbnRMaXN0ZW5lcihiLGMsITEpOmEuZGV0YWNoRXZlbnQoXCJvblwiK2IsYyk6dm9pZCAwfSxkb2N1bWVudElzUmVhZHk6ZnVuY3Rpb24oKXtyZXR1cm5cImNvbXBsZXRlXCI9PT1kb2N1bWVudC5yZWFkeVN0YXRlfSxldnRQcmV2ZW50RGVmYXVsdDpmdW5jdGlvbihhKXthLnByZXZlbnREZWZhdWx0P2EucHJldmVudERlZmF1bHQoKTpldmVudCYmKGV2ZW50LnJldHVyblZhbHVlPSExKX0sZXh0ZW5kOmZ1bmN0aW9uKGEsYil7dmFyIGM7Zm9yKGMgaW4gYiliLmhhc093blByb3BlcnR5KGMpJiYoYVtjXT1iW2NdKX0sZ2V0U3RlcFRhcmdldEhlbHBlcjpmdW5jdGlvbihhKXt2YXIgYj1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChhKTtpZihiKXJldHVybiBiO2lmKHMpcmV0dXJuIGI9alF1ZXJ5KGEpLGIubGVuZ3RoP2JbMF06bnVsbDtpZihwKXJldHVybiBiPW5ldyBwKGEpLGIubGVuZ3RoP2JbMF06bnVsbDtpZihkb2N1bWVudC5xdWVyeVNlbGVjdG9yKXRyeXtyZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihhKX1jYXRjaChjKXt9cmV0dXJuL14jW2EtekEtWl1bXFx3LV86Ll0qJC8udGVzdChhKT9kb2N1bWVudC5nZXRFbGVtZW50QnlJZChhLnN1YnN0cmluZygxKSk6bnVsbH0sZ2V0U3RlcFRhcmdldDpmdW5jdGlvbihhKXt2YXIgYjtpZighYXx8IWEudGFyZ2V0KXJldHVybiBudWxsO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBhLnRhcmdldClyZXR1cm4gaC5nZXRTdGVwVGFyZ2V0SGVscGVyKGEudGFyZ2V0KTtpZihBcnJheS5pc0FycmF5KGEudGFyZ2V0KSl7dmFyIGMsZDtmb3IoYz0wLGQ9YS50YXJnZXQubGVuZ3RoO2Q+YztjKyspaWYoXCJzdHJpbmdcIj09dHlwZW9mIGEudGFyZ2V0W2NdJiYoYj1oLmdldFN0ZXBUYXJnZXRIZWxwZXIoYS50YXJnZXRbY10pKSlyZXR1cm4gYjtyZXR1cm4gbnVsbH1yZXR1cm4gYS50YXJnZXR9LGdldEkxOE5TdHJpbmc6ZnVuY3Rpb24oYSl7cmV0dXJuIGVbYV18fGRbYV19LHNldFN0YXRlOmZ1bmN0aW9uKGEsYixjKXt2YXIgZCxlPVwiXCI7aWYodCYmdSl0cnl7c2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShhLGIpfWNhdGNoKGYpe3U9ITEsdGhpcy5zZXRTdGF0ZShhLGIsYyl9ZWxzZSB0JiZzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKGEpLGMmJihkPW5ldyBEYXRlLGQuc2V0VGltZShkLmdldFRpbWUoKSsyNCpjKjYwKjYwKjFlMyksZT1cIjsgZXhwaXJlcz1cIitkLnRvR01UU3RyaW5nKCkpLGRvY3VtZW50LmNvb2tpZT1hK1wiPVwiK2IrZStcIjsgcGF0aD0vXCJ9LGdldFN0YXRlOmZ1bmN0aW9uKGEpe3ZhciBiLGMsZCxlPWErXCI9XCIsZj1kb2N1bWVudC5jb29raWUuc3BsaXQoXCI7XCIpO2lmKHQmJihkPXNlc3Npb25TdG9yYWdlLmdldEl0ZW0oYSkpKXJldHVybiBkO2ZvcihiPTA7YjxmLmxlbmd0aDtiKyspe2ZvcihjPWZbYl07XCIgXCI9PT1jLmNoYXJBdCgwKTspYz1jLnN1YnN0cmluZygxLGMubGVuZ3RoKTtpZigwPT09Yy5pbmRleE9mKGUpKXtkPWMuc3Vic3RyaW5nKGUubGVuZ3RoLGMubGVuZ3RoKTticmVha319cmV0dXJuIGR9LGNsZWFyU3RhdGU6ZnVuY3Rpb24oYSl7dD9zZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKGEpOnRoaXMuc2V0U3RhdGUoYSxcIlwiLC0xKX0sbm9ybWFsaXplUGxhY2VtZW50OmZ1bmN0aW9uKGEpeyFhLnBsYWNlbWVudCYmYS5vcmllbnRhdGlvbiYmKGEucGxhY2VtZW50PWEub3JpZW50YXRpb24pfSxmbGlwUGxhY2VtZW50OmZ1bmN0aW9uKGEpe2lmKGEuaXNSdGwmJiFhLl9pc0ZsaXBwZWQpe3ZhciBiLGMsZD1bXCJvcmllbnRhdGlvblwiLFwicGxhY2VtZW50XCJdO2EueE9mZnNldCYmKGEueE9mZnNldD0tMSp0aGlzLmdldFBpeGVsVmFsdWUoYS54T2Zmc2V0KSk7Zm9yKGMgaW4gZCliPWRbY10sYS5oYXNPd25Qcm9wZXJ0eShiKSYmdy5oYXNPd25Qcm9wZXJ0eShhW2JdKSYmKGFbYl09d1thW2JdXSk7YS5faXNGbGlwcGVkPSEwfX19LGguYWRkRXZ0TGlzdGVuZXIod2luZG93LFwibG9hZFwiLGspLGk9e25leHQ6W10scHJldjpbXSxzdGFydDpbXSxlbmQ6W10sc2hvdzpbXSxlcnJvcjpbXSxjbG9zZTpbXX0saj17fSxkPXtzdGVwTnVtczpudWxsLG5leHRCdG46XCJOZXh0XCIscHJldkJ0bjpcIkJhY2tcIixkb25lQnRuOlwiRG9uZVwiLHNraXBCdG46XCJTa2lwXCIsY2xvc2VUb29sdGlwOlwiQ2xvc2VcIn0sZT17fSxiPWZ1bmN0aW9uKGEpe3RoaXMuaW5pdChhKX0sYi5wcm90b3R5cGU9e2lzU2hvd2luZzohMSxjdXJyU3RlcDp2b2lkIDAsc2V0UG9zaXRpb246ZnVuY3Rpb24oYSl7dmFyIGIsYyxkLGUsZixnLGksaj1oLmdldFN0ZXBUYXJnZXQoYSksaz10aGlzLmVsZW1lbnQsbD10aGlzLmFycm93RWwsbT1hLmlzUnRsP1wicmlnaHRcIjpcImxlZnRcIjtpZihoLmZsaXBQbGFjZW1lbnQoYSksaC5ub3JtYWxpemVQbGFjZW1lbnQoYSksYz1rLm9mZnNldFdpZHRoLGI9ay5vZmZzZXRIZWlnaHQsaC5yZW1vdmVDbGFzcyhrLFwiZmFkZS1pbi1kb3duIGZhZGUtaW4tdXAgZmFkZS1pbi1sZWZ0IGZhZGUtaW4tcmlnaHRcIiksZD1qLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLGk9YS5pc1J0bD9kLnJpZ2h0LWM6ZC5sZWZ0LFwidG9wXCI9PT1hLnBsYWNlbWVudCllPWQudG9wLWItdGhpcy5vcHQuYXJyb3dXaWR0aCxmPWk7ZWxzZSBpZihcImJvdHRvbVwiPT09YS5wbGFjZW1lbnQpZT1kLmJvdHRvbSt0aGlzLm9wdC5hcnJvd1dpZHRoLGY9aTtlbHNlIGlmKFwibGVmdFwiPT09YS5wbGFjZW1lbnQpZT1kLnRvcCxmPWQubGVmdC1jLXRoaXMub3B0LmFycm93V2lkdGg7ZWxzZXtpZihcInJpZ2h0XCIhPT1hLnBsYWNlbWVudCl0aHJvdyBuZXcgRXJyb3IoXCJCdWJibGUgcGxhY2VtZW50IGZhaWxlZCBiZWNhdXNlIHN0ZXAucGxhY2VtZW50IGlzIGludmFsaWQgb3IgdW5kZWZpbmVkIVwiKTtlPWQudG9wLGY9ZC5yaWdodCt0aGlzLm9wdC5hcnJvd1dpZHRofWc9XCJjZW50ZXJcIiE9PWEuYXJyb3dPZmZzZXQ/aC5nZXRQaXhlbFZhbHVlKGEuYXJyb3dPZmZzZXQpOmEuYXJyb3dPZmZzZXQsZz9cInRvcFwiPT09YS5wbGFjZW1lbnR8fFwiYm90dG9tXCI9PT1hLnBsYWNlbWVudD8obC5zdHlsZS50b3A9XCJcIixcImNlbnRlclwiPT09Zz9sLnN0eWxlW21dPU1hdGguZmxvb3IoYy8yLWwub2Zmc2V0V2lkdGgvMikrXCJweFwiOmwuc3R5bGVbbV09ZytcInB4XCIpOihcImxlZnRcIj09PWEucGxhY2VtZW50fHxcInJpZ2h0XCI9PT1hLnBsYWNlbWVudCkmJihsLnN0eWxlW21dPVwiXCIsXCJjZW50ZXJcIj09PWc/bC5zdHlsZS50b3A9TWF0aC5mbG9vcihiLzItbC5vZmZzZXRIZWlnaHQvMikrXCJweFwiOmwuc3R5bGUudG9wPWcrXCJweFwiKToobC5zdHlsZS50b3A9XCJcIixsLnN0eWxlW21dPVwiXCIpLFwiY2VudGVyXCI9PT1hLnhPZmZzZXQ/Zj1kLmxlZnQrai5vZmZzZXRXaWR0aC8yLWMvMjpmKz1oLmdldFBpeGVsVmFsdWUoYS54T2Zmc2V0KSxcImNlbnRlclwiPT09YS55T2Zmc2V0P2U9ZC50b3Arai5vZmZzZXRIZWlnaHQvMi1iLzI6ZSs9aC5nZXRQaXhlbFZhbHVlKGEueU9mZnNldCksYS5maXhlZEVsZW1lbnR8fChlKz1oLmdldFNjcm9sbFRvcCgpLGYrPWguZ2V0U2Nyb2xsTGVmdCgpKSxrLnN0eWxlLnBvc2l0aW9uPWEuZml4ZWRFbGVtZW50P1wiZml4ZWRcIjpcImFic29sdXRlXCIsay5zdHlsZS50b3A9ZStcInB4XCIsay5zdHlsZS5sZWZ0PWYrXCJweFwifSxyZW5kZXI6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkLGUsZyxpLGosayxsLG4scCxxLHI9dGhpcy5lbGVtZW50O2lmKGE/dGhpcy5jdXJyU3RlcD1hOnRoaXMuY3VyclN0ZXAmJihhPXRoaXMuY3VyclN0ZXApLHRoaXMub3B0LmlzVG91ckJ1YmJsZT8oaT1tLmdldEN1cnJUb3VyKCksaSYmKGU9aS5jdXN0b21EYXRhLGQ9aS5jdXN0b21SZW5kZXJlcixhLmlzUnRsPWEuaGFzT3duUHJvcGVydHkoXCJpc1J0bFwiKT9hLmlzUnRsOmkuaGFzT3duUHJvcGVydHkoXCJpc1J0bFwiKT9pLmlzUnRsOnRoaXMub3B0LmlzUnRsLGc9aS51bnNhZmUsQXJyYXkuaXNBcnJheShpLnN0ZXBzKSYmKGo9aS5zdGVwcy5sZW5ndGgsaz10aGlzLl9nZXRTdGVwSTE4bk51bSh0aGlzLl9nZXRTdGVwTnVtKGotMSkpLG49dGhpcy5fZ2V0U3RlcE51bShiKT09PXRoaXMuX2dldFN0ZXBOdW0oai0xKSkpKTooZT1hLmN1c3RvbURhdGEsZD1hLmN1c3RvbVJlbmRlcmVyLGc9YS51bnNhZmUsYS5pc1J0bD1hLmhhc093blByb3BlcnR5KFwiaXNSdGxcIik/YS5pc1J0bDp0aGlzLm9wdC5pc1J0bCksbD1uP2guZ2V0STE4TlN0cmluZyhcImRvbmVCdG5cIik6YS5zaG93U2tpcD9oLmdldEkxOE5TdHJpbmcoXCJza2lwQnRuXCIpOmguZ2V0STE4TlN0cmluZyhcIm5leHRCdG5cIiksaC5mbGlwUGxhY2VtZW50KGEpLGgubm9ybWFsaXplUGxhY2VtZW50KGEpLHRoaXMucGxhY2VtZW50PWEucGxhY2VtZW50LHE9e2kxOG46e3ByZXZCdG46aC5nZXRJMThOU3RyaW5nKFwicHJldkJ0blwiKSxuZXh0QnRuOmwsY2xvc2VUb29sdGlwOmguZ2V0STE4TlN0cmluZyhcImNsb3NlVG9vbHRpcFwiKSxzdGVwTnVtOnRoaXMuX2dldFN0ZXBJMThuTnVtKHRoaXMuX2dldFN0ZXBOdW0oYikpLG51bVN0ZXBzOmt9LGJ1dHRvbnM6e3Nob3dQcmV2OmgudmFsT3JEZWZhdWx0KGEuc2hvd1ByZXZCdXR0b24sdGhpcy5vcHQuc2hvd1ByZXZCdXR0b24pJiZ0aGlzLl9nZXRTdGVwTnVtKGIpPjAsc2hvd05leHQ6aC52YWxPckRlZmF1bHQoYS5zaG93TmV4dEJ1dHRvbix0aGlzLm9wdC5zaG93TmV4dEJ1dHRvbiksc2hvd0NUQTpoLnZhbE9yRGVmYXVsdChhLnNob3dDVEFCdXR0b24mJmEuY3RhTGFiZWwsITEpLGN0YUxhYmVsOmEuY3RhTGFiZWwsc2hvd0Nsb3NlOmgudmFsT3JEZWZhdWx0KHRoaXMub3B0LnNob3dDbG9zZUJ1dHRvbiwhMCl9LHN0ZXA6e251bTpiLGlzTGFzdDpoLnZhbE9yRGVmYXVsdChuLCExKSx0aXRsZTphLnRpdGxlfHxcIlwiLGNvbnRlbnQ6YS5jb250ZW50fHxcIlwiLGlzUnRsOmEuaXNSdGwscGxhY2VtZW50OmEucGxhY2VtZW50LHBhZGRpbmc6aC52YWxPckRlZmF1bHQoYS5wYWRkaW5nLHRoaXMub3B0LmJ1YmJsZVBhZGRpbmcpLHdpZHRoOmguZ2V0UGl4ZWxWYWx1ZShhLndpZHRoKXx8dGhpcy5vcHQuYnViYmxlV2lkdGgsY3VzdG9tRGF0YTphLmN1c3RvbURhdGF8fHt9fSx0b3VyOntpc1RvdXI6dGhpcy5vcHQuaXNUb3VyQnViYmxlLG51bVN0ZXBzOmosdW5zYWZlOmgudmFsT3JEZWZhdWx0KGcsITEpLGN1c3RvbURhdGE6ZXx8e319fSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBkKXIuaW5uZXJIVE1MPWQocSk7ZWxzZSBpZihcInN0cmluZ1wiPT10eXBlb2YgZCl7aWYoIW0udGVtcGxhdGVzfHxcImZ1bmN0aW9uXCIhPXR5cGVvZiBtLnRlbXBsYXRlc1tkXSl0aHJvdyBuZXcgRXJyb3IoJ0J1YmJsZSByZW5kZXJpbmcgZmFpbGVkIC0gdGVtcGxhdGUgXCInK2QrJ1wiIGlzIG5vdCBhIGZ1bmN0aW9uLicpO3IuaW5uZXJIVE1MPW0udGVtcGxhdGVzW2RdKHEpfWVsc2UgaWYoZilyLmlubmVySFRNTD1mKHEpO2Vsc2V7aWYoIW0udGVtcGxhdGVzfHxcImZ1bmN0aW9uXCIhPXR5cGVvZiBtLnRlbXBsYXRlc1tvXSl0aHJvdyBuZXcgRXJyb3IoJ0J1YmJsZSByZW5kZXJpbmcgZmFpbGVkIC0gdGVtcGxhdGUgXCInK28rJ1wiIGlzIG5vdCBhIGZ1bmN0aW9uLicpO3IuaW5uZXJIVE1MPW0udGVtcGxhdGVzW29dKHEpfXZhciBzLHQ9ci5jaGlsZHJlbix1PXQubGVuZ3RoO2ZvcihwPTA7dT5wO3ArKylzPXRbcF0saC5oYXNDbGFzcyhzLFwiaG9wc2NvdGNoLWFycm93XCIpJiYodGhpcy5hcnJvd0VsPXMpO3JldHVybiByLnN0eWxlLnpJbmRleD1cIm51bWJlclwiPT10eXBlb2YgYS56aW5kZXg/YS56aW5kZXg6XCJcIix0aGlzLl9zZXRBcnJvdyhhLnBsYWNlbWVudCksdGhpcy5oaWRlKCExKSx0aGlzLnNldFBvc2l0aW9uKGEpLGMmJmMoIWEuZml4ZWRFbGVtZW50KSx0aGlzfSxfZ2V0U3RlcE51bTpmdW5jdGlvbihhKXt2YXIgYixjLGQ9MCxlPW0uZ2V0U2tpcHBlZFN0ZXBzSW5kZXhlcygpLGY9ZS5sZW5ndGg7Zm9yKGM9MDtmPmM7YysrKWI9ZVtjXSxhPmImJmQrKztyZXR1cm4gYS1kfSxfZ2V0U3RlcEkxOG5OdW06ZnVuY3Rpb24oYSl7dmFyIGI9aC5nZXRJMThOU3RyaW5nKFwic3RlcE51bXNcIik7cmV0dXJuIGImJmE8Yi5sZW5ndGg/YT1iW2FdOmErPTEsYX0sX3NldEFycm93OmZ1bmN0aW9uKGEpe2gucmVtb3ZlQ2xhc3ModGhpcy5hcnJvd0VsLFwiZG93biB1cCByaWdodCBsZWZ0XCIpLFwidG9wXCI9PT1hP2guYWRkQ2xhc3ModGhpcy5hcnJvd0VsLFwiZG93blwiKTpcImJvdHRvbVwiPT09YT9oLmFkZENsYXNzKHRoaXMuYXJyb3dFbCxcInVwXCIpOlwibGVmdFwiPT09YT9oLmFkZENsYXNzKHRoaXMuYXJyb3dFbCxcInJpZ2h0XCIpOlwicmlnaHRcIj09PWEmJmguYWRkQ2xhc3ModGhpcy5hcnJvd0VsLFwibGVmdFwiKX0sX2dldEFycm93RGlyZWN0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuXCJ0b3BcIj09PXRoaXMucGxhY2VtZW50P1wiZG93blwiOlwiYm90dG9tXCI9PT10aGlzLnBsYWNlbWVudD9cInVwXCI6XCJsZWZ0XCI9PT10aGlzLnBsYWNlbWVudD9cInJpZ2h0XCI6XCJyaWdodFwiPT09dGhpcy5wbGFjZW1lbnQ/XCJsZWZ0XCI6dm9pZCAwfSxzaG93OmZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxiPVwiZmFkZS1pbi1cIit0aGlzLl9nZXRBcnJvd0RpcmVjdGlvbigpLGM9MWUzO3JldHVybiBoLnJlbW92ZUNsYXNzKHRoaXMuZWxlbWVudCxcImhpZGVcIiksaC5hZGRDbGFzcyh0aGlzLmVsZW1lbnQsYiksc2V0VGltZW91dChmdW5jdGlvbigpe2gucmVtb3ZlQ2xhc3MoYS5lbGVtZW50LFwiaW52aXNpYmxlXCIpfSw1MCksc2V0VGltZW91dChmdW5jdGlvbigpe2gucmVtb3ZlQ2xhc3MoYS5lbGVtZW50LGIpfSxjKSx0aGlzLmlzU2hvd2luZz0hMCx0aGlzfSxoaWRlOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZWxlbWVudDtyZXR1cm4gYT1oLnZhbE9yRGVmYXVsdChhLCEwKSxiLnN0eWxlLnRvcD1cIlwiLGIuc3R5bGUubGVmdD1cIlwiLGE/KGguYWRkQ2xhc3MoYixcImhpZGVcIiksaC5yZW1vdmVDbGFzcyhiLFwiaW52aXNpYmxlXCIpKTooaC5yZW1vdmVDbGFzcyhiLFwiaGlkZVwiKSxoLmFkZENsYXNzKGIsXCJpbnZpc2libGVcIikpLGgucmVtb3ZlQ2xhc3MoYixcImFuaW1hdGUgZmFkZS1pbi11cCBmYWRlLWluLWRvd24gZmFkZS1pbi1yaWdodCBmYWRlLWluLWxlZnRcIiksdGhpcy5pc1Nob3dpbmc9ITEsdGhpc30sZGVzdHJveTpmdW5jdGlvbigpe3ZhciBhPXRoaXMuZWxlbWVudDthJiZhLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYSksaC5yZW1vdmVFdnRMaXN0ZW5lcihhLFwiY2xpY2tcIix0aGlzLmNsaWNrQ2IpfSxfaGFuZGxlQnViYmxlQ2xpY2s6ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYihjKXtyZXR1cm4gYz09PWEuY3VycmVudFRhcmdldD9udWxsOmguaGFzQ2xhc3MoYyxcImhvcHNjb3RjaC1jdGFcIik/XCJjdGFcIjpoLmhhc0NsYXNzKGMsXCJob3BzY290Y2gtbmV4dFwiKT9cIm5leHRcIjpoLmhhc0NsYXNzKGMsXCJob3BzY290Y2gtcHJldlwiKT9cInByZXZcIjpoLmhhc0NsYXNzKGMsXCJob3BzY290Y2gtY2xvc2VcIik/XCJjbG9zZVwiOmIoYy5wYXJlbnRFbGVtZW50KX12YXIgYzthPWF8fHdpbmRvdy5ldmVudDt2YXIgZD1hLnRhcmdldHx8YS5zcmNFbGVtZW50O2lmKGM9YihkKSxcImN0YVwiPT09Yyl0aGlzLm9wdC5pc1RvdXJCdWJibGV8fG0uZ2V0Q2FsbG91dE1hbmFnZXIoKS5yZW1vdmVDYWxsb3V0KHRoaXMuY3VyclN0ZXAuaWQpLHRoaXMuY3VyclN0ZXAub25DVEEmJmguaW52b2tlQ2FsbGJhY2sodGhpcy5jdXJyU3RlcC5vbkNUQSk7ZWxzZSBpZihcIm5leHRcIj09PWMpbS5uZXh0U3RlcCghMCk7ZWxzZSBpZihcInByZXZcIj09PWMpbS5wcmV2U3RlcCghMCk7ZWxzZSBpZihcImNsb3NlXCI9PT1jKXtpZih0aGlzLm9wdC5pc1RvdXJCdWJibGUpe3ZhciBlPW0uZ2V0Q3VyclN0ZXBOdW0oKSxmPW0uZ2V0Q3VyclRvdXIoKSxnPWU9PT1mLnN0ZXBzLmxlbmd0aC0xO2guaW52b2tlRXZlbnRDYWxsYmFja3MoXCJjbG9zZVwiKSxtLmVuZFRvdXIoITAsZyl9ZWxzZSB0aGlzLm9wdC5vbkNsb3NlJiZoLmludm9rZUNhbGxiYWNrKHRoaXMub3B0Lm9uQ2xvc2UpLHRoaXMub3B0LmlkJiYhdGhpcy5vcHQuaXNUb3VyQnViYmxlP20uZ2V0Q2FsbG91dE1hbmFnZXIoKS5yZW1vdmVDYWxsb3V0KHRoaXMub3B0LmlkKTp0aGlzLmRlc3Ryb3koKTtoLmV2dFByZXZlbnREZWZhdWx0KGEpfX0saW5pdDpmdW5jdGlvbihhKXt2YXIgYixjLGQsZSxmPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksZz10aGlzLGk9ITE7dGhpcy5lbGVtZW50PWYsZT17c2hvd1ByZXZCdXR0b246bC5zaG93UHJldkJ1dHRvbixzaG93TmV4dEJ1dHRvbjpsLnNob3dOZXh0QnV0dG9uLGJ1YmJsZVdpZHRoOmwuYnViYmxlV2lkdGgsYnViYmxlUGFkZGluZzpsLmJ1YmJsZVBhZGRpbmcsYXJyb3dXaWR0aDpsLmFycm93V2lkdGgsaXNSdGw6bC5pc1J0bCxzaG93TnVtYmVyOiEwLGlzVG91ckJ1YmJsZTohMH0sYT0oXCJ1bmRlZmluZWRcIj09dHlwZW9mIGE/XCJ1bmRlZmluZWRcIjpuKGEpKT09PXE/e306YSxoLmV4dGVuZChlLGEpLHRoaXMub3B0PWUsZi5jbGFzc05hbWU9XCJob3BzY290Y2gtYnViYmxlIGFuaW1hdGVkXCIsZS5pc1RvdXJCdWJibGU/KGQ9bS5nZXRDdXJyVG91cigpLGQmJmguYWRkQ2xhc3MoZixcInRvdXItXCIrZC5pZCkpOmguYWRkQ2xhc3MoZixcImhvcHNjb3RjaC1jYWxsb3V0IG5vLW51bWJlclwiKSxiPWZ1bmN0aW9uKCl7IWkmJmcuaXNTaG93aW5nJiYoaT0hMCxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7Zy5zZXRQb3NpdGlvbihnLmN1cnJTdGVwKSxpPSExfSwxMDApKX0saC5hZGRFdnRMaXN0ZW5lcih3aW5kb3csXCJyZXNpemVcIixiKSx0aGlzLmNsaWNrQ2I9ZnVuY3Rpb24oYSl7Zy5faGFuZGxlQnViYmxlQ2xpY2soYSl9LGguYWRkRXZ0TGlzdGVuZXIoZixcImNsaWNrXCIsdGhpcy5jbGlja0NiKSx0aGlzLmhpZGUoKSxoLmRvY3VtZW50SXNSZWFkeSgpP2RvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZik6KGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXI/KGM9ZnVuY3Rpb24oKXtkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLGMpLHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibG9hZFwiLGMpLGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZil9LGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsYywhMSkpOihjPWZ1bmN0aW9uKCl7XCJjb21wbGV0ZVwiPT09ZG9jdW1lbnQucmVhZHlTdGF0ZSYmKGRvY3VtZW50LmRldGFjaEV2ZW50KFwib25yZWFkeXN0YXRlY2hhbmdlXCIsYyksd2luZG93LmRldGFjaEV2ZW50KFwib25sb2FkXCIsYyksZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmKSl9LGRvY3VtZW50LmF0dGFjaEV2ZW50KFwib25yZWFkeXN0YXRlY2hhbmdlXCIsYykpLGguYWRkRXZ0TGlzdGVuZXIod2luZG93LFwibG9hZFwiLGMpKX19LGM9ZnVuY3Rpb24oKXt2YXIgYT17fSxjPXt9O3RoaXMuY3JlYXRlQ2FsbG91dD1mdW5jdGlvbihkKXt2YXIgZTtpZighZC5pZCl0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHNwZWNpZnkgYSBjYWxsb3V0IGlkLlwiKTtpZighdi50ZXN0KGQuaWQpKXRocm93IG5ldyBFcnJvcihcIkNhbGxvdXQgSUQgaXMgdXNpbmcgYW4gaW52YWxpZCBmb3JtYXQuIFVzZSBhbHBoYW51bWVyaWMsIHVuZGVyc2NvcmVzLCBhbmQvb3IgaHlwaGVucyBvbmx5LiBGaXJzdCBjaGFyYWN0ZXIgbXVzdCBiZSBhIGxldHRlci5cIik7aWYoYVtkLmlkXSl0aHJvdyBuZXcgRXJyb3IoXCJDYWxsb3V0IGJ5IHRoYXQgaWQgYWxyZWFkeSBleGlzdHMuIFBsZWFzZSBjaG9vc2UgYSB1bmlxdWUgaWQuXCIpO2lmKCFoLmdldFN0ZXBUYXJnZXQoZCkpdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBzcGVjaWZ5IGV4aXN0aW5nIHRhcmdldCBlbGVtZW50IHZpYSAndGFyZ2V0JyBvcHRpb24uXCIpO3JldHVybiBkLnNob3dOZXh0QnV0dG9uPWQuc2hvd1ByZXZCdXR0b249ITEsZC5pc1RvdXJCdWJibGU9ITEsZT1uZXcgYihkKSxhW2QuaWRdPWUsY1tkLmlkXT1kLGUucmVuZGVyKGQsbnVsbCxmdW5jdGlvbigpe2Uuc2hvdygpLGQub25TaG93JiZoLmludm9rZUNhbGxiYWNrKGQub25TaG93KX0pLGV9LHRoaXMuZ2V0Q2FsbG91dD1mdW5jdGlvbihiKXtyZXR1cm4gYVtiXX0sdGhpcy5yZW1vdmVBbGxDYWxsb3V0cz1mdW5jdGlvbigpe3ZhciBiO2ZvcihiIGluIGEpYS5oYXNPd25Qcm9wZXJ0eShiKSYmdGhpcy5yZW1vdmVDYWxsb3V0KGIpfSx0aGlzLnJlbW92ZUNhbGxvdXQ9ZnVuY3Rpb24oYil7dmFyIGQ9YVtiXTthW2JdPW51bGwsY1tiXT1udWxsLGQmJmQuZGVzdHJveSgpfSx0aGlzLnJlZnJlc2hDYWxsb3V0UG9zaXRpb25zPWZ1bmN0aW9uKCl7dmFyIGIsZCxlO2ZvcihiIGluIGEpYS5oYXNPd25Qcm9wZXJ0eShiKSYmYy5oYXNPd25Qcm9wZXJ0eShiKSYmKGQ9YVtiXSxlPWNbYl0sZCYmZSYmZC5zZXRQb3NpdGlvbihlKSl9fSxhPWZ1bmN0aW9uKGEpe3ZhciBkLGsscCx0LHUsdyx4LHksej10aGlzLEE9e30sQj1bXSxDPWZ1bmN0aW9uKGEpe3JldHVybiBkJiZkLmVsZW1lbnQmJmQuZWxlbWVudC5wYXJlbnROb2RlfHwoZD1uZXcgYihwKSksYSYmaC5leHRlbmQoZC5vcHQse2J1YmJsZVBhZGRpbmc6RShcImJ1YmJsZVBhZGRpbmdcIiksYnViYmxlV2lkdGg6RShcImJ1YmJsZVdpZHRoXCIpLHNob3dOZXh0QnV0dG9uOkUoXCJzaG93TmV4dEJ1dHRvblwiKSxzaG93UHJldkJ1dHRvbjpFKFwic2hvd1ByZXZCdXR0b25cIiksc2hvd0Nsb3NlQnV0dG9uOkUoXCJzaG93Q2xvc2VCdXR0b25cIiksYXJyb3dXaWR0aDpFKFwiYXJyb3dXaWR0aFwiKSxpc1J0bDpFKFwiaXNSdGxcIil9KSxkfSxEPWZ1bmN0aW9uKCl7ZCYmKGQuZGVzdHJveSgpLGQ9bnVsbCl9LEU9ZnVuY3Rpb24oYSl7cmV0dXJuXCJ1bmRlZmluZWRcIj09dHlwZW9mIHA/bFthXTpoLnZhbE9yRGVmYXVsdChwW2FdLGxbYV0pfSxGPWZ1bmN0aW9uKCl7dmFyIGE7cmV0dXJuIGE9IXR8fDA+dXx8dT49dC5zdGVwcy5sZW5ndGg/bnVsbDp0LnN0ZXBzW3VdfSxHPWZ1bmN0aW9uKCl7ei5uZXh0U3RlcCgpfSxIPWZ1bmN0aW9uKGEpe3ZhciBiLGMsZCxlLGYsZyxpPUMoKSxqPWkuZWxlbWVudCxrPWguZ2V0UGl4ZWxWYWx1ZShqLnN0eWxlLnRvcCksbD1rK2guZ2V0UGl4ZWxWYWx1ZShqLm9mZnNldEhlaWdodCksbT1oLmdldFN0ZXBUYXJnZXQoRigpKSxvPW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkscD1vLnRvcCtoLmdldFNjcm9sbFRvcCgpLHI9by5ib3R0b20raC5nZXRTY3JvbGxUb3AoKSx0PXA+az9rOnAsdT1sPnI/bDpyLHY9aC5nZXRTY3JvbGxUb3AoKSx3PXYraC5nZXRXaW5kb3dIZWlnaHQoKSx4PXQtRShcInNjcm9sbFRvcE1hcmdpblwiKTt0Pj12JiYodDw9ditFKFwic2Nyb2xsVG9wTWFyZ2luXCIpfHx3Pj11KT9hJiZhKCk6RShcInNtb290aFNjcm9sbFwiKT8oXCJ1bmRlZmluZWRcIj09dHlwZW9mIFlBSE9PP1widW5kZWZpbmVkXCI6bihZQUhPTykpIT09cSYmbihZQUhPTy5lbnYpIT09cSYmbihZQUhPTy5lbnYudWEpIT09cSYmbihZQUhPTy51dGlsKSE9PXEmJm4oWUFIT08udXRpbC5TY3JvbGwpIT09cT8oYj1ZQUhPTy5lbnYudWEud2Via2l0P2RvY3VtZW50LmJvZHk6ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LGQ9WUFIT08udXRpbC5FYXNpbmc/WUFIT08udXRpbC5FYXNpbmcuZWFzZU91dDp2b2lkIDAsYz1uZXcgWUFIT08udXRpbC5TY3JvbGwoYix7c2Nyb2xsOnt0bzpbMCx4XX19LEUoXCJzY3JvbGxEdXJhdGlvblwiKS8xZTMsZCksYy5vbkNvbXBsZXRlLnN1YnNjcmliZShhKSxjLmFuaW1hdGUoKSk6cz9qUXVlcnkoXCJib2R5LCBodG1sXCIpLmFuaW1hdGUoe3Njcm9sbFRvcDp4fSxFKFwic2Nyb2xsRHVyYXRpb25cIiksYSk6KDA+eCYmKHg9MCksZT12PnQ/LTE6MSxmPU1hdGguYWJzKHYteCkvKEUoXCJzY3JvbGxEdXJhdGlvblwiKS8xMCksKGc9ZnVuY3Rpb24oKXt2YXIgYj1oLmdldFNjcm9sbFRvcCgpLGM9YitlKmY7cmV0dXJuIGU+MCYmYz49eHx8MD5lJiZ4Pj1jPyhjPXgsYSYmYSgpLHZvaWQgd2luZG93LnNjcm9sbFRvKDAsYykpOih3aW5kb3cuc2Nyb2xsVG8oMCxjKSxoLmdldFNjcm9sbFRvcCgpPT09Yj92b2lkKGEmJmEoKSk6dm9pZCBzZXRUaW1lb3V0KGcsMTApKX0pKCkpOih3aW5kb3cuc2Nyb2xsVG8oMCx4KSxhJiZhKCkpfSxJPWZ1bmN0aW9uIFAoYSxiKXt2YXIgYyxkLGU7dSthPj0wJiZ1K2E8dC5zdGVwcy5sZW5ndGg/KHUrPWEsZD1GKCksZT1mdW5jdGlvbigpe2M9aC5nZXRTdGVwVGFyZ2V0KGQpLGM/KEFbdV0mJmRlbGV0ZSBBW3VdLGIodSkpOihBW3VdPSEwLGguaW52b2tlRXZlbnRDYWxsYmFja3MoXCJlcnJvclwiKSxQKGEsYikpfSxkLmRlbGF5P3NldFRpbWVvdXQoZSxkLmRlbGF5KTplKCkpOmIoLTEpfSxKPWZ1bmN0aW9uKGEsYil7dmFyIGMsZCxlLGYsZz1DKCksaT10aGlzO2lmKGcuaGlkZSgpLGE9aC52YWxPckRlZmF1bHQoYSwhMCksYz1GKCksYy5uZXh0T25UYXJnZXRDbGljayYmaC5yZW1vdmVFdnRMaXN0ZW5lcihoLmdldFN0ZXBUYXJnZXQoYyksXCJjbGlja1wiLEcpLGQ9YyxlPWI+MD9kLm11bHRpcGFnZTp1PjAmJnQuc3RlcHNbdS0xXS5tdWx0aXBhZ2UsZj1mdW5jdGlvbihjKXt2YXIgZjtpZigtMT09PWMpcmV0dXJuIHRoaXMuZW5kVG91cighMCk7aWYoYSYmKGY9Yj4wP2guaW52b2tlRXZlbnRDYWxsYmFja3MoXCJuZXh0XCIsZC5vbk5leHQpOmguaW52b2tlRXZlbnRDYWxsYmFja3MoXCJwcmV2XCIsZC5vblByZXYpKSxjPT09dSl7aWYoZSlyZXR1cm4gdm9pZCBOKCk7Zj1oLnZhbE9yRGVmYXVsdChmLCEwKSxmP3RoaXMuc2hvd1N0ZXAoYyk6dGhpcy5lbmRUb3VyKCExKX19LCFlJiZFKFwic2tpcElmTm9FbGVtZW50XCIpKUkoYixmdW5jdGlvbihhKXtmLmNhbGwoaSxhKX0pO2Vsc2UgaWYodStiPj0wJiZ1K2I8dC5zdGVwcy5sZW5ndGgpe2lmKHUrPWIsYz1GKCksIWguZ2V0U3RlcFRhcmdldChjKSYmIWUpcmV0dXJuIGguaW52b2tlRXZlbnRDYWxsYmFja3MoXCJlcnJvclwiKSx0aGlzLmVuZFRvdXIoITAsITEpO2YuY2FsbCh0aGlzLHUpfWVsc2UgaWYodStiPT09dC5zdGVwcy5sZW5ndGgpcmV0dXJuIHRoaXMuZW5kVG91cigpO3JldHVybiB0aGlzfSxLPWZ1bmN0aW9uKGEpe3ZhciBiLGMsZCxlPXt9O2ZvcihiIGluIGEpYS5oYXNPd25Qcm9wZXJ0eShiKSYmXCJpZFwiIT09YiYmXCJzdGVwc1wiIT09YiYmKGVbYl09YVtiXSk7cmV0dXJuIHkuY2FsbCh0aGlzLGUsITApLGM9aC5nZXRTdGF0ZShFKFwiY29va2llTmFtZVwiKSksYyYmKGQ9Yy5zcGxpdChcIjpcIiksdz1kWzBdLHg9ZFsxXSxkLmxlbmd0aD4yJiYoQj1kWzJdLnNwbGl0KFwiLFwiKSkseD1wYXJzZUludCh4LDEwKSksdGhpc30sTD1mdW5jdGlvbihhLGIsYyl7dmFyIGQsZTtpZih1PWF8fDAsQT1ifHx7fSxkPUYoKSxlPWguZ2V0U3RlcFRhcmdldChkKSlyZXR1cm4gdm9pZCBjKHUpO2lmKCFlKXtpZihoLmludm9rZUV2ZW50Q2FsbGJhY2tzKFwiZXJyb3JcIiksQVt1XT0hMCxFKFwic2tpcElmTm9FbGVtZW50XCIpKXJldHVybiB2b2lkIEkoMSxjKTt1PS0xLGModSl9fSxNPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGIoKXtkLnNob3coKSxoLmludm9rZUV2ZW50Q2FsbGJhY2tzKFwic2hvd1wiLGMub25TaG93KX12YXIgYz10LnN0ZXBzW2FdLGQ9QygpLGU9aC5nZXRTdGVwVGFyZ2V0KGMpO3UhPT1hJiZGKCkubmV4dE9uVGFyZ2V0Q2xpY2smJmgucmVtb3ZlRXZ0TGlzdGVuZXIoaC5nZXRTdGVwVGFyZ2V0KEYoKSksXCJjbGlja1wiLEcpLHU9YSxkLmhpZGUoITEpLGQucmVuZGVyKGMsYSxmdW5jdGlvbihhKXthP0goYik6YigpLGMubmV4dE9uVGFyZ2V0Q2xpY2smJmguYWRkRXZ0TGlzdGVuZXIoZSxcImNsaWNrXCIsRyl9KSxOKCl9LE49ZnVuY3Rpb24oKXt2YXIgYT10LmlkK1wiOlwiK3UsYj1tLmdldFNraXBwZWRTdGVwc0luZGV4ZXMoKTtiJiZiLmxlbmd0aD4wJiYoYSs9XCI6XCIrYi5qb2luKFwiLFwiKSksaC5zZXRTdGF0ZShFKFwiY29va2llTmFtZVwiKSxhLDEpfSxPPWZ1bmN0aW9uKGEpe2EmJnRoaXMuY29uZmlndXJlKGEpfTt0aGlzLmdldENhbGxvdXRNYW5hZ2VyPWZ1bmN0aW9uKCl7cmV0dXJuKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBrP1widW5kZWZpbmVkXCI6bihrKSk9PT1xJiYoaz1uZXcgYyksa30sdGhpcy5zdGFydFRvdXI9ZnVuY3Rpb24oYSxiKXt2YXIgYyxkLGU9e30sZj10aGlzO2lmKCF0KXtpZighYSl0aHJvdyBuZXcgRXJyb3IoXCJUb3VyIGRhdGEgaXMgcmVxdWlyZWQgZm9yIHN0YXJ0VG91ci5cIik7aWYoIWEuaWR8fCF2LnRlc3QoYS5pZCkpdGhyb3cgbmV3IEVycm9yKFwiVG91ciBJRCBpcyB1c2luZyBhbiBpbnZhbGlkIGZvcm1hdC4gVXNlIGFscGhhbnVtZXJpYywgdW5kZXJzY29yZXMsIGFuZC9vciBoeXBoZW5zIG9ubHkuIEZpcnN0IGNoYXJhY3RlciBtdXN0IGJlIGEgbGV0dGVyLlwiKTt0PWEsSy5jYWxsKHRoaXMsYSl9aWYoKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBiP1widW5kZWZpbmVkXCI6bihiKSkhPT1xKXtpZihiPj10LnN0ZXBzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJTcGVjaWZpZWQgc3RlcCBudW1iZXIgb3V0IG9mIGJvdW5kcy5cIik7ZD1ifWlmKCFoLmRvY3VtZW50SXNSZWFkeSgpKXJldHVybiByPSEwLHRoaXM7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIGQmJnQuaWQ9PT13JiYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIHg/XCJ1bmRlZmluZWRcIjpuKHgpKSE9PXEpe2lmKGQ9eCxCLmxlbmd0aD4wKWZvcih2YXIgZz0wLGk9Qi5sZW5ndGg7aT5nO2crKyllW0JbZ11dPSEwfWVsc2UgZHx8KGQ9MCk7cmV0dXJuIEwoZCxlLGZ1bmN0aW9uKGEpe3ZhciBiPS0xIT09YSYmaC5nZXRTdGVwVGFyZ2V0KHQuc3RlcHNbYV0pO3JldHVybiBiPyhoLmludm9rZUV2ZW50Q2FsbGJhY2tzKFwic3RhcnRcIiksYz1DKCksYy5oaWRlKCExKSxmLmlzQWN0aXZlPSEwLHZvaWQoaC5nZXRTdGVwVGFyZ2V0KEYoKSk/Zi5zaG93U3RlcChhKTooaC5pbnZva2VFdmVudENhbGxiYWNrcyhcImVycm9yXCIpLEUoXCJza2lwSWZOb0VsZW1lbnRcIikmJmYubmV4dFN0ZXAoITEpKSkpOnZvaWQgZi5lbmRUb3VyKCExLCExKX0pLHRoaXN9LHRoaXMuc2hvd1N0ZXA9ZnVuY3Rpb24oYSl7dmFyIGI9dC5zdGVwc1thXSxjPXU7cmV0dXJuIGguZ2V0U3RlcFRhcmdldChiKT8oYi5kZWxheT9zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7TShhKX0sYi5kZWxheSk6TShhKSx0aGlzKToodT1hLGguaW52b2tlRXZlbnRDYWxsYmFja3MoXCJlcnJvclwiKSx2b2lkKHU9YykpfSx0aGlzLnByZXZTdGVwPWZ1bmN0aW9uKGEpe3JldHVybiBKLmNhbGwodGhpcyxhLC0xKSx0aGlzfSx0aGlzLm5leHRTdGVwPWZ1bmN0aW9uKGEpe3JldHVybiBKLmNhbGwodGhpcyxhLDEpLHRoaXN9LHRoaXMuZW5kVG91cj1mdW5jdGlvbihhLGIpe3ZhciBjLGQ9QygpO3JldHVybiBhPWgudmFsT3JEZWZhdWx0KGEsITApLGI9aC52YWxPckRlZmF1bHQoYiwhMCksdCYmKGM9RigpLGMmJmMubmV4dE9uVGFyZ2V0Q2xpY2smJmgucmVtb3ZlRXZ0TGlzdGVuZXIoaC5nZXRTdGVwVGFyZ2V0KGMpLFwiY2xpY2tcIixHKSksdT0wLHg9dm9pZCAwLGQuaGlkZSgpLGEmJmguY2xlYXJTdGF0ZShFKFwiY29va2llTmFtZVwiKSksdGhpcy5pc0FjdGl2ZSYmKHRoaXMuaXNBY3RpdmU9ITEsdCYmYiYmaC5pbnZva2VFdmVudENhbGxiYWNrcyhcImVuZFwiKSksdGhpcy5yZW1vdmVDYWxsYmFja3MobnVsbCwhMCksdGhpcy5yZXNldERlZmF1bHRPcHRpb25zKCksRCgpLHQ9bnVsbCx0aGlzfSx0aGlzLmdldEN1cnJUb3VyPWZ1bmN0aW9uKCl7cmV0dXJuIHR9LHRoaXMuZ2V0Q3VyclRhcmdldD1mdW5jdGlvbigpe3JldHVybiBoLmdldFN0ZXBUYXJnZXQoRigpKX0sdGhpcy5nZXRDdXJyU3RlcE51bT1mdW5jdGlvbigpe3JldHVybiB1fSx0aGlzLmdldFNraXBwZWRTdGVwc0luZGV4ZXM9ZnVuY3Rpb24oKXt2YXIgYSxiPVtdO2ZvcihhIGluIEEpYi5wdXNoKGEpO3JldHVybiBifSx0aGlzLnJlZnJlc2hCdWJibGVQb3NpdGlvbj1mdW5jdGlvbigpe3ZhciBhPUYoKTtyZXR1cm4gYSYmQygpLnNldFBvc2l0aW9uKGEpLHRoaXMuZ2V0Q2FsbG91dE1hbmFnZXIoKS5yZWZyZXNoQ2FsbG91dFBvc2l0aW9ucygpLHRoaXN9LHRoaXMubGlzdGVuPWZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gYSYmaVthXS5wdXNoKHtjYjpiLGZyb21Ub3VyOmN9KSx0aGlzfSx0aGlzLnVubGlzdGVuPWZ1bmN0aW9uKGEsYil7dmFyIGMsZCxlPWlbYV07Zm9yKGM9MCxkPWUubGVuZ3RoO2Q+YzsrK2MpZVtjXS5jYj09PWImJmUuc3BsaWNlKGMsMSk7cmV0dXJuIHRoaXN9LHRoaXMucmVtb3ZlQ2FsbGJhY2tzPWZ1bmN0aW9uKGEsYil7dmFyIGMsZCxlLGY7Zm9yKGYgaW4gaSlpZighYXx8YT09PWYpaWYoYilmb3IoYz1pW2ZdLGQ9MCxlPWMubGVuZ3RoO2U+ZDsrK2QpY1tkXS5mcm9tVG91ciYmKGMuc3BsaWNlKGQtLSwxKSwtLWUpO2Vsc2UgaVtmXT1bXTtyZXR1cm4gdGhpc30sdGhpcy5yZWdpc3RlckhlbHBlcj1mdW5jdGlvbihhLGIpe1wic3RyaW5nXCI9PXR5cGVvZiBhJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBiJiYoalthXT1iKX0sdGhpcy51bnJlZ2lzdGVySGVscGVyPWZ1bmN0aW9uKGEpe2pbYV09bnVsbH0sdGhpcy5pbnZva2VIZWxwZXI9ZnVuY3Rpb24oYSl7dmFyIGIsYyxkPVtdO2ZvcihiPTEsYz1hcmd1bWVudHMubGVuZ3RoO2M+YjsrK2IpZC5wdXNoKGFyZ3VtZW50c1tiXSk7althXSYmalthXS5jYWxsKG51bGwsZCl9LHRoaXMuc2V0Q29va2llTmFtZT1mdW5jdGlvbihhKXtyZXR1cm4gcC5jb29raWVOYW1lPWEsdGhpc30sdGhpcy5yZXNldERlZmF1bHRPcHRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuIHA9e30sdGhpc30sdGhpcy5yZXNldERlZmF1bHRJMThOPWZ1bmN0aW9uKCl7cmV0dXJuIGU9e30sdGhpc30sdGhpcy5nZXRTdGF0ZT1mdW5jdGlvbigpe3JldHVybiBoLmdldFN0YXRlKEUoXCJjb29raWVOYW1lXCIpKX0seT1mdW5jdGlvbihhLGIpe3ZhciBjLGQsZixnLGk9W1wibmV4dFwiLFwicHJldlwiLFwic3RhcnRcIixcImVuZFwiLFwic2hvd1wiLFwiZXJyb3JcIixcImNsb3NlXCJdO2ZvcihwfHx0aGlzLnJlc2V0RGVmYXVsdE9wdGlvbnMoKSxoLmV4dGVuZChwLGEpLGEmJmguZXh0ZW5kKGUsYS5pMThuKSxmPTAsZz1pLmxlbmd0aDtnPmY7KytmKWQ9XCJvblwiK2lbZl0uY2hhckF0KDApLnRvVXBwZXJDYXNlKCkraVtmXS5zdWJzdHJpbmcoMSksYVtkXSYmdGhpcy5saXN0ZW4oaVtmXSxhW2RdLGIpO3JldHVybiBjPUMoITApLHRoaXN9LHRoaXMuY29uZmlndXJlPWZ1bmN0aW9uKGEpe3JldHVybiB5LmNhbGwodGhpcyxhLCExKX0sdGhpcy5zZXRSZW5kZXJlcj1mdW5jdGlvbihhKXt2YXIgYj1cInVuZGVmaW5lZFwiPT10eXBlb2YgYT9cInVuZGVmaW5lZFwiOm4oYSk7cmV0dXJuXCJzdHJpbmdcIj09PWI/KG89YSxmPXZvaWQgMCk6XCJmdW5jdGlvblwiPT09YiYmKGY9YSksdGhpc30sdGhpcy5zZXRFc2NhcGVyPWZ1bmN0aW9uKGEpe3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIGEmJihnPWEpLHRoaXN9LE8uY2FsbCh0aGlzLGEpfSxtPW5ldyBhLGZ1bmN0aW9uKCl7dmFyIGE9e307YS5lc2NhcGU9ZnVuY3Rpb24oYSl7cmV0dXJuIGc/ZyhhKTpudWxsPT1hP1wiXCI6KFwiXCIrYSkucmVwbGFjZShuZXcgUmVnRXhwKFwiWyY8PlxcXCInXVwiLFwiZ1wiKSxmdW5jdGlvbihhKXtyZXR1cm5cIiZcIj09YT9cIiZhbXA7XCI6XCI8XCI9PWE/XCImbHQ7XCI6XCI+XCI9PWE/XCImZ3Q7XCI6J1wiJz09YT9cIiZxdW90O1wiOlwiJ1wiPT1hP1wiJiN4Mjc7XCI6dm9pZCAwfSl9LHRoaXMudGVtcGxhdGVzPXRoaXMudGVtcGxhdGVzfHx7fSx0aGlzLnRlbXBsYXRlcy5idWJibGVfZGVmYXVsdD1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGIsYyl7cmV0dXJuIGM/YS5lc2NhcGUoYik6Yn12YXIgZCxlPVwiXCI7YS5lc2NhcGUsQXJyYXkucHJvdG90eXBlLmpvaW47ZSs9XCJcXG5cIjt2YXIgZj1iLmkxOG4sZz1iLmJ1dHRvbnMsaD1iLnN0ZXAsaT1iLnRvdXI7cmV0dXJuIGUrPSdcXG48ZGl2IGNsYXNzPVwiaG9wc2NvdGNoLWJ1YmJsZS1jb250YWluZXJcIiBzdHlsZT1cIndpZHRoOiAnKyhudWxsPT0oZD1oLndpZHRoKT9cIlwiOmQpK1wicHg7IHBhZGRpbmc6IFwiKyhudWxsPT0oZD1oLnBhZGRpbmcpP1wiXCI6ZCkrJ3B4O1wiPlxcbiAgJyxpLmlzVG91ciYmKGUrPSc8c3BhbiBjbGFzcz1cImhvcHNjb3RjaC1idWJibGUtbnVtYmVyXCI+JysobnVsbD09KGQ9Zi5zdGVwTnVtKT9cIlwiOmQpK1wiPC9zcGFuPlwiKSxlKz0nXFxuICA8ZGl2IGNsYXNzPVwiaG9wc2NvdGNoLWJ1YmJsZS1jb250ZW50XCI+XFxuICAgICcsXCJcIiE9PWgudGl0bGUmJihlKz0nPGgzIGNsYXNzPVwiaG9wc2NvdGNoLXRpdGxlXCI+JysobnVsbD09KGQ9YyhoLnRpdGxlLGkudW5zYWZlKSk/XCJcIjpkKStcIjwvaDM+XCIpLGUrPVwiXFxuICAgIFwiLFwiXCIhPT1oLmNvbnRlbnQmJihlKz0nPGRpdiBjbGFzcz1cImhvcHNjb3RjaC1jb250ZW50XCI+JysobnVsbD09KGQ9YyhoLmNvbnRlbnQsaS51bnNhZmUpKT9cIlwiOmQpK1wiPC9kaXY+XCIpLGUrPSdcXG4gIDwvZGl2PlxcbiAgPGRpdiBjbGFzcz1cImhvcHNjb3RjaC1hY3Rpb25zXCI+XFxuICAgICcsZy5zaG93UHJldiYmKGUrPSc8YnV0dG9uIGNsYXNzPVwiaG9wc2NvdGNoLW5hdi1idXR0b24gcHJldiBob3BzY290Y2gtcHJldlwiPicrKG51bGw9PShkPWYucHJldkJ0bik/XCJcIjpkKStcIjwvYnV0dG9uPlwiKSxlKz1cIlxcbiAgICBcIixnLnNob3dDVEEmJihlKz0nPGJ1dHRvbiBjbGFzcz1cImhvcHNjb3RjaC1uYXYtYnV0dG9uIG5leHQgaG9wc2NvdGNoLWN0YVwiPicrKG51bGw9PShkPWcuY3RhTGFiZWwpP1wiXCI6ZCkrXCI8L2J1dHRvbj5cIiksZSs9XCJcXG4gICAgXCIsZy5zaG93TmV4dCYmKGUrPSc8YnV0dG9uIGNsYXNzPVwiaG9wc2NvdGNoLW5hdi1idXR0b24gbmV4dCBob3BzY290Y2gtbmV4dFwiPicrKG51bGw9PShkPWYubmV4dEJ0bik/XCJcIjpkKStcIjwvYnV0dG9uPlwiKSxlKz1cIlxcbiAgPC9kaXY+XFxuICBcIixnLnNob3dDbG9zZSYmKGUrPSc8YnV0dG9uIGNsYXNzPVwiaG9wc2NvdGNoLWJ1YmJsZS1jbG9zZSBob3BzY290Y2gtY2xvc2VcIj4nKyhudWxsPT0oZD1mLmNsb3NlVG9vbHRpcCk/XCJcIjpkKStcIjwvYnV0dG9uPlwiKSxlKz0nXFxuPC9kaXY+XFxuPGRpdiBjbGFzcz1cImhvcHNjb3RjaC1idWJibGUtYXJyb3ctY29udGFpbmVyIGhvcHNjb3RjaC1hcnJvd1wiPlxcbiAgPGRpdiBjbGFzcz1cImhvcHNjb3RjaC1idWJibGUtYXJyb3ctYm9yZGVyXCI+PC9kaXY+XFxuICA8ZGl2IGNsYXNzPVwiaG9wc2NvdGNoLWJ1YmJsZS1hcnJvd1wiPjwvZGl2PlxcbjwvZGl2Plxcbid9fS5jYWxsKG0pO3ZhciB5PW07cmV0dXJuIHl9KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vaG9wc2NvdGNoL2Rpc3QvanMvaG9wc2NvdGNoLm1pbi5qc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4\n')},function(module,exports){eval('var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function("return this")() || (1,eval)("this");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === "object")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it\'s\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzPzM2OTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUMiLCJmaWxlIjoiNS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBnO1xyXG5cclxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcclxuZyA9IChmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufSkoKTtcclxuXHJcbnRyeSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXHJcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLGV2YWwpKFwidGhpc1wiKTtcclxufSBjYXRjaChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZih0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKVxyXG5cdFx0ZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5\n')},function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\nexports.get_width = get_width;\nexports.linechart = linechart;\nexports.explore = explore;\nexports.callTreeApp = callTreeApp;\n\nvar _mithril = __webpack_require__(0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _app = __webpack_require__(1);\n\nvar app = _interopRequireWildcard(_app);\n\nvar _plots = __webpack_require__(2);\n\nvar plots = _interopRequireWildcard(_plots);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar $private = false;\n\nfunction heatmap(x_Axis_name, y_Axis_name) {\n    document.getElementById(\'heatchart\').style.display = "block";\n    d3.select("#heatchart").select("svg").remove();\n    $(\'#heatchart\').html("");\n\n    var margin_heat = { top: 30, right: 10, bottom: 60, left: 60 },\n        width_heat = 500 - margin_heat.left - margin_heat.right,\n        height_heat = 300 - margin_heat.top - margin_heat.bottom;\n    var padding = 100;\n\n    var min_x = d3.min(data_plot, function (d, i) {\n        return data_plot[i].xaxis;\n    });\n    var max_x = d3.max(data_plot, function (d, i) {\n        return data_plot[i].xaxis;\n    });\n    var avg_x = (max_x - min_x) / 100;\n    var min_y = d3.min(data_plot, function (d, i) {\n        return data_plot[i].yaxis;\n    });\n    var max_y = d3.max(data_plot, function (d, i) {\n        return data_plot[i].yaxis;\n    });\n    var avg_y = (max_y - min_y) / 100;\n\n    var x = d3.scale.linear().domain([min_x - avg_x, max_x + avg_x]).range([0, width_heat]);\n\n    var y = d3.scale.linear().domain([min_y - avg_y, max_y + avg_y]).range([height_heat, 0]);\n\n    var z = d3.scale.linear().range(["#EF9A9A", "#EF5350"]);\n\n    // This could be inferred from the data if it weren\'t sparse.\n    var xStep = avg_x + 0.1,\n        yStep = avg_y + 0.2;\n    var svg_heat = d3.select("#heatchart").append("svg").attr("width", width_heat + margin_heat.left + margin_heat.right).attr("height", height_heat + margin_heat.top + margin_heat.bottom).append("g").attr("transform", "translate(" + margin_heat.left + "," + margin_heat.top + ")").style("background-color", "#FFEBEE");\n\n    // Compute the scale domains.\n    x.domain(d3.extent(data_plot, function (d, i) {\n        return data_plot[i].xaxis;\n    }));\n    y.domain(d3.extent(data_plot, function (d, i) {\n        return data_plot[i].yaxis;\n    }));\n    z.domain([0, d3.max(data_plot, function (d, i) {\n        return data_plot[i].score;\n    })]);\n\n    // Extend the x- and y-domain to fit the last bucket.\n    // For example, the y-bucket 3200 corresponds to values [3200, 3300].\n    x.domain([x.domain()[0], +x.domain()[1] + xStep]);\n    y.domain([y.domain()[0], y.domain()[1] + yStep]);\n\n    // Display the tiles for each non-zero bucket.\n    // See http://bl.ocks.org/3074470 for an alternative implementation.\n    svg_heat.selectAll(".tile").data(data_plot).enter().append("rect").attr("class", "tile").attr("x", function (d, i) {\n        return x(data_plot[i].xaxis);\n    }).attr("y", function (d, i) {\n        return y(data_plot[i].yaxis + yStep);\n    }).attr("width", 15).attr("height", 15).attr("dx", ".35em").attr("dy", ".35em").style("fill", function (d, i) {\n        return z(data_plot[i].score);\n    });\n\n    svg_heat.append("text").attr("class", "label").attr("x", width_heat + 20).attr("y", 10).attr("dy", ".35em").text("Count");\n\n    // Add an x-axis with label.\n    svg_heat.append("g").attr("class", "x axis").attr("transform", "translate(0," + height_heat + ")").call(d3.svg.axis().scale(x).ticks(5).tickSize(-height_heat).orient("bottom")).append("text").attr("class", "label").attr("x", width_heat).attr("y", -6).attr("text-anchor", "end").text("");\n\n    // Add a y-axis with label.\n    svg_heat.append("g").attr("class", "y axis").call(d3.svg.axis().scale(y).tickSize(-width_heat).orient("left")).append("text").attr("class", "label").attr("y", 6).attr("dy", ".71em").attr("text-anchor", "end").attr("transform", "rotate(-90)").text("");\n\n    svg_heat.append("text").attr("text-anchor", "middle") // this makes it easy to centre the text as the transform is applied to the anchor\n    .attr("transform", "translate(-40," + height_heat / 2 + ")rotate(-90)") // text is drawn off the screen top left, move down and out and rotate\n    .text(y_Axis_name).style("fill", "#424242").style("text-indent", "20px").style("font-size", "12px").style("font-weight", "bold");\n\n    svg_heat.append("text").attr("text-anchor", "middle") // this makes it easy to centre the text as the transform is applied to the anchor\n    .attr("transform", "translate(" + width_heat / 2 + "," + (height_heat + padding / 4) + ")") // centre below axis\n    .text(x_Axis_name).style("fill", "#424242").style("text-indent", "20px").style("font-size", "12px").style("font-weight", "bold");\n}\n\nvar heatxaxis = void 0,\n    heatyaxis = void 0;\nvar data_plot = [];\n\nfunction bivariatePlot(x_Axis, y_Axis, x_Axis_name, y_Axis_name) {\n    heatxaxis = x_Axis_name;\n    heatyaxis = y_Axis_name;\n    app.byId(\'scatterplot\').style.display = \'block\';\n    d3.select("#scatterplot").html("");\n    d3.select("#scatterplot").select("svg").remove();\n\n    // scatter plot\n    data_plot = [];\n    var nanCount = 0;\n    for (var i = 0; i < 1000; i++) {\n        if (isNaN(x_Axis[i]) || isNaN(y_Axis[i])) {\n            nanCount++;\n        } else {\n            var newNumber1 = x_Axis[i];\n            var newNumber2 = y_Axis[i];\n            data_plot.push({ xaxis: newNumber1, yaxis: newNumber2, score: Math.random() * 100 });\n        }\n    }\n\n    var margin = { top: 20, right: 15, bottom: 40, left: 60 },\n        width = 500 - margin.left - margin.right,\n        height = 280 - margin.top - margin.bottom,\n        padding = 100;\n\n    var min_x = d3.min(data_plot, function (_, i) {\n        return data_plot[i].xaxis;\n    });\n    var max_x = d3.max(data_plot, function (_, i) {\n        return data_plot[i].xaxis;\n    });\n    var avg_x = (max_x - min_x) / 10;\n    var min_y = d3.min(data_plot, function (d, i) {\n        return data_plot[i].yaxis;\n    });\n    var max_y = d3.max(data_plot, function (d, i) {\n        return data_plot[i].yaxis;\n    });\n    var avg_y = (max_y - min_y) / 10;\n\n    var xScale = d3.scale.linear().domain([min_x - avg_x, max_x + avg_x]).range([0, width]);\n\n    var yScale = d3.scale.linear().domain([min_y - avg_y, max_y + avg_y]).range([height, 0]);\n\n    var xAxis = d3.svg.axis().scale(xScale).orient(\'bottom\').tickSize(-height);\n\n    var yAxis = d3.svg.axis().scale(yScale).orient(\'left\').ticks(5).tickSize(-width);\n\n    var zoom = d3.behavior.zoom().x(xScale).y(yScale).scaleExtent([1, 10]).on("zoom", zoomed);\n\n    var chart_scatter = d3.select(\'#scatterplot\').append(\'svg:svg\').attr(\'width\', width + margin.right + margin.left).attr(\'height\', height + margin.top + margin.bottom).call(zoom);\n\n    var main1 = chart_scatter.append(\'g\').attr(\'transform\', \'translate(\' + margin.left + \',\' + margin.top + \')\').attr(\'width\', width + margin.right + margin.left).attr(\'height\', height + margin.top + margin.bottom).attr(\'class\', \'main\');\n\n    main1.append(\'g\').attr(\'transform\', \'translate(0,\' + height + \')\').attr(\'class\', \'x axis\').call(xAxis);\n\n    main1.append(\'g\').attr(\'transform\', \'translate(0,0)\').attr(\'class\', \'y axis\').call(yAxis);\n\n    var clip = main1.append("defs").append("svg:clipPath").attr("id", "clip").append("svg:rect").attr("id", "clip-rect").attr("x", "0").attr("y", "0").attr(\'width\', width).attr(\'height\', height);\n\n    main1.append("g").attr("clip-path", "url(#clip)").selectAll("circle").data(data_plot).enter().append("circle").attr("cx", function (_, i) {\n        return xScale(data_plot[i].xaxis);\n    }).attr("cy", function (_, i) {\n        return yScale(data_plot[i].yaxis);\n    }).attr("r", 2).style("fill", "#B71C1C");\n    chart_scatter.append("text").attr("text-anchor", "middle") // this makes it easy to centre the text as the transform is applied to the anchor\n    .attr("transform", "translate(" + padding / 5 + "," + height / 2 + ")rotate(-90)") // text is drawn off the screen top left, move down and out and rotate\n    .text(y_Axis_name).style("fill", "#424242").style("text-indent", "20px").style("font-size", "12px").style("font-weight", "bold");\n\n    chart_scatter.append("text").attr("text-anchor", "middle") // this makes it easy to centre the text as the transform is applied to the anchor\n    .attr("transform", "translate(" + width / 2 + "," + (height + padding / 2) + ")") // centre below axis\n    .text(x_Axis_name).style("fill", "#424242").style("text-indent", "20px").style("font-size", "12px").style("font-weight", "bold");\n\n    function zoomed() {\n        var panX = d3.event.translate[0];\n        var panY = d3.event.translate[1];\n        var scale = d3.event.scale;\n\n        panX = panX > 10 ? 10 : panX;\n        var maxX = -(scale - 1) * width - 10;\n        panX = panX < maxX ? maxX : panX;\n\n        panY = panY > 10 ? 10 : panY;\n        var maxY = -(scale - 1) * height - 10;\n        panY = panY < maxY ? maxY : panY;\n\n        zoom.translate([panX, panY]);\n\n        main1.select(".x.axis").call(xAxis);\n        main1.select(".y.axis").call(yAxis);\n        main1.selectAll("circle").attr("cx", function (_, i) {\n            return xScale(data_plot[i].xaxis);\n        }).attr("cy", function (_, i) {\n            return yScale(data_plot[i].yaxis);\n        }).attr("r", 2.5).style("fill", "#B71C1C");\n    }\n\n    d3.select(\'#NAcount\').style(\'display\', \'block\');\n    d3.select("#NAcount").text("There are " + nanCount + " number of NA values in the relation.");\n}\n\nvar plotnamea = void 0,\n    plotnameb = void 0,\n    varn1 = void 0,\n    varn2 = void 0,\n    varsize1 = void 0,\n    varsize2 = void 0;\n\nvar continuous_n = 0;\nvar bar_n = 0;\n\nfunction get_width(id) {\n    return 50 * (id === \'plotA\' ? continuous_n : bar_n);\n}\n\nfunction crossTabPlots(PlotNameA, PlotNameB, json_obj) {\n    plotnamea = PlotNameA;\n    plotnameb = PlotNameB;\n    $("#input1").attr("placeholder", PlotNameA).blur();\n    $("#input2").attr("placeholder", PlotNameB).blur();\n    var plot_a = \'#plotA\',\n        plot_b = \'#plotB\';\n\n\n    var margin_cross = { top: 30, right: 35, bottom: 40, left: 40 },\n        width_cross = 300 - margin_cross.left - margin_cross.right,\n        height_cross = 160 - margin_cross.top - margin_cross.bottom;\n    var padding_cross = 100;\n\n    d3.select("#input1").on("mouseover", function () {\n        d3.select("#tooltipPlotA").style("visibility", "visible").style("opacity", "1").text(PlotNameA);\n    }).on("mouseout", function () {\n        d3.select("#tooltipPlotA").style("visibility", "hidden").style("opacity", "0");\n    });\n    d3.select("#input2").on("mouseover", function () {\n        d3.select("#tooltipPlotB").style("visibility", "visible").style("opacity", "1").text(PlotNameB);\n    }).on("mouseout", function () {\n        d3.select("#tooltipPlotB").style("visibility", "hidden").style("opacity", "0");\n    });\n\n    var plot_nodes = app.nodes.slice();\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n        for (var _iterator = plot_nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var node = _step.value;\n\n            if (node.name === PlotNameA) {\n                if (node.plottype === "continuous") {\n                    continuous_n++;\n                    density_cross(node);\n                } else if (node.plottype === "bar") {\n                    bar_n++;\n                    bar_cross(node);\n                }\n            } else if (node.name === PlotNameB) {\n                if (node.plottype === "continuous") {\n                    continuous_n++;\n                    density_cross(node);\n                } else if (node.plottype === "bar") {\n                    bar_n++;\n                    bar_cross(node);\n                }\n            }\n        }\n    } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n            }\n        } finally {\n            if (_didIteratorError) {\n                throw _iteratorError;\n            }\n        }\n    }\n\n    var plotA_size = void 0,\n        plotB_size = void 0,\n        plotA_sizem = void 0,\n        plotB_sizem = void 0;\n    var varn1 = void 0,\n        varn2 = void 0,\n        varsize1 = void 0,\n        varsize2 = void 0;\n    $("#Equidistance1").click(function () {\n        varn1 = "equidistance";\n        plotA_size = parseInt(d3.select("#input1")[0][0].value);\n        varsize1 = plotA_size;\n        equidistance(PlotNameA, plotA_size);\n        document.getElementById("plotA_status").innerHTML = PlotNameA + \' : \' + varn1 + \' distribution with \' + varsize1 + \' divisions\';\n    });\n    $("#Equimass1").click(function () {\n        plotA_sizem = parseInt(d3.select("#input1")[0][0].value);\n        varsize1 = plotA_sizem;\n        equimass(PlotNameA, plotA_sizem);\n        varn1 = "equimass";\n        document.getElementById("plotA_status").innerHTML = PlotNameA + \' : \' + varn1 + \' distribution with \' + varsize1 + \' divisions\';\n    });\n    $("#Equidistance2").click(function () {\n        varn2 = "equidistance";\n        plotB_size = parseInt(d3.select("#input2")[0][0].value);\n        equidistance(PlotNameB, plotB_size);\n        varsize2 = plotB_size;\n        document.getElementById("plotB_status").innerHTML = PlotNameB + \' : \' + varn2 + \' distribution with \' + varsize2 + \' divisions\';\n    });\n    $("#Equimass2").click(function () {\n        varn2 = "equimass";\n        plotB_sizem = parseInt(d3.select("#input2")[0][0].value);\n        equimass(PlotNameB, plotB_sizem);\n        varsize2 = plotB_sizem;\n        document.getElementById("plotB_status").innerHTML = PlotNameB + \' : \' + varn2 + \' distribution with \' + varsize2 + \' divisions\';\n    });\n\n    // this is the function to add  the density plot if any\n    function density_cross(density_env, a, method_name) {\n        // setup the x_cord according to the size given by user\n        var yVals = density_env.ploty;\n        var xVals = density_env.plotx;\n\n        // an array of objects\n        var data2 = [];\n        for (var i = 0; i < density_env.plotx.length; i++) {\n            data2.push({ x: density_env.plotx[i], y: density_env.ploty[i] });\n        }\n        data2.forEach(function (d) {\n            d.x = +d.x;\n            d.y = +d.y;\n        });\n\n        var min_x = d3.min(data2, function (d, i) {\n            return data2[i].x;\n        });\n        var max_x = d3.max(data2, function (d, i) {\n            return data2[i].x;\n        });\n        var avg_x = (max_x - min_x) / 10;\n        var min_y = d3.min(data2, function (d, i) {\n            return data2[i].y;\n        });\n        var max_y = d3.max(data2, function (d, i) {\n            return data2[i].y;\n        });\n        var avg_y = (max_y - min_y) / 10;\n        var x = d3.scale.linear().domain([d3.min(xVals), d3.max(xVals)]).range([0, width_cross]);\n        var invx = d3.scale.linear().range([d3.min(data2.map(function (d) {\n            return d.x;\n        })), d3.max(data2.map(function (d) {\n            return d.x;\n        }))]).domain([0, width_cross]);\n        var y = d3.scale.linear().domain([d3.min(data2.map(function (d) {\n            return d.y;\n        })), d3.max(data2.map(function (d) {\n            return d.y;\n        }))]).range([height_cross, 0]);\n        var xAxis = d3.svg.axis().scale(x).ticks(5).orient("bottom");\n        var yAxis = d3.svg.axis().scale(y).orient("left");\n        var area = d3.svg.area().interpolate("monotone").x(function (d) {\n            return x(d.x);\n        }).y0(height_cross - avg_y).y1(function (d) {\n            return y(d.y);\n        });\n        var line = d3.svg.line().x(function (d) {\n            return x(d.x);\n        }).y(function (d) {\n            return y(d.y);\n        }).interpolate("monotone");\n\n        var plotsvg = d3.select(plot_a).append("svg").attr("id", "plotsvg_id").style("width", width_cross + margin_cross.left + margin_cross.right) //setting height to the height of #main.left\n        .style("height", height_cross + margin_cross.top + margin_cross.bottom).style("margin-left", "20px").append("g").attr("transform", "translate(0," + margin_cross.top + ")");\n        plotsvg.append("path").attr("id", "path1").datum(data2).attr("class", "area").attr("d", area);\n        plotsvg.append("g").attr("class", "x axis").attr("transform", "translate(0," + height_cross + ")").call(xAxis);\n        plotsvg.append("text").attr("x", width_cross / 2).attr("y", margin_cross.top + padding_cross - 10).attr("text-anchor", "middle").text(density_env.name).style("text-indent", "20px").style("font-size", "12px").style("font-weight", "bold");\n\n        if (isNaN(a) || a === 0) {\n            var upper_limit = d3.max(xVals);\n            var lower_limit = d3.min(xVals);\n            var z = 10;\n            var diff = upper_limit - lower_limit;\n            var buffer = diff / z;\n            var x_cord = [];\n            var push_data = lower_limit;\n            for (var i = 0; i < z - 1; i++) {\n                push_data = push_data + buffer;\n                x_cord.push(push_data);\n                plotsvg.append("line").attr("id", "line1").attr("x1", x(x_cord[i])).attr("x2", x(x_cord[i])).attr("y1", y(d3.min(yVals))).attr("y2", y(d3.max(yVals))).style("stroke", "#0D47A1").style("stroke-dasharray", "3");\n            }\n        } else {\n            if (method_name === "equidistance") {\n                var upper_limit = d3.max(xVals);\n                var lower_limit = d3.min(xVals);\n                var diff = upper_limit - lower_limit;\n                var buffer = diff / a;\n                var x_cord = [];\n                var push_data = lower_limit;\n                for (var i = 0; i < a - 1; i++) {\n                    push_data = push_data + buffer;\n                    x_cord.push(push_data);\n                    plotsvg.append("line").attr("id", "line1").attr("x1", x(x_cord[i])).attr("x2", x(x_cord[i])).attr("y1", y(d3.min(yVals))).attr("y2", y(d3.max(yVals))).style("stroke", "#0D47A1").style("stroke-dasharray", "4");\n                }\n            } else if (method_name === "equimass") {\n                // here we use the data from equimassCalculation to draw lines\n                var temp = [];\n                temp = equimassCalculation(density_env, a);\n                for (var i = 1; i < a; i++) {\n                    plotsvg.append("line").attr("id", "line1").attr("x1", x(temp[i])).attr("x2", x(temp[i])).attr("y1", y(d3.min(yVals))).attr("y2", y(d3.max(yVals))).style("stroke", "#0D47A1").style("stroke-dasharray", "4");\n                }\n            }\n        }\n    }\n\n    // this is the function to add the bar plot if any\n    function bar_cross(bar_env, a, method_name) {\n        var barPadding = .015; // Space between bars\n        var topScale = 1.2; // Multiplicative factor to assign space at top within graph - currently removed from implementation\n        var plotXaxis = true;\n\n        // Data\n        var keys = Object.keys(bar_env.plotvalues);\n        var yVals = new Array();\n        var ciUpperVals = new Array();\n        var ciLowerVals = new Array();\n        var ciSize;\n\n        var xVals = new Array();\n        var yValKey = new Array();\n\n        if (bar_env.nature === "nominal") {\n            var xi = 0;\n            for (var i = 0; i < keys.length; i++) {\n                if (bar_env.plotvalues[keys[i]] == 0) {\n                    continue;\n                }\n                yVals[xi] = bar_env.plotvalues[keys[i]];\n                xVals[xi] = xi;\n                if ($private) {\n                    if (bar_env.plotvaluesCI) {\n                        ciLowerVals[xi] = bar_env.plotValuesCI.lowerBound[keys[i]];\n                        ciUpperVals[xi] = bar_env.plotValuesCI.upperBound[keys[i]];\n                    }\n                    ciSize = ciUpperVals[xi] - ciLowerVals[xi];\n                }\n                yValKey.push({ y: yVals[xi], x: keys[i] });\n                xi = xi + 1;\n            }\n            yValKey.sort(function (a, b) {\n                return b.y - a.y;\n            }); // array of objects, each object has y, the same as yVals, and x, the category\n            yVals.sort(function (a, b) {\n                return b - a;\n            }); // array of y values, the height of the bars\n            ciUpperVals.sort(function (a, b) {\n                return b.y - a.y;\n            }); // ?\n            ciLowerVals.sort(function (a, b) {\n                return b.y - a.y;\n            }); // ?\n        } else {\n            for (var i = 0; i < keys.length; i++) {\n                yVals[i] = bar_env.plotvalues[keys[i]];\n                xVals[i] = Number(keys[i]);\n                if ($private) {\n                    if (bar_env.plotvaluesCI) {\n                        ciLowerVals[i] = bar_env.plotvaluesCI.lowerBound[keys[i]];\n                        ciUpperVals[i] = bar_env.plotvaluesCI.upperBound[keys[i]];\n                    }\n                    ciSize = ciUpperVals[i] - ciLowerVals[i];\n                }\n            }\n        }\n\n        if (yVals.length > 15 & bar_env.numchar === "numeric" | yVals.length > 5 & bar_env.numchar === "character") {\n            plotXaxis = false;\n        }\n        var minY = d3.min(yVals);\n        var maxY = d3.max(yVals); // in the future, set maxY to the value of the maximum confidence limit\n        var minX = d3.min(xVals);\n        var maxX = d3.max(xVals);\n        var x_1 = d3.scale.linear().domain([minX - 0.5, maxX + 0.5]).range([0, width_cross]);\n\n        var invx = d3.scale.linear().range([minX - 0.5, maxX + 0.5]).domain([0, width_cross]);\n\n        var y_1 = d3.scale.linear()\n        // .domain([0, maxY])\n        .domain([0, maxY]).range([0, height_cross]);\n\n        var xAxis = d3.svg.axis().scale(x_1).ticks(yVals.length).orient("bottom");\n\n        var yAxis = d3.svg.axis().scale(y_1).orient("left");\n\n        var plotsvg1 = d3.select(plot_b).append("svg").attr("id", "plotsvg1_id").style("width", width_cross + margin_cross.left + margin_cross.right) //setting height to the height of #main.left\n        .style("height", height_cross + margin_cross.top + margin_cross.bottom).style("margin-left", "20px").append("g").attr("transform", "translate(0," + margin_cross.top + ")");\n\n        var rectWidth = x_1(minX + 0.5 - 2 * barPadding); //the "width" is the coordinate of the end of the first bar\n        plotsvg1.selectAll("rect").data(yVals).enter().append("rect").attr("id", "path2").attr("x", function (d, i) {\n            return x_1(xVals[i] - 0.5 + barPadding);\n        }).attr("y", function (d) {\n            return y_1(maxY - d);\n        }).attr("width", rectWidth).attr("height", function (d) {\n            return y_1(d);\n        }).attr("fill", "#fa8072");\n\n        if (plotXaxis) {\n            plotsvg1.append("g").attr("class", "x axis").attr("transform", "translate(0," + height_cross + ")").call(xAxis);\n        }\n\n        plotsvg1.append("text").attr("x", width_cross / 2).attr("y", margin_cross.top + padding_cross - 10).attr("text-anchor", "middle").text(bar_env.name).style("text-indent", "20px").style("font-size", "12px").style("font-weight", "bold");\n\n        if (isNaN(a) || a === 0) {\n            x_cord2 = equimass_bar(bar_env, keys.length);\n            for (var i = 0; i < keys.length - 1; i++) {\n                plotsvg1.append("line").attr("id", "line2").attr("x1", x_1(x_cord2[i])).attr("x2", x_1(x_cord2[i])).attr("y1", y_1(0)).attr("y2", y_1(maxY)).style("stroke", "#212121").style("stroke-dasharray", "4");\n            }\n        } else {\n            if (method_name === "equidistance") {\n                var upper_limit1 = maxX;\n                var lower_limit1 = minX;\n                var diff1 = upper_limit1 - lower_limit1;\n                var buffer1 = diff1 / a;\n                var x_cord1 = [];\n                var push_data1 = lower_limit1;\n                for (var i = 0; i < a - 1; i++) {\n                    push_data1 = push_data1 + buffer1;\n                    x_cord1.push(push_data1);\n                    plotsvg1.append("line").attr("id", "line2").attr("x1", x_1(x_cord1[i])).attr("x2", x_1(x_cord1[i])).attr("y1", y_1(0)).attr("y2", y_1(maxY)).style("stroke", "#0D47A1").style("stroke-dasharray", "4");\n                }\n            } else if (method_name === "equimass") {\n                var x_cord2 = [];\n                x_cord2 = equimass_bar(bar_env, a);\n                for (var i = 0; i < a - 1; i++) {\n                    plotsvg1.append("line").attr("id", "line2").attr("x1", x_1(x_cord2[i])).attr("x2", x_1(x_cord2[i])).attr("y1", y_1(0)).attr("y2", y_1(maxY)).style("stroke", "#0D47A1").style("stroke-dasharray", "4");\n                }\n            }\n        }\n    }\n\n    function equidistance(A, a) {\n        var method_name = "equidistance";\n        // json object to be sent to r server\n        var obj = new Object();\n        obj.plotNameA = A;\n        obj.equidistance = a;\n        var string = JSON.stringify(obj);\n        for (var i = 0; i < plot_nodes.length; i++) {\n            if (plot_nodes[i].name === A) {\n                if (plot_nodes[i].plottype === "continuous") {\n                    $("#plotsvg_id").remove();\n                    density_cross(plot_nodes[i], a, method_name);\n                } else if (plot_nodes[i].plottype === "bar") {\n                    $("#plotsvg1_id").remove();\n                    bar_cross(plot_nodes[i], a, method_name);\n                }\n            } else {\n                console.log("not found");\n            }\n        }\n    }\n    function equimass(A, a) {\n        //equimass function to call the plot function\n        var method_name = "equimass";\n        var obj = new Object();\n        obj.plotNameA = A;\n        obj.equidistance = a;\n        var string = JSON.stringify(obj);\n        for (var i = 0; i < plot_nodes.length; i++) {\n            if (plot_nodes[i].name === A) {\n                if (plot_nodes[i].plottype === "continuous") {\n                    $("#plotsvg_id").remove();\n                    density_cross(plot_nodes[i], a, method_name);\n                } else if (plot_nodes[i].plottype === "bar") {\n                    $("#plotsvg1_id").remove();\n                    bar_cross(plot_nodes[i], a, method_name);\n                }\n            } else {\n                console.log("not found");\n            }\n        }\n    }\n\n    function equimassCalculation(plot_ev, n) {\n        // here we find the coordinates using CDF values\n        //var n =v-1;\n        var arr_y = [];\n        var arr_x = [];\n\n        arr_y = plot_ev.cdfploty; // cdfploty data stored\n        arr_x = plot_ev.cdfplotx; // cdfplotx data stored\n\n        var Upper_limitY = d3.max(arr_y);\n        var Lower_limitY = d3.min(arr_y);\n        var diffy = Upper_limitY - Lower_limitY;\n        var e = diffy / n; // e is the variable to store the average distance between the points in the cdfy in order to divide the cdfy\n\n        var arr_c = []; //array to store the cdfy divided coordinates data\n        var push_data = arr_y[0];\n        for (var i = 0; i < n; i++) {\n            push_data = push_data + e;\n            arr_c.push(push_data);\n        }\n\n        var temp_cdfx = [];\n        var temp = [];\n        var store = [];\n\n        for (var i = 0; i < n; i++) //to get through each arr_c\n        {\n            for (var j = 0; j < 50; j++) // to compare with cdfy or arr_y\n            {\n                if (arr_c[i] === arr_y[j]) {\n                    store.push({ val: i, coor1: j, coor2: j, diff1: 0.34, diff2: 0 }); // for testing purpose\n                }\n            }\n        }\n        for (var i = 0; i < n; i++) {\n            var diff_val1, diff_val2; // here the diff is not actual difference, it is the fraction of the distance from the two points\n            var x1, x2, x3, x4;\n            for (var j = 0; j < 50; j++) {\n                if (arr_y[j] < arr_c[i] && arr_c[i] < arr_y[j + 1]) {\n                    x1 = arr_c[i];\n                    x2 = arr_c[i] - arr_y[j];\n                    x3 = arr_y[j + 1] - arr_c[i];\n                    x4 = arr_y[j + 1] - arr_y[j];\n                    diff_val1 = x2 / x4;\n                    diff_val2 = x3 / x4;\n                    store.push({ val: i, coor1: j, coor2: j + 1, diff1: diff_val1, diff2: diff_val2 });\n                }\n            }\n        }\n\n        for (var i = 0; i < n; i++) {\n            var y1, y2, y3, diffy1, diffy2;\n            y1 = store[i].val;\n            y2 = store[i].coor1;\n            y3 = store[i].coor2;\n            diffy1 = store[i].diff1;\n            diffy2 = store[i].diff2;\n            var x_coor1 = arr_x[y2];\n            var x_coor2 = arr_x[y3];\n            var x_diff = x_coor2 - x_coor1;\n            var distance1 = x_diff * diffy1;\n            var val_x = x_coor1 + distance1;\n            temp.push(val_x);\n        }\n        return temp;\n    }\n\n    function equimass_bar(plot_ev, n) {\n        var keys = Object.keys(plot_ev.plotvalues);\n        var k = keys.length;\n        var temp = [];\n        var count = 0;\n\n        if (k < n) {\n            alert("error enter vaild size");\n        } else {\n            while (k > 0) {\n                temp.push({ pos: count, val: k });\n                count++;\n                k--;\n                if (count >= n) {\n                    count = 0;\n                }\n            }\n\n            var temp2 = new Array(n);\n            for (var i = 0; i < temp2.length; i++) {\n                temp2[i] = 0;\n            }\n            for (var i = 0; i < keys.length; i++) {\n                keys[i] = (keys[i] + 5) / 10; // to get the increase in the actual values by 0.5 according to the xaxis in plot\n            }\n            for (var i = 0; i < n; i++) {\n                for (var j = 0; j < temp.length; j++) {\n                    if (temp[j].pos === i) {\n                        temp2[i] = temp2[i] + 1;\n                    }\n                }\n            }\n\n            var j = 0,\n                k = 0;\n            var temp_final = new Array(n);\n            for (var i = 0; i < keys.length; i++) {\n                temp2[j] = temp2[j] - 1;\n                if (temp2[j] === 0) {\n                    j++;\n                    temp_final[k] = keys[i];\n                    k++;\n                }\n            }\n            return temp_final;\n        }\n    }\n}\n\nfunction linechart(x_Axis_name, y_Axis_name) {\n    document.getElementById(\'linechart\').style.display = "block";\n    d3.select("#lineChart").select("svg").remove();\n    $(\'#linechart\').html("");\n    var padding = 10;\n    var w_linechart = 480;\n    var h_linechart = 300;\n    var margin_linechart = { top: 20, right: 80, bottom: 30, left: 50 };\n    var width_linechart = w_linechart - margin_linechart.left - margin_linechart.right;\n    var height_linechart = h_linechart - margin_linechart.top - margin_linechart.bottom;\n\n    var svg = d3.select("#linechart").append("svg").attr("id", "chart").attr("width", w_linechart).attr("height", h_linechart);\n    var chart = svg.append("g").classed("display", true).attr("transform", "translate(" + margin_linechart.left + "," + margin_linechart.top + ")");\n    var x = d3.scale.linear().domain(d3.extent(data_plot, function (d) {\n        return d.xaxis;\n    })).range([0, width_linechart]);\n    var y = d3.scale.linear().domain([d3.min(data_plot, function (d) {\n        return d.yaxis;\n    }), d3.max(data_plot, function (d) {\n        return d.yaxis;\n    })]).range([height_linechart, 0]);\n    var xAxis = d3.svg.axis().scale(x).orient("bottom").ticks(5);\n    var yAxis = d3.svg.axis().scale(y).orient("left").ticks(5);\n    var line = d3.svg.line().x(function (d) {\n        return x(d.xaxis);\n    }).y(function (d) {\n        return y(d.yaxis);\n    });\n\n    function plot(params) {\n        this.append("g").classed("x axis", true).attr("transform", "translate(0," + height_linechart + ")").call(params.axis.x);\n        this.append("g").classed("y axis", true).attr("transform", "translate(0,0)").call(params.axis.y);\n        //enter()\n        this.selectAll(".trendline").data([params.data]).enter().append("path").classed("trendline", true);\n        this.selectAll(".point").data(params.data).enter().append("circle").classed("point", true).attr("r", 2);\n        //update\n        this.selectAll(".trendline").attr("d", function (d) {\n            return line(d);\n        });\n        this.selectAll(".point").attr("cx", function (d) {\n            var date = d.xaxis;\n            return x(date);\n        }).attr("cy", function (d) {\n            return y(d.yaxis);\n        }).style("color", "#EF5350");\n        //exit()\n        this.selectAll(".trendline").data([params.data]).exit().remove();\n        this.selectAll(".point").data(params.data).exit().remove();\n    }\n\n    var temp = d3.select("#main.left").style("width");\n    var width = temp.substring(0, temp.length - 2);\n    var height = $(window).height() - 120;\n    svg.append("text").attr("text-anchor", "middle") // this makes it easy to centre the text as the transform is applied to the anchor\n    .attr("transform", "translate(" + padding + "," + height / 3 + ")rotate(-90)") // text is drawn off the screen top left, move down and out and rotate\n    .text(y_Axis_name).style("fill", "#424242").style("text-indent", "20px").style("font-size", "12px").style("font-weight", "bold");\n    svg.append("text").attr("text-anchor", "middle") // this makes it easy to centre the text as the transform is applied to the anchor\n    .attr("transform", "translate(" + width / 5 + "," + (height - padding - 128) + ")") // centre below axis\n    .text(x_Axis_name).style("fill", "#424242").style("text-indent", "20px").style("font-size", "12px").style("font-weight", "bold");\n\n    plot.call(chart, {\n        data: data_plot,\n        axis: {\n            x: xAxis,\n            y: yAxis\n        }\n    });\n}\n\nfunction viz(m, json_vizexplore, model_name_set) {\n    d3.select("#plotA").html("");\n    d3.select("#plotB").html("");\n    d3.select("#tabular_1").style("display", "block");\n    d3.select("#tabular_2").style("display", "block");\n\n    var get_data = model_name_set.split("-");\n    var model_name1 = get_data[0] + "-" + get_data[1];\n    var model_name2 = get_data[1] + "-" + get_data[0];\n    var mym = +m.substr(5, 5) - 1;\n\n    function removeKids(parent) {\n        while (parent.firstChild) {\n            parent.removeChild(parent.firstChild);\n        }\n    }\n\n    var json = json_vizexplore;\n    // pipe in figures to right panel\n    var filelist = new Array();\n\n    // image added to the div\n    var x_axis = [];\n    var y_axis = [];\n    for (var i in json.plotdata) {\n        for (var j in json.plotdata[i].varname) {\n            if (json.plotdata[i].varname[j] === get_data[0]) {\n                for (var k in json.plotdata[i].data) {\n                    x_axis[k] = json.plotdata[i].data[k];\n                }\n            }\n            if (json.plotdata[i].varname[j] === get_data[1]) {\n                for (var k in json.plotdata[i].data) {\n                    y_axis[k] = json.plotdata[i].data[k];\n                }\n            }\n        }\n    }\n\n    bivariatePlot(x_axis, y_axis, get_data[0], get_data[1]);\n\n    $(\'#scatterplot_img\').on(\'click\', function () {\n        $("#scatterplot_img").fadeOut("fast").fadeIn().fadeTo("fast", 1.0);\n    });\n    $(\'#heatmap_img\').on(\'click\', function () {\n        $("#heatmap_img").fadeOut("fast").fadeIn().fadeTo("fast", 1.0);\n    });\n    $(\'#linechart_img\').on(\'click\', function () {\n        $("#linechart_img").fadeOut("fast").fadeIn().fadeTo("fast", 1.0);\n    });\n    $(\'#scatterplot_img\').click(function () {\n        document.getElementById(\'heatchart\').style.display = "none";\n        document.getElementById(\'linechart\').style.display = "none";\n        bivariatePlot(x_axis, y_axis, get_data[0], get_data[1]);\n    });\n    $(\'#heatmap_img\').click(function () {\n        document.getElementById(\'scatterplot\').style.display = "none";\n        document.getElementById(\'linechart\').style.display = "none";\n        heatmap(get_data[0], get_data[1]);\n    });\n    $(\'#linechart_img\').click(function () {\n        document.getElementById(\'heatchart\').style.display = "none";\n        document.getElementById(\'scatterplot\').style.display = "none";\n        linechart(get_data[0], get_data[1]);\n    });\n\n    var empty = [];\n    crossTabPlots(get_data[0], get_data[1], empty);\n\n    var cork = [];\n    var corp = [];\n    var cors = [];\n    var var1 = [];\n    var var2 = [];\n    var table_obj = [];\n    var colnames = [];\n    var colvar = [];\n    var table_data = [];\n    var rowvar = [];\n    var rownames = [];\n    function crossTab_Table(json) {\n        table_data = [];\n        table_obj = [];\n        var push = function push(i, key) {\n            return json.tabular[i][key].map(function (v) {\n                return v;\n            });\n        };\n        // data for statistics\n        for (var i in json.tabular) {\n            if (i == model_name1 || i == model_name2) {\n                colnames = push(i, \'colnames\');\n                rownames = push(i, \'rownames\');\n                rowvar = push(i, \'rowvar\');\n                colvar = push(i, \'colvar\');\n            }\n        }\n        for (var i in json.tabular) {\n            if (i == model_name1 || i == model_name2) {\n                for (var n in json.tabular[i].data) {\n                    table_data[n] = [];\n                    for (var a = 0; a < colnames.length; a++) {\n                        table_data[n].push(json.tabular[i].data[n][a]);\n                    }\n                }\n            }\n        }\n        for (var p = 0; p < rownames.length; p++) {\n            for (var l = 0; l < colnames.length; l++) {\n                table_obj.push({ rowname: rownames[p], colname: colnames[l], value: table_data[p][l] });\n            }\n        }\n        d3table1(table_obj);\n    }\n\n    // for the statistics\n    for (var key in json.statistical) {\n        if (key == model_name1 || key == model_name2) {\n            for (var a in json.statistical[key].cork) {\n                cork.push(json.statistical[key].cork[a]);\n            }\n        }\n    }\n    for (var key1 in json.statistical) {\n        if (key1 == model_name1 || key1 == model_name2) {\n            for (var b in json.statistical[key1].corp) {\n                corp.push(json.statistical[key1].corp[b]);\n            }\n        }\n    }\n    for (var key in json.statistical) {\n        if (key == model_name1 || key == model_name2) {\n            for (var c in json.statistical[key].cors) {\n                cors.push(json.statistical[key].cors[c]);\n            }\n        }\n    }\n    for (var key in json.statistical) {\n        if (key == model_name1 || key == model_name2) {\n            for (var d in json.statistical[key].var1) {\n                var1.push(json.statistical[key].var1[d]);\n            }\n        }\n    }\n    for (var key4 in json.statistical) {\n        if (key == model_name1 || key == model_name2) {\n            for (var e in json.statistical[key].var2) {\n                var2.push(json.statistical[key].var2[e]);\n            }\n        }\n    }\n    for (var i = 0; i < app.zparams.zvars.length; i++) {\n        var resultsArray = [];\n    }\n    for (var key in json.tabular) {\n        if (key == "colnames") {\n            console.log("colnames found");\n            continue;\n        }\n        var obj = json.tabular[key];\n        resultsArray.push(obj);\n    }\n\n    function d3table1(data) {\n        var width = 120,\n            // width of svg\n        height = 160,\n            // height of svg\n        padding = 22; // space around the chart, not including labels\n\n        d3.select("#tabular_2").html("").style("background-color", "#fff").append("h5").text("CROSS-TABS ").style("color", "#424242");\n\n        var sv = d3.select("#tabular_2").append("svg").attr("width", "100%").attr("height", "100%").style("overflow", "visible");\n        var fo = sv.append(\'foreignObject\').attr("width", "100%").attr("height", "100%").style("padding", 10).attr("overflow", "visible");\n        var table = fo.append("xhtml:table").attr("class", "table").style("border-collapse", " collapse"),\n            th = table.append("tr").style("border", 1).text("_").style("color", "#fff");\n        for (var i = 0; i < colnames.length; i++) {\n            th.append("td").style("border-bottom", 1).style("text-align", "center").style("background-color", plots.selVarColor).append("b").text(colnames[i]);\n        }\n        for (var k = 0; k < rownames.length; k++) {\n            var pos = 0;\n            var tr = table.append("tr").style("margin-left", 20).style("background-color", "#BDBDBD").style("border", 1).style("text-align", "center").text(rownames[k]);\n            for (var m = 0; m < colnames.length; m++) {\n                for (var z = 0; z < data.length; z++) {\n                    if (rownames[k] === data[z].rowname && colnames[m] === data[z].colname) {\n                        tr.append("td").style("border", 1).style("text-align", "center").style("position", "relative").style("background-color", app.varColor).text(data[z].value);\n                    }\n                }\n            }\n        }\n    }\n\n    crossTab_Table(json);\n\n    var plotAval = varsize1,\n        plotBval = varsize2;\n    if (isNaN(plotAval)) plotAval = 10;\n    if (isNaN(plotBval)) plotBval = 10;\n    var crosstabs = {\n        var1: {\n            name: plotnamea,\n            value: plotAval,\n            buttonType: varn1\n        },\n        var2: {\n            name: plotnameb,\n            value: plotBval,\n            buttonType: varn2\n        }\n    };\n\n    function removeData(key) {\n        for (var key1 in app.zparams) {\n            if (app.zparams.hasOwnProperty(key1) && key === key1 && app.zparams[key1.length] > 0) app.zparams[key1] = [];\n        }\n    }\n\n    var zbreaks = [];\n    var zbreaks_tabular = [];\n    $(\'#SelectionData1\').click(function () {\n        d3.select("#tabular_2").html("");\n        removeData(\'zcrosstab\');\n        app.zparams.zcrosstab.push(crosstabs);\n        explore_crosstab(json);\n        app.estimateLadda.stop();\n        app.explored = true;\n        zbreaks.push(crosstabs);\n        zbreaks_tabular.push(json.tabular);\n        d3.select(\'#breakspace\').append("span").text(\'\\xA0 \\xA0 \\xA0 \\xA0   \').style("margin-top", 0).style("white-space", "pre").style("display", "inline-block").style("float", "left").append("span").append("button") // top stack for results\n        .attr("class", "btn btn-default btn-xs").attr("id", zbreaks.length).text("break " + (zbreaks.length + 1)).on("click", function () {\n            d3.select("#tabular_2").html("");\n            removeData();\n            var id = this.id - 1;\n            app.zparams.zcrosstab.push(zbreaks[id]);\n            explore_crosstab(zbreaks_tabular[id]);\n\n            var inputvalue1, inputvalue2;\n            inputvalue1 = zbreaks[id].var1.value;\n            inputvalue2 = zbreaks[id].var2.value;\n            document.getElementById("input1").value = inputvalue1;\n            document.getElementById("input2").value = inputvalue2;\n\n            var json_obj = zbreaks[id];\n            var varn1, varn2, varsize1, varsize2;\n            if (json_obj.length === 0) {\n                console.log("break not called");\n            } else {\n                varn1 = json_obj.var1.buttonType;\n                varn2 = json_obj.var2.buttonType;\n                varsize1 = json_obj.var1.value;\n                varsize2 = json_obj.var2.value;\n                if (varn1 === "equidistance") {\n                    crossTabPlots.equidistance(get_data[0], varsize1);\n                } else if (varn1 === "equimass") {\n                    crossTabPlots.equimass(get_data[0], varsize1);\n                }\n                if (varn2 === "equidistance") {\n                    crossTabPlots.equidistance(get_data[1], varsize2);\n                } else if (varn2 === "equimass") {\n                    crossTabPlots.equimass(get_data[1], varsize2);\n                }\n            }\n        });\n    });\n\n    async function explore_crosstab(btn) {\n        if (app.downloadIncomplete()) {\n            return;\n        }\n        app.zPop();\n\n        app.estimateLadda.start();\n        // write links to file & run R CMD\n        app.zparams.callHistory = app.callHistory;\n        var json = await app.makeRequest(ROOK_SVC_URL + \'exploreapp\', app.zparams);\n        app.estimateLadda.start();\n        app.explored = false;\n        d3.json("static/result.json", function (err, json) {\n            if (err) {\n                return console.warn(err);\n            }\n            crossTab_Table(json);\n            app.estimateLadda.stop();\n            app.explored = true;\n        });\n    }\n\n    // data for the statistical div\n    var string1 = cork.toString();\n    var string3 = string1.substring(string1.indexOf(":"), string1.length);\n    var string2 = string1.substring(0, string1.indexOf("c"));\n    var string4 = corp.toString();\n    var string6 = string4.substring(string4.indexOf(":"), string4.length);\n    var string5 = string4.substring(0, string4.indexOf("c"));\n    var string7 = cors.toString();\n    var string9 = string7.substring(string7.indexOf(":"), string7.length);\n    var string8 = string7.substring(0, string7.indexOf("c"));\n    var statistical_data = [{ correlation: string2, value: string3 }, { correlation: string5, value: string6 }, { correlation: string8, value: string9 }];\n\n    function d3table(data) {\n        d3.select("#resultsView_statistics").html("").style("background-color", "#fff").append("h5").text("CORRELATION STATISTICS ").style("color", "#424242");\n        var table = d3.select("#resultsView_statistics").append("table").attr("class", "table").style("border-collapse", " collapse"),\n            th = table.append("tr").style("border", 1);\n        for (var i in Object.keys(data[0])) {\n            th.append("td").style("border-bottom", 1).style("text-align", "left").style("background-color", plots.selVarColor).append("b").text(Object.keys(data[0])[i]);\n        }\n        for (var row in data) {\n            var tr = table.append("tr").style("margin-left", 40).style("border", 1).style("text-align", "left");\n            for (var td in data[row]) {\n                tr.append("td").style("border", 1).style("text-align", "left").style("position", "relative").style("background-color", app.varColor).text(data[row][td]);\n            }\n        }\n    }\n    d3table(statistical_data);\n}\n\nfunction model_selection(model_selection_name, count_value, json) {\n    if (count_value % 2 == 0 && count_value != 0) {\n        d3.select("#modelView").append("span").text(\'\\xA0 \\xA0 \\xA0 \\xA0   \\xA0 \').style("margin-top", 0).style("white-space", "pre").style("display", "inline-block").style("float", "left").append("span").text("|").style("margin-top", 0).style("white-space", "pre").style("display", "inline-block").style("float", "left").append("span").text(\'\\xA0 \\xA0 \\xA0 \\xA0   \\xA0 \').style("margin-top", 0).style("white-space", "pre").style("display", "inline-block").style("float", "left");\n    }\n    d3.select("#modelView").append("span").text(\' \\xA0\').style("margin-top", 0).style("float", "left").style("display", "inline-block").style("white-space", "pre").style("overflow-y", "hidden").style("overflow-x", "scroll").append("button") // top stack for results\n    //      .append("xhtml:button")\n    .attr("class", "btn btn-outline-success").style("padding", "4px").attr("id", model_selection_name).text(model_selection_name).style(\'background-color\', function () {\n        var color1 = "#FFD54F";\n        return count == count1 ? plots.selVarColor : color1;\n    }).style("display", "inline-block").style("white-space", "pre").style("margin-top", 0).style("float", "left").on("click", function () {\n        var a = this.style.backgroundColor.replace(/\\s*/g, "");\n        var b = app.hexToRgba(plots.selVarColor).replace(/\\s*/g, "");\n        if (a.substr(0, 17) === b.substr(0, 17)) {\n            return; //escapes the function early if the displayed model is clicked\n        }\n        viz(this.id, json, model_selection_name);\n        d3.select("#modelView").selectAll("button").style(\'background-color\', "#FFD54F");\n        d3.select(this).style(\'background-color\', plots.selVarColor);\n    });\n}\n\nfunction showLog() {\n    if (app.logArray.length > 0) {\n        app.byId(\'logdiv\').setAttribute("style", "display:block");\n        d3.select("#collapseLog div.panel-body").selectAll("p").data(app.logArray).enter().append("p").text(function (d) {\n            return d;\n        });\n        return;\n    }\n    app.byId(\'logdiv\').setAttribute("style", "display:none");\n}\n\nvar count = 0;\nvar count1 = 0;\n\n/**\n   called by clicking \'Explore\' in explore mode\n*/\nasync function explore() {\n    if (app.downloadIncomplete()) {\n        return;\n    }\n\n    app.zPop();\n    console.log(\'zpop:\', app.zparams);\n\n    // write links to file & run R CMD\n    app.zparams.callHistory = app.callHistory;\n    app.estimateLadda.start(); // start spinner\n    var json = await app.makeRequest(ROOK_SVC_URL + \'exploreapp\', app.zparams);\n    if (!json) {\n        return;\n    }\n    app.allResults.push(json);\n\n    d3.select(\'#rightpanel\').style(\'width\', \'75%\');\n\n    var parent = app.byId(\'rightContentArea\');\n    app.explored || parent.removeChild(app.byId(\'resultsHolder\'));\n    app.explored = true;\n\n    d3.select("#decisionTree").style("display", "none");\n    d3.select("#modelView").html(\'\');\n    d3.select("#resultsView_statistics").html(\'\');\n    ["#left_thumbnail", "#result_left", "#result_left1", "#result_right", "#modelView_Container", "#modelView", "#resultsView_tabular", "#plotA", "#plotB", "#SelectionData", "#resultsView_statistics"].forEach(function (id) {\n        return d3.select(id).style("display", "block");\n    });\n\n    d3.select("#modelView").style(\'background-color\', app.hexToRgba(app.varColor)).style("overflow-y", "hidden").style("overflow-x", "scroll").append("span").style("white-space", "pre").style("margin-top", 0).style("float", "left").style("position", "relative").style("color", "#757575").text("MODEL SELECTION :  ");\n\n    // programmatic click on Results button\n    $("#btnBivariate").trigger("click");\n    var model_name = void 0;\n    for (var img in json.images) {\n        if (count === 0) {\n            model_name = img;\n        }\n        model_selection(img, count, json); // for entering all the variables\n        count++;\n    }\n    count1 = count - 1;\n    app.modelCount++;\n\n    var rCall = [];\n    rCall[0] = json.call;\n    app.logArray.push("explore: ".concat(rCall[0]));\n    showLog();\n    viz(model_name, json, model_name);\n}\n\nasync function callTreeApp(node_var) {\n    app.zPop();\n    app.zparams.callHistory = app.callHistory;\n\n    var res = await app.makeRequest(ROOK_SVC_URL + \'treeapp\', { zparams: app.zparams, dv: node_var });\n    if (!res) {\n        alert("treeapp failed");\n    } else {\n        // console.log(res);\n        univariatePart(res, node_var);\n    }\n}\n\n// Kripanshu : Function to create D3 Tree using the JSON result from call Tree app\nfunction univariatePart(json, var_name) {\n    document.getElementById("decisionTree").innerHTML = "";\n    d3.select(\'#rightpanel\').style(\'width\', \'75%\');\n    d3.select("#decisionTree").style("display", "block").append("p").style("margin-top", "1px").text(var_name);\n    d3.select("p#resultsHolder").style("display", "none");\n    d3.select("#left_thumbnail").style("display", "none");\n    d3.select("#result_left").style("display", "none");\n    d3.select("#result_left1").style("display", "none");\n    d3.select("#result_right").style("display", "none");\n    d3.select("#modelView_Container").style("display", "none");\n    d3.select("#modelView").style("display", "none");\n    d3.select("#resultsView_tabular").style("display", "none");\n    d3.select("#plotA").style("display", "none");\n    d3.select("#plotB").style("display", "none");\n    d3.select("#SelectionData").style("display", "none");\n    d3.select("#resultsView_statistics").style("display", "none");\n\n    // request for r code using nodevar\n    //code for the  decision tree map\n\n    var m = [15, 100, 15, 100],\n        w = 700 - m[1] - m[3],\n        h = 500 - m[0] - m[2],\n        i = 0,\n        rect_width = 60,\n        rect_height = 20,\n        max_link_width = 20,\n        min_link_width = 1.5,\n        char_to_pxl = 6,\n        root;\n\n    var tree = d3.layout.tree().size([h, w]);\n\n    var diagonal = d3.svg.diagonal().projection(function (d) {\n        return [d.x, d.y];\n    });\n\n    var vis = d3.select("#decisionTree").append("svg:svg").attr("width", w + m[1] + m[3]).attr("height", h + m[0] + m[2] + 1000).append("svg:g").attr("transform", "translate(" + m[3] + "," + m[0] + ")");\n\n    // global scale for link width\n    var link_stoke_scale = d3.scale.linear();\n\n    var color_map = d3.scale.category10();\n\n    // stroke style of link - either color or function\n    var stroke_callback = "#ccc";\n    load_dataset(json);\n\n    function load_dataset(json_data) {\n\n        console.log("our data for decision tree", json_data);\n        root = json_data;\n        root.x0 = 0;\n        root.y0 = 0;\n\n        var n_samples = root.samples;\n        var n_labels = root.value.length;\n\n        if (n_labels >= 2) {\n            stroke_callback = mix_colors;\n        } else if (n_labels === 1) {\n            stroke_callback = mean_interpolation(root);\n        }\n\n        link_stoke_scale = d3.scale.linear().domain([0, n_samples]).range([min_link_width, max_link_width]);\n\n        function toggleAll(d) {\n            if (d && d.children) {\n                d.children.forEach(toggleAll);\n                toggle(d);\n            }\n        }\n\n        // Initialize the display to show a few nodes.\n        root.children.forEach(toggleAll);\n\n        update(root);\n    }\n\n    function update(source) {\n        var duration = d3.event && d3.event.altKey ? 5000 : 500;\n\n        // Compute the new tree layout.\n        var nodes = tree.nodes(root).reverse();\n\n        // Normalize for fixed-depth.\n        nodes.forEach(function (d) {\n            d.y = d.depth * 180;\n        });\n\n        // Update the nodes\n        var node = vis.selectAll("g.node").data(nodes, function (d) {\n            return d.id || (d.id = ++i);\n        });\n\n        // Enter any new nodes at the parent\'s previous position.\n        var nodeEnter = node.enter().append("svg:g").attr("class", "node").attr("transform", function (d) {\n            return "translate(" + source.x0 + "," + source.y0 + ")";\n        }).on("click", function (d) {\n            toggle(d);\n            update(d);\n        });\n\n        nodeEnter.append("svg:rect").attr("x", function (d) {\n            var label = node_label(d);\n            var text_len = label.length * char_to_pxl;\n            var width = d3.max([rect_width, text_len]);\n            return -width / 2;\n        }).attr("width", 1e-6).attr("height", 1e-6).attr("rx", function (d) {\n            return d.type === "split" ? 2 : 0;\n        }).attr("ry", function (d) {\n            return d.type === "split" ? 2 : 0;\n        }).style("stroke", function (d) {\n            return d.type === "split" ? "steelblue" : "olivedrab";\n        }).style("fill", function (d) {\n            return d._children ? "lightsteelblue" : "#fff";\n        });\n\n        nodeEnter.append("svg:text").attr("dy", "12px").attr("text-anchor", "middle").text(node_label).style("fill-opacity", 1e-6);\n\n        // Transition nodes to their new position.\n        var nodeUpdate = node.transition().duration(duration).attr("transform", function (d) {\n            return "translate(" + d.x + "," + d.y + ")";\n        });\n\n        nodeUpdate.select("rect").attr("width", function (d) {\n            var label = node_label(d);\n            var text_len = label.length * char_to_pxl;\n            var width = d3.max([rect_width, text_len]);\n            return width;\n        }).attr("height", rect_height).style("fill", function (d) {\n            return d._children ? "lightsteelblue" : "#fff";\n        });\n\n        nodeUpdate.select("text").style("fill-opacity", 1);\n\n        // Transition exiting nodes to the parent\'s new position.\n        var nodeExit = node.exit().transition().duration(duration).attr("transform", function (d) {\n            return "translate(" + source.x + "," + source.y + ")";\n        }).remove();\n\n        nodeExit.select("rect").attr("width", 1e-6).attr("height", 1e-6);\n\n        nodeExit.select("text").style("fill-opacity", 1e-6);\n\n        // Update the links\n        var link = vis.selectAll("path.link").data(tree.links(nodes), function (d) {\n            return d.target.id;\n        });\n\n        // Enter any new links at the parent\'s previous position.\n        link.enter().insert("svg:path", "g").attr("class", "link").attr("d", function (d) {\n            var o = {\n                x: source.x0,\n                y: source.y0\n            };\n            return diagonal({\n                source: o,\n                target: o\n            });\n        }).transition().duration(duration).attr("d", diagonal).style("stroke-width", function (d) {\n            return link_stoke_scale(d.target.samples);\n        }).style("stroke", stroke_callback);\n\n        // Transition links to their new position.\n        link.transition().duration(duration).attr("d", diagonal).style("stroke-width", function (d) {\n            return link_stoke_scale(d.target.samples);\n        }).style("stroke", stroke_callback);\n\n        // Transition exiting nodes to the parent\'s new position.\n        link.exit().transition().duration(duration).attr("d", function (d) {\n            var o = {\n                x: source.x,\n                y: source.y\n            };\n            return diagonal({\n                source: o,\n                target: o\n            });\n        }).remove();\n\n        // Stash the old positions for transition.\n        nodes.forEach(function (d) {\n            d.x0 = d.x;\n            d.y0 = d.y;\n        });\n    }\n\n    // Toggle children.\n    function toggle(d) {\n        if (d.children) {\n            d._children = d.children;\n            d.children = null;\n        } else {\n            d.children = d._children;\n            d._children = null;\n        }\n    }\n\n    // Node labels\n    function node_label(d) {\n        if (d.type === "leaf") {\n            // leaf\n            var formatter = d3.format(".2f");\n            var vals = [];\n            d.value.forEach(function (v) {\n                vals.push(formatter(v));\n            });\n            return "[" + vals.join(", ") + "]";\n        } else {\n            // split node\n            return d.label;\n        }\n    }\n\n    /**\n     * Mixes colors according to the relative frequency of classes.\n     */\n    function mix_colors(d) {\n        var value = d.target.value;\n        var sum = d3.sum(value);\n        var col = d3.rgb(0, 0, 0);\n        value.forEach(function (val, i) {\n            var label_color = d3.rgb(color_map(i));\n            var mix_coef = val / sum;\n            col.r += mix_coef * label_color.r;\n            col.g += mix_coef * label_color.g;\n            col.b += mix_coef * label_color.b;\n        });\n        return col;\n    }\n\n    /**\n     * A linear interpolator for value[0].\n     *\n     * Useful for link coloring in regression trees.\n     */\n    function mean_interpolation(root) {\n\n        var max = 1e-9,\n            min = 1e9;\n\n        function recurse(node) {\n            if (node.value[0] > max) {\n                max = node.value[0];\n            }\n\n            if (node.value[0] < min) {\n                min = node.value[0];\n            }\n\n            if (node.children) {\n                node.children.forEach(recurse);\n            }\n        }\n\n        recurse(root);\n\n        var scale = d3.scale.linear().domain([min, max]).range(["#2166AC", "#B2182B"]);\n\n        function interpolator(d) {\n            return scale(d.target.value[0]);\n        }\n\n        return interpolator;\n    }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvYXBwL2V4cGxvcmUuanM/NzYxMCJdLCJuYW1lcyI6WyJnZXRfd2lkdGgiLCJsaW5lY2hhcnQiLCJleHBsb3JlIiwiY2FsbFRyZWVBcHAiLCJhcHAiLCJwbG90cyIsIiRwcml2YXRlIiwiaGVhdG1hcCIsInhfQXhpc19uYW1lIiwieV9BeGlzX25hbWUiLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwic3R5bGUiLCJkaXNwbGF5IiwiZDMiLCJzZWxlY3QiLCJyZW1vdmUiLCIkIiwiaHRtbCIsIm1hcmdpbl9oZWF0IiwidG9wIiwicmlnaHQiLCJib3R0b20iLCJsZWZ0Iiwid2lkdGhfaGVhdCIsImhlaWdodF9oZWF0IiwicGFkZGluZyIsIm1pbl94IiwibWluIiwiZGF0YV9wbG90IiwiZCIsImkiLCJ4YXhpcyIsIm1heF94IiwibWF4IiwiYXZnX3giLCJtaW5feSIsInlheGlzIiwibWF4X3kiLCJhdmdfeSIsIngiLCJzY2FsZSIsImxpbmVhciIsImRvbWFpbiIsInJhbmdlIiwieSIsInoiLCJ4U3RlcCIsInlTdGVwIiwic3ZnX2hlYXQiLCJhcHBlbmQiLCJhdHRyIiwiZXh0ZW50Iiwic2NvcmUiLCJzZWxlY3RBbGwiLCJkYXRhIiwiZW50ZXIiLCJ0ZXh0IiwiY2FsbCIsInN2ZyIsImF4aXMiLCJ0aWNrcyIsInRpY2tTaXplIiwib3JpZW50IiwiaGVhdHhheGlzIiwiaGVhdHlheGlzIiwiYml2YXJpYXRlUGxvdCIsInhfQXhpcyIsInlfQXhpcyIsImJ5SWQiLCJuYW5Db3VudCIsImlzTmFOIiwibmV3TnVtYmVyMSIsIm5ld051bWJlcjIiLCJwdXNoIiwiTWF0aCIsInJhbmRvbSIsIm1hcmdpbiIsIndpZHRoIiwiaGVpZ2h0IiwiXyIsInhTY2FsZSIsInlTY2FsZSIsInhBeGlzIiwieUF4aXMiLCJ6b29tIiwiYmVoYXZpb3IiLCJzY2FsZUV4dGVudCIsIm9uIiwiem9vbWVkIiwiY2hhcnRfc2NhdHRlciIsIm1haW4xIiwiY2xpcCIsInBhblgiLCJldmVudCIsInRyYW5zbGF0ZSIsInBhblkiLCJtYXhYIiwibWF4WSIsInBsb3RuYW1lYSIsInBsb3RuYW1lYiIsInZhcm4xIiwidmFybjIiLCJ2YXJzaXplMSIsInZhcnNpemUyIiwiY29udGludW91c19uIiwiYmFyX24iLCJpZCIsImNyb3NzVGFiUGxvdHMiLCJQbG90TmFtZUEiLCJQbG90TmFtZUIiLCJqc29uX29iaiIsImJsdXIiLCJwbG90X2EiLCJwbG90X2IiLCJtYXJnaW5fY3Jvc3MiLCJ3aWR0aF9jcm9zcyIsImhlaWdodF9jcm9zcyIsInBhZGRpbmdfY3Jvc3MiLCJwbG90X25vZGVzIiwibm9kZXMiLCJzbGljZSIsIm5vZGUiLCJuYW1lIiwicGxvdHR5cGUiLCJkZW5zaXR5X2Nyb3NzIiwiYmFyX2Nyb3NzIiwicGxvdEFfc2l6ZSIsInBsb3RCX3NpemUiLCJwbG90QV9zaXplbSIsInBsb3RCX3NpemVtIiwiY2xpY2siLCJwYXJzZUludCIsInZhbHVlIiwiZXF1aWRpc3RhbmNlIiwiaW5uZXJIVE1MIiwiZXF1aW1hc3MiLCJkZW5zaXR5X2VudiIsImEiLCJtZXRob2RfbmFtZSIsInlWYWxzIiwicGxvdHkiLCJ4VmFscyIsInBsb3R4IiwiZGF0YTIiLCJsZW5ndGgiLCJmb3JFYWNoIiwiaW52eCIsIm1hcCIsImFyZWEiLCJpbnRlcnBvbGF0ZSIsInkwIiwieTEiLCJsaW5lIiwicGxvdHN2ZyIsImRhdHVtIiwidXBwZXJfbGltaXQiLCJsb3dlcl9saW1pdCIsImRpZmYiLCJidWZmZXIiLCJ4X2NvcmQiLCJwdXNoX2RhdGEiLCJ0ZW1wIiwiZXF1aW1hc3NDYWxjdWxhdGlvbiIsImJhcl9lbnYiLCJiYXJQYWRkaW5nIiwidG9wU2NhbGUiLCJwbG90WGF4aXMiLCJrZXlzIiwiT2JqZWN0IiwicGxvdHZhbHVlcyIsIkFycmF5IiwiY2lVcHBlclZhbHMiLCJjaUxvd2VyVmFscyIsImNpU2l6ZSIsInlWYWxLZXkiLCJuYXR1cmUiLCJ4aSIsInBsb3R2YWx1ZXNDSSIsInBsb3RWYWx1ZXNDSSIsImxvd2VyQm91bmQiLCJ1cHBlckJvdW5kIiwic29ydCIsImIiLCJOdW1iZXIiLCJudW1jaGFyIiwibWluWSIsIm1pblgiLCJ4XzEiLCJ5XzEiLCJwbG90c3ZnMSIsInJlY3RXaWR0aCIsInhfY29yZDIiLCJlcXVpbWFzc19iYXIiLCJ1cHBlcl9saW1pdDEiLCJsb3dlcl9saW1pdDEiLCJkaWZmMSIsImJ1ZmZlcjEiLCJ4X2NvcmQxIiwicHVzaF9kYXRhMSIsIkEiLCJvYmoiLCJwbG90TmFtZUEiLCJzdHJpbmciLCJKU09OIiwic3RyaW5naWZ5IiwiY29uc29sZSIsImxvZyIsInBsb3RfZXYiLCJuIiwiYXJyX3kiLCJhcnJfeCIsImNkZnBsb3R5IiwiY2RmcGxvdHgiLCJVcHBlcl9saW1pdFkiLCJMb3dlcl9saW1pdFkiLCJkaWZmeSIsImUiLCJhcnJfYyIsInRlbXBfY2RmeCIsInN0b3JlIiwiaiIsInZhbCIsImNvb3IxIiwiY29vcjIiLCJkaWZmMiIsImRpZmZfdmFsMSIsImRpZmZfdmFsMiIsIngxIiwieDIiLCJ4MyIsIng0IiwieTIiLCJ5MyIsImRpZmZ5MSIsImRpZmZ5MiIsInhfY29vcjEiLCJ4X2Nvb3IyIiwieF9kaWZmIiwiZGlzdGFuY2UxIiwidmFsX3giLCJrIiwiY291bnQiLCJhbGVydCIsInBvcyIsInRlbXAyIiwidGVtcF9maW5hbCIsIndfbGluZWNoYXJ0IiwiaF9saW5lY2hhcnQiLCJtYXJnaW5fbGluZWNoYXJ0Iiwid2lkdGhfbGluZWNoYXJ0IiwiaGVpZ2h0X2xpbmVjaGFydCIsImNoYXJ0IiwiY2xhc3NlZCIsInBsb3QiLCJwYXJhbXMiLCJkYXRlIiwiZXhpdCIsInN1YnN0cmluZyIsIndpbmRvdyIsInZpeiIsIm0iLCJqc29uX3ZpemV4cGxvcmUiLCJtb2RlbF9uYW1lX3NldCIsImdldF9kYXRhIiwic3BsaXQiLCJtb2RlbF9uYW1lMSIsIm1vZGVsX25hbWUyIiwibXltIiwic3Vic3RyIiwicmVtb3ZlS2lkcyIsInBhcmVudCIsImZpcnN0Q2hpbGQiLCJyZW1vdmVDaGlsZCIsImpzb24iLCJmaWxlbGlzdCIsInhfYXhpcyIsInlfYXhpcyIsInBsb3RkYXRhIiwidmFybmFtZSIsImZhZGVPdXQiLCJmYWRlSW4iLCJmYWRlVG8iLCJlbXB0eSIsImNvcmsiLCJjb3JwIiwiY29ycyIsInZhcjEiLCJ2YXIyIiwidGFibGVfb2JqIiwiY29sbmFtZXMiLCJjb2x2YXIiLCJ0YWJsZV9kYXRhIiwicm93dmFyIiwicm93bmFtZXMiLCJjcm9zc1RhYl9UYWJsZSIsImtleSIsInRhYnVsYXIiLCJ2IiwicCIsImwiLCJyb3duYW1lIiwiY29sbmFtZSIsImQzdGFibGUxIiwic3RhdGlzdGljYWwiLCJrZXkxIiwiYyIsImtleTQiLCJ6cGFyYW1zIiwienZhcnMiLCJyZXN1bHRzQXJyYXkiLCJzdiIsImZvIiwidGFibGUiLCJ0aCIsInNlbFZhckNvbG9yIiwidHIiLCJ2YXJDb2xvciIsInBsb3RBdmFsIiwicGxvdEJ2YWwiLCJjcm9zc3RhYnMiLCJidXR0b25UeXBlIiwicmVtb3ZlRGF0YSIsImhhc093blByb3BlcnR5IiwiemJyZWFrcyIsInpicmVha3NfdGFidWxhciIsInpjcm9zc3RhYiIsImV4cGxvcmVfY3Jvc3N0YWIiLCJlc3RpbWF0ZUxhZGRhIiwic3RvcCIsImV4cGxvcmVkIiwiaW5wdXR2YWx1ZTEiLCJpbnB1dHZhbHVlMiIsImJ0biIsImRvd25sb2FkSW5jb21wbGV0ZSIsInpQb3AiLCJzdGFydCIsImNhbGxIaXN0b3J5IiwibWFrZVJlcXVlc3QiLCJST09LX1NWQ19VUkwiLCJlcnIiLCJ3YXJuIiwic3RyaW5nMSIsInRvU3RyaW5nIiwic3RyaW5nMyIsImluZGV4T2YiLCJzdHJpbmcyIiwic3RyaW5nNCIsInN0cmluZzYiLCJzdHJpbmc1Iiwic3RyaW5nNyIsInN0cmluZzkiLCJzdHJpbmc4Iiwic3RhdGlzdGljYWxfZGF0YSIsImNvcnJlbGF0aW9uIiwiZDN0YWJsZSIsInJvdyIsInRkIiwibW9kZWxfc2VsZWN0aW9uIiwibW9kZWxfc2VsZWN0aW9uX25hbWUiLCJjb3VudF92YWx1ZSIsImNvbG9yMSIsImNvdW50MSIsImJhY2tncm91bmRDb2xvciIsInJlcGxhY2UiLCJoZXhUb1JnYmEiLCJzaG93TG9nIiwibG9nQXJyYXkiLCJzZXRBdHRyaWJ1dGUiLCJhbGxSZXN1bHRzIiwidHJpZ2dlciIsIm1vZGVsX25hbWUiLCJpbWciLCJpbWFnZXMiLCJtb2RlbENvdW50IiwickNhbGwiLCJjb25jYXQiLCJub2RlX3ZhciIsInJlcyIsImR2IiwidW5pdmFyaWF0ZVBhcnQiLCJ2YXJfbmFtZSIsInciLCJoIiwicmVjdF93aWR0aCIsInJlY3RfaGVpZ2h0IiwibWF4X2xpbmtfd2lkdGgiLCJtaW5fbGlua193aWR0aCIsImNoYXJfdG9fcHhsIiwicm9vdCIsInRyZWUiLCJsYXlvdXQiLCJzaXplIiwiZGlhZ29uYWwiLCJwcm9qZWN0aW9uIiwidmlzIiwibGlua19zdG9rZV9zY2FsZSIsImNvbG9yX21hcCIsImNhdGVnb3J5MTAiLCJzdHJva2VfY2FsbGJhY2siLCJsb2FkX2RhdGFzZXQiLCJqc29uX2RhdGEiLCJ4MCIsIm5fc2FtcGxlcyIsInNhbXBsZXMiLCJuX2xhYmVscyIsIm1peF9jb2xvcnMiLCJtZWFuX2ludGVycG9sYXRpb24iLCJ0b2dnbGVBbGwiLCJjaGlsZHJlbiIsInRvZ2dsZSIsInVwZGF0ZSIsInNvdXJjZSIsImR1cmF0aW9uIiwiYWx0S2V5IiwicmV2ZXJzZSIsImRlcHRoIiwibm9kZUVudGVyIiwibGFiZWwiLCJub2RlX2xhYmVsIiwidGV4dF9sZW4iLCJ0eXBlIiwiX2NoaWxkcmVuIiwibm9kZVVwZGF0ZSIsInRyYW5zaXRpb24iLCJub2RlRXhpdCIsImxpbmsiLCJsaW5rcyIsInRhcmdldCIsImluc2VydCIsIm8iLCJmb3JtYXR0ZXIiLCJmb3JtYXQiLCJ2YWxzIiwiam9pbiIsInN1bSIsImNvbCIsInJnYiIsImxhYmVsX2NvbG9yIiwibWl4X2NvZWYiLCJyIiwiZyIsInJlY3Vyc2UiLCJpbnRlcnBvbGF0b3IiXSwibWFwcGluZ3MiOiI7Ozs7O1FBdVNn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SVgsS0FBSytSLFFBQVQsRUFBbUI7QUFDZi9SLHFCQUFLK1IsUUFBTCxDQUFjdlEsT0FBZCxDQUFzQndTLE9BQXRCO0FBQ0g7QUFDSjs7QUFFREEsZ0JBQVFyRCxJQUFSOztBQUVBLFlBQUk1VixRQUFRM0IsR0FBRzJCLEtBQUgsQ0FBU0MsTUFBVCxHQUFrQkMsTUFBbEIsQ0FBeUIsQ0FBQ2YsR0FBRCxFQUFNTSxHQUFOLENBQXpCLEVBQ1BVLEtBRE8sQ0FDRCxDQUFDLFNBQUQsRUFBWSxTQUFaLENBREMsQ0FBWjs7QUFHQSxpQkFBUytZLFlBQVQsQ0FBc0I3WixDQUF0QixFQUF5QjtBQUNyQixtQkFBT1csTUFBTVgsRUFBRThZLE1BQUYsQ0FBU3ZTLEtBQVQsQ0FBZSxDQUFmLENBQU4sQ0FBUDtBQUNIOztBQUVELGVBQU9zVCxZQUFQO0FBQ0g7QUFHSiIsImZpbGUiOiI2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCc7XG5cbmltcG9ydCAqIGFzIGFwcCBmcm9tICcuL2FwcCc7XG5pbXBvcnQgKiBhcyBwbG90cyBmcm9tICcuL3Bsb3RzJztcblxuY29uc3QgJHByaXZhdGUgPSBmYWxzZTtcblxuZnVuY3Rpb24gaGVhdG1hcCh4X0F4aXNfbmFtZSwgeV9BeGlzX25hbWUpIHtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaGVhdGNoYXJ0Jykuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICBkMy5zZWxlY3QoXCIjaGVhdGNoYXJ0XCIpLnNlbGVjdChcInN2Z1wiKS5yZW1vdmUoKTtcbiAgICAkKCcjaGVhdGNoYXJ0JykuaHRtbChcIlwiKTtcblxuICAgIHZhciBtYXJnaW5faGVhdCA9IHt0b3A6IDMwLCByaWdodDogMTAsIGJvdHRvbTogNjAsIGxlZnQ6IDYwfSxcbiAgICAgICAgd2lkdGhfaGVhdCA9IDUwMCAtIG1hcmdpbl9oZWF0LmxlZnQgLSBtYXJnaW5faGVhdC5yaWdodCxcbiAgICAgICAgaGVpZ2h0X2hlYXQgPSAzMDAgLSBtYXJnaW5faGVhdC50b3AgLSBtYXJnaW5faGVhdC5ib3R0b207XG4gICAgdmFyIHBhZGRpbmcgPSAxMDA7XG5cbiAgICB2YXIgbWluX3ggPSBkMy5taW4oZGF0YV9wbG90LCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICByZXR1cm4gZGF0YV9wbG90W2ldLnhheGlzO1xuICAgIH0pO1xuICAgIHZhciBtYXhfeCA9IGQzLm1heChkYXRhX3Bsb3QsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgIHJldHVybiBkYXRhX3Bsb3RbaV0ueGF4aXM7XG4gICAgfSk7XG4gICAgdmFyIGF2Z194ID0gKG1heF94IC0gbWluX3gpIC8gMTAwO1xuICAgIHZhciBtaW5feSA9IGQzLm1pbihkYXRhX3Bsb3QsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgIHJldHVybiBkYXRhX3Bsb3RbaV0ueWF4aXM7XG4gICAgfSk7XG4gICAgdmFyIG1heF95ID0gZDMubWF4KGRhdGFfcGxvdCwgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgcmV0dXJuIGRhdGFfcGxvdFtpXS55YXhpcztcbiAgICB9KTtcbiAgICB2YXIgYXZnX3kgPSAobWF4X3kgLSBtaW5feSkgLyAxMDA7XG5cbiAgICB2YXIgeCA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgIC5kb21haW4oW21pbl94IC0gYXZnX3gsIG1heF94ICsgYXZnX3hdKVxuICAgICAgICAucmFuZ2UoWzAsIHdpZHRoX2hlYXRdKTtcblxuICAgIHZhciB5ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLmRvbWFpbihbbWluX3kgLSBhdmdfeSwgbWF4X3kgKyBhdmdfeV0pXG4gICAgICAgIC5yYW5nZShbaGVpZ2h0X2hlYXQsIDBdKTtcblxuICAgIHZhciB6ID0gZDMuc2NhbGUubGluZWFyKCkucmFuZ2UoW1wiI0VGOUE5QVwiLCBcIiNFRjUzNTBcIl0pO1xuXG4gICAgLy8gVGhpcyBjb3VsZCBiZSBpbmZlcnJlZCBmcm9tIHRoZSBkYXRhIGlmIGl0IHdlcmVuJ3Qgc3BhcnNlLlxuICAgIHZhciB4U3RlcCA9IGF2Z194KyAwLjEsXG4gICAgICAgIHlTdGVwID0gYXZnX3kgKyAwLjI7XG4gICAgdmFyIHN2Z19oZWF0ID0gZDMuc2VsZWN0KFwiI2hlYXRjaGFydFwiKS5hcHBlbmQoXCJzdmdcIilcbiAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCB3aWR0aF9oZWF0ICsgbWFyZ2luX2hlYXQubGVmdCArIG1hcmdpbl9oZWF0LnJpZ2h0KVxuICAgICAgICAuYXR0cihcImhlaWdodFwiLCBoZWlnaHRfaGVhdCArIG1hcmdpbl9oZWF0LnRvcCArIG1hcmdpbl9oZWF0LmJvdHRvbSlcbiAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBtYXJnaW5faGVhdC5sZWZ0ICsgXCIsXCIgKyBtYXJnaW5faGVhdC50b3ArIFwiKVwiKVxuICAgICAgICAuc3R5bGUoXCJiYWNrZ3JvdW5kLWNvbG9yXCIsIFwiI0ZGRUJFRVwiKTtcblxuXG4gICAgLy8gQ29tcHV0ZSB0aGUgc2NhbGUgZG9tYWlucy5cbiAgICB4LmRvbWFpbihkMy5leHRlbnQoZGF0YV9wbG90LCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICByZXR1cm4gZGF0YV9wbG90W2ldLnhheGlzO1xuICAgIH0pKTtcbiAgICB5LmRvbWFpbihkMy5leHRlbnQoZGF0YV9wbG90LCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICByZXR1cm4gZGF0YV9wbG90W2ldLnlheGlzO1xuICAgIH0pKTtcbiAgICB6LmRvbWFpbihbMCwgZDMubWF4KGRhdGFfcGxvdCwgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgcmV0dXJuIGRhdGFfcGxvdFtpXS5zY29yZTtcbiAgICB9KV0pO1xuXG4gICAgLy8gRXh0ZW5kIHRoZSB4LSBhbmQgeS1kb21haW4gdG8gZml0IHRoZSBsYXN0IGJ1Y2tldC5cbiAgICAvLyBGb3IgZXhhbXBsZSwgdGhlIHktYnVja2V0IDMyMDAgY29ycmVzcG9uZHMgdG8gdmFsdWVzIFszMjAwLCAzMzAwXS5cbiAgICB4LmRvbWFpbihbeC5kb21haW4oKVswXSwgK3guZG9tYWluKClbMV0gKyB4U3RlcF0pO1xuICAgIHkuZG9tYWluKFt5LmRvbWFpbigpWzBdLCB5LmRvbWFpbigpWzFdICsgeVN0ZXBdKTtcblxuICAgIC8vIERpc3BsYXkgdGhlIHRpbGVzIGZvciBlYWNoIG5vbi16ZXJvIGJ1Y2tldC5cbiAgICAvLyBTZWUgaHR0cDovL2JsLm9ja3Mub3JnLzMwNzQ0NzAgZm9yIGFuIGFsdGVybmF0aXZlIGltcGxlbWVudGF0aW9uLlxuICAgIHN2Z19oZWF0LnNlbGVjdEFsbChcIi50aWxlXCIpXG4gICAgICAgIC5kYXRhKGRhdGFfcGxvdClcbiAgICAgICAgLmVudGVyKCkuYXBwZW5kKFwicmVjdFwiKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwidGlsZVwiKVxuICAgICAgICAuYXR0cihcInhcIiwgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiB4KGRhdGFfcGxvdFtpXS54YXhpcyk7XG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKFwieVwiLCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIHkoZGF0YV9wbG90W2ldLnlheGlzICsgeVN0ZXAgKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCAxNSlcbiAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgMTUpXG4gICAgICAgIC5hdHRyKFwiZHhcIiwgXCIuMzVlbVwiKVxuICAgICAgICAuYXR0cihcImR5XCIsIFwiLjM1ZW1cIilcbiAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIHooZGF0YV9wbG90W2ldLnNjb3JlKTtcbiAgICAgICAgfSk7XG5cblxuICAgIHN2Z19oZWF0LmFwcGVuZChcInRleHRcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImxhYmVsXCIpXG4gICAgICAgIC5hdHRyKFwieFwiLCB3aWR0aF9oZWF0ICsgMjApXG4gICAgICAgIC5hdHRyKFwieVwiLCAxMClcbiAgICAgICAgLmF0dHIoXCJkeVwiLCBcIi4zNWVtXCIpXG4gICAgICAgIC50ZXh0KFwiQ291bnRcIik7XG5cbiAgICAvLyBBZGQgYW4geC1heGlzIHdpdGggbGFiZWwuXG4gICAgc3ZnX2hlYXQuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwieCBheGlzXCIpXG4gICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsXCIgKyBoZWlnaHRfaGVhdCArIFwiKVwiKVxuICAgICAgICAuY2FsbChkMy5zdmcuYXhpcygpLnNjYWxlKHgpLnRpY2tzKDUpLnRpY2tTaXplKC1oZWlnaHRfaGVhdCkub3JpZW50KFwiYm90dG9tXCIpKVxuICAgICAgICAuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwibGFiZWxcIilcbiAgICAgICAgLmF0dHIoXCJ4XCIsIHdpZHRoX2hlYXQpXG4gICAgICAgIC5hdHRyKFwieVwiLCAtNilcbiAgICAgICAgLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBcImVuZFwiKVxuICAgICAgICAudGV4dChcIlwiKTtcblxuICAgIC8vIEFkZCBhIHktYXhpcyB3aXRoIGxhYmVsLlxuICAgIHN2Z19oZWF0LmFwcGVuZChcImdcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInkgYXhpc1wiKVxuICAgICAgICAuY2FsbChkMy5zdmcuYXhpcygpLnNjYWxlKHkpLnRpY2tTaXplKC13aWR0aF9oZWF0KS5vcmllbnQoXCJsZWZ0XCIpKVxuICAgICAgICAuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwibGFiZWxcIilcbiAgICAgICAgLmF0dHIoXCJ5XCIsIDYpXG4gICAgICAgIC5hdHRyKFwiZHlcIiwgXCIuNzFlbVwiKVxuICAgICAgICAuYXR0cihcInRleHQtYW5jaG9yXCIsIFwiZW5kXCIpXG4gICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwicm90YXRlKC05MClcIilcbiAgICAgICAgLnRleHQoXCJcIik7XG5cbiAgICBzdmdfaGVhdC5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgIC5hdHRyKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIikgIC8vIHRoaXMgbWFrZXMgaXQgZWFzeSB0byBjZW50cmUgdGhlIHRleHQgYXMgdGhlIHRyYW5zZm9ybSBpcyBhcHBsaWVkIHRvIHRoZSBhbmNob3JcbiAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoLTQwLFwiICsgKGhlaWdodF9oZWF0IC8gMikgKyBcIilyb3RhdGUoLTkwKVwiKSAgLy8gdGV4dCBpcyBkcmF3biBvZmYgdGhlIHNjcmVlbiB0b3AgbGVmdCwgbW92ZSBkb3duIGFuZCBvdXQgYW5kIHJvdGF0ZVxuICAgICAgICAudGV4dCh5X0F4aXNfbmFtZSlcbiAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBcIiM0MjQyNDJcIilcbiAgICAgICAgLnN0eWxlKFwidGV4dC1pbmRlbnRcIixcIjIwcHhcIilcbiAgICAgICAgLnN0eWxlKFwiZm9udC1zaXplXCIsXCIxMnB4XCIpXG4gICAgICAgIC5zdHlsZShcImZvbnQtd2VpZ2h0XCIsXCJib2xkXCIpO1xuXG4gICAgc3ZnX2hlYXQuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAuYXR0cihcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpICAvLyB0aGlzIG1ha2VzIGl0IGVhc3kgdG8gY2VudHJlIHRoZSB0ZXh0IGFzIHRoZSB0cmFuc2Zvcm0gaXMgYXBwbGllZCB0byB0aGUgYW5jaG9yXG4gICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgKHdpZHRoX2hlYXQgLyAyKSArIFwiLFwiICsgKGhlaWdodF9oZWF0ICsgcGFkZGluZyAvIDQpICsgXCIpXCIpICAvLyBjZW50cmUgYmVsb3cgYXhpc1xuICAgICAgICAudGV4dCh4X0F4aXNfbmFtZSlcbiAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBcIiM0MjQyNDJcIilcbiAgICAgICAgLnN0eWxlKFwidGV4dC1pbmRlbnRcIixcIjIwcHhcIilcbiAgICAgICAgLnN0eWxlKFwiZm9udC1zaXplXCIsXCIxMnB4XCIpXG4gICAgICAgIC5zdHlsZShcImZvbnQtd2VpZ2h0XCIsXCJib2xkXCIpO1xufVxuXG5sZXQgaGVhdHhheGlzLCBoZWF0eWF4aXM7XG5sZXQgZGF0YV9wbG90ID0gW107XG5cbmZ1bmN0aW9uIGJpdmFyaWF0ZVBsb3QoeF9BeGlzLCB5X0F4aXMsIHhfQXhpc19uYW1lLCB5X0F4aXNfbmFtZSkge1xuICAgIGhlYXR4YXhpcyA9IHhfQXhpc19uYW1lO1xuICAgIGhlYXR5YXhpcyA9IHlfQXhpc19uYW1lO1xuICAgIGFwcC5ieUlkKCdzY2F0dGVycGxvdCcpLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIGQzLnNlbGVjdChcIiNzY2F0dGVycGxvdFwiKS5odG1sKFwiXCIpO1xuICAgIGQzLnNlbGVjdChcIiNzY2F0dGVycGxvdFwiKS5zZWxlY3QoXCJzdmdcIikucmVtb3ZlKCk7XG5cbiAgICAvLyBzY2F0dGVyIHBsb3RcbiAgICBkYXRhX3Bsb3QgPSBbXTtcbiAgICBsZXQgbmFuQ291bnQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTAwMDsgaSsrKSB7XG4gICAgICAgIGlmIChpc05hTih4X0F4aXNbaV0pIHx8IGlzTmFOKHlfQXhpc1tpXSkpIHtcbiAgICAgICAgICAgIG5hbkNvdW50Kys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgbmV3TnVtYmVyMSA9IHhfQXhpc1tpXTtcbiAgICAgICAgICAgIGxldCBuZXdOdW1iZXIyID0geV9BeGlzW2ldO1xuICAgICAgICAgICAgZGF0YV9wbG90LnB1c2goe3hheGlzOiBuZXdOdW1iZXIxLCB5YXhpczogbmV3TnVtYmVyMiwgc2NvcmU6IE1hdGgucmFuZG9tKCkgKiAxMDB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxldCBtYXJnaW4gPSB7dG9wOiAyMCwgcmlnaHQ6IDE1LCBib3R0b206IDQwLCBsZWZ0OiA2MH0sXG4gICAgICAgIHdpZHRoID0gNTAwIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQsXG4gICAgICAgIGhlaWdodCA9IDI4MCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tLFxuICAgICAgICBwYWRkaW5nID0gMTAwO1xuXG4gICAgbGV0IG1pbl94ID0gZDMubWluKGRhdGFfcGxvdCwgKF8sIGkpID0+IGRhdGFfcGxvdFtpXS54YXhpcyk7XG4gICAgbGV0IG1heF94ID0gZDMubWF4KGRhdGFfcGxvdCwgKF8sIGkpID0+IGRhdGFfcGxvdFtpXS54YXhpcyk7XG4gICAgdmFyIGF2Z194ID0gKG1heF94IC0gbWluX3gpIC8gMTA7XG4gICAgdmFyIG1pbl95ID0gZDMubWluKGRhdGFfcGxvdCwgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgcmV0dXJuIGRhdGFfcGxvdFtpXS55YXhpcztcbiAgICB9KTtcbiAgICB2YXIgbWF4X3kgPSBkMy5tYXgoZGF0YV9wbG90LCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICByZXR1cm4gZGF0YV9wbG90W2ldLnlheGlzO1xuICAgIH0pO1xuICAgIHZhciBhdmdfeSA9IChtYXhfeSAtIG1pbl95KSAvIDEwO1xuXG4gICAgdmFyIHhTY2FsZSA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgIC5kb21haW4oW21pbl94IC0gYXZnX3gsIG1heF94ICsgYXZnX3hdKVxuICAgICAgICAucmFuZ2UoWzAsIHdpZHRoXSk7XG5cbiAgICB2YXIgeVNjYWxlID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLmRvbWFpbihbbWluX3kgLSBhdmdfeSwgbWF4X3kgKyBhdmdfeV0pXG4gICAgICAgIC5yYW5nZShbaGVpZ2h0LCAwXSk7XG5cbiAgICB2YXIgeEF4aXMgPSBkMy5zdmcuYXhpcygpXG4gICAgICAgIC5zY2FsZSh4U2NhbGUpXG4gICAgICAgIC5vcmllbnQoJ2JvdHRvbScpXG4gICAgICAgIC50aWNrU2l6ZSgtaGVpZ2h0KTtcblxuICAgIHZhciB5QXhpcyA9IGQzLnN2Zy5heGlzKClcbiAgICAgICAgLnNjYWxlKHlTY2FsZSlcbiAgICAgICAgLm9yaWVudCgnbGVmdCcpXG4gICAgICAgIC50aWNrcyg1KVxuICAgICAgICAudGlja1NpemUoLXdpZHRoKTtcblxuICAgIHZhciB6b29tID0gZDMuYmVoYXZpb3Iuem9vbSgpXG4gICAgICAgIC54KHhTY2FsZSlcbiAgICAgICAgLnkoeVNjYWxlKVxuICAgICAgICAuc2NhbGVFeHRlbnQoWzEsIDEwXSlcbiAgICAgICAgLm9uKFwiem9vbVwiLCB6b29tZWQpO1xuXG4gICAgdmFyIGNoYXJ0X3NjYXR0ZXIgPSBkMy5zZWxlY3QoJyNzY2F0dGVycGxvdCcpXG4gICAgICAgIC5hcHBlbmQoJ3N2ZzpzdmcnKVxuICAgICAgICAuYXR0cignd2lkdGgnLCB3aWR0aCArIG1hcmdpbi5yaWdodCArIG1hcmdpbi5sZWZ0KVxuICAgICAgICAuYXR0cignaGVpZ2h0JywgaGVpZ2h0ICsgbWFyZ2luLnRvcCArIG1hcmdpbi5ib3R0b20pXG4gICAgICAgIC5jYWxsKHpvb20pO1xuXG4gICAgdmFyIG1haW4xID0gY2hhcnRfc2NhdHRlci5hcHBlbmQoJ2cnKVxuICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgbWFyZ2luLmxlZnQgKyAnLCcgKyBtYXJnaW4udG9wICsgJyknKVxuICAgICAgICAuYXR0cignd2lkdGgnLCB3aWR0aCsgbWFyZ2luLnJpZ2h0ICsgbWFyZ2luLmxlZnQpXG4gICAgICAgIC5hdHRyKCdoZWlnaHQnLCBoZWlnaHQgKyBtYXJnaW4udG9wICsgbWFyZ2luLmJvdHRvbSlcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ21haW4nKTtcblxuICAgIG1haW4xLmFwcGVuZCgnZycpXG4gICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsJyArIGhlaWdodCArICcpJylcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3ggYXhpcycpXG4gICAgICAgIC5jYWxsKHhBeGlzKTtcblxuICAgIG1haW4xLmFwcGVuZCgnZycpXG4gICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsMCknKVxuICAgICAgICAuYXR0cignY2xhc3MnLCAneSBheGlzJylcbiAgICAgICAgLmNhbGwoeUF4aXMpO1xuXG4gICAgdmFyIGNsaXAgPSBtYWluMS5hcHBlbmQoXCJkZWZzXCIpLmFwcGVuZChcInN2ZzpjbGlwUGF0aFwiKVxuICAgICAgICAuYXR0cihcImlkXCIsIFwiY2xpcFwiKVxuICAgICAgICAuYXBwZW5kKFwic3ZnOnJlY3RcIilcbiAgICAgICAgLmF0dHIoXCJpZFwiLCBcImNsaXAtcmVjdFwiKVxuICAgICAgICAuYXR0cihcInhcIiwgXCIwXCIpXG4gICAgICAgIC5hdHRyKFwieVwiLCBcIjBcIilcbiAgICAgICAgLmF0dHIoJ3dpZHRoJywgd2lkdGgpXG4gICAgICAgIC5hdHRyKCdoZWlnaHQnLCBoZWlnaHQpO1xuXG4gICAgbWFpbjEuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xpcC1wYXRoXCIsIFwidXJsKCNjbGlwKVwiKVxuICAgICAgICAuc2VsZWN0QWxsKFwiY2lyY2xlXCIpXG4gICAgICAgIC5kYXRhKGRhdGFfcGxvdClcbiAgICAgICAgLmVudGVyKClcbiAgICAgICAgLmFwcGVuZChcImNpcmNsZVwiKVxuICAgICAgICAuYXR0cihcImN4XCIsIChfLCBpKSA9PiB4U2NhbGUoZGF0YV9wbG90W2ldLnhheGlzKSlcbiAgICAgICAgLmF0dHIoXCJjeVwiLCAoXywgaSkgPT4geVNjYWxlKGRhdGFfcGxvdFtpXS55YXhpcykpXG4gICAgICAgIC5hdHRyKFwiclwiLCAyKVxuICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIFwiI0I3MUMxQ1wiKTtcbiAgICBjaGFydF9zY2F0dGVyLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKSAgLy8gdGhpcyBtYWtlcyBpdCBlYXN5IHRvIGNlbnRyZSB0aGUgdGV4dCBhcyB0aGUgdHJhbnNmb3JtIGlzIGFwcGxpZWQgdG8gdGhlIGFuY2hvclxuICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIHBhZGRpbmcgLyA1ICsgXCIsXCIgKyAoaGVpZ2h0IC8gMikgKyBcIilyb3RhdGUoLTkwKVwiKSAgLy8gdGV4dCBpcyBkcmF3biBvZmYgdGhlIHNjcmVlbiB0b3AgbGVmdCwgbW92ZSBkb3duIGFuZCBvdXQgYW5kIHJvdGF0ZVxuICAgICAgICAudGV4dCh5X0F4aXNfbmFtZSlcbiAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBcIiM0MjQyNDJcIilcbiAgICAgICAgLnN0eWxlKFwidGV4dC1pbmRlbnRcIixcIjIwcHhcIilcbiAgICAgICAgLnN0eWxlKFwiZm9udC1zaXplXCIsXCIxMnB4XCIpXG4gICAgICAgIC5zdHlsZShcImZvbnQtd2VpZ2h0XCIsXCJib2xkXCIpO1xuXG4gICAgY2hhcnRfc2NhdHRlci5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgIC5hdHRyKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIikgIC8vIHRoaXMgbWFrZXMgaXQgZWFzeSB0byBjZW50cmUgdGhlIHRleHQgYXMgdGhlIHRyYW5zZm9ybSBpcyBhcHBsaWVkIHRvIHRoZSBhbmNob3JcbiAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyAod2lkdGggLyAyKSArIFwiLFwiICsgKGhlaWdodCArIChwYWRkaW5nIC8gMikpICsgXCIpXCIpICAvLyBjZW50cmUgYmVsb3cgYXhpc1xuICAgICAgICAudGV4dCh4X0F4aXNfbmFtZSlcbiAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBcIiM0MjQyNDJcIilcbiAgICAgICAgLnN0eWxlKFwidGV4dC1pbmRlbnRcIixcIjIwcHhcIilcbiAgICAgICAgLnN0eWxlKFwiZm9udC1zaXplXCIsXCIxMnB4XCIpXG4gICAgICAgIC5zdHlsZShcImZvbnQtd2VpZ2h0XCIsXCJib2xkXCIpO1xuXG4gICAgZnVuY3Rpb24gem9vbWVkKCkge1xuICAgICAgICB2YXIgcGFuWCA9IGQzLmV2ZW50LnRyYW5zbGF0ZVswXTtcbiAgICAgICAgdmFyIHBhblkgPSBkMy5ldmVudC50cmFuc2xhdGVbMV07XG4gICAgICAgIHZhciBzY2FsZSA9IGQzLmV2ZW50LnNjYWxlO1xuXG4gICAgICAgIHBhblggPSBwYW5YID4gMTAgPyAxMCA6IHBhblg7XG4gICAgICAgIHZhciBtYXhYID0gLShzY2FsZSAtIDEpICogd2lkdGggLSAxMDtcbiAgICAgICAgcGFuWCA9IHBhblggPCBtYXhYID8gbWF4WCA6IHBhblg7XG5cbiAgICAgICAgcGFuWSA9IHBhblkgPiAxMCA/IDEwIDogcGFuWTtcbiAgICAgICAgdmFyIG1heFkgPSAtKHNjYWxlIC0gMSkgKiBoZWlnaHQgLSAxMDtcbiAgICAgICAgcGFuWSA9IHBhblkgPCBtYXhZID8gbWF4WSA6IHBhblk7XG5cbiAgICAgICAgem9vbS50cmFuc2xhdGUoW3BhblgsIHBhblldKTtcblxuICAgICAgICBtYWluMS5zZWxlY3QoXCIueC5heGlzXCIpLmNhbGwoeEF4aXMpO1xuICAgICAgICBtYWluMS5zZWxlY3QoXCIueS5heGlzXCIpLmNhbGwoeUF4aXMpO1xuICAgICAgICBtYWluMS5zZWxlY3RBbGwoXCJjaXJjbGVcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY3hcIiwgKF8sIGkpID0+IHhTY2FsZShkYXRhX3Bsb3RbaV0ueGF4aXMpKVxuICAgICAgICAgICAgLmF0dHIoXCJjeVwiLCAoXywgaSkgPT4geVNjYWxlKGRhdGFfcGxvdFtpXS55YXhpcykpXG4gICAgICAgICAgICAuYXR0cihcInJcIiwgMi41KVxuICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBcIiNCNzFDMUNcIik7XG4gICAgfVxuXG4gICAgZDMuc2VsZWN0KCcjTkFjb3VudCcpLnN0eWxlKCdkaXNwbGF5JywgJ2Jsb2NrJyk7XG4gICAgZDMuc2VsZWN0KFwiI05BY291bnRcIikudGV4dChcIlRoZXJlIGFyZSBcIiArIG5hbkNvdW50ICsgXCIgbnVtYmVyIG9mIE5BIHZhbHVlcyBpbiB0aGUgcmVsYXRpb24uXCIpO1xufVxuXG5sZXQgcGxvdG5hbWVhLCBwbG90bmFtZWIsIHZhcm4xLCB2YXJuMiwgdmFyc2l6ZTEsIHZhcnNpemUyO1xuXG5sZXQgY29udGludW91c19uID0gMDtcbmxldCBiYXJfbiA9IDA7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRfd2lkdGgoaWQpIHtcbiAgICByZXR1cm4gNTAgKiAoaWQgPT09ICdwbG90QScgPyBjb250aW51b3VzX24gOiBiYXJfbik7XG59XG5cbmZ1bmN0aW9uIGNyb3NzVGFiUGxvdHMoUGxvdE5hbWVBLCBQbG90TmFtZUIsIGpzb25fb2JqKSB7XG4gICAgcGxvdG5hbWVhID0gUGxvdE5hbWVBO1xuICAgIHBsb3RuYW1lYiA9IFBsb3ROYW1lQjtcbiAgICAkKFwiI2lucHV0MVwiKS5hdHRyKFwicGxhY2Vob2xkZXJcIiwgUGxvdE5hbWVBKS5ibHVyKCk7XG4gICAgJChcIiNpbnB1dDJcIikuYXR0cihcInBsYWNlaG9sZGVyXCIsIFBsb3ROYW1lQikuYmx1cigpO1xuICAgIGxldCBbcGxvdF9hLCBwbG90X2JdID0gWycjcGxvdEEnLCAnI3Bsb3RCJ107XG5cbiAgICB2YXIgbWFyZ2luX2Nyb3NzID0ge3RvcDogMzAsIHJpZ2h0OiAzNSwgYm90dG9tOiA0MCwgbGVmdDogNDB9LFxuICAgICAgICB3aWR0aF9jcm9zcyA9IDMwMCAtIG1hcmdpbl9jcm9zcy5sZWZ0IC0gbWFyZ2luX2Nyb3NzLnJpZ2h0LFxuICAgICAgICBoZWlnaHRfY3Jvc3MgPSAxNjAgLSBtYXJnaW5fY3Jvc3MudG9wIC0gbWFyZ2luX2Nyb3NzLmJvdHRvbTtcbiAgICB2YXIgcGFkZGluZ19jcm9zcyA9IDEwMDtcblxuICAgIGQzLnNlbGVjdChcIiNpbnB1dDFcIikub24oXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGQzLnNlbGVjdChcIiN0b29sdGlwUGxvdEFcIilcbiAgICAgICAgICAgIC5zdHlsZShcInZpc2liaWxpdHlcIiwgXCJ2aXNpYmxlXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsXCIxXCIpXG4gICAgICAgICAgICAudGV4dChQbG90TmFtZUEpO1xuICAgIH0pXG4gICAgICAgIC5vbihcIm1vdXNlb3V0XCIsZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGQzLnNlbGVjdChcIiN0b29sdGlwUGxvdEFcIilcbiAgICAgICAgICAgICAgICAuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIFwiaGlkZGVuXCIpXG4gICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLFwiMFwiKTtcbiAgICAgICAgfSk7XG4gICAgZDMuc2VsZWN0KFwiI2lucHV0MlwiKS5vbihcIm1vdXNlb3ZlclwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgZDMuc2VsZWN0KFwiI3Rvb2x0aXBQbG90QlwiKVxuICAgICAgICAgICAgLnN0eWxlKFwidmlzaWJpbGl0eVwiLCBcInZpc2libGVcIilcbiAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIixcIjFcIilcbiAgICAgICAgICAgIC50ZXh0KFBsb3ROYW1lQik7XG4gICAgfSlcbiAgICAgICAgLm9uKFwibW91c2VvdXRcIixmdW5jdGlvbigpe1xuICAgICAgICAgICAgZDMuc2VsZWN0KFwiI3Rvb2x0aXBQbG90QlwiKVxuICAgICAgICAgICAgICAgIC5zdHlsZShcInZpc2liaWxpdHlcIiwgXCJoaWRkZW5cIilcbiAgICAgICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsXCIwXCIpO1xuICAgICAgICB9KTtcblxuICAgIHZhciBwbG90X25vZGVzID0gYXBwLm5vZGVzLnNsaWNlKCk7XG4gICAgZm9yIChsZXQgbm9kZSBvZiBwbG90X25vZGVzKSB7XG4gICAgICAgIGlmIChub2RlLm5hbWUgPT09IFBsb3ROYW1lQSkge1xuICAgICAgICAgICAgaWYgKG5vZGUucGxvdHR5cGUgPT09IFwiY29udGludW91c1wiKSB7XG4gICAgICAgICAgICAgICAgY29udGludW91c19uKys7XG4gICAgICAgICAgICAgICAgZGVuc2l0eV9jcm9zcyhub2RlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS5wbG90dHlwZSA9PT0gXCJiYXJcIikge1xuICAgICAgICAgICAgICAgIGJhcl9uKys7XG4gICAgICAgICAgICAgICAgYmFyX2Nyb3NzKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG5vZGUubmFtZSA9PT0gUGxvdE5hbWVCKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5wbG90dHlwZSA9PT0gXCJjb250aW51b3VzXCIpIHtcbiAgICAgICAgICAgICAgICBjb250aW51b3VzX24rKztcbiAgICAgICAgICAgICAgICBkZW5zaXR5X2Nyb3NzKG5vZGUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLnBsb3R0eXBlID09PSBcImJhclwiKSB7XG4gICAgICAgICAgICAgICAgYmFyX24rKztcbiAgICAgICAgICAgICAgICBiYXJfY3Jvc3Mobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgcGxvdEFfc2l6ZSwgcGxvdEJfc2l6ZSwgcGxvdEFfc2l6ZW0sIHBsb3RCX3NpemVtO1xuICAgIGxldCB2YXJuMSwgdmFybjIsIHZhcnNpemUxLCB2YXJzaXplMjtcbiAgICAkKFwiI0VxdWlkaXN0YW5jZTFcIikuY2xpY2soZnVuY3Rpb24oKXtcbiAgICAgICAgdmFybjEgPSBcImVxdWlkaXN0YW5jZVwiO1xuICAgICAgICBwbG90QV9zaXplID0gcGFyc2VJbnQoZDMuc2VsZWN0KFwiI2lucHV0MVwiKVswXVswXS52YWx1ZSk7XG4gICAgICAgIHZhcnNpemUxID0gcGxvdEFfc2l6ZTtcbiAgICAgICAgZXF1aWRpc3RhbmNlKFBsb3ROYW1lQSwgcGxvdEFfc2l6ZSk7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicGxvdEFfc3RhdHVzXCIpLmlubmVySFRNTCA9IGAke1Bsb3ROYW1lQX0gOiAke3Zhcm4xfSBkaXN0cmlidXRpb24gd2l0aCAke3ZhcnNpemUxfSBkaXZpc2lvbnNgO1xuICAgIH0pO1xuICAgICQoXCIjRXF1aW1hc3MxXCIpLmNsaWNrKGZ1bmN0aW9uKCl7XG4gICAgICAgIHBsb3RBX3NpemVtID0gcGFyc2VJbnQoZDMuc2VsZWN0KFwiI2lucHV0MVwiKVswXVswXS52YWx1ZSk7XG4gICAgICAgIHZhcnNpemUxID0gcGxvdEFfc2l6ZW07XG4gICAgICAgIGVxdWltYXNzKFBsb3ROYW1lQSwgcGxvdEFfc2l6ZW0pO1xuICAgICAgICB2YXJuMSA9IFwiZXF1aW1hc3NcIjtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJwbG90QV9zdGF0dXNcIikuaW5uZXJIVE1MID0gYCR7UGxvdE5hbWVBfSA6ICR7dmFybjF9IGRpc3RyaWJ1dGlvbiB3aXRoICR7dmFyc2l6ZTF9IGRpdmlzaW9uc2A7XG4gICAgfSk7XG4gICAgJChcIiNFcXVpZGlzdGFuY2UyXCIpLmNsaWNrKGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhcm4yID0gXCJlcXVpZGlzdGFuY2VcIjtcbiAgICAgICAgcGxvdEJfc2l6ZSA9IHBhcnNlSW50KGQzLnNlbGVjdChcIiNpbnB1dDJcIilbMF1bMF0udmFsdWUpO1xuICAgICAgICBlcXVpZGlzdGFuY2UoUGxvdE5hbWVCLCBwbG90Ql9zaXplKTtcbiAgICAgICAgdmFyc2l6ZTIgPSBwbG90Ql9zaXplO1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInBsb3RCX3N0YXR1c1wiKS5pbm5lckhUTUwgPSBgJHtQbG90TmFtZUJ9IDogJHt2YXJuMn0gZGlzdHJpYnV0aW9uIHdpdGggJHt2YXJzaXplMn0gZGl2aXNpb25zYDtcbiAgICB9KTtcbiAgICAkKFwiI0VxdWltYXNzMlwiKS5jbGljayhmdW5jdGlvbigpe1xuICAgICAgICB2YXJuMiA9IFwiZXF1aW1hc3NcIjtcbiAgICAgICAgcGxvdEJfc2l6ZW0gPSBwYXJzZUludChkMy5zZWxlY3QoXCIjaW5wdXQyXCIpWzBdWzBdLnZhbHVlKTtcbiAgICAgICAgZXF1aW1hc3MoUGxvdE5hbWVCLCBwbG90Ql9zaXplbSk7XG4gICAgICAgIHZhcnNpemUyID0gcGxvdEJfc2l6ZW07XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicGxvdEJfc3RhdHVzXCIpLmlubmVySFRNTCA9IGAke1Bsb3ROYW1lQn0gOiAke3Zhcm4yfSBkaXN0cmlidXRpb24gd2l0aCAke3ZhcnNpemUyfSBkaXZpc2lvbnNgO1xuICAgIH0pO1xuXG4gICAgLy8gdGhpcyBpcyB0aGUgZnVuY3Rpb24gdG8gYWRkICB0aGUgZGVuc2l0eSBwbG90IGlmIGFueVxuICAgIGZ1bmN0aW9uIGRlbnNpdHlfY3Jvc3MoZGVuc2l0eV9lbnYsYSxtZXRob2RfbmFtZSkge1xuICAgICAgICAvLyBzZXR1cCB0aGUgeF9jb3JkIGFjY29yZGluZyB0byB0aGUgc2l6ZSBnaXZlbiBieSB1c2VyXG4gICAgICAgIHZhciB5VmFscyA9IGRlbnNpdHlfZW52LnBsb3R5O1xuICAgICAgICB2YXIgeFZhbHMgPSBkZW5zaXR5X2Vudi5wbG90eDtcblxuICAgICAgICAvLyBhbiBhcnJheSBvZiBvYmplY3RzXG4gICAgICAgIHZhciBkYXRhMiA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlbnNpdHlfZW52LnBsb3R4Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBkYXRhMi5wdXNoKHt4OiBkZW5zaXR5X2Vudi5wbG90eFtpXSwgeTogZGVuc2l0eV9lbnYucGxvdHlbaV19KTtcbiAgICAgICAgfVxuICAgICAgICBkYXRhMi5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICBkLnggPSArZC54O1xuICAgICAgICAgICAgZC55ID0gK2QueTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIG1pbl94ID0gZDMubWluKGRhdGEyLCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGEyW2ldLng7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbWF4X3ggPSBkMy5tYXgoZGF0YTIsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTJbaV0ueDtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBhdmdfeCA9IChtYXhfeCAtIG1pbl94KSAvIDEwO1xuICAgICAgICB2YXIgbWluX3kgPSBkMy5taW4oZGF0YTIsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTJbaV0ueTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBtYXhfeSA9IGQzLm1heChkYXRhMiwgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhMltpXS55O1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGF2Z195ID0gKG1heF95IC0gbWluX3kpIC8gMTA7XG4gICAgICAgIHZhciB4ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgICAgIC5kb21haW4oW2QzLm1pbih4VmFscyksIGQzLm1heCh4VmFscyldKVxuICAgICAgICAgICAgLnJhbmdlKFswLCB3aWR0aF9jcm9zc10pO1xuICAgICAgICB2YXIgaW52eCA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgICAgICAucmFuZ2UoW2QzLm1pbihkYXRhMi5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZC54O1xuICAgICAgICAgICAgfSkpLCBkMy5tYXgoZGF0YTIubWFwKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGQueDtcbiAgICAgICAgICAgIH0pKV0pXG4gICAgICAgICAgICAuZG9tYWluKFswLCB3aWR0aF9jcm9zc10pO1xuICAgICAgICB2YXIgeSA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgICAgICAuZG9tYWluKFtkMy5taW4oZGF0YTIubWFwKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGQueTtcbiAgICAgICAgICAgIH0pKSwgZDMubWF4KGRhdGEyLm1hcChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkLnk7XG4gICAgICAgICAgICB9KSldKVxuICAgICAgICAgICAgLnJhbmdlKFtoZWlnaHRfY3Jvc3MsIDBdKTtcbiAgICAgICAgdmFyIHhBeGlzID0gZDMuc3ZnLmF4aXMoKVxuICAgICAgICAgICAgLnNjYWxlKHgpXG4gICAgICAgICAgICAudGlja3MoNSlcbiAgICAgICAgICAgIC5vcmllbnQoXCJib3R0b21cIik7XG4gICAgICAgIHZhciB5QXhpcyA9IGQzLnN2Zy5heGlzKClcbiAgICAgICAgICAgIC5zY2FsZSh5KVxuICAgICAgICAgICAgLm9yaWVudChcImxlZnRcIik7XG4gICAgICAgIHZhciBhcmVhID0gZDMuc3ZnLmFyZWEoKVxuICAgICAgICAgICAgLmludGVycG9sYXRlKFwibW9ub3RvbmVcIilcbiAgICAgICAgICAgIC54KGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHgoZC54KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAueTAoaGVpZ2h0X2Nyb3NzIC0gYXZnX3kpXG4gICAgICAgICAgICAueTEoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geShkLnkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIHZhciBsaW5lID0gZDMuc3ZnLmxpbmUoKVxuICAgICAgICAgICAgLngoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geChkLngpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC55KGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHkoZC55KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuaW50ZXJwb2xhdGUoXCJtb25vdG9uZVwiKTtcblxuICAgICAgICB2YXIgcGxvdHN2ZyA9IGQzLnNlbGVjdChwbG90X2EpXG4gICAgICAgICAgICAuYXBwZW5kKFwic3ZnXCIpXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsIFwicGxvdHN2Z19pZFwiKVxuICAgICAgICAgICAgLnN0eWxlKFwid2lkdGhcIiwgd2lkdGhfY3Jvc3MgKyBtYXJnaW5fY3Jvc3MubGVmdCArIG1hcmdpbl9jcm9zcy5yaWdodCkgLy9zZXR0aW5nIGhlaWdodCB0byB0aGUgaGVpZ2h0IG9mICNtYWluLmxlZnRcbiAgICAgICAgICAgIC5zdHlsZShcImhlaWdodFwiLCBoZWlnaHRfY3Jvc3MgKyBtYXJnaW5fY3Jvc3MudG9wICsgbWFyZ2luX2Nyb3NzLmJvdHRvbSlcbiAgICAgICAgICAgIC5zdHlsZShcIm1hcmdpbi1sZWZ0XCIsXCIyMHB4XCIpXG4gICAgICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCxcIiArIG1hcmdpbl9jcm9zcy50b3AgKyBcIilcIik7XG4gICAgICAgIHBsb3RzdmcuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBcInBhdGgxXCIpXG4gICAgICAgICAgICAuZGF0dW0oZGF0YTIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiYXJlYVwiKVxuICAgICAgICAgICAgLmF0dHIoXCJkXCIsIGFyZWEpO1xuICAgICAgICBwbG90c3ZnLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJ4IGF4aXNcIilcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsXCIgKyAoaGVpZ2h0X2Nyb3NzICApICsgXCIpXCIpXG4gICAgICAgICAgICAuY2FsbCh4QXhpcyk7XG4gICAgICAgIHBsb3RzdmcuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ4XCIsICh3aWR0aF9jcm9zcyAvIDIpKVxuICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIChtYXJnaW5fY3Jvc3MudG9wICsgcGFkZGluZ19jcm9zcyAtMTApKVxuICAgICAgICAgICAgLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKVxuICAgICAgICAgICAgLnRleHQoZGVuc2l0eV9lbnYubmFtZSlcbiAgICAgICAgICAgIC5zdHlsZShcInRleHQtaW5kZW50XCIsXCIyMHB4XCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJmb250LXNpemVcIixcIjEycHhcIilcbiAgICAgICAgICAgIC5zdHlsZShcImZvbnQtd2VpZ2h0XCIsXCJib2xkXCIpO1xuXG4gICAgICAgIGlmIChpc05hTihhKSB8fCBhID09PSAwKSB7XG4gICAgICAgICAgICB2YXIgdXBwZXJfbGltaXQgPSBkMy5tYXgoeFZhbHMpO1xuICAgICAgICAgICAgdmFyIGxvd2VyX2xpbWl0ID0gZDMubWluKHhWYWxzKTtcbiAgICAgICAgICAgIHZhciB6ID0gMTA7XG4gICAgICAgICAgICB2YXIgZGlmZiA9IHVwcGVyX2xpbWl0IC0gbG93ZXJfbGltaXQ7XG4gICAgICAgICAgICB2YXIgYnVmZmVyID0gZGlmZiAvIHo7XG4gICAgICAgICAgICB2YXIgeF9jb3JkID0gW107XG4gICAgICAgICAgICB2YXIgcHVzaF9kYXRhID0gbG93ZXJfbGltaXQ7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHogLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwdXNoX2RhdGEgPSBwdXNoX2RhdGEgKyBidWZmZXI7XG4gICAgICAgICAgICAgICAgeF9jb3JkLnB1c2gocHVzaF9kYXRhKTtcbiAgICAgICAgICAgICAgICBwbG90c3ZnLmFwcGVuZChcImxpbmVcIilcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBcImxpbmUxXCIpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieDFcIiwgeCh4X2NvcmRbaV0pKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcIngyXCIsIHgoeF9jb3JkW2ldKSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ5MVwiLCB5KGQzLm1pbih5VmFscykpKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcInkyXCIsIHkoZDMubWF4KHlWYWxzKSkpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZShcInN0cm9rZVwiLCBcIiMwRDQ3QTFcIilcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwic3Ryb2tlLWRhc2hhcnJheVwiLCBcIjNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAobWV0aG9kX25hbWUgPT09IFwiZXF1aWRpc3RhbmNlXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgdXBwZXJfbGltaXQgPSBkMy5tYXgoeFZhbHMpO1xuICAgICAgICAgICAgICAgIHZhciBsb3dlcl9saW1pdCA9IGQzLm1pbih4VmFscyk7XG4gICAgICAgICAgICAgICAgdmFyIGRpZmYgPSB1cHBlcl9saW1pdCAtIGxvd2VyX2xpbWl0O1xuICAgICAgICAgICAgICAgIHZhciBidWZmZXIgPSBkaWZmIC8gYTtcbiAgICAgICAgICAgICAgICB2YXIgeF9jb3JkID0gW107XG4gICAgICAgICAgICAgICAgdmFyIHB1c2hfZGF0YSA9IGxvd2VyX2xpbWl0O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYSAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBwdXNoX2RhdGEgPSBwdXNoX2RhdGEgKyBidWZmZXI7XG4gICAgICAgICAgICAgICAgICAgIHhfY29yZC5wdXNoKHB1c2hfZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHBsb3RzdmcuYXBwZW5kKFwibGluZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBcImxpbmUxXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcIngxXCIsIHgoeF9jb3JkW2ldKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieDJcIiwgeCh4X2NvcmRbaV0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ5MVwiLCB5KGQzLm1pbih5VmFscykpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ5MlwiLCB5KGQzLm1heCh5VmFscykpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwic3Ryb2tlXCIsIFwiIzBENDdBMVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwic3Ryb2tlLWRhc2hhcnJheVwiLCBcIjRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChtZXRob2RfbmFtZSA9PT0gXCJlcXVpbWFzc1wiKSB7XG4gICAgICAgICAgICAgICAgLy8gaGVyZSB3ZSB1c2UgdGhlIGRhdGEgZnJvbSBlcXVpbWFzc0NhbGN1bGF0aW9uIHRvIGRyYXcgbGluZXNcbiAgICAgICAgICAgICAgICB2YXIgdGVtcCA9IFtdO1xuICAgICAgICAgICAgICAgIHRlbXAgPSBlcXVpbWFzc0NhbGN1bGF0aW9uKGRlbnNpdHlfZW52LCBhKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGE7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBwbG90c3ZnLmFwcGVuZChcImxpbmVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgXCJsaW5lMVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ4MVwiLCB4KHRlbXBbaV0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ4MlwiLCB4KHRlbXBbaV0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ5MVwiLCB5KGQzLm1pbih5VmFscykpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ5MlwiLCB5KGQzLm1heCh5VmFscykpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwic3Ryb2tlXCIsIFwiIzBENDdBMVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwic3Ryb2tlLWRhc2hhcnJheVwiLCBcIjRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gdGhpcyBpcyB0aGUgZnVuY3Rpb24gdG8gYWRkIHRoZSBiYXIgcGxvdCBpZiBhbnlcbiAgICBmdW5jdGlvbiBiYXJfY3Jvc3MoYmFyX2VudixhLG1ldGhvZF9uYW1lKSB7XG4gICAgICAgIHZhciBiYXJQYWRkaW5nID0gLjAxNTsgIC8vIFNwYWNlIGJldHdlZW4gYmFyc1xuICAgICAgICB2YXIgdG9wU2NhbGUgPSAxLjI7ICAgICAgLy8gTXVsdGlwbGljYXRpdmUgZmFjdG9yIHRvIGFzc2lnbiBzcGFjZSBhdCB0b3Agd2l0aGluIGdyYXBoIC0gY3VycmVudGx5IHJlbW92ZWQgZnJvbSBpbXBsZW1lbnRhdGlvblxuICAgICAgICB2YXIgcGxvdFhheGlzID0gdHJ1ZTtcblxuICAgICAgICAvLyBEYXRhXG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYmFyX2Vudi5wbG90dmFsdWVzKTtcbiAgICAgICAgdmFyIHlWYWxzID0gbmV3IEFycmF5O1xuICAgICAgICB2YXIgY2lVcHBlclZhbHMgPSBuZXcgQXJyYXk7XG4gICAgICAgIHZhciBjaUxvd2VyVmFscyA9IG5ldyBBcnJheTtcbiAgICAgICAgdmFyIGNpU2l6ZTtcblxuICAgICAgICB2YXIgeFZhbHMgPSBuZXcgQXJyYXk7XG4gICAgICAgIHZhciB5VmFsS2V5ID0gbmV3IEFycmF5O1xuXG4gICAgICAgIGlmIChiYXJfZW52Lm5hdHVyZSA9PT0gXCJub21pbmFsXCIpIHtcbiAgICAgICAgICAgIHZhciB4aSA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoYmFyX2Vudi5wbG90dmFsdWVzW2tleXNbaV1dID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHlWYWxzW3hpXSA9IGJhcl9lbnYucGxvdHZhbHVlc1trZXlzW2ldXTtcbiAgICAgICAgICAgICAgICB4VmFsc1t4aV0gPSB4aTtcbiAgICAgICAgICAgICAgICBpZiAoJHByaXZhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJhcl9lbnYucGxvdHZhbHVlc0NJKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaUxvd2VyVmFsc1t4aV0gPSBiYXJfZW52LnBsb3RWYWx1ZXNDSS5sb3dlckJvdW5kW2tleXNbaV1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2lVcHBlclZhbHNbeGldID0gYmFyX2Vudi5wbG90VmFsdWVzQ0kudXBwZXJCb3VuZFtrZXlzW2ldXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjaVNpemUgPSBjaVVwcGVyVmFsc1t4aV0gLSBjaUxvd2VyVmFsc1t4aV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHlWYWxLZXkucHVzaCh7eTogeVZhbHNbeGldLCB4OiBrZXlzW2ldfSk7XG4gICAgICAgICAgICAgICAgeGkgPSB4aSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5VmFsS2V5LnNvcnQoKGEsIGIpID0+IGIueSAtIGEueSk7IC8vIGFycmF5IG9mIG9iamVjdHMsIGVhY2ggb2JqZWN0IGhhcyB5LCB0aGUgc2FtZSBhcyB5VmFscywgYW5kIHgsIHRoZSBjYXRlZ29yeVxuICAgICAgICAgICAgeVZhbHMuc29ydCgoYSwgYikgPT4gYiAtIGEpOyAvLyBhcnJheSBvZiB5IHZhbHVlcywgdGhlIGhlaWdodCBvZiB0aGUgYmFyc1xuICAgICAgICAgICAgY2lVcHBlclZhbHMuc29ydCgoYSwgYikgPT4gYi55IC0gYS55KTsgLy8gP1xuICAgICAgICAgICAgY2lMb3dlclZhbHMuc29ydCgoYSwgYikgPT4gYi55IC0gYS55KTsgLy8gP1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgeVZhbHNbaV0gPSBiYXJfZW52LnBsb3R2YWx1ZXNba2V5c1tpXV07XG4gICAgICAgICAgICAgICAgeFZhbHNbaV0gPSBOdW1iZXIoa2V5c1tpXSk7XG4gICAgICAgICAgICAgICAgaWYgKCRwcml2YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiYXJfZW52LnBsb3R2YWx1ZXNDSSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2lMb3dlclZhbHNbaV0gPSBiYXJfZW52LnBsb3R2YWx1ZXNDSS5sb3dlckJvdW5kW2tleXNbaV1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2lVcHBlclZhbHNbaV0gPSBiYXJfZW52LnBsb3R2YWx1ZXNDSS51cHBlckJvdW5kW2tleXNbaV1dO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNpU2l6ZSA9IGNpVXBwZXJWYWxzW2ldIC0gY2lMb3dlclZhbHNbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCh5VmFscy5sZW5ndGggPiAxNSAmIGJhcl9lbnYubnVtY2hhciA9PT0gXCJudW1lcmljXCIpIHwgKHlWYWxzLmxlbmd0aCA+IDUgJiBiYXJfZW52Lm51bWNoYXIgPT09IFwiY2hhcmFjdGVyXCIpKSB7XG4gICAgICAgICAgICBwbG90WGF4aXMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWluWT1kMy5taW4oeVZhbHMpO1xuICAgICAgICB2YXIgIG1heFkgPSBkMy5tYXgoeVZhbHMpOyAvLyBpbiB0aGUgZnV0dXJlLCBzZXQgbWF4WSB0byB0aGUgdmFsdWUgb2YgdGhlIG1heGltdW0gY29uZmlkZW5jZSBsaW1pdFxuICAgICAgICB2YXIgIG1pblggPSBkMy5taW4oeFZhbHMpO1xuICAgICAgICB2YXIgIG1heFggPSBkMy5tYXgoeFZhbHMpO1xuICAgICAgICB2YXIgICB4XzEgPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAgICAgLmRvbWFpbihbbWluWCAtIDAuNSwgbWF4WCArIDAuNV0pXG4gICAgICAgICAgICAucmFuZ2UoWzAsIHdpZHRoX2Nyb3NzXSk7XG5cbiAgICAgICAgdmFyIGludnggPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAgICAgLnJhbmdlKFttaW5YIC0gMC41LCBtYXhYICsgMC41XSlcbiAgICAgICAgICAgIC5kb21haW4oWzAsIHdpZHRoX2Nyb3NzXSk7XG5cbiAgICAgICAgdmFyICB5XzEgPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAvLyAuZG9tYWluKFswLCBtYXhZXSlcbiAgICAgICAgICAgIC5kb21haW4oWzAsIG1heFldKVxuICAgICAgICAgICAgLnJhbmdlKFswLCBoZWlnaHRfY3Jvc3NdKTtcblxuICAgICAgICB2YXIgeEF4aXMgPSBkMy5zdmcuYXhpcygpXG4gICAgICAgICAgICAuc2NhbGUoeF8xKVxuICAgICAgICAgICAgLnRpY2tzKHlWYWxzLmxlbmd0aClcbiAgICAgICAgICAgIC5vcmllbnQoXCJib3R0b21cIik7XG5cbiAgICAgICAgdmFyIHlBeGlzID0gZDMuc3ZnLmF4aXMoKVxuICAgICAgICAgICAgLnNjYWxlKHlfMSlcbiAgICAgICAgICAgIC5vcmllbnQoXCJsZWZ0XCIpO1xuXG4gICAgICAgIHZhciBwbG90c3ZnMSA9IGQzLnNlbGVjdChwbG90X2IpXG4gICAgICAgICAgICAuYXBwZW5kKFwic3ZnXCIpXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsXCJwbG90c3ZnMV9pZFwiKVxuICAgICAgICAgICAgLnN0eWxlKFwid2lkdGhcIiwgd2lkdGhfY3Jvc3MgKyBtYXJnaW5fY3Jvc3MubGVmdCArIG1hcmdpbl9jcm9zcy5yaWdodCkgLy9zZXR0aW5nIGhlaWdodCB0byB0aGUgaGVpZ2h0IG9mICNtYWluLmxlZnRcbiAgICAgICAgICAgIC5zdHlsZShcImhlaWdodFwiLCBoZWlnaHRfY3Jvc3MgKyBtYXJnaW5fY3Jvc3MudG9wICsgbWFyZ2luX2Nyb3NzLmJvdHRvbSlcbiAgICAgICAgICAgIC5zdHlsZShcIm1hcmdpbi1sZWZ0XCIsXCIyMHB4XCIpXG4gICAgICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCxcIiArIG1hcmdpbl9jcm9zcy50b3AgKyBcIilcIik7XG5cbiAgICAgICAgdmFyIHJlY3RXaWR0aCA9IHhfMShtaW5YICsgMC41IC0gMiAqIGJhclBhZGRpbmcpOyAvL3RoZSBcIndpZHRoXCIgaXMgdGhlIGNvb3JkaW5hdGUgb2YgdGhlIGVuZCBvZiB0aGUgZmlyc3QgYmFyXG4gICAgICAgIHBsb3RzdmcxLnNlbGVjdEFsbChcInJlY3RcIilcbiAgICAgICAgICAgIC5kYXRhKHlWYWxzKVxuICAgICAgICAgICAgLmVudGVyKClcbiAgICAgICAgICAgIC5hcHBlbmQoXCJyZWN0XCIpXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsXCJwYXRoMlwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHhfMSh4VmFsc1tpXSAtIDAuNSArIGJhclBhZGRpbmcpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5hdHRyKFwieVwiLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB5XzEobWF4WSAtIGQpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgcmVjdFdpZHRoKVxuICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geV8xKGQpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5hdHRyKFwiZmlsbFwiLCBcIiNmYTgwNzJcIik7XG5cbiAgICAgICAgaWYgKHBsb3RYYXhpcykge1xuICAgICAgICAgICAgcGxvdHN2ZzEuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJ4IGF4aXNcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLFwiICsgaGVpZ2h0X2Nyb3NzICsgXCIpXCIpXG4gICAgICAgICAgICAgICAgLmNhbGwoeEF4aXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGxvdHN2ZzEuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ4XCIsICh3aWR0aF9jcm9zcyAvIDIpKVxuICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIG1hcmdpbl9jcm9zcy50b3AgKyBwYWRkaW5nX2Nyb3NzLTEwKVxuICAgICAgICAgICAgLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKVxuICAgICAgICAgICAgLnRleHQoYmFyX2Vudi5uYW1lKVxuICAgICAgICAgICAgLnN0eWxlKFwidGV4dC1pbmRlbnRcIixcIjIwcHhcIilcbiAgICAgICAgICAgIC5zdHlsZShcImZvbnQtc2l6ZVwiLFwiMTJweFwiKVxuICAgICAgICAgICAgLnN0eWxlKFwiZm9udC13ZWlnaHRcIixcImJvbGRcIik7XG5cbiAgICAgICAgaWYoaXNOYU4oYSl8fCBhPT09MCkge1xuICAgICAgICAgICAgeF9jb3JkMiA9IGVxdWltYXNzX2JhcihiYXJfZW52LCBrZXlzLmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcGxvdHN2ZzEuYXBwZW5kKFwibGluZVwiKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcImlkXCIsIFwibGluZTJcIilcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ4MVwiLCB4XzEoeF9jb3JkMltpXSApKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcIngyXCIsIHhfMSh4X2NvcmQyW2ldICkpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieTFcIiwgeV8xKDApKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcInkyXCIsIHlfMShtYXhZKSlcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwic3Ryb2tlXCIsIFwiIzIxMjEyMVwiKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJzdHJva2UtZGFzaGFycmF5XCIsIFwiNFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChtZXRob2RfbmFtZSA9PT0gXCJlcXVpZGlzdGFuY2VcIikge1xuICAgICAgICAgICAgICAgIHZhciB1cHBlcl9saW1pdDEgPSBtYXhYO1xuICAgICAgICAgICAgICAgIHZhciBsb3dlcl9saW1pdDEgPSBtaW5YO1xuICAgICAgICAgICAgICAgIHZhciBkaWZmMSA9IHVwcGVyX2xpbWl0MSAtIGxvd2VyX2xpbWl0MTtcbiAgICAgICAgICAgICAgICB2YXIgYnVmZmVyMSA9IGRpZmYxIC8gYTtcbiAgICAgICAgICAgICAgICB2YXIgeF9jb3JkMSA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBwdXNoX2RhdGExID0gbG93ZXJfbGltaXQxO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYSAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBwdXNoX2RhdGExID0gcHVzaF9kYXRhMSArIGJ1ZmZlcjE7XG4gICAgICAgICAgICAgICAgICAgIHhfY29yZDEucHVzaChwdXNoX2RhdGExKTtcbiAgICAgICAgICAgICAgICAgICAgcGxvdHN2ZzEuYXBwZW5kKFwibGluZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBcImxpbmUyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcIngxXCIsIHhfMSh4X2NvcmQxW2ldKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieDJcIiwgeF8xKHhfY29yZDFbaV0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ5MVwiLCB5XzEoMCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInkyXCIsIHlfMShtYXhZKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcInN0cm9rZVwiLCBcIiMwRDQ3QTFcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcInN0cm9rZS1kYXNoYXJyYXlcIiwgXCI0XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWV0aG9kX25hbWU9PT1cImVxdWltYXNzXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgeF9jb3JkMiA9IFtdO1xuICAgICAgICAgICAgICAgIHhfY29yZDIgPSBlcXVpbWFzc19iYXIoYmFyX2VudiwgYSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHBsb3RzdmcxLmFwcGVuZChcImxpbmVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgXCJsaW5lMlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ4MVwiLCB4XzEoeF9jb3JkMltpXSApKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ4MlwiLCB4XzEoeF9jb3JkMltpXSApKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ5MVwiLCB5XzEoMCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInkyXCIsIHlfMShtYXhZKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcInN0cm9rZVwiLCBcIiMwRDQ3QTFcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcInN0cm9rZS1kYXNoYXJyYXlcIiwgXCI0XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVxdWlkaXN0YW5jZShBLGEpIHtcbiAgICAgICAgdmFyIG1ldGhvZF9uYW1lPSBcImVxdWlkaXN0YW5jZVwiO1xuICAgICAgICAvLyBqc29uIG9iamVjdCB0byBiZSBzZW50IHRvIHIgc2VydmVyXG4gICAgICAgIHZhciBvYmogPSBuZXcgT2JqZWN0KCk7XG4gICAgICAgIG9iai5wbG90TmFtZUEgPSBBO1xuICAgICAgICBvYmouZXF1aWRpc3RhbmNlID0gYTtcbiAgICAgICAgdmFyIHN0cmluZyA9IEpTT04uc3RyaW5naWZ5KG9iaik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGxvdF9ub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHBsb3Rfbm9kZXNbaV0ubmFtZSA9PT0gQSkge1xuICAgICAgICAgICAgICAgIGlmIChwbG90X25vZGVzW2ldLnBsb3R0eXBlID09PSBcImNvbnRpbnVvdXNcIikge1xuICAgICAgICAgICAgICAgICAgICAkKFwiI3Bsb3RzdmdfaWRcIikucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgIGRlbnNpdHlfY3Jvc3MocGxvdF9ub2Rlc1tpXSxhLG1ldGhvZF9uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocGxvdF9ub2Rlc1tpXS5wbG90dHlwZSA9PT0gXCJiYXJcIikge1xuICAgICAgICAgICAgICAgICAgICAkKFwiI3Bsb3RzdmcxX2lkXCIpLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICBiYXJfY3Jvc3MocGxvdF9ub2Rlc1tpXSxhLG1ldGhvZF9uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwibm90IGZvdW5kXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVxdWltYXNzKEEsYSkge1xuICAgICAgICAvL2VxdWltYXNzIGZ1bmN0aW9uIHRvIGNhbGwgdGhlIHBsb3QgZnVuY3Rpb25cbiAgICAgICAgdmFyIG1ldGhvZF9uYW1lPSBcImVxdWltYXNzXCI7XG4gICAgICAgIHZhciBvYmogPSBuZXcgT2JqZWN0KCk7XG4gICAgICAgIG9iai5wbG90TmFtZUEgPSBBO1xuICAgICAgICBvYmouZXF1aWRpc3RhbmNlID0gYTtcbiAgICAgICAgdmFyIHN0cmluZyA9IEpTT04uc3RyaW5naWZ5KG9iaik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGxvdF9ub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHBsb3Rfbm9kZXNbaV0ubmFtZSA9PT0gQSkge1xuICAgICAgICAgICAgICAgIGlmIChwbG90X25vZGVzW2ldLnBsb3R0eXBlID09PSBcImNvbnRpbnVvdXNcIikge1xuICAgICAgICAgICAgICAgICAgICAkKFwiI3Bsb3RzdmdfaWRcIikucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgIGRlbnNpdHlfY3Jvc3MocGxvdF9ub2Rlc1tpXSxhLG1ldGhvZF9uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocGxvdF9ub2Rlc1tpXS5wbG90dHlwZSA9PT0gXCJiYXJcIikge1xuICAgICAgICAgICAgICAgICAgICAkKFwiI3Bsb3RzdmcxX2lkXCIpLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICBiYXJfY3Jvc3MocGxvdF9ub2Rlc1tpXSxhLG1ldGhvZF9uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwibm90IGZvdW5kXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXF1aW1hc3NDYWxjdWxhdGlvbihwbG90X2V2LG4pIHtcbiAgICAgICAgLy8gaGVyZSB3ZSBmaW5kIHRoZSBjb29yZGluYXRlcyB1c2luZyBDREYgdmFsdWVzXG4gICAgICAgIC8vdmFyIG4gPXYtMTtcbiAgICAgICAgdmFyIGFycl95PVtdO1xuICAgICAgICB2YXIgYXJyX3g9W107XG5cbiAgICAgICAgYXJyX3k9cGxvdF9ldi5jZGZwbG90eTsvLyBjZGZwbG90eSBkYXRhIHN0b3JlZFxuICAgICAgICBhcnJfeD1wbG90X2V2LmNkZnBsb3R4Oy8vIGNkZnBsb3R4IGRhdGEgc3RvcmVkXG5cbiAgICAgICAgdmFyIFVwcGVyX2xpbWl0WT0gZDMubWF4KGFycl95KTtcbiAgICAgICAgdmFyIExvd2VyX2xpbWl0WT1kMy5taW4oYXJyX3kpO1xuICAgICAgICB2YXIgZGlmZnk9VXBwZXJfbGltaXRZLUxvd2VyX2xpbWl0WTtcbiAgICAgICAgdmFyIGU9KGRpZmZ5KS9uOyAvLyBlIGlzIHRoZSB2YXJpYWJsZSB0byBzdG9yZSB0aGUgYXZlcmFnZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBwb2ludHMgaW4gdGhlIGNkZnkgaW4gb3JkZXIgdG8gZGl2aWRlIHRoZSBjZGZ5XG5cbiAgICAgICAgdmFyIGFycl9jPVtdOyAvL2FycmF5IHRvIHN0b3JlIHRoZSBjZGZ5IGRpdmlkZWQgY29vcmRpbmF0ZXMgZGF0YVxuICAgICAgICB2YXIgcHVzaF9kYXRhPWFycl95WzBdO1xuICAgICAgICBmb3IodmFyIGk9MDtpPG47aSsrKSB7XG4gICAgICAgICAgICBwdXNoX2RhdGE9cHVzaF9kYXRhK2U7XG4gICAgICAgICAgICBhcnJfYy5wdXNoKHB1c2hfZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGVtcF9jZGZ4PVtdO1xuICAgICAgICB2YXIgdGVtcD1bXTtcbiAgICAgICAgdmFyIHN0b3JlPVtdO1xuXG4gICAgICAgIGZvciAodmFyIGk9MDsgaTxuOyBpKyspLy90byBnZXQgdGhyb3VnaCBlYWNoIGFycl9jXG4gICAgICAgIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgNTA7IGorKykvLyB0byBjb21wYXJlIHdpdGggY2RmeSBvciBhcnJfeVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChhcnJfY1tpXSA9PT0gYXJyX3lbal0pIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmUucHVzaCh7dmFsOiBpLCBjb29yMTogaiwgY29vcjI6IGosIGRpZmYxOiAwLjM0LCBkaWZmMjogMH0pOy8vIGZvciB0ZXN0aW5nIHB1cnBvc2VcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yKHZhciBpPTA7IGk8bjtpKyspIHtcbiAgICAgICAgICAgIHZhciBkaWZmX3ZhbDEsIGRpZmZfdmFsMjsvLyBoZXJlIHRoZSBkaWZmIGlzIG5vdCBhY3R1YWwgZGlmZmVyZW5jZSwgaXQgaXMgdGhlIGZyYWN0aW9uIG9mIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSB0d28gcG9pbnRzXG4gICAgICAgICAgICB2YXIgeDEsIHgyLCB4Myx4NDtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgNTA7IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChhcnJfeVtqXSA8IGFycl9jW2ldICYmIGFycl9jW2ldIDwgYXJyX3lbaiArIDFdKSB7XG4gICAgICAgICAgICAgICAgICAgIHgxID0gYXJyX2NbaV07XG4gICAgICAgICAgICAgICAgICAgIHgyID0gYXJyX2NbaV0tYXJyX3lbal07XG4gICAgICAgICAgICAgICAgICAgIHgzID0gYXJyX3lbaisxXS1hcnJfY1tpXTtcbiAgICAgICAgICAgICAgICAgICAgeDQ9YXJyX3lbaisxXS1hcnJfeVtqXTtcbiAgICAgICAgICAgICAgICAgICAgZGlmZl92YWwxID0geDIvIHg0O1xuICAgICAgICAgICAgICAgICAgICBkaWZmX3ZhbDIgPSB4MyAvIHg0O1xuICAgICAgICAgICAgICAgICAgICBzdG9yZS5wdXNoKHt2YWw6IGksIGNvb3IxOiBqLCBjb29yMjogaiArIDEsIGRpZmYxOiBkaWZmX3ZhbDEsIGRpZmYyOiBkaWZmX3ZhbDJ9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IodmFyIGk9MDsgaTxuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB5MSx5Mix5MyxkaWZmeTEsZGlmZnkyO1xuICAgICAgICAgICAgeTE9c3RvcmVbaV0udmFsO1xuICAgICAgICAgICAgeTI9IHN0b3JlW2ldLmNvb3IxO1xuICAgICAgICAgICAgeTM9IHN0b3JlW2ldLmNvb3IyO1xuICAgICAgICAgICAgZGlmZnkxPXN0b3JlW2ldLmRpZmYxO1xuICAgICAgICAgICAgZGlmZnkyPXN0b3JlW2ldLmRpZmYyO1xuICAgICAgICAgICAgdmFyIHhfY29vcjE9IGFycl94W3kyXTtcbiAgICAgICAgICAgIHZhciB4X2Nvb3IyPWFycl94W3kzXTtcbiAgICAgICAgICAgIHZhciB4X2RpZmY9eF9jb29yMi14X2Nvb3IxO1xuICAgICAgICAgICAgdmFyIGRpc3RhbmNlMT0geF9kaWZmKmRpZmZ5MTtcbiAgICAgICAgICAgIHZhciB2YWxfeD14X2Nvb3IxK2Rpc3RhbmNlMTtcbiAgICAgICAgICAgIHRlbXAucHVzaCh2YWxfeCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRlbXA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXF1aW1hc3NfYmFyKHBsb3RfZXYsbikge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHBsb3RfZXYucGxvdHZhbHVlcyk7XG4gICAgICAgIHZhciBrID0ga2V5cy5sZW5ndGg7XG4gICAgICAgIHZhciB0ZW1wID0gW107XG4gICAgICAgIHZhciBjb3VudCA9IDA7XG5cbiAgICAgICAgaWYgKGsgPCBuKSB7XG4gICAgICAgICAgICBhbGVydChcImVycm9yIGVudGVyIHZhaWxkIHNpemVcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aGlsZSAoayA+IDApIHtcbiAgICAgICAgICAgICAgICB0ZW1wLnB1c2goe3BvczogY291bnQsIHZhbDoga30pO1xuICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICAgICAgay0tO1xuICAgICAgICAgICAgICAgIGlmIChjb3VudCA+PSBuKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0ZW1wMiA9IG5ldyBBcnJheShuKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGVtcDIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0ZW1wMltpXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBrZXlzW2ldID0gKGtleXNbaV0gKyA1KSAvIDEwOy8vIHRvIGdldCB0aGUgaW5jcmVhc2UgaW4gdGhlIGFjdHVhbCB2YWx1ZXMgYnkgMC41IGFjY29yZGluZyB0byB0aGUgeGF4aXMgaW4gcGxvdFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRlbXAubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRlbXBbal0ucG9zID09PSBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wMltpXSA9IHRlbXAyW2ldICsgMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGogPSAwLCBrID0gMDtcbiAgICAgICAgICAgIHZhciB0ZW1wX2ZpbmFsID0gbmV3IEFycmF5KG4pO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGVtcDJbal0gPSB0ZW1wMltqXSAtIDE7XG4gICAgICAgICAgICAgICAgaWYgKHRlbXAyW2pdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgICAgICAgICAgdGVtcF9maW5hbFtrXSA9IGtleXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGsrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGVtcF9maW5hbDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxpbmVjaGFydCh4X0F4aXNfbmFtZSwgeV9BeGlzX25hbWUpIHtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbGluZWNoYXJ0Jykuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICBkMy5zZWxlY3QoXCIjbGluZUNoYXJ0XCIpLnNlbGVjdChcInN2Z1wiKS5yZW1vdmUoKTtcbiAgICAkKCcjbGluZWNoYXJ0JykuaHRtbChcIlwiKTtcbiAgICBsZXQgcGFkZGluZyA9IDEwO1xuICAgIHZhciB3X2xpbmVjaGFydCA9IDQ4MDtcbiAgICB2YXIgaF9saW5lY2hhcnQgPSAzMDA7XG4gICAgdmFyIG1hcmdpbl9saW5lY2hhcnQgPSB7dG9wOiAyMCwgcmlnaHQ6IDgwLCBib3R0b206IDMwLCBsZWZ0OiA1MH07XG4gICAgdmFyIHdpZHRoX2xpbmVjaGFydCA9IHdfbGluZWNoYXJ0IC0gbWFyZ2luX2xpbmVjaGFydC5sZWZ0IC0gbWFyZ2luX2xpbmVjaGFydC5yaWdodDtcbiAgICB2YXIgaGVpZ2h0X2xpbmVjaGFydCA9IGhfbGluZWNoYXJ0IC0gbWFyZ2luX2xpbmVjaGFydC50b3AgLSBtYXJnaW5fbGluZWNoYXJ0LmJvdHRvbTtcblxuICAgIHZhciBzdmcgPSBkMy5zZWxlY3QoXCIjbGluZWNoYXJ0XCIpLmFwcGVuZChcInN2Z1wiKVxuICAgICAgICAuYXR0cihcImlkXCIsIFwiY2hhcnRcIilcbiAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCB3X2xpbmVjaGFydClcbiAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgaF9saW5lY2hhcnQpO1xuICAgIHZhciBjaGFydCA9IHN2Zy5hcHBlbmQoXCJnXCIpXG4gICAgICAgIC5jbGFzc2VkKFwiZGlzcGxheVwiLCB0cnVlKVxuICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIG1hcmdpbl9saW5lY2hhcnQubGVmdCArIFwiLFwiICsgbWFyZ2luX2xpbmVjaGFydC50b3AgKyBcIilcIik7XG4gICAgdmFyIHggPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAuZG9tYWluKGQzLmV4dGVudChkYXRhX3Bsb3QsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gZC54YXhpcztcbiAgICAgICAgfSkpXG4gICAgICAgIC5yYW5nZShbMCwgd2lkdGhfbGluZWNoYXJ0XSk7XG4gICAgdmFyIHkgPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAuZG9tYWluKFtkMy5taW4oZGF0YV9wbG90LCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuIGQueWF4aXM7XG4gICAgICAgIH0pLCBkMy5tYXgoZGF0YV9wbG90LCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuIGQueWF4aXM7XG4gICAgICAgIH0pXSlcbiAgICAgICAgLnJhbmdlKFtoZWlnaHRfbGluZWNoYXJ0LCAwXSk7XG4gICAgdmFyIHhBeGlzID0gZDMuc3ZnLmF4aXMoKVxuICAgICAgICAuc2NhbGUoeClcbiAgICAgICAgLm9yaWVudChcImJvdHRvbVwiKVxuICAgICAgICAudGlja3MoNSk7XG4gICAgdmFyIHlBeGlzID0gZDMuc3ZnLmF4aXMoKVxuICAgICAgICAuc2NhbGUoeSlcbiAgICAgICAgLm9yaWVudChcImxlZnRcIilcbiAgICAgICAgLnRpY2tzKDUpO1xuICAgIHZhciBsaW5lID0gZDMuc3ZnLmxpbmUoKVxuICAgICAgICAueChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuIHgoZC54YXhpcyk7XG4gICAgICAgIH0pXG4gICAgICAgIC55KGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4geShkLnlheGlzKTtcbiAgICAgICAgfSk7XG5cbiAgICBmdW5jdGlvbiBwbG90KHBhcmFtcykge1xuICAgICAgICB0aGlzLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5jbGFzc2VkKFwieCBheGlzXCIsIHRydWUpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLFwiICsgaGVpZ2h0X2xpbmVjaGFydCArIFwiKVwiKVxuICAgICAgICAgICAgLmNhbGwocGFyYW1zLmF4aXMueCk7XG4gICAgICAgIHRoaXMuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmNsYXNzZWQoXCJ5IGF4aXNcIiwgdHJ1ZSlcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsMClcIilcbiAgICAgICAgICAgIC5jYWxsKHBhcmFtcy5heGlzLnkpO1xuICAgICAgICAvL2VudGVyKClcbiAgICAgICAgdGhpcy5zZWxlY3RBbGwoXCIudHJlbmRsaW5lXCIpXG4gICAgICAgICAgICAuZGF0YShbcGFyYW1zLmRhdGFdKVxuICAgICAgICAgICAgLmVudGVyKClcbiAgICAgICAgICAgIC5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgICAgICAuY2xhc3NlZChcInRyZW5kbGluZVwiLCB0cnVlKTtcbiAgICAgICAgdGhpcy5zZWxlY3RBbGwoXCIucG9pbnRcIilcbiAgICAgICAgICAgIC5kYXRhKHBhcmFtcy5kYXRhKVxuICAgICAgICAgICAgLmVudGVyKClcbiAgICAgICAgICAgIC5hcHBlbmQoXCJjaXJjbGVcIilcbiAgICAgICAgICAgIC5jbGFzc2VkKFwicG9pbnRcIiwgdHJ1ZSlcbiAgICAgICAgICAgIC5hdHRyKFwiclwiLCAyKTtcbiAgICAgICAgLy91cGRhdGVcbiAgICAgICAgdGhpcy5zZWxlY3RBbGwoXCIudHJlbmRsaW5lXCIpXG4gICAgICAgICAgICAuYXR0cihcImRcIiwgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGluZShkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNlbGVjdEFsbChcIi5wb2ludFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJjeFwiLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRlID0gZC54YXhpcztcbiAgICAgICAgICAgICAgICByZXR1cm4geChkYXRlKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuYXR0cihcImN5XCIsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHkoZC55YXhpcyk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnN0eWxlKFwiY29sb3JcIiwgXCIjRUY1MzUwXCIpO1xuICAgICAgICAvL2V4aXQoKVxuICAgICAgICB0aGlzLnNlbGVjdEFsbChcIi50cmVuZGxpbmVcIilcbiAgICAgICAgICAgIC5kYXRhKFtwYXJhbXMuZGF0YV0pXG4gICAgICAgICAgICAuZXhpdCgpXG4gICAgICAgICAgICAucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMuc2VsZWN0QWxsKFwiLnBvaW50XCIpXG4gICAgICAgICAgICAuZGF0YShwYXJhbXMuZGF0YSlcbiAgICAgICAgICAgIC5leGl0KClcbiAgICAgICAgICAgIC5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICBsZXQgdGVtcCA9IGQzLnNlbGVjdChcIiNtYWluLmxlZnRcIikuc3R5bGUoXCJ3aWR0aFwiKTtcbiAgICBsZXQgd2lkdGggPSB0ZW1wLnN1YnN0cmluZygwLCAodGVtcC5sZW5ndGggLSAyKSk7XG4gICAgbGV0IGhlaWdodCA9ICQod2luZG93KS5oZWlnaHQoKSAtIDEyMDtcbiAgICBzdmcuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAuYXR0cihcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpICAvLyB0aGlzIG1ha2VzIGl0IGVhc3kgdG8gY2VudHJlIHRoZSB0ZXh0IGFzIHRoZSB0cmFuc2Zvcm0gaXMgYXBwbGllZCB0byB0aGUgYW5jaG9yXG4gICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgcGFkZGluZyAgKyBcIixcIiArIChoZWlnaHQgLyAzKSArIFwiKXJvdGF0ZSgtOTApXCIpICAvLyB0ZXh0IGlzIGRyYXduIG9mZiB0aGUgc2NyZWVuIHRvcCBsZWZ0LCBtb3ZlIGRvd24gYW5kIG91dCBhbmQgcm90YXRlXG4gICAgICAgIC50ZXh0KHlfQXhpc19uYW1lKVxuICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIFwiIzQyNDI0MlwiKVxuICAgICAgICAuc3R5bGUoXCJ0ZXh0LWluZGVudFwiLFwiMjBweFwiKVxuICAgICAgICAuc3R5bGUoXCJmb250LXNpemVcIixcIjEycHhcIilcbiAgICAgICAgLnN0eWxlKFwiZm9udC13ZWlnaHRcIixcImJvbGRcIik7XG4gICAgc3ZnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKSAgLy8gdGhpcyBtYWtlcyBpdCBlYXN5IHRvIGNlbnRyZSB0aGUgdGV4dCBhcyB0aGUgdHJhbnNmb3JtIGlzIGFwcGxpZWQgdG8gdGhlIGFuY2hvclxuICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArICh3aWR0aCAvIDUpICsgXCIsXCIgKyAoaGVpZ2h0IC0gcGFkZGluZyAtIDEyOCApICsgXCIpXCIpICAvLyBjZW50cmUgYmVsb3cgYXhpc1xuICAgICAgICAudGV4dCh4X0F4aXNfbmFtZSlcbiAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBcIiM0MjQyNDJcIilcbiAgICAgICAgLnN0eWxlKFwidGV4dC1pbmRlbnRcIixcIjIwcHhcIilcbiAgICAgICAgLnN0eWxlKFwiZm9udC1zaXplXCIsXCIxMnB4XCIpXG4gICAgICAgIC5zdHlsZShcImZvbnQtd2VpZ2h0XCIsXCJib2xkXCIpO1xuXG4gICAgcGxvdC5jYWxsKGNoYXJ0LCB7XG4gICAgICAgIGRhdGE6IGRhdGFfcGxvdCxcbiAgICAgICAgYXhpczoge1xuICAgICAgICAgICAgeDogeEF4aXMsXG4gICAgICAgICAgICB5OiB5QXhpc1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHZpeihtLCBqc29uX3ZpemV4cGxvcmUsIG1vZGVsX25hbWVfc2V0KSB7XG4gICAgZDMuc2VsZWN0KFwiI3Bsb3RBXCIpLmh0bWwoXCJcIik7XG4gICAgZDMuc2VsZWN0KFwiI3Bsb3RCXCIpLmh0bWwoXCJcIik7XG4gICAgZDMuc2VsZWN0KFwiI3RhYnVsYXJfMVwiKS5zdHlsZShcImRpc3BsYXlcIiwgXCJibG9ja1wiKTtcbiAgICBkMy5zZWxlY3QoXCIjdGFidWxhcl8yXCIpLnN0eWxlKFwiZGlzcGxheVwiLCBcImJsb2NrXCIpO1xuXG4gICAgbGV0IGdldF9kYXRhID0gbW9kZWxfbmFtZV9zZXQuc3BsaXQoXCItXCIpO1xuICAgIHZhciBtb2RlbF9uYW1lMSA9IGdldF9kYXRhWzBdICsgXCItXCIgKyBnZXRfZGF0YVsxXTtcbiAgICB2YXIgbW9kZWxfbmFtZTIgPSBnZXRfZGF0YVsxXSArIFwiLVwiICsgZ2V0X2RhdGFbMF07XG4gICAgdmFyIG15bSA9ICttLnN1YnN0cig1LCA1KSAtIDE7XG5cbiAgICBmdW5jdGlvbiByZW1vdmVLaWRzKHBhcmVudCkge1xuICAgICAgICB3aGlsZSAocGFyZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChwYXJlbnQuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIganNvbiA9IGpzb25fdml6ZXhwbG9yZTtcbiAgICAvLyBwaXBlIGluIGZpZ3VyZXMgdG8gcmlnaHQgcGFuZWxcbiAgICB2YXIgZmlsZWxpc3QgPSBuZXcgQXJyYXk7XG5cbiAgICAvLyBpbWFnZSBhZGRlZCB0byB0aGUgZGl2XG4gICAgdmFyIHhfYXhpcyA9IFtdO1xuICAgIHZhciB5X2F4aXMgPSBbXTtcbiAgICBmb3IgKHZhciBpIGluIGpzb24ucGxvdGRhdGEpIHtcbiAgICAgICAgZm9yICh2YXIgaiBpbiBqc29uLnBsb3RkYXRhW2ldLnZhcm5hbWUpIHtcbiAgICAgICAgICAgIGlmIChqc29uLnBsb3RkYXRhW2ldLnZhcm5hbWVbal0gPT09IGdldF9kYXRhWzBdKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayBpbiBqc29uLnBsb3RkYXRhW2ldLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgeF9heGlzW2tdID0ganNvbi5wbG90ZGF0YVtpXS5kYXRhW2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChqc29uLnBsb3RkYXRhW2ldLnZhcm5hbWVbal0gPT09IGdldF9kYXRhWzFdKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayBpbiBqc29uLnBsb3RkYXRhW2ldLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgeV9heGlzW2tdID0ganNvbi5wbG90ZGF0YVtpXS5kYXRhW2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGJpdmFyaWF0ZVBsb3QoeF9heGlzLCB5X2F4aXMsIGdldF9kYXRhWzBdLCBnZXRfZGF0YVsxXSk7XG5cbiAgICAkKCcjc2NhdHRlcnBsb3RfaW1nJykub24oJ2NsaWNrJywgZnVuY3Rpb24oKXtcbiAgICAgICAgJChcIiNzY2F0dGVycGxvdF9pbWdcIikuZmFkZU91dChcImZhc3RcIikuZmFkZUluKCkuZmFkZVRvKFwiZmFzdFwiLDEuMCk7XG4gICAgfSk7XG4gICAgJCgnI2hlYXRtYXBfaW1nJykub24oJ2NsaWNrJywgZnVuY3Rpb24oKXtcbiAgICAgICAgJChcIiNoZWF0bWFwX2ltZ1wiKS5mYWRlT3V0KFwiZmFzdFwiKS5mYWRlSW4oKS5mYWRlVG8oXCJmYXN0XCIsMS4wKTtcbiAgICB9KTtcbiAgICAkKCcjbGluZWNoYXJ0X2ltZycpLm9uKCdjbGljaycsIGZ1bmN0aW9uKCl7XG4gICAgICAgICQoXCIjbGluZWNoYXJ0X2ltZ1wiKS5mYWRlT3V0KFwiZmFzdFwiKS5mYWRlSW4oKS5mYWRlVG8oXCJmYXN0XCIsMS4wKTtcbiAgICB9KTtcbiAgICAkKCcjc2NhdHRlcnBsb3RfaW1nJykuY2xpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdoZWF0Y2hhcnQnKS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsaW5lY2hhcnQnKS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgIGJpdmFyaWF0ZVBsb3QoeF9heGlzLCB5X2F4aXMsIGdldF9kYXRhWzBdLCBnZXRfZGF0YVsxXSk7XG4gICAgfSk7XG4gICAgJCgnI2hlYXRtYXBfaW1nJykuY2xpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzY2F0dGVycGxvdCcpLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xpbmVjaGFydCcpLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgaGVhdG1hcChnZXRfZGF0YVswXSwgZ2V0X2RhdGFbMV0pO1xuICAgIH0pO1xuICAgICQoJyNsaW5lY2hhcnRfaW1nJykuY2xpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdoZWF0Y2hhcnQnKS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzY2F0dGVycGxvdCcpLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgbGluZWNoYXJ0KGdldF9kYXRhWzBdLGdldF9kYXRhWzFdKTtcbiAgICB9KTtcblxuICAgIHZhciBlbXB0eT1bXTtcbiAgICBjcm9zc1RhYlBsb3RzKGdldF9kYXRhWzBdLCBnZXRfZGF0YVsxXSxlbXB0eSk7XG5cbiAgICB2YXIgY29yayA9IFtdO1xuICAgIHZhciBjb3JwID0gW107XG4gICAgdmFyIGNvcnMgPSBbXTtcbiAgICB2YXIgdmFyMSA9IFtdO1xuICAgIHZhciB2YXIyID0gW107XG4gICAgdmFyIHRhYmxlX29iaiA9IFtdO1xuICAgIHZhciBjb2xuYW1lcyA9IFtdO1xuICAgIHZhciBjb2x2YXIgPSBbXTtcbiAgICB2YXIgdGFibGVfZGF0YSA9IFtdO1xuICAgIHZhciByb3d2YXIgPSBbXTtcbiAgICB2YXIgcm93bmFtZXMgPSBbXTtcbiAgICBmdW5jdGlvbiBjcm9zc1RhYl9UYWJsZShqc29uKSB7XG4gICAgICAgIHRhYmxlX2RhdGEgPSBbXTtcbiAgICAgICAgdGFibGVfb2JqID0gW107XG4gICAgICAgIGxldCBwdXNoID0gKGksIGtleSkgPT4ganNvbi50YWJ1bGFyW2ldW2tleV0ubWFwKHYgPT4gdik7XG4gICAgICAgIC8vIGRhdGEgZm9yIHN0YXRpc3RpY3NcbiAgICAgICAgZm9yICh2YXIgaSBpbiBqc29uLnRhYnVsYXIpIHtcbiAgICAgICAgICAgIGlmIChpID09IG1vZGVsX25hbWUxIHx8IGkgPT0gbW9kZWxfbmFtZTIpIHtcbiAgICAgICAgICAgICAgICBjb2xuYW1lcyA9IHB1c2goaSwgJ2NvbG5hbWVzJyk7XG4gICAgICAgICAgICAgICAgcm93bmFtZXMgPSBwdXNoKGksICdyb3duYW1lcycpO1xuICAgICAgICAgICAgICAgIHJvd3ZhciA9IHB1c2goaSwgJ3Jvd3ZhcicpO1xuICAgICAgICAgICAgICAgIGNvbHZhciA9IHB1c2goaSwnY29sdmFyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSBpbiBqc29uLnRhYnVsYXIpIHtcbiAgICAgICAgICAgIGlmIChpID09IG1vZGVsX25hbWUxIHx8IGkgPT0gbW9kZWxfbmFtZTIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBuIGluIGpzb24udGFidWxhcltpXS5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhYmxlX2RhdGFbbl0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYSA9IDA7IGEgPCBjb2xuYW1lcy5sZW5ndGg7IGErKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFibGVfZGF0YVtuXS5wdXNoKGpzb24udGFidWxhcltpXS5kYXRhW25dW2FdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBwID0gMDsgcCA8IHJvd25hbWVzLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IGNvbG5hbWVzLmxlbmd0aDsgbCsrKSB7XG4gICAgICAgICAgICAgICAgdGFibGVfb2JqLnB1c2goe3Jvd25hbWU6IHJvd25hbWVzW3BdLCBjb2xuYW1lOiBjb2xuYW1lc1tsXSwgdmFsdWU6IHRhYmxlX2RhdGFbcF1bbF19KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkM3RhYmxlMSh0YWJsZV9vYmopO1xuICAgIH1cblxuICAgIC8vIGZvciB0aGUgc3RhdGlzdGljc1xuICAgIGZvciAodmFyIGtleSBpbiBqc29uLnN0YXRpc3RpY2FsKSB7XG4gICAgICAgIGlmIChrZXkgPT0gbW9kZWxfbmFtZTEgfHwga2V5ID09IG1vZGVsX25hbWUyKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBhIGluIGpzb24uc3RhdGlzdGljYWxba2V5XS5jb3JrKSB7XG4gICAgICAgICAgICAgICAgY29yay5wdXNoKGpzb24uc3RhdGlzdGljYWxba2V5XS5jb3JrW2FdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBrZXkxIGluIGpzb24uc3RhdGlzdGljYWwpIHtcbiAgICAgICAgaWYgKGtleTEgPT0gbW9kZWxfbmFtZTEgfHwga2V5MSA9PSBtb2RlbF9uYW1lMikge1xuICAgICAgICAgICAgZm9yICh2YXIgYiBpbiBqc29uLnN0YXRpc3RpY2FsW2tleTFdLmNvcnApIHtcbiAgICAgICAgICAgICAgICBjb3JwLnB1c2goanNvbi5zdGF0aXN0aWNhbFtrZXkxXS5jb3JwW2JdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBrZXkgaW4ganNvbi5zdGF0aXN0aWNhbCkge1xuICAgICAgICBpZiAoa2V5ID09IG1vZGVsX25hbWUxIHx8IGtleSA9PSBtb2RlbF9uYW1lMikge1xuICAgICAgICAgICAgZm9yICh2YXIgYyBpbiBqc29uLnN0YXRpc3RpY2FsW2tleV0uY29ycykge1xuICAgICAgICAgICAgICAgIGNvcnMucHVzaChqc29uLnN0YXRpc3RpY2FsW2tleV0uY29yc1tjXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIga2V5IGluIGpzb24uc3RhdGlzdGljYWwpIHtcbiAgICAgICAgaWYgKGtleSA9PSBtb2RlbF9uYW1lMSB8fCBrZXkgPT0gbW9kZWxfbmFtZTIpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGQgaW4ganNvbi5zdGF0aXN0aWNhbFtrZXldLnZhcjEpIHtcbiAgICAgICAgICAgICAgICB2YXIxLnB1c2goanNvbi5zdGF0aXN0aWNhbFtrZXldLnZhcjFbZF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGtleTQgaW4ganNvbi5zdGF0aXN0aWNhbCkge1xuICAgICAgICBpZiAoa2V5ID09IG1vZGVsX25hbWUxIHx8IGtleSA9PSBtb2RlbF9uYW1lMikge1xuICAgICAgICAgICAgZm9yICh2YXIgZSBpbiBqc29uLnN0YXRpc3RpY2FsW2tleV0udmFyMikge1xuICAgICAgICAgICAgICAgIHZhcjIucHVzaChqc29uLnN0YXRpc3RpY2FsW2tleV0udmFyMltlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcHAuenBhcmFtcy56dmFycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcmVzdWx0c0FycmF5ID0gW107XG4gICAgfVxuICAgIGZvciAodmFyIGtleSBpbiBqc29uLnRhYnVsYXIpIHtcbiAgICAgICAgaWYgKGtleSA9PSBcImNvbG5hbWVzXCIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY29sbmFtZXMgZm91bmRcIik7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb2JqID0ganNvbi50YWJ1bGFyW2tleV07XG4gICAgICAgIHJlc3VsdHNBcnJheS5wdXNoKG9iaik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZDN0YWJsZTEoZGF0YSkge1xuICAgICAgICB2YXIgd2lkdGggPSAxMjAsIC8vIHdpZHRoIG9mIHN2Z1xuICAgICAgICAgICAgaGVpZ2h0ID0gMTYwLC8vIGhlaWdodCBvZiBzdmdcbiAgICAgICAgICAgIHBhZGRpbmcgPSAyMjsgLy8gc3BhY2UgYXJvdW5kIHRoZSBjaGFydCwgbm90IGluY2x1ZGluZyBsYWJlbHNcblxuICAgICAgICBkMy5zZWxlY3QoXCIjdGFidWxhcl8yXCIpXG4gICAgICAgICAgICAuaHRtbChcIlwiKVxuICAgICAgICAgICAgLnN0eWxlKFwiYmFja2dyb3VuZC1jb2xvclwiLCBcIiNmZmZcIilcbiAgICAgICAgICAgIC5hcHBlbmQoXCJoNVwiKVxuICAgICAgICAgICAgLnRleHQoXCJDUk9TUy1UQUJTIFwiKVxuICAgICAgICAgICAgLnN0eWxlKFwiY29sb3JcIiwgXCIjNDI0MjQyXCIpO1xuXG4gICAgICAgIHZhciBzdiA9IGQzLnNlbGVjdChcIiN0YWJ1bGFyXzJcIikuYXBwZW5kKFwic3ZnXCIpLmF0dHIoXCJ3aWR0aFwiLCBcIjEwMCVcIikuYXR0cihcImhlaWdodFwiLCBcIjEwMCVcIikuc3R5bGUoXCJvdmVyZmxvd1wiLCBcInZpc2libGVcIik7XG4gICAgICAgIHZhciBmbyA9IHN2LmFwcGVuZCgnZm9yZWlnbk9iamVjdCcpLmF0dHIoXCJ3aWR0aFwiLCBcIjEwMCVcIikuYXR0cihcImhlaWdodFwiLCBcIjEwMCVcIikuc3R5bGUoXCJwYWRkaW5nXCIsIDEwKS5hdHRyKFwib3ZlcmZsb3dcIiwgXCJ2aXNpYmxlXCIpO1xuICAgICAgICB2YXIgdGFibGUgPSBmby5hcHBlbmQoXCJ4aHRtbDp0YWJsZVwiKS5hdHRyKFwiY2xhc3NcIiwgXCJ0YWJsZVwiKS5zdHlsZShcImJvcmRlci1jb2xsYXBzZVwiLCBcIiBjb2xsYXBzZVwiKSxcbiAgICAgICAgICAgIHRoID0gdGFibGUuYXBwZW5kKFwidHJcIikuc3R5bGUoXCJib3JkZXJcIiwgMSkudGV4dChcIl9cIikuc3R5bGUoXCJjb2xvclwiLCBcIiNmZmZcIik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoLmFwcGVuZChcInRkXCIpLnN0eWxlKFwiYm9yZGVyLWJvdHRvbVwiLCAxKS5zdHlsZShcInRleHQtYWxpZ25cIiwgXCJjZW50ZXJcIikuc3R5bGUoXCJiYWNrZ3JvdW5kLWNvbG9yXCIsIHBsb3RzLnNlbFZhckNvbG9yKS5hcHBlbmQoXCJiXCIpLnRleHQoY29sbmFtZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgcm93bmFtZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIHZhciBwb3MgPSAwO1xuICAgICAgICAgICAgdmFyIHRyID0gdGFibGUuYXBwZW5kKFwidHJcIikuc3R5bGUoXCJtYXJnaW4tbGVmdFwiLCAyMCkuc3R5bGUoXCJiYWNrZ3JvdW5kLWNvbG9yXCIsIFwiI0JEQkRCRFwiKS5zdHlsZShcImJvcmRlclwiLCAxKS5zdHlsZShcInRleHQtYWxpZ25cIiwgXCJjZW50ZXJcIikudGV4dChyb3duYW1lc1trXSk7XG4gICAgICAgICAgICBmb3IgKHZhciBtID0gMDsgbSA8IGNvbG5hbWVzLmxlbmd0aDsgbSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgeiA9IDA7IHogPCBkYXRhLmxlbmd0aDsgeisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyb3duYW1lc1trXSA9PT0gZGF0YVt6XS5yb3duYW1lICYmIGNvbG5hbWVzW21dID09PSBkYXRhW3pdLmNvbG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyLmFwcGVuZChcInRkXCIpLnN0eWxlKFwiYm9yZGVyXCIsIDEpLnN0eWxlKFwidGV4dC1hbGlnblwiLCBcImNlbnRlclwiKS5zdHlsZShcInBvc2l0aW9uXCIsIFwicmVsYXRpdmVcIikuc3R5bGUoXCJiYWNrZ3JvdW5kLWNvbG9yXCIsIGFwcC52YXJDb2xvcikudGV4dChkYXRhW3pdLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNyb3NzVGFiX1RhYmxlKGpzb24pO1xuXG4gICAgdmFyIHBsb3RBdmFsPXZhcnNpemUxLHBsb3RCdmFsPXZhcnNpemUyO1xuICAgIGlmIChpc05hTihwbG90QXZhbCkpIHBsb3RBdmFsID0gMTA7XG4gICAgaWYgKGlzTmFOKHBsb3RCdmFsKSkgcGxvdEJ2YWwgPSAxMDtcbiAgICBsZXQgY3Jvc3N0YWJzID0gIHtcbiAgICAgICAgdmFyMToge1xuICAgICAgICAgICAgbmFtZTogcGxvdG5hbWVhLFxuICAgICAgICAgICAgdmFsdWU6IHBsb3RBdmFsLFxuICAgICAgICAgICAgYnV0dG9uVHlwZTogdmFybjFcbiAgICAgICAgfSxcbiAgICAgICAgdmFyMjoge1xuICAgICAgICAgICAgbmFtZTogcGxvdG5hbWViLFxuICAgICAgICAgICAgdmFsdWU6IHBsb3RCdmFsLFxuICAgICAgICAgICAgYnV0dG9uVHlwZTogdmFybjJcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiByZW1vdmVEYXRhKGtleSkge1xuICAgICAgICBmb3IgKHZhciBrZXkxIGluIGFwcC56cGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYXBwLnpwYXJhbXMuaGFzT3duUHJvcGVydHkoa2V5MSkgJiYga2V5ID09PSBrZXkxICYmIGFwcC56cGFyYW1zW2tleTEubGVuZ3RoXSA+IDApIGFwcC56cGFyYW1zW2tleTFdID0gW107XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgemJyZWFrcyA9IFtdO1xuICAgIGxldCB6YnJlYWtzX3RhYnVsYXIgPSBbXTtcbiAgICAkKCcjU2VsZWN0aW9uRGF0YTEnKS5jbGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgZDMuc2VsZWN0KFwiI3RhYnVsYXJfMlwiKS5odG1sKFwiXCIpO1xuICAgICAgICByZW1vdmVEYXRhKCd6Y3Jvc3N0YWInKTtcbiAgICAgICAgYXBwLnpwYXJhbXMuemNyb3NzdGFiLnB1c2goY3Jvc3N0YWJzKTtcbiAgICAgICAgZXhwbG9yZV9jcm9zc3RhYihqc29uKTtcbiAgICAgICAgYXBwLmVzdGltYXRlTGFkZGEuc3RvcCgpO1xuICAgICAgICBhcHAuZXhwbG9yZWQgPSB0cnVlO1xuICAgICAgICB6YnJlYWtzLnB1c2goY3Jvc3N0YWJzKTtcbiAgICAgICAgemJyZWFrc190YWJ1bGFyLnB1c2goanNvbi50YWJ1bGFyKTtcbiAgICAgICAgZDMuc2VsZWN0KCcjYnJlYWtzcGFjZScpXG4gICAgICAgICAgICAuYXBwZW5kKFwic3BhblwiKVxuICAgICAgICAgICAgLnRleHQoXCJcXHUwMEEwIFxcdTAwQTAgXFx1MDBBMCBcXHUwMEEwICAgXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJtYXJnaW4tdG9wXCIsIDApXG4gICAgICAgICAgICAuc3R5bGUoXCJ3aGl0ZS1zcGFjZVwiLCBcInByZVwiKVxuICAgICAgICAgICAgLnN0eWxlKFwiZGlzcGxheVwiLCBcImlubGluZS1ibG9ja1wiKVxuICAgICAgICAgICAgLnN0eWxlKFwiZmxvYXRcIiwgXCJsZWZ0XCIpXG4gICAgICAgICAgICAuYXBwZW5kKFwic3BhblwiKVxuICAgICAgICAgICAgLmFwcGVuZChcImJ1dHRvblwiKSAvLyB0b3Agc3RhY2sgZm9yIHJlc3VsdHNcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIixcImJ0biBidG4tZGVmYXVsdCBidG4teHNcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgemJyZWFrcy5sZW5ndGgpXG4gICAgICAgICAgICAudGV4dChcImJyZWFrIFwiICsgKHpicmVha3MubGVuZ3RoICsgMSkpLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KFwiI3RhYnVsYXJfMlwiKS5odG1sKFwiXCIpO1xuICAgICAgICAgICAgICAgIHJlbW92ZURhdGEoKTtcbiAgICAgICAgICAgICAgICBsZXQgaWQgPSB0aGlzLmlkIC0gMTtcbiAgICAgICAgICAgICAgICBhcHAuenBhcmFtcy56Y3Jvc3N0YWIucHVzaCh6YnJlYWtzW2lkXSk7XG4gICAgICAgICAgICAgICAgZXhwbG9yZV9jcm9zc3RhYih6YnJlYWtzX3RhYnVsYXJbaWRdKTtcblxuICAgICAgICAgICAgICAgIHZhciBpbnB1dHZhbHVlMSxpbnB1dHZhbHVlMjtcbiAgICAgICAgICAgICAgICBpbnB1dHZhbHVlMT16YnJlYWtzW2lkXS52YXIxLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlucHV0dmFsdWUyPXpicmVha3NbaWRdLnZhcjIudmFsdWU7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJpbnB1dDFcIikudmFsdWUgPSBpbnB1dHZhbHVlMTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImlucHV0MlwiKS52YWx1ZSA9IGlucHV0dmFsdWUyO1xuXG4gICAgICAgICAgICAgICAgdmFyIGpzb25fb2JqPXpicmVha3NbaWRdO1xuICAgICAgICAgICAgICAgIHZhciB2YXJuMSx2YXJuMix2YXJzaXplMSx2YXJzaXplMjtcbiAgICAgICAgICAgICAgICBpZiAoanNvbl9vYmoubGVuZ3RoPT09MCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImJyZWFrIG5vdCBjYWxsZWRcIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFybjE9anNvbl9vYmoudmFyMS5idXR0b25UeXBlO1xuICAgICAgICAgICAgICAgICAgICB2YXJuMj1qc29uX29iai52YXIyLmJ1dHRvblR5cGU7XG4gICAgICAgICAgICAgICAgICAgIHZhcnNpemUxPWpzb25fb2JqLnZhcjEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHZhcnNpemUyPWpzb25fb2JqLnZhcjIudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YXJuMT09PVwiZXF1aWRpc3RhbmNlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyb3NzVGFiUGxvdHMuZXF1aWRpc3RhbmNlKGdldF9kYXRhWzBdLCB2YXJzaXplMSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodmFybjE9PT1cImVxdWltYXNzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyb3NzVGFiUGxvdHMuZXF1aW1hc3MoZ2V0X2RhdGFbMF0sdmFyc2l6ZTEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YXJuMj09PVwiZXF1aWRpc3RhbmNlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyb3NzVGFiUGxvdHMuZXF1aWRpc3RhbmNlKGdldF9kYXRhWzFdLCB2YXJzaXplMik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodmFybjI9PT1cImVxdWltYXNzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyb3NzVGFiUGxvdHMuZXF1aW1hc3MoZ2V0X2RhdGFbMV0sIHZhcnNpemUyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgYXN5bmMgZnVuY3Rpb24gZXhwbG9yZV9jcm9zc3RhYihidG4pIHtcbiAgICAgICAgaWYgKGFwcC5kb3dubG9hZEluY29tcGxldGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGFwcC56UG9wKCk7XG5cbiAgICAgICAgYXBwLmVzdGltYXRlTGFkZGEuc3RhcnQoKTtcbiAgICAgICAgLy8gd3JpdGUgbGlua3MgdG8gZmlsZSAmIHJ1biBSIENNRFxuICAgICAgICBhcHAuenBhcmFtcy5jYWxsSGlzdG9yeSA9IGFwcC5jYWxsSGlzdG9yeTtcbiAgICAgICAgbGV0IGpzb24gPSBhd2FpdCBhcHAubWFrZVJlcXVlc3QoUk9PS19TVkNfVVJMICsgJ2V4cGxvcmVhcHAnLCBhcHAuenBhcmFtcyk7XG4gICAgICAgIGFwcC5lc3RpbWF0ZUxhZGRhLnN0YXJ0KCk7XG4gICAgICAgIGFwcC5leHBsb3JlZCA9IGZhbHNlO1xuICAgICAgICBkMy5qc29uKFwic3RhdGljL3Jlc3VsdC5qc29uXCIsIChlcnIsIGpzb24pID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjcm9zc1RhYl9UYWJsZShqc29uKTtcbiAgICAgICAgICAgIGFwcC5lc3RpbWF0ZUxhZGRhLnN0b3AoKTtcbiAgICAgICAgICAgIGFwcC5leHBsb3JlZCA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIGRhdGEgZm9yIHRoZSBzdGF0aXN0aWNhbCBkaXZcbiAgICB2YXIgc3RyaW5nMSA9IGNvcmsudG9TdHJpbmcoKTtcbiAgICB2YXIgc3RyaW5nMyA9IHN0cmluZzEuc3Vic3RyaW5nKHN0cmluZzEuaW5kZXhPZihcIjpcIiksIHN0cmluZzEubGVuZ3RoKTtcbiAgICB2YXIgc3RyaW5nMiA9IHN0cmluZzEuc3Vic3RyaW5nKDAsIHN0cmluZzEuaW5kZXhPZihcImNcIikpO1xuICAgIHZhciBzdHJpbmc0ID0gY29ycC50b1N0cmluZygpO1xuICAgIHZhciBzdHJpbmc2ID0gc3RyaW5nNC5zdWJzdHJpbmcoc3RyaW5nNC5pbmRleE9mKFwiOlwiKSwgc3RyaW5nNC5sZW5ndGgpO1xuICAgIHZhciBzdHJpbmc1ID0gc3RyaW5nNC5zdWJzdHJpbmcoMCwgc3RyaW5nNC5pbmRleE9mKFwiY1wiKSk7XG4gICAgdmFyIHN0cmluZzcgPSBjb3JzLnRvU3RyaW5nKCk7XG4gICAgdmFyIHN0cmluZzkgPSBzdHJpbmc3LnN1YnN0cmluZyhzdHJpbmc3LmluZGV4T2YoXCI6XCIpLCBzdHJpbmc3Lmxlbmd0aCk7XG4gICAgdmFyIHN0cmluZzggPSBzdHJpbmc3LnN1YnN0cmluZygwLCBzdHJpbmc3LmluZGV4T2YoXCJjXCIpKTtcbiAgICB2YXIgc3RhdGlzdGljYWxfZGF0YSA9IFtcbiAgICAgICAge2NvcnJlbGF0aW9uOiBzdHJpbmcyLCB2YWx1ZTogc3RyaW5nM30sXG4gICAgICAgIHtjb3JyZWxhdGlvbjogc3RyaW5nNSwgdmFsdWU6IHN0cmluZzZ9LFxuICAgICAgICB7Y29ycmVsYXRpb246IHN0cmluZzgsIHZhbHVlOiBzdHJpbmc5fVxuICAgIF07XG5cbiAgICBmdW5jdGlvbiBkM3RhYmxlKGRhdGEpIHtcbiAgICAgICAgZDMuc2VsZWN0KFwiI3Jlc3VsdHNWaWV3X3N0YXRpc3RpY3NcIilcbiAgICAgICAgICAgIC5odG1sKFwiXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJiYWNrZ3JvdW5kLWNvbG9yXCIsIFwiI2ZmZlwiKVxuICAgICAgICAgICAgLmFwcGVuZChcImg1XCIpXG4gICAgICAgICAgICAudGV4dChcIkNPUlJFTEFUSU9OIFNUQVRJU1RJQ1MgXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJjb2xvclwiLCBcIiM0MjQyNDJcIik7XG4gICAgICAgIHZhciB0YWJsZSA9IGQzLnNlbGVjdChcIiNyZXN1bHRzVmlld19zdGF0aXN0aWNzXCIpLmFwcGVuZChcInRhYmxlXCIpLmF0dHIoXCJjbGFzc1wiLCBcInRhYmxlXCIpLnN0eWxlKFwiYm9yZGVyLWNvbGxhcHNlXCIsIFwiIGNvbGxhcHNlXCIpLFxuICAgICAgICAgICAgdGggPSB0YWJsZS5hcHBlbmQoXCJ0clwiKS5zdHlsZShcImJvcmRlclwiLCAxKTtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBPYmplY3Qua2V5cyhkYXRhWzBdKSkge1xuICAgICAgICAgICAgdGguYXBwZW5kKFwidGRcIikuc3R5bGUoXCJib3JkZXItYm90dG9tXCIsIDEpLnN0eWxlKFwidGV4dC1hbGlnblwiLCBcImxlZnRcIikuc3R5bGUoXCJiYWNrZ3JvdW5kLWNvbG9yXCIsIHBsb3RzLnNlbFZhckNvbG9yKS5hcHBlbmQoXCJiXCIpLnRleHQoT2JqZWN0LmtleXMoZGF0YVswXSlbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIHJvdyBpbiBkYXRhKSB7XG4gICAgICAgICAgICB2YXIgdHIgPSB0YWJsZS5hcHBlbmQoXCJ0clwiKS5zdHlsZShcIm1hcmdpbi1sZWZ0XCIsIDQwKS5zdHlsZShcImJvcmRlclwiLCAxKS5zdHlsZShcInRleHQtYWxpZ25cIiwgXCJsZWZ0XCIpO1xuICAgICAgICAgICAgZm9yICh2YXIgdGQgaW4gZGF0YVtyb3ddKVxuICAgICAgICAgICAgICAgIHRyLmFwcGVuZChcInRkXCIpLnN0eWxlKFwiYm9yZGVyXCIsIDEpLnN0eWxlKFwidGV4dC1hbGlnblwiLCBcImxlZnRcIikuc3R5bGUoXCJwb3NpdGlvblwiLCBcInJlbGF0aXZlXCIpLnN0eWxlKFwiYmFja2dyb3VuZC1jb2xvclwiLCBhcHAudmFyQ29sb3IpLnRleHQoZGF0YVtyb3ddW3RkXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZDN0YWJsZShzdGF0aXN0aWNhbF9kYXRhKTtcbn1cblxuXG5mdW5jdGlvbiBtb2RlbF9zZWxlY3Rpb24obW9kZWxfc2VsZWN0aW9uX25hbWUsIGNvdW50X3ZhbHVlLCBqc29uKSB7XG4gICAgaWYgKGNvdW50X3ZhbHVlICUgMiA9PSAwICYmIGNvdW50X3ZhbHVlICE9IDApIHtcbiAgICAgICAgZDMuc2VsZWN0KFwiI21vZGVsVmlld1wiKVxuICAgICAgICAgICAgLmFwcGVuZChcInNwYW5cIilcbiAgICAgICAgICAgIC50ZXh0KFwiXFx1MDBBMCBcXHUwMEEwIFxcdTAwQTAgXFx1MDBBMCAgIFxcdTAwQTAgXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJtYXJnaW4tdG9wXCIsIDApXG4gICAgICAgICAgICAuc3R5bGUoXCJ3aGl0ZS1zcGFjZVwiLCBcInByZVwiKVxuICAgICAgICAgICAgLnN0eWxlKFwiZGlzcGxheVwiLCBcImlubGluZS1ibG9ja1wiKVxuICAgICAgICAgICAgLnN0eWxlKFwiZmxvYXRcIiwgXCJsZWZ0XCIpXG4gICAgICAgICAgICAuYXBwZW5kKFwic3BhblwiKVxuICAgICAgICAgICAgLnRleHQoXCJ8XCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJtYXJnaW4tdG9wXCIsIDApXG4gICAgICAgICAgICAuc3R5bGUoXCJ3aGl0ZS1zcGFjZVwiLCBcInByZVwiKVxuICAgICAgICAgICAgLnN0eWxlKFwiZGlzcGxheVwiLCBcImlubGluZS1ibG9ja1wiKVxuICAgICAgICAgICAgLnN0eWxlKFwiZmxvYXRcIiwgXCJsZWZ0XCIpXG4gICAgICAgICAgICAuYXBwZW5kKFwic3BhblwiKVxuICAgICAgICAgICAgLnRleHQoXCJcXHUwMEEwIFxcdTAwQTAgXFx1MDBBMCBcXHUwMEEwICAgXFx1MDBBMCBcIilcbiAgICAgICAgICAgIC5zdHlsZShcIm1hcmdpbi10b3BcIiwgMClcbiAgICAgICAgICAgIC5zdHlsZShcIndoaXRlLXNwYWNlXCIsIFwicHJlXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJkaXNwbGF5XCIsIFwiaW5saW5lLWJsb2NrXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJmbG9hdFwiLCBcImxlZnRcIik7XG5cbiAgICB9XG4gICAgZDMuc2VsZWN0KFwiI21vZGVsVmlld1wiKVxuICAgICAgICAuYXBwZW5kKFwic3BhblwiKVxuICAgICAgICAudGV4dChcIiBcXHUwMEEwXCIpXG4gICAgICAgIC5zdHlsZShcIm1hcmdpbi10b3BcIiwgMClcbiAgICAgICAgLnN0eWxlKFwiZmxvYXRcIiwgXCJsZWZ0XCIpXG5cbiAgICAgICAgLnN0eWxlKFwiZGlzcGxheVwiLCBcImlubGluZS1ibG9ja1wiKVxuICAgICAgICAuc3R5bGUoXCJ3aGl0ZS1zcGFjZVwiLCBcInByZVwiKVxuICAgICAgICAuc3R5bGUoXCJvdmVyZmxvdy15XCIsIFwiaGlkZGVuXCIpXG4gICAgICAgIC5zdHlsZShcIm92ZXJmbG93LXhcIiwgXCJzY3JvbGxcIilcbiAgICAgICAgLmFwcGVuZChcImJ1dHRvblwiKS8vIHRvcCBzdGFjayBmb3IgcmVzdWx0c1xuICAgIC8vICAgICAgLmFwcGVuZChcInhodG1sOmJ1dHRvblwiKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsXCJidG4gYnRuLW91dGxpbmUtc3VjY2Vzc1wiKVxuICAgICAgICAuc3R5bGUoXCJwYWRkaW5nXCIsXCI0cHhcIilcbiAgICAgICAgLmF0dHIoXCJpZFwiLCBtb2RlbF9zZWxlY3Rpb25fbmFtZSlcbiAgICAgICAgLnRleHQobW9kZWxfc2VsZWN0aW9uX25hbWUpXG4gICAgICAgIC5zdHlsZSgnYmFja2dyb3VuZC1jb2xvcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGNvbG9yMSA9IFwiI0ZGRDU0RlwiO1xuICAgICAgICAgICAgcmV0dXJuIGNvdW50ID09IGNvdW50MSA/IHBsb3RzLnNlbFZhckNvbG9yIDogY29sb3IxO1xuICAgICAgICB9KVxuICAgICAgICAuc3R5bGUoXCJkaXNwbGF5XCIsIFwiaW5saW5lLWJsb2NrXCIpXG4gICAgICAgIC5zdHlsZShcIndoaXRlLXNwYWNlXCIsIFwicHJlXCIpXG4gICAgICAgIC5zdHlsZShcIm1hcmdpbi10b3BcIiwgMClcbiAgICAgICAgLnN0eWxlKFwiZmxvYXRcIiwgXCJsZWZ0XCIpXG4gICAgICAgIC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGEgPSB0aGlzLnN0eWxlLmJhY2tncm91bmRDb2xvci5yZXBsYWNlKC9cXHMqL2csIFwiXCIpO1xuICAgICAgICAgICAgdmFyIGIgPSBhcHAuaGV4VG9SZ2JhKHBsb3RzLnNlbFZhckNvbG9yKS5yZXBsYWNlKC9cXHMqL2csIFwiXCIpO1xuICAgICAgICAgICAgaWYgKGEuc3Vic3RyKDAsIDE3KSA9PT0gYi5zdWJzdHIoMCwgMTcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvL2VzY2FwZXMgdGhlIGZ1bmN0aW9uIGVhcmx5IGlmIHRoZSBkaXNwbGF5ZWQgbW9kZWwgaXMgY2xpY2tlZFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdml6KHRoaXMuaWQsIGpzb24sIG1vZGVsX3NlbGVjdGlvbl9uYW1lKTtcbiAgICAgICAgICAgIGQzLnNlbGVjdChcIiNtb2RlbFZpZXdcIilcbiAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKFwiYnV0dG9uXCIpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJywgXCIjRkZENTRGXCIpO1xuICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJywgcGxvdHMuc2VsVmFyQ29sb3IpO1xuICAgICAgICB9KTtcbn1cblxuZnVuY3Rpb24gc2hvd0xvZygpIHtcbiAgICBpZiAoYXBwLmxvZ0FycmF5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgYXBwLmJ5SWQoJ2xvZ2RpdicpLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIFwiZGlzcGxheTpibG9ja1wiKTtcbiAgICAgICAgZDMuc2VsZWN0KFwiI2NvbGxhcHNlTG9nIGRpdi5wYW5lbC1ib2R5XCIpLnNlbGVjdEFsbChcInBcIilcbiAgICAgICAgICAgIC5kYXRhKGFwcC5sb2dBcnJheSlcbiAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAuYXBwZW5kKFwicFwiKVxuICAgICAgICAgICAgLnRleHQoZCA9PiBkKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhcHAuYnlJZCgnbG9nZGl2Jykuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgXCJkaXNwbGF5Om5vbmVcIik7XG59XG5cblxuXG5sZXQgY291bnQgPSAwO1xubGV0IGNvdW50MSA9IDA7XG5cbi8qKlxuICAgY2FsbGVkIGJ5IGNsaWNraW5nICdFeHBsb3JlJyBpbiBleHBsb3JlIG1vZGVcbiovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZXhwbG9yZSgpIHtcbiAgICBpZiAoYXBwLmRvd25sb2FkSW5jb21wbGV0ZSgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBhcHAuelBvcCgpO1xuICAgIGNvbnNvbGUubG9nKCd6cG9wOicsIGFwcC56cGFyYW1zKTtcblxuICAgIC8vIHdyaXRlIGxpbmtzIHRvIGZpbGUgJiBydW4gUiBDTURcbiAgICBhcHAuenBhcmFtcy5jYWxsSGlzdG9yeSA9IGFwcC5jYWxsSGlzdG9yeTtcbiAgICBhcHAuZXN0aW1hdGVMYWRkYS5zdGFydCgpOyAvLyBzdGFydCBzcGlubmVyXG4gICAgbGV0IGpzb24gPSBhd2FpdCBhcHAubWFrZVJlcXVlc3QoUk9PS19TVkNfVVJMICsgJ2V4cGxvcmVhcHAnLCBhcHAuenBhcmFtcyk7XG4gICAgaWYgKCFqc29uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYXBwLmFsbFJlc3VsdHMucHVzaChqc29uKTtcblxuICAgIGQzLnNlbGVjdCgnI3JpZ2h0cGFuZWwnKVxuICAgICAgICAuc3R5bGUoJ3dpZHRoJywgJzc1JScpO1xuXG4gICAgbGV0IHBhcmVudCA9IGFwcC5ieUlkKCdyaWdodENvbnRlbnRBcmVhJyk7XG4gICAgYXBwLmV4cGxvcmVkIHx8IHBhcmVudC5yZW1vdmVDaGlsZChhcHAuYnlJZCgncmVzdWx0c0hvbGRlcicpKTtcbiAgICBhcHAuZXhwbG9yZWQgPSB0cnVlO1xuXG4gICAgZDMuc2VsZWN0KFwiI2RlY2lzaW9uVHJlZVwiKVxuICAgICAgICAuc3R5bGUoXCJkaXNwbGF5XCIsIFwibm9uZVwiKTtcbiAgICBkMy5zZWxlY3QoXCIjbW9kZWxWaWV3XCIpLmh0bWwoJycpO1xuICAgIGQzLnNlbGVjdChcIiNyZXN1bHRzVmlld19zdGF0aXN0aWNzXCIpLmh0bWwoJycpO1xuICAgIFtcIiNsZWZ0X3RodW1ibmFpbFwiLFxuICAgICBcIiNyZXN1bHRfbGVmdFwiLFxuICAgICBcIiNyZXN1bHRfbGVmdDFcIixcbiAgICAgXCIjcmVzdWx0X3JpZ2h0XCIsXG4gICAgIFwiI21vZGVsVmlld19Db250YWluZXJcIixcbiAgICAgXCIjbW9kZWxWaWV3XCIsXG4gICAgIFwiI3Jlc3VsdHNWaWV3X3RhYnVsYXJcIixcbiAgICAgXCIjcGxvdEFcIixcbiAgICAgXCIjcGxvdEJcIixcbiAgICAgXCIjU2VsZWN0aW9uRGF0YVwiLFxuICAgICBcIiNyZXN1bHRzVmlld19zdGF0aXN0aWNzXCJcbiAgICBdLmZvckVhY2goaWQgPT4gZDMuc2VsZWN0KGlkKS5zdHlsZShcImRpc3BsYXlcIiwgXCJibG9ja1wiKSk7XG5cbiAgICBkMy5zZWxlY3QoXCIjbW9kZWxWaWV3XCIpXG4gICAgICAgIC5zdHlsZSgnYmFja2dyb3VuZC1jb2xvcicsIGFwcC5oZXhUb1JnYmEoYXBwLnZhckNvbG9yKSlcbiAgICAgICAgLnN0eWxlKFwib3ZlcmZsb3cteVwiLCBcImhpZGRlblwiKVxuICAgICAgICAuc3R5bGUoXCJvdmVyZmxvdy14XCIsIFwic2Nyb2xsXCIpXG4gICAgICAgIC5hcHBlbmQoXCJzcGFuXCIpXG4gICAgICAgIC5zdHlsZShcIndoaXRlLXNwYWNlXCIsIFwicHJlXCIpXG4gICAgICAgIC5zdHlsZShcIm1hcmdpbi10b3BcIiwgMClcbiAgICAgICAgLnN0eWxlKFwiZmxvYXRcIiwgXCJsZWZ0XCIpXG4gICAgICAgIC5zdHlsZShcInBvc2l0aW9uXCIsIFwicmVsYXRpdmVcIilcbiAgICAgICAgLnN0eWxlKFwiY29sb3JcIiwgXCIjNzU3NTc1XCIpXG4gICAgICAgIC50ZXh0KFwiTU9ERUwgU0VMRUNUSU9OIDogIFwiKTtcblxuICAgIC8vIHByb2dyYW1tYXRpYyBjbGljayBvbiBSZXN1bHRzIGJ1dHRvblxuICAgICQoXCIjYnRuQml2YXJpYXRlXCIpLnRyaWdnZXIoXCJjbGlja1wiKTtcbiAgICBsZXQgbW9kZWxfbmFtZTtcbiAgICBmb3IgKGxldCBpbWcgaW4ganNvbi5pbWFnZXMpIHtcbiAgICAgICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICBtb2RlbF9uYW1lID0gaW1nO1xuICAgICAgICB9XG4gICAgICAgIG1vZGVsX3NlbGVjdGlvbihpbWcsIGNvdW50LCBqc29uKTsgLy8gZm9yIGVudGVyaW5nIGFsbCB0aGUgdmFyaWFibGVzXG4gICAgICAgIGNvdW50Kys7XG4gICAgfVxuICAgIGNvdW50MSA9IGNvdW50IC0gMTtcbiAgICBhcHAubW9kZWxDb3VudCsrO1xuXG4gICAgdmFyIHJDYWxsID0gW107XG4gICAgckNhbGxbMF0gPSBqc29uLmNhbGw7XG4gICAgYXBwLmxvZ0FycmF5LnB1c2goXCJleHBsb3JlOiBcIi5jb25jYXQockNhbGxbMF0pKTtcbiAgICBzaG93TG9nKCk7XG4gICAgdml6KG1vZGVsX25hbWUsIGpzb24sIG1vZGVsX25hbWUpO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2FsbFRyZWVBcHAobm9kZV92YXIpIHtcbiAgICBhcHAuelBvcCgpO1xuICAgIGFwcC56cGFyYW1zLmNhbGxIaXN0b3J5ID0gYXBwLmNhbGxIaXN0b3J5O1xuICAgIFxuICAgIGxldCByZXMgPSBhd2FpdCBhcHAubWFrZVJlcXVlc3QoUk9PS19TVkNfVVJMICsgJ3RyZWVhcHAnLCB7enBhcmFtczphcHAuenBhcmFtcywgZHY6bm9kZV92YXJ9KTtcbiAgICBpZiAoIXJlcykge1xuICAgICAgICBhbGVydChcInRyZWVhcHAgZmFpbGVkXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHJlcyk7XG4gICAgICAgIHVuaXZhcmlhdGVQYXJ0KHJlcyxub2RlX3Zhcik7XG4gICAgfVxufVxuXG4vLyBLcmlwYW5zaHUgOiBGdW5jdGlvbiB0byBjcmVhdGUgRDMgVHJlZSB1c2luZyB0aGUgSlNPTiByZXN1bHQgZnJvbSBjYWxsIFRyZWUgYXBwXG5mdW5jdGlvbiB1bml2YXJpYXRlUGFydChqc29uLCB2YXJfbmFtZSkge1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZGVjaXNpb25UcmVlXCIpLmlubmVySFRNTCA9IFwiXCI7XG4gICAgZDMuc2VsZWN0KCcjcmlnaHRwYW5lbCcpXG4gICAgICAgIC5zdHlsZSgnd2lkdGgnLCAnNzUlJyk7XG4gICAgZDMuc2VsZWN0KFwiI2RlY2lzaW9uVHJlZVwiKVxuICAgICAgICAuc3R5bGUoXCJkaXNwbGF5XCIsIFwiYmxvY2tcIilcbiAgICAgICAgLmFwcGVuZChcInBcIilcbiAgICAgICAgLnN0eWxlKFwibWFyZ2luLXRvcFwiLCBcIjFweFwiKVxuICAgICAgICAudGV4dCh2YXJfbmFtZSk7XG4gICAgZDMuc2VsZWN0KFwicCNyZXN1bHRzSG9sZGVyXCIpLnN0eWxlKFwiZGlzcGxheVwiLCBcIm5vbmVcIik7XG4gICAgZDMuc2VsZWN0KFwiI2xlZnRfdGh1bWJuYWlsXCIpXG4gICAgICAgIC5zdHlsZShcImRpc3BsYXlcIiwgXCJub25lXCIpO1xuICAgIGQzLnNlbGVjdChcIiNyZXN1bHRfbGVmdFwiKVxuICAgICAgICAuc3R5bGUoXCJkaXNwbGF5XCIsIFwibm9uZVwiKTtcbiAgICBkMy5zZWxlY3QoXCIjcmVzdWx0X2xlZnQxXCIpXG4gICAgICAgIC5zdHlsZShcImRpc3BsYXlcIiwgXCJub25lXCIpO1xuICAgIGQzLnNlbGVjdChcIiNyZXN1bHRfcmlnaHRcIilcbiAgICAgICAgLnN0eWxlKFwiZGlzcGxheVwiLCBcIm5vbmVcIik7XG4gICAgZDMuc2VsZWN0KFwiI21vZGVsVmlld19Db250YWluZXJcIilcbiAgICAgICAgLnN0eWxlKFwiZGlzcGxheVwiLCBcIm5vbmVcIik7XG4gICAgZDMuc2VsZWN0KFwiI21vZGVsVmlld1wiKVxuICAgICAgICAuc3R5bGUoXCJkaXNwbGF5XCIsIFwibm9uZVwiKTtcbiAgICBkMy5zZWxlY3QoXCIjcmVzdWx0c1ZpZXdfdGFidWxhclwiKVxuICAgICAgICAuc3R5bGUoXCJkaXNwbGF5XCIsIFwibm9uZVwiKTtcbiAgICBkMy5zZWxlY3QoXCIjcGxvdEFcIilcbiAgICAgICAgLnN0eWxlKFwiZGlzcGxheVwiLCBcIm5vbmVcIik7XG4gICAgZDMuc2VsZWN0KFwiI3Bsb3RCXCIpXG4gICAgICAgIC5zdHlsZShcImRpc3BsYXlcIiwgXCJub25lXCIpO1xuICAgIGQzLnNlbGVjdChcIiNTZWxlY3Rpb25EYXRhXCIpXG4gICAgICAgIC5zdHlsZShcImRpc3BsYXlcIiwgXCJub25lXCIpO1xuICAgIGQzLnNlbGVjdChcIiNyZXN1bHRzVmlld19zdGF0aXN0aWNzXCIpXG4gICAgICAgIC5zdHlsZShcImRpc3BsYXlcIiwgXCJub25lXCIpO1xuXG4gICAgLy8gcmVxdWVzdCBmb3IgciBjb2RlIHVzaW5nIG5vZGV2YXJcbiAgICAvL2NvZGUgZm9yIHRoZSAgZGVjaXNpb24gdHJlZSBtYXBcblxuICAgIHZhciBtID0gWzE1LCAxMDAsIDE1LCAxMDBdLFxuICAgICAgICB3ID0gNzAwIC0gbVsxXSAtIG1bM10sXG4gICAgICAgIGggPSA1MDAgLSBtWzBdIC0gbVsyXSxcbiAgICAgICAgaSA9IDAsXG4gICAgICAgIHJlY3Rfd2lkdGggPSA2MCxcbiAgICAgICAgcmVjdF9oZWlnaHQgPSAyMCxcbiAgICAgICAgbWF4X2xpbmtfd2lkdGggPSAyMCxcbiAgICAgICAgbWluX2xpbmtfd2lkdGggPSAxLjUsXG4gICAgICAgIGNoYXJfdG9fcHhsID0gNixcbiAgICAgICAgcm9vdDtcblxuXG5cbiAgICB2YXIgdHJlZSA9IGQzLmxheW91dC50cmVlKClcbiAgICAgICAgLnNpemUoW2gsIHddKTtcblxuICAgIHZhciBkaWFnb25hbCA9IGQzLnN2Zy5kaWFnb25hbCgpXG4gICAgICAgIC5wcm9qZWN0aW9uKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBbZC54LCBkLnldO1xuICAgICAgICB9KTtcblxuICAgIHZhciB2aXMgPSBkMy5zZWxlY3QoXCIjZGVjaXNpb25UcmVlXCIpLmFwcGVuZChcInN2ZzpzdmdcIilcbiAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCB3ICsgbVsxXSArIG1bM10pXG4gICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGggKyBtWzBdICsgbVsyXSArIDEwMDApXG4gICAgICAgIC5hcHBlbmQoXCJzdmc6Z1wiKVxuICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIG1bM10gKyBcIixcIiArIG1bMF0gKyBcIilcIik7XG5cbiAgICAvLyBnbG9iYWwgc2NhbGUgZm9yIGxpbmsgd2lkdGhcbiAgICB2YXIgbGlua19zdG9rZV9zY2FsZSA9IGQzLnNjYWxlLmxpbmVhcigpO1xuXG4gICAgdmFyIGNvbG9yX21hcCA9IGQzLnNjYWxlLmNhdGVnb3J5MTAoKTtcblxuICAgIC8vIHN0cm9rZSBzdHlsZSBvZiBsaW5rIC0gZWl0aGVyIGNvbG9yIG9yIGZ1bmN0aW9uXG4gICAgdmFyIHN0cm9rZV9jYWxsYmFjayA9IFwiI2NjY1wiO1xuICAgIGxvYWRfZGF0YXNldChqc29uKVxuXG4gICAgZnVuY3Rpb24gbG9hZF9kYXRhc2V0KGpzb25fZGF0YSkge1xuXG4gICAgICAgIGNvbnNvbGUubG9nKFwib3VyIGRhdGEgZm9yIGRlY2lzaW9uIHRyZWVcIiwganNvbl9kYXRhKTtcbiAgICAgICAgcm9vdCA9IGpzb25fZGF0YTtcbiAgICAgICAgcm9vdC54MCA9IDA7XG4gICAgICAgIHJvb3QueTAgPSAwO1xuXG4gICAgICAgIHZhciBuX3NhbXBsZXMgPSByb290LnNhbXBsZXM7XG4gICAgICAgIHZhciBuX2xhYmVscyA9IHJvb3QudmFsdWUubGVuZ3RoO1xuXG4gICAgICAgIGlmIChuX2xhYmVscyA+PSAyKSB7XG4gICAgICAgICAgICBzdHJva2VfY2FsbGJhY2sgPSBtaXhfY29sb3JzO1xuICAgICAgICB9IGVsc2UgaWYgKG5fbGFiZWxzID09PSAxKSB7XG4gICAgICAgICAgICBzdHJva2VfY2FsbGJhY2sgPSBtZWFuX2ludGVycG9sYXRpb24ocm9vdCk7XG4gICAgICAgIH1cblxuICAgICAgICBsaW5rX3N0b2tlX3NjYWxlID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgICAgIC5kb21haW4oWzAsIG5fc2FtcGxlc10pXG4gICAgICAgICAgICAucmFuZ2UoW21pbl9saW5rX3dpZHRoLCBtYXhfbGlua193aWR0aF0pO1xuXG4gICAgICAgIGZ1bmN0aW9uIHRvZ2dsZUFsbChkKSB7XG4gICAgICAgICAgICBpZiAoZCAmJiBkLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgZC5jaGlsZHJlbi5mb3JFYWNoKHRvZ2dsZUFsbCk7XG4gICAgICAgICAgICAgICAgdG9nZ2xlKGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgZGlzcGxheSB0byBzaG93IGEgZmV3IG5vZGVzLlxuICAgICAgICByb290LmNoaWxkcmVuLmZvckVhY2godG9nZ2xlQWxsKTtcblxuICAgICAgICB1cGRhdGUocm9vdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlKHNvdXJjZSkge1xuICAgICAgICB2YXIgZHVyYXRpb24gPSBkMy5ldmVudCAmJiBkMy5ldmVudC5hbHRLZXkgPyA1MDAwIDogNTAwO1xuXG4gICAgICAgIC8vIENvbXB1dGUgdGhlIG5ldyB0cmVlIGxheW91dC5cbiAgICAgICAgdmFyIG5vZGVzID0gdHJlZS5ub2Rlcyhyb290KS5yZXZlcnNlKCk7XG5cbiAgICAgICAgLy8gTm9ybWFsaXplIGZvciBmaXhlZC1kZXB0aC5cbiAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICBkLnkgPSBkLmRlcHRoICogMTgwO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBVcGRhdGUgdGhlIG5vZGVz4oCmXG4gICAgICAgIHZhciBub2RlID0gdmlzLnNlbGVjdEFsbChcImcubm9kZVwiKVxuICAgICAgICAgICAgLmRhdGEobm9kZXMsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZC5pZCB8fCAoZC5pZCA9ICsraSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAvLyBFbnRlciBhbnkgbmV3IG5vZGVzIGF0IHRoZSBwYXJlbnQncyBwcmV2aW91cyBwb3NpdGlvbi5cbiAgICAgICAgdmFyIG5vZGVFbnRlciA9IG5vZGUuZW50ZXIoKS5hcHBlbmQoXCJzdmc6Z1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcIm5vZGVcIilcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJ0cmFuc2xhdGUoXCIgKyBzb3VyY2UueDAgKyBcIixcIiArIHNvdXJjZS55MCArIFwiKVwiO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICB0b2dnbGUoZCk7XG4gICAgICAgICAgICAgICAgdXBkYXRlKGQpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgbm9kZUVudGVyLmFwcGVuZChcInN2ZzpyZWN0XCIpXG4gICAgICAgICAgICAuYXR0cihcInhcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIHZhciBsYWJlbCA9IG5vZGVfbGFiZWwoZCk7XG4gICAgICAgICAgICAgICAgdmFyIHRleHRfbGVuID0gbGFiZWwubGVuZ3RoICogY2hhcl90b19weGw7XG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gZDMubWF4KFtyZWN0X3dpZHRoLCB0ZXh0X2xlbl0pO1xuICAgICAgICAgICAgICAgIHJldHVybiAtd2lkdGggLyAyO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgMWUtNilcbiAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIDFlLTYpXG4gICAgICAgICAgICAuYXR0cihcInJ4XCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZC50eXBlID09PSBcInNwbGl0XCIgPyAyIDogMDtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuYXR0cihcInJ5XCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZC50eXBlID09PSBcInNwbGl0XCIgPyAyIDogMDtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuc3R5bGUoXCJzdHJva2VcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkLnR5cGUgPT09IFwic3BsaXRcIiA/IFwic3RlZWxibHVlXCIgOiBcIm9saXZlZHJhYlwiO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkLl9jaGlsZHJlbiA/IFwibGlnaHRzdGVlbGJsdWVcIiA6IFwiI2ZmZlwiO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgbm9kZUVudGVyLmFwcGVuZChcInN2Zzp0ZXh0XCIpXG4gICAgICAgICAgICAuYXR0cihcImR5XCIsIFwiMTJweFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKVxuICAgICAgICAgICAgLnRleHQobm9kZV9sYWJlbClcbiAgICAgICAgICAgIC5zdHlsZShcImZpbGwtb3BhY2l0eVwiLCAxZS02KTtcblxuICAgICAgICAvLyBUcmFuc2l0aW9uIG5vZGVzIHRvIHRoZWlyIG5ldyBwb3NpdGlvbi5cbiAgICAgICAgdmFyIG5vZGVVcGRhdGUgPSBub2RlLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgLmR1cmF0aW9uKGR1cmF0aW9uKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcInRyYW5zbGF0ZShcIiArIGQueCArIFwiLFwiICsgZC55ICsgXCIpXCI7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBub2RlVXBkYXRlLnNlbGVjdChcInJlY3RcIilcbiAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIHZhciBsYWJlbCA9IG5vZGVfbGFiZWwoZCk7XG4gICAgICAgICAgICAgICAgdmFyIHRleHRfbGVuID0gbGFiZWwubGVuZ3RoICogY2hhcl90b19weGw7XG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gZDMubWF4KFtyZWN0X3dpZHRoLCB0ZXh0X2xlbl0pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpZHRoO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIHJlY3RfaGVpZ2h0KVxuICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGQuX2NoaWxkcmVuID8gXCJsaWdodHN0ZWVsYmx1ZVwiIDogXCIjZmZmXCI7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBub2RlVXBkYXRlLnNlbGVjdChcInRleHRcIilcbiAgICAgICAgICAgIC5zdHlsZShcImZpbGwtb3BhY2l0eVwiLCAxKTtcblxuICAgICAgICAvLyBUcmFuc2l0aW9uIGV4aXRpbmcgbm9kZXMgdG8gdGhlIHBhcmVudCdzIG5ldyBwb3NpdGlvbi5cbiAgICAgICAgdmFyIG5vZGVFeGl0ID0gbm9kZS5leGl0KCkudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAuZHVyYXRpb24oZHVyYXRpb24pXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwidHJhbnNsYXRlKFwiICsgc291cmNlLnggKyBcIixcIiArIHNvdXJjZS55ICsgXCIpXCI7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnJlbW92ZSgpO1xuXG4gICAgICAgIG5vZGVFeGl0LnNlbGVjdChcInJlY3RcIilcbiAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgMWUtNilcbiAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIDFlLTYpO1xuXG4gICAgICAgIG5vZGVFeGl0LnNlbGVjdChcInRleHRcIilcbiAgICAgICAgICAgIC5zdHlsZShcImZpbGwtb3BhY2l0eVwiLCAxZS02KTtcblxuICAgICAgICAvLyBVcGRhdGUgdGhlIGxpbmtzXG4gICAgICAgIHZhciBsaW5rID0gdmlzLnNlbGVjdEFsbChcInBhdGgubGlua1wiKVxuICAgICAgICAgICAgLmRhdGEodHJlZS5saW5rcyhub2RlcyksIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZC50YXJnZXQuaWQ7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAvLyBFbnRlciBhbnkgbmV3IGxpbmtzIGF0IHRoZSBwYXJlbnQncyBwcmV2aW91cyBwb3NpdGlvbi5cbiAgICAgICAgbGluay5lbnRlcigpLmluc2VydChcInN2ZzpwYXRoXCIsIFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImxpbmtcIilcbiAgICAgICAgICAgIC5hdHRyKFwiZFwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgdmFyIG8gPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IHNvdXJjZS54MCxcbiAgICAgICAgICAgICAgICAgICAgeTogc291cmNlLnkwXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlhZ29uYWwoe1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IG8sXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogb1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgIC5kdXJhdGlvbihkdXJhdGlvbilcbiAgICAgICAgICAgIC5hdHRyKFwiZFwiLCBkaWFnb25hbClcbiAgICAgICAgICAgIC5zdHlsZShcInN0cm9rZS13aWR0aFwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpbmtfc3Rva2Vfc2NhbGUoZC50YXJnZXQuc2FtcGxlcyk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnN0eWxlKFwic3Ryb2tlXCIsIHN0cm9rZV9jYWxsYmFjayk7XG5cbiAgICAgICAgLy8gVHJhbnNpdGlvbiBsaW5rcyB0byB0aGVpciBuZXcgcG9zaXRpb24uXG4gICAgICAgIGxpbmsudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAuZHVyYXRpb24oZHVyYXRpb24pXG4gICAgICAgICAgICAuYXR0cihcImRcIiwgZGlhZ29uYWwpXG4gICAgICAgICAgICAuc3R5bGUoXCJzdHJva2Utd2lkdGhcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsaW5rX3N0b2tlX3NjYWxlKGQudGFyZ2V0LnNhbXBsZXMpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5zdHlsZShcInN0cm9rZVwiLCBzdHJva2VfY2FsbGJhY2spO1xuXG4gICAgICAgIC8vIFRyYW5zaXRpb24gZXhpdGluZyBub2RlcyB0byB0aGUgcGFyZW50J3MgbmV3IHBvc2l0aW9uLlxuICAgICAgICBsaW5rLmV4aXQoKS50cmFuc2l0aW9uKClcbiAgICAgICAgICAgIC5kdXJhdGlvbihkdXJhdGlvbilcbiAgICAgICAgICAgIC5hdHRyKFwiZFwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgdmFyIG8gPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IHNvdXJjZS54LFxuICAgICAgICAgICAgICAgICAgICB5OiBzb3VyY2UueVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpYWdvbmFsKHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiBvLFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IG9cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAucmVtb3ZlKCk7XG5cbiAgICAgICAgLy8gU3Rhc2ggdGhlIG9sZCBwb3NpdGlvbnMgZm9yIHRyYW5zaXRpb24uXG4gICAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgZC54MCA9IGQueDtcbiAgICAgICAgICAgIGQueTAgPSBkLnk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFRvZ2dsZSBjaGlsZHJlbi5cbiAgICBmdW5jdGlvbiB0b2dnbGUoZCkge1xuICAgICAgICBpZiAoZC5jaGlsZHJlbikge1xuICAgICAgICAgICAgZC5fY2hpbGRyZW4gPSBkLmNoaWxkcmVuO1xuICAgICAgICAgICAgZC5jaGlsZHJlbiA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkLmNoaWxkcmVuID0gZC5fY2hpbGRyZW47XG4gICAgICAgICAgICBkLl9jaGlsZHJlbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBOb2RlIGxhYmVsc1xuICAgIGZ1bmN0aW9uIG5vZGVfbGFiZWwoZCkge1xuICAgICAgICBpZiAoZC50eXBlID09PSBcImxlYWZcIikge1xuICAgICAgICAgICAgLy8gbGVhZlxuICAgICAgICAgICAgdmFyIGZvcm1hdHRlciA9IGQzLmZvcm1hdChcIi4yZlwiKTtcbiAgICAgICAgICAgIHZhciB2YWxzID0gW107XG4gICAgICAgICAgICBkLnZhbHVlLmZvckVhY2goZnVuY3Rpb24odikge1xuICAgICAgICAgICAgICAgIHZhbHMucHVzaChmb3JtYXR0ZXIodikpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gXCJbXCIgKyB2YWxzLmpvaW4oXCIsIFwiKSArIFwiXVwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gc3BsaXQgbm9kZVxuICAgICAgICAgICAgcmV0dXJuIGQubGFiZWw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNaXhlcyBjb2xvcnMgYWNjb3JkaW5nIHRvIHRoZSByZWxhdGl2ZSBmcmVxdWVuY3kgb2YgY2xhc3Nlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtaXhfY29sb3JzKGQpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gZC50YXJnZXQudmFsdWU7XG4gICAgICAgIHZhciBzdW0gPSBkMy5zdW0odmFsdWUpO1xuICAgICAgICB2YXIgY29sID0gZDMucmdiKDAsIDAsIDApO1xuICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaSkge1xuICAgICAgICAgICAgdmFyIGxhYmVsX2NvbG9yID0gZDMucmdiKGNvbG9yX21hcChpKSk7XG4gICAgICAgICAgICB2YXIgbWl4X2NvZWYgPSB2YWwgLyBzdW07XG4gICAgICAgICAgICBjb2wuciArPSBtaXhfY29lZiAqIGxhYmVsX2NvbG9yLnI7XG4gICAgICAgICAgICBjb2wuZyArPSBtaXhfY29lZiAqIGxhYmVsX2NvbG9yLmc7XG4gICAgICAgICAgICBjb2wuYiArPSBtaXhfY29lZiAqIGxhYmVsX2NvbG9yLmI7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY29sO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQSBsaW5lYXIgaW50ZXJwb2xhdG9yIGZvciB2YWx1ZVswXS5cbiAgICAgKlxuICAgICAqIFVzZWZ1bCBmb3IgbGluayBjb2xvcmluZyBpbiByZWdyZXNzaW9uIHRyZWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lYW5faW50ZXJwb2xhdGlvbihyb290KSB7XG5cbiAgICAgICAgdmFyIG1heCA9IDFlLTksXG4gICAgICAgICAgICBtaW4gPSAxZTk7XG5cbiAgICAgICAgZnVuY3Rpb24gcmVjdXJzZShub2RlKSB7XG4gICAgICAgICAgICBpZiAobm9kZS52YWx1ZVswXSA+IG1heCkge1xuICAgICAgICAgICAgICAgIG1heCA9IG5vZGUudmFsdWVbMF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChub2RlLnZhbHVlWzBdIDwgbWluKSB7XG4gICAgICAgICAgICAgICAgbWluID0gbm9kZS52YWx1ZVswXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICBub2RlLmNoaWxkcmVuLmZvckVhY2gocmVjdXJzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZWN1cnNlKHJvb3QpO1xuXG4gICAgICAgIHZhciBzY2FsZSA9IGQzLnNjYWxlLmxpbmVhcigpLmRvbWFpbihbbWluLCBtYXhdKVxuICAgICAgICAgICAgLnJhbmdlKFtcIiMyMTY2QUNcIiwgXCIjQjIxODJCXCJdKTtcblxuICAgICAgICBmdW5jdGlvbiBpbnRlcnBvbGF0b3IoZCkge1xuICAgICAgICAgICAgcmV0dXJuIHNjYWxlKGQudGFyZ2V0LnZhbHVlWzBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbnRlcnBvbGF0b3I7XG4gICAgfVxuXG5cbn1cblxuXG5cblxuXG5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Fzc2V0cy9hcHAvZXhwbG9yZS5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6\n')},function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.getClasses = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mithril = __webpack_require__(0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _app = __webpack_require__(1);\n\nvar app = _interopRequireWildcard(_app);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar getClasses = exports.getClasses = function getClasses(cls, panel) {\n    return cls + (panel.closed ? '.closepanel' : panel.side === 'left' && app.lefttab === 'tab2' ? '.expandpanel' : '');\n};\n\nvar Panel = function () {\n    function Panel() {\n        _classCallCheck(this, Panel);\n    }\n\n    _createClass(Panel, [{\n        key: 'oninit',\n        value: function oninit(vnode) {\n            this.closed = false;\n        }\n    }, {\n        key: 'view',\n        value: function view(vnode) {\n            var _this = this;\n\n            var _vnode$attrs = vnode.attrs,\n                side = _vnode$attrs.side,\n                title = _vnode$attrs.title,\n                buttons = _vnode$attrs.buttons,\n                is_explore_mode = _vnode$attrs.is_explore_mode;\n\n            var btns = buttons;\n            var dot = [_mithril2.default.trust('&#9679;'), (0, _mithril2.default)('br')];\n            var width = 100 / btns.length;\n            var expandwidth = 35;\n            var shrinkwidth = 65 / (btns.length - 1);\n            return (0, _mithril2.default)(getClasses('#' + side + 'panel.sidepanel.container.clearfix', this), (0, _mithril2.default)('#toggle' + (side === 'left' ? 'L' : 'R') + 'panelicon.panelbar[style=height: 100%]', (0, _mithril2.default)('span', { onclick: function onclick(_) {\n                    return _this.closed = !_this.closed;\n                } }, dot, dot, dot, dot)), (0, _mithril2.default)('#' + side + 'paneltitle.panel-heading.text-center', (0, _mithril2.default)(\"h3.panel-title\", title)), (0, _mithril2.default)('ul' + (side === 'right' ? '#rightpanelbuttons' : '') + '.accordion', btns.map(function (b) {\n                b.attrs.style = b.attrs.style + '; width: 100%';\n                b.attrs.is_explore_mode = is_explore_mode;\n                var id = b.attrs.id;\n                //let w = this.active_btn === id ? shrinkwidth :\n                //this.active_btn === null ? width :\n                //expandwidth;\n                return (0, _mithril2.default)('li', { style: { width: width + '%', 'max-width': '150px' },\n                    onmouseover: function onmouseover(_) {\n                        return _this.active_btn = id;\n                    },\n                    onmouseout: function onmouseout(_) {\n                        return _this.active_btn = null;\n                    } }, b);\n            })), (0, _mithril2.default)(getClasses('.row-fluid', this), (0, _mithril2.default)('#' + side + 'panelcontent', (0, _mithril2.default)('#' + side + 'ContentArea[style=height: calc(100vh - 213px); overflow: auto]', vnode.children))));\n        }\n    }]);\n\n    return Panel;\n}();\n\nexports.default = Panel;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvYXBwL3ZpZXdzL1BhbmVsLmpzPzkyNGYiXSwibmFtZXMiOlsiYXBwIiwiZ2V0Q2xhc3NlcyIsImNscyIsInBhbmVsIiwiY2xvc2VkIiwic2lkZSIsImxlZnR0YWIiLCJQYW5lbCIsInZub2RlIiwiYXR0cnMiLCJ0aXRsZSIsImJ1dHRvbnMiLCJpc19leHBsb3JlX21vZGUiLCJidG5zIiwiZG90IiwidHJ1c3QiLCJ3aWR0aCIsImxlbmd0aCIsImV4cGFuZHdpZHRoIiwic2hyaW5rd2lkdGgiLCJvbmNsaWNrIiwibWFwIiwiYiIsInN0eWxlIiwiaWQiLCJvbm1vdXNlb3ZlciIsImFjdGl2ZV9idG4iLCJvbm1vdXNlb3V0IiwiY2hpbGRyZW4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOzs7O0FBRUE7O0lBQVlBLEc7Ozs7Ozs7O0FBRUwsSUFBSUMsa0NBQWEsU0FBYkEsVUFBYSxDQUFTQyxHQUFULEVBQWNDLEtBQWQsRUFBcUI7QUFDekMsV0FBT0QsT0FBT0MsTUFBTUMsTUFBTixHQUFlLGFBQWYsR0FDVEQsTUFBTUUsSUFBTixLQUFlLE1BQWYsSUFBeUJMLElBQUlNLE9BQUosS0FBZ0IsTUFBMUMsR0FBb0QsY0FBcEQsR0FDQSxFQUZHLENBQVA7QUFHSCxDQUpNOztJQU1EQyxLOzs7Ozs7OytCQUNLQyxLLEVBQU87QUFDVixpQkFBS0osTUFBTCxHQUFjLEtBQWQ7QUFDSDs7OzZCQUVJSSxLLEVBQU87QUFBQTs7QUFBQSwrQkFDc0NBLE1BQU1DLEtBRDVDO0FBQUEsZ0JBQ0hKLElBREcsZ0JBQ0hBLElBREc7QUFBQSxnQkFDR0ssS0FESCxnQkFDR0EsS0FESDtBQUFBLGdCQUNVQyxPQURWLGdCQUNVQSxPQURWO0FBQUEsZ0JBQ21CQyxlQURuQixnQkFDbUJBLGVBRG5COztBQUVSLGdCQUFJQyxPQUFPRixPQUFYO0FBQ0EsZ0JBQUlHLE1BQU0sQ0FBQyxrQkFBRUMsS0FBRixDQUFRLFNBQVIsQ0FBRCxFQUFxQix1QkFBRSxJQUFGLENBQXJCLENBQVY7QUFDQSxnQkFBSUMsUUFBUSxNQUFNSCxLQUFLSSxNQUF2QjtBQUNBLGdCQUFJQyxjQUFjLEVBQWxCO0FBQ0EsZ0JBQUlDLGNBQWMsTUFBTU4sS0FBS0ksTUFBTCxHQUFjLENBQXBCLENBQWxCO0FBQ0EsbUJBQU8sdUJBQ0hoQixpQkFBZUksSUFBZix5Q0FBeUQsSUFBekQsQ0FERyxFQUVILG9DQUFZQSxTQUFTLE1BQVQsR0FBa0IsR0FBbEIsR0FBd0IsR0FBcEMsOENBQ0UsdUJBQUUsTUFBRixFQUFVLEVBQUNlLFNBQVM7QUFBQSwyQkFBSyxNQUFLaEIsTUFBTCxHQUFjLENBQUMsTUFBS0EsTUFBekI7QUFBQSxpQkFBVixFQUFWLEVBQXNEVSxHQUF0RCxFQUEyREEsR0FBM0QsRUFBZ0VBLEdBQWhFLEVBQXFFQSxHQUFyRSxDQURGLENBRkcsRUFJSCw2QkFBTVQsSUFBTiwyQ0FDRSx1QkFBRSxnQkFBRixFQUFvQkssS0FBcEIsQ0FERixDQUpHLEVBTUgsK0JBQU9MLFNBQVMsT0FBVCxHQUFtQixvQkFBbkIsR0FBMEMsRUFBakQsa0JBQ0VRLEtBQUtRLEdBQUwsQ0FBUyxhQUFLO0FBQ1ZDLGtCQUFFYixLQUFGLENBQVFjLEtBQVIsR0FBZ0JELEVBQUViLEtBQUYsQ0FBUWMsS0FBUixHQUFnQixlQUFoQztBQUNBRCxrQkFBRWIsS0FBRixDQUFRRyxlQUFSLEdBQTBCQSxlQUExQjtBQUNBLG9CQUFJWSxLQUFLRixFQUFFYixLQUFGLENBQVFlLEVBQWpCO0FBQ0E7QUFDSTtBQUNBO0FBQ0osdUJBQU8sdUJBQ0gsSUFERyxFQUVILEVBQUNELE9BQU8sRUFBQ1AsT0FBT0EsUUFBUSxHQUFoQixFQUFxQixhQUFhLE9BQWxDLEVBQVI7QUFDQ1MsaUNBQWE7QUFBQSwrQkFBSyxNQUFLQyxVQUFMLEdBQWtCRixFQUF2QjtBQUFBLHFCQURkO0FBRUNHLGdDQUFZO0FBQUEsK0JBQUssTUFBS0QsVUFBTCxHQUFrQixJQUF2QjtBQUFBLHFCQUZiLEVBRkcsRUFLSEosQ0FMRyxDQUFQO0FBTUgsYUFiRCxDQURGLENBTkcsRUFxQkgsdUJBQUVyQixXQUFXLFlBQVgsRUFBeUIsSUFBekIsQ0FBRixFQUNFLDZCQUFNSSxJQUFOLG1CQUNFLDZCQUFNQSxJQUFOLHFFQUE0RUcsTUFBTW9CLFFBQWxGLENBREYsQ0FERixDQXJCRyxDQUFQO0FBd0JIOzs7Ozs7a0JBR1VyQixLIiwiZmlsZSI6IjcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbSBmcm9tICdtaXRocmlsJztcblxuaW1wb3J0ICogYXMgYXBwIGZyb20gJy4uL2FwcCc7XG5cbmV4cG9ydCBsZXQgZ2V0Q2xhc3NlcyA9IGZ1bmN0aW9uKGNscywgcGFuZWwpIHtcbiAgICByZXR1cm4gY2xzICsgKHBhbmVsLmNsb3NlZCA/ICcuY2xvc2VwYW5lbCcgOlxuICAgICAgICAocGFuZWwuc2lkZSA9PT0gJ2xlZnQnICYmIGFwcC5sZWZ0dGFiID09PSAndGFiMicpID8gJy5leHBhbmRwYW5lbCcgOlxuICAgICAgICAnJyk7XG59O1xuXG5jbGFzcyBQYW5lbCB7XG4gICAgb25pbml0KHZub2RlKSB7XG4gICAgICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmlldyh2bm9kZSkge1xuICAgICAgICBsZXQge3NpZGUsIHRpdGxlLCBidXR0b25zLCBpc19leHBsb3JlX21vZGV9ID0gdm5vZGUuYXR0cnM7XG4gICAgICAgIGxldCBidG5zID0gYnV0dG9ucztcbiAgICAgICAgbGV0IGRvdCA9IFttLnRydXN0KCcmIzk2Nzk7JyksIG0oJ2JyJyldO1xuICAgICAgICBsZXQgd2lkdGggPSAxMDAgLyBidG5zLmxlbmd0aDtcbiAgICAgICAgbGV0IGV4cGFuZHdpZHRoID0gMzU7XG4gICAgICAgIGxldCBzaHJpbmt3aWR0aCA9IDY1IC8gKGJ0bnMubGVuZ3RoIC0gMSk7XG4gICAgICAgIHJldHVybiBtKFxuICAgICAgICAgICAgZ2V0Q2xhc3NlcyhgIyR7c2lkZX1wYW5lbC5zaWRlcGFuZWwuY29udGFpbmVyLmNsZWFyZml4YCwgdGhpcyksXG4gICAgICAgICAgICBtKGAjdG9nZ2xlJHtzaWRlID09PSAnbGVmdCcgPyAnTCcgOiAnUid9cGFuZWxpY29uLnBhbmVsYmFyW3N0eWxlPWhlaWdodDogMTAwJV1gLFxuICAgICAgICAgICAgICBtKCdzcGFuJywge29uY2xpY2s6IF8gPT4gdGhpcy5jbG9zZWQgPSAhdGhpcy5jbG9zZWR9LCBkb3QsIGRvdCwgZG90LCBkb3QpKSxcbiAgICAgICAgICAgIG0oYCMke3NpZGV9cGFuZWx0aXRsZS5wYW5lbC1oZWFkaW5nLnRleHQtY2VudGVyYCxcbiAgICAgICAgICAgICAgbShcImgzLnBhbmVsLXRpdGxlXCIsIHRpdGxlKSksXG4gICAgICAgICAgICBtKGB1bCR7c2lkZSA9PT0gJ3JpZ2h0JyA/ICcjcmlnaHRwYW5lbGJ1dHRvbnMnIDogJyd9LmFjY29yZGlvbmAsXG4gICAgICAgICAgICAgIGJ0bnMubWFwKGIgPT4ge1xuICAgICAgICAgICAgICAgICAgYi5hdHRycy5zdHlsZSA9IGIuYXR0cnMuc3R5bGUgKyAnOyB3aWR0aDogMTAwJSc7XG4gICAgICAgICAgICAgICAgICBiLmF0dHJzLmlzX2V4cGxvcmVfbW9kZSA9IGlzX2V4cGxvcmVfbW9kZTtcbiAgICAgICAgICAgICAgICAgIGxldCBpZCA9IGIuYXR0cnMuaWQ7XG4gICAgICAgICAgICAgICAgICAvL2xldCB3ID0gdGhpcy5hY3RpdmVfYnRuID09PSBpZCA/IHNocmlua3dpZHRoIDpcbiAgICAgICAgICAgICAgICAgICAgICAvL3RoaXMuYWN0aXZlX2J0biA9PT0gbnVsbCA/IHdpZHRoIDpcbiAgICAgICAgICAgICAgICAgICAgICAvL2V4cGFuZHdpZHRoO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG0oXG4gICAgICAgICAgICAgICAgICAgICAgJ2xpJyxcbiAgICAgICAgICAgICAgICAgICAgICB7c3R5bGU6IHt3aWR0aDogd2lkdGggKyAnJScsICdtYXgtd2lkdGgnOiAnMTUwcHgnfSxcbiAgICAgICAgICAgICAgICAgICAgICAgb25tb3VzZW92ZXI6IF8gPT4gdGhpcy5hY3RpdmVfYnRuID0gaWQsXG4gICAgICAgICAgICAgICAgICAgICAgIG9ubW91c2VvdXQ6IF8gPT4gdGhpcy5hY3RpdmVfYnRuID0gbnVsbH0sXG4gICAgICAgICAgICAgICAgICAgICAgYik7XG4gICAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgIG0oZ2V0Q2xhc3NlcygnLnJvdy1mbHVpZCcsIHRoaXMpLFxuICAgICAgICAgICAgICBtKGAjJHtzaWRlfXBhbmVsY29udGVudGAsXG4gICAgICAgICAgICAgICAgbShgIyR7c2lkZX1Db250ZW50QXJlYVtzdHlsZT1oZWlnaHQ6IGNhbGMoMTAwdmggLSAyMTNweCk7IG92ZXJmbG93OiBhdXRvXWAsIHZub2RlLmNoaWxkcmVuKSkpKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBhbmVsO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYXNzZXRzL2FwcC92aWV3cy9QYW5lbC5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.when = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mithril = __webpack_require__(0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _app = __webpack_require__(1);\n\nvar app = _interopRequireWildcard(_app);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar when = exports.when = function when(side, val) {\n    var y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'block';\n    var n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'none';\n\n    return app[side + 'tab'] === val ? y : n;\n};\n\nvar PanelButton = function () {\n    function PanelButton() {\n        _classCallCheck(this, PanelButton);\n    }\n\n    _createClass(PanelButton, [{\n        key: 'view',\n        value: function view(vnode) {\n            var _vnode$attrs = vnode.attrs,\n                id = _vnode$attrs.id,\n                id2 = _vnode$attrs.id2,\n                classes = _vnode$attrs.classes,\n                onclick = _vnode$attrs.onclick,\n                style = _vnode$attrs.style,\n                title = _vnode$attrs.title,\n                is_explore_mode = _vnode$attrs.is_explore_mode;\n\n            var left = id2 ? true : false;\n            id2 = id2 || id;\n            var disabled = is_explore_mode && !app.explored;\n            return (0, _mithril2.default)('button#' + id + '.btn.' + (classes || when(left ? 'left' : 'right', id2, 'active', disabled ? 'btn.disabled' : 'btn-default')) + '[type=button]', {\n                onclick: onclick || function (_) {\n                    return left ? app.probDiscView(id2) : disabled || app.tabRight(id2);\n                },\n                style: style,\n                title: title }, vnode.children);\n        }\n    }]);\n\n    return PanelButton;\n}();\n\nexports.default = PanelButton;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvYXBwL3ZpZXdzL1BhbmVsQnV0dG9uLmpzP2M4NTciXSwibmFtZXMiOlsiYXBwIiwid2hlbiIsInNpZGUiLCJ2YWwiLCJ5IiwibiIsIlBhbmVsQnV0dG9uIiwidm5vZGUiLCJhdHRycyIsImlkIiwiaWQyIiwiY2xhc3NlcyIsIm9uY2xpY2siLCJzdHlsZSIsInRpdGxlIiwiaXNfZXhwbG9yZV9tb2RlIiwibGVmdCIsImRpc2FibGVkIiwiZXhwbG9yZWQiLCJwcm9iRGlzY1ZpZXciLCJ0YWJSaWdodCIsImNoaWxkcmVuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTs7OztBQUVBOztJQUFZQSxHOzs7Ozs7OztBQUVMLElBQUlDLHNCQUFPLFNBQVBBLElBQU8sQ0FBU0MsSUFBVCxFQUFlQyxHQUFmLEVBQXlDO0FBQUEsUUFBckJDLENBQXFCLHVFQUFuQixPQUFtQjtBQUFBLFFBQVZDLENBQVUsdUVBQVIsTUFBUTs7QUFDdkQsV0FBT0wsSUFBSUUsT0FBTyxLQUFYLE1BQXNCQyxHQUF0QixHQUE0QkMsQ0FBNUIsR0FBZ0NDLENBQXZDO0FBQ0gsQ0FGTTs7SUFJREMsVzs7Ozs7Ozs2QkFDR0MsSyxFQUFPO0FBQUEsK0JBQ3lEQSxNQUFNQyxLQUQvRDtBQUFBLGdCQUNIQyxFQURHLGdCQUNIQSxFQURHO0FBQUEsZ0JBQ0NDLEdBREQsZ0JBQ0NBLEdBREQ7QUFBQSxnQkFDTUMsT0FETixnQkFDTUEsT0FETjtBQUFBLGdCQUNlQyxPQURmLGdCQUNlQSxPQURmO0FBQUEsZ0JBQ3dCQyxLQUR4QixnQkFDd0JBLEtBRHhCO0FBQUEsZ0JBQytCQyxLQUQvQixnQkFDK0JBLEtBRC9CO0FBQUEsZ0JBQ3NDQyxlQUR0QyxnQkFDc0NBLGVBRHRDOztBQUVSLGdCQUFJQyxPQUFPTixNQUFNLElBQU4sR0FBYSxLQUF4QjtBQUNBQSxrQkFBTUEsT0FBT0QsRUFBYjtBQUNBLGdCQUFJUSxXQUFXRixtQkFBbUIsQ0FBQ2YsSUFBSWtCLFFBQXZDO0FBQ0EsbUJBQU8sbUNBQ09ULEVBRFAsY0FDaUJFLFdBQVdWLEtBQUtlLE9BQU8sTUFBUCxHQUFnQixPQUFyQixFQUE4Qk4sR0FBOUIsRUFBbUMsUUFBbkMsRUFBNkNPLFdBQVcsY0FBWCxHQUE0QixhQUF6RSxDQUQ1QixxQkFDb0k7QUFDdklMLHlCQUFTQSxXQUFZO0FBQUEsMkJBQUtJLE9BQU9oQixJQUFJbUIsWUFBSixDQUFpQlQsR0FBakIsQ0FBUCxHQUErQk8sWUFBWWpCLElBQUlvQixRQUFKLENBQWFWLEdBQWIsQ0FBaEQ7QUFBQSxpQkFEa0g7QUFFdklHLHVCQUFPQSxLQUZnSTtBQUd2SUMsdUJBQU9BLEtBSGdJLEVBRHBJLEVBS0hQLE1BQU1jLFFBTEgsQ0FBUDtBQU1IOzs7Ozs7a0JBR1VmLFciLCJmaWxlIjoiOC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuXG5pbXBvcnQgKiBhcyBhcHAgZnJvbSAnLi4vYXBwJztcblxuZXhwb3J0IGxldCB3aGVuID0gZnVuY3Rpb24oc2lkZSwgdmFsLCB5PSdibG9jaycsIG49J25vbmUnKSB7XG4gICAgcmV0dXJuIGFwcFtzaWRlICsgJ3RhYiddID09PSB2YWwgPyB5IDogbjtcbn07XG5cbmNsYXNzIFBhbmVsQnV0dG9uIHtcbiAgICB2aWV3KHZub2RlKSB7XG4gICAgICAgIGxldCB7aWQsIGlkMiwgY2xhc3Nlcywgb25jbGljaywgc3R5bGUsIHRpdGxlLCBpc19leHBsb3JlX21vZGV9ID0gdm5vZGUuYXR0cnM7XG4gICAgICAgIGxldCBsZWZ0ID0gaWQyID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgICBpZDIgPSBpZDIgfHwgaWQ7XG4gICAgICAgIGxldCBkaXNhYmxlZCA9IGlzX2V4cGxvcmVfbW9kZSAmJiAhYXBwLmV4cGxvcmVkO1xuICAgICAgICByZXR1cm4gbShcbiAgICAgICAgICAgIGBidXR0b24jJHtpZH0uYnRuLiR7Y2xhc3NlcyB8fCB3aGVuKGxlZnQgPyAnbGVmdCcgOiAncmlnaHQnLCBpZDIsICdhY3RpdmUnLCBkaXNhYmxlZCA/ICdidG4uZGlzYWJsZWQnIDogJ2J0bi1kZWZhdWx0Jyl9W3R5cGU9YnV0dG9uXWAsIHtcbiAgICAgICAgICAgIG9uY2xpY2s6IG9uY2xpY2sgfHwgKF8gPT4gbGVmdCA/IGFwcC5wcm9iRGlzY1ZpZXcoaWQyKSA6IGRpc2FibGVkIHx8IGFwcC50YWJSaWdodChpZDIpKSxcbiAgICAgICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgICAgIHRpdGxlOiB0aXRsZX0sXG4gICAgICAgICAgICB2bm9kZS5jaGlsZHJlbik7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBQYW5lbEJ1dHRvbjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Fzc2V0cy9hcHAvdmlld3MvUGFuZWxCdXR0b24uanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mithril = __webpack_require__(0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _app = __webpack_require__(1);\n\nvar app = _interopRequireWildcard(_app);\n\nvar _plots = __webpack_require__(2);\n\nvar plots = _interopRequireWildcard(_plots);\n\nvar _Search = __webpack_require__(3);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar PanelList = function () {\n    function PanelList() {\n        _classCallCheck(this, PanelList);\n    }\n\n    _createClass(PanelList, [{\n        key: 'view',\n        value: function view(vnode) {\n            var _vnode$attrs = vnode.attrs,\n                items = _vnode$attrs.items,\n                content = _vnode$attrs.content,\n                title = _vnode$attrs.title,\n                probDesc = _vnode$attrs.probDesc;\n\n            return (0, _mithril2.default)('#varList[style=display: block]', items.map(function (v, i) {\n                return (0, _mithril2.default)('p#' + v.replace(/\\W/g, '_'), {\n                    class: probDesc ? app.d3mProblemDescription[probDesc] === v ? 'item-select' : app.locktoggle ? 'item-default item-lineout' : 'item-default' : '',\n                    style: {\n                        'background-color': probDesc ? '' : app.zparams.zdv.includes(v) ? app.hexToRgba(app.dvColor) : app.zparams.znom.includes(v) ? app.hexToRgba(app.nomColor) : app.nodes.map(function (n) {\n                            return n.name;\n                        }).includes(v) ? app.hexToRgba(plots.selVarColor) : app.varColor,\n                        'border-color': '#000000',\n                        'border-style': !probDesc && _Search.searchIndex && i < _Search.searchIndex ? 'solid' : 'none'\n                    },\n                    onclick: probDesc || app.clickVar,\n                    onmouseover: function onmouseover() {\n                        $(this).popover('toggle');\n                        if (probDesc) return;\n                        $(\"body div.popover\").addClass(\"variables\");\n                        $(\"body div.popover div.popover-content\").addClass(\"form-horizontal\");\n                    },\n                    onmouseout: \"$(this).popover('toggle');\",\n                    'data-container': 'body',\n                    'data-content': content ? content(v) : app.popoverContent(app.findNodeIndex(v, true)),\n                    'data-html': 'true',\n                    'data-original-title': title,\n                    'data-placement': probDesc ? 'top' : 'right',\n                    'data-toggle': 'popover',\n                    'data-trigger': 'hover' }, v);\n            }));\n        }\n    }]);\n\n    return PanelList;\n}();\n\nexports.default = PanelList;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvYXBwL3ZpZXdzL1BhbmVsTGlzdC5qcz9mNjE3Il0sIm5hbWVzIjpbImFwcCIsInBsb3RzIiwiUGFuZWxMaXN0Iiwidm5vZGUiLCJhdHRycyIsIml0ZW1zIiwiY29udGVudCIsInRpdGxlIiwicHJvYkRlc2MiLCJtYXAiLCJ2IiwiaSIsInJlcGxhY2UiLCJjbGFzcyIsImQzbVByb2JsZW1EZXNjcmlwdGlvbiIsImxvY2t0b2dnbGUiLCJzdHlsZSIsInpwYXJhbXMiLCJ6ZHYiLCJpbmNsdWRlcyIsImhleFRvUmdiYSIsImR2Q29sb3IiLCJ6bm9tIiwibm9tQ29sb3IiLCJub2RlcyIsIm4iLCJuYW1lIiwic2VsVmFyQ29sb3IiLCJ2YXJDb2xvciIsIm9uY2xpY2siLCJjbGlja1ZhciIsIm9ubW91c2VvdmVyIiwiJCIsInBvcG92ZXIiLCJhZGRDbGFzcyIsIm9ubW91c2VvdXQiLCJwb3BvdmVyQ29udGVudCIsImZpbmROb2RlSW5kZXgiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7Ozs7QUFFQTs7SUFBWUEsRzs7QUFDWjs7SUFBWUMsSzs7QUFFWjs7Ozs7Ozs7SUFFTUMsUzs7Ozs7Ozs2QkFDR0MsSyxFQUFPO0FBQUEsK0JBQ2dDQSxNQUFNQyxLQUR0QztBQUFBLGdCQUNIQyxLQURHLGdCQUNIQSxLQURHO0FBQUEsZ0JBQ0lDLE9BREosZ0JBQ0lBLE9BREo7QUFBQSxnQkFDYUMsS0FEYixnQkFDYUEsS0FEYjtBQUFBLGdCQUNvQkMsUUFEcEIsZ0JBQ29CQSxRQURwQjs7QUFFUixtQkFBTyx1QkFDSCxnQ0FERyxFQUVISCxNQUFNSSxHQUFOLENBQVUsVUFBQ0MsQ0FBRCxFQUFJQyxDQUFKO0FBQUEsdUJBQ0EsOEJBQU9ELEVBQUVFLE9BQUYsQ0FBVSxLQUFWLEVBQWlCLEdBQWpCLENBQVAsRUFBZ0M7QUFDNUJDLDJCQUFPTCxXQUNGUixJQUFJYyxxQkFBSixDQUEwQk4sUUFBMUIsTUFBd0NFLENBQXhDLEdBQTRDLGFBQTVDLEdBQ0FWLElBQUllLFVBQUosR0FBaUIsMkJBQWpCLEdBQ0EsY0FIRSxHQUdnQixFQUpLO0FBSzVCQywyQkFBTztBQUNILDRDQUFvQlIsV0FBVyxFQUFYLEdBQ2hCUixJQUFJaUIsT0FBSixDQUFZQyxHQUFaLENBQWdCQyxRQUFoQixDQUF5QlQsQ0FBekIsSUFBOEJWLElBQUlvQixTQUFKLENBQWNwQixJQUFJcUIsT0FBbEIsQ0FBOUIsR0FDQXJCLElBQUlpQixPQUFKLENBQVlLLElBQVosQ0FBaUJILFFBQWpCLENBQTBCVCxDQUExQixJQUErQlYsSUFBSW9CLFNBQUosQ0FBY3BCLElBQUl1QixRQUFsQixDQUEvQixHQUNBdkIsSUFBSXdCLEtBQUosQ0FBVWYsR0FBVixDQUFjO0FBQUEsbUNBQUtnQixFQUFFQyxJQUFQO0FBQUEseUJBQWQsRUFBMkJQLFFBQTNCLENBQW9DVCxDQUFwQyxJQUF5Q1YsSUFBSW9CLFNBQUosQ0FBY25CLE1BQU0wQixXQUFwQixDQUF6QyxHQUNBM0IsSUFBSTRCLFFBTEw7QUFNSCx3Q0FBZ0IsU0FOYjtBQU9ILHdDQUFnQixDQUFDcEIsUUFBRCwyQkFBNEJHLHVCQUE1QixHQUE4QyxPQUE5QyxHQUF3RDtBQVByRSxxQkFMcUI7QUFjNUJrQiw2QkFBU3JCLFlBQVlSLElBQUk4QixRQWRHO0FBZTVCQyxpQ0FBYSx1QkFBVztBQUNwQkMsMEJBQUUsSUFBRixFQUFRQyxPQUFSLENBQWdCLFFBQWhCO0FBQ0EsNEJBQUl6QixRQUFKLEVBQWM7QUFDZHdCLDBCQUFFLGtCQUFGLEVBQ0tFLFFBREwsQ0FDYyxXQURkO0FBRUFGLDBCQUFFLHNDQUFGLEVBQ0tFLFFBREwsQ0FDYyxpQkFEZDtBQUVILHFCQXRCMkI7QUF1QjVCQyxnQ0FBWSw0QkF2QmdCO0FBd0I1QixzQ0FBa0IsTUF4QlU7QUF5QjVCLG9DQUFnQjdCLFVBQVVBLFFBQVFJLENBQVIsQ0FBVixHQUF1QlYsSUFBSW9DLGNBQUosQ0FBbUJwQyxJQUFJcUMsYUFBSixDQUFrQjNCLENBQWxCLEVBQXFCLElBQXJCLENBQW5CLENBekJYO0FBMEI1QixpQ0FBYSxNQTFCZTtBQTJCNUIsMkNBQXVCSCxLQTNCSztBQTRCNUIsc0NBQWtCQyxXQUFXLEtBQVgsR0FBbUIsT0E1QlQ7QUE2QjVCLG1DQUFlLFNBN0JhO0FBOEI1QixvQ0FBZ0IsT0E5QlksRUFBaEMsRUErQkVFLENBL0JGLENBREE7QUFBQSxhQUFWLENBRkcsQ0FBUDtBQW1DSDs7Ozs7O2tCQUdVUixTIiwiZmlsZSI6IjkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbSBmcm9tICdtaXRocmlsJztcblxuaW1wb3J0ICogYXMgYXBwIGZyb20gJy4uL2FwcCc7XG5pbXBvcnQgKiBhcyBwbG90cyBmcm9tICcuLi9wbG90cyc7XG5cbmltcG9ydCB7c2VhcmNoSW5kZXh9IGZyb20gJy4vU2VhcmNoJztcblxuY2xhc3MgUGFuZWxMaXN0IHtcbiAgICB2aWV3KHZub2RlKSB7XG4gICAgICAgIGxldCB7aXRlbXMsIGNvbnRlbnQsIHRpdGxlLCBwcm9iRGVzY30gPSB2bm9kZS5hdHRycztcbiAgICAgICAgcmV0dXJuIG0oXG4gICAgICAgICAgICAnI3Zhckxpc3Rbc3R5bGU9ZGlzcGxheTogYmxvY2tdJyxcbiAgICAgICAgICAgIGl0ZW1zLm1hcCgodiwgaSkgPT5cbiAgICAgICAgICAgICAgICAgICAgICBtKGBwIyR7di5yZXBsYWNlKC9cXFcvZywgJ18nKX1gLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOiBwcm9iRGVzYyA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYXBwLmQzbVByb2JsZW1EZXNjcmlwdGlvbltwcm9iRGVzY10gPT09IHYgPyAnaXRlbS1zZWxlY3QnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHAubG9ja3RvZ2dsZSA/ICdpdGVtLWRlZmF1bHQgaXRlbS1saW5lb3V0JyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2l0ZW0tZGVmYXVsdCcpIDogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnYmFja2dyb3VuZC1jb2xvcic6IHByb2JEZXNjID8gJycgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcC56cGFyYW1zLnpkdi5pbmNsdWRlcyh2KSA/IGFwcC5oZXhUb1JnYmEoYXBwLmR2Q29sb3IpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHAuenBhcmFtcy56bm9tLmluY2x1ZGVzKHYpID8gYXBwLmhleFRvUmdiYShhcHAubm9tQ29sb3IpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHAubm9kZXMubWFwKG4gPT4gbi5uYW1lKS5pbmNsdWRlcyh2KSA/IGFwcC5oZXhUb1JnYmEocGxvdHMuc2VsVmFyQ29sb3IpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHAudmFyQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnYm9yZGVyLWNvbG9yJzogJyMwMDAwMDAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2JvcmRlci1zdHlsZSc6ICFwcm9iRGVzYyAmJiBzZWFyY2hJbmRleCAmJiBpIDwgc2VhcmNoSW5kZXggPyAnc29saWQnIDogJ25vbmUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9uY2xpY2s6IHByb2JEZXNjIHx8IGFwcC5jbGlja1ZhcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb25tb3VzZW92ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5wb3BvdmVyKCd0b2dnbGUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9iRGVzYykgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJChcImJvZHkgZGl2LnBvcG92ZXJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoXCJ2YXJpYWJsZXNcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKFwiYm9keSBkaXYucG9wb3ZlciBkaXYucG9wb3Zlci1jb250ZW50XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKFwiZm9ybS1ob3Jpem9udGFsXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBvbm1vdXNlb3V0OiBcIiQodGhpcykucG9wb3ZlcigndG9nZ2xlJyk7XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhLWNvbnRhaW5lcic6ICdib2R5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEtY29udGVudCc6IGNvbnRlbnQgPyBjb250ZW50KHYpIDogYXBwLnBvcG92ZXJDb250ZW50KGFwcC5maW5kTm9kZUluZGV4KHYsIHRydWUpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEtaHRtbCc6ICd0cnVlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEtb3JpZ2luYWwtdGl0bGUnOiB0aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEtcGxhY2VtZW50JzogcHJvYkRlc2MgPyAndG9wJyA6ICdyaWdodCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhLXRvZ2dsZSc6ICdwb3BvdmVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEtdHJpZ2dlcic6ICdob3Zlcid9LFxuICAgICAgICAgICAgICAgICAgICAgICAgdikpKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBhbmVsTGlzdDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Fzc2V0cy9hcHAvdmlld3MvUGFuZWxMaXN0LmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mithril = __webpack_require__(0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _app = __webpack_require__(1);\n\nvar app = _interopRequireWildcard(_app);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Subpanel = function () {\n    function Subpanel() {\n        _classCallCheck(this, Subpanel);\n    }\n\n    _createClass(Subpanel, [{\n        key: 'oninit',\n        value: function oninit(vnode) {\n            this.hide = false;\n        }\n    }, {\n        key: 'view',\n        value: function view(vnode) {\n            var _this = this;\n\n            var title = vnode.attrs.title;\n            var legend = title === 'Legend';\n            var target = 'collapse' + title;\n            var z = app.zparams;\n            return (0, _mithril2.default)('#' + (legend ? \"legend.legendary\" : \"logdiv.logbox\") + '.panel.panel-default', {\n                style: { display: legend && z.ztime.length + z.zcross.length + z.zdv.length + z.znom.length || !legend && app.logArray.length > 0 ? 'block' : 'none' } }, (0, _mithril2.default)(\".panel-heading\", (0, _mithril2.default)(\"h3.panel-title\", title, (0, _mithril2.default)('span.glyphicon.glyphicon-large.glyphicon-chevron-' + (this.hide ? 'up' : 'down') + '.pull-right[data-target=#' + target + '][data-toggle=collapse][href=#' + target + ']', {\n                style: 'cursor: pointer',\n                onclick: function onclick(_) {\n                    return _this.hide = !_this.hide;\n                } }))), (0, _mithril2.default)('#' + target + '.panel-collapse.collapse.in', (0, _mithril2.default)(\".panel-body\", !legend ? app.logArray.map(function (x) {\n                return (0, _mithril2.default)('p', x);\n            }) : vnode.attrs.buttons.map(function (x) {\n                return (0, _mithril2.default)('#' + x[0] + '.clearfix.' + (z[x[1]].length === 0 ? \"hide\" : \"show\"), (0, _mithril2.default)(\".rectColor\", (0, _mithril2.default)(\"svg[style=width: 20px; height: 20px]\", (0, _mithril2.default)(\"circle[cx=10][cy=10][fill=white][r=9][stroke=black][stroke-width=2]\"))), (0, _mithril2.default)(\".rectLabel\", x[2]));\n            }))));\n        }\n    }]);\n\n    return Subpanel;\n}();\n\nexports.default = Subpanel;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvYXBwL3ZpZXdzL1N1YnBhbmVsLmpzP2ViYWIiXSwibmFtZXMiOlsiYXBwIiwiU3VicGFuZWwiLCJ2bm9kZSIsImhpZGUiLCJ0aXRsZSIsImF0dHJzIiwibGVnZW5kIiwidGFyZ2V0IiwieiIsInpwYXJhbXMiLCJzdHlsZSIsImRpc3BsYXkiLCJ6dGltZSIsImxlbmd0aCIsInpjcm9zcyIsInpkdiIsInpub20iLCJsb2dBcnJheSIsIm9uY2xpY2siLCJtYXAiLCJ4IiwiYnV0dG9ucyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7OztBQUVBOztJQUFZQSxHOzs7Ozs7OztJQUVOQyxROzs7Ozs7OytCQUNLQyxLLEVBQU87QUFDVixpQkFBS0MsSUFBTCxHQUFZLEtBQVo7QUFDSDs7OzZCQUVJRCxLLEVBQU87QUFBQTs7QUFDUixnQkFBSUUsUUFBUUYsTUFBTUcsS0FBTixDQUFZRCxLQUF4QjtBQUNBLGdCQUFJRSxTQUFTRixVQUFVLFFBQXZCO0FBQ0EsZ0JBQUlHLFNBQVMsYUFBYUgsS0FBMUI7QUFDQSxnQkFBSUksSUFBSVIsSUFBSVMsT0FBWjtBQUNBLG1CQUFPLDhCQUFNSCxTQUFTLGtCQUFULEdBQThCLGVBQXBDLDRCQUEyRTtBQUM5RUksdUJBQU8sRUFBQ0MsU0FBU0wsVUFBVUUsRUFBRUksS0FBRixDQUFRQyxNQUFSLEdBQWlCTCxFQUFFTSxNQUFGLENBQVNELE1BQTFCLEdBQW1DTCxFQUFFTyxHQUFGLENBQU1GLE1BQXpDLEdBQWtETCxFQUFFUSxJQUFGLENBQU9ILE1BQW5FLElBQTZFLENBQUNQLE1BQUQsSUFBV04sSUFBSWlCLFFBQUosQ0FBYUosTUFBYixHQUFzQixDQUE5RyxHQUFrSCxPQUFsSCxHQUE0SCxNQUF0SSxFQUR1RSxFQUEzRSxFQUVFLHVCQUFFLGdCQUFGLEVBQ0UsdUJBQUUsZ0JBQUYsRUFDRVQsS0FERixFQUVFLDhFQUFzRCxLQUFLRCxJQUFMLEdBQVksSUFBWixHQUFrQixNQUF4RSxrQ0FBMEdJLE1BQTFHLHNDQUFpSkEsTUFBakosUUFBNEo7QUFDeEpHLHVCQUFPLGlCQURpSjtBQUV4SlEseUJBQVM7QUFBQSwyQkFBSyxNQUFLZixJQUFMLEdBQVksQ0FBQyxNQUFLQSxJQUF2QjtBQUFBLGlCQUYrSSxFQUE1SixDQUZGLENBREYsQ0FGRixFQVFFLDZCQUFNSSxNQUFOLGtDQUNFLHVCQUFFLGFBQUYsRUFBaUIsQ0FBQ0QsTUFBRCxHQUFVTixJQUFJaUIsUUFBSixDQUFhRSxHQUFiLENBQWlCO0FBQUEsdUJBQUssdUJBQUUsR0FBRixFQUFPQyxDQUFQLENBQUw7QUFBQSxhQUFqQixDQUFWLEdBQTZDbEIsTUFBTUcsS0FBTixDQUFZZ0IsT0FBWixDQUFvQkYsR0FBcEIsQ0FBd0IsYUFBSztBQUN2Rix1QkFBTyw2QkFBTUMsRUFBRSxDQUFGLENBQU4sbUJBQXVCWixFQUFFWSxFQUFFLENBQUYsQ0FBRixFQUFRUCxNQUFSLEtBQW1CLENBQW5CLEdBQXVCLE1BQXZCLEdBQWdDLE1BQXZELEdBQ0UsdUJBQUUsWUFBRixFQUNFLHVCQUFFLHNDQUFGLEVBQ0UsdUJBQUUscUVBQUYsQ0FERixDQURGLENBREYsRUFJRSx1QkFBRSxZQUFGLEVBQWdCTyxFQUFFLENBQUYsQ0FBaEIsQ0FKRixDQUFQO0FBSWlDLGFBTHlCLENBQTlELENBREYsQ0FSRixDQUFQO0FBZUg7Ozs7OztrQkFHVW5CLFEiLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbSBmcm9tICdtaXRocmlsJztcblxuaW1wb3J0ICogYXMgYXBwIGZyb20gJy4uL2FwcCc7XG5cbmNsYXNzIFN1YnBhbmVsIHtcbiAgICBvbmluaXQodm5vZGUpIHtcbiAgICAgICAgdGhpcy5oaWRlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmlldyh2bm9kZSkge1xuICAgICAgICBsZXQgdGl0bGUgPSB2bm9kZS5hdHRycy50aXRsZTtcbiAgICAgICAgbGV0IGxlZ2VuZCA9IHRpdGxlID09PSAnTGVnZW5kJztcbiAgICAgICAgbGV0IHRhcmdldCA9ICdjb2xsYXBzZScgKyB0aXRsZTtcbiAgICAgICAgbGV0IHogPSBhcHAuenBhcmFtcztcbiAgICAgICAgcmV0dXJuIG0oYCMke2xlZ2VuZCA/IFwibGVnZW5kLmxlZ2VuZGFyeVwiIDogXCJsb2dkaXYubG9nYm94XCJ9LnBhbmVsLnBhbmVsLWRlZmF1bHRgLCB7XG4gICAgICAgICAgICBzdHlsZToge2Rpc3BsYXk6IGxlZ2VuZCAmJiB6Lnp0aW1lLmxlbmd0aCArIHouemNyb3NzLmxlbmd0aCArIHouemR2Lmxlbmd0aCArIHouem5vbS5sZW5ndGggfHwgIWxlZ2VuZCAmJiBhcHAubG9nQXJyYXkubGVuZ3RoID4gMCA/ICdibG9jaycgOiAnbm9uZSd9fSxcbiAgICAgICAgICAgICAgICAgbShcIi5wYW5lbC1oZWFkaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgbShcImgzLnBhbmVsLXRpdGxlXCIsXG4gICAgICAgICAgICAgICAgICAgICB0aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgIG0oYHNwYW4uZ2x5cGhpY29uLmdseXBoaWNvbi1sYXJnZS5nbHlwaGljb24tY2hldnJvbi0ke3RoaXMuaGlkZSA/ICd1cCc6ICdkb3duJ30ucHVsbC1yaWdodFtkYXRhLXRhcmdldD0jJHt0YXJnZXR9XVtkYXRhLXRvZ2dsZT1jb2xsYXBzZV1baHJlZj0jJHt0YXJnZXR9XWAsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogJ2N1cnNvcjogcG9pbnRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgb25jbGljazogXyA9PiB0aGlzLmhpZGUgPSAhdGhpcy5oaWRlfSkpKSxcbiAgICAgICAgICAgICAgICAgbShgIyR7dGFyZ2V0fS5wYW5lbC1jb2xsYXBzZS5jb2xsYXBzZS5pbmAsXG4gICAgICAgICAgICAgICAgICAgbShcIi5wYW5lbC1ib2R5XCIsICFsZWdlbmQgPyBhcHAubG9nQXJyYXkubWFwKHggPT4gbSgncCcsIHgpKSA6IHZub2RlLmF0dHJzLmJ1dHRvbnMubWFwKHggPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbShgIyR7eFswXX0uY2xlYXJmaXguJHt6W3hbMV1dLmxlbmd0aCA9PT0gMCA/IFwiaGlkZVwiIDogXCJzaG93XCJ9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbShcIi5yZWN0Q29sb3JcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKFwic3ZnW3N0eWxlPXdpZHRoOiAyMHB4OyBoZWlnaHQ6IDIwcHhdXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKFwiY2lyY2xlW2N4PTEwXVtjeT0xMF1bZmlsbD13aGl0ZV1bcj05XVtzdHJva2U9YmxhY2tdW3N0cm9rZS13aWR0aD0yXVwiKSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKFwiLnJlY3RMYWJlbFwiLCB4WzJdKSk7fSkpKSk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBTdWJwYW5lbDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Fzc2V0cy9hcHAvdmlld3MvU3VicGFuZWwuanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///10\n")},function(module,exports){eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvY3NzL2FwcC5jc3M/MmY3ZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIxMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hc3NldHMvY3NzL2FwcC5jc3Ncbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///11\n")},function(module,exports){eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvcGtncy9MYWRkYS9kaXN0L2xhZGRhLXRoZW1lbGVzcy5taW4uY3NzP2E2ZTEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYXNzZXRzL3BrZ3MvTGFkZGEvZGlzdC9sYWRkYS10aGVtZWxlc3MubWluLmNzc1xuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///12\n")},function(module,exports){eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvcGtncy9ib290c3RyYXAvY3NzL2Jvb3RzdHJhcC10aGVtZS5taW4uY3NzP2ZiNzQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYXNzZXRzL3BrZ3MvYm9vdHN0cmFwL2Nzcy9ib290c3RyYXAtdGhlbWUubWluLmNzc1xuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///13\n")},function(module,exports){eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2hvcHNjb3RjaC9kaXN0L2Nzcy9ob3BzY290Y2guY3NzPzYyZmEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9ob3BzY290Y2gvZGlzdC9jc3MvaG9wc2NvdGNoLmNzc1xuLy8gbW9kdWxlIGlkID0gMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///14\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.mytour3 = exports.mytour2 = exports.step = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n__webpack_require__(11);\n\n__webpack_require__(13);\n\n__webpack_require__(12);\n\n__webpack_require__(14);\n\nvar _hopscotch = __webpack_require__(4);\n\nvar _hopscotch2 = _interopRequireDefault(_hopscotch);\n\nvar _mithril = __webpack_require__(0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _app = __webpack_require__(1);\n\nvar app = _interopRequireWildcard(_app);\n\nvar _explore = __webpack_require__(6);\n\nvar exp = _interopRequireWildcard(_explore);\n\nvar _plots = __webpack_require__(2);\n\nvar plots = _interopRequireWildcard(_plots);\n\nvar _Panel = __webpack_require__(7);\n\nvar _Panel2 = _interopRequireDefault(_Panel);\n\nvar _PanelButton = __webpack_require__(8);\n\nvar _PanelButton2 = _interopRequireDefault(_PanelButton);\n\nvar _PanelList = __webpack_require__(9);\n\nvar _PanelList2 = _interopRequireDefault(_PanelList);\n\nvar _Search = __webpack_require__(3);\n\nvar _Search2 = _interopRequireDefault(_Search);\n\nvar _Subpanel = __webpack_require__(10);\n\nvar _Subpanel2 = _interopRequireDefault(_Subpanel);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction setBackgroundColor(color) {\n    return function () {\n        this.style['background-color'] = color;\n    };\n}\n\nvar step = exports.step = function step(target, placement, title, content) {\n    return {\n        target: target,\n        placement: placement,\n        title: title,\n        content: content,\n        showCTAButton: true,\n        ctaLabel: 'Disable these messages',\n        onCTA: function onCTA() {\n            _hopscotch2.default.endTour(true);\n            tutorial_mode = false;\n        }\n    };\n};\n\nvar mytour2 = exports.mytour2 = {\n    id: \"dataset_launch\",\n    i18n: { doneBtn: 'Ok' },\n    showCloseButton: true,\n    scrollDuration: 300,\n    //onEnd: () => first_load = false,\n    steps: [step(\"dataName\", \"bottom\", \"Welcome to TwoRavens Solver\", '<p>This tool can guide you to solve an empirical problem in the dataset above.</p>\\n                      <p>These messages will teach you the steps to take to find and submit a solution.</p>'), step(\"btnReset\", \"bottom\", \"Restart Any Problem Here\", '<p>You can always start a problem over by using this reset button.</p>'), step(\"btnSubset\", \"right\", \"Start Task 1\", '<p>This Problem Discovery button allows you to start Task 1 - Problem Discovery.</p>\\n                     <p>Generally, as a tip, the Green button is the next button you need to press to move the current task forward.</p>\\n                     <p>Click this button to see a list of problems that have been discovered in the dataset.</p>\\n                     <p>You can mark which ones you agree may be interesting, and then submit the table as an answer.</p>'), step(\"btnSelect\", \"right\", \"Complete Task 1\", '<p>This submission button marks Task 1 - Problem Discovery, as complete.</p>\\n                     <p>Click this button to save the check marked problems in the table below as potentially interesting or relevant.</p>\\n                     <p>Generally, as a tip, the Green button is the next button you need to press to move the current task forward.</p>'), step(\"btnEstimate\", \"left\", \"Solve Task 2\", '<p>This generally is the important step to follow for Task 2 - Build a Model.</p>\\n                      <p>Generally, as a tip, the Green button is the next button you need to press to move the current task forward, and this button will be Green when Task 1 is completed and Task 2 started.</p>\\n                      <p>Click this Solve button to tell the tool to find a solution to the problem, using the variables presented in the center panel.</p>'),\n    //step(mytarget + 'biggroup', \"left\", \"Target Variable\",\n    //     `This is the variable, ${mytarget}, we are trying to predict.\n    //      This center panel graphically represents the problem currently being attempted.`),\n    step(\"gr1hull\", \"right\", \"Explanation Set\", \"This set of variables can potentially predict the target.\"), step(\"displacement\", \"right\", \"Variable List\", '<p>Click on any variable name here if you wish to remove it from the problem solution.</p>\\n                      <p>You likely do not need to adjust the problem representation in the center panel.</p>'), step(\"btnEndSession\", \"bottom\", \"Finish Problem\", \"If the solution reported back seems acceptable, then finish this problem by clicking this End Session button.\")]\n};\n\nvar mytour3 = exports.mytour3 = {\n    id: \"dataset_launch\",\n    i18n: { doneBtn: 'Ok' },\n    showCloseButton: true,\n    scrollDuration: 300,\n    steps: [step(\"btnSelect\", \"right\", \"Complete Task 1\", '<p>This submission button marks Task 1 - Problem Discovery, as complete.</p>\\n                     <p>Click this button to save the check marked problems in the table below as potentially interesting or relevant.</p>\\n                     <p>Generally, as a tip, the Green button is the next button you need to press to move the current task forward.</p>')]\n};\n\nfunction leftpanel() {\n    return (0, _mithril2.default)(_Panel2.default, { side: 'left',\n        title: 'Data Selection',\n        buttons: [(0, _mithril2.default)(_PanelButton2.default, { id: 'btnVariables',\n            id2: 'tab1',\n            title: 'Click variable name to add or remove the variable pebble from the modeling space.' }, 'Variables'), (0, _mithril2.default)(_PanelButton2.default, { id: 'btnSubset', id2: 'tab2', classes: 'btn-success' }, 'Prob. Disc.'), //onclick: _ => app.probDiscView('btnSubset')\n        (0, _mithril2.default)(_PanelButton2.default, { id: 'btnSelect',\n            classes: 'btn-success.ladda-button[data-spinner-color=#000000][data-style=zoom-in]',\n            onclick: function onclick(_) {\n                return app.submitDiscProb('btnSelect');\n            },\n            style: 'display: ' + (app.subset ? 'none' : 'none') + '; float: right; margin-right: 10px',\n            title: 'Submit all checked discovered problems.' }, (0, _mithril2.default)('span.ladda-label[style=pointer-events: none]', 'Submit Disc. Probs.'))] }, (0, _mithril2.default)('#tab1[style=display: ' + (0, _PanelButton.when)('left', 'tab1') + '; padding: 0 8px; text-align: center]', (0, _mithril2.default)(_Search2.default, { placeholder: 'Search variables and labels' }), (0, _mithril2.default)(_PanelList2.default, { items: app.valueKey, title: 'Summary Statistics' })), (0, _mithril2.default)('#tab2[style=display: ' + (0, _PanelButton.when)('left', 'tab2') + '; height:75%; overflow: auto; margin-top: .5em]'), (0, _mithril2.default)('#tab2a[style=display:none; float: left; width: 100%; height:25%; overflow: auto;]', (0, _mithril2.default)('textarea#tab2input[style=display:block; float: left; width: 75%; height:100%; overflow: auto; background-color: white]'), (0, _mithril2.default)(_PanelButton2.default, { id: 'btnSave', onclick: function onclick(_) {\n            return app.saveDisc('btnSave');\n        }, title: 'Saves your revised problem description.' }, 'Save Desc.')),\n\n    //     m(\"input#input1[name='fname'][type='text']\", {style: {\"margin-left\": \"2%\"}}),\n    (0, _mithril2.default)('#tab3[style=height: 350px]', (0, _mithril2.default)('p[style=padding: .5em 1em; display: ' + (0, _PanelButton.when)('left', 'tab3') + ']', { title: \"Select a variable from within the visualization in the center panel to view its summary statistics.\" }, (0, _mithril2.default)('center', (0, _mithril2.default)('b', app.summary.name), (0, _mithril2.default)('br'), (0, _mithril2.default)('i', app.summary.labl)), (0, _mithril2.default)('table', app.summary.data.map(function (tr) {\n        return (0, _mithril2.default)('tr', tr.map(function (td) {\n            return (0, _mithril2.default)('td', { onmouseover: setBackgroundColor('aliceblue'), onmouseout: setBackgroundColor('f9f9f9') }, td);\n        }));\n    })))));\n}\n\nvar righttab = function righttab(id, btnId, task, title, probDesc) {\n    return (0, _mithril2.default)('#' + id + '[style=display: ' + (0, _PanelButton.when)('right', btnId) + '; padding: 6px 12px; text-align: center]', (0, _mithril2.default)(_PanelList2.default, { items: Object.keys(task || {}),\n        title: title + ' Description',\n        content: function content(v) {\n            return task[v][1];\n        },\n        probDesc: probDesc }));\n};\n\nfunction rightpanel(mode) {\n    var thumb = function thumb(idx, id, title) {\n        return (0, _mithril2.default)(\"th\", (0, _mithril2.default)(\"figure\", { style: { float: \"left\" } }, (0, _mithril2.default)('img#' + id + '_img[alt=' + id + '][src=/static/images/thumb' + idx + '.png]', { style: { width: \"75%\", height: \"75%\", border: \"1px solid #ddd\", \"border-radius\": \"3px\", padding: \"5px\", margin: \"3%\", cursor: \"pointer\" } }), (0, _mithril2.default)(\"figcaption\", { style: { \"text-align\": \"center\" } }, title)));\n    };\n    var unique_link_names = function unique_link_names() {\n        var names = [];\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n            for (var _iterator = app.links[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                var link = _step.value;\n\n                if (!names.includes(link.source.name)) {\n                    names.push(link.source.name);\n                }\n                if (!names.includes(link.target.name)) {\n                    names.push(link.target.name);\n                }\n            }\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally {\n            try {\n                if (!_iteratorNormalCompletion && _iterator.return) {\n                    _iterator.return();\n                }\n            } finally {\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n\n        return names;\n    };\n    return mode ? (0, _mithril2.default)(_Panel2.default, { side: 'right',\n        title: 'Result Exploration',\n        is_explore_mode: true,\n        buttons: [(0, _mithril2.default)(_PanelButton2.default, { id: 'btnUnivariate' }, 'Univariate'), (0, _mithril2.default)(_PanelButton2.default, { id: 'btnBivariate' }, 'Bivariate')] }, (0, _mithril2.default)('#modelView_Container', { style: 'width: 100%; height: auto; background-color: white; float: left; overflow-x: auto; overflow-y: auto; white-space: nowrap;' }, (0, _mithril2.default)('#modelView', { style: 'width: 100%; height: auto; background-color: white; float: left; overflow: auto; margin-top: 2px;' })), (0, _mithril2.default)('#decisionTree[style=width: 100%; height: auto ; background-color: white ;  overflow : scroll; float: left; white-space: nowrap; margin-top: 2px;]'), (0, _mithril2.default)('#result_left', { style: { \"width\": \"50%\", \"height\": \"90%\", \"float\": \"left\", \"background-color\": \"white\", \"border-right\": \"ridge\", \"border-bottom\": \"ridge\", \"overflow\": \"auto\", \"white-space\": \"nowrap\" } }, (0, _mithril2.default)('#left_thumbnail', { style: { \"width\": \"100%\", \"height\": \"20%\", \"background-color\": \"white\", \"margin-top\": \"3%\", \"margin-right\": \"3%\", \"border-bottom\": \"ridge\", \"overflow\": \"auto\", \"white-space\": \"nowrap\" } }, (0, _mithril2.default)(\"table\", (0, _mithril2.default)(\"tbody\", (0, _mithril2.default)(\"tr\", thumb(1, 'scatterplot', \"Scatter Plot\"), thumb(2, 'heatmap', \"Heatpmap\"), thumb(3, 'linechart', \"Linechart\"))))), (0, _mithril2.default)('#result_left1', { style: { width: \"100%\", height: \"320px\", \"text-align\": \"center\", \"margin-top\": \"3%\", \"background-color\": \"white\", \"white-space\": \"nowrap\" } }, (0, _mithril2.default)(\".container3[id=scatterplot]\", { style: { \"width\": \"500px\", \"height\": \"80%\", \"background-color\": \"white\", \"float\": \"left\", \"overflow\": \"hidden\", \"margin\": \"5% 5% 0 5%\" } }), (0, _mithril2.default)(\".container4[id=heatchart]\", { style: { \"width\": \"500px\", \"height\": \"80%\", \"float\": \"left\", \"overflow\": \"hidden\", \"background-color\": \"#FFEBEE\", \"margin\": \"5%  \" } }), (0, _mithril2.default)(\".container4[id=linechart]\", { style: { \"width\": \"500px\", \"height\": \"80%\", \"background-color\": \"white\", \"float\": \"left\", \"overflow\": \"hidden\", \"margin\": \"5% \" } })), (0, _mithril2.default)(\"div\", { style: { \"border-bottom\": \"ridge\", \"display\": \"inline-block\", \"width\": \"100%\", \"margin-bottom\": \"2%\", \"text-align\": \"center\" } }, (0, _mithril2.default)(\"h5#NAcount\", { style: { \" margin-bottom\": \"0\" } })), (0, _mithril2.default)(\".container2[id='resultsView_statistics']\", { style: { \"width\": \"100%\", \"height\": \"15%\", \"background-color\": \"white\", \"float\": \"left\", \"white-space\": \"nowrap\", \"margin-bottom\": \"3%\", \"border-bottom\": \"ridge\" } })), (0, _mithril2.default)('#result_right', { style: { width: \"50%\", height: \"90%\", float: \"right\", \"background-color\": \"white\", \"border-right\": \"groove\", \"white-space\": \"nowrap\" } }, (0, _mithril2.default)('#resultsView_tabular.container1', { style: { width: \"100%\", height: \"100%\", \"background-color\": \"white\", float: \"left\", overflow: \"auto\", \"white-space\": \"nowrap\", \"border-right\": \"groove\", \"border-bottom\": \"groove\" } }, (0, _mithril2.default)('#SelectionData', { style: { width: \"100%\", height: \"50%\", overflow: \"auto\", \"margin-top\": \"10px\", \"border-bottom-style\": \"inset\" } }, (0, _mithril2.default)(\"fieldset\", { style: { margin: \"3%\" } }, (0, _mithril2.default)(\"h4\", { style: { \"text-align\": \"center\" } }, \"Data Distribution Selection\"), (0, _mithril2.default)(\"p\", { style: { \"font-family\": \"Arial, Helvetica, sans-serif\", \"font-size\": \"12px\" } }, \"Enter number for each variable to specify the break points\"), (0, _mithril2.default)('p#boldstuff', { style: { color: \"#2a6496\", \"font-family\": \"Arial, Helvetica, sans-serif\", \"font-size\": \"12px\" } }, \"Select between Equidistant and Equimass\")), (0, _mithril2.default)('#forPlotA', { style: { display: 'block', \"margin\": \"2%\" } }, (0, _mithril2.default)(\"input#input1[name='fname'][type='text']\", { style: { \"margin-left\": \"2%\" } }), (0, _mithril2.default)('span#tooltipPlotA.tooltiptext[style=visibility: hidden]'), (0, _mithril2.default)(\"button.btn.btn-default.btn-xs#Equidistance1[type='button']\", { style: { float: \"left\", \"margin-left\": \"2%\" } }, \"EQUIDISTANCE\"), (0, _mithril2.default)(\"button.btn.btn-default.btn-xs#Equimass1[type='button']\", { style: { float: \"left\", \"margin-left\": \"2%\" } }, \"EQUIMASS\")), (0, _mithril2.default)('#forPlotB', { style: { display: \"block\", margin: \"2%\" } }, (0, _mithril2.default)(\"input#input2[name='fname1'][type='text']\", { style: { \"margin-left\": \"2%\" } }), (0, _mithril2.default)('span#tooltipPlotB.tooltiptext1[style=visibility: hidden]'), (0, _mithril2.default)(\"button.btn.btn-default.btn-xs#Equidistance2[type='button']\", { style: { float: \"left\", \"margin-left\": \"2%\" } }, \"EQUIDISTANCE\"), (0, _mithril2.default)(\"button.btn.btn-default.btn-xs#Equimass2[type='button']\", { style: { float: \"left\", \"margin-left\": \"2%\" } }, \"EQUIMASS\")), (0, _mithril2.default)(\"#plotA_status[style=margin-top: 1%; margin-left: 2%]\"), (0, _mithril2.default)(\"#plotB_status[style=margin-top: 1%; margin-left: 2%]\"), (0, _mithril2.default)('h5[style=color: #ac2925; margin-top: 1%; margin-left: 2%]', 'Selection History'), (0, _mithril2.default)('#breakspace[style=display: inline-block; overflow: auto; width: 100%]'), (0, _mithril2.default)(\"button.btn.btn-default.btn-sm[id='SelectionData1'][type='button']\", { style: { display: \"block\", margin: \"0 auto\", position: \"relative\" } }, \"Create\")), (0, _mithril2.default)('#tabular_1', { style: { width: \"100%\", height: \"200px\", \"border-bottom-style\": \"inset\" } }, (0, _mithril2.default)('#plotA', { style: { width: exp.get_width('plotA') + '%', height: \"100%\", float: \"left\", overflow: \"hidden\" } }, \"plotA\"), (0, _mithril2.default)('#plotB', { style: { width: exp.get_width('plotB') + '%', height: \"100%\", float: \"right\", overflow: \"hidden\" } }, \"plotB\")), (0, _mithril2.default)('#tabular_2', { style: { width: \"100%\", height: \"50%\", \"border-bottom-style\": \"inset\", overflow: \"hidden\" } }))), (0, _mithril2.default)(\"p#resultsHolder\", { style: { padding: \".5em 1em\" } }, (0, _mithril2.default)('#varList[style=display: block]', unique_link_names().map(function (x) {\n        return (0, _mithril2.default)('p#' + x.replace(/\\W/g, '_'), { onclick: function onclick(_) {\n                return exp.callTreeApp(x);\n            }, style: { 'background-color': app.varColor } }, x);\n    }))), (0, _mithril2.default)('#setx[style=display: none; margin-top: .5em]')) :\n    // mode == null (model mode)\n    (0, _mithril2.default)(_Panel2.default, { side: 'right',\n        title: 'Model Selection',\n        buttons: (!app.IS_D3M_DOMAIN ? [] : [(0, _mithril2.default)(_PanelButton2.default, { id: 'btnModels' }, 'Models'), (0, _mithril2.default)(_PanelButton2.default, { id: 'btnSetx' }, 'Set Covar.'), (0, _mithril2.default)(_PanelButton2.default, { id: 'btnResults' }, 'Results')]).concat([(0, _mithril2.default)(_PanelButton2.default, { id: 'btnType', is_explore_mode: exp.explore }, 'Task Type'), (0, _mithril2.default)(_PanelButton2.default, { id: 'btnSubtype', is_explore_mode: exp.explore }, 'Subtype'), (0, _mithril2.default)(_PanelButton2.default, { id: 'btnMetrics', is_explore_mode: exp.explore }, 'Metrics'), (0, _mithril2.default)(_PanelButton2.default, { id: 'btnSetx', is_explore_mode: exp.explore }, 'Set Covar.'), (0, _mithril2.default)(_PanelButton2.default, { id: 'btnResults', is_explore_mode: exp.explore }, 'Results')]) }, (0, _mithril2.default)('#results[style=display: ' + (0, _PanelButton.when)('right', 'btnResults') + '; margin-top: .5em]', (0, _mithril2.default)(\"#resultsView.container[style=float: right; overflow: auto; width: 80%; background-color: white; white-space: nowrap]\"), (0, _mithril2.default)('#modelView[style=display: none; float: left; width: 20%; background-color: white]'), (0, _mithril2.default)(\"p#resultsHolder[style=padding: .5em 1em]\")),\n    // this naming is getting ridiculous...\n    (0, _mithril2.default)('#setx[style=display: ' + (0, _PanelButton.when)('right', 'btnSetx') + ']', (0, _mithril2.default)('#setxRight[style=display:block; float: right; width: 25%; height:100%; background-color: white]'), (0, _mithril2.default)('#setxTop[style=display:block; float: left; width: 75%; height:10%; overflow: auto; background-color: white]', (0, _mithril2.default)(\"button.btn.btn-default.btn-xs#btnPredPlot[type='button']\", { onclick: function onclick(_) {\n            return app.showPredPlot('btnPredPlot');\n        }, style: { float: \"left\", \"margin-left\": \"2%\" } }, \"Prediction Summary\"), (0, _mithril2.default)(\"button.btn.btn-default.btn-xs#btnGenPreds[type='button']\", { onclick: function onclick(_) {\n            return app.showGenPreds('btnGenPreds');\n        }, style: { float: \"left\", \"margin-left\": \"2%\" } }, \"Generate New Predictions\")), (0, _mithril2.default)('#setxLeftPlot[style=display:block; float: left; width: 75%; height:95%; overflow: auto; background-color: white]'), (0, _mithril2.default)('#setxLeft[style=display:none; float: left; width: 75%; height:95%; overflow: auto; background-color: white]'), (0, _mithril2.default)('#setxLeftGen[style=display:none; float: left; width: 75%; height:95%; overflow: auto; background-color: white]', (0, _mithril2.default)('#setxLeftTop[style=display:block; float: left; width: 100%; height:50%; overflow: auto; background-color: white]', (0, _mithril2.default)('#setxLeftTopLeft[style=display:block; float: left; width: 30%; height:100%; overflow: auto; background-color: white]'), (0, _mithril2.default)('#setxLeftTopRight[style=display:block; float: left; width: 70%; height:100%; overflow: auto; background-color: white]')), (0, _mithril2.default)('#setxLeftBottomLeft[style=display:block; float: left; width: 70%; height:50%; overflow: auto; background-color: white]'), (0, _mithril2.default)('#setxLeftBottomRightTop[style=display:block; float: left; width: 30%; height:10%; overflow: auto; background-color: white]', (0, _mithril2.default)(_PanelButton2.default, { id: 'btnExecutePipe',\n        classes: 'btn-default.ladda-button[data-spinner-color=#000000][data-style=zoom-in]',\n        onclick: function onclick(_) {\n            return app.executepipeline('btnExecutePipe');\n        },\n        style: 'display:inline; float: left; margin-right: 10px',\n        title: 'Execute pipeline.' }, (0, _mithril2.default)('span.ladda-label[style=pointer-events: none]', 'Execute Generation'))), (0, _mithril2.default)('#setxLeftBottomRightBottom[style=display:block; float: left; width: 30%; height:40%; overflow: auto; background-color: white]'))), righttab('models', 'btnModels'), righttab('types', 'btnType', app.d3mTaskType, 'Task', 'taskType'), righttab('subtypes', 'btnSubtype', app.d3mTaskSubtype, 'Task Subtype', 'taskSubtype'), righttab('metrics', 'btnMetrics', app.d3mMetrics, 'Metric', 'metric'));\n}\n\nvar ticker = function ticker(mode) {\n    var link = function link(name) {\n        return (0, _mithril2.default)('a' + (name === mode ? '.active' : '') + '[href=/' + name + '][style=margin-right: 0.5em]', { oncreate: _mithril2.default.route.link }, name[0].toUpperCase() + name.slice(1));\n    };\n    return (0, _mithril2.default)('#ticker[style=background: #F9F9F9; bottom: 0; height: 40px; position: fixed; width: 100%; border-top: 1px solid #ADADAD]', link('model'), link('explore'), (0, _mithril2.default)(\"a#logID[href=somelink][target=_blank]\", \"Replication\"), (0, _mithril2.default)(\"span[style=color:#337ab7]\", \" | \"),\n    // dev links...\n    (0, _mithril2.default)(\"a[href='/dev-raven-links'][target=_blank]\", \"raven-links\"),\n    //m(\"a[style=margin-right: 0.5em]\",\n    //  {onclick: app.record_user_metadata},\n    //  \"record-metadata\"),\n    (0, _mithril2.default)(\"span[style=color:#337ab7]\", \" | \"), (0, _mithril2.default)(\"span[style=color:#337ab7]\", \"TA2: \" + TA2_SERVER), (0, _mithril2.default)(\"span[style=color:#337ab7]\", \" | \"), (0, _mithril2.default)(\"span[style=color:#337ab7]\", \"TA3TA2 api: \" + TA3TA2_API_VERSION));\n};\n\nvar Body = function () {\n    function Body() {\n        _classCallCheck(this, Body);\n    }\n\n    _createClass(Body, [{\n        key: 'oninit',\n        value: function oninit(vnode) {\n            if (vnode.attrs.mode) {\n                _mithril2.default.route.set('/model');\n            };\n            this.about = false;\n            this.usertasks = false;\n            this.cite = false;\n            this.citeHidden = false;\n            this.last_mode = null;\n        }\n    }, {\n        key: 'oncreate',\n        value: function oncreate() {\n            var extract = function extract(name, key, offset, replace) {\n                key = key + '=';\n                var loc = window.location.toString();\n                var val = loc.indexOf(key) > 0 ? loc.substring(loc.indexOf(key) + offset) : '';\n                var idx = val.indexOf('&');\n                val = idx > 0 ? val.substring(0, idx) : val;\n                val = val.replace('#!/model', '');\n                console.log(name, ': ', val);\n                if (replace) val = val.replace(/%25/g, '%').replace(/%3A/g, ':').replace(/%2F/g, '/');\n                return val;\n            };\n            app.main(extract('fileid', 'dfId', 5), extract('hostname', 'host', 5), extract('ddiurl', 'ddiurl', 7, true), extract('dataurl', 'dataurl', 8, true), extract('apikey', 'key', 4));\n        }\n    }, {\n        key: 'view',\n        value: function view(vnode) {\n            var _this = this;\n\n            var mode = vnode.attrs.mode;\n\n            var explore = mode === 'explore';\n            app.is_results_mode = mode === 'results';\n            var userlinks = [];\n            if (username == \"no logged in user\") {\n                userlinks = [{ title: \"Log in\", url: login_url }, { title: \"Sign up\", url: signup_url }];\n            } else {\n                userlinks = [{ title: \"Workspaces\", url: workspaces_url }, { title: \"Settings\", url: settings_url }, { title: \"Links\", url: devlinks_url }, { title: \"Logout\", url: logout_url }];\n            };\n            var _navBtn = function _navBtn(id, left, right, onclick, args, min) {\n                return (0, _mithril2.default)('button#' + id + '.btn.navbar-right', { onclick: onclick,\n                    style: { 'margin-left': left + 'em',\n                        'margin-right': right + 'em',\n                        'min-width': min } }, args);\n            };\n            var navBtn = function navBtn(id, left, right, onclick, args, min) {\n                return _navBtn(id + '.ladda-button[data-spinner-color=#000000][data-style=zoom-in]', left, right, onclick, args, min);\n            };\n            var navBtn1 = function navBtn1(id, onclick, args, title) {\n                return _navBtn(id + '.btn-default[title=' + title + ']', 2, 0, onclick, args);\n            };\n            var glyph = function glyph(icon, unstyled) {\n                return (0, _mithril2.default)('span.glyphicon.glyphicon-' + icon + (unstyled ? '' : '[style=color: #818181; font-size: 1em; pointer-events: none]'));\n            };\n            var transformation = function transformation(id, list) {\n                return (0, _mithril2.default)('ul#' + id, {\n                    style: { display: 'none', 'background-color': app.varColor },\n                    onclick: function onclick(evt) {\n                        // if interact is selected, show variable list again\n                        if ($(this).text() === 'interact(d,e)') {\n                            $('#tInput').val(tvar.concat('*'));\n                            selInteract = true;\n                            $(this).parent().fadeOut(100);\n                            $('#transSel').fadeIn(100);\n                            evt.stopPropagation();\n                            return;\n                        }\n\n                        var tvar = $('#tInput').val();\n                        var tfunc = $(this).text().replace(\"d\", \"_transvar0\");\n                        var tcall = $(this).text().replace(\"d\", tvar);\n                        $('#tInput').val(tcall);\n                        $(this).parent().fadeOut(100);\n                        evt.stopPropagation();\n                        transform(tvar, tfunc, typeTransform = false);\n                    }\n                }, list.map(function (x) {\n                    return (0, _mithril2.default)('li', x);\n                }));\n            };\n            var spaceBtn = function spaceBtn(id, onclick, title, icon) {\n                return (0, _mithril2.default)('button#' + id + '.btn.btn-default', { onclick: onclick, title: title }, glyph(icon, true));\n            };\n\n            if (mode != this.last_mode) {\n                if (explore) {\n                    app.set_explore_mode(explore);\n                    app.set_righttab('btnUnivariate');\n                } else if (!mode) {\n                    app.set_righttab(IS_D3M_DOMAIN ? 'btnType' : 'btnModels');\n                }\n                app.restart && app.restart();\n                this.last_mode = mode;\n            }\n\n            return (0, _mithril2.default)('main', (0, _mithril2.default)(\"nav#navbar.navbar.navbar-default.navbar-fixed-top[role=navigation]\", { style: mode === 'explore' && 'background-image: -webkit-linear-gradient(top, #fff 0, rgb(227, 242, 254) 100%)' }, (0, _mithril2.default)(\"a.navbar-brand\", (0, _mithril2.default)(\"img[src=/static/images/TwoRavens.png][alt=TwoRavens][width=100][style=margin-left: 1em; margin-top: -0.5em]\", { onmouseover: function onmouseover(_) {\n                    return _this.about = true;\n                }, onmouseout: function onmouseout(_) {\n                    return _this.about = false;\n                } })), (0, _mithril2.default)('#navbarNav[style=padding: 0.5em]', (0, _mithril2.default)('#dataField.field[style=margin-top: 0.5em; text-align: center]', (0, _mithril2.default)('h4#dataName[style=display: inline]', { onclick: function onclick(_) {\n                    return _this.cite = _this.citeHidden = !_this.citeHidden;\n                },\n                onmouseout: function onmouseout(_) {\n                    return _this.citeHidden || (_this.cite = false);\n                },\n                onmouseover: function onmouseover(_) {\n                    return _this.cite = true;\n                } }, \"Dataset Name\"), (0, _mithril2.default)('#cite.panel.panel-default', { style: 'display: ' + (this.cite ? 'block' : 'none') + '; position: absolute; right: 50%; width: 380px; text-align: left; z-index: 50' }, (0, _mithril2.default)(\".panel-body\")), (0, _mithril2.default)('span', (0, _mithril2.default)('.dropdown[style=float: right; padding-right: 1em]', (0, _mithril2.default)('#drop.button.btn[type=button][data-toggle=dropdown][aria-haspopup=true][aria-expanded=false]', [username, \" \", glyph('triangle-bottom')]), (0, _mithril2.default)('ul.dropdown-menu[role=menu][aria-labelledby=drop]', userlinks.map(function (link) {\n                return (0, _mithril2.default)('a[style=padding: 0.5em]', { href: link.url }, link.title, (0, _mithril2.default)('br'));\n            }))), navBtn('btnEstimate.btn-default', 2, 1, explore ? exp.explore : app.estimate, (0, _mithril2.default)(\"span.ladda-label\", explore ? 'Explore' : 'Solve This Problem'), '150px'), navBtn('btnTA2.btn-default', .2, 1, function (_) {\n                return app.helpmaterials('manual');\n            }, ['Help Manual ', glyph('book')]), navBtn('btnTA2.btn-default', .2, .2, function (_) {\n                return app.helpmaterials('video');\n            }, ['Help Video ', glyph('expand')]), navBtn('btnTA2.btn-default', 2, .2, function (_) {\n                return _hopscotch2.default.startTour(mytour2, 0);\n            }, ['Help Tour ', glyph('road')]), navBtn1(\"btnReset\", app.reset, glyph('repeat'), 'Reset'), navBtn1('btnEndSession', app.endsession, (0, _mithril2.default)(\"span.ladda-label\", 'Mark Problem Finished'), 'Mark Problem Finished')), (0, _mithril2.default)('#tInput', {\n                style: { display: 'none' },\n                onclick: function onclick(_) {\n                    if (byId('transSel').style.display !== 'none') {\n                        // if variable list is displayed when input is clicked...\n                        $('#transSel').fadeOut(100);\n                        return false;\n                    }\n                    if (byId('transList').style.display !== 'none') {\n                        // if function list is displayed when input is clicked...\n                        $('#transList').fadeOut(100);\n                        return false;\n                    }\n\n                    // highlight the text\n                    $(_this).select();\n                    var pos = $('#tInput').offset();\n                    pos.top += $('#tInput').width();\n                    $('#transSel').fadeIn(100);\n                    return false;\n                },\n                keyup: function keyup(evt) {\n                    var t = byId('transSel').style.display;\n                    var t1 = byId('transList').style.display;\n                    if (t !== 'none') {\n                        $('#transSel').fadeOut(100);\n                    } else if (t1 !== 'none') {\n                        $('#transList').fadeOut(100);\n                    }\n\n                    if (evt.keyCode == 13) {\n                        // keyup on Enter\n                        var _t = transParse($('#tInput').val());\n                        if (!_t) {\n                            return;\n                        }\n                        transform(_t.slice(0, _t.length - 1), _t[_t.length - 1], typeTransform = false);\n                    }\n                }\n            }), (0, _mithril2.default)('#transformations.transformTool', {\n                title: 'Construct transformations of existing variables using valid R syntax.\\n                              For example, assuming a variable named d, you can enter \"log(d)\" or \"d^2\".' }, transformation('transSel', ['a', 'b']), transformation('transList', app.transformList)))), (0, _mithril2.default)('#about.panel.panel-default[style=display: ' + (this.about ? 'block' : 'none') + '; left: 140px; position: absolute; width: 500px; z-index: 50]', (0, _mithril2.default)('.panel-body', 'TwoRavens v0.1 \"Dallas\" -- The Norse god Odin had two talking ravens as advisors, who would fly out into the world and report back all they observed. In the Norse, their names were \"Thought\" and \"Memory\". In our coming release, our thought-raven automatically advises on statistical model selection, while our memory-raven accumulates previous statistical models from Dataverse, to provide cummulative guidance and meta-analysis.'))), (0, _mithril2.default)('#main.left.carousel.slide.svg-leftpanel.svg-rightpanel[style=overflow: hidden]', (0, _mithril2.default)(\"#innercarousel.carousel-inner\", (0, _mithril2.default)('#m0.item.active', (0, _mithril2.default)('svg#whitespace'))), (0, _mithril2.default)(\"#spacetools.spaceTool[style=z-index: 16]\", spaceBtn('btnLock.active', app.lockDescription, 'Lock selection of problem description', 'pencil'), spaceBtn('btnJoin', function (_) {\n                var _ref;\n\n                var links = [];\n                if (explore) {\n                    var _iteratorNormalCompletion2 = true;\n                    var _didIteratorError2 = false;\n                    var _iteratorError2 = undefined;\n\n                    try {\n                        var _loop = function _loop() {\n                            var node = _step2.value;\n                            var _iteratorNormalCompletion3 = true;\n                            var _didIteratorError3 = false;\n                            var _iteratorError3 = undefined;\n\n                            try {\n                                var _loop2 = function _loop2() {\n                                    var node1 = _step3.value;\n\n                                    if (node !== node1 && links.filter(function (l) {\n                                        return l.target === node1 && l.source === node;\n                                    }).length === 0) {\n                                        links.push({ left: false, right: false, target: node, source: node1 });\n                                    }\n                                };\n\n                                for (var _iterator3 = app.nodes[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                                    _loop2();\n                                }\n                            } catch (err) {\n                                _didIteratorError3 = true;\n                                _iteratorError3 = err;\n                            } finally {\n                                try {\n                                    if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                                        _iterator3.return();\n                                    }\n                                } finally {\n                                    if (_didIteratorError3) {\n                                        throw _iteratorError3;\n                                    }\n                                }\n                            }\n                        };\n\n                        for (var _iterator2 = app.nodes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                            _loop();\n                        }\n                    } catch (err) {\n                        _didIteratorError2 = true;\n                        _iteratorError2 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                                _iterator2.return();\n                            }\n                        } finally {\n                            if (_didIteratorError2) {\n                                throw _iteratorError2;\n                            }\n                        }\n                    }\n                } else {\n                    var dvs = app.nodes.filter(function (n) {\n                        return app.zparams.zdv.includes(n.name);\n                    });\n                    var ivs = app.nodes.filter(function (n) {\n                        return !dvs.includes(n);\n                    });\n                    links = dvs.map(function (dv) {\n                        return ivs.map(function (iv) {\n                            return {\n                                left: true,\n                                right: false,\n                                target: iv,\n                                source: dv\n                            };\n                        });\n                    });\n                }\n                app.restart((_ref = []).concat.apply(_ref, _toConsumableArray(links)));\n            }, 'Make all possible connections between nodes', 'link'), spaceBtn('btnDisconnect', function (_) {\n                return app.restart([]);\n            }, 'Delete all connections between nodes', 'remove-circle'), spaceBtn('btnForce', app.forceSwitch, 'Pin the variable pebbles to the page', 'pushpin'), spaceBtn('btnEraser', app.erase, 'Wipe all variables from the modeling space', 'magnet')), (0, _mithril2.default)(_Subpanel2.default, { title: \"Legend\",\n                buttons: [['timeButton', 'ztime', 'Time'], ['csButton', 'zcross', 'Cross Sec'], ['dvButton', 'zdv', 'Dep Var'], ['nomButton', 'znom', 'Nom Var'], ['gr1Button', 'zgroup1', 'Group 1'], ['gr2Button', 'zgroup2', 'Group 2']] }), (0, _mithril2.default)(_Subpanel2.default, { title: \"History\" }), ticker(mode), leftpanel(), rightpanel(mode)));\n        }\n    }]);\n\n    return Body;\n}();\n\n_mithril2.default.route(document.body, '/model', {\n    '/model': { render: function render() {\n            return (0, _mithril2.default)(Body);\n        } },\n    '/explore': { render: function render() {\n            return (0, _mithril2.default)(Body, { mode: 'explore' });\n        } },\n    '/results': { render: function render() {\n            return (0, _mithril2.default)(Body, { mode: 'results' });\n        } }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvYXBwL2luZGV4LmpzPzMzYmUiXSwibmFtZXMiOlsiYXBwIiwiZXhwIiwicGxvdHMiLCJzZXRCYWNrZ3JvdW5kQ29sb3IiLCJjb2xvciIsInN0eWxlIiwic3RlcCIsInRhcmdldCIsInBsYWNlbWVudCIsInRpdGxlIiwiY29udGVudCIsInNob3dDVEFCdXR0b24iLCJjdGFMYWJlbCIsIm9uQ1RBIiwiZW5kVG91ciIsInR1dG9yaWFsX21vZGUiLCJteXRvdXIyIiwiaWQiLCJpMThuIiwiZG9uZUJ0biIsInNob3dDbG9zZUJ1dHRvbiIsInNjcm9sbER1cmF0aW9uIiwic3RlcHMiLCJteXRvdXIzIiwibGVmdHBhbmVsIiwic2lkZSIsImJ1dHRvbnMiLCJpZDIiLCJjbGFzc2VzIiwib25jbGljayIsInN1Ym1pdERpc2NQcm9iIiwic3Vic2V0IiwicGxhY2Vob2xkZXIiLCJpdGVtcyIsInZhbHVlS2V5Iiwic2F2ZURpc2MiLCJzdW1tYXJ5IiwibmFtZSIsImxhYmwiLCJkYXRhIiwibWFwIiwidHIiLCJvbm1vdXNlb3ZlciIsIm9ubW91c2VvdXQiLCJ0ZCIsInJpZ2h0dGFiIiwiYnRuSWQiLCJ0YXNrIiwicHJvYkRlc2MiLCJPYmplY3QiLCJrZXlzIiwidiIsInJpZ2h0cGFuZWwiLCJtb2RlIiwidGh1bWIiLCJpZHgiLCJmbG9hdCIsIndpZHRoIiwiaGVpZ2h0IiwiYm9yZGVyIiwicGFkZGluZyIsIm1hcmdpbiIsImN1cnNvciIsInVuaXF1ZV9saW5rX25hbWVzIiwibmFtZXMiLCJsaW5rcyIsImxpbmsiLCJpbmNsdWRlcyIsInNvdXJjZSIsInB1c2giLCJpc19leHBsb3JlX21vZGUiLCJvdmVyZmxvdyIsImRpc3BsYXkiLCJwb3NpdGlvbiIsImdldF93aWR0aCIsIngiLCJyZXBsYWNlIiwiY2FsbFRyZWVBcHAiLCJ2YXJDb2xvciIsIklTX0QzTV9ET01BSU4iLCJjb25jYXQiLCJleHBsb3JlIiwic2hvd1ByZWRQbG90Iiwic2hvd0dlblByZWRzIiwiZXhlY3V0ZXBpcGVsaW5lIiwiZDNtVGFza1R5cGUiLCJkM21UYXNrU3VidHlwZSIsImQzbU1ldHJpY3MiLCJ0aWNrZXIiLCJvbmNyZWF0ZSIsInJvdXRlIiwidG9VcHBlckNhc2UiLCJzbGljZSIsIlRBMl9TRVJWRVIiLCJUQTNUQTJfQVBJX1ZFUlNJT04iLCJCb2R5Iiwidm5vZGUiLCJhdHRycyIsInNldCIsImFib3V0IiwidXNlcnRhc2tzIiwiY2l0ZSIsImNpdGVIaWRkZW4iLCJsYXN0X21vZGUiLCJleHRyYWN0Iiwia2V5Iiwib2Zmc2V0IiwibG9jIiwid2luZG93IiwibG9jYXRpb24iLCJ0b1N0cmluZyIsInZhbCIsImluZGV4T2YiLCJzdWJzdHJpbmciLCJjb25zb2xlIiwibG9nIiwibWFpbiIsImlzX3Jlc3VsdHNfbW9kZSIsInVzZXJsaW5rcyIsInVzZXJuYW1lIiwidXJsIiwibG9naW5fdXJsIiwic2lnbnVwX3VybCIsIndvcmtzcGFjZXNfdXJsIiwic2V0dGluZ3NfdXJsIiwiZGV2bGlua3NfdXJsIiwibG9nb3V0X3VybCIsIl9uYXZCdG4iLCJsZWZ0IiwicmlnaHQiLCJhcmdzIiwibWluIiwibmF2QnRuIiwibmF2QnRuMSIsImdseXBoIiwiaWNvbiIsInVuc3R5bGVkIiwidHJhbnNmb3JtYXRpb24iLCJsaXN0IiwiZXZ0IiwiJCIsInRleHQiLCJ0dmFyIiwic2VsSW50ZXJhY3QiLCJwYXJlbnQiLCJmYWRlT3V0IiwiZmFkZUluIiwic3RvcFByb3BhZ2F0aW9uIiwidGZ1bmMiLCJ0Y2FsbCIsInRyYW5zZm9ybSIsInR5cGVUcmFuc2Zvcm0iLCJzcGFjZUJ0biIsInNldF9leHBsb3JlX21vZGUiLCJzZXRfcmlnaHR0YWIiLCJyZXN0YXJ0IiwiaHJlZiIsImVzdGltYXRlIiwiaGVscG1hdGVyaWFscyIsInN0YXJ0VG91ciIsInJlc2V0IiwiZW5kc2Vzc2lvbiIsImJ5SWQiLCJzZWxlY3QiLCJwb3MiLCJ0b3AiLCJrZXl1cCIsInQiLCJ0MSIsImtleUNvZGUiLCJ0cmFuc1BhcnNlIiwibGVuZ3RoIiwidHJhbnNmb3JtTGlzdCIsImxvY2tEZXNjcmlwdGlvbiIsIm5vZGUiLCJub2RlMSIsImZpbHRlciIsImwiLCJub2RlcyIsImR2cyIsInpwYXJhbXMiLCJ6ZHYiLCJuIiwiaXZzIiwiaXYiLCJkdiIsImZvcmNlU3dpdGNoIiwiZXJhc2UiLCJkb2N1bWVudCIsImJvZHkiLCJyZW5kZXIiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUVBOzs7O0FBRUE7Ozs7QUFFQTs7SUFBWUEsRzs7QUFDWjs7SUFBWUMsRzs7QUFDWjs7SUFBWUMsSzs7QUFDWjs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7QUFFQSxTQUFTQyxrQkFBVCxDQUE0QkMsS0FBNUIsRUFBbUM7QUFDL0IsV0FBTyxZQUFXO0FBQ2QsYUFBS0MsS0FBTCxDQUFXLGtCQUFYLElBQWlDRCxLQUFqQztBQUNILEtBRkQ7QUFHSDs7QUFFTSxJQUFJRSxzQkFBTyxTQUFQQSxJQUFPLENBQUNDLE1BQUQsRUFBU0MsU0FBVCxFQUFvQkMsS0FBcEIsRUFBMkJDLE9BQTNCO0FBQUEsV0FBd0M7QUFDOUNILHNCQUQ4QztBQUU5Q0MsNEJBRjhDO0FBRzlDQyxvQkFIOEM7QUFJOUNDLHdCQUo4QztBQUs5Q0MsdUJBQWUsSUFMK0I7QUFNOUNDLGtCQUFVLHdCQU5vQztBQU85Q0MsZUFBTyxpQkFBTTtBQUNULGdDQUFVQyxPQUFWLENBQWtCLElBQWxCO0FBQ0FDLDRCQUFnQixLQUFoQjtBQUNIO0FBVjZDLEtBQXhDO0FBQUEsQ0FBWDs7QUFjQSxJQUFJQyw0QkFBVTtBQUNUQyxRQUFJLGdCQURLO0FBRVRDLFVBQU0sRUFBQ0MsU0FBUSxJQUFULEVBRkc7QUFHVEMscUJBQWlCLElBSFI7QUFJVEMsb0JBQWdCLEdBSlA7QUFLVDtBQUNBQyxXQUFPLENBQ0hoQixLQUFLLFVBQUwsRUFBaUIsUUFBakIsRUFBMkIsNkJBQTNCLG9NQURHLEVBSUhBLEtBQUssVUFBTCxFQUFpQixRQUFqQixFQUEyQiwwQkFBM0IsRUFDSyx3RUFETCxDQUpHLEVBTUhBLEtBQUssV0FBTCxFQUFrQixPQUFsQixFQUEyQixjQUEzQixpZEFORyxFQVdIQSxLQUFLLFdBQUwsRUFBa0IsT0FBbEIsRUFBMkIsaUJBQTNCLHVXQVhHLEVBZUhBLEtBQUssYUFBTCxFQUFvQixNQUFwQixFQUE0QixjQUE1Qix5Y0FmRztBQW1CSDtBQUNBO0FBQ0E7QUFDQUEsU0FBSyxTQUFMLEVBQWdCLE9BQWhCLEVBQXlCLGlCQUF6QixFQUE0QywyREFBNUMsQ0F0QkcsRUF1QkhBLEtBQUssY0FBTCxFQUFxQixPQUFyQixFQUE4QixlQUE5Qiw4TUF2QkcsRUEwQkhBLEtBQUssZUFBTCxFQUFzQixRQUF0QixFQUFnQyxnQkFBaEMsRUFDSywrR0FETCxDQTFCRztBQU5FLENBQWQ7O0FBcUNBLElBQUlpQiw0QkFBVTtBQUNUTixRQUFJLGdCQURLO0FBRVRDLFVBQU0sRUFBQ0MsU0FBUSxJQUFULEVBRkc7QUFHVEMscUJBQWlCLElBSFI7QUFJVEMsb0JBQWdCLEdBSlA7QUFLVEMsV0FBTyxDQUNIaEIsS0FBSyxXQUFMLEVBQWtCLE9BQWxCLEVBQTJCLGlCQUEzQix1V0FERztBQUxFLENBQWQ7O0FBaUJQLFNBQVNrQixTQUFULEdBQXFCO0FBQ2pCLFdBQU8sd0NBRUgsRUFBQ0MsTUFBTSxNQUFQO0FBQ0NoQixlQUFPLGdCQURSO0FBRUNpQixpQkFBUyxDQUNMLDhDQUNFLEVBQUNULElBQUksY0FBTDtBQUNDVSxpQkFBSyxNQUROO0FBRUNsQixtQkFBTyxtRkFGUixFQURGLEVBSUUsV0FKRixDQURLLEVBTUwsOENBQVUsRUFBQ1EsSUFBSSxXQUFMLEVBQWtCVSxLQUFLLE1BQXZCLEVBQStCQyxTQUFTLGFBQXhDLEVBQVYsRUFBa0UsYUFBbEUsQ0FOSyxFQU02RTtBQUNsRixzREFDRSxFQUFDWCxJQUFJLFdBQUw7QUFDQ1cscUJBQVMsMEVBRFY7QUFFQ0MscUJBQVM7QUFBQSx1QkFBSzdCLElBQUk4QixjQUFKLENBQW1CLFdBQW5CLENBQUw7QUFBQSxhQUZWO0FBR0N6QixrQ0FBbUJMLElBQUkrQixNQUFKLEdBQWEsTUFBYixHQUFzQixNQUF6Qyx3Q0FIRDtBQUlDdEIsbUJBQU8seUNBSlIsRUFERixFQU1FLHVCQUFFLDhDQUFGLEVBQWtELHFCQUFsRCxDQU5GLENBUEssQ0FGVixFQUZHLEVBa0JILGlEQUEwQix1QkFBSyxNQUFMLEVBQWEsTUFBYixDQUExQiw0Q0FDRSx5Q0FBVSxFQUFDdUIsYUFBYSw2QkFBZCxFQUFWLENBREYsRUFFRSw0Q0FBUSxFQUFDQyxPQUFPakMsSUFBSWtDLFFBQVosRUFBc0J6QixPQUFPLG9CQUE3QixFQUFSLENBRkYsQ0FsQkcsRUFxQkgsaURBQTBCLHVCQUFLLE1BQUwsRUFBYSxNQUFiLENBQTFCLHFEQXJCRyxFQXNCSCx1QkFBRSxtRkFBRixFQUNJLHVCQUFFLHdIQUFGLENBREosRUFFSSw4Q0FBVSxFQUFDUSxJQUFJLFNBQUwsRUFBZ0JZLFNBQVE7QUFBQSxtQkFBRzdCLElBQUltQyxRQUFKLENBQWEsU0FBYixDQUFIO0FBQUEsU0FBeEIsRUFBbUQxQixPQUFPLHlDQUExRCxFQUFWLEVBQWdILFlBQWhILENBRkosQ0F0Qkc7O0FBMEJSO0FBQ0ssMkJBQUUsNEJBQUYsRUFDRSxnRUFBeUMsdUJBQUssTUFBTCxFQUFhLE1BQWIsQ0FBekMsUUFDRSxFQUFDQSxPQUFPLHFHQUFSLEVBREYsRUFFRSx1QkFBRSxRQUFGLEVBQ0UsdUJBQUUsR0FBRixFQUFPVCxJQUFJb0MsT0FBSixDQUFZQyxJQUFuQixDQURGLEVBRUUsdUJBQUUsSUFBRixDQUZGLEVBR0UsdUJBQUUsR0FBRixFQUFPckMsSUFBSW9DLE9BQUosQ0FBWUUsSUFBbkIsQ0FIRixDQUZGLEVBTUUsdUJBQUUsT0FBRixFQUFXdEMsSUFBSW9DLE9BQUosQ0FBWUcsSUFBWixDQUFpQkMsR0FBakIsQ0FDUDtBQUFBLGVBQU0sdUJBQUUsSUFBRixFQUFRQyxHQUFHRCxHQUFILENBQ1Y7QUFBQSxtQkFBTSx1QkFBRSxJQUFGLEVBQVEsRUFBQ0UsYUFBYXZDLG1CQUFtQixXQUFuQixDQUFkLEVBQStDd0MsWUFBWXhDLG1CQUFtQixRQUFuQixDQUEzRCxFQUFSLEVBQ0V5QyxFQURGLENBQU47QUFBQSxTQURVLENBQVIsQ0FBTjtBQUFBLEtBRE8sQ0FBWCxDQU5GLENBREYsQ0EzQkcsQ0FBUDtBQXNDSDs7QUFFRCxJQUFJQyxXQUFXLFNBQVhBLFFBQVcsQ0FBQzVCLEVBQUQsRUFBSzZCLEtBQUwsRUFBWUMsSUFBWixFQUFrQnRDLEtBQWxCLEVBQXlCdUMsUUFBekI7QUFBQSxXQUFzQyw2QkFDN0MvQixFQUQ2Qyx3QkFDeEIsdUJBQUssT0FBTCxFQUFjNkIsS0FBZCxDQUR3QiwrQ0FFakQsNENBQ0UsRUFBQ2IsT0FBT2dCLE9BQU9DLElBQVAsQ0FBWUgsUUFBUSxFQUFwQixDQUFSO0FBQ0N0QyxlQUFPQSxRQUFRLGNBRGhCO0FBRUNDLGlCQUFTO0FBQUEsbUJBQUtxQyxLQUFLSSxDQUFMLEVBQVEsQ0FBUixDQUFMO0FBQUEsU0FGVjtBQUdDSCxrQkFBVUEsUUFIWCxFQURGLENBRmlELENBQXRDO0FBQUEsQ0FBZjs7QUFRQSxTQUFTSSxVQUFULENBQW9CQyxJQUFwQixFQUEwQjtBQUN0QixRQUFJQyxRQUFRLFNBQVJBLEtBQVEsQ0FBQ0MsR0FBRCxFQUFNdEMsRUFBTixFQUFVUixLQUFWO0FBQUEsZUFDUix1QkFBRSxJQUFGLEVBQ0UsdUJBQUUsUUFBRixFQUFZLEVBQUNKLE9BQU8sRUFBQ21ELE9BQU8sTUFBUixFQUFSLEVBQVosRUFDRSxnQ0FBU3ZDLEVBQVQsaUJBQXVCQSxFQUF2QixrQ0FBc0RzQyxHQUF0RCxZQUNFLEVBQUNsRCxPQUFPLEVBQUNvRCxPQUFPLEtBQVIsRUFBZUMsUUFBUSxLQUF2QixFQUE4QkMsUUFBUSxnQkFBdEMsRUFBd0QsaUJBQWlCLEtBQXpFLEVBQWdGQyxTQUFTLEtBQXpGLEVBQWdHQyxRQUFRLElBQXhHLEVBQThHQyxRQUFRLFNBQXRILEVBQVIsRUFERixDQURGLEVBR0UsdUJBQUUsWUFBRixFQUFnQixFQUFDekQsT0FBTyxFQUFDLGNBQWMsUUFBZixFQUFSLEVBQWhCLEVBQW1ESSxLQUFuRCxDQUhGLENBREYsQ0FEUTtBQUFBLEtBQVo7QUFNQSxRQUFJc0Qsb0JBQW9CLFNBQXBCQSxpQkFBb0IsR0FBTTtBQUMxQixZQUFJQyxRQUFRLEVBQVo7QUFEMEI7QUFBQTtBQUFBOztBQUFBO0FBRTFCLGlDQUFpQmhFLElBQUlpRSxLQUFyQiw4SEFBNEI7QUFBQSxvQkFBbkJDLElBQW1COztBQUN4QixvQkFBSSxDQUFDRixNQUFNRyxRQUFOLENBQWVELEtBQUtFLE1BQUwsQ0FBWS9CLElBQTNCLENBQUwsRUFBdUM7QUFDbkMyQiwwQkFBTUssSUFBTixDQUFXSCxLQUFLRSxNQUFMLENBQVkvQixJQUF2QjtBQUNIO0FBQ0Qsb0JBQUksQ0FBQzJCLE1BQU1HLFFBQU4sQ0FBZUQsS0FBSzNELE1BQUwsQ0FBWThCLElBQTNCLENBQUwsRUFBdUM7QUFDbkMyQiwwQkFBTUssSUFBTixDQUFXSCxLQUFLM0QsTUFBTCxDQUFZOEIsSUFBdkI7QUFDSDtBQUNKO0FBVHlCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBVTFCLGVBQU8yQixLQUFQO0FBQ0gsS0FYRDtBQVlBLFdBQU9YLE9BQ0gsd0NBQ0UsRUFBQzVCLE1BQU0sT0FBUDtBQUNDaEIsZUFBTyxvQkFEUjtBQUVDNkQseUJBQWlCLElBRmxCO0FBR0M1QyxpQkFBUyxDQUNMLDhDQUFVLEVBQUNULElBQUksZUFBTCxFQUFWLEVBQWlDLFlBQWpDLENBREssRUFFTCw4Q0FBVSxFQUFDQSxJQUFJLGNBQUwsRUFBVixFQUFnQyxXQUFoQyxDQUZLLENBSFYsRUFERixFQU9FLHVCQUFFLHNCQUFGLEVBQTBCLEVBQUNaLE9BQU8sMkhBQVIsRUFBMUIsRUFDRSx1QkFBRSxZQUFGLEVBQWdCLEVBQUNBLE9BQU8sbUdBQVIsRUFBaEIsQ0FERixDQVBGLEVBU0UsdUJBQUUsbUpBQUYsQ0FURixFQVVFLHVCQUFFLGNBQUYsRUFDRSxFQUFDQSxPQUFPLEVBQUMsU0FBUyxLQUFWLEVBQWlCLFVBQVUsS0FBM0IsRUFBa0MsU0FBUyxNQUEzQyxFQUFtRCxvQkFBb0IsT0FBdkUsRUFBZ0YsZ0JBQWdCLE9BQWhHLEVBQXlHLGlCQUFpQixPQUExSCxFQUFtSSxZQUFZLE1BQS9JLEVBQXVKLGVBQWUsUUFBdEssRUFBUixFQURGLEVBRUUsdUJBQUUsaUJBQUYsRUFDRSxFQUFDQSxPQUFPLEVBQUMsU0FBUyxNQUFWLEVBQWtCLFVBQVUsS0FBNUIsRUFBbUMsb0JBQW9CLE9BQXZELEVBQWdFLGNBQWMsSUFBOUUsRUFBb0YsZ0JBQWdCLElBQXBHLEVBQTBHLGlCQUFpQixPQUEzSCxFQUFvSSxZQUFZLE1BQWhKLEVBQXdKLGVBQWUsUUFBdkssRUFBUixFQURGLEVBRUUsdUJBQUUsT0FBRixFQUNFLHVCQUFFLE9BQUYsRUFDRSx1QkFBRSxJQUFGLEVBQVFpRCxNQUFNLENBQU4sRUFBUyxhQUFULEVBQXdCLGNBQXhCLENBQVIsRUFBaURBLE1BQU0sQ0FBTixFQUFTLFNBQVQsRUFBb0IsVUFBcEIsQ0FBakQsRUFBa0ZBLE1BQU0sQ0FBTixFQUFTLFdBQVQsRUFBc0IsV0FBdEIsQ0FBbEYsQ0FERixDQURGLENBRkYsQ0FGRixFQU9FLHVCQUFFLGVBQUYsRUFBbUIsRUFBQ2pELE9BQU8sRUFBQ29ELE9BQU8sTUFBUixFQUFnQkMsUUFBUSxPQUF4QixFQUFpQyxjQUFjLFFBQS9DLEVBQXlELGNBQWMsSUFBdkUsRUFBNkUsb0JBQW9CLE9BQWpHLEVBQTBHLGVBQWUsUUFBekgsRUFBUixFQUFuQixFQUNFLHVCQUFFLDZCQUFGLEVBQWlDLEVBQUNyRCxPQUFPLEVBQUMsU0FBUyxPQUFWLEVBQW1CLFVBQVUsS0FBN0IsRUFBb0Msb0JBQW9CLE9BQXhELEVBQWlFLFNBQVMsTUFBMUUsRUFBa0YsWUFBWSxRQUE5RixFQUF3RyxVQUFVLFlBQWxILEVBQVIsRUFBakMsQ0FERixFQUVFLHVCQUFFLDJCQUFGLEVBQStCLEVBQUNBLE9BQU8sRUFBQyxTQUFTLE9BQVYsRUFBbUIsVUFBVSxLQUE3QixFQUFvQyxTQUFTLE1BQTdDLEVBQXFELFlBQVksUUFBakUsRUFBMkUsb0JBQW9CLFNBQS9GLEVBQTBHLFVBQVUsTUFBcEgsRUFBUixFQUEvQixDQUZGLEVBR0UsdUJBQUUsMkJBQUYsRUFBK0IsRUFBQ0EsT0FBTyxFQUFDLFNBQVMsT0FBVixFQUFtQixVQUFVLEtBQTdCLEVBQW9DLG9CQUFvQixPQUF4RCxFQUFpRSxTQUFTLE1BQTFFLEVBQWtGLFlBQVksUUFBOUYsRUFBd0csVUFBVSxLQUFsSCxFQUFSLEVBQS9CLENBSEYsQ0FQRixFQVdFLHVCQUFFLEtBQUYsRUFBUyxFQUFDQSxPQUFPLEVBQUMsaUJBQWlCLE9BQWxCLEVBQTJCLFdBQVcsY0FBdEMsRUFBc0QsU0FBUyxNQUEvRCxFQUF1RSxpQkFBaUIsSUFBeEYsRUFBOEYsY0FBYyxRQUE1RyxFQUFSLEVBQVQsRUFDRSx1QkFBRSxZQUFGLEVBQWdCLEVBQUNBLE9BQU8sRUFBQyxrQkFBa0IsR0FBbkIsRUFBUixFQUFoQixDQURGLENBWEYsRUFhRSx1QkFBRSwwQ0FBRixFQUNFLEVBQUNBLE9BQU8sRUFBQyxTQUFTLE1BQVYsRUFBa0IsVUFBVSxLQUE1QixFQUFtQyxvQkFBb0IsT0FBdkQsRUFBZ0UsU0FBUyxNQUF6RSxFQUFpRixlQUFlLFFBQWhHLEVBQTBHLGlCQUFpQixJQUEzSCxFQUFpSSxpQkFBaUIsT0FBbEosRUFBUixFQURGLENBYkYsQ0FWRixFQXlCRSx1QkFBRSxlQUFGLEVBQ0UsRUFBQ0EsT0FBTyxFQUFDb0QsT0FBTyxLQUFSLEVBQWVDLFFBQVEsS0FBdkIsRUFBOEJGLE9BQU8sT0FBckMsRUFBOEMsb0JBQW9CLE9BQWxFLEVBQTJFLGdCQUFnQixRQUEzRixFQUFxRyxlQUFlLFFBQXBILEVBQVIsRUFERixFQUVFLHVCQUFFLGlDQUFGLEVBQ0UsRUFBQ25ELE9BQU8sRUFBQ29ELE9BQU8sTUFBUixFQUFnQkMsUUFBUSxNQUF4QixFQUFnQyxvQkFBb0IsT0FBcEQsRUFBNkRGLE9BQU8sTUFBcEUsRUFBNEVlLFVBQVUsTUFBdEYsRUFBOEYsZUFBZSxRQUE3RyxFQUF1SCxnQkFBZ0IsUUFBdkksRUFBaUosaUJBQWlCLFFBQWxLLEVBQVIsRUFERixFQUVFLHVCQUFFLGdCQUFGLEVBQW9CLEVBQUNsRSxPQUFPLEVBQUNvRCxPQUFPLE1BQVIsRUFBZ0JDLFFBQVEsS0FBeEIsRUFBK0JhLFVBQVUsTUFBekMsRUFBaUQsY0FBYyxNQUEvRCxFQUF1RSx1QkFBdUIsT0FBOUYsRUFBUixFQUFwQixFQUNFLHVCQUFFLFVBQUYsRUFBYyxFQUFDbEUsT0FBTyxFQUFDd0QsUUFBUSxJQUFULEVBQVIsRUFBZCxFQUNFLHVCQUFFLElBQUYsRUFBUSxFQUFDeEQsT0FBTyxFQUFDLGNBQWMsUUFBZixFQUFSLEVBQVIsRUFBMkMsNkJBQTNDLENBREYsRUFFRSx1QkFBRSxHQUFGLEVBQU8sRUFBQ0EsT0FBTyxFQUFDLGVBQWUsOEJBQWhCLEVBQWdELGFBQWEsTUFBN0QsRUFBUixFQUFQLEVBQ0UsNERBREYsQ0FGRixFQUlFLHVCQUFFLGFBQUYsRUFBaUIsRUFBQ0EsT0FBTyxFQUFDRCxPQUFPLFNBQVIsRUFBbUIsZUFBZSw4QkFBbEMsRUFBa0UsYUFBYSxNQUEvRSxFQUFSLEVBQWpCLEVBQ0UseUNBREYsQ0FKRixDQURGLEVBT0UsdUJBQUUsV0FBRixFQUFlLEVBQUNDLE9BQU8sRUFBQ21FLFNBQVMsT0FBVixFQUFtQixVQUFVLElBQTdCLEVBQVIsRUFBZixFQUNFLHVCQUFFLHlDQUFGLEVBQTZDLEVBQUNuRSxPQUFPLEVBQUMsZUFBZSxJQUFoQixFQUFSLEVBQTdDLENBREYsRUFFRSx1QkFBRSx5REFBRixDQUZGLEVBR0UsdUJBQUUsNERBQUYsRUFBZ0UsRUFBQ0EsT0FBTyxFQUFDbUQsT0FBTyxNQUFSLEVBQWdCLGVBQWUsSUFBL0IsRUFBUixFQUFoRSxFQUNFLGNBREYsQ0FIRixFQUtFLHVCQUFFLHdEQUFGLEVBQTRELEVBQUNuRCxPQUFPLEVBQUNtRCxPQUFPLE1BQVIsRUFBZ0IsZUFBZSxJQUEvQixFQUFSLEVBQTVELEVBQ0UsVUFERixDQUxGLENBUEYsRUFjRSx1QkFBRSxXQUFGLEVBQWUsRUFBQ25ELE9BQU8sRUFBQ21FLFNBQVMsT0FBVixFQUFtQlgsUUFBUSxJQUEzQixFQUFSLEVBQWYsRUFDRSx1QkFBRSwwQ0FBRixFQUE4QyxFQUFDeEQsT0FBTyxFQUFDLGVBQWUsSUFBaEIsRUFBUixFQUE5QyxDQURGLEVBRUUsdUJBQUUsMERBQUYsQ0FGRixFQUdFLHVCQUFFLDREQUFGLEVBQWdFLEVBQUNBLE9BQU8sRUFBQ21ELE9BQU8sTUFBUixFQUFnQixlQUFlLElBQS9CLEVBQVIsRUFBaEUsRUFBK0csY0FBL0csQ0FIRixFQUlFLHVCQUFFLHdEQUFGLEVBQTRELEVBQUNuRCxPQUFPLEVBQUNtRCxPQUFPLE1BQVIsRUFBZ0IsZUFBZSxJQUEvQixFQUFSLEVBQTVELEVBQTJHLFVBQTNHLENBSkYsQ0FkRixFQW1CRSx1QkFBRSxzREFBRixDQW5CRixFQW9CRSx1QkFBRSxzREFBRixDQXBCRixFQXFCRSx1QkFBRSwyREFBRixFQUErRCxtQkFBL0QsQ0FyQkYsRUFzQkUsdUJBQUUsdUVBQUYsQ0F0QkYsRUF1QkUsdUJBQUUsbUVBQUYsRUFBdUUsRUFBQ25ELE9BQU8sRUFBQ21FLFNBQVMsT0FBVixFQUFtQlgsUUFBUSxRQUEzQixFQUFxQ1ksVUFBVSxVQUEvQyxFQUFSLEVBQXZFLEVBQ0UsUUFERixDQXZCRixDQUZGLEVBMkJFLHVCQUFFLFlBQUYsRUFBZ0IsRUFBQ3BFLE9BQU8sRUFBQ29ELE9BQU8sTUFBUixFQUFnQkMsUUFBUSxPQUF4QixFQUFpQyx1QkFBdUIsT0FBeEQsRUFBUixFQUFoQixFQUNFLHVCQUFFLFFBQUYsRUFBWSxFQUFDckQsT0FBTyxFQUFDb0QsT0FBT3hELElBQUl5RSxTQUFKLENBQWMsT0FBZCxJQUF5QixHQUFqQyxFQUFzQ2hCLFFBQVEsTUFBOUMsRUFBc0RGLE9BQU8sTUFBN0QsRUFBcUVlLFVBQVUsUUFBL0UsRUFBUixFQUFaLEVBQStHLE9BQS9HLENBREYsRUFFRSx1QkFBRSxRQUFGLEVBQVksRUFBQ2xFLE9BQU8sRUFBQ29ELE9BQU94RCxJQUFJeUUsU0FBSixDQUFjLE9BQWQsSUFBeUIsR0FBakMsRUFBc0NoQixRQUFRLE1BQTlDLEVBQXNERixPQUFPLE9BQTdELEVBQXNFZSxVQUFVLFFBQWhGLEVBQVIsRUFBWixFQUFnSCxPQUFoSCxDQUZGLENBM0JGLEVBOEJFLHVCQUFFLFlBQUYsRUFBZ0IsRUFBQ2xFLE9BQU8sRUFBQ29ELE9BQU8sTUFBUixFQUFnQkMsUUFBUSxLQUF4QixFQUErQix1QkFBdUIsT0FBdEQsRUFBK0RhLFVBQVUsUUFBekUsRUFBUixFQUFoQixDQTlCRixDQUZGLENBekJGLEVBMERFLHVCQUFFLGlCQUFGLEVBQXFCLEVBQUNsRSxPQUFPLEVBQUN1RCxTQUFTLFVBQVYsRUFBUixFQUFyQixFQUNFLHVCQUFFLGdDQUFGLEVBQ0VHLG9CQUFvQnZCLEdBQXBCLENBQXdCO0FBQUEsZUFBSyw4QkFBT21DLEVBQUVDLE9BQUYsQ0FBVSxLQUFWLEVBQWlCLEdBQWpCLENBQVAsRUFBZ0MsRUFBQy9DLFNBQVM7QUFBQSx1QkFBSTVCLElBQUk0RSxXQUFKLENBQWdCRixDQUFoQixDQUFKO0FBQUEsYUFBVixFQUFrQ3RFLE9BQU8sRUFBQyxvQkFBb0JMLElBQUk4RSxRQUF6QixFQUF6QyxFQUFoQyxFQUE4R0gsQ0FBOUcsQ0FBTDtBQUFBLEtBQXhCLENBREYsQ0FERixDQTFERixFQTZERSx1QkFBRSw4Q0FBRixDQTdERixDQURHO0FBK0RQO0FBQ0EsNENBQ0UsRUFBQ2xELE1BQU0sT0FBUDtBQUNDaEIsZUFBTyxpQkFEUjtBQUVDaUIsaUJBQVMsQ0FBQyxDQUFDMUIsSUFBSStFLGFBQUwsR0FBcUIsRUFBckIsR0FBMEIsQ0FDaEMsOENBQVUsRUFBQzlELElBQUksV0FBTCxFQUFWLEVBQTZCLFFBQTdCLENBRGdDLEVBRWhDLDhDQUFVLEVBQUNBLElBQUksU0FBTCxFQUFWLEVBQTJCLFlBQTNCLENBRmdDLEVBR2hDLDhDQUFVLEVBQUNBLElBQUksWUFBTCxFQUFWLEVBQThCLFNBQTlCLENBSGdDLENBQTNCLEVBSU4rRCxNQUpNLENBSUMsQ0FDTiw4Q0FBVSxFQUFDL0QsSUFBSSxTQUFMLEVBQWdCcUQsaUJBQWlCckUsSUFBSWdGLE9BQXJDLEVBQVYsRUFBeUQsV0FBekQsQ0FETSxFQUVOLDhDQUFVLEVBQUNoRSxJQUFJLFlBQUwsRUFBbUJxRCxpQkFBaUJyRSxJQUFJZ0YsT0FBeEMsRUFBVixFQUE0RCxTQUE1RCxDQUZNLEVBR04sOENBQVUsRUFBQ2hFLElBQUksWUFBTCxFQUFtQnFELGlCQUFpQnJFLElBQUlnRixPQUF4QyxFQUFWLEVBQTRELFNBQTVELENBSE0sRUFJTiw4Q0FBVSxFQUFDaEUsSUFBSSxTQUFMLEVBQWdCcUQsaUJBQWlCckUsSUFBSWdGLE9BQXJDLEVBQVYsRUFBeUQsWUFBekQsQ0FKTSxFQUtOLDhDQUFVLEVBQUNoRSxJQUFJLFlBQUwsRUFBbUJxRCxpQkFBaUJyRSxJQUFJZ0YsT0FBeEMsRUFBVixFQUE0RCxTQUE1RCxDQUxNLENBSkQsQ0FGVixFQURGLEVBYUUsb0RBQTZCLHVCQUFLLE9BQUwsRUFBYyxZQUFkLENBQTdCLDBCQUNFLHVCQUFFLHNIQUFGLENBREYsRUFFRSx1QkFBRSxtRkFBRixDQUZGLEVBR0UsdUJBQUUsMENBQUYsQ0FIRixDQWJGO0FBaUJJO0FBQ0YscURBQTBCLHVCQUFLLE9BQUwsRUFBYyxTQUFkLENBQTFCLFFBQ0UsdUJBQUUsaUdBQUYsQ0FERixFQUVFLHVCQUFFLDZHQUFGLEVBQ0ksdUJBQUUsMERBQUYsRUFBOEQsRUFBQ3BELFNBQVM7QUFBQSxtQkFBSTdCLElBQUlrRixZQUFKLENBQWlCLGFBQWpCLENBQUo7QUFBQSxTQUFWLEVBQStDN0UsT0FBTyxFQUFDbUQsT0FBTyxNQUFSLEVBQWdCLGVBQWUsSUFBL0IsRUFBdEQsRUFBOUQsRUFBMkosb0JBQTNKLENBREosRUFFSSx1QkFBRSwwREFBRixFQUE4RCxFQUFDM0IsU0FBUztBQUFBLG1CQUFJN0IsSUFBSW1GLFlBQUosQ0FBaUIsYUFBakIsQ0FBSjtBQUFBLFNBQVYsRUFBK0M5RSxPQUFPLEVBQUNtRCxPQUFPLE1BQVIsRUFBZ0IsZUFBZSxJQUEvQixFQUF0RCxFQUE5RCxFQUEySiwwQkFBM0osQ0FGSixDQUZGLEVBS0UsdUJBQUUsa0hBQUYsQ0FMRixFQU1FLHVCQUFFLDZHQUFGLENBTkYsRUFPRSx1QkFBRSxnSEFBRixFQUNJLHVCQUFFLGtIQUFGLEVBQ0ksdUJBQUUsc0hBQUYsQ0FESixFQUVJLHVCQUFFLHVIQUFGLENBRkosQ0FESixFQUlJLHVCQUFFLHdIQUFGLENBSkosRUFLSSx1QkFBRSw0SEFBRixFQUNJLDhDQUNJLEVBQUN2QyxJQUFJLGdCQUFMO0FBQ0FXLGlCQUFTLDBFQURUO0FBRUFDLGlCQUFTO0FBQUEsbUJBQUs3QixJQUFJb0YsZUFBSixDQUFvQixnQkFBcEIsQ0FBTDtBQUFBLFNBRlQ7QUFHQS9FLGdFQUhBO0FBSUFJLGVBQU8sbUJBSlAsRUFESixFQU1JLHVCQUFFLDhDQUFGLEVBQWtELG9CQUFsRCxDQU5KLENBREosQ0FMSixFQWFJLHVCQUFFLCtIQUFGLENBYkosQ0FQRixDQWxCRixFQXVDRW9DLFNBQVMsUUFBVCxFQUFtQixXQUFuQixDQXZDRixFQXdDRUEsU0FBUyxPQUFULEVBQWtCLFNBQWxCLEVBQTZCN0MsSUFBSXFGLFdBQWpDLEVBQThDLE1BQTlDLEVBQXNELFVBQXRELENBeENGLEVBeUNFeEMsU0FBUyxVQUFULEVBQXFCLFlBQXJCLEVBQW1DN0MsSUFBSXNGLGNBQXZDLEVBQXVELGNBQXZELEVBQXVFLGFBQXZFLENBekNGLEVBMENFekMsU0FBUyxTQUFULEVBQW9CLFlBQXBCLEVBQWtDN0MsSUFBSXVGLFVBQXRDLEVBQWtELFFBQWxELEVBQTRELFFBQTVELENBMUNGLENBaEVBO0FBMkdIOztBQUVELElBQUlDLFNBQVMsU0FBVEEsTUFBUyxPQUFRO0FBQ2pCLFFBQUl0QixPQUFPLFNBQVBBLElBQU87QUFBQSxlQUFRLDhCQUFNN0IsU0FBU2dCLElBQVQsR0FBZ0IsU0FBaEIsR0FBNEIsRUFBbEMsZ0JBQThDaEIsSUFBOUMsbUNBQWtGLEVBQUNvRCxVQUFVLGtCQUFFQyxLQUFGLENBQVF4QixJQUFuQixFQUFsRixFQUE0RzdCLEtBQUssQ0FBTCxFQUFRc0QsV0FBUixLQUF3QnRELEtBQUt1RCxLQUFMLENBQVcsQ0FBWCxDQUFwSSxDQUFSO0FBQUEsS0FBWDtBQUNBLFdBQU8sdUJBQUUsMEhBQUYsRUFDSDFCLEtBQUssT0FBTCxDQURHLEVBRUhBLEtBQUssU0FBTCxDQUZHLEVBR0gsdUJBQUUsdUNBQUYsRUFBMkMsYUFBM0MsQ0FIRyxFQUlILHVCQUFFLDJCQUFGLEVBQStCLEtBQS9CLENBSkc7QUFLSDtBQUNBLDJCQUFFLDJDQUFGLEVBQStDLGFBQS9DLENBTkc7QUFPSDtBQUNBO0FBQ0E7QUFDQSwyQkFBRSwyQkFBRixFQUErQixLQUEvQixDQVZHLEVBV0YsdUJBQUUsMkJBQUYsRUFBK0IsVUFBVTJCLFVBQXpDLENBWEUsRUFZRix1QkFBRSwyQkFBRixFQUErQixLQUEvQixDQVpFLEVBYUYsdUJBQUUsMkJBQUYsRUFBK0IsaUJBQWlCQyxrQkFBaEQsQ0FiRSxDQUFQO0FBY0gsQ0FoQkQ7O0lBa0JNQyxJOzs7Ozs7OytCQUNLQyxLLEVBQU87QUFDVixnQkFBSUEsTUFBTUMsS0FBTixDQUFZNUMsSUFBaEIsRUFBc0I7QUFDbEIsa0NBQUVxQyxLQUFGLENBQVFRLEdBQVIsQ0FBWSxRQUFaO0FBQ0g7QUFDRCxpQkFBS0MsS0FBTCxHQUFhLEtBQWI7QUFDQSxpQkFBS0MsU0FBTCxHQUFpQixLQUFqQjtBQUNBLGlCQUFLQyxJQUFMLEdBQVksS0FBWjtBQUNBLGlCQUFLQyxVQUFMLEdBQWtCLEtBQWxCO0FBQ0EsaUJBQUtDLFNBQUwsR0FBaUIsSUFBakI7QUFDSDs7O21DQUVVO0FBQ1AsZ0JBQUlDLFVBQVUsU0FBVkEsT0FBVSxDQUFDbkUsSUFBRCxFQUFPb0UsR0FBUCxFQUFZQyxNQUFaLEVBQW9COUIsT0FBcEIsRUFBZ0M7QUFDMUM2QixzQkFBTUEsTUFBTSxHQUFaO0FBQ0Esb0JBQUlFLE1BQU1DLE9BQU9DLFFBQVAsQ0FBZ0JDLFFBQWhCLEVBQVY7QUFDQSxvQkFBSUMsTUFBTUosSUFBSUssT0FBSixDQUFZUCxHQUFaLElBQW1CLENBQW5CLEdBQXVCRSxJQUFJTSxTQUFKLENBQWNOLElBQUlLLE9BQUosQ0FBWVAsR0FBWixJQUFtQkMsTUFBakMsQ0FBdkIsR0FBa0UsRUFBNUU7QUFDQSxvQkFBSW5ELE1BQU13RCxJQUFJQyxPQUFKLENBQVksR0FBWixDQUFWO0FBQ0FELHNCQUFNeEQsTUFBTSxDQUFOLEdBQVV3RCxJQUFJRSxTQUFKLENBQWMsQ0FBZCxFQUFpQjFELEdBQWpCLENBQVYsR0FBa0N3RCxHQUF4QztBQUNBQSxzQkFBTUEsSUFBSW5DLE9BQUosQ0FBWSxVQUFaLEVBQXdCLEVBQXhCLENBQU47QUFDQXNDLHdCQUFRQyxHQUFSLENBQVk5RSxJQUFaLEVBQWtCLElBQWxCLEVBQXdCMEUsR0FBeEI7QUFDQSxvQkFBSW5DLE9BQUosRUFBYW1DLE1BQU1BLElBQ2RuQyxPQURjLENBQ04sTUFETSxFQUNFLEdBREYsRUFFZEEsT0FGYyxDQUVOLE1BRk0sRUFFRSxHQUZGLEVBR2RBLE9BSGMsQ0FHTixNQUhNLEVBR0UsR0FIRixDQUFOO0FBSWIsdUJBQU9tQyxHQUFQO0FBQ0gsYUFiRDtBQWNBL0csZ0JBQUlvSCxJQUFKLENBQ0laLFFBQVEsUUFBUixFQUFrQixNQUFsQixFQUEwQixDQUExQixDQURKLEVBRUlBLFFBQVEsVUFBUixFQUFvQixNQUFwQixFQUE0QixDQUE1QixDQUZKLEVBR0lBLFFBQVEsUUFBUixFQUFrQixRQUFsQixFQUE0QixDQUE1QixFQUErQixJQUEvQixDQUhKLEVBSUlBLFFBQVEsU0FBUixFQUFtQixTQUFuQixFQUE4QixDQUE5QixFQUFpQyxJQUFqQyxDQUpKLEVBS0lBLFFBQVEsUUFBUixFQUFrQixLQUFsQixFQUF5QixDQUF6QixDQUxKO0FBTUg7Ozs2QkFFSVIsSyxFQUFPO0FBQUE7O0FBQUEsZ0JBQ0gzQyxJQURHLEdBQ0syQyxNQUFNQyxLQURYLENBQ0g1QyxJQURHOztBQUVSLGdCQUFJNEIsVUFBVTVCLFNBQVMsU0FBdkI7QUFDQXJELGdCQUFJcUgsZUFBSixHQUFzQmhFLFNBQVMsU0FBL0I7QUFDQSxnQkFBSWlFLFlBQVksRUFBaEI7QUFDQSxnQkFBR0MsWUFBVSxtQkFBYixFQUFpQztBQUMvQkQsNEJBQVksQ0FDWixFQUFDN0csT0FBTyxRQUFSLEVBQWtCK0csS0FBS0MsU0FBdkIsRUFEWSxFQUVaLEVBQUNoSCxPQUFPLFNBQVIsRUFBbUIrRyxLQUFLRSxVQUF4QixFQUZZLENBQVo7QUFJRCxhQUxELE1BS087QUFDTEosNEJBQVksQ0FDWixFQUFDN0csT0FBTyxZQUFSLEVBQXNCK0csS0FBS0csY0FBM0IsRUFEWSxFQUVaLEVBQUNsSCxPQUFPLFVBQVIsRUFBb0IrRyxLQUFLSSxZQUF6QixFQUZZLEVBR1osRUFBQ25ILE9BQU8sT0FBUixFQUFpQitHLEtBQUtLLFlBQXRCLEVBSFksRUFJWixFQUFDcEgsT0FBTyxRQUFSLEVBQWtCK0csS0FBS00sVUFBdkIsRUFKWSxDQUFaO0FBS0E7QUFDRixnQkFBSUMsVUFBVSxTQUFWQSxPQUFVLENBQUM5RyxFQUFELEVBQUsrRyxJQUFMLEVBQVdDLEtBQVgsRUFBa0JwRyxPQUFsQixFQUEyQnFHLElBQTNCLEVBQWlDQyxHQUFqQztBQUFBLHVCQUF5QyxtQ0FDekNsSCxFQUR5Qyx3QkFFbkQsRUFBQ1ksU0FBU0EsT0FBVjtBQUNDeEIsMkJBQU8sRUFBQyxlQUFlMkgsT0FBTyxJQUF2QjtBQUNDLHdDQUFnQkMsUUFBUSxJQUR6QjtBQUVDLHFDQUFhRSxHQUZkLEVBRFIsRUFGbUQsRUFNbkRELElBTm1ELENBQXpDO0FBQUEsYUFBZDtBQU9BLGdCQUFJRSxTQUFTLFNBQVRBLE1BQVMsQ0FBQ25ILEVBQUQsRUFBSytHLElBQUwsRUFBV0MsS0FBWCxFQUFrQnBHLE9BQWxCLEVBQTJCcUcsSUFBM0IsRUFBaUNDLEdBQWpDO0FBQUEsdUJBQXlDSixRQUNsRDlHLEtBQUssK0RBRDZDLEVBRWxEK0csSUFGa0QsRUFFNUNDLEtBRjRDLEVBRXJDcEcsT0FGcUMsRUFFNUJxRyxJQUY0QixFQUV0QkMsR0FGc0IsQ0FBekM7QUFBQSxhQUFiO0FBR0EsZ0JBQUlFLFVBQVUsU0FBVkEsT0FBVSxDQUFDcEgsRUFBRCxFQUFLWSxPQUFMLEVBQWNxRyxJQUFkLEVBQW9CekgsS0FBcEI7QUFBQSx1QkFBOEJzSCxRQUNyQzlHLEVBRHFDLDJCQUNiUixLQURhLFFBQ0gsQ0FERyxFQUNBLENBREEsRUFDR29CLE9BREgsRUFDWXFHLElBRFosQ0FBOUI7QUFBQSxhQUFkO0FBRUEsZ0JBQUlJLFFBQVEsU0FBUkEsS0FBUSxDQUFDQyxJQUFELEVBQU9DLFFBQVA7QUFBQSx1QkFBb0IsdUJBQzVCLDhCQUE0QkQsSUFBNUIsSUFBc0NDLFdBQVcsRUFBWCxHQUFnQiw4REFBdEQsQ0FENEIsQ0FBcEI7QUFBQSxhQUFaO0FBRUEsZ0JBQUlDLGlCQUFpQixTQUFqQkEsY0FBaUIsQ0FBQ3hILEVBQUQsRUFBS3lILElBQUw7QUFBQSx1QkFBYywrQkFDekJ6SCxFQUR5QixFQUNuQjtBQUNSWiwyQkFBTyxFQUFDbUUsU0FBUyxNQUFWLEVBQWtCLG9CQUFvQnhFLElBQUk4RSxRQUExQyxFQURDO0FBRVJqRCw2QkFBUyxpQkFBUzhHLEdBQVQsRUFBYztBQUNuQjtBQUNBLDRCQUFJQyxFQUFFLElBQUYsRUFBUUMsSUFBUixPQUFtQixlQUF2QixFQUF3QztBQUNwQ0QsOEJBQUUsU0FBRixFQUFhN0IsR0FBYixDQUFpQitCLEtBQUs5RCxNQUFMLENBQVksR0FBWixDQUFqQjtBQUNBK0QsMENBQWMsSUFBZDtBQUNBSCw4QkFBRSxJQUFGLEVBQVFJLE1BQVIsR0FBaUJDLE9BQWpCLENBQXlCLEdBQXpCO0FBQ0FMLDhCQUFFLFdBQUYsRUFBZU0sTUFBZixDQUFzQixHQUF0QjtBQUNBUCxnQ0FBSVEsZUFBSjtBQUNBO0FBQ0g7O0FBRUQsNEJBQUlMLE9BQU9GLEVBQUUsU0FBRixFQUFhN0IsR0FBYixFQUFYO0FBQ0EsNEJBQUlxQyxRQUFRUixFQUFFLElBQUYsRUFBUUMsSUFBUixHQUFlakUsT0FBZixDQUF1QixHQUF2QixFQUE0QixZQUE1QixDQUFaO0FBQ0EsNEJBQUl5RSxRQUFRVCxFQUFFLElBQUYsRUFBUUMsSUFBUixHQUFlakUsT0FBZixDQUF1QixHQUF2QixFQUE0QmtFLElBQTVCLENBQVo7QUFDQUYsMEJBQUUsU0FBRixFQUFhN0IsR0FBYixDQUFpQnNDLEtBQWpCO0FBQ0FULDBCQUFFLElBQUYsRUFBUUksTUFBUixHQUFpQkMsT0FBakIsQ0FBeUIsR0FBekI7QUFDQU4sNEJBQUlRLGVBQUo7QUFDQUcsa0NBQVVSLElBQVYsRUFBZ0JNLEtBQWhCLEVBQXVCRyxnQkFBZ0IsS0FBdkM7QUFDSDtBQXBCTyxpQkFEbUIsRUF1Qi9CYixLQUFLbEcsR0FBTCxDQUFTO0FBQUEsMkJBQUssdUJBQUUsSUFBRixFQUFRbUMsQ0FBUixDQUFMO0FBQUEsaUJBQVQsQ0F2QitCLENBQWQ7QUFBQSxhQUFyQjtBQXdCQSxnQkFBSTZFLFdBQVcsU0FBWEEsUUFBVyxDQUFDdkksRUFBRCxFQUFLWSxPQUFMLEVBQWNwQixLQUFkLEVBQXFCOEgsSUFBckI7QUFBQSx1QkFBOEIsbUNBQy9CdEgsRUFEK0IsdUJBQ1QsRUFBQ1ksZ0JBQUQsRUFBVXBCLFlBQVYsRUFEUyxFQUNTNkgsTUFBTUMsSUFBTixFQUFZLElBQVosQ0FEVCxDQUE5QjtBQUFBLGFBQWY7O0FBR0EsZ0JBQUlsRixRQUFRLEtBQUtrRCxTQUFqQixFQUE0QjtBQUN4QixvQkFBSXRCLE9BQUosRUFBYTtBQUNUakYsd0JBQUl5SixnQkFBSixDQUFxQnhFLE9BQXJCO0FBQ0FqRix3QkFBSTBKLFlBQUosQ0FBaUIsZUFBakI7QUFDSCxpQkFIRCxNQUdPLElBQUksQ0FBQ3JHLElBQUwsRUFBVztBQUNkckQsd0JBQUkwSixZQUFKLENBQWlCM0UsZ0JBQWdCLFNBQWhCLEdBQTRCLFdBQTdDO0FBQ0g7QUFDRC9FLG9CQUFJMkosT0FBSixJQUFlM0osSUFBSTJKLE9BQUosRUFBZjtBQUNBLHFCQUFLcEQsU0FBTCxHQUFpQmxELElBQWpCO0FBQ0g7O0FBRUQsbUJBQU8sdUJBQ0gsTUFERyxFQUVILHVCQUFFLG9FQUFGLEVBQ0UsRUFBQ2hELE9BQU9nRCxTQUFTLFNBQVQsSUFBc0IsaUZBQTlCLEVBREYsRUFFRSx1QkFBRSxnQkFBRixFQUNFLHVCQUFFLDZHQUFGLEVBQ0UsRUFBQ1gsYUFBYTtBQUFBLDJCQUFLLE1BQUt5RCxLQUFMLEdBQWEsSUFBbEI7QUFBQSxpQkFBZCxFQUFzQ3hELFlBQVk7QUFBQSwyQkFBSyxNQUFLd0QsS0FBTCxHQUFhLEtBQWxCO0FBQUEsaUJBQWxELEVBREYsQ0FERixDQUZGLEVBS0UsdUJBQUUsa0NBQUYsRUFDRSx1QkFBRSwrREFBRixFQUNFLHVCQUFFLG9DQUFGLEVBQ0UsRUFBQ3RFLFNBQVM7QUFBQSwyQkFBSyxNQUFLd0UsSUFBTCxHQUFZLE1BQUtDLFVBQUwsR0FBa0IsQ0FBQyxNQUFLQSxVQUF6QztBQUFBLGlCQUFWO0FBQ0MzRCw0QkFBWTtBQUFBLDJCQUFLLE1BQUsyRCxVQUFMLEtBQW9CLE1BQUtELElBQUwsR0FBWSxLQUFoQyxDQUFMO0FBQUEsaUJBRGI7QUFFQzNELDZCQUFhO0FBQUEsMkJBQUssTUFBSzJELElBQUwsR0FBWSxJQUFqQjtBQUFBLGlCQUZkLEVBREYsRUFJRSxjQUpGLENBREYsRUFNRSx1QkFBRSwyQkFBRixFQUNFLEVBQUNoRyxzQkFBbUIsS0FBS2dHLElBQUwsR0FBWSxPQUFaLEdBQXNCLE1BQXpDLG1GQUFELEVBREYsRUFFRSx1QkFBRSxhQUFGLENBRkYsQ0FORixFQVNFLHVCQUFFLE1BQUYsRUFDRSx1QkFBRSxtREFBRixFQUNFLHVCQUFFLDhGQUFGLEVBQ0UsQ0FBQ2tCLFFBQUQsRUFBVyxHQUFYLEVBQWlCZSxNQUFNLGlCQUFOLENBQWpCLENBREYsQ0FERixFQUdFLHVCQUFFLG1EQUFGLEVBQ0VoQixVQUFVOUUsR0FBVixDQUFjLFVBQVMwQixJQUFULEVBQWU7QUFDM0IsdUJBQU8sdUJBQUUseUJBQUYsRUFBNkIsRUFBQzBGLE1BQU0xRixLQUFLc0QsR0FBWixFQUE3QixFQUErQ3RELEtBQUt6RCxLQUFwRCxFQUNQLHVCQUFFLElBQUYsQ0FETyxDQUFQO0FBRUQsYUFIRCxDQURGLENBSEYsQ0FERixFQVNFMkgsT0FBTyx5QkFBUCxFQUFrQyxDQUFsQyxFQUFxQyxDQUFyQyxFQUF3Q25ELFVBQVVoRixJQUFJZ0YsT0FBZCxHQUF3QmpGLElBQUk2SixRQUFwRSxFQUE4RSx1QkFBRSxrQkFBRixFQUFzQjVFLFVBQVUsU0FBVixHQUFzQixvQkFBNUMsQ0FBOUUsRUFBaUosT0FBakosQ0FURixFQVVFbUQsT0FBTyxvQkFBUCxFQUE2QixFQUE3QixFQUFpQyxDQUFqQyxFQUFvQztBQUFBLHVCQUFLcEksSUFBSThKLGFBQUosQ0FBa0IsUUFBbEIsQ0FBTDtBQUFBLGFBQXBDLEVBQXNFLENBQUMsY0FBRCxFQUFpQnhCLE1BQU0sTUFBTixDQUFqQixDQUF0RSxDQVZGLEVBV0VGLE9BQU8sb0JBQVAsRUFBNkIsRUFBN0IsRUFBaUMsRUFBakMsRUFBcUM7QUFBQSx1QkFBS3BJLElBQUk4SixhQUFKLENBQWtCLE9BQWxCLENBQUw7QUFBQSxhQUFyQyxFQUFzRSxDQUFDLGFBQUQsRUFBZ0J4QixNQUFNLFFBQU4sQ0FBaEIsQ0FBdEUsQ0FYRixFQVlFRixPQUFPLG9CQUFQLEVBQTZCLENBQTdCLEVBQWdDLEVBQWhDLEVBQW9DO0FBQUEsdUJBQUssb0JBQVUyQixTQUFWLENBQW9CL0ksT0FBcEIsRUFBNkIsQ0FBN0IsQ0FBTDtBQUFBLGFBQXBDLEVBQTBFLENBQUMsWUFBRCxFQUFlc0gsTUFBTSxNQUFOLENBQWYsQ0FBMUUsQ0FaRixFQWFFRCxRQUFRLFVBQVIsRUFBb0JySSxJQUFJZ0ssS0FBeEIsRUFBK0IxQixNQUFNLFFBQU4sQ0FBL0IsRUFBZ0QsT0FBaEQsQ0FiRixFQWNFRCxRQUFRLGVBQVIsRUFBeUJySSxJQUFJaUssVUFBN0IsRUFBeUMsdUJBQUUsa0JBQUYsRUFBc0IsdUJBQXRCLENBQXpDLEVBQXlGLHVCQUF6RixDQWRGLENBVEYsRUF3QkUsdUJBQUUsU0FBRixFQUFhO0FBQ1Q1Six1QkFBTyxFQUFDbUUsU0FBUyxNQUFWLEVBREU7QUFFVDNDLHlCQUFTLG9CQUFLO0FBQ1Ysd0JBQUlxSSxLQUFLLFVBQUwsRUFBaUI3SixLQUFqQixDQUF1Qm1FLE9BQXZCLEtBQW1DLE1BQXZDLEVBQStDO0FBQUU7QUFDN0NvRSwwQkFBRSxXQUFGLEVBQWVLLE9BQWYsQ0FBdUIsR0FBdkI7QUFDQSwrQkFBTyxLQUFQO0FBQ0g7QUFDRCx3QkFBSWlCLEtBQUssV0FBTCxFQUFrQjdKLEtBQWxCLENBQXdCbUUsT0FBeEIsS0FBb0MsTUFBeEMsRUFBZ0Q7QUFBRTtBQUM5Q29FLDBCQUFFLFlBQUYsRUFBZ0JLLE9BQWhCLENBQXdCLEdBQXhCO0FBQ0EsK0JBQU8sS0FBUDtBQUNIOztBQUVEO0FBQ0FMLDZCQUFRdUIsTUFBUjtBQUNBLHdCQUFJQyxNQUFNeEIsRUFBRSxTQUFGLEVBQWFsQyxNQUFiLEVBQVY7QUFDQTBELHdCQUFJQyxHQUFKLElBQVd6QixFQUFFLFNBQUYsRUFBYW5GLEtBQWIsRUFBWDtBQUNBbUYsc0JBQUUsV0FBRixFQUFlTSxNQUFmLENBQXNCLEdBQXRCO0FBQ0EsMkJBQU8sS0FBUDtBQUNILGlCQWxCUTtBQW1CVG9CLHVCQUFPLG9CQUFPO0FBQ1Ysd0JBQUlDLElBQUlMLEtBQUssVUFBTCxFQUFpQjdKLEtBQWpCLENBQXVCbUUsT0FBL0I7QUFDQSx3QkFBSWdHLEtBQUtOLEtBQUssV0FBTCxFQUFrQjdKLEtBQWxCLENBQXdCbUUsT0FBakM7QUFDQSx3QkFBSStGLE1BQU0sTUFBVixFQUFrQjtBQUNkM0IsMEJBQUUsV0FBRixFQUFlSyxPQUFmLENBQXVCLEdBQXZCO0FBQ0gscUJBRkQsTUFFTyxJQUFJdUIsT0FBTyxNQUFYLEVBQW1CO0FBQ3RCNUIsMEJBQUUsWUFBRixFQUFnQkssT0FBaEIsQ0FBd0IsR0FBeEI7QUFDSDs7QUFFRCx3QkFBSU4sSUFBSThCLE9BQUosSUFBZSxFQUFuQixFQUF1QjtBQUFFO0FBQ3JCLDRCQUFJRixLQUFJRyxXQUFXOUIsRUFBRSxTQUFGLEVBQWE3QixHQUFiLEVBQVgsQ0FBUjtBQUNBLDRCQUFJLENBQUN3RCxFQUFMLEVBQVE7QUFDSjtBQUNIO0FBQ0RqQixrQ0FBVWlCLEdBQUUzRSxLQUFGLENBQVEsQ0FBUixFQUFXMkUsR0FBRUksTUFBRixHQUFXLENBQXRCLENBQVYsRUFBb0NKLEdBQUVBLEdBQUVJLE1BQUYsR0FBVyxDQUFiLENBQXBDLEVBQXFEcEIsZ0JBQWdCLEtBQXJFO0FBQ0g7QUFDSjtBQW5DUSxhQUFiLENBeEJGLEVBNkRFLHVCQUFFLGdDQUFGLEVBQW9DO0FBQ2hDOUksd01BRGdDLEVBQXBDLEVBR0VnSSxlQUFlLFVBQWYsRUFBMkIsQ0FBQyxHQUFELEVBQU0sR0FBTixDQUEzQixDQUhGLEVBSUVBLGVBQWUsV0FBZixFQUE0QnpJLElBQUk0SyxhQUFoQyxDQUpGLENBN0RGLENBREYsQ0FMRixFQXdFRSx1RUFBK0MsS0FBS3pFLEtBQUwsR0FBYSxPQUFiLEdBQXVCLE1BQXRFLHFFQUNFLHVCQUFFLGFBQUYsRUFDRSwrYUFERixDQURGLENBeEVGLENBRkcsRUE2RUgseUdBQ0UsdUJBQUUsK0JBQUYsRUFDRSx1QkFBRSxpQkFBRixFQUNFLHVCQUFFLGdCQUFGLENBREYsQ0FERixDQURGLEVBSUUsdUJBQUUsMENBQUYsRUFDRXFELFNBQVMsZ0JBQVQsRUFBMkJ4SixJQUFJNkssZUFBL0IsRUFBZ0QsdUNBQWhELEVBQXlGLFFBQXpGLENBREYsRUFFRXJCLFNBQVMsU0FBVCxFQUFvQixhQUFLO0FBQUE7O0FBQ3JCLG9CQUFJdkYsUUFBUSxFQUFaO0FBQ0Esb0JBQUlnQixPQUFKLEVBQWE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBLGdDQUNBNkYsSUFEQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUEsd0NBRUlDLEtBRko7O0FBR0Qsd0NBQUlELFNBQVNDLEtBQVQsSUFBa0I5RyxNQUFNK0csTUFBTixDQUFhO0FBQUEsK0NBQUtDLEVBQUUxSyxNQUFGLEtBQWF3SyxLQUFiLElBQXNCRSxFQUFFN0csTUFBRixLQUFhMEcsSUFBeEM7QUFBQSxxQ0FBYixFQUEyREgsTUFBM0QsS0FBc0UsQ0FBNUYsRUFBK0Y7QUFDM0YxRyw4Q0FBTUksSUFBTixDQUFXLEVBQUMyRCxNQUFNLEtBQVAsRUFBY0MsT0FBTyxLQUFyQixFQUE0QjFILFFBQVF1SyxJQUFwQyxFQUEwQzFHLFFBQVEyRyxLQUFsRCxFQUFYO0FBQ0g7QUFMQTs7QUFFTCxzREFBa0IvSyxJQUFJa0wsS0FBdEIsbUlBQTZCO0FBQUE7QUFJNUI7QUFOSTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQ1QsOENBQWlCbEwsSUFBSWtMLEtBQXJCLG1JQUE0QjtBQUFBO0FBTTNCO0FBUFE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVFaLGlCQVJELE1BUU87QUFDSCx3QkFBSUMsTUFBTW5MLElBQUlrTCxLQUFKLENBQVVGLE1BQVYsQ0FBaUI7QUFBQSwrQkFBS2hMLElBQUlvTCxPQUFKLENBQVlDLEdBQVosQ0FBZ0JsSCxRQUFoQixDQUF5Qm1ILEVBQUVqSixJQUEzQixDQUFMO0FBQUEscUJBQWpCLENBQVY7QUFDQSx3QkFBSWtKLE1BQU12TCxJQUFJa0wsS0FBSixDQUFVRixNQUFWLENBQWlCO0FBQUEsK0JBQUssQ0FBQ0csSUFBSWhILFFBQUosQ0FBYW1ILENBQWIsQ0FBTjtBQUFBLHFCQUFqQixDQUFWO0FBQ0FySCw0QkFBUWtILElBQUkzSSxHQUFKLENBQVE7QUFBQSwrQkFBTStJLElBQUkvSSxHQUFKLENBQVE7QUFBQSxtQ0FBTztBQUNqQ3dGLHNDQUFNLElBRDJCO0FBRWpDQyx1Q0FBTyxLQUYwQjtBQUdqQzFILHdDQUFRaUwsRUFIeUI7QUFJakNwSCx3Q0FBUXFIO0FBSnlCLDZCQUFQO0FBQUEseUJBQVIsQ0FBTjtBQUFBLHFCQUFSLENBQVI7QUFNSDtBQUNEekwsb0JBQUkySixPQUFKLENBQVksWUFBRzNFLE1BQUgsZ0NBQWFmLEtBQWIsRUFBWjtBQUNILGFBckJELEVBcUJHLDZDQXJCSCxFQXFCa0QsTUFyQmxELENBRkYsRUF3QkV1RixTQUFTLGVBQVQsRUFBMEI7QUFBQSx1QkFBS3hKLElBQUkySixPQUFKLENBQVksRUFBWixDQUFMO0FBQUEsYUFBMUIsRUFBZ0Qsc0NBQWhELEVBQXdGLGVBQXhGLENBeEJGLEVBeUJFSCxTQUFTLFVBQVQsRUFBcUJ4SixJQUFJMEwsV0FBekIsRUFBc0Msc0NBQXRDLEVBQThFLFNBQTlFLENBekJGLEVBMEJFbEMsU0FBUyxXQUFULEVBQXNCeEosSUFBSTJMLEtBQTFCLEVBQWlDLDRDQUFqQyxFQUErRSxRQUEvRSxDQTFCRixDQUpGLEVBK0JFLDJDQUNFLEVBQUNsTCxPQUFPLFFBQVI7QUFDQ2lCLHlCQUFTLENBQ0wsQ0FBQyxZQUFELEVBQWUsT0FBZixFQUF3QixNQUF4QixDQURLLEVBRUwsQ0FBQyxVQUFELEVBQWEsUUFBYixFQUF1QixXQUF2QixDQUZLLEVBR0wsQ0FBQyxVQUFELEVBQWEsS0FBYixFQUFvQixTQUFwQixDQUhLLEVBSUwsQ0FBQyxXQUFELEVBQWMsTUFBZCxFQUFzQixTQUF0QixDQUpLLEVBS0wsQ0FBQyxXQUFELEVBQWMsU0FBZCxFQUF5QixTQUF6QixDQUxLLEVBTUwsQ0FBQyxXQUFELEVBQWMsU0FBZCxFQUF5QixTQUF6QixDQU5LLENBRFYsRUFERixDQS9CRixFQXdDRSwyQ0FBWSxFQUFDakIsT0FBTyxTQUFSLEVBQVosQ0F4Q0YsRUF5Q0UrRSxPQUFPbkMsSUFBUCxDQXpDRixFQTBDRTdCLFdBMUNGLEVBMkNFNEIsV0FBV0MsSUFBWCxDQTNDRixDQTdFRyxDQUFQO0FBeUhIOzs7Ozs7QUFHTCxrQkFBRXFDLEtBQUYsQ0FBUWtHLFNBQVNDLElBQWpCLEVBQXVCLFFBQXZCLEVBQWlDO0FBQzdCLGNBQVUsRUFBQ0MsUUFBUTtBQUFBLG1CQUFNLHVCQUFFL0YsSUFBRixDQUFOO0FBQUEsU0FBVCxFQURtQjtBQUU3QixnQkFBWSxFQUFDK0YsUUFBUTtBQUFBLG1CQUFNLHVCQUFFL0YsSUFBRixFQUFRLEVBQUMxQyxNQUFNLFNBQVAsRUFBUixDQUFOO0FBQUEsU0FBVCxFQUZpQjtBQUc3QixnQkFBWSxFQUFDeUksUUFBUTtBQUFBLG1CQUFNLHVCQUFFL0YsSUFBRixFQUFRLEVBQUMxQyxNQUFNLFNBQVAsRUFBUixDQUFOO0FBQUEsU0FBVDtBQUhpQixDQUFqQyIsImZpbGUiOiIxNS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAnLi4vY3NzL2FwcC5jc3MnO1xuaW1wb3J0ICcuLi9wa2dzL2Jvb3RzdHJhcC9jc3MvYm9vdHN0cmFwLXRoZW1lLm1pbi5jc3MnO1xuaW1wb3J0ICcuLi9wa2dzL0xhZGRhL2Rpc3QvbGFkZGEtdGhlbWVsZXNzLm1pbi5jc3MnO1xuaW1wb3J0ICcuLi8uLi9ub2RlX21vZHVsZXMvaG9wc2NvdGNoL2Rpc3QvY3NzL2hvcHNjb3RjaC5jc3MnO1xuXG5pbXBvcnQgaG9wc2NvdGNoIGZyb20gJ2hvcHNjb3RjaCc7XG5cbmltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuXG5pbXBvcnQgKiBhcyBhcHAgZnJvbSAnLi9hcHAnO1xuaW1wb3J0ICogYXMgZXhwIGZyb20gJy4vZXhwbG9yZSc7XG5pbXBvcnQgKiBhcyBwbG90cyBmcm9tICcuL3Bsb3RzJztcbmltcG9ydCBQYW5lbCBmcm9tICcuL3ZpZXdzL1BhbmVsJztcbmltcG9ydCBCdXR0b24sIHt3aGVufSBmcm9tICcuL3ZpZXdzL1BhbmVsQnV0dG9uJztcbmltcG9ydCBMaXN0IGZyb20gJy4vdmlld3MvUGFuZWxMaXN0JztcbmltcG9ydCBTZWFyY2ggZnJvbSAnLi92aWV3cy9TZWFyY2gnO1xuaW1wb3J0IFN1YnBhbmVsIGZyb20gJy4vdmlld3MvU3VicGFuZWwnO1xuXG5mdW5jdGlvbiBzZXRCYWNrZ3JvdW5kQ29sb3IoY29sb3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc3R5bGVbJ2JhY2tncm91bmQtY29sb3InXSA9IGNvbG9yO1xuICAgIH07XG59XG5cbmV4cG9ydCBsZXQgc3RlcCA9ICh0YXJnZXQsIHBsYWNlbWVudCwgdGl0bGUsIGNvbnRlbnQpID0+ICh7XG4gICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgICAgICB0aXRsZSxcbiAgICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgICBzaG93Q1RBQnV0dG9uOiB0cnVlLFxuICAgICAgICAgICAgY3RhTGFiZWw6ICdEaXNhYmxlIHRoZXNlIG1lc3NhZ2VzJyxcbiAgICAgICAgICAgIG9uQ1RBOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaG9wc2NvdGNoLmVuZFRvdXIodHJ1ZSk7XG4gICAgICAgICAgICAgICAgdHV0b3JpYWxfbW9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG5cblxuZXhwb3J0IGxldCBteXRvdXIyID0ge1xuICAgICAgICAgICAgaWQ6IFwiZGF0YXNldF9sYXVuY2hcIixcbiAgICAgICAgICAgIGkxOG46IHtkb25lQnRuOidPayd9LFxuICAgICAgICAgICAgc2hvd0Nsb3NlQnV0dG9uOiB0cnVlLFxuICAgICAgICAgICAgc2Nyb2xsRHVyYXRpb246IDMwMCxcbiAgICAgICAgICAgIC8vb25FbmQ6ICgpID0+IGZpcnN0X2xvYWQgPSBmYWxzZSxcbiAgICAgICAgICAgIHN0ZXBzOiBbXG4gICAgICAgICAgICAgICAgc3RlcChcImRhdGFOYW1lXCIsIFwiYm90dG9tXCIsIFwiV2VsY29tZSB0byBUd29SYXZlbnMgU29sdmVyXCIsXG4gICAgICAgICAgICAgICAgICAgICBgPHA+VGhpcyB0b29sIGNhbiBndWlkZSB5b3UgdG8gc29sdmUgYW4gZW1waXJpY2FsIHByb2JsZW0gaW4gdGhlIGRhdGFzZXQgYWJvdmUuPC9wPlxuICAgICAgICAgICAgICAgICAgICAgIDxwPlRoZXNlIG1lc3NhZ2VzIHdpbGwgdGVhY2ggeW91IHRoZSBzdGVwcyB0byB0YWtlIHRvIGZpbmQgYW5kIHN1Ym1pdCBhIHNvbHV0aW9uLjwvcD5gKSxcbiAgICAgICAgICAgICAgICBzdGVwKFwiYnRuUmVzZXRcIiwgXCJib3R0b21cIiwgXCJSZXN0YXJ0IEFueSBQcm9ibGVtIEhlcmVcIixcbiAgICAgICAgICAgICAgICAgICAgICc8cD5Zb3UgY2FuIGFsd2F5cyBzdGFydCBhIHByb2JsZW0gb3ZlciBieSB1c2luZyB0aGlzIHJlc2V0IGJ1dHRvbi48L3A+JyksXG4gICAgICAgICAgICAgICAgc3RlcChcImJ0blN1YnNldFwiLCBcInJpZ2h0XCIsIFwiU3RhcnQgVGFzayAxXCIsXG4gICAgICAgICAgICAgICAgICAgICBgPHA+VGhpcyBQcm9ibGVtIERpc2NvdmVyeSBidXR0b24gYWxsb3dzIHlvdSB0byBzdGFydCBUYXNrIDEgLSBQcm9ibGVtIERpc2NvdmVyeS48L3A+XG4gICAgICAgICAgICAgICAgICAgICA8cD5HZW5lcmFsbHksIGFzIGEgdGlwLCB0aGUgR3JlZW4gYnV0dG9uIGlzIHRoZSBuZXh0IGJ1dHRvbiB5b3UgbmVlZCB0byBwcmVzcyB0byBtb3ZlIHRoZSBjdXJyZW50IHRhc2sgZm9yd2FyZC48L3A+XG4gICAgICAgICAgICAgICAgICAgICA8cD5DbGljayB0aGlzIGJ1dHRvbiB0byBzZWUgYSBsaXN0IG9mIHByb2JsZW1zIHRoYXQgaGF2ZSBiZWVuIGRpc2NvdmVyZWQgaW4gdGhlIGRhdGFzZXQuPC9wPlxuICAgICAgICAgICAgICAgICAgICAgPHA+WW91IGNhbiBtYXJrIHdoaWNoIG9uZXMgeW91IGFncmVlIG1heSBiZSBpbnRlcmVzdGluZywgYW5kIHRoZW4gc3VibWl0IHRoZSB0YWJsZSBhcyBhbiBhbnN3ZXIuPC9wPmApLFxuICAgICAgICAgICAgICAgIHN0ZXAoXCJidG5TZWxlY3RcIiwgXCJyaWdodFwiLCBcIkNvbXBsZXRlIFRhc2sgMVwiLFxuICAgICAgICAgICAgICAgICAgICAgYDxwPlRoaXMgc3VibWlzc2lvbiBidXR0b24gbWFya3MgVGFzayAxIC0gUHJvYmxlbSBEaXNjb3ZlcnksIGFzIGNvbXBsZXRlLjwvcD5cbiAgICAgICAgICAgICAgICAgICAgIDxwPkNsaWNrIHRoaXMgYnV0dG9uIHRvIHNhdmUgdGhlIGNoZWNrIG1hcmtlZCBwcm9ibGVtcyBpbiB0aGUgdGFibGUgYmVsb3cgYXMgcG90ZW50aWFsbHkgaW50ZXJlc3Rpbmcgb3IgcmVsZXZhbnQuPC9wPlxuICAgICAgICAgICAgICAgICAgICAgPHA+R2VuZXJhbGx5LCBhcyBhIHRpcCwgdGhlIEdyZWVuIGJ1dHRvbiBpcyB0aGUgbmV4dCBidXR0b24geW91IG5lZWQgdG8gcHJlc3MgdG8gbW92ZSB0aGUgY3VycmVudCB0YXNrIGZvcndhcmQuPC9wPmApLFxuICAgICAgICAgICAgICAgIHN0ZXAoXCJidG5Fc3RpbWF0ZVwiLCBcImxlZnRcIiwgXCJTb2x2ZSBUYXNrIDJcIixcbiAgICAgICAgICAgICAgICAgICAgIGA8cD5UaGlzIGdlbmVyYWxseSBpcyB0aGUgaW1wb3J0YW50IHN0ZXAgdG8gZm9sbG93IGZvciBUYXNrIDIgLSBCdWlsZCBhIE1vZGVsLjwvcD5cbiAgICAgICAgICAgICAgICAgICAgICA8cD5HZW5lcmFsbHksIGFzIGEgdGlwLCB0aGUgR3JlZW4gYnV0dG9uIGlzIHRoZSBuZXh0IGJ1dHRvbiB5b3UgbmVlZCB0byBwcmVzcyB0byBtb3ZlIHRoZSBjdXJyZW50IHRhc2sgZm9yd2FyZCwgYW5kIHRoaXMgYnV0dG9uIHdpbGwgYmUgR3JlZW4gd2hlbiBUYXNrIDEgaXMgY29tcGxldGVkIGFuZCBUYXNrIDIgc3RhcnRlZC48L3A+XG4gICAgICAgICAgICAgICAgICAgICAgPHA+Q2xpY2sgdGhpcyBTb2x2ZSBidXR0b24gdG8gdGVsbCB0aGUgdG9vbCB0byBmaW5kIGEgc29sdXRpb24gdG8gdGhlIHByb2JsZW0sIHVzaW5nIHRoZSB2YXJpYWJsZXMgcHJlc2VudGVkIGluIHRoZSBjZW50ZXIgcGFuZWwuPC9wPmApLFxuICAgICAgICAgICAgICAgIC8vc3RlcChteXRhcmdldCArICdiaWdncm91cCcsIFwibGVmdFwiLCBcIlRhcmdldCBWYXJpYWJsZVwiLFxuICAgICAgICAgICAgICAgIC8vICAgICBgVGhpcyBpcyB0aGUgdmFyaWFibGUsICR7bXl0YXJnZXR9LCB3ZSBhcmUgdHJ5aW5nIHRvIHByZWRpY3QuXG4gICAgICAgICAgICAgICAgLy8gICAgICBUaGlzIGNlbnRlciBwYW5lbCBncmFwaGljYWxseSByZXByZXNlbnRzIHRoZSBwcm9ibGVtIGN1cnJlbnRseSBiZWluZyBhdHRlbXB0ZWQuYCksXG4gICAgICAgICAgICAgICAgc3RlcChcImdyMWh1bGxcIiwgXCJyaWdodFwiLCBcIkV4cGxhbmF0aW9uIFNldFwiLCBcIlRoaXMgc2V0IG9mIHZhcmlhYmxlcyBjYW4gcG90ZW50aWFsbHkgcHJlZGljdCB0aGUgdGFyZ2V0LlwiKSxcbiAgICAgICAgICAgICAgICBzdGVwKFwiZGlzcGxhY2VtZW50XCIsIFwicmlnaHRcIiwgXCJWYXJpYWJsZSBMaXN0XCIsXG4gICAgICAgICAgICAgICAgICAgICBgPHA+Q2xpY2sgb24gYW55IHZhcmlhYmxlIG5hbWUgaGVyZSBpZiB5b3Ugd2lzaCB0byByZW1vdmUgaXQgZnJvbSB0aGUgcHJvYmxlbSBzb2x1dGlvbi48L3A+XG4gICAgICAgICAgICAgICAgICAgICAgPHA+WW91IGxpa2VseSBkbyBub3QgbmVlZCB0byBhZGp1c3QgdGhlIHByb2JsZW0gcmVwcmVzZW50YXRpb24gaW4gdGhlIGNlbnRlciBwYW5lbC48L3A+YCksXG4gICAgICAgICAgICAgICAgc3RlcChcImJ0bkVuZFNlc3Npb25cIiwgXCJib3R0b21cIiwgXCJGaW5pc2ggUHJvYmxlbVwiLFxuICAgICAgICAgICAgICAgICAgICAgXCJJZiB0aGUgc29sdXRpb24gcmVwb3J0ZWQgYmFjayBzZWVtcyBhY2NlcHRhYmxlLCB0aGVuIGZpbmlzaCB0aGlzIHByb2JsZW0gYnkgY2xpY2tpbmcgdGhpcyBFbmQgU2Vzc2lvbiBidXR0b24uXCIpLFxuICAgICAgICAgICAgXVxuICAgICAgICB9O1xuXG5leHBvcnQgbGV0IG15dG91cjMgPSB7XG4gICAgICAgICAgICBpZDogXCJkYXRhc2V0X2xhdW5jaFwiLFxuICAgICAgICAgICAgaTE4bjoge2RvbmVCdG46J09rJ30sXG4gICAgICAgICAgICBzaG93Q2xvc2VCdXR0b246IHRydWUsXG4gICAgICAgICAgICBzY3JvbGxEdXJhdGlvbjogMzAwLFxuICAgICAgICAgICAgc3RlcHM6IFtcbiAgICAgICAgICAgICAgICBzdGVwKFwiYnRuU2VsZWN0XCIsIFwicmlnaHRcIiwgXCJDb21wbGV0ZSBUYXNrIDFcIixcbiAgICAgICAgICAgICAgICAgICAgIGA8cD5UaGlzIHN1Ym1pc3Npb24gYnV0dG9uIG1hcmtzIFRhc2sgMSAtIFByb2JsZW0gRGlzY292ZXJ5LCBhcyBjb21wbGV0ZS48L3A+XG4gICAgICAgICAgICAgICAgICAgICA8cD5DbGljayB0aGlzIGJ1dHRvbiB0byBzYXZlIHRoZSBjaGVjayBtYXJrZWQgcHJvYmxlbXMgaW4gdGhlIHRhYmxlIGJlbG93IGFzIHBvdGVudGlhbGx5IGludGVyZXN0aW5nIG9yIHJlbGV2YW50LjwvcD5cbiAgICAgICAgICAgICAgICAgICAgIDxwPkdlbmVyYWxseSwgYXMgYSB0aXAsIHRoZSBHcmVlbiBidXR0b24gaXMgdGhlIG5leHQgYnV0dG9uIHlvdSBuZWVkIHRvIHByZXNzIHRvIG1vdmUgdGhlIGN1cnJlbnQgdGFzayBmb3J3YXJkLjwvcD5gKSxcbiAgICAgICAgICAgIF1cbiAgICAgICAgfTtcblxuXG5cblxuXG5mdW5jdGlvbiBsZWZ0cGFuZWwoKSB7XG4gICAgcmV0dXJuIG0oXG4gICAgICAgIFBhbmVsLFxuICAgICAgICB7c2lkZTogJ2xlZnQnLFxuICAgICAgICAgdGl0bGU6ICdEYXRhIFNlbGVjdGlvbicsXG4gICAgICAgICBidXR0b25zOiBbXG4gICAgICAgICAgICAgbShCdXR0b24sXG4gICAgICAgICAgICAgICB7aWQ6ICdidG5WYXJpYWJsZXMnLFxuICAgICAgICAgICAgICAgIGlkMjogJ3RhYjEnLFxuICAgICAgICAgICAgICAgIHRpdGxlOiAnQ2xpY2sgdmFyaWFibGUgbmFtZSB0byBhZGQgb3IgcmVtb3ZlIHRoZSB2YXJpYWJsZSBwZWJibGUgZnJvbSB0aGUgbW9kZWxpbmcgc3BhY2UuJ30sXG4gICAgICAgICAgICAgICAnVmFyaWFibGVzJyksXG4gICAgICAgICAgICAgbShCdXR0b24sIHtpZDogJ2J0blN1YnNldCcsIGlkMjogJ3RhYjInLCBjbGFzc2VzOiAnYnRuLXN1Y2Nlc3MnfSwgJ1Byb2IuIERpc2MuJyksIC8vb25jbGljazogXyA9PiBhcHAucHJvYkRpc2NWaWV3KCdidG5TdWJzZXQnKVxuICAgICAgICAgICAgIG0oQnV0dG9uLFxuICAgICAgICAgICAgICAge2lkOiAnYnRuU2VsZWN0JyxcbiAgICAgICAgICAgICAgICBjbGFzc2VzOiAnYnRuLXN1Y2Nlc3MubGFkZGEtYnV0dG9uW2RhdGEtc3Bpbm5lci1jb2xvcj0jMDAwMDAwXVtkYXRhLXN0eWxlPXpvb20taW5dJyxcbiAgICAgICAgICAgICAgICBvbmNsaWNrOiBfID0+IGFwcC5zdWJtaXREaXNjUHJvYignYnRuU2VsZWN0JyksXG4gICAgICAgICAgICAgICAgc3R5bGU6IGBkaXNwbGF5OiAke2FwcC5zdWJzZXQgPyAnbm9uZScgOiAnbm9uZSd9OyBmbG9hdDogcmlnaHQ7IG1hcmdpbi1yaWdodDogMTBweGAsXG4gICAgICAgICAgICAgICAgdGl0bGU6ICdTdWJtaXQgYWxsIGNoZWNrZWQgZGlzY292ZXJlZCBwcm9ibGVtcy4nfSxcbiAgICAgICAgICAgICAgIG0oJ3NwYW4ubGFkZGEtbGFiZWxbc3R5bGU9cG9pbnRlci1ldmVudHM6IG5vbmVdJywgJ1N1Ym1pdCBEaXNjLiBQcm9icy4nKSldfSxcbiAgICAgICAgbShgI3RhYjFbc3R5bGU9ZGlzcGxheTogJHt3aGVuKCdsZWZ0JywgJ3RhYjEnKX07IHBhZGRpbmc6IDAgOHB4OyB0ZXh0LWFsaWduOiBjZW50ZXJdYCxcbiAgICAgICAgICBtKFNlYXJjaCwge3BsYWNlaG9sZGVyOiAnU2VhcmNoIHZhcmlhYmxlcyBhbmQgbGFiZWxzJ30pLFxuICAgICAgICAgIG0oTGlzdCwge2l0ZW1zOiBhcHAudmFsdWVLZXksIHRpdGxlOiAnU3VtbWFyeSBTdGF0aXN0aWNzJ30pKSxcbiAgICAgICAgbShgI3RhYjJbc3R5bGU9ZGlzcGxheTogJHt3aGVuKCdsZWZ0JywgJ3RhYjInKX07IGhlaWdodDo3NSU7IG92ZXJmbG93OiBhdXRvOyBtYXJnaW4tdG9wOiAuNWVtXWApLFxuICAgICAgICBtKCcjdGFiMmFbc3R5bGU9ZGlzcGxheTpub25lOyBmbG9hdDogbGVmdDsgd2lkdGg6IDEwMCU7IGhlaWdodDoyNSU7IG92ZXJmbG93OiBhdXRvO10nLFxuICAgICAgICAgICAgbSgndGV4dGFyZWEjdGFiMmlucHV0W3N0eWxlPWRpc3BsYXk6YmxvY2s7IGZsb2F0OiBsZWZ0OyB3aWR0aDogNzUlOyBoZWlnaHQ6MTAwJTsgb3ZlcmZsb3c6IGF1dG87IGJhY2tncm91bmQtY29sb3I6IHdoaXRlXScpLFxuICAgICAgICAgICAgbShCdXR0b24sIHtpZDogJ2J0blNhdmUnLCBvbmNsaWNrOl89PmFwcC5zYXZlRGlzYygnYnRuU2F2ZScpLHRpdGxlOiAnU2F2ZXMgeW91ciByZXZpc2VkIHByb2JsZW0gZGVzY3JpcHRpb24uJ30sICdTYXZlIERlc2MuJykpLFxuICAgIFxuICAgLy8gICAgIG0oXCJpbnB1dCNpbnB1dDFbbmFtZT0nZm5hbWUnXVt0eXBlPSd0ZXh0J11cIiwge3N0eWxlOiB7XCJtYXJnaW4tbGVmdFwiOiBcIjIlXCJ9fSksXG4gICAgICAgIG0oJyN0YWIzW3N0eWxlPWhlaWdodDogMzUwcHhdJyxcbiAgICAgICAgICBtKGBwW3N0eWxlPXBhZGRpbmc6IC41ZW0gMWVtOyBkaXNwbGF5OiAke3doZW4oJ2xlZnQnLCAndGFiMycpfV1gLFxuICAgICAgICAgICAge3RpdGxlOiBcIlNlbGVjdCBhIHZhcmlhYmxlIGZyb20gd2l0aGluIHRoZSB2aXN1YWxpemF0aW9uIGluIHRoZSBjZW50ZXIgcGFuZWwgdG8gdmlldyBpdHMgc3VtbWFyeSBzdGF0aXN0aWNzLlwifSxcbiAgICAgICAgICAgIG0oJ2NlbnRlcicsXG4gICAgICAgICAgICAgIG0oJ2InLCBhcHAuc3VtbWFyeS5uYW1lKSxcbiAgICAgICAgICAgICAgbSgnYnInKSxcbiAgICAgICAgICAgICAgbSgnaScsIGFwcC5zdW1tYXJ5LmxhYmwpKSxcbiAgICAgICAgICAgIG0oJ3RhYmxlJywgYXBwLnN1bW1hcnkuZGF0YS5tYXAoXG4gICAgICAgICAgICAgICAgdHIgPT4gbSgndHInLCB0ci5tYXAoXG4gICAgICAgICAgICAgICAgICAgIHRkID0+IG0oJ3RkJywge29ubW91c2VvdmVyOiBzZXRCYWNrZ3JvdW5kQ29sb3IoJ2FsaWNlYmx1ZScpLCBvbm1vdXNlb3V0OiBzZXRCYWNrZ3JvdW5kQ29sb3IoJ2Y5ZjlmOScpfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZCkpKSkpKSkpO1xufVxuXG5sZXQgcmlnaHR0YWIgPSAoaWQsIGJ0bklkLCB0YXNrLCB0aXRsZSwgcHJvYkRlc2MpID0+IG0oXG4gICAgYCMke2lkfVtzdHlsZT1kaXNwbGF5OiAke3doZW4oJ3JpZ2h0JywgYnRuSWQpfTsgcGFkZGluZzogNnB4IDEycHg7IHRleHQtYWxpZ246IGNlbnRlcl1gLFxuICAgIG0oTGlzdCxcbiAgICAgIHtpdGVtczogT2JqZWN0LmtleXModGFzayB8fCB7fSksXG4gICAgICAgdGl0bGU6IHRpdGxlICsgJyBEZXNjcmlwdGlvbicsXG4gICAgICAgY29udGVudDogdiA9PiB0YXNrW3ZdWzFdLFxuICAgICAgIHByb2JEZXNjOiBwcm9iRGVzY30pKTtcblxuZnVuY3Rpb24gcmlnaHRwYW5lbChtb2RlKSB7XG4gICAgbGV0IHRodW1iID0gKGlkeCwgaWQsIHRpdGxlKSA9PlxuICAgICAgICBtKFwidGhcIixcbiAgICAgICAgICBtKFwiZmlndXJlXCIsIHtzdHlsZToge2Zsb2F0OiBcImxlZnRcIn19LFxuICAgICAgICAgICAgbShgaW1nIyR7aWR9X2ltZ1thbHQ9JHtpZH1dW3NyYz0vc3RhdGljL2ltYWdlcy90aHVtYiR7aWR4fS5wbmddYCxcbiAgICAgICAgICAgICAge3N0eWxlOiB7d2lkdGg6IFwiNzUlXCIsIGhlaWdodDogXCI3NSVcIiwgYm9yZGVyOiBcIjFweCBzb2xpZCAjZGRkXCIsIFwiYm9yZGVyLXJhZGl1c1wiOiBcIjNweFwiLCBwYWRkaW5nOiBcIjVweFwiLCBtYXJnaW46IFwiMyVcIiwgY3Vyc29yOiBcInBvaW50ZXJcIn19KSxcbiAgICAgICAgICAgIG0oXCJmaWdjYXB0aW9uXCIsIHtzdHlsZToge1widGV4dC1hbGlnblwiOiBcImNlbnRlclwifX0sIHRpdGxlKSkpO1xuICAgIGxldCB1bmlxdWVfbGlua19uYW1lcyA9ICgpID0+IHtcbiAgICAgICAgbGV0IG5hbWVzID0gW107XG4gICAgICAgIGZvciAobGV0IGxpbmsgb2YgYXBwLmxpbmtzKSB7XG4gICAgICAgICAgICBpZiAoIW5hbWVzLmluY2x1ZGVzKGxpbmsuc291cmNlLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgbmFtZXMucHVzaChsaW5rLnNvdXJjZS5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbmFtZXMuaW5jbHVkZXMobGluay50YXJnZXQubmFtZSkpIHtcbiAgICAgICAgICAgICAgICBuYW1lcy5wdXNoKGxpbmsudGFyZ2V0Lm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuYW1lcztcbiAgICB9O1xuICAgIHJldHVybiBtb2RlID9cbiAgICAgICAgbShQYW5lbCxcbiAgICAgICAgICB7c2lkZTogJ3JpZ2h0JyxcbiAgICAgICAgICAgdGl0bGU6ICdSZXN1bHQgRXhwbG9yYXRpb24nLFxuICAgICAgICAgICBpc19leHBsb3JlX21vZGU6IHRydWUsXG4gICAgICAgICAgIGJ1dHRvbnM6IFtcbiAgICAgICAgICAgICAgIG0oQnV0dG9uLCB7aWQ6ICdidG5Vbml2YXJpYXRlJ30sICdVbml2YXJpYXRlJyksXG4gICAgICAgICAgICAgICBtKEJ1dHRvbiwge2lkOiAnYnRuQml2YXJpYXRlJ30sICdCaXZhcmlhdGUnKV19LFxuICAgICAgICAgIG0oJyNtb2RlbFZpZXdfQ29udGFpbmVyJywge3N0eWxlOiAnd2lkdGg6IDEwMCU7IGhlaWdodDogYXV0bzsgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7IGZsb2F0OiBsZWZ0OyBvdmVyZmxvdy14OiBhdXRvOyBvdmVyZmxvdy15OiBhdXRvOyB3aGl0ZS1zcGFjZTogbm93cmFwOyd9LFxuICAgICAgICAgICAgbSgnI21vZGVsVmlldycsIHtzdHlsZTogJ3dpZHRoOiAxMDAlOyBoZWlnaHQ6IGF1dG87IGJhY2tncm91bmQtY29sb3I6IHdoaXRlOyBmbG9hdDogbGVmdDsgb3ZlcmZsb3c6IGF1dG87IG1hcmdpbi10b3A6IDJweDsnfSkpLFxuICAgICAgICAgIG0oJyNkZWNpc2lvblRyZWVbc3R5bGU9d2lkdGg6IDEwMCU7IGhlaWdodDogYXV0byA7IGJhY2tncm91bmQtY29sb3I6IHdoaXRlIDsgIG92ZXJmbG93IDogc2Nyb2xsOyBmbG9hdDogbGVmdDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbWFyZ2luLXRvcDogMnB4O10nKSxcbiAgICAgICAgICBtKCcjcmVzdWx0X2xlZnQnLFxuICAgICAgICAgICAge3N0eWxlOiB7XCJ3aWR0aFwiOiBcIjUwJVwiLCBcImhlaWdodFwiOiBcIjkwJVwiLCBcImZsb2F0XCI6IFwibGVmdFwiLCBcImJhY2tncm91bmQtY29sb3JcIjogXCJ3aGl0ZVwiLCBcImJvcmRlci1yaWdodFwiOiBcInJpZGdlXCIsIFwiYm9yZGVyLWJvdHRvbVwiOiBcInJpZGdlXCIsIFwib3ZlcmZsb3dcIjogXCJhdXRvXCIsIFwid2hpdGUtc3BhY2VcIjogXCJub3dyYXBcIn19LFxuICAgICAgICAgICAgbSgnI2xlZnRfdGh1bWJuYWlsJyxcbiAgICAgICAgICAgICAge3N0eWxlOiB7XCJ3aWR0aFwiOiBcIjEwMCVcIiwgXCJoZWlnaHRcIjogXCIyMCVcIiwgXCJiYWNrZ3JvdW5kLWNvbG9yXCI6IFwid2hpdGVcIiwgXCJtYXJnaW4tdG9wXCI6IFwiMyVcIiwgXCJtYXJnaW4tcmlnaHRcIjogXCIzJVwiLCBcImJvcmRlci1ib3R0b21cIjogXCJyaWRnZVwiLCBcIm92ZXJmbG93XCI6IFwiYXV0b1wiLCBcIndoaXRlLXNwYWNlXCI6IFwibm93cmFwXCJ9fSxcbiAgICAgICAgICAgICAgbShcInRhYmxlXCIsXG4gICAgICAgICAgICAgICAgbShcInRib2R5XCIsXG4gICAgICAgICAgICAgICAgICBtKFwidHJcIiwgdGh1bWIoMSwgJ3NjYXR0ZXJwbG90JywgXCJTY2F0dGVyIFBsb3RcIiksIHRodW1iKDIsICdoZWF0bWFwJywgXCJIZWF0cG1hcFwiKSwgdGh1bWIoMywgJ2xpbmVjaGFydCcsIFwiTGluZWNoYXJ0XCIpKSkpKSxcbiAgICAgICAgICAgIG0oJyNyZXN1bHRfbGVmdDEnLCB7c3R5bGU6IHt3aWR0aDogXCIxMDAlXCIsIGhlaWdodDogXCIzMjBweFwiLCBcInRleHQtYWxpZ25cIjogXCJjZW50ZXJcIiwgXCJtYXJnaW4tdG9wXCI6IFwiMyVcIiwgXCJiYWNrZ3JvdW5kLWNvbG9yXCI6IFwid2hpdGVcIiwgXCJ3aGl0ZS1zcGFjZVwiOiBcIm5vd3JhcFwifX0sXG4gICAgICAgICAgICAgIG0oXCIuY29udGFpbmVyM1tpZD1zY2F0dGVycGxvdF1cIiwge3N0eWxlOiB7XCJ3aWR0aFwiOiBcIjUwMHB4XCIsIFwiaGVpZ2h0XCI6IFwiODAlXCIsIFwiYmFja2dyb3VuZC1jb2xvclwiOiBcIndoaXRlXCIsIFwiZmxvYXRcIjogXCJsZWZ0XCIsIFwib3ZlcmZsb3dcIjogXCJoaWRkZW5cIiwgXCJtYXJnaW5cIjogXCI1JSA1JSAwIDUlXCJ9fSksXG4gICAgICAgICAgICAgIG0oXCIuY29udGFpbmVyNFtpZD1oZWF0Y2hhcnRdXCIsIHtzdHlsZToge1wid2lkdGhcIjogXCI1MDBweFwiLCBcImhlaWdodFwiOiBcIjgwJVwiLCBcImZsb2F0XCI6IFwibGVmdFwiLCBcIm92ZXJmbG93XCI6IFwiaGlkZGVuXCIsIFwiYmFja2dyb3VuZC1jb2xvclwiOiBcIiNGRkVCRUVcIiwgXCJtYXJnaW5cIjogXCI1JSAgXCJ9fSksXG4gICAgICAgICAgICAgIG0oXCIuY29udGFpbmVyNFtpZD1saW5lY2hhcnRdXCIsIHtzdHlsZToge1wid2lkdGhcIjogXCI1MDBweFwiLCBcImhlaWdodFwiOiBcIjgwJVwiLCBcImJhY2tncm91bmQtY29sb3JcIjogXCJ3aGl0ZVwiLCBcImZsb2F0XCI6IFwibGVmdFwiLCBcIm92ZXJmbG93XCI6IFwiaGlkZGVuXCIsIFwibWFyZ2luXCI6IFwiNSUgXCJ9fSkpLFxuICAgICAgICAgICAgbShcImRpdlwiLCB7c3R5bGU6IHtcImJvcmRlci1ib3R0b21cIjogXCJyaWRnZVwiLCBcImRpc3BsYXlcIjogXCJpbmxpbmUtYmxvY2tcIiwgXCJ3aWR0aFwiOiBcIjEwMCVcIiwgXCJtYXJnaW4tYm90dG9tXCI6IFwiMiVcIiwgXCJ0ZXh0LWFsaWduXCI6IFwiY2VudGVyXCJ9fSxcbiAgICAgICAgICAgICAgbShcImg1I05BY291bnRcIiwge3N0eWxlOiB7XCIgbWFyZ2luLWJvdHRvbVwiOiBcIjBcIn19KSksXG4gICAgICAgICAgICBtKFwiLmNvbnRhaW5lcjJbaWQ9J3Jlc3VsdHNWaWV3X3N0YXRpc3RpY3MnXVwiLFxuICAgICAgICAgICAgICB7c3R5bGU6IHtcIndpZHRoXCI6IFwiMTAwJVwiLCBcImhlaWdodFwiOiBcIjE1JVwiLCBcImJhY2tncm91bmQtY29sb3JcIjogXCJ3aGl0ZVwiLCBcImZsb2F0XCI6IFwibGVmdFwiLCBcIndoaXRlLXNwYWNlXCI6IFwibm93cmFwXCIsIFwibWFyZ2luLWJvdHRvbVwiOiBcIjMlXCIsIFwiYm9yZGVyLWJvdHRvbVwiOiBcInJpZGdlXCJ9fSkpLFxuICAgICAgICAgIG0oJyNyZXN1bHRfcmlnaHQnLFxuICAgICAgICAgICAge3N0eWxlOiB7d2lkdGg6IFwiNTAlXCIsIGhlaWdodDogXCI5MCVcIiwgZmxvYXQ6IFwicmlnaHRcIiwgXCJiYWNrZ3JvdW5kLWNvbG9yXCI6IFwid2hpdGVcIiwgXCJib3JkZXItcmlnaHRcIjogXCJncm9vdmVcIiwgXCJ3aGl0ZS1zcGFjZVwiOiBcIm5vd3JhcFwifX0sXG4gICAgICAgICAgICBtKCcjcmVzdWx0c1ZpZXdfdGFidWxhci5jb250YWluZXIxJyxcbiAgICAgICAgICAgICAge3N0eWxlOiB7d2lkdGg6IFwiMTAwJVwiLCBoZWlnaHQ6IFwiMTAwJVwiLCBcImJhY2tncm91bmQtY29sb3JcIjogXCJ3aGl0ZVwiLCBmbG9hdDogXCJsZWZ0XCIsIG92ZXJmbG93OiBcImF1dG9cIiwgXCJ3aGl0ZS1zcGFjZVwiOiBcIm5vd3JhcFwiLCBcImJvcmRlci1yaWdodFwiOiBcImdyb292ZVwiLCBcImJvcmRlci1ib3R0b21cIjogXCJncm9vdmVcIn19LFxuICAgICAgICAgICAgICBtKCcjU2VsZWN0aW9uRGF0YScsIHtzdHlsZToge3dpZHRoOiBcIjEwMCVcIiwgaGVpZ2h0OiBcIjUwJVwiLCBvdmVyZmxvdzogXCJhdXRvXCIsIFwibWFyZ2luLXRvcFwiOiBcIjEwcHhcIiwgXCJib3JkZXItYm90dG9tLXN0eWxlXCI6IFwiaW5zZXRcIn19LFxuICAgICAgICAgICAgICAgIG0oXCJmaWVsZHNldFwiLCB7c3R5bGU6IHttYXJnaW46IFwiMyVcIn19LFxuICAgICAgICAgICAgICAgICAgbShcImg0XCIsIHtzdHlsZToge1widGV4dC1hbGlnblwiOiBcImNlbnRlclwifX0sIFwiRGF0YSBEaXN0cmlidXRpb24gU2VsZWN0aW9uXCIpLFxuICAgICAgICAgICAgICAgICAgbShcInBcIiwge3N0eWxlOiB7XCJmb250LWZhbWlseVwiOiBcIkFyaWFsLCBIZWx2ZXRpY2EsIHNhbnMtc2VyaWZcIiwgXCJmb250LXNpemVcIjogXCIxMnB4XCJ9fSxcbiAgICAgICAgICAgICAgICAgICAgXCJFbnRlciBudW1iZXIgZm9yIGVhY2ggdmFyaWFibGUgdG8gc3BlY2lmeSB0aGUgYnJlYWsgcG9pbnRzXCIpLFxuICAgICAgICAgICAgICAgICAgbSgncCNib2xkc3R1ZmYnLCB7c3R5bGU6IHtjb2xvcjogXCIjMmE2NDk2XCIsIFwiZm9udC1mYW1pbHlcIjogXCJBcmlhbCwgSGVsdmV0aWNhLCBzYW5zLXNlcmlmXCIsIFwiZm9udC1zaXplXCI6IFwiMTJweFwifX0sXG4gICAgICAgICAgICAgICAgICAgIFwiU2VsZWN0IGJldHdlZW4gRXF1aWRpc3RhbnQgYW5kIEVxdWltYXNzXCIpKSxcbiAgICAgICAgICAgICAgICBtKCcjZm9yUGxvdEEnLCB7c3R5bGU6IHtkaXNwbGF5OiAnYmxvY2snLCBcIm1hcmdpblwiOiBcIjIlXCJ9fSxcbiAgICAgICAgICAgICAgICAgIG0oXCJpbnB1dCNpbnB1dDFbbmFtZT0nZm5hbWUnXVt0eXBlPSd0ZXh0J11cIiwge3N0eWxlOiB7XCJtYXJnaW4tbGVmdFwiOiBcIjIlXCJ9fSksXG4gICAgICAgICAgICAgICAgICBtKCdzcGFuI3Rvb2x0aXBQbG90QS50b29sdGlwdGV4dFtzdHlsZT12aXNpYmlsaXR5OiBoaWRkZW5dJyksXG4gICAgICAgICAgICAgICAgICBtKFwiYnV0dG9uLmJ0bi5idG4tZGVmYXVsdC5idG4teHMjRXF1aWRpc3RhbmNlMVt0eXBlPSdidXR0b24nXVwiLCB7c3R5bGU6IHtmbG9hdDogXCJsZWZ0XCIsIFwibWFyZ2luLWxlZnRcIjogXCIyJVwifX0sXG4gICAgICAgICAgICAgICAgICAgIFwiRVFVSURJU1RBTkNFXCIpLFxuICAgICAgICAgICAgICAgICAgbShcImJ1dHRvbi5idG4uYnRuLWRlZmF1bHQuYnRuLXhzI0VxdWltYXNzMVt0eXBlPSdidXR0b24nXVwiLCB7c3R5bGU6IHtmbG9hdDogXCJsZWZ0XCIsIFwibWFyZ2luLWxlZnRcIjogXCIyJVwifX0sXG4gICAgICAgICAgICAgICAgICAgIFwiRVFVSU1BU1NcIikpLFxuICAgICAgICAgICAgICAgIG0oJyNmb3JQbG90QicsIHtzdHlsZToge2Rpc3BsYXk6IFwiYmxvY2tcIiwgbWFyZ2luOiBcIjIlXCJ9fSxcbiAgICAgICAgICAgICAgICAgIG0oXCJpbnB1dCNpbnB1dDJbbmFtZT0nZm5hbWUxJ11bdHlwZT0ndGV4dCddXCIsIHtzdHlsZToge1wibWFyZ2luLWxlZnRcIjogXCIyJVwifX0pLFxuICAgICAgICAgICAgICAgICAgbSgnc3BhbiN0b29sdGlwUGxvdEIudG9vbHRpcHRleHQxW3N0eWxlPXZpc2liaWxpdHk6IGhpZGRlbl0nKSxcbiAgICAgICAgICAgICAgICAgIG0oXCJidXR0b24uYnRuLmJ0bi1kZWZhdWx0LmJ0bi14cyNFcXVpZGlzdGFuY2UyW3R5cGU9J2J1dHRvbiddXCIsIHtzdHlsZToge2Zsb2F0OiBcImxlZnRcIiwgXCJtYXJnaW4tbGVmdFwiOiBcIjIlXCJ9fSwgXCJFUVVJRElTVEFOQ0VcIiksXG4gICAgICAgICAgICAgICAgICBtKFwiYnV0dG9uLmJ0bi5idG4tZGVmYXVsdC5idG4teHMjRXF1aW1hc3MyW3R5cGU9J2J1dHRvbiddXCIsIHtzdHlsZToge2Zsb2F0OiBcImxlZnRcIiwgXCJtYXJnaW4tbGVmdFwiOiBcIjIlXCJ9fSwgXCJFUVVJTUFTU1wiKSksXG4gICAgICAgICAgICAgICAgbShcIiNwbG90QV9zdGF0dXNbc3R5bGU9bWFyZ2luLXRvcDogMSU7IG1hcmdpbi1sZWZ0OiAyJV1cIiksXG4gICAgICAgICAgICAgICAgbShcIiNwbG90Ql9zdGF0dXNbc3R5bGU9bWFyZ2luLXRvcDogMSU7IG1hcmdpbi1sZWZ0OiAyJV1cIiksXG4gICAgICAgICAgICAgICAgbSgnaDVbc3R5bGU9Y29sb3I6ICNhYzI5MjU7IG1hcmdpbi10b3A6IDElOyBtYXJnaW4tbGVmdDogMiVdJywgJ1NlbGVjdGlvbiBIaXN0b3J5JyksXG4gICAgICAgICAgICAgICAgbSgnI2JyZWFrc3BhY2Vbc3R5bGU9ZGlzcGxheTogaW5saW5lLWJsb2NrOyBvdmVyZmxvdzogYXV0bzsgd2lkdGg6IDEwMCVdJyksXG4gICAgICAgICAgICAgICAgbShcImJ1dHRvbi5idG4uYnRuLWRlZmF1bHQuYnRuLXNtW2lkPSdTZWxlY3Rpb25EYXRhMSddW3R5cGU9J2J1dHRvbiddXCIsIHtzdHlsZToge2Rpc3BsYXk6IFwiYmxvY2tcIiwgbWFyZ2luOiBcIjAgYXV0b1wiLCBwb3NpdGlvbjogXCJyZWxhdGl2ZVwifX0sXG4gICAgICAgICAgICAgICAgICBcIkNyZWF0ZVwiKSksXG4gICAgICAgICAgICAgIG0oJyN0YWJ1bGFyXzEnLCB7c3R5bGU6IHt3aWR0aDogXCIxMDAlXCIsIGhlaWdodDogXCIyMDBweFwiLCBcImJvcmRlci1ib3R0b20tc3R5bGVcIjogXCJpbnNldFwifX0sXG4gICAgICAgICAgICAgICAgbSgnI3Bsb3RBJywge3N0eWxlOiB7d2lkdGg6IGV4cC5nZXRfd2lkdGgoJ3Bsb3RBJykgKyAnJScsIGhlaWdodDogXCIxMDAlXCIsIGZsb2F0OiBcImxlZnRcIiwgb3ZlcmZsb3c6IFwiaGlkZGVuXCJ9fSwgXCJwbG90QVwiKSxcbiAgICAgICAgICAgICAgICBtKCcjcGxvdEInLCB7c3R5bGU6IHt3aWR0aDogZXhwLmdldF93aWR0aCgncGxvdEInKSArICclJywgaGVpZ2h0OiBcIjEwMCVcIiwgZmxvYXQ6IFwicmlnaHRcIiwgb3ZlcmZsb3c6IFwiaGlkZGVuXCJ9fSwgXCJwbG90QlwiKSksXG4gICAgICAgICAgICAgIG0oJyN0YWJ1bGFyXzInLCB7c3R5bGU6IHt3aWR0aDogXCIxMDAlXCIsIGhlaWdodDogXCI1MCVcIiwgXCJib3JkZXItYm90dG9tLXN0eWxlXCI6IFwiaW5zZXRcIiwgb3ZlcmZsb3c6IFwiaGlkZGVuXCJ9fSkpKSxcbiAgICAgICAgICBtKFwicCNyZXN1bHRzSG9sZGVyXCIsIHtzdHlsZToge3BhZGRpbmc6IFwiLjVlbSAxZW1cIn19LFxuICAgICAgICAgICAgbSgnI3Zhckxpc3Rbc3R5bGU9ZGlzcGxheTogYmxvY2tdJyxcbiAgICAgICAgICAgICAgdW5pcXVlX2xpbmtfbmFtZXMoKS5tYXAoeCA9PiBtKGBwIyR7eC5yZXBsYWNlKC9cXFcvZywgJ18nKX1gLCB7b25jbGljazogXz0+IGV4cC5jYWxsVHJlZUFwcCh4KSwgc3R5bGU6IHsnYmFja2dyb3VuZC1jb2xvcic6IGFwcC52YXJDb2xvcn19LCB4KSkpKSxcbiAgICAgICAgICBtKCcjc2V0eFtzdHlsZT1kaXNwbGF5OiBub25lOyBtYXJnaW4tdG9wOiAuNWVtXScpKSA6XG4gICAgLy8gbW9kZSA9PSBudWxsIChtb2RlbCBtb2RlKVxuICAgIG0oUGFuZWwsXG4gICAgICB7c2lkZTogJ3JpZ2h0JyxcbiAgICAgICB0aXRsZTogJ01vZGVsIFNlbGVjdGlvbicsXG4gICAgICAgYnV0dG9uczogKCFhcHAuSVNfRDNNX0RPTUFJTiA/IFtdIDogW1xuICAgICAgICAgICBtKEJ1dHRvbiwge2lkOiAnYnRuTW9kZWxzJ30sICdNb2RlbHMnKSxcbiAgICAgICAgICAgbShCdXR0b24sIHtpZDogJ2J0blNldHgnfSwgJ1NldCBDb3Zhci4nKSxcbiAgICAgICAgICAgbShCdXR0b24sIHtpZDogJ2J0blJlc3VsdHMnfSwgJ1Jlc3VsdHMnKSxcbiAgICAgICBdKS5jb25jYXQoW1xuICAgICAgICAgICBtKEJ1dHRvbiwge2lkOiAnYnRuVHlwZScsIGlzX2V4cGxvcmVfbW9kZTogZXhwLmV4cGxvcmV9LCAnVGFzayBUeXBlJyksXG4gICAgICAgICAgIG0oQnV0dG9uLCB7aWQ6ICdidG5TdWJ0eXBlJywgaXNfZXhwbG9yZV9tb2RlOiBleHAuZXhwbG9yZX0sICdTdWJ0eXBlJyksXG4gICAgICAgICAgIG0oQnV0dG9uLCB7aWQ6ICdidG5NZXRyaWNzJywgaXNfZXhwbG9yZV9tb2RlOiBleHAuZXhwbG9yZX0sICdNZXRyaWNzJyksXG4gICAgICAgICAgIG0oQnV0dG9uLCB7aWQ6ICdidG5TZXR4JywgaXNfZXhwbG9yZV9tb2RlOiBleHAuZXhwbG9yZX0sICdTZXQgQ292YXIuJyksXG4gICAgICAgICAgIG0oQnV0dG9uLCB7aWQ6ICdidG5SZXN1bHRzJywgaXNfZXhwbG9yZV9tb2RlOiBleHAuZXhwbG9yZX0sICdSZXN1bHRzJyldKX0sXG4gICAgICBtKGAjcmVzdWx0c1tzdHlsZT1kaXNwbGF5OiAke3doZW4oJ3JpZ2h0JywgJ2J0blJlc3VsdHMnKX07IG1hcmdpbi10b3A6IC41ZW1dYCxcbiAgICAgICAgbShcIiNyZXN1bHRzVmlldy5jb250YWluZXJbc3R5bGU9ZmxvYXQ6IHJpZ2h0OyBvdmVyZmxvdzogYXV0bzsgd2lkdGg6IDgwJTsgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7IHdoaXRlLXNwYWNlOiBub3dyYXBdXCIpLFxuICAgICAgICBtKCcjbW9kZWxWaWV3W3N0eWxlPWRpc3BsYXk6IG5vbmU7IGZsb2F0OiBsZWZ0OyB3aWR0aDogMjAlOyBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZV0nKSxcbiAgICAgICAgbShcInAjcmVzdWx0c0hvbGRlcltzdHlsZT1wYWRkaW5nOiAuNWVtIDFlbV1cIikpLFxuICAgICAgICAvLyB0aGlzIG5hbWluZyBpcyBnZXR0aW5nIHJpZGljdWxvdXMuLi5cbiAgICAgIG0oYCNzZXR4W3N0eWxlPWRpc3BsYXk6ICR7d2hlbigncmlnaHQnLCAnYnRuU2V0eCcpfV1gLFxuICAgICAgICBtKCcjc2V0eFJpZ2h0W3N0eWxlPWRpc3BsYXk6YmxvY2s7IGZsb2F0OiByaWdodDsgd2lkdGg6IDI1JTsgaGVpZ2h0OjEwMCU7IGJhY2tncm91bmQtY29sb3I6IHdoaXRlXScpLFxuICAgICAgICBtKCcjc2V0eFRvcFtzdHlsZT1kaXNwbGF5OmJsb2NrOyBmbG9hdDogbGVmdDsgd2lkdGg6IDc1JTsgaGVpZ2h0OjEwJTsgb3ZlcmZsb3c6IGF1dG87IGJhY2tncm91bmQtY29sb3I6IHdoaXRlXScsXG4gICAgICAgICAgICBtKFwiYnV0dG9uLmJ0bi5idG4tZGVmYXVsdC5idG4teHMjYnRuUHJlZFBsb3RbdHlwZT0nYnV0dG9uJ11cIiwge29uY2xpY2s6IF89PiBhcHAuc2hvd1ByZWRQbG90KCdidG5QcmVkUGxvdCcpLCBzdHlsZToge2Zsb2F0OiBcImxlZnRcIiwgXCJtYXJnaW4tbGVmdFwiOiBcIjIlXCJ9fSwgXCJQcmVkaWN0aW9uIFN1bW1hcnlcIiksXG4gICAgICAgICAgICBtKFwiYnV0dG9uLmJ0bi5idG4tZGVmYXVsdC5idG4teHMjYnRuR2VuUHJlZHNbdHlwZT0nYnV0dG9uJ11cIiwge29uY2xpY2s6IF89PiBhcHAuc2hvd0dlblByZWRzKCdidG5HZW5QcmVkcycpLCBzdHlsZToge2Zsb2F0OiBcImxlZnRcIiwgXCJtYXJnaW4tbGVmdFwiOiBcIjIlXCJ9fSwgXCJHZW5lcmF0ZSBOZXcgUHJlZGljdGlvbnNcIikpLFxuICAgICAgICBtKCcjc2V0eExlZnRQbG90W3N0eWxlPWRpc3BsYXk6YmxvY2s7IGZsb2F0OiBsZWZ0OyB3aWR0aDogNzUlOyBoZWlnaHQ6OTUlOyBvdmVyZmxvdzogYXV0bzsgYmFja2dyb3VuZC1jb2xvcjogd2hpdGVdJyksXG4gICAgICAgIG0oJyNzZXR4TGVmdFtzdHlsZT1kaXNwbGF5Om5vbmU7IGZsb2F0OiBsZWZ0OyB3aWR0aDogNzUlOyBoZWlnaHQ6OTUlOyBvdmVyZmxvdzogYXV0bzsgYmFja2dyb3VuZC1jb2xvcjogd2hpdGVdJyksXG4gICAgICAgIG0oJyNzZXR4TGVmdEdlbltzdHlsZT1kaXNwbGF5Om5vbmU7IGZsb2F0OiBsZWZ0OyB3aWR0aDogNzUlOyBoZWlnaHQ6OTUlOyBvdmVyZmxvdzogYXV0bzsgYmFja2dyb3VuZC1jb2xvcjogd2hpdGVdJyxcbiAgICAgICAgICAgIG0oJyNzZXR4TGVmdFRvcFtzdHlsZT1kaXNwbGF5OmJsb2NrOyBmbG9hdDogbGVmdDsgd2lkdGg6IDEwMCU7IGhlaWdodDo1MCU7IG92ZXJmbG93OiBhdXRvOyBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZV0nLFxuICAgICAgICAgICAgICAgIG0oJyNzZXR4TGVmdFRvcExlZnRbc3R5bGU9ZGlzcGxheTpibG9jazsgZmxvYXQ6IGxlZnQ7IHdpZHRoOiAzMCU7IGhlaWdodDoxMDAlOyBvdmVyZmxvdzogYXV0bzsgYmFja2dyb3VuZC1jb2xvcjogd2hpdGVdJyksXG4gICAgICAgICAgICAgICAgbSgnI3NldHhMZWZ0VG9wUmlnaHRbc3R5bGU9ZGlzcGxheTpibG9jazsgZmxvYXQ6IGxlZnQ7IHdpZHRoOiA3MCU7IGhlaWdodDoxMDAlOyBvdmVyZmxvdzogYXV0bzsgYmFja2dyb3VuZC1jb2xvcjogd2hpdGVdJykpLFxuICAgICAgICAgICAgbSgnI3NldHhMZWZ0Qm90dG9tTGVmdFtzdHlsZT1kaXNwbGF5OmJsb2NrOyBmbG9hdDogbGVmdDsgd2lkdGg6IDcwJTsgaGVpZ2h0OjUwJTsgb3ZlcmZsb3c6IGF1dG87IGJhY2tncm91bmQtY29sb3I6IHdoaXRlXScpLFxuICAgICAgICAgICAgbSgnI3NldHhMZWZ0Qm90dG9tUmlnaHRUb3Bbc3R5bGU9ZGlzcGxheTpibG9jazsgZmxvYXQ6IGxlZnQ7IHdpZHRoOiAzMCU7IGhlaWdodDoxMCU7IG92ZXJmbG93OiBhdXRvOyBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZV0nLFxuICAgICAgICAgICAgICAgIG0oQnV0dG9uLFxuICAgICAgICAgICAgICAgICAgICB7aWQ6ICdidG5FeGVjdXRlUGlwZScsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzZXM6ICdidG4tZGVmYXVsdC5sYWRkYS1idXR0b25bZGF0YS1zcGlubmVyLWNvbG9yPSMwMDAwMDBdW2RhdGEtc3R5bGU9em9vbS1pbl0nLFxuICAgICAgICAgICAgICAgICAgICBvbmNsaWNrOiBfID0+IGFwcC5leGVjdXRlcGlwZWxpbmUoJ2J0bkV4ZWN1dGVQaXBlJyksXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiBgZGlzcGxheTppbmxpbmU7IGZsb2F0OiBsZWZ0OyBtYXJnaW4tcmlnaHQ6IDEwcHhgLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ0V4ZWN1dGUgcGlwZWxpbmUuJ30sXG4gICAgICAgICAgICAgICAgICAgIG0oJ3NwYW4ubGFkZGEtbGFiZWxbc3R5bGU9cG9pbnRlci1ldmVudHM6IG5vbmVdJywgJ0V4ZWN1dGUgR2VuZXJhdGlvbicpKSksXG4gICAgICAgICAgICBtKCcjc2V0eExlZnRCb3R0b21SaWdodEJvdHRvbVtzdHlsZT1kaXNwbGF5OmJsb2NrOyBmbG9hdDogbGVmdDsgd2lkdGg6IDMwJTsgaGVpZ2h0OjQwJTsgb3ZlcmZsb3c6IGF1dG87IGJhY2tncm91bmQtY29sb3I6IHdoaXRlXScpKSksXG4gICAgICByaWdodHRhYignbW9kZWxzJywgJ2J0bk1vZGVscycpLFxuICAgICAgcmlnaHR0YWIoJ3R5cGVzJywgJ2J0blR5cGUnLCBhcHAuZDNtVGFza1R5cGUsICdUYXNrJywgJ3Rhc2tUeXBlJyksXG4gICAgICByaWdodHRhYignc3VidHlwZXMnLCAnYnRuU3VidHlwZScsIGFwcC5kM21UYXNrU3VidHlwZSwgJ1Rhc2sgU3VidHlwZScsICd0YXNrU3VidHlwZScpLFxuICAgICAgcmlnaHR0YWIoJ21ldHJpY3MnLCAnYnRuTWV0cmljcycsIGFwcC5kM21NZXRyaWNzLCAnTWV0cmljJywgJ21ldHJpYycpKTtcbn1cblxubGV0IHRpY2tlciA9IG1vZGUgPT4ge1xuICAgIGxldCBsaW5rID0gbmFtZSA9PiBtKGBhJHtuYW1lID09PSBtb2RlID8gJy5hY3RpdmUnIDogJyd9W2hyZWY9LyR7bmFtZX1dW3N0eWxlPW1hcmdpbi1yaWdodDogMC41ZW1dYCwge29uY3JlYXRlOiBtLnJvdXRlLmxpbmt9LCBuYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpKTtcbiAgICByZXR1cm4gbSgnI3RpY2tlcltzdHlsZT1iYWNrZ3JvdW5kOiAjRjlGOUY5OyBib3R0b206IDA7IGhlaWdodDogNDBweDsgcG9zaXRpb246IGZpeGVkOyB3aWR0aDogMTAwJTsgYm9yZGVyLXRvcDogMXB4IHNvbGlkICNBREFEQURdJyxcbiAgICAgICAgbGluaygnbW9kZWwnKSxcbiAgICAgICAgbGluaygnZXhwbG9yZScpLFxuICAgICAgICBtKFwiYSNsb2dJRFtocmVmPXNvbWVsaW5rXVt0YXJnZXQ9X2JsYW5rXVwiLCBcIlJlcGxpY2F0aW9uXCIpLFxuICAgICAgICBtKFwic3BhbltzdHlsZT1jb2xvcjojMzM3YWI3XVwiLCBcIiB8IFwiKSxcbiAgICAgICAgLy8gZGV2IGxpbmtzLi4uXG4gICAgICAgIG0oXCJhW2hyZWY9Jy9kZXYtcmF2ZW4tbGlua3MnXVt0YXJnZXQ9X2JsYW5rXVwiLCBcInJhdmVuLWxpbmtzXCIpLFxuICAgICAgICAvL20oXCJhW3N0eWxlPW1hcmdpbi1yaWdodDogMC41ZW1dXCIsXG4gICAgICAgIC8vICB7b25jbGljazogYXBwLnJlY29yZF91c2VyX21ldGFkYXRhfSxcbiAgICAgICAgLy8gIFwicmVjb3JkLW1ldGFkYXRhXCIpLFxuICAgICAgICBtKFwic3BhbltzdHlsZT1jb2xvcjojMzM3YWI3XVwiLCBcIiB8IFwiKSxcbiAgICAgICAgIG0oXCJzcGFuW3N0eWxlPWNvbG9yOiMzMzdhYjddXCIsIFwiVEEyOiBcIiArIFRBMl9TRVJWRVIpLFxuICAgICAgICAgbShcInNwYW5bc3R5bGU9Y29sb3I6IzMzN2FiN11cIiwgXCIgfCBcIiksXG4gICAgICAgICBtKFwic3BhbltzdHlsZT1jb2xvcjojMzM3YWI3XVwiLCBcIlRBM1RBMiBhcGk6IFwiICsgVEEzVEEyX0FQSV9WRVJTSU9OKSk7XG59O1xuXG5jbGFzcyBCb2R5IHtcbiAgICBvbmluaXQodm5vZGUpIHtcbiAgICAgICAgaWYgKHZub2RlLmF0dHJzLm1vZGUpIHtcbiAgICAgICAgICAgIG0ucm91dGUuc2V0KCcvbW9kZWwnKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hYm91dCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnVzZXJ0YXNrcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNpdGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jaXRlSGlkZGVuID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGFzdF9tb2RlID0gbnVsbDtcbiAgICB9XG5cbiAgICBvbmNyZWF0ZSgpIHtcbiAgICAgICAgbGV0IGV4dHJhY3QgPSAobmFtZSwga2V5LCBvZmZzZXQsIHJlcGxhY2UpID0+IHtcbiAgICAgICAgICAgIGtleSA9IGtleSArICc9JztcbiAgICAgICAgICAgIGxldCBsb2MgPSB3aW5kb3cubG9jYXRpb24udG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGxldCB2YWwgPSBsb2MuaW5kZXhPZihrZXkpID4gMCA/IGxvYy5zdWJzdHJpbmcobG9jLmluZGV4T2Yoa2V5KSArIG9mZnNldCkgOiAnJztcbiAgICAgICAgICAgIGxldCBpZHggPSB2YWwuaW5kZXhPZignJicpO1xuICAgICAgICAgICAgdmFsID0gaWR4ID4gMCA/IHZhbC5zdWJzdHJpbmcoMCwgaWR4KSA6IHZhbDtcbiAgICAgICAgICAgIHZhbCA9IHZhbC5yZXBsYWNlKCcjIS9tb2RlbCcsICcnKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG5hbWUsICc6ICcsIHZhbCk7XG4gICAgICAgICAgICBpZiAocmVwbGFjZSkgdmFsID0gdmFsXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoLyUyNS9nLCAnJScpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoLyUzQS9nLCAnOicpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoLyUyRi9nLCAnLycpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfTtcbiAgICAgICAgYXBwLm1haW4oXG4gICAgICAgICAgICBleHRyYWN0KCdmaWxlaWQnLCAnZGZJZCcsIDUpLFxuICAgICAgICAgICAgZXh0cmFjdCgnaG9zdG5hbWUnLCAnaG9zdCcsIDUpLFxuICAgICAgICAgICAgZXh0cmFjdCgnZGRpdXJsJywgJ2RkaXVybCcsIDcsIHRydWUpLFxuICAgICAgICAgICAgZXh0cmFjdCgnZGF0YXVybCcsICdkYXRhdXJsJywgOCwgdHJ1ZSksXG4gICAgICAgICAgICBleHRyYWN0KCdhcGlrZXknLCAna2V5JywgNCkpO1xuICAgIH1cblxuICAgIHZpZXcodm5vZGUpIHtcbiAgICAgICAgbGV0IHttb2RlfSA9IHZub2RlLmF0dHJzO1xuICAgICAgICBsZXQgZXhwbG9yZSA9IG1vZGUgPT09ICdleHBsb3JlJztcbiAgICAgICAgYXBwLmlzX3Jlc3VsdHNfbW9kZSA9IG1vZGUgPT09ICdyZXN1bHRzJztcbiAgICAgICAgbGV0IHVzZXJsaW5rcyA9IFtdO1xuICAgICAgICBpZih1c2VybmFtZT09XCJubyBsb2dnZWQgaW4gdXNlclwiKXtcbiAgICAgICAgICB1c2VybGlua3MgPSBbXG4gICAgICAgICAge3RpdGxlOiBcIkxvZyBpblwiLCB1cmw6IGxvZ2luX3VybH0sXG4gICAgICAgICAge3RpdGxlOiBcIlNpZ24gdXBcIiwgdXJsOiBzaWdudXBfdXJsfVxuICAgICAgICAgIF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXNlcmxpbmtzID0gW1xuICAgICAgICAgIHt0aXRsZTogXCJXb3Jrc3BhY2VzXCIsIHVybDogd29ya3NwYWNlc191cmx9LFxuICAgICAgICAgIHt0aXRsZTogXCJTZXR0aW5nc1wiLCB1cmw6IHNldHRpbmdzX3VybH0sXG4gICAgICAgICAge3RpdGxlOiBcIkxpbmtzXCIsIHVybDogZGV2bGlua3NfdXJsfSxcbiAgICAgICAgICB7dGl0bGU6IFwiTG9nb3V0XCIsIHVybDogbG9nb3V0X3VybH1cbiAgICAgICAgXX07XG4gICAgICAgIGxldCBfbmF2QnRuID0gKGlkLCBsZWZ0LCByaWdodCwgb25jbGljaywgYXJncywgbWluKSA9PiBtKFxuICAgICAgICAgICAgYGJ1dHRvbiMke2lkfS5idG4ubmF2YmFyLXJpZ2h0YCxcbiAgICAgICAgICAgIHtvbmNsaWNrOiBvbmNsaWNrLFxuICAgICAgICAgICAgIHN0eWxlOiB7J21hcmdpbi1sZWZ0JzogbGVmdCArICdlbScsXG4gICAgICAgICAgICAgICAgICAgICAnbWFyZ2luLXJpZ2h0JzogcmlnaHQgKyAnZW0nLFxuICAgICAgICAgICAgICAgICAgICAgJ21pbi13aWR0aCc6IG1pbn19LFxuICAgICAgICAgICAgYXJncyk7XG4gICAgICAgIGxldCBuYXZCdG4gPSAoaWQsIGxlZnQsIHJpZ2h0LCBvbmNsaWNrLCBhcmdzLCBtaW4pID0+IF9uYXZCdG4oXG4gICAgICAgICAgICBpZCArICcubGFkZGEtYnV0dG9uW2RhdGEtc3Bpbm5lci1jb2xvcj0jMDAwMDAwXVtkYXRhLXN0eWxlPXpvb20taW5dJyxcbiAgICAgICAgICAgIGxlZnQsIHJpZ2h0LCBvbmNsaWNrLCBhcmdzLCBtaW4pO1xuICAgICAgICBsZXQgbmF2QnRuMSA9IChpZCwgb25jbGljaywgYXJncywgdGl0bGUpID0+IF9uYXZCdG4oXG4gICAgICAgICAgICBgJHtpZH0uYnRuLWRlZmF1bHRbdGl0bGU9JHt0aXRsZX1dYCwgMiwgMCwgb25jbGljaywgYXJncyk7XG4gICAgICAgIGxldCBnbHlwaCA9IChpY29uLCB1bnN0eWxlZCkgPT4gbShcbiAgICAgICAgICAgIGBzcGFuLmdseXBoaWNvbi5nbHlwaGljb24tJHtpY29ufWAgKyAodW5zdHlsZWQgPyAnJyA6ICdbc3R5bGU9Y29sb3I6ICM4MTgxODE7IGZvbnQtc2l6ZTogMWVtOyBwb2ludGVyLWV2ZW50czogbm9uZV0nKSk7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1hdGlvbiA9IChpZCwgbGlzdCkgPT4gbShcbiAgICAgICAgICAgIGB1bCMke2lkfWAsIHtcbiAgICAgICAgICAgICAgICBzdHlsZToge2Rpc3BsYXk6ICdub25lJywgJ2JhY2tncm91bmQtY29sb3InOiBhcHAudmFyQ29sb3J9LFxuICAgICAgICAgICAgICAgIG9uY2xpY2s6IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBpbnRlcmFjdCBpcyBzZWxlY3RlZCwgc2hvdyB2YXJpYWJsZSBsaXN0IGFnYWluXG4gICAgICAgICAgICAgICAgICAgIGlmICgkKHRoaXMpLnRleHQoKSA9PT0gJ2ludGVyYWN0KGQsZSknKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkKCcjdElucHV0JykudmFsKHR2YXIuY29uY2F0KCcqJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsSW50ZXJhY3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5wYXJlbnQoKS5mYWRlT3V0KDEwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkKCcjdHJhbnNTZWwnKS5mYWRlSW4oMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGxldCB0dmFyID0gJCgnI3RJbnB1dCcpLnZhbCgpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdGZ1bmMgPSAkKHRoaXMpLnRleHQoKS5yZXBsYWNlKFwiZFwiLCBcIl90cmFuc3ZhcjBcIik7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0Y2FsbCA9ICQodGhpcykudGV4dCgpLnJlcGxhY2UoXCJkXCIsIHR2YXIpO1xuICAgICAgICAgICAgICAgICAgICAkKCcjdElucHV0JykudmFsKHRjYWxsKTtcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5wYXJlbnQoKS5mYWRlT3V0KDEwMCk7XG4gICAgICAgICAgICAgICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtKHR2YXIsIHRmdW5jLCB0eXBlVHJhbnNmb3JtID0gZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsaXN0Lm1hcCh4ID0+IG0oJ2xpJywgeCkpKTtcbiAgICAgICAgbGV0IHNwYWNlQnRuID0gKGlkLCBvbmNsaWNrLCB0aXRsZSwgaWNvbikgPT4gbShcbiAgICAgICAgICAgIGBidXR0b24jJHtpZH0uYnRuLmJ0bi1kZWZhdWx0YCwge29uY2xpY2ssIHRpdGxlfSwgZ2x5cGgoaWNvbiwgdHJ1ZSkpO1xuXG4gICAgICAgIGlmIChtb2RlICE9IHRoaXMubGFzdF9tb2RlKSB7XG4gICAgICAgICAgICBpZiAoZXhwbG9yZSkge1xuICAgICAgICAgICAgICAgIGFwcC5zZXRfZXhwbG9yZV9tb2RlKGV4cGxvcmUpO1xuICAgICAgICAgICAgICAgIGFwcC5zZXRfcmlnaHR0YWIoJ2J0blVuaXZhcmlhdGUnKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIW1vZGUpIHtcbiAgICAgICAgICAgICAgICBhcHAuc2V0X3JpZ2h0dGFiKElTX0QzTV9ET01BSU4gPyAnYnRuVHlwZScgOiAnYnRuTW9kZWxzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhcHAucmVzdGFydCAmJiBhcHAucmVzdGFydCgpO1xuICAgICAgICAgICAgdGhpcy5sYXN0X21vZGUgPSBtb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG0oXG4gICAgICAgICAgICAnbWFpbicsXG4gICAgICAgICAgICBtKFwibmF2I25hdmJhci5uYXZiYXIubmF2YmFyLWRlZmF1bHQubmF2YmFyLWZpeGVkLXRvcFtyb2xlPW5hdmlnYXRpb25dXCIsXG4gICAgICAgICAgICAgIHtzdHlsZTogbW9kZSA9PT0gJ2V4cGxvcmUnICYmICdiYWNrZ3JvdW5kLWltYWdlOiAtd2Via2l0LWxpbmVhci1ncmFkaWVudCh0b3AsICNmZmYgMCwgcmdiKDIyNywgMjQyLCAyNTQpIDEwMCUpJ30sXG4gICAgICAgICAgICAgIG0oXCJhLm5hdmJhci1icmFuZFwiLFxuICAgICAgICAgICAgICAgIG0oXCJpbWdbc3JjPS9zdGF0aWMvaW1hZ2VzL1R3b1JhdmVucy5wbmddW2FsdD1Ud29SYXZlbnNdW3dpZHRoPTEwMF1bc3R5bGU9bWFyZ2luLWxlZnQ6IDFlbTsgbWFyZ2luLXRvcDogLTAuNWVtXVwiLFxuICAgICAgICAgICAgICAgICAge29ubW91c2VvdmVyOiBfID0+IHRoaXMuYWJvdXQgPSB0cnVlLCBvbm1vdXNlb3V0OiBfID0+IHRoaXMuYWJvdXQgPSBmYWxzZX0pKSxcbiAgICAgICAgICAgICAgbSgnI25hdmJhck5hdltzdHlsZT1wYWRkaW5nOiAwLjVlbV0nLFxuICAgICAgICAgICAgICAgIG0oJyNkYXRhRmllbGQuZmllbGRbc3R5bGU9bWFyZ2luLXRvcDogMC41ZW07IHRleHQtYWxpZ246IGNlbnRlcl0nLFxuICAgICAgICAgICAgICAgICAgbSgnaDQjZGF0YU5hbWVbc3R5bGU9ZGlzcGxheTogaW5saW5lXScsXG4gICAgICAgICAgICAgICAgICAgIHtvbmNsaWNrOiBfID0+IHRoaXMuY2l0ZSA9IHRoaXMuY2l0ZUhpZGRlbiA9ICF0aGlzLmNpdGVIaWRkZW4sXG4gICAgICAgICAgICAgICAgICAgICBvbm1vdXNlb3V0OiBfID0+IHRoaXMuY2l0ZUhpZGRlbiB8fCAodGhpcy5jaXRlID0gZmFsc2UpLFxuICAgICAgICAgICAgICAgICAgICAgb25tb3VzZW92ZXI6IF8gPT4gdGhpcy5jaXRlID0gdHJ1ZX0sXG4gICAgICAgICAgICAgICAgICAgIFwiRGF0YXNldCBOYW1lXCIpLFxuICAgICAgICAgICAgICAgICAgbSgnI2NpdGUucGFuZWwucGFuZWwtZGVmYXVsdCcsXG4gICAgICAgICAgICAgICAgICAgIHtzdHlsZTogYGRpc3BsYXk6ICR7dGhpcy5jaXRlID8gJ2Jsb2NrJyA6ICdub25lJ307IHBvc2l0aW9uOiBhYnNvbHV0ZTsgcmlnaHQ6IDUwJTsgd2lkdGg6IDM4MHB4OyB0ZXh0LWFsaWduOiBsZWZ0OyB6LWluZGV4OiA1MGB9LFxuICAgICAgICAgICAgICAgICAgICBtKFwiLnBhbmVsLWJvZHlcIikpLFxuICAgICAgICAgICAgICAgICAgbSgnc3BhbicsXG4gICAgICAgICAgICAgICAgICAgIG0oJy5kcm9wZG93bltzdHlsZT1mbG9hdDogcmlnaHQ7IHBhZGRpbmctcmlnaHQ6IDFlbV0nLFxuICAgICAgICAgICAgICAgICAgICAgIG0oJyNkcm9wLmJ1dHRvbi5idG5bdHlwZT1idXR0b25dW2RhdGEtdG9nZ2xlPWRyb3Bkb3duXVthcmlhLWhhc3BvcHVwPXRydWVdW2FyaWEtZXhwYW5kZWQ9ZmFsc2VdJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIFt1c2VybmFtZSwgXCIgXCIgLCBnbHlwaCgndHJpYW5nbGUtYm90dG9tJyldKSxcbiAgICAgICAgICAgICAgICAgICAgICBtKCd1bC5kcm9wZG93bi1tZW51W3JvbGU9bWVudV1bYXJpYS1sYWJlbGxlZGJ5PWRyb3BdJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJsaW5rcy5tYXAoZnVuY3Rpb24obGluaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbSgnYVtzdHlsZT1wYWRkaW5nOiAwLjVlbV0nLCB7aHJlZjogbGluay51cmx9LCBsaW5rLnRpdGxlICwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG0oJ2JyJykpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSkpLCBcbiAgICAgICAgICAgICAgICAgICAgbmF2QnRuKCdidG5Fc3RpbWF0ZS5idG4tZGVmYXVsdCcsIDIsIDEsIGV4cGxvcmUgPyBleHAuZXhwbG9yZSA6IGFwcC5lc3RpbWF0ZSwgbShcInNwYW4ubGFkZGEtbGFiZWxcIiwgZXhwbG9yZSA/ICdFeHBsb3JlJyA6ICdTb2x2ZSBUaGlzIFByb2JsZW0nKSwgJzE1MHB4JyksXG4gICAgICAgICAgICAgICAgICAgIG5hdkJ0bignYnRuVEEyLmJ0bi1kZWZhdWx0JywgLjIsIDEsIF8gPT4gYXBwLmhlbHBtYXRlcmlhbHMoJ21hbnVhbCcpLCBbJ0hlbHAgTWFudWFsICcsIGdseXBoKCdib29rJyldKSxcbiAgICAgICAgICAgICAgICAgICAgbmF2QnRuKCdidG5UQTIuYnRuLWRlZmF1bHQnLCAuMiwgLjIsIF8gPT4gYXBwLmhlbHBtYXRlcmlhbHMoJ3ZpZGVvJyksIFsnSGVscCBWaWRlbyAnLCBnbHlwaCgnZXhwYW5kJyldKSxcbiAgICAgICAgICAgICAgICAgICAgbmF2QnRuKCdidG5UQTIuYnRuLWRlZmF1bHQnLCAyLCAuMiwgXyA9PiBob3BzY290Y2guc3RhcnRUb3VyKG15dG91cjIsIDApLCBbJ0hlbHAgVG91ciAnLCBnbHlwaCgncm9hZCcpXSksXG4gICAgICAgICAgICAgICAgICAgIG5hdkJ0bjEoXCJidG5SZXNldFwiLCBhcHAucmVzZXQsIGdseXBoKCdyZXBlYXQnKSwgJ1Jlc2V0JyksXG4gICAgICAgICAgICAgICAgICAgIG5hdkJ0bjEoJ2J0bkVuZFNlc3Npb24nLCBhcHAuZW5kc2Vzc2lvbiwgbShcInNwYW4ubGFkZGEtbGFiZWxcIiwgJ01hcmsgUHJvYmxlbSBGaW5pc2hlZCcpLCAnTWFyayBQcm9ibGVtIEZpbmlzaGVkJykpLFxuICAgICAgICAgICAgICAgICAgbSgnI3RJbnB1dCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICBzdHlsZToge2Rpc3BsYXk6ICdub25lJ30sXG4gICAgICAgICAgICAgICAgICAgICAgb25jbGljazogXyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChieUlkKCd0cmFuc1NlbCcpLnN0eWxlLmRpc3BsYXkgIT09ICdub25lJykgeyAvLyBpZiB2YXJpYWJsZSBsaXN0IGlzIGRpc3BsYXllZCB3aGVuIGlucHV0IGlzIGNsaWNrZWQuLi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoJyN0cmFuc1NlbCcpLmZhZGVPdXQoMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYnlJZCgndHJhbnNMaXN0Jykuc3R5bGUuZGlzcGxheSAhPT0gJ25vbmUnKSB7IC8vIGlmIGZ1bmN0aW9uIGxpc3QgaXMgZGlzcGxheWVkIHdoZW4gaW5wdXQgaXMgY2xpY2tlZC4uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJCgnI3RyYW5zTGlzdCcpLmZhZGVPdXQoMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhpZ2hsaWdodCB0aGUgdGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLnNlbGVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcG9zID0gJCgnI3RJbnB1dCcpLm9mZnNldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MudG9wICs9ICQoJyN0SW5wdXQnKS53aWR0aCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAkKCcjdHJhbnNTZWwnKS5mYWRlSW4oMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAga2V5dXA6IGV2dCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0ID0gYnlJZCgndHJhbnNTZWwnKS5zdHlsZS5kaXNwbGF5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdDEgPSBieUlkKCd0cmFuc0xpc3QnKS5zdHlsZS5kaXNwbGF5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodCAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKCcjdHJhbnNTZWwnKS5mYWRlT3V0KDEwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodDEgIT09ICdub25lJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJCgnI3RyYW5zTGlzdCcpLmZhZGVPdXQoMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldnQua2V5Q29kZSA9PSAxMykgeyAvLyBrZXl1cCBvbiBFbnRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHQgPSB0cmFuc1BhcnNlKCQoJyN0SW5wdXQnKS52YWwoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm0odC5zbGljZSgwLCB0Lmxlbmd0aCAtIDEpLCB0W3QubGVuZ3RoIC0gMV0sIHR5cGVUcmFuc2Zvcm0gPSBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgIG0oJyN0cmFuc2Zvcm1hdGlvbnMudHJhbnNmb3JtVG9vbCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogYENvbnN0cnVjdCB0cmFuc2Zvcm1hdGlvbnMgb2YgZXhpc3RpbmcgdmFyaWFibGVzIHVzaW5nIHZhbGlkIFIgc3ludGF4LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRm9yIGV4YW1wbGUsIGFzc3VtaW5nIGEgdmFyaWFibGUgbmFtZWQgZCwgeW91IGNhbiBlbnRlciBcImxvZyhkKVwiIG9yIFwiZF4yXCIuYH0sXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybWF0aW9uKCd0cmFuc1NlbCcsIFsnYScsICdiJ10pLFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1hdGlvbigndHJhbnNMaXN0JywgYXBwLnRyYW5zZm9ybUxpc3QpKSkpLFxuICAgICAgICAgICAgICBtKGAjYWJvdXQucGFuZWwucGFuZWwtZGVmYXVsdFtzdHlsZT1kaXNwbGF5OiAke3RoaXMuYWJvdXQgPyAnYmxvY2snIDogJ25vbmUnfTsgbGVmdDogMTQwcHg7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgd2lkdGg6IDUwMHB4OyB6LWluZGV4OiA1MF1gLFxuICAgICAgICAgICAgICAgIG0oJy5wYW5lbC1ib2R5JyxcbiAgICAgICAgICAgICAgICAgICdUd29SYXZlbnMgdjAuMSBcIkRhbGxhc1wiIC0tIFRoZSBOb3JzZSBnb2QgT2RpbiBoYWQgdHdvIHRhbGtpbmcgcmF2ZW5zIGFzIGFkdmlzb3JzLCB3aG8gd291bGQgZmx5IG91dCBpbnRvIHRoZSB3b3JsZCBhbmQgcmVwb3J0IGJhY2sgYWxsIHRoZXkgb2JzZXJ2ZWQuIEluIHRoZSBOb3JzZSwgdGhlaXIgbmFtZXMgd2VyZSBcIlRob3VnaHRcIiBhbmQgXCJNZW1vcnlcIi4gSW4gb3VyIGNvbWluZyByZWxlYXNlLCBvdXIgdGhvdWdodC1yYXZlbiBhdXRvbWF0aWNhbGx5IGFkdmlzZXMgb24gc3RhdGlzdGljYWwgbW9kZWwgc2VsZWN0aW9uLCB3aGlsZSBvdXIgbWVtb3J5LXJhdmVuIGFjY3VtdWxhdGVzIHByZXZpb3VzIHN0YXRpc3RpY2FsIG1vZGVscyBmcm9tIERhdGF2ZXJzZSwgdG8gcHJvdmlkZSBjdW1tdWxhdGl2ZSBndWlkYW5jZSBhbmQgbWV0YS1hbmFseXNpcy4nKSkpLFxuICAgICAgICAgICAgbShgI21haW4ubGVmdC5jYXJvdXNlbC5zbGlkZS5zdmctbGVmdHBhbmVsLnN2Zy1yaWdodHBhbmVsW3N0eWxlPW92ZXJmbG93OiBoaWRkZW5dYCxcbiAgICAgICAgICAgICAgbShcIiNpbm5lcmNhcm91c2VsLmNhcm91c2VsLWlubmVyXCIsXG4gICAgICAgICAgICAgICAgbSgnI20wLml0ZW0uYWN0aXZlJyxcbiAgICAgICAgICAgICAgICAgIG0oJ3N2ZyN3aGl0ZXNwYWNlJykpKSxcbiAgICAgICAgICAgICAgbShcIiNzcGFjZXRvb2xzLnNwYWNlVG9vbFtzdHlsZT16LWluZGV4OiAxNl1cIixcbiAgICAgICAgICAgICAgICBzcGFjZUJ0bignYnRuTG9jay5hY3RpdmUnLCBhcHAubG9ja0Rlc2NyaXB0aW9uLCAnTG9jayBzZWxlY3Rpb24gb2YgcHJvYmxlbSBkZXNjcmlwdGlvbicsICdwZW5jaWwnKSxcbiAgICAgICAgICAgICAgICBzcGFjZUJ0bignYnRuSm9pbicsIF8gPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGlua3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4cGxvcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IG5vZGUgb2YgYXBwLm5vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgbm9kZTEgb2YgYXBwLm5vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlICE9PSBub2RlMSAmJiBsaW5rcy5maWx0ZXIobCA9PiBsLnRhcmdldCA9PT0gbm9kZTEgJiYgbC5zb3VyY2UgPT09IG5vZGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua3MucHVzaCh7bGVmdDogZmFsc2UsIHJpZ2h0OiBmYWxzZSwgdGFyZ2V0OiBub2RlLCBzb3VyY2U6IG5vZGUxfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZHZzID0gYXBwLm5vZGVzLmZpbHRlcihuID0+IGFwcC56cGFyYW1zLnpkdi5pbmNsdWRlcyhuLm5hbWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpdnMgPSBhcHAubm9kZXMuZmlsdGVyKG4gPT4gIWR2cy5pbmNsdWRlcyhuKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rcyA9IGR2cy5tYXAoZHYgPT4gaXZzLm1hcChpdiA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogaXYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBkdixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXBwLnJlc3RhcnQoW10uY29uY2F0KC4uLmxpbmtzKSk7XG4gICAgICAgICAgICAgICAgfSwgJ01ha2UgYWxsIHBvc3NpYmxlIGNvbm5lY3Rpb25zIGJldHdlZW4gbm9kZXMnLCAnbGluaycpLFxuICAgICAgICAgICAgICAgIHNwYWNlQnRuKCdidG5EaXNjb25uZWN0JywgXyA9PiBhcHAucmVzdGFydChbXSksICdEZWxldGUgYWxsIGNvbm5lY3Rpb25zIGJldHdlZW4gbm9kZXMnLCAncmVtb3ZlLWNpcmNsZScpLFxuICAgICAgICAgICAgICAgIHNwYWNlQnRuKCdidG5Gb3JjZScsIGFwcC5mb3JjZVN3aXRjaCwgJ1BpbiB0aGUgdmFyaWFibGUgcGViYmxlcyB0byB0aGUgcGFnZScsICdwdXNocGluJyksXG4gICAgICAgICAgICAgICAgc3BhY2VCdG4oJ2J0bkVyYXNlcicsIGFwcC5lcmFzZSwgJ1dpcGUgYWxsIHZhcmlhYmxlcyBmcm9tIHRoZSBtb2RlbGluZyBzcGFjZScsICdtYWduZXQnKSksXG4gICAgICAgICAgICAgIG0oU3VicGFuZWwsXG4gICAgICAgICAgICAgICAge3RpdGxlOiBcIkxlZ2VuZFwiLFxuICAgICAgICAgICAgICAgICBidXR0b25zOiBbXG4gICAgICAgICAgICAgICAgICAgICBbJ3RpbWVCdXR0b24nLCAnenRpbWUnLCAnVGltZSddLFxuICAgICAgICAgICAgICAgICAgICAgWydjc0J1dHRvbicsICd6Y3Jvc3MnLCAnQ3Jvc3MgU2VjJ10sXG4gICAgICAgICAgICAgICAgICAgICBbJ2R2QnV0dG9uJywgJ3pkdicsICdEZXAgVmFyJ10sXG4gICAgICAgICAgICAgICAgICAgICBbJ25vbUJ1dHRvbicsICd6bm9tJywgJ05vbSBWYXInXSxcbiAgICAgICAgICAgICAgICAgICAgIFsnZ3IxQnV0dG9uJywgJ3pncm91cDEnLCAnR3JvdXAgMSddLFxuICAgICAgICAgICAgICAgICAgICAgWydncjJCdXR0b24nLCAnemdyb3VwMicsICdHcm91cCAyJ11dfSksXG4gICAgICAgICAgICAgIG0oU3VicGFuZWwsIHt0aXRsZTogXCJIaXN0b3J5XCJ9KSxcbiAgICAgICAgICAgICAgdGlja2VyKG1vZGUpLFxuICAgICAgICAgICAgICBsZWZ0cGFuZWwoKSxcbiAgICAgICAgICAgICAgcmlnaHRwYW5lbChtb2RlKSkpO1xuICAgIH1cbn1cblxubS5yb3V0ZShkb2N1bWVudC5ib2R5LCAnL21vZGVsJywge1xuICAgICcvbW9kZWwnOiB7cmVuZGVyOiAoKSA9PiBtKEJvZHkpfSxcbiAgICAnL2V4cGxvcmUnOiB7cmVuZGVyOiAoKSA9PiBtKEJvZHksIHttb2RlOiAnZXhwbG9yZSd9KX0sXG4gICAgJy9yZXN1bHRzJzoge3JlbmRlcjogKCkgPT4gbShCb2R5LCB7bW9kZTogJ3Jlc3VsdHMnfSl9LFxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9hc3NldHMvYXBwL2luZGV4LmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///15\n")},function(module,exports){eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2Nlc3MvYnJvd3Nlci5qcz84MmU0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVUiLCJmaWxlIjoiMTYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Byb2Nlc3MvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///16\n")},function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    "use strict";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== "function") {\n        callback = new Function("" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."\n        // So if we\'re currently running a task, we\'ll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // "too much recursion" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can\'t be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage("", "*");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = "setImmediate$" + Math.random() + "$";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === "string" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener("message", onGlobalMessage, false);\n        } else {\n            global.attachEvent("onmessage", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, "*");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it\'s been called.\n            var script = doc.createElement("script");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don\'t get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === "[object process]") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && "onreadystatechange" in doc.createElement("script")) {\n        // For IE 68\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5), __webpack_require__(16)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanM/NGE4MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMsc0JBQXNCLEVBQUU7QUFDbEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiMTcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgdW5kZWZpbmVkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZiAoZ2xvYmFsLnNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5leHRIYW5kbGUgPSAxOyAvLyBTcGVjIHNheXMgZ3JlYXRlciB0aGFuIHplcm9cbiAgICB2YXIgdGFza3NCeUhhbmRsZSA9IHt9O1xuICAgIHZhciBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICB2YXIgZG9jID0gZ2xvYmFsLmRvY3VtZW50O1xuICAgIHZhciByZWdpc3RlckltbWVkaWF0ZTtcblxuICAgIGZ1bmN0aW9uIHNldEltbWVkaWF0ZShjYWxsYmFjaykge1xuICAgICAgLy8gQ2FsbGJhY2sgY2FuIGVpdGhlciBiZSBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBuZXcgRnVuY3Rpb24oXCJcIiArIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIC8vIENvcHkgZnVuY3Rpb24gYXJndW1lbnRzXG4gICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2kgKyAxXTtcbiAgICAgIH1cbiAgICAgIC8vIFN0b3JlIGFuZCByZWdpc3RlciB0aGUgdGFza1xuICAgICAgdmFyIHRhc2sgPSB7IGNhbGxiYWNrOiBjYWxsYmFjaywgYXJnczogYXJncyB9O1xuICAgICAgdGFza3NCeUhhbmRsZVtuZXh0SGFuZGxlXSA9IHRhc2s7XG4gICAgICByZWdpc3RlckltbWVkaWF0ZShuZXh0SGFuZGxlKTtcbiAgICAgIHJldHVybiBuZXh0SGFuZGxlKys7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaGFuZGxlKSB7XG4gICAgICAgIGRlbGV0ZSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuKHRhc2spIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gdGFzay5jYWxsYmFjaztcbiAgICAgICAgdmFyIGFyZ3MgPSB0YXNrLmFyZ3M7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuSWZQcmVzZW50KGhhbmRsZSkge1xuICAgICAgICAvLyBGcm9tIHRoZSBzcGVjOiBcIldhaXQgdW50aWwgYW55IGludm9jYXRpb25zIG9mIHRoaXMgYWxnb3JpdGhtIHN0YXJ0ZWQgYmVmb3JlIHRoaXMgb25lIGhhdmUgY29tcGxldGVkLlwiXG4gICAgICAgIC8vIFNvIGlmIHdlJ3JlIGN1cnJlbnRseSBydW5uaW5nIGEgdGFzaywgd2UnbGwgbmVlZCB0byBkZWxheSB0aGlzIGludm9jYXRpb24uXG4gICAgICAgIGlmIChjdXJyZW50bHlSdW5uaW5nQVRhc2spIHtcbiAgICAgICAgICAgIC8vIERlbGF5IGJ5IGRvaW5nIGEgc2V0VGltZW91dC4gc2V0SW1tZWRpYXRlIHdhcyB0cmllZCBpbnN0ZWFkLCBidXQgaW4gRmlyZWZveCA3IGl0IGdlbmVyYXRlZCBhXG4gICAgICAgICAgICAvLyBcInRvbyBtdWNoIHJlY3Vyc2lvblwiIGVycm9yLlxuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGFzayA9IHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICAgICAgICAgIGlmICh0YXNrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBydW4odGFzayk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbW1lZGlhdGUoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHsgcnVuSWZQcmVzZW50KGhhbmRsZSk7IH0pO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhblVzZVBvc3RNZXNzYWdlKCkge1xuICAgICAgICAvLyBUaGUgdGVzdCBhZ2FpbnN0IGBpbXBvcnRTY3JpcHRzYCBwcmV2ZW50cyB0aGlzIGltcGxlbWVudGF0aW9uIGZyb20gYmVpbmcgaW5zdGFsbGVkIGluc2lkZSBhIHdlYiB3b3JrZXIsXG4gICAgICAgIC8vIHdoZXJlIGBnbG9iYWwucG9zdE1lc3NhZ2VgIG1lYW5zIHNvbWV0aGluZyBjb21wbGV0ZWx5IGRpZmZlcmVudCBhbmQgY2FuJ3QgYmUgdXNlZCBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgICBpZiAoZ2xvYmFsLnBvc3RNZXNzYWdlICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cykge1xuICAgICAgICAgICAgdmFyIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG9sZE9uTWVzc2FnZSA9IGdsb2JhbC5vbm1lc3NhZ2U7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShcIlwiLCBcIipcIik7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gb2xkT25NZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgLy8gSW5zdGFsbHMgYW4gZXZlbnQgaGFuZGxlciBvbiBgZ2xvYmFsYCBmb3IgdGhlIGBtZXNzYWdlYCBldmVudDogc2VlXG4gICAgICAgIC8vICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vRE9NL3dpbmRvdy5wb3N0TWVzc2FnZVxuICAgICAgICAvLyAqIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL2NvbW1zLmh0bWwjY3Jvc3NEb2N1bWVudE1lc3NhZ2VzXG5cbiAgICAgICAgdmFyIG1lc3NhZ2VQcmVmaXggPSBcInNldEltbWVkaWF0ZSRcIiArIE1hdGgucmFuZG9tKCkgKyBcIiRcIjtcbiAgICAgICAgdmFyIG9uR2xvYmFsTWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlID09PSBnbG9iYWwgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZXZlbnQuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEuaW5kZXhPZihtZXNzYWdlUHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudCgrZXZlbnQuZGF0YS5zbGljZShtZXNzYWdlUHJlZml4Lmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFsLmF0dGFjaEV2ZW50KFwib25tZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKG1lc3NhZ2VQcmVmaXggKyBoYW5kbGUsIFwiKlwiKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZShoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBodG1sID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIDxzY3JpcHQ+IGVsZW1lbnQ7IGl0cyByZWFkeXN0YXRlY2hhbmdlIGV2ZW50IHdpbGwgYmUgZmlyZWQgYXN5bmNocm9ub3VzbHkgb25jZSBpdCBpcyBpbnNlcnRlZFxuICAgICAgICAgICAgLy8gaW50byB0aGUgZG9jdW1lbnQuIERvIHNvLCB0aHVzIHF1ZXVpbmcgdXAgdGhlIHRhc2suIFJlbWVtYmVyIHRvIGNsZWFuIHVwIG9uY2UgaXQncyBiZWVuIGNhbGxlZC5cbiAgICAgICAgICAgIHZhciBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaHRtbC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgICAgIHNjcmlwdCA9IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaHRtbC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBJZiBzdXBwb3J0ZWQsIHdlIHNob3VsZCBhdHRhY2ggdG8gdGhlIHByb3RvdHlwZSBvZiBnbG9iYWwsIHNpbmNlIHRoYXQgaXMgd2hlcmUgc2V0VGltZW91dCBldCBhbC4gbGl2ZS5cbiAgICB2YXIgYXR0YWNoVG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGdsb2JhbCk7XG4gICAgYXR0YWNoVG8gPSBhdHRhY2hUbyAmJiBhdHRhY2hUby5zZXRUaW1lb3V0ID8gYXR0YWNoVG8gOiBnbG9iYWw7XG5cbiAgICAvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IGUuZy4gYnJvd3NlcmlmeSBlbnZpcm9ubWVudHMuXG4gICAgaWYgKHt9LnRvU3RyaW5nLmNhbGwoZ2xvYmFsLnByb2Nlc3MpID09PSBcIltvYmplY3QgcHJvY2Vzc11cIikge1xuICAgICAgICAvLyBGb3IgTm9kZS5qcyBiZWZvcmUgMC45XG4gICAgICAgIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGNhblVzZVBvc3RNZXNzYWdlKCkpIHtcbiAgICAgICAgLy8gRm9yIG5vbi1JRTEwIG1vZGVybiBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChnbG9iYWwuTWVzc2FnZUNoYW5uZWwpIHtcbiAgICAgICAgLy8gRm9yIHdlYiB3b3JrZXJzLCB3aGVyZSBzdXBwb3J0ZWRcbiAgICAgICAgaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZG9jICYmIFwib25yZWFkeXN0YXRlY2hhbmdlXCIgaW4gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIikpIHtcbiAgICAgICAgLy8gRm9yIElFIDbigJM4XG4gICAgICAgIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBvbGRlciBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCk7XG4gICAgfVxuXG4gICAgYXR0YWNoVG8uc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlO1xuICAgIGF0dGFjaFRvLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG59KHR5cGVvZiBzZWxmID09PSBcInVuZGVmaW5lZFwiID8gdHlwZW9mIGdsb2JhbCA9PT0gXCJ1bmRlZmluZWRcIiA/IHRoaXMgOiBnbG9iYWwgOiBzZWxmKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///17\n')},function(module,exports,__webpack_require__){eval("var apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(17);\nexports.setImmediate = setImmediate;\nexports.clearImmediate = clearImmediate;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3RpbWVycy1icm93c2VyaWZ5L21haW4uanM/YjA4OCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjE4LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkge1xuICBpZiAodGltZW91dCkge1xuICAgIHRpbWVvdXQuY2xvc2UoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbCh3aW5kb3csIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBzZXRpbW1lZGlhdGUgYXR0YWNoZXMgaXRzZWxmIHRvIHRoZSBnbG9iYWwgb2JqZWN0XG5yZXF1aXJlKFwic2V0aW1tZWRpYXRlXCIpO1xuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qc1xuLy8gbW9kdWxlIGlkID0gMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///18\n")}]);