!function(Q){function I(B){if(F[B])return F[B].exports;var g=F[B]={i:B,l:!1,exports:{}};return Q[B].call(g.exports,g,g.exports,I),g.l=!0,g.exports}var F={};I.m=Q,I.c=F,I.i=function(Q){return Q},I.d=function(Q,F,B){I.o(Q,F)||Object.defineProperty(Q,F,{configurable:!1,enumerable:!0,get:B})},I.n=function(Q){var F=Q&&Q.__esModule?function(){return Q.default}:function(){return Q};return I.d(F,"a",F),F},I.o=function(Q,I){return Object.prototype.hasOwnProperty.call(Q,I)},I.p="",I(I.s=11)}([function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(setImmediate, global) {;(function() {\n"use strict"\nfunction Vnode(tag, key, attrs0, children, text, dom) {\n\treturn {tag: tag, key: key, attrs: attrs0, children: children, text: text, dom: dom, domSize: undefined, state: undefined, _state: undefined, events: undefined, instance: undefined, skip: false}\n}\nVnode.normalize = function(node) {\n\tif (Array.isArray(node)) return Vnode("[", undefined, undefined, Vnode.normalizeChildren(node), undefined, undefined)\n\tif (node != null && typeof node !== "object") return Vnode("#", undefined, undefined, node === false ? "" : node, undefined, undefined)\n\treturn node\n}\nVnode.normalizeChildren = function normalizeChildren(children) {\n\tfor (var i = 0; i < children.length; i++) {\n\t\tchildren[i] = Vnode.normalize(children[i])\n\t}\n\treturn children\n}\nvar selectorParser = /(?:(^|#|\\.)([^#\\.\\[\\]]+))|(\\[(.+?)(?:\\s*=\\s*("|\'|)((?:\\\\["\'\\]]|.)*?)\\5)?\\])/g\nvar selectorCache = {}\nvar hasOwn = {}.hasOwnProperty\nfunction compileSelector(selector) {\n\tvar match, tag = "div", classes = [], attrs = {}\n\twhile (match = selectorParser.exec(selector)) {\n\t\tvar type = match[1], value = match[2]\n\t\tif (type === "" && value !== "") tag = value\n\t\telse if (type === "#") attrs.id = value\n\t\telse if (type === ".") classes.push(value)\n\t\telse if (match[3][0] === "[") {\n\t\t\tvar attrValue = match[6]\n\t\t\tif (attrValue) attrValue = attrValue.replace(/\\\\(["\'])/g, "$1").replace(/\\\\\\\\/g, "\\\\")\n\t\t\tif (match[4] === "class") classes.push(attrValue)\n\t\t\telse attrs[match[4]] = attrValue === "" ? attrValue : attrValue || true\n\t\t}\n\t}\n\tif (classes.length > 0) attrs.className = classes.join(" ")\n\treturn selectorCache[selector] = {tag: tag, attrs: attrs}\n}\nfunction execSelector(state, attrs, children) {\n\tvar hasAttrs = false, childList, text\n\tvar className = attrs.className || attrs.class\n\tfor (var key in state.attrs) {\n\t\tif (hasOwn.call(state.attrs, key)) {\n\t\t\tattrs[key] = state.attrs[key]\n\t\t}\n\t}\n\tif (className !== undefined) {\n\t\tif (attrs.class !== undefined) {\n\t\t\tattrs.class = undefined\n\t\t\tattrs.className = className\n\t\t}\n\t\tif (state.attrs.className != null) {\n\t\t\tattrs.className = state.attrs.className + " " + className\n\t\t}\n\t}\n\tfor (var key in attrs) {\n\t\tif (hasOwn.call(attrs, key) && key !== "key") {\n\t\t\thasAttrs = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif (Array.isArray(children) && children.length === 1 && children[0] != null && children[0].tag === "#") {\n\t\ttext = children[0].children\n\t} else {\n\t\tchildList = children\n\t}\n\treturn Vnode(state.tag, attrs.key, hasAttrs ? attrs : undefined, childList, text)\n}\nfunction hyperscript(selector) {\n\t// Because sloppy mode sucks\n\tvar attrs = arguments[1], start = 2, children\n\tif (selector == null || typeof selector !== "string" && typeof selector !== "function" && typeof selector.view !== "function") {\n\t\tthrow Error("The selector must be either a string or a component.");\n\t}\n\tif (typeof selector === "string") {\n\t\tvar cached = selectorCache[selector] || compileSelector(selector)\n\t}\n\tif (attrs == null) {\n\t\tattrs = {}\n\t} else if (typeof attrs !== "object" || attrs.tag != null || Array.isArray(attrs)) {\n\t\tattrs = {}\n\t\tstart = 1\n\t}\n\tif (arguments.length === start + 1) {\n\t\tchildren = arguments[start]\n\t\tif (!Array.isArray(children)) children = [children]\n\t} else {\n\t\tchildren = []\n\t\twhile (start < arguments.length) children.push(arguments[start++])\n\t}\n\tvar normalized = Vnode.normalizeChildren(children)\n\tif (typeof selector === "string") {\n\t\treturn execSelector(cached, attrs, normalized)\n\t} else {\n\t\treturn Vnode(selector, attrs.key, attrs, normalized)\n\t}\n}\nhyperscript.trust = function(html) {\n\tif (html == null) html = ""\n\treturn Vnode("<", undefined, undefined, html, undefined, undefined)\n}\nhyperscript.fragment = function(attrs1, children) {\n\treturn Vnode("[", attrs1.key, attrs1, Vnode.normalizeChildren(children), undefined, undefined)\n}\nvar m = hyperscript\n/** @constructor */\nvar PromisePolyfill = function(executor) {\n\tif (!(this instanceof PromisePolyfill)) throw new Error("Promise must be called with `new`")\n\tif (typeof executor !== "function") throw new TypeError("executor must be a function")\n\tvar self = this, resolvers = [], rejectors = [], resolveCurrent = handler(resolvers, true), rejectCurrent = handler(rejectors, false)\n\tvar instance = self._instance = {resolvers: resolvers, rejectors: rejectors}\n\tvar callAsync = typeof setImmediate === "function" ? setImmediate : setTimeout\n\tfunction handler(list, shouldAbsorb) {\n\t\treturn function execute(value) {\n\t\t\tvar then\n\t\t\ttry {\n\t\t\t\tif (shouldAbsorb && value != null && (typeof value === "object" || typeof value === "function") && typeof (then = value.then) === "function") {\n\t\t\t\t\tif (value === self) throw new TypeError("Promise can\'t be resolved w/ itself")\n\t\t\t\t\texecuteOnce(then.bind(value))\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcallAsync(function() {\n\t\t\t\t\t\tif (!shouldAbsorb && list.length === 0) console.error("Possible unhandled promise rejection:", value)\n\t\t\t\t\t\tfor (var i = 0; i < list.length; i++) list[i](value)\n\t\t\t\t\t\tresolvers.length = 0, rejectors.length = 0\n\t\t\t\t\t\tinstance.state = shouldAbsorb\n\t\t\t\t\t\tinstance.retry = function() {execute(value)}\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (e) {\n\t\t\t\trejectCurrent(e)\n\t\t\t}\n\t\t}\n\t}\n\tfunction executeOnce(then) {\n\t\tvar runs = 0\n\t\tfunction run(fn) {\n\t\t\treturn function(value) {\n\t\t\t\tif (runs++ > 0) return\n\t\t\t\tfn(value)\n\t\t\t}\n\t\t}\n\t\tvar onerror = run(rejectCurrent)\n\t\ttry {then(run(resolveCurrent), onerror)} catch (e) {onerror(e)}\n\t}\n\texecuteOnce(executor)\n}\nPromisePolyfill.prototype.then = function(onFulfilled, onRejection) {\n\tvar self = this, instance = self._instance\n\tfunction handle(callback, list, next, state) {\n\t\tlist.push(function(value) {\n\t\t\tif (typeof callback !== "function") next(value)\n\t\t\telse try {resolveNext(callback(value))} catch (e) {if (rejectNext) rejectNext(e)}\n\t\t})\n\t\tif (typeof instance.retry === "function" && state === instance.state) instance.retry()\n\t}\n\tvar resolveNext, rejectNext\n\tvar promise = new PromisePolyfill(function(resolve, reject) {resolveNext = resolve, rejectNext = reject})\n\thandle(onFulfilled, instance.resolvers, resolveNext, true), handle(onRejection, instance.rejectors, rejectNext, false)\n\treturn promise\n}\nPromisePolyfill.prototype.catch = function(onRejection) {\n\treturn this.then(null, onRejection)\n}\nPromisePolyfill.resolve = function(value) {\n\tif (value instanceof PromisePolyfill) return value\n\treturn new PromisePolyfill(function(resolve) {resolve(value)})\n}\nPromisePolyfill.reject = function(value) {\n\treturn new PromisePolyfill(function(resolve, reject) {reject(value)})\n}\nPromisePolyfill.all = function(list) {\n\treturn new PromisePolyfill(function(resolve, reject) {\n\t\tvar total = list.length, count = 0, values = []\n\t\tif (list.length === 0) resolve([])\n\t\telse for (var i = 0; i < list.length; i++) {\n\t\t\t(function(i) {\n\t\t\t\tfunction consume(value) {\n\t\t\t\t\tcount++\n\t\t\t\t\tvalues[i] = value\n\t\t\t\t\tif (count === total) resolve(values)\n\t\t\t\t}\n\t\t\t\tif (list[i] != null && (typeof list[i] === "object" || typeof list[i] === "function") && typeof list[i].then === "function") {\n\t\t\t\t\tlist[i].then(consume, reject)\n\t\t\t\t}\n\t\t\t\telse consume(list[i])\n\t\t\t})(i)\n\t\t}\n\t})\n}\nPromisePolyfill.race = function(list) {\n\treturn new PromisePolyfill(function(resolve, reject) {\n\t\tfor (var i = 0; i < list.length; i++) {\n\t\t\tlist[i].then(resolve, reject)\n\t\t}\n\t})\n}\nif (typeof window !== "undefined") {\n\tif (typeof window.Promise === "undefined") window.Promise = PromisePolyfill\n\tvar PromisePolyfill = window.Promise\n} else if (typeof global !== "undefined") {\n\tif (typeof global.Promise === "undefined") global.Promise = PromisePolyfill\n\tvar PromisePolyfill = global.Promise\n} else {\n}\nvar buildQueryString = function(object) {\n\tif (Object.prototype.toString.call(object) !== "[object Object]") return ""\n\tvar args = []\n\tfor (var key0 in object) {\n\t\tdestructure(key0, object[key0])\n\t}\n\treturn args.join("&")\n\tfunction destructure(key0, value) {\n\t\tif (Array.isArray(value)) {\n\t\t\tfor (var i = 0; i < value.length; i++) {\n\t\t\t\tdestructure(key0 + "[" + i + "]", value[i])\n\t\t\t}\n\t\t}\n\t\telse if (Object.prototype.toString.call(value) === "[object Object]") {\n\t\t\tfor (var i in value) {\n\t\t\t\tdestructure(key0 + "[" + i + "]", value[i])\n\t\t\t}\n\t\t}\n\t\telse args.push(encodeURIComponent(key0) + (value != null && value !== "" ? "=" + encodeURIComponent(value) : ""))\n\t}\n}\nvar FILE_PROTOCOL_REGEX = new RegExp("^file://", "i")\nvar _8 = function($window, Promise) {\n\tvar callbackCount = 0\n\tvar oncompletion\n\tfunction setCompletionCallback(callback) {oncompletion = callback}\n\tfunction finalizer() {\n\t\tvar count = 0\n\t\tfunction complete() {if (--count === 0 && typeof oncompletion === "function") oncompletion()}\n\t\treturn function finalize(promise0) {\n\t\t\tvar then0 = promise0.then\n\t\t\tpromise0.then = function() {\n\t\t\t\tcount++\n\t\t\t\tvar next = then0.apply(promise0, arguments)\n\t\t\t\tnext.then(complete, function(e) {\n\t\t\t\t\tcomplete()\n\t\t\t\t\tif (count === 0) throw e\n\t\t\t\t})\n\t\t\t\treturn finalize(next)\n\t\t\t}\n\t\t\treturn promise0\n\t\t}\n\t}\n\tfunction normalize(args, extra) {\n\t\tif (typeof args === "string") {\n\t\t\tvar url = args\n\t\t\targs = extra || {}\n\t\t\tif (args.url == null) args.url = url\n\t\t}\n\t\treturn args\n\t}\n\tfunction request(args, extra) {\n\t\tvar finalize = finalizer()\n\t\targs = normalize(args, extra)\n\t\tvar promise0 = new Promise(function(resolve, reject) {\n\t\t\tif (args.method == null) args.method = "GET"\n\t\t\targs.method = args.method.toUpperCase()\n\t\t\tvar useBody = (args.method === "GET" || args.method === "TRACE") ? false : (typeof args.useBody === "boolean" ? args.useBody : true)\n\t\t\tif (typeof args.serialize !== "function") args.serialize = typeof FormData !== "undefined" && args.data instanceof FormData ? function(value) {return value} : JSON.stringify\n\t\t\tif (typeof args.deserialize !== "function") args.deserialize = deserialize\n\t\t\tif (typeof args.extract !== "function") args.extract = extract\n\t\t\targs.url = interpolate(args.url, args.data)\n\t\t\tif (useBody) args.data = args.serialize(args.data)\n\t\t\telse args.url = assemble(args.url, args.data)\n\t\t\tvar xhr = new $window.XMLHttpRequest(),\n\t\t\t\taborted = false,\n\t\t\t\t_abort = xhr.abort\n\t\t\txhr.abort = function abort() {\n\t\t\t\taborted = true\n\t\t\t\t_abort.call(xhr)\n\t\t\t}\n\t\t\txhr.open(args.method, args.url, typeof args.async === "boolean" ? args.async : true, typeof args.user === "string" ? args.user : undefined, typeof args.password === "string" ? args.password : undefined)\n\t\t\tif (args.serialize === JSON.stringify && useBody) {\n\t\t\t\txhr.setRequestHeader("Content-Type", "application/json; charset=utf-8")\n\t\t\t}\n\t\t\tif (args.deserialize === deserialize) {\n\t\t\t\txhr.setRequestHeader("Accept", "application/json, text/*")\n\t\t\t}\n\t\t\tif (args.withCredentials) xhr.withCredentials = args.withCredentials\n\t\t\tfor (var key in args.headers) if ({}.hasOwnProperty.call(args.headers, key)) {\n\t\t\t\txhr.setRequestHeader(key, args.headers[key])\n\t\t\t}\n\t\t\tif (typeof args.config === "function") xhr = args.config(xhr, args) || xhr\n\t\t\txhr.onreadystatechange = function() {\n\t\t\t\t// Don\'t throw errors on xhr.abort().\n\t\t\t\tif(aborted) return\n\t\t\t\tif (xhr.readyState === 4) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvar response = (args.extract !== extract) ? args.extract(xhr, args) : args.deserialize(args.extract(xhr, args))\n\t\t\t\t\t\tif ((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304 || FILE_PROTOCOL_REGEX.test(args.url)) {\n\t\t\t\t\t\t\tresolve(cast(args.type, response))\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tvar error = new Error(xhr.responseText)\n\t\t\t\t\t\t\tfor (var key in response) error[key] = response[key]\n\t\t\t\t\t\t\treject(error)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (e) {\n\t\t\t\t\t\treject(e)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (useBody && (args.data != null)) xhr.send(args.data)\n\t\t\telse xhr.send()\n\t\t})\n\t\treturn args.background === true ? promise0 : finalize(promise0)\n\t}\n\tfunction jsonp(args, extra) {\n\t\tvar finalize = finalizer()\n\t\targs = normalize(args, extra)\n\t\tvar promise0 = new Promise(function(resolve, reject) {\n\t\t\tvar callbackName = args.callbackName || "_mithril_" + Math.round(Math.random() * 1e16) + "_" + callbackCount++\n\t\t\tvar script = $window.document.createElement("script")\n\t\t\t$window[callbackName] = function(data) {\n\t\t\t\tscript.parentNode.removeChild(script)\n\t\t\t\tresolve(cast(args.type, data))\n\t\t\t\tdelete $window[callbackName]\n\t\t\t}\n\t\t\tscript.onerror = function() {\n\t\t\t\tscript.parentNode.removeChild(script)\n\t\t\t\treject(new Error("JSONP request failed"))\n\t\t\t\tdelete $window[callbackName]\n\t\t\t}\n\t\t\tif (args.data == null) args.data = {}\n\t\t\targs.url = interpolate(args.url, args.data)\n\t\t\targs.data[args.callbackKey || "callback"] = callbackName\n\t\t\tscript.src = assemble(args.url, args.data)\n\t\t\t$window.document.documentElement.appendChild(script)\n\t\t})\n\t\treturn args.background === true? promise0 : finalize(promise0)\n\t}\n\tfunction interpolate(url, data) {\n\t\tif (data == null) return url\n\t\tvar tokens = url.match(/:[^\\/]+/gi) || []\n\t\tfor (var i = 0; i < tokens.length; i++) {\n\t\t\tvar key = tokens[i].slice(1)\n\t\t\tif (data[key] != null) {\n\t\t\t\turl = url.replace(tokens[i], data[key])\n\t\t\t}\n\t\t}\n\t\treturn url\n\t}\n\tfunction assemble(url, data) {\n\t\tvar querystring = buildQueryString(data)\n\t\tif (querystring !== "") {\n\t\t\tvar prefix = url.indexOf("?") < 0 ? "?" : "&"\n\t\t\turl += prefix + querystring\n\t\t}\n\t\treturn url\n\t}\n\tfunction deserialize(data) {\n\t\ttry {return data !== "" ? JSON.parse(data) : null}\n\t\tcatch (e) {throw new Error(data)}\n\t}\n\tfunction extract(xhr) {return xhr.responseText}\n\tfunction cast(type0, data) {\n\t\tif (typeof type0 === "function") {\n\t\t\tif (Array.isArray(data)) {\n\t\t\t\tfor (var i = 0; i < data.length; i++) {\n\t\t\t\t\tdata[i] = new type0(data[i])\n\t\t\t\t}\n\t\t\t}\n\t\t\telse return new type0(data)\n\t\t}\n\t\treturn data\n\t}\n\treturn {request: request, jsonp: jsonp, setCompletionCallback: setCompletionCallback}\n}\nvar requestService = _8(window, PromisePolyfill)\nvar coreRenderer = function($window) {\n\tvar $doc = $window.document\n\tvar $emptyFragment = $doc.createDocumentFragment()\n\tvar nameSpace = {\n\t\tsvg: "http://www.w3.org/2000/svg",\n\t\tmath: "http://www.w3.org/1998/Math/MathML"\n\t}\n\tvar onevent\n\tfunction setEventCallback(callback) {return onevent = callback}\n\tfunction getNameSpace(vnode) {\n\t\treturn vnode.attrs && vnode.attrs.xmlns || nameSpace[vnode.tag]\n\t}\n\t//create\n\tfunction createNodes(parent, vnodes, start, end, hooks, nextSibling, ns) {\n\t\tfor (var i = start; i < end; i++) {\n\t\t\tvar vnode = vnodes[i]\n\t\t\tif (vnode != null) {\n\t\t\t\tcreateNode(parent, vnode, hooks, ns, nextSibling)\n\t\t\t}\n\t\t}\n\t}\n\tfunction createNode(parent, vnode, hooks, ns, nextSibling) {\n\t\tvar tag = vnode.tag\n\t\tif (typeof tag === "string") {\n\t\t\tvnode.state = {}\n\t\t\tif (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks)\n\t\t\tswitch (tag) {\n\t\t\t\tcase "#": return createText(parent, vnode, nextSibling)\n\t\t\t\tcase "<": return createHTML(parent, vnode, nextSibling)\n\t\t\t\tcase "[": return createFragment(parent, vnode, hooks, ns, nextSibling)\n\t\t\t\tdefault: return createElement(parent, vnode, hooks, ns, nextSibling)\n\t\t\t}\n\t\t}\n\t\telse return createComponent(parent, vnode, hooks, ns, nextSibling)\n\t}\n\tfunction createText(parent, vnode, nextSibling) {\n\t\tvnode.dom = $doc.createTextNode(vnode.children)\n\t\tinsertNode(parent, vnode.dom, nextSibling)\n\t\treturn vnode.dom\n\t}\n\tfunction createHTML(parent, vnode, nextSibling) {\n\t\tvar match1 = vnode.children.match(/^\\s*?<(\\w+)/im) || []\n\t\tvar parent1 = {caption: "table", thead: "table", tbody: "table", tfoot: "table", tr: "tbody", th: "tr", td: "tr", colgroup: "table", col: "colgroup"}[match1[1]] || "div"\n\t\tvar temp = $doc.createElement(parent1)\n\t\ttemp.innerHTML = vnode.children\n\t\tvnode.dom = temp.firstChild\n\t\tvnode.domSize = temp.childNodes.length\n\t\tvar fragment = $doc.createDocumentFragment()\n\t\tvar child\n\t\twhile (child = temp.firstChild) {\n\t\t\tfragment.appendChild(child)\n\t\t}\n\t\tinsertNode(parent, fragment, nextSibling)\n\t\treturn fragment\n\t}\n\tfunction createFragment(parent, vnode, hooks, ns, nextSibling) {\n\t\tvar fragment = $doc.createDocumentFragment()\n\t\tif (vnode.children != null) {\n\t\t\tvar children = vnode.children\n\t\t\tcreateNodes(fragment, children, 0, children.length, hooks, null, ns)\n\t\t}\n\t\tvnode.dom = fragment.firstChild\n\t\tvnode.domSize = fragment.childNodes.length\n\t\tinsertNode(parent, fragment, nextSibling)\n\t\treturn fragment\n\t}\n\tfunction createElement(parent, vnode, hooks, ns, nextSibling) {\n\t\tvar tag = vnode.tag\n\t\tvar attrs2 = vnode.attrs\n\t\tvar is = attrs2 && attrs2.is\n\t\tns = getNameSpace(vnode) || ns\n\t\tvar element = ns ?\n\t\t\tis ? $doc.createElementNS(ns, tag, {is: is}) : $doc.createElementNS(ns, tag) :\n\t\t\tis ? $doc.createElement(tag, {is: is}) : $doc.createElement(tag)\n\t\tvnode.dom = element\n\t\tif (attrs2 != null) {\n\t\t\tsetAttrs(vnode, attrs2, ns)\n\t\t}\n\t\tinsertNode(parent, element, nextSibling)\n\t\tif (vnode.attrs != null && vnode.attrs.contenteditable != null) {\n\t\t\tsetContentEditable(vnode)\n\t\t}\n\t\telse {\n\t\t\tif (vnode.text != null) {\n\t\t\t\tif (vnode.text !== "") element.textContent = vnode.text\n\t\t\t\telse vnode.children = [Vnode("#", undefined, undefined, vnode.text, undefined, undefined)]\n\t\t\t}\n\t\t\tif (vnode.children != null) {\n\t\t\t\tvar children = vnode.children\n\t\t\t\tcreateNodes(element, children, 0, children.length, hooks, null, ns)\n\t\t\t\tsetLateAttrs(vnode)\n\t\t\t}\n\t\t}\n\t\treturn element\n\t}\n\tfunction initComponent(vnode, hooks) {\n\t\tvar sentinel\n\t\tif (typeof vnode.tag.view === "function") {\n\t\t\tvnode.state = Object.create(vnode.tag)\n\t\t\tsentinel = vnode.state.view\n\t\t\tif (sentinel.$$reentrantLock$$ != null) return $emptyFragment\n\t\t\tsentinel.$$reentrantLock$$ = true\n\t\t} else {\n\t\t\tvnode.state = void 0\n\t\t\tsentinel = vnode.tag\n\t\t\tif (sentinel.$$reentrantLock$$ != null) return $emptyFragment\n\t\t\tsentinel.$$reentrantLock$$ = true\n\t\t\tvnode.state = (vnode.tag.prototype != null && typeof vnode.tag.prototype.view === "function") ? new vnode.tag(vnode) : vnode.tag(vnode)\n\t\t}\n\t\tvnode._state = vnode.state\n\t\tif (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks)\n\t\tinitLifecycle(vnode._state, vnode, hooks)\n\t\tvnode.instance = Vnode.normalize(vnode._state.view.call(vnode.state, vnode))\n\t\tif (vnode.instance === vnode) throw Error("A view cannot return the vnode it received as argument")\n\t\tsentinel.$$reentrantLock$$ = null\n\t}\n\tfunction createComponent(parent, vnode, hooks, ns, nextSibling) {\n\t\tinitComponent(vnode, hooks)\n\t\tif (vnode.instance != null) {\n\t\t\tvar element = createNode(parent, vnode.instance, hooks, ns, nextSibling)\n\t\t\tvnode.dom = vnode.instance.dom\n\t\t\tvnode.domSize = vnode.dom != null ? vnode.instance.domSize : 0\n\t\t\tinsertNode(parent, element, nextSibling)\n\t\t\treturn element\n\t\t}\n\t\telse {\n\t\t\tvnode.domSize = 0\n\t\t\treturn $emptyFragment\n\t\t}\n\t}\n\t//update\n\tfunction updateNodes(parent, old, vnodes, recycling, hooks, nextSibling, ns) {\n\t\tif (old === vnodes || old == null && vnodes == null) return\n\t\telse if (old == null) createNodes(parent, vnodes, 0, vnodes.length, hooks, nextSibling, ns)\n\t\telse if (vnodes == null) removeNodes(old, 0, old.length, vnodes)\n\t\telse {\n\t\t\tif (old.length === vnodes.length) {\n\t\t\t\tvar isUnkeyed = false\n\t\t\t\tfor (var i = 0; i < vnodes.length; i++) {\n\t\t\t\t\tif (vnodes[i] != null && old[i] != null) {\n\t\t\t\t\t\tisUnkeyed = vnodes[i].key == null && old[i].key == null\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (isUnkeyed) {\n\t\t\t\t\tfor (var i = 0; i < old.length; i++) {\n\t\t\t\t\t\tif (old[i] === vnodes[i]) continue\n\t\t\t\t\t\telse if (old[i] == null && vnodes[i] != null) createNode(parent, vnodes[i], hooks, ns, getNextSibling(old, i + 1, nextSibling))\n\t\t\t\t\t\telse if (vnodes[i] == null) removeNodes(old, i, i + 1, vnodes)\n\t\t\t\t\t\telse updateNode(parent, old[i], vnodes[i], hooks, getNextSibling(old, i + 1, nextSibling), recycling, ns)\n\t\t\t\t\t}\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\trecycling = recycling || isRecyclable(old, vnodes)\n\t\t\tif (recycling) {\n\t\t\t\tvar pool = old.pool\n\t\t\t\told = old.concat(old.pool)\n\t\t\t}\n\t\t\tvar oldStart = 0, start = 0, oldEnd = old.length - 1, end = vnodes.length - 1, map\n\t\t\twhile (oldEnd >= oldStart && end >= start) {\n\t\t\t\tvar o = old[oldStart], v = vnodes[start]\n\t\t\t\tif (o === v && !recycling) oldStart++, start++\n\t\t\t\telse if (o == null) oldStart++\n\t\t\t\telse if (v == null) start++\n\t\t\t\telse if (o.key === v.key) {\n\t\t\t\t\tvar shouldRecycle = (pool != null && oldStart >= old.length - pool.length) || ((pool == null) && recycling)\n\t\t\t\t\toldStart++, start++\n\t\t\t\t\tupdateNode(parent, o, v, hooks, getNextSibling(old, oldStart, nextSibling), shouldRecycle, ns)\n\t\t\t\t\tif (recycling && o.tag === v.tag) insertNode(parent, toFragment(o), nextSibling)\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tvar o = old[oldEnd]\n\t\t\t\t\tif (o === v && !recycling) oldEnd--, start++\n\t\t\t\t\telse if (o == null) oldEnd--\n\t\t\t\t\telse if (v == null) start++\n\t\t\t\t\telse if (o.key === v.key) {\n\t\t\t\t\t\tvar shouldRecycle = (pool != null && oldEnd >= old.length - pool.length) || ((pool == null) && recycling)\n\t\t\t\t\t\tupdateNode(parent, o, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), shouldRecycle, ns)\n\t\t\t\t\t\tif (recycling || start < end) insertNode(parent, toFragment(o), getNextSibling(old, oldStart, nextSibling))\n\t\t\t\t\t\toldEnd--, start++\n\t\t\t\t\t}\n\t\t\t\t\telse break\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (oldEnd >= oldStart && end >= start) {\n\t\t\t\tvar o = old[oldEnd], v = vnodes[end]\n\t\t\t\tif (o === v && !recycling) oldEnd--, end--\n\t\t\t\telse if (o == null) oldEnd--\n\t\t\t\telse if (v == null) end--\n\t\t\t\telse if (o.key === v.key) {\n\t\t\t\t\tvar shouldRecycle = (pool != null && oldEnd >= old.length - pool.length) || ((pool == null) && recycling)\n\t\t\t\t\tupdateNode(parent, o, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), shouldRecycle, ns)\n\t\t\t\t\tif (recycling && o.tag === v.tag) insertNode(parent, toFragment(o), nextSibling)\n\t\t\t\t\tif (o.dom != null) nextSibling = o.dom\n\t\t\t\t\toldEnd--, end--\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (!map) map = getKeyMap(old, oldEnd)\n\t\t\t\t\tif (v != null) {\n\t\t\t\t\t\tvar oldIndex = map[v.key]\n\t\t\t\t\t\tif (oldIndex != null) {\n\t\t\t\t\t\t\tvar movable = old[oldIndex]\n\t\t\t\t\t\t\tvar shouldRecycle = (pool != null && oldIndex >= old.length - pool.length) || ((pool == null) && recycling)\n\t\t\t\t\t\t\tupdateNode(parent, movable, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), recycling, ns)\n\t\t\t\t\t\t\tinsertNode(parent, toFragment(movable), nextSibling)\n\t\t\t\t\t\t\told[oldIndex].skip = true\n\t\t\t\t\t\t\tif (movable.dom != null) nextSibling = movable.dom\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tvar dom = createNode(parent, v, hooks, ns, nextSibling)\n\t\t\t\t\t\t\tnextSibling = dom\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tend--\n\t\t\t\t}\n\t\t\t\tif (end < start) break\n\t\t\t}\n\t\t\tcreateNodes(parent, vnodes, start, end + 1, hooks, nextSibling, ns)\n\t\t\tremoveNodes(old, oldStart, oldEnd + 1, vnodes)\n\t\t}\n\t}\n\tfunction updateNode(parent, old, vnode, hooks, nextSibling, recycling, ns) {\n\t\tvar oldTag = old.tag, tag = vnode.tag\n\t\tif (oldTag === tag) {\n\t\t\tvnode.state = old.state\n\t\t\tvnode._state = old._state\n\t\t\tvnode.events = old.events\n\t\t\tif (!recycling && shouldNotUpdate(vnode, old)) return\n\t\t\tif (typeof oldTag === "string") {\n\t\t\t\tif (vnode.attrs != null) {\n\t\t\t\t\tif (recycling) {\n\t\t\t\t\t\tvnode.state = {}\n\t\t\t\t\t\tinitLifecycle(vnode.attrs, vnode, hooks)\n\t\t\t\t\t}\n\t\t\t\t\telse updateLifecycle(vnode.attrs, vnode, hooks)\n\t\t\t\t}\n\t\t\t\tswitch (oldTag) {\n\t\t\t\t\tcase "#": updateText(old, vnode); break\n\t\t\t\t\tcase "<": updateHTML(parent, old, vnode, nextSibling); break\n\t\t\t\t\tcase "[": updateFragment(parent, old, vnode, recycling, hooks, nextSibling, ns); break\n\t\t\t\t\tdefault: updateElement(old, vnode, recycling, hooks, ns)\n\t\t\t\t}\n\t\t\t}\n\t\t\telse updateComponent(parent, old, vnode, hooks, nextSibling, recycling, ns)\n\t\t}\n\t\telse {\n\t\t\tremoveNode(old, null)\n\t\t\tcreateNode(parent, vnode, hooks, ns, nextSibling)\n\t\t}\n\t}\n\tfunction updateText(old, vnode) {\n\t\tif (old.children.toString() !== vnode.children.toString()) {\n\t\t\told.dom.nodeValue = vnode.children\n\t\t}\n\t\tvnode.dom = old.dom\n\t}\n\tfunction updateHTML(parent, old, vnode, nextSibling) {\n\t\tif (old.children !== vnode.children) {\n\t\t\ttoFragment(old)\n\t\t\tcreateHTML(parent, vnode, nextSibling)\n\t\t}\n\t\telse vnode.dom = old.dom, vnode.domSize = old.domSize\n\t}\n\tfunction updateFragment(parent, old, vnode, recycling, hooks, nextSibling, ns) {\n\t\tupdateNodes(parent, old.children, vnode.children, recycling, hooks, nextSibling, ns)\n\t\tvar domSize = 0, children = vnode.children\n\t\tvnode.dom = null\n\t\tif (children != null) {\n\t\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\t\tvar child = children[i]\n\t\t\t\tif (child != null && child.dom != null) {\n\t\t\t\t\tif (vnode.dom == null) vnode.dom = child.dom\n\t\t\t\t\tdomSize += child.domSize || 1\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (domSize !== 1) vnode.domSize = domSize\n\t\t}\n\t}\n\tfunction updateElement(old, vnode, recycling, hooks, ns) {\n\t\tvar element = vnode.dom = old.dom\n\t\tns = getNameSpace(vnode) || ns\n\t\tif (vnode.tag === "textarea") {\n\t\t\tif (vnode.attrs == null) vnode.attrs = {}\n\t\t\tif (vnode.text != null) {\n\t\t\t\tvnode.attrs.value = vnode.text //FIXME handle0 multiple children\n\t\t\t\tvnode.text = undefined\n\t\t\t}\n\t\t}\n\t\tupdateAttrs(vnode, old.attrs, vnode.attrs, ns)\n\t\tif (vnode.attrs != null && vnode.attrs.contenteditable != null) {\n\t\t\tsetContentEditable(vnode)\n\t\t}\n\t\telse if (old.text != null && vnode.text != null && vnode.text !== "") {\n\t\t\tif (old.text.toString() !== vnode.text.toString()) old.dom.firstChild.nodeValue = vnode.text\n\t\t}\n\t\telse {\n\t\t\tif (old.text != null) old.children = [Vnode("#", undefined, undefined, old.text, undefined, old.dom.firstChild)]\n\t\t\tif (vnode.text != null) vnode.children = [Vnode("#", undefined, undefined, vnode.text, undefined, undefined)]\n\t\t\tupdateNodes(element, old.children, vnode.children, recycling, hooks, null, ns)\n\t\t}\n\t}\n\tfunction updateComponent(parent, old, vnode, hooks, nextSibling, recycling, ns) {\n\t\tif (recycling) {\n\t\t\tinitComponent(vnode, hooks)\n\t\t} else {\n\t\t\tvnode.instance = Vnode.normalize(vnode._state.view.call(vnode.state, vnode))\n\t\t\tif (vnode.instance === vnode) throw Error("A view cannot return the vnode it received as argument")\n\t\t\tif (vnode.attrs != null) updateLifecycle(vnode.attrs, vnode, hooks)\n\t\t\tupdateLifecycle(vnode._state, vnode, hooks)\n\t\t}\n\t\tif (vnode.instance != null) {\n\t\t\tif (old.instance == null) createNode(parent, vnode.instance, hooks, ns, nextSibling)\n\t\t\telse updateNode(parent, old.instance, vnode.instance, hooks, nextSibling, recycling, ns)\n\t\t\tvnode.dom = vnode.instance.dom\n\t\t\tvnode.domSize = vnode.instance.domSize\n\t\t}\n\t\telse if (old.instance != null) {\n\t\t\tremoveNode(old.instance, null)\n\t\t\tvnode.dom = undefined\n\t\t\tvnode.domSize = 0\n\t\t}\n\t\telse {\n\t\t\tvnode.dom = old.dom\n\t\t\tvnode.domSize = old.domSize\n\t\t}\n\t}\n\tfunction isRecyclable(old, vnodes) {\n\t\tif (old.pool != null && Math.abs(old.pool.length - vnodes.length) <= Math.abs(old.length - vnodes.length)) {\n\t\t\tvar oldChildrenLength = old[0] && old[0].children && old[0].children.length || 0\n\t\t\tvar poolChildrenLength = old.pool[0] && old.pool[0].children && old.pool[0].children.length || 0\n\t\t\tvar vnodesChildrenLength = vnodes[0] && vnodes[0].children && vnodes[0].children.length || 0\n\t\t\tif (Math.abs(poolChildrenLength - vnodesChildrenLength) <= Math.abs(oldChildrenLength - vnodesChildrenLength)) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\tfunction getKeyMap(vnodes, end) {\n\t\tvar map = {}, i = 0\n\t\tfor (var i = 0; i < end; i++) {\n\t\t\tvar vnode = vnodes[i]\n\t\t\tif (vnode != null) {\n\t\t\t\tvar key2 = vnode.key\n\t\t\t\tif (key2 != null) map[key2] = i\n\t\t\t}\n\t\t}\n\t\treturn map\n\t}\n\tfunction toFragment(vnode) {\n\t\tvar count0 = vnode.domSize\n\t\tif (count0 != null || vnode.dom == null) {\n\t\t\tvar fragment = $doc.createDocumentFragment()\n\t\t\tif (count0 > 0) {\n\t\t\t\tvar dom = vnode.dom\n\t\t\t\twhile (--count0) fragment.appendChild(dom.nextSibling)\n\t\t\t\tfragment.insertBefore(dom, fragment.firstChild)\n\t\t\t}\n\t\t\treturn fragment\n\t\t}\n\t\telse return vnode.dom\n\t}\n\tfunction getNextSibling(vnodes, i, nextSibling) {\n\t\tfor (; i < vnodes.length; i++) {\n\t\t\tif (vnodes[i] != null && vnodes[i].dom != null) return vnodes[i].dom\n\t\t}\n\t\treturn nextSibling\n\t}\n\tfunction insertNode(parent, dom, nextSibling) {\n\t\tif (nextSibling && nextSibling.parentNode) parent.insertBefore(dom, nextSibling)\n\t\telse parent.appendChild(dom)\n\t}\n\tfunction setContentEditable(vnode) {\n\t\tvar children = vnode.children\n\t\tif (children != null && children.length === 1 && children[0].tag === "<") {\n\t\t\tvar content = children[0].children\n\t\t\tif (vnode.dom.innerHTML !== content) vnode.dom.innerHTML = content\n\t\t}\n\t\telse if (vnode.text != null || children != null && children.length !== 0) throw new Error("Child node of a contenteditable must be trusted")\n\t}\n\t//remove\n\tfunction removeNodes(vnodes, start, end, context) {\n\t\tfor (var i = start; i < end; i++) {\n\t\t\tvar vnode = vnodes[i]\n\t\t\tif (vnode != null) {\n\t\t\t\tif (vnode.skip) vnode.skip = false\n\t\t\t\telse removeNode(vnode, context)\n\t\t\t}\n\t\t}\n\t}\n\tfunction removeNode(vnode, context) {\n\t\tvar expected = 1, called = 0\n\t\tif (vnode.attrs && typeof vnode.attrs.onbeforeremove === "function") {\n\t\t\tvar result = vnode.attrs.onbeforeremove.call(vnode.state, vnode)\n\t\t\tif (result != null && typeof result.then === "function") {\n\t\t\t\texpected++\n\t\t\t\tresult.then(continuation, continuation)\n\t\t\t}\n\t\t}\n\t\tif (typeof vnode.tag !== "string" && typeof vnode._state.onbeforeremove === "function") {\n\t\t\tvar result = vnode._state.onbeforeremove.call(vnode.state, vnode)\n\t\t\tif (result != null && typeof result.then === "function") {\n\t\t\t\texpected++\n\t\t\t\tresult.then(continuation, continuation)\n\t\t\t}\n\t\t}\n\t\tcontinuation()\n\t\tfunction continuation() {\n\t\t\tif (++called === expected) {\n\t\t\t\tonremove(vnode)\n\t\t\t\tif (vnode.dom) {\n\t\t\t\t\tvar count0 = vnode.domSize || 1\n\t\t\t\t\tif (count0 > 1) {\n\t\t\t\t\t\tvar dom = vnode.dom\n\t\t\t\t\t\twhile (--count0) {\n\t\t\t\t\t\t\tremoveNodeFromDOM(dom.nextSibling)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tremoveNodeFromDOM(vnode.dom)\n\t\t\t\t\tif (context != null && vnode.domSize == null && !hasIntegrationMethods(vnode.attrs) && typeof vnode.tag === "string") { //TODO test custom elements\n\t\t\t\t\t\tif (!context.pool) context.pool = [vnode]\n\t\t\t\t\t\telse context.pool.push(vnode)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfunction removeNodeFromDOM(node) {\n\t\tvar parent = node.parentNode\n\t\tif (parent != null) parent.removeChild(node)\n\t}\n\tfunction onremove(vnode) {\n\t\tif (vnode.attrs && typeof vnode.attrs.onremove === "function") vnode.attrs.onremove.call(vnode.state, vnode)\n\t\tif (typeof vnode.tag !== "string" && typeof vnode._state.onremove === "function") vnode._state.onremove.call(vnode.state, vnode)\n\t\tif (vnode.instance != null) onremove(vnode.instance)\n\t\telse {\n\t\t\tvar children = vnode.children\n\t\t\tif (Array.isArray(children)) {\n\t\t\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\t\t\tvar child = children[i]\n\t\t\t\t\tif (child != null) onremove(child)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//attrs2\n\tfunction setAttrs(vnode, attrs2, ns) {\n\t\tfor (var key2 in attrs2) {\n\t\t\tsetAttr(vnode, key2, null, attrs2[key2], ns)\n\t\t}\n\t}\n\tfunction setAttr(vnode, key2, old, value, ns) {\n\t\tvar element = vnode.dom\n\t\tif (key2 === "key" || key2 === "is" || (old === value && !isFormAttribute(vnode, key2)) && typeof value !== "object" || typeof value === "undefined" || isLifecycleMethod(key2)) return\n\t\tvar nsLastIndex = key2.indexOf(":")\n\t\tif (nsLastIndex > -1 && key2.substr(0, nsLastIndex) === "xlink") {\n\t\t\telement.setAttributeNS("http://www.w3.org/1999/xlink", key2.slice(nsLastIndex + 1), value)\n\t\t}\n\t\telse if (key2[0] === "o" && key2[1] === "n" && typeof value === "function") updateEvent(vnode, key2, value)\n\t\telse if (key2 === "style") updateStyle(element, old, value)\n\t\telse if (key2 in element && !isAttribute(key2) && ns === undefined && !isCustomElement(vnode)) {\n\t\t\tif (key2 === "value") {\n\t\t\t\tvar normalized0 = "" + value // eslint-disable-line no-implicit-coercion\n\t\t\t\t//setting input[value] to same value by typing on focused element moves cursor to end in Chrome\n\t\t\t\tif ((vnode.tag === "input" || vnode.tag === "textarea") && vnode.dom.value === normalized0 && vnode.dom === $doc.activeElement) return\n\t\t\t\t//setting select[value] to same value while having select open blinks select dropdown in Chrome\n\t\t\t\tif (vnode.tag === "select") {\n\t\t\t\t\tif (value === null) {\n\t\t\t\t\t\tif (vnode.dom.selectedIndex === -1 && vnode.dom === $doc.activeElement) return\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (old !== null && vnode.dom.value === normalized0 && vnode.dom === $doc.activeElement) return\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//setting option[value] to same value while having select open blinks select dropdown in Chrome\n\t\t\t\tif (vnode.tag === "option" && old != null && vnode.dom.value === normalized0) return\n\t\t\t}\n\t\t\t// If you assign an input type1 that is not supported by IE 11 with an assignment expression, an error0 will occur.\n\t\t\tif (vnode.tag === "input" && key2 === "type") {\n\t\t\t\telement.setAttribute(key2, value)\n\t\t\t\treturn\n\t\t\t}\n\t\t\telement[key2] = value\n\t\t}\n\t\telse {\n\t\t\tif (typeof value === "boolean") {\n\t\t\t\tif (value) element.setAttribute(key2, "")\n\t\t\t\telse element.removeAttribute(key2)\n\t\t\t}\n\t\t\telse element.setAttribute(key2 === "className" ? "class" : key2, value)\n\t\t}\n\t}\n\tfunction setLateAttrs(vnode) {\n\t\tvar attrs2 = vnode.attrs\n\t\tif (vnode.tag === "select" && attrs2 != null) {\n\t\t\tif ("value" in attrs2) setAttr(vnode, "value", null, attrs2.value, undefined)\n\t\t\tif ("selectedIndex" in attrs2) setAttr(vnode, "selectedIndex", null, attrs2.selectedIndex, undefined)\n\t\t}\n\t}\n\tfunction updateAttrs(vnode, old, attrs2, ns) {\n\t\tif (attrs2 != null) {\n\t\t\tfor (var key2 in attrs2) {\n\t\t\t\tsetAttr(vnode, key2, old && old[key2], attrs2[key2], ns)\n\t\t\t}\n\t\t}\n\t\tif (old != null) {\n\t\t\tfor (var key2 in old) {\n\t\t\t\tif (attrs2 == null || !(key2 in attrs2)) {\n\t\t\t\t\tif (key2 === "className") key2 = "class"\n\t\t\t\t\tif (key2[0] === "o" && key2[1] === "n" && !isLifecycleMethod(key2)) updateEvent(vnode, key2, undefined)\n\t\t\t\t\telse if (key2 !== "key") vnode.dom.removeAttribute(key2)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfunction isFormAttribute(vnode, attr) {\n\t\treturn attr === "value" || attr === "checked" || attr === "selectedIndex" || attr === "selected" && vnode.dom === $doc.activeElement\n\t}\n\tfunction isLifecycleMethod(attr) {\n\t\treturn attr === "oninit" || attr === "oncreate" || attr === "onupdate" || attr === "onremove" || attr === "onbeforeremove" || attr === "onbeforeupdate"\n\t}\n\tfunction isAttribute(attr) {\n\t\treturn attr === "href" || attr === "list" || attr === "form" || attr === "width" || attr === "height"// || attr === "type"\n\t}\n\tfunction isCustomElement(vnode){\n\t\treturn vnode.attrs.is || vnode.tag.indexOf("-") > -1\n\t}\n\tfunction hasIntegrationMethods(source) {\n\t\treturn source != null && (source.oncreate || source.onupdate || source.onbeforeremove || source.onremove)\n\t}\n\t//style\n\tfunction updateStyle(element, old, style) {\n\t\tif (old === style) element.style.cssText = "", old = null\n\t\tif (style == null) element.style.cssText = ""\n\t\telse if (typeof style === "string") element.style.cssText = style\n\t\telse {\n\t\t\tif (typeof old === "string") element.style.cssText = ""\n\t\t\tfor (var key2 in style) {\n\t\t\t\telement.style[key2] = style[key2]\n\t\t\t}\n\t\t\tif (old != null && typeof old !== "string") {\n\t\t\t\tfor (var key2 in old) {\n\t\t\t\t\tif (!(key2 in style)) element.style[key2] = ""\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//event\n\tfunction updateEvent(vnode, key2, value) {\n\t\tvar element = vnode.dom\n\t\tvar callback = typeof onevent !== "function" ? value : function(e) {\n\t\t\tvar result = value.call(element, e)\n\t\t\tonevent.call(element, e)\n\t\t\treturn result\n\t\t}\n\t\tif (key2 in element) element[key2] = typeof value === "function" ? callback : null\n\t\telse {\n\t\t\tvar eventName = key2.slice(2)\n\t\t\tif (vnode.events === undefined) vnode.events = {}\n\t\t\tif (vnode.events[key2] === callback) return\n\t\t\tif (vnode.events[key2] != null) element.removeEventListener(eventName, vnode.events[key2], false)\n\t\t\tif (typeof value === "function") {\n\t\t\t\tvnode.events[key2] = callback\n\t\t\t\telement.addEventListener(eventName, vnode.events[key2], false)\n\t\t\t}\n\t\t}\n\t}\n\t//lifecycle\n\tfunction initLifecycle(source, vnode, hooks) {\n\t\tif (typeof source.oninit === "function") source.oninit.call(vnode.state, vnode)\n\t\tif (typeof source.oncreate === "function") hooks.push(source.oncreate.bind(vnode.state, vnode))\n\t}\n\tfunction updateLifecycle(source, vnode, hooks) {\n\t\tif (typeof source.onupdate === "function") hooks.push(source.onupdate.bind(vnode.state, vnode))\n\t}\n\tfunction shouldNotUpdate(vnode, old) {\n\t\tvar forceVnodeUpdate, forceComponentUpdate\n\t\tif (vnode.attrs != null && typeof vnode.attrs.onbeforeupdate === "function") forceVnodeUpdate = vnode.attrs.onbeforeupdate.call(vnode.state, vnode, old)\n\t\tif (typeof vnode.tag !== "string" && typeof vnode._state.onbeforeupdate === "function") forceComponentUpdate = vnode._state.onbeforeupdate.call(vnode.state, vnode, old)\n\t\tif (!(forceVnodeUpdate === undefined && forceComponentUpdate === undefined) && !forceVnodeUpdate && !forceComponentUpdate) {\n\t\t\tvnode.dom = old.dom\n\t\t\tvnode.domSize = old.domSize\n\t\t\tvnode.instance = old.instance\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\tfunction render(dom, vnodes) {\n\t\tif (!dom) throw new Error("Ensure the DOM element being passed to m.route/m.mount/m.render is not undefined.")\n\t\tvar hooks = []\n\t\tvar active = $doc.activeElement\n\t\tvar namespace = dom.namespaceURI\n\t\t// First time0 rendering into a node clears it out\n\t\tif (dom.vnodes == null) dom.textContent = ""\n\t\tif (!Array.isArray(vnodes)) vnodes = [vnodes]\n\t\tupdateNodes(dom, dom.vnodes, Vnode.normalizeChildren(vnodes), false, hooks, null, namespace === "http://www.w3.org/1999/xhtml" ? undefined : namespace)\n\t\tdom.vnodes = vnodes\n\t\tfor (var i = 0; i < hooks.length; i++) hooks[i]()\n\t\tif ($doc.activeElement !== active) active.focus()\n\t}\n\treturn {render: render, setEventCallback: setEventCallback}\n}\nfunction throttle(callback) {\n\t//60fps translates to 16.6ms, round it down since setTimeout requires int\n\tvar time = 16\n\tvar last = 0, pending = null\n\tvar timeout = typeof requestAnimationFrame === "function" ? requestAnimationFrame : setTimeout\n\treturn function() {\n\t\tvar now = Date.now()\n\t\tif (last === 0 || now - last >= time) {\n\t\t\tlast = now\n\t\t\tcallback()\n\t\t}\n\t\telse if (pending === null) {\n\t\t\tpending = timeout(function() {\n\t\t\t\tpending = null\n\t\t\t\tcallback()\n\t\t\t\tlast = Date.now()\n\t\t\t}, time - (now - last))\n\t\t}\n\t}\n}\nvar _11 = function($window) {\n\tvar renderService = coreRenderer($window)\n\trenderService.setEventCallback(function(e) {\n\t\tif (e.redraw === false) e.redraw = undefined\n\t\telse redraw()\n\t})\n\tvar callbacks = []\n\tfunction subscribe(key1, callback) {\n\t\tunsubscribe(key1)\n\t\tcallbacks.push(key1, throttle(callback))\n\t}\n\tfunction unsubscribe(key1) {\n\t\tvar index = callbacks.indexOf(key1)\n\t\tif (index > -1) callbacks.splice(index, 2)\n\t}\n\tfunction redraw() {\n\t\tfor (var i = 1; i < callbacks.length; i += 2) {\n\t\t\tcallbacks[i]()\n\t\t}\n\t}\n\treturn {subscribe: subscribe, unsubscribe: unsubscribe, redraw: redraw, render: renderService.render}\n}\nvar redrawService = _11(window)\nrequestService.setCompletionCallback(redrawService.redraw)\nvar _16 = function(redrawService0) {\n\treturn function(root, component) {\n\t\tif (component === null) {\n\t\t\tredrawService0.render(root, [])\n\t\t\tredrawService0.unsubscribe(root)\n\t\t\treturn\n\t\t}\n\t\t\n\t\tif (component.view == null && typeof component !== "function") throw new Error("m.mount(element, component) expects a component, not a vnode")\n\t\t\n\t\tvar run0 = function() {\n\t\t\tredrawService0.render(root, Vnode(component))\n\t\t}\n\t\tredrawService0.subscribe(root, run0)\n\t\tredrawService0.redraw()\n\t}\n}\nm.mount = _16(redrawService)\nvar Promise = PromisePolyfill\nvar parseQueryString = function(string) {\n\tif (string === "" || string == null) return {}\n\tif (string.charAt(0) === "?") string = string.slice(1)\n\tvar entries = string.split("&"), data0 = {}, counters = {}\n\tfor (var i = 0; i < entries.length; i++) {\n\t\tvar entry = entries[i].split("=")\n\t\tvar key5 = decodeURIComponent(entry[0])\n\t\tvar value = entry.length === 2 ? decodeURIComponent(entry[1]) : ""\n\t\tif (value === "true") value = true\n\t\telse if (value === "false") value = false\n\t\tvar levels = key5.split(/\\]\\[?|\\[/)\n\t\tvar cursor = data0\n\t\tif (key5.indexOf("[") > -1) levels.pop()\n\t\tfor (var j = 0; j < levels.length; j++) {\n\t\t\tvar level = levels[j], nextLevel = levels[j + 1]\n\t\t\tvar isNumber = nextLevel == "" || !isNaN(parseInt(nextLevel, 10))\n\t\t\tvar isValue = j === levels.length - 1\n\t\t\tif (level === "") {\n\t\t\t\tvar key5 = levels.slice(0, j).join()\n\t\t\t\tif (counters[key5] == null) counters[key5] = 0\n\t\t\t\tlevel = counters[key5]++\n\t\t\t}\n\t\t\tif (cursor[level] == null) {\n\t\t\t\tcursor[level] = isValue ? value : isNumber ? [] : {}\n\t\t\t}\n\t\t\tcursor = cursor[level]\n\t\t}\n\t}\n\treturn data0\n}\nvar coreRouter = function($window) {\n\tvar supportsPushState = typeof $window.history.pushState === "function"\n\tvar callAsync0 = typeof setImmediate === "function" ? setImmediate : setTimeout\n\tfunction normalize1(fragment0) {\n\t\tvar data = $window.location[fragment0].replace(/(?:%[a-f89][a-f0-9])+/gim, decodeURIComponent)\n\t\tif (fragment0 === "pathname" && data[0] !== "/") data = "/" + data\n\t\treturn data\n\t}\n\tvar asyncId\n\tfunction debounceAsync(callback0) {\n\t\treturn function() {\n\t\t\tif (asyncId != null) return\n\t\t\tasyncId = callAsync0(function() {\n\t\t\t\tasyncId = null\n\t\t\t\tcallback0()\n\t\t\t})\n\t\t}\n\t}\n\tfunction parsePath(path, queryData, hashData) {\n\t\tvar queryIndex = path.indexOf("?")\n\t\tvar hashIndex = path.indexOf("#")\n\t\tvar pathEnd = queryIndex > -1 ? queryIndex : hashIndex > -1 ? hashIndex : path.length\n\t\tif (queryIndex > -1) {\n\t\t\tvar queryEnd = hashIndex > -1 ? hashIndex : path.length\n\t\t\tvar queryParams = parseQueryString(path.slice(queryIndex + 1, queryEnd))\n\t\t\tfor (var key4 in queryParams) queryData[key4] = queryParams[key4]\n\t\t}\n\t\tif (hashIndex > -1) {\n\t\t\tvar hashParams = parseQueryString(path.slice(hashIndex + 1))\n\t\t\tfor (var key4 in hashParams) hashData[key4] = hashParams[key4]\n\t\t}\n\t\treturn path.slice(0, pathEnd)\n\t}\n\tvar router = {prefix: "#!"}\n\trouter.getPath = function() {\n\t\tvar type2 = router.prefix.charAt(0)\n\t\tswitch (type2) {\n\t\t\tcase "#": return normalize1("hash").slice(router.prefix.length)\n\t\t\tcase "?": return normalize1("search").slice(router.prefix.length) + normalize1("hash")\n\t\t\tdefault: return normalize1("pathname").slice(router.prefix.length) + normalize1("search") + normalize1("hash")\n\t\t}\n\t}\n\trouter.setPath = function(path, data, options) {\n\t\tvar queryData = {}, hashData = {}\n\t\tpath = parsePath(path, queryData, hashData)\n\t\tif (data != null) {\n\t\t\tfor (var key4 in data) queryData[key4] = data[key4]\n\t\t\tpath = path.replace(/:([^\\/]+)/g, function(match2, token) {\n\t\t\t\tdelete queryData[token]\n\t\t\t\treturn data[token]\n\t\t\t})\n\t\t}\n\t\tvar query = buildQueryString(queryData)\n\t\tif (query) path += "?" + query\n\t\tvar hash = buildQueryString(hashData)\n\t\tif (hash) path += "#" + hash\n\t\tif (supportsPushState) {\n\t\t\tvar state = options ? options.state : null\n\t\t\tvar title = options ? options.title : null\n\t\t\t$window.onpopstate()\n\t\t\tif (options && options.replace) $window.history.replaceState(state, title, router.prefix + path)\n\t\t\telse $window.history.pushState(state, title, router.prefix + path)\n\t\t}\n\t\telse $window.location.href = router.prefix + path\n\t}\n\trouter.defineRoutes = function(routes, resolve, reject) {\n\t\tfunction resolveRoute() {\n\t\t\tvar path = router.getPath()\n\t\t\tvar params = {}\n\t\t\tvar pathname = parsePath(path, params, params)\n\t\t\tvar state = $window.history.state\n\t\t\tif (state != null) {\n\t\t\t\tfor (var k in state) params[k] = state[k]\n\t\t\t}\n\t\t\tfor (var route0 in routes) {\n\t\t\t\tvar matcher = new RegExp("^" + route0.replace(/:[^\\/]+?\\.{3}/g, "(.*?)").replace(/:[^\\/]+/g, "([^\\\\/]+)") + "\\/?$")\n\t\t\t\tif (matcher.test(pathname)) {\n\t\t\t\t\tpathname.replace(matcher, function() {\n\t\t\t\t\t\tvar keys = route0.match(/:[^\\/]+/g) || []\n\t\t\t\t\t\tvar values = [].slice.call(arguments, 1, -2)\n\t\t\t\t\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\t\t\t\t\tparams[keys[i].replace(/:|\\./g, "")] = decodeURIComponent(values[i])\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresolve(routes[route0], params, path, route0)\n\t\t\t\t\t})\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\treject(path, params)\n\t\t}\n\t\tif (supportsPushState) $window.onpopstate = debounceAsync(resolveRoute)\n\t\telse if (router.prefix.charAt(0) === "#") $window.onhashchange = resolveRoute\n\t\tresolveRoute()\n\t}\n\treturn router\n}\nvar _20 = function($window, redrawService0) {\n\tvar routeService = coreRouter($window)\n\tvar identity = function(v) {return v}\n\tvar render1, component, attrs3, currentPath, lastUpdate\n\tvar route = function(root, defaultRoute, routes) {\n\t\tif (root == null) throw new Error("Ensure the DOM element that was passed to `m.route` is not undefined")\n\t\tvar run1 = function() {\n\t\t\tif (render1 != null) redrawService0.render(root, render1(Vnode(component, attrs3.key, attrs3)))\n\t\t}\n\t\tvar bail = function(path) {\n\t\t\tif (path !== defaultRoute) routeService.setPath(defaultRoute, null, {replace: true})\n\t\t\telse throw new Error("Could not resolve default route " + defaultRoute)\n\t\t}\n\t\trouteService.defineRoutes(routes, function(payload, params, path) {\n\t\t\tvar update = lastUpdate = function(routeResolver, comp) {\n\t\t\t\tif (update !== lastUpdate) return\n\t\t\t\tcomponent = comp != null && (typeof comp.view === "function" || typeof comp === "function")? comp : "div"\n\t\t\t\tattrs3 = params, currentPath = path, lastUpdate = null\n\t\t\t\trender1 = (routeResolver.render || identity).bind(routeResolver)\n\t\t\t\trun1()\n\t\t\t}\n\t\t\tif (payload.view || typeof payload === "function") update({}, payload)\n\t\t\telse {\n\t\t\t\tif (payload.onmatch) {\n\t\t\t\t\tPromise.resolve(payload.onmatch(params, path)).then(function(resolved) {\n\t\t\t\t\t\tupdate(payload, resolved)\n\t\t\t\t\t}, bail)\n\t\t\t\t}\n\t\t\t\telse update(payload, "div")\n\t\t\t}\n\t\t}, bail)\n\t\tredrawService0.subscribe(root, run1)\n\t}\n\troute.set = function(path, data, options) {\n\t\tif (lastUpdate != null) {\n\t\t\toptions = options || {}\n\t\t\toptions.replace = true\n\t\t}\n\t\tlastUpdate = null\n\t\trouteService.setPath(path, data, options)\n\t}\n\troute.get = function() {return currentPath}\n\troute.prefix = function(prefix0) {routeService.prefix = prefix0}\n\troute.link = function(vnode1) {\n\t\tvnode1.dom.setAttribute("href", routeService.prefix + vnode1.attrs.href)\n\t\tvnode1.dom.onclick = function(e) {\n\t\t\tif (e.ctrlKey || e.metaKey || e.shiftKey || e.which === 2) return\n\t\t\te.preventDefault()\n\t\t\te.redraw = false\n\t\t\tvar href = this.getAttribute("href")\n\t\t\tif (href.indexOf(routeService.prefix) === 0) href = href.slice(routeService.prefix.length)\n\t\t\troute.set(href, undefined, undefined)\n\t\t}\n\t}\n\troute.param = function(key3) {\n\t\tif(typeof attrs3 !== "undefined" && typeof key3 !== "undefined") return attrs3[key3]\n\t\treturn attrs3\n\t}\n\treturn route\n}\nm.route = _20(window, redrawService)\nm.withAttr = function(attrName, callback1, context) {\n\treturn function(e) {\n\t\tcallback1.call(context || this, attrName in e.currentTarget ? e.currentTarget[attrName] : e.currentTarget.getAttribute(attrName))\n\t}\n}\nvar _28 = coreRenderer(window)\nm.render = _28.render\nm.redraw = redrawService.redraw\nm.request = requestService.request\nm.jsonp = requestService.jsonp\nm.parseQueryString = parseQueryString\nm.buildQueryString = buildQueryString\nm.version = "1.1.3"\nm.vnode = Vnode\nif (true) module["exports"] = m\nelse window.m = m\n}());\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(14).setImmediate, __webpack_require__(3)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21pdGhyaWwvbWl0aHJpbC5qcz9iZDQyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLDZEQUFDO0FBQ0Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxP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QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QyxpQ0FBaUMsT0FBTztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsMkRBQTJEO0FBQzNELHFGQUFxRjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG1CQUFtQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0SEFBNEg7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QyxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsRUFBRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLGNBQWM7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsSSIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiOyhmdW5jdGlvbigpIHtcblwidXNlIHN0cmljdFwiXG5mdW5jdGlvbiBWbm9kZSh0YWcsIGtleSwgYXR0cnMwLCBjaGlsZHJlbiwgdGV4dCwgZG9tKSB7XG5cdHJldHVybiB7dGFnOiB0YWcsIGtleToga2V5LCBhdHRyczogYXR0cnMwLCBjaGlsZHJlbjogY2hpbGRyZW4sIHRleHQ6IHRleHQsIGRvbTogZG9tLCBkb21TaXplOiB1bmRlZmluZWQsIHN0YXRlOiB1bmRlZmluZWQsIF9zdGF0ZTogdW5kZWZpbmVkLCBldmVudHM6IHVuZGVmaW5lZCwgaW5zdGFuY2U6IHVuZGVmaW5lZCwgc2tpcDogZmFsc2V9XG59XG5Wbm9kZS5ub3JtYWxpemUgPSBmdW5jdGlvbihub2RlKSB7XG5cdGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSByZXR1cm4gVm5vZGUoXCJbXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBWbm9kZS5ub3JtYWxpemVDaGlsZHJlbihub2RlKSwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG5cdGlmIChub2RlICE9IG51bGwgJiYgdHlwZW9mIG5vZGUgIT09IFwib2JqZWN0XCIpIHJldHVybiBWbm9kZShcIiNcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG5vZGUgPT09IGZhbHNlID8gXCJcIiA6IG5vZGUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKVxuXHRyZXR1cm4gbm9kZVxufVxuVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4gPSBmdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbikge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0Y2hpbGRyZW5baV0gPSBWbm9kZS5ub3JtYWxpemUoY2hpbGRyZW5baV0pXG5cdH1cblx0cmV0dXJuIGNoaWxkcmVuXG59XG52YXIgc2VsZWN0b3JQYXJzZXIgPSAvKD86KF58I3xcXC4pKFteI1xcLlxcW1xcXV0rKSl8KFxcWyguKz8pKD86XFxzKj1cXHMqKFwifCd8KSgoPzpcXFxcW1wiJ1xcXV18LikqPylcXDUpP1xcXSkvZ1xudmFyIHNlbGVjdG9yQ2FjaGUgPSB7fVxudmFyIGhhc093biA9IHt9Lmhhc093blByb3BlcnR5XG5mdW5jdGlvbiBjb21waWxlU2VsZWN0b3Ioc2VsZWN0b3IpIHtcblx0dmFyIG1hdGNoLCB0YWcgPSBcImRpdlwiLCBjbGFzc2VzID0gW10sIGF0dHJzID0ge31cblx0d2hpbGUgKG1hdGNoID0gc2VsZWN0b3JQYXJzZXIuZXhlYyhzZWxlY3RvcikpIHtcblx0XHR2YXIgdHlwZSA9IG1hdGNoWzFdLCB2YWx1ZSA9IG1hdGNoWzJdXG5cdFx0aWYgKHR5cGUgPT09IFwiXCIgJiYgdmFsdWUgIT09IFwiXCIpIHRhZyA9IHZhbHVlXG5cdFx0ZWxzZSBpZiAodHlwZSA9PT0gXCIjXCIpIGF0dHJzLmlkID0gdmFsdWVcblx0XHRlbHNlIGlmICh0eXBlID09PSBcIi5cIikgY2xhc3Nlcy5wdXNoKHZhbHVlKVxuXHRcdGVsc2UgaWYgKG1hdGNoWzNdWzBdID09PSBcIltcIikge1xuXHRcdFx0dmFyIGF0dHJWYWx1ZSA9IG1hdGNoWzZdXG5cdFx0XHRpZiAoYXR0clZhbHVlKSBhdHRyVmFsdWUgPSBhdHRyVmFsdWUucmVwbGFjZSgvXFxcXChbXCInXSkvZywgXCIkMVwiKS5yZXBsYWNlKC9cXFxcXFxcXC9nLCBcIlxcXFxcIilcblx0XHRcdGlmIChtYXRjaFs0XSA9PT0gXCJjbGFzc1wiKSBjbGFzc2VzLnB1c2goYXR0clZhbHVlKVxuXHRcdFx0ZWxzZSBhdHRyc1ttYXRjaFs0XV0gPSBhdHRyVmFsdWUgPT09IFwiXCIgPyBhdHRyVmFsdWUgOiBhdHRyVmFsdWUgfHwgdHJ1ZVxuXHRcdH1cblx0fVxuXHRpZiAoY2xhc3Nlcy5sZW5ndGggPiAwKSBhdHRycy5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oXCIgXCIpXG5cdHJldHVybiBzZWxlY3RvckNhY2hlW3NlbGVjdG9yXSA9IHt0YWc6IHRhZywgYXR0cnM6IGF0dHJzfVxufVxuZnVuY3Rpb24gZXhlY1NlbGVjdG9yKHN0YXRlLCBhdHRycywgY2hpbGRyZW4pIHtcblx0dmFyIGhhc0F0dHJzID0gZmFsc2UsIGNoaWxkTGlzdCwgdGV4dFxuXHR2YXIgY2xhc3NOYW1lID0gYXR0cnMuY2xhc3NOYW1lIHx8IGF0dHJzLmNsYXNzXG5cdGZvciAodmFyIGtleSBpbiBzdGF0ZS5hdHRycykge1xuXHRcdGlmIChoYXNPd24uY2FsbChzdGF0ZS5hdHRycywga2V5KSkge1xuXHRcdFx0YXR0cnNba2V5XSA9IHN0YXRlLmF0dHJzW2tleV1cblx0XHR9XG5cdH1cblx0aWYgKGNsYXNzTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0aWYgKGF0dHJzLmNsYXNzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGF0dHJzLmNsYXNzID0gdW5kZWZpbmVkXG5cdFx0XHRhdHRycy5jbGFzc05hbWUgPSBjbGFzc05hbWVcblx0XHR9XG5cdFx0aWYgKHN0YXRlLmF0dHJzLmNsYXNzTmFtZSAhPSBudWxsKSB7XG5cdFx0XHRhdHRycy5jbGFzc05hbWUgPSBzdGF0ZS5hdHRycy5jbGFzc05hbWUgKyBcIiBcIiArIGNsYXNzTmFtZVxuXHRcdH1cblx0fVxuXHRmb3IgKHZhciBrZXkgaW4gYXR0cnMpIHtcblx0XHRpZiAoaGFzT3duLmNhbGwoYXR0cnMsIGtleSkgJiYga2V5ICE9PSBcImtleVwiKSB7XG5cdFx0XHRoYXNBdHRycyA9IHRydWVcblx0XHRcdGJyZWFrXG5cdFx0fVxuXHR9XG5cdGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJiBjaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgY2hpbGRyZW5bMF0gIT0gbnVsbCAmJiBjaGlsZHJlblswXS50YWcgPT09IFwiI1wiKSB7XG5cdFx0dGV4dCA9IGNoaWxkcmVuWzBdLmNoaWxkcmVuXG5cdH0gZWxzZSB7XG5cdFx0Y2hpbGRMaXN0ID0gY2hpbGRyZW5cblx0fVxuXHRyZXR1cm4gVm5vZGUoc3RhdGUudGFnLCBhdHRycy5rZXksIGhhc0F0dHJzID8gYXR0cnMgOiB1bmRlZmluZWQsIGNoaWxkTGlzdCwgdGV4dClcbn1cbmZ1bmN0aW9uIGh5cGVyc2NyaXB0KHNlbGVjdG9yKSB7XG5cdC8vIEJlY2F1c2Ugc2xvcHB5IG1vZGUgc3Vja3Ncblx0dmFyIGF0dHJzID0gYXJndW1lbnRzWzFdLCBzdGFydCA9IDIsIGNoaWxkcmVuXG5cdGlmIChzZWxlY3RvciA9PSBudWxsIHx8IHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygc2VsZWN0b3IgIT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygc2VsZWN0b3IudmlldyAhPT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0dGhyb3cgRXJyb3IoXCJUaGUgc2VsZWN0b3IgbXVzdCBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgYSBjb21wb25lbnQuXCIpO1xuXHR9XG5cdGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIpIHtcblx0XHR2YXIgY2FjaGVkID0gc2VsZWN0b3JDYWNoZVtzZWxlY3Rvcl0gfHwgY29tcGlsZVNlbGVjdG9yKHNlbGVjdG9yKVxuXHR9XG5cdGlmIChhdHRycyA9PSBudWxsKSB7XG5cdFx0YXR0cnMgPSB7fVxuXHR9IGVsc2UgaWYgKHR5cGVvZiBhdHRycyAhPT0gXCJvYmplY3RcIiB8fCBhdHRycy50YWcgIT0gbnVsbCB8fCBBcnJheS5pc0FycmF5KGF0dHJzKSkge1xuXHRcdGF0dHJzID0ge31cblx0XHRzdGFydCA9IDFcblx0fVxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gc3RhcnQgKyAxKSB7XG5cdFx0Y2hpbGRyZW4gPSBhcmd1bWVudHNbc3RhcnRdXG5cdFx0aWYgKCFBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkgY2hpbGRyZW4gPSBbY2hpbGRyZW5dXG5cdH0gZWxzZSB7XG5cdFx0Y2hpbGRyZW4gPSBbXVxuXHRcdHdoaWxlIChzdGFydCA8IGFyZ3VtZW50cy5sZW5ndGgpIGNoaWxkcmVuLnB1c2goYXJndW1lbnRzW3N0YXJ0KytdKVxuXHR9XG5cdHZhciBub3JtYWxpemVkID0gVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pXG5cdGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIpIHtcblx0XHRyZXR1cm4gZXhlY1NlbGVjdG9yKGNhY2hlZCwgYXR0cnMsIG5vcm1hbGl6ZWQpXG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIFZub2RlKHNlbGVjdG9yLCBhdHRycy5rZXksIGF0dHJzLCBub3JtYWxpemVkKVxuXHR9XG59XG5oeXBlcnNjcmlwdC50cnVzdCA9IGZ1bmN0aW9uKGh0bWwpIHtcblx0aWYgKGh0bWwgPT0gbnVsbCkgaHRtbCA9IFwiXCJcblx0cmV0dXJuIFZub2RlKFwiPFwiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaHRtbCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG59XG5oeXBlcnNjcmlwdC5mcmFnbWVudCA9IGZ1bmN0aW9uKGF0dHJzMSwgY2hpbGRyZW4pIHtcblx0cmV0dXJuIFZub2RlKFwiW1wiLCBhdHRyczEua2V5LCBhdHRyczEsIFZub2RlLm5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKSwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG59XG52YXIgbSA9IGh5cGVyc2NyaXB0XG4vKiogQGNvbnN0cnVjdG9yICovXG52YXIgUHJvbWlzZVBvbHlmaWxsID0gZnVuY3Rpb24oZXhlY3V0b3IpIHtcblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIFByb21pc2VQb2x5ZmlsbCkpIHRocm93IG5ldyBFcnJvcihcIlByb21pc2UgbXVzdCBiZSBjYWxsZWQgd2l0aCBgbmV3YFwiKVxuXHRpZiAodHlwZW9mIGV4ZWN1dG9yICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJleGVjdXRvciBtdXN0IGJlIGEgZnVuY3Rpb25cIilcblx0dmFyIHNlbGYgPSB0aGlzLCByZXNvbHZlcnMgPSBbXSwgcmVqZWN0b3JzID0gW10sIHJlc29sdmVDdXJyZW50ID0gaGFuZGxlcihyZXNvbHZlcnMsIHRydWUpLCByZWplY3RDdXJyZW50ID0gaGFuZGxlcihyZWplY3RvcnMsIGZhbHNlKVxuXHR2YXIgaW5zdGFuY2UgPSBzZWxmLl9pbnN0YW5jZSA9IHtyZXNvbHZlcnM6IHJlc29sdmVycywgcmVqZWN0b3JzOiByZWplY3RvcnN9XG5cdHZhciBjYWxsQXN5bmMgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBzZXRJbW1lZGlhdGUgOiBzZXRUaW1lb3V0XG5cdGZ1bmN0aW9uIGhhbmRsZXIobGlzdCwgc2hvdWxkQWJzb3JiKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGV4ZWN1dGUodmFsdWUpIHtcblx0XHRcdHZhciB0aGVuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAoc2hvdWxkQWJzb3JiICYmIHZhbHVlICE9IG51bGwgJiYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikgJiYgdHlwZW9mICh0aGVuID0gdmFsdWUudGhlbikgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdGlmICh2YWx1ZSA9PT0gc2VsZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByb21pc2UgY2FuJ3QgYmUgcmVzb2x2ZWQgdy8gaXRzZWxmXCIpXG5cdFx0XHRcdFx0ZXhlY3V0ZU9uY2UodGhlbi5iaW5kKHZhbHVlKSlcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRjYWxsQXN5bmMoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRpZiAoIXNob3VsZEFic29yYiAmJiBsaXN0Lmxlbmd0aCA9PT0gMCkgY29uc29sZS5lcnJvcihcIlBvc3NpYmxlIHVuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbjpcIiwgdmFsdWUpXG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIGxpc3RbaV0odmFsdWUpXG5cdFx0XHRcdFx0XHRyZXNvbHZlcnMubGVuZ3RoID0gMCwgcmVqZWN0b3JzLmxlbmd0aCA9IDBcblx0XHRcdFx0XHRcdGluc3RhbmNlLnN0YXRlID0gc2hvdWxkQWJzb3JiXG5cdFx0XHRcdFx0XHRpbnN0YW5jZS5yZXRyeSA9IGZ1bmN0aW9uKCkge2V4ZWN1dGUodmFsdWUpfVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGNhdGNoIChlKSB7XG5cdFx0XHRcdHJlamVjdEN1cnJlbnQoZSlcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gZXhlY3V0ZU9uY2UodGhlbikge1xuXHRcdHZhciBydW5zID0gMFxuXHRcdGZ1bmN0aW9uIHJ1bihmbikge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdGlmIChydW5zKysgPiAwKSByZXR1cm5cblx0XHRcdFx0Zm4odmFsdWUpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHZhciBvbmVycm9yID0gcnVuKHJlamVjdEN1cnJlbnQpXG5cdFx0dHJ5IHt0aGVuKHJ1bihyZXNvbHZlQ3VycmVudCksIG9uZXJyb3IpfSBjYXRjaCAoZSkge29uZXJyb3IoZSl9XG5cdH1cblx0ZXhlY3V0ZU9uY2UoZXhlY3V0b3IpXG59XG5Qcm9taXNlUG9seWZpbGwucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbihvbkZ1bGZpbGxlZCwgb25SZWplY3Rpb24pIHtcblx0dmFyIHNlbGYgPSB0aGlzLCBpbnN0YW5jZSA9IHNlbGYuX2luc3RhbmNlXG5cdGZ1bmN0aW9uIGhhbmRsZShjYWxsYmFjaywgbGlzdCwgbmV4dCwgc3RhdGUpIHtcblx0XHRsaXN0LnB1c2goZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikgbmV4dCh2YWx1ZSlcblx0XHRcdGVsc2UgdHJ5IHtyZXNvbHZlTmV4dChjYWxsYmFjayh2YWx1ZSkpfSBjYXRjaCAoZSkge2lmIChyZWplY3ROZXh0KSByZWplY3ROZXh0KGUpfVxuXHRcdH0pXG5cdFx0aWYgKHR5cGVvZiBpbnN0YW5jZS5yZXRyeSA9PT0gXCJmdW5jdGlvblwiICYmIHN0YXRlID09PSBpbnN0YW5jZS5zdGF0ZSkgaW5zdGFuY2UucmV0cnkoKVxuXHR9XG5cdHZhciByZXNvbHZlTmV4dCwgcmVqZWN0TmV4dFxuXHR2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlUG9seWZpbGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7cmVzb2x2ZU5leHQgPSByZXNvbHZlLCByZWplY3ROZXh0ID0gcmVqZWN0fSlcblx0aGFuZGxlKG9uRnVsZmlsbGVkLCBpbnN0YW5jZS5yZXNvbHZlcnMsIHJlc29sdmVOZXh0LCB0cnVlKSwgaGFuZGxlKG9uUmVqZWN0aW9uLCBpbnN0YW5jZS5yZWplY3RvcnMsIHJlamVjdE5leHQsIGZhbHNlKVxuXHRyZXR1cm4gcHJvbWlzZVxufVxuUHJvbWlzZVBvbHlmaWxsLnByb3RvdHlwZS5jYXRjaCA9IGZ1bmN0aW9uKG9uUmVqZWN0aW9uKSB7XG5cdHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3Rpb24pXG59XG5Qcm9taXNlUG9seWZpbGwucmVzb2x2ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2VQb2x5ZmlsbCkgcmV0dXJuIHZhbHVlXG5cdHJldHVybiBuZXcgUHJvbWlzZVBvbHlmaWxsKGZ1bmN0aW9uKHJlc29sdmUpIHtyZXNvbHZlKHZhbHVlKX0pXG59XG5Qcm9taXNlUG9seWZpbGwucmVqZWN0ID0gZnVuY3Rpb24odmFsdWUpIHtcblx0cmV0dXJuIG5ldyBQcm9taXNlUG9seWZpbGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7cmVqZWN0KHZhbHVlKX0pXG59XG5Qcm9taXNlUG9seWZpbGwuYWxsID0gZnVuY3Rpb24obGlzdCkge1xuXHRyZXR1cm4gbmV3IFByb21pc2VQb2x5ZmlsbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHR2YXIgdG90YWwgPSBsaXN0Lmxlbmd0aCwgY291bnQgPSAwLCB2YWx1ZXMgPSBbXVxuXHRcdGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkgcmVzb2x2ZShbXSlcblx0XHRlbHNlIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdFx0KGZ1bmN0aW9uKGkpIHtcblx0XHRcdFx0ZnVuY3Rpb24gY29uc3VtZSh2YWx1ZSkge1xuXHRcdFx0XHRcdGNvdW50Kytcblx0XHRcdFx0XHR2YWx1ZXNbaV0gPSB2YWx1ZVxuXHRcdFx0XHRcdGlmIChjb3VudCA9PT0gdG90YWwpIHJlc29sdmUodmFsdWVzKVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChsaXN0W2ldICE9IG51bGwgJiYgKHR5cGVvZiBsaXN0W2ldID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBsaXN0W2ldID09PSBcImZ1bmN0aW9uXCIpICYmIHR5cGVvZiBsaXN0W2ldLnRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdGxpc3RbaV0udGhlbihjb25zdW1lLCByZWplY3QpXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBjb25zdW1lKGxpc3RbaV0pXG5cdFx0XHR9KShpKVxuXHRcdH1cblx0fSlcbn1cblByb21pc2VQb2x5ZmlsbC5yYWNlID0gZnVuY3Rpb24obGlzdCkge1xuXHRyZXR1cm4gbmV3IFByb21pc2VQb2x5ZmlsbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHRcdGxpc3RbaV0udGhlbihyZXNvbHZlLCByZWplY3QpXG5cdFx0fVxuXHR9KVxufVxuaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcblx0aWYgKHR5cGVvZiB3aW5kb3cuUHJvbWlzZSA9PT0gXCJ1bmRlZmluZWRcIikgd2luZG93LlByb21pc2UgPSBQcm9taXNlUG9seWZpbGxcblx0dmFyIFByb21pc2VQb2x5ZmlsbCA9IHdpbmRvdy5Qcm9taXNlXG59IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcblx0aWYgKHR5cGVvZiBnbG9iYWwuUHJvbWlzZSA9PT0gXCJ1bmRlZmluZWRcIikgZ2xvYmFsLlByb21pc2UgPSBQcm9taXNlUG9seWZpbGxcblx0dmFyIFByb21pc2VQb2x5ZmlsbCA9IGdsb2JhbC5Qcm9taXNlXG59IGVsc2Uge1xufVxudmFyIGJ1aWxkUXVlcnlTdHJpbmcgPSBmdW5jdGlvbihvYmplY3QpIHtcblx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpICE9PSBcIltvYmplY3QgT2JqZWN0XVwiKSByZXR1cm4gXCJcIlxuXHR2YXIgYXJncyA9IFtdXG5cdGZvciAodmFyIGtleTAgaW4gb2JqZWN0KSB7XG5cdFx0ZGVzdHJ1Y3R1cmUoa2V5MCwgb2JqZWN0W2tleTBdKVxuXHR9XG5cdHJldHVybiBhcmdzLmpvaW4oXCImXCIpXG5cdGZ1bmN0aW9uIGRlc3RydWN0dXJlKGtleTAsIHZhbHVlKSB7XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGRlc3RydWN0dXJlKGtleTAgKyBcIltcIiArIGkgKyBcIl1cIiwgdmFsdWVbaV0pXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09IFwiW29iamVjdCBPYmplY3RdXCIpIHtcblx0XHRcdGZvciAodmFyIGkgaW4gdmFsdWUpIHtcblx0XHRcdFx0ZGVzdHJ1Y3R1cmUoa2V5MCArIFwiW1wiICsgaSArIFwiXVwiLCB2YWx1ZVtpXSlcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBhcmdzLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleTApICsgKHZhbHVlICE9IG51bGwgJiYgdmFsdWUgIT09IFwiXCIgPyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkgOiBcIlwiKSlcblx0fVxufVxudmFyIEZJTEVfUFJPVE9DT0xfUkVHRVggPSBuZXcgUmVnRXhwKFwiXmZpbGU6Ly9cIiwgXCJpXCIpXG52YXIgXzggPSBmdW5jdGlvbigkd2luZG93LCBQcm9taXNlKSB7XG5cdHZhciBjYWxsYmFja0NvdW50ID0gMFxuXHR2YXIgb25jb21wbGV0aW9uXG5cdGZ1bmN0aW9uIHNldENvbXBsZXRpb25DYWxsYmFjayhjYWxsYmFjaykge29uY29tcGxldGlvbiA9IGNhbGxiYWNrfVxuXHRmdW5jdGlvbiBmaW5hbGl6ZXIoKSB7XG5cdFx0dmFyIGNvdW50ID0gMFxuXHRcdGZ1bmN0aW9uIGNvbXBsZXRlKCkge2lmICgtLWNvdW50ID09PSAwICYmIHR5cGVvZiBvbmNvbXBsZXRpb24gPT09IFwiZnVuY3Rpb25cIikgb25jb21wbGV0aW9uKCl9XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGZpbmFsaXplKHByb21pc2UwKSB7XG5cdFx0XHR2YXIgdGhlbjAgPSBwcm9taXNlMC50aGVuXG5cdFx0XHRwcm9taXNlMC50aGVuID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNvdW50Kytcblx0XHRcdFx0dmFyIG5leHQgPSB0aGVuMC5hcHBseShwcm9taXNlMCwgYXJndW1lbnRzKVxuXHRcdFx0XHRuZXh0LnRoZW4oY29tcGxldGUsIGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0XHRjb21wbGV0ZSgpXG5cdFx0XHRcdFx0aWYgKGNvdW50ID09PSAwKSB0aHJvdyBlXG5cdFx0XHRcdH0pXG5cdFx0XHRcdHJldHVybiBmaW5hbGl6ZShuZXh0KVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHByb21pc2UwXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIG5vcm1hbGl6ZShhcmdzLCBleHRyYSkge1xuXHRcdGlmICh0eXBlb2YgYXJncyA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0dmFyIHVybCA9IGFyZ3Ncblx0XHRcdGFyZ3MgPSBleHRyYSB8fCB7fVxuXHRcdFx0aWYgKGFyZ3MudXJsID09IG51bGwpIGFyZ3MudXJsID0gdXJsXG5cdFx0fVxuXHRcdHJldHVybiBhcmdzXG5cdH1cblx0ZnVuY3Rpb24gcmVxdWVzdChhcmdzLCBleHRyYSkge1xuXHRcdHZhciBmaW5hbGl6ZSA9IGZpbmFsaXplcigpXG5cdFx0YXJncyA9IG5vcm1hbGl6ZShhcmdzLCBleHRyYSlcblx0XHR2YXIgcHJvbWlzZTAgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHRcdGlmIChhcmdzLm1ldGhvZCA9PSBudWxsKSBhcmdzLm1ldGhvZCA9IFwiR0VUXCJcblx0XHRcdGFyZ3MubWV0aG9kID0gYXJncy5tZXRob2QudG9VcHBlckNhc2UoKVxuXHRcdFx0dmFyIHVzZUJvZHkgPSAoYXJncy5tZXRob2QgPT09IFwiR0VUXCIgfHwgYXJncy5tZXRob2QgPT09IFwiVFJBQ0VcIikgPyBmYWxzZSA6ICh0eXBlb2YgYXJncy51c2VCb2R5ID09PSBcImJvb2xlYW5cIiA/IGFyZ3MudXNlQm9keSA6IHRydWUpXG5cdFx0XHRpZiAodHlwZW9mIGFyZ3Muc2VyaWFsaXplICE9PSBcImZ1bmN0aW9uXCIpIGFyZ3Muc2VyaWFsaXplID0gdHlwZW9mIEZvcm1EYXRhICE9PSBcInVuZGVmaW5lZFwiICYmIGFyZ3MuZGF0YSBpbnN0YW5jZW9mIEZvcm1EYXRhID8gZnVuY3Rpb24odmFsdWUpIHtyZXR1cm4gdmFsdWV9IDogSlNPTi5zdHJpbmdpZnlcblx0XHRcdGlmICh0eXBlb2YgYXJncy5kZXNlcmlhbGl6ZSAhPT0gXCJmdW5jdGlvblwiKSBhcmdzLmRlc2VyaWFsaXplID0gZGVzZXJpYWxpemVcblx0XHRcdGlmICh0eXBlb2YgYXJncy5leHRyYWN0ICE9PSBcImZ1bmN0aW9uXCIpIGFyZ3MuZXh0cmFjdCA9IGV4dHJhY3Rcblx0XHRcdGFyZ3MudXJsID0gaW50ZXJwb2xhdGUoYXJncy51cmwsIGFyZ3MuZGF0YSlcblx0XHRcdGlmICh1c2VCb2R5KSBhcmdzLmRhdGEgPSBhcmdzLnNlcmlhbGl6ZShhcmdzLmRhdGEpXG5cdFx0XHRlbHNlIGFyZ3MudXJsID0gYXNzZW1ibGUoYXJncy51cmwsIGFyZ3MuZGF0YSlcblx0XHRcdHZhciB4aHIgPSBuZXcgJHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpLFxuXHRcdFx0XHRhYm9ydGVkID0gZmFsc2UsXG5cdFx0XHRcdF9hYm9ydCA9IHhoci5hYm9ydFxuXHRcdFx0eGhyLmFib3J0ID0gZnVuY3Rpb24gYWJvcnQoKSB7XG5cdFx0XHRcdGFib3J0ZWQgPSB0cnVlXG5cdFx0XHRcdF9hYm9ydC5jYWxsKHhocilcblx0XHRcdH1cblx0XHRcdHhoci5vcGVuKGFyZ3MubWV0aG9kLCBhcmdzLnVybCwgdHlwZW9mIGFyZ3MuYXN5bmMgPT09IFwiYm9vbGVhblwiID8gYXJncy5hc3luYyA6IHRydWUsIHR5cGVvZiBhcmdzLnVzZXIgPT09IFwic3RyaW5nXCIgPyBhcmdzLnVzZXIgOiB1bmRlZmluZWQsIHR5cGVvZiBhcmdzLnBhc3N3b3JkID09PSBcInN0cmluZ1wiID8gYXJncy5wYXNzd29yZCA6IHVuZGVmaW5lZClcblx0XHRcdGlmIChhcmdzLnNlcmlhbGl6ZSA9PT0gSlNPTi5zdHJpbmdpZnkgJiYgdXNlQm9keSkge1xuXHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiLCBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIilcblx0XHRcdH1cblx0XHRcdGlmIChhcmdzLmRlc2VyaWFsaXplID09PSBkZXNlcmlhbGl6ZSkge1xuXHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkFjY2VwdFwiLCBcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvKlwiKVxuXHRcdFx0fVxuXHRcdFx0aWYgKGFyZ3Mud2l0aENyZWRlbnRpYWxzKSB4aHIud2l0aENyZWRlbnRpYWxzID0gYXJncy53aXRoQ3JlZGVudGlhbHNcblx0XHRcdGZvciAodmFyIGtleSBpbiBhcmdzLmhlYWRlcnMpIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFyZ3MuaGVhZGVycywga2V5KSkge1xuXHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIGFyZ3MuaGVhZGVyc1trZXldKVxuXHRcdFx0fVxuXHRcdFx0aWYgKHR5cGVvZiBhcmdzLmNvbmZpZyA9PT0gXCJmdW5jdGlvblwiKSB4aHIgPSBhcmdzLmNvbmZpZyh4aHIsIGFyZ3MpIHx8IHhoclxuXHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBEb24ndCB0aHJvdyBlcnJvcnMgb24geGhyLmFib3J0KCkuXG5cdFx0XHRcdGlmKGFib3J0ZWQpIHJldHVyblxuXHRcdFx0XHRpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0dmFyIHJlc3BvbnNlID0gKGFyZ3MuZXh0cmFjdCAhPT0gZXh0cmFjdCkgPyBhcmdzLmV4dHJhY3QoeGhyLCBhcmdzKSA6IGFyZ3MuZGVzZXJpYWxpemUoYXJncy5leHRyYWN0KHhociwgYXJncykpXG5cdFx0XHRcdFx0XHRpZiAoKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDApIHx8IHhoci5zdGF0dXMgPT09IDMwNCB8fCBGSUxFX1BST1RPQ09MX1JFR0VYLnRlc3QoYXJncy51cmwpKSB7XG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoY2FzdChhcmdzLnR5cGUsIHJlc3BvbnNlKSlcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR2YXIgZXJyb3IgPSBuZXcgRXJyb3IoeGhyLnJlc3BvbnNlVGV4dClcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIga2V5IGluIHJlc3BvbnNlKSBlcnJvcltrZXldID0gcmVzcG9uc2Vba2V5XVxuXHRcdFx0XHRcdFx0XHRyZWplY3QoZXJyb3IpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0XHRyZWplY3QoZSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICh1c2VCb2R5ICYmIChhcmdzLmRhdGEgIT0gbnVsbCkpIHhoci5zZW5kKGFyZ3MuZGF0YSlcblx0XHRcdGVsc2UgeGhyLnNlbmQoKVxuXHRcdH0pXG5cdFx0cmV0dXJuIGFyZ3MuYmFja2dyb3VuZCA9PT0gdHJ1ZSA/IHByb21pc2UwIDogZmluYWxpemUocHJvbWlzZTApXG5cdH1cblx0ZnVuY3Rpb24ganNvbnAoYXJncywgZXh0cmEpIHtcblx0XHR2YXIgZmluYWxpemUgPSBmaW5hbGl6ZXIoKVxuXHRcdGFyZ3MgPSBub3JtYWxpemUoYXJncywgZXh0cmEpXG5cdFx0dmFyIHByb21pc2UwID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0XHR2YXIgY2FsbGJhY2tOYW1lID0gYXJncy5jYWxsYmFja05hbWUgfHwgXCJfbWl0aHJpbF9cIiArIE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDFlMTYpICsgXCJfXCIgKyBjYWxsYmFja0NvdW50Kytcblx0XHRcdHZhciBzY3JpcHQgPSAkd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIilcblx0XHRcdCR3aW5kb3dbY2FsbGJhY2tOYW1lXSA9IGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdFx0c2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KVxuXHRcdFx0XHRyZXNvbHZlKGNhc3QoYXJncy50eXBlLCBkYXRhKSlcblx0XHRcdFx0ZGVsZXRlICR3aW5kb3dbY2FsbGJhY2tOYW1lXVxuXHRcdFx0fVxuXHRcdFx0c2NyaXB0Lm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KVxuXHRcdFx0XHRyZWplY3QobmV3IEVycm9yKFwiSlNPTlAgcmVxdWVzdCBmYWlsZWRcIikpXG5cdFx0XHRcdGRlbGV0ZSAkd2luZG93W2NhbGxiYWNrTmFtZV1cblx0XHRcdH1cblx0XHRcdGlmIChhcmdzLmRhdGEgPT0gbnVsbCkgYXJncy5kYXRhID0ge31cblx0XHRcdGFyZ3MudXJsID0gaW50ZXJwb2xhdGUoYXJncy51cmwsIGFyZ3MuZGF0YSlcblx0XHRcdGFyZ3MuZGF0YVthcmdzLmNhbGxiYWNrS2V5IHx8IFwiY2FsbGJhY2tcIl0gPSBjYWxsYmFja05hbWVcblx0XHRcdHNjcmlwdC5zcmMgPSBhc3NlbWJsZShhcmdzLnVybCwgYXJncy5kYXRhKVxuXHRcdFx0JHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoc2NyaXB0KVxuXHRcdH0pXG5cdFx0cmV0dXJuIGFyZ3MuYmFja2dyb3VuZCA9PT0gdHJ1ZT8gcHJvbWlzZTAgOiBmaW5hbGl6ZShwcm9taXNlMClcblx0fVxuXHRmdW5jdGlvbiBpbnRlcnBvbGF0ZSh1cmwsIGRhdGEpIHtcblx0XHRpZiAoZGF0YSA9PSBudWxsKSByZXR1cm4gdXJsXG5cdFx0dmFyIHRva2VucyA9IHVybC5tYXRjaCgvOlteXFwvXSsvZ2kpIHx8IFtdXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBrZXkgPSB0b2tlbnNbaV0uc2xpY2UoMSlcblx0XHRcdGlmIChkYXRhW2tleV0gIT0gbnVsbCkge1xuXHRcdFx0XHR1cmwgPSB1cmwucmVwbGFjZSh0b2tlbnNbaV0sIGRhdGFba2V5XSlcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHVybFxuXHR9XG5cdGZ1bmN0aW9uIGFzc2VtYmxlKHVybCwgZGF0YSkge1xuXHRcdHZhciBxdWVyeXN0cmluZyA9IGJ1aWxkUXVlcnlTdHJpbmcoZGF0YSlcblx0XHRpZiAocXVlcnlzdHJpbmcgIT09IFwiXCIpIHtcblx0XHRcdHZhciBwcmVmaXggPSB1cmwuaW5kZXhPZihcIj9cIikgPCAwID8gXCI/XCIgOiBcIiZcIlxuXHRcdFx0dXJsICs9IHByZWZpeCArIHF1ZXJ5c3RyaW5nXG5cdFx0fVxuXHRcdHJldHVybiB1cmxcblx0fVxuXHRmdW5jdGlvbiBkZXNlcmlhbGl6ZShkYXRhKSB7XG5cdFx0dHJ5IHtyZXR1cm4gZGF0YSAhPT0gXCJcIiA/IEpTT04ucGFyc2UoZGF0YSkgOiBudWxsfVxuXHRcdGNhdGNoIChlKSB7dGhyb3cgbmV3IEVycm9yKGRhdGEpfVxuXHR9XG5cdGZ1bmN0aW9uIGV4dHJhY3QoeGhyKSB7cmV0dXJuIHhoci5yZXNwb25zZVRleHR9XG5cdGZ1bmN0aW9uIGNhc3QodHlwZTAsIGRhdGEpIHtcblx0XHRpZiAodHlwZW9mIHR5cGUwID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGRhdGFbaV0gPSBuZXcgdHlwZTAoZGF0YVtpXSlcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSByZXR1cm4gbmV3IHR5cGUwKGRhdGEpXG5cdFx0fVxuXHRcdHJldHVybiBkYXRhXG5cdH1cblx0cmV0dXJuIHtyZXF1ZXN0OiByZXF1ZXN0LCBqc29ucDoganNvbnAsIHNldENvbXBsZXRpb25DYWxsYmFjazogc2V0Q29tcGxldGlvbkNhbGxiYWNrfVxufVxudmFyIHJlcXVlc3RTZXJ2aWNlID0gXzgod2luZG93LCBQcm9taXNlUG9seWZpbGwpXG52YXIgY29yZVJlbmRlcmVyID0gZnVuY3Rpb24oJHdpbmRvdykge1xuXHR2YXIgJGRvYyA9ICR3aW5kb3cuZG9jdW1lbnRcblx0dmFyICRlbXB0eUZyYWdtZW50ID0gJGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcblx0dmFyIG5hbWVTcGFjZSA9IHtcblx0XHRzdmc6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcblx0XHRtYXRoOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIlxuXHR9XG5cdHZhciBvbmV2ZW50XG5cdGZ1bmN0aW9uIHNldEV2ZW50Q2FsbGJhY2soY2FsbGJhY2spIHtyZXR1cm4gb25ldmVudCA9IGNhbGxiYWNrfVxuXHRmdW5jdGlvbiBnZXROYW1lU3BhY2Uodm5vZGUpIHtcblx0XHRyZXR1cm4gdm5vZGUuYXR0cnMgJiYgdm5vZGUuYXR0cnMueG1sbnMgfHwgbmFtZVNwYWNlW3Zub2RlLnRhZ11cblx0fVxuXHQvL2NyZWF0ZVxuXHRmdW5jdGlvbiBjcmVhdGVOb2RlcyhwYXJlbnQsIHZub2Rlcywgc3RhcnQsIGVuZCwgaG9va3MsIG5leHRTaWJsaW5nLCBucykge1xuXHRcdGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG5cdFx0XHR2YXIgdm5vZGUgPSB2bm9kZXNbaV1cblx0XHRcdGlmICh2bm9kZSAhPSBudWxsKSB7XG5cdFx0XHRcdGNyZWF0ZU5vZGUocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlTm9kZShwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKSB7XG5cdFx0dmFyIHRhZyA9IHZub2RlLnRhZ1xuXHRcdGlmICh0eXBlb2YgdGFnID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHR2bm9kZS5zdGF0ZSA9IHt9XG5cdFx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCkgaW5pdExpZmVjeWNsZSh2bm9kZS5hdHRycywgdm5vZGUsIGhvb2tzKVxuXHRcdFx0c3dpdGNoICh0YWcpIHtcblx0XHRcdFx0Y2FzZSBcIiNcIjogcmV0dXJuIGNyZWF0ZVRleHQocGFyZW50LCB2bm9kZSwgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdGNhc2UgXCI8XCI6IHJldHVybiBjcmVhdGVIVE1MKHBhcmVudCwgdm5vZGUsIG5leHRTaWJsaW5nKVxuXHRcdFx0XHRjYXNlIFwiW1wiOiByZXR1cm4gY3JlYXRlRnJhZ21lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdFx0ZGVmYXVsdDogcmV0dXJuIGNyZWF0ZUVsZW1lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSByZXR1cm4gY3JlYXRlQ29tcG9uZW50KHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlVGV4dChwYXJlbnQsIHZub2RlLCBuZXh0U2libGluZykge1xuXHRcdHZub2RlLmRvbSA9ICRkb2MuY3JlYXRlVGV4dE5vZGUodm5vZGUuY2hpbGRyZW4pXG5cdFx0aW5zZXJ0Tm9kZShwYXJlbnQsIHZub2RlLmRvbSwgbmV4dFNpYmxpbmcpXG5cdFx0cmV0dXJuIHZub2RlLmRvbVxuXHR9XG5cdGZ1bmN0aW9uIGNyZWF0ZUhUTUwocGFyZW50LCB2bm9kZSwgbmV4dFNpYmxpbmcpIHtcblx0XHR2YXIgbWF0Y2gxID0gdm5vZGUuY2hpbGRyZW4ubWF0Y2goL15cXHMqPzwoXFx3KykvaW0pIHx8IFtdXG5cdFx0dmFyIHBhcmVudDEgPSB7Y2FwdGlvbjogXCJ0YWJsZVwiLCB0aGVhZDogXCJ0YWJsZVwiLCB0Ym9keTogXCJ0YWJsZVwiLCB0Zm9vdDogXCJ0YWJsZVwiLCB0cjogXCJ0Ym9keVwiLCB0aDogXCJ0clwiLCB0ZDogXCJ0clwiLCBjb2xncm91cDogXCJ0YWJsZVwiLCBjb2w6IFwiY29sZ3JvdXBcIn1bbWF0Y2gxWzFdXSB8fCBcImRpdlwiXG5cdFx0dmFyIHRlbXAgPSAkZG9jLmNyZWF0ZUVsZW1lbnQocGFyZW50MSlcblx0XHR0ZW1wLmlubmVySFRNTCA9IHZub2RlLmNoaWxkcmVuXG5cdFx0dm5vZGUuZG9tID0gdGVtcC5maXJzdENoaWxkXG5cdFx0dm5vZGUuZG9tU2l6ZSA9IHRlbXAuY2hpbGROb2Rlcy5sZW5ndGhcblx0XHR2YXIgZnJhZ21lbnQgPSAkZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuXHRcdHZhciBjaGlsZFxuXHRcdHdoaWxlIChjaGlsZCA9IHRlbXAuZmlyc3RDaGlsZCkge1xuXHRcdFx0ZnJhZ21lbnQuYXBwZW5kQ2hpbGQoY2hpbGQpXG5cdFx0fVxuXHRcdGluc2VydE5vZGUocGFyZW50LCBmcmFnbWVudCwgbmV4dFNpYmxpbmcpXG5cdFx0cmV0dXJuIGZyYWdtZW50XG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlRnJhZ21lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZykge1xuXHRcdHZhciBmcmFnbWVudCA9ICRkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG5cdFx0aWYgKHZub2RlLmNoaWxkcmVuICE9IG51bGwpIHtcblx0XHRcdHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuXG5cdFx0XHRjcmVhdGVOb2RlcyhmcmFnbWVudCwgY2hpbGRyZW4sIDAsIGNoaWxkcmVuLmxlbmd0aCwgaG9va3MsIG51bGwsIG5zKVxuXHRcdH1cblx0XHR2bm9kZS5kb20gPSBmcmFnbWVudC5maXJzdENoaWxkXG5cdFx0dm5vZGUuZG9tU2l6ZSA9IGZyYWdtZW50LmNoaWxkTm9kZXMubGVuZ3RoXG5cdFx0aW5zZXJ0Tm9kZShwYXJlbnQsIGZyYWdtZW50LCBuZXh0U2libGluZylcblx0XHRyZXR1cm4gZnJhZ21lbnRcblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVFbGVtZW50KHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpIHtcblx0XHR2YXIgdGFnID0gdm5vZGUudGFnXG5cdFx0dmFyIGF0dHJzMiA9IHZub2RlLmF0dHJzXG5cdFx0dmFyIGlzID0gYXR0cnMyICYmIGF0dHJzMi5pc1xuXHRcdG5zID0gZ2V0TmFtZVNwYWNlKHZub2RlKSB8fCBuc1xuXHRcdHZhciBlbGVtZW50ID0gbnMgP1xuXHRcdFx0aXMgPyAkZG9jLmNyZWF0ZUVsZW1lbnROUyhucywgdGFnLCB7aXM6IGlzfSkgOiAkZG9jLmNyZWF0ZUVsZW1lbnROUyhucywgdGFnKSA6XG5cdFx0XHRpcyA/ICRkb2MuY3JlYXRlRWxlbWVudCh0YWcsIHtpczogaXN9KSA6ICRkb2MuY3JlYXRlRWxlbWVudCh0YWcpXG5cdFx0dm5vZGUuZG9tID0gZWxlbWVudFxuXHRcdGlmIChhdHRyczIgIT0gbnVsbCkge1xuXHRcdFx0c2V0QXR0cnModm5vZGUsIGF0dHJzMiwgbnMpXG5cdFx0fVxuXHRcdGluc2VydE5vZGUocGFyZW50LCBlbGVtZW50LCBuZXh0U2libGluZylcblx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCAmJiB2bm9kZS5hdHRycy5jb250ZW50ZWRpdGFibGUgIT0gbnVsbCkge1xuXHRcdFx0c2V0Q29udGVudEVkaXRhYmxlKHZub2RlKVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGlmICh2bm9kZS50ZXh0ICE9IG51bGwpIHtcblx0XHRcdFx0aWYgKHZub2RlLnRleHQgIT09IFwiXCIpIGVsZW1lbnQudGV4dENvbnRlbnQgPSB2bm9kZS50ZXh0XG5cdFx0XHRcdGVsc2Ugdm5vZGUuY2hpbGRyZW4gPSBbVm5vZGUoXCIjXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB2bm9kZS50ZXh0LCB1bmRlZmluZWQsIHVuZGVmaW5lZCldXG5cdFx0XHR9XG5cdFx0XHRpZiAodm5vZGUuY2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0XHR2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlblxuXHRcdFx0XHRjcmVhdGVOb2RlcyhlbGVtZW50LCBjaGlsZHJlbiwgMCwgY2hpbGRyZW4ubGVuZ3RoLCBob29rcywgbnVsbCwgbnMpXG5cdFx0XHRcdHNldExhdGVBdHRycyh2bm9kZSlcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGVsZW1lbnRcblx0fVxuXHRmdW5jdGlvbiBpbml0Q29tcG9uZW50KHZub2RlLCBob29rcykge1xuXHRcdHZhciBzZW50aW5lbFxuXHRcdGlmICh0eXBlb2Ygdm5vZGUudGFnLnZpZXcgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0dm5vZGUuc3RhdGUgPSBPYmplY3QuY3JlYXRlKHZub2RlLnRhZylcblx0XHRcdHNlbnRpbmVsID0gdm5vZGUuc3RhdGUudmlld1xuXHRcdFx0aWYgKHNlbnRpbmVsLiQkcmVlbnRyYW50TG9jayQkICE9IG51bGwpIHJldHVybiAkZW1wdHlGcmFnbWVudFxuXHRcdFx0c2VudGluZWwuJCRyZWVudHJhbnRMb2NrJCQgPSB0cnVlXG5cdFx0fSBlbHNlIHtcblx0XHRcdHZub2RlLnN0YXRlID0gdm9pZCAwXG5cdFx0XHRzZW50aW5lbCA9IHZub2RlLnRhZ1xuXHRcdFx0aWYgKHNlbnRpbmVsLiQkcmVlbnRyYW50TG9jayQkICE9IG51bGwpIHJldHVybiAkZW1wdHlGcmFnbWVudFxuXHRcdFx0c2VudGluZWwuJCRyZWVudHJhbnRMb2NrJCQgPSB0cnVlXG5cdFx0XHR2bm9kZS5zdGF0ZSA9ICh2bm9kZS50YWcucHJvdG90eXBlICE9IG51bGwgJiYgdHlwZW9mIHZub2RlLnRhZy5wcm90b3R5cGUudmlldyA9PT0gXCJmdW5jdGlvblwiKSA/IG5ldyB2bm9kZS50YWcodm5vZGUpIDogdm5vZGUudGFnKHZub2RlKVxuXHRcdH1cblx0XHR2bm9kZS5fc3RhdGUgPSB2bm9kZS5zdGF0ZVxuXHRcdGlmICh2bm9kZS5hdHRycyAhPSBudWxsKSBpbml0TGlmZWN5Y2xlKHZub2RlLmF0dHJzLCB2bm9kZSwgaG9va3MpXG5cdFx0aW5pdExpZmVjeWNsZSh2bm9kZS5fc3RhdGUsIHZub2RlLCBob29rcylcblx0XHR2bm9kZS5pbnN0YW5jZSA9IFZub2RlLm5vcm1hbGl6ZSh2bm9kZS5fc3RhdGUudmlldy5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSkpXG5cdFx0aWYgKHZub2RlLmluc3RhbmNlID09PSB2bm9kZSkgdGhyb3cgRXJyb3IoXCJBIHZpZXcgY2Fubm90IHJldHVybiB0aGUgdm5vZGUgaXQgcmVjZWl2ZWQgYXMgYXJndW1lbnRcIilcblx0XHRzZW50aW5lbC4kJHJlZW50cmFudExvY2skJCA9IG51bGxcblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVDb21wb25lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZykge1xuXHRcdGluaXRDb21wb25lbnQodm5vZGUsIGhvb2tzKVxuXHRcdGlmICh2bm9kZS5pbnN0YW5jZSAhPSBudWxsKSB7XG5cdFx0XHR2YXIgZWxlbWVudCA9IGNyZWF0ZU5vZGUocGFyZW50LCB2bm9kZS5pbnN0YW5jZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdHZub2RlLmRvbSA9IHZub2RlLmluc3RhbmNlLmRvbVxuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IHZub2RlLmRvbSAhPSBudWxsID8gdm5vZGUuaW5zdGFuY2UuZG9tU2l6ZSA6IDBcblx0XHRcdGluc2VydE5vZGUocGFyZW50LCBlbGVtZW50LCBuZXh0U2libGluZylcblx0XHRcdHJldHVybiBlbGVtZW50XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IDBcblx0XHRcdHJldHVybiAkZW1wdHlGcmFnbWVudFxuXHRcdH1cblx0fVxuXHQvL3VwZGF0ZVxuXHRmdW5jdGlvbiB1cGRhdGVOb2RlcyhwYXJlbnQsIG9sZCwgdm5vZGVzLCByZWN5Y2xpbmcsIGhvb2tzLCBuZXh0U2libGluZywgbnMpIHtcblx0XHRpZiAob2xkID09PSB2bm9kZXMgfHwgb2xkID09IG51bGwgJiYgdm5vZGVzID09IG51bGwpIHJldHVyblxuXHRcdGVsc2UgaWYgKG9sZCA9PSBudWxsKSBjcmVhdGVOb2RlcyhwYXJlbnQsIHZub2RlcywgMCwgdm5vZGVzLmxlbmd0aCwgaG9va3MsIG5leHRTaWJsaW5nLCBucylcblx0XHRlbHNlIGlmICh2bm9kZXMgPT0gbnVsbCkgcmVtb3ZlTm9kZXMob2xkLCAwLCBvbGQubGVuZ3RoLCB2bm9kZXMpXG5cdFx0ZWxzZSB7XG5cdFx0XHRpZiAob2xkLmxlbmd0aCA9PT0gdm5vZGVzLmxlbmd0aCkge1xuXHRcdFx0XHR2YXIgaXNVbmtleWVkID0gZmFsc2Vcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB2bm9kZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRpZiAodm5vZGVzW2ldICE9IG51bGwgJiYgb2xkW2ldICE9IG51bGwpIHtcblx0XHRcdFx0XHRcdGlzVW5rZXllZCA9IHZub2Rlc1tpXS5rZXkgPT0gbnVsbCAmJiBvbGRbaV0ua2V5ID09IG51bGxcblx0XHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChpc1Vua2V5ZWQpIHtcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG9sZC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0aWYgKG9sZFtpXSA9PT0gdm5vZGVzW2ldKSBjb250aW51ZVxuXHRcdFx0XHRcdFx0ZWxzZSBpZiAob2xkW2ldID09IG51bGwgJiYgdm5vZGVzW2ldICE9IG51bGwpIGNyZWF0ZU5vZGUocGFyZW50LCB2bm9kZXNbaV0sIGhvb2tzLCBucywgZ2V0TmV4dFNpYmxpbmcob2xkLCBpICsgMSwgbmV4dFNpYmxpbmcpKVxuXHRcdFx0XHRcdFx0ZWxzZSBpZiAodm5vZGVzW2ldID09IG51bGwpIHJlbW92ZU5vZGVzKG9sZCwgaSwgaSArIDEsIHZub2Rlcylcblx0XHRcdFx0XHRcdGVsc2UgdXBkYXRlTm9kZShwYXJlbnQsIG9sZFtpXSwgdm5vZGVzW2ldLCBob29rcywgZ2V0TmV4dFNpYmxpbmcob2xkLCBpICsgMSwgbmV4dFNpYmxpbmcpLCByZWN5Y2xpbmcsIG5zKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmVjeWNsaW5nID0gcmVjeWNsaW5nIHx8IGlzUmVjeWNsYWJsZShvbGQsIHZub2Rlcylcblx0XHRcdGlmIChyZWN5Y2xpbmcpIHtcblx0XHRcdFx0dmFyIHBvb2wgPSBvbGQucG9vbFxuXHRcdFx0XHRvbGQgPSBvbGQuY29uY2F0KG9sZC5wb29sKVxuXHRcdFx0fVxuXHRcdFx0dmFyIG9sZFN0YXJ0ID0gMCwgc3RhcnQgPSAwLCBvbGRFbmQgPSBvbGQubGVuZ3RoIC0gMSwgZW5kID0gdm5vZGVzLmxlbmd0aCAtIDEsIG1hcFxuXHRcdFx0d2hpbGUgKG9sZEVuZCA+PSBvbGRTdGFydCAmJiBlbmQgPj0gc3RhcnQpIHtcblx0XHRcdFx0dmFyIG8gPSBvbGRbb2xkU3RhcnRdLCB2ID0gdm5vZGVzW3N0YXJ0XVxuXHRcdFx0XHRpZiAobyA9PT0gdiAmJiAhcmVjeWNsaW5nKSBvbGRTdGFydCsrLCBzdGFydCsrXG5cdFx0XHRcdGVsc2UgaWYgKG8gPT0gbnVsbCkgb2xkU3RhcnQrK1xuXHRcdFx0XHRlbHNlIGlmICh2ID09IG51bGwpIHN0YXJ0Kytcblx0XHRcdFx0ZWxzZSBpZiAoby5rZXkgPT09IHYua2V5KSB7XG5cdFx0XHRcdFx0dmFyIHNob3VsZFJlY3ljbGUgPSAocG9vbCAhPSBudWxsICYmIG9sZFN0YXJ0ID49IG9sZC5sZW5ndGggLSBwb29sLmxlbmd0aCkgfHwgKChwb29sID09IG51bGwpICYmIHJlY3ljbGluZylcblx0XHRcdFx0XHRvbGRTdGFydCsrLCBzdGFydCsrXG5cdFx0XHRcdFx0dXBkYXRlTm9kZShwYXJlbnQsIG8sIHYsIGhvb2tzLCBnZXROZXh0U2libGluZyhvbGQsIG9sZFN0YXJ0LCBuZXh0U2libGluZyksIHNob3VsZFJlY3ljbGUsIG5zKVxuXHRcdFx0XHRcdGlmIChyZWN5Y2xpbmcgJiYgby50YWcgPT09IHYudGFnKSBpbnNlcnROb2RlKHBhcmVudCwgdG9GcmFnbWVudChvKSwgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0dmFyIG8gPSBvbGRbb2xkRW5kXVxuXHRcdFx0XHRcdGlmIChvID09PSB2ICYmICFyZWN5Y2xpbmcpIG9sZEVuZC0tLCBzdGFydCsrXG5cdFx0XHRcdFx0ZWxzZSBpZiAobyA9PSBudWxsKSBvbGRFbmQtLVxuXHRcdFx0XHRcdGVsc2UgaWYgKHYgPT0gbnVsbCkgc3RhcnQrK1xuXHRcdFx0XHRcdGVsc2UgaWYgKG8ua2V5ID09PSB2LmtleSkge1xuXHRcdFx0XHRcdFx0dmFyIHNob3VsZFJlY3ljbGUgPSAocG9vbCAhPSBudWxsICYmIG9sZEVuZCA+PSBvbGQubGVuZ3RoIC0gcG9vbC5sZW5ndGgpIHx8ICgocG9vbCA9PSBudWxsKSAmJiByZWN5Y2xpbmcpXG5cdFx0XHRcdFx0XHR1cGRhdGVOb2RlKHBhcmVudCwgbywgdiwgaG9va3MsIGdldE5leHRTaWJsaW5nKG9sZCwgb2xkRW5kICsgMSwgbmV4dFNpYmxpbmcpLCBzaG91bGRSZWN5Y2xlLCBucylcblx0XHRcdFx0XHRcdGlmIChyZWN5Y2xpbmcgfHwgc3RhcnQgPCBlbmQpIGluc2VydE5vZGUocGFyZW50LCB0b0ZyYWdtZW50KG8pLCBnZXROZXh0U2libGluZyhvbGQsIG9sZFN0YXJ0LCBuZXh0U2libGluZykpXG5cdFx0XHRcdFx0XHRvbGRFbmQtLSwgc3RhcnQrK1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIGJyZWFrXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHdoaWxlIChvbGRFbmQgPj0gb2xkU3RhcnQgJiYgZW5kID49IHN0YXJ0KSB7XG5cdFx0XHRcdHZhciBvID0gb2xkW29sZEVuZF0sIHYgPSB2bm9kZXNbZW5kXVxuXHRcdFx0XHRpZiAobyA9PT0gdiAmJiAhcmVjeWNsaW5nKSBvbGRFbmQtLSwgZW5kLS1cblx0XHRcdFx0ZWxzZSBpZiAobyA9PSBudWxsKSBvbGRFbmQtLVxuXHRcdFx0XHRlbHNlIGlmICh2ID09IG51bGwpIGVuZC0tXG5cdFx0XHRcdGVsc2UgaWYgKG8ua2V5ID09PSB2LmtleSkge1xuXHRcdFx0XHRcdHZhciBzaG91bGRSZWN5Y2xlID0gKHBvb2wgIT0gbnVsbCAmJiBvbGRFbmQgPj0gb2xkLmxlbmd0aCAtIHBvb2wubGVuZ3RoKSB8fCAoKHBvb2wgPT0gbnVsbCkgJiYgcmVjeWNsaW5nKVxuXHRcdFx0XHRcdHVwZGF0ZU5vZGUocGFyZW50LCBvLCB2LCBob29rcywgZ2V0TmV4dFNpYmxpbmcob2xkLCBvbGRFbmQgKyAxLCBuZXh0U2libGluZyksIHNob3VsZFJlY3ljbGUsIG5zKVxuXHRcdFx0XHRcdGlmIChyZWN5Y2xpbmcgJiYgby50YWcgPT09IHYudGFnKSBpbnNlcnROb2RlKHBhcmVudCwgdG9GcmFnbWVudChvKSwgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdFx0aWYgKG8uZG9tICE9IG51bGwpIG5leHRTaWJsaW5nID0gby5kb21cblx0XHRcdFx0XHRvbGRFbmQtLSwgZW5kLS1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRpZiAoIW1hcCkgbWFwID0gZ2V0S2V5TWFwKG9sZCwgb2xkRW5kKVxuXHRcdFx0XHRcdGlmICh2ICE9IG51bGwpIHtcblx0XHRcdFx0XHRcdHZhciBvbGRJbmRleCA9IG1hcFt2LmtleV1cblx0XHRcdFx0XHRcdGlmIChvbGRJbmRleCAhPSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBtb3ZhYmxlID0gb2xkW29sZEluZGV4XVxuXHRcdFx0XHRcdFx0XHR2YXIgc2hvdWxkUmVjeWNsZSA9IChwb29sICE9IG51bGwgJiYgb2xkSW5kZXggPj0gb2xkLmxlbmd0aCAtIHBvb2wubGVuZ3RoKSB8fCAoKHBvb2wgPT0gbnVsbCkgJiYgcmVjeWNsaW5nKVxuXHRcdFx0XHRcdFx0XHR1cGRhdGVOb2RlKHBhcmVudCwgbW92YWJsZSwgdiwgaG9va3MsIGdldE5leHRTaWJsaW5nKG9sZCwgb2xkRW5kICsgMSwgbmV4dFNpYmxpbmcpLCByZWN5Y2xpbmcsIG5zKVxuXHRcdFx0XHRcdFx0XHRpbnNlcnROb2RlKHBhcmVudCwgdG9GcmFnbWVudChtb3ZhYmxlKSwgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdFx0XHRcdG9sZFtvbGRJbmRleF0uc2tpcCA9IHRydWVcblx0XHRcdFx0XHRcdFx0aWYgKG1vdmFibGUuZG9tICE9IG51bGwpIG5leHRTaWJsaW5nID0gbW92YWJsZS5kb21cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR2YXIgZG9tID0gY3JlYXRlTm9kZShwYXJlbnQsIHYsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdFx0XHRcdG5leHRTaWJsaW5nID0gZG9tXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVuZC0tXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGVuZCA8IHN0YXJ0KSBicmVha1xuXHRcdFx0fVxuXHRcdFx0Y3JlYXRlTm9kZXMocGFyZW50LCB2bm9kZXMsIHN0YXJ0LCBlbmQgKyAxLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKVxuXHRcdFx0cmVtb3ZlTm9kZXMob2xkLCBvbGRTdGFydCwgb2xkRW5kICsgMSwgdm5vZGVzKVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVOb2RlKHBhcmVudCwgb2xkLCB2bm9kZSwgaG9va3MsIG5leHRTaWJsaW5nLCByZWN5Y2xpbmcsIG5zKSB7XG5cdFx0dmFyIG9sZFRhZyA9IG9sZC50YWcsIHRhZyA9IHZub2RlLnRhZ1xuXHRcdGlmIChvbGRUYWcgPT09IHRhZykge1xuXHRcdFx0dm5vZGUuc3RhdGUgPSBvbGQuc3RhdGVcblx0XHRcdHZub2RlLl9zdGF0ZSA9IG9sZC5fc3RhdGVcblx0XHRcdHZub2RlLmV2ZW50cyA9IG9sZC5ldmVudHNcblx0XHRcdGlmICghcmVjeWNsaW5nICYmIHNob3VsZE5vdFVwZGF0ZSh2bm9kZSwgb2xkKSkgcmV0dXJuXG5cdFx0XHRpZiAodHlwZW9mIG9sZFRhZyA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCkge1xuXHRcdFx0XHRcdGlmIChyZWN5Y2xpbmcpIHtcblx0XHRcdFx0XHRcdHZub2RlLnN0YXRlID0ge31cblx0XHRcdFx0XHRcdGluaXRMaWZlY3ljbGUodm5vZGUuYXR0cnMsIHZub2RlLCBob29rcylcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB1cGRhdGVMaWZlY3ljbGUodm5vZGUuYXR0cnMsIHZub2RlLCBob29rcylcblx0XHRcdFx0fVxuXHRcdFx0XHRzd2l0Y2ggKG9sZFRhZykge1xuXHRcdFx0XHRcdGNhc2UgXCIjXCI6IHVwZGF0ZVRleHQob2xkLCB2bm9kZSk7IGJyZWFrXG5cdFx0XHRcdFx0Y2FzZSBcIjxcIjogdXBkYXRlSFRNTChwYXJlbnQsIG9sZCwgdm5vZGUsIG5leHRTaWJsaW5nKTsgYnJlYWtcblx0XHRcdFx0XHRjYXNlIFwiW1wiOiB1cGRhdGVGcmFnbWVudChwYXJlbnQsIG9sZCwgdm5vZGUsIHJlY3ljbGluZywgaG9va3MsIG5leHRTaWJsaW5nLCBucyk7IGJyZWFrXG5cdFx0XHRcdFx0ZGVmYXVsdDogdXBkYXRlRWxlbWVudChvbGQsIHZub2RlLCByZWN5Y2xpbmcsIGhvb2tzLCBucylcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSB1cGRhdGVDb21wb25lbnQocGFyZW50LCBvbGQsIHZub2RlLCBob29rcywgbmV4dFNpYmxpbmcsIHJlY3ljbGluZywgbnMpXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0cmVtb3ZlTm9kZShvbGQsIG51bGwpXG5cdFx0XHRjcmVhdGVOb2RlKHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZVRleHQob2xkLCB2bm9kZSkge1xuXHRcdGlmIChvbGQuY2hpbGRyZW4udG9TdHJpbmcoKSAhPT0gdm5vZGUuY2hpbGRyZW4udG9TdHJpbmcoKSkge1xuXHRcdFx0b2xkLmRvbS5ub2RlVmFsdWUgPSB2bm9kZS5jaGlsZHJlblxuXHRcdH1cblx0XHR2bm9kZS5kb20gPSBvbGQuZG9tXG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlSFRNTChwYXJlbnQsIG9sZCwgdm5vZGUsIG5leHRTaWJsaW5nKSB7XG5cdFx0aWYgKG9sZC5jaGlsZHJlbiAhPT0gdm5vZGUuY2hpbGRyZW4pIHtcblx0XHRcdHRvRnJhZ21lbnQob2xkKVxuXHRcdFx0Y3JlYXRlSFRNTChwYXJlbnQsIHZub2RlLCBuZXh0U2libGluZylcblx0XHR9XG5cdFx0ZWxzZSB2bm9kZS5kb20gPSBvbGQuZG9tLCB2bm9kZS5kb21TaXplID0gb2xkLmRvbVNpemVcblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVGcmFnbWVudChwYXJlbnQsIG9sZCwgdm5vZGUsIHJlY3ljbGluZywgaG9va3MsIG5leHRTaWJsaW5nLCBucykge1xuXHRcdHVwZGF0ZU5vZGVzKHBhcmVudCwgb2xkLmNoaWxkcmVuLCB2bm9kZS5jaGlsZHJlbiwgcmVjeWNsaW5nLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKVxuXHRcdHZhciBkb21TaXplID0gMCwgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlblxuXHRcdHZub2RlLmRvbSA9IG51bGxcblx0XHRpZiAoY2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgY2hpbGQgPSBjaGlsZHJlbltpXVxuXHRcdFx0XHRpZiAoY2hpbGQgIT0gbnVsbCAmJiBjaGlsZC5kb20gIT0gbnVsbCkge1xuXHRcdFx0XHRcdGlmICh2bm9kZS5kb20gPT0gbnVsbCkgdm5vZGUuZG9tID0gY2hpbGQuZG9tXG5cdFx0XHRcdFx0ZG9tU2l6ZSArPSBjaGlsZC5kb21TaXplIHx8IDFcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGRvbVNpemUgIT09IDEpIHZub2RlLmRvbVNpemUgPSBkb21TaXplXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUVsZW1lbnQob2xkLCB2bm9kZSwgcmVjeWNsaW5nLCBob29rcywgbnMpIHtcblx0XHR2YXIgZWxlbWVudCA9IHZub2RlLmRvbSA9IG9sZC5kb21cblx0XHRucyA9IGdldE5hbWVTcGFjZSh2bm9kZSkgfHwgbnNcblx0XHRpZiAodm5vZGUudGFnID09PSBcInRleHRhcmVhXCIpIHtcblx0XHRcdGlmICh2bm9kZS5hdHRycyA9PSBudWxsKSB2bm9kZS5hdHRycyA9IHt9XG5cdFx0XHRpZiAodm5vZGUudGV4dCAhPSBudWxsKSB7XG5cdFx0XHRcdHZub2RlLmF0dHJzLnZhbHVlID0gdm5vZGUudGV4dCAvL0ZJWE1FIGhhbmRsZTAgbXVsdGlwbGUgY2hpbGRyZW5cblx0XHRcdFx0dm5vZGUudGV4dCA9IHVuZGVmaW5lZFxuXHRcdFx0fVxuXHRcdH1cblx0XHR1cGRhdGVBdHRycyh2bm9kZSwgb2xkLmF0dHJzLCB2bm9kZS5hdHRycywgbnMpXG5cdFx0aWYgKHZub2RlLmF0dHJzICE9IG51bGwgJiYgdm5vZGUuYXR0cnMuY29udGVudGVkaXRhYmxlICE9IG51bGwpIHtcblx0XHRcdHNldENvbnRlbnRFZGl0YWJsZSh2bm9kZSlcblx0XHR9XG5cdFx0ZWxzZSBpZiAob2xkLnRleHQgIT0gbnVsbCAmJiB2bm9kZS50ZXh0ICE9IG51bGwgJiYgdm5vZGUudGV4dCAhPT0gXCJcIikge1xuXHRcdFx0aWYgKG9sZC50ZXh0LnRvU3RyaW5nKCkgIT09IHZub2RlLnRleHQudG9TdHJpbmcoKSkgb2xkLmRvbS5maXJzdENoaWxkLm5vZGVWYWx1ZSA9IHZub2RlLnRleHRcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRpZiAob2xkLnRleHQgIT0gbnVsbCkgb2xkLmNoaWxkcmVuID0gW1Zub2RlKFwiI1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgb2xkLnRleHQsIHVuZGVmaW5lZCwgb2xkLmRvbS5maXJzdENoaWxkKV1cblx0XHRcdGlmICh2bm9kZS50ZXh0ICE9IG51bGwpIHZub2RlLmNoaWxkcmVuID0gW1Zub2RlKFwiI1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdm5vZGUudGV4dCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXVxuXHRcdFx0dXBkYXRlTm9kZXMoZWxlbWVudCwgb2xkLmNoaWxkcmVuLCB2bm9kZS5jaGlsZHJlbiwgcmVjeWNsaW5nLCBob29rcywgbnVsbCwgbnMpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUNvbXBvbmVudChwYXJlbnQsIG9sZCwgdm5vZGUsIGhvb2tzLCBuZXh0U2libGluZywgcmVjeWNsaW5nLCBucykge1xuXHRcdGlmIChyZWN5Y2xpbmcpIHtcblx0XHRcdGluaXRDb21wb25lbnQodm5vZGUsIGhvb2tzKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2bm9kZS5pbnN0YW5jZSA9IFZub2RlLm5vcm1hbGl6ZSh2bm9kZS5fc3RhdGUudmlldy5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSkpXG5cdFx0XHRpZiAodm5vZGUuaW5zdGFuY2UgPT09IHZub2RlKSB0aHJvdyBFcnJvcihcIkEgdmlldyBjYW5ub3QgcmV0dXJuIHRoZSB2bm9kZSBpdCByZWNlaXZlZCBhcyBhcmd1bWVudFwiKVxuXHRcdFx0aWYgKHZub2RlLmF0dHJzICE9IG51bGwpIHVwZGF0ZUxpZmVjeWNsZSh2bm9kZS5hdHRycywgdm5vZGUsIGhvb2tzKVxuXHRcdFx0dXBkYXRlTGlmZWN5Y2xlKHZub2RlLl9zdGF0ZSwgdm5vZGUsIGhvb2tzKVxuXHRcdH1cblx0XHRpZiAodm5vZGUuaW5zdGFuY2UgIT0gbnVsbCkge1xuXHRcdFx0aWYgKG9sZC5pbnN0YW5jZSA9PSBudWxsKSBjcmVhdGVOb2RlKHBhcmVudCwgdm5vZGUuaW5zdGFuY2UsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0XHRlbHNlIHVwZGF0ZU5vZGUocGFyZW50LCBvbGQuaW5zdGFuY2UsIHZub2RlLmluc3RhbmNlLCBob29rcywgbmV4dFNpYmxpbmcsIHJlY3ljbGluZywgbnMpXG5cdFx0XHR2bm9kZS5kb20gPSB2bm9kZS5pbnN0YW5jZS5kb21cblx0XHRcdHZub2RlLmRvbVNpemUgPSB2bm9kZS5pbnN0YW5jZS5kb21TaXplXG5cdFx0fVxuXHRcdGVsc2UgaWYgKG9sZC5pbnN0YW5jZSAhPSBudWxsKSB7XG5cdFx0XHRyZW1vdmVOb2RlKG9sZC5pbnN0YW5jZSwgbnVsbClcblx0XHRcdHZub2RlLmRvbSA9IHVuZGVmaW5lZFxuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IDBcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHR2bm9kZS5kb20gPSBvbGQuZG9tXG5cdFx0XHR2bm9kZS5kb21TaXplID0gb2xkLmRvbVNpemVcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gaXNSZWN5Y2xhYmxlKG9sZCwgdm5vZGVzKSB7XG5cdFx0aWYgKG9sZC5wb29sICE9IG51bGwgJiYgTWF0aC5hYnMob2xkLnBvb2wubGVuZ3RoIC0gdm5vZGVzLmxlbmd0aCkgPD0gTWF0aC5hYnMob2xkLmxlbmd0aCAtIHZub2Rlcy5sZW5ndGgpKSB7XG5cdFx0XHR2YXIgb2xkQ2hpbGRyZW5MZW5ndGggPSBvbGRbMF0gJiYgb2xkWzBdLmNoaWxkcmVuICYmIG9sZFswXS5jaGlsZHJlbi5sZW5ndGggfHwgMFxuXHRcdFx0dmFyIHBvb2xDaGlsZHJlbkxlbmd0aCA9IG9sZC5wb29sWzBdICYmIG9sZC5wb29sWzBdLmNoaWxkcmVuICYmIG9sZC5wb29sWzBdLmNoaWxkcmVuLmxlbmd0aCB8fCAwXG5cdFx0XHR2YXIgdm5vZGVzQ2hpbGRyZW5MZW5ndGggPSB2bm9kZXNbMF0gJiYgdm5vZGVzWzBdLmNoaWxkcmVuICYmIHZub2Rlc1swXS5jaGlsZHJlbi5sZW5ndGggfHwgMFxuXHRcdFx0aWYgKE1hdGguYWJzKHBvb2xDaGlsZHJlbkxlbmd0aCAtIHZub2Rlc0NoaWxkcmVuTGVuZ3RoKSA8PSBNYXRoLmFicyhvbGRDaGlsZHJlbkxlbmd0aCAtIHZub2Rlc0NoaWxkcmVuTGVuZ3RoKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2Vcblx0fVxuXHRmdW5jdGlvbiBnZXRLZXlNYXAodm5vZGVzLCBlbmQpIHtcblx0XHR2YXIgbWFwID0ge30sIGkgPSAwXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBlbmQ7IGkrKykge1xuXHRcdFx0dmFyIHZub2RlID0gdm5vZGVzW2ldXG5cdFx0XHRpZiAodm5vZGUgIT0gbnVsbCkge1xuXHRcdFx0XHR2YXIga2V5MiA9IHZub2RlLmtleVxuXHRcdFx0XHRpZiAoa2V5MiAhPSBudWxsKSBtYXBba2V5Ml0gPSBpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBtYXBcblx0fVxuXHRmdW5jdGlvbiB0b0ZyYWdtZW50KHZub2RlKSB7XG5cdFx0dmFyIGNvdW50MCA9IHZub2RlLmRvbVNpemVcblx0XHRpZiAoY291bnQwICE9IG51bGwgfHwgdm5vZGUuZG9tID09IG51bGwpIHtcblx0XHRcdHZhciBmcmFnbWVudCA9ICRkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG5cdFx0XHRpZiAoY291bnQwID4gMCkge1xuXHRcdFx0XHR2YXIgZG9tID0gdm5vZGUuZG9tXG5cdFx0XHRcdHdoaWxlICgtLWNvdW50MCkgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZG9tLm5leHRTaWJsaW5nKVxuXHRcdFx0XHRmcmFnbWVudC5pbnNlcnRCZWZvcmUoZG9tLCBmcmFnbWVudC5maXJzdENoaWxkKVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZyYWdtZW50XG5cdFx0fVxuXHRcdGVsc2UgcmV0dXJuIHZub2RlLmRvbVxuXHR9XG5cdGZ1bmN0aW9uIGdldE5leHRTaWJsaW5nKHZub2RlcywgaSwgbmV4dFNpYmxpbmcpIHtcblx0XHRmb3IgKDsgaSA8IHZub2Rlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKHZub2Rlc1tpXSAhPSBudWxsICYmIHZub2Rlc1tpXS5kb20gIT0gbnVsbCkgcmV0dXJuIHZub2Rlc1tpXS5kb21cblx0XHR9XG5cdFx0cmV0dXJuIG5leHRTaWJsaW5nXG5cdH1cblx0ZnVuY3Rpb24gaW5zZXJ0Tm9kZShwYXJlbnQsIGRvbSwgbmV4dFNpYmxpbmcpIHtcblx0XHRpZiAobmV4dFNpYmxpbmcgJiYgbmV4dFNpYmxpbmcucGFyZW50Tm9kZSkgcGFyZW50Lmluc2VydEJlZm9yZShkb20sIG5leHRTaWJsaW5nKVxuXHRcdGVsc2UgcGFyZW50LmFwcGVuZENoaWxkKGRvbSlcblx0fVxuXHRmdW5jdGlvbiBzZXRDb250ZW50RWRpdGFibGUodm5vZGUpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlblxuXHRcdGlmIChjaGlsZHJlbiAhPSBudWxsICYmIGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBjaGlsZHJlblswXS50YWcgPT09IFwiPFwiKSB7XG5cdFx0XHR2YXIgY29udGVudCA9IGNoaWxkcmVuWzBdLmNoaWxkcmVuXG5cdFx0XHRpZiAodm5vZGUuZG9tLmlubmVySFRNTCAhPT0gY29udGVudCkgdm5vZGUuZG9tLmlubmVySFRNTCA9IGNvbnRlbnRcblx0XHR9XG5cdFx0ZWxzZSBpZiAodm5vZGUudGV4dCAhPSBudWxsIHx8IGNoaWxkcmVuICE9IG51bGwgJiYgY2hpbGRyZW4ubGVuZ3RoICE9PSAwKSB0aHJvdyBuZXcgRXJyb3IoXCJDaGlsZCBub2RlIG9mIGEgY29udGVudGVkaXRhYmxlIG11c3QgYmUgdHJ1c3RlZFwiKVxuXHR9XG5cdC8vcmVtb3ZlXG5cdGZ1bmN0aW9uIHJlbW92ZU5vZGVzKHZub2Rlcywgc3RhcnQsIGVuZCwgY29udGV4dCkge1xuXHRcdGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG5cdFx0XHR2YXIgdm5vZGUgPSB2bm9kZXNbaV1cblx0XHRcdGlmICh2bm9kZSAhPSBudWxsKSB7XG5cdFx0XHRcdGlmICh2bm9kZS5za2lwKSB2bm9kZS5za2lwID0gZmFsc2Vcblx0XHRcdFx0ZWxzZSByZW1vdmVOb2RlKHZub2RlLCBjb250ZXh0KVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiByZW1vdmVOb2RlKHZub2RlLCBjb250ZXh0KSB7XG5cdFx0dmFyIGV4cGVjdGVkID0gMSwgY2FsbGVkID0gMFxuXHRcdGlmICh2bm9kZS5hdHRycyAmJiB0eXBlb2Ygdm5vZGUuYXR0cnMub25iZWZvcmVyZW1vdmUgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0dmFyIHJlc3VsdCA9IHZub2RlLmF0dHJzLm9uYmVmb3JlcmVtb3ZlLmNhbGwodm5vZGUuc3RhdGUsIHZub2RlKVxuXHRcdFx0aWYgKHJlc3VsdCAhPSBudWxsICYmIHR5cGVvZiByZXN1bHQudGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdGV4cGVjdGVkKytcblx0XHRcdFx0cmVzdWx0LnRoZW4oY29udGludWF0aW9uLCBjb250aW51YXRpb24pXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICh0eXBlb2Ygdm5vZGUudGFnICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiB2bm9kZS5fc3RhdGUub25iZWZvcmVyZW1vdmUgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0dmFyIHJlc3VsdCA9IHZub2RlLl9zdGF0ZS5vbmJlZm9yZXJlbW92ZS5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSlcblx0XHRcdGlmIChyZXN1bHQgIT0gbnVsbCAmJiB0eXBlb2YgcmVzdWx0LnRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRleHBlY3RlZCsrXG5cdFx0XHRcdHJlc3VsdC50aGVuKGNvbnRpbnVhdGlvbiwgY29udGludWF0aW9uKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRjb250aW51YXRpb24oKVxuXHRcdGZ1bmN0aW9uIGNvbnRpbnVhdGlvbigpIHtcblx0XHRcdGlmICgrK2NhbGxlZCA9PT0gZXhwZWN0ZWQpIHtcblx0XHRcdFx0b25yZW1vdmUodm5vZGUpXG5cdFx0XHRcdGlmICh2bm9kZS5kb20pIHtcblx0XHRcdFx0XHR2YXIgY291bnQwID0gdm5vZGUuZG9tU2l6ZSB8fCAxXG5cdFx0XHRcdFx0aWYgKGNvdW50MCA+IDEpIHtcblx0XHRcdFx0XHRcdHZhciBkb20gPSB2bm9kZS5kb21cblx0XHRcdFx0XHRcdHdoaWxlICgtLWNvdW50MCkge1xuXHRcdFx0XHRcdFx0XHRyZW1vdmVOb2RlRnJvbURPTShkb20ubmV4dFNpYmxpbmcpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJlbW92ZU5vZGVGcm9tRE9NKHZub2RlLmRvbSlcblx0XHRcdFx0XHRpZiAoY29udGV4dCAhPSBudWxsICYmIHZub2RlLmRvbVNpemUgPT0gbnVsbCAmJiAhaGFzSW50ZWdyYXRpb25NZXRob2RzKHZub2RlLmF0dHJzKSAmJiB0eXBlb2Ygdm5vZGUudGFnID09PSBcInN0cmluZ1wiKSB7IC8vVE9ETyB0ZXN0IGN1c3RvbSBlbGVtZW50c1xuXHRcdFx0XHRcdFx0aWYgKCFjb250ZXh0LnBvb2wpIGNvbnRleHQucG9vbCA9IFt2bm9kZV1cblx0XHRcdFx0XHRcdGVsc2UgY29udGV4dC5wb29sLnB1c2godm5vZGUpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHJlbW92ZU5vZGVGcm9tRE9NKG5vZGUpIHtcblx0XHR2YXIgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlXG5cdFx0aWYgKHBhcmVudCAhPSBudWxsKSBwYXJlbnQucmVtb3ZlQ2hpbGQobm9kZSlcblx0fVxuXHRmdW5jdGlvbiBvbnJlbW92ZSh2bm9kZSkge1xuXHRcdGlmICh2bm9kZS5hdHRycyAmJiB0eXBlb2Ygdm5vZGUuYXR0cnMub25yZW1vdmUgPT09IFwiZnVuY3Rpb25cIikgdm5vZGUuYXR0cnMub25yZW1vdmUuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpXG5cdFx0aWYgKHR5cGVvZiB2bm9kZS50YWcgIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHZub2RlLl9zdGF0ZS5vbnJlbW92ZSA9PT0gXCJmdW5jdGlvblwiKSB2bm9kZS5fc3RhdGUub25yZW1vdmUuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpXG5cdFx0aWYgKHZub2RlLmluc3RhbmNlICE9IG51bGwpIG9ucmVtb3ZlKHZub2RlLmluc3RhbmNlKVxuXHRcdGVsc2Uge1xuXHRcdFx0dmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW5cblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0dmFyIGNoaWxkID0gY2hpbGRyZW5baV1cblx0XHRcdFx0XHRpZiAoY2hpbGQgIT0gbnVsbCkgb25yZW1vdmUoY2hpbGQpXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0Ly9hdHRyczJcblx0ZnVuY3Rpb24gc2V0QXR0cnModm5vZGUsIGF0dHJzMiwgbnMpIHtcblx0XHRmb3IgKHZhciBrZXkyIGluIGF0dHJzMikge1xuXHRcdFx0c2V0QXR0cih2bm9kZSwga2V5MiwgbnVsbCwgYXR0cnMyW2tleTJdLCBucylcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gc2V0QXR0cih2bm9kZSwga2V5Miwgb2xkLCB2YWx1ZSwgbnMpIHtcblx0XHR2YXIgZWxlbWVudCA9IHZub2RlLmRvbVxuXHRcdGlmIChrZXkyID09PSBcImtleVwiIHx8IGtleTIgPT09IFwiaXNcIiB8fCAob2xkID09PSB2YWx1ZSAmJiAhaXNGb3JtQXR0cmlidXRlKHZub2RlLCBrZXkyKSkgJiYgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIiB8fCBpc0xpZmVjeWNsZU1ldGhvZChrZXkyKSkgcmV0dXJuXG5cdFx0dmFyIG5zTGFzdEluZGV4ID0ga2V5Mi5pbmRleE9mKFwiOlwiKVxuXHRcdGlmIChuc0xhc3RJbmRleCA+IC0xICYmIGtleTIuc3Vic3RyKDAsIG5zTGFzdEluZGV4KSA9PT0gXCJ4bGlua1wiKSB7XG5cdFx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZU5TKFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLCBrZXkyLnNsaWNlKG5zTGFzdEluZGV4ICsgMSksIHZhbHVlKVxuXHRcdH1cblx0XHRlbHNlIGlmIChrZXkyWzBdID09PSBcIm9cIiAmJiBrZXkyWzFdID09PSBcIm5cIiAmJiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikgdXBkYXRlRXZlbnQodm5vZGUsIGtleTIsIHZhbHVlKVxuXHRcdGVsc2UgaWYgKGtleTIgPT09IFwic3R5bGVcIikgdXBkYXRlU3R5bGUoZWxlbWVudCwgb2xkLCB2YWx1ZSlcblx0XHRlbHNlIGlmIChrZXkyIGluIGVsZW1lbnQgJiYgIWlzQXR0cmlidXRlKGtleTIpICYmIG5zID09PSB1bmRlZmluZWQgJiYgIWlzQ3VzdG9tRWxlbWVudCh2bm9kZSkpIHtcblx0XHRcdGlmIChrZXkyID09PSBcInZhbHVlXCIpIHtcblx0XHRcdFx0dmFyIG5vcm1hbGl6ZWQwID0gXCJcIiArIHZhbHVlIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8taW1wbGljaXQtY29lcmNpb25cblx0XHRcdFx0Ly9zZXR0aW5nIGlucHV0W3ZhbHVlXSB0byBzYW1lIHZhbHVlIGJ5IHR5cGluZyBvbiBmb2N1c2VkIGVsZW1lbnQgbW92ZXMgY3Vyc29yIHRvIGVuZCBpbiBDaHJvbWVcblx0XHRcdFx0aWYgKCh2bm9kZS50YWcgPT09IFwiaW5wdXRcIiB8fCB2bm9kZS50YWcgPT09IFwidGV4dGFyZWFcIikgJiYgdm5vZGUuZG9tLnZhbHVlID09PSBub3JtYWxpemVkMCAmJiB2bm9kZS5kb20gPT09ICRkb2MuYWN0aXZlRWxlbWVudCkgcmV0dXJuXG5cdFx0XHRcdC8vc2V0dGluZyBzZWxlY3RbdmFsdWVdIHRvIHNhbWUgdmFsdWUgd2hpbGUgaGF2aW5nIHNlbGVjdCBvcGVuIGJsaW5rcyBzZWxlY3QgZHJvcGRvd24gaW4gQ2hyb21lXG5cdFx0XHRcdGlmICh2bm9kZS50YWcgPT09IFwic2VsZWN0XCIpIHtcblx0XHRcdFx0XHRpZiAodmFsdWUgPT09IG51bGwpIHtcblx0XHRcdFx0XHRcdGlmICh2bm9kZS5kb20uc2VsZWN0ZWRJbmRleCA9PT0gLTEgJiYgdm5vZGUuZG9tID09PSAkZG9jLmFjdGl2ZUVsZW1lbnQpIHJldHVyblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpZiAob2xkICE9PSBudWxsICYmIHZub2RlLmRvbS52YWx1ZSA9PT0gbm9ybWFsaXplZDAgJiYgdm5vZGUuZG9tID09PSAkZG9jLmFjdGl2ZUVsZW1lbnQpIHJldHVyblxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHQvL3NldHRpbmcgb3B0aW9uW3ZhbHVlXSB0byBzYW1lIHZhbHVlIHdoaWxlIGhhdmluZyBzZWxlY3Qgb3BlbiBibGlua3Mgc2VsZWN0IGRyb3Bkb3duIGluIENocm9tZVxuXHRcdFx0XHRpZiAodm5vZGUudGFnID09PSBcIm9wdGlvblwiICYmIG9sZCAhPSBudWxsICYmIHZub2RlLmRvbS52YWx1ZSA9PT0gbm9ybWFsaXplZDApIHJldHVyblxuXHRcdFx0fVxuXHRcdFx0Ly8gSWYgeW91IGFzc2lnbiBhbiBpbnB1dCB0eXBlMSB0aGF0IGlzIG5vdCBzdXBwb3J0ZWQgYnkgSUUgMTEgd2l0aCBhbiBhc3NpZ25tZW50IGV4cHJlc3Npb24sIGFuIGVycm9yMCB3aWxsIG9jY3VyLlxuXHRcdFx0aWYgKHZub2RlLnRhZyA9PT0gXCJpbnB1dFwiICYmIGtleTIgPT09IFwidHlwZVwiKSB7XG5cdFx0XHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleTIsIHZhbHVlKVxuXHRcdFx0XHRyZXR1cm5cblx0XHRcdH1cblx0XHRcdGVsZW1lbnRba2V5Ml0gPSB2YWx1ZVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiKSB7XG5cdFx0XHRcdGlmICh2YWx1ZSkgZWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5MiwgXCJcIilcblx0XHRcdFx0ZWxzZSBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShrZXkyKVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSBlbGVtZW50LnNldEF0dHJpYnV0ZShrZXkyID09PSBcImNsYXNzTmFtZVwiID8gXCJjbGFzc1wiIDoga2V5MiwgdmFsdWUpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHNldExhdGVBdHRycyh2bm9kZSkge1xuXHRcdHZhciBhdHRyczIgPSB2bm9kZS5hdHRyc1xuXHRcdGlmICh2bm9kZS50YWcgPT09IFwic2VsZWN0XCIgJiYgYXR0cnMyICE9IG51bGwpIHtcblx0XHRcdGlmIChcInZhbHVlXCIgaW4gYXR0cnMyKSBzZXRBdHRyKHZub2RlLCBcInZhbHVlXCIsIG51bGwsIGF0dHJzMi52YWx1ZSwgdW5kZWZpbmVkKVxuXHRcdFx0aWYgKFwic2VsZWN0ZWRJbmRleFwiIGluIGF0dHJzMikgc2V0QXR0cih2bm9kZSwgXCJzZWxlY3RlZEluZGV4XCIsIG51bGwsIGF0dHJzMi5zZWxlY3RlZEluZGV4LCB1bmRlZmluZWQpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUF0dHJzKHZub2RlLCBvbGQsIGF0dHJzMiwgbnMpIHtcblx0XHRpZiAoYXR0cnMyICE9IG51bGwpIHtcblx0XHRcdGZvciAodmFyIGtleTIgaW4gYXR0cnMyKSB7XG5cdFx0XHRcdHNldEF0dHIodm5vZGUsIGtleTIsIG9sZCAmJiBvbGRba2V5Ml0sIGF0dHJzMltrZXkyXSwgbnMpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChvbGQgIT0gbnVsbCkge1xuXHRcdFx0Zm9yICh2YXIga2V5MiBpbiBvbGQpIHtcblx0XHRcdFx0aWYgKGF0dHJzMiA9PSBudWxsIHx8ICEoa2V5MiBpbiBhdHRyczIpKSB7XG5cdFx0XHRcdFx0aWYgKGtleTIgPT09IFwiY2xhc3NOYW1lXCIpIGtleTIgPSBcImNsYXNzXCJcblx0XHRcdFx0XHRpZiAoa2V5MlswXSA9PT0gXCJvXCIgJiYga2V5MlsxXSA9PT0gXCJuXCIgJiYgIWlzTGlmZWN5Y2xlTWV0aG9kKGtleTIpKSB1cGRhdGVFdmVudCh2bm9kZSwga2V5MiwgdW5kZWZpbmVkKVxuXHRcdFx0XHRcdGVsc2UgaWYgKGtleTIgIT09IFwia2V5XCIpIHZub2RlLmRvbS5yZW1vdmVBdHRyaWJ1dGUoa2V5Milcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBpc0Zvcm1BdHRyaWJ1dGUodm5vZGUsIGF0dHIpIHtcblx0XHRyZXR1cm4gYXR0ciA9PT0gXCJ2YWx1ZVwiIHx8IGF0dHIgPT09IFwiY2hlY2tlZFwiIHx8IGF0dHIgPT09IFwic2VsZWN0ZWRJbmRleFwiIHx8IGF0dHIgPT09IFwic2VsZWN0ZWRcIiAmJiB2bm9kZS5kb20gPT09ICRkb2MuYWN0aXZlRWxlbWVudFxuXHR9XG5cdGZ1bmN0aW9uIGlzTGlmZWN5Y2xlTWV0aG9kKGF0dHIpIHtcblx0XHRyZXR1cm4gYXR0ciA9PT0gXCJvbmluaXRcIiB8fCBhdHRyID09PSBcIm9uY3JlYXRlXCIgfHwgYXR0ciA9PT0gXCJvbnVwZGF0ZVwiIHx8IGF0dHIgPT09IFwib25yZW1vdmVcIiB8fCBhdHRyID09PSBcIm9uYmVmb3JlcmVtb3ZlXCIgfHwgYXR0ciA9PT0gXCJvbmJlZm9yZXVwZGF0ZVwiXG5cdH1cblx0ZnVuY3Rpb24gaXNBdHRyaWJ1dGUoYXR0cikge1xuXHRcdHJldHVybiBhdHRyID09PSBcImhyZWZcIiB8fCBhdHRyID09PSBcImxpc3RcIiB8fCBhdHRyID09PSBcImZvcm1cIiB8fCBhdHRyID09PSBcIndpZHRoXCIgfHwgYXR0ciA9PT0gXCJoZWlnaHRcIi8vIHx8IGF0dHIgPT09IFwidHlwZVwiXG5cdH1cblx0ZnVuY3Rpb24gaXNDdXN0b21FbGVtZW50KHZub2RlKXtcblx0XHRyZXR1cm4gdm5vZGUuYXR0cnMuaXMgfHwgdm5vZGUudGFnLmluZGV4T2YoXCItXCIpID4gLTFcblx0fVxuXHRmdW5jdGlvbiBoYXNJbnRlZ3JhdGlvbk1ldGhvZHMoc291cmNlKSB7XG5cdFx0cmV0dXJuIHNvdXJjZSAhPSBudWxsICYmIChzb3VyY2Uub25jcmVhdGUgfHwgc291cmNlLm9udXBkYXRlIHx8IHNvdXJjZS5vbmJlZm9yZXJlbW92ZSB8fCBzb3VyY2Uub25yZW1vdmUpXG5cdH1cblx0Ly9zdHlsZVxuXHRmdW5jdGlvbiB1cGRhdGVTdHlsZShlbGVtZW50LCBvbGQsIHN0eWxlKSB7XG5cdFx0aWYgKG9sZCA9PT0gc3R5bGUpIGVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IFwiXCIsIG9sZCA9IG51bGxcblx0XHRpZiAoc3R5bGUgPT0gbnVsbCkgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gXCJcIlxuXHRcdGVsc2UgaWYgKHR5cGVvZiBzdHlsZSA9PT0gXCJzdHJpbmdcIikgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gc3R5bGVcblx0XHRlbHNlIHtcblx0XHRcdGlmICh0eXBlb2Ygb2xkID09PSBcInN0cmluZ1wiKSBlbGVtZW50LnN0eWxlLmNzc1RleHQgPSBcIlwiXG5cdFx0XHRmb3IgKHZhciBrZXkyIGluIHN0eWxlKSB7XG5cdFx0XHRcdGVsZW1lbnQuc3R5bGVba2V5Ml0gPSBzdHlsZVtrZXkyXVxuXHRcdFx0fVxuXHRcdFx0aWYgKG9sZCAhPSBudWxsICYmIHR5cGVvZiBvbGQgIT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0Zm9yICh2YXIga2V5MiBpbiBvbGQpIHtcblx0XHRcdFx0XHRpZiAoIShrZXkyIGluIHN0eWxlKSkgZWxlbWVudC5zdHlsZVtrZXkyXSA9IFwiXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHQvL2V2ZW50XG5cdGZ1bmN0aW9uIHVwZGF0ZUV2ZW50KHZub2RlLCBrZXkyLCB2YWx1ZSkge1xuXHRcdHZhciBlbGVtZW50ID0gdm5vZGUuZG9tXG5cdFx0dmFyIGNhbGxiYWNrID0gdHlwZW9mIG9uZXZlbnQgIT09IFwiZnVuY3Rpb25cIiA/IHZhbHVlIDogZnVuY3Rpb24oZSkge1xuXHRcdFx0dmFyIHJlc3VsdCA9IHZhbHVlLmNhbGwoZWxlbWVudCwgZSlcblx0XHRcdG9uZXZlbnQuY2FsbChlbGVtZW50LCBlKVxuXHRcdFx0cmV0dXJuIHJlc3VsdFxuXHRcdH1cblx0XHRpZiAoa2V5MiBpbiBlbGVtZW50KSBlbGVtZW50W2tleTJdID0gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBjYWxsYmFjayA6IG51bGxcblx0XHRlbHNlIHtcblx0XHRcdHZhciBldmVudE5hbWUgPSBrZXkyLnNsaWNlKDIpXG5cdFx0XHRpZiAodm5vZGUuZXZlbnRzID09PSB1bmRlZmluZWQpIHZub2RlLmV2ZW50cyA9IHt9XG5cdFx0XHRpZiAodm5vZGUuZXZlbnRzW2tleTJdID09PSBjYWxsYmFjaykgcmV0dXJuXG5cdFx0XHRpZiAodm5vZGUuZXZlbnRzW2tleTJdICE9IG51bGwpIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIHZub2RlLmV2ZW50c1trZXkyXSwgZmFsc2UpXG5cdFx0XHRpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0dm5vZGUuZXZlbnRzW2tleTJdID0gY2FsbGJhY2tcblx0XHRcdFx0ZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgdm5vZGUuZXZlbnRzW2tleTJdLCBmYWxzZSlcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0Ly9saWZlY3ljbGVcblx0ZnVuY3Rpb24gaW5pdExpZmVjeWNsZShzb3VyY2UsIHZub2RlLCBob29rcykge1xuXHRcdGlmICh0eXBlb2Ygc291cmNlLm9uaW5pdCA9PT0gXCJmdW5jdGlvblwiKSBzb3VyY2Uub25pbml0LmNhbGwodm5vZGUuc3RhdGUsIHZub2RlKVxuXHRcdGlmICh0eXBlb2Ygc291cmNlLm9uY3JlYXRlID09PSBcImZ1bmN0aW9uXCIpIGhvb2tzLnB1c2goc291cmNlLm9uY3JlYXRlLmJpbmQodm5vZGUuc3RhdGUsIHZub2RlKSlcblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVMaWZlY3ljbGUoc291cmNlLCB2bm9kZSwgaG9va3MpIHtcblx0XHRpZiAodHlwZW9mIHNvdXJjZS5vbnVwZGF0ZSA9PT0gXCJmdW5jdGlvblwiKSBob29rcy5wdXNoKHNvdXJjZS5vbnVwZGF0ZS5iaW5kKHZub2RlLnN0YXRlLCB2bm9kZSkpXG5cdH1cblx0ZnVuY3Rpb24gc2hvdWxkTm90VXBkYXRlKHZub2RlLCBvbGQpIHtcblx0XHR2YXIgZm9yY2VWbm9kZVVwZGF0ZSwgZm9yY2VDb21wb25lbnRVcGRhdGVcblx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCAmJiB0eXBlb2Ygdm5vZGUuYXR0cnMub25iZWZvcmV1cGRhdGUgPT09IFwiZnVuY3Rpb25cIikgZm9yY2VWbm9kZVVwZGF0ZSA9IHZub2RlLmF0dHJzLm9uYmVmb3JldXBkYXRlLmNhbGwodm5vZGUuc3RhdGUsIHZub2RlLCBvbGQpXG5cdFx0aWYgKHR5cGVvZiB2bm9kZS50YWcgIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHZub2RlLl9zdGF0ZS5vbmJlZm9yZXVwZGF0ZSA9PT0gXCJmdW5jdGlvblwiKSBmb3JjZUNvbXBvbmVudFVwZGF0ZSA9IHZub2RlLl9zdGF0ZS5vbmJlZm9yZXVwZGF0ZS5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSwgb2xkKVxuXHRcdGlmICghKGZvcmNlVm5vZGVVcGRhdGUgPT09IHVuZGVmaW5lZCAmJiBmb3JjZUNvbXBvbmVudFVwZGF0ZSA9PT0gdW5kZWZpbmVkKSAmJiAhZm9yY2VWbm9kZVVwZGF0ZSAmJiAhZm9yY2VDb21wb25lbnRVcGRhdGUpIHtcblx0XHRcdHZub2RlLmRvbSA9IG9sZC5kb21cblx0XHRcdHZub2RlLmRvbVNpemUgPSBvbGQuZG9tU2l6ZVxuXHRcdFx0dm5vZGUuaW5zdGFuY2UgPSBvbGQuaW5zdGFuY2Vcblx0XHRcdHJldHVybiB0cnVlXG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZVxuXHR9XG5cdGZ1bmN0aW9uIHJlbmRlcihkb20sIHZub2Rlcykge1xuXHRcdGlmICghZG9tKSB0aHJvdyBuZXcgRXJyb3IoXCJFbnN1cmUgdGhlIERPTSBlbGVtZW50IGJlaW5nIHBhc3NlZCB0byBtLnJvdXRlL20ubW91bnQvbS5yZW5kZXIgaXMgbm90IHVuZGVmaW5lZC5cIilcblx0XHR2YXIgaG9va3MgPSBbXVxuXHRcdHZhciBhY3RpdmUgPSAkZG9jLmFjdGl2ZUVsZW1lbnRcblx0XHR2YXIgbmFtZXNwYWNlID0gZG9tLm5hbWVzcGFjZVVSSVxuXHRcdC8vIEZpcnN0IHRpbWUwIHJlbmRlcmluZyBpbnRvIGEgbm9kZSBjbGVhcnMgaXQgb3V0XG5cdFx0aWYgKGRvbS52bm9kZXMgPT0gbnVsbCkgZG9tLnRleHRDb250ZW50ID0gXCJcIlxuXHRcdGlmICghQXJyYXkuaXNBcnJheSh2bm9kZXMpKSB2bm9kZXMgPSBbdm5vZGVzXVxuXHRcdHVwZGF0ZU5vZGVzKGRvbSwgZG9tLnZub2RlcywgVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4odm5vZGVzKSwgZmFsc2UsIGhvb2tzLCBudWxsLCBuYW1lc3BhY2UgPT09IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiID8gdW5kZWZpbmVkIDogbmFtZXNwYWNlKVxuXHRcdGRvbS52bm9kZXMgPSB2bm9kZXNcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSBob29rc1tpXSgpXG5cdFx0aWYgKCRkb2MuYWN0aXZlRWxlbWVudCAhPT0gYWN0aXZlKSBhY3RpdmUuZm9jdXMoKVxuXHR9XG5cdHJldHVybiB7cmVuZGVyOiByZW5kZXIsIHNldEV2ZW50Q2FsbGJhY2s6IHNldEV2ZW50Q2FsbGJhY2t9XG59XG5mdW5jdGlvbiB0aHJvdHRsZShjYWxsYmFjaykge1xuXHQvLzYwZnBzIHRyYW5zbGF0ZXMgdG8gMTYuNm1zLCByb3VuZCBpdCBkb3duIHNpbmNlIHNldFRpbWVvdXQgcmVxdWlyZXMgaW50XG5cdHZhciB0aW1lID0gMTZcblx0dmFyIGxhc3QgPSAwLCBwZW5kaW5nID0gbnVsbFxuXHR2YXIgdGltZW91dCA9IHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09IFwiZnVuY3Rpb25cIiA/IHJlcXVlc3RBbmltYXRpb25GcmFtZSA6IHNldFRpbWVvdXRcblx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBub3cgPSBEYXRlLm5vdygpXG5cdFx0aWYgKGxhc3QgPT09IDAgfHwgbm93IC0gbGFzdCA+PSB0aW1lKSB7XG5cdFx0XHRsYXN0ID0gbm93XG5cdFx0XHRjYWxsYmFjaygpXG5cdFx0fVxuXHRcdGVsc2UgaWYgKHBlbmRpbmcgPT09IG51bGwpIHtcblx0XHRcdHBlbmRpbmcgPSB0aW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRwZW5kaW5nID0gbnVsbFxuXHRcdFx0XHRjYWxsYmFjaygpXG5cdFx0XHRcdGxhc3QgPSBEYXRlLm5vdygpXG5cdFx0XHR9LCB0aW1lIC0gKG5vdyAtIGxhc3QpKVxuXHRcdH1cblx0fVxufVxudmFyIF8xMSA9IGZ1bmN0aW9uKCR3aW5kb3cpIHtcblx0dmFyIHJlbmRlclNlcnZpY2UgPSBjb3JlUmVuZGVyZXIoJHdpbmRvdylcblx0cmVuZGVyU2VydmljZS5zZXRFdmVudENhbGxiYWNrKGZ1bmN0aW9uKGUpIHtcblx0XHRpZiAoZS5yZWRyYXcgPT09IGZhbHNlKSBlLnJlZHJhdyA9IHVuZGVmaW5lZFxuXHRcdGVsc2UgcmVkcmF3KClcblx0fSlcblx0dmFyIGNhbGxiYWNrcyA9IFtdXG5cdGZ1bmN0aW9uIHN1YnNjcmliZShrZXkxLCBjYWxsYmFjaykge1xuXHRcdHVuc3Vic2NyaWJlKGtleTEpXG5cdFx0Y2FsbGJhY2tzLnB1c2goa2V5MSwgdGhyb3R0bGUoY2FsbGJhY2spKVxuXHR9XG5cdGZ1bmN0aW9uIHVuc3Vic2NyaWJlKGtleTEpIHtcblx0XHR2YXIgaW5kZXggPSBjYWxsYmFja3MuaW5kZXhPZihrZXkxKVxuXHRcdGlmIChpbmRleCA+IC0xKSBjYWxsYmFja3Muc3BsaWNlKGluZGV4LCAyKVxuXHR9XG5cdGZ1bmN0aW9uIHJlZHJhdygpIHtcblx0XHRmb3IgKHZhciBpID0gMTsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkgKz0gMikge1xuXHRcdFx0Y2FsbGJhY2tzW2ldKClcblx0XHR9XG5cdH1cblx0cmV0dXJuIHtzdWJzY3JpYmU6IHN1YnNjcmliZSwgdW5zdWJzY3JpYmU6IHVuc3Vic2NyaWJlLCByZWRyYXc6IHJlZHJhdywgcmVuZGVyOiByZW5kZXJTZXJ2aWNlLnJlbmRlcn1cbn1cbnZhciByZWRyYXdTZXJ2aWNlID0gXzExKHdpbmRvdylcbnJlcXVlc3RTZXJ2aWNlLnNldENvbXBsZXRpb25DYWxsYmFjayhyZWRyYXdTZXJ2aWNlLnJlZHJhdylcbnZhciBfMTYgPSBmdW5jdGlvbihyZWRyYXdTZXJ2aWNlMCkge1xuXHRyZXR1cm4gZnVuY3Rpb24ocm9vdCwgY29tcG9uZW50KSB7XG5cdFx0aWYgKGNvbXBvbmVudCA9PT0gbnVsbCkge1xuXHRcdFx0cmVkcmF3U2VydmljZTAucmVuZGVyKHJvb3QsIFtdKVxuXHRcdFx0cmVkcmF3U2VydmljZTAudW5zdWJzY3JpYmUocm9vdClcblx0XHRcdHJldHVyblxuXHRcdH1cblx0XHRcblx0XHRpZiAoY29tcG9uZW50LnZpZXcgPT0gbnVsbCAmJiB0eXBlb2YgY29tcG9uZW50ICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcihcIm0ubW91bnQoZWxlbWVudCwgY29tcG9uZW50KSBleHBlY3RzIGEgY29tcG9uZW50LCBub3QgYSB2bm9kZVwiKVxuXHRcdFxuXHRcdHZhciBydW4wID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZWRyYXdTZXJ2aWNlMC5yZW5kZXIocm9vdCwgVm5vZGUoY29tcG9uZW50KSlcblx0XHR9XG5cdFx0cmVkcmF3U2VydmljZTAuc3Vic2NyaWJlKHJvb3QsIHJ1bjApXG5cdFx0cmVkcmF3U2VydmljZTAucmVkcmF3KClcblx0fVxufVxubS5tb3VudCA9IF8xNihyZWRyYXdTZXJ2aWNlKVxudmFyIFByb21pc2UgPSBQcm9taXNlUG9seWZpbGxcbnZhciBwYXJzZVF1ZXJ5U3RyaW5nID0gZnVuY3Rpb24oc3RyaW5nKSB7XG5cdGlmIChzdHJpbmcgPT09IFwiXCIgfHwgc3RyaW5nID09IG51bGwpIHJldHVybiB7fVxuXHRpZiAoc3RyaW5nLmNoYXJBdCgwKSA9PT0gXCI/XCIpIHN0cmluZyA9IHN0cmluZy5zbGljZSgxKVxuXHR2YXIgZW50cmllcyA9IHN0cmluZy5zcGxpdChcIiZcIiksIGRhdGEwID0ge30sIGNvdW50ZXJzID0ge31cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGVudHJ5ID0gZW50cmllc1tpXS5zcGxpdChcIj1cIilcblx0XHR2YXIga2V5NSA9IGRlY29kZVVSSUNvbXBvbmVudChlbnRyeVswXSlcblx0XHR2YXIgdmFsdWUgPSBlbnRyeS5sZW5ndGggPT09IDIgPyBkZWNvZGVVUklDb21wb25lbnQoZW50cnlbMV0pIDogXCJcIlxuXHRcdGlmICh2YWx1ZSA9PT0gXCJ0cnVlXCIpIHZhbHVlID0gdHJ1ZVxuXHRcdGVsc2UgaWYgKHZhbHVlID09PSBcImZhbHNlXCIpIHZhbHVlID0gZmFsc2Vcblx0XHR2YXIgbGV2ZWxzID0ga2V5NS5zcGxpdCgvXFxdXFxbP3xcXFsvKVxuXHRcdHZhciBjdXJzb3IgPSBkYXRhMFxuXHRcdGlmIChrZXk1LmluZGV4T2YoXCJbXCIpID4gLTEpIGxldmVscy5wb3AoKVxuXHRcdGZvciAodmFyIGogPSAwOyBqIDwgbGV2ZWxzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHR2YXIgbGV2ZWwgPSBsZXZlbHNbal0sIG5leHRMZXZlbCA9IGxldmVsc1tqICsgMV1cblx0XHRcdHZhciBpc051bWJlciA9IG5leHRMZXZlbCA9PSBcIlwiIHx8ICFpc05hTihwYXJzZUludChuZXh0TGV2ZWwsIDEwKSlcblx0XHRcdHZhciBpc1ZhbHVlID0gaiA9PT0gbGV2ZWxzLmxlbmd0aCAtIDFcblx0XHRcdGlmIChsZXZlbCA9PT0gXCJcIikge1xuXHRcdFx0XHR2YXIga2V5NSA9IGxldmVscy5zbGljZSgwLCBqKS5qb2luKClcblx0XHRcdFx0aWYgKGNvdW50ZXJzW2tleTVdID09IG51bGwpIGNvdW50ZXJzW2tleTVdID0gMFxuXHRcdFx0XHRsZXZlbCA9IGNvdW50ZXJzW2tleTVdKytcblx0XHRcdH1cblx0XHRcdGlmIChjdXJzb3JbbGV2ZWxdID09IG51bGwpIHtcblx0XHRcdFx0Y3Vyc29yW2xldmVsXSA9IGlzVmFsdWUgPyB2YWx1ZSA6IGlzTnVtYmVyID8gW10gOiB7fVxuXHRcdFx0fVxuXHRcdFx0Y3Vyc29yID0gY3Vyc29yW2xldmVsXVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gZGF0YTBcbn1cbnZhciBjb3JlUm91dGVyID0gZnVuY3Rpb24oJHdpbmRvdykge1xuXHR2YXIgc3VwcG9ydHNQdXNoU3RhdGUgPSB0eXBlb2YgJHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSA9PT0gXCJmdW5jdGlvblwiXG5cdHZhciBjYWxsQXN5bmMwID0gdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiID8gc2V0SW1tZWRpYXRlIDogc2V0VGltZW91dFxuXHRmdW5jdGlvbiBub3JtYWxpemUxKGZyYWdtZW50MCkge1xuXHRcdHZhciBkYXRhID0gJHdpbmRvdy5sb2NhdGlvbltmcmFnbWVudDBdLnJlcGxhY2UoLyg/OiVbYS1mODldW2EtZjAtOV0pKy9naW0sIGRlY29kZVVSSUNvbXBvbmVudClcblx0XHRpZiAoZnJhZ21lbnQwID09PSBcInBhdGhuYW1lXCIgJiYgZGF0YVswXSAhPT0gXCIvXCIpIGRhdGEgPSBcIi9cIiArIGRhdGFcblx0XHRyZXR1cm4gZGF0YVxuXHR9XG5cdHZhciBhc3luY0lkXG5cdGZ1bmN0aW9uIGRlYm91bmNlQXN5bmMoY2FsbGJhY2swKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKGFzeW5jSWQgIT0gbnVsbCkgcmV0dXJuXG5cdFx0XHRhc3luY0lkID0gY2FsbEFzeW5jMChmdW5jdGlvbigpIHtcblx0XHRcdFx0YXN5bmNJZCA9IG51bGxcblx0XHRcdFx0Y2FsbGJhY2swKClcblx0XHRcdH0pXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHBhcnNlUGF0aChwYXRoLCBxdWVyeURhdGEsIGhhc2hEYXRhKSB7XG5cdFx0dmFyIHF1ZXJ5SW5kZXggPSBwYXRoLmluZGV4T2YoXCI/XCIpXG5cdFx0dmFyIGhhc2hJbmRleCA9IHBhdGguaW5kZXhPZihcIiNcIilcblx0XHR2YXIgcGF0aEVuZCA9IHF1ZXJ5SW5kZXggPiAtMSA/IHF1ZXJ5SW5kZXggOiBoYXNoSW5kZXggPiAtMSA/IGhhc2hJbmRleCA6IHBhdGgubGVuZ3RoXG5cdFx0aWYgKHF1ZXJ5SW5kZXggPiAtMSkge1xuXHRcdFx0dmFyIHF1ZXJ5RW5kID0gaGFzaEluZGV4ID4gLTEgPyBoYXNoSW5kZXggOiBwYXRoLmxlbmd0aFxuXHRcdFx0dmFyIHF1ZXJ5UGFyYW1zID0gcGFyc2VRdWVyeVN0cmluZyhwYXRoLnNsaWNlKHF1ZXJ5SW5kZXggKyAxLCBxdWVyeUVuZCkpXG5cdFx0XHRmb3IgKHZhciBrZXk0IGluIHF1ZXJ5UGFyYW1zKSBxdWVyeURhdGFba2V5NF0gPSBxdWVyeVBhcmFtc1trZXk0XVxuXHRcdH1cblx0XHRpZiAoaGFzaEluZGV4ID4gLTEpIHtcblx0XHRcdHZhciBoYXNoUGFyYW1zID0gcGFyc2VRdWVyeVN0cmluZyhwYXRoLnNsaWNlKGhhc2hJbmRleCArIDEpKVxuXHRcdFx0Zm9yICh2YXIga2V5NCBpbiBoYXNoUGFyYW1zKSBoYXNoRGF0YVtrZXk0XSA9IGhhc2hQYXJhbXNba2V5NF1cblx0XHR9XG5cdFx0cmV0dXJuIHBhdGguc2xpY2UoMCwgcGF0aEVuZClcblx0fVxuXHR2YXIgcm91dGVyID0ge3ByZWZpeDogXCIjIVwifVxuXHRyb3V0ZXIuZ2V0UGF0aCA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0eXBlMiA9IHJvdXRlci5wcmVmaXguY2hhckF0KDApXG5cdFx0c3dpdGNoICh0eXBlMikge1xuXHRcdFx0Y2FzZSBcIiNcIjogcmV0dXJuIG5vcm1hbGl6ZTEoXCJoYXNoXCIpLnNsaWNlKHJvdXRlci5wcmVmaXgubGVuZ3RoKVxuXHRcdFx0Y2FzZSBcIj9cIjogcmV0dXJuIG5vcm1hbGl6ZTEoXCJzZWFyY2hcIikuc2xpY2Uocm91dGVyLnByZWZpeC5sZW5ndGgpICsgbm9ybWFsaXplMShcImhhc2hcIilcblx0XHRcdGRlZmF1bHQ6IHJldHVybiBub3JtYWxpemUxKFwicGF0aG5hbWVcIikuc2xpY2Uocm91dGVyLnByZWZpeC5sZW5ndGgpICsgbm9ybWFsaXplMShcInNlYXJjaFwiKSArIG5vcm1hbGl6ZTEoXCJoYXNoXCIpXG5cdFx0fVxuXHR9XG5cdHJvdXRlci5zZXRQYXRoID0gZnVuY3Rpb24ocGF0aCwgZGF0YSwgb3B0aW9ucykge1xuXHRcdHZhciBxdWVyeURhdGEgPSB7fSwgaGFzaERhdGEgPSB7fVxuXHRcdHBhdGggPSBwYXJzZVBhdGgocGF0aCwgcXVlcnlEYXRhLCBoYXNoRGF0YSlcblx0XHRpZiAoZGF0YSAhPSBudWxsKSB7XG5cdFx0XHRmb3IgKHZhciBrZXk0IGluIGRhdGEpIHF1ZXJ5RGF0YVtrZXk0XSA9IGRhdGFba2V5NF1cblx0XHRcdHBhdGggPSBwYXRoLnJlcGxhY2UoLzooW15cXC9dKykvZywgZnVuY3Rpb24obWF0Y2gyLCB0b2tlbikge1xuXHRcdFx0XHRkZWxldGUgcXVlcnlEYXRhW3Rva2VuXVxuXHRcdFx0XHRyZXR1cm4gZGF0YVt0b2tlbl1cblx0XHRcdH0pXG5cdFx0fVxuXHRcdHZhciBxdWVyeSA9IGJ1aWxkUXVlcnlTdHJpbmcocXVlcnlEYXRhKVxuXHRcdGlmIChxdWVyeSkgcGF0aCArPSBcIj9cIiArIHF1ZXJ5XG5cdFx0dmFyIGhhc2ggPSBidWlsZFF1ZXJ5U3RyaW5nKGhhc2hEYXRhKVxuXHRcdGlmIChoYXNoKSBwYXRoICs9IFwiI1wiICsgaGFzaFxuXHRcdGlmIChzdXBwb3J0c1B1c2hTdGF0ZSkge1xuXHRcdFx0dmFyIHN0YXRlID0gb3B0aW9ucyA/IG9wdGlvbnMuc3RhdGUgOiBudWxsXG5cdFx0XHR2YXIgdGl0bGUgPSBvcHRpb25zID8gb3B0aW9ucy50aXRsZSA6IG51bGxcblx0XHRcdCR3aW5kb3cub25wb3BzdGF0ZSgpXG5cdFx0XHRpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlcGxhY2UpICR3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoc3RhdGUsIHRpdGxlLCByb3V0ZXIucHJlZml4ICsgcGF0aClcblx0XHRcdGVsc2UgJHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZShzdGF0ZSwgdGl0bGUsIHJvdXRlci5wcmVmaXggKyBwYXRoKVxuXHRcdH1cblx0XHRlbHNlICR3aW5kb3cubG9jYXRpb24uaHJlZiA9IHJvdXRlci5wcmVmaXggKyBwYXRoXG5cdH1cblx0cm91dGVyLmRlZmluZVJvdXRlcyA9IGZ1bmN0aW9uKHJvdXRlcywgcmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0ZnVuY3Rpb24gcmVzb2x2ZVJvdXRlKCkge1xuXHRcdFx0dmFyIHBhdGggPSByb3V0ZXIuZ2V0UGF0aCgpXG5cdFx0XHR2YXIgcGFyYW1zID0ge31cblx0XHRcdHZhciBwYXRobmFtZSA9IHBhcnNlUGF0aChwYXRoLCBwYXJhbXMsIHBhcmFtcylcblx0XHRcdHZhciBzdGF0ZSA9ICR3aW5kb3cuaGlzdG9yeS5zdGF0ZVxuXHRcdFx0aWYgKHN0YXRlICE9IG51bGwpIHtcblx0XHRcdFx0Zm9yICh2YXIgayBpbiBzdGF0ZSkgcGFyYW1zW2tdID0gc3RhdGVba11cblx0XHRcdH1cblx0XHRcdGZvciAodmFyIHJvdXRlMCBpbiByb3V0ZXMpIHtcblx0XHRcdFx0dmFyIG1hdGNoZXIgPSBuZXcgUmVnRXhwKFwiXlwiICsgcm91dGUwLnJlcGxhY2UoLzpbXlxcL10rP1xcLnszfS9nLCBcIiguKj8pXCIpLnJlcGxhY2UoLzpbXlxcL10rL2csIFwiKFteXFxcXC9dKylcIikgKyBcIlxcLz8kXCIpXG5cdFx0XHRcdGlmIChtYXRjaGVyLnRlc3QocGF0aG5hbWUpKSB7XG5cdFx0XHRcdFx0cGF0aG5hbWUucmVwbGFjZShtYXRjaGVyLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHZhciBrZXlzID0gcm91dGUwLm1hdGNoKC86W15cXC9dKy9nKSB8fCBbXVxuXHRcdFx0XHRcdFx0dmFyIHZhbHVlcyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxLCAtMilcblx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRwYXJhbXNba2V5c1tpXS5yZXBsYWNlKC86fFxcLi9nLCBcIlwiKV0gPSBkZWNvZGVVUklDb21wb25lbnQodmFsdWVzW2ldKVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmVzb2x2ZShyb3V0ZXNbcm91dGUwXSwgcGFyYW1zLCBwYXRoLCByb3V0ZTApXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmVqZWN0KHBhdGgsIHBhcmFtcylcblx0XHR9XG5cdFx0aWYgKHN1cHBvcnRzUHVzaFN0YXRlKSAkd2luZG93Lm9ucG9wc3RhdGUgPSBkZWJvdW5jZUFzeW5jKHJlc29sdmVSb3V0ZSlcblx0XHRlbHNlIGlmIChyb3V0ZXIucHJlZml4LmNoYXJBdCgwKSA9PT0gXCIjXCIpICR3aW5kb3cub25oYXNoY2hhbmdlID0gcmVzb2x2ZVJvdXRlXG5cdFx0cmVzb2x2ZVJvdXRlKClcblx0fVxuXHRyZXR1cm4gcm91dGVyXG59XG52YXIgXzIwID0gZnVuY3Rpb24oJHdpbmRvdywgcmVkcmF3U2VydmljZTApIHtcblx0dmFyIHJvdXRlU2VydmljZSA9IGNvcmVSb3V0ZXIoJHdpbmRvdylcblx0dmFyIGlkZW50aXR5ID0gZnVuY3Rpb24odikge3JldHVybiB2fVxuXHR2YXIgcmVuZGVyMSwgY29tcG9uZW50LCBhdHRyczMsIGN1cnJlbnRQYXRoLCBsYXN0VXBkYXRlXG5cdHZhciByb3V0ZSA9IGZ1bmN0aW9uKHJvb3QsIGRlZmF1bHRSb3V0ZSwgcm91dGVzKSB7XG5cdFx0aWYgKHJvb3QgPT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKFwiRW5zdXJlIHRoZSBET00gZWxlbWVudCB0aGF0IHdhcyBwYXNzZWQgdG8gYG0ucm91dGVgIGlzIG5vdCB1bmRlZmluZWRcIilcblx0XHR2YXIgcnVuMSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKHJlbmRlcjEgIT0gbnVsbCkgcmVkcmF3U2VydmljZTAucmVuZGVyKHJvb3QsIHJlbmRlcjEoVm5vZGUoY29tcG9uZW50LCBhdHRyczMua2V5LCBhdHRyczMpKSlcblx0XHR9XG5cdFx0dmFyIGJhaWwgPSBmdW5jdGlvbihwYXRoKSB7XG5cdFx0XHRpZiAocGF0aCAhPT0gZGVmYXVsdFJvdXRlKSByb3V0ZVNlcnZpY2Uuc2V0UGF0aChkZWZhdWx0Um91dGUsIG51bGwsIHtyZXBsYWNlOiB0cnVlfSlcblx0XHRcdGVsc2UgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IHJlc29sdmUgZGVmYXVsdCByb3V0ZSBcIiArIGRlZmF1bHRSb3V0ZSlcblx0XHR9XG5cdFx0cm91dGVTZXJ2aWNlLmRlZmluZVJvdXRlcyhyb3V0ZXMsIGZ1bmN0aW9uKHBheWxvYWQsIHBhcmFtcywgcGF0aCkge1xuXHRcdFx0dmFyIHVwZGF0ZSA9IGxhc3RVcGRhdGUgPSBmdW5jdGlvbihyb3V0ZVJlc29sdmVyLCBjb21wKSB7XG5cdFx0XHRcdGlmICh1cGRhdGUgIT09IGxhc3RVcGRhdGUpIHJldHVyblxuXHRcdFx0XHRjb21wb25lbnQgPSBjb21wICE9IG51bGwgJiYgKHR5cGVvZiBjb21wLnZpZXcgPT09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgY29tcCA9PT0gXCJmdW5jdGlvblwiKT8gY29tcCA6IFwiZGl2XCJcblx0XHRcdFx0YXR0cnMzID0gcGFyYW1zLCBjdXJyZW50UGF0aCA9IHBhdGgsIGxhc3RVcGRhdGUgPSBudWxsXG5cdFx0XHRcdHJlbmRlcjEgPSAocm91dGVSZXNvbHZlci5yZW5kZXIgfHwgaWRlbnRpdHkpLmJpbmQocm91dGVSZXNvbHZlcilcblx0XHRcdFx0cnVuMSgpXG5cdFx0XHR9XG5cdFx0XHRpZiAocGF5bG9hZC52aWV3IHx8IHR5cGVvZiBwYXlsb2FkID09PSBcImZ1bmN0aW9uXCIpIHVwZGF0ZSh7fSwgcGF5bG9hZClcblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRpZiAocGF5bG9hZC5vbm1hdGNoKSB7XG5cdFx0XHRcdFx0UHJvbWlzZS5yZXNvbHZlKHBheWxvYWQub25tYXRjaChwYXJhbXMsIHBhdGgpKS50aGVuKGZ1bmN0aW9uKHJlc29sdmVkKSB7XG5cdFx0XHRcdFx0XHR1cGRhdGUocGF5bG9hZCwgcmVzb2x2ZWQpXG5cdFx0XHRcdFx0fSwgYmFpbClcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHVwZGF0ZShwYXlsb2FkLCBcImRpdlwiKVxuXHRcdFx0fVxuXHRcdH0sIGJhaWwpXG5cdFx0cmVkcmF3U2VydmljZTAuc3Vic2NyaWJlKHJvb3QsIHJ1bjEpXG5cdH1cblx0cm91dGUuc2V0ID0gZnVuY3Rpb24ocGF0aCwgZGF0YSwgb3B0aW9ucykge1xuXHRcdGlmIChsYXN0VXBkYXRlICE9IG51bGwpIHtcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cdFx0XHRvcHRpb25zLnJlcGxhY2UgPSB0cnVlXG5cdFx0fVxuXHRcdGxhc3RVcGRhdGUgPSBudWxsXG5cdFx0cm91dGVTZXJ2aWNlLnNldFBhdGgocGF0aCwgZGF0YSwgb3B0aW9ucylcblx0fVxuXHRyb3V0ZS5nZXQgPSBmdW5jdGlvbigpIHtyZXR1cm4gY3VycmVudFBhdGh9XG5cdHJvdXRlLnByZWZpeCA9IGZ1bmN0aW9uKHByZWZpeDApIHtyb3V0ZVNlcnZpY2UucHJlZml4ID0gcHJlZml4MH1cblx0cm91dGUubGluayA9IGZ1bmN0aW9uKHZub2RlMSkge1xuXHRcdHZub2RlMS5kb20uc2V0QXR0cmlidXRlKFwiaHJlZlwiLCByb3V0ZVNlcnZpY2UucHJlZml4ICsgdm5vZGUxLmF0dHJzLmhyZWYpXG5cdFx0dm5vZGUxLmRvbS5vbmNsaWNrID0gZnVuY3Rpb24oZSkge1xuXHRcdFx0aWYgKGUuY3RybEtleSB8fCBlLm1ldGFLZXkgfHwgZS5zaGlmdEtleSB8fCBlLndoaWNoID09PSAyKSByZXR1cm5cblx0XHRcdGUucHJldmVudERlZmF1bHQoKVxuXHRcdFx0ZS5yZWRyYXcgPSBmYWxzZVxuXHRcdFx0dmFyIGhyZWYgPSB0aGlzLmdldEF0dHJpYnV0ZShcImhyZWZcIilcblx0XHRcdGlmIChocmVmLmluZGV4T2Yocm91dGVTZXJ2aWNlLnByZWZpeCkgPT09IDApIGhyZWYgPSBocmVmLnNsaWNlKHJvdXRlU2VydmljZS5wcmVmaXgubGVuZ3RoKVxuXHRcdFx0cm91dGUuc2V0KGhyZWYsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKVxuXHRcdH1cblx0fVxuXHRyb3V0ZS5wYXJhbSA9IGZ1bmN0aW9uKGtleTMpIHtcblx0XHRpZih0eXBlb2YgYXR0cnMzICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBrZXkzICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gYXR0cnMzW2tleTNdXG5cdFx0cmV0dXJuIGF0dHJzM1xuXHR9XG5cdHJldHVybiByb3V0ZVxufVxubS5yb3V0ZSA9IF8yMCh3aW5kb3csIHJlZHJhd1NlcnZpY2UpXG5tLndpdGhBdHRyID0gZnVuY3Rpb24oYXR0ck5hbWUsIGNhbGxiYWNrMSwgY29udGV4dCkge1xuXHRyZXR1cm4gZnVuY3Rpb24oZSkge1xuXHRcdGNhbGxiYWNrMS5jYWxsKGNvbnRleHQgfHwgdGhpcywgYXR0ck5hbWUgaW4gZS5jdXJyZW50VGFyZ2V0ID8gZS5jdXJyZW50VGFyZ2V0W2F0dHJOYW1lXSA6IGUuY3VycmVudFRhcmdldC5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpKVxuXHR9XG59XG52YXIgXzI4ID0gY29yZVJlbmRlcmVyKHdpbmRvdylcbm0ucmVuZGVyID0gXzI4LnJlbmRlclxubS5yZWRyYXcgPSByZWRyYXdTZXJ2aWNlLnJlZHJhd1xubS5yZXF1ZXN0ID0gcmVxdWVzdFNlcnZpY2UucmVxdWVzdFxubS5qc29ucCA9IHJlcXVlc3RTZXJ2aWNlLmpzb25wXG5tLnBhcnNlUXVlcnlTdHJpbmcgPSBwYXJzZVF1ZXJ5U3RyaW5nXG5tLmJ1aWxkUXVlcnlTdHJpbmcgPSBidWlsZFF1ZXJ5U3RyaW5nXG5tLnZlcnNpb24gPSBcIjEuMS4zXCJcbm0udm5vZGUgPSBWbm9kZVxuaWYgKHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIpIG1vZHVsZVtcImV4cG9ydHNcIl0gPSBtXG5lbHNlIHdpbmRvdy5tID0gbVxufSgpKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbWl0aHJpbC9taXRocmlsLmpzXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n')},function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\nexports.fakeClick = exports.hexToRgba = exports.popoverContent = exports.summary = exports.legend = exports.ta2stuff = exports.spliceLinksForNode = exports.findNode = exports.findNodeIndex = exports.clickVar = exports.reset = exports.nodes = exports.allNodes = exports.valueKey = exports.zparams = exports.logArray = exports.righttab = exports.summaryHold = exports.subset = exports.lefttab = exports.timeColor = exports.varColor = exports.nomColor = exports.gr2Color = exports.gr1Color = exports.dvColor = exports.csColor = exports.cdb = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();\n\nvar _arguments = arguments;\nexports.main = main;\nexports.getVariableData = getVariableData;\nexports.forceSwitch = forceSwitch;\nexports.lockDescription = lockDescription;\nexports.estimate = estimate;\nexports.runPreprocess = runPreprocess;\nexports.erase = erase;\nexports.tabLeft = tabLeft;\nexports.tabRight = tabRight;\nexports.panelPlots = panelPlots;\nexports.borderState = borderState;\nexports.subsetSelect = subsetSelect;\nexports.endsession = endsession;\nexports.listpipelines = listpipelines;\nexports.executepipeline = executepipeline;\nexports.expandrightpanel = expandrightpanel;\nexports.bivariatePlot = bivariatePlot;\nexports.setxTable = setxTable;\n\nvar _mithril = __webpack_require__(0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _plots = __webpack_require__(2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// hostname default - the app will use it to obtain the variable metadata\n// (ddi) and pre-processed data info if the file id is supplied as an\n// argument (for ex., gui.html?dfId=17), but hostname isn\'t.\n// Edit it to suit your installation.\n// (NOTE that if the file id isn\'t supplied, the app will default to the\n// local files specified below!)\n// NEW: it is also possible now to supply complete urls for the ddi and\n// the tab-delimited data file; the parameters are ddiurl and dataurl.\n// These new parameters are optional. If they are not supplied, the app\n// will go the old route - will try to cook standard dataverse urls\n// for both the data and metadata, if the file id is supplied; or the\n// local files if nothing is supplied.\n\n\n//-------------------------------------------------\n// NOTE: global variables are now set in the index.html file.\n//    Developers, see /template/index.html\n//-------------------------------------------------\n\n// for debugging - if in production, prints args and returns them\nvar cdb = exports.cdb = function cdb(_) {\n    return production || console.log.apply(undefined, _arguments) && _arguments;\n};\n\nvar k = 4; // strength parameter for group attraction/repulsion\n\n// initial color scale used to establish the initial colors of nodes\n// allNodes.push() below establishes a field for the master node array allNodes called "nodeCol" and assigns a color from this scale to that field\n// everything there after should refer to the nodeCol and not the color scale, this enables us to update colors and pass the variable type to R based on its coloring\nvar colors = d3.scale.category20();\nvar csColor = exports.csColor = \'#419641\';\nvar dvColor = exports.dvColor = \'#28a4c9\';\nvar gr1Color = exports.gr1Color = \'#14bdcc\'; // initially was #24a4c9\', but that is dvColor, and we track some properties by color assuming them unique\nvar gr1Opacity = [0, 1];\nvar gr2Color = exports.gr2Color = \'#ffcccc\';\nvar gr2Opacity = [0, 1];\n\nvar grayColor = \'#c0c0c0\';\nvar nomColor = exports.nomColor = \'#ff6600\';\nvar varColor = exports.varColor = \'#f0f8ff\'; // d3.rgb("aliceblue");\nvar taggedColor = \'#f5f5f5\'; // d3.rgb("whitesmoke");\nvar timeColor = exports.timeColor = \'#2d6ca2\';\n\nvar lefttab = exports.lefttab = \'tab1\'; // current tab in left panel\nvar subset = exports.subset = false;\nvar summaryHold = exports.summaryHold = false;\nvar righttab = exports.righttab = \'btnModels\'; // current tab in right panel\n\n// transformation toolbar options\nvar t = void 0,\n    typeTransform = void 0;\nvar transformList = \'log(d) exp(d) d^2 sqrt(d) interact(d,e)\'.split(\' \');\nvar transformVar = \'\';\n\n// var list for each space contain variables in original data\n// plus trans in that space\nvar trans = [];\nvar preprocess = {}; // hold pre-processed data\nvar spaces = [];\n\n// layout function constants\nvar layoutAdd = "add";\nvar layoutMove = "move";\n\n// Radius of circle\nvar allR = 40;\nvar ind1 = [(allR + 30) * Math.cos(1.3), -1 * (allR + 30) * Math.sin(1.3), 5]; // cx, cy, r  values for indicator lights\nvar ind2 = [(allR + 30) * Math.cos(1.1), -1 * (allR + 30) * Math.sin(1.1), 5]; // cx, cy, r  values for indicator lights\n\n\n// space index\nvar myspace = 0;\n\nvar forcetoggle = ["true"];\nvar locktoggle = true;\nvar priv = true;\n\nvar logArray = exports.logArray = [];\nvar zparams = exports.zparams = {\n    zdata: [],\n    zedges: [],\n    ztime: [],\n    znom: [],\n    zcross: [],\n    zmodel: "",\n    zvars: [],\n    zdv: [],\n    zgroup1: [],\n    zgroup2: [], // hard coding to two groups for present experiments, but will eventually make zgroup array of arrays, with zgroup.lenght the number of groups\n    zdataurl: "",\n    zd3mdata: "", //these take the place of zdataurl for d3m, because data is in two placees. eventually will generalize\n    zd3mtarget: "",\n    zsubset: [],\n    zsetx: [],\n    zmodelcount: 0,\n    zplot: [],\n    zsessionid: "",\n    zdatacite: ""\n};\n\nvar modelCount = 0;\nvar valueKey = exports.valueKey = [];\nvar allNodes = exports.allNodes = [];\nvar allResults = [];\nvar nodes = exports.nodes = [];\nvar links = [];\nvar mods = {};\nvar estimated = false;\nvar rightClickLast = false;\nvar selInteract = false;\nvar callHistory = []; // transform and subset calls\nvar mytarget = "";\n\n//eventually read this from the schema with real descriptions\n// metrics, tasks, and subtasks as specified in D3M schemas\n// MEAN SQUARED ERROR IS SET TO SAME AS RMSE. MSE is in schema but not proto\nvar d3mMetrics = { metricUndefined: ["description", "METRIC_UNDEFINED", 0],\n    accuracy: ["description", "ACCURACY", 1],\n    f1: ["description", "F1", 2],\n    f1Micro: ["description", "F1_MICRO", 3],\n    f1Macro: ["description", "F1_MACRO", 4],\n    rocAuc: ["description", "ROC_AUC", 5],\n    rocAucMicro: ["description", "ROC_AUC_MICRO", 6],\n    rocAucMacro: ["description", "ROC_AUC_MACRO", 7],\n    meanSquaredError: ["description", "MEAN_SQUARED_ERROR", 8],\n    rootMeanSquaredError: ["description", "ROOT_MEAN_SQUARED_ERROR", 8],\n    rootMeanSquaredErrorAvg: ["description", "ROOT_MEAN_SQUARED_ERROR_AVG", 9],\n    meanAbsoluteError: ["description", "MEAN_ABSOLUTE_ERROR", 10],\n    rSquared: ["description", "R_SQUARED", 11],\n    normalizedMutualInformation: ["description", "NORMALIZED_MUTUAL_INFORMATION", 12],\n    jaccardSimilarityScore: ["description", "JACCARD_SIMILARITY_SCORE", 13],\n    executionTime: ["description", "EXECUTION_TIME", 14] };\n\nvar d3mTaskType = { taskTypeUndefined: ["description", "TASK_TYPE_UNDEFINED", 0], classification: ["description", "CLASSIFICATION", 1],\n    regression: ["description", "REGRESSION", 2],\n    similarityMatching: ["description", "SIMILARITY_MATCHING", 3],\n    linkPrediction: ["description", "LINK_PREDICTION", 4],\n    vertexNomination: ["description", "VERTEX_NOMINATION", 5],\n    communityDetection: ["description", "COMMUNITY_DETECTION", 6],\n    graphMatching: ["description", "GRAPH_MATCHING", 7],\n    timeseriesForecasting: ["description", "TIMESERIES_FORECASTING", 8],\n    collaborativeFiltering: ["description", "COLLABORATIVE_FILTERING", 9] };\n\nvar d3mTaskSubtype = { taskSubtypeUndefined: ["description", "TASK_SUBTYPE_UNDEFINED", 0],\n    subtypeNone: ["description", "NONE", 1],\n    binary: ["description", "BINARY", 2],\n    multiClass: ["description", "MULTICLASS", 3],\n    multiLabel: ["description", "MULTILABEL", 4],\n    uniVariate: ["description", "UNIVARIATE", 5],\n    multiVariate: ["description", "MULTIVARIATE", 6],\n    overlapping: ["description", "OVERLAPPING", 7],\n    nonOverlapping: ["description", "NONOVERLAPPING", 8] };\n\nvar d3mOutputType = { outputUndefined: ["description", "OUTPUT_TYPE_UNDEFINED ", 0],\n    classLabel: ["description", "CLASS_LABEL", 1],\n    probability: ["description", "PROBABILITY", 2],\n    real: ["description", "REAL", 3],\n    nodeID: ["description", "NODE_ID", 4],\n    vectorClassLabel: ["description", "VECTOR_CLASS_LABEL", 5],\n    vectorStochastic: ["description", "VECTOR_STOCHASTIC", 6],\n    vectorReal: ["description", "VECTOR_REAL", 7],\n    file: ["description", "FILE", 8] };\n\nvar d3mProblemDescription = {\n    taskType: [2, "DEFAULT"],\n    taskSubtype: [1, "DEFAFULT"],\n    outputType: [3, "DEFAULT"],\n    metric: [4, "DEFAULT"],\n    taskDescription: "" };\n\nvar svg = void 0,\n    width = void 0,\n    height = void 0,\n    div = void 0,\n    estimateLadda = void 0,\n    selectLadda = void 0;\nvar arc1 = void 0,\n    arc3 = void 0,\n    arc4 = void 0,\n    arcInd1 = void 0,\n    arcInd2 = void 0;\n\nvar arcInd1Limits = [0, 0.3];\nvar arcInd2Limits = [0.35, 0.65];\n\nvar byId = function byId(id) {\n    return document.getElementById(id);\n};\n\n// page reload linked to btnReset\nvar reset = exports.reset = function reloadPage() {\n    location.reload();\n};\n\nvar dataurl = "";\nfunction main(fileid, hostname, ddiurl, dataurl, apikey) {\n    dataurl = dataurl;\n    if (production && fileid == "") {\n        alert("Error: No fileid has been provided.");\n        throw new Error("Error: No fileid has been provided.");\n    }\n\n    var dataverseurl = hostname ? "https://" + hostname : production ? DATAVERSE_URL : "http://localhost:8080";\n\n    if (fileid && !dataurl) {\n        // file id supplied; assume we are dealing with dataverse and cook a standard dataverse data access url\n        // with the fileid supplied and the hostname we have supplied or configured\n        dataurl = dataverseurl + "/api/access/datafile/" + fileid;\n        // rp; temporarily remove this\n        dataurl = dataurl + "?key=" + apikey;\n    }\n    cdb(\'--dataurl: \' + dataurl);\n    cdb(\'--dataverseurl: \' + dataverseurl);\n    svg = d3.select("#whitespace");\n\n    var tempWidth = d3.select("#main.left").style("width");\n    width = tempWidth.substring(0, tempWidth.length - 2);\n    height = $(window).height() - 120; // Hard coding for header and footer and bottom margin.\n\n    estimateLadda = Ladda.create(byId("btnEstimate"));\n    selectLadda = Ladda.create(byId("btnSelect"));\n\n    var colorTime = false;\n    var colorCS = false;\n\n    var depVar = false;\n    var subsetdiv = false;\n    var setxdiv = false;\n\n    // width and height for histgrams\n    var barwidth = 1.3 * allR;\n    var barheight = 0.5 * allR;\n    var barPadding = 0.35;\n    var barnumber = 7;\n\n    // arcs for denoting pebble characteristics\n    var arc = function arc(start, end) {\n        return d3.svg.arc().innerRadius(allR + 5).outerRadius(allR + 20).startAngle(start).endAngle(end);\n    };\n    var arcInd = function arcInd(arclimits) {\n        return d3.svg.arc().innerRadius(allR + 22).outerRadius(allR + 37).startAngle(arclimits[0]).endAngle(arclimits[1]);\n    };\n\n    var _ref = [arc(0, 3.2), arc(1.1, 2.2)],\n        arc0 = _ref[0],\n        arc2 = _ref[1];\n    //arc1 = arc(1.3, 2.3);\n\n    arc1 = arc(0, 1);\n    arc3 = arc(2.3, 3.3);\n    arc4 = arc(4.3, 5.3);\n\n    arcInd1 = arcInd(arcInd1Limits);\n    arcInd2 = arcInd(arcInd2Limits);\n\n    // indicators for showing membership above arcs\n    // let indicator = (degree) => d3.svg.circle()\n    //     .cx( allR )//(allR+35) * Math.sin(degree))\n    //     .cy( allR )//(allR+35) * Math.cos(degree))\n    //     .r(3);\n    // ind1 = indicator(1);\n    // ind2 = indicator(1.2);\n\n    // from .csv\n    var dataset2 = [];\n    var lablArray = [];\n    var hold = [];\n    var subsetNodes = [];\n\n    // collapsable user log\n    $(\'#collapseLog\').on(\'shown.bs.collapse\', function () {\n        return d3.select("#collapseLog div.panel-body").selectAll("p").data(logArray).enter().append("p").text(function (d) {\n            return d;\n        });\n    });\n    $(\'#collapseLog\').on(\'hidden.bs.collapse\', function () {\n        return d3.select("#collapseLog div.panel-body").selectAll("p").remove();\n    });\n\n    //set start from user input, then assume locations are consistent based on d3m directory structure (alternatively can make each of these locations be set by user)\n    var configurations = {};\n    var d3mRootPath = "";\n    var d3mDataName = "";\n    var d3mData = "";\n    var d3mTarget = "";\n    var d3mPreprocess = "";\n    var d3mPS = "";\n    var d3mDS = "";\n\n    // default to California PUMS subset (should, doesn\'t actually do that)\n    var data = \'data/\' + (false ? \'PUMS5small\' : \'fearonLaitin\');\n    var metadataurl = ddiurl || (fileid ? dataverseurl + \'/api/meta/datafile/\' + fileid : data + \'.xml\');\n    // read pre-processed metadata and data\n    var pURL = dataurl ? dataurl + \'&format=prep\' : data + \'.json\';\n    cdb(\'pURL: \' + pURL);\n\n    console.log("pURL is: " + pURL);\n\n    if (IS_D3M_DOMAIN) {\n        pURL = d3mPreprocess;\n        // zparams.zdataurl = start+\'/data/trainDatamerged.tsv\';\n        zparams.zdata = d3mDataName;\n    } else if (!production) {\n        zparams.zdataurl = \'data/fearonLaitin.tsv\';\n    }\n\n    // loads all external data: metadata (DVN\'s ddi), preprocessed (for plotting distributions), and zeligmodels (produced by Zelig) and initiates the data download to the server\n    Promise.resolve(IS_D3M_DOMAIN && _mithril2.default.request({\n        method: "POST",\n        url: "/config/d3m-config/json/latest"\n    }).then(function (result) {\n        configurations = JSON.parse(JSON.stringify(result));\n        d3mRootPath = configurations.training_data_root;\n        d3mRootPath = d3mRootPath.replace(/\\/data/, \'\');\n        d3mDataName = configurations.name;\n        d3mData = configurations.training_data_root + "/trainData.csv";\n        d3mTarget = result.training_data_root + "/trainTargets.csv";\n        d3mPS = configurations.problem_schema;\n        d3mDS = configurations.dataset_schema;\n\n        // doing this for now, assuming everything after TwoRavens is readable\n        d3mPS = d3mPS.split("TwoRavens/").pop();\n        d3mDS = d3mDS.split("TwoRavens/").pop();\n        d3mTarget = d3mTarget.split("TwoRavens/").pop();\n        d3mData = d3mData.split("TwoRavens/").pop();\n        d3mRootPath = d3mRootPath.split("TwoRavens/").pop();\n        pURL = \'rook-custom/rook-files/\' + d3mDataName + \'/preprocess/preprocess.json\';\n        d3mPreprocess = pURL;\n        zparams.zd3mdata = d3mData;\n        zparams.zd3mtarget = d3mTarget;\n    })).then(function (_) {\n        return _mithril2.default.request(pURL);\n    })\n    // do nothing if preprocess.json already exists, else runPreprocess\n    .then(null, function (_) {\n        return runPreprocess(d3mData, d3mTarget, d3mDataName);\n    }).then(function (data) {\n        return readPreprocess(data);\n    }).then(function () {\n        return new Promise(function (resolve, reject) {\n            return d3.xml(metadataurl, \'application/xml\', function (xml) {\n                var vars = Object.keys(preprocess); // this doesn\'t come from xml, but from preprocessed json\n                // the labels, citations, and file name come from the \'xml\' (metadataurl), which is the file from the data repo\n                // however, TwoRavens should function using only the data that comes from our preprocess script, which is the \'json\' (pURL)\n                // for now the metadataurl is still Fearon & Laitin\n                var temp = xml.documentElement.getElementsByTagName("fileName");\n                if (!IS_D3M_DOMAIN) zparams.zdata = temp[0].childNodes[0].nodeValue;\n\n                var cite = xml.documentElement.getElementsByTagName("biblCit");\n                // clean citation so POST is valid json\n                zparams.zdatacite = cite[0].childNodes[0].nodeValue.replace(/\\&/g, "and").replace(/\\;/g, ",").replace(/\\%/g, "-");\n                $(\'#cite div.panel-body\').text(zparams.zdatacite);\n\n                // dataset name trimmed to 12 chars\n                var dataname = zparams.zdata;\n                if (!IS_D3M_DOMAIN) dataname = zparams.zdata.replace(/\\.(.*)/, \'\'); // drop file extension\n                d3.select("#dataName").html(dataname);\n\n                // Put dataset name, from meta-data, into page title\n                d3.select("title").html("TwoRavens " + dataname);\n                // temporary values for hold that correspond to histogram bins\n                hold = [.6, .2, .9, .8, .1, .3, .4];\n                for (var i = 0; i < vars.length; i++) {\n                    // valueKey[i] = vars[i].attributes.name.nodeValue;\n                    // lablArray[i] = varsXML[i].getElementsByTagName("labl").length == 0 ?\n                    // "no label" :\n                    // varsXML[i].getElementsByTagName("labl")[0].childNodes[0].nodeValue;\n                    // let datasetcount = d3.layout.histogram()\n                    //     .bins(barnumber).frequency(false)\n                    //     ([0, 0, 0, 0, 0]);\n                    valueKey[i] = vars[i];\n                    lablArray[i] = "no label";\n                    // contains all the preprocessed data we have for the variable, as well as UI data pertinent to that variable,\n                    // such as setx values (if the user has selected them) and pebble coordinates\n                    var obj = {\n                        id: i,\n                        reflexive: false,\n                        name: valueKey[i],\n                        labl: lablArray[i],\n                        data: [5, 15, 20, 0, 5, 15, 20],\n                        count: hold,\n                        nodeCol: colors(i),\n                        baseCol: colors(i),\n                        strokeColor: _plots.selVarColor,\n                        strokeWidth: "1",\n                        subsetplot: false,\n                        subsetrange: ["", ""],\n                        setxplot: false,\n                        setxvals: ["", ""],\n                        grayout: false,\n                        group1: false,\n                        group2: false,\n                        forefront: false\n                    };\n                    jQuery.extend(true, obj, preprocess[valueKey[i]]);\n                    allNodes.push(obj);\n                };\n                resolve();\n            });\n        });\n    }).then(function () {\n        return new Promise(function (resolve, reject) {\n            // read zelig models and populate model list in right panel\n            d3.json("data/zelig5models.json", function (err, data) {\n                if (err) return reject(err);\n                cdb("zelig models json: ", data);\n                for (var key in data.zelig5models) {\n                    if (data.zelig5models.hasOwnProperty(key)) mods[data.zelig5models[key].name[0]] = data.zelig5models[key].description[0];\n                }resolve();\n            });\n        });\n    }).then(function () {\n        return new Promise(function (resolve, reject) {\n            if (IS_D3M_DOMAIN) return resolve();\n            d3.json("data/zelig5choicemodels.json", function (err, data) {\n                if (err) return reject(err);\n                cdb("zelig choice models json: ", data);\n                for (var key in data.zelig5choicemodels) {\n                    if (data.zelig5choicemodels.hasOwnProperty(key)) mods[data.zelig5choicemodels[key].name[0]] = data.zelig5choicemodels[key].description[0];\n                }scaffolding(layout);\n                dataDownload();\n                resolve();\n            });\n        });\n    }).then(function () {\n        return new Promise(function (resolve, reject) {\n            // read in problem schema and we\'ll make a call to start the session with TA2. if we get this far, data are guaranteed to exist for the frontend\n            if (!IS_D3M_DOMAIN) return resolve();\n\n            d3.json(d3mPS, function (_, data) {\n                console.log("prob schema data: ", data);\n                mytarget = data.target.field;\n                var aTag = document.createElement(\'a\');\n                aTag.setAttribute(\'href\', d3mRootPath + \'/\' + data.descriptionFile);\n                aTag.setAttribute(\'id\', "probdesc");\n                aTag.setAttribute(\'target\', "_blank");\n                aTag.textContent = "Problem Description";\n                document.getElementById("ticker").appendChild(aTag);\n\n                if (data.taskType in d3mTaskType) {\n                    d3mProblemDescription.taskType = data.taskType; //[d3mTaskType[data.taskType][2],d3mTaskType[data.taskType][1]]; console.log(d3mProblemDescription);\n                } else {\n                    d3mProblemDescription.taskType = "taskTypeUndefined";\n                    //   alert("Specified task type, " + data.taskType + ", is not valid.");\n                }\n\n                if (data.taskSubType in d3mTaskSubtype) {\n                    d3mProblemDescription.taskSubtype = data.taskSubType;\n                    //[d3mTaskSubtype[data.taskSubType][2],d3mTaskSubtype[data.taskSubType][1]];\n                } else {\n                    d3mProblemDescription.taskSubtype = "taskSubtypeUndefined";\n                    //     alert("Specified task subtype, " + data.taskSubType + ", is not valid.")\n                }\n                if (data.metric in d3mMetrics) {\n                    d3mProblemDescription.metric = data.metric; //[d3mMetrics[data.metric][2],d3mMetrics[data.metric][1]];\n                } else {\n                    d3mProblemDescription.metric = "metricUndefined";\n                    // alert("Specified metric type, " + data.metric + ", is not valid.");\n                }\n                if (data.outputType in d3mOutputType) {\n                    d3mProblemDescription.outputType = data.outputType; //[d3mOutputType[data.outputType][2],d3mOutputType[data.outputType][1]];\n                } else {\n                    d3mProblemDescription.outputType = "outputUndefined";\n                    //  alert("Specified output type, " + data.outputType + ", is not valid.");\n                }\n\n                d3mProblemDescription.taskDescription = data.descriptionFile;\n\n                document.getElementById("btnType").click();\n                resolve();\n            });\n        });\n    }).then(function () {\n        return new Promise(function (resolve, reject) {\n            if (!IS_D3M_DOMAIN) return resolve();\n            // this is our call to django to start the session\n            //rpc StartSession(SessionRequest) returns (SessionResponse) {}\n            var user_agent = "some agent";\n            var version = "some version";\n            var SessionRequest = { user_agent: user_agent, version: version };\n\n            var jsonout = JSON.stringify(SessionRequest);\n            var urlcall = d3mURL + "/startsession";\n            var solajsonout = "grpcrequest=" + jsonout;\n            console.log("SessionRequest: ");\n            console.log(solajsonout);\n            console.log("urlcall: ", urlcall);\n\n            function ssSuccess(btn, SessionResponse) {\n                zparams.zsessionid = SessionResponse.context.sessionId;\n                console.log("startsession: ", SessionResponse);\n\n                scaffolding(layout);\n                zPop(); // called in dataDownload, but required to be called so moved here for IS_D3M_DOMAIN\n                //dataDownload();  we do not call dataDownload in IS_D3M_DOMAIN. we assume we have the path to the data already\n                resolve();\n            }\n\n            function ssFail(btn) {\n                alert("StartSession has failed.");\n                resolve();\n            }\n\n            makeCorsRequest(urlcall, "nobutton", ssSuccess, ssFail, solajsonout);\n        });\n    });\n}\n\nvar $fill = function $fill(obj, op, d1, d2) {\n    return d3.select(obj).transition().attr(\'fill-opacity\', op).delay(d1).duration(d2);\n};\nvar fill = function fill(d, id, op, d1, d2) {\n    return $fill(\'#\' + id + d.id, op, d1, d2);\n};\nvar fillThis = function fillThis(self, op, d1, d2) {\n    return $fill(self, op, d1, d2);\n};\n\n// scaffolding is called after all external data are guaranteed to have been read to completion. this populates the left panel with variable names, the right panel with model names, the transformation tool, an the associated mouseovers. its callback is layout(), which initializes the modeling space\nfunction scaffolding(callback) {\n    var _this = this;\n\n    // establishing the transformation element\n    d3.select("#transformations").append("input").attr("id", "tInput").attr("class", "form-control").attr("type", "text").attr("value", "Variable transformation");\n\n    // variable dropdown\n    d3.select("#transformations").append("ul").attr("id", "transSel").style("display", "none").style("background-color", varColor).selectAll(\'li\').data(["a", "b"]) //set to variables in model space as they\'re added\n    .enter().append("li").text(function (d) {\n        return d;\n    });\n\n    // function dropdown\n    d3.select("#transformations").append("ul").attr("id", "transList").style("display", "none").style("background-color", varColor).selectAll(\'li\').data(transformList).enter().append("li").text(function (d) {\n        return d;\n    });\n\n    $(\'#tInput\').click(function () {\n        var t = byId(\'transSel\').style.display;\n        if (t !== "none") {\n            // if variable list is displayed when input is clicked...\n            $(\'#transSel\').fadeOut(100);\n            return false;\n        }\n        var t1 = byId(\'transList\').style.display;\n        if (t1 !== "none") {\n            // if function list is displayed when input is clicked...\n            $(\'#transList\').fadeOut(100);\n            return false;\n        }\n\n        // highlight the text\n        $(_this).select();\n        var pos = $(\'#tInput\').offset();\n        pos.top += $(\'#tInput\').width();\n        $(\'#transSel\').fadeIn(100);\n        return false;\n    });\n\n    var n;\n    $(\'#tInput\').keyup(function (evt) {\n        var t = byId(\'transSel\').style.display;\n        var t1 = byId(\'transList\').style.display;\n        if (t != "none") $(\'#transSel\').fadeOut(100);else if (t1 != "none") $(\'#transList\').fadeOut(100);\n\n        if (evt.keyCode == 13) {\n            // keyup on Enter\n            n = $(\'#tInput\').val();\n            var t = transParse(n = n);\n            if (!t) return;\n            transform(n = t.slice(0, t.length - 1), t = t[t.length - 1], typeTransform = false);\n        }\n    });\n\n    var t;\n    $(\'#transList li\').click(function (evt) {\n        // if interact is selected, show variable list again\n        if ($(this).text() == "interact(d,e)") {\n            $(\'#tInput\').val(tvar.concat(\'*\'));\n            selInteract = true;\n            $(this).parent().fandeOut(100);\n            $(\'#transSel\').fadeIn(100);\n            evt.stopPropagation();\n            return;\n        }\n\n        var tvar = $(\'#tInput\').val();\n        var tfunc = $(this).text().replace("d", "_transvar0");\n        var tcall = $(this).text().replace("d", tvar);\n        $(\'#tInput\').val(tcall);\n        $(this).parent().fadeOut(100);\n        evt.stopPropagation();\n        transform(n = tvar, t = tfunc, typeTransform = false);\n    });\n\n    d3.select("#models").style(\'height\', 2000).style(\'overfill\', \'scroll\');\n\n    if (!IS_D3M_DOMAIN) {\n        d3.select("#models").selectAll("p").data(Object.keys(mods)).enter().append("p").attr("id", "_model_".concat).text(function (d) {\n            return d;\n        }).style(\'background-color\', function (d) {\n            return varColor;\n        }).attr("data-container", "body").attr("data-toggle", "popover").attr("data-trigger", "hover").attr("data-placement", "top").attr("data-html", "true").attr("onmouseover", "$(this).popover(\'toggle\');").attr("onmouseout", "$(this).popover(\'toggle\');").attr("data-original-title", "Model Description").attr("data-content", function (d) {\n            return mods[d];\n        });\n    }\n    if (IS_D3M_DOMAIN) {\n\n        //\n\n        toggleRightButtons("tasks");\n\n        d3.select("#types").selectAll("p").data(Object.keys(d3mTaskType)).enter().append("p").attr("id", function (d) {\n            return d + ".types";\n        }).text(function (d) {\n            return d;\n        }).attr(\'class\', function (d) {\n            if (d3mProblemDescription.taskType == d.toString()) {\n                return \'item-select\';\n            } else {\n                if (locktoggle) return \'item-default item-lineout\';\n                return \'item-default\';\n            }\n        }).attr("data-container", "body").attr("data-toggle", "popover").attr("data-trigger", "hover").attr("data-placement", "top").attr("data-html", "true").attr("onmouseover", "$(this).popover(\'toggle\');").attr("onmouseout", "$(this).popover(\'toggle\');").attr("data-original-title", "Task Description").attr("data-content", function (d) {\n            return d3mTaskType[d][1];\n        });\n\n        d3.select("#subtypes").selectAll("p").data(Object.keys(d3mTaskSubtype)).enter().append("p").attr("id", function (d) {\n            return d + ".subtypes";\n        }).text(function (d) {\n            return d;\n        }).attr(\'class\', function (d) {\n            if (d3mProblemDescription.taskSubtype == d.toString()) {\n                return \'item-select\';\n            } else {\n                if (locktoggle) return \'item-default item-lineout\';\n                return \'item-default\';\n            }\n        }).attr("data-container", "body").attr("data-toggle", "popover").attr("data-trigger", "hover").attr("data-placement", "top").attr("data-html", "true").attr("onmouseover", "$(this).popover(\'toggle\');").attr("onmouseout", "$(this).popover(\'toggle\');").attr("data-original-title", "Task Subtype Desc.").attr("data-content", function (d) {\n            return d3mTaskSubtype[d][1];\n        });\n\n        d3.select("#metrics").selectAll("p").data(Object.keys(d3mMetrics)).enter().append("p").attr("id", function (d) {\n            return d + ".metrics";\n        }).text(function (d) {\n            return d;\n        }).attr(\'class\', function (d) {\n            if (d3mProblemDescription.metric == d.toString()) {\n                return \'item-select\';\n            } else {\n                if (locktoggle) return \'item-default item-lineout\';\n                return \'item-default\';\n            }\n        }).attr("data-container", "body").attr("data-toggle", "popover").attr("data-trigger", "hover").attr("data-placement", "top").attr("data-html", "true").attr("onmouseover", "$(this).popover(\'toggle\');").attr("onmouseout", "$(this).popover(\'toggle\');").attr("data-original-title", "Metric Description").attr("data-content", function (d) {\n            return d3mMetrics[d][1];\n        });\n\n        d3.select("#outputs").selectAll("p").data(Object.keys(d3mOutputType)).enter().append("p").attr("id", function (d) {\n            return d + ".outputs";\n        }).text(function (d) {\n            return d;\n        }).attr(\'class\', function (d) {\n            if (d3mProblemDescription.outputType == d.toString()) {\n                return \'item-select\';\n            } else {\n                if (locktoggle) return \'item-default item-lineout\';\n                return \'item-default\';\n            }\n        }).attr("data-container", "body").attr("data-toggle", "popover").attr("data-trigger", "hover").attr("data-placement", "top").attr("data-html", "true").attr("onmouseover", "$(this).popover(\'toggle\');").attr("onmouseout", "$(this).popover(\'toggle\');").attr("data-original-title", "Output Description").attr("data-content", function (d) {\n            return d3mOutputType[d][1];\n        });\n    }\n\n    // call layout() because at this point all scaffolding is up and ready\n    if (typeof callback == "function") {\n        callback(false, true);\n        _mithril2.default.redraw();\n    }\n}\n\nvar splice = function splice(color, text) {\n    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        args[_key - 2] = arguments[_key];\n    }\n\n    args.forEach(function (x) {\n        if (color != x[0]) return;\n        var idx = zparams[x[1]].indexOf(text);\n        idx > -1 && zparams[x[1]].splice(idx, 1);\n    });\n};\n\nvar clickVar = exports.clickVar = void 0;\n\nfunction layout(v, v2) {\n    var myValues = [];\n    exports.nodes = nodes = [];\n    links = [];\n\n    svg.append("svg:defs").append("svg:marker").attr("id", "group1-arrow").attr(\'viewBox\', \'0 -5 15 15\').attr("refX", 2.5).attr("refY", 0).attr("markerWidth", 3).attr("markerHeight", 3).attr("orient", "auto").append("path").attr(\'d\', \'M0,-5L10,0L0,5\').style("fill", gr1Color);\n\n    svg.append("svg:defs").append("svg:marker").attr("id", "group2-arrow").attr(\'viewBox\', \'0 -5 15 15\').attr("refX", 2.5).attr("refY", 0).attr("markerWidth", 3).attr("markerHeight", 3).attr("orient", "auto").append("path").attr(\'d\', \'M0,-5L10,0L0,5\').style("fill", gr2Color);\n\n    var line = svg.append("line").style(\'fill\', \'none\').style(\'stroke\', gr1Color).style(\'stroke-width\', 5).attr("marker-end", "url(#group1-arrow)");\n\n    var line2 = svg.append("line").style(\'fill\', \'none\').style(\'stroke\', gr2Color).style(\'stroke-width\', 5).attr("marker-end", "url(#group2-arrow)");;\n\n    var visbackground = d3.select("#whitespace").append("svg").attr("width", width).attr("height", height);\n\n    visbackground.append("path") // note lines, are behind group hulls of which there is a white and colored semi transparent layer\n    .attr("id", \'gr1background\').style("fill", \'#ffffff\').style("stroke", \'#ffffff\').style("stroke-width", 2.5 * allR).style(\'stroke-linejoin\', \'round\').style("opacity", 1);\n\n    var vis2background = d3.select("#whitespace").append("svg").attr("width", width).attr("height", height);\n\n    vis2background.append("path").attr("id", \'gr1background\').style("fill", \'#ffffff\').style("stroke", \'#ffffff\').style("stroke-width", 2.5 * allR).style(\'stroke-linejoin\', \'round\').style("opacity", 1);\n\n    var vis = d3.select("#whitespace").append("svg").attr("width", width).attr("height", height);\n\n    vis.append("path").attr("id", \'gr1hull\').style("fill", gr1Color).style("stroke", gr1Color).style("stroke-width", 2.5 * allR).style(\'stroke-linejoin\', \'round\');\n\n    var vis2 = d3.select("#whitespace").append("svg").attr("width", width).attr("height", height);\n\n    vis2.append("path").style("fill", gr2Color).style("stroke", gr2Color).style("stroke-width", 2.5 * allR).style(\'stroke-linejoin\', \'round\');\n\n    if (v == layoutAdd || v == layoutMove) {\n        for (var j = 0; j < zparams.zvars.length; j++) {\n            var ii = findNodeIndex(zparams.zvars[j]);\n            if (allNodes[ii].grayout) continue;\n            nodes.push(allNodes[ii]);\n            var selectMe = zparams.zvars[j].replace(/\\W/g, "_");\n            selectMe = "#".concat(selectMe);\n            d3.select(selectMe).style(\'background-color\', function () {\n                return hexToRgba(nodes[j].strokeColor);\n            });\n        }\n\n        for (var j = 0; j < zparams.zedges.length; j++) {\n            var mysrc = nodeIndex(zparams.zedges[j][0]);\n            var mytgt = nodeIndex(zparams.zedges[j][1]);\n            links.push({\n                source: nodes[mysrc],\n                target: nodes[mytgt],\n                left: false,\n                right: true\n            });\n        }\n    } else {\n        if (IS_D3M_DOMAIN) {\n            //nodes = [findNode(mytarget)];               // Only add dependent variable on startup\n            exports.nodes = nodes = allNodes.slice(1, allNodes.length); // Add all but first variable on startup (assumes 0 position is d3m index variable)\n            for (var _j = 0; _j < nodes.length; _j++) {\n                //populate zvars array\n                if (nodes[_j].name != mytarget) {\n                    nodes[_j].group1 = true;\n                    zparams.zgroup1.push(nodes[_j].name); // write all names (except d3m index and the dependent variable) to zgroup1 array\n                };\n            };\n        } else if (allNodes.length > 2) {\n            exports.nodes = nodes = [allNodes[0], allNodes[1], allNodes[2]];\n            links = [{\n                source: nodes[1],\n                target: nodes[0],\n                left: false,\n                right: true\n            }, {\n                source: nodes[0],\n                target: nodes[2],\n                left: false,\n                right: true\n            }];\n        } else if (allNodes.length === 2) {\n            exports.nodes = nodes = [allNodes[0], allNodes[1]];\n            links = [{\n                source: nodes[1],\n                target: nodes[0],\n                left: false,\n                right: true\n            }];\n        } else if (allNodes.length === 1) {\n            exports.nodes = nodes = [allNodes[0]];\n        } else {\n            alert("There are zero variables in the metadata.");\n            return;\n        }\n    }\n\n    panelPlots(); // after nodes is populated, add subset and (if !IS_D3M_DOMAIN) setx panels\n\n\n    var force = d3.layout.force().nodes(nodes).links(links).size([width, height]).linkDistance(150).charge(-800).on(\'tick\', tick);\n\n    // define arrow markers for graph links\n    svg.append(\'svg:defs\').append(\'svg:marker\').attr(\'id\', \'end-arrow\').attr(\'viewBox\', \'0 -5 10 10\').attr(\'refX\', 6).attr(\'markerWidth\', 3).attr(\'markerHeight\', 3).attr(\'orient\', \'auto\').append(\'svg:path\').attr(\'d\', \'M0,-5L10,0L0,5\').style(\'fill\', \'#000\');\n\n    svg.append(\'svg:defs\').append(\'svg:marker\').attr(\'id\', \'start-arrow\').attr(\'viewBox\', \'0 -5 10 10\').attr(\'refX\', 4).attr(\'markerWidth\', 3).attr(\'markerHeight\', 3).attr(\'orient\', \'auto\').append(\'svg:path\').attr(\'d\', \'M10,-5L0,0L10,5\').style(\'fill\', \'#000\');\n\n    // line displayed when dragging new nodes\n    var drag_line = svg.append(\'svg:path\').attr(\'class\', \'link dragline hidden\').attr(\'d\', \'M0,0L0,0\');\n\n    // handles to link and node element groups\n    var path = svg.append(\'svg:g\').selectAll(\'path\'),\n        circle = svg.append(\'svg:g\').selectAll(\'g\');\n    //line = svg.append(\'svg:g\').selectAll(\'line\');\n\n    // mouse event vars\n    var selected_node = null,\n        selected_link = null,\n        mousedown_link = null,\n        mousedown_node = null,\n        mouseup_node = null;\n\n    function resetMouseVars() {\n        mousedown_node = null;\n        mouseup_node = null;\n        mousedown_link = null;\n    }\n\n    // update force layout (called automatically each iteration)\n    function tick() {\n\n        function findcoords(findnames, allnames, coords, lengthen) {\n            var fcoords = new Array(findnames.length); // found coordinates\n            var addlocation = 0;\n            if (findnames.length > 0) {\n                for (var j = 0; j < findnames.length; j++) {\n                    addlocation = allnames.indexOf(findnames[j]);\n                    fcoords[j] = coords[addlocation];\n                };\n            };\n\n            if (lengthen) {\n                // d3.geom.hull returns null for two points, and fails if three points are in a line,\n                // so this puts a couple points slightly off the line for two points, or around a singleton.\n                if (fcoords.length == 2) {\n                    var deltax = fcoords[0][0] - fcoords[1][0];\n                    var deltay = fcoords[0][1] - fcoords[1][1];\n                    fcoords.push([(fcoords[0][0] + fcoords[1][0]) / 2 + deltay / 20, (fcoords[0][1] + fcoords[1][1]) / 2 + deltax / 20]);\n                    fcoords.push([(fcoords[0][0] + fcoords[1][0]) / 2 - deltay / 20, (fcoords[0][1] + fcoords[1][1]) / 2 - deltax / 20]);\n                }\n                if (fcoords.length == 1) {\n                    var delta = allR * 0.2;\n                    fcoords.push([fcoords[0][0] + delta, fcoords[0][1]]);\n                    fcoords.push([fcoords[0][0] - delta, fcoords[0][1]]);\n                    fcoords.push([fcoords[0][0], fcoords[0][1] + delta]);\n                    fcoords.push([fcoords[0][0], fcoords[0][1] - delta]);\n                }\n            }\n            return fcoords;\n        };\n\n        // d3.geom.hull returns null for two points, and fails if three points are in a line,\n        // so this puts a couple points slightly off the line for two points, or around a singleton.\n        function lengthencoords(coords) {\n            if (coords.length == 2) {\n                var deltax = coords[0][0] - coords[1][0];\n                var deltay = coords[0][1] - coords[1][1];\n                coords.push([(coords[0][0] + coords[1][0]) / 2 + deltay / 20, (coords[0][1] + coords[1][1]) / 2 + deltax / 20]);\n                coords.push([(coords[0][0] + coords[1][0]) / 2 - deltay / 20, (coords[0][1] + coords[1][1]) / 2 - deltax / 20]);\n            }\n            if (coords.length == 1) {\n                var delta = allR * 0.2;\n                coords.push([coords[0][0] + delta, coords[0][1]]);\n                coords.push([coords[0][0] - delta, coords[0][1]]);\n                coords.push([coords[0][0], coords[0][1] + delta]);\n                coords.push([coords[0][0], coords[0][1] - delta]);\n            }\n            return coords;\n        };\n\n        var coords = nodes.map(function (d) {\n            return [d.x, d.y];\n        });\n        var gr1coords = findcoords(zparams.zgroup1, zparams.zvars, coords, true);\n        var gr2coords = findcoords(zparams.zgroup2, zparams.zvars, coords, true);\n        var depcoords = findcoords(zparams.zdv, zparams.zvars, coords, false);\n\n        // draw convex hull around independent variables, if three or more coordinates given\n        // note, d3.geom.hull returns null if shorter coordinate set than 3,\n        // so findcoords() function has option to lengthen the coordinates returned to bypass this\n        if (gr1coords.length > 2) {\n            line.style("opacity", 1);\n            visbackground.style("opacity", 1);\n            vis.style("opacity", 0.3);\n            var myhull = d3.geom.hull(gr1coords);\n\n            vis.selectAll("path").data([myhull]) // returns null if less than three coordinates\n            .attr("d", function (d) {\n                return "M" + d.join("L") + "Z";\n            });\n            visbackground.selectAll("path").data([myhull]) // returns null if less than three coordinates\n            .attr("d", function (d) {\n                return "M" + d.join("L") + "Z";\n            });\n\n            //var p = d3.geom.polygon(indcoords).centroid();  // Seems to go strange sometimes\n            var p = jamescentroid(gr1coords);\n\n            if (depcoords.length > 0) {\n                var q = depcoords[0]; // Note, only using first dep var currently\n                //var r = findboundary(p,q,gr1coords);        // An approach to find the exact boundary, not presently working\n                var ldeltaX = q[0] - p[0],\n                    ldeltaY = q[1] - p[1],\n                    ldist = Math.sqrt(ldeltaX * ldeltaX + ldeltaY * ldeltaY),\n                    lnormX = 0,\n                    lnormY = 0,\n                    lsourcePadding = allR + 7,\n                    ltargetPadding = allR + 10;\n\n                if (ldist > 0) {\n                    lnormX = ldeltaX / ldist;\n                    lnormY = ldeltaY / ldist;\n                };\n\n                line.attr("x1", p[0] + lsourcePadding * lnormX) // or r[0] if findboundary works\n                .attr("y1", p[1] + lsourcePadding * lnormY) // or r[1] if findboundary works\n                .attr("x2", q[0] - ltargetPadding * lnormX).attr("y2", q[1] - ltargetPadding * lnormY);\n            };\n\n            // group members attract each other, repulse non-group members\n            nodes.forEach(function (n) {\n                var sign = n.group1 ? 1 : -1; //was: Math.sign( zparams.zgroup1.indexOf(n.name) +0.5 );  // 1 if n in group, -1 if n not in group;\n                var ldeltaX = p[0] - n.x,\n                    ldeltaY = p[1] - n.y,\n                    ldist = Math.sqrt(ldeltaX * ldeltaX + ldeltaY * ldeltaY);\n                lnormX = 0, lnormY = 0;\n\n                if (ldist > 0) {\n                    lnormX = ldeltaX / ldist;\n                    lnormY = ldeltaY / ldist;\n                };\n\n                n.x += Math.min(lnormX, ldeltaX / 100) * k * sign * force.alpha();\n                n.y += Math.min(lnormY, ldeltaY / 100) * k * sign * force.alpha();\n            });\n        } else {\n            visbackground.style("opacity", 0);\n\n            vis.style("opacity", 0);\n            //            vis.style("opacity", 0);\n            line.style("opacity", 0);\n        };\n\n        if (gr2coords.length > 2) {\n            line2.style("opacity", 1);\n            vis2background.style("opacity", 1);\n            vis2.style("opacity", 0.3);\n            var myhull = d3.geom.hull(gr2coords);\n            vis2.selectAll("path").data([myhull]) // returns null if less than three coordinates\n            .attr("d", function (d) {\n                return "M" + d.join("L") + "Z";\n            });\n            vis2background.selectAll("path").data([myhull]) // returns null if less than three coordinates\n            .attr("d", function (d) {\n                return "M" + d.join("L") + "Z";\n            });\n\n            //var p = d3.geom.polygon(indcoords).centroid();  // Seems to go strange sometimes\n            var p = jamescentroid(gr2coords);\n\n            if (depcoords.length > 0) {\n                var q = depcoords[0]; // Note, only using first dep var currently\n                var ldeltaX = q[0] - p[0],\n                    ldeltaY = q[1] - p[1],\n                    ldist = Math.sqrt(ldeltaX * ldeltaX + ldeltaY * ldeltaY),\n                    lnormX = ldeltaX / ldist,\n                    lnormY = ldeltaY / ldist,\n                    lsourcePadding = allR + 7,\n                    ltargetPadding = allR + 10;\n\n                line2.attr("x1", p[0] + lsourcePadding * lnormX).attr("y1", p[1] + lsourcePadding * lnormY).attr("x2", q[0] - ltargetPadding * lnormX).attr("y2", q[1] - ltargetPadding * lnormY);\n            };\n\n            // group members attract each other, repulse non-group members\n            nodes.forEach(function (n) {\n                var sign = n.group2 ? 1 : -1; // was: Math.sign( zparams.zgroup2.indexOf(n.name) +0.5 );  // 1 if n in group, -1 if n not in group;\n                var ldeltaX = p[0] - n.x,\n                    ldeltaY = p[1] - n.y,\n                    ldist = Math.sqrt(ldeltaX * ldeltaX + ldeltaY * ldeltaY),\n                    lnormX = 0,\n                    lnormY = 0;\n\n                if (ldist > 0) {\n                    lnormX = ldeltaX / ldist;\n                    lnormY = ldeltaY / ldist;\n                };\n\n                n.x += Math.min(lnormX, ldeltaX / 100) * k * sign * force.alpha();\n                n.y += Math.min(lnormY, ldeltaY / 100) * k * sign * force.alpha();\n            });\n        } else {\n            vis2background.style("opacity", 0);\n            vis2.style("opacity", 0);\n            line2.style("opacity", 0);\n        };\n\n        // draw directed edges with proper padding from node centers\n        path.attr(\'d\', function (d) {\n            var deltaX = d.target.x - d.source.x,\n                deltaY = d.target.y - d.source.y,\n                dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY),\n                normX = deltaX / dist,\n                normY = deltaY / dist,\n                sourcePadding = d.left ? allR + 5 : allR,\n                targetPadding = d.right ? allR + 5 : allR,\n                sourceX = d.source.x + sourcePadding * normX,\n                sourceY = d.source.y + sourcePadding * normY,\n                targetX = d.target.x - targetPadding * normX,\n                targetY = d.target.y - targetPadding * normY;\n            return \'M\' + sourceX + \',\' + sourceY + \'L\' + targetX + \',\' + targetY;\n        });\n\n        circle.attr(\'transform\', function (d) {\n            return \'translate(\' + d.x + \',\' + d.y + \')\';\n        });\n\n        circle.selectAll(\'circle\') // Shrink/expand pebbles that join/leave groups\n        .transition().duration(100).attr(\'r\', function (d) {\n            return setPebbleRadius(d);\n        });\n    }\n\n    exports.clickVar = clickVar = function clickVar() {\n        // every time a variable in leftpanel is clicked, nodes updates and background color changes\n        if (findNodeIndex(this.id, true).grayout) return;\n        zparams.zvars = [];\n        var text = d3.select(this).text();\n        var node = findNode(text);\n        if (nodes.map(function (n) {\n            return n.name;\n        }).includes(text)) {\n            nodes.splice(node.index, 1);\n            spliceLinksForNode(node);\n            splice(node.strokeColor, text, [dvColor, \'zdv\'], [csColor, \'zcross\'], [timeColor, \'ztime\'], [nomColor, \'znom\']);\n\n            if (node.group1) {\n                // remove node name from group lists (should use adaptation of splice-by-color)\n                node.group1 = false;\n                zparams.zgroup1.splice(zparams.zgroup1.indexOf(node.name), 1);\n            };\n            if (node.group2) {\n                node.group2 = false;\n                zparams.zgroup2.splice(zparams.zgroup2.indexOf(node.name), 1);\n            };\n\n            nodeReset(node);\n            legend();\n        } else {\n            nodes.push(node);\n            if (nodes.length === 0) nodes[0].reflexive = true;\n        }\n        zparams.zvars = nodes.map(function (n) {\n            return n.name;\n        }); // adding this to keep it current (or should we rely on nodes.map(n => n.name) for variable list?)\n        panelPlots();\n        restart();\n    };\n\n    d3.select("#models").selectAll("p") // models tab\n    //  d3.select("#Display_content")\n    .on("click", function () {\n        var myColor = d3.select(this).style(\'background-color\');\n        d3.select("#models").selectAll("p").style(\'background-color\', varColor);\n        d3.select(this).style(\'background-color\', function (d) {\n            if (d3.rgb(myColor).toString() === varColor.toString()) {\n                zparams.zmodel = d.toString();\n                return hexToRgba(_plots.selVarColor);\n            } else {\n                zparams.zmodel = \'\';\n                return varColor;\n            }\n        });\n        restart();\n    });\n\n    d3.select("#types").selectAll("p") // models tab\n    //  d3.select("#Display_content")\n    .on("click", function () {\n        if (locktoggle) return;\n        if (this.className == "item-select") {\n            return;\n        } else {\n            d3.select("#types").select("p.item-select").attr(\'class\', \'item-default\');\n            d3mProblemDescription.taskType = this.innerHTML.toString();\n            d3.select(this).attr(\'class\', "item-select");\n        }\n        restart();\n        updateSchema("taskType", d3mProblemDescription, d3mTaskType);\n    });\n\n    d3.select("#subtypes").selectAll("p").on("click", function () {\n        if (locktoggle) return;\n        if (this.className == "item-select") {\n            return;\n        } else {\n            d3.select("#subtypes").select("p.item-select").attr(\'class\', \'item-default\');\n            d3mProblemDescription.taskSubtype = this.innerHTML.toString();\n            d3.select(this).attr(\'class\', "item-select");\n        }\n        restart();\n        updateSchema("taskSubtype", d3mProblemDescription, d3mTaskSubtype);\n    });\n\n    d3.select("#metrics").selectAll("p").on("click", function () {\n        if (locktoggle) return;\n        if (this.className == "item-select") {\n            return;\n            //         d3mProblemDescription.metric = ["",""];\n            //        this.className="item-default";\n        } else {\n            d3.select("#metrics").select("p.item-select").attr(\'class\', \'item-default\');\n            d3mProblemDescription.metric = this.innerHTML.toString();\n            d3.select(this).attr(\'class\', "item-select");\n        }\n        restart();\n        updateSchema("metric", d3mProblemDescription, d3mMetrics);\n    });\n\n    d3.select("#outputs").selectAll("p").on("click", function () {\n        if (locktoggle) return;\n        if (this.className == "item-select") {\n            return;\n        } else {\n            d3.select("#outputs").select("p.item-select").attr(\'class\', \'item-default\');\n            d3mProblemDescription.outputType = this.innerHTML.toString();\n            d3.select(this).attr(\'class\', "item-select");\n        }\n        restart();\n        updateSchema("outputType", d3mProblemDescription, d3mOutputType);\n    });\n\n    // update graph (called when needed)\n    function restart() {\n        // nodes.id is pegged to allNodes, i.e. the order in which variables are read in\n        // nodes.index is floating and depends on updates to nodes.  a variables index changes when new variables are added.\n        circle.call(force.drag);\n        if (forcetoggle[0] == "true") {\n            force.gravity(0.1);\n            force.charge(function (d) {\n                return setPebbleCharge(d);\n            });\n            force.start();\n            force.linkStrength(1);\n            k = 4; // strength parameter for group attraction/repulsion\n            if (zparams.zgroup1.length > 0 & zparams.zgroup2.length > 0) {\n                // scale down by number of active groups\n                k = 2.5;\n            }\n        } else {\n            force.gravity(0);\n            force.charge(0);\n            force.linkStrength(0);\n            k = 0;\n        }\n        force.resume();\n\n        // path (link) group\n        path = path.data(links);\n\n        // update existing links\n        // VJD: dashed links between pebbles are "selected". this is disabled for now\n        path.classed(\'selected\', function (x) {\n            return null;\n        }).style(\'marker-start\', function (x) {\n            return x.left ? \'url(#start-arrow)\' : \'\';\n        }).style(\'marker-end\', function (x) {\n            return x.right ? \'url(#end-arrow)\' : \'\';\n        });\n\n        // add new links\n        path.enter().append(\'svg:path\').attr(\'class\', \'link\').classed(\'selected\', function (x) {\n            return null;\n        }).style(\'marker-start\', function (x) {\n            return x.left ? \'url(#start-arrow)\' : \'\';\n        }).style(\'marker-end\', function (x) {\n            return x.right ? \'url(#end-arrow)\' : \'\';\n        }).on(\'mousedown\', function (d) {\n            // do we ever need to select a link? make it delete..\n            var obj = JSON.stringify(d);\n            for (var j = 0; j < links.length; j++) {\n                if (obj === JSON.stringify(links[j])) links.splice(j, 1);\n            }\n        });\n\n        // remove old links\n        path.exit().remove();\n\n        // circle (node) group\n        circle = circle.data(nodes, function (x) {\n            return x.id;\n        });\n\n        // update existing nodes (reflexive & selected visual states)\n        // d3.rgb is the function adjusting the color here\n        circle.selectAll(\'circle\').classed(\'reflexive\', function (x) {\n            return x.reflexive;\n        }).style(\'fill\', function (x) {\n            return d3.rgb(x.nodeCol);\n        }).style(\'stroke\', function (x) {\n            return d3.rgb(x.strokeColor);\n        }).style(\'stroke-width\', function (x) {\n            return x.strokeWidth;\n        });\n\n        // add new nodes\n        var g = circle.enter().append(\'svg:g\').attr(\'id\', function (x) {\n            return x.name + \'biggroup\';\n        });\n\n        // add plot\n        g.each(function (d) {\n            d3.select(this);\n            if (d.plottype == \'continuous\') (0, _plots.densityNode)(d, this);else if (d.plottype == \'bar\') (0, _plots.barsNode)(d, this);\n        });\n\n        var append = function append(str, attr) {\n            return function (x) {\n                return str + x[attr || \'id\'];\n            };\n        };\n\n        g.append("path").attr("id", append(\'dvArc\')).attr("d", arc3).style("fill", dvColor).attr("fill-opacity", 0).on(\'mouseover\', function (d) {\n            fillThis(this, .3, 0, 100);\n            fill(d, \'dvText\', .9, 0, 100);\n        }).on(\'mouseout\', function (d) {\n            fillThis(this, 0, 100, 500);\n            fill(d, \'dvText\', 0, 100, 500);\n        }).on(\'click\', function (d) {\n            setColors(d, dvColor);\n            legend(dvColor);\n            restart();\n        });\n\n        g.append("text").attr("id", append(\'dvText\')).attr("x", 6).attr("dy", 11.5).attr("fill-opacity", 0).append("textPath").attr("xlink:href", append(\'#dvArc\')).text("Dep Var");\n\n        g.append("path").attr("id", append(\'nomArc\')).attr("d", arc4).style("fill", nomColor).attr("fill-opacity", 0).on(\'mouseover\', function (d) {\n            if (d.defaultNumchar == "character") return;\n            fillThis(this, .3, 0, 100);\n            fill(d, "nomText", .9, 0, 100);\n        }).on(\'mouseout\', function (d) {\n            if (d.defaultNumchar == "character") return;\n            fillThis(this, 0, 100, 500);\n            fill(d, "nomText", 0, 100, 500);\n        }).on(\'click\', function (d) {\n            if (d.defaultNumchar == "character") return;\n            setColors(d, nomColor);\n            legend(nomColor);\n            restart();\n        });\n\n        g.append("text").attr("id", append("nomText")).attr("x", 6).attr("dy", 11.5).attr("fill-opacity", 0).append("textPath").attr("xlink:href", append("#nomArc")).text("Nominal");\n\n        g.append("path").attr("id", append(\'grArc\')).attr("d", arc1).style("fill", gr1Color).attr("fill-opacity", 0).on(\'mouseover\', function (d) {\n            fill(d, "gr1indicator", .3, 0, 100);\n            fill(d, "gr2indicator", .3, 0, 100);\n            fillThis(this, .3, 0, 100);\n            fill(d, \'grText\', .9, 0, 100);\n        }).on(\'mouseout\', function (d) {\n            fill(d, "gr1indicator", 0, 100, 500);\n            fill(d, "gr2indicator", 0, 100, 500);\n            fillThis(this, 0, 100, 500);\n            fill(d, \'grText\', 0, 100, 500);\n        }).on(\'click\', function (d) {\n            //d.group1 = !d.group1;      // This might be easier, but currently set in setColors()\n            setColors(d, gr1Color);\n            legend(gr1Color);\n            restart();\n        });\n\n        g.append("path").attr("id", append(\'gr1indicator\')).attr("d", arcInd1).style("fill", gr1Color) // something like: zparams.zgroup1.indexOf(node.name) > -1  ?  #FFFFFF : gr1Color)\n        .attr("fill-opacity", 0).on(\'mouseover\', function (d) {\n            fillThis(this, .3, 0, 100);\n            fill(d, "grArc", .1, 0, 100);\n            fill(d, \'grText\', .9, 0, 100);\n        }).on(\'mouseout\', function (d) {\n            fillThis(this, 0, 100, 500);\n            fill(d, "grArc", 0, 100, 500);\n            fill(d, \'grText\', 0, 100, 500);\n        }).on(\'click\', function (d) {\n            //d.group1 = !d.group1;      // This might be easier, but currently set in setColors()\n            setColors(d, gr1Color);\n            legend(gr1Color);\n            restart();\n        });\n\n        g.append("path").attr("id", append(\'gr2indicator\')).attr("d", arcInd2).style("fill", gr2Color) // something like: zparams.zgroup1.indexOf(node.name) > -1  ?  #FFFFFF : gr1Color)\n        .attr("fill-opacity", 0).on(\'mouseover\', function (d) {\n            fillThis(this, .3, 0, 100);\n            fill(d, "grArc", .1, 0, 100);\n            fill(d, \'grText\', .9, 0, 100);\n        }).on(\'mouseout\', function (d) {\n            fillThis(this, 0, 100, 500);\n            fill(d, "grArc", 0, 100, 500);\n            fill(d, \'grText\', 0, 100, 500);\n        }).on(\'click\', function (d) {\n            //d.group2 = !d.group2;      // This might be easier, but currently set in setColors()\n            setColors(d, gr2Color);\n            legend(gr2Color);\n            restart();\n        });\n\n        g.append("text").attr("id", append(\'grText\')).attr("x", 6).attr("dy", 11.5).attr("fill-opacity", 0).append("textPath").attr("xlink:href", append(\'#grArc\')).text("Groups");\n\n        g.append(\'svg:circle\').attr(\'class\', \'node\').attr(\'r\', function (d) {\n            return setPebbleRadius(d);\n        }).style(\'pointer-events\', \'inherit\').style(\'fill\', function (d) {\n            return d.nodeCol;\n        }).style(\'opacity\', "0.5").style(\'stroke\', function (d) {\n            return d3.rgb(d.strokeColor).toString();\n        }).classed(\'reflexive\', function (d) {\n            return d.reflexive;\n        }).on(\'dblclick\', function (_) {\n            d3.event.stopPropagation(); // stop click from bubbling\n            exports.summaryHold = summaryHold = true;\n        }).on(\'contextmenu\', function (d) {\n            // right click on node\n            d3.event.preventDefault();\n            d3.event.stopPropagation();\n\n            rightClickLast = true;\n            mousedown_node = d;\n            selected_node = mousedown_node === selected_node ? null : mousedown_node;\n            selected_link = null;\n\n            // reposition drag line\n            drag_line.style(\'marker-end\', \'url(#end-arrow)\').classed(\'hidden\', false).attr(\'d\', \'M\' + mousedown_node.x + \',\' + mousedown_node.y + \'L\' + mousedown_node.x + \',\' + mousedown_node.y);\n\n            svg.on(\'mousemove\', mousemove);\n            restart();\n        }).on(\'mouseup\', function (d) {\n            d3.event.stopPropagation();\n\n            if (rightClickLast) {\n                rightClickLast = false;\n                return;\n            }\n            if (!mousedown_node) return;\n\n            // needed by FF\n            drag_line.classed(\'hidden\', true).style(\'marker-end\', \'\');\n\n            // check for drag-to-self\n            mouseup_node = d;\n            if (mouseup_node === mousedown_node) {\n                resetMouseVars();\n                return;\n            }\n\n            // unenlarge target node\n            d3.select(this).attr(\'transform\', \'\');\n\n            // add link to graph (update if exists)\n            // NB: links are strictly source < target; arrows separately specified by booleans\n            var source, target, direction;\n            if (mousedown_node.id < mouseup_node.id) {\n                source = mousedown_node;\n                target = mouseup_node;\n                direction = \'right\';\n            } else {\n                source = mouseup_node;\n                target = mousedown_node;\n                direction = \'left\';\n            }\n\n            var link = links.filter(function (x) {\n                return x.source == source && x.target == target;\n            })[0];\n            if (link) {\n                link[direction] = true;\n            } else {\n                link = {\n                    source: source,\n                    target: target,\n                    left: false,\n                    right: false\n                };\n                link[direction] = true;\n                links.push(link);\n            }\n\n            // select new link\n            selected_link = link;\n            selected_node = null;\n            svg.on(\'mousemove\', null);\n\n            resetMouseVars();\n            restart();\n        });\n\n        // show node names\n        g.append(\'svg:text\').attr(\'x\', 0).attr(\'y\', 15).attr(\'class\', \'id\').text(function (d) {\n            return d.name;\n        });\n\n        // show summary stats on mouseover\n        // SVG doesn\'t support text wrapping, use html instead\n        g.selectAll("circle.node").on("mouseover", function (d) {\n            tabLeft(\'tab3\');\n            varSummary(d);\n            d.forefront = true;\n\n            byId(\'transformations\').setAttribute(\'style\', \'display:block\');\n            byId("transSel").selectedIndex = d.id;\n            transformVar = valueKey[d.id];\n\n            fill(d, "dvArc", .1, 0, 100);\n            fill(d, "dvText", .5, 0, 100);\n            fill(d, "grArc", .1, 0, 100);\n            fill(d, "grText", .5, 0, 100);\n            //fill(d, "gr1indicator", .1, 0, 100);\n            //fill(d, "gr1indicatorText", .1, 0, 100);\n            //fill(d, "gr2indicator", .1, 0, 100);\n            //fill(d, "gr2indicatorText", .1, 0, 100);\n\n            if (d.defaultNumchar == "numeric") {\n                fill(d, "nomArc", .1, 0, 100);\n                fill(d, "nomText", .5, 0, 100);\n            }\n            fill(d, "csArc", .1, 0, 100);\n            fill(d, "csText", .5, 0, 100);\n            fill(d, "timeArc", .1, 0, 100);\n            fill(d, "timeText", .5, 0, 100);\n\n            _mithril2.default.redraw();\n        }).on(\'mouseout\', function (d) {\n            d.forefront = false;\n            summaryHold || tabLeft(subset ? \'tab2\' : \'tab1\');\n            \'csArc csText timeArc timeText dvArc dvText nomArc nomText grArc grText\'.split(\' \').map(function (x) {\n                return fill(d, x, 0, 100, 500);\n            });\n            _mithril2.default.redraw();\n        });\n\n        // the transformation variable list is silently updated as pebbles are added/removed\n        d3.select("#transSel").selectAll(\'li\').remove();\n\n        d3.select("#transSel").selectAll(\'li\').data(nodes.map(function (x) {\n            return x.name;\n        })) // set to variables in model space as they\'re added\n        .enter().append("li").text(function (d) {\n            return d;\n        });\n\n        $(\'#transSel li\').click(function (evt) {\n            // if \'interaction\' is the selected function, don\'t show the function list again\n            if (selInteract) {\n                var n = $(\'#tInput\').val().concat($(this).text());\n                $(\'#tInput\').val(n);\n                evt.stopPropagation();\n                var t = transParse(n = n);\n                if (!t) return;\n                $(this).parent().fadeOut(100);\n                transform(n = t.slice(0, t.length - 1), t = t[t.length - 1], typeTransform = false);\n                return;\n            }\n\n            $(\'#tInput\').val($(this).text());\n            $(this).parent().fadeOut(100);\n            $(\'#transList\').fadeIn(100);\n            evt.stopPropagation();\n        });\n\n        // remove old nodes\n        circle.exit().remove();\n        force.start();\n    }\n\n    function mousedown(d) {\n        // prevent I-bar on drag\n        d3.event.preventDefault();\n        // because :active only works in WebKit?\n        svg.classed(\'active\', true);\n        if (d3.event.ctrlKey || mousedown_node || mousedown_link) return;\n        restart();\n    }\n\n    function mousemove(d) {\n        if (!mousedown_node) return;\n        // update drag line\n        drag_line.attr(\'d\', \'M\' + mousedown_node.x + \',\' + mousedown_node.y + \'L\' + d3.mouse(this)[0] + \',\' + d3.mouse(this)[1]);\n    }\n\n    function mouseup(d) {\n        if (mousedown_node) {\n            drag_line.classed(\'hidden\', true).style(\'marker-end\', \'\');\n        }\n        // because :active only works in WebKit?\n        svg.classed(\'active\', false);\n        // clear mouse event vars\n        resetMouseVars();\n    }\n\n    // app starts here\n    svg.attr(\'id\', function () {\n        return "whitespace".concat(myspace);\n    }).attr(\'height\', height).on(\'mousedown\', function () {\n        mousedown(this);\n    }).on(\'mouseup\', function () {\n        mouseup(this);\n    });\n\n    d3.select(window).on(\'click\', function () {\n        // all clicks will bubble here unless event.stopPropagation()\n        $(\'#transList\').fadeOut(100);\n        $(\'#transSel\').fadeOut(100);\n    });\n\n    restart(); // initializes force.layout()\n    fakeClick();\n\n    if (v2 & IS_D3M_DOMAIN) {\n        var click_ev = document.createEvent("MouseEvents");\n        // initialize the event\n        click_ev.initEvent("click", true /* bubble */, true /* cancelable */);\n        // trigger the event\n        var clickID = "dvArc" + findNodeIndex(mytarget);\n        document.getElementById(clickID).dispatchEvent(click_ev);\n    }\n}\n\nvar find = function find($nodes, name) {\n    for (var i in $nodes) {\n        if ($nodes[i].name == name) return $nodes[i].id;\n    }\n};\n\n// returns id\nvar findNodeIndex = exports.findNodeIndex = function findNodeIndex(name, all) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n        for (var _iterator = allNodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var node = _step.value;\n\n            if (node.name === name) {\n                //cdb(\'Yes!\' + allNodes[i].id);\n                return all ? node : node.id;\n            }\n        }\n    } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n            }\n        } finally {\n            if (_didIteratorError) {\n                throw _iteratorError;\n            }\n        }\n    }\n};\n\nvar nodeIndex = function nodeIndex(nodeName) {\n    for (var i in nodes) {\n        if (nodes[i].name == nodeName) return i;\n    }\n};\n\nvar findNode = exports.findNode = function findNode(nodeName) {\n    for (var i in allNodes) {\n        if (allNodes[i].name == nodeName) return allNodes[i];\n    }\n};\n\n/*\n    Retrieve the variable list from the preprocess data.\n    This helps handle the new format and (temporarily)\n    the older format in production (rp 8.14.2017)\n */\nfunction getVariableData(jsonData) {\n    /* "new" response:\n    {\n        "dataset" : {...}\n        "variables" : {\n            "var1" : {...}, (etc)\n        }\n    }\n    "old" response\n    {\n         "var1" : {...},\n         (etc)\n    }*/\n    return jsonData.hasOwnProperty(\'variables\') ? jsonData.variables : jsonData;\n}\n\n// function called by force button\nfunction forceSwitch() {\n    forcetoggle = [forcetoggle[0] == \'true\' ? \'false\' : \'true\'];\n    if (forcetoggle[0] === "false") {\n        byId(\'btnForce\').setAttribute("class", "btn active");\n    } else {\n        byId(\'btnForce\').setAttribute("class", "btn btn-default");\n        fakeClick();\n    }\n}\n\nfunction lockDescription() {\n    locktoggle = locktoggle ? false : true;\n    var temp = void 0;\n    var i = void 0;\n    if (!locktoggle) {\n        document.getElementById(\'btnLock\').setAttribute("class", "btn btn-default");\n        temp = document.getElementById(\'rightContentArea\').querySelectorAll("p.item-lineout");\n        for (i = 0; i < temp.length; i++) {\n            temp[i].classList.remove("item-lineout");\n        }\n    } else {\n        document.getElementById(\'btnLock\').setAttribute("class", "btn active");\n        temp = document.getElementById(\'metrics\').querySelectorAll("p.item-default");\n        console.log(temp);\n        for (i = 0; i < temp.length; i++) {\n            temp[i].classList.add("item-lineout");\n        }\n        temp = document.getElementById(\'types\').querySelectorAll("p.item-default");\n        for (i = 0; i < temp.length; i++) {\n            temp[i].classList.add("item-lineout");\n        }\n        temp = document.getElementById(\'subtypes\').querySelectorAll("p.item-default");\n        for (i = 0; i < temp.length; i++) {\n            temp[i].classList.add("item-lineout");\n        }\n        temp = document.getElementById(\'outputs\').querySelectorAll("p.item-default");\n        for (i = 0; i < temp.length; i++) {\n            temp[i].classList.add("item-lineout");\n        }\n        fakeClick();\n    }\n}\n\nvar spliceLinksForNode = exports.spliceLinksForNode = function spliceLinksForNode(node) {\n    return links.filter(function (l) {\n        return l.source === node || l.target === node;\n    }).map(function (x) {\n        return links.splice(links.indexOf(x), 1);\n    });\n};\n\nfunction zPop() {\n    if (dataurl) zparams.zdataurl = dataurl;\n    zparams.zmodelcount = modelCount;\n    zparams.zedges = [];\n    zparams.zvars = [];\n    for (var j = 0; j < nodes.length; j++) {\n        //populate zvars array\n        zparams.zvars.push(nodes[j].name);\n        var temp = nodes[j].id;\n        zparams.zsetx[j] = allNodes[temp].setxvals;\n        zparams.zsubset[j] = allNodes[temp].subsetrange;\n    }\n    for (var _j2 = 0; _j2 < links.length; _j2++) {\n        //populate zedges array\n        //correct the source target ordering for Zelig\n        var srctgt = links[_j2].left == false ? [links[_j2].source.name, links[_j2].target.name] : [links[_j2].target.name, links[_j2].source.name];\n        zparams.zedges.push(srctgt);\n    }\n}\n\nfunction estimate(btn) {\n    if (!IS_D3M_DOMAIN) {\n        var estimateSuccess = function estimateSuccess(btn, json) {\n            //  toggleRightButtons("all");\n            estimateLadda.stop(); // stop spinner\n            allResults.push(json);\n            cdb("json in: ", json);\n\n            if (!estimated) byId("results").removeChild(byId("resultsHolder"));\n\n            estimated = true;\n            d3.select("#results").style("display", "block");\n\n            d3.select("#resultsView").style("display", "block");\n\n            d3.select("#modelView").style("display", "block");\n\n            // programmatic click on Results button\n            $("#btnResults").trigger("click");\n\n            var model = "Model".concat(modelCount = modelCount + 1);\n\n            function modCol() {\n                d3.select("#modelView").selectAll("p").style(\'background-color\', hexToRgba(varColor));\n            }\n            modCol();\n\n            d3.select("#modelView").insert("p", ":first-child") // top stack for results\n            .attr("id", model).text(model).style(\'background-color\', hexToRgba(_plots.selVarColor)).on("click", function () {\n                var a = this.style.backgroundColor.replace(/\\s*/g, "");\n                var b = hexToRgba(_plots.selVarColor).replace(/\\s*/g, "");\n                if (a.substr(0, 17) == b.substr(0, 17)) return; // escape function if displayed model is clicked\n                modCol();\n                d3.select(this).style(\'background-color\', hexToRgba(_plots.selVarColor));\n                viz(this.id);\n            });\n\n            var rCall = [];\n            rCall[0] = json.call;\n            showLog("estimate", rCall);\n\n            viz(model);\n        };\n\n        var estimateFail = function estimateFail(btn) {\n            estimateLadda.stop(); // stop spinner\n            estimated = true;\n        };\n\n        var selectorSuccess = function selectorSuccess(btn, json) {\n            d3.select("#ticker").text("Suggested variables and percent improvement on RMSE: " + json.vars);\n            cdb("selectorSuccess: ", json);\n        };\n\n        var selectorFail = function selectorFail(btn) {\n            alert("Selector Fail");\n        };\n\n        if (production && zparams.zsessionid == \'\') {\n            alert("Warning: Data download is not complete. Try again soon.");\n            return;\n        }\n\n        zPop();\n        // write links to file & run R CMD\n        // package the output as JSON\n        // add call history and package the zparams object as JSON\n        zparams.callHistory = callHistory;\n        var jsonout = JSON.stringify(zparams);\n\n        var urlcall = rappURL + "zeligapp"; //base.concat(jsonout);\n        var solajsonout = "solaJSON=" + jsonout;\n        cdb("urlcall out: ", urlcall);\n        cdb("POST out: ", solajsonout);\n        console.log("estimate: ", solajsonout);\n\n        zparams.allVars = valueKey.slice(10, 25); // because the URL is too long...\n        jsonout = JSON.stringify(zparams);\n        var selectorurlcall = rappURL + "selectorapp";\n\n        estimateLadda.start(); // start spinner\n        makeCorsRequest(urlcall, btn, estimateSuccess, estimateFail, solajsonout);\n    } else {\n        var createPipelineSuccess = function createPipelineSuccess(btn, json) {\n            estimateLadda.stop(); // stop spinner\n\n            var trainFeatures = apiFeature(json.predictors, uri.features);\n            var targetFeatures = apiFeature(json.depvar, uri.target);\n            var task = d3mTaskType[d3mProblemDescription.taskType][1];\n            var taskSubtype = d3mTaskSubtype[d3mProblemDescription.taskSubtype][1];\n            var output = d3mOutputType[d3mProblemDescription.outputType][1];\n            var metrics = [d3mMetrics[d3mProblemDescription.metric][1]];\n            var taskDescription = d3mProblemDescription.taskDescriptionription;\n            var maxPipelines = 10; //user to specify this eventually?\n\n            setxTable(json.predictors);\n            var dvvalues = json.dvvalues;\n\n            var PipelineCreateRequest = { context: context, trainFeatures: trainFeatures, task: task, taskSubtype: taskSubtype, taskDescription: taskDescription, output: output, metrics: metrics, targetFeatures: targetFeatures, maxPipelines: maxPipelines };\n\n            var jsonout = JSON.stringify(PipelineCreateRequest);\n\n            var urlcall = d3mURL + "/createpipeline";\n            var solajsonout = "grpcrequest=" + jsonout;\n\n            console.log(urlcall);\n            console.log(solajsonout);\n            function sendPipelineSuccess(btn, PipelineCreateResult) {\n                //rpc GetExecutePipelineResults(PipelineExecuteResultsRequest) returns (stream PipelineExecuteResult) {}\n                console.log(PipelineCreateResult);\n                toggleRightButtons("all");\n                document.getElementById("btnResults").click();\n\n                // this is our function for the ListPipelines of API\n                listpipelines();\n\n                // once we know what TA2 does we\'ll get the pipeline ids from there\n                //let pipelineid = PipelineCreateResult.pipelineid;\n                var pipelineid = "id1";\n                var PipelineExecuteResultsRequest = { context: context, pipelineid: pipelineid };\n                jsonout = JSON.stringify(PipelineExecuteResultsRequest);\n                var urlcall = d3mURL + "/getexecutepipelineresults";\n                var solajsonout = "grpcrequest=" + jsonout;\n                console.log("GetExecutePipelineResults: ");\n                console.log(solajsonout);\n                console.log(urlcall);\n\n                function getExecutePipeSuccess(btn, PipelineExecuteResult) {\n                    // presumably we\'ll be reading in results from a path\n                    // for now it\'s just hardcoded\n                    console.log(PipelineExecuteResult);\n                    var predvals = dvvalues;\n                    for (var i = 0; i < predvals.length; i++) {\n                        predvals[i] = predvals[i] * (Math.random() + .5);\n                    }\n                    var xdata = "Actual";\n                    var ydata = "Predicted";\n                    bivariatePlot(dvvalues, predvals, xdata, ydata);\n                }\n                function getExecutePipeFail(btn) {\n                    console.log("GetExecutePipelineResults failed");\n                }\n                makeCorsRequest(urlcall, "nobutton", getExecutePipeSuccess, getExecutePipeFail, solajsonout);\n            }\n\n            function sendPipelineFail(btn) {\n                console.log("pipeline to django failed");\n            }\n\n            makeCorsRequest(urlcall, "nobutton", sendPipelineSuccess, sendPipelineFail, solajsonout);\n        };\n\n        var createPipelineFail = function createPipelineFail(btn) {\n            estimateLadda.stop(); // stop spinner\n            estimated = true;\n        };\n\n        // we are in IS_D3M_DOMAIN\n        // rpc CreatePipelines(PipelineCreateRequest) returns (stream PipelineCreateResult) {}\n        zPop();\n        zparams.callHistory = callHistory;\n        var jsonout = JSON.stringify(zparams);\n        console.log(jsonout);\n\n        var context = apiSession(zparams.zsessionid);\n        var uri = { features: zparams.zd3mdata, target: zparams.zd3mtarget };\n\n        var urlcall = rappURL + "pipelineapp";\n\n        var solajsonout = "solaJSON=" + jsonout;\n        cdb("urlcall out: ", urlcall);\n        cdb("POST out: ", solajsonout);\n\n        estimateLadda.start(); // start spinner\n        makeCorsRequest(urlcall, btn, createPipelineSuccess, createPipelineFail, solajsonout);\n    }\n}\n\nfunction runPreprocess(dataloc, targetloc, datastub) {\n    var url = rappURL + \'preprocessapp\';\n    console.log("GOING TO RUN THE PREPROCESSAPP");\n    var json = JSON.stringify({ data: dataloc, target: targetloc, datastub: datastub }); //, preprocess: preprocessloc});\n    console.log(\'urlcall out: \', url);\n    console.log(\'POST out: \', json);\n    var data = new FormData();\n    data.append(\'solaJSON\', json);\n    return _mithril2.default.request({ method: \'POST\', url: url, data: data }).then(function (data) {\n        console.log(\'json in RIGHT HERE: \', data);\n        return data;\n    }, function (_) {\n        return console.log(\'preprocess failed\');\n    });\n}\n\nvar ta2stuff = exports.ta2stuff = function ta2stuff(_) {\n    return console.log(d3mProblemDescription);\n};\n\nfunction dataDownload() {\n    zPop();\n    // write links to file & run R CMD\n\n    //package the output as JSON\n    // add call history and package the zparams object as JSON\n    var jsonout = JSON.stringify(zparams);\n    var btn = "nobutton";\n\n    var urlcall = rappURL + "dataapp";\n    var solajsonout = "solaJSON=" + jsonout;\n    cdb("urlcall out: ", urlcall);\n    cdb("POST out: ", solajsonout);\n\n    var downloadSuccess = function downloadSuccess(btn, json) {\n        console.log(\'datadownload: \', json);\n        cdb(\'dataDownload json in: \', json);\n        zparams.zsessionid = json.sessionid[0];\n        // set link URL\n        byId("logID").href = \'\' + (production ? rappURL + \'log_dir/log_\' : \'rook/log_\') + zparams.zsessionid + \'.txt\';\n    };\n    var downloadFail = function downloadFail(_) {\n        return cdb(\'Data have not been downloaded\');\n    };\n    makeCorsRequest(urlcall, btn, downloadSuccess, downloadFail, solajsonout);\n}\n\nfunction viz(mym) {\n    var mym = +mym.substr(5, 5) - 1;\n\n    function removeKids(parent) {\n        while (parent.firstChild) {\n            parent.removeChild(parent.firstChild);\n        }\n    }\n\n    removeKids(byId("resultsView"));\n\n    var json = allResults[mym];\n\n    // pipe in figures to right panel\n    var filelist = new Array();\n    for (var i in json.images) {\n        var zfig = document.createElement("img");\n        zfig.setAttribute("src", json.images[i]);\n        zfig.setAttribute(\'width\', 200);\n        zfig.setAttribute(\'height\', 200);\n        byId("resultsView").appendChild(zfig);\n    }\n\n    // write the results table\n    var resultsArray = [];\n    for (var key in json.sumInfo) {\n        if (key == \'colnames\') continue;\n        resultsArray.push(json.sumInfo[key]);\n    }\n\n    var table = d3.select("#resultsView").append("p").append("table");\n\n    var thead = table.append("thead");\n    thead.append("tr").selectAll("th").data(json.sumInfo.colnames).enter().append("th").text(function (d) {\n        return d;\n    });\n\n    var tbody = table.append("tbody");\n    tbody.selectAll("tr").data(resultsArray).enter().append("tr").selectAll("td").data(function (d) {\n        return d;\n    }).enter().append("td").text(function (d) {\n        var myNum = Number(d);\n        if (isNaN(myNum)) return d;\n        return myNum.toPrecision(3);\n    }).on("mouseover", function () {\n        d3.select(this).style("background-color", "aliceblue");\n    }) // for no discernable reason\n    .on("mouseout", function () {\n        d3.select(this).style("background-color", "#F9F9F9");\n    }); //(but maybe we\'ll think of one)\n\n    d3.select("#resultsView").append("p").html(function () {\n        return "<b>Formula: </b>".concat(json.call[0]);\n    });\n\n    _mithril2.default.redraw();\n}\n\n// parses the transformation input. variable names are often nested inside one another, e.g., ethwar, war, wars, and so this is handled\nfunction transParse(n) {\n    var out2 = [];\n    var t2 = n;\n    var k2 = 0;\n    var subMe2 = "_transvar".concat(k2);\n    var indexed = [];\n\n    // out2 is all matched variables, indexed is an array, each element is an object that contains the matched variables starting index and finishing index.  e.g., n="wars+2", out2=[war, wars], indexed=[{0,2},{0,3}]\n    for (var i in valueKey) {\n        var m2 = n.match(valueKey[i]);\n        if (m2 != null) out2.push(m2[0]);\n\n        var re = new RegExp(valueKey[i], "g");\n        var s = n.search(re);\n        if (s != -1) indexed.push({ from: s, to: s + valueKey[i].length });\n    }\n\n    // nested loop not good, but indexed is not likely to be very large.\n    // if a variable is nested, it is removed from out2\n    // notice, loop is backwards so that index changes don\'t affect the splice\n    cdb("indexed ", indexed);\n    for (var i = indexed.length - 1; i > -1; i--) {\n        for (var j = indexed.length - 1; j > -1; j--) {\n            if (i === j) continue;\n            if (indexed[i].from >= indexed[j].from & indexed[i].to <= indexed[j].to) {\n                cdb(i, " is nested in ", j);\n                out2.splice(i, 1);\n            }\n        }\n    }\n\n    for (var i in out2) {\n        t2 = t2.replace(out2[i], subMe2); //something that\'ll never be a variable name\n        k2 = k2 + 1;\n        subMe2 = "_transvar".concat(k2);\n    }\n\n    if (out2.length > 0) {\n        out2.push(t2);\n        cdb("new out ", out2);\n        return out2;\n    } else {\n        alert("No variable name found. Perhaps check your spelling?");\n        return null;\n    }\n}\n\n/**\n  n = name of column/node\n  t = selected transformation\n */\nfunction transform(n, t, typeTransform) {\n    if (production && zparams.zsessionid == "") {\n        alert("Warning: Data download is not complete. Try again soon.");\n        return;\n    }\n    if (!typeTransform) t = t.replace("+", "_plus_"); // can\'t send the plus operator\n\n    cdb(\'name of col: \' + n);\n    cdb(\'transformation: \' + t);\n\n    var btn = byId(\'btnEstimate\');\n\n    // find the node by name\n    var myn = findNodeIndex(n[0], true);\n\n    if (typeof myn === "undefined") {\n        myn = findNodeIndex(n, true);\n    }\n\n    var outtypes = {\n        varnamesTypes: n,\n        interval: myn.interval,\n        numchar: myn.numchar,\n        nature: myn.nature,\n        binary: myn.binary\n    };\n\n    cdb(myn);\n    // if typeTransform but we already have the metadata\n    if (typeTransform) {\n        if (myn.nature == "nominal" & typeof myn.plotvalues !== "undefined") {\n            myn.plottype = "bar";\n            (0, _plots.barsNode)(myn);\n            panelPlots();\n            return;\n        } else if (myn.nature != "nominal" & typeof myn.plotx !== "undefined") {\n            myn.plottype = "continuous";\n            (0, _plots.densityNode)(myn);\n            panelPlots();\n            return;\n        }\n    }\n\n    //package the output as JSON\n    var transformstuff = {\n        zdataurl: dataurl,\n        zvars: myn.name,\n        zsessionid: zparams.zsessionid,\n        transform: t,\n        callHistory: callHistory,\n        typeTransform: typeTransform,\n        typeStuff: outtypes\n    };\n    var jsonout = JSON.stringify(transformstuff);\n    var urlcall = rappURL + "transformapp";\n    var solajsonout = "solaJSON=" + jsonout;\n    cdb("urlcall out: " + urlcall);\n    cdb("POST out: " + solajsonout);\n\n    function transformSuccess(btn, json) {\n        estimateLadda.stop();\n        cdb("json in: " + JSON.stringify(json));\n\n        // Is this a typeTransform?\n        if (json.typeTransform[0]) {\n            // Yes. We\'re updating an existing node\n            d3.json(json.url, function (err, data) {\n                if (err) return console.warn(err);\n                var node = void 0;\n                for (var key in data) {\n                    node = findNodeIndex(key, true);\n                    if (!node) continue;\n                    jQuery.extend(true, node, data[key]);\n                    node.plottype === "continuous" ? (0, _plots.densityNode)(node) : node.plottype === "bar" ? (0, _plots.barsNode)(node) : null;\n                }\n                fakeClick();\n                panelPlots();\n                node && cdb(node);\n            });\n        } else {\n            /* No, we have a new node here--e.g. the transformed column\n                 example response: {\n                 "call":["t_year_2"],\n                 "url":["data/preprocessSubset_BACCBC78-7DD9-4482-B31D-6EB01C3A0C95.txt"],\n                 "trans":["year","_transvar0^2"],\n                 "typeTransform":[false]\n               }\n            */\n            callHistory.push({\n                func: "transform",\n                zvars: n,\n                transform: t\n            });\n\n            var subseted = false;\n            var rCall = [];\n\n            rCall[0] = json.call;\n            var newVar = rCall[0][0];\n\n            trans.push(newVar);\n\n            // Read the preprocess file containing values\n            // for the transformed variable\n            //\n            d3.json(json.url, function (error, json) {\n                if (error) return console.warn(error);\n\n                var jsondata = getVariableData(json);\n\n                for (var key in jsondata) {\n                    var myIndex = findNodeIndex(key);\n                    if (typeof myIndex !== "undefined") {\n                        alert("Invalid transformation: this variable name already exists.");\n                        return;\n                    }\n                    // add transformed variable to the current space\n                    var i = allNodes.length; // get new index\n                    var obj1 = {\n                        id: i,\n                        reflexive: false,\n                        name: key,\n                        labl: "transformlabel",\n                        data: [5, 15, 20, 0, 5, 15, 20],\n                        count: [.6, .2, .9, .8, .1, .3, .4],\n                        nodeCol: colors(i),\n                        baseCol: colors(i),\n                        strokeColor: _plots.selVarColor,\n                        strokeWidth: "1",\n                        subsetplot: false,\n                        subsetrange: ["", ""],\n                        setxplot: false,\n                        setxvals: ["", ""],\n                        grayout: false,\n                        defaultInterval: jsondata[key].interval,\n                        defaultNumchar: jsondata[key].numchar,\n                        defaultNature: jsondata[key].nature,\n                        defaultBinary: jsondata[key].binary\n                    };\n\n                    jQuery.extend(true, obj1, jsondata[key]);\n                    allNodes.push(obj1);\n\n                    valueKey.push(newVar);\n                    nodes.push(allNodes[i]);\n                    fakeClick();\n                    panelPlots();\n\n                    if (allNodes[i].plottype === "continuous") {\n                        (0, _plots.densityNode)(allNodes[i]);\n                    } else if (allNodes[i].plottype === "bar") {\n                        (0, _plots.barsNode)(allNodes[i]);\n                    }\n\n                    _mithril2.default.redraw();\n                }\n            });\n\n            showLog(\'transform\', rCall);\n        }\n    }\n\n    function transformFail(btn) {\n        alert("transform fail");\n        estimateLadda.stop();\n    }\n\n    estimateLadda.start(); // start spinner\n    makeCorsRequest(urlcall, btn, transformSuccess, transformFail, solajsonout);\n}\n\n// below from http://www.html5rocks.com/en/tutorials/cors/ for cross-origin resource sharing\n// Create the XHR object.\nfunction createCORSRequest(method, url, callback) {\n    var xhr = new XMLHttpRequest();\n    if ("withCredentials" in xhr) {\n        // XHR for Chrome/Firefox/Opera/Safari.\n        xhr.open(method, url, true);\n    } else if (typeof XDomainRequest != "undefined") {\n        // XDomainRequest for IE.\n        xhr = new XDomainRequest();\n        xhr.open(method, url);\n    } else {\n        // CORS not supported.\n        xhr = null;\n    }\n    // xhr.setRequestHeader(\'Content-Type\', \'text/plain\');\n    xhr.setRequestHeader(\'Content-Type\', \'application/x-www-form-urlencoded\');\n    return xhr;\n}\n\n// Make the actual CORS request.\nfunction makeCorsRequest(url, btn, callback, warningcallback, jsonstring) {\n    var xhr = createCORSRequest(\'POST\', url);\n    if (!xhr) {\n        alert(\'CORS not supported\');\n        return;\n    }\n    // Response handlers for asynchronous load\n    // onload or onreadystatechange?\n\n    xhr.onload = function () {\n        var text = xhr.responseText;\n        cdb("text ", text);\n\n        try {\n            var json = JSON.parse(text); // should wrap in try / catch\n            var names = Object.keys(json);\n        } catch (err) {\n            estimateLadda.stop();\n            selectLadda.stop();\n            cdb(err);\n            alert(\'Error: Could not parse incoming JSON.\');\n        }\n\n        if (names[0] == "warning") {\n            warningcallback(btn);\n            alert("Warning: " + json.warning);\n        } else {\n            callback(btn, json);\n        }\n    };\n    xhr.onerror = function () {\n        // note: xhr.readystate should be 4 and status should be 200. a status of 0 occurs when the url is too large\n        xhr.status == 0 ? alert(\'There was an error making the request. xmlhttprequest status is 0.\') : xhr.readyState != 4 ? alert(\'There was an error making the request. xmlhttprequest readystate is not 4.\') : alert(\'Woops, there was an error making the request.\');\n        cdb(xhr);\n        estimateLadda.stop();\n        selectLadda.stop();\n    };\n    xhr.send(jsonstring);\n}\n\nvar legend = exports.legend = function legend(_) {\n    borderState();\n    _mithril2.default.redraw();\n};\n\n// programmatically deselect every selected variable\nfunction erase() {\n    leftpanelMedium();\n    rightpanelMedium();\n    tabLeft(\'tab1\');\n    jQuery.fn.d3Click = function () {\n        this.children().each(function (i, e) {\n            var mycol = d3.rgb(this.style.backgroundColor);\n            if (mycol.toString() === varColor.toString()) return;\n            var evt = document.createEvent("MouseEvents");\n            evt.initMouseEvent("click", true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);\n            e.dispatchEvent(evt);\n        });\n    };\n    $("#varList").d3Click();\n}\n\n// http://www.tutorials2learn.com/tutorials/scripts/javascript/xml-parser-javascript.html\nfunction loadXMLDoc(XMLname) {\n    var xmlDoc;\n    if (window.XMLHttpRequest) {\n        xmlDoc = new window.XMLHttpRequest();\n        xmlDoc.open("GET", XMLname, false);\n        xmlDoc.send("");\n        return xmlDoc.responseXML;\n    }\n    // IE 5 and IE 6\n    else if (ActiveXObject("Microsoft.XMLDOM")) {\n            xmlDoc = new ActiveXObject("Microsoft.XMLDOM");\n            xmlDoc.async = false;\n            xmlDoc.load(XMLname);\n            return xmlDoc;\n        }\n    alert("Error loading document!");\n}\n\nfunction tabLeft(tab) {\n    byId(\'tab1\').style.display = \'none\';\n    byId(\'tab2\').style.display = \'none\';\n    byId(\'tab3\').style.display = \'none\';\n    byId(tab).style.display = \'block\';\n    if (tab != \'tab3\') {\n        exports.subset = subset = tab == \'tab2\';\n        exports.summaryHold = summaryHold = false;\n    }\n    exports.lefttab = lefttab = tab;\n}\n\nfunction tabRight(tab) {\n    var select = function select(cls) {\n        var panel = d3.select("#rightpanel");\n        return cls ? panel.attr(\'class\', cls) : panel.attr(\'class\');\n    };\n    var cls = "sidepanel container clearfix";\n    var toggleR = function toggleR() {\n        select(function () {\n            var expand = cls + \' expandpanel\';\n            return this.getAttribute("class") === expand ? cls : expand;\n        });\n    };\n    var toggleRFull = function toggleRFull() {\n        select(function () {\n            var expand = cls + \' expandpanelfull\';\n            return this.getAttribute("class") === expand ? cls : expand;\n        });\n    };\n    if (tab === "btnModels") select(cls);else if (tab === "btnSetx") righttab === "btnSetx" || select() === cls && toggleRFull();else if (tab === "btnResults") !estimated ? select(cls) : righttab === "btnResults" || select() === cls && toggleR();\n    exports.righttab = righttab = tab;\n}\n\nvar summary = exports.summary = { data: [] };\n\nfunction varSummary(d) {\n    var t1 = \'Mean:, Median:, Most Freq:, Occurrences:, Median Freq:, Occurrences:, Least Freq:, Occurrences:, Std Dev:, Minimum:, Maximum:, Invalid:, Valid:, Uniques:, Herfindahl\'.split(\', \');\n\n    var rint = d3.format(\'r\');\n    var str = function str(x, p) {\n        return (+x).toPrecision(p || 4).toString();\n    };\n    var t2 = priv && d.meanCI ? [str(d.mean, 2) + \' (\' + str(d.meanCI.lowerBound, 2) + \' - \' + str(d.meanCI.upperBound, 2) + \')\', str(d.median), d.mode, rint(d.freqmode), d.mid, rint(d.freqmid), d.fewest, rint(d.freqfewest), str(d.sd), str(d.min), str(d.max), rint(d.invalid), rint(d.valid), rint(d.uniques), str(d.herfindahl)] : [str(d.mean), str(d.median), d.mode, rint(d.freqmode), d.mid, rint(d.freqmid), d.fewest, rint(d.freqfewest), str(d.sd), str(d.min), str(d.max), rint(d.invalid), rint(d.valid), rint(d.uniques), str(d.herfindahl)];\n\n    summary.data = [];\n    t1.forEach(function (e, i) {\n        return !t2[i].includes(\'NaN\') && t2[i] != \'NA\' && t2[i] != \'\' && summary.data.push([e, t2[i]]);\n    });\n\n    summary.name = d.name;\n    summary.labl = d.labl;\n\n    d3.select(\'#tab3\').selectAll(\'svg\').remove();\n\n    if (!d.plottype) return;\n    d.plottype == \'continuous\' ? (0, _plots.density)(d, \'varSummary\', priv) : d.plottype == "bar" ? (0, _plots.bars)(d, \'varSummary\', priv) : d3.select("#tab3") // no graph to draw, but still need to remove previous graph\n    .selectAll("svg").remove();\n}\n\nvar popoverContent = exports.popoverContent = function popoverContent(d) {\n    var text = \'\';\n    var _ref2 = [d3.format(\'r\'), function (val, int) {\n        return (+val).toPrecision(int).toString();\n    }],\n        rint = _ref2[0],\n        prec = _ref2[1];\n\n    var div = function div(field, name, val) {\n        if (field != \'NA\') text += \'<div class=\\\'form-group\\\'><label class=\\\'col-sm-4 control-label\\\'>\' + name + \'</label><div class=\\\'col-sm-6\\\'><p class=\\\'form-control-static\\\'>\' + (val || field) + \'</p></div></div>\';\n    };\n    d.labl != \'\' && div(d.labl, \'Label\');\n    div(d.mean, \'Mean\', priv && d.meanCI ? prec(d.mean, 2) + \' (\' + prec(d.meanCI.lowerBound, 2) + \' - \' + prec(d.meanCI.upperBound, 2) + \')\' : prec(d.mean, 4));\n    div(d.median, \'Median\', prec(d.median, 4));\n    div(d.mode, \'Most Freq\');\n    div(d.freqmode, \'Occurrences\', rint(d.freqmode));\n    div(d.mid, \'Median Freq\');\n    div(d.freqmid, \'Occurrences\', rint(d.freqmid));\n    div(d.fewest, \'Least Freq\');\n    div(d.freqfewest, \'Occurrences\', rint(d.freqfewest));\n    div(d.sd, \'Stand Dev\', prec(d.sd, 4));\n    div(d.max, \'Maximum\', prec(d.max, 4));\n    div(d.min, \'Minimum\', prec(d.min, 4));\n    div(d.invalid, \'Invalid\', rint(d.invalid));\n    div(d.valid, \'Valid\', rint(d.valid));\n    div(d.uniques, \'Uniques\', rint(d.uniques));\n    div(d.herfindahl, \'Herfindahl\', prec(d.herfindahl, 4));\n    return text;\n};\n\nfunction popupX(d) {\n    var tsf = d3.format(".4r");\n    var rint = d3.format("r");\n    //Create the tooltip label\n    d3.select("#tooltip").style("left", tempX + "px").style("top", tempY + "px").select("#tooltiptext").html("<div class=\'form-group\'><label class=\'col-sm-4 control-label\'>Mean</label><div class=\'col-sm-6\'><p class=\'form-control-static\'>" + tsf(d.mean) + "</p></div></div>" + "<div class=\'form-group\'><label class=\'col-sm-4 control-label\'>Median</label><div class=\'col-sm-6\'><p class=\'form-control-static\'>" + tsf(d.median) + "</p></div></div>" + "<div class=\'form-group\'><label class=\'col-sm-4 control-label\'>Mode</label><div class=\'col-sm-6\'><p class=\'form-control-static\'>" + d.mode + "</p></div></div>" + "<div class=\'form-group\'><label class=\'col-sm-4 control-label\'>Stand Dev</label><div class=\'col-sm-6\'><p class=\'form-control-static\'>" + tsf(d.sd) + "</p></div></div>" + "<div class=\'form-group\'><label class=\'col-sm-4 control-label\'>Maximum</label><div class=\'col-sm-6\'><p class=\'form-control-static\'>" + tsf(d.max) + "</p></div></div>" + "<div class=\'form-group\'><label class=\'col-sm-4 control-label\'>Minimum</label><div class=\'col-sm-6\'><p class=\'form-control-static\'>" + tsf(d.min) + "</p></div></div>" + "<div class=\'form-group\'><label class=\'col-sm-4 control-label\'>Valid</label><div class=\'col-sm-6\'><p class=\'form-control-static\'>" + rint(d.valid) + "</p></div></div>" + "<div class=\'form-group\'><label class=\'col-sm-4 control-label\'>Invalid</label><div class=\'col-sm-6\'><p class=\'form-control-static\'>" + rint(d.invalid) + "</p></div></div>");\n}\n\nfunction panelPlots() {\n    // build arrays from nodes in main\n    var vars = [];\n    var ids = [];\n    nodes.forEach(function (n) {\n        vars.push(n.name.replace(/\\(|\\)/g, \'\'));\n        ids.push(n.id);\n    });\n\n    //remove all plots, could be smarter here\n    d3.select(\'#setxLeft\').selectAll(\'svg\').remove();\n    d3.select(\'#tab2\').selectAll(\'svg\').remove();\n    for (var i = 0; i < vars.length; i++) {\n        var node = allNodes[ids[i]];\n        node.setxplot = false;\n        node.subsetplot = false;\n        if (node.plottype === "continuous" & node.setxplot == false) {\n            node.setxplot = true;\n            (0, _plots.density)(node, div = "setxLeft", priv);\n            node.subsetplot = true;\n            (0, _plots.density)(node, div = "subset", priv);\n        } else if (node.plottype === "bar" & node.setxplot == false) {\n            node.setxplot = true;\n            (0, _plots.bars)(node, div = "setxLeft", priv);\n            node.subsetplot = true;\n            (0, _plots.barsSubset)(node);\n        }\n    }\n\n    d3.select("#setxLeft").selectAll("svg").each(function () {\n        d3.select(this);\n        var regstr = /(.+)_setxLeft_(\\d+)/;\n        var myname = regstr.exec(this.id);\n        var nodeid = myname[2];\n        myname = myname[1];\n        if (!vars.includes(myname)) {\n            allNodes[nodeid].setxplot = false;\n            var temp = "#".concat(myname, "_setxLeft_", nodeid);\n            d3.select(temp).remove();\n            allNodes[nodeid].subsetplot = false;\n            temp = "#".concat(myname, "_tab2_", nodeid);\n            d3.select(temp).remove();\n        }\n    });\n}\n\n// easy functions to collapse panels to base\nfunction rightpanelMedium() {\n    d3.select("#rightpanel").attr("class", "sidepanel container clearfix");\n}\n\nfunction leftpanelMedium() {\n    d3.select("#leftpanel").attr("class", "sidepanel container clearfix");\n}\n\n// converts color codes\nvar hexToRgba = exports.hexToRgba = function hexToRgba(hex) {\n    var int = parseInt(hex.replace(\'#\', \'\'), 16);\n    return \'rgba(\' + [int >> 16 & 255, int >> 8 & 255, int & 255, \'0.5\'].join(\',\') + \')\';\n};\n\n// takes node and color and updates zparams\nfunction setColors(n, c) {\n    if (n.strokeWidth == \'1\') {\n        if (c == gr1Color) {\n            var tempindex = zparams.zgroup1.indexOf(n.name);\n            if (tempindex > -1) {\n                n.group1 = false;\n                zparams.zgroup1.splice(tempindex, 1);\n            } else {\n                n.group1 = true;\n                zparams.zgroup1.push(n.name);\n            };\n        } else if (c == gr2Color) {\n            var tempindex = zparams.zgroup2.indexOf(n.name);\n            if (tempindex > -1) {\n                n.group2 = false;\n                zparams.zgroup2.splice(tempindex, 1);\n            } else {\n                n.group2 = true;\n                zparams.zgroup2.push(n.name);\n            };\n        } else {\n            // adding time, cs, dv, nom to node with no stroke\n            n.strokeWidth = \'4\';\n            n.strokeColor = c;\n            n.nodeCol = taggedColor;\n            var push = function push(_ref3) {\n                var _ref4 = _slicedToArray(_ref3, 2),\n                    color = _ref4[0],\n                    key = _ref4[1];\n\n                if (color != c) return;\n                zparams[key] = Array.isArray(zparams[key]) ? zparams[key] : [];\n                zparams[key].push(n.name);\n                if (key == \'znom\') {\n                    findNodeIndex(n.name, true).nature = "nominal";\n                    transform(n.name, t = null, typeTransform = true);\n                }\n                if (key == \'zdv\') {\n                    // remove group memberships from dv\'s\n                    if (n.group1) {\n                        n.group1 = false;\n                        zparams.zgroup1.splice(zparams.zgroup1.indexOf(n.name), 1);\n                    };\n                    if (n.group2) {\n                        n.group2 = false;\n                        zparams.zgroup2.splice(zparams.zgroup2.indexOf(n.name), 1);\n                    };\n                }\n            };\n            [[dvColor, \'zdv\'], [csColor, \'zcross\'], [timeColor, \'ztime\'], [nomColor, \'znom\']].forEach(push);\n        }\n    } else if (n.strokeWidth == \'4\') {\n        if (c == n.strokeColor) {\n            // deselecting time, cs, dv, nom\n            n.strokeWidth = \'1\';\n            n.strokeColor = _plots.selVarColor;\n            n.nodeCol = colors(n.id);\n            splice(c, n.name, [dvColor, \'zdv\'], [csColor, \'zcross\'], [timeColor, \'ztime\'], [nomColor, \'znom\']);\n            if (nomColor == c && zparams.znom.includes(n.name)) {\n                findNodeIndex(n.name, true).nature = findNodeIndex(n.name, true).defaultNature;\n                transform(n.name, t = null, typeTransform = true);\n            }\n        } else {\n            // deselecting time, cs, dv, nom AND changing it to time, cs, dv, nom\n            splice(n.strokeColor, n.name, [dvColor, \'zdv\'], [csColor, \'zcross\'], [timeColor, \'ztime\'], [nomColor, \'znom\']);\n            if (nomColor == n.strokeColor && zparams.znom.includes(n.name)) {\n                findNodeIndex(n.name, true).nature = findNodeIndex(n.name, true).defaultNature;\n                transform(n.name, t = null, typeTransform = true);\n            }\n            n.strokeColor = c;\n            if (dvColor == c) {\n                var dvname = n.name;\n                zparams.zdv.push(dvname);\n                if (n.group1) {\n                    // remove group memberships from dv\'s\n                    ngroup1 = false;\n                    zparams.zgroup1.splice(zparams.zgroup1.indexOf(dvname), 1);\n                };\n                if (n.group2) {\n                    ngroup2 = false;\n                    zparams.zgroup2.splice(zparams.zgroup2.indexOf(dvname), 1);\n                };\n            } else if (csColor == c) zparams.zcross.push(n.name);else if (timeColor == c) zparams.ztime.push(n.name);else if (nomColor == c) {\n                zparams.znom.push(n.name);\n                findNodeIndex(n.name, true).nature = "nominal";\n                transform(n.name, t = null, typeTransform = true);\n            }\n        }\n    }\n}\n\nfunction borderState() {\n    zparams.zdv.length > 0 ? $(\'#dvButton .rectColor svg circle\').attr(\'stroke\', dvColor) : $(\'#dvButton\').css(\'border-color\', \'#ccc\');\n    zparams.zcross.length > 0 ? $(\'#csButton .rectColor svg circle\').attr(\'stroke\', csColor) : $(\'#csButton\').css(\'border-color\', \'#ccc\');\n    zparams.ztime.length > 0 ? $(\'#timeButton .rectColor svg circle\').attr(\'stroke\', timeColor) : $(\'#timeButton\').css(\'border-color\', \'#ccc\');\n    zparams.znom.length > 0 ? $(\'#nomButton .rectColor svg circle\').attr(\'stroke\', nomColor) : $(\'#nomButton\').css(\'border-color\', \'#ccc\');\n    zparams.zgroup1.length > 0 ? $(\'#gr1Button .rectColor svg circle\').attr(\'stroke\', gr1Color).attr(\'fill\', gr1Color).attr(\'fill-opacity\', 0.6).attr(\'stroke-opacity\', 0) : $(\'#gr1Button\').css(\'border-color\', \'#ccc\');\n    zparams.zgroup2.length > 0 ? $(\'#gr2Button .rectColor svg circle\').attr(\'stroke\', gr2Color).attr(\'fill\', gr2Color).attr(\'fill-opacity\', 0.6).attr(\'stroke-opacity\', 0) : $(\'#gr2Button\').css(\'border-color\', \'#ccc\');\n}\n\n// small appearance resets, but perhaps this will become a hard reset back to all original allNode values?\nfunction nodeReset(n) {\n    n.strokeColor = _plots.selVarColor;\n    n.strokeWidth = "1";\n    n.nodeCol = n.baseCol;\n}\n\nfunction subsetSelect(btn) {\n    if (dataurl) zparams.zdataurl = dataurl;\n    if (production && zparams.zsessionid == "") {\n        alert("Warning: Data download is not complete. Try again soon.");\n        return;\n    }\n    zparams.zvars = [];\n    zparams.zplot = [];\n    var subsetEmpty = true;\n    // is this the same as zPop()?\n    for (var j = 0; j < nodes.length; j++) {\n        // populate zvars and zsubset arrays\n        zparams.zvars.push(nodes[j].name);\n        var temp = nodes[j].id;\n        zparams.zsubset[j] = allNodes[temp].subsetrange;\n        if (zparams.zsubset[j].length > 0) {\n            if (zparams.zsubset[j][0] != "") zparams.zsubset[j][0] = Number(zparams.zsubset[j][0]);\n            if (zparams.zsubset[j][1] != "") zparams.zsubset[j][1] = Number(zparams.zsubset[j][1]);\n        }\n        zparams.zplot.push(allNodes[temp].plottype);\n        if (zparams.zsubset[j][1] != "") subsetEmpty = false; // only need to check one\n    }\n\n    if (subsetEmpty == true) {\n        alert("Warning: No new subset selected.");\n        return;\n    }\n\n    var outtypes = [];\n    for (var j = 0; j < allNodes.length; j++) {\n        outtypes.push({\n            varnamesTypes: allNodes[j].name,\n            nature: allNodes[j].nature,\n            numchar: allNodes[j].numchar,\n            binary: allNodes[j].binary,\n            interval: allNodes[j].interval\n        });\n    }\n\n    var subsetstuff = {\n        zdataurl: zparams.zdataurl,\n        zvars: zparams.zvars,\n        zsubset: zparams.zsubset,\n        zsessionid: zparams.zsessionid,\n        zplot: zparams.zplot,\n        callHistory: callHistory,\n        typeStuff: outtypes\n    };\n\n    var jsonout = JSON.stringify(subsetstuff);\n    var urlcall = rappURL + "subsetapp";\n    var solajsonout = "solaJSON=" + jsonout;\n    cdb("urlcall out: ", urlcall);\n    cdb("POST out: ", solajsonout);\n\n    function subsetSelectSuccess(btn, json) {\n        selectLadda.stop(); // stop motion\n        $("#btnVariables").trigger("click"); // programmatic clicks\n        $("#btnModels").trigger("click");\n\n        var grayOuts = [];\n        var rCall = [];\n        rCall[0] = json.call;\n\n        // store contents of the pre-subset space\n        zPop();\n        var myNodes = jQuery.extend(true, [], allNodes);\n        var myParams = jQuery.extend(true, {}, zparams);\n        var myTrans = jQuery.extend(true, [], trans);\n        var myForce = jQuery.extend(true, [], forcetoggle);\n        var myPreprocess = jQuery.extend(true, {}, preprocess);\n        var myLog = jQuery.extend(true, [], logArray);\n        var myHistory = jQuery.extend(true, [], callHistory);\n\n        spaces[myspace] = {\n            "allNodes": myNodes,\n            "zparams": myParams,\n            "trans": myTrans,\n            "force": myForce,\n            "preprocess": myPreprocess,\n            "logArray": myLog,\n            "callHistory": myHistory\n        };\n\n        // remove pre-subset svg\n        var selectMe = "#m".concat(myspace);\n        d3.select(selectMe).attr(\'class\', \'item\');\n        selectMe = "#whitespace".concat(myspace);\n        d3.select(selectMe).remove();\n\n        myspace = spaces.length;\n        callHistory.push({\n            func: "subset",\n            zvars: jQuery.extend(true, [], zparams.zvars),\n            zsubset: jQuery.extend(true, [], zparams.zsubset),\n            zplot: jQuery.extend(true, [], zparams.zplot)\n        });\n\n        // this is to be used to gray out and remove listeners for variables that have been subsetted out of the data\n        function varOut(v) {\n            // if in nodes, remove gray out in left panel\n            // make unclickable in left panel\n            for (var i = 0; i < v.length; i++) {\n                var selectMe = v[i].replace(/\\W/g, "_");\n                byId(selectMe).style.color = hexToRgba(grayColor);\n                selectMe = "p#".concat(selectMe);\n                d3.select(selectMe).on("click", null);\n            }\n        }\n\n        showLog(\'subset\', rCall);\n        reWriteLog();\n\n        d3.select("#innercarousel").append(\'div\').attr(\'class\', \'item active\').attr(\'id\', function () {\n            return "m".concat(myspace.toString());\n        }).append(\'svg\').attr(\'id\', \'whitespace\');\n        svg = d3.select("#whitespace");\n\n        d3.json(json.url, function (error, json) {\n            if (error) {\n                return console.warn(error);\n            }\n            var jsondata = getVariableData(json);\n\n            for (var key in jsondata) {\n                var myIndex = findNodeIndex(key);\n\n                allNodes[myIndex].plotx = undefined;\n                allNodes[myIndex].ploty = undefined;\n                allNodes[myIndex].plotvalues = undefined;\n                allNodes[myIndex].plottype = "";\n\n                jQuery.extend(true, allNodes[myIndex], jsondata[key]);\n                allNodes[myIndex].subsetplot = false;\n                allNodes[myIndex].subsetrange = ["", ""];\n                allNodes[myIndex].setxplot = false;\n                allNodes[myIndex].setxvals = ["", ""];\n\n                if (allNodes[myIndex].valid == 0) {\n                    grayOuts.push(allNodes[myIndex].name);\n                    allNodes[myIndex].grayout = true;\n                }\n            }\n            rePlot();\n\n            layout(layoutAdd);\n        });\n\n        varOut(grayOuts);\n    }\n\n    selectLadda.start(); //start button motion\n    makeCorsRequest(urlcall, btn, subsetSelectSuccess, function (btn) {\n        return selectLadda.stop();\n    }, solajsonout);\n}\n\nfunction readPreprocess(data) {\n    return new Promise(function (resolve, _) {\n        priv = data.dataset.private || priv;\n        Object.keys(data.variables).forEach(function (k) {\n            return preprocess[k] = data.variables[k];\n        });\n        resolve();\n    });\n}\n\n// removes all the children svgs inside subset and setx divs\nfunction rePlot() {\n    d3.select(\'#tab2\').selectAll(\'svg\').remove();\n    d3.select(\'#setx\').selectAll(\'svg\').remove();\n    allNodes.forEach(function (n) {\n        return n.setxplot = n.subsetplot = false;\n    });\n}\n\nvar showLog = function showLog(val, rCall) {\n    logArray.push((val + \': \').concat(rCall[0]));\n    _mithril2.default.redraw();\n};\n\nfunction reWriteLog() {\n    d3.select("#collapseLog div.panel-body").selectAll("p").remove();\n    d3.select("#collapseLog div.panel-body").selectAll("p").data(logArray).enter().append("p").text(function (d) {\n        return d;\n    });\n}\n\n// acts as if the user clicked in whitespace. useful when restart() is outside of scope\nvar fakeClick = exports.fakeClick = function fakeClick() {\n    var ws = "#whitespace".concat(myspace);\n    // d3 and programmatic events don\'t mesh well, here\'s a SO workaround that looks good but uses jquery...\n    jQuery.fn.d3Click = function () {\n        this.each(function (i, e) {\n            var evt = document.createEvent("MouseEvents");\n            evt.initMouseEvent("mousedown", true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);\n            e.dispatchEvent(evt);\n        });\n    };\n    $(ws).d3Click();\n    d3.select(ws).classed(\'active\', false);\n};\n\n//EndSession(SessionContext) returns (Response) {}\nfunction endsession() {\n    var SessionContext = apiSession(zparams.zsessionid);\n\n    var jsonout = JSON.stringify(SessionContext);\n\n    var urlcall = d3mURL + "/endsession";\n    var solajsonout = "grpcrequest=" + jsonout;\n    console.log("EndSession: ");\n    console.log(solajsonout);\n    console.log("urlcall: ", urlcall);\n\n    function endSuccess(btn, Response) {\n        console.log(Response);\n    }\n\n    function endFail(btn) {\n        console.log("end session failed");\n    }\n\n    makeCorsRequest(urlcall, "nobutton", endSuccess, endFail, solajsonout);\n}\n\n//rpc ListPipelines(PipelineListRequest) returns (PipelineListResult) {}\nfunction listpipelines() {\n    var SessionContext = apiSession(zparams.zsessionid);\n    var PipeLineListRequest = { SessionContext: SessionContext };\n\n    var jsonout = JSON.stringify(PipeLineListRequest);\n\n    var urlcall = d3mURL + "/listpipelines";\n    var solajsonout = "grpcrequest=" + jsonout;\n    console.log("PipelineListRequest: ");\n    console.log(solajsonout);\n    console.log(urlcall);\n\n    function listPipesSuccess(btn, PipelineListResult) {\n        console.log(PipelineListResult);\n        //hardcoded pipes for now\n        var pipes = ["", "id1", "id2", "id3", "id4", "id5"];\n        d3.select("#results").selectAll("p").data(pipes).enter().append("p").attr("id", "_pipe_".concat).text(function (d) {\n            return d;\n        }).attr(\'class\', \'item-default\').on("click", function () {\n            if (this.className == "item-select") {\n                return;\n            } else {\n                d3.select("#results").select("p.item-select").attr(\'class\', \'item-default\');\n                d3.select(this).attr(\'class\', "item-select");\n            }\n        });\n\n        d3.select("#setxRight").selectAll("p").data(pipes).enter().append("p").attr("id", "_setxpipe_".concat).text(function (d) {\n            return d;\n        }).attr(\'class\', \'item-default\').on("click", function () {\n            if (this.className == "item-select") {\n                return;\n            } else {\n                d3.select("#setxRight").select("p.item-select").attr(\'class\', \'item-default\');\n                d3.select(this).attr(\'class\', "item-select");\n            }\n        });\n    }\n\n    function listPipesFail(btn) {\n        console.log("list pipelines failed");\n    }\n\n    makeCorsRequest(urlcall, "nobutton", listPipesSuccess, listPipesFail, solajsonout);\n}\n\n// rpc ExecutePipeline(PipelineExecuteRequest) returns (stream PipelineExecuteResult) {}\nfunction executepipeline() {\n    var SessionContext = apiSession(zparams.zsessionid);\n    var pipelineid = document.getElementById(\'setxRight\').querySelector(\'p.item-select\');\n    if (pipelineid == null) {\n        alert("Please select a pipeline to execute on.");return;\n    }\n    pipelineid = pipelineid.innerText;\n\n    zPop();\n    zparams.callHistory = callHistory;\n    var jsonout = JSON.stringify(zparams);\n\n    var features = apiFeature(zparams.zvars, "some uri");\n    var data = [];\n\n    //this will just set zparams.zsetx to the mean, which is default for setx plots\n    //note that if setxplot is modified, it will NOT == "" because zparams.zsetx is modified when the setx plot slider is moved for the first time\n    for (var i = 0; i < zparams.zvars.length; i++) {\n        var mydata = [];\n        var mymean = allNodes[findNodeIndex(zparams.zvars[i])].mean;\n        if (zparams.zsetx[i][0] == "") {\n            mydata[0] = mymean;\n        } else if (zparams.zsetx[i][0] != mymean) {\n            mydata[0] = zparams.zsetx[i][0];\n        }\n        if (zparams.zsetx[i][1] == "") {\n            mydata[1] = allNodes[findNodeIndex(zparams.zvars[i])].mean;\n        } else if (zparams.zsetx[i][1] != mymean) {\n            mydata[1] = zparams.zsetx[i][1];\n        }\n        data.push(mydata);\n    }\n\n    var PipelineExecuteRequest = { SessionContext: SessionContext, pipelineid: pipelineid, features: features, data: data };\n\n    jsonout = JSON.stringify(PipelineExecuteRequest);\n\n    var urlcall = d3mURL + "/executepipeline";\n    var solajsonout = "grpcrequest=" + jsonout;\n    console.log("PipelineExecuteRequest: ");\n    console.log(solajsonout);\n    console.log("urlcall: ", urlcall);\n\n    function executePipeSuccess(btn, PipelineExecuteResult) {\n        alert("pipeline executed");\n        console.log(PipelineExecuteResult);\n    }\n\n    function executePipeFail(btn) {\n        console.log("execute pipelines failed");\n    }\n\n    makeCorsRequest(urlcall, "nobutton", executePipeSuccess, executePipeFail, solajsonout);\n}\n\n// this is our call to django to update the problem schema\n// rpc UpdateProblemSchema(UpdateProblemSchemaRequest) returns (Response) {}\nfunction updateSchema(type, updates, lookup) {\n    var ReplaceProblemSchemaField = _defineProperty({}, type, lookup[updates[type]][1]);\n    //    let valuenum = lookup[updates[type]][2];\n    var UpdateProblemSchemaRequest = { ReplaceProblemSchemaField: ReplaceProblemSchemaField };\n\n    var jsonout = JSON.stringify(UpdateProblemSchemaRequest);\n\n    var urlcall = d3mURL + "/updateproblemschema";\n    var solajsonout = "grpcrequest=" + jsonout;\n    console.log("UpdateProblemSchemaRequest: ");\n    console.log(solajsonout);\n    console.log("urlcall: ", urlcall);\n\n    function usSuccess(btn, Response) {\n        console.log(Response);\n    }\n\n    function usFail(btn) {\n        console.log("update schema failed");\n    }\n\n    makeCorsRequest(urlcall, "nobutton", usSuccess, usFail, solajsonout);\n}\n\n// Find something centerish to the vertices of a convex hull\n// (specifically, the center of the bounding box)\nfunction jamescentroid(coord) {\n    var minx = coord[0][0],\n        maxx = coord[0][0],\n        miny = coord[0][1],\n        maxy = coord[0][1];\n    for (var j = 1; j < coord.length; j++) {\n        if (coord[j][0] < minx) minx = coord[j][0];\n        if (coord[j][1] < miny) miny = coord[j][1];\n        if (coord[j][0] > maxx) maxx = coord[j][0];\n        if (coord[j][1] > maxy) maxy = coord[j][1];\n    };\n    return [(minx + maxx) / 2, (miny + maxy) / 2];\n};\n\n// Define each pebble radius.\n// Presently, most pebbles are scaled to radius set by global allR.\n// Members of groups are scaled down if group gets large.\nfunction setPebbleRadius(d) {\n    if (d.group1 || d.group2) {\n        // if a member of a group, need to calculate radius size\n        var uppersize = 7;\n        var ng1 = d.group1 ? zparams.zgroup1.length : 1; // size of group1, if a member of group 1\n        var ng2 = d.group2 ? zparams.zgroup2.length : 1; // size of group2, if a member of group 2\n        var maxng = Math.max(ng1, ng2); // size of the largest group variable is member of\n        return maxng > uppersize ? allR * Math.sqrt(uppersize / maxng) : allR; // keep total area of pebbles bounded to pi * allR^2 * uppersize, thus shrinking radius for pebbles in larger groups                \n    } else {\n            return allR; // nongroup members get the common global radius\n        }\n};\n\n// Define each pebble charge.\n// This was the previous charge setting:\n//return ((zparams.zgroup1.indexOf(node.name) < 0 ) & (zparams.zgroup2.indexOf(node.name) < 0 ))   ? -800 : -400;  // -1 is the value if no index position found\nfunction setPebbleCharge(d) {\n    if (d.group1 || d.group2) {\n        if (d.forefront) {\n            // pebbles packed in groups repel others on mouseover\n            return -1000;\n        }\n        var uppersize = 7;\n        var ng1 = d.group1 ? zparams.zgroup1.length : 1; // size of group1, if a member of group 1\n        var ng2 = d.group2 ? zparams.zgroup2.length : 1; // size of group2, if a member of group 2\n        var maxng = Math.max(ng1, ng2); // size of the largest group variable is member of\n        return maxng > uppersize ? -400 * (uppersize / maxng) : -400; // decrease charge as pebbles become smaller, so they can pack together\n    } else {\n        return -800;\n    }\n};\n\nfunction expandrightpanel() {\n    document.getElementById(\'rightpanel\').classList.add("expandpanelfull");\n    console.log("HERE");\n}\n\nfunction toggleRightButtons(set) {\n\n    function setWidths(btns) {\n        var mywidth = 100 / btns.length;\n        mywidth = mywidth.toString() + \'%\';\n        var expandwidth = \'35%\';\n        var shrinkwidth = 65 / (btns.length - 1);\n        shrinkwidth = shrinkwidth.toString() + \'%\';\n        var mylis = document.getElementById(\'rightpanel\').querySelectorAll(".accordian li");\n        // hardly ever runs on the page\n        for (var i = 0; i < mylis.length; i++) {\n            mylis[i].style.width = mywidth;\n            mylis[i].addEventListener(\'mouseover\', function () {\n                for (var j = 0; j < mylis.length; j++) {\n                    mylis[j].style.width = shrinkwidth;\n                }\n                this.style.width = expandwidth;\n            });\n            mylis[i].addEventListener(\'mouseout\', function () {\n                for (var j = 0; j < mylis.length; j++) {\n                    mylis[j].style.width = mywidth;\n                }\n            });\n        }\n    }\n\n    if (set == "tasks") {\n\n        document.getElementById(\'btnModels\').classList.add("noshow");\n        document.getElementById(\'btnSetx\').classList.add("noshow");\n        document.getElementById(\'btnResults\').classList.add("noshow");\n\n        var mybtns = document.getElementById(\'rightpanelbuttons\').querySelectorAll(".btn:not(.noshow)");\n        setWidths(mybtns);\n    } else if (set == "all") {\n        // first remove noshow class\n        var _mybtns = document.getElementById(\'rightpanelbuttons\').querySelectorAll(".noshow");\n        for (var i = 0; i < _mybtns.length; i++) {\n            _mybtns[i].classList.remove("noshow");\n        }\n\n        // droping models for IS_D3M_DOMAIN\n        document.getElementById(\'btnModels\').classList.add("noshow");\n\n        // then select all the buttons\n        _mybtns = document.getElementById(\'rightpanelbuttons\').querySelectorAll(".btn:not(.noshow)");\n        setWidths(_mybtns);\n    }\n    if (set == "models") {\n        document.getElementById(\'btnModels\').style.display = \'inline\';\n        document.getElementById(\'btnSetx\').style.display = \'inline\';\n        document.getElementById(\'btnResults\').style.display = \'inline\';\n\n        document.getElementById(\'btnType\').style.display = \'none\';\n        document.getElementById(\'btnSubtype\').style.display = \'none\';\n        document.getElementById(\'btnMetrics\').style.display = \'none\';\n        document.getElementById(\'btnOutputs\').style.display = \'none\';\n    }\n}\n\n// scatterplot function to go to plots.js to be reused\nfunction bivariatePlot(x_Axis, y_Axis, x_Axis_name, y_Axis_name) {\n\n    d3.select("#setxMiddle").html("");\n    d3.select("#setxMiddle").select("svg").remove();\n\n    console.log("bivariate plot called");\n    // scatter plot\n\n    var data_plot = [];\n    var nanCount = 0;\n    for (var i = 0; i < 1000; i++) {\n        if (isNaN(x_Axis[i]) || isNaN(y_Axis[i])) {\n            nanCount++;\n        } else {\n            var newNumber1 = x_Axis[i];\n            var newNumber2 = y_Axis[i];\n            data_plot.push({ xaxis: newNumber1, yaxis: newNumber2, score: Math.random() * 100 });\n        }\n    }\n\n    var margin = { top: 20, right: 15, bottom: 40, left: 60 },\n        width = 500 - margin.left - margin.right,\n        height = 280 - margin.top - margin.bottom;\n    var padding = 100;\n\n    var min_x = d3.min(data_plot, function (d, i) {\n        return data_plot[i].xaxis;\n    });\n    var max_x = d3.max(data_plot, function (d, i) {\n        return data_plot[i].xaxis;\n    });\n    var avg_x = (max_x - min_x) / 10;\n    var min_y = d3.min(data_plot, function (d, i) {\n        return data_plot[i].yaxis;\n    });\n    var max_y = d3.max(data_plot, function (d, i) {\n        return data_plot[i].yaxis;\n    });\n    var avg_y = (max_y - min_y) / 10;\n\n    var xScale = d3.scale.linear().domain([min_x - avg_x, max_x + avg_x]).range([0, width]);\n\n    var yScale = d3.scale.linear().domain([min_y - avg_y, max_y + avg_y]).range([height, 0]);\n\n    var xAxis = d3.svg.axis().scale(xScale).orient(\'bottom\').tickSize(-height);\n\n    var yAxis = d3.svg.axis().scale(yScale).orient(\'left\').ticks(5).tickSize(-width);\n\n    var zoom = d3.behavior.zoom().x(xScale).y(yScale).scaleExtent([1, 10]).on("zoom", zoomed);\n\n    var chart_scatter = d3.select(\'#setxMiddle\').append(\'svg:svg\').attr(\'width\', width + margin.right + margin.left).attr(\'height\', height + margin.top + margin.bottom);\n    // .call(zoom); dropping this for now, until the line zooms properly\n\n    var main1 = chart_scatter.append(\'g\').attr(\'transform\', \'translate(\' + margin.left + \',\' + margin.top + \')\').attr(\'width\', width + margin.right + margin.left).attr(\'height\', height + margin.top + margin.bottom).attr(\'class\', \'main\');\n\n    var gX = main1.append(\'g\').attr(\'transform\', \'translate(0,\' + height + \')\').attr(\'class\', \'x axis\').call(xAxis);\n\n    var gY = main1.append(\'g\').attr(\'transform\', \'translate(0,0)\').attr(\'class\', \'y axis\').call(yAxis);\n\n    var clip = main1.append("defs").append("svg:clipPath").attr("id", "clip").append("svg:rect").attr("id", "clip-rect").attr("x", "0").attr("y", "0").attr(\'width\', width).attr(\'height\', height);\n\n    main1.append("g").attr("clip-path", "url(#clip)").selectAll("circle").data(data_plot).enter().append("circle").attr("cx", function (d, i) {\n        return xScale(data_plot[i].xaxis);\n    }).attr("cy", function (d, i) {\n        return yScale(data_plot[i].yaxis);\n    }).attr("r", 2).style("fill", "#B71C1C");\n    chart_scatter.append("text").attr("text-anchor", "middle") // this makes it easy to centre the text as the transform is applied to the anchor\n    .attr("transform", "translate(" + padding / 5 + "," + height / 2 + ")rotate(-90)") // text is drawn off the screen top left, move down and out and rotate\n    .text(y_Axis_name).style("fill", "#424242").style("text-indent", "20px").style("font-size", "12px").style("font-weight", "bold");\n\n    chart_scatter.append("text").attr("text-anchor", "middle") // this makes it easy to centre the text as the transform is applied to the anchor\n    .attr("transform", "translate(" + width / 2 + "," + (height + padding / 2) + ")") // centre below axis\n    .text(x_Axis_name).style("fill", "#424242").style("text-indent", "20px").style("font-size", "12px").style("font-weight", "bold");\n\n    main1.append("line").attr("x1", xScale(min_x)).attr("y1", yScale(min_x)).attr("x2", xScale(max_x)).attr("y2", yScale(max_x)).attr("stroke-width", 2).attr("stroke", "black");\n\n    function zoomed() {\n        var panX = d3.event.translate[0];\n        var panY = d3.event.translate[1];\n        var scale = d3.event.scale;\n\n        panX = panX > 10 ? 10 : panX;\n        var maxX = -(scale - 1) * width - 10;\n        panX = panX < maxX ? maxX : panX;\n\n        panY = panY > 10 ? 10 : panY;\n        var maxY = -(scale - 1) * height - 10;\n        panY = panY < maxY ? maxY : panY;\n\n        zoom.translate([panX, panY]);\n\n        main1.select(".x.axis").call(xAxis);\n        main1.select(".y.axis").call(yAxis);\n        main1.selectAll("circle").attr("cx", function (d, i) {\n            console.log("circle x ", xScale(5));\n            return xScale(data_plot[i].xaxis);\n        }).attr("cy", function (d, i) {\n            return yScale(data_plot[i].yaxis);\n        }).attr("r", 2.5).style("fill", "#B71C1C");\n\n        // below doesn\'t work, so I\'m just dropping the zoom\n        main1.select("line").attr("x1", function (d, i) {\n            return xScale(min_x);\n        }).attr("y1", function (d, i) {\n            return xScale(min_x);\n        }).attr("x2", function (d, i) {\n            return xScale(max_x);\n        }).attr("y2", function (d, i) {\n            return yScale(max_x);\n        }).attr("stroke-width", 2).attr("stroke", "black");\n    }\n\n    //  d3.select("#NAcount").text("There are " + nanCount + " number of NA values in the relation.");\n\n}\n\nfunction setxTable(features) {\n    function tabulate(data, columns) {\n        var table = d3.select(\'#setxLeftBottom\').append(\'table\');\n        var thead = table.append(\'thead\');\n        var tbody = table.append(\'tbody\');\n\n        // append the header row\n        thead.append(\'tr\').selectAll(\'th\').data(columns).enter().append(\'th\').text(function (column) {\n            return column;\n        });\n\n        // create a row for each object in the data\n        var rows = tbody.selectAll(\'tr\').data(data).enter().append(\'tr\');\n\n        // create a cell in each row for each column\n        var cells = rows.selectAll(\'td\').data(function (row) {\n            return columns.map(function (column) {\n                return { column: column, value: row[column] };\n            });\n        }).enter().append(\'td\').text(function (d) {\n            return d.value;\n        });\n\n        return table;\n    }\n\n    var mydata = [];\n    for (var i = 0; i < features.length; i++) {\n        mydata.push({ "Variables": features[i], "From": 1, "To": 3 });\n    }\n\n    // render the table(s)\n    tabulate(mydata, [\'Variables\', \'From\', \'To\']); // 2 column table\n}\n\n// D3M API HELPERS\n// because these get built in various places, pulling them out for easy manipulation\nfunction apiFeature(vars, uri) {\n    var out = [];\n    for (var i = 0; i < vars.length; i++) {\n        out.push({ featureId: vars[i], dataUri: uri });\n    }\n    return out;\n}\n\n// silly but perhaps useful if in the future SessionContext requires more things (as suggest by core)\nfunction apiSession(context) {\n    return { "session_id": context };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvYXBwL2FwcC5qcz9mNTEyIl0sIm5hbWVzIjpbIm1haW4iLCJnZXRWYXJpYWJsZURhdGEiLCJmb3JjZVN3aXRjaCIsImxvY2tEZXNjcmlwdGlvbiIsImVzdGltYXRlIiwicnVuUHJlcHJvY2VzcyIsImVyYXNlIiwidGFiTGVmdCIsInRhYlJpZ2h0IiwicGFuZWxQbG90cyIsImJvcmRlclN0YXRlIiwic3Vic2V0U2VsZWN0IiwiZW5kc2Vzc2lvbiIsImxpc3RwaXBlbGluZXMiLCJleGVjdXRlcGlwZWxpbmUiLCJleHBhbmRyaWdodHBhbmVsIiwiYml2YXJpYXRlUGxvdCIsInNldHhUYWJsZSIsImNkYiIsInByb2R1Y3Rpb24iLCJjb25zb2xlIiwibG9nIiwiYXBwbHkiLCJrIiwiY29sb3JzIiwiZDMiLCJzY2FsZSIsImNhdGVnb3J5MjAiLCJjc0NvbG9yIiwiZHZDb2xvciIsImdyMUNvbG9yIiwiZ3IxT3BhY2l0eSIsImdyMkNvbG9yIiwiZ3IyT3BhY2l0eSIsImdyYXlDb2xvciIsIm5vbUNvbG9yIiwidmFyQ29sb3IiLCJ0YWdnZWRDb2xvciIsInRpbWVDb2xvciIsImxlZnR0YWIiLCJzdWJzZXQiLCJzdW1tYXJ5SG9sZCIsInJpZ2h0dGFiIiwidCIsInR5cGVUcmFuc2Zvcm0iLCJ0cmFuc2Zvcm1MaXN0Iiwic3BsaXQiLCJ0cmFuc2Zvcm1WYXIiLCJ0cmFucyIsInByZXByb2Nlc3MiLCJzcGFjZXMiLCJsYXlvdXRBZGQiLCJsYXlvdXRNb3ZlIiwiYWxsUiIsImluZDEiLCJNYXRoIiwiY29zIiwic2luIiwiaW5kMiIsIm15c3BhY2UiLCJmb3JjZXRvZ2dsZSIsImxvY2t0b2dnbGUiLCJwcml2IiwibG9nQXJyYXkiLCJ6cGFyYW1zIiwiemRhdGEiLCJ6ZWRnZXMiLCJ6dGltZSIsInpub20iLCJ6Y3Jvc3MiLCJ6bW9kZWwiLCJ6dmFycyIsInpkdiIsInpncm91cDEiLCJ6Z3JvdXAyIiwiemRhdGF1cmwiLCJ6ZDNtZGF0YSIsInpkM210YXJnZXQiLCJ6c3Vic2V0IiwienNldHgiLCJ6bW9kZWxjb3VudCIsInpwbG90IiwienNlc3Npb25pZCIsInpkYXRhY2l0ZSIsIm1vZGVsQ291bnQiLCJ2YWx1ZUtleSIsImFsbE5vZGVzIiwiYWxsUmVzdWx0cyIsIm5vZGVzIiwibGlua3MiLCJtb2RzIiwiZXN0aW1hdGVkIiwicmlnaHRDbGlja0xhc3QiLCJzZWxJbnRlcmFjdCIsImNhbGxIaXN0b3J5IiwibXl0YXJnZXQiLCJkM21NZXRyaWNzIiwibWV0cmljVW5kZWZpbmVkIiwiYWNjdXJhY3kiLCJmMSIsImYxTWljcm8iLCJmMU1hY3JvIiwicm9jQXVjIiwicm9jQXVjTWljcm8iLCJyb2NBdWNNYWNybyIsIm1lYW5TcXVhcmVkRXJyb3IiLCJyb290TWVhblNxdWFyZWRFcnJvciIsInJvb3RNZWFuU3F1YXJlZEVycm9yQXZnIiwibWVhbkFic29sdXRlRXJyb3IiLCJyU3F1YXJlZCIsIm5vcm1hbGl6ZWRNdXR1YWxJbmZvcm1hdGlvbiIsImphY2NhcmRTaW1pbGFyaXR5U2NvcmUiLCJleGVjdXRpb25UaW1lIiwiZDNtVGFza1R5cGUiLCJ0YXNrVHlwZVVuZGVmaW5lZCIsImNsYXNzaWZpY2F0aW9uIiwicmVncmVzc2lvbiIsInNpbWlsYXJpdHlNYXRjaGluZyIsImxpbmtQcmVkaWN0aW9uIiwidmVydGV4Tm9taW5hdGlvbiIsImNvbW11bml0eURldGVjdGlvbiIsImdyYXBoTWF0Y2hpbmciLCJ0aW1lc2VyaWVzRm9yZWNhc3RpbmciLCJjb2xsYWJvcmF0aXZlRmlsdGVyaW5nIiwiZDNtVGFza1N1YnR5cGUiLCJ0YXNrU3VidHlwZVVuZGVmaW5lZCIsInN1YnR5cGVOb25lIiwiYmluYXJ5IiwibXVsdGlDbGFzcyIsIm11bHRpTGFiZWwiLCJ1bmlWYXJpYXRlIiwibXVsdGlWYXJpYXRlIiwib3ZlcmxhcHBpbmciLCJub25PdmVybGFwcGluZyIsImQzbU91dHB1dFR5cGUiLCJvdXRwdXRVbmRlZmluZWQiLCJjbGFzc0xhYmVsIiwicHJvYmFiaWxpdHkiLCJyZWFsIiwibm9kZUlEIiwidmVjdG9yQ2xhc3NMYWJlbCIsInZlY3RvclN0b2NoYXN0aWMiLCJ2ZWN0b3JSZWFsIiwiZmlsZSIsImQzbVByb2JsZW1EZXNjcmlwdGlvbiIsInRhc2tUeXBlIiwidGFza1N1YnR5cGUiLCJvdXRwdXRUeXBlIiwibWV0cmljIiwidGFza0Rlc2NyaXB0aW9uIiwic3ZnIiwid2lkdGgiLCJoZWlnaHQiLCJkaXYiLCJlc3RpbWF0ZUxhZGRhIiwic2VsZWN0TGFkZGEiLCJhcmMxIiwiYXJjMyIsImFyYzQiLCJhcmNJbmQxIiwiYXJjSW5kMiIsImFyY0luZDFMaW1pdHMiLCJhcmNJbmQyTGltaXRzIiwiYnlJZCIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJpZCIsInJlc2V0IiwicmVsb2FkUGFnZSIsImxvY2F0aW9uIiwicmVsb2FkIiwiZGF0YXVybCIsImZpbGVpZCIsImhvc3RuYW1lIiwiZGRpdXJsIiwiYXBpa2V5IiwiYWxlcnQiLCJFcnJvciIsImRhdGF2ZXJzZXVybCIsIkRBVEFWRVJTRV9VUkwiLCJzZWxlY3QiLCJ0ZW1wV2lkdGgiLCJzdHlsZSIsInN1YnN0cmluZyIsImxlbmd0aCIsIiQiLCJ3aW5kb3ciLCJMYWRkYSIsImNyZWF0ZSIsImNvbG9yVGltZSIsImNvbG9yQ1MiLCJkZXBWYXIiLCJzdWJzZXRkaXYiLCJzZXR4ZGl2IiwiYmFyd2lkdGgiLCJiYXJoZWlnaHQiLCJiYXJQYWRkaW5nIiwiYmFybnVtYmVyIiwiYXJjIiwic3RhcnQiLCJlbmQiLCJpbm5lclJhZGl1cyIsIm91dGVyUmFkaXVzIiwic3RhcnRBbmdsZSIsImVuZEFuZ2xlIiwiYXJjSW5kIiwiYXJjbGltaXRzIiwiYXJjMCIsImFyYzIiLCJkYXRhc2V0MiIsImxhYmxBcnJheSIsImhvbGQiLCJzdWJzZXROb2RlcyIsIm9uIiwic2VsZWN0QWxsIiwiZGF0YSIsImVudGVyIiwiYXBwZW5kIiwidGV4dCIsImQiLCJyZW1vdmUiLCJjb25maWd1cmF0aW9ucyIsImQzbVJvb3RQYXRoIiwiZDNtRGF0YU5hbWUiLCJkM21EYXRhIiwiZDNtVGFyZ2V0IiwiZDNtUHJlcHJvY2VzcyIsImQzbVBTIiwiZDNtRFMiLCJtZXRhZGF0YXVybCIsInBVUkwiLCJkM21fbW9kZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVxdWVzdCIsIm1ldGhvZCIsInVybCIsInRoZW4iLCJyZXN1bHQiLCJKU09OIiwicGFyc2UiLCJzdHJpbmdpZnkiLCJ0cmFpbmluZ19kYXRhX3Jvb3QiLCJyZXBsYWNlIiwibmFtZSIsInByb2JsZW1fc2NoZW1hIiwiZGF0YXNldF9zY2hlbWEiLCJwb3AiLCJyZWFkUHJlcHJvY2VzcyIsInJlamVjdCIsInhtbCIsInZhcnMiLCJPYmplY3QiLCJrZXlzIiwidGVtcCIsImRvY3VtZW50RWxlbWVudCIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwiY2hpbGROb2RlcyIsIm5vZGVWYWx1ZSIsImNpdGUiLCJkYXRhbmFtZSIsImh0bWwiLCJpIiwib2JqIiwicmVmbGV4aXZlIiwibGFibCIsImNvdW50Iiwibm9kZUNvbCIsImJhc2VDb2wiLCJzdHJva2VDb2xvciIsInN0cm9rZVdpZHRoIiwic3Vic2V0cGxvdCIsInN1YnNldHJhbmdlIiwic2V0eHBsb3QiLCJzZXR4dmFscyIsImdyYXlvdXQiLCJncm91cDEiLCJncm91cDIiLCJmb3JlZnJvbnQiLCJqUXVlcnkiLCJleHRlbmQiLCJwdXNoIiwianNvbiIsImVyciIsImtleSIsInplbGlnNW1vZGVscyIsImhhc093blByb3BlcnR5IiwiZGVzY3JpcHRpb24iLCJ6ZWxpZzVjaG9pY2Vtb2RlbHMiLCJzY2FmZm9sZGluZyIsImxheW91dCIsImRhdGFEb3dubG9hZCIsIl8iLCJ0YXJnZXQiLCJmaWVsZCIsImFUYWciLCJjcmVhdGVFbGVtZW50Iiwic2V0QXR0cmlidXRlIiwiZGVzY3JpcHRpb25GaWxlIiwidGV4dENvbnRlbnQiLCJhcHBlbmRDaGlsZCIsInRhc2tTdWJUeXBlIiwiY2xpY2siLCJ1c2VyX2FnZW50IiwidmVyc2lvbiIsIlNlc3Npb25SZXF1ZXN0IiwianNvbm91dCIsInVybGNhbGwiLCJkM21VUkwiLCJzb2xhanNvbm91dCIsInNzU3VjY2VzcyIsImJ0biIsIlNlc3Npb25SZXNwb25zZSIsImNvbnRleHQiLCJzZXNzaW9uSWQiLCJ6UG9wIiwic3NGYWlsIiwibWFrZUNvcnNSZXF1ZXN0IiwiJGZpbGwiLCJvcCIsImQxIiwiZDIiLCJ0cmFuc2l0aW9uIiwiYXR0ciIsImRlbGF5IiwiZHVyYXRpb24iLCJmaWxsIiwiZmlsbFRoaXMiLCJzZWxmIiwiY2FsbGJhY2siLCJkaXNwbGF5IiwiZmFkZU91dCIsInQxIiwicG9zIiwib2Zmc2V0IiwidG9wIiwiZmFkZUluIiwibiIsImtleXVwIiwiZXZ0Iiwia2V5Q29kZSIsInZhbCIsInRyYW5zUGFyc2UiLCJ0cmFuc2Zvcm0iLCJzbGljZSIsInR2YXIiLCJjb25jYXQiLCJwYXJlbnQiLCJmYW5kZU91dCIsInN0b3BQcm9wYWdhdGlvbiIsInRmdW5jIiwidGNhbGwiLCJ0b2dnbGVSaWdodEJ1dHRvbnMiLCJ0b1N0cmluZyIsInJlZHJhdyIsInNwbGljZSIsImNvbG9yIiwiYXJncyIsImZvckVhY2giLCJ4IiwiaWR4IiwiaW5kZXhPZiIsImNsaWNrVmFyIiwidiIsInYyIiwibXlWYWx1ZXMiLCJsaW5lIiwibGluZTIiLCJ2aXNiYWNrZ3JvdW5kIiwidmlzMmJhY2tncm91bmQiLCJ2aXMiLCJ2aXMyIiwiaiIsImlpIiwiZmluZE5vZGVJbmRleCIsInNlbGVjdE1lIiwiaGV4VG9SZ2JhIiwibXlzcmMiLCJub2RlSW5kZXgiLCJteXRndCIsInNvdXJjZSIsImxlZnQiLCJyaWdodCIsImZvcmNlIiwic2l6ZSIsImxpbmtEaXN0YW5jZSIsImNoYXJnZSIsInRpY2siLCJkcmFnX2xpbmUiLCJwYXRoIiwiY2lyY2xlIiwic2VsZWN0ZWRfbm9kZSIsInNlbGVjdGVkX2xpbmsiLCJtb3VzZWRvd25fbGluayIsIm1vdXNlZG93bl9ub2RlIiwibW91c2V1cF9ub2RlIiwicmVzZXRNb3VzZVZhcnMiLCJmaW5kY29vcmRzIiwiZmluZG5hbWVzIiwiYWxsbmFtZXMiLCJjb29yZHMiLCJsZW5ndGhlbiIsImZjb29yZHMiLCJBcnJheSIsImFkZGxvY2F0aW9uIiwiZGVsdGF4IiwiZGVsdGF5IiwiZGVsdGEiLCJsZW5ndGhlbmNvb3JkcyIsIm1hcCIsInkiLCJncjFjb29yZHMiLCJncjJjb29yZHMiLCJkZXBjb29yZHMiLCJteWh1bGwiLCJnZW9tIiwiaHVsbCIsImpvaW4iLCJwIiwiamFtZXNjZW50cm9pZCIsInEiLCJsZGVsdGFYIiwibGRlbHRhWSIsImxkaXN0Iiwic3FydCIsImxub3JtWCIsImxub3JtWSIsImxzb3VyY2VQYWRkaW5nIiwibHRhcmdldFBhZGRpbmciLCJzaWduIiwibWluIiwiYWxwaGEiLCJkZWx0YVgiLCJkZWx0YVkiLCJkaXN0Iiwibm9ybVgiLCJub3JtWSIsInNvdXJjZVBhZGRpbmciLCJ0YXJnZXRQYWRkaW5nIiwic291cmNlWCIsInNvdXJjZVkiLCJ0YXJnZXRYIiwidGFyZ2V0WSIsInNldFBlYmJsZVJhZGl1cyIsIm5vZGUiLCJmaW5kTm9kZSIsImluY2x1ZGVzIiwiaW5kZXgiLCJzcGxpY2VMaW5rc0Zvck5vZGUiLCJub2RlUmVzZXQiLCJsZWdlbmQiLCJyZXN0YXJ0IiwibXlDb2xvciIsInJnYiIsImNsYXNzTmFtZSIsImlubmVySFRNTCIsInVwZGF0ZVNjaGVtYSIsImNhbGwiLCJkcmFnIiwiZ3Jhdml0eSIsInNldFBlYmJsZUNoYXJnZSIsImxpbmtTdHJlbmd0aCIsInJlc3VtZSIsImNsYXNzZWQiLCJleGl0IiwiZyIsImVhY2giLCJwbG90dHlwZSIsInN0ciIsInNldENvbG9ycyIsImRlZmF1bHROdW1jaGFyIiwiZXZlbnQiLCJwcmV2ZW50RGVmYXVsdCIsIm1vdXNlbW92ZSIsImRpcmVjdGlvbiIsImxpbmsiLCJmaWx0ZXIiLCJ2YXJTdW1tYXJ5Iiwic2VsZWN0ZWRJbmRleCIsIm1vdXNlZG93biIsImN0cmxLZXkiLCJtb3VzZSIsIm1vdXNldXAiLCJmYWtlQ2xpY2siLCJjbGlja19ldiIsImNyZWF0ZUV2ZW50IiwiaW5pdEV2ZW50IiwiY2xpY2tJRCIsImRpc3BhdGNoRXZlbnQiLCJmaW5kIiwiJG5vZGVzIiwiYWxsIiwibm9kZU5hbWUiLCJqc29uRGF0YSIsInZhcmlhYmxlcyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJjbGFzc0xpc3QiLCJhZGQiLCJsIiwic3JjdGd0IiwiZXN0aW1hdGVTdWNjZXNzIiwic3RvcCIsInJlbW92ZUNoaWxkIiwidHJpZ2dlciIsIm1vZGVsIiwibW9kQ29sIiwiaW5zZXJ0IiwiYSIsImJhY2tncm91bmRDb2xvciIsImIiLCJzdWJzdHIiLCJ2aXoiLCJyQ2FsbCIsInNob3dMb2ciLCJlc3RpbWF0ZUZhaWwiLCJzZWxlY3RvclN1Y2Nlc3MiLCJzZWxlY3RvckZhaWwiLCJyYXBwVVJMIiwiYWxsVmFycyIsInNlbGVjdG9ydXJsY2FsbCIsImNyZWF0ZVBpcGVsaW5lU3VjY2VzcyIsInRyYWluRmVhdHVyZXMiLCJhcGlGZWF0dXJlIiwicHJlZGljdG9ycyIsInVyaSIsImZlYXR1cmVzIiwidGFyZ2V0RmVhdHVyZXMiLCJkZXB2YXIiLCJ0YXNrIiwib3V0cHV0IiwibWV0cmljcyIsInRhc2tEZXNjcmlwdGlvbnJpcHRpb24iLCJtYXhQaXBlbGluZXMiLCJkdnZhbHVlcyIsIlBpcGVsaW5lQ3JlYXRlUmVxdWVzdCIsInNlbmRQaXBlbGluZVN1Y2Nlc3MiLCJQaXBlbGluZUNyZWF0ZVJlc3VsdCIsInBpcGVsaW5laWQiLCJQaXBlbGluZUV4ZWN1dGVSZXN1bHRzUmVxdWVzdCIsImdldEV4ZWN1dGVQaXBlU3VjY2VzcyIsIlBpcGVsaW5lRXhlY3V0ZVJlc3VsdCIsInByZWR2YWxzIiwicmFuZG9tIiwieGRhdGEiLCJ5ZGF0YSIsImdldEV4ZWN1dGVQaXBlRmFpbCIsInNlbmRQaXBlbGluZUZhaWwiLCJjcmVhdGVQaXBlbGluZUZhaWwiLCJhcGlTZXNzaW9uIiwiZGF0YWxvYyIsInRhcmdldGxvYyIsImRhdGFzdHViIiwiRm9ybURhdGEiLCJ0YTJzdHVmZiIsImRvd25sb2FkU3VjY2VzcyIsInNlc3Npb25pZCIsImhyZWYiLCJkb3dubG9hZEZhaWwiLCJteW0iLCJyZW1vdmVLaWRzIiwiZmlyc3RDaGlsZCIsImZpbGVsaXN0IiwiaW1hZ2VzIiwiemZpZyIsInJlc3VsdHNBcnJheSIsInN1bUluZm8iLCJ0YWJsZSIsInRoZWFkIiwiY29sbmFtZXMiLCJ0Ym9keSIsIm15TnVtIiwiTnVtYmVyIiwiaXNOYU4iLCJ0b1ByZWNpc2lvbiIsIm91dDIiLCJ0MiIsImsyIiwic3ViTWUyIiwiaW5kZXhlZCIsIm0yIiwibWF0Y2giLCJyZSIsIlJlZ0V4cCIsInMiLCJzZWFyY2giLCJmcm9tIiwidG8iLCJteW4iLCJvdXR0eXBlcyIsInZhcm5hbWVzVHlwZXMiLCJpbnRlcnZhbCIsIm51bWNoYXIiLCJuYXR1cmUiLCJwbG90dmFsdWVzIiwicGxvdHgiLCJ0cmFuc2Zvcm1zdHVmZiIsInR5cGVTdHVmZiIsInRyYW5zZm9ybVN1Y2Nlc3MiLCJ3YXJuIiwiZnVuYyIsInN1YnNldGVkIiwibmV3VmFyIiwiZXJyb3IiLCJqc29uZGF0YSIsIm15SW5kZXgiLCJvYmoxIiwiZGVmYXVsdEludGVydmFsIiwiZGVmYXVsdE5hdHVyZSIsImRlZmF1bHRCaW5hcnkiLCJ0cmFuc2Zvcm1GYWlsIiwiY3JlYXRlQ09SU1JlcXVlc3QiLCJ4aHIiLCJYTUxIdHRwUmVxdWVzdCIsIm9wZW4iLCJYRG9tYWluUmVxdWVzdCIsInNldFJlcXVlc3RIZWFkZXIiLCJ3YXJuaW5nY2FsbGJhY2siLCJqc29uc3RyaW5nIiwib25sb2FkIiwicmVzcG9uc2VUZXh0IiwibmFtZXMiLCJ3YXJuaW5nIiwib25lcnJvciIsInN0YXR1cyIsInJlYWR5U3RhdGUiLCJzZW5kIiwibGVmdHBhbmVsTWVkaXVtIiwicmlnaHRwYW5lbE1lZGl1bSIsImZuIiwiZDNDbGljayIsImNoaWxkcmVuIiwiZSIsIm15Y29sIiwiaW5pdE1vdXNlRXZlbnQiLCJsb2FkWE1MRG9jIiwiWE1MbmFtZSIsInhtbERvYyIsInJlc3BvbnNlWE1MIiwiQWN0aXZlWE9iamVjdCIsImFzeW5jIiwibG9hZCIsInRhYiIsInBhbmVsIiwiY2xzIiwidG9nZ2xlUiIsImV4cGFuZCIsImdldEF0dHJpYnV0ZSIsInRvZ2dsZVJGdWxsIiwic3VtbWFyeSIsInJpbnQiLCJmb3JtYXQiLCJtZWFuQ0kiLCJtZWFuIiwibG93ZXJCb3VuZCIsInVwcGVyQm91bmQiLCJtZWRpYW4iLCJtb2RlIiwiZnJlcW1vZGUiLCJtaWQiLCJmcmVxbWlkIiwiZmV3ZXN0IiwiZnJlcWZld2VzdCIsInNkIiwibWF4IiwiaW52YWxpZCIsInZhbGlkIiwidW5pcXVlcyIsImhlcmZpbmRhaGwiLCJwb3BvdmVyQ29udGVudCIsImludCIsInByZWMiLCJwb3B1cFgiLCJ0c2YiLCJ0ZW1wWCIsInRlbXBZIiwiaWRzIiwicmVnc3RyIiwibXluYW1lIiwiZXhlYyIsIm5vZGVpZCIsInBhcnNlSW50IiwiaGV4IiwiYyIsInRlbXBpbmRleCIsImlzQXJyYXkiLCJkdm5hbWUiLCJuZ3JvdXAxIiwibmdyb3VwMiIsImNzcyIsInN1YnNldEVtcHR5Iiwic3Vic2V0c3R1ZmYiLCJzdWJzZXRTZWxlY3RTdWNjZXNzIiwiZ3JheU91dHMiLCJteU5vZGVzIiwibXlQYXJhbXMiLCJteVRyYW5zIiwibXlGb3JjZSIsIm15UHJlcHJvY2VzcyIsIm15TG9nIiwibXlIaXN0b3J5IiwidmFyT3V0IiwicmVXcml0ZUxvZyIsInVuZGVmaW5lZCIsInBsb3R5IiwicmVQbG90IiwiZGF0YXNldCIsInByaXZhdGUiLCJ3cyIsIlNlc3Npb25Db250ZXh0IiwiZW5kU3VjY2VzcyIsIlJlc3BvbnNlIiwiZW5kRmFpbCIsIlBpcGVMaW5lTGlzdFJlcXVlc3QiLCJsaXN0UGlwZXNTdWNjZXNzIiwiUGlwZWxpbmVMaXN0UmVzdWx0IiwicGlwZXMiLCJsaXN0UGlwZXNGYWlsIiwicXVlcnlTZWxlY3RvciIsImlubmVyVGV4dCIsIm15ZGF0YSIsIm15bWVhbiIsIlBpcGVsaW5lRXhlY3V0ZVJlcXVlc3QiLCJleGVjdXRlUGlwZVN1Y2Nlc3MiLCJleGVjdXRlUGlwZUZhaWwiLCJ0eXBlIiwidXBkYXRlcyIsImxvb2t1cCIsIlJlcGxhY2VQcm9ibGVtU2NoZW1hRmllbGQiLCJVcGRhdGVQcm9ibGVtU2NoZW1hUmVxdWVzdCIsInVzU3VjY2VzcyIsInVzRmFpbCIsImNvb3JkIiwibWlueCIsIm1heHgiLCJtaW55IiwibWF4eSIsInVwcGVyc2l6ZSIsIm5nMSIsIm5nMiIsIm1heG5nIiwic2V0Iiwic2V0V2lkdGhzIiwiYnRucyIsIm15d2lkdGgiLCJleHBhbmR3aWR0aCIsInNocmlua3dpZHRoIiwibXlsaXMiLCJhZGRFdmVudExpc3RlbmVyIiwibXlidG5zIiwieF9BeGlzIiwieV9BeGlzIiwieF9BeGlzX25hbWUiLCJ5X0F4aXNfbmFtZSIsImRhdGFfcGxvdCIsIm5hbkNvdW50IiwibmV3TnVtYmVyMSIsIm5ld051bWJlcjIiLCJ4YXhpcyIsInlheGlzIiwic2NvcmUiLCJtYXJnaW4iLCJib3R0b20iLCJwYWRkaW5nIiwibWluX3giLCJtYXhfeCIsImF2Z194IiwibWluX3kiLCJtYXhfeSIsImF2Z195IiwieFNjYWxlIiwibGluZWFyIiwiZG9tYWluIiwicmFuZ2UiLCJ5U2NhbGUiLCJ4QXhpcyIsImF4aXMiLCJvcmllbnQiLCJ0aWNrU2l6ZSIsInlBeGlzIiwidGlja3MiLCJ6b29tIiwiYmVoYXZpb3IiLCJzY2FsZUV4dGVudCIsInpvb21lZCIsImNoYXJ0X3NjYXR0ZXIiLCJtYWluMSIsImdYIiwiZ1kiLCJjbGlwIiwicGFuWCIsInRyYW5zbGF0ZSIsInBhblkiLCJtYXhYIiwibWF4WSIsInRhYnVsYXRlIiwiY29sdW1ucyIsImNvbHVtbiIsInJvd3MiLCJjZWxscyIsInJvdyIsInZhbHVlIiwib3V0IiwiZmVhdHVyZUlkIiwiZGF0YVVyaSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztRQTRMZ0JBLEksR0FBQUEsSTtRQWloREFDLGUsR0FBQUEsZTtRQWlCQUMsVyxHQUFBQSxXO1FBVUFDLGUsR0FBQUEsZTtRQXlEQUMsUSxHQUFBQSxR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RUFBUDtBQUNDLGFBRmIsQ0FBUDtBQUdDLFNBTEssRUFNWHBrQixLQU5XLEdBT1hDLE1BUFcsQ0FPSixJQVBJLEVBUVhDLElBUlcsQ0FRTixVQUFVQyxDQUFWLEVBQWE7QUFBRSxtQkFBT0EsRUFBRXFrQixLQUFUO0FBQWlCLFNBUjFCLENBQVo7O0FBVUEsZUFBTzFPLEtBQVA7QUFDSDs7QUFFRCxRQUFJeUosU0FBUyxFQUFiO0FBQ0EsU0FBSSxJQUFJemMsSUFBSSxDQUFaLEVBQWVBLElBQUV1USxTQUFTclYsTUFBMUIsRUFBa0M4RSxHQUFsQyxFQUF1QztBQUNuQ3ljLGVBQU90YixJQUFQLENBQVksRUFBQyxhQUFZb1AsU0FBU3ZRLENBQVQsQ0FBYixFQUF5QixRQUFPLENBQWhDLEVBQW1DLE1BQUssQ0FBeEMsRUFBWjtBQUNIOztBQUVEO0FBQ0FvaEIsYUFBUzNFLE1BQVQsRUFBaUIsQ0FBQyxXQUFELEVBQWMsTUFBZCxFQUFzQixJQUF0QixDQUFqQixFQXZDZ0MsQ0F1Q2U7QUFDbEQ7O0FBRUQ7QUFDQTtBQUNBLFNBQVNyTSxVQUFULENBQXFCL1EsSUFBckIsRUFBMkJpUixHQUEzQixFQUFnQztBQUM1QixRQUFJcVIsTUFBTSxFQUFWO0FBQ0EsU0FBSSxJQUFJM2hCLElBQUksQ0FBWixFQUFlQSxJQUFJWCxLQUFLbkUsTUFBeEIsRUFBZ0M4RSxHQUFoQyxFQUFxQztBQUNqQzJoQixZQUFJeGdCLElBQUosQ0FBUyxFQUFDeWdCLFdBQVV2aUIsS0FBS1csQ0FBTCxDQUFYLEVBQW1CNmhCLFNBQVF2UixHQUEzQixFQUFUO0FBQ0g7QUFDRCxXQUFPcVIsR0FBUDtBQUNIOztBQUVEO0FBQ0EsU0FBUzdQLFVBQVQsQ0FBcUIzTyxPQUFyQixFQUE4QjtBQUMxQixXQUFPLEVBQUMsY0FBYUEsT0FBZCxFQUFQO0FBQ0giLCJmaWxlIjoiMS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuXG5pbXBvcnQge2JhcnMsIGJhcnNOb2RlLCBiYXJzU3Vic2V0LCBkZW5zaXR5LCBkZW5zaXR5Tm9kZSwgc2VsVmFyQ29sb3J9IGZyb20gJy4vcGxvdHMuanMnO1xuXG4vLyBob3N0bmFtZSBkZWZhdWx0IC0gdGhlIGFwcCB3aWxsIHVzZSBpdCB0byBvYnRhaW4gdGhlIHZhcmlhYmxlIG1ldGFkYXRhXG4vLyAoZGRpKSBhbmQgcHJlLXByb2Nlc3NlZCBkYXRhIGluZm8gaWYgdGhlIGZpbGUgaWQgaXMgc3VwcGxpZWQgYXMgYW5cbi8vIGFyZ3VtZW50IChmb3IgZXguLCBndWkuaHRtbD9kZklkPTE3KSwgYnV0IGhvc3RuYW1lIGlzbid0LlxuLy8gRWRpdCBpdCB0byBzdWl0IHlvdXIgaW5zdGFsbGF0aW9uLlxuLy8gKE5PVEUgdGhhdCBpZiB0aGUgZmlsZSBpZCBpc24ndCBzdXBwbGllZCwgdGhlIGFwcCB3aWxsIGRlZmF1bHQgdG8gdGhlXG4vLyBsb2NhbCBmaWxlcyBzcGVjaWZpZWQgYmVsb3chKVxuLy8gTkVXOiBpdCBpcyBhbHNvIHBvc3NpYmxlIG5vdyB0byBzdXBwbHkgY29tcGxldGUgdXJscyBmb3IgdGhlIGRkaSBhbmRcbi8vIHRoZSB0YWItZGVsaW1pdGVkIGRhdGEgZmlsZTsgdGhlIHBhcmFtZXRlcnMgYXJlIGRkaXVybCBhbmQgZGF0YXVybC5cbi8vIFRoZXNlIG5ldyBwYXJhbWV0ZXJzIGFyZSBvcHRpb25hbC4gSWYgdGhleSBhcmUgbm90IHN1cHBsaWVkLCB0aGUgYXBwXG4vLyB3aWxsIGdvIHRoZSBvbGQgcm91dGUgLSB3aWxsIHRyeSB0byBjb29rIHN0YW5kYXJkIGRhdGF2ZXJzZSB1cmxzXG4vLyBmb3IgYm90aCB0aGUgZGF0YSBhbmQgbWV0YWRhdGEsIGlmIHRoZSBmaWxlIGlkIGlzIHN1cHBsaWVkOyBvciB0aGVcbi8vIGxvY2FsIGZpbGVzIGlmIG5vdGhpbmcgaXMgc3VwcGxpZWQuXG5cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBOT1RFOiBnbG9iYWwgdmFyaWFibGVzIGFyZSBub3cgc2V0IGluIHRoZSBpbmRleC5odG1sIGZpbGUuXG4vLyAgICBEZXZlbG9wZXJzLCBzZWUgL3RlbXBsYXRlL2luZGV4Lmh0bWxcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyBmb3IgZGVidWdnaW5nIC0gaWYgaW4gcHJvZHVjdGlvbiwgcHJpbnRzIGFyZ3MgYW5kIHJldHVybnMgdGhlbVxuZXhwb3J0IGxldCBjZGIgPSBfID0+IHByb2R1Y3Rpb24gfHwgY29uc29sZS5sb2cuYXBwbHkodGhpcywgYXJndW1lbnRzKSAmJiBhcmd1bWVudHM7XG5cbmxldCBrID0gNDsgLy8gc3RyZW5ndGggcGFyYW1ldGVyIGZvciBncm91cCBhdHRyYWN0aW9uL3JlcHVsc2lvblxuXG4vLyBpbml0aWFsIGNvbG9yIHNjYWxlIHVzZWQgdG8gZXN0YWJsaXNoIHRoZSBpbml0aWFsIGNvbG9ycyBvZiBub2Rlc1xuLy8gYWxsTm9kZXMucHVzaCgpIGJlbG93IGVzdGFibGlzaGVzIGEgZmllbGQgZm9yIHRoZSBtYXN0ZXIgbm9kZSBhcnJheSBhbGxOb2RlcyBjYWxsZWQgXCJub2RlQ29sXCIgYW5kIGFzc2lnbnMgYSBjb2xvciBmcm9tIHRoaXMgc2NhbGUgdG8gdGhhdCBmaWVsZFxuLy8gZXZlcnl0aGluZyB0aGVyZSBhZnRlciBzaG91bGQgcmVmZXIgdG8gdGhlIG5vZGVDb2wgYW5kIG5vdCB0aGUgY29sb3Igc2NhbGUsIHRoaXMgZW5hYmxlcyB1cyB0byB1cGRhdGUgY29sb3JzIGFuZCBwYXNzIHRoZSB2YXJpYWJsZSB0eXBlIHRvIFIgYmFzZWQgb24gaXRzIGNvbG9yaW5nXG5sZXQgY29sb3JzID0gZDMuc2NhbGUuY2F0ZWdvcnkyMCgpO1xuZXhwb3J0IGxldCBjc0NvbG9yID0gJyM0MTk2NDEnO1xuZXhwb3J0IGxldCBkdkNvbG9yID0gJyMyOGE0YzknO1xuZXhwb3J0IGxldCBncjFDb2xvciA9ICcjMTRiZGNjJzsgIC8vIGluaXRpYWxseSB3YXMgIzI0YTRjOScsIGJ1dCB0aGF0IGlzIGR2Q29sb3IsIGFuZCB3ZSB0cmFjayBzb21lIHByb3BlcnRpZXMgYnkgY29sb3IgYXNzdW1pbmcgdGhlbSB1bmlxdWVcbmxldCBncjFPcGFjaXR5ID0gWzAsMV07XG5leHBvcnQgbGV0IGdyMkNvbG9yID0gJyNmZmNjY2MnO1xubGV0IGdyMk9wYWNpdHkgPSBbMCwxXTtcblxubGV0IGdyYXlDb2xvciA9ICcjYzBjMGMwJztcbmV4cG9ydCBsZXQgbm9tQ29sb3IgPSAnI2ZmNjYwMCc7XG5leHBvcnQgbGV0IHZhckNvbG9yID0gJyNmMGY4ZmYnOyAvLyBkMy5yZ2IoXCJhbGljZWJsdWVcIik7XG5sZXQgdGFnZ2VkQ29sb3IgPSAnI2Y1ZjVmNSc7IC8vIGQzLnJnYihcIndoaXRlc21va2VcIik7XG5leHBvcnQgbGV0IHRpbWVDb2xvciA9ICcjMmQ2Y2EyJztcblxuZXhwb3J0IGxldCBsZWZ0dGFiID0gJ3RhYjEnOyAvLyBjdXJyZW50IHRhYiBpbiBsZWZ0IHBhbmVsXG5leHBvcnQgbGV0IHN1YnNldCA9IGZhbHNlO1xuZXhwb3J0IGxldCBzdW1tYXJ5SG9sZCA9IGZhbHNlO1xuZXhwb3J0IGxldCByaWdodHRhYiA9ICdidG5Nb2RlbHMnOyAvLyBjdXJyZW50IHRhYiBpbiByaWdodCBwYW5lbFxuXG4vLyB0cmFuc2Zvcm1hdGlvbiB0b29sYmFyIG9wdGlvbnNcbmxldCB0LCB0eXBlVHJhbnNmb3JtO1xubGV0IHRyYW5zZm9ybUxpc3QgPSAnbG9nKGQpIGV4cChkKSBkXjIgc3FydChkKSBpbnRlcmFjdChkLGUpJy5zcGxpdCgnICcpO1xubGV0IHRyYW5zZm9ybVZhciA9ICcnO1xuXG4vLyB2YXIgbGlzdCBmb3IgZWFjaCBzcGFjZSBjb250YWluIHZhcmlhYmxlcyBpbiBvcmlnaW5hbCBkYXRhXG4vLyBwbHVzIHRyYW5zIGluIHRoYXQgc3BhY2VcbmxldCB0cmFucyA9IFtdO1xubGV0IHByZXByb2Nlc3MgPSB7fTsgLy8gaG9sZCBwcmUtcHJvY2Vzc2VkIGRhdGFcbmxldCBzcGFjZXMgPSBbXTtcblxuLy8gbGF5b3V0IGZ1bmN0aW9uIGNvbnN0YW50c1xuY29uc3QgbGF5b3V0QWRkID0gXCJhZGRcIjtcbmNvbnN0IGxheW91dE1vdmUgPSBcIm1vdmVcIjtcblxuLy8gUmFkaXVzIG9mIGNpcmNsZVxubGV0IGFsbFIgPSA0MDtcbmxldCBpbmQxID0gWyhhbGxSKzMwKSAqIE1hdGguY29zKDEuMyksIC0xKihhbGxSKzMwKSAqIE1hdGguc2luKDEuMyksNV0gLy8gY3gsIGN5LCByICB2YWx1ZXMgZm9yIGluZGljYXRvciBsaWdodHNcbmxldCBpbmQyID0gWyhhbGxSKzMwKSAqIE1hdGguY29zKDEuMSksIC0xKihhbGxSKzMwKSAqIE1hdGguc2luKDEuMSksNV0gLy8gY3gsIGN5LCByICB2YWx1ZXMgZm9yIGluZGljYXRvciBsaWdodHNcblxuXG4vLyBzcGFjZSBpbmRleFxubGV0IG15c3BhY2UgPSAwO1xuXG5sZXQgZm9yY2V0b2dnbGUgPSBbXCJ0cnVlXCJdO1xubGV0IGxvY2t0b2dnbGUgPSB0cnVlO1xubGV0IHByaXYgPSB0cnVlO1xuXG5leHBvcnQgbGV0IGxvZ0FycmF5ID0gW107XG5leHBvcnQgbGV0IHpwYXJhbXMgPSB7XG4gICAgemRhdGE6IFtdLFxuICAgIHplZGdlczogW10sXG4gICAgenRpbWU6IFtdLFxuICAgIHpub206IFtdLFxuICAgIHpjcm9zczogW10sXG4gICAgem1vZGVsOiBcIlwiLFxuICAgIHp2YXJzOiBbXSxcbiAgICB6ZHY6IFtdLFxuICAgIHpncm91cDE6IFtdLFxuICAgIHpncm91cDI6IFtdLCAgICAgICAvLyBoYXJkIGNvZGluZyB0byB0d28gZ3JvdXBzIGZvciBwcmVzZW50IGV4cGVyaW1lbnRzLCBidXQgd2lsbCBldmVudHVhbGx5IG1ha2Ugemdyb3VwIGFycmF5IG9mIGFycmF5cywgd2l0aCB6Z3JvdXAubGVuZ2h0IHRoZSBudW1iZXIgb2YgZ3JvdXBzXG4gICAgemRhdGF1cmw6IFwiXCIsXG4gICAgemQzbWRhdGE6IFwiXCIsIC8vdGhlc2UgdGFrZSB0aGUgcGxhY2Ugb2YgemRhdGF1cmwgZm9yIGQzbSwgYmVjYXVzZSBkYXRhIGlzIGluIHR3byBwbGFjZWVzLiBldmVudHVhbGx5IHdpbGwgZ2VuZXJhbGl6ZVxuICAgIHpkM210YXJnZXQ6IFwiXCIsXG4gICAgenN1YnNldDogW10sXG4gICAgenNldHg6IFtdLFxuICAgIHptb2RlbGNvdW50OiAwLFxuICAgIHpwbG90OiBbXSxcbiAgICB6c2Vzc2lvbmlkOiBcIlwiLFxuICAgIHpkYXRhY2l0ZTogXCJcIlxufTtcblxubGV0IG1vZGVsQ291bnQgPSAwO1xuZXhwb3J0IGxldCB2YWx1ZUtleSA9IFtdO1xuZXhwb3J0IGxldCBhbGxOb2RlcyA9IFtdO1xubGV0IGFsbFJlc3VsdHMgPSBbXTtcbmV4cG9ydCBsZXQgbm9kZXMgPSBbXTtcbmxldCBsaW5rcyA9IFtdO1xubGV0IG1vZHMgPSB7fTtcbmxldCBlc3RpbWF0ZWQgPSBmYWxzZTtcbmxldCByaWdodENsaWNrTGFzdCA9IGZhbHNlO1xubGV0IHNlbEludGVyYWN0ID0gZmFsc2U7XG5sZXQgY2FsbEhpc3RvcnkgPSBbXTsgLy8gdHJhbnNmb3JtIGFuZCBzdWJzZXQgY2FsbHNcbmxldCBteXRhcmdldCA9IFwiXCI7XG5cblxuLy9ldmVudHVhbGx5IHJlYWQgdGhpcyBmcm9tIHRoZSBzY2hlbWEgd2l0aCByZWFsIGRlc2NyaXB0aW9uc1xuLy8gbWV0cmljcywgdGFza3MsIGFuZCBzdWJ0YXNrcyBhcyBzcGVjaWZpZWQgaW4gRDNNIHNjaGVtYXNcbi8vIE1FQU4gU1FVQVJFRCBFUlJPUiBJUyBTRVQgVE8gU0FNRSBBUyBSTVNFLiBNU0UgaXMgaW4gc2NoZW1hIGJ1dCBub3QgcHJvdG9cbmxldCBkM21NZXRyaWNzID0geyBtZXRyaWNVbmRlZmluZWQ6W1wiZGVzY3JpcHRpb25cIiwgXCJNRVRSSUNfVU5ERUZJTkVEXCIgLCAwXSxcbiAgICBhY2N1cmFjeSA6IFtcImRlc2NyaXB0aW9uXCIsIFwiQUNDVVJBQ1lcIiAsIDFdLFxuZjE6W1wiZGVzY3JpcHRpb25cIiwgXCJGMVwiICwgMl0sXG5mMU1pY3JvOltcImRlc2NyaXB0aW9uXCIsIFwiRjFfTUlDUk9cIiAsIDNdLFxuZjFNYWNybzpbXCJkZXNjcmlwdGlvblwiLCBcIkYxX01BQ1JPXCIgLCA0XSxcbnJvY0F1YzpbXCJkZXNjcmlwdGlvblwiLCBcIlJPQ19BVUNcIiAsIDVdLFxucm9jQXVjTWljcm86W1wiZGVzY3JpcHRpb25cIiwgXCJST0NfQVVDX01JQ1JPXCIgLCA2XSxcbnJvY0F1Y01hY3JvOltcImRlc2NyaXB0aW9uXCIsIFwiUk9DX0FVQ19NQUNST1wiICwgN10sXG5tZWFuU3F1YXJlZEVycm9yOltcImRlc2NyaXB0aW9uXCIsIFwiTUVBTl9TUVVBUkVEX0VSUk9SXCIsIDhdLFxucm9vdE1lYW5TcXVhcmVkRXJyb3I6W1wiZGVzY3JpcHRpb25cIiwgXCJST09UX01FQU5fU1FVQVJFRF9FUlJPUlwiICwgOF0sXG5yb290TWVhblNxdWFyZWRFcnJvckF2ZzpbXCJkZXNjcmlwdGlvblwiLCBcIlJPT1RfTUVBTl9TUVVBUkVEX0VSUk9SX0FWR1wiICwgOV0sXG5tZWFuQWJzb2x1dGVFcnJvcjpbXCJkZXNjcmlwdGlvblwiLCBcIk1FQU5fQUJTT0xVVEVfRVJST1JcIiAsIDEwXSxcbnJTcXVhcmVkOltcImRlc2NyaXB0aW9uXCIsIFwiUl9TUVVBUkVEXCIgLCAxMV0sXG5ub3JtYWxpemVkTXV0dWFsSW5mb3JtYXRpb246W1wiZGVzY3JpcHRpb25cIiwgXCJOT1JNQUxJWkVEX01VVFVBTF9JTkZPUk1BVElPTlwiICwgMTJdLFxuICAgIGphY2NhcmRTaW1pbGFyaXR5U2NvcmU6W1wiZGVzY3JpcHRpb25cIiwgXCJKQUNDQVJEX1NJTUlMQVJJVFlfU0NPUkVcIiAsIDEzXSxcbiAgICBleGVjdXRpb25UaW1lOltcImRlc2NyaXB0aW9uXCIsIFwiRVhFQ1VUSU9OX1RJTUVcIiAsIDE0XX07XG5cbmxldCBkM21UYXNrVHlwZSA9IHt0YXNrVHlwZVVuZGVmaW5lZDpbXCJkZXNjcmlwdGlvblwiLFwiVEFTS19UWVBFX1VOREVGSU5FRFwiLCAwXSxjbGFzc2lmaWNhdGlvbjpbXCJkZXNjcmlwdGlvblwiLCBcIkNMQVNTSUZJQ0FUSU9OXCIgLCAxXSxcbnJlZ3Jlc3Npb246W1wiZGVzY3JpcHRpb25cIiwgXCJSRUdSRVNTSU9OXCIgLCAyXSxcbnNpbWlsYXJpdHlNYXRjaGluZzpbXCJkZXNjcmlwdGlvblwiLCBcIlNJTUlMQVJJVFlfTUFUQ0hJTkdcIiAsIDNdLFxubGlua1ByZWRpY3Rpb246W1wiZGVzY3JpcHRpb25cIiwgXCJMSU5LX1BSRURJQ1RJT05cIiAsIDRdLFxudmVydGV4Tm9taW5hdGlvbjpbXCJkZXNjcmlwdGlvblwiLCBcIlZFUlRFWF9OT01JTkFUSU9OXCIgLCA1XSxcbmNvbW11bml0eURldGVjdGlvbjpbXCJkZXNjcmlwdGlvblwiLCBcIkNPTU1VTklUWV9ERVRFQ1RJT05cIiAsIDZdLFxuZ3JhcGhNYXRjaGluZzpbXCJkZXNjcmlwdGlvblwiLCBcIkdSQVBIX01BVENISU5HXCIgLCA3XSxcbnRpbWVzZXJpZXNGb3JlY2FzdGluZzpbXCJkZXNjcmlwdGlvblwiLCBcIlRJTUVTRVJJRVNfRk9SRUNBU1RJTkdcIiAsIDhdLFxuICAgIGNvbGxhYm9yYXRpdmVGaWx0ZXJpbmc6W1wiZGVzY3JpcHRpb25cIiwgXCJDT0xMQUJPUkFUSVZFX0ZJTFRFUklOR1wiICwgOV19O1xuXG5sZXQgZDNtVGFza1N1YnR5cGUgPSB7dGFza1N1YnR5cGVVbmRlZmluZWQ6W1wiZGVzY3JpcHRpb25cIiwgXCJUQVNLX1NVQlRZUEVfVU5ERUZJTkVEXCIsIDBdLFxuc3VidHlwZU5vbmU6W1wiZGVzY3JpcHRpb25cIixcIk5PTkVcIiwxXSxcbiAgICBiaW5hcnk6W1wiZGVzY3JpcHRpb25cIiwgXCJCSU5BUllcIiAsIDJdLFxubXVsdGlDbGFzczpbXCJkZXNjcmlwdGlvblwiLCBcIk1VTFRJQ0xBU1NcIiAsIDNdLFxubXVsdGlMYWJlbDpbXCJkZXNjcmlwdGlvblwiLCBcIk1VTFRJTEFCRUxcIiAsIDRdLFxudW5pVmFyaWF0ZTpbXCJkZXNjcmlwdGlvblwiLCBcIlVOSVZBUklBVEVcIiAsIDVdLFxubXVsdGlWYXJpYXRlOltcImRlc2NyaXB0aW9uXCIsIFwiTVVMVElWQVJJQVRFXCIgLCA2XSxcbm92ZXJsYXBwaW5nOltcImRlc2NyaXB0aW9uXCIsIFwiT1ZFUkxBUFBJTkdcIiAsIDddLFxuICAgIG5vbk92ZXJsYXBwaW5nOltcImRlc2NyaXB0aW9uXCIsIFwiTk9OT1ZFUkxBUFBJTkdcIiAsIDhdfTtcblxubGV0IGQzbU91dHB1dFR5cGUgPSB7b3V0cHV0VW5kZWZpbmVkOltcImRlc2NyaXB0aW9uXCIsXCJPVVRQVVRfVFlQRV9VTkRFRklORUQgXCIsIDBdLFxuY2xhc3NMYWJlbDpbXCJkZXNjcmlwdGlvblwiLFwiQ0xBU1NfTEFCRUxcIiwgMV0sXG5wcm9iYWJpbGl0eTpbXCJkZXNjcmlwdGlvblwiLFwiUFJPQkFCSUxJVFlcIiwgMl0sXG5yZWFsOltcImRlc2NyaXB0aW9uXCIsXCJSRUFMXCIsIDNdLFxubm9kZUlEOltcImRlc2NyaXB0aW9uXCIsXCJOT0RFX0lEXCIsIDRdLFxudmVjdG9yQ2xhc3NMYWJlbDpbXCJkZXNjcmlwdGlvblwiLFwiVkVDVE9SX0NMQVNTX0xBQkVMXCIsIDVdLFxuICAgIHZlY3RvclN0b2NoYXN0aWM6W1wiZGVzY3JpcHRpb25cIixcIlZFQ1RPUl9TVE9DSEFTVElDXCIsIDZdLFxuICAgIHZlY3RvclJlYWw6W1wiZGVzY3JpcHRpb25cIixcIlZFQ1RPUl9SRUFMXCIsIDddLFxuICAgIGZpbGU6W1wiZGVzY3JpcHRpb25cIixcIkZJTEVcIiw4XX07XG5cbmxldCBkM21Qcm9ibGVtRGVzY3JpcHRpb24gPSB7XG50YXNrVHlwZTogWzIsXCJERUZBVUxUXCJdLFxudGFza1N1YnR5cGU6IFsxLFwiREVGQUZVTFRcIl0sXG5vdXRwdXRUeXBlOiBbMyxcIkRFRkFVTFRcIl0sXG4gICAgbWV0cmljOiBbNCxcIkRFRkFVTFRcIl0sXG4gICAgdGFza0Rlc2NyaXB0aW9uOiBcIlwifTtcblxuXG5sZXQgc3ZnLCB3aWR0aCwgaGVpZ2h0LCBkaXYsIGVzdGltYXRlTGFkZGEsIHNlbGVjdExhZGRhO1xubGV0IGFyYzEsIGFyYzMsIGFyYzQsIGFyY0luZDEsIGFyY0luZDI7XG5cbmxldCBhcmNJbmQxTGltaXRzID0gWzAsMC4zXTtcbmxldCBhcmNJbmQyTGltaXRzID0gWzAuMzUsMC42NV07XG5cbmxldCBieUlkID0gaWQgPT4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuXG4vLyBwYWdlIHJlbG9hZCBsaW5rZWQgdG8gYnRuUmVzZXRcbmV4cG9ydCBjb25zdCByZXNldCA9IGZ1bmN0aW9uIHJlbG9hZFBhZ2UoKSB7XG4gIGxvY2F0aW9uLnJlbG9hZCgpO1xufVxuXG5cbmxldCBkYXRhdXJsID0gXCJcIjtcbmV4cG9ydCBmdW5jdGlvbiBtYWluKGZpbGVpZCwgaG9zdG5hbWUsIGRkaXVybCwgZGF0YXVybCwgYXBpa2V5KSB7XG4gICAgZGF0YXVybCA9IGRhdGF1cmw7XG4gICAgaWYgKHByb2R1Y3Rpb24gJiYgZmlsZWlkID09IFwiXCIpIHtcbiAgICAgICAgYWxlcnQoXCJFcnJvcjogTm8gZmlsZWlkIGhhcyBiZWVuIHByb3ZpZGVkLlwiKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3I6IE5vIGZpbGVpZCBoYXMgYmVlbiBwcm92aWRlZC5cIik7XG4gICAgfVxuXG4gICAgbGV0IGRhdGF2ZXJzZXVybCA9IGhvc3RuYW1lID8gXCJodHRwczovL1wiICsgaG9zdG5hbWUgOlxuICAgICAgICBwcm9kdWN0aW9uID8gREFUQVZFUlNFX1VSTCA6XG4gICAgICAgIFwiaHR0cDovL2xvY2FsaG9zdDo4MDgwXCI7XG5cbiAgICBpZiAoZmlsZWlkICYmICFkYXRhdXJsKSB7XG4gICAgICAgIC8vIGZpbGUgaWQgc3VwcGxpZWQ7IGFzc3VtZSB3ZSBhcmUgZGVhbGluZyB3aXRoIGRhdGF2ZXJzZSBhbmQgY29vayBhIHN0YW5kYXJkIGRhdGF2ZXJzZSBkYXRhIGFjY2VzcyB1cmxcbiAgICAgICAgLy8gd2l0aCB0aGUgZmlsZWlkIHN1cHBsaWVkIGFuZCB0aGUgaG9zdG5hbWUgd2UgaGF2ZSBzdXBwbGllZCBvciBjb25maWd1cmVkXG4gICAgICAgIGRhdGF1cmwgPSBkYXRhdmVyc2V1cmwgKyBcIi9hcGkvYWNjZXNzL2RhdGFmaWxlL1wiICsgZmlsZWlkO1xuICAgICAgICAvLyBycDsgdGVtcG9yYXJpbHkgcmVtb3ZlIHRoaXNcbiAgICAgICAgZGF0YXVybCA9IGRhdGF1cmwgKyBcIj9rZXk9XCIgKyBhcGlrZXk7XG4gICAgfVxuICAgIGNkYignLS1kYXRhdXJsOiAnICsgZGF0YXVybCk7XG4gICAgY2RiKCctLWRhdGF2ZXJzZXVybDogJyArIGRhdGF2ZXJzZXVybCk7XG4gICAgc3ZnID0gZDMuc2VsZWN0KFwiI3doaXRlc3BhY2VcIik7XG5cbiAgICBsZXQgdGVtcFdpZHRoID0gZDMuc2VsZWN0KFwiI21haW4ubGVmdFwiKS5zdHlsZShcIndpZHRoXCIpO1xuICAgIHdpZHRoID0gdGVtcFdpZHRoLnN1YnN0cmluZygwLCB0ZW1wV2lkdGgubGVuZ3RoIC0gMik7XG4gICAgaGVpZ2h0ID0gJCh3aW5kb3cpLmhlaWdodCgpIC0gMTIwOyAvLyBIYXJkIGNvZGluZyBmb3IgaGVhZGVyIGFuZCBmb290ZXIgYW5kIGJvdHRvbSBtYXJnaW4uXG5cbiAgICBlc3RpbWF0ZUxhZGRhID0gTGFkZGEuY3JlYXRlKGJ5SWQoXCJidG5Fc3RpbWF0ZVwiKSk7XG4gICAgc2VsZWN0TGFkZGEgPSBMYWRkYS5jcmVhdGUoYnlJZChcImJ0blNlbGVjdFwiKSk7XG5cbiAgICBsZXQgY29sb3JUaW1lID0gZmFsc2U7XG4gICAgbGV0IGNvbG9yQ1MgPSBmYWxzZTtcblxuICAgIGxldCBkZXBWYXIgPSBmYWxzZTtcbiAgICBsZXQgc3Vic2V0ZGl2ID0gZmFsc2U7XG4gICAgbGV0IHNldHhkaXYgPSBmYWxzZTtcblxuICAgIC8vIHdpZHRoIGFuZCBoZWlnaHQgZm9yIGhpc3RncmFtc1xuICAgIGxldCBiYXJ3aWR0aCA9IDEuMyAqIGFsbFI7XG4gICAgbGV0IGJhcmhlaWdodCA9IDAuNSAqIGFsbFI7XG4gICAgbGV0IGJhclBhZGRpbmcgPSAwLjM1O1xuICAgIGxldCBiYXJudW1iZXIgPSA3O1xuXG4gICAgLy8gYXJjcyBmb3IgZGVub3RpbmcgcGViYmxlIGNoYXJhY3RlcmlzdGljc1xuICAgIGxldCBhcmMgPSAoc3RhcnQsIGVuZCkgPT4gZDMuc3ZnLmFyYygpXG4gICAgICAgIC5pbm5lclJhZGl1cyhhbGxSICsgNSlcbiAgICAgICAgLm91dGVyUmFkaXVzKGFsbFIgKyAyMClcbiAgICAgICAgLnN0YXJ0QW5nbGUoc3RhcnQpXG4gICAgICAgIC5lbmRBbmdsZShlbmQpO1xuICAgIGxldCBhcmNJbmQgPSAoYXJjbGltaXRzKSA9PiBkMy5zdmcuYXJjKClcbiAgICAgICAgLmlubmVyUmFkaXVzKGFsbFIgKyAyMilcbiAgICAgICAgLm91dGVyUmFkaXVzKGFsbFIgKyAzNylcbiAgICAgICAgLnN0YXJ0QW5nbGUoYXJjbGltaXRzWzBdKVxuICAgICAgICAuZW5kQW5nbGUoYXJjbGltaXRzWzFdKTtcblxuICAgIGxldCBbYXJjMCwgYXJjMl0gPSBbYXJjKDAsIDMuMiksIGFyYygxLjEsIDIuMildO1xuICAgIC8vYXJjMSA9IGFyYygxLjMsIDIuMyk7XG4gICAgYXJjMSA9IGFyYygwLDEpO1xuICAgIGFyYzMgPSBhcmMoMi4zLCAzLjMpO1xuICAgIGFyYzQgPSBhcmMoNC4zLCA1LjMpO1xuXG4gICAgYXJjSW5kMSA9IGFyY0luZChhcmNJbmQxTGltaXRzKTtcbiAgICBhcmNJbmQyID0gYXJjSW5kKGFyY0luZDJMaW1pdHMpO1xuXG4gICAgLy8gaW5kaWNhdG9ycyBmb3Igc2hvd2luZyBtZW1iZXJzaGlwIGFib3ZlIGFyY3NcbiAgICAvLyBsZXQgaW5kaWNhdG9yID0gKGRlZ3JlZSkgPT4gZDMuc3ZnLmNpcmNsZSgpXG4gICAgLy8gICAgIC5jeCggYWxsUiApLy8oYWxsUiszNSkgKiBNYXRoLnNpbihkZWdyZWUpKVxuICAgIC8vICAgICAuY3koIGFsbFIgKS8vKGFsbFIrMzUpICogTWF0aC5jb3MoZGVncmVlKSlcbiAgICAvLyAgICAgLnIoMyk7XG4gICAgLy8gaW5kMSA9IGluZGljYXRvcigxKTtcbiAgICAvLyBpbmQyID0gaW5kaWNhdG9yKDEuMik7XG5cbiAgICAvLyBmcm9tIC5jc3ZcbiAgICBsZXQgZGF0YXNldDIgPSBbXTtcbiAgICBsZXQgbGFibEFycmF5ID0gW107XG4gICAgbGV0IGhvbGQgPSBbXTtcbiAgICBsZXQgc3Vic2V0Tm9kZXMgPSBbXTtcblxuICAgIC8vIGNvbGxhcHNhYmxlIHVzZXIgbG9nXG4gICAgJCgnI2NvbGxhcHNlTG9nJykub24oJ3Nob3duLmJzLmNvbGxhcHNlJywgKCkgPT4gZDMuc2VsZWN0KFwiI2NvbGxhcHNlTG9nIGRpdi5wYW5lbC1ib2R5XCIpLnNlbGVjdEFsbChcInBcIilcbiAgICAgICAgLmRhdGEobG9nQXJyYXkpXG4gICAgICAgIC5lbnRlcigpXG4gICAgICAgIC5hcHBlbmQoXCJwXCIpXG4gICAgICAgIC50ZXh0KGQgPT4gZCkpO1xuICAgICQoJyNjb2xsYXBzZUxvZycpLm9uKCdoaWRkZW4uYnMuY29sbGFwc2UnLCAoKSA9PiBkMy5zZWxlY3QoXCIjY29sbGFwc2VMb2cgZGl2LnBhbmVsLWJvZHlcIikuc2VsZWN0QWxsKFwicFwiKVxuICAgICAgICAucmVtb3ZlKCkpO1xuXG4gICAgLy9zZXQgc3RhcnQgZnJvbSB1c2VyIGlucHV0LCB0aGVuIGFzc3VtZSBsb2NhdGlvbnMgYXJlIGNvbnNpc3RlbnQgYmFzZWQgb24gZDNtIGRpcmVjdG9yeSBzdHJ1Y3R1cmUgKGFsdGVybmF0aXZlbHkgY2FuIG1ha2UgZWFjaCBvZiB0aGVzZSBsb2NhdGlvbnMgYmUgc2V0IGJ5IHVzZXIpXG4gICAgbGV0IGNvbmZpZ3VyYXRpb25zID0ge307XG4gICAgbGV0IGQzbVJvb3RQYXRoID0gXCJcIjtcbiAgICBsZXQgZDNtRGF0YU5hbWUgPSBcIlwiO1xuICAgIGxldCBkM21EYXRhID0gXCJcIjtcbiAgICBsZXQgZDNtVGFyZ2V0ID0gXCJcIjtcbiAgICBsZXQgZDNtUHJlcHJvY2VzcyA9IFwiXCI7XG4gICAgbGV0IGQzbVBTID0gXCJcIjtcbiAgICBsZXQgZDNtRFMgPSBcIlwiO1xuXG4gICAgLy8gZGVmYXVsdCB0byBDYWxpZm9ybmlhIFBVTVMgc3Vic2V0IChzaG91bGQsIGRvZXNuJ3QgYWN0dWFsbHkgZG8gdGhhdClcbiAgICBsZXQgZGF0YSA9ICdkYXRhLycgKyAoZmFsc2UgPyAnUFVNUzVzbWFsbCcgOiAnZmVhcm9uTGFpdGluJyk7XG4gICAgbGV0IG1ldGFkYXRhdXJsID0gZGRpdXJsIHx8IChmaWxlaWQgPyBgJHtkYXRhdmVyc2V1cmx9L2FwaS9tZXRhL2RhdGFmaWxlLyR7ZmlsZWlkfWAgOiBkYXRhICsgJy54bWwnKTtcbiAgICAvLyByZWFkIHByZS1wcm9jZXNzZWQgbWV0YWRhdGEgYW5kIGRhdGFcbiAgICBsZXQgcFVSTCA9IGRhdGF1cmwgPyBgJHtkYXRhdXJsfSZmb3JtYXQ9cHJlcGAgOiBkYXRhICsgJy5qc29uJztcbiAgICBjZGIoJ3BVUkw6ICcgKyBwVVJMKTtcblxuICAgIGNvbnNvbGUubG9nKFwicFVSTCBpczogXCIgKyBwVVJMKTtcblxuICAgIGlmKGQzbV9tb2RlKSB7XG4gICAgICAgIHBVUkwgPSBkM21QcmVwcm9jZXNzO1xuICAgICAgICAvLyB6cGFyYW1zLnpkYXRhdXJsID0gc3RhcnQrJy9kYXRhL3RyYWluRGF0YW1lcmdlZC50c3YnO1xuICAgICAgICB6cGFyYW1zLnpkYXRhID0gZDNtRGF0YU5hbWU7XG4gICAgfSBlbHNlIGlmKCFwcm9kdWN0aW9uKSB7XG4gICAgICAgIHpwYXJhbXMuemRhdGF1cmwgPSAnZGF0YS9mZWFyb25MYWl0aW4udHN2JztcbiAgICB9XG5cbiAgICAvLyBsb2FkcyBhbGwgZXh0ZXJuYWwgZGF0YTogbWV0YWRhdGEgKERWTidzIGRkaSksIHByZXByb2Nlc3NlZCAoZm9yIHBsb3R0aW5nIGRpc3RyaWJ1dGlvbnMpLCBhbmQgemVsaWdtb2RlbHMgKHByb2R1Y2VkIGJ5IFplbGlnKSBhbmQgaW5pdGlhdGVzIHRoZSBkYXRhIGRvd25sb2FkIHRvIHRoZSBzZXJ2ZXJcbiAgICAgUHJvbWlzZS5yZXNvbHZlKGQzbV9tb2RlICYmIG0ucmVxdWVzdCh7XG4gICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgIHVybDogXCIvY29uZmlnL2QzbS1jb25maWcvanNvbi9sYXRlc3RcIlxuICAgICB9KVxuICAgICAudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgY29uZmlndXJhdGlvbnMgPSAgSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShyZXN1bHQpKTtcbiAgICAgICAgICAgZDNtUm9vdFBhdGggPSBjb25maWd1cmF0aW9ucy50cmFpbmluZ19kYXRhX3Jvb3Q7XG4gICAgICAgICAgIGQzbVJvb3RQYXRoID0gZDNtUm9vdFBhdGgucmVwbGFjZSgvXFwvZGF0YS8sJycpO1xuICAgICAgICAgICBkM21EYXRhTmFtZSA9IGNvbmZpZ3VyYXRpb25zLm5hbWU7XG4gICAgICAgICAgIGQzbURhdGEgPSBjb25maWd1cmF0aW9ucy50cmFpbmluZ19kYXRhX3Jvb3QrXCIvdHJhaW5EYXRhLmNzdlwiO1xuICAgICAgICAgICBkM21UYXJnZXQgPSByZXN1bHQudHJhaW5pbmdfZGF0YV9yb290K1wiL3RyYWluVGFyZ2V0cy5jc3ZcIjtcbiAgICAgICAgICAgZDNtUFMgPSBjb25maWd1cmF0aW9ucy5wcm9ibGVtX3NjaGVtYTtcbiAgICAgICAgICAgZDNtRFMgPSBjb25maWd1cmF0aW9ucy5kYXRhc2V0X3NjaGVtYTtcbiAgICAgICAgICAgXG4gICAgICAgICAgIC8vIGRvaW5nIHRoaXMgZm9yIG5vdywgYXNzdW1pbmcgZXZlcnl0aGluZyBhZnRlciBUd29SYXZlbnMgaXMgcmVhZGFibGVcbiAgICAgICAgICAgZDNtUFMgPSBkM21QUy5zcGxpdChcIlR3b1JhdmVucy9cIikucG9wKCk7XG4gICAgICAgICAgIGQzbURTID0gZDNtRFMuc3BsaXQoXCJUd29SYXZlbnMvXCIpLnBvcCgpO1xuICAgICAgICAgICBkM21UYXJnZXQgPSBkM21UYXJnZXQuc3BsaXQoXCJUd29SYXZlbnMvXCIpLnBvcCgpO1xuICAgICAgICAgICBkM21EYXRhID0gZDNtRGF0YS5zcGxpdChcIlR3b1JhdmVucy9cIikucG9wKCk7XG4gICAgICAgICAgIGQzbVJvb3RQYXRoID0gZDNtUm9vdFBhdGguc3BsaXQoXCJUd29SYXZlbnMvXCIpLnBvcCgpO1xuICAgICAgICAgICBwVVJMPSdyb29rLWN1c3RvbS9yb29rLWZpbGVzLycrZDNtRGF0YU5hbWUrJy9wcmVwcm9jZXNzL3ByZXByb2Nlc3MuanNvbic7ICAgIFxuICAgICAgICAgICBkM21QcmVwcm9jZXNzPXBVUkw7XG4gICAgICAgICAgIHpwYXJhbXMuemQzbWRhdGEgPSBkM21EYXRhO1xuICAgICAgICAgICB6cGFyYW1zLnpkM210YXJnZXQgPSBkM21UYXJnZXQ7XG4gICAgIH0pKVxuICAgICAudGhlbihfID0+IG0ucmVxdWVzdChwVVJMKSlcbiAgICAgLy8gZG8gbm90aGluZyBpZiBwcmVwcm9jZXNzLmpzb24gYWxyZWFkeSBleGlzdHMsIGVsc2UgcnVuUHJlcHJvY2Vzc1xuICAgICAudGhlbihudWxsLCBfID0+IHJ1blByZXByb2Nlc3MoZDNtRGF0YSwgZDNtVGFyZ2V0LCBkM21EYXRhTmFtZSkpXG4gICAgIC50aGVuKGRhdGEgPT4gcmVhZFByZXByb2Nlc3MoZGF0YSkpXG4gICAgIC50aGVuKCgpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IGQzLnhtbChtZXRhZGF0YXVybCwgJ2FwcGxpY2F0aW9uL3htbCcsIHhtbCA9PiB7XG4gICAgICAgIGxldCB2YXJzID0gT2JqZWN0LmtleXMocHJlcHJvY2Vzcyk7IC8vIHRoaXMgZG9lc24ndCBjb21lIGZyb20geG1sLCBidXQgZnJvbSBwcmVwcm9jZXNzZWQganNvblxuICAgICAgICAgICAgLy8gdGhlIGxhYmVscywgY2l0YXRpb25zLCBhbmQgZmlsZSBuYW1lIGNvbWUgZnJvbSB0aGUgJ3htbCcgKG1ldGFkYXRhdXJsKSwgd2hpY2ggaXMgdGhlIGZpbGUgZnJvbSB0aGUgZGF0YSByZXBvXG4gICAgICAgICAgICAvLyBob3dldmVyLCBUd29SYXZlbnMgc2hvdWxkIGZ1bmN0aW9uIHVzaW5nIG9ubHkgdGhlIGRhdGEgdGhhdCBjb21lcyBmcm9tIG91ciBwcmVwcm9jZXNzIHNjcmlwdCwgd2hpY2ggaXMgdGhlICdqc29uJyAocFVSTClcbiAgICAgICAgICAgIC8vIGZvciBub3cgdGhlIG1ldGFkYXRhdXJsIGlzIHN0aWxsIEZlYXJvbiAmIExhaXRpblxuICAgICAgICAgICAgbGV0IHRlbXAgPSB4bWwuZG9jdW1lbnRFbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiZmlsZU5hbWVcIik7XG4gICAgICAgICAgICBpZighZDNtX21vZGUpXG4gICAgICAgICAgICAgICAgenBhcmFtcy56ZGF0YSA9IHRlbXBbMF0uY2hpbGROb2Rlc1swXS5ub2RlVmFsdWU7XG5cbiAgICAgICAgICAgIGxldCBjaXRlID0geG1sLmRvY3VtZW50RWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImJpYmxDaXRcIik7XG4gICAgICAgICAgICAvLyBjbGVhbiBjaXRhdGlvbiBzbyBQT1NUIGlzIHZhbGlkIGpzb25cbiAgICAgICAgICAgIHpwYXJhbXMuemRhdGFjaXRlID0gY2l0ZVswXS5jaGlsZE5vZGVzWzBdLm5vZGVWYWx1ZVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXCYvZywgXCJhbmRcIilcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFw7L2csIFwiLFwiKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXCUvZywgXCItXCIpO1xuICAgICAgICAgICAgJCgnI2NpdGUgZGl2LnBhbmVsLWJvZHknKS50ZXh0KHpwYXJhbXMuemRhdGFjaXRlKTtcblxuICAgICAgICAgICAgLy8gZGF0YXNldCBuYW1lIHRyaW1tZWQgdG8gMTIgY2hhcnNcbiAgICAgICAgICAgIGxldCBkYXRhbmFtZSA9IHpwYXJhbXMuemRhdGE7XG4gICAgICAgICAgICBpZighZDNtX21vZGUpXG4gICAgICAgICAgICAgICAgZGF0YW5hbWUgPSB6cGFyYW1zLnpkYXRhLnJlcGxhY2UoL1xcLiguKikvLCAnJyk7IC8vIGRyb3AgZmlsZSBleHRlbnNpb25cbiAgICAgICAgICAgIGQzLnNlbGVjdChcIiNkYXRhTmFtZVwiKS5odG1sKGRhdGFuYW1lKTtcblxuICAgICAgICAgICAgLy8gUHV0IGRhdGFzZXQgbmFtZSwgZnJvbSBtZXRhLWRhdGEsIGludG8gcGFnZSB0aXRsZVxuICAgICAgICAgICAgZDMuc2VsZWN0KFwidGl0bGVcIikuaHRtbChcIlR3b1JhdmVucyBcIiArIGRhdGFuYW1lKTtcbiAgICAgICAgICAgIC8vIHRlbXBvcmFyeSB2YWx1ZXMgZm9yIGhvbGQgdGhhdCBjb3JyZXNwb25kIHRvIGhpc3RvZ3JhbSBiaW5zXG4gICAgICAgICAgICBob2xkID0gWy42LCAuMiwgLjksIC44LCAuMSwgLjMsIC40XTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIHZhbHVlS2V5W2ldID0gdmFyc1tpXS5hdHRyaWJ1dGVzLm5hbWUubm9kZVZhbHVlO1xuICAgICAgICAgICAgICAgIC8vIGxhYmxBcnJheVtpXSA9IHZhcnNYTUxbaV0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJsYWJsXCIpLmxlbmd0aCA9PSAwID9cbiAgICAgICAgICAgICAgICAvLyBcIm5vIGxhYmVsXCIgOlxuICAgICAgICAgICAgICAgIC8vIHZhcnNYTUxbaV0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJsYWJsXCIpWzBdLmNoaWxkTm9kZXNbMF0ubm9kZVZhbHVlO1xuICAgICAgICAgICAgICAgIC8vIGxldCBkYXRhc2V0Y291bnQgPSBkMy5sYXlvdXQuaGlzdG9ncmFtKClcbiAgICAgICAgICAgICAgICAvLyAgICAgLmJpbnMoYmFybnVtYmVyKS5mcmVxdWVuY3koZmFsc2UpXG4gICAgICAgICAgICAgICAgLy8gICAgIChbMCwgMCwgMCwgMCwgMF0pO1xuICAgICAgICAgICAgICAgIHZhbHVlS2V5W2ldID0gdmFyc1tpXTtcbiAgICAgICAgICAgICAgICBsYWJsQXJyYXlbaV0gPSBcIm5vIGxhYmVsXCI7XG4gICAgICAgICAgICAgICAgLy8gY29udGFpbnMgYWxsIHRoZSBwcmVwcm9jZXNzZWQgZGF0YSB3ZSBoYXZlIGZvciB0aGUgdmFyaWFibGUsIGFzIHdlbGwgYXMgVUkgZGF0YSBwZXJ0aW5lbnQgdG8gdGhhdCB2YXJpYWJsZSxcbiAgICAgICAgICAgICAgICAvLyBzdWNoIGFzIHNldHggdmFsdWVzIChpZiB0aGUgdXNlciBoYXMgc2VsZWN0ZWQgdGhlbSkgYW5kIHBlYmJsZSBjb29yZGluYXRlc1xuICAgICAgICAgICAgICAgIGxldCBvYmogPSB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBpLFxuICAgICAgICAgICAgICAgICAgICByZWZsZXhpdmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiB2YWx1ZUtleVtpXSxcbiAgICAgICAgICAgICAgICAgICAgbGFibDogbGFibEFycmF5W2ldLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBbNSwgMTUsIDIwLCAwLCA1LCAxNSwgMjBdLFxuICAgICAgICAgICAgICAgICAgICBjb3VudDogaG9sZCxcbiAgICAgICAgICAgICAgICAgICAgbm9kZUNvbDogY29sb3JzKGkpLFxuICAgICAgICAgICAgICAgICAgICBiYXNlQ29sOiBjb2xvcnMoaSksXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZUNvbG9yOiBzZWxWYXJDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IFwiMVwiLFxuICAgICAgICAgICAgICAgICAgICBzdWJzZXRwbG90OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgc3Vic2V0cmFuZ2U6IFtcIlwiLCBcIlwiXSxcbiAgICAgICAgICAgICAgICAgICAgc2V0eHBsb3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBzZXR4dmFsczogW1wiXCIsIFwiXCJdLFxuICAgICAgICAgICAgICAgICAgICBncmF5b3V0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXAxOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXAyOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZm9yZWZyb250OiBmYWxzZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgalF1ZXJ5LmV4dGVuZCh0cnVlLCBvYmosIHByZXByb2Nlc3NbdmFsdWVLZXlbaV1dKTtcbiAgICAgICAgICAgICAgICBhbGxOb2Rlcy5wdXNoKG9iaik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KSkpXG4gICAgICAgIC50aGVuKCgpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIC8vIHJlYWQgemVsaWcgbW9kZWxzIGFuZCBwb3B1bGF0ZSBtb2RlbCBsaXN0IGluIHJpZ2h0IHBhbmVsXG4gICAgICAgICAgICBkMy5qc29uKFwiZGF0YS96ZWxpZzVtb2RlbHMuanNvblwiLCAoZXJyLCBkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIGNkYihcInplbGlnIG1vZGVscyBqc29uOiBcIiwgZGF0YSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIGRhdGEuemVsaWc1bW9kZWxzKVxuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS56ZWxpZzVtb2RlbHMuaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZHNbZGF0YS56ZWxpZzVtb2RlbHNba2V5XS5uYW1lWzBdXSA9IGRhdGEuemVsaWc1bW9kZWxzW2tleV0uZGVzY3JpcHRpb25bMF07XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pKVxuICAgICAgICAudGhlbigoKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBpZiAoZDNtX21vZGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgICAgICAgIGQzLmpzb24oXCJkYXRhL3plbGlnNWNob2ljZW1vZGVscy5qc29uXCIsIChlcnIsIGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgY2RiKFwiemVsaWcgY2hvaWNlIG1vZGVscyBqc29uOiBcIiwgZGF0YSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIGRhdGEuemVsaWc1Y2hvaWNlbW9kZWxzKVxuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS56ZWxpZzVjaG9pY2Vtb2RlbHMuaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZHNbZGF0YS56ZWxpZzVjaG9pY2Vtb2RlbHNba2V5XS5uYW1lWzBdXSA9IGRhdGEuemVsaWc1Y2hvaWNlbW9kZWxzW2tleV0uZGVzY3JpcHRpb25bMF07XG5cbiAgICAgICAgICAgICAgICBzY2FmZm9sZGluZyhsYXlvdXQpO1xuICAgICAgICAgICAgICAgIGRhdGFEb3dubG9hZCgpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pKVxuICAgICAgICAudGhlbigoKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAvLyByZWFkIGluIHByb2JsZW0gc2NoZW1hIGFuZCB3ZSdsbCBtYWtlIGEgY2FsbCB0byBzdGFydCB0aGUgc2Vzc2lvbiB3aXRoIFRBMi4gaWYgd2UgZ2V0IHRoaXMgZmFyLCBkYXRhIGFyZSBndWFyYW50ZWVkIHRvIGV4aXN0IGZvciB0aGUgZnJvbnRlbmRcbiAgICAgICAgICAgIGlmICghZDNtX21vZGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICBkMy5qc29uKGQzbVBTLCAoXywgZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwicHJvYiBzY2hlbWEgZGF0YTogXCIsIGRhdGEpO1xuICAgICAgICAgICAgICAgIG15dGFyZ2V0ID0gZGF0YS50YXJnZXQuZmllbGQ7XG4gICAgICAgICAgICAgICAgbGV0IGFUYWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICAgICAgICAgICAgYVRhZy5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBgJHtkM21Sb290UGF0aH0vJHtkYXRhLmRlc2NyaXB0aW9uRmlsZX1gKTtcbiAgICAgICAgICAgICAgICBhVGFnLnNldEF0dHJpYnV0ZSgnaWQnLCBcInByb2JkZXNjXCIpO1xuICAgICAgICAgICAgICAgIGFUYWcuc2V0QXR0cmlidXRlKCd0YXJnZXQnLCBcIl9ibGFua1wiKTtcbiAgICAgICAgICAgICAgICBhVGFnLnRleHRDb250ZW50ID0gXCJQcm9ibGVtIERlc2NyaXB0aW9uXCI7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ0aWNrZXJcIikuYXBwZW5kQ2hpbGQoYVRhZyk7XG5cbiAgICAgICAgICAgICAgICBpZihkYXRhLnRhc2tUeXBlIGluIGQzbVRhc2tUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGQzbVByb2JsZW1EZXNjcmlwdGlvbi50YXNrVHlwZSA9IGRhdGEudGFza1R5cGU7Ly9bZDNtVGFza1R5cGVbZGF0YS50YXNrVHlwZV1bMl0sZDNtVGFza1R5cGVbZGF0YS50YXNrVHlwZV1bMV1dOyBjb25zb2xlLmxvZyhkM21Qcm9ibGVtRGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGQzbVByb2JsZW1EZXNjcmlwdGlvbi50YXNrVHlwZSA9IFwidGFza1R5cGVVbmRlZmluZWRcIjtcbiAgICAgICAgICAgICAgICAgLy8gICBhbGVydChcIlNwZWNpZmllZCB0YXNrIHR5cGUsIFwiICsgZGF0YS50YXNrVHlwZSArIFwiLCBpcyBub3QgdmFsaWQuXCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmKGRhdGEudGFza1N1YlR5cGUgaW4gZDNtVGFza1N1YnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZDNtUHJvYmxlbURlc2NyaXB0aW9uLnRhc2tTdWJ0eXBlID0gZGF0YS50YXNrU3ViVHlwZTtcbiAgICAgICAgICAgICAgICAgICAgLy9bZDNtVGFza1N1YnR5cGVbZGF0YS50YXNrU3ViVHlwZV1bMl0sZDNtVGFza1N1YnR5cGVbZGF0YS50YXNrU3ViVHlwZV1bMV1dO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZDNtUHJvYmxlbURlc2NyaXB0aW9uLnRhc2tTdWJ0eXBlID0gXCJ0YXNrU3VidHlwZVVuZGVmaW5lZFwiO1xuICAgICAgICAgICAgICAgICAgIC8vICAgICBhbGVydChcIlNwZWNpZmllZCB0YXNrIHN1YnR5cGUsIFwiICsgZGF0YS50YXNrU3ViVHlwZSArIFwiLCBpcyBub3QgdmFsaWQuXCIpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZihkYXRhLm1ldHJpYyBpbiBkM21NZXRyaWNzKSB7XG4gICAgICAgICAgICAgICAgICAgIGQzbVByb2JsZW1EZXNjcmlwdGlvbi5tZXRyaWMgPSBkYXRhLm1ldHJpYzsvL1tkM21NZXRyaWNzW2RhdGEubWV0cmljXVsyXSxkM21NZXRyaWNzW2RhdGEubWV0cmljXVsxXV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZDNtUHJvYmxlbURlc2NyaXB0aW9uLm1ldHJpYyA9IFwibWV0cmljVW5kZWZpbmVkXCI7XG4gICAgICAgICAgICAgICAgICAgLy8gYWxlcnQoXCJTcGVjaWZpZWQgbWV0cmljIHR5cGUsIFwiICsgZGF0YS5tZXRyaWMgKyBcIiwgaXMgbm90IHZhbGlkLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmKGRhdGEub3V0cHV0VHlwZSBpbiBkM21PdXRwdXRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGQzbVByb2JsZW1EZXNjcmlwdGlvbi5vdXRwdXRUeXBlID0gZGF0YS5vdXRwdXRUeXBlOy8vW2QzbU91dHB1dFR5cGVbZGF0YS5vdXRwdXRUeXBlXVsyXSxkM21PdXRwdXRUeXBlW2RhdGEub3V0cHV0VHlwZV1bMV1dO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGQzbVByb2JsZW1EZXNjcmlwdGlvbi5vdXRwdXRUeXBlID0gXCJvdXRwdXRVbmRlZmluZWRcIjtcbiAgICAgICAgICAgICAgICAgIC8vICBhbGVydChcIlNwZWNpZmllZCBvdXRwdXQgdHlwZSwgXCIgKyBkYXRhLm91dHB1dFR5cGUgKyBcIiwgaXMgbm90IHZhbGlkLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgZDNtUHJvYmxlbURlc2NyaXB0aW9uLnRhc2tEZXNjcmlwdGlvbiA9IGRhdGEuZGVzY3JpcHRpb25GaWxlO1xuXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJidG5UeXBlXCIpLmNsaWNrKCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pKVxuICAgICAgICAudGhlbigoKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFkM21fbW9kZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIG91ciBjYWxsIHRvIGRqYW5nbyB0byBzdGFydCB0aGUgc2Vzc2lvblxuICAgICAgICAgICAgICAgIC8vcnBjIFN0YXJ0U2Vzc2lvbihTZXNzaW9uUmVxdWVzdCkgcmV0dXJucyAoU2Vzc2lvblJlc3BvbnNlKSB7fVxuICAgICAgICAgICAgICAgIGxldCB1c2VyX2FnZW50ID0gXCJzb21lIGFnZW50XCI7XG4gICAgICAgICAgICAgICAgbGV0IHZlcnNpb24gPSBcInNvbWUgdmVyc2lvblwiO1xuICAgICAgICAgICAgICAgIGxldCBTZXNzaW9uUmVxdWVzdD17dXNlcl9hZ2VudCx2ZXJzaW9ufTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyIGpzb25vdXQgPSBKU09OLnN0cmluZ2lmeShTZXNzaW9uUmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgdmFyIHVybGNhbGwgPSBkM21VUkwgKyBcIi9zdGFydHNlc3Npb25cIjtcbiAgICAgICAgICAgICAgICB2YXIgc29sYWpzb25vdXQgPSBcImdycGNyZXF1ZXN0PVwiICsganNvbm91dDtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlNlc3Npb25SZXF1ZXN0OiBcIik7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coc29sYWpzb25vdXQpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidXJsY2FsbDogXCIsIHVybGNhbGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzc1N1Y2Nlc3MoYnRuLCBTZXNzaW9uUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgenBhcmFtcy56c2Vzc2lvbmlkPVNlc3Npb25SZXNwb25zZS5jb250ZXh0LnNlc3Npb25JZDtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJzdGFydHNlc3Npb246IFwiLCBTZXNzaW9uUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgc2NhZmZvbGRpbmcobGF5b3V0KTtcbiAgICAgICAgICAgICAgICAgICAgelBvcCgpOyAvLyBjYWxsZWQgaW4gZGF0YURvd25sb2FkLCBidXQgcmVxdWlyZWQgdG8gYmUgY2FsbGVkIHNvIG1vdmVkIGhlcmUgZm9yIGQzbV9tb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZGF0YURvd25sb2FkKCk7ICB3ZSBkbyBub3QgY2FsbCBkYXRhRG93bmxvYWQgaW4gZDNtX21vZGUuIHdlIGFzc3VtZSB3ZSBoYXZlIHRoZSBwYXRoIHRvIHRoZSBkYXRhIGFscmVhZHlcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gc3NGYWlsKGJ0bikge1xuICAgICAgICAgICAgICAgICAgICBhbGVydChcIlN0YXJ0U2Vzc2lvbiBoYXMgZmFpbGVkLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgbWFrZUNvcnNSZXF1ZXN0KHVybGNhbGwsIFwibm9idXR0b25cIiwgc3NTdWNjZXNzLCBzc0ZhaWwsIHNvbGFqc29ub3V0KTtcbiAgICBcbiAgICAgICAgfSkpXG59XG5cblxubGV0ICRmaWxsID0gKG9iaiwgb3AsIGQxLCBkMikgPT4gZDMuc2VsZWN0KG9iaikudHJhbnNpdGlvbigpXG4gICAgLmF0dHIoJ2ZpbGwtb3BhY2l0eScsIG9wKVxuICAgIC5kZWxheShkMSlcbiAgICAuZHVyYXRpb24oZDIpO1xubGV0IGZpbGwgPSAoZCwgaWQsIG9wLCBkMSwgZDIpID0+ICRmaWxsKCcjJyArIGlkICsgZC5pZCwgb3AsIGQxLCBkMik7XG5sZXQgZmlsbFRoaXMgPSAoc2VsZiwgb3AsIGQxLCBkMikgPT4gJGZpbGwoc2VsZiwgb3AsIGQxLCBkMik7XG5cbi8vIHNjYWZmb2xkaW5nIGlzIGNhbGxlZCBhZnRlciBhbGwgZXh0ZXJuYWwgZGF0YSBhcmUgZ3VhcmFudGVlZCB0byBoYXZlIGJlZW4gcmVhZCB0byBjb21wbGV0aW9uLiB0aGlzIHBvcHVsYXRlcyB0aGUgbGVmdCBwYW5lbCB3aXRoIHZhcmlhYmxlIG5hbWVzLCB0aGUgcmlnaHQgcGFuZWwgd2l0aCBtb2RlbCBuYW1lcywgdGhlIHRyYW5zZm9ybWF0aW9uIHRvb2wsIGFuIHRoZSBhc3NvY2lhdGVkIG1vdXNlb3ZlcnMuIGl0cyBjYWxsYmFjayBpcyBsYXlvdXQoKSwgd2hpY2ggaW5pdGlhbGl6ZXMgdGhlIG1vZGVsaW5nIHNwYWNlXG5mdW5jdGlvbiBzY2FmZm9sZGluZyhjYWxsYmFjaykge1xuICAgIC8vIGVzdGFibGlzaGluZyB0aGUgdHJhbnNmb3JtYXRpb24gZWxlbWVudFxuICAgIGQzLnNlbGVjdChcIiN0cmFuc2Zvcm1hdGlvbnNcIilcbiAgICAgICAgLmFwcGVuZChcImlucHV0XCIpXG4gICAgICAgIC5hdHRyKFwiaWRcIiwgXCJ0SW5wdXRcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImZvcm0tY29udHJvbFwiKVxuICAgICAgICAuYXR0cihcInR5cGVcIiwgXCJ0ZXh0XCIpXG4gICAgICAgIC5hdHRyKFwidmFsdWVcIiwgXCJWYXJpYWJsZSB0cmFuc2Zvcm1hdGlvblwiKTtcblxuICAgIC8vIHZhcmlhYmxlIGRyb3Bkb3duXG4gICAgZDMuc2VsZWN0KFwiI3RyYW5zZm9ybWF0aW9uc1wiKVxuICAgICAgICAuYXBwZW5kKFwidWxcIilcbiAgICAgICAgLmF0dHIoXCJpZFwiLCBcInRyYW5zU2VsXCIpXG4gICAgICAgIC5zdHlsZShcImRpc3BsYXlcIiwgXCJub25lXCIpXG4gICAgICAgIC5zdHlsZShcImJhY2tncm91bmQtY29sb3JcIiwgdmFyQ29sb3IpXG4gICAgICAgIC5zZWxlY3RBbGwoJ2xpJylcbiAgICAgICAgLmRhdGEoW1wiYVwiLCBcImJcIl0pIC8vc2V0IHRvIHZhcmlhYmxlcyBpbiBtb2RlbCBzcGFjZSBhcyB0aGV5J3JlIGFkZGVkXG4gICAgICAgIC5lbnRlcigpXG4gICAgICAgIC5hcHBlbmQoXCJsaVwiKVxuICAgICAgICAudGV4dChkID0+IGQpO1xuXG4gICAgLy8gZnVuY3Rpb24gZHJvcGRvd25cbiAgICBkMy5zZWxlY3QoXCIjdHJhbnNmb3JtYXRpb25zXCIpXG4gICAgICAgIC5hcHBlbmQoXCJ1bFwiKVxuICAgICAgICAuYXR0cihcImlkXCIsIFwidHJhbnNMaXN0XCIpXG4gICAgICAgIC5zdHlsZShcImRpc3BsYXlcIiwgXCJub25lXCIpXG4gICAgICAgIC5zdHlsZShcImJhY2tncm91bmQtY29sb3JcIiwgdmFyQ29sb3IpXG4gICAgICAgIC5zZWxlY3RBbGwoJ2xpJylcbiAgICAgICAgLmRhdGEodHJhbnNmb3JtTGlzdClcbiAgICAgICAgLmVudGVyKClcbiAgICAgICAgLmFwcGVuZChcImxpXCIpXG4gICAgICAgIC50ZXh0KGQgPT4gZCk7XG5cbiAgICAkKCcjdElucHV0JykuY2xpY2soKCkgPT4ge1xuICAgICAgICB2YXIgdCA9IGJ5SWQoJ3RyYW5zU2VsJykuc3R5bGUuZGlzcGxheTtcbiAgICAgICAgaWYgKHQgIT09IFwibm9uZVwiKSB7IC8vIGlmIHZhcmlhYmxlIGxpc3QgaXMgZGlzcGxheWVkIHdoZW4gaW5wdXQgaXMgY2xpY2tlZC4uLlxuICAgICAgICAgICAgJCgnI3RyYW5zU2VsJykuZmFkZU91dCgxMDApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0MSA9IGJ5SWQoJ3RyYW5zTGlzdCcpLnN0eWxlLmRpc3BsYXk7XG4gICAgICAgIGlmICh0MSAhPT0gXCJub25lXCIpIHsgLy8gaWYgZnVuY3Rpb24gbGlzdCBpcyBkaXNwbGF5ZWQgd2hlbiBpbnB1dCBpcyBjbGlja2VkLi4uXG4gICAgICAgICAgICAkKCcjdHJhbnNMaXN0JykuZmFkZU91dCgxMDApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaGlnaGxpZ2h0IHRoZSB0ZXh0XG4gICAgICAgICQodGhpcykuc2VsZWN0KCk7XG4gICAgICAgIHZhciBwb3MgPSAkKCcjdElucHV0Jykub2Zmc2V0KCk7XG4gICAgICAgIHBvcy50b3AgKz0gJCgnI3RJbnB1dCcpLndpZHRoKCk7XG4gICAgICAgICQoJyN0cmFuc1NlbCcpLmZhZGVJbigxMDApO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG5cbiAgICB2YXIgbjtcbiAgICAkKCcjdElucHV0Jykua2V5dXAoZXZ0ID0+IHtcbiAgICAgICAgdmFyIHQgPSBieUlkKCd0cmFuc1NlbCcpLnN0eWxlLmRpc3BsYXk7XG4gICAgICAgIHZhciB0MSA9IGJ5SWQoJ3RyYW5zTGlzdCcpLnN0eWxlLmRpc3BsYXk7XG4gICAgICAgIGlmICh0ICE9IFwibm9uZVwiKSAkKCcjdHJhbnNTZWwnKS5mYWRlT3V0KDEwMCk7XG4gICAgICAgIGVsc2UgaWYgKHQxICE9IFwibm9uZVwiKSAkKCcjdHJhbnNMaXN0JykuZmFkZU91dCgxMDApO1xuXG4gICAgICAgIGlmIChldnQua2V5Q29kZSA9PSAxMykgeyAvLyBrZXl1cCBvbiBFbnRlclxuICAgICAgICAgICAgbiA9ICQoJyN0SW5wdXQnKS52YWwoKTtcbiAgICAgICAgICAgIHZhciB0ID0gdHJhbnNQYXJzZShuPW4pO1xuICAgICAgICAgICAgaWYgKCF0KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRyYW5zZm9ybShuID0gdC5zbGljZSgwLCB0Lmxlbmd0aCAtIDEpLCB0ID0gdFt0Lmxlbmd0aCAtIDFdLCB0eXBlVHJhbnNmb3JtID0gZmFsc2UpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgdDtcbiAgICAkKCcjdHJhbnNMaXN0IGxpJykuY2xpY2soZnVuY3Rpb24oZXZ0KXtcbiAgICAgICAgLy8gaWYgaW50ZXJhY3QgaXMgc2VsZWN0ZWQsIHNob3cgdmFyaWFibGUgbGlzdCBhZ2FpblxuICAgICAgICBpZiAoJCh0aGlzKS50ZXh0KCkgPT0gXCJpbnRlcmFjdChkLGUpXCIpIHtcbiAgICAgICAgICAgICQoJyN0SW5wdXQnKS52YWwodHZhci5jb25jYXQoJyonKSk7XG4gICAgICAgICAgICBzZWxJbnRlcmFjdCA9IHRydWU7XG4gICAgICAgICAgICAkKHRoaXMpLnBhcmVudCgpLmZhbmRlT3V0KDEwMCk7XG4gICAgICAgICAgICAkKCcjdHJhbnNTZWwnKS5mYWRlSW4oMTAwKTtcbiAgICAgICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0dmFyID0gJCgnI3RJbnB1dCcpLnZhbCgpO1xuICAgICAgICB2YXIgdGZ1bmMgPSAkKHRoaXMpLnRleHQoKS5yZXBsYWNlKFwiZFwiLCBcIl90cmFuc3ZhcjBcIik7XG4gICAgICAgIHZhciB0Y2FsbCA9ICQodGhpcykudGV4dCgpLnJlcGxhY2UoXCJkXCIsIHR2YXIpO1xuICAgICAgICAkKCcjdElucHV0JykudmFsKHRjYWxsKTtcbiAgICAgICAgJCh0aGlzKS5wYXJlbnQoKS5mYWRlT3V0KDEwMCk7XG4gICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgdHJhbnNmb3JtKG4gPSB0dmFyLCB0ID0gdGZ1bmMsIHR5cGVUcmFuc2Zvcm0gPSBmYWxzZSk7XG4gICAgfSk7XG5cbiAgICBkMy5zZWxlY3QoXCIjbW9kZWxzXCIpXG4gICAgICAgIC5zdHlsZSgnaGVpZ2h0JywgMjAwMClcbiAgICAgICAgLnN0eWxlKCdvdmVyZmlsbCcsICdzY3JvbGwnKTtcblxuICAgIGlmKCFkM21fbW9kZSl7XG4gICAgZDMuc2VsZWN0KFwiI21vZGVsc1wiKS5zZWxlY3RBbGwoXCJwXCIpXG4gICAgICAgIC5kYXRhKE9iamVjdC5rZXlzKG1vZHMpKVxuICAgICAgICAuZW50ZXIoKVxuICAgICAgICAuYXBwZW5kKFwicFwiKVxuICAgICAgICAuYXR0cihcImlkXCIsIFwiX21vZGVsX1wiLmNvbmNhdClcbiAgICAgICAgLnRleHQoZCA9PiBkKVxuICAgICAgICAuc3R5bGUoJ2JhY2tncm91bmQtY29sb3InLCBkID0+IHZhckNvbG9yKVxuICAgICAgICAuYXR0cihcImRhdGEtY29udGFpbmVyXCIsIFwiYm9keVwiKVxuICAgICAgICAuYXR0cihcImRhdGEtdG9nZ2xlXCIsIFwicG9wb3ZlclwiKVxuICAgICAgICAuYXR0cihcImRhdGEtdHJpZ2dlclwiLCBcImhvdmVyXCIpXG4gICAgICAgIC5hdHRyKFwiZGF0YS1wbGFjZW1lbnRcIiwgXCJ0b3BcIilcbiAgICAgICAgLmF0dHIoXCJkYXRhLWh0bWxcIiwgXCJ0cnVlXCIpXG4gICAgICAgIC5hdHRyKFwib25tb3VzZW92ZXJcIiwgXCIkKHRoaXMpLnBvcG92ZXIoJ3RvZ2dsZScpO1wiKVxuICAgICAgICAuYXR0cihcIm9ubW91c2VvdXRcIiwgXCIkKHRoaXMpLnBvcG92ZXIoJ3RvZ2dsZScpO1wiKVxuICAgICAgICAuYXR0cihcImRhdGEtb3JpZ2luYWwtdGl0bGVcIiwgXCJNb2RlbCBEZXNjcmlwdGlvblwiKVxuICAgICAgICAuYXR0cihcImRhdGEtY29udGVudFwiLCBkID0+IG1vZHNbZF0pO1xuICAgIH1cbiAgICBpZihkM21fbW9kZSkge1xuXG4gICAgICAgIC8vXG5cbiAgICAgICAgdG9nZ2xlUmlnaHRCdXR0b25zKFwidGFza3NcIik7XG5cbiAgICAgICAgZDMuc2VsZWN0KFwiI3R5cGVzXCIpLnNlbGVjdEFsbChcInBcIilcbiAgICAgICAgLmRhdGEoT2JqZWN0LmtleXMoZDNtVGFza1R5cGUpKVxuICAgICAgICAuZW50ZXIoKVxuICAgICAgICAuYXBwZW5kKFwicFwiKVxuICAgICAgICAuYXR0cihcImlkXCIsIGQgPT4gZCArIFwiLnR5cGVzXCIpXG4gICAgICAgIC50ZXh0KGQgPT4gZClcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgZD0+IHtcbiAgICAgICAgICAgICAgaWYgKGQzbVByb2JsZW1EZXNjcmlwdGlvbi50YXNrVHlwZSA9PSBkLnRvU3RyaW5nKCkpe1xuICAgICAgICAgICAgICByZXR1cm4gJ2l0ZW0tc2VsZWN0JztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYobG9ja3RvZ2dsZSkgcmV0dXJuICdpdGVtLWRlZmF1bHQgaXRlbS1saW5lb3V0JztcbiAgICAgICAgICAgICAgcmV0dXJuICdpdGVtLWRlZmF1bHQnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgIC5hdHRyKFwiZGF0YS1jb250YWluZXJcIiwgXCJib2R5XCIpXG4gICAgICAgIC5hdHRyKFwiZGF0YS10b2dnbGVcIiwgXCJwb3BvdmVyXCIpXG4gICAgICAgIC5hdHRyKFwiZGF0YS10cmlnZ2VyXCIsIFwiaG92ZXJcIilcbiAgICAgICAgLmF0dHIoXCJkYXRhLXBsYWNlbWVudFwiLCBcInRvcFwiKVxuICAgICAgICAuYXR0cihcImRhdGEtaHRtbFwiLCBcInRydWVcIilcbiAgICAgICAgLmF0dHIoXCJvbm1vdXNlb3ZlclwiLCBcIiQodGhpcykucG9wb3ZlcigndG9nZ2xlJyk7XCIpXG4gICAgICAgIC5hdHRyKFwib25tb3VzZW91dFwiLCBcIiQodGhpcykucG9wb3ZlcigndG9nZ2xlJyk7XCIpXG4gICAgICAgIC5hdHRyKFwiZGF0YS1vcmlnaW5hbC10aXRsZVwiLCBcIlRhc2sgRGVzY3JpcHRpb25cIilcbiAgICAgICAgLmF0dHIoXCJkYXRhLWNvbnRlbnRcIiwgZCA9PiBkM21UYXNrVHlwZVtkXVsxXSk7XG5cbiAgICAgICAgZDMuc2VsZWN0KFwiI3N1YnR5cGVzXCIpLnNlbGVjdEFsbChcInBcIilcbiAgICAgICAgLmRhdGEoT2JqZWN0LmtleXMoZDNtVGFza1N1YnR5cGUpKVxuICAgICAgICAuZW50ZXIoKVxuICAgICAgICAuYXBwZW5kKFwicFwiKVxuICAgICAgICAuYXR0cihcImlkXCIsIGQgPT4gZCArIFwiLnN1YnR5cGVzXCIpXG4gICAgICAgIC50ZXh0KGQgPT4gZClcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgZD0+IHtcbiAgICAgICAgICAgICAgaWYgKGQzbVByb2JsZW1EZXNjcmlwdGlvbi50YXNrU3VidHlwZSA9PSBkLnRvU3RyaW5nKCkpe1xuICAgICAgICAgICAgICByZXR1cm4gJ2l0ZW0tc2VsZWN0JztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYobG9ja3RvZ2dsZSkgcmV0dXJuICdpdGVtLWRlZmF1bHQgaXRlbS1saW5lb3V0JztcbiAgICAgICAgICAgICAgcmV0dXJuICdpdGVtLWRlZmF1bHQnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgIC5hdHRyKFwiZGF0YS1jb250YWluZXJcIiwgXCJib2R5XCIpXG4gICAgICAgIC5hdHRyKFwiZGF0YS10b2dnbGVcIiwgXCJwb3BvdmVyXCIpXG4gICAgICAgIC5hdHRyKFwiZGF0YS10cmlnZ2VyXCIsIFwiaG92ZXJcIilcbiAgICAgICAgLmF0dHIoXCJkYXRhLXBsYWNlbWVudFwiLCBcInRvcFwiKVxuICAgICAgICAuYXR0cihcImRhdGEtaHRtbFwiLCBcInRydWVcIilcbiAgICAgICAgLmF0dHIoXCJvbm1vdXNlb3ZlclwiLCBcIiQodGhpcykucG9wb3ZlcigndG9nZ2xlJyk7XCIpXG4gICAgICAgIC5hdHRyKFwib25tb3VzZW91dFwiLCBcIiQodGhpcykucG9wb3ZlcigndG9nZ2xlJyk7XCIpXG4gICAgICAgIC5hdHRyKFwiZGF0YS1vcmlnaW5hbC10aXRsZVwiLCBcIlRhc2sgU3VidHlwZSBEZXNjLlwiKVxuICAgICAgICAuYXR0cihcImRhdGEtY29udGVudFwiLCBkID0+IGQzbVRhc2tTdWJ0eXBlW2RdWzFdKTtcblxuICAgICAgICBkMy5zZWxlY3QoXCIjbWV0cmljc1wiKS5zZWxlY3RBbGwoXCJwXCIpXG4gICAgICAgIC5kYXRhKE9iamVjdC5rZXlzKGQzbU1ldHJpY3MpKVxuICAgICAgICAuZW50ZXIoKVxuICAgICAgICAuYXBwZW5kKFwicFwiKVxuICAgICAgICAuYXR0cihcImlkXCIsIGQgPT4gZCArIFwiLm1ldHJpY3NcIilcbiAgICAgICAgLnRleHQoZCA9PiBkKVxuICAgICAgICAuYXR0cignY2xhc3MnLCBkPT4ge1xuICAgICAgICAgICAgICBpZiAoZDNtUHJvYmxlbURlc2NyaXB0aW9uLm1ldHJpYyA9PSBkLnRvU3RyaW5nKCkpe1xuICAgICAgICAgICAgICAgIHJldHVybiAnaXRlbS1zZWxlY3QnO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmKGxvY2t0b2dnbGUpIHJldHVybiAnaXRlbS1kZWZhdWx0IGl0ZW0tbGluZW91dCc7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdpdGVtLWRlZmF1bHQnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgIC5hdHRyKFwiZGF0YS1jb250YWluZXJcIiwgXCJib2R5XCIpXG4gICAgICAgIC5hdHRyKFwiZGF0YS10b2dnbGVcIiwgXCJwb3BvdmVyXCIpXG4gICAgICAgIC5hdHRyKFwiZGF0YS10cmlnZ2VyXCIsIFwiaG92ZXJcIilcbiAgICAgICAgLmF0dHIoXCJkYXRhLXBsYWNlbWVudFwiLCBcInRvcFwiKVxuICAgICAgICAuYXR0cihcImRhdGEtaHRtbFwiLCBcInRydWVcIilcbiAgICAgICAgLmF0dHIoXCJvbm1vdXNlb3ZlclwiLCBcIiQodGhpcykucG9wb3ZlcigndG9nZ2xlJyk7XCIpXG4gICAgICAgIC5hdHRyKFwib25tb3VzZW91dFwiLCBcIiQodGhpcykucG9wb3ZlcigndG9nZ2xlJyk7XCIpXG4gICAgICAgIC5hdHRyKFwiZGF0YS1vcmlnaW5hbC10aXRsZVwiLCBcIk1ldHJpYyBEZXNjcmlwdGlvblwiKVxuICAgICAgICAuYXR0cihcImRhdGEtY29udGVudFwiLCBkID0+IGQzbU1ldHJpY3NbZF1bMV0pO1xuXG4gICAgICAgIGQzLnNlbGVjdChcIiNvdXRwdXRzXCIpLnNlbGVjdEFsbChcInBcIilcbiAgICAgICAgLmRhdGEoT2JqZWN0LmtleXMoZDNtT3V0cHV0VHlwZSkpXG4gICAgICAgIC5lbnRlcigpXG4gICAgICAgIC5hcHBlbmQoXCJwXCIpXG4gICAgICAgIC5hdHRyKFwiaWRcIiwgZCA9PiBkICsgXCIub3V0cHV0c1wiKVxuICAgICAgICAudGV4dChkID0+IGQpXG4gICAgICAgIC5hdHRyKCdjbGFzcycsIGQ9PiB7XG4gICAgICAgICAgICAgIGlmIChkM21Qcm9ibGVtRGVzY3JpcHRpb24ub3V0cHV0VHlwZSA9PSBkLnRvU3RyaW5nKCkpe1xuICAgICAgICAgICAgICByZXR1cm4gJ2l0ZW0tc2VsZWN0JztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYobG9ja3RvZ2dsZSkgcmV0dXJuICdpdGVtLWRlZmF1bHQgaXRlbS1saW5lb3V0JztcbiAgICAgICAgICAgICAgcmV0dXJuICdpdGVtLWRlZmF1bHQnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgIC5hdHRyKFwiZGF0YS1jb250YWluZXJcIiwgXCJib2R5XCIpXG4gICAgICAgIC5hdHRyKFwiZGF0YS10b2dnbGVcIiwgXCJwb3BvdmVyXCIpXG4gICAgICAgIC5hdHRyKFwiZGF0YS10cmlnZ2VyXCIsIFwiaG92ZXJcIilcbiAgICAgICAgLmF0dHIoXCJkYXRhLXBsYWNlbWVudFwiLCBcInRvcFwiKVxuICAgICAgICAuYXR0cihcImRhdGEtaHRtbFwiLCBcInRydWVcIilcbiAgICAgICAgLmF0dHIoXCJvbm1vdXNlb3ZlclwiLCBcIiQodGhpcykucG9wb3ZlcigndG9nZ2xlJyk7XCIpXG4gICAgICAgIC5hdHRyKFwib25tb3VzZW91dFwiLCBcIiQodGhpcykucG9wb3ZlcigndG9nZ2xlJyk7XCIpXG4gICAgICAgIC5hdHRyKFwiZGF0YS1vcmlnaW5hbC10aXRsZVwiLCBcIk91dHB1dCBEZXNjcmlwdGlvblwiKVxuICAgICAgICAuYXR0cihcImRhdGEtY29udGVudFwiLCBkID0+IGQzbU91dHB1dFR5cGVbZF1bMV0pO1xuXG4gICAgfVxuXG4gICAgLy8gY2FsbCBsYXlvdXQoKSBiZWNhdXNlIGF0IHRoaXMgcG9pbnQgYWxsIHNjYWZmb2xkaW5nIGlzIHVwIGFuZCByZWFkeVxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrKGZhbHNlLHRydWUpO1xuICAgICAgICBtLnJlZHJhdygpO1xuICAgIH1cbn1cblxubGV0IHNwbGljZSA9IChjb2xvciwgdGV4dCwgLi4uYXJncykgPT4ge1xuICAgIGFyZ3MuZm9yRWFjaCh4ID0+IHtcbiAgICAgICAgaWYgKGNvbG9yICE9IHhbMF0pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBpZHggPSB6cGFyYW1zW3hbMV1dLmluZGV4T2YodGV4dCk7XG4gICAgICAgIGlkeCA+IC0xICYmIHpwYXJhbXNbeFsxXV0uc3BsaWNlKGlkeCwgMSk7XG4gICAgfSk7XG59O1xuXG5leHBvcnQgbGV0IGNsaWNrVmFyO1xuXG5mdW5jdGlvbiBsYXlvdXQodix2Mikge1xuICAgIHZhciBteVZhbHVlcyA9IFtdO1xuICAgIG5vZGVzID0gW107XG4gICAgbGlua3MgPSBbXTtcblxuICAgIHN2Zy5hcHBlbmQoXCJzdmc6ZGVmc1wiKS5hcHBlbmQoXCJzdmc6bWFya2VyXCIpXG4gICAgICAgIC5hdHRyKFwiaWRcIiwgXCJncm91cDEtYXJyb3dcIilcbiAgICAgICAgLmF0dHIoJ3ZpZXdCb3gnLCAnMCAtNSAxNSAxNScpXG4gICAgICAgIC5hdHRyKFwicmVmWFwiLCAyLjUpXG4gICAgICAgIC5hdHRyKFwicmVmWVwiLCAwKVxuICAgICAgICAuYXR0cihcIm1hcmtlcldpZHRoXCIsIDMpXG4gICAgICAgIC5hdHRyKFwibWFya2VySGVpZ2h0XCIsIDMpXG4gICAgICAgIC5hdHRyKFwib3JpZW50XCIsIFwiYXV0b1wiKVxuICAgICAgICAuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAuYXR0cignZCcsICdNMCwtNUwxMCwwTDAsNScpXG4gICAgICAgIC5zdHlsZShcImZpbGxcIiwgZ3IxQ29sb3IpO1xuXG4gICAgc3ZnLmFwcGVuZChcInN2ZzpkZWZzXCIpLmFwcGVuZChcInN2ZzptYXJrZXJcIilcbiAgICAgICAgLmF0dHIoXCJpZFwiLCBcImdyb3VwMi1hcnJvd1wiKVxuICAgICAgICAuYXR0cigndmlld0JveCcsICcwIC01IDE1IDE1JylcbiAgICAgICAgLmF0dHIoXCJyZWZYXCIsIDIuNSlcbiAgICAgICAgLmF0dHIoXCJyZWZZXCIsIDApXG4gICAgICAgIC5hdHRyKFwibWFya2VyV2lkdGhcIiwgMylcbiAgICAgICAgLmF0dHIoXCJtYXJrZXJIZWlnaHRcIiwgMylcbiAgICAgICAgLmF0dHIoXCJvcmllbnRcIiwgXCJhdXRvXCIpXG4gICAgICAgIC5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgIC5hdHRyKCdkJywgJ00wLC01TDEwLDBMMCw1JylcbiAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBncjJDb2xvcik7XG5cbiAgICB2YXIgbGluZSA9IHN2Zy5hcHBlbmQoXCJsaW5lXCIpXG4gICAgICAgIC5zdHlsZSgnZmlsbCcsICdub25lJylcbiAgICAgICAgLnN0eWxlKCdzdHJva2UnLCBncjFDb2xvcilcbiAgICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLCA1KVxuICAgICAgICAuYXR0cihcIm1hcmtlci1lbmRcIiwgXCJ1cmwoI2dyb3VwMS1hcnJvdylcIik7XG5cbiAgICB2YXIgbGluZTIgPSBzdmcuYXBwZW5kKFwibGluZVwiKVxuICAgICAgICAuc3R5bGUoJ2ZpbGwnLCAnbm9uZScpXG4gICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgZ3IyQ29sb3IpXG4gICAgICAgIC5zdHlsZSgnc3Ryb2tlLXdpZHRoJywgNSlcbiAgICAgICAgLmF0dHIoXCJtYXJrZXItZW5kXCIsIFwidXJsKCNncm91cDItYXJyb3cpXCIpOztcblxuICAgIHZhciB2aXNiYWNrZ3JvdW5kID0gZDMuc2VsZWN0KFwiI3doaXRlc3BhY2VcIikuYXBwZW5kKFwic3ZnXCIpXG4gICAgICAgIC5hdHRyKFwid2lkdGhcIiwgd2lkdGgpXG4gICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGhlaWdodCk7XG5cbiAgICB2aXNiYWNrZ3JvdW5kLmFwcGVuZChcInBhdGhcIikgLy8gbm90ZSBsaW5lcywgYXJlIGJlaGluZCBncm91cCBodWxscyBvZiB3aGljaCB0aGVyZSBpcyBhIHdoaXRlIGFuZCBjb2xvcmVkIHNlbWkgdHJhbnNwYXJlbnQgbGF5ZXJcbiAgICAgICAgLmF0dHIoXCJpZFwiLCAnZ3IxYmFja2dyb3VuZCcpXG4gICAgICAgIC5zdHlsZShcImZpbGxcIiwgJyNmZmZmZmYnKVxuICAgICAgICAuc3R5bGUoXCJzdHJva2VcIiwgJyNmZmZmZmYnKVxuICAgICAgICAuc3R5bGUoXCJzdHJva2Utd2lkdGhcIiwgMi41KmFsbFIpXG4gICAgICAgIC5zdHlsZSgnc3Ryb2tlLWxpbmVqb2luJywncm91bmQnKVxuICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDEpO1xuXG4gICAgdmFyIHZpczJiYWNrZ3JvdW5kID0gZDMuc2VsZWN0KFwiI3doaXRlc3BhY2VcIikuYXBwZW5kKFwic3ZnXCIpXG4gICAgICAgIC5hdHRyKFwid2lkdGhcIiwgd2lkdGgpXG4gICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGhlaWdodCk7XG5cbiAgICB2aXMyYmFja2dyb3VuZC5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgIC5hdHRyKFwiaWRcIiwgJ2dyMWJhY2tncm91bmQnKVxuICAgICAgICAuc3R5bGUoXCJmaWxsXCIsICcjZmZmZmZmJylcbiAgICAgICAgLnN0eWxlKFwic3Ryb2tlXCIsICcjZmZmZmZmJylcbiAgICAgICAgLnN0eWxlKFwic3Ryb2tlLXdpZHRoXCIsIDIuNSphbGxSKVxuICAgICAgICAuc3R5bGUoJ3N0cm9rZS1saW5lam9pbicsJ3JvdW5kJylcbiAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAxKTtcblxuICAgIHZhciB2aXMgPSBkMy5zZWxlY3QoXCIjd2hpdGVzcGFjZVwiKS5hcHBlbmQoXCJzdmdcIilcbiAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCB3aWR0aClcbiAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgaGVpZ2h0KTtcblxuICAgIHZpcy5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgIC5hdHRyKFwiaWRcIiwgJ2dyMWh1bGwnKVxuICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGdyMUNvbG9yKVxuICAgICAgICAuc3R5bGUoXCJzdHJva2VcIiwgZ3IxQ29sb3IpXG4gICAgICAgIC5zdHlsZShcInN0cm9rZS13aWR0aFwiLCAyLjUqYWxsUilcbiAgICAgICAgLnN0eWxlKCdzdHJva2UtbGluZWpvaW4nLCdyb3VuZCcpO1xuXG4gICAgdmFyIHZpczIgPSBkMy5zZWxlY3QoXCIjd2hpdGVzcGFjZVwiKS5hcHBlbmQoXCJzdmdcIilcbiAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCB3aWR0aClcbiAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgaGVpZ2h0KTtcblxuICAgIHZpczIuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGdyMkNvbG9yKVxuICAgICAgICAuc3R5bGUoXCJzdHJva2VcIiwgZ3IyQ29sb3IpXG4gICAgICAgIC5zdHlsZShcInN0cm9rZS13aWR0aFwiLCAyLjUqYWxsUilcbiAgICAgICAgLnN0eWxlKCdzdHJva2UtbGluZWpvaW4nLCdyb3VuZCcpO1xuXG4gICAgaWYgKHYgPT0gbGF5b3V0QWRkIHx8IHYgPT0gbGF5b3V0TW92ZSkge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHpwYXJhbXMuenZhcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBpaSA9IGZpbmROb2RlSW5kZXgoenBhcmFtcy56dmFyc1tqXSk7XG4gICAgICAgICAgICBpZiAoYWxsTm9kZXNbaWldLmdyYXlvdXQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBub2Rlcy5wdXNoKGFsbE5vZGVzW2lpXSk7XG4gICAgICAgICAgICB2YXIgc2VsZWN0TWUgPSB6cGFyYW1zLnp2YXJzW2pdLnJlcGxhY2UoL1xcVy9nLCBcIl9cIik7XG4gICAgICAgICAgICBzZWxlY3RNZSA9IFwiI1wiLmNvbmNhdChzZWxlY3RNZSk7XG4gICAgICAgICAgICBkMy5zZWxlY3Qoc2VsZWN0TWUpLnN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJywgKCkgPT4gaGV4VG9SZ2JhKG5vZGVzW2pdLnN0cm9rZUNvbG9yKSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHpwYXJhbXMuemVkZ2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgbXlzcmMgPSBub2RlSW5kZXgoenBhcmFtcy56ZWRnZXNbal1bMF0pO1xuICAgICAgICAgICAgdmFyIG15dGd0ID0gbm9kZUluZGV4KHpwYXJhbXMuemVkZ2VzW2pdWzFdKTtcbiAgICAgICAgICAgIGxpbmtzLnB1c2goe1xuICAgICAgICAgICAgICAgIHNvdXJjZTogbm9kZXNbbXlzcmNdLFxuICAgICAgICAgICAgICAgIHRhcmdldDogbm9kZXNbbXl0Z3RdLFxuICAgICAgICAgICAgICAgIGxlZnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmKGQzbV9tb2RlKSB7XG4gICAgICAgICAgICAvL25vZGVzID0gW2ZpbmROb2RlKG15dGFyZ2V0KV07ICAgICAgICAgICAgICAgLy8gT25seSBhZGQgZGVwZW5kZW50IHZhcmlhYmxlIG9uIHN0YXJ0dXBcbiAgICAgICAgICAgIG5vZGVzID0gYWxsTm9kZXMuc2xpY2UoMSxhbGxOb2Rlcy5sZW5ndGgpOyAgICAvLyBBZGQgYWxsIGJ1dCBmaXJzdCB2YXJpYWJsZSBvbiBzdGFydHVwIChhc3N1bWVzIDAgcG9zaXRpb24gaXMgZDNtIGluZGV4IHZhcmlhYmxlKVxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBub2Rlcy5sZW5ndGg7IGorKykgeyAvL3BvcHVsYXRlIHp2YXJzIGFycmF5XG4gICAgICAgICAgICAgICAgaWYgKG5vZGVzW2pdLm5hbWUgIT0gbXl0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXNbal0uZ3JvdXAxID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgenBhcmFtcy56Z3JvdXAxLnB1c2gobm9kZXNbal0ubmFtZSk7ICAvLyB3cml0ZSBhbGwgbmFtZXMgKGV4Y2VwdCBkM20gaW5kZXggYW5kIHRoZSBkZXBlbmRlbnQgdmFyaWFibGUpIHRvIHpncm91cDEgYXJyYXlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChhbGxOb2Rlcy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICBub2RlcyA9IFthbGxOb2Rlc1swXSwgYWxsTm9kZXNbMV0sIGFsbE5vZGVzWzJdXTtcbiAgICAgICAgICAgIGxpbmtzID0gW3tcbiAgICAgICAgICAgICAgICBzb3VyY2U6IG5vZGVzWzFdLFxuICAgICAgICAgICAgICAgIHRhcmdldDogbm9kZXNbMF0sXG4gICAgICAgICAgICAgICAgbGVmdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IHRydWVcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBzb3VyY2U6IG5vZGVzWzBdLFxuICAgICAgICAgICAgICAgIHRhcmdldDogbm9kZXNbMl0sXG4gICAgICAgICAgICAgICAgbGVmdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IHRydWVcbiAgICAgICAgICAgIH1dO1xuICAgICAgICB9IGVsc2UgaWYgKGFsbE5vZGVzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgbm9kZXMgPSBbYWxsTm9kZXNbMF0sIGFsbE5vZGVzWzFdXTtcbiAgICAgICAgICAgIGxpbmtzID0gW3tcbiAgICAgICAgICAgICAgICBzb3VyY2U6IG5vZGVzWzFdLFxuICAgICAgICAgICAgICAgIHRhcmdldDogbm9kZXNbMF0sXG4gICAgICAgICAgICAgICAgbGVmdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IHRydWVcbiAgICAgICAgICAgIH1dO1xuICAgICAgICB9IGVsc2UgaWYgKGFsbE5vZGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgbm9kZXMgPSBbYWxsTm9kZXNbMF1dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWxlcnQoXCJUaGVyZSBhcmUgemVybyB2YXJpYWJsZXMgaW4gdGhlIG1ldGFkYXRhLlwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHBhbmVsUGxvdHMoKTsgLy8gYWZ0ZXIgbm9kZXMgaXMgcG9wdWxhdGVkLCBhZGQgc3Vic2V0IGFuZCAoaWYgIWQzbV9tb2RlKSBzZXR4IHBhbmVsc1xuXG5cbiAgICB2YXIgZm9yY2UgPSBkMy5sYXlvdXQuZm9yY2UoKVxuICAgICAgICAubm9kZXMobm9kZXMpXG4gICAgICAgIC5saW5rcyhsaW5rcylcbiAgICAgICAgLnNpemUoW3dpZHRoLCBoZWlnaHRdKVxuICAgICAgICAubGlua0Rpc3RhbmNlKDE1MClcbiAgICAgICAgLmNoYXJnZSgtODAwKVxuICAgICAgICAub24oJ3RpY2snLCB0aWNrKTtcblxuICAgIC8vIGRlZmluZSBhcnJvdyBtYXJrZXJzIGZvciBncmFwaCBsaW5rc1xuICAgIHN2Zy5hcHBlbmQoJ3N2ZzpkZWZzJykuYXBwZW5kKCdzdmc6bWFya2VyJylcbiAgICAgICAgLmF0dHIoJ2lkJywgJ2VuZC1hcnJvdycpXG4gICAgICAgIC5hdHRyKCd2aWV3Qm94JywgJzAgLTUgMTAgMTAnKVxuICAgICAgICAuYXR0cigncmVmWCcsIDYpXG4gICAgICAgIC5hdHRyKCdtYXJrZXJXaWR0aCcsIDMpXG4gICAgICAgIC5hdHRyKCdtYXJrZXJIZWlnaHQnLCAzKVxuICAgICAgICAuYXR0cignb3JpZW50JywgJ2F1dG8nKVxuICAgICAgICAuYXBwZW5kKCdzdmc6cGF0aCcpXG4gICAgICAgIC5hdHRyKCdkJywgJ00wLC01TDEwLDBMMCw1JylcbiAgICAgICAgLnN0eWxlKCdmaWxsJywgJyMwMDAnKTtcblxuICAgIHN2Zy5hcHBlbmQoJ3N2ZzpkZWZzJykuYXBwZW5kKCdzdmc6bWFya2VyJylcbiAgICAgICAgLmF0dHIoJ2lkJywgJ3N0YXJ0LWFycm93JylcbiAgICAgICAgLmF0dHIoJ3ZpZXdCb3gnLCAnMCAtNSAxMCAxMCcpXG4gICAgICAgIC5hdHRyKCdyZWZYJywgNClcbiAgICAgICAgLmF0dHIoJ21hcmtlcldpZHRoJywgMylcbiAgICAgICAgLmF0dHIoJ21hcmtlckhlaWdodCcsIDMpXG4gICAgICAgIC5hdHRyKCdvcmllbnQnLCAnYXV0bycpXG4gICAgICAgIC5hcHBlbmQoJ3N2ZzpwYXRoJylcbiAgICAgICAgLmF0dHIoJ2QnLCAnTTEwLC01TDAsMEwxMCw1JylcbiAgICAgICAgLnN0eWxlKCdmaWxsJywgJyMwMDAnKTtcblxuICAgIC8vIGxpbmUgZGlzcGxheWVkIHdoZW4gZHJhZ2dpbmcgbmV3IG5vZGVzXG4gICAgdmFyIGRyYWdfbGluZSA9IHN2Zy5hcHBlbmQoJ3N2ZzpwYXRoJylcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2xpbmsgZHJhZ2xpbmUgaGlkZGVuJylcbiAgICAgICAgLmF0dHIoJ2QnLCAnTTAsMEwwLDAnKTtcblxuICAgIC8vIGhhbmRsZXMgdG8gbGluayBhbmQgbm9kZSBlbGVtZW50IGdyb3Vwc1xuICAgIHZhciBwYXRoID0gc3ZnLmFwcGVuZCgnc3ZnOmcnKS5zZWxlY3RBbGwoJ3BhdGgnKSxcbiAgICAgICAgY2lyY2xlID0gc3ZnLmFwcGVuZCgnc3ZnOmcnKS5zZWxlY3RBbGwoJ2cnKTtcbiAgICAgICAgLy9saW5lID0gc3ZnLmFwcGVuZCgnc3ZnOmcnKS5zZWxlY3RBbGwoJ2xpbmUnKTtcblxuICAgIC8vIG1vdXNlIGV2ZW50IHZhcnNcbiAgICB2YXIgc2VsZWN0ZWRfbm9kZSA9IG51bGwsXG4gICAgICAgIHNlbGVjdGVkX2xpbmsgPSBudWxsLFxuICAgICAgICBtb3VzZWRvd25fbGluayA9IG51bGwsXG4gICAgICAgIG1vdXNlZG93bl9ub2RlID0gbnVsbCxcbiAgICAgICAgbW91c2V1cF9ub2RlID0gbnVsbDtcblxuICAgIGZ1bmN0aW9uIHJlc2V0TW91c2VWYXJzKCkge1xuICAgICAgICBtb3VzZWRvd25fbm9kZSA9IG51bGw7XG4gICAgICAgIG1vdXNldXBfbm9kZSA9IG51bGw7XG4gICAgICAgIG1vdXNlZG93bl9saW5rID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgZm9yY2UgbGF5b3V0IChjYWxsZWQgYXV0b21hdGljYWxseSBlYWNoIGl0ZXJhdGlvbilcbiAgICBmdW5jdGlvbiB0aWNrKCkge1xuXG5cbiAgICAgICAgZnVuY3Rpb24gZmluZGNvb3JkcyhmaW5kbmFtZXMsYWxsbmFtZXMsY29vcmRzLGxlbmd0aGVuKXtcbiAgICAgICAgICAgIHZhciBmY29vcmRzID0gbmV3IEFycmF5KGZpbmRuYW1lcy5sZW5ndGgpOyAgIC8vIGZvdW5kIGNvb3JkaW5hdGVzXG4gICAgICAgICAgICB2YXIgYWRkbG9jYXRpb24gPSAwO1xuICAgICAgICAgICAgaWYoZmluZG5hbWVzLmxlbmd0aD4wKXtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGZpbmRuYW1lcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBhZGRsb2NhdGlvbiA9IGFsbG5hbWVzLmluZGV4T2YoZmluZG5hbWVzW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgZmNvb3Jkc1tqXSA9IGNvb3Jkc1thZGRsb2NhdGlvbl07XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmKGxlbmd0aGVuKXtcbiAgICAgICAgICAgICAgICAvLyBkMy5nZW9tLmh1bGwgcmV0dXJucyBudWxsIGZvciB0d28gcG9pbnRzLCBhbmQgZmFpbHMgaWYgdGhyZWUgcG9pbnRzIGFyZSBpbiBhIGxpbmUsXG4gICAgICAgICAgICAgICAgLy8gc28gdGhpcyBwdXRzIGEgY291cGxlIHBvaW50cyBzbGlnaHRseSBvZmYgdGhlIGxpbmUgZm9yIHR3byBwb2ludHMsIG9yIGFyb3VuZCBhIHNpbmdsZXRvbi5cbiAgICAgICAgICAgICAgICBpZiAoZmNvb3Jkcy5sZW5ndGggPT0gMil7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWx0YXggPSBmY29vcmRzWzBdWzBdLSBmY29vcmRzWzFdWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVsdGF5ID0gZmNvb3Jkc1swXVsxXS0gZmNvb3Jkc1sxXVsxXTtcbiAgICAgICAgICAgICAgICAgICAgZmNvb3Jkcy5wdXNoKFsoZmNvb3Jkc1swXVswXSArIGZjb29yZHNbMV1bMF0pLzIgKyBkZWx0YXkvMjAsIChmY29vcmRzWzBdWzFdKyBmY29vcmRzWzFdWzFdKS8yICsgZGVsdGF4LzIwXSk7XG4gICAgICAgICAgICAgICAgICAgIGZjb29yZHMucHVzaChbKGZjb29yZHNbMF1bMF0gKyBmY29vcmRzWzFdWzBdKS8yIC0gZGVsdGF5LzIwLCAoZmNvb3Jkc1swXVsxXSsgZmNvb3Jkc1sxXVsxXSkvMiAtIGRlbHRheC8yMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZmNvb3Jkcy5sZW5ndGggPT0gMSl7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWx0YSA9IGFsbFIgKiAwLjI7XG4gICAgICAgICAgICAgICAgICAgIGZjb29yZHMucHVzaChbZmNvb3Jkc1swXVswXSArIGRlbHRhLCBmY29vcmRzWzBdWzFdXSk7XG4gICAgICAgICAgICAgICAgICAgIGZjb29yZHMucHVzaChbZmNvb3Jkc1swXVswXSAtIGRlbHRhLCBmY29vcmRzWzBdWzFdXSk7XG4gICAgICAgICAgICAgICAgICAgIGZjb29yZHMucHVzaChbZmNvb3Jkc1swXVswXSwgZmNvb3Jkc1swXVsxXSArIGRlbHRhXSk7XG4gICAgICAgICAgICAgICAgICAgIGZjb29yZHMucHVzaChbZmNvb3Jkc1swXVswXSwgZmNvb3Jkc1swXVsxXSAtIGRlbHRhXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChmY29vcmRzKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBkMy5nZW9tLmh1bGwgcmV0dXJucyBudWxsIGZvciB0d28gcG9pbnRzLCBhbmQgZmFpbHMgaWYgdGhyZWUgcG9pbnRzIGFyZSBpbiBhIGxpbmUsXG4gICAgICAgIC8vIHNvIHRoaXMgcHV0cyBhIGNvdXBsZSBwb2ludHMgc2xpZ2h0bHkgb2ZmIHRoZSBsaW5lIGZvciB0d28gcG9pbnRzLCBvciBhcm91bmQgYSBzaW5nbGV0b24uXG4gICAgICAgIGZ1bmN0aW9uIGxlbmd0aGVuY29vcmRzKGNvb3Jkcyl7XG4gICAgICAgICAgICBpZiAoY29vcmRzLmxlbmd0aCA9PSAyKXtcbiAgICAgICAgICAgICAgICB2YXIgZGVsdGF4ID0gY29vcmRzWzBdWzBdLSBjb29yZHNbMV1bMF07XG4gICAgICAgICAgICAgICAgdmFyIGRlbHRheSA9IGNvb3Jkc1swXVsxXS0gY29vcmRzWzFdWzFdO1xuICAgICAgICAgICAgICAgIGNvb3Jkcy5wdXNoKFsoY29vcmRzWzBdWzBdICsgY29vcmRzWzFdWzBdKS8yICsgZGVsdGF5LzIwLCAoY29vcmRzWzBdWzFdKyBjb29yZHNbMV1bMV0pLzIgKyBkZWx0YXgvMjBdKTtcbiAgICAgICAgICAgICAgICBjb29yZHMucHVzaChbKGNvb3Jkc1swXVswXSArIGNvb3Jkc1sxXVswXSkvMiAtIGRlbHRheS8yMCwgKGNvb3Jkc1swXVsxXSsgY29vcmRzWzFdWzFdKS8yIC0gZGVsdGF4LzIwXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29vcmRzLmxlbmd0aCA9PSAxKXtcbiAgICAgICAgICAgICAgICB2YXIgZGVsdGEgPSBhbGxSICogMC4yO1xuICAgICAgICAgICAgICAgIGNvb3Jkcy5wdXNoKFtjb29yZHNbMF1bMF0gKyBkZWx0YSwgY29vcmRzWzBdWzFdXSk7XG4gICAgICAgICAgICAgICAgY29vcmRzLnB1c2goW2Nvb3Jkc1swXVswXSAtIGRlbHRhLCBjb29yZHNbMF1bMV1dKTtcbiAgICAgICAgICAgICAgICBjb29yZHMucHVzaChbY29vcmRzWzBdWzBdLCBjb29yZHNbMF1bMV0gKyBkZWx0YV0pO1xuICAgICAgICAgICAgICAgIGNvb3Jkcy5wdXNoKFtjb29yZHNbMF1bMF0sIGNvb3Jkc1swXVsxXSAtIGRlbHRhXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKGNvb3Jkcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGNvb3JkcyA9IG5vZGVzLm1hcChmdW5jdGlvbihkKSB7ICByZXR1cm4gWyBkLngsIGQueV07IH0pO1xuICAgICAgICB2YXIgZ3IxY29vcmRzID0gZmluZGNvb3Jkcyh6cGFyYW1zLnpncm91cDEsIHpwYXJhbXMuenZhcnMsIGNvb3JkcywgdHJ1ZSk7XG4gICAgICAgIHZhciBncjJjb29yZHMgPSBmaW5kY29vcmRzKHpwYXJhbXMuemdyb3VwMiwgenBhcmFtcy56dmFycywgY29vcmRzLCB0cnVlKTtcbiAgICAgICAgdmFyIGRlcGNvb3JkcyA9IGZpbmRjb29yZHMoenBhcmFtcy56ZHYsIHpwYXJhbXMuenZhcnMsIGNvb3JkcywgZmFsc2UpO1xuXG4gICAgICAgIC8vIGRyYXcgY29udmV4IGh1bGwgYXJvdW5kIGluZGVwZW5kZW50IHZhcmlhYmxlcywgaWYgdGhyZWUgb3IgbW9yZSBjb29yZGluYXRlcyBnaXZlblxuICAgICAgICAvLyBub3RlLCBkMy5nZW9tLmh1bGwgcmV0dXJucyBudWxsIGlmIHNob3J0ZXIgY29vcmRpbmF0ZSBzZXQgdGhhbiAzLFxuICAgICAgICAvLyBzbyBmaW5kY29vcmRzKCkgZnVuY3Rpb24gaGFzIG9wdGlvbiB0byBsZW5ndGhlbiB0aGUgY29vcmRpbmF0ZXMgcmV0dXJuZWQgdG8gYnlwYXNzIHRoaXNcbiAgICAgICAgaWYoZ3IxY29vcmRzLmxlbmd0aCA+IDIpe1xuICAgICAgICAgICAgbGluZS5zdHlsZShcIm9wYWNpdHlcIiwgMSk7XG4gICAgICAgICAgICB2aXNiYWNrZ3JvdW5kLnN0eWxlKFwib3BhY2l0eVwiLCAxKTtcbiAgICAgICAgICAgIHZpcy5zdHlsZShcIm9wYWNpdHlcIiwgMC4zKTtcbiAgICAgICAgICAgIHZhciBteWh1bGwgPSBkMy5nZW9tLmh1bGwoZ3IxY29vcmRzKTtcblxuICAgICAgICAgICAgdmlzLnNlbGVjdEFsbChcInBhdGhcIilcbiAgICAgICAgICAgICAgICAuZGF0YShbbXlodWxsXSkgICAvLyByZXR1cm5zIG51bGwgaWYgbGVzcyB0aGFuIHRocmVlIGNvb3JkaW5hdGVzXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJkXCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIFwiTVwiICsgZC5qb2luKFwiTFwiKSArIFwiWlwiOyB9KTtcbiAgICAgICAgICAgIHZpc2JhY2tncm91bmQuc2VsZWN0QWxsKFwicGF0aFwiKVxuICAgICAgICAgICAgICAgIC5kYXRhKFtteWh1bGxdKSAgIC8vIHJldHVybnMgbnVsbCBpZiBsZXNzIHRoYW4gdGhyZWUgY29vcmRpbmF0ZXNcbiAgICAgICAgICAgICAgICAuYXR0cihcImRcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gXCJNXCIgKyBkLmpvaW4oXCJMXCIpICsgXCJaXCI7IH0pO1xuXG4gICAgICAgICAgICAvL3ZhciBwID0gZDMuZ2VvbS5wb2x5Z29uKGluZGNvb3JkcykuY2VudHJvaWQoKTsgIC8vIFNlZW1zIHRvIGdvIHN0cmFuZ2Ugc29tZXRpbWVzXG4gICAgICAgICAgICB2YXIgcCA9IGphbWVzY2VudHJvaWQoZ3IxY29vcmRzKTtcblxuICAgICAgICAgICAgaWYoZGVwY29vcmRzLmxlbmd0aD4wKXtcbiAgICAgICAgICAgICAgICB2YXIgcSA9IGRlcGNvb3Jkc1swXTsgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90ZSwgb25seSB1c2luZyBmaXJzdCBkZXAgdmFyIGN1cnJlbnRseVxuICAgICAgICAgICAgICAgIC8vdmFyIHIgPSBmaW5kYm91bmRhcnkocCxxLGdyMWNvb3Jkcyk7ICAgICAgICAvLyBBbiBhcHByb2FjaCB0byBmaW5kIHRoZSBleGFjdCBib3VuZGFyeSwgbm90IHByZXNlbnRseSB3b3JraW5nXG4gICAgICAgICAgICAgICAgdmFyIGxkZWx0YVggPSBxWzBdIC0gcFswXSxcbiAgICAgICAgICAgICAgICAgICAgbGRlbHRhWSA9IHFbMV0gLSBwWzFdLFxuICAgICAgICAgICAgICAgICAgICBsZGlzdCA9IE1hdGguc3FydChsZGVsdGFYICogbGRlbHRhWCArIGxkZWx0YVkgKiBsZGVsdGFZKSxcbiAgICAgICAgICAgICAgICAgICAgbG5vcm1YID0gMCxcbiAgICAgICAgICAgICAgICAgICAgbG5vcm1ZID0gMCxcbiAgICAgICAgICAgICAgICAgICAgbHNvdXJjZVBhZGRpbmcgPSBhbGxSICsgNyxcbiAgICAgICAgICAgICAgICAgICAgbHRhcmdldFBhZGRpbmcgPSBhbGxSICsgMTA7XG5cbiAgICAgICAgICAgICAgICBpZiAobGRpc3QgPiAwKXtcbiAgICAgICAgICAgICAgICAgICAgbG5vcm1YID0gbGRlbHRhWCAvIGxkaXN0O1xuICAgICAgICAgICAgICAgICAgICBsbm9ybVkgPSBsZGVsdGFZIC8gbGRpc3Q7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGxpbmUuYXR0cihcIngxXCIsIHBbMF0gKyAobHNvdXJjZVBhZGRpbmcgKiBsbm9ybVgpKSAgIC8vIG9yIHJbMF0gaWYgZmluZGJvdW5kYXJ5IHdvcmtzXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieTFcIiwgcFsxXSArIChsc291cmNlUGFkZGluZyAqIGxub3JtWSkpICAgLy8gb3IgclsxXSBpZiBmaW5kYm91bmRhcnkgd29ya3NcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ4MlwiLCBxWzBdLSAobHRhcmdldFBhZGRpbmcgKiBsbm9ybVgpKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcInkyXCIsIHFbMV0tIChsdGFyZ2V0UGFkZGluZyAqIGxub3JtWSkpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gZ3JvdXAgbWVtYmVycyBhdHRyYWN0IGVhY2ggb3RoZXIsIHJlcHVsc2Ugbm9uLWdyb3VwIG1lbWJlcnNcbiAgICAgICAgICAgIG5vZGVzLmZvckVhY2gobiA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIHNpZ24gPSAobi5ncm91cDEpID8gMSA6IC0xOyAgICAvL3dhczogTWF0aC5zaWduKCB6cGFyYW1zLnpncm91cDEuaW5kZXhPZihuLm5hbWUpICswLjUgKTsgIC8vIDEgaWYgbiBpbiBncm91cCwgLTEgaWYgbiBub3QgaW4gZ3JvdXA7XG4gICAgICAgICAgICAgICAgdmFyIGxkZWx0YVggPSBwWzBdIC0gbi54LFxuICAgICAgICAgICAgICAgICAgICBsZGVsdGFZID0gcFsxXSAtIG4ueSxcbiAgICAgICAgICAgICAgICAgICAgbGRpc3QgPSBNYXRoLnNxcnQobGRlbHRhWCAqIGxkZWx0YVggKyBsZGVsdGFZICogbGRlbHRhWSk7XG4gICAgICAgICAgICAgICAgICAgIGxub3JtWCA9IDAsXG4gICAgICAgICAgICAgICAgICAgIGxub3JtWSA9IDA7XG5cbiAgICAgICAgICAgICAgICBpZiAobGRpc3QgPiAwKXtcbiAgICAgICAgICAgICAgICAgICAgbG5vcm1YID0gbGRlbHRhWCAvIGxkaXN0O1xuICAgICAgICAgICAgICAgICAgICBsbm9ybVkgPSBsZGVsdGFZIC8gbGRpc3Q7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIG4ueCArPSBNYXRoLm1pbihsbm9ybVggLCBsZGVsdGFYLzEwMCApICogayAqIHNpZ24gICAqIGZvcmNlLmFscGhhKCk7XG4gICAgICAgICAgICAgICAgbi55ICs9IE1hdGgubWluKGxub3JtWSAsIGxkZWx0YVkvMTAwICkgKiBrICogc2lnbiAgICogZm9yY2UuYWxwaGEoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgdmlzYmFja2dyb3VuZC5zdHlsZShcIm9wYWNpdHlcIiwgMCk7XG5cbiAgICAgICAgICAgIHZpcy5zdHlsZShcIm9wYWNpdHlcIiwgMCk7XG4vLyAgICAgICAgICAgIHZpcy5zdHlsZShcIm9wYWNpdHlcIiwgMCk7XG4gICAgICAgICAgICBsaW5lLnN0eWxlKFwib3BhY2l0eVwiLCAwKTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZihncjJjb29yZHMubGVuZ3RoID4gMil7XG4gICAgICAgICAgICBsaW5lMi5zdHlsZShcIm9wYWNpdHlcIiwgMSk7XG4gICAgICAgICAgICB2aXMyYmFja2dyb3VuZC5zdHlsZShcIm9wYWNpdHlcIiwgMSk7XG4gICAgICAgICAgICB2aXMyLnN0eWxlKFwib3BhY2l0eVwiLCAwLjMpO1xuICAgICAgICAgICAgdmFyIG15aHVsbCA9IGQzLmdlb20uaHVsbChncjJjb29yZHMpO1xuICAgICAgICAgICAgdmlzMi5zZWxlY3RBbGwoXCJwYXRoXCIpXG4gICAgICAgICAgICAgICAgLmRhdGEoW215aHVsbF0pICAgLy8gcmV0dXJucyBudWxsIGlmIGxlc3MgdGhhbiB0aHJlZSBjb29yZGluYXRlc1xuICAgICAgICAgICAgICAgIC5hdHRyKFwiZFwiLCBmdW5jdGlvbihkKSB7IHJldHVybiBcIk1cIiArIGQuam9pbihcIkxcIikgKyBcIlpcIjsgfSk7XG4gICAgICAgICAgICB2aXMyYmFja2dyb3VuZC5zZWxlY3RBbGwoXCJwYXRoXCIpXG4gICAgICAgICAgICAgICAgLmRhdGEoW215aHVsbF0pICAgLy8gcmV0dXJucyBudWxsIGlmIGxlc3MgdGhhbiB0aHJlZSBjb29yZGluYXRlc1xuICAgICAgICAgICAgICAgIC5hdHRyKFwiZFwiLCBmdW5jdGlvbihkKSB7IHJldHVybiBcIk1cIiArIGQuam9pbihcIkxcIikgKyBcIlpcIjsgfSk7XG5cbiAgICAgICAgICAgIC8vdmFyIHAgPSBkMy5nZW9tLnBvbHlnb24oaW5kY29vcmRzKS5jZW50cm9pZCgpOyAgLy8gU2VlbXMgdG8gZ28gc3RyYW5nZSBzb21ldGltZXNcbiAgICAgICAgICAgIHZhciBwID0gamFtZXNjZW50cm9pZChncjJjb29yZHMpO1xuXG4gICAgICAgICAgICBpZihkZXBjb29yZHMubGVuZ3RoPjApe1xuICAgICAgICAgICAgICAgIHZhciBxID0gZGVwY29vcmRzWzBdOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90ZSwgb25seSB1c2luZyBmaXJzdCBkZXAgdmFyIGN1cnJlbnRseVxuICAgICAgICAgICAgICAgIHZhciBsZGVsdGFYID0gcVswXSAtIHBbMF0sXG4gICAgICAgICAgICAgICAgICAgIGxkZWx0YVkgPSBxWzFdIC0gcFsxXSxcbiAgICAgICAgICAgICAgICAgICAgbGRpc3QgPSBNYXRoLnNxcnQobGRlbHRhWCAqIGxkZWx0YVggKyBsZGVsdGFZICogbGRlbHRhWSksXG4gICAgICAgICAgICAgICAgICAgIGxub3JtWCA9IGxkZWx0YVggLyBsZGlzdCxcbiAgICAgICAgICAgICAgICAgICAgbG5vcm1ZID0gbGRlbHRhWSAvIGxkaXN0LFxuICAgICAgICAgICAgICAgICAgICBsc291cmNlUGFkZGluZyA9IGFsbFIgKyA3LFxuICAgICAgICAgICAgICAgICAgICBsdGFyZ2V0UGFkZGluZyA9IGFsbFIgKyAxMDtcblxuICAgICAgICAgICAgICAgIGxpbmUyLmF0dHIoXCJ4MVwiLCBwWzBdICsgKGxzb3VyY2VQYWRkaW5nICogbG5vcm1YKSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ5MVwiLCBwWzFdICsgKGxzb3VyY2VQYWRkaW5nICogbG5vcm1ZKSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ4MlwiLCBxWzBdLSAobHRhcmdldFBhZGRpbmcgKiBsbm9ybVgpKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcInkyXCIsIHFbMV0tIChsdGFyZ2V0UGFkZGluZyAqIGxub3JtWSkpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gZ3JvdXAgbWVtYmVycyBhdHRyYWN0IGVhY2ggb3RoZXIsIHJlcHVsc2Ugbm9uLWdyb3VwIG1lbWJlcnNcbiAgICAgICAgICAgIG5vZGVzLmZvckVhY2gobiA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIHNpZ24gPSAobi5ncm91cDIpID8gMSA6IC0xOyAgLy8gd2FzOiBNYXRoLnNpZ24oIHpwYXJhbXMuemdyb3VwMi5pbmRleE9mKG4ubmFtZSkgKzAuNSApOyAgLy8gMSBpZiBuIGluIGdyb3VwLCAtMSBpZiBuIG5vdCBpbiBncm91cDtcbiAgICAgICAgICAgICAgICB2YXIgbGRlbHRhWCA9IHBbMF0gLSBuLngsXG4gICAgICAgICAgICAgICAgICAgIGxkZWx0YVkgPSBwWzFdIC0gbi55LFxuICAgICAgICAgICAgICAgICAgICBsZGlzdCA9IE1hdGguc3FydChsZGVsdGFYICogbGRlbHRhWCArIGxkZWx0YVkgKiBsZGVsdGFZKSxcbiAgICAgICAgICAgICAgICAgICAgbG5vcm1YID0gMCxcbiAgICAgICAgICAgICAgICAgICAgbG5vcm1ZID0gMDtcblxuICAgICAgICAgICAgICAgIGlmIChsZGlzdCA+IDApe1xuICAgICAgICAgICAgICAgICAgICBsbm9ybVggPSBsZGVsdGFYIC8gbGRpc3Q7XG4gICAgICAgICAgICAgICAgICAgIGxub3JtWSA9IGxkZWx0YVkgLyBsZGlzdDtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgbi54ICs9IE1hdGgubWluKGxub3JtWCAsIGxkZWx0YVgvMTAwICkgKiBrICogc2lnbiAgICogZm9yY2UuYWxwaGEoKTtcbiAgICAgICAgICAgICAgICBuLnkgKz0gTWF0aC5taW4obG5vcm1ZICwgbGRlbHRhWS8xMDAgKSAqIGsgKiBzaWduICAgKiBmb3JjZS5hbHBoYSgpO1xuICAgICAgICAgICAgfSk7XG5cblxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHZpczJiYWNrZ3JvdW5kLnN0eWxlKFwib3BhY2l0eVwiLCAwKTtcbiAgICAgICAgICAgIHZpczIuc3R5bGUoXCJvcGFjaXR5XCIsIDApO1xuICAgICAgICAgICAgbGluZTIuc3R5bGUoXCJvcGFjaXR5XCIsIDApO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGRyYXcgZGlyZWN0ZWQgZWRnZXMgd2l0aCBwcm9wZXIgcGFkZGluZyBmcm9tIG5vZGUgY2VudGVyc1xuICAgICAgICBwYXRoLmF0dHIoJ2QnLCBkID0+IHtcbiAgICAgICAgICAgIHZhciBkZWx0YVggPSBkLnRhcmdldC54IC0gZC5zb3VyY2UueCxcbiAgICAgICAgICAgICAgICBkZWx0YVkgPSBkLnRhcmdldC55IC0gZC5zb3VyY2UueSxcbiAgICAgICAgICAgICAgICBkaXN0ID0gTWF0aC5zcXJ0KGRlbHRhWCAqIGRlbHRhWCArIGRlbHRhWSAqIGRlbHRhWSksXG4gICAgICAgICAgICAgICAgbm9ybVggPSBkZWx0YVggLyBkaXN0LFxuICAgICAgICAgICAgICAgIG5vcm1ZID0gZGVsdGFZIC8gZGlzdCxcbiAgICAgICAgICAgICAgICBzb3VyY2VQYWRkaW5nID0gZC5sZWZ0ID8gYWxsUiArIDUgOiBhbGxSLFxuICAgICAgICAgICAgICAgIHRhcmdldFBhZGRpbmcgPSBkLnJpZ2h0ID8gYWxsUiArIDUgOiBhbGxSLFxuICAgICAgICAgICAgICAgIHNvdXJjZVggPSBkLnNvdXJjZS54ICsgKHNvdXJjZVBhZGRpbmcgKiBub3JtWCksXG4gICAgICAgICAgICAgICAgc291cmNlWSA9IGQuc291cmNlLnkgKyAoc291cmNlUGFkZGluZyAqIG5vcm1ZKSxcbiAgICAgICAgICAgICAgICB0YXJnZXRYID0gZC50YXJnZXQueCAtICh0YXJnZXRQYWRkaW5nICogbm9ybVgpLFxuICAgICAgICAgICAgICAgIHRhcmdldFkgPSBkLnRhcmdldC55IC0gKHRhcmdldFBhZGRpbmcgKiBub3JtWSk7XG4gICAgICAgICAgICByZXR1cm4gYE0ke3NvdXJjZVh9LCR7c291cmNlWX1MJHt0YXJnZXRYfSwke3RhcmdldFl9YDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY2lyY2xlLmF0dHIoJ3RyYW5zZm9ybScsIGQgPT4gJ3RyYW5zbGF0ZSgnICsgZC54ICsgJywnICsgZC55ICsgJyknKTtcblxuICAgICAgICBjaXJjbGUuc2VsZWN0QWxsKCdjaXJjbGUnKSAgICAgICAgICAgLy8gU2hyaW5rL2V4cGFuZCBwZWJibGVzIHRoYXQgam9pbi9sZWF2ZSBncm91cHNcbiAgICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgIC5kdXJhdGlvbigxMDApXG4gICAgICAgICAgICAuYXR0cigncicsIGQgPT4gc2V0UGViYmxlUmFkaXVzKGQpKTtcblxuICAgIH1cblxuICAgIGNsaWNrVmFyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIGV2ZXJ5IHRpbWUgYSB2YXJpYWJsZSBpbiBsZWZ0cGFuZWwgaXMgY2xpY2tlZCwgbm9kZXMgdXBkYXRlcyBhbmQgYmFja2dyb3VuZCBjb2xvciBjaGFuZ2VzXG4gICAgICAgIGlmIChmaW5kTm9kZUluZGV4KHRoaXMuaWQsIHRydWUpLmdyYXlvdXQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHpwYXJhbXMuenZhcnMgPSBbXTtcbiAgICAgICAgbGV0IHRleHQgPSBkMy5zZWxlY3QodGhpcykudGV4dCgpO1xuICAgICAgICBsZXQgbm9kZSA9IGZpbmROb2RlKHRleHQpO1xuICAgICAgICBpZiAobm9kZXMubWFwKG4gPT4gbi5uYW1lKS5pbmNsdWRlcyh0ZXh0KSkge1xuICAgICAgICAgICAgbm9kZXMuc3BsaWNlKG5vZGUuaW5kZXgsIDEpO1xuICAgICAgICAgICAgc3BsaWNlTGlua3NGb3JOb2RlKG5vZGUpO1xuICAgICAgICAgICAgc3BsaWNlKG5vZGUuc3Ryb2tlQ29sb3IsIHRleHQsIFtkdkNvbG9yLCAnemR2J10sIFtjc0NvbG9yLCAnemNyb3NzJ10sIFt0aW1lQ29sb3IsICd6dGltZSddLCBbbm9tQ29sb3IsICd6bm9tJ10pO1xuXG4gICAgICAgICAgICBpZihub2RlLmdyb3VwMSl7ICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBub2RlIG5hbWUgZnJvbSBncm91cCBsaXN0cyAoc2hvdWxkIHVzZSBhZGFwdGF0aW9uIG9mIHNwbGljZS1ieS1jb2xvcilcbiAgICAgICAgICAgICAgICBub2RlLmdyb3VwMSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHpwYXJhbXMuemdyb3VwMS5zcGxpY2UoenBhcmFtcy56Z3JvdXAxLmluZGV4T2Yobm9kZS5uYW1lKSwxKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZihub2RlLmdyb3VwMil7XG4gICAgICAgICAgICAgICAgbm9kZS5ncm91cDIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB6cGFyYW1zLnpncm91cDIuc3BsaWNlKHpwYXJhbXMuemdyb3VwMi5pbmRleE9mKG5vZGUubmFtZSksMSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBub2RlUmVzZXQobm9kZSk7XG4gICAgICAgICAgICBsZWdlbmQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICBpZiAobm9kZXMubGVuZ3RoID09PSAwKSBub2Rlc1swXS5yZWZsZXhpdmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHpwYXJhbXMuenZhcnMgPSBub2Rlcy5tYXAobiA9PiBuLm5hbWUpICAgIC8vIGFkZGluZyB0aGlzIHRvIGtlZXAgaXQgY3VycmVudCAob3Igc2hvdWxkIHdlIHJlbHkgb24gbm9kZXMubWFwKG4gPT4gbi5uYW1lKSBmb3IgdmFyaWFibGUgbGlzdD8pXG4gICAgICAgIHBhbmVsUGxvdHMoKTtcbiAgICAgICAgcmVzdGFydCgpO1xuICAgIH1cblxuICAgIGQzLnNlbGVjdChcIiNtb2RlbHNcIikuc2VsZWN0QWxsKFwicFwiKSAvLyBtb2RlbHMgdGFiXG4gICAgICAgIC8vICBkMy5zZWxlY3QoXCIjRGlzcGxheV9jb250ZW50XCIpXG4gICAgICAgIC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIG15Q29sb3IgPSBkMy5zZWxlY3QodGhpcykuc3R5bGUoJ2JhY2tncm91bmQtY29sb3InKTtcbiAgICAgICAgICAgIGQzLnNlbGVjdChcIiNtb2RlbHNcIikuc2VsZWN0QWxsKFwicFwiKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnYmFja2dyb3VuZC1jb2xvcicsIHZhckNvbG9yKTtcbiAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnYmFja2dyb3VuZC1jb2xvcicsIGQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZDMucmdiKG15Q29sb3IpLnRvU3RyaW5nKCkgPT09IHZhckNvbG9yLnRvU3RyaW5nKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHpwYXJhbXMuem1vZGVsID0gZC50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhleFRvUmdiYShzZWxWYXJDb2xvcik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB6cGFyYW1zLnptb2RlbCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhckNvbG9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXN0YXJ0KCk7XG4gICAgICAgIH0pO1xuXG4gICAgZDMuc2VsZWN0KFwiI3R5cGVzXCIpLnNlbGVjdEFsbChcInBcIikgLy8gbW9kZWxzIHRhYlxuICAgIC8vICBkMy5zZWxlY3QoXCIjRGlzcGxheV9jb250ZW50XCIpXG4gICAgLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmKGxvY2t0b2dnbGUpIHJldHVybjtcbiAgICAgICAgaWYodGhpcy5jbGFzc05hbWU9PVwiaXRlbS1zZWxlY3RcIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZDMuc2VsZWN0KFwiI3R5cGVzXCIpLnNlbGVjdChcInAuaXRlbS1zZWxlY3RcIilcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdpdGVtLWRlZmF1bHQnKTtcbiAgICAgICAgICAgIGQzbVByb2JsZW1EZXNjcmlwdGlvbi50YXNrVHlwZSA9IHRoaXMuaW5uZXJIVE1MLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuYXR0cignY2xhc3MnLFwiaXRlbS1zZWxlY3RcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdGFydCgpO1xuICAgICAgICB1cGRhdGVTY2hlbWEoXCJ0YXNrVHlwZVwiLCBkM21Qcm9ibGVtRGVzY3JpcHRpb24sIGQzbVRhc2tUeXBlKTtcbiAgICAgICAgfSk7XG5cbiAgICBkMy5zZWxlY3QoXCIjc3VidHlwZXNcIikuc2VsZWN0QWxsKFwicFwiKVxuICAgIC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZihsb2NrdG9nZ2xlKSByZXR1cm47XG4gICAgICAgIGlmKHRoaXMuY2xhc3NOYW1lPT1cIml0ZW0tc2VsZWN0XCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGQzLnNlbGVjdChcIiNzdWJ0eXBlc1wiKS5zZWxlY3QoXCJwLml0ZW0tc2VsZWN0XCIpXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnaXRlbS1kZWZhdWx0Jyk7XG4gICAgICAgICAgICBkM21Qcm9ibGVtRGVzY3JpcHRpb24udGFza1N1YnR5cGUgPSB0aGlzLmlubmVySFRNTC50b1N0cmluZygpO1xuICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmF0dHIoJ2NsYXNzJyxcIml0ZW0tc2VsZWN0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3RhcnQoKTtcbiAgICAgICAgdXBkYXRlU2NoZW1hKFwidGFza1N1YnR5cGVcIiwgZDNtUHJvYmxlbURlc2NyaXB0aW9uLCBkM21UYXNrU3VidHlwZSk7XG4gICAgICAgIH0pO1xuXG4gICAgZDMuc2VsZWN0KFwiI21ldHJpY3NcIikuc2VsZWN0QWxsKFwicFwiKVxuICAgIC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZihsb2NrdG9nZ2xlKSByZXR1cm47XG4gICAgICAgIGlmKHRoaXMuY2xhc3NOYW1lPT1cIml0ZW0tc2VsZWN0XCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgIC8vICAgICAgICAgZDNtUHJvYmxlbURlc2NyaXB0aW9uLm1ldHJpYyA9IFtcIlwiLFwiXCJdO1xuICAgIC8vICAgICAgICB0aGlzLmNsYXNzTmFtZT1cIml0ZW0tZGVmYXVsdFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZDMuc2VsZWN0KFwiI21ldHJpY3NcIikuc2VsZWN0KFwicC5pdGVtLXNlbGVjdFwiKVxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2l0ZW0tZGVmYXVsdCcpO1xuICAgICAgICAgICAgZDNtUHJvYmxlbURlc2NyaXB0aW9uLm1ldHJpYyA9IHRoaXMuaW5uZXJIVE1MLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuYXR0cignY2xhc3MnLFwiaXRlbS1zZWxlY3RcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdGFydCgpO1xuICAgICAgICB1cGRhdGVTY2hlbWEoXCJtZXRyaWNcIiwgZDNtUHJvYmxlbURlc2NyaXB0aW9uLCBkM21NZXRyaWNzKTtcbiAgICAgICAgfSk7XG5cbiAgICBkMy5zZWxlY3QoXCIjb3V0cHV0c1wiKS5zZWxlY3RBbGwoXCJwXCIpXG4gICAgLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmKGxvY2t0b2dnbGUpIHJldHVybjtcbiAgICAgICAgaWYodGhpcy5jbGFzc05hbWU9PVwiaXRlbS1zZWxlY3RcIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZDMuc2VsZWN0KFwiI291dHB1dHNcIikuc2VsZWN0KFwicC5pdGVtLXNlbGVjdFwiKVxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2l0ZW0tZGVmYXVsdCcpO1xuICAgICAgICAgICAgZDNtUHJvYmxlbURlc2NyaXB0aW9uLm91dHB1dFR5cGUgPSB0aGlzLmlubmVySFRNTC50b1N0cmluZygpO1xuICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmF0dHIoJ2NsYXNzJyxcIml0ZW0tc2VsZWN0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3RhcnQoKTtcbiAgICAgICAgdXBkYXRlU2NoZW1hKFwib3V0cHV0VHlwZVwiLCBkM21Qcm9ibGVtRGVzY3JpcHRpb24sIGQzbU91dHB1dFR5cGUpO1xuICAgICAgICB9KTtcblxuICAgIC8vIHVwZGF0ZSBncmFwaCAoY2FsbGVkIHdoZW4gbmVlZGVkKVxuICAgIGZ1bmN0aW9uIHJlc3RhcnQoKSB7XG4gICAgICAgIC8vIG5vZGVzLmlkIGlzIHBlZ2dlZCB0byBhbGxOb2RlcywgaS5lLiB0aGUgb3JkZXIgaW4gd2hpY2ggdmFyaWFibGVzIGFyZSByZWFkIGluXG4gICAgICAgIC8vIG5vZGVzLmluZGV4IGlzIGZsb2F0aW5nIGFuZCBkZXBlbmRzIG9uIHVwZGF0ZXMgdG8gbm9kZXMuICBhIHZhcmlhYmxlcyBpbmRleCBjaGFuZ2VzIHdoZW4gbmV3IHZhcmlhYmxlcyBhcmUgYWRkZWQuXG4gICAgICAgIGNpcmNsZS5jYWxsKGZvcmNlLmRyYWcpO1xuICAgICAgICBpZiAoZm9yY2V0b2dnbGVbMF0gPT0gXCJ0cnVlXCIpIHtcbiAgICAgICAgICAgIGZvcmNlLmdyYXZpdHkoMC4xKTtcbiAgICAgICAgICAgIGZvcmNlLmNoYXJnZShkID0+IHNldFBlYmJsZUNoYXJnZShkKSk7XG4gICAgICAgICAgICBmb3JjZS5zdGFydCgpO1xuICAgICAgICAgICAgZm9yY2UubGlua1N0cmVuZ3RoKDEpO1xuICAgICAgICAgICAgayA9IDQ7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdHJlbmd0aCBwYXJhbWV0ZXIgZm9yIGdyb3VwIGF0dHJhY3Rpb24vcmVwdWxzaW9uXG4gICAgICAgICAgICBpZigoenBhcmFtcy56Z3JvdXAxLmxlbmd0aCA+IDApICYgKHpwYXJhbXMuemdyb3VwMi5sZW5ndGggPiAwICkpeyAgLy8gc2NhbGUgZG93biBieSBudW1iZXIgb2YgYWN0aXZlIGdyb3Vwc1xuICAgICAgICAgICAgICAgIGsgPSAyLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3JjZS5ncmF2aXR5KDApO1xuICAgICAgICAgICAgZm9yY2UuY2hhcmdlKDApO1xuICAgICAgICAgICAgZm9yY2UubGlua1N0cmVuZ3RoKDApO1xuICAgICAgICAgICAgayA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yY2UucmVzdW1lKCk7XG5cbiAgICAgICAgLy8gcGF0aCAobGluaykgZ3JvdXBcbiAgICAgICAgcGF0aCA9IHBhdGguZGF0YShsaW5rcyk7XG5cbiAgICAgICAgLy8gdXBkYXRlIGV4aXN0aW5nIGxpbmtzXG4gICAgICAgIC8vIFZKRDogZGFzaGVkIGxpbmtzIGJldHdlZW4gcGViYmxlcyBhcmUgXCJzZWxlY3RlZFwiLiB0aGlzIGlzIGRpc2FibGVkIGZvciBub3dcbiAgICAgICAgcGF0aC5jbGFzc2VkKCdzZWxlY3RlZCcsIHggPT4gbnVsbClcbiAgICAgICAgICAgIC5zdHlsZSgnbWFya2VyLXN0YXJ0JywgeCA9PiB4LmxlZnQgPyAndXJsKCNzdGFydC1hcnJvdyknIDogJycpXG4gICAgICAgICAgICAuc3R5bGUoJ21hcmtlci1lbmQnLCB4ID0+IHgucmlnaHQgPyAndXJsKCNlbmQtYXJyb3cpJyA6ICcnKTtcblxuICAgICAgICAvLyBhZGQgbmV3IGxpbmtzXG4gICAgICAgIHBhdGguZW50ZXIoKS5hcHBlbmQoJ3N2ZzpwYXRoJylcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdsaW5rJylcbiAgICAgICAgICAgIC5jbGFzc2VkKCdzZWxlY3RlZCcsIHggPT4gbnVsbClcbiAgICAgICAgICAgIC5zdHlsZSgnbWFya2VyLXN0YXJ0JywgeCA9PiB4LmxlZnQgPyAndXJsKCNzdGFydC1hcnJvdyknIDogJycpXG4gICAgICAgICAgICAuc3R5bGUoJ21hcmtlci1lbmQnLCB4ID0+IHgucmlnaHQgPyAndXJsKCNlbmQtYXJyb3cpJyA6ICcnKVxuICAgICAgICAgICAgLm9uKCdtb3VzZWRvd24nLCBmdW5jdGlvbihkKSB7IC8vIGRvIHdlIGV2ZXIgbmVlZCB0byBzZWxlY3QgYSBsaW5rPyBtYWtlIGl0IGRlbGV0ZS4uXG4gICAgICAgICAgICAgICAgdmFyIG9iaiA9IEpTT04uc3RyaW5naWZ5KGQpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGlua3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9iaiA9PT0gSlNPTi5zdHJpbmdpZnkobGlua3Nbal0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua3Muc3BsaWNlKGosIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHJlbW92ZSBvbGQgbGlua3NcbiAgICAgICAgcGF0aC5leGl0KCkucmVtb3ZlKCk7XG5cbiAgICAgICAgLy8gY2lyY2xlIChub2RlKSBncm91cFxuICAgICAgICBjaXJjbGUgPSBjaXJjbGUuZGF0YShub2RlcywgeCA9PiB4LmlkKTtcblxuICAgICAgICAvLyB1cGRhdGUgZXhpc3Rpbmcgbm9kZXMgKHJlZmxleGl2ZSAmIHNlbGVjdGVkIHZpc3VhbCBzdGF0ZXMpXG4gICAgICAgIC8vIGQzLnJnYiBpcyB0aGUgZnVuY3Rpb24gYWRqdXN0aW5nIHRoZSBjb2xvciBoZXJlXG4gICAgICAgIGNpcmNsZS5zZWxlY3RBbGwoJ2NpcmNsZScpXG4gICAgICAgICAgICAuY2xhc3NlZCgncmVmbGV4aXZlJywgeCA9PiB4LnJlZmxleGl2ZSlcbiAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIHggPT4gZDMucmdiKHgubm9kZUNvbCkpXG4gICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsIHggPT4gZDMucmdiKHguc3Ryb2tlQ29sb3IpKVxuICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLCB4ID0+IHguc3Ryb2tlV2lkdGgpO1xuXG4gICAgICAgIC8vIGFkZCBuZXcgbm9kZXNcbiAgICAgICAgbGV0IGcgPSBjaXJjbGUuZW50ZXIoKVxuICAgICAgICAgICAgLmFwcGVuZCgnc3ZnOmcnKVxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgeCA9PiB4Lm5hbWUgKyAnYmlnZ3JvdXAnKTtcblxuICAgICAgICAvLyBhZGQgcGxvdFxuICAgICAgICBnLmVhY2goZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpO1xuICAgICAgICAgICAgaWYgKGQucGxvdHR5cGUgPT0gJ2NvbnRpbnVvdXMnKSBkZW5zaXR5Tm9kZShkLCB0aGlzKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGQucGxvdHR5cGUgPT0gJ2JhcicpIGJhcnNOb2RlKGQsIHRoaXMpO1xuICAgICAgICB9KTtcblxuICAgICAgICBsZXQgYXBwZW5kID0gKHN0ciwgYXR0cikgPT4geCA9PiBzdHIgKyB4W2F0dHIgfHwgJ2lkJ107XG5cbiAgICAgICAgZy5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsIGFwcGVuZCgnZHZBcmMnKSlcbiAgICAgICAgICAgIC5hdHRyKFwiZFwiLCBhcmMzKVxuICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBkdkNvbG9yKVxuICAgICAgICAgICAgLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIGZpbGxUaGlzKHRoaXMsIC4zLCAwLCAxMDApO1xuICAgICAgICAgICAgICAgIGZpbGwoZCwgJ2R2VGV4dCcsIC45LCAwLCAxMDApO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgZmlsbFRoaXModGhpcywgMCwgMTAwLCA1MDApO1xuICAgICAgICAgICAgICAgIGZpbGwoZCwgJ2R2VGV4dCcsIDAsIDEwMCwgNTAwKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ2NsaWNrJywgZCA9PiB7XG4gICAgICAgICAgICAgICAgc2V0Q29sb3JzKGQsIGR2Q29sb3IpO1xuICAgICAgICAgICAgICAgIGxlZ2VuZChkdkNvbG9yKTtcbiAgICAgICAgICAgICAgICByZXN0YXJ0KCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgYXBwZW5kKCdkdlRleHQnKSlcbiAgICAgICAgICAgIC5hdHRyKFwieFwiLCA2KVxuICAgICAgICAgICAgLmF0dHIoXCJkeVwiLCAxMS41KVxuICAgICAgICAgICAgLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgIC5hcHBlbmQoXCJ0ZXh0UGF0aFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ4bGluazpocmVmXCIsIGFwcGVuZCgnI2R2QXJjJykpXG4gICAgICAgICAgICAudGV4dChcIkRlcCBWYXJcIik7XG5cbiAgICAgICAgZy5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsIGFwcGVuZCgnbm9tQXJjJykpXG4gICAgICAgICAgICAuYXR0cihcImRcIiwgYXJjNClcbiAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgbm9tQ29sb3IpXG4gICAgICAgICAgICAuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGQuZGVmYXVsdE51bWNoYXIgPT0gXCJjaGFyYWN0ZXJcIikgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGZpbGxUaGlzKHRoaXMsIC4zLCAwLCAxMDApO1xuICAgICAgICAgICAgICAgIGZpbGwoZCwgXCJub21UZXh0XCIsIC45LCAwLCAxMDApO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGQuZGVmYXVsdE51bWNoYXIgPT0gXCJjaGFyYWN0ZXJcIikgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGZpbGxUaGlzKHRoaXMsIDAsIDEwMCwgNTAwKTtcbiAgICAgICAgICAgICAgICBmaWxsKGQsIFwibm9tVGV4dFwiLCAwLCAxMDAsIDUwMCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdjbGljaycsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZC5kZWZhdWx0TnVtY2hhciA9PSBcImNoYXJhY3RlclwiKSByZXR1cm47XG4gICAgICAgICAgICAgICAgc2V0Q29sb3JzKGQsIG5vbUNvbG9yKTtcbiAgICAgICAgICAgICAgICBsZWdlbmQobm9tQ29sb3IpO1xuICAgICAgICAgICAgICAgIHJlc3RhcnQoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIGcuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBhcHBlbmQoXCJub21UZXh0XCIpKVxuICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIDYpXG4gICAgICAgICAgICAuYXR0cihcImR5XCIsIDExLjUpXG4gICAgICAgICAgICAuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgLmFwcGVuZChcInRleHRQYXRoXCIpXG4gICAgICAgICAgICAuYXR0cihcInhsaW5rOmhyZWZcIiwgYXBwZW5kKFwiI25vbUFyY1wiKSlcbiAgICAgICAgICAgIC50ZXh0KFwiTm9taW5hbFwiKTtcblxuICAgICAgICBnLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgYXBwZW5kKCdnckFyYycpKVxuICAgICAgICAgICAgLmF0dHIoXCJkXCIsIGFyYzEpXG4gICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsICBncjFDb2xvcilcbiAgICAgICAgICAgIC5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICBmaWxsKGQsIFwiZ3IxaW5kaWNhdG9yXCIsIC4zLCAwLCAxMDApO1xuICAgICAgICAgICAgICAgIGZpbGwoZCwgXCJncjJpbmRpY2F0b3JcIiwgLjMsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgZmlsbFRoaXModGhpcywgLjMsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgZmlsbChkLCAnZ3JUZXh0JywgLjksIDAsIDEwMCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICBmaWxsKGQsIFwiZ3IxaW5kaWNhdG9yXCIsIDAsIDEwMCwgNTAwKTtcbiAgICAgICAgICAgICAgICBmaWxsKGQsIFwiZ3IyaW5kaWNhdG9yXCIsIDAsIDEwMCwgNTAwKTtcbiAgICAgICAgICAgICAgICBmaWxsVGhpcyh0aGlzLCAwLCAxMDAsIDUwMCk7XG4gICAgICAgICAgICAgICAgZmlsbChkLCAnZ3JUZXh0JywgMCwgMTAwLCA1MDApO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignY2xpY2snLCBkID0+IHtcbiAgICAgICAgICAgICAgICAvL2QuZ3JvdXAxID0gIWQuZ3JvdXAxOyAgICAgIC8vIFRoaXMgbWlnaHQgYmUgZWFzaWVyLCBidXQgY3VycmVudGx5IHNldCBpbiBzZXRDb2xvcnMoKVxuICAgICAgICAgICAgICAgIHNldENvbG9ycyhkLCBncjFDb2xvcik7XG4gICAgICAgICAgICAgICAgbGVnZW5kKGdyMUNvbG9yKTtcbiAgICAgICAgICAgICAgICByZXN0YXJ0KCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBnLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgYXBwZW5kKCdncjFpbmRpY2F0b3InKSlcbiAgICAgICAgICAgIC5hdHRyKFwiZFwiLCBhcmNJbmQxKVxuICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBncjFDb2xvcikgIC8vIHNvbWV0aGluZyBsaWtlOiB6cGFyYW1zLnpncm91cDEuaW5kZXhPZihub2RlLm5hbWUpID4gLTEgID8gICNGRkZGRkYgOiBncjFDb2xvcilcbiAgICAgICAgICAgIC5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICBmaWxsVGhpcyh0aGlzLCAuMywgMCwgMTAwKTtcbiAgICAgICAgICAgICAgICBmaWxsKGQsIFwiZ3JBcmNcIiwgLjEsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgZmlsbChkLCAnZ3JUZXh0JywgLjksIDAsIDEwMCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICBmaWxsVGhpcyh0aGlzLCAwLCAxMDAsIDUwMCk7XG4gICAgICAgICAgICAgICAgZmlsbChkLCBcImdyQXJjXCIsIDAsIDEwMCwgNTAwKTtcbiAgICAgICAgICAgICAgICBmaWxsKGQsICdnclRleHQnLCAwLCAxMDAsIDUwMCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdjbGljaycsIGQgPT4ge1xuICAgICAgICAgICAgICAgIC8vZC5ncm91cDEgPSAhZC5ncm91cDE7ICAgICAgLy8gVGhpcyBtaWdodCBiZSBlYXNpZXIsIGJ1dCBjdXJyZW50bHkgc2V0IGluIHNldENvbG9ycygpXG4gICAgICAgICAgICAgICAgc2V0Q29sb3JzKGQsIGdyMUNvbG9yKTtcbiAgICAgICAgICAgICAgICBsZWdlbmQoZ3IxQ29sb3IpO1xuICAgICAgICAgICAgICAgIHJlc3RhcnQoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICBnLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgYXBwZW5kKCdncjJpbmRpY2F0b3InKSlcbiAgICAgICAgICAgIC5hdHRyKFwiZFwiLCBhcmNJbmQyKVxuICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBncjJDb2xvcikgIC8vIHNvbWV0aGluZyBsaWtlOiB6cGFyYW1zLnpncm91cDEuaW5kZXhPZihub2RlLm5hbWUpID4gLTEgID8gICNGRkZGRkYgOiBncjFDb2xvcilcbiAgICAgICAgICAgIC5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICBmaWxsVGhpcyh0aGlzLCAuMywgMCwgMTAwKTtcbiAgICAgICAgICAgICAgICBmaWxsKGQsIFwiZ3JBcmNcIiwgLjEsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgZmlsbChkLCAnZ3JUZXh0JywgLjksIDAsIDEwMCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICBmaWxsVGhpcyh0aGlzLCAwLCAxMDAsIDUwMCk7XG4gICAgICAgICAgICAgICAgZmlsbChkLCBcImdyQXJjXCIsIDAsIDEwMCwgNTAwKTtcbiAgICAgICAgICAgICAgICBmaWxsKGQsICdnclRleHQnLCAwLCAxMDAsIDUwMCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdjbGljaycsIGQgPT4ge1xuICAgICAgICAgICAgICAgIC8vZC5ncm91cDIgPSAhZC5ncm91cDI7ICAgICAgLy8gVGhpcyBtaWdodCBiZSBlYXNpZXIsIGJ1dCBjdXJyZW50bHkgc2V0IGluIHNldENvbG9ycygpXG4gICAgICAgICAgICAgICAgc2V0Q29sb3JzKGQsIGdyMkNvbG9yKTtcbiAgICAgICAgICAgICAgICBsZWdlbmQoZ3IyQ29sb3IpO1xuICAgICAgICAgICAgICAgIHJlc3RhcnQoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIGcuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBhcHBlbmQoJ2dyVGV4dCcpKVxuICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIDYpXG4gICAgICAgICAgICAuYXR0cihcImR5XCIsIDExLjUpXG4gICAgICAgICAgICAuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgLmFwcGVuZChcInRleHRQYXRoXCIpXG4gICAgICAgICAgICAuYXR0cihcInhsaW5rOmhyZWZcIiwgYXBwZW5kKCcjZ3JBcmMnKSlcbiAgICAgICAgICAgIC50ZXh0KFwiR3JvdXBzXCIpO1xuXG4gICAgICAgIGcuYXBwZW5kKCdzdmc6Y2lyY2xlJylcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdub2RlJylcbiAgICAgICAgICAgIC5hdHRyKCdyJywgZCA9PiBzZXRQZWJibGVSYWRpdXMoZCkpXG4gICAgICAgICAgICAuc3R5bGUoJ3BvaW50ZXItZXZlbnRzJywgJ2luaGVyaXQnKVxuICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgZCA9PiBkLm5vZGVDb2wpXG4gICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCBcIjAuNVwiKVxuICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCBkID0+IGQzLnJnYihkLnN0cm9rZUNvbG9yKS50b1N0cmluZygpKVxuICAgICAgICAgICAgLmNsYXNzZWQoJ3JlZmxleGl2ZScsIGQgPT4gZC5yZWZsZXhpdmUpXG4gICAgICAgICAgICAub24oJ2RibGNsaWNrJywgZnVuY3Rpb24oXykge1xuICAgICAgICAgICAgICAgIGQzLmV2ZW50LnN0b3BQcm9wYWdhdGlvbigpOyAvLyBzdG9wIGNsaWNrIGZyb20gYnViYmxpbmdcbiAgICAgICAgICAgICAgICBzdW1tYXJ5SG9sZCA9IHRydWU7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdjb250ZXh0bWVudScsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAvLyByaWdodCBjbGljayBvbiBub2RlXG4gICAgICAgICAgICAgICAgZDMuZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBkMy5ldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAgICAgICAgIHJpZ2h0Q2xpY2tMYXN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBtb3VzZWRvd25fbm9kZSA9IGQ7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRfbm9kZSA9IG1vdXNlZG93bl9ub2RlID09PSBzZWxlY3RlZF9ub2RlID8gbnVsbCA6IG1vdXNlZG93bl9ub2RlO1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkX2xpbmsgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgLy8gcmVwb3NpdGlvbiBkcmFnIGxpbmVcbiAgICAgICAgICAgICAgICBkcmFnX2xpbmVcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdtYXJrZXItZW5kJywgJ3VybCgjZW5kLWFycm93KScpXG4gICAgICAgICAgICAgICAgICAgIC5jbGFzc2VkKCdoaWRkZW4nLCBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCAnTScgKyBtb3VzZWRvd25fbm9kZS54ICsgJywnICsgbW91c2Vkb3duX25vZGUueSArICdMJyArIG1vdXNlZG93bl9ub2RlLnggKyAnLCcgKyBtb3VzZWRvd25fbm9kZS55KTtcblxuICAgICAgICAgICAgICAgIHN2Zy5vbignbW91c2Vtb3ZlJywgbW91c2Vtb3ZlKTtcbiAgICAgICAgICAgICAgICByZXN0YXJ0KCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdtb3VzZXVwJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIGQzLmV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJpZ2h0Q2xpY2tMYXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0Q2xpY2tMYXN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFtb3VzZWRvd25fbm9kZSkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgLy8gbmVlZGVkIGJ5IEZGXG4gICAgICAgICAgICAgICAgZHJhZ19saW5lXG4gICAgICAgICAgICAgICAgICAgIC5jbGFzc2VkKCdoaWRkZW4nLCB0cnVlKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ21hcmtlci1lbmQnLCAnJyk7XG5cbiAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgZHJhZy10by1zZWxmXG4gICAgICAgICAgICAgICAgbW91c2V1cF9ub2RlID0gZDtcbiAgICAgICAgICAgICAgICBpZiAobW91c2V1cF9ub2RlID09PSBtb3VzZWRvd25fbm9kZSkge1xuICAgICAgICAgICAgICAgICAgICByZXNldE1vdXNlVmFycygpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gdW5lbmxhcmdlIHRhcmdldCBub2RlXG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmF0dHIoJ3RyYW5zZm9ybScsICcnKTtcblxuICAgICAgICAgICAgICAgIC8vIGFkZCBsaW5rIHRvIGdyYXBoICh1cGRhdGUgaWYgZXhpc3RzKVxuICAgICAgICAgICAgICAgIC8vIE5COiBsaW5rcyBhcmUgc3RyaWN0bHkgc291cmNlIDwgdGFyZ2V0OyBhcnJvd3Mgc2VwYXJhdGVseSBzcGVjaWZpZWQgYnkgYm9vbGVhbnNcbiAgICAgICAgICAgICAgICB2YXIgc291cmNlLCB0YXJnZXQsIGRpcmVjdGlvbjtcbiAgICAgICAgICAgICAgICBpZiAobW91c2Vkb3duX25vZGUuaWQgPCBtb3VzZXVwX25vZGUuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlID0gbW91c2Vkb3duX25vZGU7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IG1vdXNldXBfbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gJ3JpZ2h0JztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2UgPSBtb3VzZXVwX25vZGU7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IG1vdXNlZG93bl9ub2RlO1xuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSAnbGVmdCc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IGxpbmsgPSBsaW5rcy5maWx0ZXIoeCA9PiB4LnNvdXJjZSA9PSBzb3VyY2UgJiYgeC50YXJnZXQgPT0gdGFyZ2V0KVswXTtcbiAgICAgICAgICAgICAgICBpZiAobGluaykge1xuICAgICAgICAgICAgICAgICAgICBsaW5rW2RpcmVjdGlvbl0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmsgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodDogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgbGlua1tkaXJlY3Rpb25dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbGlua3MucHVzaChsaW5rKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBzZWxlY3QgbmV3IGxpbmtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZF9saW5rID0gbGluaztcbiAgICAgICAgICAgICAgICBzZWxlY3RlZF9ub2RlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBzdmcub24oJ21vdXNlbW92ZScsIG51bGwpO1xuXG4gICAgICAgICAgICAgICAgcmVzZXRNb3VzZVZhcnMoKTtcbiAgICAgICAgICAgICAgICByZXN0YXJ0KCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAvLyBzaG93IG5vZGUgbmFtZXNcbiAgICAgICAgZy5hcHBlbmQoJ3N2Zzp0ZXh0JylcbiAgICAgICAgICAgIC5hdHRyKCd4JywgMClcbiAgICAgICAgICAgIC5hdHRyKCd5JywgMTUpXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnaWQnKVxuICAgICAgICAgICAgLnRleHQoZCA9PiBkLm5hbWUpO1xuXG4gICAgICAgIC8vIHNob3cgc3VtbWFyeSBzdGF0cyBvbiBtb3VzZW92ZXJcbiAgICAgICAgLy8gU1ZHIGRvZXNuJ3Qgc3VwcG9ydCB0ZXh0IHdyYXBwaW5nLCB1c2UgaHRtbCBpbnN0ZWFkXG4gICAgICAgIGcuc2VsZWN0QWxsKFwiY2lyY2xlLm5vZGVcIilcbiAgICAgICAgICAgIC5vbihcIm1vdXNlb3ZlclwiLCBkID0+IHtcbiAgICAgICAgICAgICAgICB0YWJMZWZ0KCd0YWIzJyk7XG4gICAgICAgICAgICAgICAgdmFyU3VtbWFyeShkKTtcbiAgICAgICAgICAgICAgICBkLmZvcmVmcm9udCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBieUlkKCd0cmFuc2Zvcm1hdGlvbnMnKS5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2Rpc3BsYXk6YmxvY2snKTtcbiAgICAgICAgICAgICAgICBieUlkKFwidHJhbnNTZWxcIikuc2VsZWN0ZWRJbmRleCA9IGQuaWQ7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtVmFyID0gdmFsdWVLZXlbZC5pZF07XG5cbiAgICAgICAgICAgICAgICBmaWxsKGQsIFwiZHZBcmNcIiwgLjEsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgZmlsbChkLCBcImR2VGV4dFwiLCAuNSwgMCwgMTAwKTtcbiAgICAgICAgICAgICAgICBmaWxsKGQsIFwiZ3JBcmNcIiwgLjEsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgZmlsbChkLCBcImdyVGV4dFwiLCAuNSwgMCwgMTAwKTtcbiAgICAgICAgICAgICAgICAvL2ZpbGwoZCwgXCJncjFpbmRpY2F0b3JcIiwgLjEsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgLy9maWxsKGQsIFwiZ3IxaW5kaWNhdG9yVGV4dFwiLCAuMSwgMCwgMTAwKTtcbiAgICAgICAgICAgICAgICAvL2ZpbGwoZCwgXCJncjJpbmRpY2F0b3JcIiwgLjEsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgLy9maWxsKGQsIFwiZ3IyaW5kaWNhdG9yVGV4dFwiLCAuMSwgMCwgMTAwKTtcblxuICAgICAgICAgICAgICAgIGlmIChkLmRlZmF1bHROdW1jaGFyID09IFwibnVtZXJpY1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGwoZCwgXCJub21BcmNcIiwgLjEsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgICAgIGZpbGwoZCwgXCJub21UZXh0XCIsIC41LCAwLCAxMDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaWxsKGQsIFwiY3NBcmNcIiwgLjEsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgZmlsbChkLCBcImNzVGV4dFwiLCAuNSwgMCwgMTAwKTtcbiAgICAgICAgICAgICAgICBmaWxsKGQsIFwidGltZUFyY1wiLCAuMSwgMCwgMTAwKTtcbiAgICAgICAgICAgICAgICBmaWxsKGQsIFwidGltZVRleHRcIiwgLjUsIDAsIDEwMCk7XG5cbiAgICAgICAgICAgICAgICBtLnJlZHJhdygpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBkID0+IHtcbiAgICAgICAgICAgICAgICBkLmZvcmVmcm9udCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHN1bW1hcnlIb2xkIHx8IHRhYkxlZnQoc3Vic2V0ID8gJ3RhYjInIDogJ3RhYjEnKTtcbiAgICAgICAgICAgICAgICAnY3NBcmMgY3NUZXh0IHRpbWVBcmMgdGltZVRleHQgZHZBcmMgZHZUZXh0IG5vbUFyYyBub21UZXh0IGdyQXJjIGdyVGV4dCcuc3BsaXQoJyAnKS5tYXAoeCA9PiBmaWxsKGQsIHgsIDAsIDEwMCwgNTAwKSk7XG4gICAgICAgICAgICAgICAgbS5yZWRyYXcoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHRoZSB0cmFuc2Zvcm1hdGlvbiB2YXJpYWJsZSBsaXN0IGlzIHNpbGVudGx5IHVwZGF0ZWQgYXMgcGViYmxlcyBhcmUgYWRkZWQvcmVtb3ZlZFxuICAgICAgICBkMy5zZWxlY3QoXCIjdHJhbnNTZWxcIilcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoJ2xpJylcbiAgICAgICAgICAgIC5yZW1vdmUoKTtcblxuICAgICAgICBkMy5zZWxlY3QoXCIjdHJhbnNTZWxcIilcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoJ2xpJylcbiAgICAgICAgICAgIC5kYXRhKG5vZGVzLm1hcCh4ID0+IHgubmFtZSkpIC8vIHNldCB0byB2YXJpYWJsZXMgaW4gbW9kZWwgc3BhY2UgYXMgdGhleSdyZSBhZGRlZFxuICAgICAgICAgICAgLmVudGVyKClcbiAgICAgICAgICAgIC5hcHBlbmQoXCJsaVwiKVxuICAgICAgICAgICAgLnRleHQoZCA9PiBkKTtcblxuICAgICAgICAkKCcjdHJhbnNTZWwgbGknKS5jbGljayhmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICAgIC8vIGlmICdpbnRlcmFjdGlvbicgaXMgdGhlIHNlbGVjdGVkIGZ1bmN0aW9uLCBkb24ndCBzaG93IHRoZSBmdW5jdGlvbiBsaXN0IGFnYWluXG4gICAgICAgICAgICBpZiAoc2VsSW50ZXJhY3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgbiA9ICQoJyN0SW5wdXQnKS52YWwoKS5jb25jYXQoJCh0aGlzKS50ZXh0KCkpO1xuICAgICAgICAgICAgICAgICQoJyN0SW5wdXQnKS52YWwobik7XG4gICAgICAgICAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIHZhciB0ID0gdHJhbnNQYXJzZShuID0gbik7XG4gICAgICAgICAgICAgICAgaWYgKCF0KSByZXR1cm47XG4gICAgICAgICAgICAgICAgJCh0aGlzKS5wYXJlbnQoKS5mYWRlT3V0KDEwMCk7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtKG4gPSB0LnNsaWNlKDAsIHQubGVuZ3RoIC0gMSksIHQgPSB0W3QubGVuZ3RoIC0gMV0sIHR5cGVUcmFuc2Zvcm0gPSBmYWxzZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAkKCcjdElucHV0JykudmFsKCQodGhpcykudGV4dCgpKTtcbiAgICAgICAgICAgICQodGhpcykucGFyZW50KCkuZmFkZU91dCgxMDApO1xuICAgICAgICAgICAgJCgnI3RyYW5zTGlzdCcpLmZhZGVJbigxMDApO1xuICAgICAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyByZW1vdmUgb2xkIG5vZGVzXG4gICAgICAgIGNpcmNsZS5leGl0KCkucmVtb3ZlKCk7XG4gICAgICAgIGZvcmNlLnN0YXJ0KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW91c2Vkb3duKGQpIHtcbiAgICAgICAgLy8gcHJldmVudCBJLWJhciBvbiBkcmFnXG4gICAgICAgIGQzLmV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIC8vIGJlY2F1c2UgOmFjdGl2ZSBvbmx5IHdvcmtzIGluIFdlYktpdD9cbiAgICAgICAgc3ZnLmNsYXNzZWQoJ2FjdGl2ZScsIHRydWUpO1xuICAgICAgICBpZiAoZDMuZXZlbnQuY3RybEtleSB8fCBtb3VzZWRvd25fbm9kZSB8fCBtb3VzZWRvd25fbGluaykgcmV0dXJuO1xuICAgICAgICByZXN0YXJ0KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW91c2Vtb3ZlKGQpIHtcbiAgICAgICAgaWYgKCFtb3VzZWRvd25fbm9kZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gdXBkYXRlIGRyYWcgbGluZVxuICAgICAgICBkcmFnX2xpbmUuYXR0cignZCcsICdNJyArIG1vdXNlZG93bl9ub2RlLnggKyAnLCcgKyBtb3VzZWRvd25fbm9kZS55ICsgJ0wnICsgZDMubW91c2UodGhpcylbMF0gKyAnLCcgKyBkMy5tb3VzZSh0aGlzKVsxXSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW91c2V1cChkKSB7XG4gICAgICAgIGlmIChtb3VzZWRvd25fbm9kZSkge1xuICAgICAgICAgICAgZHJhZ19saW5lXG4gICAgICAgICAgICAgICAgLmNsYXNzZWQoJ2hpZGRlbicsIHRydWUpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdtYXJrZXItZW5kJywgJycpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGJlY2F1c2UgOmFjdGl2ZSBvbmx5IHdvcmtzIGluIFdlYktpdD9cbiAgICAgICAgc3ZnLmNsYXNzZWQoJ2FjdGl2ZScsIGZhbHNlKTtcbiAgICAgICAgLy8gY2xlYXIgbW91c2UgZXZlbnQgdmFyc1xuICAgICAgICByZXNldE1vdXNlVmFycygpO1xuICAgIH1cblxuICAgIC8vIGFwcCBzdGFydHMgaGVyZVxuICAgIHN2Zy5hdHRyKCdpZCcsICgpID0+IFwid2hpdGVzcGFjZVwiLmNvbmNhdChteXNwYWNlKSlcbiAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGhlaWdodClcbiAgICAgICAgLm9uKCdtb3VzZWRvd24nLCBmdW5jdGlvbigpIHttb3VzZWRvd24odGhpcyk7fSlcbiAgICAgICAgLm9uKCdtb3VzZXVwJywgZnVuY3Rpb24oKSB7bW91c2V1cCh0aGlzKTt9KTtcblxuICAgIGQzLnNlbGVjdCh3aW5kb3cpXG4gICAgICAgIC5vbignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgICAvLyBhbGwgY2xpY2tzIHdpbGwgYnViYmxlIGhlcmUgdW5sZXNzIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICAgICAgICAkKCcjdHJhbnNMaXN0JykuZmFkZU91dCgxMDApO1xuICAgICAgICAgICAgJCgnI3RyYW5zU2VsJykuZmFkZU91dCgxMDApO1xuICAgICAgICB9KTtcblxuICAgIHJlc3RhcnQoKTsgLy8gaW5pdGlhbGl6ZXMgZm9yY2UubGF5b3V0KClcbiAgICBmYWtlQ2xpY2soKTtcblxuICAgIGlmKHYyICYgZDNtX21vZGUpIHtcbiAgICAgICAgdmFyIGNsaWNrX2V2ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJNb3VzZUV2ZW50c1wiKTtcbiAgICAgICAgLy8gaW5pdGlhbGl6ZSB0aGUgZXZlbnRcbiAgICAgICAgY2xpY2tfZXYuaW5pdEV2ZW50KFwiY2xpY2tcIiwgdHJ1ZSAvKiBidWJibGUgKi8sIHRydWUgLyogY2FuY2VsYWJsZSAqLyk7XG4gICAgICAgIC8vIHRyaWdnZXIgdGhlIGV2ZW50XG4gICAgICAgIGxldCBjbGlja0lEID0gXCJkdkFyY1wiK2ZpbmROb2RlSW5kZXgobXl0YXJnZXQpO1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjbGlja0lEKS5kaXNwYXRjaEV2ZW50KGNsaWNrX2V2KTtcbiAgICB9XG59XG5cblxubGV0IGZpbmQgPSAoJG5vZGVzLCBuYW1lKSA9PiB7XG4gICAgZm9yIChsZXQgaSBpbiAkbm9kZXMpXG4gICAgICAgIGlmICgkbm9kZXNbaV0ubmFtZSA9PSBuYW1lKSByZXR1cm4gJG5vZGVzW2ldLmlkO1xufTtcblxuLy8gcmV0dXJucyBpZFxuZXhwb3J0IGxldCBmaW5kTm9kZUluZGV4ID0gKG5hbWUsIGFsbCkgPT4ge1xuICAgIGZvciAobGV0IG5vZGUgb2YgYWxsTm9kZXMpIHtcbiAgICAgICAgaWYgKG5vZGUubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgLy9jZGIoJ1llcyEnICsgYWxsTm9kZXNbaV0uaWQpO1xuICAgICAgICAgICAgcmV0dXJuIGFsbD8gbm9kZSA6IG5vZGUuaWQ7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5sZXQgbm9kZUluZGV4ID0gbm9kZU5hbWUgPT4ge1xuICAgIGZvciAobGV0IGkgaW4gbm9kZXMpXG4gICAgICAgIGlmIChub2Rlc1tpXS5uYW1lID09IG5vZGVOYW1lKSByZXR1cm4gaTtcbn07XG5cbmV4cG9ydCBsZXQgZmluZE5vZGUgPSBub2RlTmFtZSA9PiB7XG4gICAgZm9yIChsZXQgaSBpbiBhbGxOb2RlcylcbiAgICAgICAgaWYgKGFsbE5vZGVzW2ldLm5hbWUgPT0gbm9kZU5hbWUpIHJldHVybiBhbGxOb2Rlc1tpXTtcbn07XG5cbi8qXG4gICAgUmV0cmlldmUgdGhlIHZhcmlhYmxlIGxpc3QgZnJvbSB0aGUgcHJlcHJvY2VzcyBkYXRhLlxuICAgIFRoaXMgaGVscHMgaGFuZGxlIHRoZSBuZXcgZm9ybWF0IGFuZCAodGVtcG9yYXJpbHkpXG4gICAgdGhlIG9sZGVyIGZvcm1hdCBpbiBwcm9kdWN0aW9uIChycCA4LjE0LjIwMTcpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRWYXJpYWJsZURhdGEoanNvbkRhdGEpIHtcbiAgICAvKiBcIm5ld1wiIHJlc3BvbnNlOlxuICAgIHtcbiAgICAgICAgXCJkYXRhc2V0XCIgOiB7Li4ufVxuICAgICAgICBcInZhcmlhYmxlc1wiIDoge1xuICAgICAgICAgICAgXCJ2YXIxXCIgOiB7Li4ufSwgKGV0YylcbiAgICAgICAgfVxuICAgIH1cbiAgICBcIm9sZFwiIHJlc3BvbnNlXG4gICAge1xuICAgICAgICAgXCJ2YXIxXCIgOiB7Li4ufSxcbiAgICAgICAgIChldGMpXG4gICAgfSovXG4gICAgcmV0dXJuIGpzb25EYXRhLmhhc093blByb3BlcnR5KCd2YXJpYWJsZXMnKSA/IGpzb25EYXRhLnZhcmlhYmxlcyA6IGpzb25EYXRhO1xufVxuXG4vLyBmdW5jdGlvbiBjYWxsZWQgYnkgZm9yY2UgYnV0dG9uXG5leHBvcnQgZnVuY3Rpb24gZm9yY2VTd2l0Y2goKSB7XG4gICAgZm9yY2V0b2dnbGUgPSBbZm9yY2V0b2dnbGVbMF0gPT0gJ3RydWUnID8gJ2ZhbHNlJyA6ICd0cnVlJ107XG4gICAgaWYgKGZvcmNldG9nZ2xlWzBdID09PSBcImZhbHNlXCIpIHtcbiAgICAgICAgYnlJZCgnYnRuRm9yY2UnKS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImJ0biBhY3RpdmVcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYnlJZCgnYnRuRm9yY2UnKS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImJ0biBidG4tZGVmYXVsdFwiKTtcbiAgICAgICAgZmFrZUNsaWNrKCk7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9ja0Rlc2NyaXB0aW9uKCkge1xuICAgIGxvY2t0b2dnbGUgPSBsb2NrdG9nZ2xlID8gZmFsc2UgOiB0cnVlO1xuICAgIGxldCB0ZW1wO1xuICAgIGxldCBpO1xuICAgIGlmICghbG9ja3RvZ2dsZSkge1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYnRuTG9jaycpLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiYnRuIGJ0bi1kZWZhdWx0XCIpO1xuICAgICAgICB0ZW1wID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3JpZ2h0Q29udGVudEFyZWEnKS5xdWVyeVNlbGVjdG9yQWxsKFwicC5pdGVtLWxpbmVvdXRcIik7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0ZW1wLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0ZW1wW2ldLmNsYXNzTGlzdC5yZW1vdmUoXCJpdGVtLWxpbmVvdXRcIik7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYnRuTG9jaycpLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiYnRuIGFjdGl2ZVwiKTtcbiAgICAgICAgdGVtcCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtZXRyaWNzJykucXVlcnlTZWxlY3RvckFsbChcInAuaXRlbS1kZWZhdWx0XCIpO1xuICAgICAgICBjb25zb2xlLmxvZyh0ZW1wKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRlbXAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRlbXBbaV0uY2xhc3NMaXN0LmFkZChcIml0ZW0tbGluZW91dFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0ZW1wID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3R5cGVzJykucXVlcnlTZWxlY3RvckFsbChcInAuaXRlbS1kZWZhdWx0XCIpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGVtcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGVtcFtpXS5jbGFzc0xpc3QuYWRkKFwiaXRlbS1saW5lb3V0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHRlbXAgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3VidHlwZXMnKS5xdWVyeVNlbGVjdG9yQWxsKFwicC5pdGVtLWRlZmF1bHRcIik7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0ZW1wLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0ZW1wW2ldLmNsYXNzTGlzdC5hZGQoXCJpdGVtLWxpbmVvdXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGVtcCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdvdXRwdXRzJykucXVlcnlTZWxlY3RvckFsbChcInAuaXRlbS1kZWZhdWx0XCIpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGVtcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGVtcFtpXS5jbGFzc0xpc3QuYWRkKFwiaXRlbS1saW5lb3V0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGZha2VDbGljaygpO1xuICAgIH1cbn1cblxuZXhwb3J0IGxldCBzcGxpY2VMaW5rc0Zvck5vZGUgPSBub2RlID0+IGxpbmtzXG4gICAgLmZpbHRlcihsID0+IGwuc291cmNlID09PSBub2RlIHx8IGwudGFyZ2V0ID09PSBub2RlKVxuICAgIC5tYXAoeCA9PiBsaW5rcy5zcGxpY2UobGlua3MuaW5kZXhPZih4KSwgMSkpO1xuXG5mdW5jdGlvbiB6UG9wKCkge1xuICAgIGlmIChkYXRhdXJsKSB6cGFyYW1zLnpkYXRhdXJsID0gZGF0YXVybDtcbiAgICB6cGFyYW1zLnptb2RlbGNvdW50ID0gbW9kZWxDb3VudDtcbiAgICB6cGFyYW1zLnplZGdlcyA9IFtdO1xuICAgIHpwYXJhbXMuenZhcnMgPSBbXTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IG5vZGVzLmxlbmd0aDsgaisrKSB7IC8vcG9wdWxhdGUgenZhcnMgYXJyYXlcbiAgICAgICAgenBhcmFtcy56dmFycy5wdXNoKG5vZGVzW2pdLm5hbWUpO1xuICAgICAgICBsZXQgdGVtcCA9IG5vZGVzW2pdLmlkO1xuICAgICAgICB6cGFyYW1zLnpzZXR4W2pdID0gYWxsTm9kZXNbdGVtcF0uc2V0eHZhbHM7XG4gICAgICAgIHpwYXJhbXMuenN1YnNldFtqXSA9IGFsbE5vZGVzW3RlbXBdLnN1YnNldHJhbmdlO1xuICAgIH1cbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxpbmtzLmxlbmd0aDsgaisrKSB7IC8vcG9wdWxhdGUgemVkZ2VzIGFycmF5XG4gICAgICAgIC8vY29ycmVjdCB0aGUgc291cmNlIHRhcmdldCBvcmRlcmluZyBmb3IgWmVsaWdcbiAgICAgICAgbGV0IHNyY3RndCA9IGxpbmtzW2pdLmxlZnQgPT0gZmFsc2UgP1xuICAgICAgICAgICAgW2xpbmtzW2pdLnNvdXJjZS5uYW1lLCBsaW5rc1tqXS50YXJnZXQubmFtZV0gOlxuICAgICAgICAgICAgW2xpbmtzW2pdLnRhcmdldC5uYW1lLCBsaW5rc1tqXS5zb3VyY2UubmFtZV07XG4gICAgICAgIHpwYXJhbXMuemVkZ2VzLnB1c2goc3JjdGd0KTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlc3RpbWF0ZShidG4pIHtcbiAgICBpZighZDNtX21vZGUpe1xuICAgIGlmIChwcm9kdWN0aW9uICYmIHpwYXJhbXMuenNlc3Npb25pZCA9PSAnJykge1xuICAgICAgICBhbGVydChcIldhcm5pbmc6IERhdGEgZG93bmxvYWQgaXMgbm90IGNvbXBsZXRlLiBUcnkgYWdhaW4gc29vbi5cIik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgICBcbiAgICB6UG9wKCk7XG4gICAgLy8gd3JpdGUgbGlua3MgdG8gZmlsZSAmIHJ1biBSIENNRFxuICAgIC8vIHBhY2thZ2UgdGhlIG91dHB1dCBhcyBKU09OXG4gICAgLy8gYWRkIGNhbGwgaGlzdG9yeSBhbmQgcGFja2FnZSB0aGUgenBhcmFtcyBvYmplY3QgYXMgSlNPTlxuICAgIHpwYXJhbXMuY2FsbEhpc3RvcnkgPSBjYWxsSGlzdG9yeTtcbiAgICB2YXIganNvbm91dCA9IEpTT04uc3RyaW5naWZ5KHpwYXJhbXMpO1xuXG4gICAgdmFyIHVybGNhbGwgPSByYXBwVVJMICsgXCJ6ZWxpZ2FwcFwiOyAvL2Jhc2UuY29uY2F0KGpzb25vdXQpO1xuICAgIHZhciBzb2xhanNvbm91dCA9IFwic29sYUpTT049XCIgKyBqc29ub3V0O1xuICAgIGNkYihcInVybGNhbGwgb3V0OiBcIiwgdXJsY2FsbCk7XG4gICAgY2RiKFwiUE9TVCBvdXQ6IFwiLCBzb2xhanNvbm91dCk7XG4gICAgY29uc29sZS5sb2coXCJlc3RpbWF0ZTogXCIsIHNvbGFqc29ub3V0KTtcblxuICAgIHpwYXJhbXMuYWxsVmFycyA9IHZhbHVlS2V5LnNsaWNlKDEwLCAyNSk7IC8vIGJlY2F1c2UgdGhlIFVSTCBpcyB0b28gbG9uZy4uLlxuICAgIGpzb25vdXQgPSBKU09OLnN0cmluZ2lmeSh6cGFyYW1zKTtcbiAgICB2YXIgc2VsZWN0b3J1cmxjYWxsID0gcmFwcFVSTCArIFwic2VsZWN0b3JhcHBcIjtcblxuICAgIGZ1bmN0aW9uIGVzdGltYXRlU3VjY2VzcyhidG4sIGpzb24pIHtcbiAgICAgIC8vICB0b2dnbGVSaWdodEJ1dHRvbnMoXCJhbGxcIik7XG4gICAgICAgIGVzdGltYXRlTGFkZGEuc3RvcCgpOyAvLyBzdG9wIHNwaW5uZXJcbiAgICAgICAgYWxsUmVzdWx0cy5wdXNoKGpzb24pO1xuICAgICAgICBjZGIoXCJqc29uIGluOiBcIiwganNvbik7XG5cbiAgICAgICAgaWYgKCFlc3RpbWF0ZWQpIGJ5SWQoXCJyZXN1bHRzXCIpLnJlbW92ZUNoaWxkKGJ5SWQoXCJyZXN1bHRzSG9sZGVyXCIpKTtcblxuICAgICAgICBlc3RpbWF0ZWQgPSB0cnVlO1xuICAgICAgICBkMy5zZWxlY3QoXCIjcmVzdWx0c1wiKVxuICAgICAgICAgICAgLnN0eWxlKFwiZGlzcGxheVwiLCBcImJsb2NrXCIpO1xuXG4gICAgICAgIGQzLnNlbGVjdChcIiNyZXN1bHRzVmlld1wiKVxuICAgICAgICAgICAgLnN0eWxlKFwiZGlzcGxheVwiLCBcImJsb2NrXCIpO1xuXG4gICAgICAgIGQzLnNlbGVjdChcIiNtb2RlbFZpZXdcIilcbiAgICAgICAgICAgIC5zdHlsZShcImRpc3BsYXlcIiwgXCJibG9ja1wiKTtcbiAgICAgICAgXG5cbiAgICAgICAgLy8gcHJvZ3JhbW1hdGljIGNsaWNrIG9uIFJlc3VsdHMgYnV0dG9uXG4gICAgICAgICQoXCIjYnRuUmVzdWx0c1wiKS50cmlnZ2VyKFwiY2xpY2tcIik7XG5cbiAgICAgICAgbGV0IG1vZGVsID0gXCJNb2RlbFwiLmNvbmNhdChtb2RlbENvdW50ID0gbW9kZWxDb3VudCArIDEpO1xuXG4gICAgICAgIGZ1bmN0aW9uIG1vZENvbCgpIHtcbiAgICAgICAgICAgIGQzLnNlbGVjdChcIiNtb2RlbFZpZXdcIilcbiAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKFwicFwiKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnYmFja2dyb3VuZC1jb2xvcicsIGhleFRvUmdiYSh2YXJDb2xvcikpO1xuICAgICAgICB9XG4gICAgICAgIG1vZENvbCgpO1xuXG4gICAgICAgIGQzLnNlbGVjdChcIiNtb2RlbFZpZXdcIilcbiAgICAgICAgICAgIC5pbnNlcnQoXCJwXCIsIFwiOmZpcnN0LWNoaWxkXCIpIC8vIHRvcCBzdGFjayBmb3IgcmVzdWx0c1xuICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBtb2RlbClcbiAgICAgICAgICAgIC50ZXh0KG1vZGVsKVxuICAgICAgICAgICAgLnN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJywgaGV4VG9SZ2JhKHNlbFZhckNvbG9yKSlcbiAgICAgICAgICAgIC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBhID0gdGhpcy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IucmVwbGFjZSgvXFxzKi9nLCBcIlwiKTtcbiAgICAgICAgICAgICAgICB2YXIgYiA9IGhleFRvUmdiYShzZWxWYXJDb2xvcikucmVwbGFjZSgvXFxzKi9nLCBcIlwiKTtcbiAgICAgICAgICAgICAgICBpZiAoYS5zdWJzdHIoMCwgMTcpID09IGIuc3Vic3RyKDAsIDE3KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBlc2NhcGUgZnVuY3Rpb24gaWYgZGlzcGxheWVkIG1vZGVsIGlzIGNsaWNrZWRcbiAgICAgICAgICAgICAgICBtb2RDb2woKTtcbiAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcylcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJywgaGV4VG9SZ2JhKHNlbFZhckNvbG9yKSk7XG4gICAgICAgICAgICAgICAgdml6KHRoaXMuaWQpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgbGV0IHJDYWxsID0gW107XG4gICAgICAgIHJDYWxsWzBdID0ganNvbi5jYWxsO1xuICAgICAgICBzaG93TG9nKFwiZXN0aW1hdGVcIiwgckNhbGwpO1xuXG4gICAgICAgIHZpeihtb2RlbCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXN0aW1hdGVGYWlsKGJ0bikge1xuICAgICAgICBlc3RpbWF0ZUxhZGRhLnN0b3AoKTsgLy8gc3RvcCBzcGlubmVyXG4gICAgICAgIGVzdGltYXRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2VsZWN0b3JTdWNjZXNzKGJ0biwganNvbikge1xuICAgICAgICBkMy5zZWxlY3QoXCIjdGlja2VyXCIpXG4gICAgICAgICAgICAudGV4dChcIlN1Z2dlc3RlZCB2YXJpYWJsZXMgYW5kIHBlcmNlbnQgaW1wcm92ZW1lbnQgb24gUk1TRTogXCIgKyBqc29uLnZhcnMpO1xuICAgICAgICBjZGIoXCJzZWxlY3RvclN1Y2Nlc3M6IFwiLCBqc29uKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZWxlY3RvckZhaWwoYnRuKSB7XG4gICAgICAgIGFsZXJ0KFwiU2VsZWN0b3IgRmFpbFwiKTtcbiAgICB9XG5cbiAgICBlc3RpbWF0ZUxhZGRhLnN0YXJ0KCk7IC8vIHN0YXJ0IHNwaW5uZXJcbiAgICBtYWtlQ29yc1JlcXVlc3QodXJsY2FsbCwgYnRuLCBlc3RpbWF0ZVN1Y2Nlc3MsIGVzdGltYXRlRmFpbCwgc29sYWpzb25vdXQpO1xuICAgIH0gZWxzZSB7IC8vIHdlIGFyZSBpbiBkM21fbW9kZVxuICAgICAgICAvLyBycGMgQ3JlYXRlUGlwZWxpbmVzKFBpcGVsaW5lQ3JlYXRlUmVxdWVzdCkgcmV0dXJucyAoc3RyZWFtIFBpcGVsaW5lQ3JlYXRlUmVzdWx0KSB7fVxuICAgICAgICAgICAgelBvcCgpO1xuICAgICAgICAgICAgenBhcmFtcy5jYWxsSGlzdG9yeSA9IGNhbGxIaXN0b3J5O1xuICAgICAgICAgICAgdmFyIGpzb25vdXQgPSBKU09OLnN0cmluZ2lmeSh6cGFyYW1zKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGpzb25vdXQpO1xuICAgICAgICBcbiAgICAgICAgICAgIGxldCBjb250ZXh0ID0gYXBpU2Vzc2lvbih6cGFyYW1zLnpzZXNzaW9uaWQpO1xuICAgICAgICAgICAgbGV0IHVyaSA9IHtmZWF0dXJlczogenBhcmFtcy56ZDNtZGF0YSwgdGFyZ2V0OnpwYXJhbXMuemQzbXRhcmdldH07XG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgICAgIHZhciB1cmxjYWxsID0gcmFwcFVSTCArIFwicGlwZWxpbmVhcHBcIjtcbiAgICAgICAgXG4gICAgICAgICAgICB2YXIgc29sYWpzb25vdXQgPSBcInNvbGFKU09OPVwiICsganNvbm91dDtcbiAgICAgICAgICAgIGNkYihcInVybGNhbGwgb3V0OiBcIiwgdXJsY2FsbCk7XG4gICAgICAgICAgICBjZGIoXCJQT1NUIG91dDogXCIsIHNvbGFqc29ub3V0KTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gY3JlYXRlUGlwZWxpbmVTdWNjZXNzKGJ0biwganNvbikge1xuICAgICAgICAgICAgICAgIGVzdGltYXRlTGFkZGEuc3RvcCgpOyAvLyBzdG9wIHNwaW5uZXJcblxuICAgICAgICAgICAgICAgIGxldCB0cmFpbkZlYXR1cmVzPWFwaUZlYXR1cmUoanNvbi5wcmVkaWN0b3JzLHVyaS5mZWF0dXJlcyk7XG4gICAgICAgICAgICAgICAgbGV0IHRhcmdldEZlYXR1cmVzPWFwaUZlYXR1cmUoanNvbi5kZXB2YXIsdXJpLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgbGV0IHRhc2sgPSBkM21UYXNrVHlwZVtkM21Qcm9ibGVtRGVzY3JpcHRpb24udGFza1R5cGVdWzFdO1xuICAgICAgICAgICAgICAgIGxldCB0YXNrU3VidHlwZSA9IGQzbVRhc2tTdWJ0eXBlW2QzbVByb2JsZW1EZXNjcmlwdGlvbi50YXNrU3VidHlwZV1bMV07XG4gICAgICAgICAgICAgICAgbGV0IG91dHB1dCA9IGQzbU91dHB1dFR5cGVbZDNtUHJvYmxlbURlc2NyaXB0aW9uLm91dHB1dFR5cGVdWzFdO1xuICAgICAgICAgICAgICAgIGxldCBtZXRyaWNzID0gW2QzbU1ldHJpY3NbZDNtUHJvYmxlbURlc2NyaXB0aW9uLm1ldHJpY11bMV1dO1xuICAgICAgICAgICAgICAgIGxldCB0YXNrRGVzY3JpcHRpb24gPSBkM21Qcm9ibGVtRGVzY3JpcHRpb24udGFza0Rlc2NyaXB0aW9ucmlwdGlvbjtcbiAgICAgICAgICAgICAgICBsZXQgbWF4UGlwZWxpbmVzID0gMTA7IC8vdXNlciB0byBzcGVjaWZ5IHRoaXMgZXZlbnR1YWxseT9cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBzZXR4VGFibGUoanNvbi5wcmVkaWN0b3JzKTtcbiAgICAgICAgICAgICAgICBsZXQgZHZ2YWx1ZXMgPSBqc29uLmR2dmFsdWVzO1xuICAgICAgICAgICAgICAgIFxuXG4gICAgICAgICAgICAgICAgbGV0IFBpcGVsaW5lQ3JlYXRlUmVxdWVzdD17Y29udGV4dCwgdHJhaW5GZWF0dXJlcywgdGFzaywgdGFza1N1YnR5cGUsIHRhc2tEZXNjcmlwdGlvbiwgb3V0cHV0LCBtZXRyaWNzLCB0YXJnZXRGZWF0dXJlcywgbWF4UGlwZWxpbmVzfTtcblxuICAgICAgICAgICAgICAgIGxldCBqc29ub3V0ID0gSlNPTi5zdHJpbmdpZnkoUGlwZWxpbmVDcmVhdGVSZXF1ZXN0KTtcblxuICAgICAgICAgICAgICAgIGxldCB1cmxjYWxsID0gZDNtVVJMICsgXCIvY3JlYXRlcGlwZWxpbmVcIjtcbiAgICAgICAgICAgICAgICB2YXIgc29sYWpzb25vdXQgPSBcImdycGNyZXF1ZXN0PVwiICsganNvbm91dDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyh1cmxjYWxsKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhzb2xhanNvbm91dCk7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gc2VuZFBpcGVsaW5lU3VjY2VzcyhidG4sIFBpcGVsaW5lQ3JlYXRlUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vcnBjIEdldEV4ZWN1dGVQaXBlbGluZVJlc3VsdHMoUGlwZWxpbmVFeGVjdXRlUmVzdWx0c1JlcXVlc3QpIHJldHVybnMgKHN0cmVhbSBQaXBlbGluZUV4ZWN1dGVSZXN1bHQpIHt9XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFBpcGVsaW5lQ3JlYXRlUmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgdG9nZ2xlUmlnaHRCdXR0b25zKFwiYWxsXCIpO1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImJ0blJlc3VsdHNcIikuY2xpY2soKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgb3VyIGZ1bmN0aW9uIGZvciB0aGUgTGlzdFBpcGVsaW5lcyBvZiBBUElcbiAgICAgICAgICAgICAgICAgICAgbGlzdHBpcGVsaW5lcygpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIG9uY2Ugd2Uga25vdyB3aGF0IFRBMiBkb2VzIHdlJ2xsIGdldCB0aGUgcGlwZWxpbmUgaWRzIGZyb20gdGhlcmVcbiAgICAgICAgICAgICAgICAgICAgLy9sZXQgcGlwZWxpbmVpZCA9IFBpcGVsaW5lQ3JlYXRlUmVzdWx0LnBpcGVsaW5laWQ7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwaXBlbGluZWlkID0gXCJpZDFcIjtcbiAgICAgICAgICAgICAgICAgICAgbGV0IFBpcGVsaW5lRXhlY3V0ZVJlc3VsdHNSZXF1ZXN0ID0ge2NvbnRleHQsIHBpcGVsaW5laWR9O1xuICAgICAgICAgICAgICAgICAgICBqc29ub3V0ID0gSlNPTi5zdHJpbmdpZnkoUGlwZWxpbmVFeGVjdXRlUmVzdWx0c1JlcXVlc3QpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdXJsY2FsbCA9IGQzbVVSTCArIFwiL2dldGV4ZWN1dGVwaXBlbGluZXJlc3VsdHNcIjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNvbGFqc29ub3V0ID0gXCJncnBjcmVxdWVzdD1cIiArIGpzb25vdXQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiR2V0RXhlY3V0ZVBpcGVsaW5lUmVzdWx0czogXCIpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhzb2xhanNvbm91dCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHVybGNhbGwpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2V0RXhlY3V0ZVBpcGVTdWNjZXNzKGJ0biwgUGlwZWxpbmVFeGVjdXRlUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwcmVzdW1hYmx5IHdlJ2xsIGJlIHJlYWRpbmcgaW4gcmVzdWx0cyBmcm9tIGEgcGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yIG5vdyBpdCdzIGp1c3QgaGFyZGNvZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhQaXBlbGluZUV4ZWN1dGVSZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHByZWR2YWxzID0gZHZ2YWx1ZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGkgPTA7IGk8cHJlZHZhbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVkdmFsc1tpXSA9IHByZWR2YWxzW2ldICogKE1hdGgucmFuZG9tKCkrLjUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHhkYXRhID0gXCJBY3R1YWxcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB5ZGF0YSA9IFwiUHJlZGljdGVkXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBiaXZhcmlhdGVQbG90KGR2dmFsdWVzLCBwcmVkdmFscywgeGRhdGEsIHlkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZXRFeGVjdXRlUGlwZUZhaWwgKGJ0bikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJHZXRFeGVjdXRlUGlwZWxpbmVSZXN1bHRzIGZhaWxlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtYWtlQ29yc1JlcXVlc3QodXJsY2FsbCwgXCJub2J1dHRvblwiLCBnZXRFeGVjdXRlUGlwZVN1Y2Nlc3MsIGdldEV4ZWN1dGVQaXBlRmFpbCwgc29sYWpzb25vdXQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNlbmRQaXBlbGluZUZhaWwoYnRuKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwicGlwZWxpbmUgdG8gZGphbmdvIGZhaWxlZFwiKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtYWtlQ29yc1JlcXVlc3QodXJsY2FsbCwgXCJub2J1dHRvblwiLCBzZW5kUGlwZWxpbmVTdWNjZXNzLCBzZW5kUGlwZWxpbmVGYWlsLCBzb2xhanNvbm91dCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVBpcGVsaW5lRmFpbChidG4pIHtcbiAgICAgICAgICAgICAgICBlc3RpbWF0ZUxhZGRhLnN0b3AoKTsgLy8gc3RvcCBzcGlubmVyXG4gICAgICAgICAgICAgICAgZXN0aW1hdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXN0aW1hdGVMYWRkYS5zdGFydCgpOyAvLyBzdGFydCBzcGlubmVyXG4gICAgICAgICAgICBtYWtlQ29yc1JlcXVlc3QodXJsY2FsbCwgYnRuLCBjcmVhdGVQaXBlbGluZVN1Y2Nlc3MsIGNyZWF0ZVBpcGVsaW5lRmFpbCwgc29sYWpzb25vdXQpO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJ1blByZXByb2Nlc3MoZGF0YWxvYywgdGFyZ2V0bG9jLCBkYXRhc3R1Yikge1xuICAgIGxldCB1cmwgPSByYXBwVVJMICsgJ3ByZXByb2Nlc3NhcHAnO1xuICAgIGNvbnNvbGUubG9nKFwiR09JTkcgVE8gUlVOIFRIRSBQUkVQUk9DRVNTQVBQXCIpO1xuICAgIGxldCBqc29uID0gSlNPTi5zdHJpbmdpZnkoe2RhdGE6IGRhdGFsb2MsIHRhcmdldDogdGFyZ2V0bG9jLCBkYXRhc3R1YjogZGF0YXN0dWJ9KTsgLy8sIHByZXByb2Nlc3M6IHByZXByb2Nlc3Nsb2N9KTtcbiAgICBjb25zb2xlLmxvZygndXJsY2FsbCBvdXQ6ICcsIHVybCk7XG4gICAgY29uc29sZS5sb2coJ1BPU1Qgb3V0OiAnLCBqc29uKTtcbiAgICBsZXQgZGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgIGRhdGEuYXBwZW5kKCdzb2xhSlNPTicsIGpzb24pO1xuICAgIHJldHVybiBtLnJlcXVlc3Qoe21ldGhvZDogJ1BPU1QnLCB1cmw6IHVybCwgZGF0YTogZGF0YX0pXG4gICAgICAgIC50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2pzb24gaW4gUklHSFQgSEVSRTogJywgZGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSwgXyA9PiBjb25zb2xlLmxvZygncHJlcHJvY2VzcyBmYWlsZWQnKSk7XG59XG5cbmV4cG9ydCBsZXQgdGEyc3R1ZmYgPSBfID0+IGNvbnNvbGUubG9nKGQzbVByb2JsZW1EZXNjcmlwdGlvbik7XG5cbmZ1bmN0aW9uIGRhdGFEb3dubG9hZCgpIHtcbiAgICB6UG9wKCk7XG4gICAgLy8gd3JpdGUgbGlua3MgdG8gZmlsZSAmIHJ1biBSIENNRFxuXG4gICAgLy9wYWNrYWdlIHRoZSBvdXRwdXQgYXMgSlNPTlxuICAgIC8vIGFkZCBjYWxsIGhpc3RvcnkgYW5kIHBhY2thZ2UgdGhlIHpwYXJhbXMgb2JqZWN0IGFzIEpTT05cbiAgICB2YXIganNvbm91dCA9IEpTT04uc3RyaW5naWZ5KHpwYXJhbXMpO1xuICAgIHZhciBidG4gPSBcIm5vYnV0dG9uXCI7XG5cbiAgICB2YXIgdXJsY2FsbCA9IHJhcHBVUkwgKyBcImRhdGFhcHBcIjtcbiAgICB2YXIgc29sYWpzb25vdXQgPSBcInNvbGFKU09OPVwiICsganNvbm91dDtcbiAgICBjZGIoXCJ1cmxjYWxsIG91dDogXCIsIHVybGNhbGwpO1xuICAgIGNkYihcIlBPU1Qgb3V0OiBcIiwgc29sYWpzb25vdXQpO1xuXG4gICAgbGV0IGRvd25sb2FkU3VjY2VzcyA9IChidG4sIGpzb24pID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ2RhdGFkb3dubG9hZDogJywganNvbik7XG4gICAgICAgIGNkYignZGF0YURvd25sb2FkIGpzb24gaW46ICcsIGpzb24pO1xuICAgICAgICB6cGFyYW1zLnpzZXNzaW9uaWQgPSBqc29uLnNlc3Npb25pZFswXTtcbiAgICAgICAgLy8gc2V0IGxpbmsgVVJMXG4gICAgICAgIGJ5SWQoXCJsb2dJRFwiKS5ocmVmID0gYCR7cHJvZHVjdGlvbiA/IHJhcHBVUkwgKyAnbG9nX2Rpci9sb2dfJyA6ICdyb29rL2xvZ18nIH0ke3pwYXJhbXMuenNlc3Npb25pZH0udHh0YDtcbiAgICB9O1xuICAgIGxldCBkb3dubG9hZEZhaWwgPSBfID0+IGNkYignRGF0YSBoYXZlIG5vdCBiZWVuIGRvd25sb2FkZWQnKTtcbiAgICBtYWtlQ29yc1JlcXVlc3QodXJsY2FsbCwgYnRuLCBkb3dubG9hZFN1Y2Nlc3MsIGRvd25sb2FkRmFpbCwgc29sYWpzb25vdXQpO1xufVxuXG5mdW5jdGlvbiB2aXoobXltKSB7XG4gICAgdmFyIG15bSA9ICtteW0uc3Vic3RyKDUsIDUpIC0gMTtcblxuICAgIGZ1bmN0aW9uIHJlbW92ZUtpZHMocGFyZW50KSB7XG4gICAgICAgIHdoaWxlIChwYXJlbnQuZmlyc3RDaGlsZClcbiAgICAgICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChwYXJlbnQuZmlyc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgcmVtb3ZlS2lkcyhieUlkKFwicmVzdWx0c1ZpZXdcIikpO1xuXG4gICAgbGV0IGpzb24gPSBhbGxSZXN1bHRzW215bV07XG5cbiAgICAvLyBwaXBlIGluIGZpZ3VyZXMgdG8gcmlnaHQgcGFuZWxcbiAgICB2YXIgZmlsZWxpc3QgPSBuZXcgQXJyYXk7XG4gICAgZm9yICh2YXIgaSBpbiBqc29uLmltYWdlcykge1xuICAgICAgICB2YXIgemZpZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG4gICAgICAgIHpmaWcuc2V0QXR0cmlidXRlKFwic3JjXCIsIGpzb24uaW1hZ2VzW2ldKTtcbiAgICAgICAgemZpZy5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgMjAwKTtcbiAgICAgICAgemZpZy5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIDIwMCk7XG4gICAgICAgIGJ5SWQoXCJyZXN1bHRzVmlld1wiKS5hcHBlbmRDaGlsZCh6ZmlnKTtcbiAgICB9XG5cbiAgICAvLyB3cml0ZSB0aGUgcmVzdWx0cyB0YWJsZVxuICAgIHZhciByZXN1bHRzQXJyYXkgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4ganNvbi5zdW1JbmZvKSB7XG4gICAgICAgIGlmIChrZXkgPT0gJ2NvbG5hbWVzJylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICByZXN1bHRzQXJyYXkucHVzaChqc29uLnN1bUluZm9ba2V5XSk7XG4gICAgfVxuXG4gICAgdmFyIHRhYmxlID0gZDMuc2VsZWN0KFwiI3Jlc3VsdHNWaWV3XCIpXG4gICAgICAgIC5hcHBlbmQoXCJwXCIpXG4gICAgICAgIC5hcHBlbmQoXCJ0YWJsZVwiKTtcblxuICAgIHZhciB0aGVhZCA9IHRhYmxlLmFwcGVuZChcInRoZWFkXCIpO1xuICAgIHRoZWFkLmFwcGVuZChcInRyXCIpXG4gICAgICAgIC5zZWxlY3RBbGwoXCJ0aFwiKVxuICAgICAgICAuZGF0YShqc29uLnN1bUluZm8uY29sbmFtZXMpXG4gICAgICAgIC5lbnRlcigpXG4gICAgICAgIC5hcHBlbmQoXCJ0aFwiKVxuICAgICAgICAudGV4dChkID0+IGQpO1xuXG4gICAgdmFyIHRib2R5ID0gdGFibGUuYXBwZW5kKFwidGJvZHlcIik7XG4gICAgdGJvZHkuc2VsZWN0QWxsKFwidHJcIilcbiAgICAgICAgLmRhdGEocmVzdWx0c0FycmF5KVxuICAgICAgICAuZW50ZXIoKS5hcHBlbmQoXCJ0clwiKVxuICAgICAgICAuc2VsZWN0QWxsKFwidGRcIilcbiAgICAgICAgLmRhdGEoZCA9PiBkKVxuICAgICAgICAuZW50ZXIoKS5hcHBlbmQoXCJ0ZFwiKVxuICAgICAgICAudGV4dChmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICB2YXIgbXlOdW0gPSBOdW1iZXIoZCk7XG4gICAgICAgICAgICBpZiAoaXNOYU4obXlOdW0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgICAgcmV0dXJuIG15TnVtLnRvUHJlY2lzaW9uKDMpO1xuICAgICAgICB9KVxuICAgICAgICAub24oXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuc3R5bGUoXCJiYWNrZ3JvdW5kLWNvbG9yXCIsIFwiYWxpY2VibHVlXCIpO1xuICAgICAgICB9KSAvLyBmb3Igbm8gZGlzY2VybmFibGUgcmVhc29uXG4gICAgICAgIC5vbihcIm1vdXNlb3V0XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnN0eWxlKFwiYmFja2dyb3VuZC1jb2xvclwiLCBcIiNGOUY5RjlcIik7XG4gICAgICAgIH0pOyAvLyhidXQgbWF5YmUgd2UnbGwgdGhpbmsgb2Ygb25lKVxuXG4gICAgZDMuc2VsZWN0KFwiI3Jlc3VsdHNWaWV3XCIpXG4gICAgICAgIC5hcHBlbmQoXCJwXCIpXG4gICAgICAgIC5odG1sKCgpID0+IFwiPGI+Rm9ybXVsYTogPC9iPlwiLmNvbmNhdChqc29uLmNhbGxbMF0pKTtcblxuICAgIG0ucmVkcmF3KCk7XG59XG5cbi8vIHBhcnNlcyB0aGUgdHJhbnNmb3JtYXRpb24gaW5wdXQuIHZhcmlhYmxlIG5hbWVzIGFyZSBvZnRlbiBuZXN0ZWQgaW5zaWRlIG9uZSBhbm90aGVyLCBlLmcuLCBldGh3YXIsIHdhciwgd2FycywgYW5kIHNvIHRoaXMgaXMgaGFuZGxlZFxuZnVuY3Rpb24gdHJhbnNQYXJzZShuKSB7XG4gICAgdmFyIG91dDIgPSBbXTtcbiAgICB2YXIgdDIgPSBuO1xuICAgIHZhciBrMiA9IDA7XG4gICAgdmFyIHN1Yk1lMiA9IFwiX3RyYW5zdmFyXCIuY29uY2F0KGsyKTtcbiAgICB2YXIgaW5kZXhlZCA9IFtdO1xuXG4gICAgLy8gb3V0MiBpcyBhbGwgbWF0Y2hlZCB2YXJpYWJsZXMsIGluZGV4ZWQgaXMgYW4gYXJyYXksIGVhY2ggZWxlbWVudCBpcyBhbiBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgbWF0Y2hlZCB2YXJpYWJsZXMgc3RhcnRpbmcgaW5kZXggYW5kIGZpbmlzaGluZyBpbmRleC4gIGUuZy4sIG49XCJ3YXJzKzJcIiwgb3V0Mj1bd2FyLCB3YXJzXSwgaW5kZXhlZD1bezAsMn0sezAsM31dXG4gICAgZm9yICh2YXIgaSBpbiB2YWx1ZUtleSkge1xuICAgICAgICB2YXIgbTIgPSBuLm1hdGNoKHZhbHVlS2V5W2ldKTtcbiAgICAgICAgaWYgKG0yICE9IG51bGwpXG4gICAgICAgICAgICBvdXQyLnB1c2gobTJbMF0pO1xuXG4gICAgICAgIHZhciByZSA9IG5ldyBSZWdFeHAodmFsdWVLZXlbaV0sIFwiZ1wiKTtcbiAgICAgICAgdmFyIHMgPSBuLnNlYXJjaChyZSk7XG4gICAgICAgIGlmIChzICE9IC0xKVxuICAgICAgICAgICAgaW5kZXhlZC5wdXNoKHtmcm9tOiBzLCB0bzogcyArIHZhbHVlS2V5W2ldLmxlbmd0aH0pO1xuICAgIH1cblxuICAgIC8vIG5lc3RlZCBsb29wIG5vdCBnb29kLCBidXQgaW5kZXhlZCBpcyBub3QgbGlrZWx5IHRvIGJlIHZlcnkgbGFyZ2UuXG4gICAgLy8gaWYgYSB2YXJpYWJsZSBpcyBuZXN0ZWQsIGl0IGlzIHJlbW92ZWQgZnJvbSBvdXQyXG4gICAgLy8gbm90aWNlLCBsb29wIGlzIGJhY2t3YXJkcyBzbyB0aGF0IGluZGV4IGNoYW5nZXMgZG9uJ3QgYWZmZWN0IHRoZSBzcGxpY2VcbiAgICBjZGIoXCJpbmRleGVkIFwiLCBpbmRleGVkKTtcbiAgICBmb3IgKHZhciBpID0gaW5kZXhlZC5sZW5ndGggLSAxOyBpID4gLTE7IGktLSkge1xuICAgICAgICBmb3IgKHZhciBqID0gaW5kZXhlZC5sZW5ndGggLSAxOyBqID4gLTE7IGotLSkge1xuICAgICAgICAgICAgaWYgKGkgPT09IGopXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoKGluZGV4ZWRbaV0uZnJvbSA+PSBpbmRleGVkW2pdLmZyb20pICYgKGluZGV4ZWRbaV0udG8gPD0gaW5kZXhlZFtqXS50bykpIHtcbiAgICAgICAgICAgICAgICBjZGIoaSwgXCIgaXMgbmVzdGVkIGluIFwiLCBqKTtcbiAgICAgICAgICAgICAgICBvdXQyLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGkgaW4gb3V0Mikge1xuICAgICAgICB0MiA9IHQyLnJlcGxhY2Uob3V0MltpXSwgc3ViTWUyKTsgLy9zb21ldGhpbmcgdGhhdCdsbCBuZXZlciBiZSBhIHZhcmlhYmxlIG5hbWVcbiAgICAgICAgazIgPSBrMiArIDE7XG4gICAgICAgIHN1Yk1lMiA9IFwiX3RyYW5zdmFyXCIuY29uY2F0KGsyKTtcbiAgICB9XG5cbiAgICBpZiAob3V0Mi5sZW5ndGggPiAwKSB7XG4gICAgICAgIG91dDIucHVzaCh0Mik7XG4gICAgICAgIGNkYihcIm5ldyBvdXQgXCIsIG91dDIpO1xuICAgICAgICByZXR1cm4gKG91dDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGFsZXJ0KFwiTm8gdmFyaWFibGUgbmFtZSBmb3VuZC4gUGVyaGFwcyBjaGVjayB5b3VyIHNwZWxsaW5nP1wiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuXG4vKipcbiAgbiA9IG5hbWUgb2YgY29sdW1uL25vZGVcbiAgdCA9IHNlbGVjdGVkIHRyYW5zZm9ybWF0aW9uXG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybShuLCB0LCB0eXBlVHJhbnNmb3JtKSB7XG4gICAgaWYgKHByb2R1Y3Rpb24gJiYgenBhcmFtcy56c2Vzc2lvbmlkID09IFwiXCIpIHtcbiAgICAgICAgYWxlcnQoXCJXYXJuaW5nOiBEYXRhIGRvd25sb2FkIGlzIG5vdCBjb21wbGV0ZS4gVHJ5IGFnYWluIHNvb24uXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdHlwZVRyYW5zZm9ybSlcbiAgICAgICAgdCA9IHQucmVwbGFjZShcIitcIiwgXCJfcGx1c19cIik7IC8vIGNhbid0IHNlbmQgdGhlIHBsdXMgb3BlcmF0b3JcblxuICAgIGNkYignbmFtZSBvZiBjb2w6ICcgKyBuKTtcbiAgICBjZGIoJ3RyYW5zZm9ybWF0aW9uOiAnICsgdCk7XG5cbiAgICB2YXIgYnRuID0gYnlJZCgnYnRuRXN0aW1hdGUnKTtcblxuICAgIC8vIGZpbmQgdGhlIG5vZGUgYnkgbmFtZVxuICAgIHZhciBteW4gPSBmaW5kTm9kZUluZGV4KG5bMF0sIHRydWUpO1xuXG4gICAgaWYgKHR5cGVvZiBteW4gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgbXluID0gZmluZE5vZGVJbmRleChuLCB0cnVlKTtcbiAgICB9XG5cbiAgICB2YXIgb3V0dHlwZXMgPSB7XG4gICAgICAgIHZhcm5hbWVzVHlwZXM6IG4sXG4gICAgICAgIGludGVydmFsOiBteW4uaW50ZXJ2YWwsXG4gICAgICAgIG51bWNoYXI6IG15bi5udW1jaGFyLFxuICAgICAgICBuYXR1cmU6IG15bi5uYXR1cmUsXG4gICAgICAgIGJpbmFyeTogbXluLmJpbmFyeVxuICAgIH07XG5cbiAgICBjZGIobXluKTtcbiAgICAvLyBpZiB0eXBlVHJhbnNmb3JtIGJ1dCB3ZSBhbHJlYWR5IGhhdmUgdGhlIG1ldGFkYXRhXG4gICAgaWYgKHR5cGVUcmFuc2Zvcm0pIHtcbiAgICAgICAgaWYgKG15bi5uYXR1cmUgPT0gXCJub21pbmFsXCIgJiB0eXBlb2YgbXluLnBsb3R2YWx1ZXMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIG15bi5wbG90dHlwZSA9IFwiYmFyXCI7XG4gICAgICAgICAgICBiYXJzTm9kZShteW4pO1xuICAgICAgICAgICAgcGFuZWxQbG90cygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKG15bi5uYXR1cmUgIT0gXCJub21pbmFsXCIgJiB0eXBlb2YgbXluLnBsb3R4ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBteW4ucGxvdHR5cGUgPSBcImNvbnRpbnVvdXNcIjtcbiAgICAgICAgICAgIGRlbnNpdHlOb2RlKG15bik7XG4gICAgICAgICAgICBwYW5lbFBsb3RzKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvL3BhY2thZ2UgdGhlIG91dHB1dCBhcyBKU09OXG4gICAgdmFyIHRyYW5zZm9ybXN0dWZmID0ge1xuICAgICAgICB6ZGF0YXVybDogZGF0YXVybCxcbiAgICAgICAgenZhcnM6IG15bi5uYW1lLFxuICAgICAgICB6c2Vzc2lvbmlkOiB6cGFyYW1zLnpzZXNzaW9uaWQsXG4gICAgICAgIHRyYW5zZm9ybTogdCxcbiAgICAgICAgY2FsbEhpc3Rvcnk6IGNhbGxIaXN0b3J5LFxuICAgICAgICB0eXBlVHJhbnNmb3JtOiB0eXBlVHJhbnNmb3JtLFxuICAgICAgICB0eXBlU3R1ZmY6IG91dHR5cGVzXG4gICAgfTtcbiAgICB2YXIganNvbm91dCA9IEpTT04uc3RyaW5naWZ5KHRyYW5zZm9ybXN0dWZmKTtcbiAgICB2YXIgdXJsY2FsbCA9IHJhcHBVUkwgKyBcInRyYW5zZm9ybWFwcFwiO1xuICAgIHZhciBzb2xhanNvbm91dCA9IFwic29sYUpTT049XCIgKyBqc29ub3V0O1xuICAgIGNkYihcInVybGNhbGwgb3V0OiBcIiArIHVybGNhbGwpO1xuICAgIGNkYihcIlBPU1Qgb3V0OiBcIiArIHNvbGFqc29ub3V0KTtcblxuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybVN1Y2Nlc3MoYnRuLCBqc29uKSB7XG4gICAgICAgIGVzdGltYXRlTGFkZGEuc3RvcCgpO1xuICAgICAgICBjZGIoXCJqc29uIGluOiBcIiArIEpTT04uc3RyaW5naWZ5KGpzb24pKTtcblxuICAgICAgICAvLyBJcyB0aGlzIGEgdHlwZVRyYW5zZm9ybT9cbiAgICAgICAgaWYgKGpzb24udHlwZVRyYW5zZm9ybVswXSkge1xuICAgICAgICAgICAgLy8gWWVzLiBXZSdyZSB1cGRhdGluZyBhbiBleGlzdGluZyBub2RlXG4gICAgICAgICAgICBkMy5qc29uKGpzb24udXJsLCAoZXJyLCBkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybihlcnIpO1xuICAgICAgICAgICAgICAgIGxldCBub2RlO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBmaW5kTm9kZUluZGV4KGtleSwgdHJ1ZSk7XG5cdFx0ICAgIGlmICghbm9kZSlcblx0XHQgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXh0ZW5kKHRydWUsIG5vZGUsIGRhdGFba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUucGxvdHR5cGUgPT09IFwiY29udGludW91c1wiID8gZGVuc2l0eU5vZGUobm9kZSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5wbG90dHlwZSA9PT0gXCJiYXJcIiA/IGJhcnNOb2RlKG5vZGUpIDogbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmFrZUNsaWNrKCk7XG4gICAgICAgICAgICAgICAgcGFuZWxQbG90cygpO1xuICAgICAgICAgICAgICAgIG5vZGUgJiYgY2RiKG5vZGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLyogTm8sIHdlIGhhdmUgYSBuZXcgbm9kZSBoZXJlLS1lLmcuIHRoZSB0cmFuc2Zvcm1lZCBjb2x1bW5cbiAgICAgICAgICAgICAgIGV4YW1wbGUgcmVzcG9uc2U6IHtcbiAgICAgICAgICAgICAgIFwiY2FsbFwiOltcInRfeWVhcl8yXCJdLFxuICAgICAgICAgICAgICAgXCJ1cmxcIjpbXCJkYXRhL3ByZXByb2Nlc3NTdWJzZXRfQkFDQ0JDNzgtN0REOS00NDgyLUIzMUQtNkVCMDFDM0EwQzk1LnR4dFwiXSxcbiAgICAgICAgICAgICAgIFwidHJhbnNcIjpbXCJ5ZWFyXCIsXCJfdHJhbnN2YXIwXjJcIl0sXG4gICAgICAgICAgICAgICBcInR5cGVUcmFuc2Zvcm1cIjpbZmFsc2VdXG4gICAgICAgICAgICAgfVxuICAgICAgICAgICovXG4gICAgICAgICAgICBjYWxsSGlzdG9yeS5wdXNoKHtcbiAgICAgICAgICAgICAgICBmdW5jOiBcInRyYW5zZm9ybVwiLFxuICAgICAgICAgICAgICAgIHp2YXJzOiBuLFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogdFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciBzdWJzZXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIHJDYWxsID0gW107XG5cbiAgICAgICAgICAgIHJDYWxsWzBdID0ganNvbi5jYWxsO1xuICAgICAgICAgICAgdmFyIG5ld1ZhciA9IHJDYWxsWzBdWzBdO1xuXG4gICAgICAgICAgICB0cmFucy5wdXNoKG5ld1Zhcik7XG5cbiAgICAgICAgICAgIC8vIFJlYWQgdGhlIHByZXByb2Nlc3MgZmlsZSBjb250YWluaW5nIHZhbHVlc1xuICAgICAgICAgICAgLy8gZm9yIHRoZSB0cmFuc2Zvcm1lZCB2YXJpYWJsZVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIGQzLmpzb24oanNvbi51cmwsIGZ1bmN0aW9uKGVycm9yLCBqc29uKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gY29uc29sZS53YXJuKGVycm9yKTtcblxuICAgICAgICAgICAgICAgIHZhciBqc29uZGF0YSA9IGdldFZhcmlhYmxlRGF0YShqc29uKTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBqc29uZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbXlJbmRleCA9IGZpbmROb2RlSW5kZXgoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBteUluZGV4ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGVydChcIkludmFsaWQgdHJhbnNmb3JtYXRpb246IHRoaXMgdmFyaWFibGUgbmFtZSBhbHJlYWR5IGV4aXN0cy5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIHRyYW5zZm9ybWVkIHZhcmlhYmxlIHRvIHRoZSBjdXJyZW50IHNwYWNlXG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gYWxsTm9kZXMubGVuZ3RoOyAgLy8gZ2V0IG5ldyBpbmRleFxuICAgICAgICAgICAgICAgICAgICB2YXIgb2JqMSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmbGV4aXZlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmw6IFwidHJhbnNmb3JtbGFiZWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IFs1LCAxNSwgMjAsIDAsIDUsIDE1LCAyMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudDogWy42LCAuMiwgLjksIC44LCAuMSwgLjMsIC40XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVDb2w6IGNvbG9ycyhpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VDb2w6IGNvbG9ycyhpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZUNvbG9yOiBzZWxWYXJDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiBcIjFcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNldHBsb3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2V0cmFuZ2U6IFtcIlwiLCBcIlwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHhwbG90OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHh2YWxzOiBbXCJcIiwgXCJcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBncmF5b3V0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRJbnRlcnZhbDoganNvbmRhdGFba2V5XS5pbnRlcnZhbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHROdW1jaGFyOiBqc29uZGF0YVtrZXldLm51bWNoYXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0TmF0dXJlOiBqc29uZGF0YVtrZXldLm5hdHVyZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRCaW5hcnk6IGpzb25kYXRhW2tleV0uYmluYXJ5XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmV4dGVuZCh0cnVlLCBvYmoxLCBqc29uZGF0YVtrZXldKTtcbiAgICAgICAgICAgICAgICAgICAgYWxsTm9kZXMucHVzaChvYmoxKTtcblxuICAgICAgICAgICAgICAgICAgICB2YWx1ZUtleS5wdXNoKG5ld1Zhcik7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLnB1c2goYWxsTm9kZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICBmYWtlQ2xpY2soKTtcbiAgICAgICAgICAgICAgICAgICAgcGFuZWxQbG90cygpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbGxOb2Rlc1tpXS5wbG90dHlwZSA9PT0gXCJjb250aW51b3VzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbnNpdHlOb2RlKGFsbE5vZGVzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhbGxOb2Rlc1tpXS5wbG90dHlwZSA9PT0gXCJiYXJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFyc05vZGUoYWxsTm9kZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbS5yZWRyYXcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgc2hvd0xvZygndHJhbnNmb3JtJywgckNhbGwpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtRmFpbChidG4pIHtcbiAgICAgICAgYWxlcnQoXCJ0cmFuc2Zvcm0gZmFpbFwiKTtcbiAgICAgICAgZXN0aW1hdGVMYWRkYS5zdG9wKCk7XG4gICAgfVxuXG4gICAgZXN0aW1hdGVMYWRkYS5zdGFydCgpOyAvLyBzdGFydCBzcGlubmVyXG4gICAgbWFrZUNvcnNSZXF1ZXN0KHVybGNhbGwsIGJ0biwgdHJhbnNmb3JtU3VjY2VzcywgdHJhbnNmb3JtRmFpbCwgc29sYWpzb25vdXQpO1xufVxuXG4vLyBiZWxvdyBmcm9tIGh0dHA6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vdHV0b3JpYWxzL2NvcnMvIGZvciBjcm9zcy1vcmlnaW4gcmVzb3VyY2Ugc2hhcmluZ1xuLy8gQ3JlYXRlIHRoZSBYSFIgb2JqZWN0LlxuZnVuY3Rpb24gY3JlYXRlQ09SU1JlcXVlc3QobWV0aG9kLCB1cmwsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIGlmIChcIndpdGhDcmVkZW50aWFsc1wiIGluIHhocikge1xuICAgICAgICAvLyBYSFIgZm9yIENocm9tZS9GaXJlZm94L09wZXJhL1NhZmFyaS5cbiAgICAgICAgeGhyLm9wZW4obWV0aG9kLCB1cmwsIHRydWUpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIFhEb21haW5SZXF1ZXN0ICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgLy8gWERvbWFpblJlcXVlc3QgZm9yIElFLlxuICAgICAgICB4aHIgPSBuZXcgWERvbWFpblJlcXVlc3QoKTtcbiAgICAgICAgeGhyLm9wZW4obWV0aG9kLCB1cmwpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENPUlMgbm90IHN1cHBvcnRlZC5cbiAgICAgICAgeGhyID0gbnVsbDtcbiAgICB9XG4gICAgLy8geGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICd0ZXh0L3BsYWluJyk7XG4gICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnKTtcbiAgICByZXR1cm4geGhyO1xufVxuXG4vLyBNYWtlIHRoZSBhY3R1YWwgQ09SUyByZXF1ZXN0LlxuZnVuY3Rpb24gbWFrZUNvcnNSZXF1ZXN0KHVybCwgYnRuLCBjYWxsYmFjaywgd2FybmluZ2NhbGxiYWNrLCBqc29uc3RyaW5nKSB7XG4gICAgdmFyIHhociA9IGNyZWF0ZUNPUlNSZXF1ZXN0KCdQT1NUJywgdXJsKTtcbiAgICBpZiAoIXhocikge1xuICAgICAgICBhbGVydCgnQ09SUyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gUmVzcG9uc2UgaGFuZGxlcnMgZm9yIGFzeW5jaHJvbm91cyBsb2FkXG4gICAgLy8gb25sb2FkIG9yIG9ucmVhZHlzdGF0ZWNoYW5nZT9cblxuICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRleHQgPSB4aHIucmVzcG9uc2VUZXh0O1xuICAgICAgICBjZGIoXCJ0ZXh0IFwiLCB0ZXh0KTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGpzb24gPSBKU09OLnBhcnNlKHRleHQpOyAvLyBzaG91bGQgd3JhcCBpbiB0cnkgLyBjYXRjaFxuICAgICAgICAgICAgdmFyIG5hbWVzID0gT2JqZWN0LmtleXMoanNvbik7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgZXN0aW1hdGVMYWRkYS5zdG9wKCk7XG4gICAgICAgICAgICBzZWxlY3RMYWRkYS5zdG9wKCk7XG4gICAgICAgICAgICBjZGIoZXJyKTtcbiAgICAgICAgICAgIGFsZXJ0KCdFcnJvcjogQ291bGQgbm90IHBhcnNlIGluY29taW5nIEpTT04uJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmFtZXNbMF0gPT0gXCJ3YXJuaW5nXCIpIHtcbiAgICAgICAgICAgIHdhcm5pbmdjYWxsYmFjayhidG4pO1xuICAgICAgICAgICAgYWxlcnQoXCJXYXJuaW5nOiBcIiArIGpzb24ud2FybmluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjayhidG4sIGpzb24pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBub3RlOiB4aHIucmVhZHlzdGF0ZSBzaG91bGQgYmUgNCBhbmQgc3RhdHVzIHNob3VsZCBiZSAyMDAuIGEgc3RhdHVzIG9mIDAgb2NjdXJzIHdoZW4gdGhlIHVybCBpcyB0b28gbGFyZ2VcbiAgICAgICAgeGhyLnN0YXR1cyA9PSAwID8gYWxlcnQoJ1RoZXJlIHdhcyBhbiBlcnJvciBtYWtpbmcgdGhlIHJlcXVlc3QuIHhtbGh0dHByZXF1ZXN0IHN0YXR1cyBpcyAwLicpIDpcbiAgICAgICAgICAgIHhoci5yZWFkeVN0YXRlICE9IDQgPyBhbGVydCgnVGhlcmUgd2FzIGFuIGVycm9yIG1ha2luZyB0aGUgcmVxdWVzdC4geG1saHR0cHJlcXVlc3QgcmVhZHlzdGF0ZSBpcyBub3QgNC4nKSA6XG4gICAgICAgICAgICBhbGVydCgnV29vcHMsIHRoZXJlIHdhcyBhbiBlcnJvciBtYWtpbmcgdGhlIHJlcXVlc3QuJyk7XG4gICAgICAgIGNkYih4aHIpO1xuICAgICAgICBlc3RpbWF0ZUxhZGRhLnN0b3AoKTtcbiAgICAgICAgc2VsZWN0TGFkZGEuc3RvcCgpO1xuICAgIH07XG4gICAgeGhyLnNlbmQoanNvbnN0cmluZyk7XG59XG5cbmV4cG9ydCBsZXQgbGVnZW5kID0gXyA9PiB7XG4gICAgYm9yZGVyU3RhdGUoKTtcbiAgICBtLnJlZHJhdygpO1xufTtcblxuLy8gcHJvZ3JhbW1hdGljYWxseSBkZXNlbGVjdCBldmVyeSBzZWxlY3RlZCB2YXJpYWJsZVxuZXhwb3J0IGZ1bmN0aW9uIGVyYXNlKCkge1xuICAgIGxlZnRwYW5lbE1lZGl1bSgpO1xuICAgIHJpZ2h0cGFuZWxNZWRpdW0oKTtcbiAgICB0YWJMZWZ0KCd0YWIxJyk7XG4gICAgalF1ZXJ5LmZuLmQzQ2xpY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbigpLmVhY2goZnVuY3Rpb24oaSwgZSkge1xuICAgICAgICAgICAgdmFyIG15Y29sID0gZDMucmdiKHRoaXMuc3R5bGUuYmFja2dyb3VuZENvbG9yKTtcbiAgICAgICAgICAgIGlmIChteWNvbC50b1N0cmluZygpID09PSB2YXJDb2xvci50b1N0cmluZygpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIk1vdXNlRXZlbnRzXCIpO1xuICAgICAgICAgICAgZXZ0LmluaXRNb3VzZUV2ZW50KFwiY2xpY2tcIiwgdHJ1ZSwgdHJ1ZSwgd2luZG93LCAwLCAwLCAwLCAwLCAwLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgMCwgbnVsbCk7XG4gICAgICAgICAgICBlLmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAkKFwiI3Zhckxpc3RcIikuZDNDbGljaygpO1xufVxuXG4vLyBodHRwOi8vd3d3LnR1dG9yaWFsczJsZWFybi5jb20vdHV0b3JpYWxzL3NjcmlwdHMvamF2YXNjcmlwdC94bWwtcGFyc2VyLWphdmFzY3JpcHQuaHRtbFxuZnVuY3Rpb24gbG9hZFhNTERvYyhYTUxuYW1lKSB7XG4gICAgdmFyIHhtbERvYztcbiAgICBpZiAod2luZG93LlhNTEh0dHBSZXF1ZXN0KSB7XG4gICAgICAgIHhtbERvYyA9IG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgeG1sRG9jLm9wZW4oXCJHRVRcIiwgWE1MbmFtZSwgZmFsc2UpO1xuICAgICAgICB4bWxEb2Muc2VuZChcIlwiKTtcbiAgICAgICAgcmV0dXJuIHhtbERvYy5yZXNwb25zZVhNTDtcbiAgICB9XG4gICAgLy8gSUUgNSBhbmQgSUUgNlxuICAgIGVsc2UgaWYgKEFjdGl2ZVhPYmplY3QoXCJNaWNyb3NvZnQuWE1MRE9NXCIpKSB7XG4gICAgICAgIHhtbERvYyA9IG5ldyBBY3RpdmVYT2JqZWN0KFwiTWljcm9zb2Z0LlhNTERPTVwiKTtcbiAgICAgICAgeG1sRG9jLmFzeW5jID0gZmFsc2U7XG4gICAgICAgIHhtbERvYy5sb2FkKFhNTG5hbWUpO1xuICAgICAgICByZXR1cm4geG1sRG9jO1xuICAgIH1cbiAgICBhbGVydChcIkVycm9yIGxvYWRpbmcgZG9jdW1lbnQhXCIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGFiTGVmdCh0YWIpIHtcbiAgICBieUlkKCd0YWIxJykuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBieUlkKCd0YWIyJykuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBieUlkKCd0YWIzJykuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBieUlkKHRhYikuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgaWYgKHRhYiAhPSAndGFiMycpIHtcbiAgICAgICAgc3Vic2V0ID0gdGFiID09ICd0YWIyJztcbiAgICAgICAgc3VtbWFyeUhvbGQgPSBmYWxzZTtcbiAgICB9XG4gICAgbGVmdHRhYiA9IHRhYjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRhYlJpZ2h0KHRhYikge1xuICAgIGxldCBzZWxlY3QgPSBjbHMgPT4ge1xuICAgICAgICBsZXQgcGFuZWwgPSBkMy5zZWxlY3QoXCIjcmlnaHRwYW5lbFwiKTtcbiAgICAgICAgcmV0dXJuIGNscyA/IHBhbmVsLmF0dHIoJ2NsYXNzJywgY2xzKSA6IHBhbmVsLmF0dHIoJ2NsYXNzJyk7XG4gICAgfTtcbiAgICBsZXQgY2xzID0gXCJzaWRlcGFuZWwgY29udGFpbmVyIGNsZWFyZml4XCI7XG4gICAgbGV0IHRvZ2dsZVIgPSAoKSA9PiB7XG4gICAgICAgIHNlbGVjdChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGxldCBleHBhbmQgPSBjbHMgKyAnIGV4cGFuZHBhbmVsJztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpID09PSBleHBhbmQgPyBjbHMgOiBleHBhbmQ7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgbGV0IHRvZ2dsZVJGdWxsID0gKCkgPT4ge1xuICAgICAgICBzZWxlY3QoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICBsZXQgZXhwYW5kID0gY2xzICsgJyBleHBhbmRwYW5lbGZ1bGwnO1xuICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgPT09IGV4cGFuZCA/IGNscyA6IGV4cGFuZDtcbiAgICAgICAgICAgICAgIH0pO1xuICAgIH07XG4gICAgaWYgKHRhYiA9PT0gXCJidG5Nb2RlbHNcIikgc2VsZWN0KGNscyk7XG4gICAgZWxzZSBpZiAodGFiID09PSBcImJ0blNldHhcIikgcmlnaHR0YWIgPT09IFwiYnRuU2V0eFwiIHx8IHNlbGVjdCgpID09PSBjbHMgJiYgdG9nZ2xlUkZ1bGwoKTtcbiAgICBlbHNlIGlmICh0YWIgPT09IFwiYnRuUmVzdWx0c1wiKSAhZXN0aW1hdGVkID8gc2VsZWN0KGNscykgOlxuICAgICAgICByaWdodHRhYiA9PT0gXCJidG5SZXN1bHRzXCIgfHwgc2VsZWN0KCkgPT09IGNscyAmJiB0b2dnbGVSKCk7XG4gICAgcmlnaHR0YWIgPSB0YWI7XG59XG5cbmV4cG9ydCBsZXQgc3VtbWFyeSA9IHtkYXRhOiBbXX07XG5cbmZ1bmN0aW9uIHZhclN1bW1hcnkoZCkge1xuICAgIGxldCB0MSA9ICdNZWFuOiwgTWVkaWFuOiwgTW9zdCBGcmVxOiwgT2NjdXJyZW5jZXM6LCBNZWRpYW4gRnJlcTosIE9jY3VycmVuY2VzOiwgTGVhc3QgRnJlcTosIE9jY3VycmVuY2VzOiwgU3RkIERldjosIE1pbmltdW06LCBNYXhpbXVtOiwgSW52YWxpZDosIFZhbGlkOiwgVW5pcXVlczosIEhlcmZpbmRhaGwnLnNwbGl0KCcsICcpO1xuXG4gICAgbGV0IHJpbnQgPSBkMy5mb3JtYXQoJ3InKTtcbiAgICBsZXQgc3RyID0gKHgsIHApID0+ICgreCkudG9QcmVjaXNpb24ocCB8fCA0KS50b1N0cmluZygpO1xuICAgIGxldCB0MiA9IHByaXYgJiYgZC5tZWFuQ0kgP1xuICAgICAgICBbc3RyKGQubWVhbiwgMikgKyAnICgnICsgc3RyKGQubWVhbkNJLmxvd2VyQm91bmQsIDIpICsgJyAtICcgKyBzdHIoZC5tZWFuQ0kudXBwZXJCb3VuZCwgMikgKyAnKScsXG4gICAgICAgICBzdHIoZC5tZWRpYW4pLCBkLm1vZGUsIHJpbnQoZC5mcmVxbW9kZSksIGQubWlkLCByaW50KGQuZnJlcW1pZCksIGQuZmV3ZXN0LCByaW50KGQuZnJlcWZld2VzdCksXG4gICAgICAgICBzdHIoZC5zZCksIHN0cihkLm1pbiksIHN0cihkLm1heCksIHJpbnQoZC5pbnZhbGlkKSwgcmludChkLnZhbGlkKSwgcmludChkLnVuaXF1ZXMpLCBzdHIoZC5oZXJmaW5kYWhsKV0gOlxuICAgICAgICBbc3RyKGQubWVhbiksIHN0cihkLm1lZGlhbiksIGQubW9kZSwgcmludChkLmZyZXFtb2RlKSwgZC5taWQsIHJpbnQoZC5mcmVxbWlkKSwgZC5mZXdlc3QsIHJpbnQoZC5mcmVxZmV3ZXN0KSxcbiAgICAgICAgIHN0cihkLnNkKSwgc3RyKGQubWluKSwgc3RyKGQubWF4KSwgcmludChkLmludmFsaWQpLCByaW50KGQudmFsaWQpLCByaW50KGQudW5pcXVlcyksIHN0cihkLmhlcmZpbmRhaGwpXTtcblxuICAgIHN1bW1hcnkuZGF0YSA9IFtdO1xuICAgIHQxLmZvckVhY2goKGUsIGkpID0+ICF0MltpXS5pbmNsdWRlcygnTmFOJykgJiYgdDJbaV0gIT0gJ05BJyAmJiB0MltpXSAhPSAnJyAmJiBzdW1tYXJ5LmRhdGEucHVzaChbZSwgdDJbaV1dKSk7XG5cbiAgICBzdW1tYXJ5Lm5hbWUgPSBkLm5hbWU7XG4gICAgc3VtbWFyeS5sYWJsID0gZC5sYWJsO1xuXG4gICAgZDMuc2VsZWN0KCcjdGFiMycpXG4gICAgICAgIC5zZWxlY3RBbGwoJ3N2ZycpXG4gICAgICAgIC5yZW1vdmUoKTtcblxuICAgIGlmICghZC5wbG90dHlwZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGQucGxvdHR5cGUgPT0gJ2NvbnRpbnVvdXMnID8gZGVuc2l0eShkLCAndmFyU3VtbWFyeScsIHByaXYpIDpcbiAgICAgICAgZC5wbG90dHlwZSA9PSBcImJhclwiID8gYmFycyhkLCAndmFyU3VtbWFyeScsIHByaXYpIDpcbiAgICAgICAgZDMuc2VsZWN0KFwiI3RhYjNcIikgLy8gbm8gZ3JhcGggdG8gZHJhdywgYnV0IHN0aWxsIG5lZWQgdG8gcmVtb3ZlIHByZXZpb3VzIGdyYXBoXG4gICAgICAgIC5zZWxlY3RBbGwoXCJzdmdcIilcbiAgICAgICAgLnJlbW92ZSgpO1xufVxuXG5leHBvcnQgbGV0IHBvcG92ZXJDb250ZW50ID0gZCA9PiB7XG4gICAgbGV0IHRleHQgPSAnJztcbiAgICBsZXQgW3JpbnQsIHByZWNdID0gW2QzLmZvcm1hdCgncicpLCAodmFsLCBpbnQpID0+ICgrdmFsKS50b1ByZWNpc2lvbihpbnQpLnRvU3RyaW5nKCldO1xuICAgIGxldCBkaXYgPSAoZmllbGQsIG5hbWUsIHZhbCkgPT4ge1xuICAgICAgICBpZiAoZmllbGQgIT0gJ05BJykgdGV4dCArPSBgPGRpdiBjbGFzcz0nZm9ybS1ncm91cCc+PGxhYmVsIGNsYXNzPSdjb2wtc20tNCBjb250cm9sLWxhYmVsJz4ke25hbWV9PC9sYWJlbD48ZGl2IGNsYXNzPSdjb2wtc20tNic+PHAgY2xhc3M9J2Zvcm0tY29udHJvbC1zdGF0aWMnPiR7dmFsIHx8IGZpZWxkfTwvcD48L2Rpdj48L2Rpdj5gO1xuICAgIH07XG4gICAgZC5sYWJsICE9ICcnICYmIGRpdihkLmxhYmwsICdMYWJlbCcpO1xuICAgIGRpdihkLm1lYW4sICdNZWFuJywgcHJpdiAmJiBkLm1lYW5DSSA/XG4gICAgICAgIGAke3ByZWMoZC5tZWFuLCAyKX0gKCR7cHJlYyhkLm1lYW5DSS5sb3dlckJvdW5kLCAyKX0gLSAke3ByZWMoZC5tZWFuQ0kudXBwZXJCb3VuZCwgMil9KWAgOlxuICAgICAgICBwcmVjKGQubWVhbiwgNCkpO1xuICAgIGRpdihkLm1lZGlhbiwgJ01lZGlhbicsIHByZWMoZC5tZWRpYW4sIDQpKTtcbiAgICBkaXYoZC5tb2RlLCAnTW9zdCBGcmVxJyk7XG4gICAgZGl2KGQuZnJlcW1vZGUsICdPY2N1cnJlbmNlcycsICByaW50KGQuZnJlcW1vZGUpKTtcbiAgICBkaXYoZC5taWQsICdNZWRpYW4gRnJlcScpO1xuICAgIGRpdihkLmZyZXFtaWQsICdPY2N1cnJlbmNlcycsIHJpbnQoZC5mcmVxbWlkKSk7XG4gICAgZGl2KGQuZmV3ZXN0LCAnTGVhc3QgRnJlcScpO1xuICAgIGRpdihkLmZyZXFmZXdlc3QsICdPY2N1cnJlbmNlcycsIHJpbnQoZC5mcmVxZmV3ZXN0KSk7XG4gICAgZGl2KGQuc2QsICdTdGFuZCBEZXYnLCBwcmVjKGQuc2QsIDQpKTtcbiAgICBkaXYoZC5tYXgsICdNYXhpbXVtJywgcHJlYyhkLm1heCwgNCkpO1xuICAgIGRpdihkLm1pbiwgJ01pbmltdW0nLCBwcmVjKGQubWluLCA0KSk7XG4gICAgZGl2KGQuaW52YWxpZCwgJ0ludmFsaWQnLCByaW50KGQuaW52YWxpZCkpO1xuICAgIGRpdihkLnZhbGlkLCAnVmFsaWQnLCByaW50KGQudmFsaWQpKTtcbiAgICBkaXYoZC51bmlxdWVzLCAnVW5pcXVlcycsIHJpbnQoZC51bmlxdWVzKSk7XG4gICAgZGl2KGQuaGVyZmluZGFobCwgJ0hlcmZpbmRhaGwnLCBwcmVjKGQuaGVyZmluZGFobCwgNCkpO1xuICAgIHJldHVybiB0ZXh0O1xufVxuXG5mdW5jdGlvbiBwb3B1cFgoZCkge1xuICAgIHZhciB0c2YgPSBkMy5mb3JtYXQoXCIuNHJcIik7XG4gICAgdmFyIHJpbnQgPSBkMy5mb3JtYXQoXCJyXCIpO1xuICAgIC8vQ3JlYXRlIHRoZSB0b29sdGlwIGxhYmVsXG4gICAgZDMuc2VsZWN0KFwiI3Rvb2x0aXBcIilcbiAgICAgICAgLnN0eWxlKFwibGVmdFwiLCB0ZW1wWCArIFwicHhcIilcbiAgICAgICAgLnN0eWxlKFwidG9wXCIsIHRlbXBZICsgXCJweFwiKVxuICAgICAgICAuc2VsZWN0KFwiI3Rvb2x0aXB0ZXh0XCIpXG4gICAgICAgIC5odG1sKFwiPGRpdiBjbGFzcz0nZm9ybS1ncm91cCc+PGxhYmVsIGNsYXNzPSdjb2wtc20tNCBjb250cm9sLWxhYmVsJz5NZWFuPC9sYWJlbD48ZGl2IGNsYXNzPSdjb2wtc20tNic+PHAgY2xhc3M9J2Zvcm0tY29udHJvbC1zdGF0aWMnPlwiICsgdHNmKGQubWVhbikgKyBcIjwvcD48L2Rpdj48L2Rpdj5cIiArXG4gICAgICAgICAgICBcIjxkaXYgY2xhc3M9J2Zvcm0tZ3JvdXAnPjxsYWJlbCBjbGFzcz0nY29sLXNtLTQgY29udHJvbC1sYWJlbCc+TWVkaWFuPC9sYWJlbD48ZGl2IGNsYXNzPSdjb2wtc20tNic+PHAgY2xhc3M9J2Zvcm0tY29udHJvbC1zdGF0aWMnPlwiICsgdHNmKGQubWVkaWFuKSArIFwiPC9wPjwvZGl2PjwvZGl2PlwiICtcbiAgICAgICAgICAgIFwiPGRpdiBjbGFzcz0nZm9ybS1ncm91cCc+PGxhYmVsIGNsYXNzPSdjb2wtc20tNCBjb250cm9sLWxhYmVsJz5Nb2RlPC9sYWJlbD48ZGl2IGNsYXNzPSdjb2wtc20tNic+PHAgY2xhc3M9J2Zvcm0tY29udHJvbC1zdGF0aWMnPlwiICsgZC5tb2RlICsgXCI8L3A+PC9kaXY+PC9kaXY+XCIgK1xuICAgICAgICAgICAgXCI8ZGl2IGNsYXNzPSdmb3JtLWdyb3VwJz48bGFiZWwgY2xhc3M9J2NvbC1zbS00IGNvbnRyb2wtbGFiZWwnPlN0YW5kIERldjwvbGFiZWw+PGRpdiBjbGFzcz0nY29sLXNtLTYnPjxwIGNsYXNzPSdmb3JtLWNvbnRyb2wtc3RhdGljJz5cIiArIHRzZihkLnNkKSArIFwiPC9wPjwvZGl2PjwvZGl2PlwiICtcbiAgICAgICAgICAgIFwiPGRpdiBjbGFzcz0nZm9ybS1ncm91cCc+PGxhYmVsIGNsYXNzPSdjb2wtc20tNCBjb250cm9sLWxhYmVsJz5NYXhpbXVtPC9sYWJlbD48ZGl2IGNsYXNzPSdjb2wtc20tNic+PHAgY2xhc3M9J2Zvcm0tY29udHJvbC1zdGF0aWMnPlwiICsgdHNmKGQubWF4KSArIFwiPC9wPjwvZGl2PjwvZGl2PlwiICtcbiAgICAgICAgICAgIFwiPGRpdiBjbGFzcz0nZm9ybS1ncm91cCc+PGxhYmVsIGNsYXNzPSdjb2wtc20tNCBjb250cm9sLWxhYmVsJz5NaW5pbXVtPC9sYWJlbD48ZGl2IGNsYXNzPSdjb2wtc20tNic+PHAgY2xhc3M9J2Zvcm0tY29udHJvbC1zdGF0aWMnPlwiICsgdHNmKGQubWluKSArIFwiPC9wPjwvZGl2PjwvZGl2PlwiICtcbiAgICAgICAgICAgIFwiPGRpdiBjbGFzcz0nZm9ybS1ncm91cCc+PGxhYmVsIGNsYXNzPSdjb2wtc20tNCBjb250cm9sLWxhYmVsJz5WYWxpZDwvbGFiZWw+PGRpdiBjbGFzcz0nY29sLXNtLTYnPjxwIGNsYXNzPSdmb3JtLWNvbnRyb2wtc3RhdGljJz5cIiArIHJpbnQoZC52YWxpZCkgKyBcIjwvcD48L2Rpdj48L2Rpdj5cIiArXG4gICAgICAgICAgICBcIjxkaXYgY2xhc3M9J2Zvcm0tZ3JvdXAnPjxsYWJlbCBjbGFzcz0nY29sLXNtLTQgY29udHJvbC1sYWJlbCc+SW52YWxpZDwvbGFiZWw+PGRpdiBjbGFzcz0nY29sLXNtLTYnPjxwIGNsYXNzPSdmb3JtLWNvbnRyb2wtc3RhdGljJz5cIiArIHJpbnQoZC5pbnZhbGlkKSArIFwiPC9wPjwvZGl2PjwvZGl2PlwiXG4gICAgICAgICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYW5lbFBsb3RzKCkge1xuICAgIC8vIGJ1aWxkIGFycmF5cyBmcm9tIG5vZGVzIGluIG1haW5cbiAgICBsZXQgdmFycyA9IFtdO1xuICAgIGxldCBpZHMgPSBbXTtcbiAgICBub2Rlcy5mb3JFYWNoKG4gPT4ge1xuICAgICAgICB2YXJzLnB1c2gobi5uYW1lLnJlcGxhY2UoL1xcKHxcXCkvZywgJycpKTtcbiAgICAgICAgaWRzLnB1c2gobi5pZCk7XG4gICAgfSk7XG5cbiAgICAvL3JlbW92ZSBhbGwgcGxvdHMsIGNvdWxkIGJlIHNtYXJ0ZXIgaGVyZVxuICAgIGQzLnNlbGVjdCgnI3NldHhMZWZ0Jykuc2VsZWN0QWxsKCdzdmcnKS5yZW1vdmUoKTtcbiAgICBkMy5zZWxlY3QoJyN0YWIyJykuc2VsZWN0QWxsKCdzdmcnKS5yZW1vdmUoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG5vZGUgPSBhbGxOb2Rlc1tpZHNbaV1dO1xuICAgICAgICBub2RlLnNldHhwbG90ID0gZmFsc2U7XG4gICAgICAgIG5vZGUuc3Vic2V0cGxvdCA9IGZhbHNlO1xuICAgICAgICBpZiAobm9kZS5wbG90dHlwZSA9PT0gXCJjb250aW51b3VzXCIgJiBub2RlLnNldHhwbG90ID09IGZhbHNlKSB7XG4gICAgICAgICAgICBub2RlLnNldHhwbG90ID0gdHJ1ZTtcbiAgICAgICAgICAgIGRlbnNpdHkobm9kZSwgZGl2ID0gXCJzZXR4TGVmdFwiLCBwcml2KTtcbiAgICAgICAgICAgIG5vZGUuc3Vic2V0cGxvdCA9IHRydWU7XG4gICAgICAgICAgICBkZW5zaXR5KG5vZGUsIGRpdiA9IFwic3Vic2V0XCIsIHByaXYpO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGUucGxvdHR5cGUgPT09IFwiYmFyXCIgJiBub2RlLnNldHhwbG90ID09IGZhbHNlKSB7XG4gICAgICAgICAgICBub2RlLnNldHhwbG90ID0gdHJ1ZTtcbiAgICAgICAgICAgIGJhcnMobm9kZSwgZGl2ID0gXCJzZXR4TGVmdFwiLCBwcml2KTtcbiAgICAgICAgICAgIG5vZGUuc3Vic2V0cGxvdCA9IHRydWU7XG4gICAgICAgICAgICBiYXJzU3Vic2V0KG5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgICAgIGQzLnNlbGVjdChcIiNzZXR4TGVmdFwiKS5zZWxlY3RBbGwoXCJzdmdcIilcbiAgICAgICAgLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcyk7XG4gICAgICAgICAgICAgIHZhciByZWdzdHIgPSAvKC4rKV9zZXR4TGVmdF8oXFxkKykvO1xuICAgICAgICAgICAgICB2YXIgbXluYW1lID0gcmVnc3RyLmV4ZWModGhpcy5pZCk7XG4gICAgICAgICAgICAgIHZhciBub2RlaWQgPSBteW5hbWVbMl07XG4gICAgICAgICAgICAgIG15bmFtZSA9IG15bmFtZVsxXTtcbiAgICAgICAgICAgICAgaWYgKCF2YXJzLmluY2x1ZGVzKG15bmFtZSkpIHtcbiAgICAgICAgICAgICAgYWxsTm9kZXNbbm9kZWlkXS5zZXR4cGxvdCA9IGZhbHNlO1xuICAgICAgICAgICAgICBsZXQgdGVtcCA9IFwiI1wiLmNvbmNhdChteW5hbWUsIFwiX3NldHhMZWZ0X1wiLCBub2RlaWQpO1xuICAgICAgICAgICAgICBkMy5zZWxlY3QodGVtcClcbiAgICAgICAgICAgICAgLnJlbW92ZSgpO1xuICAgICAgICAgICAgICBhbGxOb2Rlc1tub2RlaWRdLnN1YnNldHBsb3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgdGVtcCA9IFwiI1wiLmNvbmNhdChteW5hbWUsIFwiX3RhYjJfXCIsIG5vZGVpZCk7XG4gICAgICAgICAgICAgIGQzLnNlbGVjdCh0ZW1wKVxuICAgICAgICAgICAgICAucmVtb3ZlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG59XG5cblxuLy8gZWFzeSBmdW5jdGlvbnMgdG8gY29sbGFwc2UgcGFuZWxzIHRvIGJhc2VcbmZ1bmN0aW9uIHJpZ2h0cGFuZWxNZWRpdW0oKSB7XG4gICAgZDMuc2VsZWN0KFwiI3JpZ2h0cGFuZWxcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInNpZGVwYW5lbCBjb250YWluZXIgY2xlYXJmaXhcIik7XG59XG5cbmZ1bmN0aW9uIGxlZnRwYW5lbE1lZGl1bSgpIHtcbiAgICBkMy5zZWxlY3QoXCIjbGVmdHBhbmVsXCIpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJzaWRlcGFuZWwgY29udGFpbmVyIGNsZWFyZml4XCIpO1xufVxuXG4vLyBjb252ZXJ0cyBjb2xvciBjb2Rlc1xuZXhwb3J0IGxldCBoZXhUb1JnYmEgPSBoZXggPT4ge1xuICAgIGxldCBpbnQgPSBwYXJzZUludChoZXgucmVwbGFjZSgnIycsICcnKSwgMTYpO1xuICAgIHJldHVybiBgcmdiYSgke1soaW50ID4+IDE2KSAmIDI1NSwgKGludCA+PiA4KSAmIDI1NSwgaW50ICYgMjU1LCAnMC41J10uam9pbignLCcpfSlgO1xufTtcblxuLy8gdGFrZXMgbm9kZSBhbmQgY29sb3IgYW5kIHVwZGF0ZXMgenBhcmFtc1xuZnVuY3Rpb24gc2V0Q29sb3JzKG4sIGMpIHtcbiAgICBpZiAobi5zdHJva2VXaWR0aCA9PSAnMScpIHtcbiAgICAgICAgaWYgKGMgPT0gZ3IxQ29sb3Ipe1xuICAgICAgICAgICAgdmFyIHRlbXBpbmRleCA9IHpwYXJhbXMuemdyb3VwMS5pbmRleE9mKG4ubmFtZSk7XG4gICAgICAgICAgICBpZiAodGVtcGluZGV4ID4gLTEpe1xuICAgICAgICAgICAgICAgIG4uZ3JvdXAxID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgenBhcmFtcy56Z3JvdXAxLnNwbGljZSh0ZW1waW5kZXgsMSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG4uZ3JvdXAxID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB6cGFyYW1zLnpncm91cDEucHVzaChuLm5hbWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChjID09IGdyMkNvbG9yKXtcbiAgICAgICAgICAgIHZhciB0ZW1waW5kZXggPSB6cGFyYW1zLnpncm91cDIuaW5kZXhPZihuLm5hbWUpO1xuICAgICAgICAgICAgaWYgKHRlbXBpbmRleCA+IC0xKXtcbiAgICAgICAgICAgICAgICBuLmdyb3VwMiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHpwYXJhbXMuemdyb3VwMi5zcGxpY2UodGVtcGluZGV4LDEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuLmdyb3VwMiA9IHRydWU7XG4gICAgICAgICAgICAgICAgenBhcmFtcy56Z3JvdXAyLnB1c2gobi5uYW1lKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGFkZGluZyB0aW1lLCBjcywgZHYsIG5vbSB0byBub2RlIHdpdGggbm8gc3Ryb2tlXG4gICAgICAgIG4uc3Ryb2tlV2lkdGggPSAnNCc7XG4gICAgICAgIG4uc3Ryb2tlQ29sb3IgPSBjO1xuICAgICAgICBuLm5vZGVDb2wgPSB0YWdnZWRDb2xvcjtcbiAgICAgICAgbGV0IHB1c2ggPSAoW2NvbG9yLCBrZXldKSA9PiB7XG4gICAgICAgICAgICBpZiAoY29sb3IgIT0gYylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB6cGFyYW1zW2tleV0gPSBBcnJheS5pc0FycmF5KHpwYXJhbXNba2V5XSkgPyB6cGFyYW1zW2tleV0gOiBbXTtcbiAgICAgICAgICAgIHpwYXJhbXNba2V5XS5wdXNoKG4ubmFtZSk7XG4gICAgICAgICAgICBpZiAoa2V5ID09ICd6bm9tJykge1xuICAgICAgICAgICAgICAgIGZpbmROb2RlSW5kZXgobi5uYW1lLCB0cnVlKS5uYXR1cmUgPSBcIm5vbWluYWxcIjtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm0obi5uYW1lLCB0ID0gbnVsbCwgdHlwZVRyYW5zZm9ybSA9IHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGtleSA9PSAnemR2Jyl7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBncm91cCBtZW1iZXJzaGlwcyBmcm9tIGR2J3NcbiAgICAgICAgICAgICAgICBpZihuLmdyb3VwMSl7XG4gICAgICAgICAgICAgICAgICAgIG4uZ3JvdXAxID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHpwYXJhbXMuemdyb3VwMS5zcGxpY2UoenBhcmFtcy56Z3JvdXAxLmluZGV4T2Yobi5uYW1lKSwxKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmKG4uZ3JvdXAyKXtcbiAgICAgICAgICAgICAgICAgICAgbi5ncm91cDIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgenBhcmFtcy56Z3JvdXAyLnNwbGljZSh6cGFyYW1zLnpncm91cDIuaW5kZXhPZihuLm5hbWUpLDEpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFtbZHZDb2xvciwgJ3pkdiddLCBbY3NDb2xvciwgJ3pjcm9zcyddLCBbdGltZUNvbG9yLCAnenRpbWUnXSwgW25vbUNvbG9yLCAnem5vbSddXS5mb3JFYWNoKHB1c2gpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChuLnN0cm9rZVdpZHRoID09ICc0Jykge1xuICAgICAgICBpZiAoYyA9PSBuLnN0cm9rZUNvbG9yKSB7IC8vIGRlc2VsZWN0aW5nIHRpbWUsIGNzLCBkdiwgbm9tXG4gICAgICAgICAgICBuLnN0cm9rZVdpZHRoID0gJzEnO1xuICAgICAgICAgICAgbi5zdHJva2VDb2xvciA9IHNlbFZhckNvbG9yO1xuICAgICAgICAgICAgbi5ub2RlQ29sID0gY29sb3JzKG4uaWQpO1xuICAgICAgICAgICAgc3BsaWNlKGMsIG4ubmFtZSwgW2R2Q29sb3IsICd6ZHYnXSwgW2NzQ29sb3IsICd6Y3Jvc3MnXSwgW3RpbWVDb2xvciwgJ3p0aW1lJ10sIFtub21Db2xvciwgJ3pub20nXSk7XG4gICAgICAgICAgICBpZiAobm9tQ29sb3IgPT0gYyAmJiB6cGFyYW1zLnpub20uaW5jbHVkZXMobi5uYW1lKSkge1xuICAgICAgICAgICAgICAgIGZpbmROb2RlSW5kZXgobi5uYW1lLCB0cnVlKS5uYXR1cmUgPSBmaW5kTm9kZUluZGV4KG4ubmFtZSwgdHJ1ZSkuZGVmYXVsdE5hdHVyZTtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm0obi5uYW1lLCB0ID0gbnVsbCwgdHlwZVRyYW5zZm9ybSA9IHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgeyAvLyBkZXNlbGVjdGluZyB0aW1lLCBjcywgZHYsIG5vbSBBTkQgY2hhbmdpbmcgaXQgdG8gdGltZSwgY3MsIGR2LCBub21cbiAgICAgICAgICAgIHNwbGljZShuLnN0cm9rZUNvbG9yLCBuLm5hbWUsIFtkdkNvbG9yLCAnemR2J10sIFtjc0NvbG9yLCAnemNyb3NzJ10sIFt0aW1lQ29sb3IsICd6dGltZSddLCBbbm9tQ29sb3IsICd6bm9tJ10pO1xuICAgICAgICAgICAgaWYgKG5vbUNvbG9yID09IG4uc3Ryb2tlQ29sb3IgJiYgenBhcmFtcy56bm9tLmluY2x1ZGVzKG4ubmFtZSkpIHtcbiAgICAgICAgICAgICAgICBmaW5kTm9kZUluZGV4KG4ubmFtZSwgdHJ1ZSkubmF0dXJlID0gZmluZE5vZGVJbmRleChuLm5hbWUsIHRydWUpLmRlZmF1bHROYXR1cmU7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtKG4ubmFtZSwgdCA9IG51bGwsIHR5cGVUcmFuc2Zvcm0gPSB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG4uc3Ryb2tlQ29sb3IgPSBjO1xuICAgICAgICAgICAgaWYgKGR2Q29sb3IgPT0gYyl7XG4gICAgICAgICAgICAgICAgdmFyIGR2bmFtZSA9IG4ubmFtZTtcbiAgICAgICAgICAgICAgICB6cGFyYW1zLnpkdi5wdXNoKGR2bmFtZSk7XG4gICAgICAgICAgICAgICAgaWYobi5ncm91cDEpeyAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBncm91cCBtZW1iZXJzaGlwcyBmcm9tIGR2J3NcbiAgICAgICAgICAgICAgICAgICAgbmdyb3VwMSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB6cGFyYW1zLnpncm91cDEuc3BsaWNlKHpwYXJhbXMuemdyb3VwMS5pbmRleE9mKGR2bmFtZSksMSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZihuLmdyb3VwMil7XG4gICAgICAgICAgICAgICAgICAgIG5ncm91cDIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgenBhcmFtcy56Z3JvdXAyLnNwbGljZSh6cGFyYW1zLnpncm91cDIuaW5kZXhPZihkdm5hbWUpLDEpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjc0NvbG9yID09IGMpIHpwYXJhbXMuemNyb3NzLnB1c2gobi5uYW1lKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHRpbWVDb2xvciA9PSBjKSB6cGFyYW1zLnp0aW1lLnB1c2gobi5uYW1lKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKG5vbUNvbG9yID09IGMpIHtcbiAgICAgICAgICAgICAgICB6cGFyYW1zLnpub20ucHVzaChuLm5hbWUpO1xuICAgICAgICAgICAgICAgIGZpbmROb2RlSW5kZXgobi5uYW1lLCB0cnVlKS5uYXR1cmUgPSBcIm5vbWluYWxcIjtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm0obi5uYW1lLCB0ID0gbnVsbCwgdHlwZVRyYW5zZm9ybSA9IHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYm9yZGVyU3RhdGUoKSB7XG4gICAgenBhcmFtcy56ZHYubGVuZ3RoID4gMCA/XG4gICAgICAgICQoJyNkdkJ1dHRvbiAucmVjdENvbG9yIHN2ZyBjaXJjbGUnKS5hdHRyKCdzdHJva2UnLCBkdkNvbG9yKSA6XG4gICAgICAgICQoJyNkdkJ1dHRvbicpLmNzcygnYm9yZGVyLWNvbG9yJywgJyNjY2MnKTtcbiAgICB6cGFyYW1zLnpjcm9zcy5sZW5ndGggPiAwID9cbiAgICAgICAgJCgnI2NzQnV0dG9uIC5yZWN0Q29sb3Igc3ZnIGNpcmNsZScpLmF0dHIoJ3N0cm9rZScsIGNzQ29sb3IpIDpcbiAgICAgICAgJCgnI2NzQnV0dG9uJykuY3NzKCdib3JkZXItY29sb3InLCAnI2NjYycpO1xuICAgIHpwYXJhbXMuenRpbWUubGVuZ3RoID4gMCA/XG4gICAgICAgICQoJyN0aW1lQnV0dG9uIC5yZWN0Q29sb3Igc3ZnIGNpcmNsZScpLmF0dHIoJ3N0cm9rZScsIHRpbWVDb2xvcikgOlxuICAgICAgICAkKCcjdGltZUJ1dHRvbicpLmNzcygnYm9yZGVyLWNvbG9yJywgJyNjY2MnKTtcbiAgICB6cGFyYW1zLnpub20ubGVuZ3RoID4gMCA/XG4gICAgICAgICQoJyNub21CdXR0b24gLnJlY3RDb2xvciBzdmcgY2lyY2xlJykuYXR0cignc3Ryb2tlJywgbm9tQ29sb3IpIDpcbiAgICAgICAgJCgnI25vbUJ1dHRvbicpLmNzcygnYm9yZGVyLWNvbG9yJywgJyNjY2MnKTtcbiAgICB6cGFyYW1zLnpncm91cDEubGVuZ3RoID4gMCA/XG4gICAgICAgICQoJyNncjFCdXR0b24gLnJlY3RDb2xvciBzdmcgY2lyY2xlJykuYXR0cignc3Ryb2tlJywgZ3IxQ29sb3IpLmF0dHIoJ2ZpbGwnLCBncjFDb2xvcikuYXR0cignZmlsbC1vcGFjaXR5JywgMC42KS5hdHRyKCdzdHJva2Utb3BhY2l0eScsIDApIDpcbiAgICAgICAgJCgnI2dyMUJ1dHRvbicpLmNzcygnYm9yZGVyLWNvbG9yJywgJyNjY2MnKTtcbiAgICB6cGFyYW1zLnpncm91cDIubGVuZ3RoID4gMCA/XG4gICAgICAgICQoJyNncjJCdXR0b24gLnJlY3RDb2xvciBzdmcgY2lyY2xlJykuYXR0cignc3Ryb2tlJywgZ3IyQ29sb3IpLmF0dHIoJ2ZpbGwnLCBncjJDb2xvcikuYXR0cignZmlsbC1vcGFjaXR5JywgMC42KS5hdHRyKCdzdHJva2Utb3BhY2l0eScsIDApIDpcbiAgICAgICAgJCgnI2dyMkJ1dHRvbicpLmNzcygnYm9yZGVyLWNvbG9yJywgJyNjY2MnKTtcbn1cblxuLy8gc21hbGwgYXBwZWFyYW5jZSByZXNldHMsIGJ1dCBwZXJoYXBzIHRoaXMgd2lsbCBiZWNvbWUgYSBoYXJkIHJlc2V0IGJhY2sgdG8gYWxsIG9yaWdpbmFsIGFsbE5vZGUgdmFsdWVzP1xuZnVuY3Rpb24gbm9kZVJlc2V0KG4pIHtcbiAgICBuLnN0cm9rZUNvbG9yID0gc2VsVmFyQ29sb3I7XG4gICAgbi5zdHJva2VXaWR0aCA9IFwiMVwiO1xuICAgIG4ubm9kZUNvbCA9IG4uYmFzZUNvbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN1YnNldFNlbGVjdChidG4pIHtcbiAgICBpZiAoZGF0YXVybClcbiAgICAgICAgenBhcmFtcy56ZGF0YXVybCA9IGRhdGF1cmw7XG4gICAgaWYgKHByb2R1Y3Rpb24gJiYgenBhcmFtcy56c2Vzc2lvbmlkID09IFwiXCIpIHtcbiAgICAgICAgYWxlcnQoXCJXYXJuaW5nOiBEYXRhIGRvd25sb2FkIGlzIG5vdCBjb21wbGV0ZS4gVHJ5IGFnYWluIHNvb24uXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHpwYXJhbXMuenZhcnMgPSBbXTtcbiAgICB6cGFyYW1zLnpwbG90ID0gW107XG4gICAgdmFyIHN1YnNldEVtcHR5ID0gdHJ1ZTtcbiAgICAvLyBpcyB0aGlzIHRoZSBzYW1lIGFzIHpQb3AoKT9cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5vZGVzLmxlbmd0aDsgaisrKSB7IC8vIHBvcHVsYXRlIHp2YXJzIGFuZCB6c3Vic2V0IGFycmF5c1xuICAgICAgICB6cGFyYW1zLnp2YXJzLnB1c2gobm9kZXNbal0ubmFtZSk7XG4gICAgICAgIHZhciB0ZW1wID0gbm9kZXNbal0uaWQ7XG4gICAgICAgIHpwYXJhbXMuenN1YnNldFtqXSA9IGFsbE5vZGVzW3RlbXBdLnN1YnNldHJhbmdlO1xuICAgICAgICBpZiAoenBhcmFtcy56c3Vic2V0W2pdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlmICh6cGFyYW1zLnpzdWJzZXRbal1bMF0gIT0gXCJcIilcbiAgICAgICAgICAgICAgICB6cGFyYW1zLnpzdWJzZXRbal1bMF0gPSBOdW1iZXIoenBhcmFtcy56c3Vic2V0W2pdWzBdKTtcbiAgICAgICAgICAgIGlmICh6cGFyYW1zLnpzdWJzZXRbal1bMV0gIT0gXCJcIilcbiAgICAgICAgICAgICAgICB6cGFyYW1zLnpzdWJzZXRbal1bMV0gPSBOdW1iZXIoenBhcmFtcy56c3Vic2V0W2pdWzFdKTtcbiAgICAgICAgfVxuICAgICAgICB6cGFyYW1zLnpwbG90LnB1c2goYWxsTm9kZXNbdGVtcF0ucGxvdHR5cGUpO1xuICAgICAgICBpZiAoenBhcmFtcy56c3Vic2V0W2pdWzFdICE9IFwiXCIpXG4gICAgICAgICAgICBzdWJzZXRFbXB0eSA9IGZhbHNlOyAvLyBvbmx5IG5lZWQgdG8gY2hlY2sgb25lXG4gICAgfVxuXG4gICAgaWYgKHN1YnNldEVtcHR5ID09IHRydWUpIHtcbiAgICAgICAgYWxlcnQoXCJXYXJuaW5nOiBObyBuZXcgc3Vic2V0IHNlbGVjdGVkLlwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBvdXR0eXBlcyA9IFtdO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgYWxsTm9kZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgb3V0dHlwZXMucHVzaCh7XG4gICAgICAgICAgICB2YXJuYW1lc1R5cGVzOiBhbGxOb2Rlc1tqXS5uYW1lLFxuICAgICAgICAgICAgbmF0dXJlOiBhbGxOb2Rlc1tqXS5uYXR1cmUsXG4gICAgICAgICAgICBudW1jaGFyOiBhbGxOb2Rlc1tqXS5udW1jaGFyLFxuICAgICAgICAgICAgYmluYXJ5OiBhbGxOb2Rlc1tqXS5iaW5hcnksXG4gICAgICAgICAgICBpbnRlcnZhbDogYWxsTm9kZXNbal0uaW50ZXJ2YWxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIHN1YnNldHN0dWZmID0ge1xuICAgICAgICB6ZGF0YXVybDogenBhcmFtcy56ZGF0YXVybCxcbiAgICAgICAgenZhcnM6IHpwYXJhbXMuenZhcnMsXG4gICAgICAgIHpzdWJzZXQ6IHpwYXJhbXMuenN1YnNldCxcbiAgICAgICAgenNlc3Npb25pZDogenBhcmFtcy56c2Vzc2lvbmlkLFxuICAgICAgICB6cGxvdDogenBhcmFtcy56cGxvdCxcbiAgICAgICAgY2FsbEhpc3Rvcnk6IGNhbGxIaXN0b3J5LFxuICAgICAgICB0eXBlU3R1ZmY6IG91dHR5cGVzXG4gICAgfTtcblxuICAgIHZhciBqc29ub3V0ID0gSlNPTi5zdHJpbmdpZnkoc3Vic2V0c3R1ZmYpO1xuICAgIHZhciB1cmxjYWxsID0gcmFwcFVSTCArIFwic3Vic2V0YXBwXCI7XG4gICAgdmFyIHNvbGFqc29ub3V0ID0gXCJzb2xhSlNPTj1cIiArIGpzb25vdXQ7XG4gICAgY2RiKFwidXJsY2FsbCBvdXQ6IFwiLCB1cmxjYWxsKTtcbiAgICBjZGIoXCJQT1NUIG91dDogXCIsIHNvbGFqc29ub3V0KTtcblxuICAgIGZ1bmN0aW9uIHN1YnNldFNlbGVjdFN1Y2Nlc3MoYnRuLCBqc29uKSB7XG4gICAgICAgIHNlbGVjdExhZGRhLnN0b3AoKTsgLy8gc3RvcCBtb3Rpb25cbiAgICAgICAgJChcIiNidG5WYXJpYWJsZXNcIikudHJpZ2dlcihcImNsaWNrXCIpOyAvLyBwcm9ncmFtbWF0aWMgY2xpY2tzXG4gICAgICAgICQoXCIjYnRuTW9kZWxzXCIpLnRyaWdnZXIoXCJjbGlja1wiKTtcblxuICAgICAgICB2YXIgZ3JheU91dHMgPSBbXTtcbiAgICAgICAgdmFyIHJDYWxsID0gW107XG4gICAgICAgIHJDYWxsWzBdID0ganNvbi5jYWxsO1xuXG4gICAgICAgIC8vIHN0b3JlIGNvbnRlbnRzIG9mIHRoZSBwcmUtc3Vic2V0IHNwYWNlXG4gICAgICAgIHpQb3AoKTtcbiAgICAgICAgdmFyIG15Tm9kZXMgPSBqUXVlcnkuZXh0ZW5kKHRydWUsIFtdLCBhbGxOb2Rlcyk7XG4gICAgICAgIHZhciBteVBhcmFtcyA9IGpRdWVyeS5leHRlbmQodHJ1ZSwge30sIHpwYXJhbXMpO1xuICAgICAgICB2YXIgbXlUcmFucyA9IGpRdWVyeS5leHRlbmQodHJ1ZSwgW10sIHRyYW5zKTtcbiAgICAgICAgdmFyIG15Rm9yY2UgPSBqUXVlcnkuZXh0ZW5kKHRydWUsIFtdLCBmb3JjZXRvZ2dsZSk7XG4gICAgICAgIHZhciBteVByZXByb2Nlc3MgPSBqUXVlcnkuZXh0ZW5kKHRydWUsIHt9LCBwcmVwcm9jZXNzKTtcbiAgICAgICAgdmFyIG15TG9nID0galF1ZXJ5LmV4dGVuZCh0cnVlLCBbXSwgbG9nQXJyYXkpO1xuICAgICAgICB2YXIgbXlIaXN0b3J5ID0galF1ZXJ5LmV4dGVuZCh0cnVlLCBbXSwgY2FsbEhpc3RvcnkpO1xuXG4gICAgICAgIHNwYWNlc1tteXNwYWNlXSA9IHtcbiAgICAgICAgICAgIFwiYWxsTm9kZXNcIjogbXlOb2RlcyxcbiAgICAgICAgICAgIFwienBhcmFtc1wiOiBteVBhcmFtcyxcbiAgICAgICAgICAgIFwidHJhbnNcIjogbXlUcmFucyxcbiAgICAgICAgICAgIFwiZm9yY2VcIjogbXlGb3JjZSxcbiAgICAgICAgICAgIFwicHJlcHJvY2Vzc1wiOiBteVByZXByb2Nlc3MsXG4gICAgICAgICAgICBcImxvZ0FycmF5XCI6IG15TG9nLFxuICAgICAgICAgICAgXCJjYWxsSGlzdG9yeVwiOiBteUhpc3RvcnlcbiAgICAgICAgfTtcblxuICAgICAgICAvLyByZW1vdmUgcHJlLXN1YnNldCBzdmdcbiAgICAgICAgdmFyIHNlbGVjdE1lID0gXCIjbVwiLmNvbmNhdChteXNwYWNlKTtcbiAgICAgICAgZDMuc2VsZWN0KHNlbGVjdE1lKS5hdHRyKCdjbGFzcycsICdpdGVtJyk7XG4gICAgICAgIHNlbGVjdE1lID0gXCIjd2hpdGVzcGFjZVwiLmNvbmNhdChteXNwYWNlKTtcbiAgICAgICAgZDMuc2VsZWN0KHNlbGVjdE1lKS5yZW1vdmUoKTtcblxuICAgICAgICBteXNwYWNlID0gc3BhY2VzLmxlbmd0aDtcbiAgICAgICAgY2FsbEhpc3RvcnkucHVzaCh7XG4gICAgICAgICAgICBmdW5jOiBcInN1YnNldFwiLFxuICAgICAgICAgICAgenZhcnM6IGpRdWVyeS5leHRlbmQodHJ1ZSwgW10sIHpwYXJhbXMuenZhcnMpLFxuICAgICAgICAgICAgenN1YnNldDogalF1ZXJ5LmV4dGVuZCh0cnVlLCBbXSwgenBhcmFtcy56c3Vic2V0KSxcbiAgICAgICAgICAgIHpwbG90OiBqUXVlcnkuZXh0ZW5kKHRydWUsIFtdLCB6cGFyYW1zLnpwbG90KVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyB0aGlzIGlzIHRvIGJlIHVzZWQgdG8gZ3JheSBvdXQgYW5kIHJlbW92ZSBsaXN0ZW5lcnMgZm9yIHZhcmlhYmxlcyB0aGF0IGhhdmUgYmVlbiBzdWJzZXR0ZWQgb3V0IG9mIHRoZSBkYXRhXG4gICAgICAgIGZ1bmN0aW9uIHZhck91dCh2KSB7XG4gICAgICAgICAgICAvLyBpZiBpbiBub2RlcywgcmVtb3ZlIGdyYXkgb3V0IGluIGxlZnQgcGFuZWxcbiAgICAgICAgICAgIC8vIG1ha2UgdW5jbGlja2FibGUgaW4gbGVmdCBwYW5lbFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdE1lID0gdltpXS5yZXBsYWNlKC9cXFcvZywgXCJfXCIpO1xuICAgICAgICAgICAgICAgIGJ5SWQoc2VsZWN0TWUpLnN0eWxlLmNvbG9yID0gaGV4VG9SZ2JhKGdyYXlDb2xvcik7XG4gICAgICAgICAgICAgICAgc2VsZWN0TWUgPSBcInAjXCIuY29uY2F0KHNlbGVjdE1lKTtcbiAgICAgICAgICAgICAgICBkMy5zZWxlY3Qoc2VsZWN0TWUpXG4gICAgICAgICAgICAgICAgICAgIC5vbihcImNsaWNrXCIsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2hvd0xvZygnc3Vic2V0JywgckNhbGwpO1xuICAgICAgICByZVdyaXRlTG9nKCk7XG5cbiAgICAgICAgZDMuc2VsZWN0KFwiI2lubmVyY2Fyb3VzZWxcIilcbiAgICAgICAgICAgIC5hcHBlbmQoJ2RpdicpXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnaXRlbSBhY3RpdmUnKVxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgKCkgPT4gXCJtXCIuY29uY2F0KG15c3BhY2UudG9TdHJpbmcoKSkpXG4gICAgICAgICAgICAuYXBwZW5kKCdzdmcnKVxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ3doaXRlc3BhY2UnKTtcbiAgICAgICAgc3ZnID0gZDMuc2VsZWN0KFwiI3doaXRlc3BhY2VcIik7XG5cbiAgICAgICAgZDMuanNvbihqc29uLnVybCwgZnVuY3Rpb24oZXJyb3IsIGpzb24pIHtcbiAgICAgICAgICAgIGlmIChlcnJvcil7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybihlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIganNvbmRhdGEgPSBnZXRWYXJpYWJsZURhdGEoanNvbik7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBqc29uZGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciBteUluZGV4ID0gZmluZE5vZGVJbmRleChrZXkpO1xuXG4gICAgICAgICAgICAgICAgYWxsTm9kZXNbbXlJbmRleF0ucGxvdHggPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgYWxsTm9kZXNbbXlJbmRleF0ucGxvdHkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgYWxsTm9kZXNbbXlJbmRleF0ucGxvdHZhbHVlcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBhbGxOb2Rlc1tteUluZGV4XS5wbG90dHlwZSA9IFwiXCI7XG5cbiAgICAgICAgICAgICAgICBqUXVlcnkuZXh0ZW5kKHRydWUsIGFsbE5vZGVzW215SW5kZXhdLCBqc29uZGF0YVtrZXldKTtcbiAgICAgICAgICAgICAgICBhbGxOb2Rlc1tteUluZGV4XS5zdWJzZXRwbG90ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYWxsTm9kZXNbbXlJbmRleF0uc3Vic2V0cmFuZ2UgPSBbXCJcIiwgXCJcIl07XG4gICAgICAgICAgICAgICAgYWxsTm9kZXNbbXlJbmRleF0uc2V0eHBsb3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBhbGxOb2Rlc1tteUluZGV4XS5zZXR4dmFscyA9IFtcIlwiLCBcIlwiXTtcblxuICAgICAgICAgICAgICAgIGlmIChhbGxOb2Rlc1tteUluZGV4XS52YWxpZCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyYXlPdXRzLnB1c2goYWxsTm9kZXNbbXlJbmRleF0ubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGFsbE5vZGVzW215SW5kZXhdLmdyYXlvdXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlUGxvdCgpO1xuXG4gICAgICAgICAgICBsYXlvdXQobGF5b3V0QWRkKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyT3V0KGdyYXlPdXRzKTtcbiAgICB9XG5cbiAgICBzZWxlY3RMYWRkYS5zdGFydCgpOyAvL3N0YXJ0IGJ1dHRvbiBtb3Rpb25cbiAgICBtYWtlQ29yc1JlcXVlc3QodXJsY2FsbCwgYnRuLCBzdWJzZXRTZWxlY3RTdWNjZXNzLCBidG4gPT4gc2VsZWN0TGFkZGEuc3RvcCgpLCBzb2xhanNvbm91dCk7XG59XG5cbmZ1bmN0aW9uIHJlYWRQcmVwcm9jZXNzKGRhdGEpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIF8pID0+IHtcbiAgICAgICAgcHJpdiA9IGRhdGEuZGF0YXNldC5wcml2YXRlIHx8IHByaXY7XG4gICAgICAgIE9iamVjdC5rZXlzKGRhdGEudmFyaWFibGVzKS5mb3JFYWNoKGsgPT4gcHJlcHJvY2Vzc1trXSA9IGRhdGEudmFyaWFibGVzW2tdKTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgIH0pO1xufVxuXG4vLyByZW1vdmVzIGFsbCB0aGUgY2hpbGRyZW4gc3ZncyBpbnNpZGUgc3Vic2V0IGFuZCBzZXR4IGRpdnNcbmZ1bmN0aW9uIHJlUGxvdCgpIHtcbiAgICBkMy5zZWxlY3QoJyN0YWIyJylcbiAgICAgICAgLnNlbGVjdEFsbCgnc3ZnJylcbiAgICAgICAgLnJlbW92ZSgpO1xuICAgIGQzLnNlbGVjdCgnI3NldHgnKVxuICAgICAgICAuc2VsZWN0QWxsKCdzdmcnKVxuICAgICAgICAucmVtb3ZlKCk7XG4gICAgYWxsTm9kZXMuZm9yRWFjaChuID0+IG4uc2V0eHBsb3QgPSBuLnN1YnNldHBsb3QgPSBmYWxzZSk7XG59XG5cbmxldCBzaG93TG9nID0gKHZhbCwgckNhbGwpID0+IHtcbiAgICBsb2dBcnJheS5wdXNoKCh2YWwgKyAnOiAnKS5jb25jYXQockNhbGxbMF0pKTtcbiAgICBtLnJlZHJhdygpO1xufVxuXG5mdW5jdGlvbiByZVdyaXRlTG9nKCkge1xuICAgIGQzLnNlbGVjdChcIiNjb2xsYXBzZUxvZyBkaXYucGFuZWwtYm9keVwiKS5zZWxlY3RBbGwoXCJwXCIpXG4gICAgICAgIC5yZW1vdmUoKTtcbiAgICBkMy5zZWxlY3QoXCIjY29sbGFwc2VMb2cgZGl2LnBhbmVsLWJvZHlcIikuc2VsZWN0QWxsKFwicFwiKVxuICAgICAgICAuZGF0YShsb2dBcnJheSlcbiAgICAgICAgLmVudGVyKClcbiAgICAgICAgLmFwcGVuZChcInBcIilcbiAgICAgICAgLnRleHQoZCA9PiBkKTtcbn1cblxuLy8gYWN0cyBhcyBpZiB0aGUgdXNlciBjbGlja2VkIGluIHdoaXRlc3BhY2UuIHVzZWZ1bCB3aGVuIHJlc3RhcnQoKSBpcyBvdXRzaWRlIG9mIHNjb3BlXG5leHBvcnQgbGV0IGZha2VDbGljayA9ICgpID0+IHtcbiAgICBsZXQgd3MgPSBcIiN3aGl0ZXNwYWNlXCIuY29uY2F0KG15c3BhY2UpO1xuICAgIC8vIGQzIGFuZCBwcm9ncmFtbWF0aWMgZXZlbnRzIGRvbid0IG1lc2ggd2VsbCwgaGVyZSdzIGEgU08gd29ya2Fyb3VuZCB0aGF0IGxvb2tzIGdvb2QgYnV0IHVzZXMganF1ZXJ5Li4uXG4gICAgalF1ZXJ5LmZuLmQzQ2xpY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5lYWNoKChpLCBlKSA9PiB7XG4gICAgICAgICAgICBsZXQgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJNb3VzZUV2ZW50c1wiKTtcbiAgICAgICAgICAgIGV2dC5pbml0TW91c2VFdmVudChcIm1vdXNlZG93blwiLCB0cnVlLCB0cnVlLCB3aW5kb3csIDAsIDAsIDAsIDAsIDAsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAwLCBudWxsKTtcbiAgICAgICAgICAgIGUuZGlzcGF0Y2hFdmVudChldnQpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgICQod3MpLmQzQ2xpY2soKTtcbiAgICBkMy5zZWxlY3Qod3MpXG4gICAgICAgIC5jbGFzc2VkKCdhY3RpdmUnLCBmYWxzZSk7XG59O1xuXG5cblxuXG4vL0VuZFNlc3Npb24oU2Vzc2lvbkNvbnRleHQpIHJldHVybnMgKFJlc3BvbnNlKSB7fVxuZXhwb3J0IGZ1bmN0aW9uIGVuZHNlc3Npb24oKSB7XG4gICAgbGV0IFNlc3Npb25Db250ZXh0PSBhcGlTZXNzaW9uKHpwYXJhbXMuenNlc3Npb25pZCk7XG4gICAgXG4gICAgdmFyIGpzb25vdXQgPSBKU09OLnN0cmluZ2lmeShTZXNzaW9uQ29udGV4dCk7XG4gICAgXG4gICAgdmFyIHVybGNhbGwgPSBkM21VUkwgKyBcIi9lbmRzZXNzaW9uXCI7XG4gICAgdmFyIHNvbGFqc29ub3V0ID0gXCJncnBjcmVxdWVzdD1cIiArIGpzb25vdXQ7XG4gICAgY29uc29sZS5sb2coXCJFbmRTZXNzaW9uOiBcIilcbiAgICBjb25zb2xlLmxvZyhzb2xhanNvbm91dCk7XG4gICAgY29uc29sZS5sb2coXCJ1cmxjYWxsOiBcIiwgdXJsY2FsbCk7XG4gICAgXG4gICAgZnVuY3Rpb24gZW5kU3VjY2VzcyhidG4sIFJlc3BvbnNlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFJlc3BvbnNlKTtcbiAgICB9XG4gICAgXG4gICAgZnVuY3Rpb24gZW5kRmFpbChidG4pIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJlbmQgc2Vzc2lvbiBmYWlsZWRcIik7XG4gICAgfVxuICAgIFxuICAgIG1ha2VDb3JzUmVxdWVzdCh1cmxjYWxsLCBcIm5vYnV0dG9uXCIsIGVuZFN1Y2Nlc3MsIGVuZEZhaWwsIHNvbGFqc29ub3V0KTtcbn1cblxuLy9ycGMgTGlzdFBpcGVsaW5lcyhQaXBlbGluZUxpc3RSZXF1ZXN0KSByZXR1cm5zIChQaXBlbGluZUxpc3RSZXN1bHQpIHt9XG5leHBvcnQgZnVuY3Rpb24gbGlzdHBpcGVsaW5lcygpIHtcbiAgICBsZXQgU2Vzc2lvbkNvbnRleHQgPSBhcGlTZXNzaW9uKHpwYXJhbXMuenNlc3Npb25pZCk7XG4gICAgbGV0IFBpcGVMaW5lTGlzdFJlcXVlc3Q9e1Nlc3Npb25Db250ZXh0fTtcbiAgICBcbiAgICB2YXIganNvbm91dCA9IEpTT04uc3RyaW5naWZ5KFBpcGVMaW5lTGlzdFJlcXVlc3QpO1xuICAgIFxuICAgIHZhciB1cmxjYWxsID0gZDNtVVJMICsgXCIvbGlzdHBpcGVsaW5lc1wiO1xuICAgIHZhciBzb2xhanNvbm91dCA9IFwiZ3JwY3JlcXVlc3Q9XCIgKyBqc29ub3V0O1xuICAgIGNvbnNvbGUubG9nKFwiUGlwZWxpbmVMaXN0UmVxdWVzdDogXCIpO1xuICAgIGNvbnNvbGUubG9nKHNvbGFqc29ub3V0KTtcbiAgICBjb25zb2xlLmxvZyh1cmxjYWxsKTtcbiAgICBcbiAgICBmdW5jdGlvbiBsaXN0UGlwZXNTdWNjZXNzKGJ0biwgUGlwZWxpbmVMaXN0UmVzdWx0KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFBpcGVsaW5lTGlzdFJlc3VsdCk7XG4gICAgICAgIC8vaGFyZGNvZGVkIHBpcGVzIGZvciBub3dcbiAgICAgICAgbGV0IHBpcGVzID0gW1wiXCIsXCJpZDFcIiwgXCJpZDJcIiwgXCJpZDNcIiwgXCJpZDRcIiwgXCJpZDVcIl1cbiAgICAgICAgZDMuc2VsZWN0KFwiI3Jlc3VsdHNcIikuc2VsZWN0QWxsKFwicFwiKVxuICAgICAgICAuZGF0YShwaXBlcylcbiAgICAgICAgLmVudGVyKClcbiAgICAgICAgLmFwcGVuZChcInBcIilcbiAgICAgICAgLmF0dHIoXCJpZFwiLCBcIl9waXBlX1wiLmNvbmNhdClcbiAgICAgICAgLnRleHQoZCA9PiBkKVxuICAgICAgICAuYXR0cignY2xhc3MnLCAnaXRlbS1kZWZhdWx0JylcbiAgICAgICAgLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZih0aGlzLmNsYXNzTmFtZT09XCJpdGVtLXNlbGVjdFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkMy5zZWxlY3QoXCIjcmVzdWx0c1wiKS5zZWxlY3QoXCJwLml0ZW0tc2VsZWN0XCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2l0ZW0tZGVmYXVsdCcpO1xuICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5hdHRyKCdjbGFzcycsXCJpdGVtLXNlbGVjdFwiKTtcbiAgICAgICAgICAgIH19KTtcbiAgICAgICAgXG4gICAgICAgIGQzLnNlbGVjdChcIiNzZXR4UmlnaHRcIikuc2VsZWN0QWxsKFwicFwiKVxuICAgICAgICAuZGF0YShwaXBlcylcbiAgICAgICAgLmVudGVyKClcbiAgICAgICAgLmFwcGVuZChcInBcIilcbiAgICAgICAgLmF0dHIoXCJpZFwiLCBcIl9zZXR4cGlwZV9cIi5jb25jYXQpXG4gICAgICAgIC50ZXh0KGQgPT4gZClcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2l0ZW0tZGVmYXVsdCcpXG4gICAgICAgIC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYodGhpcy5jbGFzc05hbWU9PVwiaXRlbS1zZWxlY3RcIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGQzLnNlbGVjdChcIiNzZXR4UmlnaHRcIikuc2VsZWN0KFwicC5pdGVtLXNlbGVjdFwiKVxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2l0ZW0tZGVmYXVsdCcpO1xuICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmF0dHIoJ2NsYXNzJyxcIml0ZW0tc2VsZWN0XCIpO1xuICAgICAgICAgICAgfX0pO1xuICAgIH1cbiAgICBcbiAgICBmdW5jdGlvbiBsaXN0UGlwZXNGYWlsKGJ0bikge1xuICAgICAgICBjb25zb2xlLmxvZyhcImxpc3QgcGlwZWxpbmVzIGZhaWxlZFwiKTtcbiAgICB9XG4gICAgXG4gICAgbWFrZUNvcnNSZXF1ZXN0KHVybGNhbGwsIFwibm9idXR0b25cIiwgbGlzdFBpcGVzU3VjY2VzcywgbGlzdFBpcGVzRmFpbCwgc29sYWpzb25vdXQpO1xufVxuXG4vLyBycGMgRXhlY3V0ZVBpcGVsaW5lKFBpcGVsaW5lRXhlY3V0ZVJlcXVlc3QpIHJldHVybnMgKHN0cmVhbSBQaXBlbGluZUV4ZWN1dGVSZXN1bHQpIHt9XG5leHBvcnQgZnVuY3Rpb24gZXhlY3V0ZXBpcGVsaW5lKCkge1xuICAgIGxldCBTZXNzaW9uQ29udGV4dCA9IGFwaVNlc3Npb24oenBhcmFtcy56c2Vzc2lvbmlkKTtcbiAgICBsZXQgcGlwZWxpbmVpZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzZXR4UmlnaHQnKS5xdWVyeVNlbGVjdG9yKCdwLml0ZW0tc2VsZWN0Jyk7XG4gICAgaWYocGlwZWxpbmVpZCA9PSBudWxsKSB7YWxlcnQoXCJQbGVhc2Ugc2VsZWN0IGEgcGlwZWxpbmUgdG8gZXhlY3V0ZSBvbi5cIik7IHJldHVybjt9XG4gICAgcGlwZWxpbmVpZCA9IHBpcGVsaW5laWQuaW5uZXJUZXh0O1xuICAgIFxuICAgIFxuICAgIHpQb3AoKTtcbiAgICB6cGFyYW1zLmNhbGxIaXN0b3J5ID0gY2FsbEhpc3Rvcnk7XG4gICAgbGV0IGpzb25vdXQgPSBKU09OLnN0cmluZ2lmeSh6cGFyYW1zKTtcbiAgICBcbiAgICBsZXQgZmVhdHVyZXMgPSBhcGlGZWF0dXJlKHpwYXJhbXMuenZhcnMsXCJzb21lIHVyaVwiKTtcbiAgICBsZXQgZGF0YSA9IFtdO1xuICAgIFxuICAgIC8vdGhpcyB3aWxsIGp1c3Qgc2V0IHpwYXJhbXMuenNldHggdG8gdGhlIG1lYW4sIHdoaWNoIGlzIGRlZmF1bHQgZm9yIHNldHggcGxvdHNcbiAgICAvL25vdGUgdGhhdCBpZiBzZXR4cGxvdCBpcyBtb2RpZmllZCwgaXQgd2lsbCBOT1QgPT0gXCJcIiBiZWNhdXNlIHpwYXJhbXMuenNldHggaXMgbW9kaWZpZWQgd2hlbiB0aGUgc2V0eCBwbG90IHNsaWRlciBpcyBtb3ZlZCBmb3IgdGhlIGZpcnN0IHRpbWVcbiAgICBmb3IobGV0IGkgPTA7IGk8enBhcmFtcy56dmFycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgbXlkYXRhID0gW107XG4gICAgICAgIGxldCBteW1lYW4gPSBhbGxOb2Rlc1tmaW5kTm9kZUluZGV4KHpwYXJhbXMuenZhcnNbaV0pXS5tZWFuO1xuICAgICAgICBpZih6cGFyYW1zLnpzZXR4W2ldWzBdPT1cIlwiKSB7XG4gICAgICAgICAgICBteWRhdGFbMF09bXltZWFuO1xuICAgICAgICB9IGVsc2UgaWYoenBhcmFtcy56c2V0eFtpXVswXSE9bXltZWFuKXtcbiAgICAgICAgICAgIG15ZGF0YVswXT16cGFyYW1zLnpzZXR4W2ldWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmKHpwYXJhbXMuenNldHhbaV1bMV09PVwiXCIpIHtcbiAgICAgICAgICAgIG15ZGF0YVsxXT1hbGxOb2Rlc1tmaW5kTm9kZUluZGV4KHpwYXJhbXMuenZhcnNbaV0pXS5tZWFuO1xuICAgICAgICB9IGVsc2UgaWYoenBhcmFtcy56c2V0eFtpXVsxXSE9bXltZWFuKXtcbiAgICAgICAgICAgIG15ZGF0YVsxXT16cGFyYW1zLnpzZXR4W2ldWzFdO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEucHVzaChteWRhdGEpO1xuICAgIH1cbiAgICBcbiAgICBsZXQgUGlwZWxpbmVFeGVjdXRlUmVxdWVzdD17U2Vzc2lvbkNvbnRleHQsIHBpcGVsaW5laWQsIGZlYXR1cmVzLCBkYXRhfTtcbiAgICBcbiAgICBqc29ub3V0ID0gSlNPTi5zdHJpbmdpZnkoUGlwZWxpbmVFeGVjdXRlUmVxdWVzdCk7XG4gICAgXG4gICAgdmFyIHVybGNhbGwgPSBkM21VUkwgKyBcIi9leGVjdXRlcGlwZWxpbmVcIjtcbiAgICB2YXIgc29sYWpzb25vdXQgPSBcImdycGNyZXF1ZXN0PVwiICsganNvbm91dDtcbiAgICBjb25zb2xlLmxvZyhcIlBpcGVsaW5lRXhlY3V0ZVJlcXVlc3Q6IFwiKTtcbiAgICBjb25zb2xlLmxvZyhzb2xhanNvbm91dCk7XG4gICAgY29uc29sZS5sb2coXCJ1cmxjYWxsOiBcIiwgdXJsY2FsbCk7XG4gICAgXG4gICAgZnVuY3Rpb24gZXhlY3V0ZVBpcGVTdWNjZXNzKGJ0biwgUGlwZWxpbmVFeGVjdXRlUmVzdWx0KSB7XG4gICAgICAgIGFsZXJ0KFwicGlwZWxpbmUgZXhlY3V0ZWRcIik7XG4gICAgICAgIGNvbnNvbGUubG9nKFBpcGVsaW5lRXhlY3V0ZVJlc3VsdCk7XG4gICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIGV4ZWN1dGVQaXBlRmFpbChidG4pIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJleGVjdXRlIHBpcGVsaW5lcyBmYWlsZWRcIik7XG4gICAgfVxuICAgIFxuICAgIG1ha2VDb3JzUmVxdWVzdCh1cmxjYWxsLCBcIm5vYnV0dG9uXCIsIGV4ZWN1dGVQaXBlU3VjY2VzcywgZXhlY3V0ZVBpcGVGYWlsLCBzb2xhanNvbm91dCk7XG59XG5cbi8vIHRoaXMgaXMgb3VyIGNhbGwgdG8gZGphbmdvIHRvIHVwZGF0ZSB0aGUgcHJvYmxlbSBzY2hlbWFcbi8vIHJwYyBVcGRhdGVQcm9ibGVtU2NoZW1hKFVwZGF0ZVByb2JsZW1TY2hlbWFSZXF1ZXN0KSByZXR1cm5zIChSZXNwb25zZSkge31cbmZ1bmN0aW9uIHVwZGF0ZVNjaGVtYSh0eXBlLCB1cGRhdGVzLCBsb29rdXApIHtcbiAgICBsZXQgUmVwbGFjZVByb2JsZW1TY2hlbWFGaWVsZD17W3R5cGVdOmxvb2t1cFt1cGRhdGVzW3R5cGVdXVsxXX07XG4vLyAgICBsZXQgdmFsdWVudW0gPSBsb29rdXBbdXBkYXRlc1t0eXBlXV1bMl07XG4gICAgbGV0IFVwZGF0ZVByb2JsZW1TY2hlbWFSZXF1ZXN0ID0ge1JlcGxhY2VQcm9ibGVtU2NoZW1hRmllbGR9O1xuXG4gICAgbGV0IGpzb25vdXQgPSBKU09OLnN0cmluZ2lmeShVcGRhdGVQcm9ibGVtU2NoZW1hUmVxdWVzdCk7XG5cbiAgICBsZXQgdXJsY2FsbCA9IGQzbVVSTCArIFwiL3VwZGF0ZXByb2JsZW1zY2hlbWFcIjtcbiAgICBsZXQgc29sYWpzb25vdXQgPSBcImdycGNyZXF1ZXN0PVwiICsganNvbm91dDtcbiAgICBjb25zb2xlLmxvZyhcIlVwZGF0ZVByb2JsZW1TY2hlbWFSZXF1ZXN0OiBcIik7XG4gICAgY29uc29sZS5sb2coc29sYWpzb25vdXQpO1xuICAgIGNvbnNvbGUubG9nKFwidXJsY2FsbDogXCIsIHVybGNhbGwpO1xuXG4gICAgZnVuY3Rpb24gdXNTdWNjZXNzKGJ0biwgUmVzcG9uc2UpIHtcbiAgICAgICAgY29uc29sZS5sb2coUmVzcG9uc2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVzRmFpbChidG4pIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJ1cGRhdGUgc2NoZW1hIGZhaWxlZFwiKTtcbiAgICB9XG5cbiAgICBtYWtlQ29yc1JlcXVlc3QodXJsY2FsbCwgXCJub2J1dHRvblwiLCB1c1N1Y2Nlc3MsIHVzRmFpbCwgc29sYWpzb25vdXQpO1xufVxuXG5cbi8vIEZpbmQgc29tZXRoaW5nIGNlbnRlcmlzaCB0byB0aGUgdmVydGljZXMgb2YgYSBjb252ZXggaHVsbFxuLy8gKHNwZWNpZmljYWxseSwgdGhlIGNlbnRlciBvZiB0aGUgYm91bmRpbmcgYm94KVxuZnVuY3Rpb24gamFtZXNjZW50cm9pZChjb29yZCl7XG4gICAgdmFyIG1pbnggPSBjb29yZFswXVswXSxcbiAgICAgICAgbWF4eCA9IGNvb3JkWzBdWzBdLFxuICAgICAgICBtaW55ID0gY29vcmRbMF1bMV0sXG4gICAgICAgIG1heHkgPSBjb29yZFswXVsxXTtcbiAgICBmb3IodmFyIGogPSAxOyBqPGNvb3JkLmxlbmd0aDsgaisrKXtcbiAgICAgICAgaWYgKGNvb3JkW2pdWzBdIDwgbWlueCkgbWlueCA9IGNvb3JkW2pdWzBdO1xuICAgICAgICBpZiAoY29vcmRbal1bMV0gPCBtaW55KSBtaW55ID0gY29vcmRbal1bMV07XG4gICAgICAgIGlmIChjb29yZFtqXVswXSA+IG1heHgpIG1heHggPSBjb29yZFtqXVswXTtcbiAgICAgICAgaWYgKGNvb3JkW2pdWzFdID4gbWF4eSkgbWF4eSA9IGNvb3JkW2pdWzFdO1xuICAgIH07XG4gICAgICAgIHJldHVyblsobWlueCArIG1heHgpLzIsIChtaW55ICsgbWF4eSkvMl07XG59O1xuXG4vLyBEZWZpbmUgZWFjaCBwZWJibGUgcmFkaXVzLlxuLy8gUHJlc2VudGx5LCBtb3N0IHBlYmJsZXMgYXJlIHNjYWxlZCB0byByYWRpdXMgc2V0IGJ5IGdsb2JhbCBhbGxSLlxuLy8gTWVtYmVycyBvZiBncm91cHMgYXJlIHNjYWxlZCBkb3duIGlmIGdyb3VwIGdldHMgbGFyZ2UuXG5mdW5jdGlvbiBzZXRQZWJibGVSYWRpdXMoZCl7XG4gICAgaWYoZC5ncm91cDEgfHwgZC5ncm91cDIpeyAgIC8vIGlmIGEgbWVtYmVyIG9mIGEgZ3JvdXAsIG5lZWQgdG8gY2FsY3VsYXRlIHJhZGl1cyBzaXplXG4gICAgICAgIHZhciB1cHBlcnNpemUgPSA3XG4gICAgICAgIHZhciBuZzEgPSAoZC5ncm91cDEpID8genBhcmFtcy56Z3JvdXAxLmxlbmd0aCA6IDE7ICAgICAgLy8gc2l6ZSBvZiBncm91cDEsIGlmIGEgbWVtYmVyIG9mIGdyb3VwIDFcbiAgICAgICAgdmFyIG5nMiA9IChkLmdyb3VwMikgPyB6cGFyYW1zLnpncm91cDIubGVuZ3RoIDogMTsgICAgICAvLyBzaXplIG9mIGdyb3VwMiwgaWYgYSBtZW1iZXIgb2YgZ3JvdXAgMlxuICAgICAgICB2YXIgbWF4bmcgPSBNYXRoLm1heChuZzEsbmcyKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzaXplIG9mIHRoZSBsYXJnZXN0IGdyb3VwIHZhcmlhYmxlIGlzIG1lbWJlciBvZlxuICAgICAgICByZXR1cm4gKG1heG5nPnVwcGVyc2l6ZSkgPyBhbGxSKk1hdGguc3FydCh1cHBlcnNpemUvbWF4bmcpIDogYWxsUjsgICAgICAgICAgICAgICAgICAvLyBrZWVwIHRvdGFsIGFyZWEgb2YgcGViYmxlcyBib3VuZGVkIHRvIHBpICogYWxsUl4yICogdXBwZXJzaXplLCB0aHVzIHNocmlua2luZyByYWRpdXMgZm9yIHBlYmJsZXMgaW4gbGFyZ2VyIGdyb3VwcyAgICAgICAgICAgICAgICBcbiAgICB9ZWxzZXsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgIHJldHVybiBhbGxSICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vbmdyb3VwIG1lbWJlcnMgZ2V0IHRoZSBjb21tb24gZ2xvYmFsIHJhZGl1c1xuICAgIH1cbn07XG5cbi8vIERlZmluZSBlYWNoIHBlYmJsZSBjaGFyZ2UuXG4vLyBUaGlzIHdhcyB0aGUgcHJldmlvdXMgY2hhcmdlIHNldHRpbmc6XG4vL3JldHVybiAoKHpwYXJhbXMuemdyb3VwMS5pbmRleE9mKG5vZGUubmFtZSkgPCAwICkgJiAoenBhcmFtcy56Z3JvdXAyLmluZGV4T2Yobm9kZS5uYW1lKSA8IDAgKSkgICA/IC04MDAgOiAtNDAwOyAgLy8gLTEgaXMgdGhlIHZhbHVlIGlmIG5vIGluZGV4IHBvc2l0aW9uIGZvdW5kXG5mdW5jdGlvbiBzZXRQZWJibGVDaGFyZ2UoZCl7XG4gICAgaWYoZC5ncm91cDEgfHwgZC5ncm91cDIpeyBcbiAgICAgICAgaWYoZC5mb3JlZnJvbnQpeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwZWJibGVzIHBhY2tlZCBpbiBncm91cHMgcmVwZWwgb3RoZXJzIG9uIG1vdXNlb3ZlclxuICAgICAgICAgICAgcmV0dXJuIC0xMDAwXG4gICAgICAgIH1cbiAgICAgICAgdmFyIHVwcGVyc2l6ZSA9IDdcbiAgICAgICAgdmFyIG5nMSA9IChkLmdyb3VwMSkgPyB6cGFyYW1zLnpncm91cDEubGVuZ3RoIDogMTsgICAgICAvLyBzaXplIG9mIGdyb3VwMSwgaWYgYSBtZW1iZXIgb2YgZ3JvdXAgMVxuICAgICAgICB2YXIgbmcyID0gKGQuZ3JvdXAyKSA/IHpwYXJhbXMuemdyb3VwMi5sZW5ndGggOiAxOyAgICAgIC8vIHNpemUgb2YgZ3JvdXAyLCBpZiBhIG1lbWJlciBvZiBncm91cCAyXG4gICAgICAgIHZhciBtYXhuZyA9IE1hdGgubWF4KG5nMSxuZzIpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNpemUgb2YgdGhlIGxhcmdlc3QgZ3JvdXAgdmFyaWFibGUgaXMgbWVtYmVyIG9mXG4gICAgICAgIHJldHVybiAobWF4bmc+dXBwZXJzaXplKSA/IC00MDAqKHVwcGVyc2l6ZS9tYXhuZykgOiAtNDAwOyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRlY3JlYXNlIGNoYXJnZSBhcyBwZWJibGVzIGJlY29tZSBzbWFsbGVyLCBzbyB0aGV5IGNhbiBwYWNrIHRvZ2V0aGVyXG4gICAgfWVsc2V7XG4gICAgICAgIHJldHVybiAtODAwXG4gICAgfVxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGV4cGFuZHJpZ2h0cGFuZWwoKSB7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3JpZ2h0cGFuZWwnKS5jbGFzc0xpc3QuYWRkKFwiZXhwYW5kcGFuZWxmdWxsXCIpXG4gICAgY29uc29sZS5sb2coXCJIRVJFXCIpO1xufVxuXG5mdW5jdGlvbiB0b2dnbGVSaWdodEJ1dHRvbnMoc2V0KSB7XG4gICAgXG4gICAgZnVuY3Rpb24gc2V0V2lkdGhzKGJ0bnMpIHtcbiAgICAgICAgbGV0IG15d2lkdGggPSAxMDAvYnRucy5sZW5ndGg7XG4gICAgICAgIG15d2lkdGggPSBteXdpZHRoLnRvU3RyaW5nKCkgKyAnJSc7XG4gICAgICAgIGxldCBleHBhbmR3aWR0aCA9ICczNSUnO1xuICAgICAgICBsZXQgc2hyaW5rd2lkdGggPSA2NS8oYnRucy5sZW5ndGgtMSk7XG4gICAgICAgIHNocmlua3dpZHRoID0gc2hyaW5rd2lkdGgudG9TdHJpbmcoKSArICclJztcbiAgICAgICAgbGV0IG15bGlzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3JpZ2h0cGFuZWwnKS5xdWVyeVNlbGVjdG9yQWxsKFwiLmFjY29yZGlhbiBsaVwiKTtcbiAgICAgICAgLy8gaGFyZGx5IGV2ZXIgcnVucyBvbiB0aGUgcGFnZVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG15bGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBteWxpc1tpXS5zdHlsZS53aWR0aD1teXdpZHRoO1xuICAgICAgICAgICAgbXlsaXNbaV0uYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaiA9IDA7IGogPCBteWxpcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBteWxpc1tqXS5zdHlsZS53aWR0aD1zaHJpbmt3aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0eWxlLndpZHRoPWV4cGFuZHdpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG15bGlzW2ldLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaiA9IDA7IGogPCBteWxpcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBteWxpc1tqXS5zdHlsZS53aWR0aD1teXdpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgIH1cblxuICAgIGlmKHNldD09XCJ0YXNrc1wiKSB7XG5cbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2J0bk1vZGVscycpLmNsYXNzTGlzdC5hZGQoXCJub3Nob3dcIik7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdidG5TZXR4JykuY2xhc3NMaXN0LmFkZChcIm5vc2hvd1wiKTtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2J0blJlc3VsdHMnKS5jbGFzc0xpc3QuYWRkKFwibm9zaG93XCIpO1xuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIGxldCBteWJ0bnMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmlnaHRwYW5lbGJ1dHRvbnMnKS5xdWVyeVNlbGVjdG9yQWxsKFwiLmJ0bjpub3QoLm5vc2hvdylcIik7XG4gICAgICAgIHNldFdpZHRocyhteWJ0bnMpO1xuICAgICAgICBcbiAgICAgICAgXG4gICAgfSBlbHNlIGlmIChzZXQ9PVwiYWxsXCIpIHtcbiAgICAgICAgLy8gZmlyc3QgcmVtb3ZlIG5vc2hvdyBjbGFzc1xuICAgICAgICBsZXQgbXlidG5zID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3JpZ2h0cGFuZWxidXR0b25zJykucXVlcnlTZWxlY3RvckFsbChcIi5ub3Nob3dcIik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXlidG5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBteWJ0bnNbaV0uY2xhc3NMaXN0LnJlbW92ZShcIm5vc2hvd1wiKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gZHJvcGluZyBtb2RlbHMgZm9yIGQzbV9tb2RlXG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdidG5Nb2RlbHMnKS5jbGFzc0xpc3QuYWRkKFwibm9zaG93XCIpO1xuICAgICAgICBcbiAgICAgICAgLy8gdGhlbiBzZWxlY3QgYWxsIHRoZSBidXR0b25zXG4gICAgICAgIG15YnRucyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyaWdodHBhbmVsYnV0dG9ucycpLnF1ZXJ5U2VsZWN0b3JBbGwoXCIuYnRuOm5vdCgubm9zaG93KVwiKTtcbiAgICAgICAgc2V0V2lkdGhzKG15YnRucyk7XG5cbiAgICB9XG4gICAgaWYoc2V0PT1cIm1vZGVsc1wiKSB7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdidG5Nb2RlbHMnKS5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZSc7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdidG5TZXR4Jykuc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUnO1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYnRuUmVzdWx0cycpLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lJztcblxuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYnRuVHlwZScpLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdidG5TdWJ0eXBlJykuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2J0bk1ldHJpY3MnKS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYnRuT3V0cHV0cycpLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgfVxufVxuXG5cblxuXG5cbi8vIHNjYXR0ZXJwbG90IGZ1bmN0aW9uIHRvIGdvIHRvIHBsb3RzLmpzIHRvIGJlIHJldXNlZFxuZXhwb3J0IGZ1bmN0aW9uIGJpdmFyaWF0ZVBsb3QoeF9BeGlzLCB5X0F4aXMsIHhfQXhpc19uYW1lLCB5X0F4aXNfbmFtZSkge1xuICAgIFxuICAgIGQzLnNlbGVjdChcIiNzZXR4TWlkZGxlXCIpLmh0bWwoXCJcIik7XG4gICAgZDMuc2VsZWN0KFwiI3NldHhNaWRkbGVcIikuc2VsZWN0KFwic3ZnXCIpLnJlbW92ZSgpO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKFwiYml2YXJpYXRlIHBsb3QgY2FsbGVkXCIpO1xuICAgIC8vIHNjYXR0ZXIgcGxvdFxuICAgIFxuICAgIGxldCBkYXRhX3Bsb3QgPSBbXTtcbiAgICB2YXIgbmFuQ291bnQgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTAwMDsgaSsrKSB7XG4gICAgICAgIGlmIChpc05hTih4X0F4aXNbaV0pIHx8IGlzTmFOKHlfQXhpc1tpXSkpIHtcbiAgICAgICAgICAgIG5hbkNvdW50Kys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbmV3TnVtYmVyMSA9IHhfQXhpc1tpXTtcbiAgICAgICAgICAgIHZhciBuZXdOdW1iZXIyID0geV9BeGlzW2ldO1xuICAgICAgICAgICAgZGF0YV9wbG90LnB1c2goe3hheGlzOiBuZXdOdW1iZXIxLCB5YXhpczogbmV3TnVtYmVyMiwgc2NvcmU6IE1hdGgucmFuZG9tKCkgKiAxMDB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBcbiAgICB9XG4gICAgXG4gICAgXG4gICAgdmFyIG1hcmdpbiA9IHt0b3A6IDIwLCByaWdodDogMTUsIGJvdHRvbTogNDAsIGxlZnQ6IDYwfVxuICAgICwgd2lkdGggPSA1MDAgLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodFxuICAgICwgaGVpZ2h0ID0gMjgwIC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b207XG4gICAgdmFyIHBhZGRpbmcgPSAxMDA7XG4gICAgXG4gICAgdmFyIG1pbl94ID0gZDMubWluKGRhdGFfcGxvdCwgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFfcGxvdFtpXS54YXhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgdmFyIG1heF94ID0gZDMubWF4KGRhdGFfcGxvdCwgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFfcGxvdFtpXS54YXhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgdmFyIGF2Z194ID0gKG1heF94IC0gbWluX3gpIC8gMTA7XG4gICAgdmFyIG1pbl95ID0gZDMubWluKGRhdGFfcGxvdCwgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFfcGxvdFtpXS55YXhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgdmFyIG1heF95ID0gZDMubWF4KGRhdGFfcGxvdCwgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFfcGxvdFtpXS55YXhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgdmFyIGF2Z195ID0gKG1heF95IC0gbWluX3kpIC8gMTA7XG4gICAgXG4gICAgdmFyIHhTY2FsZSA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgLmRvbWFpbihbbWluX3ggLSBhdmdfeCwgbWF4X3ggKyBhdmdfeF0pXG4gICAgLnJhbmdlKFswLCB3aWR0aF0pO1xuICAgIFxuICAgIHZhciB5U2NhbGUgPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgIC5kb21haW4oW21pbl95IC0gYXZnX3ksIG1heF95ICsgYXZnX3ldKVxuICAgIC5yYW5nZShbaGVpZ2h0LCAwXSk7XG4gICAgXG4gICAgdmFyIHhBeGlzID0gZDMuc3ZnLmF4aXMoKVxuICAgIC5zY2FsZSh4U2NhbGUpXG4gICAgLm9yaWVudCgnYm90dG9tJylcbiAgICAudGlja1NpemUoLWhlaWdodCk7XG4gICAgXG4gICAgdmFyIHlBeGlzID0gZDMuc3ZnLmF4aXMoKVxuICAgIC5zY2FsZSh5U2NhbGUpXG4gICAgLm9yaWVudCgnbGVmdCcpXG4gICAgLnRpY2tzKDUpXG4gICAgLnRpY2tTaXplKC13aWR0aCk7XG4gICAgXG4gICAgdmFyIHpvb20gPSBkMy5iZWhhdmlvci56b29tKClcbiAgICAueCh4U2NhbGUpXG4gICAgLnkoeVNjYWxlKVxuICAgIC5zY2FsZUV4dGVudChbMSwgMTBdKVxuICAgIC5vbihcInpvb21cIiwgem9vbWVkKTtcbiAgICBcbiAgICB2YXIgY2hhcnRfc2NhdHRlciA9IGQzLnNlbGVjdCgnI3NldHhNaWRkbGUnKVxuICAgIC5hcHBlbmQoJ3N2ZzpzdmcnKVxuICAgIC5hdHRyKCd3aWR0aCcsIHdpZHRoICsgbWFyZ2luLnJpZ2h0ICsgbWFyZ2luLmxlZnQpXG4gICAgLmF0dHIoJ2hlaWdodCcsIGhlaWdodCArIG1hcmdpbi50b3AgKyBtYXJnaW4uYm90dG9tKTtcbiAgIC8vIC5jYWxsKHpvb20pOyBkcm9wcGluZyB0aGlzIGZvciBub3csIHVudGlsIHRoZSBsaW5lIHpvb21zIHByb3Blcmx5XG4gICAgXG4gICAgdmFyIG1haW4xID0gY2hhcnRfc2NhdHRlci5hcHBlbmQoJ2cnKVxuICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBtYXJnaW4ubGVmdCArICcsJyArIG1hcmdpbi50b3AgKyAnKScpXG4gICAgLmF0dHIoJ3dpZHRoJywgd2lkdGgrIG1hcmdpbi5yaWdodCArIG1hcmdpbi5sZWZ0KVxuICAgIC5hdHRyKCdoZWlnaHQnLCBoZWlnaHQgKyBtYXJnaW4udG9wICsgbWFyZ2luLmJvdHRvbSlcbiAgICAuYXR0cignY2xhc3MnLCAnbWFpbicpO1xuICAgIFxuICAgIGxldCBnWCA9IG1haW4xLmFwcGVuZCgnZycpXG4gICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwnICsgaGVpZ2h0ICsgJyknKVxuICAgIC5hdHRyKCdjbGFzcycsICd4IGF4aXMnKVxuICAgIC5jYWxsKHhBeGlzKTtcbiAgICBcbiAgICBsZXQgZ1kgPSBtYWluMS5hcHBlbmQoJ2cnKVxuICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsMCknKVxuICAgIC5hdHRyKCdjbGFzcycsICd5IGF4aXMnKVxuICAgIC5jYWxsKHlBeGlzKTtcbiAgICBcbiAgICB2YXIgY2xpcCA9IG1haW4xLmFwcGVuZChcImRlZnNcIikuYXBwZW5kKFwic3ZnOmNsaXBQYXRoXCIpXG4gICAgLmF0dHIoXCJpZFwiLCBcImNsaXBcIilcbiAgICAuYXBwZW5kKFwic3ZnOnJlY3RcIilcbiAgICAuYXR0cihcImlkXCIsIFwiY2xpcC1yZWN0XCIpXG4gICAgLmF0dHIoXCJ4XCIsIFwiMFwiKVxuICAgIC5hdHRyKFwieVwiLCBcIjBcIilcbiAgICAuYXR0cignd2lkdGgnLCB3aWR0aClcbiAgICAuYXR0cignaGVpZ2h0JywgaGVpZ2h0KTtcbiAgICBcbiAgICBtYWluMS5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGlwLXBhdGhcIiwgXCJ1cmwoI2NsaXApXCIpXG4gICAgLnNlbGVjdEFsbChcImNpcmNsZVwiKVxuICAgIC5kYXRhKGRhdGFfcGxvdClcbiAgICAuZW50ZXIoKVxuICAgIC5hcHBlbmQoXCJjaXJjbGVcIilcbiAgICAuYXR0cihcImN4XCIsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgcmV0dXJuIHhTY2FsZShkYXRhX3Bsb3RbaV0ueGF4aXMpO1xuICAgICAgICAgIH0pXG4gICAgLmF0dHIoXCJjeVwiLCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgIHJldHVybiB5U2NhbGUoZGF0YV9wbG90W2ldLnlheGlzKTtcbiAgICAgICAgICB9KVxuICAgIC5hdHRyKFwiclwiLCAyKVxuICAgIC5zdHlsZShcImZpbGxcIiwgXCIjQjcxQzFDXCIpXG4gICAgO1xuICAgIGNoYXJ0X3NjYXR0ZXIuYXBwZW5kKFwidGV4dFwiKVxuICAgIC5hdHRyKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIikgIC8vIHRoaXMgbWFrZXMgaXQgZWFzeSB0byBjZW50cmUgdGhlIHRleHQgYXMgdGhlIHRyYW5zZm9ybSBpcyBhcHBsaWVkIHRvIHRoZSBhbmNob3JcbiAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIHBhZGRpbmcgLyA1ICsgXCIsXCIgKyAoaGVpZ2h0IC8gMikgKyBcIilyb3RhdGUoLTkwKVwiKSAgLy8gdGV4dCBpcyBkcmF3biBvZmYgdGhlIHNjcmVlbiB0b3AgbGVmdCwgbW92ZSBkb3duIGFuZCBvdXQgYW5kIHJvdGF0ZVxuICAgIC50ZXh0KHlfQXhpc19uYW1lKVxuICAgIC5zdHlsZShcImZpbGxcIiwgXCIjNDI0MjQyXCIpXG4gICAgLnN0eWxlKFwidGV4dC1pbmRlbnRcIixcIjIwcHhcIilcbiAgICAuc3R5bGUoXCJmb250LXNpemVcIixcIjEycHhcIilcbiAgICAuc3R5bGUoXCJmb250LXdlaWdodFwiLFwiYm9sZFwiKTtcbiAgICBcbiAgICBjaGFydF9zY2F0dGVyLmFwcGVuZChcInRleHRcIilcbiAgICAuYXR0cihcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpICAvLyB0aGlzIG1ha2VzIGl0IGVhc3kgdG8gY2VudHJlIHRoZSB0ZXh0IGFzIHRoZSB0cmFuc2Zvcm0gaXMgYXBwbGllZCB0byB0aGUgYW5jaG9yXG4gICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyAod2lkdGggLyAyKSArIFwiLFwiICsgKGhlaWdodCArIChwYWRkaW5nIC8gMikpICsgXCIpXCIpICAvLyBjZW50cmUgYmVsb3cgYXhpc1xuICAgIC50ZXh0KHhfQXhpc19uYW1lKVxuICAgIC5zdHlsZShcImZpbGxcIiwgXCIjNDI0MjQyXCIpXG4gICAgLnN0eWxlKFwidGV4dC1pbmRlbnRcIixcIjIwcHhcIilcbiAgICAuc3R5bGUoXCJmb250LXNpemVcIixcIjEycHhcIilcbiAgICAuc3R5bGUoXCJmb250LXdlaWdodFwiLFwiYm9sZFwiKTtcbiAgICBcbiAgICBtYWluMS5hcHBlbmQoXCJsaW5lXCIpXG4gICAgLmF0dHIoXCJ4MVwiLCB4U2NhbGUobWluX3gpKVxuICAgIC5hdHRyKFwieTFcIiwgeVNjYWxlKG1pbl94KSlcbiAgICAuYXR0cihcIngyXCIsIHhTY2FsZShtYXhfeCkpXG4gICAgLmF0dHIoXCJ5MlwiLCB5U2NhbGUobWF4X3gpKVxuICAgIC5hdHRyKFwic3Ryb2tlLXdpZHRoXCIsIDIpXG4gICAgLmF0dHIoXCJzdHJva2VcIiwgXCJibGFja1wiKTtcbiAgICBcbiAgICBmdW5jdGlvbiB6b29tZWQoKSB7XG4gICAgICAgIHZhciBwYW5YID0gZDMuZXZlbnQudHJhbnNsYXRlWzBdO1xuICAgICAgICB2YXIgcGFuWSA9IGQzLmV2ZW50LnRyYW5zbGF0ZVsxXTtcbiAgICAgICAgdmFyIHNjYWxlID0gZDMuZXZlbnQuc2NhbGU7XG4gICAgICAgIFxuICAgICAgICBwYW5YID0gcGFuWCA+IDEwID8gMTAgOiBwYW5YO1xuICAgICAgICB2YXIgbWF4WCA9IC0oc2NhbGUgLSAxKSAqIHdpZHRoIC0gMTA7XG4gICAgICAgIHBhblggPSBwYW5YIDwgbWF4WCA/IG1heFggOiBwYW5YO1xuICAgICAgICBcbiAgICAgICAgcGFuWSA9IHBhblkgPiAxMCA/IDEwIDogcGFuWTtcbiAgICAgICAgdmFyIG1heFkgPSAtKHNjYWxlIC0gMSkgKiBoZWlnaHQgLSAxMDtcbiAgICAgICAgcGFuWSA9IHBhblkgPCBtYXhZID8gbWF4WSA6IHBhblk7XG4gICAgICAgIFxuICAgICAgICB6b29tLnRyYW5zbGF0ZShbcGFuWCwgcGFuWV0pO1xuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIG1haW4xLnNlbGVjdChcIi54LmF4aXNcIikuY2FsbCh4QXhpcyk7XG4gICAgICAgIG1haW4xLnNlbGVjdChcIi55LmF4aXNcIikuY2FsbCh5QXhpcyk7XG4gICAgICAgIG1haW4xLnNlbGVjdEFsbChcImNpcmNsZVwiKVxuICAgICAgICAuYXR0cihcImN4XCIsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY2lyY2xlIHggXCIseFNjYWxlKDUpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHhTY2FsZShkYXRhX3Bsb3RbaV0ueGF4aXMpO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAuYXR0cihcImN5XCIsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB5U2NhbGUoZGF0YV9wbG90W2ldLnlheGlzKTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoXCJyXCIsIDIuNSlcbiAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBcIiNCNzFDMUNcIilcbiAgICAgICAgO1xuICAgXG4gICAgICAgLy8gYmVsb3cgZG9lc24ndCB3b3JrLCBzbyBJJ20ganVzdCBkcm9wcGluZyB0aGUgem9vbVxuICAgICAgICBtYWluMS5zZWxlY3QoXCJsaW5lXCIpXG4gICAgICAgIC5hdHRyKFwieDFcIiwgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgICByZXR1cm4geFNjYWxlKG1pbl94KTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoXCJ5MVwiLCBmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB4U2NhbGUobWluX3gpO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAuYXR0cihcIngyXCIsIGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHhTY2FsZShtYXhfeCk7XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgIC5hdHRyKFwieTJcIiwgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgICByZXR1cm4geVNjYWxlKG1heF94KTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoXCJzdHJva2Utd2lkdGhcIiwgMilcbiAgICAgICAgLmF0dHIoXCJzdHJva2VcIiwgXCJibGFja1wiKTtcbiAgICB9XG4gICAgXG4gICAgXG4gICAgXG4gIC8vICBkMy5zZWxlY3QoXCIjTkFjb3VudFwiKS50ZXh0KFwiVGhlcmUgYXJlIFwiICsgbmFuQ291bnQgKyBcIiBudW1iZXIgb2YgTkEgdmFsdWVzIGluIHRoZSByZWxhdGlvbi5cIik7XG4gICAgXG4gICAgXG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHNldHhUYWJsZShmZWF0dXJlcykge1xuICAgIGZ1bmN0aW9uIHRhYnVsYXRlKGRhdGEsIGNvbHVtbnMpIHtcbiAgICAgICAgdmFyIHRhYmxlID0gZDMuc2VsZWN0KCcjc2V0eExlZnRCb3R0b20nKS5hcHBlbmQoJ3RhYmxlJylcbiAgICAgICAgdmFyIHRoZWFkID0gdGFibGUuYXBwZW5kKCd0aGVhZCcpXG4gICAgICAgIHZhclx0dGJvZHkgPSB0YWJsZS5hcHBlbmQoJ3Rib2R5Jyk7XG4gICAgICAgIFxuICAgICAgICAvLyBhcHBlbmQgdGhlIGhlYWRlciByb3dcbiAgICAgICAgdGhlYWQuYXBwZW5kKCd0cicpXG4gICAgICAgIC5zZWxlY3RBbGwoJ3RoJylcbiAgICAgICAgLmRhdGEoY29sdW1ucykuZW50ZXIoKVxuICAgICAgICAuYXBwZW5kKCd0aCcpXG4gICAgICAgIC50ZXh0KGZ1bmN0aW9uIChjb2x1bW4pIHsgcmV0dXJuIGNvbHVtbjsgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBjcmVhdGUgYSByb3cgZm9yIGVhY2ggb2JqZWN0IGluIHRoZSBkYXRhXG4gICAgICAgIHZhciByb3dzID0gdGJvZHkuc2VsZWN0QWxsKCd0cicpXG4gICAgICAgIC5kYXRhKGRhdGEpXG4gICAgICAgIC5lbnRlcigpXG4gICAgICAgIC5hcHBlbmQoJ3RyJyk7XG4gICAgICAgIFxuICAgICAgICAvLyBjcmVhdGUgYSBjZWxsIGluIGVhY2ggcm93IGZvciBlYWNoIGNvbHVtblxuICAgICAgICB2YXIgY2VsbHMgPSByb3dzLnNlbGVjdEFsbCgndGQnKVxuICAgICAgICAuZGF0YShmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgICAgIHJldHVybiBjb2x1bW5zLm1hcChmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge2NvbHVtbjogY29sdW1uLCB2YWx1ZTogcm93W2NvbHVtbl19O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgIC5lbnRlcigpXG4gICAgICAgIC5hcHBlbmQoJ3RkJylcbiAgICAgICAgLnRleHQoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQudmFsdWU7IH0pO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRhYmxlO1xuICAgIH1cbiAgICBcbiAgICBsZXQgbXlkYXRhID0gW107XG4gICAgZm9yKGxldCBpID0gMDsgaTxmZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBteWRhdGEucHVzaCh7XCJWYXJpYWJsZXNcIjpmZWF0dXJlc1tpXSxcIkZyb21cIjoxLCBcIlRvXCI6M30pO1xuICAgIH1cblxuICAgIC8vIHJlbmRlciB0aGUgdGFibGUocylcbiAgICB0YWJ1bGF0ZShteWRhdGEsIFsnVmFyaWFibGVzJywgJ0Zyb20nLCAnVG8nXSk7IC8vIDIgY29sdW1uIHRhYmxlXG59XG5cbi8vIEQzTSBBUEkgSEVMUEVSU1xuLy8gYmVjYXVzZSB0aGVzZSBnZXQgYnVpbHQgaW4gdmFyaW91cyBwbGFjZXMsIHB1bGxpbmcgdGhlbSBvdXQgZm9yIGVhc3kgbWFuaXB1bGF0aW9uXG5mdW5jdGlvbiBhcGlGZWF0dXJlICh2YXJzLCB1cmkpIHtcbiAgICBsZXQgb3V0ID0gW11cbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgdmFycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBvdXQucHVzaCh7ZmVhdHVyZUlkOnZhcnNbaV0sZGF0YVVyaTp1cml9KTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLy8gc2lsbHkgYnV0IHBlcmhhcHMgdXNlZnVsIGlmIGluIHRoZSBmdXR1cmUgU2Vzc2lvbkNvbnRleHQgcmVxdWlyZXMgbW9yZSB0aGluZ3MgKGFzIHN1Z2dlc3QgYnkgY29yZSlcbmZ1bmN0aW9uIGFwaVNlc3Npb24gKGNvbnRleHQpIHtcbiAgICByZXR1cm4ge1wic2Vzc2lvbl9pZFwiOmNvbnRleHR9O1xufVxuXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9hc3NldHMvYXBwL2FwcC5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1\n')},function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();\n\nexports.density = density;\nexports.bars = bars;\nexports.barsSubset = barsSubset;\nexports.densityNode = densityNode;\nexports.barsNode = barsNode;\nvar d3Color = \'#1f77b4\'; // d3\'s default blue\nvar selVarColor = exports.selVarColor = \'#fa8072\'; // d3.rgb("salmon");\n\n// function to use d3 to graph density plots with preprocessed data\nfunction density(node, div, priv) {\n    div = { subset: \'#tab2\', setxLeft: \'#setxLeft\', varSummary: \'#tab3\' }[div];\n    if (!div) return alert("Error: incorrect div selected for plots");\n\n    var _ref = [node.plotx, node.ploty],\n        xVals = _ref[0],\n        yVals = _ref[1];\n\n    if (priv && node.plotCI) {\n        var _map = [\'upperBound\', \'lowerBound\'].map(function (bound) {\n            return xVals.map(function (x, i) {\n                return { x: +x, y: +node.plotCI[bound][i] };\n            });\n        }),\n            _map2 = _slicedToArray(_map, 2),\n            _upperError = _map2[0],\n            _lowerError = _map2[1];\n\n        console.log(\'upperError\\n\', _upperError);\n    }\n\n    var tempWidth = d3.select(div).style("width");\n    var width = tempWidth.substring(0, tempWidth.length - 2);\n\n    var tw = document.getElementById(\'main\').offsetWidth;\n\n    var tempHeight = d3.select(div).style("height");\n    var height = tempHeight.substring(0, tempHeight.length - 2);\n    var margin = {\n        top: 20,\n        right: 20,\n        bottom: 53,\n        left: 10\n    };\n\n    // Need to fix automatic width and height settings for leftpanel (#tab2, #tab3)\n    if (div == "#tab3") {\n        width = 0.7 * (width - margin.left - margin.right), height = 0.3 * (height - margin.top - margin.bottom);\n    } else if (div == "#tab2") {\n        width = 200;\n        height = 120;\n    } else if (div == "#setxLeft") {\n        width = tw * .185 - margin.left - margin.right; //rightpanel.expand is 40 percent, setxLeft to 50 percent, toggle bar is 16px, padding, it\'s all about .185\n        height = width * .6; //height to width is .6\n    } else {\n        width = 0.35 * (width - margin.left - margin.right), height = 0.25 * (height - margin.top - margin.bottom);\n    };\n\n    var x = d3.scale.linear().domain([d3.min(xVals), d3.max(xVals)]).range([0, width]);\n    var invx = d3.scale.linear().range([d3.min(xVals), d3.max(xVals)]).domain([0, width]);\n    var y = d3.scale.linear().domain([d3.min(yVals), d3.max(yVals)]).range([height, 0]);\n    var xAxis = d3.svg.axis().scale(x).ticks(5).orient("bottom");\n    var yAxis = d3.svg.axis().scale(y).orient("left");\n    var brush = d3.svg.brush().x(x).extent(node.subsetrange).on("brush", brushed);\n    var brush2 = d3.svg.brush().x(x).on("brush", brushed2);\n    var area = d3.svg.area().interpolate("monotone").x(function (d) {\n        return x(d.x);\n    }).y0(height).y1(function (d) {\n        return y(d.y);\n    });\n    var line = d3.svg.line().x(function (d) {\n        return x(d.x);\n    }).y(function (d) {\n        return y(d.y);\n    }).interpolate("monotone");\n\n    // cumbersome to treat "tab3" differently, but works for now\n    // tab3, has an issue, that unless width height hardcoded, they grow with each additional graph.\n    if (div == "#tab3") {\n        var plotsvg = d3.select(div).selectAll("svg").remove();\n        plotsvg = d3.select(div).append("svg").attr("id", function () {\n            return node.name.toString().concat(div.substr(1));\n        }).style("width", 300) // set height to the height of #main.left\n        .style("height", 200).append("g").attr("transform", \'translate(\' + margin.left + \',\' + margin.top + \')\');\n    } else {\n        var plotsvg = d3.select(div).append("svg").attr("id", function () {\n            return node.name.toString().replace(/\\(|\\)/g, "").concat("_", div.substr(1), "_", node.id);\n        }).style("width", width + margin.left + margin.right) //setting height to the height of #main.left\n        .style("height", height + margin.top + margin.bottom).append("g").attr("transform", \'translate(\' + margin.left + \',\' + margin.top + \')\');\n    };\n    plotsvg.append("path").datum(xVals.map(function (x, i) {\n        return { x: +x, y: +node.ploty[i] };\n    })).attr("class", "area").attr("d", area);\n\n    //add upper bound\n    priv && node.plotCI && plotsvg.append("path").attr("class", "upperError").datum(upperError).attr("d", area);\n\n    //add lower bound\n    priv && node.plotCI && plotsvg.append("path").attr("class", "lowerError").datum(lowerError).attr("d", area);\n\n    plotsvg.append("g").attr("class", "x axis").attr("transform", "translate(0," + height + ")").call(xAxis);\n\n    plotsvg.append("text").attr("x", width / 2).attr("y", 0 - margin.top / 2).attr("text-anchor", "middle").style("font-size", "12px").text(node.name);\n\n    // add brush if subset\n    if (div == "#tab2") {\n        plotsvg.append("text").attr("id", "range").attr("x", 25).attr("y", height + 40).text(function () {\n            return "Range: ".concat(d3.min(xVals).toPrecision(4), " to ", d3.max(xVals).toPrecision(4));\n        });\n        plotsvg.append("g").attr("class", "x brush").call(brush).selectAll("rect").attr("height", height);\n    }\n\n    // add z lines and sliders setx\n    if (div == "#setxLeft") {\n        plotsvg.append("text").attr("id", "range").attr("x", 25).attr("y", height + 40).text(function () {\n            return "x: ".concat((+node.mean).toPrecision(4));\n        });\n\n        plotsvg.append("text").attr("id", "range2").attr("x", 25).attr("y", height + 50).text(function () {\n            return "x1: ".concat((+node.mean).toPrecision(4));\n        });\n\n        // create tick marks at all zscores in the bounds of the data\n        var lineFunction = d3.svg.line().x(function (d) {\n            return d.x;\n        }).y(function (d) {\n            return d.y;\n        }).interpolate("linear");\n\n        var colSeq = ["#A2CD5A", "orange", "red"]; // will cycle through color sequence, and then repeat last color\n        var lineData = new Array();\n\n        var zLower = -1 * (d3.min(xVals) - node.mean) / node.sd; // zscore of lower bound\n        var zUpper = (d3.max(xVals) - node.mean) / node.sd; // zscore of upper bound\n\n        for (var i = 0; i < zUpper; i++) {\n            lineData = [{\n                "x": x(+node.mean + i * node.sd),\n                "y": height * .7\n            }, {\n                "x": x(+node.mean + i * node.sd),\n                "y": height * .9\n            }];\n            plotsvg.append("path").attr("d", lineFunction([lineData[0], lineData[1]])).attr("stroke", colSeq[d3.min([i, colSeq.length - 1])]).attr("stroke-width", 1.5).attr("fill", "none");\n        }\n\n        for (var i = 1; i < zLower; i++) {\n            lineData = [{\n                "x": x(+node.mean - i * node.sd),\n                "y": height * .7\n            }, {\n                "x": x(+node.mean - i * node.sd),\n                "y": height * .9\n            }];\n            plotsvg.append("path").attr("d", lineFunction([lineData[0], lineData[1]])).attr("stroke", colSeq[d3.min([i, colSeq.length - 1])]).attr("stroke-width", 1.5).attr("fill", "none");\n        }\n\n        // initialize slider components\n        var slideBox = plotsvg.append("g").attr("class", "x axis").attr("transform", "translate(0," + height * .8 + ")").call(d3.svg.axis().scale(x).ticks(0).orient("bottom"));\n        var slider = plotsvg.append("g").attr("class", "slider").call(brush);\n        var handle = slider.append("polygon").attr("class", "handle").attr("transform", "translate(0," + height * .7 + ")").attr("points", function (_) {\n            var s = 6;\n            var xnm = node.setxvals[0] == \'\' ? x(node.mean) : x(node.setxvals[0]);\n            return xnm - s + "," + -s + " " + (xnm + s) + "," + -s + " " + xnm + "," + s * 1.3;\n        });\n        var slider2 = plotsvg.append("g").attr("class", "slider").call(brush2);\n        var handle2 = slider2.append("polygon").attr("class", "handle").attr("transform", "translate(0," + height * .9 + ")").attr("points", function (_) {\n            var s = 6;\n            var xnm = node.setxvals[1] == \'\' ? x(node.mean) : x(node.setxvals[1]);\n            return xnm - s + "," + s + " " + (xnm + s) + "," + s + " " + xnm + "," + -s * 1.3;\n        });\n    }\n\n    // brushing functions\n    function brushed() {\n        if (div == "#tab2") {\n            plotsvg.select("text#range").text(function () {\n                return brush.empty() ? "Range: ".concat(d3.min(xVals).toPrecision(4), " to ", d3.max(xVals).toPrecision(4)) : "Range: ".concat(brush.extent()[0].toPrecision(4), " to ", brush.extent()[1].toPrecision(4));\n            });\n            node.subsetrange = brush.extent()[0].toPrecision(4) != brush.extent()[1].toPrecision(4) ? [brush.extent()[0].toPrecision(4), brush.extent()[1].toPrecision(4)] : ["", ""];\n        } else if (div == "#setxLeft") {\n            var value = brush.extent()[0];\n            var s = 6;\n            if (d3.event.sourceEvent) {\n                value = x.invert(d3.mouse(this)[0]);\n                brush.extent([value, value]);\n            }\n\n            // set x position of slider center\n            var xpos = x(value);\n            if (value > d3.max(xVals)) {\n                // dragged past max\n                xpos = x(d3.max(xVals));\n            } else if (value < d3.min(xVals)) {\n                // dragged past min\n                xpos = x(d3.min(xVals));\n            } else {\n                var m = +node.mean;\n                var sd = +node.sd;\n                var zScore = (value - m) / sd; // z-score\n                var zRound = Math.round(zScore); // nearest integer z-score\n                if (.1 > Math.abs(zRound - zScore)) // snap to integer z-score\n                    xpos = x(m + zRound * sd);\n            }\n\n            // create slider symbol and text\n            handle.attr("points", function (_) {\n                return xpos - s + "," + -s + " " + (xpos + s) + "," + -s + " " + xpos + "," + s * 1.3;\n            });\n            plotsvg.select("text#range").text(function () {\n                return "x: ".concat(invx(xpos).toPrecision(4));\n            });\n            node.setxvals[0] = invx(xpos).toPrecision(4);\n        }\n    }\n\n    // certainly a more clever way to do this, but for now it\'s basically copied with brush and handle changes to brush2 and handle2 and #range to #range2 and setxvals[0] to setxvals[1]\n    function brushed2() {\n        var value = brush2.extent()[0];\n        var s = 6; // scaling for triangle shape\n\n        if (d3.event.sourceEvent) {\n            value = x.invert(d3.mouse(this)[0]);\n            brush2.extent([value, value]);\n        }\n\n        // set x position of slider center\n        var xpos = x(value);\n        if (value > d3.max(xVals)) {\n            // dragged past max\n            xpos = x(d3.max(xVals));\n        } else if (value < d3.min(xVals)) {\n            // dragged past min\n            xpos = x(d3.min(xVals));\n        } else {\n            var m = +node.mean;\n            var sd = +node.sd;\n            var zScore = (value - m) / sd; // z-score\n            var zRound = Math.round(zScore); // nearest integer z-score\n            if (.1 > Math.abs(zRound - zScore)) // snap to integer z-score\n                xpos = x(m + zRound * sd);\n        }\n\n        // create slider symbol and text\n        handle2.attr("points", function (_) {\n            return xpos - s + "," + s + " " + (xpos + s) + "," + s + " " + xpos + "," + -s * 1.3;\n        });\n        plotsvg.select("text#range2").text(function () {\n            return "x1: ".concat(invx(xpos).toPrecision(4));\n        });\n        node.setxvals[1] = invx(xpos).toPrecision(4);\n    }\n}\n\nfunction bars(node, div, priv) {\n    // Histogram spacing\n    var barPadding = .015; // Space between bars\n    var topScale = 1.2; // Multiplicative factor to assign space at top within graph - currently removed from implementation\n    var plotXaxis = true;\n\n    // Data\n    var keys = Object.keys(node.plotvalues);\n    var yVals = new Array();\n    var ciUpperVals = new Array();\n    var ciLowerVals = new Array();\n    var ciSize;\n\n    var xVals = new Array();\n    var yValKey = new Array();\n\n    if (node.nature == "nominal") {\n        var xi = 0;\n        for (var i = 0; i < keys.length; i++) {\n            if (node.plotvalues[keys[i]] == 0) continue;\n            yVals[xi] = node.plotvalues[keys[i]];\n            xVals[xi] = xi;\n            if (priv) {\n                if (node.plotvaluesCI) {\n                    ciLowerVals[xi] = node.plotValuesCI.lowerBound[keys[i]];\n                    ciUpperVals[xi] = node.plotValuesCI.upperBound[keys[i]];\n                }\n                ciSize = ciUpperVals[xi] - ciLowerVals[xi];\n            };\n\n            yValKey.push({\n                y: yVals[xi],\n                x: keys[i]\n            });\n            xi = xi + 1;\n        }\n        yValKey.sort(function (a, b) {\n            return b.y - a.y;\n        }); // array of objects, each object has y, the same as yVals, and x, the category\n        yVals.sort(function (a, b) {\n            return b - a;\n        }); // array of y values, the height of the bars\n        ciUpperVals.sort(function (a, b) {\n            return b.y - a.y;\n        }); // ?\n        ciLowerVals.sort(function (a, b) {\n            return b.y - a.y;\n        }); // ?\n    } else {\n        for (var i = 0; i < keys.length; i++) {\n            console.log("plotvalues in bars");\n            yVals[i] = node.plotvalues[keys[i]];\n            xVals[i] = Number(keys[i]);\n            if (priv) {\n                if (node.plotvaluesCI) {\n                    ciLowerVals[i] = node.plotvaluesCI.lowerBound[keys[i]];\n                    ciUpperVals[i] = node.plotvaluesCI.upperBound[keys[i]];\n                }\n                ciSize = ciUpperVals[i] - ciLowerVals[i];\n            }\n        }\n    }\n\n    if (yVals.length > 15 & node.numchar == "numeric" || yVals.length > 5 & node.numchar == "character") plotXaxis = false;\n    var maxY = d3.max(yVals); // in the future, set maxY to the value of the maximum confidence limit\n    if (priv && node.plotvaluesCI) maxY = d3.max(ciUpperVals);\n    var minX = d3.min(xVals);\n    var maxX = d3.max(xVals);\n\n    var mydiv = void 0;\n    if (div == "setxLeft") mydiv = "#setxLeft";else if (div == "varSummary") mydiv = "#tab3";else return alert("Error: incorrect div selected for plots");\n\n    var tempWidth = d3.select(mydiv).style("width");\n    var width = tempWidth.substring(0, tempWidth.length - 2);\n    var tempHeight = d3.select(mydiv).style("height");\n    var height = tempHeight.substring(0, tempHeight.length - 2);\n\n    var margin = {\n        top: 20,\n        right: 20,\n        bottom: 53,\n        left: 10\n    };\n    var tw = document.getElementById(\'main\').offsetWidth;\n\n    // Need to fix automatic width and height settings for leftpanel (#tab2, #tab3)\n    if (mydiv == "#tab3") {\n        width = 0.7 * (width - margin.left - margin.right);\n        height = 0.3 * (height - margin.top - margin.bottom);\n    } else if (mydiv == "#setxLeft") {\n        //width = 200;\n        //height = 120;\n        width = tw * .185 - margin.left - margin.right; //rightpanel.expand is 40 percent, setxLeft to 50 percent, toggle bar is 16px, padding, it\'s all about .185\n        height = width * .6; //height to width is .6\n    } else {\n        width = 0.35 * (width - margin.left - margin.right);\n        height = 0.25 * (height - margin.top - margin.bottom);\n    };\n\n    if (priv && node.stabilityBin) {\n        var x = d3.scale.linear().domain([minX - 0.5, maxX + 1.5]).range([0, width]);\n    } else {\n        var x = d3.scale.linear().domain([minX - 0.5, maxX + 0.5]).range([0, width]);\n    }\n\n    var invx = d3.scale.linear().range([minX - 0.5, maxX + 0.5]).domain([0, width]);\n\n    var y = d3.scale.linear().domain([0, maxY]).range([0, height]);\n\n    var xAxis = d3.svg.axis().scale(x).ticks(yVals.length).orient("bottom");\n\n    var yAxis = d3.svg.axis().scale(y).orient("left");\n\n    var brush = d3.svg.brush().x(x).extent(function () {\n        return node.subsetrange.length == 1 ? [node.subsetrange[0], node.subsetrange[0]] : node.subsetrange;\n    }).on("brush", brushed);\n\n    var brush2 = d3.svg.brush().x(x).on("brush", brushed2);\n\n    // Create SVG element\n    // cumbersome to treat "tab3" differently, but works for now\n    // tab3, has an issue, that unless width height hardcoded, they grow with each additional graph.\n    if (mydiv == "#tab3") {\n        var plotsvg = d3.select(mydiv).selectAll("svg").remove();\n\n        var plotsvg = d3.select(mydiv).append("svg").attr("id", function () {\n            return node.name.toString().concat(mydiv.substr(1));\n        }).style("width", 300) //setting height to the height of #main.left\n        .style("height", 200).append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");\n    } else {\n        var plotsvg = d3.select(mydiv).append("svg").attr("id", function () {\n            var myname = node.name.toString();\n            myname = myname.replace(/\\(|\\)/g, "");\n            return myname.concat("_", mydiv.substr(1), "_", node.id);\n        }).style("width", width + margin.left + margin.right) //setting height to the height of #main.left\n        .style("height", height + margin.top + margin.bottom).append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");\n    };\n\n    var rectWidth = x(minX + 0.5 - 2 * barPadding); //the "width" is the coordinate of the end of the first bar\n\n    plotsvg.selectAll("rect").data(yVals).enter().append("rect").attr("x", function (d, i) {\n        return x(xVals[i] - 0.5 + barPadding);\n    }).attr("y", function (d) {\n        return y(maxY - d);\n    }).attr("width", rectWidth).attr("height", y).attr("fill", "#1f77b4");\n\n    // draw error bars, threshold line and extra bin\n    if (priv) {\n        if (yVals.length <= 20) {\n            plotsvg.selectAll("line").data(ciUpperVals).enter().append("line").style("stroke", "black").attr("x1", function (d, i) {\n                return x(xVals[i] - 0.5 + barPadding) + rectWidth / 2;\n            }).attr("y1", function (d) {\n                return y(maxY - d);\n            }).attr("x2", function (d, i) {\n                return x(xVals[i] - 0.5 + barPadding) + rectWidth / 2;\n            }).attr("y2", function (d) {\n                var y2 = y(maxY - d + ciSize);\n                return y2 >= y(maxY) ? y(maxY) : y2;\n            });\n\n            //draw top ticks on error bars\n            //need to fix the height of the graphs - the tops of error bars are getting cut off\n            plotsvg.selectAll(".topTick").data(ciUpperVals).enter().append("line").attr("class", "topTick").style("stroke", "black").attr("x1", function (d, i) {\n                if (yVals.length > 20) {\n                    return x(xVals[i] - 0.5 + barPadding); //make tick bigger to increase visibility\n                } else {\n                    return x(xVals[i] - 0.5 + barPadding) + 0.4 * rectWidth;\n                }\n            }).attr("y1", function (d) {\n                return y(maxY - d);\n            }).attr("x2", function (d, i) {\n                if (yVals.length > 20) {\n                    return x(xVals[i] - 0.5 + barPadding) + rectWidth; //make tick bigger to increase visibility\n                } else {\n                    return x(xVals[i] - 0.5 + barPadding) + 0.6 * rectWidth;\n                }\n            }).attr("y2", function (d) {\n                return y(maxY - d);\n            });\n\n            // draw bottom ticks of error bars\n            plotsvg.selectAll(".bottomTick").data(ciLowerVals).enter().append("line").attr("class", "bottomTick").style("stroke", "black").attr("x1", function (d, i) {\n                if (yVals.length > 20) {\n                    return x(xVals[i] - 0.5 + barPadding);\n                } else {\n                    return x(xVals[i] - 0.5 + barPadding) + 0.4 * rectWidth;\n                }\n            }).attr("y1", function (d) {\n                return y(maxY - d);\n            }).attr("x2", function (d, i) {\n                if (yVals.length > 20) {\n                    return x(xVals[i] - 0.5 + barPadding) + rectWidth;\n                } else {\n                    return x(xVals[i] - 0.5 + barPadding) + 0.6 * rectWidth;\n                }\n            }).attr("y2", function (d) {\n                return y(maxY - d);\n            });\n        } else {\n            plotsvg.selectAll(".denseError").data(yVals).enter().append("rect").attr("class", "denseError").attr("x", function (d, i) {\n                return x(xVals[i] - 0.5 + barPadding);\n            }).attr("y", function (d) {\n                return y(maxY - d) - .1 * y(d);\n            }).attr("width", rectWidth).attr("height", function (d) {\n                return y(maxY - d) + .1 * y(d) - (y(maxY - d) - .1 * y(d));\n            }).attr("fill", "silver");\n        }\n\n        //if statement for stability histograms\n        //extra stability bin\n        if (node.stabilityBin) {\n            plotsvg.append("rect").attr("x", x(maxX + 0.5 - barPadding)).attr("y", y(maxY) - node.stabilityBin).attr("width", rectWidth).attr("height", node.stabilityBin).attr("fill", "silver");\n        }\n\n        //threshold line\n        if (node.threshold) {\n            plotsvg.append("line").style("stroke", "black").attr("x1", x(minX - 0.5 + barPadding)).attr("y1", y(maxY) - node.threshold).attr("x2", function () {\n                console.log("stabilityBin");\n                console.log(node.stabilityBin);\n                if (node.stabilityBin) {\n                    return x(maxX + 0.5 - barPadding) + rectWidth;\n                } else {\n                    return x(maxX + 0.5 - barPadding);\n                }\n            }).attr("y2", y(maxY) - node.threshold);\n        }\n    }\n\n    if (plotXaxis) {\n        plotsvg.append("g").attr("class", "x axis").attr("transform", "translate(0," + height + ")").call(xAxis);\n    }\n\n    plotsvg.append("text").attr("x", width / 2).attr("y", 0 - margin.top / 2).attr("text-anchor", "middle").style("font-size", "12px").text(node.name);\n\n    if (mydiv == "#setxLeft") {\n        plotsvg.append("text").attr("id", "range").attr("x", 25).attr("y", height + 40).text(function () {\n            if (node.nature === "nominal") {\n                var t = Math.round(yValKey.length / 2) - 1;\n                return "x: " + yValKey[t].x;\n            } else {\n                return "x: ".concat((+node.mean).toPrecision(4).toString());\n            }\n        });\n\n        plotsvg.append("text").attr("id", "range2").attr("x", 25).attr("y", height + 50).text(function () {\n            if (node.nature === "nominal") {\n                var t = Math.round(yValKey.length / 2) - 1;\n                return "x1: " + yValKey[t].x;\n            } else {\n                return "x1: ".concat((+node.mean).toPrecision(4).toString());\n            }\n        });\n\n        // create tick marks at all zscores in the bounds of the data\n        var lineFunction = d3.svg.line().x(function (d) {\n            return d.x;\n        }).y(function (d) {\n            return d.y;\n        }).interpolate("linear");\n\n        var colSeq = ["#A2CD5A", "orange", "red"]; // will cycle through color sequence, and then repeat last color\n        var lineData = new Array();\n\n        var zLower = -1 * (minX - node.mean) / node.sd; // zscore of lower bound\n        var zUpper = (maxX - node.mean) / node.sd; // zscore of upper bound\n\n        for (var i = 0; i < zUpper; i++) {\n            lineData = [{\n                "x": x(+node.mean + i * node.sd),\n                "y": height * .7\n            }, {\n                "x": x(+node.mean + i * node.sd),\n                "y": height * .9\n            }];\n            plotsvg.append("path").attr("d", lineFunction([lineData[0], lineData[1]])).attr("stroke", colSeq[d3.min([i, colSeq.length - 1])]).attr("stroke-width", 1.5).attr("fill", "none");\n        }\n\n        for (var i = 1; i < zLower; i++) {\n            lineData = [{\n                "x": x(+node.mean - i * node.sd),\n                "y": height * .7\n            }, {\n                "x": x(+node.mean - i * node.sd),\n                "y": height * .9\n            }];\n            plotsvg.append("path").attr("d", lineFunction([lineData[0], lineData[1]])).attr("stroke", colSeq[d3.min([i, colSeq.length - 1])]).attr("stroke-width", 1.5).attr("fill", "none");\n        }\n\n        for (var i = d3.min(xVals); i <= d3.max(xVals); i++) {\n            lineData = [{\n                "x": x(i),\n                "y": height * .75\n            }, {\n                "x": x(i),\n                "y": height * .85\n            }];\n            plotsvg.append("path").attr("d", lineFunction([lineData[0], lineData[1]])).attr("stroke", "black").attr("stroke-width", 1).attr("fill", "none");\n        }\n\n        // initialize slider components\n        var slideBox = plotsvg.append("g").attr("class", "x axis").attr("transform", "translate(0," + height * .8 + ")").call(d3.svg.axis().scale(x).ticks(0).orient("bottom"));\n\n        var slider = plotsvg.append("g").attr("class", "slider").call(brush);\n        var slider2 = plotsvg.append("g").attr("class", "slider").call(brush2);\n\n        var points = function points(i) {\n            return function (d) {\n                var xnm = void 0,\n                    s = 6;\n                if (node.setxvals[i] == \'\') {\n                    // if nominal, use the median frequency as the position for the setx slider\n                    xnm = node.nature == \'nominal\' ? x(Math.round(xVals.length / 2) - 1) : x(node.mean);\n                } else {\n                    xnm = x(node.setxvals[i]);\n                };\n                return xnm - s + \',\' + -s + \' \' + (xnm + s) + \',\' + -s + \' \' + xnm + \',\' + s * 1.3;\n            };\n        };\n        var handle = slider.append("polygon").attr("class", "handle").attr("transform", "translate(0," + height * .7 + ")").attr("points", points(0));\n        var handle2 = slider2.append("polygon").attr("class", "handle").attr("transform", "translate(0," + height * .9 + ")").attr("points", points(1));\n    }\n\n    function twoSF(x) {\n        var tsf = d3.format(".2r"); // format to two significant figures after the decimal place\n        return tsf(x).replace(/0+$/, "").replace(/\\.$/, ""); // trim trailing zeros after a period, and any orphaned period\n    }\n\n    // brushing functions\n    function brushed() {\n        var value = brush.extent()[0];\n        var s = 6;\n\n        if (d3.event.sourceEvent) {\n            value = x.invert(d3.mouse(this)[0]);\n            brush.extent([value, value]);\n        }\n\n        // set x position of slider center\n        var xpos = x(value);\n        if (value > maxX) {\n            // dragged past max\n            xpos = x(maxX);\n        } else if (value < minX) {\n            // dragged past min\n            xpos = x(minX);\n        } else {\n            var m = +node.mean;\n            var sd = +node.sd;\n            var zScore = (value - m) / sd; // z-score\n            var zRound = Math.round(zScore); // nearest integer z-score\n            if (.1 > Math.abs(Math.round(value) - value)) {\n                // snap to integer\n                xpos = x(Math.round(value));\n            } else if (.1 > Math.abs(zRound - zScore)) {\n                // snap to integer z-score\n                xpos = x(m + zRound * sd);\n            }\n        }\n\n        // create slider symbol and text\n        handle.attr("points", function (d) {\n            return xpos - s + "," + -s + " " + (xpos + s) + "," + -s + " " + xpos + "," + s * 1.3;\n        });\n        plotsvg.select("text#range").text(function () {\n            if (node.nature === "nominal") {\n                return "x: " + yValKey[Math.round(invx(xpos))].x;\n            } else {\n                return "x: ".concat(+invx(xpos).toPrecision(4).toString());\n            }\n        });\n        node.setxvals[0] = +invx(xpos).toPrecision(4);\n    }\n\n    // certainly a more clever way to do this, but for now it\'s basically copied with brush and handle changes to brush2 and handle2 and #range to #range2 and setxvals[0] to setxvals[1]\n    function brushed2() {\n        var value = brush2.extent()[0];\n        var s = 6; // scaling for triangle shape\n\n        if (d3.event.sourceEvent) {\n            value = x.invert(d3.mouse(this)[0]);\n            brush2.extent([value, value]);\n        }\n\n        // set x position of slider center\n        var xpos = x(value);\n        if (value > maxX) {\n            // dragged past max\n            xpos = x(maxX);\n        } else if (value < minX) {\n            // dragged past min\n            xpos = x(minX);\n        } else {\n            var m = +node.mean;\n            var sd = +node.sd;\n            var zScore = (value - m) / sd; // z-score\n            var zRound = Math.round(zScore); // nearest integer z-score\n            if (.1 > Math.abs(Math.round(value) - value)) {\n                // snap to integer\n                xpos = x(Math.round(value));\n            } else if (.1 > Math.abs(zRound - zScore)) {\n                // snap to integer z-score\n                xpos = x(m + zRound * sd);\n            }\n        }\n\n        // create slider symbol and text\n        handle2.attr("points", function (d) {\n            return xpos - s + "," + s + " " + (xpos + s) + "," + s + " " + xpos + "," + -s * 1.3;\n        });\n        plotsvg.select("text#range2").text(function () {\n            if (node.nature === "nominal") {\n                return "x1: " + yValKey[Math.round(invx(xpos))].x;\n            } else {\n                return "x1: ".concat(+invx(xpos).toPrecision(4).toString());\n            }\n        });\n        node.setxvals[1] = +invx(xpos).toPrecision(4);\n    }\n}\n\n// draws barplots in subset tab\nfunction barsSubset(node) {\n    // if untouched, set node.subsetrange to an empty array, meaning all values selected by default\n    if (node.subsetrange[0] == "" & node.subsetrange[1] == "") {\n        node.subsetrange = [];\n    }\n\n    // Histogram spacing\n    var barPadding = .015; // Space between bars\n    var topScale = 1.2; // Multiplicative factor to assign space at top within graph - currently removed from implementation\n    var plotXaxis = true;\n\n    // Variable name\n    var myname = node.name.toString();\n    myname = myname.replace(/\\(|\\)/g, "");\n\n    // Data\n    var keys = Object.keys(node.plotvalues);\n    var yVals = new Array();\n    var xVals = new Array();\n    var yValKey = new Array();\n\n    var xi = 0;\n    for (var i = 0; i < keys.length; i++) {\n        if (node.plotvalues[keys[i]] == 0) continue;\n        yVals[xi] = node.plotvalues[keys[i]];\n        xVals[xi] = xi;\n        yValKey.push({\n            y: yVals[xi],\n            x: keys[i]\n        });\n        xi = xi + 1;\n    }\n    if (node.nature === "nominal") {\n        // if nominal, orders bars left to right, highest frequency to lowest\n        yValKey.sort(function (a, b) {\n            return b.y - a.y;\n        }); // array of objects, each object has y, the same as yVals, and x, the category\n        yVals.sort(function (a, b) {\n            return b - a;\n        }); // array of y values, the height of the bars\n    }\n\n    plotXaxis = false;\n\n    var maxY = d3.max(yVals);\n    var minX = d3.min(xVals);\n    var maxX = d3.max(xVals);\n    var gname = ["subsetyes", "subsetno"];\n\n    var yVals2 = [];\n    var yVals1 = [];\n    for (i = 0; i < yVals.length; i++) {\n        yVals1.push({\n            y0: maxY - yVals[i],\n            y1: yVals[i],\n            col: d3Color\n        });\n        yVals2.push({\n            y0: 0,\n            y1: maxY - yVals[i],\n            col: "transparent"\n        });\n    }\n    var freqs = [yVals1, yVals2];\n\n    // y0 is the starting point\n    // y1 is the length of the bar\n\n    var mydiv = "#tab2";\n    var width = 200;\n    var height = 120;\n    var margin = {\n        top: 20,\n        right: 20,\n        bottom: 53,\n        left: 50\n    };\n\n    var x = d3.scale.linear().domain([minX - 0.5, maxX + 0.5]).range([0, width]);\n\n    var invx = d3.scale.linear().range([minX - 0.5, maxX + 0.5]).domain([0, width]);\n\n    var y = d3.scale.linear().domain([0, maxY]).range([0, height]);\n\n    var xAxis = d3.svg.axis().scale(x).ticks(yVals.length).orient("bottom");\n\n    var yAxis = d3.svg.axis().scale(y).orient("left");\n\n    //Create SVG element\n    var plotsvg = d3.select(mydiv).append("svg").attr("id", function () {\n        return myname.concat("_", mydiv.substr(1), "_", node.id);\n    }).style("width", width + margin.left + margin.right) //setting height to the height of #main.left\n    .style("height", height + margin.top + margin.bottom).append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");\n\n    var freq = plotsvg.selectAll("g.freq").data(freqs).enter().append("g").attr("class", "freq").attr("name", function (d, i) {\n        return myname.concat(gname[i]);\n    });\n\n    var rect = freq.selectAll("rect").data(Object).enter().append("rect").attr("class", "bar").attr("name", function (d, i) {\n        return xVals[i];\n    }).attr("x", function (d, i) {\n        return x(xVals[i] - 0.5 + barPadding);\n    }).attr("y", function (d) {\n        return y(d.y0);\n    }).attr("width", x(minX + 0.5 - 2 * barPadding)) // the "width" is the coordinate of the end of the first bar\n    .attr("height", function (d) {\n        return y(d.y1);\n    }).style("fill", function (d, i) {\n        if (node.subsetrange.length > 0 & d.col === d3Color & $.inArray(xVals[i].toString(), node.subsetrange) > -1) {\n            return selVarColor;\n        } else {\n            return d.col;\n        }\n    }).on("click", function () {\n        var selectMe = this;\n        var selectName = this.getAttribute("name");\n        if (this.parentNode.getAttribute("name") == myname.concat("subsetno")) {\n            selectMe = $(\'[name="\' + myname.concat("subsetyes") + \'"]\').children(\'[name="\' + selectName + \'"]\')[0];\n        }\n        d3.select(selectMe).style("fill", function (d, i) {\n            var myCol = "";\n            if (this.style.fill === selVarColor) {\n                var myindex = node.subsetrange.indexOf(this.getAttribute("name"));\n                node.subsetrange.splice(myindex, 1);\n                myCol = d3Color;\n            } else {\n                node.subsetrange.push(this.getAttribute("name"));\n                myCol = selVarColor;\n            }\n            return myCol;\n        });\n        plotsvg.select("text#selectrange").text(function () {\n            if (node.subsetrange.length == 0) {\n                return "Selected: all values";\n            } else {\n                var a = node.subsetrange;\n                var selecteds = new Array();\n                a.forEach(function (val) {\n                    selecteds.push(yValKey[val].x);\n                });\n                return "Selected: " + selecteds;\n            }\n        });\n    }).on("mouseover", function () {\n        var i = this.getAttribute("name");\n        plotsvg.select("text#mymouseover").text(function () {\n            return yValKey[i].x + ": " + yValKey[i].y;\n        });\n    }).on("mouseout", function () {\n        var i = this.getAttribute("name");\n        plotsvg.select("text#mymouseover").text(function () {\n            return "Value: Frequency";\n        });\n    });\n\n    if (plotXaxis) {\n        plotsvg.append("g").attr("class", "x axis").attr("transform", "translate(0," + height + ")").call(xAxis);\n    } else {\n        plotsvg.append("text").attr("id", "mymouseover").attr("x", 25).attr("y", height + 20).text(function () {\n            return "Value: Frequency";\n        });\n    }\n\n    plotsvg.append("text").attr("x", width / 2).attr("y", 0 - margin.top / 2).attr("text-anchor", "middle").style("font-size", "12px").text(myname);\n\n    plotsvg.append("text").attr("id", "selectrange").attr("x", 25).attr("y", height + 40).text(function () {\n        if (node.subsetrange.length == 0) return "Selected: all values";\n        var selecteds = new Array();\n        node.subsetrange.forEach(function (val) {\n            return selecteds.push(yValKey[val].x);\n        });\n        return "Selected: " + selecteds;\n    });\n}\n\nfunction densityNode(node, obj) {\n    var myname = node.name.toString().concat("nodeplot");\n\n    if (typeof obj === "undefined") {\n        var obj = document.getElementById(node.name.toString() + "biggroup");\n        // if obj contains an svg element, remove it. this removes any plot inside the node\n        if (d3.select(obj).selectAll("svg")[0].length > 0) d3.select(obj).selectAll("svg").remove();\n    }\n\n    var yVals = node.ploty;\n    var xVals = node.plotx;\n    // array of objects\n    var data2 = node.plotx.map(function (x, i) {\n        return { x: +x, y: +node.ploty[i] };\n    });\n\n    var width = 60; // hardcoded, should be set automatically\n    var height = 30;\n    var margin = {\n        top: 20,\n        right: 10,\n        bottom: 53,\n        left: 10\n    };\n\n    var x = d3.scale.linear().domain([d3.min(xVals), d3.max(xVals)]).range([0, width]);\n\n    var y = d3.scale.linear().domain([d3.min(yVals), d3.max(yVals)]).range([height, 0]);\n\n    var area = d3.svg.area().interpolate("monotone").x(function (d) {\n        return x(d.x);\n    }).y0(height).y1(function (d) {\n        return y(d.y);\n    });\n\n    var plotsvg = d3.select(obj).insert("svg", ":first-child").attr("x", -40) // NOTE: Not sure exactly why these numbers work, but these hardcoded values seem to position the plot inside g correctly.  this shouldn\'t be hardcoded in the future\n    .attr("y", -45).attr("id", function () {\n        return myname;\n    }).style("width", width).style("height", height).append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");\n\n    plotsvg.append("path").datum(data2).attr("class", "area").attr("d", area);\n}\n\nfunction barsNode(node, obj) {\n    var myname = node.name.toString().concat("nodeplot");\n\n    if (typeof obj === "undefined") {\n        var obj = document.getElementById(node.name.toString() + "biggroup");\n        // if obj contains an svg element, remove it. this removes any plot inside the node\n        if (d3.select(obj).selectAll("svg")[0].length > 0) {\n            d3.select(obj).selectAll("svg").remove();\n        }\n    }\n\n    // Histogram spacing\n    var barPadding = .015; // Space between bars\n    var topScale = 1.2; // Multiplicative factor to assign space at top within graph - currently removed from implementation\n\n    // Data\n    var keys = Object.keys(node.plotvalues);\n    var yVals = new Array();\n    var xVals = new Array();\n    var yValKey = new Array();\n\n    if (node.nature === "nominal") {\n        var xi = 0;\n        for (var i = 0; i < keys.length; i++) {\n            if (node.plotvalues[keys[i]] == 0) continue;\n            yVals[xi] = node.plotvalues[keys[i]];\n            xVals[xi] = xi;\n            yValKey.push({ y: yVals[xi], x: keys[i] });\n            xi = xi + 1;\n        }\n        yValKey.sort(function (a, b) {\n            return b.y - a.y;\n        }); // array of objects, each object has y, the same as yVals, and x, the category\n        yVals.sort(function (a, b) {\n            return b - a;\n        }); // array of y values, the height of the bars\n    } else {\n        for (var i = 0; i < keys.length; i++) {\n            yVals[i] = node.plotvalues[keys[i]];\n            xVals[i] = Number(keys[i]);\n        }\n    }\n\n    var maxY = d3.max(yVals);\n    var minX = d3.min(xVals);\n    var maxX = d3.max(xVals);\n\n    var width = 60;\n    var height = 30;\n    var margin = {\n        top: 20,\n        right: 10,\n        bottom: 53,\n        left: 10\n    };\n\n    var x = d3.scale.linear().domain([minX - 0.5, maxX + 0.5]).range([0, width]);\n\n    var invx = d3.scale.linear().range([minX - 0.5, maxX + 0.5]).domain([0, width]);\n\n    var y = d3.scale.linear().domain([0, maxY]).range([0, height]);\n\n    //Create SVG element\n    var plotsvg = d3.select(obj).insert("svg", ":first-child").attr("x", -40).attr("y", -45).attr("id", function () {\n        return myname;\n    }).style("width", width) // set height to the height of #main.left\n    .style("height", height).append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");\n\n    plotsvg.selectAll("rect").data(yVals).enter().append("rect").attr("x", function (d, i) {\n        return x(xVals[i] - 0.5 + barPadding);\n    }).attr("y", function (d) {\n        return y(maxY - d);\n    }).attr("width", x(minX + 0.5 - 2 * barPadding)) // the "width" is the coordinate of the end of the first bar\n    .attr("height", y).attr("fill", "#1f77b4");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvYXBwL3Bsb3RzLmpzP2JmMWYiXSwibmFtZXMiOlsiZGVuc2l0eSIsImJhcnMiLCJiYXJzU3Vic2V0IiwiZGVuc2l0eU5vZGUiLCJiYXJzTm9kZSIsImQzQ29sb3IiLCJzZWxWYXJDb2xvciIsIm5vZGUiLCJkaXYiLCJwcml2Iiwic3Vic2V0Iiwic2V0eExlZnQiLCJ2YXJTdW1tYXJ5IiwiYWxlcnQiLCJwbG90eCIsInBsb3R5IiwieFZhbHMiLCJ5VmFscyIsInBsb3RDSSIsIm1hcCIsIngiLCJpIiwieSIsImJvdW5kIiwidXBwZXJFcnJvciIsImxvd2VyRXJyb3IiLCJjb25zb2xlIiwibG9nIiwidGVtcFdpZHRoIiwiZDMiLCJzZWxlY3QiLCJzdHlsZSIsIndpZHRoIiwic3Vic3RyaW5nIiwibGVuZ3RoIiwidHciLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwib2Zmc2V0V2lkdGgiLCJ0ZW1wSGVpZ2h0IiwiaGVpZ2h0IiwibWFyZ2luIiwidG9wIiwicmlnaHQiLCJib3R0b20iLCJsZWZ0Iiwic2NhbGUiLCJsaW5lYXIiLCJkb21haW4iLCJtaW4iLCJtYXgiLCJyYW5nZSIsImludngiLCJ4QXhpcyIsInN2ZyIsImF4aXMiLCJ0aWNrcyIsIm9yaWVudCIsInlBeGlzIiwiYnJ1c2giLCJleHRlbnQiLCJzdWJzZXRyYW5nZSIsIm9uIiwiYnJ1c2hlZCIsImJydXNoMiIsImJydXNoZWQyIiwiYXJlYSIsImludGVycG9sYXRlIiwiZCIsInkwIiwieTEiLCJsaW5lIiwicGxvdHN2ZyIsInNlbGVjdEFsbCIsInJlbW92ZSIsImFwcGVuZCIsImF0dHIiLCJuYW1lIiwidG9TdHJpbmciLCJjb25jYXQiLCJzdWJzdHIiLCJyZXBsYWNlIiwiaWQiLCJkYXR1bSIsImNhbGwiLCJ0ZXh0IiwidG9QcmVjaXNpb24iLCJtZWFuIiwibGluZUZ1bmN0aW9uIiwiY29sU2VxIiwibGluZURhdGEiLCJBcnJheSIsInpMb3dlciIsInNkIiwielVwcGVyIiwic2xpZGVCb3giLCJzbGlkZXIiLCJoYW5kbGUiLCJzIiwieG5tIiwic2V0eHZhbHMiLCJzbGlkZXIyIiwiaGFuZGxlMiIsImVtcHR5IiwidmFsdWUiLCJldmVudCIsInNvdXJjZUV2ZW50IiwiaW52ZXJ0IiwibW91c2UiLCJ4cG9zIiwibSIsInpTY29yZSIsInpSb3VuZCIsIk1hdGgiLCJyb3VuZCIsImFicyIsImJhclBhZGRpbmciLCJ0b3BTY2FsZSIsInBsb3RYYXhpcyIsImtleXMiLCJPYmplY3QiLCJwbG90dmFsdWVzIiwiY2lVcHBlclZhbHMiLCJjaUxvd2VyVmFscyIsImNpU2l6ZSIsInlWYWxLZXkiLCJuYXR1cmUiLCJ4aSIsInBsb3R2YWx1ZXNDSSIsInBsb3RWYWx1ZXNDSSIsImxvd2VyQm91bmQiLCJ1cHBlckJvdW5kIiwicHVzaCIsInNvcnQiLCJhIiwiYiIsIk51bWJlciIsIm51bWNoYXIiLCJtYXhZIiwibWluWCIsIm1heFgiLCJteWRpdiIsInN0YWJpbGl0eUJpbiIsIm15bmFtZSIsInJlY3RXaWR0aCIsImRhdGEiLCJlbnRlciIsInkyIiwidGhyZXNob2xkIiwidCIsInBvaW50cyIsInR3b1NGIiwidHNmIiwiZm9ybWF0IiwiZ25hbWUiLCJ5VmFsczIiLCJ5VmFsczEiLCJjb2wiLCJmcmVxcyIsImZyZXEiLCJyZWN0IiwiJCIsImluQXJyYXkiLCJzZWxlY3RNZSIsInNlbGVjdE5hbWUiLCJnZXRBdHRyaWJ1dGUiLCJwYXJlbnROb2RlIiwiY2hpbGRyZW4iLCJteUNvbCIsImZpbGwiLCJteWluZGV4IiwiaW5kZXhPZiIsInNwbGljZSIsInNlbGVjdGVkcyIsImZvckVhY2giLCJ2YWwiLCJvYmoiLCJkYXRhMiIsImluc2VydCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7UUFJZ0JBLE8sR0FBQUEsTztRQWdUQUMsSSxHQUFBQSxJO1FBcWdCQUMsVSxHQUFBQSxVO1FBNk5BQyxXLEdBQUFBLFc7UUFzREFDLFEsR0FBQUEsUTtBQTVrQ2hCLElBQUlDLFVBQVUsU0FBZCxDLENB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LEdBQWEsSUFBSXZCLFVBQW5CLENBTm5CLEVBTW1EO0FBTm5ELEtBT0t4QyxJQVBMLENBT1UsUUFQVixFQU9vQnRELENBUHBCLEVBUUtzRCxJQVJMLENBUVUsTUFSVixFQVFrQixTQVJsQjtBQVNIIiwiZmlsZSI6IjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJsZXQgZDNDb2xvciA9ICcjMWY3N2I0JzsgLy8gZDMncyBkZWZhdWx0IGJsdWVcbmV4cG9ydCBsZXQgc2VsVmFyQ29sb3IgPSAnI2ZhODA3Mic7IC8vIGQzLnJnYihcInNhbG1vblwiKTtcblxuLy8gZnVuY3Rpb24gdG8gdXNlIGQzIHRvIGdyYXBoIGRlbnNpdHkgcGxvdHMgd2l0aCBwcmVwcm9jZXNzZWQgZGF0YVxuZXhwb3J0IGZ1bmN0aW9uIGRlbnNpdHkobm9kZSwgZGl2LCBwcml2KSB7XG4gICAgZGl2ID0ge3N1YnNldDogJyN0YWIyJywgc2V0eExlZnQ6ICcjc2V0eExlZnQnLCB2YXJTdW1tYXJ5OiAnI3RhYjMnfVtkaXZdO1xuICAgIGlmICghZGl2KVxuICAgICAgICByZXR1cm4gYWxlcnQoXCJFcnJvcjogaW5jb3JyZWN0IGRpdiBzZWxlY3RlZCBmb3IgcGxvdHNcIik7XG5cbiAgICBsZXQgW3hWYWxzLCB5VmFsc10gPSBbbm9kZS5wbG90eCwgbm9kZS5wbG90eV07XG4gICAgaWYgKHByaXYgJiYgbm9kZS5wbG90Q0kpIHtcbiAgICAgICAgbGV0IFt1cHBlckVycm9yLCBsb3dlckVycm9yXSA9IFsndXBwZXJCb3VuZCcsICdsb3dlckJvdW5kJ10ubWFwKFxuICAgICAgICAgICAgYm91bmQgPT4geFZhbHMubWFwKCh4LCBpKSA9PiAoe3g6ICt4LCB5OiArbm9kZS5wbG90Q0lbYm91bmRdW2ldfSkpKTtcbiAgICAgICAgY29uc29sZS5sb2coJ3VwcGVyRXJyb3JcXG4nLCB1cHBlckVycm9yKTtcbiAgICB9XG5cbiAgICB2YXIgdGVtcFdpZHRoID0gZDMuc2VsZWN0KGRpdikuc3R5bGUoXCJ3aWR0aFwiKTtcbiAgICB2YXIgd2lkdGggPSB0ZW1wV2lkdGguc3Vic3RyaW5nKDAsICh0ZW1wV2lkdGgubGVuZ3RoIC0gMikpO1xuICAgIFxuICAgIGxldCB0dyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtYWluJykub2Zmc2V0V2lkdGg7XG4gICAgXG4gICAgdmFyIHRlbXBIZWlnaHQgPSBkMy5zZWxlY3QoZGl2KS5zdHlsZShcImhlaWdodFwiKTtcbiAgICB2YXIgaGVpZ2h0ID0gdGVtcEhlaWdodC5zdWJzdHJpbmcoMCwgKHRlbXBIZWlnaHQubGVuZ3RoIC0gMikpO1xuICAgIHZhciBtYXJnaW4gPSB7XG4gICAgICAgIHRvcDogMjAsXG4gICAgICAgIHJpZ2h0OiAyMCxcbiAgICAgICAgYm90dG9tOiA1MyxcbiAgICAgICAgbGVmdDogMTBcbiAgICB9O1xuXG4gICAgLy8gTmVlZCB0byBmaXggYXV0b21hdGljIHdpZHRoIGFuZCBoZWlnaHQgc2V0dGluZ3MgZm9yIGxlZnRwYW5lbCAoI3RhYjIsICN0YWIzKVxuICAgIGlmIChkaXYgPT0gXCIjdGFiM1wiKSB7XG4gICAgICAgIHdpZHRoID0gMC43ICogKHdpZHRoIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQpLFxuICAgICAgICBoZWlnaHQgPSAwLjMgKiAoaGVpZ2h0IC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b20pO1xuICAgIH0gZWxzZSBpZiAoZGl2ID09IFwiI3RhYjJcIikge1xuICAgICAgICB3aWR0aCA9IDIwMDtcbiAgICAgICAgaGVpZ2h0ID0gMTIwO1xuICAgIH0gZWxzZSBpZiAoZGl2ID09IFwiI3NldHhMZWZ0XCIpIHtcbiAgICAgICAgd2lkdGg9dHcqLjE4NS1tYXJnaW4ubGVmdC1tYXJnaW4ucmlnaHQ7IC8vcmlnaHRwYW5lbC5leHBhbmQgaXMgNDAgcGVyY2VudCwgc2V0eExlZnQgdG8gNTAgcGVyY2VudCwgdG9nZ2xlIGJhciBpcyAxNnB4LCBwYWRkaW5nLCBpdCdzIGFsbCBhYm91dCAuMTg1XG4gICAgICAgIGhlaWdodD13aWR0aCouNjsgLy9oZWlnaHQgdG8gd2lkdGggaXMgLjZcbiAgICB9IGVsc2Uge1xuICAgICAgICB3aWR0aCA9IDAuMzUgKiAod2lkdGggLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodCksXG4gICAgICAgIGhlaWdodCA9IDAuMjUgKiAoaGVpZ2h0IC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b20pO1xuICAgIH07XG5cbiAgICB2YXIgeCA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgIC5kb21haW4oW2QzLm1pbih4VmFscyksIGQzLm1heCh4VmFscyldKVxuICAgICAgICAucmFuZ2UoWzAsIHdpZHRoXSk7XG4gICAgdmFyIGludnggPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAucmFuZ2UoW2QzLm1pbih4VmFscyksIGQzLm1heCh4VmFscyldKVxuICAgICAgICAuZG9tYWluKFswLCB3aWR0aF0pO1xuICAgIHZhciB5ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLmRvbWFpbihbZDMubWluKHlWYWxzKSwgZDMubWF4KHlWYWxzKV0pXG4gICAgICAgIC5yYW5nZShbaGVpZ2h0LCAwXSk7XG4gICAgdmFyIHhBeGlzID0gZDMuc3ZnLmF4aXMoKVxuICAgICAgICAuc2NhbGUoeClcbiAgICAgICAgLnRpY2tzKDUpXG4gICAgICAgIC5vcmllbnQoXCJib3R0b21cIik7XG4gICAgdmFyIHlBeGlzID0gZDMuc3ZnLmF4aXMoKVxuICAgICAgICAuc2NhbGUoeSlcbiAgICAgICAgLm9yaWVudChcImxlZnRcIik7XG4gICAgdmFyIGJydXNoID0gZDMuc3ZnLmJydXNoKClcbiAgICAgICAgLngoeClcbiAgICAgICAgLmV4dGVudChub2RlLnN1YnNldHJhbmdlKVxuICAgICAgICAub24oXCJicnVzaFwiLCBicnVzaGVkKTtcbiAgICB2YXIgYnJ1c2gyID0gZDMuc3ZnLmJydXNoKClcbiAgICAgICAgLngoeClcbiAgICAgICAgLm9uKFwiYnJ1c2hcIiwgYnJ1c2hlZDIpO1xuICAgIHZhciBhcmVhID0gZDMuc3ZnLmFyZWEoKVxuICAgICAgICAuaW50ZXJwb2xhdGUoXCJtb25vdG9uZVwiKVxuICAgICAgICAueChkID0+IHgoZC54KSlcbiAgICAgICAgLnkwKGhlaWdodClcbiAgICAgICAgLnkxKGQgPT4geShkLnkpKTtcbiAgICB2YXIgbGluZSA9IGQzLnN2Zy5saW5lKClcbiAgICAgICAgLngoZCA9PiB4KGQueCkpXG4gICAgICAgIC55KGQgPT4geShkLnkpKVxuICAgICAgICAuaW50ZXJwb2xhdGUoXCJtb25vdG9uZVwiKTtcblxuICAgIC8vIGN1bWJlcnNvbWUgdG8gdHJlYXQgXCJ0YWIzXCIgZGlmZmVyZW50bHksIGJ1dCB3b3JrcyBmb3Igbm93XG4gICAgLy8gdGFiMywgaGFzIGFuIGlzc3VlLCB0aGF0IHVubGVzcyB3aWR0aCBoZWlnaHQgaGFyZGNvZGVkLCB0aGV5IGdyb3cgd2l0aCBlYWNoIGFkZGl0aW9uYWwgZ3JhcGguXG4gICAgaWYgKGRpdiA9PSBcIiN0YWIzXCIpIHtcbiAgICAgICAgdmFyIHBsb3RzdmcgPSBkMy5zZWxlY3QoZGl2KVxuICAgICAgICAgICAgLnNlbGVjdEFsbChcInN2Z1wiKVxuICAgICAgICAgICAgLnJlbW92ZSgpO1xuICAgICAgICBwbG90c3ZnID0gZDMuc2VsZWN0KGRpdilcbiAgICAgICAgICAgIC5hcHBlbmQoXCJzdmdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgKCkgPT4gbm9kZS5uYW1lLnRvU3RyaW5nKCkuY29uY2F0KGRpdi5zdWJzdHIoMSkpKVxuICAgICAgICAgICAgLnN0eWxlKFwid2lkdGhcIiwgMzAwKSAvLyBzZXQgaGVpZ2h0IHRvIHRoZSBoZWlnaHQgb2YgI21haW4ubGVmdFxuICAgICAgICAgICAgLnN0eWxlKFwiaGVpZ2h0XCIsIDIwMClcbiAgICAgICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBgdHJhbnNsYXRlKCR7bWFyZ2luLmxlZnR9LCR7bWFyZ2luLnRvcH0pYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHBsb3RzdmcgPSBkMy5zZWxlY3QoZGl2KVxuICAgICAgICAgICAgLmFwcGVuZChcInN2Z1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCAoKSA9PiBub2RlLm5hbWUudG9TdHJpbmcoKVxuICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcKHxcXCkvZywgXCJcIilcbiAgICAgICAgICAgICAgICAgIC5jb25jYXQoXCJfXCIsIGRpdi5zdWJzdHIoMSksIFwiX1wiLCBub2RlLmlkKSlcbiAgICAgICAgICAgIC5zdHlsZShcIndpZHRoXCIsIHdpZHRoICsgbWFyZ2luLmxlZnQgKyBtYXJnaW4ucmlnaHQpIC8vc2V0dGluZyBoZWlnaHQgdG8gdGhlIGhlaWdodCBvZiAjbWFpbi5sZWZ0XG4gICAgICAgICAgICAuc3R5bGUoXCJoZWlnaHRcIiwgaGVpZ2h0ICsgbWFyZ2luLnRvcCArIG1hcmdpbi5ib3R0b20pXG4gICAgICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgYHRyYW5zbGF0ZSgke21hcmdpbi5sZWZ0fSwke21hcmdpbi50b3B9KWApO1xuICAgIH07XG4gICAgcGxvdHN2Zy5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgIC5kYXR1bSh4VmFscy5tYXAoKHgsIGkpID0+ICh7eDogK3gsIHk6ICtub2RlLnBsb3R5W2ldfSkpKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiYXJlYVwiKVxuICAgICAgICAuYXR0cihcImRcIiwgYXJlYSk7XG5cbiAgICAvL2FkZCB1cHBlciBib3VuZFxuICAgIHByaXYgJiYgbm9kZS5wbG90Q0kgJiYgcGxvdHN2Zy5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJ1cHBlckVycm9yXCIpXG4gICAgICAgIC5kYXR1bSh1cHBlckVycm9yKVxuICAgICAgICAuYXR0cihcImRcIiwgYXJlYSk7XG5cbiAgICAvL2FkZCBsb3dlciBib3VuZFxuICAgIHByaXYgJiYgbm9kZS5wbG90Q0kgJiYgcGxvdHN2Zy5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJsb3dlckVycm9yXCIpXG4gICAgICAgIC5kYXR1bShsb3dlckVycm9yKVxuICAgICAgICAuYXR0cihcImRcIiwgYXJlYSk7XG5cbiAgICBwbG90c3ZnLmFwcGVuZChcImdcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInggYXhpc1wiKVxuICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLFwiICsgaGVpZ2h0ICsgXCIpXCIpXG4gICAgICAgIC5jYWxsKHhBeGlzKTtcblxuICAgIHBsb3RzdmcuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAuYXR0cihcInhcIiwgKHdpZHRoIC8gMikpXG4gICAgICAgIC5hdHRyKFwieVwiLCAwIC0gKG1hcmdpbi50b3AgLyAyKSlcbiAgICAgICAgLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKVxuICAgICAgICAuc3R5bGUoXCJmb250LXNpemVcIiwgXCIxMnB4XCIpXG4gICAgICAgIC50ZXh0KG5vZGUubmFtZSk7XG5cbiAgICAvLyBhZGQgYnJ1c2ggaWYgc3Vic2V0XG4gICAgaWYgKGRpdiA9PSBcIiN0YWIyXCIpIHtcbiAgICAgICAgcGxvdHN2Zy5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsIFwicmFuZ2VcIilcbiAgICAgICAgICAgIC5hdHRyKFwieFwiLCAyNSlcbiAgICAgICAgICAgIC5hdHRyKFwieVwiLCBoZWlnaHQgKyA0MClcbiAgICAgICAgICAgIC50ZXh0KCgpID0+IFwiUmFuZ2U6IFwiLmNvbmNhdChkMy5taW4oeFZhbHMpLnRvUHJlY2lzaW9uKDQpLCBcIiB0byBcIiwgZDMubWF4KHhWYWxzKS50b1ByZWNpc2lvbig0KSkpO1xuICAgICAgICBwbG90c3ZnLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJ4IGJydXNoXCIpXG4gICAgICAgICAgICAuY2FsbChicnVzaClcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoXCJyZWN0XCIpXG4gICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCBoZWlnaHQpO1xuICAgIH1cblxuICAgIC8vIGFkZCB6IGxpbmVzIGFuZCBzbGlkZXJzIHNldHhcbiAgICBpZiAoZGl2ID09IFwiI3NldHhMZWZ0XCIpIHtcbiAgICAgICAgcGxvdHN2Zy5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsIFwicmFuZ2VcIilcbiAgICAgICAgICAgIC5hdHRyKFwieFwiLCAyNSlcbiAgICAgICAgICAgIC5hdHRyKFwieVwiLCBoZWlnaHQgKyA0MClcbiAgICAgICAgICAgIC50ZXh0KCgpID0+IFwieDogXCIuY29uY2F0KCgrbm9kZS5tZWFuKS50b1ByZWNpc2lvbig0KSkpO1xuXG4gICAgICAgIHBsb3RzdmcuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBcInJhbmdlMlwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIDI1KVxuICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIGhlaWdodCArIDUwKVxuICAgICAgICAgICAgLnRleHQoKCkgPT4gXCJ4MTogXCIuY29uY2F0KCgrbm9kZS5tZWFuKS50b1ByZWNpc2lvbig0KSkpO1xuXG4gICAgICAgIC8vIGNyZWF0ZSB0aWNrIG1hcmtzIGF0IGFsbCB6c2NvcmVzIGluIHRoZSBib3VuZHMgb2YgdGhlIGRhdGFcbiAgICAgICAgdmFyIGxpbmVGdW5jdGlvbiA9IGQzLnN2Zy5saW5lKClcbiAgICAgICAgICAgIC54KGQgPT4gZC54KVxuICAgICAgICAgICAgLnkoZCA9PiBkLnkpXG4gICAgICAgICAgICAuaW50ZXJwb2xhdGUoXCJsaW5lYXJcIik7XG5cbiAgICAgICAgdmFyIGNvbFNlcSA9IFtcIiNBMkNENUFcIiwgXCJvcmFuZ2VcIiwgXCJyZWRcIl07IC8vIHdpbGwgY3ljbGUgdGhyb3VnaCBjb2xvciBzZXF1ZW5jZSwgYW5kIHRoZW4gcmVwZWF0IGxhc3QgY29sb3JcbiAgICAgICAgdmFyIGxpbmVEYXRhID0gbmV3IEFycmF5O1xuXG4gICAgICAgIHZhciB6TG93ZXIgPSAtMSAqIChkMy5taW4oeFZhbHMpIC0gbm9kZS5tZWFuKSAvIG5vZGUuc2Q7IC8vIHpzY29yZSBvZiBsb3dlciBib3VuZFxuICAgICAgICB2YXIgelVwcGVyID0gKGQzLm1heCh4VmFscykgLSBub2RlLm1lYW4pIC8gbm9kZS5zZDsgLy8genNjb3JlIG9mIHVwcGVyIGJvdW5kXG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB6VXBwZXI7IGkrKykge1xuICAgICAgICAgICAgbGluZURhdGEgPSBbe1xuICAgICAgICAgICAgICAgIFwieFwiOiB4KCtub2RlLm1lYW4gKyBpICogbm9kZS5zZCksXG4gICAgICAgICAgICAgICAgXCJ5XCI6IGhlaWdodCAqIC43XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgXCJ4XCI6IHgoK25vZGUubWVhbiArIGkgKiBub2RlLnNkKSxcbiAgICAgICAgICAgICAgICBcInlcIjogaGVpZ2h0ICogLjlcbiAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgcGxvdHN2Zy5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJkXCIsIGxpbmVGdW5jdGlvbihbbGluZURhdGFbMF0sIGxpbmVEYXRhWzFdXSkpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJzdHJva2VcIiwgY29sU2VxW2QzLm1pbihbaSwgY29sU2VxLmxlbmd0aCAtIDFdKV0pXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJzdHJva2Utd2lkdGhcIiwgMS41KVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiZmlsbFwiLCBcIm5vbmVcIik7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHpMb3dlcjsgaSsrKSB7XG4gICAgICAgICAgICBsaW5lRGF0YSA9IFt7XG4gICAgICAgICAgICAgICAgXCJ4XCI6IHgoK25vZGUubWVhbiAtIGkgKiBub2RlLnNkKSxcbiAgICAgICAgICAgICAgICBcInlcIjogaGVpZ2h0ICogLjdcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBcInhcIjogeCgrbm9kZS5tZWFuIC0gaSAqIG5vZGUuc2QpLFxuICAgICAgICAgICAgICAgIFwieVwiOiBoZWlnaHQgKiAuOVxuICAgICAgICAgICAgfV07XG4gICAgICAgICAgICBwbG90c3ZnLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImRcIiwgbGluZUZ1bmN0aW9uKFtsaW5lRGF0YVswXSwgbGluZURhdGFbMV1dKSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInN0cm9rZVwiLCBjb2xTZXFbZDMubWluKFtpLCBjb2xTZXEubGVuZ3RoIC0gMV0pXSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInN0cm9rZS13aWR0aFwiLCAxLjUpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJmaWxsXCIsIFwibm9uZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGluaXRpYWxpemUgc2xpZGVyIGNvbXBvbmVudHNcbiAgICAgICAgdmFyIHNsaWRlQm94ID0gcGxvdHN2Zy5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwieCBheGlzXCIpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLFwiICsgaGVpZ2h0ICogLjggKyBcIilcIilcbiAgICAgICAgICAgIC5jYWxsKGQzLnN2Zy5heGlzKClcbiAgICAgICAgICAgICAgICAgIC5zY2FsZSh4KVxuICAgICAgICAgICAgICAgICAgLnRpY2tzKDApXG4gICAgICAgICAgICAgICAgICAub3JpZW50KFwiYm90dG9tXCIpKTtcbiAgICAgICAgdmFyIHNsaWRlciA9IHBsb3RzdmcuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInNsaWRlclwiKVxuICAgICAgICAgICAgLmNhbGwoYnJ1c2gpO1xuICAgICAgICB2YXIgaGFuZGxlID0gc2xpZGVyLmFwcGVuZChcInBvbHlnb25cIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJoYW5kbGVcIilcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsXCIgKyBoZWlnaHQgKiAuNyArIFwiKVwiKVxuICAgICAgICAgICAgLmF0dHIoXCJwb2ludHNcIiwgXyA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHMgPSA2O1xuICAgICAgICAgICAgICAgIGxldCB4bm0gPSBub2RlLnNldHh2YWxzWzBdID09ICcnID8geChub2RlLm1lYW4pIDogeChub2RlLnNldHh2YWxzWzBdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHhubSAtIHMpICsgXCIsXCIgKyAoLXMpICsgXCIgXCIgKyAoeG5tICsgcykgKyBcIixcIiArICgtcykgKyBcIiBcIiArIHhubSArIFwiLFwiICsgKHMgKiAxLjMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIHZhciBzbGlkZXIyID0gcGxvdHN2Zy5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwic2xpZGVyXCIpXG4gICAgICAgICAgICAuY2FsbChicnVzaDIpO1xuICAgICAgICB2YXIgaGFuZGxlMiA9IHNsaWRlcjIuYXBwZW5kKFwicG9seWdvblwiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImhhbmRsZVwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCxcIiArIGhlaWdodCAqIC45ICsgXCIpXCIpXG4gICAgICAgICAgICAuYXR0cihcInBvaW50c1wiLCBfID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgcyA9IDY7XG4gICAgICAgICAgICAgICAgbGV0IHhubSA9IG5vZGUuc2V0eHZhbHNbMV0gPT0gJycgPyB4KG5vZGUubWVhbikgOiB4KG5vZGUuc2V0eHZhbHNbMV0pO1xuICAgICAgICAgICAgICAgIHJldHVybiAoeG5tIC0gcykgKyBcIixcIiArIHMgKyBcIiBcIiArICh4bm0gKyBzKSArIFwiLFwiICsgcyArIFwiIFwiICsgeG5tICsgXCIsXCIgKyAoLXMgKiAxLjMpO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gYnJ1c2hpbmcgZnVuY3Rpb25zXG4gICAgZnVuY3Rpb24gYnJ1c2hlZCgpIHtcbiAgICAgICAgaWYgKGRpdiA9PSBcIiN0YWIyXCIpIHtcbiAgICAgICAgICAgIHBsb3Rzdmcuc2VsZWN0KFwidGV4dCNyYW5nZVwiKVxuICAgICAgICAgICAgICAgIC50ZXh0KCgpID0+IGJydXNoLmVtcHR5KCkgP1xuICAgICAgICAgICAgICAgICAgICBcIlJhbmdlOiBcIi5jb25jYXQoZDMubWluKHhWYWxzKS50b1ByZWNpc2lvbig0KSwgXCIgdG8gXCIsIGQzLm1heCh4VmFscykudG9QcmVjaXNpb24oNCkpIDpcbiAgICAgICAgICAgICAgICAgICAgXCJSYW5nZTogXCIuY29uY2F0KChicnVzaC5leHRlbnQoKVswXSkudG9QcmVjaXNpb24oNCksIFwiIHRvIFwiLCAoYnJ1c2guZXh0ZW50KClbMV0pLnRvUHJlY2lzaW9uKDQpKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBub2RlLnN1YnNldHJhbmdlID0gYnJ1c2guZXh0ZW50KClbMF0udG9QcmVjaXNpb24oNCkgIT0gYnJ1c2guZXh0ZW50KClbMV0udG9QcmVjaXNpb24oNCkgP1xuICAgICAgICAgICAgICAgIFsoYnJ1c2guZXh0ZW50KClbMF0pLnRvUHJlY2lzaW9uKDQpLCAoYnJ1c2guZXh0ZW50KClbMV0pLnRvUHJlY2lzaW9uKDQpXSA6XG4gICAgICAgICAgICAgICAgW1wiXCIsIFwiXCJdO1xuICAgICAgICB9IGVsc2UgaWYgKGRpdiA9PSBcIiNzZXR4TGVmdFwiKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBicnVzaC5leHRlbnQoKVswXTtcbiAgICAgICAgICAgIHZhciBzID0gNjtcbiAgICAgICAgICAgIGlmIChkMy5ldmVudC5zb3VyY2VFdmVudCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0geC5pbnZlcnQoZDMubW91c2UodGhpcylbMF0pO1xuICAgICAgICAgICAgICAgIGJydXNoLmV4dGVudChbdmFsdWUsIHZhbHVlXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNldCB4IHBvc2l0aW9uIG9mIHNsaWRlciBjZW50ZXJcbiAgICAgICAgICAgIHZhciB4cG9zID0geCh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAodmFsdWUgPiBkMy5tYXgoeFZhbHMpKSB7IC8vIGRyYWdnZWQgcGFzdCBtYXhcbiAgICAgICAgICAgICAgICB4cG9zID0geChkMy5tYXgoeFZhbHMpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPCBkMy5taW4oeFZhbHMpKSB7IC8vIGRyYWdnZWQgcGFzdCBtaW5cbiAgICAgICAgICAgICAgICB4cG9zID0geChkMy5taW4oeFZhbHMpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIG0gPSArbm9kZS5tZWFuO1xuICAgICAgICAgICAgICAgIHZhciBzZCA9ICtub2RlLnNkO1xuICAgICAgICAgICAgICAgIHZhciB6U2NvcmUgPSAodmFsdWUgLSBtKSAvIHNkOyAvLyB6LXNjb3JlXG4gICAgICAgICAgICAgICAgdmFyIHpSb3VuZCA9IE1hdGgucm91bmQoelNjb3JlKTsgLy8gbmVhcmVzdCBpbnRlZ2VyIHotc2NvcmVcbiAgICAgICAgICAgICAgICBpZiAoLjEgPiBNYXRoLmFicyh6Um91bmQgLSB6U2NvcmUpKSAvLyBzbmFwIHRvIGludGVnZXIgei1zY29yZVxuICAgICAgICAgICAgICAgICAgICB4cG9zID0geChtICsgKHpSb3VuZCAqIHNkKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNyZWF0ZSBzbGlkZXIgc3ltYm9sIGFuZCB0ZXh0XG4gICAgICAgICAgICBoYW5kbGUuYXR0cihcInBvaW50c1wiLCBfID0+ICh4cG9zIC0gcykgKyBcIixcIiArICgtcykgKyBcIiBcIiArICh4cG9zICsgcykgKyBcIixcIiArICgtcykgKyBcIiBcIiArIHhwb3MgKyBcIixcIiArIChzICogMS4zKSk7XG4gICAgICAgICAgICBwbG90c3ZnLnNlbGVjdChcInRleHQjcmFuZ2VcIilcbiAgICAgICAgICAgICAgICAudGV4dCgoKSA9PiBcIng6IFwiLmNvbmNhdCgoaW52eCh4cG9zKSkudG9QcmVjaXNpb24oNCkpKTtcbiAgICAgICAgICAgIG5vZGUuc2V0eHZhbHNbMF0gPSAoaW52eCh4cG9zKSkudG9QcmVjaXNpb24oNCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjZXJ0YWlubHkgYSBtb3JlIGNsZXZlciB3YXkgdG8gZG8gdGhpcywgYnV0IGZvciBub3cgaXQncyBiYXNpY2FsbHkgY29waWVkIHdpdGggYnJ1c2ggYW5kIGhhbmRsZSBjaGFuZ2VzIHRvIGJydXNoMiBhbmQgaGFuZGxlMiBhbmQgI3JhbmdlIHRvICNyYW5nZTIgYW5kIHNldHh2YWxzWzBdIHRvIHNldHh2YWxzWzFdXG4gICAgZnVuY3Rpb24gYnJ1c2hlZDIoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGJydXNoMi5leHRlbnQoKVswXTtcbiAgICAgICAgdmFyIHMgPSA2OyAvLyBzY2FsaW5nIGZvciB0cmlhbmdsZSBzaGFwZVxuXG4gICAgICAgIGlmIChkMy5ldmVudC5zb3VyY2VFdmVudCkge1xuICAgICAgICAgICAgdmFsdWUgPSB4LmludmVydChkMy5tb3VzZSh0aGlzKVswXSk7XG4gICAgICAgICAgICBicnVzaDIuZXh0ZW50KFt2YWx1ZSwgdmFsdWVdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldCB4IHBvc2l0aW9uIG9mIHNsaWRlciBjZW50ZXJcbiAgICAgICAgdmFyIHhwb3MgPSB4KHZhbHVlKTtcbiAgICAgICAgaWYgKHZhbHVlID4gZDMubWF4KHhWYWxzKSkgeyAvLyBkcmFnZ2VkIHBhc3QgbWF4XG4gICAgICAgICAgICB4cG9zID0geChkMy5tYXgoeFZhbHMpKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA8IGQzLm1pbih4VmFscykpIHsgLy8gZHJhZ2dlZCBwYXN0IG1pblxuICAgICAgICAgICAgeHBvcyA9IHgoZDMubWluKHhWYWxzKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbSA9ICtub2RlLm1lYW47XG4gICAgICAgICAgICB2YXIgc2QgPSArbm9kZS5zZDtcbiAgICAgICAgICAgIHZhciB6U2NvcmUgPSAodmFsdWUgLSBtKSAvIHNkOyAvLyB6LXNjb3JlXG4gICAgICAgICAgICB2YXIgelJvdW5kID0gTWF0aC5yb3VuZCh6U2NvcmUpOyAvLyBuZWFyZXN0IGludGVnZXIgei1zY29yZVxuICAgICAgICAgICAgaWYgKC4xID4gTWF0aC5hYnMoelJvdW5kIC0gelNjb3JlKSkgLy8gc25hcCB0byBpbnRlZ2VyIHotc2NvcmVcbiAgICAgICAgICAgICAgICB4cG9zID0geChtICsgKHpSb3VuZCAqIHNkKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjcmVhdGUgc2xpZGVyIHN5bWJvbCBhbmQgdGV4dFxuICAgICAgICBoYW5kbGUyLmF0dHIoXCJwb2ludHNcIiwgXyA9PiAoeHBvcyAtIHMpICsgXCIsXCIgKyBzICsgXCIgXCIgKyAoeHBvcyArIHMpICsgXCIsXCIgKyBzICsgXCIgXCIgKyB4cG9zICsgXCIsXCIgKyAoLXMgKiAxLjMpKTtcbiAgICAgICAgcGxvdHN2Zy5zZWxlY3QoXCJ0ZXh0I3JhbmdlMlwiKVxuICAgICAgICAgICAgLnRleHQoKCkgPT4gXCJ4MTogXCIuY29uY2F0KChpbnZ4KHhwb3MpKS50b1ByZWNpc2lvbig0KSkpO1xuICAgICAgICBub2RlLnNldHh2YWxzWzFdID0gKGludngoeHBvcykpLnRvUHJlY2lzaW9uKDQpO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJhcnMobm9kZSwgZGl2LCBwcml2KSB7XG4gICAgLy8gSGlzdG9ncmFtIHNwYWNpbmdcbiAgICB2YXIgYmFyUGFkZGluZyA9IC4wMTU7IC8vIFNwYWNlIGJldHdlZW4gYmFyc1xuICAgIHZhciB0b3BTY2FsZSA9IDEuMjsgLy8gTXVsdGlwbGljYXRpdmUgZmFjdG9yIHRvIGFzc2lnbiBzcGFjZSBhdCB0b3Agd2l0aGluIGdyYXBoIC0gY3VycmVudGx5IHJlbW92ZWQgZnJvbSBpbXBsZW1lbnRhdGlvblxuICAgIHZhciBwbG90WGF4aXMgPSB0cnVlO1xuXG4gICAgLy8gRGF0YVxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMobm9kZS5wbG90dmFsdWVzKTtcbiAgICB2YXIgeVZhbHMgPSBuZXcgQXJyYXk7XG4gICAgdmFyIGNpVXBwZXJWYWxzID0gbmV3IEFycmF5O1xuICAgIHZhciBjaUxvd2VyVmFscyA9IG5ldyBBcnJheTtcbiAgICB2YXIgY2lTaXplO1xuXG4gICAgdmFyIHhWYWxzID0gbmV3IEFycmF5O1xuICAgIHZhciB5VmFsS2V5ID0gbmV3IEFycmF5O1xuXG4gICAgaWYgKG5vZGUubmF0dXJlID09IFwibm9taW5hbFwiKSB7XG4gICAgICAgIHZhciB4aSA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKG5vZGUucGxvdHZhbHVlc1trZXlzW2ldXSA9PSAwKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgeVZhbHNbeGldID0gbm9kZS5wbG90dmFsdWVzW2tleXNbaV1dO1xuICAgICAgICAgICAgeFZhbHNbeGldID0geGk7XG4gICAgICAgICAgICBpZiAocHJpdikge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLnBsb3R2YWx1ZXNDSSkge1xuICAgICAgICAgICAgICAgICAgICBjaUxvd2VyVmFsc1t4aV0gPSBub2RlLnBsb3RWYWx1ZXNDSS5sb3dlckJvdW5kW2tleXNbaV1dO1xuICAgICAgICAgICAgICAgICAgICBjaVVwcGVyVmFsc1t4aV0gPSBub2RlLnBsb3RWYWx1ZXNDSS51cHBlckJvdW5kW2tleXNbaV1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaVNpemUgPSBjaVVwcGVyVmFsc1t4aV0gLSBjaUxvd2VyVmFsc1t4aV07XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB5VmFsS2V5LnB1c2goe1xuICAgICAgICAgICAgICAgIHk6IHlWYWxzW3hpXSxcbiAgICAgICAgICAgICAgICB4OiBrZXlzW2ldXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHhpID0geGkgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHlWYWxLZXkuc29ydCgoYSwgYikgPT4gYi55IC0gYS55KTsgLy8gYXJyYXkgb2Ygb2JqZWN0cywgZWFjaCBvYmplY3QgaGFzIHksIHRoZSBzYW1lIGFzIHlWYWxzLCBhbmQgeCwgdGhlIGNhdGVnb3J5XG4gICAgICAgIHlWYWxzLnNvcnQoKGEsIGIpID0+IGIgLSBhKTsgLy8gYXJyYXkgb2YgeSB2YWx1ZXMsIHRoZSBoZWlnaHQgb2YgdGhlIGJhcnNcbiAgICAgICAgY2lVcHBlclZhbHMuc29ydCgoYSwgYikgPT4gYi55IC0gYS55KTsgLy8gP1xuICAgICAgICBjaUxvd2VyVmFscy5zb3J0KChhLCBiKSA9PiBiLnkgLSBhLnkpOyAvLyA/XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInBsb3R2YWx1ZXMgaW4gYmFyc1wiKTtcbiAgICAgICAgICAgIHlWYWxzW2ldID0gbm9kZS5wbG90dmFsdWVzW2tleXNbaV1dO1xuICAgICAgICAgICAgeFZhbHNbaV0gPSBOdW1iZXIoa2V5c1tpXSk7XG4gICAgICAgICAgICBpZiAocHJpdikge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLnBsb3R2YWx1ZXNDSSkge1xuICAgICAgICAgICAgICAgICAgICBjaUxvd2VyVmFsc1tpXSA9IG5vZGUucGxvdHZhbHVlc0NJLmxvd2VyQm91bmRba2V5c1tpXV07XG4gICAgICAgICAgICAgICAgICAgIGNpVXBwZXJWYWxzW2ldID0gbm9kZS5wbG90dmFsdWVzQ0kudXBwZXJCb3VuZFtrZXlzW2ldXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2lTaXplID0gY2lVcHBlclZhbHNbaV0gLSBjaUxvd2VyVmFsc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICgoeVZhbHMubGVuZ3RoID4gMTUgJiBub2RlLm51bWNoYXIgPT0gXCJudW1lcmljXCIpIHx8ICh5VmFscy5sZW5ndGggPiA1ICYgbm9kZS5udW1jaGFyID09IFwiY2hhcmFjdGVyXCIpKVxuICAgICAgICBwbG90WGF4aXMgPSBmYWxzZTtcbiAgICB2YXIgbWF4WSA9IGQzLm1heCh5VmFscyk7IC8vIGluIHRoZSBmdXR1cmUsIHNldCBtYXhZIHRvIHRoZSB2YWx1ZSBvZiB0aGUgbWF4aW11bSBjb25maWRlbmNlIGxpbWl0XG4gICAgaWYgKHByaXYgJiYgbm9kZS5wbG90dmFsdWVzQ0kpIG1heFkgPSBkMy5tYXgoY2lVcHBlclZhbHMpO1xuICAgIHZhciBtaW5YID0gZDMubWluKHhWYWxzKTtcbiAgICB2YXIgbWF4WCA9IGQzLm1heCh4VmFscyk7XG5cbiAgICBsZXQgbXlkaXY7XG4gICAgaWYgKGRpdiA9PSBcInNldHhMZWZ0XCIpIG15ZGl2ID0gXCIjc2V0eExlZnRcIjtcbiAgICBlbHNlIGlmIChkaXYgPT0gXCJ2YXJTdW1tYXJ5XCIpIG15ZGl2ID0gXCIjdGFiM1wiO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGFsZXJ0KFwiRXJyb3I6IGluY29ycmVjdCBkaXYgc2VsZWN0ZWQgZm9yIHBsb3RzXCIpO1xuXG4gICAgdmFyIHRlbXBXaWR0aCA9IGQzLnNlbGVjdChteWRpdikuc3R5bGUoXCJ3aWR0aFwiKVxuICAgIHZhciB3aWR0aCA9IHRlbXBXaWR0aC5zdWJzdHJpbmcoMCwgKHRlbXBXaWR0aC5sZW5ndGggLSAyKSk7XG4gICAgdmFyIHRlbXBIZWlnaHQgPSBkMy5zZWxlY3QobXlkaXYpLnN0eWxlKFwiaGVpZ2h0XCIpXG4gICAgdmFyIGhlaWdodCA9IHRlbXBIZWlnaHQuc3Vic3RyaW5nKDAsICh0ZW1wSGVpZ2h0Lmxlbmd0aCAtIDIpKTtcblxuICAgIHZhciBtYXJnaW4gPSB7XG4gICAgICAgIHRvcDogMjAsXG4gICAgICAgIHJpZ2h0OiAyMCxcbiAgICAgICAgYm90dG9tOiA1MyxcbiAgICAgICAgbGVmdDogMTBcbiAgICB9O1xuICAgIGxldCB0dyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtYWluJykub2Zmc2V0V2lkdGg7XG5cbiAgICAvLyBOZWVkIHRvIGZpeCBhdXRvbWF0aWMgd2lkdGggYW5kIGhlaWdodCBzZXR0aW5ncyBmb3IgbGVmdHBhbmVsICgjdGFiMiwgI3RhYjMpXG4gICAgaWYgKG15ZGl2ID09IFwiI3RhYjNcIikge1xuICAgICAgICB3aWR0aCA9IDAuNyAqICh3aWR0aCAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0KTtcbiAgICAgICAgaGVpZ2h0ID0gMC4zICogKGhlaWdodCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tKTtcbiAgICB9IGVsc2UgaWYgKG15ZGl2ID09IFwiI3NldHhMZWZ0XCIpIHtcbiAgICAgICAgLy93aWR0aCA9IDIwMDtcbiAgICAgICAgLy9oZWlnaHQgPSAxMjA7XG4gICAgICAgIHdpZHRoPXR3Ki4xODUtbWFyZ2luLmxlZnQtbWFyZ2luLnJpZ2h0OyAvL3JpZ2h0cGFuZWwuZXhwYW5kIGlzIDQwIHBlcmNlbnQsIHNldHhMZWZ0IHRvIDUwIHBlcmNlbnQsIHRvZ2dsZSBiYXIgaXMgMTZweCwgcGFkZGluZywgaXQncyBhbGwgYWJvdXQgLjE4NVxuICAgICAgICBoZWlnaHQ9d2lkdGgqLjY7IC8vaGVpZ2h0IHRvIHdpZHRoIGlzIC42XG4gICAgfSBlbHNlIHtcbiAgICAgICAgd2lkdGggPSAwLjM1ICogKHdpZHRoIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQpO1xuICAgICAgICBoZWlnaHQgPSAwLjI1ICogKGhlaWdodCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tKTtcbiAgICB9O1xuXG4gICAgaWYgKHByaXYgJiYgbm9kZS5zdGFiaWxpdHlCaW4pIHtcbiAgICAgICAgdmFyIHggPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAgICAgLmRvbWFpbihbbWluWCAtIDAuNSwgbWF4WCArIDEuNV0pXG4gICAgICAgICAgICAucmFuZ2UoWzAsIHdpZHRoXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHggPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAgICAgLmRvbWFpbihbbWluWCAtIDAuNSwgbWF4WCArIDAuNV0pXG4gICAgICAgICAgICAucmFuZ2UoWzAsIHdpZHRoXSk7XG4gICAgfVxuXG4gICAgdmFyIGludnggPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAucmFuZ2UoW21pblggLSAwLjUsIG1heFggKyAwLjVdKVxuICAgICAgICAuZG9tYWluKFswLCB3aWR0aF0pO1xuXG4gICAgdmFyIHkgPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAuZG9tYWluKFswLCBtYXhZXSlcbiAgICAgICAgLnJhbmdlKFswLCBoZWlnaHRdKTtcblxuICAgIHZhciB4QXhpcyA9IGQzLnN2Zy5heGlzKClcbiAgICAgICAgLnNjYWxlKHgpXG4gICAgICAgIC50aWNrcyh5VmFscy5sZW5ndGgpXG4gICAgICAgIC5vcmllbnQoXCJib3R0b21cIik7XG5cbiAgICB2YXIgeUF4aXMgPSBkMy5zdmcuYXhpcygpXG4gICAgICAgIC5zY2FsZSh5KVxuICAgICAgICAub3JpZW50KFwibGVmdFwiKTtcblxuICAgIHZhciBicnVzaCA9IGQzLnN2Zy5icnVzaCgpXG4gICAgICAgIC54KHgpXG4gICAgICAgIC5leHRlbnQoKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUuc3Vic2V0cmFuZ2UubGVuZ3RoID09IDEgP1xuICAgICAgICAgICAgICAgIFtub2RlLnN1YnNldHJhbmdlWzBdLCBub2RlLnN1YnNldHJhbmdlWzBdXVxuICAgICAgICAgICAgICAgIDogbm9kZS5zdWJzZXRyYW5nZTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKFwiYnJ1c2hcIiwgYnJ1c2hlZCk7XG5cbiAgICB2YXIgYnJ1c2gyID0gZDMuc3ZnLmJydXNoKClcbiAgICAgICAgLngoeClcbiAgICAgICAgLm9uKFwiYnJ1c2hcIiwgYnJ1c2hlZDIpO1xuXG4gICAgLy8gQ3JlYXRlIFNWRyBlbGVtZW50XG4gICAgLy8gY3VtYmVyc29tZSB0byB0cmVhdCBcInRhYjNcIiBkaWZmZXJlbnRseSwgYnV0IHdvcmtzIGZvciBub3dcbiAgICAvLyB0YWIzLCBoYXMgYW4gaXNzdWUsIHRoYXQgdW5sZXNzIHdpZHRoIGhlaWdodCBoYXJkY29kZWQsIHRoZXkgZ3JvdyB3aXRoIGVhY2ggYWRkaXRpb25hbCBncmFwaC5cbiAgICBpZiAobXlkaXYgPT0gXCIjdGFiM1wiKSB7XG4gICAgICAgIHZhciBwbG90c3ZnID0gZDMuc2VsZWN0KG15ZGl2KVxuICAgICAgICAgICAgLnNlbGVjdEFsbChcInN2Z1wiKVxuICAgICAgICAgICAgLnJlbW92ZSgpO1xuXG4gICAgICAgIHZhciBwbG90c3ZnID0gZDMuc2VsZWN0KG15ZGl2KVxuICAgICAgICAgICAgLmFwcGVuZChcInN2Z1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCAoKSA9PiBub2RlLm5hbWUudG9TdHJpbmcoKS5jb25jYXQobXlkaXYuc3Vic3RyKDEpKSlcbiAgICAgICAgICAgIC5zdHlsZShcIndpZHRoXCIsIDMwMCkgLy9zZXR0aW5nIGhlaWdodCB0byB0aGUgaGVpZ2h0IG9mICNtYWluLmxlZnRcbiAgICAgICAgICAgIC5zdHlsZShcImhlaWdodFwiLCAyMDApXG4gICAgICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBtYXJnaW4ubGVmdCArIFwiLFwiICsgbWFyZ2luLnRvcCArIFwiKVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcGxvdHN2ZyA9IGQzLnNlbGVjdChteWRpdilcbiAgICAgICAgICAgIC5hcHBlbmQoXCJzdmdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIG15bmFtZSA9IG5vZGUubmFtZS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIG15bmFtZSA9IG15bmFtZS5yZXBsYWNlKC9cXCh8XFwpL2csIFwiXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBteW5hbWUuY29uY2F0KFwiX1wiLCBteWRpdi5zdWJzdHIoMSksIFwiX1wiLCBub2RlLmlkKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuc3R5bGUoXCJ3aWR0aFwiLCB3aWR0aCArIG1hcmdpbi5sZWZ0ICsgbWFyZ2luLnJpZ2h0KSAvL3NldHRpbmcgaGVpZ2h0IHRvIHRoZSBoZWlnaHQgb2YgI21haW4ubGVmdFxuICAgICAgICAgICAgLnN0eWxlKFwiaGVpZ2h0XCIsIGhlaWdodCArIG1hcmdpbi50b3AgKyBtYXJnaW4uYm90dG9tKVxuICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgbWFyZ2luLmxlZnQgKyBcIixcIiArIG1hcmdpbi50b3AgKyBcIilcIik7XG4gICAgfTtcblxuICAgIHZhciByZWN0V2lkdGggPSB4KG1pblggKyAwLjUgLSAyICogYmFyUGFkZGluZyk7IC8vdGhlIFwid2lkdGhcIiBpcyB0aGUgY29vcmRpbmF0ZSBvZiB0aGUgZW5kIG9mIHRoZSBmaXJzdCBiYXJcblxuICAgIHBsb3Rzdmcuc2VsZWN0QWxsKFwicmVjdFwiKVxuICAgICAgICAuZGF0YSh5VmFscylcbiAgICAgICAgLmVudGVyKClcbiAgICAgICAgLmFwcGVuZChcInJlY3RcIilcbiAgICAgICAgLmF0dHIoXCJ4XCIsIChkLCBpKSA9PiB4KHhWYWxzW2ldIC0gMC41ICsgYmFyUGFkZGluZykpXG4gICAgICAgIC5hdHRyKFwieVwiLCBkID0+IHkobWF4WSAtIGQpKVxuICAgICAgICAuYXR0cihcIndpZHRoXCIsIHJlY3RXaWR0aClcbiAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgeSlcbiAgICAgICAgLmF0dHIoXCJmaWxsXCIsIFwiIzFmNzdiNFwiKTtcblxuICAgIC8vIGRyYXcgZXJyb3IgYmFycywgdGhyZXNob2xkIGxpbmUgYW5kIGV4dHJhIGJpblxuICAgIGlmIChwcml2KSB7XG4gICAgICAgIGlmICh5VmFscy5sZW5ndGggPD0gMjApIHtcbiAgICAgICAgICAgIHBsb3Rzdmcuc2VsZWN0QWxsKFwibGluZVwiKVxuICAgICAgICAgICAgICAgIC5kYXRhKGNpVXBwZXJWYWxzKVxuICAgICAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAgICAgLmFwcGVuZChcImxpbmVcIilcbiAgICAgICAgICAgICAgICAuc3R5bGUoXCJzdHJva2VcIiwgXCJibGFja1wiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieDFcIiwgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geCh4VmFsc1tpXSAtIDAuNSArIGJhclBhZGRpbmcpICsgcmVjdFdpZHRoIC8gMlxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgIFx0LmF0dHIoXCJ5MVwiLCBkID0+IHkobWF4WSAtIGQpKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieDJcIiwgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geCh4VmFsc1tpXSAtIDAuNSArIGJhclBhZGRpbmcpICsgcmVjdFdpZHRoIC8gMlxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ5MlwiLCBkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHkyID0geShtYXhZIC0gZCArIGNpU2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB5MiA+PSB5KG1heFkpID8geShtYXhZKSA6IHkyO1xuICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy9kcmF3IHRvcCB0aWNrcyBvbiBlcnJvciBiYXJzXG4gICAgICAgICAgICAvL25lZWQgdG8gZml4IHRoZSBoZWlnaHQgb2YgdGhlIGdyYXBocyAtIHRoZSB0b3BzIG9mIGVycm9yIGJhcnMgYXJlIGdldHRpbmcgY3V0IG9mZlxuICAgICAgICAgICAgcGxvdHN2Zy5zZWxlY3RBbGwoXCIudG9wVGlja1wiKVxuICAgICAgICAgICAgICAgIC5kYXRhKGNpVXBwZXJWYWxzKVxuICAgICAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAgICAgLmFwcGVuZChcImxpbmVcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwidG9wVGlja1wiKVxuICAgICAgICAgICAgICAgIC5zdHlsZShcInN0cm9rZVwiLCBcImJsYWNrXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ4MVwiLCBmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh5VmFscy5sZW5ndGggPiAyMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHgoeFZhbHNbaV0gLSAwLjUgKyBiYXJQYWRkaW5nKSAvL21ha2UgdGljayBiaWdnZXIgdG8gaW5jcmVhc2UgdmlzaWJpbGl0eVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHgoeFZhbHNbaV0gLSAwLjUgKyBiYXJQYWRkaW5nKSArIDAuNCAqIHJlY3RXaWR0aFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInkxXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHkobWF4WSAtIGQpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ4MlwiLCBmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh5VmFscy5sZW5ndGggPiAyMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHgoeFZhbHNbaV0gLSAwLjUgKyBiYXJQYWRkaW5nKSArIHJlY3RXaWR0aCAvL21ha2UgdGljayBiaWdnZXIgdG8gaW5jcmVhc2UgdmlzaWJpbGl0eVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHgoeFZhbHNbaV0gLSAwLjUgKyBiYXJQYWRkaW5nKSArIDAuNiAqIHJlY3RXaWR0aFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInkyXCIsIGQgPT4geShtYXhZIC0gZCkpO1xuXG4gICAgICAgICAgICAvLyBkcmF3IGJvdHRvbSB0aWNrcyBvZiBlcnJvciBiYXJzXG4gICAgICAgICAgICBwbG90c3ZnLnNlbGVjdEFsbChcIi5ib3R0b21UaWNrXCIpXG4gICAgICAgICAgICAgICAgLmRhdGEoY2lMb3dlclZhbHMpXG4gICAgICAgICAgICAgICAgLmVudGVyKClcbiAgICAgICAgICAgICAgICAuYXBwZW5kKFwibGluZVwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJib3R0b21UaWNrXCIpXG4gICAgICAgICAgICAgICAgLnN0eWxlKFwic3Ryb2tlXCIsIFwiYmxhY2tcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcIngxXCIsIGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHlWYWxzLmxlbmd0aCA+IDIwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geCh4VmFsc1tpXSAtIDAuNSArIGJhclBhZGRpbmcpXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geCh4VmFsc1tpXSAtIDAuNSArIGJhclBhZGRpbmcpICsgMC40ICogcmVjdFdpZHRoXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieTFcIiwgZCA9PiB5KG1heFkgLSBkKSlcbiAgICAgICAgICAgICAgICAuYXR0cihcIngyXCIsIGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHlWYWxzLmxlbmd0aCA+IDIwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geCh4VmFsc1tpXSAtIDAuNSArIGJhclBhZGRpbmcpICsgcmVjdFdpZHRoXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geCh4VmFsc1tpXSAtIDAuNSArIGJhclBhZGRpbmcpICsgMC42ICogcmVjdFdpZHRoXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieTJcIiwgZCA9PiB5KG1heFkgLSBkKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwbG90c3ZnLnNlbGVjdEFsbChcIi5kZW5zZUVycm9yXCIpXG4gICAgICAgICAgICAgICAgLmRhdGEoeVZhbHMpXG4gICAgICAgICAgICAgICAgLmVudGVyKClcbiAgICAgICAgICAgICAgICAuYXBwZW5kKFwicmVjdFwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJkZW5zZUVycm9yXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIChkLCBpKSA9PiB4KHhWYWxzW2ldIC0gMC41ICsgYmFyUGFkZGluZykpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIGQgPT4geShtYXhZIC0gZCkgLSAuMSAqIHkoZCkpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCByZWN0V2lkdGgpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgZCA9PiAoeShtYXhZIC0gZCkgKyAuMSAqIHkoZCkpIC0gKHkobWF4WSAtIGQpIC0gLjEgKiB5KGQpKSlcbiAgICAgICAgICAgICAgICAuYXR0cihcImZpbGxcIiwgXCJzaWx2ZXJcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvL2lmIHN0YXRlbWVudCBmb3Igc3RhYmlsaXR5IGhpc3RvZ3JhbXNcbiAgICAgICAgLy9leHRyYSBzdGFiaWxpdHkgYmluXG4gICAgICAgIGlmIChub2RlLnN0YWJpbGl0eUJpbikge1xuICAgICAgICAgICAgcGxvdHN2Zy5hcHBlbmQoXCJyZWN0XCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIHgobWF4WCArIDAuNSAtIGJhclBhZGRpbmcpKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieVwiLCB5KG1heFkpIC0gbm9kZS5zdGFiaWxpdHlCaW4pXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCByZWN0V2lkdGgpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgbm9kZS5zdGFiaWxpdHlCaW4pXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJmaWxsXCIsIFwic2lsdmVyXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy90aHJlc2hvbGQgbGluZVxuICAgICAgICBpZiAobm9kZS50aHJlc2hvbGQpIHtcbiAgICAgICAgICAgIHBsb3RzdmcuYXBwZW5kKFwibGluZVwiKVxuICAgICAgICAgICAgICAgIC5zdHlsZShcInN0cm9rZVwiLCBcImJsYWNrXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ4MVwiLCB4KG1pblggLSAwLjUgKyBiYXJQYWRkaW5nKSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInkxXCIsIHkobWF4WSkgLSBub2RlLnRocmVzaG9sZClcbiAgICAgICAgICAgICAgICAuYXR0cihcIngyXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInN0YWJpbGl0eUJpblwiKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2cobm9kZS5zdGFiaWxpdHlCaW4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5zdGFiaWxpdHlCaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB4KG1heFggKyAwLjUgLSBiYXJQYWRkaW5nKSArIHJlY3RXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB4KG1heFggKyAwLjUgLSBiYXJQYWRkaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ5MlwiLCB5KG1heFkpIC0gbm9kZS50aHJlc2hvbGQpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocGxvdFhheGlzKSB7XG4gICAgICAgIHBsb3RzdmcuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInggYXhpc1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCxcIiArIGhlaWdodCArIFwiKVwiKVxuICAgICAgICAgICAgLmNhbGwoeEF4aXMpO1xuICAgIH1cblxuICAgIHBsb3RzdmcuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAuYXR0cihcInhcIiwgKHdpZHRoIC8gMikpXG4gICAgICAgIC5hdHRyKFwieVwiLCAwIC0gKG1hcmdpbi50b3AgLyAyKSlcbiAgICAgICAgLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKVxuICAgICAgICAuc3R5bGUoXCJmb250LXNpemVcIiwgXCIxMnB4XCIpXG4gICAgICAgIC50ZXh0KG5vZGUubmFtZSk7XG5cbiAgICBpZiAobXlkaXYgPT0gXCIjc2V0eExlZnRcIikge1xuICAgICAgICBwbG90c3ZnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgXCJyYW5nZVwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIDI1KVxuICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIGhlaWdodCArIDQwKVxuICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubmF0dXJlID09PSBcIm5vbWluYWxcIikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IE1hdGgucm91bmQoeVZhbEtleS5sZW5ndGggLyAyKSAtIDE7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoXCJ4OiBcIiArIHlWYWxLZXlbdF0ueCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcIng6IFwiLmNvbmNhdCgoK25vZGUubWVhbikudG9QcmVjaXNpb24oNCkudG9TdHJpbmcoKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHBsb3RzdmcuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBcInJhbmdlMlwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIDI1KVxuICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIGhlaWdodCArIDUwKVxuICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubmF0dXJlID09PSBcIm5vbWluYWxcIikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IE1hdGgucm91bmQoeVZhbEtleS5sZW5ndGggLyAyKSAtIDE7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoXCJ4MTogXCIgKyB5VmFsS2V5W3RdLngpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoXCJ4MTogXCIuY29uY2F0KCgrbm9kZS5tZWFuKS50b1ByZWNpc2lvbig0KS50b1N0cmluZygpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gY3JlYXRlIHRpY2sgbWFya3MgYXQgYWxsIHpzY29yZXMgaW4gdGhlIGJvdW5kcyBvZiB0aGUgZGF0YVxuICAgICAgICB2YXIgbGluZUZ1bmN0aW9uID0gZDMuc3ZnLmxpbmUoKVxuICAgICAgICAgICAgLngoZCA9PiBkLngpXG4gICAgICAgICAgICAueShkID0+IGQueSlcbiAgICAgICAgICAgIC5pbnRlcnBvbGF0ZShcImxpbmVhclwiKTtcblxuICAgICAgICB2YXIgY29sU2VxID0gW1wiI0EyQ0Q1QVwiLCBcIm9yYW5nZVwiLCBcInJlZFwiXTsgLy8gd2lsbCBjeWNsZSB0aHJvdWdoIGNvbG9yIHNlcXVlbmNlLCBhbmQgdGhlbiByZXBlYXQgbGFzdCBjb2xvclxuICAgICAgICB2YXIgbGluZURhdGEgPSBuZXcgQXJyYXk7XG5cbiAgICAgICAgdmFyIHpMb3dlciA9IC0xICogKG1pblggLSBub2RlLm1lYW4pIC8gbm9kZS5zZDsgLy8genNjb3JlIG9mIGxvd2VyIGJvdW5kXG4gICAgICAgIHZhciB6VXBwZXIgPSAobWF4WCAtIG5vZGUubWVhbikgLyBub2RlLnNkOyAvLyB6c2NvcmUgb2YgdXBwZXIgYm91bmRcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHpVcHBlcjsgaSsrKSB7XG4gICAgICAgICAgICBsaW5lRGF0YSA9IFt7XG4gICAgICAgICAgICAgICAgXCJ4XCI6IHgoK25vZGUubWVhbiArIGkgKiBub2RlLnNkKSxcbiAgICAgICAgICAgICAgICBcInlcIjogaGVpZ2h0ICogLjdcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBcInhcIjogeCgrbm9kZS5tZWFuICsgaSAqIG5vZGUuc2QpLFxuICAgICAgICAgICAgICAgIFwieVwiOiBoZWlnaHQgKiAuOVxuICAgICAgICAgICAgfV07XG4gICAgICAgICAgICBwbG90c3ZnLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImRcIiwgbGluZUZ1bmN0aW9uKFtsaW5lRGF0YVswXSwgbGluZURhdGFbMV1dKSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInN0cm9rZVwiLCBjb2xTZXFbZDMubWluKFtpLCBjb2xTZXEubGVuZ3RoIC0gMV0pXSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInN0cm9rZS13aWR0aFwiLCAxLjUpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJmaWxsXCIsIFwibm9uZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgekxvd2VyOyBpKyspIHtcbiAgICAgICAgICAgIGxpbmVEYXRhID0gW3tcbiAgICAgICAgICAgICAgICBcInhcIjogeCgrbm9kZS5tZWFuIC0gaSAqIG5vZGUuc2QpLFxuICAgICAgICAgICAgICAgIFwieVwiOiBoZWlnaHQgKiAuN1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIFwieFwiOiB4KCtub2RlLm1lYW4gLSBpICogbm9kZS5zZCksXG4gICAgICAgICAgICAgICAgXCJ5XCI6IGhlaWdodCAqIC45XG4gICAgICAgICAgICB9XTtcbiAgICAgICAgICAgIHBsb3RzdmcuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiZFwiLCBsaW5lRnVuY3Rpb24oW2xpbmVEYXRhWzBdLCBsaW5lRGF0YVsxXV0pKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwic3Ryb2tlXCIsIGNvbFNlcVtkMy5taW4oW2ksIGNvbFNlcS5sZW5ndGggLSAxXSldKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwic3Ryb2tlLXdpZHRoXCIsIDEuNSlcbiAgICAgICAgICAgICAgICAuYXR0cihcImZpbGxcIiwgXCJub25lXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IGQzLm1pbih4VmFscyk7IGkgPD0gZDMubWF4KHhWYWxzKTsgaSsrKSB7XG4gICAgICAgICAgICBsaW5lRGF0YSA9IFt7XG4gICAgICAgICAgICAgICAgXCJ4XCI6IHgoaSksXG4gICAgICAgICAgICAgICAgXCJ5XCI6IGhlaWdodCAqIC43NVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIFwieFwiOiB4KGkpLFxuICAgICAgICAgICAgICAgIFwieVwiOiBoZWlnaHQgKiAuODVcbiAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgcGxvdHN2Zy5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJkXCIsIGxpbmVGdW5jdGlvbihbbGluZURhdGFbMF0sIGxpbmVEYXRhWzFdXSkpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJzdHJva2VcIiwgXCJibGFja1wiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwic3Ryb2tlLXdpZHRoXCIsIDEpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJmaWxsXCIsIFwibm9uZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGluaXRpYWxpemUgc2xpZGVyIGNvbXBvbmVudHNcbiAgICAgICAgdmFyIHNsaWRlQm94ID0gcGxvdHN2Zy5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwieCBheGlzXCIpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLFwiICsgaGVpZ2h0ICogLjggKyBcIilcIilcbiAgICAgICAgICAgIC5jYWxsKGQzLnN2Zy5heGlzKClcbiAgICAgICAgICAgICAgICAgIC5zY2FsZSh4KVxuICAgICAgICAgICAgICAgICAgLnRpY2tzKDApXG4gICAgICAgICAgICAgICAgICAub3JpZW50KFwiYm90dG9tXCIpKTtcblxuICAgICAgICB2YXIgc2xpZGVyID0gcGxvdHN2Zy5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwic2xpZGVyXCIpXG4gICAgICAgICAgICAuY2FsbChicnVzaCk7XG4gICAgICAgIHZhciBzbGlkZXIyID0gcGxvdHN2Zy5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwic2xpZGVyXCIpXG4gICAgICAgICAgICAuY2FsbChicnVzaDIpO1xuXG4gICAgICAgIGxldCBwb2ludHMgPSBpID0+IGQgPT4ge1xuICAgICAgICAgICAgbGV0IHhubSwgcyA9IDY7XG4gICAgICAgICAgICBpZiAobm9kZS5zZXR4dmFsc1tpXSA9PSAnJykge1xuICAgICAgICAgICAgICAgIC8vIGlmIG5vbWluYWwsIHVzZSB0aGUgbWVkaWFuIGZyZXF1ZW5jeSBhcyB0aGUgcG9zaXRpb24gZm9yIHRoZSBzZXR4IHNsaWRlclxuICAgICAgICAgICAgICAgIHhubSA9IG5vZGUubmF0dXJlID09ICdub21pbmFsJyA/IHgoTWF0aC5yb3VuZCh4VmFscy5sZW5ndGggLyAyKSAtIDEpIDogeChub2RlLm1lYW4pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB4bm0gPSB4KG5vZGUuc2V0eHZhbHNbaV0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBgJHt4bm0gLSBzfSwkey1zfSAke3hubSArIHN9LCR7LXN9ICR7eG5tfSwke3MgKiAxLjN9YDtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGhhbmRsZSA9IHNsaWRlci5hcHBlbmQoXCJwb2x5Z29uXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiaGFuZGxlXCIpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLFwiICsgaGVpZ2h0ICogLjcgKyBcIilcIilcbiAgICAgICAgICAgIC5hdHRyKFwicG9pbnRzXCIsIHBvaW50cygwKSk7XG4gICAgICAgIHZhciBoYW5kbGUyID0gc2xpZGVyMi5hcHBlbmQoXCJwb2x5Z29uXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiaGFuZGxlXCIpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLFwiICsgaGVpZ2h0ICogLjkgKyBcIilcIilcbiAgICAgICAgICAgIC5hdHRyKFwicG9pbnRzXCIsIHBvaW50cygxKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHdvU0YoeCkge1xuICAgICAgICB2YXIgdHNmID0gZDMuZm9ybWF0KFwiLjJyXCIpOyAvLyBmb3JtYXQgdG8gdHdvIHNpZ25pZmljYW50IGZpZ3VyZXMgYWZ0ZXIgdGhlIGRlY2ltYWwgcGxhY2VcbiAgICAgICAgcmV0dXJuIHRzZih4KS5yZXBsYWNlKC8wKyQvLCBcIlwiKS5yZXBsYWNlKC9cXC4kLywgXCJcIik7IC8vIHRyaW0gdHJhaWxpbmcgemVyb3MgYWZ0ZXIgYSBwZXJpb2QsIGFuZCBhbnkgb3JwaGFuZWQgcGVyaW9kXG4gICAgfVxuXG4gICAgLy8gYnJ1c2hpbmcgZnVuY3Rpb25zXG4gICAgZnVuY3Rpb24gYnJ1c2hlZCgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYnJ1c2guZXh0ZW50KClbMF07XG4gICAgICAgIHZhciBzID0gNjtcblxuICAgICAgICBpZiAoZDMuZXZlbnQuc291cmNlRXZlbnQpIHtcbiAgICAgICAgICAgIHZhbHVlID0geC5pbnZlcnQoZDMubW91c2UodGhpcylbMF0pO1xuICAgICAgICAgICAgYnJ1c2guZXh0ZW50KFt2YWx1ZSwgdmFsdWVdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldCB4IHBvc2l0aW9uIG9mIHNsaWRlciBjZW50ZXJcbiAgICAgICAgdmFyIHhwb3MgPSB4KHZhbHVlKTtcbiAgICAgICAgaWYgKHZhbHVlID4gbWF4WCkgeyAvLyBkcmFnZ2VkIHBhc3QgbWF4XG4gICAgICAgICAgICB4cG9zID0geChtYXhYKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA8IG1pblgpIHsgLy8gZHJhZ2dlZCBwYXN0IG1pblxuICAgICAgICAgICAgeHBvcyA9IHgobWluWCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbSA9ICtub2RlLm1lYW47XG4gICAgICAgICAgICB2YXIgc2QgPSArbm9kZS5zZDtcbiAgICAgICAgICAgIHZhciB6U2NvcmUgPSAodmFsdWUgLSBtKSAvIHNkOyAvLyB6LXNjb3JlXG4gICAgICAgICAgICB2YXIgelJvdW5kID0gTWF0aC5yb3VuZCh6U2NvcmUpOyAvLyBuZWFyZXN0IGludGVnZXIgei1zY29yZVxuICAgICAgICAgICAgaWYgKC4xID4gTWF0aC5hYnMoTWF0aC5yb3VuZCh2YWx1ZSkgLSB2YWx1ZSkpIHsgLy8gc25hcCB0byBpbnRlZ2VyXG4gICAgICAgICAgICAgICAgeHBvcyA9IHgoTWF0aC5yb3VuZCh2YWx1ZSkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICguMSA+IE1hdGguYWJzKHpSb3VuZCAtIHpTY29yZSkpIHsgLy8gc25hcCB0byBpbnRlZ2VyIHotc2NvcmVcbiAgICAgICAgICAgICAgICB4cG9zID0geChtICsgKHpSb3VuZCAqIHNkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjcmVhdGUgc2xpZGVyIHN5bWJvbCBhbmQgdGV4dFxuICAgICAgICBoYW5kbGUuYXR0cihcInBvaW50c1wiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICByZXR1cm4gKHhwb3MgLSBzKSArIFwiLFwiICsgKC1zKSArIFwiIFwiICsgKHhwb3MgKyBzKSArIFwiLFwiICsgKC1zKSArIFwiIFwiICsgeHBvcyArIFwiLFwiICsgKHMgKiAxLjMpO1xuICAgICAgICB9KTtcbiAgICAgICAgcGxvdHN2Zy5zZWxlY3QoXCJ0ZXh0I3JhbmdlXCIpXG4gICAgICAgICAgICAudGV4dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5uYXR1cmUgPT09IFwibm9taW5hbFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoXCJ4OiBcIiArIHlWYWxLZXlbTWF0aC5yb3VuZChpbnZ4KHhwb3MpKV0ueCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcIng6IFwiLmNvbmNhdCgrKGludngoeHBvcykpLnRvUHJlY2lzaW9uKDQpLnRvU3RyaW5nKCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgbm9kZS5zZXR4dmFsc1swXSA9ICsoaW52eCh4cG9zKSkudG9QcmVjaXNpb24oNCk7XG4gICAgfVxuXG4gICAgLy8gY2VydGFpbmx5IGEgbW9yZSBjbGV2ZXIgd2F5IHRvIGRvIHRoaXMsIGJ1dCBmb3Igbm93IGl0J3MgYmFzaWNhbGx5IGNvcGllZCB3aXRoIGJydXNoIGFuZCBoYW5kbGUgY2hhbmdlcyB0byBicnVzaDIgYW5kIGhhbmRsZTIgYW5kICNyYW5nZSB0byAjcmFuZ2UyIGFuZCBzZXR4dmFsc1swXSB0byBzZXR4dmFsc1sxXVxuICAgIGZ1bmN0aW9uIGJydXNoZWQyKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBicnVzaDIuZXh0ZW50KClbMF07XG4gICAgICAgIHZhciBzID0gNjsgLy8gc2NhbGluZyBmb3IgdHJpYW5nbGUgc2hhcGVcblxuICAgICAgICBpZiAoZDMuZXZlbnQuc291cmNlRXZlbnQpIHtcbiAgICAgICAgICAgIHZhbHVlID0geC5pbnZlcnQoZDMubW91c2UodGhpcylbMF0pO1xuICAgICAgICAgICAgYnJ1c2gyLmV4dGVudChbdmFsdWUsIHZhbHVlXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgeCBwb3NpdGlvbiBvZiBzbGlkZXIgY2VudGVyXG4gICAgICAgIHZhciB4cG9zID0geCh2YWx1ZSk7XG4gICAgICAgIGlmICh2YWx1ZSA+IG1heFgpIHsgLy8gZHJhZ2dlZCBwYXN0IG1heFxuICAgICAgICAgICAgeHBvcyA9IHgobWF4WCk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPCBtaW5YKSB7IC8vIGRyYWdnZWQgcGFzdCBtaW5cbiAgICAgICAgICAgIHhwb3MgPSB4KG1pblgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG0gPSArbm9kZS5tZWFuO1xuICAgICAgICAgICAgdmFyIHNkID0gK25vZGUuc2Q7XG4gICAgICAgICAgICB2YXIgelNjb3JlID0gKHZhbHVlIC0gbSkgLyBzZDsgLy8gei1zY29yZVxuICAgICAgICAgICAgdmFyIHpSb3VuZCA9IE1hdGgucm91bmQoelNjb3JlKTsgLy8gbmVhcmVzdCBpbnRlZ2VyIHotc2NvcmVcbiAgICAgICAgICAgIGlmICguMSA+IE1hdGguYWJzKE1hdGgucm91bmQodmFsdWUpIC0gdmFsdWUpKSB7IC8vIHNuYXAgdG8gaW50ZWdlclxuICAgICAgICAgICAgICAgIHhwb3MgPSB4KE1hdGgucm91bmQodmFsdWUpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoLjEgPiBNYXRoLmFicyh6Um91bmQgLSB6U2NvcmUpKSB7IC8vIHNuYXAgdG8gaW50ZWdlciB6LXNjb3JlXG4gICAgICAgICAgICAgICAgeHBvcyA9IHgobSArICh6Um91bmQgKiBzZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JlYXRlIHNsaWRlciBzeW1ib2wgYW5kIHRleHRcbiAgICAgICAgaGFuZGxlMi5hdHRyKFwicG9pbnRzXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHJldHVybiAoeHBvcyAtIHMpICsgXCIsXCIgKyBzICsgXCIgXCIgKyAoeHBvcyArIHMpICsgXCIsXCIgKyBzICsgXCIgXCIgKyB4cG9zICsgXCIsXCIgKyAoLXMgKiAxLjMpO1xuICAgICAgICB9KTtcbiAgICAgICAgcGxvdHN2Zy5zZWxlY3QoXCJ0ZXh0I3JhbmdlMlwiKVxuICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubmF0dXJlID09PSBcIm5vbWluYWxcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFwieDE6IFwiICsgeVZhbEtleVtNYXRoLnJvdW5kKGludngoeHBvcykpXS54KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFwieDE6IFwiLmNvbmNhdCgrKGludngoeHBvcykpLnRvUHJlY2lzaW9uKDQpLnRvU3RyaW5nKCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgbm9kZS5zZXR4dmFsc1sxXSA9ICsoaW52eCh4cG9zKSkudG9QcmVjaXNpb24oNCk7XG4gICAgfVxufVxuXG4vLyBkcmF3cyBiYXJwbG90cyBpbiBzdWJzZXQgdGFiXG5leHBvcnQgZnVuY3Rpb24gYmFyc1N1YnNldChub2RlKSB7XG4gICAgLy8gaWYgdW50b3VjaGVkLCBzZXQgbm9kZS5zdWJzZXRyYW5nZSB0byBhbiBlbXB0eSBhcnJheSwgbWVhbmluZyBhbGwgdmFsdWVzIHNlbGVjdGVkIGJ5IGRlZmF1bHRcbiAgICBpZiAobm9kZS5zdWJzZXRyYW5nZVswXSA9PSBcIlwiICYgbm9kZS5zdWJzZXRyYW5nZVsxXSA9PSBcIlwiKSB7XG4gICAgICAgIG5vZGUuc3Vic2V0cmFuZ2UgPSBbXTtcbiAgICB9XG5cbiAgICAvLyBIaXN0b2dyYW0gc3BhY2luZ1xuICAgIHZhciBiYXJQYWRkaW5nID0gLjAxNTsgLy8gU3BhY2UgYmV0d2VlbiBiYXJzXG4gICAgdmFyIHRvcFNjYWxlID0gMS4yOyAvLyBNdWx0aXBsaWNhdGl2ZSBmYWN0b3IgdG8gYXNzaWduIHNwYWNlIGF0IHRvcCB3aXRoaW4gZ3JhcGggLSBjdXJyZW50bHkgcmVtb3ZlZCBmcm9tIGltcGxlbWVudGF0aW9uXG4gICAgdmFyIHBsb3RYYXhpcyA9IHRydWU7XG5cbiAgICAvLyBWYXJpYWJsZSBuYW1lXG4gICAgdmFyIG15bmFtZSA9IG5vZGUubmFtZS50b1N0cmluZygpO1xuICAgIG15bmFtZSA9IG15bmFtZS5yZXBsYWNlKC9cXCh8XFwpL2csIFwiXCIpO1xuXG4gICAgLy8gRGF0YVxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMobm9kZS5wbG90dmFsdWVzKTtcbiAgICB2YXIgeVZhbHMgPSBuZXcgQXJyYXk7XG4gICAgdmFyIHhWYWxzID0gbmV3IEFycmF5O1xuICAgIHZhciB5VmFsS2V5ID0gbmV3IEFycmF5O1xuXG4gICAgdmFyIHhpID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKG5vZGUucGxvdHZhbHVlc1trZXlzW2ldXSA9PSAwKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIHlWYWxzW3hpXSA9IG5vZGUucGxvdHZhbHVlc1trZXlzW2ldXTtcbiAgICAgICAgeFZhbHNbeGldID0geGk7XG4gICAgICAgIHlWYWxLZXkucHVzaCh7XG4gICAgICAgICAgICB5OiB5VmFsc1t4aV0sXG4gICAgICAgICAgICB4OiBrZXlzW2ldXG4gICAgICAgIH0pO1xuICAgICAgICB4aSA9IHhpICsgMTtcbiAgICB9XG4gICAgaWYgKG5vZGUubmF0dXJlID09PSBcIm5vbWluYWxcIikgeyAvLyBpZiBub21pbmFsLCBvcmRlcnMgYmFycyBsZWZ0IHRvIHJpZ2h0LCBoaWdoZXN0IGZyZXF1ZW5jeSB0byBsb3dlc3RcbiAgICAgICAgeVZhbEtleS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBiLnkgLSBhLnlcbiAgICAgICAgfSk7IC8vIGFycmF5IG9mIG9iamVjdHMsIGVhY2ggb2JqZWN0IGhhcyB5LCB0aGUgc2FtZSBhcyB5VmFscywgYW5kIHgsIHRoZSBjYXRlZ29yeVxuICAgICAgICB5VmFscy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBiIC0gYVxuICAgICAgICB9KTsgLy8gYXJyYXkgb2YgeSB2YWx1ZXMsIHRoZSBoZWlnaHQgb2YgdGhlIGJhcnNcbiAgICB9XG5cbiAgICBwbG90WGF4aXMgPSBmYWxzZTtcblxuICAgIHZhciBtYXhZID0gZDMubWF4KHlWYWxzKTtcbiAgICB2YXIgbWluWCA9IGQzLm1pbih4VmFscyk7XG4gICAgdmFyIG1heFggPSBkMy5tYXgoeFZhbHMpO1xuICAgIHZhciBnbmFtZSA9IFtcInN1YnNldHllc1wiLCBcInN1YnNldG5vXCJdO1xuXG4gICAgdmFyIHlWYWxzMiA9IFtdO1xuICAgIHZhciB5VmFsczEgPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgeVZhbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgeVZhbHMxLnB1c2goe1xuICAgICAgICAgICAgeTA6IG1heFkgLSB5VmFsc1tpXSxcbiAgICAgICAgICAgIHkxOiB5VmFsc1tpXSxcbiAgICAgICAgICAgIGNvbDogZDNDb2xvclxuICAgICAgICB9KTtcbiAgICAgICAgeVZhbHMyLnB1c2goe1xuICAgICAgICAgICAgeTA6IDAsXG4gICAgICAgICAgICB5MTogbWF4WSAtIHlWYWxzW2ldLFxuICAgICAgICAgICAgY29sOiBcInRyYW5zcGFyZW50XCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBmcmVxcyA9IFt5VmFsczEsIHlWYWxzMl07XG5cbiAgICAvLyB5MCBpcyB0aGUgc3RhcnRpbmcgcG9pbnRcbiAgICAvLyB5MSBpcyB0aGUgbGVuZ3RoIG9mIHRoZSBiYXJcblxuICAgIHZhciBteWRpdiA9IFwiI3RhYjJcIjtcbiAgICB2YXIgd2lkdGggPSAyMDA7XG4gICAgdmFyIGhlaWdodCA9IDEyMDtcbiAgICB2YXIgbWFyZ2luID0ge1xuICAgICAgICB0b3A6IDIwLFxuICAgICAgICByaWdodDogMjAsXG4gICAgICAgIGJvdHRvbTogNTMsXG4gICAgICAgIGxlZnQ6IDUwXG4gICAgfTtcblxuICAgIHZhciB4ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLmRvbWFpbihbbWluWCAtIDAuNSwgbWF4WCArIDAuNV0pXG4gICAgICAgIC5yYW5nZShbMCwgd2lkdGhdKTtcblxuICAgIHZhciBpbnZ4ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLnJhbmdlKFttaW5YIC0gMC41LCBtYXhYICsgMC41XSlcbiAgICAgICAgLmRvbWFpbihbMCwgd2lkdGhdKTtcblxuICAgIHZhciB5ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLmRvbWFpbihbMCwgbWF4WV0pXG4gICAgICAgIC5yYW5nZShbMCwgaGVpZ2h0XSk7XG5cbiAgICB2YXIgeEF4aXMgPSBkMy5zdmcuYXhpcygpXG4gICAgICAgIC5zY2FsZSh4KVxuICAgICAgICAudGlja3MoeVZhbHMubGVuZ3RoKVxuICAgICAgICAub3JpZW50KFwiYm90dG9tXCIpO1xuXG4gICAgdmFyIHlBeGlzID0gZDMuc3ZnLmF4aXMoKVxuICAgICAgICAuc2NhbGUoeSlcbiAgICAgICAgLm9yaWVudChcImxlZnRcIik7XG5cbiAgICAvL0NyZWF0ZSBTVkcgZWxlbWVudFxuICAgIHZhciBwbG90c3ZnID0gZDMuc2VsZWN0KG15ZGl2KVxuICAgICAgICAuYXBwZW5kKFwic3ZnXCIpXG4gICAgICAgIC5hdHRyKFwiaWRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gbXluYW1lLmNvbmNhdChcIl9cIiwgbXlkaXYuc3Vic3RyKDEpLCBcIl9cIiwgbm9kZS5pZCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5zdHlsZShcIndpZHRoXCIsIHdpZHRoICsgbWFyZ2luLmxlZnQgKyBtYXJnaW4ucmlnaHQpIC8vc2V0dGluZyBoZWlnaHQgdG8gdGhlIGhlaWdodCBvZiAjbWFpbi5sZWZ0XG4gICAgICAgIC5zdHlsZShcImhlaWdodFwiLCBoZWlnaHQgKyBtYXJnaW4udG9wICsgbWFyZ2luLmJvdHRvbSlcbiAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBtYXJnaW4ubGVmdCArIFwiLFwiICsgbWFyZ2luLnRvcCArIFwiKVwiKTtcblxuICAgIHZhciBmcmVxID0gcGxvdHN2Zy5zZWxlY3RBbGwoXCJnLmZyZXFcIilcbiAgICAgICAgLmRhdGEoZnJlcXMpXG4gICAgICAgIC5lbnRlcigpLmFwcGVuZChcImdcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImZyZXFcIilcbiAgICAgICAgLmF0dHIoXCJuYW1lXCIsIGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiBteW5hbWUuY29uY2F0KGduYW1lW2ldKTtcbiAgICAgICAgfSk7XG5cbiAgICB2YXIgcmVjdCA9IGZyZXEuc2VsZWN0QWxsKFwicmVjdFwiKVxuICAgICAgICAuZGF0YShPYmplY3QpXG4gICAgICAgIC5lbnRlcigpLmFwcGVuZChcInJlY3RcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImJhclwiKVxuICAgICAgICAuYXR0cihcIm5hbWVcIiwgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIHhWYWxzW2ldO1xuICAgICAgICB9KVxuICAgICAgICAuYXR0cihcInhcIiwgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIHgoeFZhbHNbaV0gLSAwLjUgKyBiYXJQYWRkaW5nKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoXCJ5XCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHJldHVybiB5KGQueTApO1xuICAgICAgICB9KVxuICAgICAgICAuYXR0cihcIndpZHRoXCIsIHgobWluWCArIDAuNSAtIDIgKiBiYXJQYWRkaW5nKSkgLy8gdGhlIFwid2lkdGhcIiBpcyB0aGUgY29vcmRpbmF0ZSBvZiB0aGUgZW5kIG9mIHRoZSBmaXJzdCBiYXJcbiAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgcmV0dXJuIHkoZC55MSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5zdHlsZShcImZpbGxcIiwgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgaWYgKG5vZGUuc3Vic2V0cmFuZ2UubGVuZ3RoID4gMCAmIGQuY29sID09PSBkM0NvbG9yICYgJC5pbkFycmF5KHhWYWxzW2ldLnRvU3RyaW5nKCksIG5vZGUuc3Vic2V0cmFuZ2UpID4gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsVmFyQ29sb3I7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBkLmNvbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0TWUgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHNlbGVjdE5hbWUgPSB0aGlzLmdldEF0dHJpYnV0ZShcIm5hbWVcIik7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnROb2RlLmdldEF0dHJpYnV0ZShcIm5hbWVcIikgPT0gbXluYW1lLmNvbmNhdChcInN1YnNldG5vXCIpKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0TWUgPSAkKCdbbmFtZT1cIicgKyBteW5hbWUuY29uY2F0KFwic3Vic2V0eWVzXCIpICsgJ1wiXScpLmNoaWxkcmVuKCdbbmFtZT1cIicgKyBzZWxlY3ROYW1lICsgJ1wiXScpWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZDMuc2VsZWN0KHNlbGVjdE1lKVxuICAgICAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbXlDb2wgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zdHlsZS5maWxsID09PSBzZWxWYXJDb2xvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG15aW5kZXggPSBub2RlLnN1YnNldHJhbmdlLmluZGV4T2YodGhpcy5nZXRBdHRyaWJ1dGUoXCJuYW1lXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc3Vic2V0cmFuZ2Uuc3BsaWNlKG15aW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbXlDb2wgPSBkM0NvbG9yO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5zdWJzZXRyYW5nZS5wdXNoKHRoaXMuZ2V0QXR0cmlidXRlKFwibmFtZVwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBteUNvbCA9IHNlbFZhckNvbG9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBteUNvbDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBsb3Rzdmcuc2VsZWN0KFwidGV4dCNzZWxlY3RyYW5nZVwiKVxuICAgICAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5zdWJzZXRyYW5nZS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcIlNlbGVjdGVkOiBhbGwgdmFsdWVzXCIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBub2RlLnN1YnNldHJhbmdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGVjdGVkcyA9IG5ldyBBcnJheTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGEuZm9yRWFjaChmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZHMucHVzaCh5VmFsS2V5W3ZhbF0ueCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcIlNlbGVjdGVkOiBcIiArIHNlbGVjdGVkcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICB9KVxuICAgICAgICAub24oXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaSA9IHRoaXMuZ2V0QXR0cmlidXRlKFwibmFtZVwiKTtcbiAgICAgICAgICAgIHBsb3Rzdmcuc2VsZWN0KFwidGV4dCNteW1vdXNlb3ZlclwiKVxuICAgICAgICAgICAgICAgIC50ZXh0KCgpID0+IHlWYWxLZXlbaV0ueCArIFwiOiBcIiArIHlWYWxLZXlbaV0ueSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbihcIm1vdXNlb3V0XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGkgPSB0aGlzLmdldEF0dHJpYnV0ZShcIm5hbWVcIik7XG4gICAgICAgICAgICBwbG90c3ZnLnNlbGVjdChcInRleHQjbXltb3VzZW92ZXJcIilcbiAgICAgICAgICAgICAgICAudGV4dCgoKSA9PiBcIlZhbHVlOiBGcmVxdWVuY3lcIik7XG4gICAgICAgIH0pO1xuXG4gICAgaWYgKHBsb3RYYXhpcykge1xuICAgICAgICBwbG90c3ZnLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJ4IGF4aXNcIilcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsXCIgKyBoZWlnaHQgKyBcIilcIilcbiAgICAgICAgICAgIC5jYWxsKHhBeGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBwbG90c3ZnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgXCJteW1vdXNlb3ZlclwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIDI1KVxuICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIGhlaWdodCArIDIwKVxuICAgICAgICAgICAgLnRleHQoKCkgPT4gXCJWYWx1ZTogRnJlcXVlbmN5XCIpO1xuICAgIH1cblxuICAgIHBsb3RzdmcuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAuYXR0cihcInhcIiwgKHdpZHRoIC8gMikpXG4gICAgICAgIC5hdHRyKFwieVwiLCAwIC0gKG1hcmdpbi50b3AgLyAyKSlcbiAgICAgICAgLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKVxuICAgICAgICAuc3R5bGUoXCJmb250LXNpemVcIiwgXCIxMnB4XCIpXG4gICAgICAgIC50ZXh0KG15bmFtZSk7XG5cbiAgICBwbG90c3ZnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgLmF0dHIoXCJpZFwiLCBcInNlbGVjdHJhbmdlXCIpXG4gICAgICAgIC5hdHRyKFwieFwiLCAyNSlcbiAgICAgICAgLmF0dHIoXCJ5XCIsIGhlaWdodCArIDQwKVxuICAgICAgICAudGV4dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAobm9kZS5zdWJzZXRyYW5nZS5sZW5ndGggPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJTZWxlY3RlZDogYWxsIHZhbHVlc1wiO1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkcyA9IG5ldyBBcnJheTtcbiAgICAgICAgICAgIG5vZGUuc3Vic2V0cmFuZ2UuZm9yRWFjaCh2YWwgPT4gIHNlbGVjdGVkcy5wdXNoKHlWYWxLZXlbdmFsXS54KSk7XG4gICAgICAgICAgICByZXR1cm4gXCJTZWxlY3RlZDogXCIgKyBzZWxlY3RlZHM7XG4gICAgICAgIH0pO1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBkZW5zaXR5Tm9kZShub2RlLCBvYmopIHtcbiAgICB2YXIgbXluYW1lID0gbm9kZS5uYW1lLnRvU3RyaW5nKCkuY29uY2F0KFwibm9kZXBsb3RcIik7XG5cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB2YXIgb2JqID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobm9kZS5uYW1lLnRvU3RyaW5nKCkgKyBcImJpZ2dyb3VwXCIpO1xuICAgICAgICAvLyBpZiBvYmogY29udGFpbnMgYW4gc3ZnIGVsZW1lbnQsIHJlbW92ZSBpdC4gdGhpcyByZW1vdmVzIGFueSBwbG90IGluc2lkZSB0aGUgbm9kZVxuICAgICAgICBpZiAoZDMuc2VsZWN0KG9iaikuc2VsZWN0QWxsKFwic3ZnXCIpWzBdLmxlbmd0aCA+IDApXG4gICAgICAgICAgICBkMy5zZWxlY3Qob2JqKS5zZWxlY3RBbGwoXCJzdmdcIikucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgdmFyIHlWYWxzID0gbm9kZS5wbG90eTtcbiAgICB2YXIgeFZhbHMgPSBub2RlLnBsb3R4O1xuICAgIC8vIGFycmF5IG9mIG9iamVjdHNcbiAgICBsZXQgZGF0YTIgPSBub2RlLnBsb3R4Lm1hcCgoeCwgaSkgPT4gKHt4OiAreCwgeTogK25vZGUucGxvdHlbaV19KSk7XG5cbiAgICB2YXIgd2lkdGggPSA2MDsgLy8gaGFyZGNvZGVkLCBzaG91bGQgYmUgc2V0IGF1dG9tYXRpY2FsbHlcbiAgICB2YXIgaGVpZ2h0ID0gMzA7XG4gICAgdmFyIG1hcmdpbiA9IHtcbiAgICAgICAgdG9wOiAyMCxcbiAgICAgICAgcmlnaHQ6IDEwLFxuICAgICAgICBib3R0b206IDUzLFxuICAgICAgICBsZWZ0OiAxMFxuICAgIH07XG5cbiAgICB2YXIgeCA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgIC5kb21haW4oW2QzLm1pbih4VmFscyksIGQzLm1heCh4VmFscyldKVxuICAgICAgICAucmFuZ2UoWzAsIHdpZHRoXSk7XG5cbiAgICB2YXIgeSA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgIC5kb21haW4oW2QzLm1pbih5VmFscyksIGQzLm1heCh5VmFscyldKVxuICAgICAgICAucmFuZ2UoW2hlaWdodCwgMF0pO1xuXG4gICAgdmFyIGFyZWEgPSBkMy5zdmcuYXJlYSgpXG4gICAgICAgIC5pbnRlcnBvbGF0ZShcIm1vbm90b25lXCIpXG4gICAgICAgIC54KGQgPT4geChkLngpKVxuICAgICAgICAueTAoaGVpZ2h0KVxuICAgICAgICAueTEoZCA9PiB5KGQueSkpO1xuXG4gICAgdmFyIHBsb3RzdmcgPSBkMy5zZWxlY3Qob2JqKVxuICAgICAgICAuaW5zZXJ0KFwic3ZnXCIsIFwiOmZpcnN0LWNoaWxkXCIpXG4gICAgICAgIC5hdHRyKFwieFwiLCAtNDApIC8vIE5PVEU6IE5vdCBzdXJlIGV4YWN0bHkgd2h5IHRoZXNlIG51bWJlcnMgd29yaywgYnV0IHRoZXNlIGhhcmRjb2RlZCB2YWx1ZXMgc2VlbSB0byBwb3NpdGlvbiB0aGUgcGxvdCBpbnNpZGUgZyBjb3JyZWN0bHkuICB0aGlzIHNob3VsZG4ndCBiZSBoYXJkY29kZWQgaW4gdGhlIGZ1dHVyZVxuICAgICAgICAuYXR0cihcInlcIiwgLTQ1KVxuICAgICAgICAuYXR0cihcImlkXCIsICgpID0+IG15bmFtZSlcbiAgICAgICAgLnN0eWxlKFwid2lkdGhcIiwgd2lkdGgpXG4gICAgICAgIC5zdHlsZShcImhlaWdodFwiLCBoZWlnaHQpXG4gICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgbWFyZ2luLmxlZnQgKyBcIixcIiArIG1hcmdpbi50b3AgKyBcIilcIik7XG5cbiAgICBwbG90c3ZnLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgLmRhdHVtKGRhdGEyKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiYXJlYVwiKVxuICAgICAgICAuYXR0cihcImRcIiwgYXJlYSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBiYXJzTm9kZShub2RlLCBvYmopIHtcbiAgICB2YXIgbXluYW1lID0gbm9kZS5uYW1lLnRvU3RyaW5nKCkuY29uY2F0KFwibm9kZXBsb3RcIik7XG5cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB2YXIgb2JqID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobm9kZS5uYW1lLnRvU3RyaW5nKCkgKyBcImJpZ2dyb3VwXCIpO1xuICAgICAgICAvLyBpZiBvYmogY29udGFpbnMgYW4gc3ZnIGVsZW1lbnQsIHJlbW92ZSBpdC4gdGhpcyByZW1vdmVzIGFueSBwbG90IGluc2lkZSB0aGUgbm9kZVxuICAgICAgICBpZiAoZDMuc2VsZWN0KG9iaikuc2VsZWN0QWxsKFwic3ZnXCIpWzBdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGQzLnNlbGVjdChvYmopLnNlbGVjdEFsbChcInN2Z1wiKS5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEhpc3RvZ3JhbSBzcGFjaW5nXG4gICAgdmFyIGJhclBhZGRpbmcgPSAuMDE1OyAvLyBTcGFjZSBiZXR3ZWVuIGJhcnNcbiAgICB2YXIgdG9wU2NhbGUgPSAxLjI7IC8vIE11bHRpcGxpY2F0aXZlIGZhY3RvciB0byBhc3NpZ24gc3BhY2UgYXQgdG9wIHdpdGhpbiBncmFwaCAtIGN1cnJlbnRseSByZW1vdmVkIGZyb20gaW1wbGVtZW50YXRpb25cblxuICAgIC8vIERhdGFcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG5vZGUucGxvdHZhbHVlcyk7XG4gICAgdmFyIHlWYWxzID0gbmV3IEFycmF5O1xuICAgIHZhciB4VmFscyA9IG5ldyBBcnJheTtcbiAgICB2YXIgeVZhbEtleSA9IG5ldyBBcnJheTtcblxuICAgIGlmIChub2RlLm5hdHVyZSA9PT0gXCJub21pbmFsXCIpIHtcbiAgICAgICAgdmFyIHhpID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5wbG90dmFsdWVzW2tleXNbaV1dID09IDApXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB5VmFsc1t4aV0gPSBub2RlLnBsb3R2YWx1ZXNba2V5c1tpXV07XG4gICAgICAgICAgICB4VmFsc1t4aV0gPSB4aTtcbiAgICAgICAgICAgIHlWYWxLZXkucHVzaCh7eTogeVZhbHNbeGldLCB4OiBrZXlzW2ldfSk7XG4gICAgICAgICAgICB4aSA9IHhpICsgMTtcbiAgICAgICAgfVxuICAgICAgICB5VmFsS2V5LnNvcnQoKGEsIGIpID0+IGIueSAtIGEueSk7IC8vIGFycmF5IG9mIG9iamVjdHMsIGVhY2ggb2JqZWN0IGhhcyB5LCB0aGUgc2FtZSBhcyB5VmFscywgYW5kIHgsIHRoZSBjYXRlZ29yeVxuICAgICAgICB5VmFscy5zb3J0KChhLCBiKSA9PiBiIC0gYSk7IC8vIGFycmF5IG9mIHkgdmFsdWVzLCB0aGUgaGVpZ2h0IG9mIHRoZSBiYXJzXG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB5VmFsc1tpXSA9IG5vZGUucGxvdHZhbHVlc1trZXlzW2ldXTtcbiAgICAgICAgICAgIHhWYWxzW2ldID0gTnVtYmVyKGtleXNbaV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG1heFkgPSBkMy5tYXgoeVZhbHMpO1xuICAgIHZhciBtaW5YID0gZDMubWluKHhWYWxzKTtcbiAgICB2YXIgbWF4WCA9IGQzLm1heCh4VmFscyk7XG5cbiAgICB2YXIgd2lkdGggPSA2MDtcbiAgICB2YXIgaGVpZ2h0ID0gMzA7XG4gICAgdmFyIG1hcmdpbiA9IHtcbiAgICAgICAgdG9wOiAyMCxcbiAgICAgICAgcmlnaHQ6IDEwLFxuICAgICAgICBib3R0b206IDUzLFxuICAgICAgICBsZWZ0OiAxMFxuICAgIH07XG5cbiAgICB2YXIgeCA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgIC5kb21haW4oW21pblggLSAwLjUsIG1heFggKyAwLjVdKVxuICAgICAgICAucmFuZ2UoWzAsIHdpZHRoXSk7XG5cbiAgICB2YXIgaW52eCA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgIC5yYW5nZShbbWluWCAtIDAuNSwgbWF4WCArIDAuNV0pXG4gICAgICAgIC5kb21haW4oWzAsIHdpZHRoXSk7XG5cbiAgICB2YXIgeSA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgIC5kb21haW4oWzAsIG1heFldKVxuICAgICAgICAucmFuZ2UoWzAsIGhlaWdodF0pO1xuXG4gICAgLy9DcmVhdGUgU1ZHIGVsZW1lbnRcbiAgICB2YXIgcGxvdHN2ZyA9IGQzLnNlbGVjdChvYmopXG4gICAgICAgIC5pbnNlcnQoXCJzdmdcIiwgXCI6Zmlyc3QtY2hpbGRcIilcbiAgICAgICAgLmF0dHIoXCJ4XCIsIC00MClcbiAgICAgICAgLmF0dHIoXCJ5XCIsIC00NSlcbiAgICAgICAgLmF0dHIoXCJpZFwiLCAoKSA9PiBteW5hbWUpXG4gICAgICAgIC5zdHlsZShcIndpZHRoXCIsIHdpZHRoKSAvLyBzZXQgaGVpZ2h0IHRvIHRoZSBoZWlnaHQgb2YgI21haW4ubGVmdFxuICAgICAgICAuc3R5bGUoXCJoZWlnaHRcIiwgaGVpZ2h0KVxuICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIG1hcmdpbi5sZWZ0ICsgXCIsXCIgKyBtYXJnaW4udG9wICsgXCIpXCIpO1xuXG4gICAgcGxvdHN2Zy5zZWxlY3RBbGwoXCJyZWN0XCIpXG4gICAgICAgIC5kYXRhKHlWYWxzKVxuICAgICAgICAuZW50ZXIoKVxuICAgICAgICAuYXBwZW5kKFwicmVjdFwiKVxuICAgICAgICAuYXR0cihcInhcIiwgKGQsIGkpID0+ICB4KHhWYWxzW2ldIC0gMC41ICsgYmFyUGFkZGluZykpXG4gICAgICAgIC5hdHRyKFwieVwiLCBkID0+ICB5KG1heFkgLSBkKSlcbiAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCB4KG1pblggKyAwLjUgLSAyICogYmFyUGFkZGluZykpIC8vIHRoZSBcIndpZHRoXCIgaXMgdGhlIGNvb3JkaW5hdGUgb2YgdGhlIGVuZCBvZiB0aGUgZmlyc3QgYmFyXG4gICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIHkpXG4gICAgICAgIC5hdHRyKFwiZmlsbFwiLCBcIiMxZjc3YjRcIik7XG59XG5cblxuXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9hc3NldHMvYXBwL3Bsb3RzLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2\n')},function(module,exports){eval('var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function("return this")() || (1,eval)("this");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === "object")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it\'s\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzPzM2OTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUMiLCJmaWxlIjoiMy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBnO1xyXG5cclxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcclxuZyA9IChmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufSkoKTtcclxuXHJcbnRyeSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXHJcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLGV2YWwpKFwidGhpc1wiKTtcclxufSBjYXRjaChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZih0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKVxyXG5cdFx0ZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3\n')},function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.getClasses = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mithril = __webpack_require__(0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _app = __webpack_require__(1);\n\nvar app = _interopRequireWildcard(_app);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar getClasses = exports.getClasses = function getClasses(cls, panel) {\n    return cls + (panel.closed ? '.closepanel' : panel.side === 'left' && app.lefttab === 'tab2' ? '.expandpanel' : '');\n};\n\nvar Panel = function () {\n    function Panel() {\n        _classCallCheck(this, Panel);\n    }\n\n    _createClass(Panel, [{\n        key: 'oninit',\n        value: function oninit(vnode) {\n            this.closed = false;\n        }\n    }, {\n        key: 'view',\n        value: function view(vnode) {\n            var _this = this;\n\n            var _vnode$attrs = vnode.attrs,\n                side = _vnode$attrs.side,\n                title = _vnode$attrs.title;\n\n            var dot = [_mithril2.default.trust('&#9679;'), (0, _mithril2.default)('br')];\n            return (0, _mithril2.default)(getClasses('#' + side + 'panel.sidepanel.container.clearfix', this), (0, _mithril2.default)('#toggle' + (side === 'left' ? 'L' : 'R') + 'panelicon.panelbar[style=height: 100%]', (0, _mithril2.default)('span', { onclick: function onclick(_) {\n                    return _this.closed = !_this.closed;\n                } }, dot, dot, dot, dot)), (0, _mithril2.default)('#' + side + 'paneltitle.panel-heading.text-center', (0, _mithril2.default)(\"h3.panel-title\", title)), vnode.children[0], (0, _mithril2.default)(getClasses('.row-fluid', this), (0, _mithril2.default)('#' + side + 'panelcontent', (0, _mithril2.default)('#' + side + 'ContentArea[style=height: calc(100vh - 210px); overflow: auto]', vnode.children.slice(1)))));\n        }\n    }]);\n\n    return Panel;\n}();\n\nexports.default = Panel;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvYXBwL3ZpZXdzL1BhbmVsLmpzPzkyNGYiXSwibmFtZXMiOlsiYXBwIiwiZ2V0Q2xhc3NlcyIsImNscyIsInBhbmVsIiwiY2xvc2VkIiwic2lkZSIsImxlZnR0YWIiLCJQYW5lbCIsInZub2RlIiwiYXR0cnMiLCJ0aXRsZSIsImRvdCIsInRydXN0Iiwib25jbGljayIsImNoaWxkcmVuIiwic2xpY2UiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOzs7O0FBRUE7O0lBQVlBLEc7Ozs7Ozs7O0FBRUwsSUFBSUMsa0NBQWEsU0FBYkEsVUFBYSxDQUFTQyxHQUFULEVBQWNDLEtBQWQsRUFBcUI7QUFDekMsV0FBT0QsT0FBT0MsTUFBTUMsTUFBTixHQUFlLGFBQWYsR0FDVEQsTUFBTUUsSUFBTixLQUFlLE1BQWYsSUFBeUJMLElBQUlNLE9BQUosS0FBZ0IsTUFBMUMsR0FBb0QsY0FBcEQsR0FDQSxFQUZHLENBQVA7QUFHSCxDQUpNOztJQU1EQyxLOzs7Ozs7OytCQUNLQyxLLEVBQU87QUFDVixpQkFBS0osTUFBTCxHQUFjLEtBQWQ7QUFDSDs7OzZCQUVJSSxLLEVBQU87QUFBQTs7QUFBQSwrQkFDWUEsTUFBTUMsS0FEbEI7QUFBQSxnQkFDSEosSUFERyxnQkFDSEEsSUFERztBQUFBLGdCQUNHSyxLQURILGdCQUNHQSxLQURIOztBQUVSLGdCQUFNQyxNQUFNLENBQUMsa0JBQUVDLEtBQUYsQ0FBUSxTQUFSLENBQUQsRUFBcUIsdUJBQUUsSUFBRixDQUFyQixDQUFaO0FBQ0EsbUJBQU8sdUJBQUVYLGlCQUFlSSxJQUFmLHlDQUF5RCxJQUF6RCxDQUFGLEVBQ0gsb0NBQVlBLFNBQVMsTUFBVCxHQUFrQixHQUFsQixHQUF3QixHQUFwQyw4Q0FDRSx1QkFBRSxNQUFGLEVBQVUsRUFBQ1EsU0FBUztBQUFBLDJCQUFLLE1BQUtULE1BQUwsR0FBYyxDQUFDLE1BQUtBLE1BQXpCO0FBQUEsaUJBQVYsRUFBVixFQUFzRE8sR0FBdEQsRUFBMkRBLEdBQTNELEVBQWdFQSxHQUFoRSxFQUFxRUEsR0FBckUsQ0FERixDQURHLEVBR0gsNkJBQU1OLElBQU4sMkNBQ0UsdUJBQUUsZ0JBQUYsRUFBb0JLLEtBQXBCLENBREYsQ0FIRyxFQUtIRixNQUFNTSxRQUFOLENBQWUsQ0FBZixDQUxHLEVBTUgsdUJBQUViLFdBQVcsWUFBWCxFQUF5QixJQUF6QixDQUFGLEVBQ0UsNkJBQU1JLElBQU4sbUJBQ0UsNkJBQU1BLElBQU4scUVBQTRFRyxNQUFNTSxRQUFOLENBQWVDLEtBQWYsQ0FBcUIsQ0FBckIsQ0FBNUUsQ0FERixDQURGLENBTkcsQ0FBUDtBQVNIOzs7Ozs7a0JBR1VSLEsiLCJmaWxlIjoiNC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuXG5pbXBvcnQgKiBhcyBhcHAgZnJvbSAnLi4vYXBwJztcblxuZXhwb3J0IGxldCBnZXRDbGFzc2VzID0gZnVuY3Rpb24oY2xzLCBwYW5lbCkge1xuICAgIHJldHVybiBjbHMgKyAocGFuZWwuY2xvc2VkID8gJy5jbG9zZXBhbmVsJyA6IFxuICAgICAgICAocGFuZWwuc2lkZSA9PT0gJ2xlZnQnICYmIGFwcC5sZWZ0dGFiID09PSAndGFiMicpID8gJy5leHBhbmRwYW5lbCcgOiBcbiAgICAgICAgJycpO1xufTtcblxuY2xhc3MgUGFuZWwge1xuICAgIG9uaW5pdCh2bm9kZSkge1xuICAgICAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZpZXcodm5vZGUpIHtcbiAgICAgICAgbGV0IHtzaWRlLCB0aXRsZX0gPSB2bm9kZS5hdHRycztcbiAgICAgICAgY29uc3QgZG90ID0gW20udHJ1c3QoJyYjOTY3OTsnKSwgbSgnYnInKV07IFxuICAgICAgICByZXR1cm4gbShnZXRDbGFzc2VzKGAjJHtzaWRlfXBhbmVsLnNpZGVwYW5lbC5jb250YWluZXIuY2xlYXJmaXhgLCB0aGlzKSxcbiAgICAgICAgICAgIG0oYCN0b2dnbGUke3NpZGUgPT09ICdsZWZ0JyA/ICdMJyA6ICdSJ31wYW5lbGljb24ucGFuZWxiYXJbc3R5bGU9aGVpZ2h0OiAxMDAlXWAsXG4gICAgICAgICAgICAgIG0oJ3NwYW4nLCB7b25jbGljazogXyA9PiB0aGlzLmNsb3NlZCA9ICF0aGlzLmNsb3NlZH0sIGRvdCwgZG90LCBkb3QsIGRvdCkpLFxuICAgICAgICAgICAgbShgIyR7c2lkZX1wYW5lbHRpdGxlLnBhbmVsLWhlYWRpbmcudGV4dC1jZW50ZXJgLFxuICAgICAgICAgICAgICBtKFwiaDMucGFuZWwtdGl0bGVcIiwgdGl0bGUpKSxcbiAgICAgICAgICAgIHZub2RlLmNoaWxkcmVuWzBdLFxuICAgICAgICAgICAgbShnZXRDbGFzc2VzKCcucm93LWZsdWlkJywgdGhpcyksIFxuICAgICAgICAgICAgICBtKGAjJHtzaWRlfXBhbmVsY29udGVudGAsXG4gICAgICAgICAgICAgICAgbShgIyR7c2lkZX1Db250ZW50QXJlYVtzdHlsZT1oZWlnaHQ6IGNhbGMoMTAwdmggLSAyMTBweCk7IG92ZXJmbG93OiBhdXRvXWAsIHZub2RlLmNoaWxkcmVuLnNsaWNlKDEpKSkpKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBhbmVsO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYXNzZXRzL2FwcC92aWV3cy9QYW5lbC5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.or = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mithril = __webpack_require__(0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _app = __webpack_require__(1);\n\nvar app = _interopRequireWildcard(_app);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar or = exports.or = function or(side, val) {\n    var y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'block';\n    var n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'none';\n\n    return app[side + 'tab'] === val ? y : n;\n};\n\nvar PanelButton = function () {\n    function PanelButton() {\n        _classCallCheck(this, PanelButton);\n    }\n\n    _createClass(PanelButton, [{\n        key: 'view',\n        value: function view(vnode) {\n            var _vnode$attrs = vnode.attrs,\n                id = _vnode$attrs.id,\n                id2 = _vnode$attrs.id2,\n                classes = _vnode$attrs.classes,\n                onclick = _vnode$attrs.onclick,\n                style = _vnode$attrs.style,\n                title = _vnode$attrs.title;\n\n            var left = id2 ? true : false;\n            id2 = id2 || id;\n            return (0, _mithril2.default)('button#' + id + '.btn.' + (classes || or(left ? 'left' : 'right', id2, 'active', 'btn-default')) + '[type=button]', {\n                onclick: onclick || function (_) {\n                    return left ? app.tabLeft(id2) : app.tabRight(id2);\n                },\n                style: style,\n                title: title }, vnode.children);\n        }\n    }]);\n\n    return PanelButton;\n}();\n\nexports.default = PanelButton;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvYXBwL3ZpZXdzL1BhbmVsQnV0dG9uLmpzP2M4NTciXSwibmFtZXMiOlsiYXBwIiwib3IiLCJzaWRlIiwidmFsIiwieSIsIm4iLCJQYW5lbEJ1dHRvbiIsInZub2RlIiwiYXR0cnMiLCJpZCIsImlkMiIsImNsYXNzZXMiLCJvbmNsaWNrIiwic3R5bGUiLCJ0aXRsZSIsImxlZnQiLCJ0YWJMZWZ0IiwidGFiUmlnaHQiLCJjaGlsZHJlbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7Ozs7QUFFQTs7SUFBWUEsRzs7Ozs7Ozs7QUFFTCxJQUFJQyxrQkFBSyxTQUFMQSxFQUFLLENBQVNDLElBQVQsRUFBZUMsR0FBZixFQUF5QztBQUFBLFFBQXJCQyxDQUFxQix1RUFBbkIsT0FBbUI7QUFBQSxRQUFWQyxDQUFVLHVFQUFSLE1BQVE7O0FBQ3JELFdBQU9MLElBQUlFLE9BQU8sS0FBWCxNQUFzQkMsR0FBdEIsR0FBNEJDLENBQTVCLEdBQWdDQyxDQUF2QztBQUNILENBRk07O0lBSURDLFc7Ozs7Ozs7NkJBQ0dDLEssRUFBTztBQUFBLCtCQUN3Q0EsTUFBTUMsS0FEOUM7QUFBQSxnQkFDSEMsRUFERyxnQkFDSEEsRUFERztBQUFBLGdCQUNDQyxHQURELGdCQUNDQSxHQUREO0FBQUEsZ0JBQ01DLE9BRE4sZ0JBQ01BLE9BRE47QUFBQSxnQkFDZUMsT0FEZixnQkFDZUEsT0FEZjtBQUFBLGdCQUN3QkMsS0FEeEIsZ0JBQ3dCQSxLQUR4QjtBQUFBLGdCQUMrQkMsS0FEL0IsZ0JBQytCQSxLQUQvQjs7QUFFUixnQkFBSUMsT0FBT0wsTUFBTSxJQUFOLEdBQWEsS0FBeEI7QUFDQUEsa0JBQU1BLE9BQU9ELEVBQWI7QUFDQSxtQkFBTyxtQ0FBWUEsRUFBWixjQUFzQkUsV0FBV1YsR0FBR2MsT0FBTyxNQUFQLEdBQWdCLE9BQW5CLEVBQTRCTCxHQUE1QixFQUFpQyxRQUFqQyxFQUEyQyxhQUEzQyxDQUFqQyxxQkFBMkc7QUFDOUdFLHlCQUFTQSxXQUFZO0FBQUEsMkJBQUtHLE9BQU9mLElBQUlnQixPQUFKLENBQVlOLEdBQVosQ0FBUCxHQUEwQlYsSUFBSWlCLFFBQUosQ0FBYVAsR0FBYixDQUEvQjtBQUFBLGlCQUR5RjtBQUU5R0csdUJBQU9BLEtBRnVHO0FBRzlHQyx1QkFBT0EsS0FIdUcsRUFBM0csRUFJSFAsTUFBTVcsUUFKSCxDQUFQO0FBS0g7Ozs7OztrQkFHVVosVyIsImZpbGUiOiI1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCc7XG5cbmltcG9ydCAqIGFzIGFwcCBmcm9tICcuLi9hcHAnO1xuXG5leHBvcnQgbGV0IG9yID0gZnVuY3Rpb24oc2lkZSwgdmFsLCB5PSdibG9jaycsIG49J25vbmUnKSB7XG4gICAgcmV0dXJuIGFwcFtzaWRlICsgJ3RhYiddID09PSB2YWwgPyB5IDogbjtcbn07XG5cbmNsYXNzIFBhbmVsQnV0dG9uIHtcbiAgICB2aWV3KHZub2RlKSB7XG4gICAgICAgIGxldCB7aWQsIGlkMiwgY2xhc3Nlcywgb25jbGljaywgc3R5bGUsIHRpdGxlfSA9IHZub2RlLmF0dHJzO1xuICAgICAgICBsZXQgbGVmdCA9IGlkMiA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgaWQyID0gaWQyIHx8IGlkO1xuICAgICAgICByZXR1cm4gbShgYnV0dG9uIyR7aWR9LmJ0bi4ke2NsYXNzZXMgfHwgb3IobGVmdCA/ICdsZWZ0JyA6ICdyaWdodCcsIGlkMiwgJ2FjdGl2ZScsICdidG4tZGVmYXVsdCcpfVt0eXBlPWJ1dHRvbl1gLCB7XG4gICAgICAgICAgICBvbmNsaWNrOiBvbmNsaWNrIHx8IChfID0+IGxlZnQgPyBhcHAudGFiTGVmdChpZDIpIDogYXBwLnRhYlJpZ2h0KGlkMikpLFxuICAgICAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICAgICAgdGl0bGU6IHRpdGxlfSxcbiAgICAgICAgICAgIHZub2RlLmNoaWxkcmVuKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBhbmVsQnV0dG9uO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYXNzZXRzL2FwcC92aWV3cy9QYW5lbEJ1dHRvbi5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.searchIndex = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mithril = __webpack_require__(0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _app = __webpack_require__(1);\n\nvar app = _interopRequireWildcard(_app);\n\nvar _plots = __webpack_require__(2);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar searchIndex = exports.searchIndex = void 0;\n\nvar search = function search(val) {\n    var all = app.allNodes;\n    if (val === '') {\n        exports.searchIndex = searchIndex = null;\n        return app.valueKey = all.map(function (n) {\n            return n.name;\n        });\n    }\n\n    var matches = [],\n        others = [],\n        match = function match(n, key) {\n        return n[key].toLowerCase().includes(val.toLowerCase());\n    };\n\n    all.forEach(function (n) {\n        return match(n, 'name') || match(n, 'labl') ? matches.push(n) : others.push(n);\n    });\n    exports.searchIndex = searchIndex = matches.length;\n    app.valueKey = matches.concat(others).map(function (n) {\n        return n.name;\n    });\n};\n\nvar Search = function () {\n    function Search() {\n        _classCallCheck(this, Search);\n    }\n\n    _createClass(Search, [{\n        key: 'view',\n        value: function view(vnode) {\n            vnode.attrs.oninput = _mithril2.default.withAttr('value', search);\n            return (0, _mithril2.default)('input#searchvar.form-control[style=margin-bottom: 5px; width: 100%]', vnode.attrs);\n        }\n    }]);\n\n    return Search;\n}();\n\nexports.default = Search;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvYXBwL3ZpZXdzL1NlYXJjaC5qcz8xMzc4Il0sIm5hbWVzIjpbImFwcCIsInNlYXJjaEluZGV4Iiwic2VhcmNoIiwiYWxsIiwiYWxsTm9kZXMiLCJ2YWwiLCJ2YWx1ZUtleSIsIm1hcCIsIm4iLCJuYW1lIiwibWF0Y2hlcyIsIm90aGVycyIsIm1hdGNoIiwia2V5IiwidG9Mb3dlckNhc2UiLCJpbmNsdWRlcyIsImZvckVhY2giLCJwdXNoIiwibGVuZ3RoIiwiY29uY2F0IiwiU2VhcmNoIiwidm5vZGUiLCJhdHRycyIsIm9uaW5wdXQiLCJ3aXRoQXR0ciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7Ozs7QUFFQTs7SUFBWUEsRzs7QUFDWjs7Ozs7Ozs7QUFFTyxJQUFJQywwQ0FBSjs7QUFFUCxJQUFJQyxTQUFTLFNBQVRBLE1BQVMsTUFBTztBQUNoQixRQUFJQyxNQUFNSCxJQUFJSSxRQUFkO0FBQ0EsUUFBSUMsUUFBUSxFQUFaLEVBQWdCO0FBQ1osZ0JBTEdKLFdBS0gsaUJBQWMsSUFBZDtBQUNBLGVBQU9ELElBQUlNLFFBQUosR0FBZUgsSUFBSUksR0FBSixDQUFRO0FBQUEsbUJBQUtDLEVBQUVDLElBQVA7QUFBQSxTQUFSLENBQXRCO0FBQ0g7O0FBTGUsUUFNWEMsT0FOVyxHQU1nQixFQU5oQjtBQUFBLFFBTUZDLE1BTkUsR0FNb0IsRUFOcEI7QUFBQSxRQU1NQyxLQU5OLEdBTXdCLFNBQWxCQSxLQUFrQixDQUFDSixDQUFELEVBQUlLLEdBQUo7QUFBQSxlQUFZTCxFQUFFSyxHQUFGLEVBQU9DLFdBQVAsR0FBcUJDLFFBQXJCLENBQThCVixJQUFJUyxXQUFKLEVBQTlCLENBQVo7QUFBQSxLQU54Qjs7QUFPaEJYLFFBQUlhLE9BQUosQ0FBWTtBQUFBLGVBQUtKLE1BQU1KLENBQU4sRUFBUyxNQUFULEtBQW9CSSxNQUFNSixDQUFOLEVBQVMsTUFBVCxDQUFwQixHQUF1Q0UsUUFBUU8sSUFBUixDQUFhVCxDQUFiLENBQXZDLEdBQXlERyxPQUFPTSxJQUFQLENBQVlULENBQVosQ0FBOUQ7QUFBQSxLQUFaO0FBQ0EsWUFWT1AsV0FVUCxpQkFBY1MsUUFBUVEsTUFBdEI7QUFDQWxCLFFBQUlNLFFBQUosR0FBZUksUUFDVlMsTUFEVSxDQUNIUixNQURHLEVBRVZKLEdBRlUsQ0FFTjtBQUFBLGVBQUtDLEVBQUVDLElBQVA7QUFBQSxLQUZNLENBQWY7QUFHSCxDQVpEOztJQWNNVyxNOzs7Ozs7OzZCQUNHQyxLLEVBQU87QUFDUkEsa0JBQU1DLEtBQU4sQ0FBWUMsT0FBWixHQUFzQixrQkFBRUMsUUFBRixDQUFXLE9BQVgsRUFBb0J0QixNQUFwQixDQUF0QjtBQUNBLG1CQUFPLHVCQUFFLHFFQUFGLEVBQXlFbUIsTUFBTUMsS0FBL0UsQ0FBUDtBQUNIOzs7Ozs7a0JBR1VGLE0iLCJmaWxlIjoiNi5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuXG5pbXBvcnQgKiBhcyBhcHAgZnJvbSAnLi4vYXBwJztcbmltcG9ydCB7c2VsVmFyQ29sb3J9IGZyb20gJy4uL3Bsb3RzJztcblxuZXhwb3J0IGxldCBzZWFyY2hJbmRleDtcblxubGV0IHNlYXJjaCA9IHZhbCA9PiB7XG4gICAgbGV0IGFsbCA9IGFwcC5hbGxOb2RlcztcbiAgICBpZiAodmFsID09PSAnJykge1xuICAgICAgICBzZWFyY2hJbmRleCA9IG51bGw7XG4gICAgICAgIHJldHVybiBhcHAudmFsdWVLZXkgPSBhbGwubWFwKG4gPT4gbi5uYW1lKTtcbiAgICB9XG4gICAgbGV0IFttYXRjaGVzLCBvdGhlcnMsIG1hdGNoXSA9IFtbXSwgW10sIChuLCBrZXkpID0+IG5ba2V5XS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHZhbC50b0xvd2VyQ2FzZSgpKV07XG4gICAgYWxsLmZvckVhY2gobiA9PiBtYXRjaChuLCAnbmFtZScpIHx8IG1hdGNoKG4sICdsYWJsJykgPyBtYXRjaGVzLnB1c2gobikgOiBvdGhlcnMucHVzaChuKSk7XG4gICAgc2VhcmNoSW5kZXggPSBtYXRjaGVzLmxlbmd0aDtcbiAgICBhcHAudmFsdWVLZXkgPSBtYXRjaGVzXG4gICAgICAgIC5jb25jYXQob3RoZXJzKVxuICAgICAgICAubWFwKG4gPT4gbi5uYW1lKTtcbn07XG5cbmNsYXNzIFNlYXJjaCB7XG4gICAgdmlldyh2bm9kZSkge1xuICAgICAgICB2bm9kZS5hdHRycy5vbmlucHV0ID0gbS53aXRoQXR0cigndmFsdWUnLCBzZWFyY2gpO1xuICAgICAgICByZXR1cm4gbSgnaW5wdXQjc2VhcmNodmFyLmZvcm0tY29udHJvbFtzdHlsZT1tYXJnaW4tYm90dG9tOiA1cHg7IHdpZHRoOiAxMDAlXScsIHZub2RlLmF0dHJzKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNlYXJjaDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Fzc2V0cy9hcHAvdmlld3MvU2VhcmNoLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mithril = __webpack_require__(0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _app = __webpack_require__(1);\n\nvar app = _interopRequireWildcard(_app);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Subpanel = function () {\n    function Subpanel() {\n        _classCallCheck(this, Subpanel);\n    }\n\n    _createClass(Subpanel, [{\n        key: 'oninit',\n        value: function oninit(vnode) {\n            this.hide = false;\n        }\n    }, {\n        key: 'view',\n        value: function view(vnode) {\n            var _this = this;\n\n            var title = vnode.attrs.title;\n            var legend = title === 'Legend';\n            var target = 'collapse' + title;\n            var z = app.zparams;\n            return (0, _mithril2.default)('#' + (legend ? \"legend.legendary\" : \"logdiv.logbox\") + '.panel.panel-default', {\n                style: { display: legend && z.ztime.length + z.zcross.length + z.zdv.length + z.znom.length || !legend && app.logArray.length > 0 ? 'block' : 'none' } }, (0, _mithril2.default)(\".panel-heading\", (0, _mithril2.default)(\"h3.panel-title\", title, (0, _mithril2.default)('span.glyphicon.glyphicon-large.glyphicon-chevron-' + (this.hide ? 'up' : 'down') + '.pull-right[data-target=#' + target + '][data-toggle=collapse][href=#' + target + ']', {\n                style: 'cursor: pointer',\n                onclick: function onclick(_) {\n                    return _this.hide = !_this.hide;\n                } }))), (0, _mithril2.default)('#' + target + '.panel-collapse.collapse.in', (0, _mithril2.default)(\".panel-body\", !legend ? app.logArray.map(function (x) {\n                return (0, _mithril2.default)('p', x);\n            }) : vnode.attrs.buttons.map(function (x) {\n                return (0, _mithril2.default)('#' + x[0] + '.clearfix.' + (z[x[1]].length === 0 ? \"hide\" : \"show\"), (0, _mithril2.default)(\".rectColor\", (0, _mithril2.default)(\"svg[style=width: 20px; height: 20px]\", (0, _mithril2.default)(\"circle[cx=10][cy=10][fill=white][r=9][stroke=black][stroke-width=2]\"))), (0, _mithril2.default)(\".rectLabel\", x[2]));\n            }))));\n        }\n    }]);\n\n    return Subpanel;\n}();\n\nexports.default = Subpanel;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvYXBwL3ZpZXdzL1N1YnBhbmVsLmpzP2ViYWIiXSwibmFtZXMiOlsiYXBwIiwiU3VicGFuZWwiLCJ2bm9kZSIsImhpZGUiLCJ0aXRsZSIsImF0dHJzIiwibGVnZW5kIiwidGFyZ2V0IiwieiIsInpwYXJhbXMiLCJzdHlsZSIsImRpc3BsYXkiLCJ6dGltZSIsImxlbmd0aCIsInpjcm9zcyIsInpkdiIsInpub20iLCJsb2dBcnJheSIsIm9uY2xpY2siLCJtYXAiLCJ4IiwiYnV0dG9ucyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7OztBQUVBOztJQUFZQSxHOzs7Ozs7OztJQUVOQyxROzs7Ozs7OytCQUNLQyxLLEVBQU87QUFDVixpQkFBS0MsSUFBTCxHQUFZLEtBQVo7QUFDSDs7OzZCQUVJRCxLLEVBQU87QUFBQTs7QUFDUixnQkFBSUUsUUFBUUYsTUFBTUcsS0FBTixDQUFZRCxLQUF4QjtBQUNBLGdCQUFJRSxTQUFTRixVQUFVLFFBQXZCO0FBQ0EsZ0JBQUlHLFNBQVMsYUFBYUgsS0FBMUI7QUFDQSxnQkFBSUksSUFBSVIsSUFBSVMsT0FBWjtBQUNBLG1CQUFPLDhCQUFNSCxTQUFTLGtCQUFULEdBQThCLGVBQXBDLDRCQUEyRTtBQUM5RUksdUJBQU8sRUFBQ0MsU0FBU0wsVUFBVUUsRUFBRUksS0FBRixDQUFRQyxNQUFSLEdBQWlCTCxFQUFFTSxNQUFGLENBQVNELE1BQTFCLEdBQW1DTCxFQUFFTyxHQUFGLENBQU1GLE1BQXpDLEdBQWtETCxFQUFFUSxJQUFGLENBQU9ILE1BQW5FLElBQTZFLENBQUNQLE1BQUQsSUFBV04sSUFBSWlCLFFBQUosQ0FBYUosTUFBYixHQUFzQixDQUE5RyxHQUFrSCxPQUFsSCxHQUE0SCxNQUF0SSxFQUR1RSxFQUEzRSxFQUVFLHVCQUFFLGdCQUFGLEVBQ0UsdUJBQUUsZ0JBQUYsRUFDRVQsS0FERixFQUVFLDhFQUFzRCxLQUFLRCxJQUFMLEdBQVksSUFBWixHQUFrQixNQUF4RSxrQ0FBMEdJLE1BQTFHLHNDQUFpSkEsTUFBakosUUFBNEo7QUFDeEpHLHVCQUFPLGlCQURpSjtBQUV4SlEseUJBQVM7QUFBQSwyQkFBSyxNQUFLZixJQUFMLEdBQVksQ0FBQyxNQUFLQSxJQUF2QjtBQUFBLGlCQUYrSSxFQUE1SixDQUZGLENBREYsQ0FGRixFQVFFLDZCQUFNSSxNQUFOLGtDQUNFLHVCQUFFLGFBQUYsRUFBaUIsQ0FBQ0QsTUFBRCxHQUFVTixJQUFJaUIsUUFBSixDQUFhRSxHQUFiLENBQWlCO0FBQUEsdUJBQUssdUJBQUUsR0FBRixFQUFPQyxDQUFQLENBQUw7QUFBQSxhQUFqQixDQUFWLEdBQTZDbEIsTUFBTUcsS0FBTixDQUFZZ0IsT0FBWixDQUFvQkYsR0FBcEIsQ0FBd0IsYUFBSztBQUN2Rix1QkFBTyw2QkFBTUMsRUFBRSxDQUFGLENBQU4sbUJBQXVCWixFQUFFWSxFQUFFLENBQUYsQ0FBRixFQUFRUCxNQUFSLEtBQW1CLENBQW5CLEdBQXVCLE1BQXZCLEdBQWdDLE1BQXZELEdBQ0UsdUJBQUUsWUFBRixFQUNFLHVCQUFFLHNDQUFGLEVBQ0UsdUJBQUUscUVBQUYsQ0FERixDQURGLENBREYsRUFJRSx1QkFBRSxZQUFGLEVBQWdCTyxFQUFFLENBQUYsQ0FBaEIsQ0FKRixDQUFQO0FBSWlDLGFBTHlCLENBQTlELENBREYsQ0FSRixDQUFQO0FBZUg7Ozs7OztrQkFHVW5CLFEiLCJmaWxlIjoiNy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuXG5pbXBvcnQgKiBhcyBhcHAgZnJvbSAnLi4vYXBwJztcblxuY2xhc3MgU3VicGFuZWwge1xuICAgIG9uaW5pdCh2bm9kZSkge1xuICAgICAgICB0aGlzLmhpZGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2aWV3KHZub2RlKSB7XG4gICAgICAgIGxldCB0aXRsZSA9IHZub2RlLmF0dHJzLnRpdGxlO1xuICAgICAgICBsZXQgbGVnZW5kID0gdGl0bGUgPT09ICdMZWdlbmQnO1xuICAgICAgICBsZXQgdGFyZ2V0ID0gJ2NvbGxhcHNlJyArIHRpdGxlO1xuICAgICAgICBsZXQgeiA9IGFwcC56cGFyYW1zO1xuICAgICAgICByZXR1cm4gbShgIyR7bGVnZW5kID8gXCJsZWdlbmQubGVnZW5kYXJ5XCIgOiBcImxvZ2Rpdi5sb2dib3hcIn0ucGFuZWwucGFuZWwtZGVmYXVsdGAsIHtcbiAgICAgICAgICAgIHN0eWxlOiB7ZGlzcGxheTogbGVnZW5kICYmIHouenRpbWUubGVuZ3RoICsgei56Y3Jvc3MubGVuZ3RoICsgei56ZHYubGVuZ3RoICsgei56bm9tLmxlbmd0aCB8fCAhbGVnZW5kICYmIGFwcC5sb2dBcnJheS5sZW5ndGggPiAwID8gJ2Jsb2NrJyA6ICdub25lJ319LFxuICAgICAgICAgICAgICAgICBtKFwiLnBhbmVsLWhlYWRpbmdcIixcbiAgICAgICAgICAgICAgICAgICBtKFwiaDMucGFuZWwtdGl0bGVcIixcbiAgICAgICAgICAgICAgICAgICAgIHRpdGxlLFxuICAgICAgICAgICAgICAgICAgICAgbShgc3Bhbi5nbHlwaGljb24uZ2x5cGhpY29uLWxhcmdlLmdseXBoaWNvbi1jaGV2cm9uLSR7dGhpcy5oaWRlID8gJ3VwJzogJ2Rvd24nfS5wdWxsLXJpZ2h0W2RhdGEtdGFyZ2V0PSMke3RhcmdldH1dW2RhdGEtdG9nZ2xlPWNvbGxhcHNlXVtocmVmPSMke3RhcmdldH1dYCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiAnY3Vyc29yOiBwb2ludGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICBvbmNsaWNrOiBfID0+IHRoaXMuaGlkZSA9ICF0aGlzLmhpZGV9KSkpLFxuICAgICAgICAgICAgICAgICBtKGAjJHt0YXJnZXR9LnBhbmVsLWNvbGxhcHNlLmNvbGxhcHNlLmluYCxcbiAgICAgICAgICAgICAgICAgICBtKFwiLnBhbmVsLWJvZHlcIiwgIWxlZ2VuZCA/IGFwcC5sb2dBcnJheS5tYXAoeCA9PiBtKCdwJywgeCkpIDogdm5vZGUuYXR0cnMuYnV0dG9ucy5tYXAoeCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtKGAjJHt4WzBdfS5jbGVhcmZpeC4ke3pbeFsxXV0ubGVuZ3RoID09PSAwID8gXCJoaWRlXCIgOiBcInNob3dcIn1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKFwiLnJlY3RDb2xvclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0oXCJzdmdbc3R5bGU9d2lkdGg6IDIwcHg7IGhlaWdodDogMjBweF1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0oXCJjaXJjbGVbY3g9MTBdW2N5PTEwXVtmaWxsPXdoaXRlXVtyPTldW3N0cm9rZT1ibGFja11bc3Ryb2tlLXdpZHRoPTJdXCIpKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0oXCIucmVjdExhYmVsXCIsIHhbMl0pKTt9KSkpKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFN1YnBhbmVsO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYXNzZXRzL2FwcC92aWV3cy9TdWJwYW5lbC5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7\n")},function(module,exports){eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvY3NzL2FwcC5jc3M/MmY3ZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiI4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Fzc2V0cy9jc3MvYXBwLmNzc1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8\n")},function(module,exports){eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvcGtncy9MYWRkYS9kaXN0L2xhZGRhLXRoZW1lbGVzcy5taW4uY3NzP2E2ZTEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiOS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hc3NldHMvcGtncy9MYWRkYS9kaXN0L2xhZGRhLXRoZW1lbGVzcy5taW4uY3NzXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9\n")},function(module,exports){eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvcGtncy9ib290c3RyYXAvY3NzL2Jvb3RzdHJhcC10aGVtZS5taW4uY3NzP2ZiNzQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYXNzZXRzL3BrZ3MvYm9vdHN0cmFwL2Nzcy9ib290c3RyYXAtdGhlbWUubWluLmNzc1xuLy8gbW9kdWxlIGlkID0gMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///10\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n__webpack_require__(10);\n\n__webpack_require__(8);\n\n__webpack_require__(9);\n\nvar _mithril = __webpack_require__(0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _app = __webpack_require__(1);\n\nvar app = _interopRequireWildcard(_app);\n\nvar _plots = __webpack_require__(2);\n\nvar plots = _interopRequireWildcard(_plots);\n\nvar _Panel = __webpack_require__(4);\n\nvar _Panel2 = _interopRequireDefault(_Panel);\n\nvar _PanelButton = __webpack_require__(5);\n\nvar _PanelButton2 = _interopRequireDefault(_PanelButton);\n\nvar _Search = __webpack_require__(6);\n\nvar _Search2 = _interopRequireDefault(_Search);\n\nvar _Subpanel = __webpack_require__(7);\n\nvar _Subpanel2 = _interopRequireDefault(_Subpanel);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar leftpanel = function leftpanel() {\n  return (0, _mithril2.default)(_Panel2.default, {\n    side: 'left',\n    title: 'Data Selection' }, (0, _mithril2.default)(\".btn-toolbar[role=toolbar][style=margin-left: .5em; margin-top: .5em]\", (0, _mithril2.default)(\".btn-group\", (0, _mithril2.default)(_PanelButton2.default, {\n    id: 'btnVariables',\n    id2: 'tab1',\n    title: 'Click variable name to add or remove the variable pebble from the modeling space.' }, 'Variables'), (0, _mithril2.default)(_PanelButton2.default, { id: 'btnSubset', id2: 'tab2' }, 'Subset')), (0, _mithril2.default)(_PanelButton2.default, {\n    id: 'btnSelect',\n    classes: 'btn-default.ladda-button[data-spinner-color=#000000][data-style=zoom-in]',\n    onclick: function onclick(_) {\n      return app.subsetSelect('btnSelect');\n    },\n    style: 'display: ' + (app.subset ? 'block' : 'none') + '; float: right; margin-right: 10px',\n    title: 'Subset data by the intersection of all selected values.' }, (0, _mithril2.default)('span.ladda-label[style=pointer-events: none]', 'Select'))), (0, _mithril2.default)('#tab1[style=display: ' + (0, _PanelButton.or)('left', 'tab1') + '; padding: 10px 8px; text-align: center]', (0, _mithril2.default)(_Search2.default, { placeholder: 'Search variables and labels' }), (0, _mithril2.default)('#varList[style=display: block]', app.valueKey.map(function (v, i) {\n    return (0, _mithril2.default)('p#' + v.replace(/\\W/g, '_'), {\n      style: {\n        'background-color': app.zparams.zdv.includes(v) ? app.hexToRgba(app.dvColor) : app.zparams.znom.includes(v) ? app.hexToRgba(app.nomColor) : app.nodes.map(function (n) {\n          return n.name;\n        }).includes(v) ? app.hexToRgba(plots.selVarColor) : app.varColor,\n        'border-color': '#000000',\n        'border-style': _Search.searchIndex && i < _Search.searchIndex ? 'solid' : 'none'\n      },\n      onclick: app.clickVar,\n      onmouseover: function onmouseover() {\n        $(this).popover('show');\n        $(\"body div.popover\").addClass(\"variables\");\n        $(\"body div.popover div.popover-content\").addClass(\"form-horizontal\");\n      },\n      onmouseout: \"$(this).popover('hide');\",\n      'data-container': 'body',\n      'data-content': app.popoverContent(app.findNodeIndex(v, true)),\n      'data-html': 'true',\n      'data-original-title': 'Summary Statistics',\n      'data-placement': 'right',\n      'data-toggle': 'popover',\n      'data-trigger': 'hover' }, v);\n  }))), (0, _mithril2.default)('#tab2[style=display: ' + (0, _PanelButton.or)('left', 'tab2') + '; margin-top: .5em]'), (0, _mithril2.default)('#tab3[style=height: 350px]', (0, _mithril2.default)('p[style=padding: .5em 1em; display: ' + (0, _PanelButton.or)('left', 'tab3') + ']', {\n    title: \"Select a variable from within the visualization in the center panel to view its summary statistics.\" }, (0, _mithril2.default)('center', (0, _mithril2.default)('b', app.summary.name), (0, _mithril2.default)('br'), (0, _mithril2.default)('i', app.summary.labl)), (0, _mithril2.default)('table', app.summary.data.map(function (tr) {\n    return (0, _mithril2.default)('tr', tr.map(function (td) {\n      return (0, _mithril2.default)('td', {\n        onmouseover: function onmouseover() {\n          this.style['background-color'] = 'aliceblue';\n        },\n        onmouseout: function onmouseout() {\n          this.style['background-color'] = '#f9f9f9';\n        } }, td);\n    }));\n  })))));\n};\n\nvar rightpanel = function rightpanel(mode) {\n  return mode ? (0, _mithril2.default)(_Panel2.default, {\n    side: 'right',\n    title: 'Result Exploration' }, (0, _mithril2.default)(\".btn-group.btn-group-justified[style=margin-top: .5em]\", (0, _mithril2.default)(_PanelButton2.default, { id: 'btnUnivariate' }, 'Univariate'), (0, _mithril2.default)(_PanelButton2.default, { id: 'btnBivariate' }, 'Bivariate')), (0, _mithril2.default)('#univariate[style=display: ' + (0, _PanelButton.or)('right', 'btnUnivariate') + ']'), (0, _mithril2.default)('#bivariate[style=display: ' + (0, _PanelButton.or)('right', 'btnBivariate') + ']')) : (0, _mithril2.default)(_Panel2.default, {\n    side: 'right',\n    title: 'Model Selection' }, (0, _mithril2.default)(\".accordian[style=margin-top: .5em]\", (0, _mithril2.default)(\"ul#rightpanelbuttons\", [(0, _mithril2.default)(\"li\", [(0, _mithril2.default)(_PanelButton2.default, { id: 'btnModels', style: 'width: 100%' }, 'Models')]), (0, _mithril2.default)(\"li\", [(0, _mithril2.default)(_PanelButton2.default, { id: 'btnSetx', style: 'width: 100%' }, 'Set Covar.')]), (0, _mithril2.default)(\"li\", [(0, _mithril2.default)(_PanelButton2.default, { id: 'btnResults', style: 'width: 100%' }, 'Results')]), (0, _mithril2.default)(\"li\", [(0, _mithril2.default)(_PanelButton2.default, { id: 'btnType', style: 'width: 100%' }, 'Task Type')]), (0, _mithril2.default)(\"li\", [(0, _mithril2.default)(_PanelButton2.default, { id: 'btnSubtype', style: 'width: 100%' }, 'Subtype')]), (0, _mithril2.default)(\"li\", [(0, _mithril2.default)(_PanelButton2.default, { id: 'btnMetrics', style: 'width: 100%' }, 'Metrics')]), (0, _mithril2.default)(\"li\", [(0, _mithril2.default)(_PanelButton2.default, { id: 'btnOutputs', style: 'width: 100%' }, 'Output')])])),\n  /*     m(\".btn-group.btn-group-justified#modelGroup[style=margin-top: .5em]\",\n         m(Button, {id: 'btnModels', style: 'width: 33%'}, 'Models'),\n         m(Button, {id: 'btnSetx', style: 'width: 34%'}, 'Set Covar.'),\n         m(Button, {id: 'btnResults', style: 'width: 33%'}, 'Results'),\n         m(Button, {id: 'btnType', style: 'width: 25%; display: none'}, 'Task Type'),\n         m(Button, {id: 'btnSubtype', style: 'width: 25%; display: none'}, 'Subtype'),\n         m(Button, {id: 'btnMetrics', style: 'width: 25%; display: none'}, 'Metrics'),\n         m(Button, {id: 'btnOutputs', style: 'width: 25%; display: none'}, 'Outputs')),   */\n  (0, _mithril2.default)('#results[style=display: ' + (0, _PanelButton.or)('right', 'btnResults') + '; margin-top: .5em]', (0, _mithril2.default)(\"#resultsView.container[style=float: right; overflow: auto; width: 80%; background-color: white; white-space: nowrap]\"), (0, _mithril2.default)('#modelView[style=display: none; float: left; width: 20%; background-color: white]'), (0, _mithril2.default)(\"p#resultsHolder[style=padding: .5em 1em]\")), (0, _mithril2.default)('#setx[style=display: ' + (0, _PanelButton.or)('right', 'btnSetx') + ']', (0, _mithril2.default)('#setxLeftAll[style=display:block; float: left; width: 30%; height:100%; background-color: white]', (0, _mithril2.default)('#setxLeft[style=display:block; float: left; width: 100%; height:75%; overflow:auto; background-color: white]'), (0, _mithril2.default)('#setxLeftBottom[style=display:block; float: left; width: 100%; height:25%; clear:left; background-color: white]')), (0, _mithril2.default)('#setxRightAll[style=display:block; float: left; width: 70%; height:100%; background-color: white]', (0, _mithril2.default)('#setxRightTop[style=display:block; float: left; width: 100%; height:75%; overflow:auto; background-color: white]', (0, _mithril2.default)('#setxMiddle[style=display:block; float: left; width: 70%; background-color: white]'), (0, _mithril2.default)('#setxRight[style=display:block; float: right; width: 30%; background-color: white]')), (0, _mithril2.default)('#setxRightBottom[style=display:block; float: left; width: 100%; height:25%; overflow:auto; background-color: white]', (0, _mithril2.default)(_PanelButton2.default, {\n    id: 'btnExecutePipe',\n    classes: 'btn-default.ladda-button[data-spinner-color=#000000][data-style=zoom-in]',\n    onclick: function onclick(_) {\n      return app.executepipeline('btnExecutePipe');\n    },\n    style: 'display:inline; float: left; margin-right: 10px',\n    title: 'Execute pipeline.' }, (0, _mithril2.default)('span.ladda-label[style=pointer-events: none]', 'Execute'))))), (0, _mithril2.default)('#models[style=display: ' + (0, _PanelButton.or)('right', 'btnModels') + '; padding: 6px 12px; text-align: center]'), (0, _mithril2.default)('#types[style=display: ' + (0, _PanelButton.or)('right', 'btnType') + '; padding: 6px 12px; text-align: center]'), (0, _mithril2.default)('#subtypes[style=display: ' + (0, _PanelButton.or)('right', 'btnSubtype') + '; padding: 6px 12px; text-align: center]'), (0, _mithril2.default)('#metrics[style=display: ' + (0, _PanelButton.or)('right', 'btnMetrics') + '; padding: 6px 12px; text-align: center]'), (0, _mithril2.default)('#outputs[style=display: ' + (0, _PanelButton.or)('right', 'btnOutputs') + '; padding: 6px 12px; text-align: center]'));\n};\n\nvar ticker = function ticker(mode) {\n  var link = function link(name) {\n    return (0, _mithril2.default)('a' + (name === mode ? '.active' : '') + '[href=/' + name + '][style=margin-right: 0.5em]', { oncreate: _mithril2.default.route.link }, name[0].toUpperCase() + name.slice(1));\n  };\n  return (0, _mithril2.default)('#ticker[style=background: #F9F9F9; bottom: 0; height: 40px; position: fixed; width: 100%; border-top: 1px solid #ADADAD]', link('model'), link('explore'), (0, _mithril2.default)(\"a#logID[href=somelink][target=_blank][style=margin-right: 0.5em]\", \"Replication\"));\n};\n\nvar Body = function () {\n  function Body() {\n    _classCallCheck(this, Body);\n  }\n\n  _createClass(Body, [{\n    key: 'oninit',\n    value: function oninit() {\n      this.about = false;\n      this.cite = false;\n      this.citeHidden = false;\n    }\n  }, {\n    key: 'oncreate',\n    value: function oncreate() {\n      var extract = function extract(name, key, offset, replace) {\n        key = key + '=';\n        var loc = window.location.toString();\n        var val = loc.indexOf(key) > 0 ? loc.substring(loc.indexOf(key) + offset) : '';\n        var idx = val.indexOf('&');\n        val = idx > 0 ? val.substring(0, idx) : val;\n        val = val.replace('#!/model', '');\n        console.log(name, ': ', val);\n        if (replace) val = val.replace(/%25/g, '%').replace(/%3A/g, ':').replace(/%2F/g, '/');\n        return val;\n      };\n      // let apikey = extract('apikey', 'key', 4);\n      app.main(extract('fileid', 'dfId', 5), extract('hostname', 'host', 5), extract('ddiurl', 'ddiurl', 7, true), extract('dataurl', 'dataurl', 8, true), extract('apikey', 'key', 4));\n    }\n  }, {\n    key: 'view',\n    value: function view(vnode) {\n      var _this = this;\n\n      var mode = vnode.attrs.mode;\n\n      return (0, _mithril2.default)('main', (0, _mithril2.default)(\"nav#navbar.navbar.navbar-default.navbar-fixed-top[role=navigation]\", (0, _mithril2.default)(\"a.navbar-brand[style=margin-left: 0]\", (0, _mithril2.default)(\"img[src=/static/images/TwoRavens.png][alt=TwoRavens][width=100][style=margin-left: 2em; margin-top: -0.5em]\", {\n        onmouseover: function onmouseover(_) {\n          return _this.about = true;\n        },\n        onmouseout: function onmouseout(_) {\n          return _this.about = false;\n        } })), (0, _mithril2.default)('#navbarNav[style=padding: 0.5em]', (0, _mithril2.default)('#dataField.field[style=margin-top: 0.5em; text-align: center]', (0, _mithril2.default)('h4#dataName[style=display: inline]', {\n        onclick: function onclick(_) {\n          return _this.cite = _this.citeHidden = !_this.citeHidden;\n        },\n        onmouseout: function onmouseout(_) {\n          return _this.citeHidden || (_this.cite = false);\n        },\n        onmouseover: function onmouseover(_) {\n          return _this.cite = true;\n        } }, \"Dataset Name\"), (0, _mithril2.default)('#cite.panel.panel-default[style=display: ' + (this.cite ? 'block' : 'none') + '; position: absolute; right: 50%; width: 380px; text-align: left; z-index: 50]', (0, _mithril2.default)(\".panel-body\")), (0, _mithril2.default)(\"button#btnEstimate.btn.btn-default.ladda-button.navbar-right[data-spinner-color=#000000][data-style=zoom-in][style=margin-left: 2em; margin-right: 1em]\", {\n        onclick: function onclick(_) {\n          return app.estimate('btnEstimate');\n        } }, (0, _mithril2.default)(\"span.ladda-label\", mode ? 'Explore' : 'Estimate')), (0, _mithril2.default)(\"button#btnTA2.btn.btn-default.ladda-button.navbar-right[data-spinner-color=#000000][data-style=zoom-in][style=margin-left: 15em; margin-right: 1em]\", {\n        onclick: function onclick(_) {\n          return app.ta2stuff('btnTA2');\n        } }, 'TA2'), (0, _mithril2.default)(\"button#btnReset.btn.btn-default.navbar-right[title=Reset][style=margin-left: 2.0em]\", {\n        onclick: app.reset }, (0, _mithril2.default)(\"span.glyphicon.glyphicon-repeat[style=color: #818181; font-size: 1em; pointer-events: none]\")), (0, _mithril2.default)(\"button#btnEndSession.btn.btn-default.navbar-right[title=End Session][style=margin-left: 2.0em]\", {\n        onclick: function onclick(_) {\n          return app.endsession();\n        } }, (0, _mithril2.default)(\"span.ladda-label\", 'End Session')), (0, _mithril2.default)('#transformations.transformTool', {\n        title: 'Construct transformations of existing variables using valid R syntax. For example, assuming a variable named d, you can enter \"log(d)\" or \"d^2\".' }))), (0, _mithril2.default)('#about.panel.panel-default[style=display: ' + (this.about ? 'block' : 'none') + '; left: 140px; position: absolute; width: 500px; z-index: 50]', (0, _mithril2.default)('.panel-body', 'TwoRavens v0.1 \"Dallas\" -- The Norse god Odin had two talking ravens as advisors, who would fly out into the world and report back all they observed. In the Norse, their names were \"Thought\" and \"Memory\". In our coming release, our thought-raven automatically advises on statistical model selection, while our memory-raven accumulates previous statistical models from Dataverse, to provide cummulative guidance and meta-analysis.'))), (0, _mithril2.default)('#main.left.carousel.slide.svg-leftpanel.svg-rightpanel[style=overflow: auto]', (0, _mithril2.default)(\"#innercarousel.carousel-inner\", (0, _mithril2.default)('#m0.item.active', (0, _mithril2.default)('svg#whitespace'))), (0, _mithril2.default)(\"#spacetools.spaceTool[style=z-index: 16]\", (0, _mithril2.default)(\"button#btnLock.btn.active[title=Lock selections of problem description.]\", {\n        onclick: app.lockDescription }, (0, _mithril2.default)(\"span.glyphicon.glyphicon-pencil\")), (0, _mithril2.default)(\"button#btnForce.btn.btn-default[title=Pin the variable pebbles to the page.]\", {\n        onclick: app.forceSwitch }, (0, _mithril2.default)(\"span.glyphicon.glyphicon-pushpin\")), (0, _mithril2.default)(\"button#btnEraser.btn.btn-default[title=Wipe all variables from the modeling space.]\", {\n        onclick: app.erase }, (0, _mithril2.default)(\"span.glyphicon.glyphicon-magnet\"))), (0, _mithril2.default)(_Subpanel2.default, {\n        title: \"Legend\",\n        buttons: [['timeButton', 'ztime', 'Time'], ['csButton', 'zcross', 'Cross Sec'], ['dvButton', 'zdv', 'Dep Var'], ['nomButton', 'znom', 'Nom Var'], ['gr1Button', 'zgroup1', 'Group 1'], ['gr2Button', 'zgroup2', 'Group 2']] }), (0, _mithril2.default)(_Subpanel2.default, { title: \"History\" }), ticker(mode), leftpanel(), rightpanel(mode)));\n    }\n  }]);\n\n  return Body;\n}();\n\n_mithril2.default.route(document.body, '/model', {\n  '/model': { render: function render() {\n      return (0, _mithril2.default)(Body);\n    } },\n  '/explore': { render: function render() {\n      return (0, _mithril2.default)(Body, { mode: 'explore' });\n    } }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvYXBwL2luZGV4LmpzPzMzYmUiXSwibmFtZXMiOlsiYXBwIiwicGxvdHMiLCJsZWZ0cGFuZWwiLCJzaWRlIiwidGl0bGUiLCJpZCIsImlkMiIsImNsYXNzZXMiLCJvbmNsaWNrIiwic3Vic2V0U2VsZWN0Iiwic3R5bGUiLCJzdWJzZXQiLCJwbGFjZWhvbGRlciIsInZhbHVlS2V5IiwibWFwIiwidiIsImkiLCJyZXBsYWNlIiwienBhcmFtcyIsInpkdiIsImluY2x1ZGVzIiwiaGV4VG9SZ2JhIiwiZHZDb2xvciIsInpub20iLCJub21Db2xvciIsIm5vZGVzIiwibiIsIm5hbWUiLCJzZWxWYXJDb2xvciIsInZhckNvbG9yIiwiY2xpY2tWYXIiLCJvbm1vdXNlb3ZlciIsIiQiLCJwb3BvdmVyIiwiYWRkQ2xhc3MiLCJvbm1vdXNlb3V0IiwicG9wb3ZlckNvbnRlbnQiLCJmaW5kTm9kZUluZGV4Iiwic3VtbWFyeSIsImxhYmwiLCJkYXRhIiwidHIiLCJ0ZCIsInJpZ2h0cGFuZWwiLCJtb2RlIiwiZXhlY3V0ZXBpcGVsaW5lIiwidGlja2VyIiwibGluayIsIm9uY3JlYXRlIiwicm91dGUiLCJ0b1VwcGVyQ2FzZSIsInNsaWNlIiwiQm9keSIsImFib3V0IiwiY2l0ZSIsImNpdGVIaWRkZW4iLCJleHRyYWN0Iiwia2V5Iiwib2Zmc2V0IiwibG9jIiwid2luZG93IiwibG9jYXRpb24iLCJ0b1N0cmluZyIsInZhbCIsImluZGV4T2YiLCJzdWJzdHJpbmciLCJpZHgiLCJjb25zb2xlIiwibG9nIiwibWFpbiIsInZub2RlIiwiYXR0cnMiLCJlc3RpbWF0ZSIsInRhMnN0dWZmIiwicmVzZXQiLCJlbmRzZXNzaW9uIiwibG9ja0Rlc2NyaXB0aW9uIiwiZm9yY2VTd2l0Y2giLCJlcmFzZSIsImJ1dHRvbnMiLCJkb2N1bWVudCIsImJvZHkiLCJyZW5kZXIiXSwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFFQTs7OztBQUVB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QU9FLHVCQUFFLHFGQUFGLEVBQXlGO0FBQ3ZGckUsaUJBQVNSLElBQUk4RSxLQUQwRSxFQUF6RixFQUVFLHVCQUFFLGlDQUFGLENBRkYsQ0FQRixDQUpGLEVBY0UsMkNBQVk7QUFDVjFFLGVBQU8sUUFERztBQUVWMkUsaUJBQVMsQ0FDUCxDQUFDLFlBQUQsRUFBZSxPQUFmLEVBQXdCLE1BQXhCLENBRE8sRUFFUCxDQUFDLFVBQUQsRUFBYSxRQUFiLEVBQXVCLFdBQXZCLENBRk8sRUFHUCxDQUFDLFVBQUQsRUFBYSxLQUFiLEVBQW9CLFNBQXBCLENBSE8sRUFJUCxDQUFDLFdBQUQsRUFBYyxNQUFkLEVBQXNCLFNBQXRCLENBSk8sRUFLUCxDQUFDLFdBQUQsRUFBYyxTQUFkLEVBQXlCLFNBQXpCLENBTE8sRUFNUCxDQUFDLFdBQUQsRUFBYyxTQUFkLEVBQXlCLFNBQXpCLENBTk8sQ0FGQyxFQUFaLENBZEYsRUF1QkUsMkNBQVksRUFBQzNFLE9BQU8sU0FBUixFQUFaLENBdkJGLEVBd0JFMEMsT0FBT0YsSUFBUCxDQXhCRixFQXlCRTFDLFdBekJGLEVBMEJFeUMsV0FBV0MsSUFBWCxDQTFCRixDQWhDRyxDQUFQO0FBMkRIOzs7Ozs7QUFHTCxrQkFBRUssS0FBRixDQUFRK0IsU0FBU0MsSUFBakIsRUFBdUIsUUFBdkIsRUFBaUM7QUFDN0IsWUFBVSxFQUFDQyxRQUFRO0FBQUEsYUFBTSx1QkFBRTlCLElBQUYsQ0FBTjtBQUFBLEtBQVQsRUFEbUI7QUFFN0IsY0FBWSxFQUFDOEIsUUFBUTtBQUFBLGFBQU0sdUJBQUU5QixJQUFGLEVBQVEsRUFBQ1IsTUFBTSxTQUFQLEVBQVIsQ0FBTjtBQUFBLEtBQVQ7QUFGaUIsQ0FBakMiLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJy4uL3BrZ3MvYm9vdHN0cmFwL2Nzcy9ib290c3RyYXAtdGhlbWUubWluLmNzcyc7XG5pbXBvcnQgJy4uL2Nzcy9hcHAuY3NzJztcbmltcG9ydCAnLi4vcGtncy9MYWRkYS9kaXN0L2xhZGRhLXRoZW1lbGVzcy5taW4uY3NzJztcblxuaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCc7XG5cbmltcG9ydCAqIGFzIGFwcCBmcm9tICcuL2FwcCc7XG5pbXBvcnQgKiBhcyBwbG90cyBmcm9tICcuL3Bsb3RzJztcbmltcG9ydCBQYW5lbCBmcm9tICcuL3ZpZXdzL1BhbmVsJztcbmltcG9ydCBCdXR0b24sIHtvcn0gZnJvbSAnLi92aWV3cy9QYW5lbEJ1dHRvbic7XG5pbXBvcnQgU2VhcmNoLCB7c2VhcmNoSW5kZXh9IGZyb20gJy4vdmlld3MvU2VhcmNoJztcbmltcG9ydCBTdWJwYW5lbCBmcm9tICcuL3ZpZXdzL1N1YnBhbmVsJztcblxubGV0IGxlZnRwYW5lbCA9ICgpID0+IHtcbiAgICByZXR1cm4gbShQYW5lbCwge1xuICAgICAgICBzaWRlOiAnbGVmdCcsXG4gICAgICAgIHRpdGxlOiAnRGF0YSBTZWxlY3Rpb24nfSwgICAgICAgIFxuICAgICAgICBtKFwiLmJ0bi10b29sYmFyW3JvbGU9dG9vbGJhcl1bc3R5bGU9bWFyZ2luLWxlZnQ6IC41ZW07IG1hcmdpbi10b3A6IC41ZW1dXCIsXG4gICAgICAgICAgbShcIi5idG4tZ3JvdXBcIixcbiAgICAgICAgICAgIG0oQnV0dG9uLCB7XG4gICAgICAgICAgICAgIGlkOiAnYnRuVmFyaWFibGVzJywgXG4gICAgICAgICAgICAgIGlkMjogJ3RhYjEnLFxuICAgICAgICAgICAgICB0aXRsZTogJ0NsaWNrIHZhcmlhYmxlIG5hbWUgdG8gYWRkIG9yIHJlbW92ZSB0aGUgdmFyaWFibGUgcGViYmxlIGZyb20gdGhlIG1vZGVsaW5nIHNwYWNlLid9LCBcbiAgICAgICAgICAgICAgJ1ZhcmlhYmxlcycpLCAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIG0oQnV0dG9uLCB7aWQ6ICdidG5TdWJzZXQnLCBpZDI6ICd0YWIyJ30sICdTdWJzZXQnKSksXG4gICAgICAgICAgbShCdXR0b24sIHtcbiAgICAgICAgICAgIGlkOiAnYnRuU2VsZWN0JyxcbiAgICAgICAgICAgIGNsYXNzZXM6ICdidG4tZGVmYXVsdC5sYWRkYS1idXR0b25bZGF0YS1zcGlubmVyLWNvbG9yPSMwMDAwMDBdW2RhdGEtc3R5bGU9em9vbS1pbl0nLFxuICAgICAgICAgICAgb25jbGljazogXyA9PiBhcHAuc3Vic2V0U2VsZWN0KCdidG5TZWxlY3QnKSxcbiAgICAgICAgICAgIHN0eWxlOiBgZGlzcGxheTogJHthcHAuc3Vic2V0ID8gJ2Jsb2NrJyA6ICdub25lJ307IGZsb2F0OiByaWdodDsgbWFyZ2luLXJpZ2h0OiAxMHB4YCxcbiAgICAgICAgICAgIHRpdGxlOiAnU3Vic2V0IGRhdGEgYnkgdGhlIGludGVyc2VjdGlvbiBvZiBhbGwgc2VsZWN0ZWQgdmFsdWVzLid9LFxuICAgICAgICAgICAgbSgnc3Bhbi5sYWRkYS1sYWJlbFtzdHlsZT1wb2ludGVyLWV2ZW50czogbm9uZV0nLCAnU2VsZWN0JykpKSwgICAgICAgICBcbiAgICAgICAgbShgI3RhYjFbc3R5bGU9ZGlzcGxheTogJHtvcignbGVmdCcsICd0YWIxJyl9OyBwYWRkaW5nOiAxMHB4IDhweDsgdGV4dC1hbGlnbjogY2VudGVyXWAsXG4gICAgICAgICAgbShTZWFyY2gsIHtwbGFjZWhvbGRlcjogJ1NlYXJjaCB2YXJpYWJsZXMgYW5kIGxhYmVscyd9KSxcbiAgICAgICAgICBtKCcjdmFyTGlzdFtzdHlsZT1kaXNwbGF5OiBibG9ja10nLCBhcHAudmFsdWVLZXkubWFwKCh2LCBpKSA9PlxuICAgICAgICAgICAgbShgcCMke3YucmVwbGFjZSgvXFxXL2csICdfJyl9YCwge1xuICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogYXBwLnpwYXJhbXMuemR2LmluY2x1ZGVzKHYpID8gYXBwLmhleFRvUmdiYShhcHAuZHZDb2xvcikgOlxuICAgICAgICAgICAgICAgICAgIGFwcC56cGFyYW1zLnpub20uaW5jbHVkZXModikgPyBhcHAuaGV4VG9SZ2JhKGFwcC5ub21Db2xvcikgOlxuICAgICAgICAgICAgICAgICAgIGFwcC5ub2Rlcy5tYXAobiA9PiBuLm5hbWUpLmluY2x1ZGVzKHYpID8gYXBwLmhleFRvUmdiYShwbG90cy5zZWxWYXJDb2xvcikgOlxuICAgICAgICAgICAgICAgICAgIGFwcC52YXJDb2xvcixcbiAgICAgICAgICAgICAgICAnYm9yZGVyLWNvbG9yJzogJyMwMDAwMDAnLFxuICAgICAgICAgICAgICAgICdib3JkZXItc3R5bGUnOiBzZWFyY2hJbmRleCAmJiBpIDwgc2VhcmNoSW5kZXggPyAnc29saWQnIDogJ25vbmUnLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBvbmNsaWNrOiBhcHAuY2xpY2tWYXIsXG4gICAgICAgICAgICAgIG9ubW91c2VvdmVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAkKHRoaXMpLnBvcG92ZXIoJ3Nob3cnKTtcbiAgICAgICAgICAgICAgICAkKFwiYm9keSBkaXYucG9wb3ZlclwiKVxuICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhcInZhcmlhYmxlc1wiKTtcbiAgICAgICAgICAgICAgICAkKFwiYm9keSBkaXYucG9wb3ZlciBkaXYucG9wb3Zlci1jb250ZW50XCIpXG4gICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKFwiZm9ybS1ob3Jpem9udGFsXCIpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBvbm1vdXNlb3V0OiBcIiQodGhpcykucG9wb3ZlcignaGlkZScpO1wiLFxuICAgICAgICAgICAgICAnZGF0YS1jb250YWluZXInOiAnYm9keScsXG4gICAgICAgICAgICAgICdkYXRhLWNvbnRlbnQnOiBhcHAucG9wb3ZlckNvbnRlbnQoYXBwLmZpbmROb2RlSW5kZXgodiwgdHJ1ZSkpLFxuICAgICAgICAgICAgICAnZGF0YS1odG1sJzogJ3RydWUnLFxuICAgICAgICAgICAgICAnZGF0YS1vcmlnaW5hbC10aXRsZSc6ICdTdW1tYXJ5IFN0YXRpc3RpY3MnLFxuICAgICAgICAgICAgICAnZGF0YS1wbGFjZW1lbnQnOiAncmlnaHQnLFxuICAgICAgICAgICAgICAnZGF0YS10b2dnbGUnOiAncG9wb3ZlcicsXG4gICAgICAgICAgICAgICdkYXRhLXRyaWdnZXInOiAnaG92ZXInfSxcbiAgICAgICAgICAgICAgdikpKSksXG4gICAgICAgIG0oYCN0YWIyW3N0eWxlPWRpc3BsYXk6ICR7b3IoJ2xlZnQnLCAndGFiMicpfTsgbWFyZ2luLXRvcDogLjVlbV1gKSxcbiAgICAgICAgbSgnI3RhYjNbc3R5bGU9aGVpZ2h0OiAzNTBweF0nLFxuICAgICAgICAgIG0oYHBbc3R5bGU9cGFkZGluZzogLjVlbSAxZW07IGRpc3BsYXk6ICR7b3IoJ2xlZnQnLCAndGFiMycpfV1gLCB7XG4gICAgICAgICAgICB0aXRsZTogXCJTZWxlY3QgYSB2YXJpYWJsZSBmcm9tIHdpdGhpbiB0aGUgdmlzdWFsaXphdGlvbiBpbiB0aGUgY2VudGVyIHBhbmVsIHRvIHZpZXcgaXRzIHN1bW1hcnkgc3RhdGlzdGljcy5cIn0sXG4gICAgICAgICAgICBtKCdjZW50ZXInLFxuICAgICAgICAgICAgICBtKCdiJywgYXBwLnN1bW1hcnkubmFtZSksXG4gICAgICAgICAgICAgIG0oJ2JyJyksXG4gICAgICAgICAgICAgIG0oJ2knLCBhcHAuc3VtbWFyeS5sYWJsKSksXG4gICAgICAgICAgICBtKCd0YWJsZScsIGFwcC5zdW1tYXJ5LmRhdGEubWFwKFxuICAgICAgICAgICAgICB0ciA9PiBtKCd0cicsIHRyLm1hcChcbiAgICAgICAgICAgICAgICB0ZCA9PiBtKCd0ZCcsIHtcbiAgICAgICAgICAgICAgICAgIG9ubW91c2VvdmVyOiBmdW5jdGlvbigpIHt0aGlzLnN0eWxlWydiYWNrZ3JvdW5kLWNvbG9yJ10gPSAnYWxpY2VibHVlJ30sXG4gICAgICAgICAgICAgICAgICBvbm1vdXNlb3V0OiBmdW5jdGlvbigpIHt0aGlzLnN0eWxlWydiYWNrZ3JvdW5kLWNvbG9yJ10gPSAnI2Y5ZjlmOSd9fSxcbiAgICAgICAgICAgICAgICAgIHRkKSkpKSkpKSk7XG59O1xuXG5sZXQgcmlnaHRwYW5lbCA9IG1vZGUgPT4gbW9kZSA/IG0oUGFuZWwsIHtcbiAgICBzaWRlOiAncmlnaHQnLCBcbiAgICB0aXRsZTogJ1Jlc3VsdCBFeHBsb3JhdGlvbid9LFxuICAgIG0oXCIuYnRuLWdyb3VwLmJ0bi1ncm91cC1qdXN0aWZpZWRbc3R5bGU9bWFyZ2luLXRvcDogLjVlbV1cIixcbiAgICAgIG0oQnV0dG9uLCB7aWQ6ICdidG5Vbml2YXJpYXRlJ30sICdVbml2YXJpYXRlJyksXG4gICAgICBtKEJ1dHRvbiwge2lkOiAnYnRuQml2YXJpYXRlJ30sICdCaXZhcmlhdGUnKSksXG4gICAgbShgI3VuaXZhcmlhdGVbc3R5bGU9ZGlzcGxheTogJHtvcigncmlnaHQnLCAnYnRuVW5pdmFyaWF0ZScpfV1gKSxcbiAgICBtKGAjYml2YXJpYXRlW3N0eWxlPWRpc3BsYXk6ICR7b3IoJ3JpZ2h0JywgJ2J0bkJpdmFyaWF0ZScpfV1gKSkgOlxuICAgIG0oUGFuZWwsIHtcbiAgICAgIHNpZGU6ICdyaWdodCcsIFxuICAgICAgdGl0bGU6ICdNb2RlbCBTZWxlY3Rpb24nfSxcbiAgICAgIG0oXCIuYWNjb3JkaWFuW3N0eWxlPW1hcmdpbi10b3A6IC41ZW1dXCIsXG4gICAgICAgIG0oXCJ1bCNyaWdodHBhbmVsYnV0dG9uc1wiLFtcbiAgICAgICAgICAgbShcImxpXCIsW1xuICAgICAgICAgICAgICBtKEJ1dHRvbiwge2lkOiAnYnRuTW9kZWxzJywgc3R5bGU6ICd3aWR0aDogMTAwJSd9LCAnTW9kZWxzJyldKSxcbiAgICAgICAgICAgbShcImxpXCIsW1xuICAgICAgICAgICAgICBtKEJ1dHRvbiwge2lkOiAnYnRuU2V0eCcsIHN0eWxlOiAnd2lkdGg6IDEwMCUnfSwgJ1NldCBDb3Zhci4nKV0pLFxuICAgICAgICAgICBtKFwibGlcIixbXG4gICAgICAgICAgICAgIG0oQnV0dG9uLCB7aWQ6ICdidG5SZXN1bHRzJywgc3R5bGU6ICd3aWR0aDogMTAwJSd9LCAnUmVzdWx0cycpXSksXG4gICAgICAgICAgIG0oXCJsaVwiLFtcbiAgICAgICAgICAgICAgbShCdXR0b24sIHtpZDogJ2J0blR5cGUnLCBzdHlsZTogJ3dpZHRoOiAxMDAlJ30sICdUYXNrIFR5cGUnKSxdKSxcbiAgICAgICAgICAgbShcImxpXCIsW1xuICAgICAgICAgICAgICBtKEJ1dHRvbiwge2lkOiAnYnRuU3VidHlwZScsIHN0eWxlOiAnd2lkdGg6IDEwMCUnfSwgJ1N1YnR5cGUnKSxdKSxcbiAgICAgICAgICAgbShcImxpXCIsW1xuICAgICAgICAgICAgICBtKEJ1dHRvbiwge2lkOiAnYnRuTWV0cmljcycsIHN0eWxlOiAnd2lkdGg6IDEwMCUnfSwgJ01ldHJpY3MnKV0pLFxuICAgICAgICAgICBtKFwibGlcIixbbShCdXR0b24sIHtpZDogJ2J0bk91dHB1dHMnLCBzdHlsZTogJ3dpZHRoOiAxMDAlJ30sICdPdXRwdXQnKV0pLFxuICAgICAgICAgICBdKSksXG4gLyogICAgIG0oXCIuYnRuLWdyb3VwLmJ0bi1ncm91cC1qdXN0aWZpZWQjbW9kZWxHcm91cFtzdHlsZT1tYXJnaW4tdG9wOiAuNWVtXVwiLFxuICAgICAgICBtKEJ1dHRvbiwge2lkOiAnYnRuTW9kZWxzJywgc3R5bGU6ICd3aWR0aDogMzMlJ30sICdNb2RlbHMnKSxcbiAgICAgICAgbShCdXR0b24sIHtpZDogJ2J0blNldHgnLCBzdHlsZTogJ3dpZHRoOiAzNCUnfSwgJ1NldCBDb3Zhci4nKSxcbiAgICAgICAgbShCdXR0b24sIHtpZDogJ2J0blJlc3VsdHMnLCBzdHlsZTogJ3dpZHRoOiAzMyUnfSwgJ1Jlc3VsdHMnKSxcbiAgICAgICAgbShCdXR0b24sIHtpZDogJ2J0blR5cGUnLCBzdHlsZTogJ3dpZHRoOiAyNSU7IGRpc3BsYXk6IG5vbmUnfSwgJ1Rhc2sgVHlwZScpLFxuICAgICAgICBtKEJ1dHRvbiwge2lkOiAnYnRuU3VidHlwZScsIHN0eWxlOiAnd2lkdGg6IDI1JTsgZGlzcGxheTogbm9uZSd9LCAnU3VidHlwZScpLFxuICAgICAgICBtKEJ1dHRvbiwge2lkOiAnYnRuTWV0cmljcycsIHN0eWxlOiAnd2lkdGg6IDI1JTsgZGlzcGxheTogbm9uZSd9LCAnTWV0cmljcycpLFxuICAgICAgICBtKEJ1dHRvbiwge2lkOiAnYnRuT3V0cHV0cycsIHN0eWxlOiAnd2lkdGg6IDI1JTsgZGlzcGxheTogbm9uZSd9LCAnT3V0cHV0cycpKSwgICAqL1xuICAgICAgbShgI3Jlc3VsdHNbc3R5bGU9ZGlzcGxheTogJHtvcigncmlnaHQnLCAnYnRuUmVzdWx0cycpfTsgbWFyZ2luLXRvcDogLjVlbV1gLFxuICAgICAgICBtKFwiI3Jlc3VsdHNWaWV3LmNvbnRhaW5lcltzdHlsZT1mbG9hdDogcmlnaHQ7IG92ZXJmbG93OiBhdXRvOyB3aWR0aDogODAlOyBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTsgd2hpdGUtc3BhY2U6IG5vd3JhcF1cIiksXG4gICAgICAgIG0oJyNtb2RlbFZpZXdbc3R5bGU9ZGlzcGxheTogbm9uZTsgZmxvYXQ6IGxlZnQ7IHdpZHRoOiAyMCU7IGJhY2tncm91bmQtY29sb3I6IHdoaXRlXScpLFxuICAgICAgICBtKFwicCNyZXN1bHRzSG9sZGVyW3N0eWxlPXBhZGRpbmc6IC41ZW0gMWVtXVwiKSksXG4gICAgICBtKGAjc2V0eFtzdHlsZT1kaXNwbGF5OiAke29yKCdyaWdodCcsICdidG5TZXR4Jyl9XWAsXG4gICAgICAgIG0oJyNzZXR4TGVmdEFsbFtzdHlsZT1kaXNwbGF5OmJsb2NrOyBmbG9hdDogbGVmdDsgd2lkdGg6IDMwJTsgaGVpZ2h0OjEwMCU7IGJhY2tncm91bmQtY29sb3I6IHdoaXRlXScsXG4gICAgICAgICAgbSgnI3NldHhMZWZ0W3N0eWxlPWRpc3BsYXk6YmxvY2s7IGZsb2F0OiBsZWZ0OyB3aWR0aDogMTAwJTsgaGVpZ2h0Ojc1JTsgb3ZlcmZsb3c6YXV0bzsgYmFja2dyb3VuZC1jb2xvcjogd2hpdGVdJyksXG4gICAgICAgIG0oJyNzZXR4TGVmdEJvdHRvbVtzdHlsZT1kaXNwbGF5OmJsb2NrOyBmbG9hdDogbGVmdDsgd2lkdGg6IDEwMCU7IGhlaWdodDoyNSU7IGNsZWFyOmxlZnQ7IGJhY2tncm91bmQtY29sb3I6IHdoaXRlXScpKSxcbiAgICAgICAgbSgnI3NldHhSaWdodEFsbFtzdHlsZT1kaXNwbGF5OmJsb2NrOyBmbG9hdDogbGVmdDsgd2lkdGg6IDcwJTsgaGVpZ2h0OjEwMCU7IGJhY2tncm91bmQtY29sb3I6IHdoaXRlXScsXG4gICAgICAgICAgbSgnI3NldHhSaWdodFRvcFtzdHlsZT1kaXNwbGF5OmJsb2NrOyBmbG9hdDogbGVmdDsgd2lkdGg6IDEwMCU7IGhlaWdodDo3NSU7IG92ZXJmbG93OmF1dG87IGJhY2tncm91bmQtY29sb3I6IHdoaXRlXScsXG4gICAgICAgICAgICBtKCcjc2V0eE1pZGRsZVtzdHlsZT1kaXNwbGF5OmJsb2NrOyBmbG9hdDogbGVmdDsgd2lkdGg6IDcwJTsgYmFja2dyb3VuZC1jb2xvcjogd2hpdGVdJyksXG4gICAgICAgICAgICBtKCcjc2V0eFJpZ2h0W3N0eWxlPWRpc3BsYXk6YmxvY2s7IGZsb2F0OiByaWdodDsgd2lkdGg6IDMwJTsgYmFja2dyb3VuZC1jb2xvcjogd2hpdGVdJykpLFxuICAgICAgICBtKCcjc2V0eFJpZ2h0Qm90dG9tW3N0eWxlPWRpc3BsYXk6YmxvY2s7IGZsb2F0OiBsZWZ0OyB3aWR0aDogMTAwJTsgaGVpZ2h0OjI1JTsgb3ZlcmZsb3c6YXV0bzsgYmFja2dyb3VuZC1jb2xvcjogd2hpdGVdJyxcbiAgICAgICAgICBtKEJ1dHRvbiwge1xuICAgICAgICAgICAgaWQ6ICdidG5FeGVjdXRlUGlwZScsXG4gICAgICAgICAgICBjbGFzc2VzOiAnYnRuLWRlZmF1bHQubGFkZGEtYnV0dG9uW2RhdGEtc3Bpbm5lci1jb2xvcj0jMDAwMDAwXVtkYXRhLXN0eWxlPXpvb20taW5dJyxcbiAgICAgICAgICAgIG9uY2xpY2s6IF8gPT4gYXBwLmV4ZWN1dGVwaXBlbGluZSgnYnRuRXhlY3V0ZVBpcGUnKSxcbiAgICAgICAgICAgIHN0eWxlOiBgZGlzcGxheTppbmxpbmU7IGZsb2F0OiBsZWZ0OyBtYXJnaW4tcmlnaHQ6IDEwcHhgLFxuICAgICAgICAgICAgdGl0bGU6ICdFeGVjdXRlIHBpcGVsaW5lLid9LFxuICAgICAgICAgICAgbSgnc3Bhbi5sYWRkYS1sYWJlbFtzdHlsZT1wb2ludGVyLWV2ZW50czogbm9uZV0nLCAnRXhlY3V0ZScpKSkpKSxcbiAgICAgIG0oYCNtb2RlbHNbc3R5bGU9ZGlzcGxheTogJHtvcigncmlnaHQnLCAnYnRuTW9kZWxzJyl9OyBwYWRkaW5nOiA2cHggMTJweDsgdGV4dC1hbGlnbjogY2VudGVyXWApLFxuICAgICAgbShgI3R5cGVzW3N0eWxlPWRpc3BsYXk6ICR7b3IoJ3JpZ2h0JywgJ2J0blR5cGUnKX07IHBhZGRpbmc6IDZweCAxMnB4OyB0ZXh0LWFsaWduOiBjZW50ZXJdYCksXG4gICAgICBtKGAjc3VidHlwZXNbc3R5bGU9ZGlzcGxheTogJHtvcigncmlnaHQnLCAnYnRuU3VidHlwZScpfTsgcGFkZGluZzogNnB4IDEycHg7IHRleHQtYWxpZ246IGNlbnRlcl1gKSxcbiAgICAgIG0oYCNtZXRyaWNzW3N0eWxlPWRpc3BsYXk6ICR7b3IoJ3JpZ2h0JywgJ2J0bk1ldHJpY3MnKX07IHBhZGRpbmc6IDZweCAxMnB4OyB0ZXh0LWFsaWduOiBjZW50ZXJdYCksXG4gICAgICBtKGAjb3V0cHV0c1tzdHlsZT1kaXNwbGF5OiAke29yKCdyaWdodCcsICdidG5PdXRwdXRzJyl9OyBwYWRkaW5nOiA2cHggMTJweDsgdGV4dC1hbGlnbjogY2VudGVyXWApKTtcblxuXG5cbmxldCB0aWNrZXIgPSBtb2RlID0+IHtcbiAgICBsZXQgbGluayA9IG5hbWUgPT4gbShgYSR7bmFtZSA9PT0gbW9kZSA/ICcuYWN0aXZlJyA6ICcnfVtocmVmPS8ke25hbWV9XVtzdHlsZT1tYXJnaW4tcmlnaHQ6IDAuNWVtXWAsIHtvbmNyZWF0ZTogbS5yb3V0ZS5saW5rfSwgbmFtZVswXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKSk7XG4gICAgcmV0dXJuIG0oJyN0aWNrZXJbc3R5bGU9YmFja2dyb3VuZDogI0Y5RjlGOTsgYm90dG9tOiAwOyBoZWlnaHQ6IDQwcHg7IHBvc2l0aW9uOiBmaXhlZDsgd2lkdGg6IDEwMCU7IGJvcmRlci10b3A6IDFweCBzb2xpZCAjQURBREFEXScsXG4gICAgICAgIGxpbmsoJ21vZGVsJyksXG4gICAgICAgIGxpbmsoJ2V4cGxvcmUnKSxcbiAgICAgICAgbShcImEjbG9nSURbaHJlZj1zb21lbGlua11bdGFyZ2V0PV9ibGFua11bc3R5bGU9bWFyZ2luLXJpZ2h0OiAwLjVlbV1cIiwgXCJSZXBsaWNhdGlvblwiKSk7XG59O1xuXG5cbmNsYXNzIEJvZHkge1xuICAgIG9uaW5pdCgpIHtcbiAgICAgICAgdGhpcy5hYm91dCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNpdGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jaXRlSGlkZGVuID0gZmFsc2U7XG4gICAgfVxuXG4gICAgb25jcmVhdGUoKSB7XG4gICAgICAgIGxldCBleHRyYWN0ID0gKG5hbWUsIGtleSwgb2Zmc2V0LCByZXBsYWNlKSA9PiB7XG4gICAgICAgICAgICBrZXkgPSBrZXkgKyAnPSc7XG4gICAgICAgICAgICBsZXQgbG9jID0gd2luZG93LmxvY2F0aW9uLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBsZXQgdmFsID0gbG9jLmluZGV4T2Yoa2V5KSA+IDAgPyBsb2Muc3Vic3RyaW5nKGxvYy5pbmRleE9mKGtleSkgKyBvZmZzZXQpIDogJyc7XG4gICAgICAgICAgICBsZXQgaWR4ID0gdmFsLmluZGV4T2YoJyYnKTtcbiAgICAgICAgICAgIHZhbCA9IGlkeCA+IDAgPyB2YWwuc3Vic3RyaW5nKDAsIGlkeCkgOiB2YWw7XG4gICAgICAgICAgICB2YWwgPSB2YWwucmVwbGFjZSgnIyEvbW9kZWwnLCAnJyk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhuYW1lLCAnOiAnLCB2YWwpO1xuICAgICAgICAgICAgaWYgKHJlcGxhY2UpIHZhbCA9IHZhbFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8lMjUvZywgJyUnKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8lM0EvZywgJzonKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8lMkYvZywgJy8nKTtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH07XG4gICAgICAgIC8vIGxldCBhcGlrZXkgPSBleHRyYWN0KCdhcGlrZXknLCAna2V5JywgNCk7XG4gICAgICAgIGFwcC5tYWluKFxuICAgICAgICAgICAgZXh0cmFjdCgnZmlsZWlkJywgJ2RmSWQnLCA1KSxcbiAgICAgICAgICAgIGV4dHJhY3QoJ2hvc3RuYW1lJywgJ2hvc3QnLCA1KSxcbiAgICAgICAgICAgIGV4dHJhY3QoJ2RkaXVybCcsICdkZGl1cmwnLCA3LCB0cnVlKSxcbiAgICAgICAgICAgIGV4dHJhY3QoJ2RhdGF1cmwnLCAnZGF0YXVybCcsIDgsIHRydWUpLFxuICAgICAgICAgICAgZXh0cmFjdCgnYXBpa2V5JywgJ2tleScsIDQpKTtcbiAgICB9XG5cbiAgICB2aWV3KHZub2RlKSB7XG4gICAgICAgIGxldCB7bW9kZX0gPSB2bm9kZS5hdHRycztcbiAgICAgICAgcmV0dXJuIG0oJ21haW4nLFxuICAgICAgICAgICAgbShcIm5hdiNuYXZiYXIubmF2YmFyLm5hdmJhci1kZWZhdWx0Lm5hdmJhci1maXhlZC10b3Bbcm9sZT1uYXZpZ2F0aW9uXVwiLFxuICAgICAgICAgICAgICBtKFwiYS5uYXZiYXItYnJhbmRbc3R5bGU9bWFyZ2luLWxlZnQ6IDBdXCIsXG4gICAgICAgICAgICAgICAgbShcImltZ1tzcmM9L3N0YXRpYy9pbWFnZXMvVHdvUmF2ZW5zLnBuZ11bYWx0PVR3b1JhdmVuc11bd2lkdGg9MTAwXVtzdHlsZT1tYXJnaW4tbGVmdDogMmVtOyBtYXJnaW4tdG9wOiAtMC41ZW1dXCIsIHtcbiAgICAgICAgICAgICAgICAgIG9ubW91c2VvdmVyOiBfID0+IHRoaXMuYWJvdXQgPSB0cnVlLFxuICAgICAgICAgICAgICAgICAgb25tb3VzZW91dDogXyA9PiB0aGlzLmFib3V0ID0gZmFsc2V9KSksXG4gICAgICAgICAgICAgIG0oJyNuYXZiYXJOYXZbc3R5bGU9cGFkZGluZzogMC41ZW1dJyxcbiAgICAgICAgICAgICAgICBtKCcjZGF0YUZpZWxkLmZpZWxkW3N0eWxlPW1hcmdpbi10b3A6IDAuNWVtOyB0ZXh0LWFsaWduOiBjZW50ZXJdJyxcbiAgICAgICAgICAgICAgICAgIG0oJ2g0I2RhdGFOYW1lW3N0eWxlPWRpc3BsYXk6IGlubGluZV0nLCB7XG4gICAgICAgICAgICAgICAgICAgIG9uY2xpY2s6IF8gPT4gdGhpcy5jaXRlID0gdGhpcy5jaXRlSGlkZGVuID0gIXRoaXMuY2l0ZUhpZGRlbixcbiAgICAgICAgICAgICAgICAgICAgb25tb3VzZW91dDogXyA9PiB0aGlzLmNpdGVIaWRkZW4gfHwgKHRoaXMuY2l0ZSA9IGZhbHNlKSxcbiAgICAgICAgICAgICAgICAgICAgb25tb3VzZW92ZXI6IF8gPT4gdGhpcy5jaXRlID0gdHJ1ZX0sXG4gICAgICAgICAgICAgICAgICAgIFwiRGF0YXNldCBOYW1lXCIpLFxuICAgICAgICAgICAgICAgICAgbShgI2NpdGUucGFuZWwucGFuZWwtZGVmYXVsdFtzdHlsZT1kaXNwbGF5OiAke3RoaXMuY2l0ZSA/ICdibG9jaycgOiAnbm9uZSd9OyBwb3NpdGlvbjogYWJzb2x1dGU7IHJpZ2h0OiA1MCU7IHdpZHRoOiAzODBweDsgdGV4dC1hbGlnbjogbGVmdDsgei1pbmRleDogNTBdYCxcbiAgICAgICAgICAgICAgICAgICAgbShcIi5wYW5lbC1ib2R5XCIpKSxcbiAgICAgICAgICAgICAgICAgIG0oXCJidXR0b24jYnRuRXN0aW1hdGUuYnRuLmJ0bi1kZWZhdWx0LmxhZGRhLWJ1dHRvbi5uYXZiYXItcmlnaHRbZGF0YS1zcGlubmVyLWNvbG9yPSMwMDAwMDBdW2RhdGEtc3R5bGU9em9vbS1pbl1bc3R5bGU9bWFyZ2luLWxlZnQ6IDJlbTsgbWFyZ2luLXJpZ2h0OiAxZW1dXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgb25jbGljazogXyA9PiBhcHAuZXN0aW1hdGUoJ2J0bkVzdGltYXRlJyl9LFxuICAgICAgICAgICAgICAgICAgICBtKFwic3Bhbi5sYWRkYS1sYWJlbFwiLCBtb2RlID8gJ0V4cGxvcmUnIDogJ0VzdGltYXRlJykpLFxuICAgICAgICAgICAgICAgICAgbShcImJ1dHRvbiNidG5UQTIuYnRuLmJ0bi1kZWZhdWx0LmxhZGRhLWJ1dHRvbi5uYXZiYXItcmlnaHRbZGF0YS1zcGlubmVyLWNvbG9yPSMwMDAwMDBdW2RhdGEtc3R5bGU9em9vbS1pbl1bc3R5bGU9bWFyZ2luLWxlZnQ6IDE1ZW07IG1hcmdpbi1yaWdodDogMWVtXVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgb25jbGljazogXyA9PiBhcHAudGEyc3R1ZmYoJ2J0blRBMicpfSxcbiAgICAgICAgICAgICAgICAgICAgICAnVEEyJyksXG4gICAgICAgICAgICAgICAgICBtKFwiYnV0dG9uI2J0blJlc2V0LmJ0bi5idG4tZGVmYXVsdC5uYXZiYXItcmlnaHRbdGl0bGU9UmVzZXRdW3N0eWxlPW1hcmdpbi1sZWZ0OiAyLjBlbV1cIiwge1xuICAgICAgICAgICAgICAgICAgICBvbmNsaWNrOiBhcHAucmVzZXR9LFxuICAgICAgICAgICAgICAgICAgICBtKFwic3Bhbi5nbHlwaGljb24uZ2x5cGhpY29uLXJlcGVhdFtzdHlsZT1jb2xvcjogIzgxODE4MTsgZm9udC1zaXplOiAxZW07IHBvaW50ZXItZXZlbnRzOiBub25lXVwiKSksXG4gICAgICAgICAgICAgICAgICBtKFwiYnV0dG9uI2J0bkVuZFNlc3Npb24uYnRuLmJ0bi1kZWZhdWx0Lm5hdmJhci1yaWdodFt0aXRsZT1FbmQgU2Vzc2lvbl1bc3R5bGU9bWFyZ2luLWxlZnQ6IDIuMGVtXVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIG9uY2xpY2s6IF89PiBhcHAuZW5kc2Vzc2lvbigpfSxcbiAgICAgICAgICAgICAgICAgICAgbShcInNwYW4ubGFkZGEtbGFiZWxcIiwgJ0VuZCBTZXNzaW9uJykpLFxuICAgICAgICAgICAgICAgICAgbSgnI3RyYW5zZm9ybWF0aW9ucy50cmFuc2Zvcm1Ub29sJywge1xuICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ0NvbnN0cnVjdCB0cmFuc2Zvcm1hdGlvbnMgb2YgZXhpc3RpbmcgdmFyaWFibGVzIHVzaW5nIHZhbGlkIFIgc3ludGF4LiBGb3IgZXhhbXBsZSwgYXNzdW1pbmcgYSB2YXJpYWJsZSBuYW1lZCBkLCB5b3UgY2FuIGVudGVyIFwibG9nKGQpXCIgb3IgXCJkXjJcIi4nfSkpKSxcbiAgICAgICAgICAgICAgbShgI2Fib3V0LnBhbmVsLnBhbmVsLWRlZmF1bHRbc3R5bGU9ZGlzcGxheTogJHt0aGlzLmFib3V0ID8gJ2Jsb2NrJyA6ICdub25lJ307IGxlZnQ6IDE0MHB4OyBwb3NpdGlvbjogYWJzb2x1dGU7IHdpZHRoOiA1MDBweDsgei1pbmRleDogNTBdYCxcbiAgICAgICAgICAgICAgICBtKCcucGFuZWwtYm9keScsXG4gICAgICAgICAgICAgICAgICAnVHdvUmF2ZW5zIHYwLjEgXCJEYWxsYXNcIiAtLSBUaGUgTm9yc2UgZ29kIE9kaW4gaGFkIHR3byB0YWxraW5nIHJhdmVucyBhcyBhZHZpc29ycywgd2hvIHdvdWxkIGZseSBvdXQgaW50byB0aGUgd29ybGQgYW5kIHJlcG9ydCBiYWNrIGFsbCB0aGV5IG9ic2VydmVkLiBJbiB0aGUgTm9yc2UsIHRoZWlyIG5hbWVzIHdlcmUgXCJUaG91Z2h0XCIgYW5kIFwiTWVtb3J5XCIuIEluIG91ciBjb21pbmcgcmVsZWFzZSwgb3VyIHRob3VnaHQtcmF2ZW4gYXV0b21hdGljYWxseSBhZHZpc2VzIG9uIHN0YXRpc3RpY2FsIG1vZGVsIHNlbGVjdGlvbiwgd2hpbGUgb3VyIG1lbW9yeS1yYXZlbiBhY2N1bXVsYXRlcyBwcmV2aW91cyBzdGF0aXN0aWNhbCBtb2RlbHMgZnJvbSBEYXRhdmVyc2UsIHRvIHByb3ZpZGUgY3VtbXVsYXRpdmUgZ3VpZGFuY2UgYW5kIG1ldGEtYW5hbHlzaXMuJykpKSxcbiAgICAgICAgICAgIG0oYCNtYWluLmxlZnQuY2Fyb3VzZWwuc2xpZGUuc3ZnLWxlZnRwYW5lbC5zdmctcmlnaHRwYW5lbFtzdHlsZT1vdmVyZmxvdzogYXV0b11gLFxuICAgICAgICAgICAgICBtKFwiI2lubmVyY2Fyb3VzZWwuY2Fyb3VzZWwtaW5uZXJcIixcbiAgICAgICAgICAgICAgICBtKCcjbTAuaXRlbS5hY3RpdmUnLFxuICAgICAgICAgICAgICAgICAgbSgnc3ZnI3doaXRlc3BhY2UnKSkpLFxuICAgICAgICAgICAgICBtKFwiI3NwYWNldG9vbHMuc3BhY2VUb29sW3N0eWxlPXotaW5kZXg6IDE2XVwiLFxuICAgICAgICAgICAgICAgIG0oXCJidXR0b24jYnRuTG9jay5idG4uYWN0aXZlW3RpdGxlPUxvY2sgc2VsZWN0aW9ucyBvZiBwcm9ibGVtIGRlc2NyaXB0aW9uLl1cIiwge1xuICAgICAgICAgICAgICAgICAgb25jbGljazogYXBwLmxvY2tEZXNjcmlwdGlvbn0sXG4gICAgICAgICAgICAgICAgICBtKFwic3Bhbi5nbHlwaGljb24uZ2x5cGhpY29uLXBlbmNpbFwiKSksXG4gICAgICAgICAgICAgICAgbShcImJ1dHRvbiNidG5Gb3JjZS5idG4uYnRuLWRlZmF1bHRbdGl0bGU9UGluIHRoZSB2YXJpYWJsZSBwZWJibGVzIHRvIHRoZSBwYWdlLl1cIiwge1xuICAgICAgICAgICAgICAgICAgb25jbGljazogYXBwLmZvcmNlU3dpdGNofSxcbiAgICAgICAgICAgICAgICAgIG0oXCJzcGFuLmdseXBoaWNvbi5nbHlwaGljb24tcHVzaHBpblwiKSksXG4gICAgICAgICAgICAgICAgbShcImJ1dHRvbiNidG5FcmFzZXIuYnRuLmJ0bi1kZWZhdWx0W3RpdGxlPVdpcGUgYWxsIHZhcmlhYmxlcyBmcm9tIHRoZSBtb2RlbGluZyBzcGFjZS5dXCIsIHtcbiAgICAgICAgICAgICAgICAgIG9uY2xpY2s6IGFwcC5lcmFzZX0sXG4gICAgICAgICAgICAgICAgICBtKFwic3Bhbi5nbHlwaGljb24uZ2x5cGhpY29uLW1hZ25ldFwiKSkpLFxuICAgICAgICAgICAgICBtKFN1YnBhbmVsLCB7XG4gICAgICAgICAgICAgICAgdGl0bGU6IFwiTGVnZW5kXCIsXG4gICAgICAgICAgICAgICAgYnV0dG9uczogW1xuICAgICAgICAgICAgICAgICAgWyd0aW1lQnV0dG9uJywgJ3p0aW1lJywgJ1RpbWUnXSxcbiAgICAgICAgICAgICAgICAgIFsnY3NCdXR0b24nLCAnemNyb3NzJywgJ0Nyb3NzIFNlYyddLFxuICAgICAgICAgICAgICAgICAgWydkdkJ1dHRvbicsICd6ZHYnLCAnRGVwIFZhciddLFxuICAgICAgICAgICAgICAgICAgWydub21CdXR0b24nLCAnem5vbScsICdOb20gVmFyJ10sXG4gICAgICAgICAgICAgICAgICBbJ2dyMUJ1dHRvbicsICd6Z3JvdXAxJywgJ0dyb3VwIDEnXSxcbiAgICAgICAgICAgICAgICAgIFsnZ3IyQnV0dG9uJywgJ3pncm91cDInLCAnR3JvdXAgMiddXX0pLFxuICAgICAgICAgICAgICBtKFN1YnBhbmVsLCB7dGl0bGU6IFwiSGlzdG9yeVwifSksXG4gICAgICAgICAgICAgIHRpY2tlcihtb2RlKSxcbiAgICAgICAgICAgICAgbGVmdHBhbmVsKCksXG4gICAgICAgICAgICAgIHJpZ2h0cGFuZWwobW9kZSkpKTtcbiAgICB9XG59XG5cbm0ucm91dGUoZG9jdW1lbnQuYm9keSwgJy9tb2RlbCcsIHtcbiAgICAnL21vZGVsJzoge3JlbmRlcjogKCkgPT4gbShCb2R5KX0sXG4gICAgJy9leHBsb3JlJzoge3JlbmRlcjogKCkgPT4gbShCb2R5LCB7bW9kZTogJ2V4cGxvcmUnfSl9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Fzc2V0cy9hcHAvaW5kZXguanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///11\n")},function(module,exports){eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2Nlc3MvYnJvd3Nlci5qcz84MmU0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVUiLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Byb2Nlc3MvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///12\n")},function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    "use strict";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== "function") {\n        callback = new Function("" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."\n        // So if we\'re currently running a task, we\'ll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // "too much recursion" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can\'t be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage("", "*");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = "setImmediate$" + Math.random() + "$";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === "string" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener("message", onGlobalMessage, false);\n        } else {\n            global.attachEvent("onmessage", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, "*");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it\'s been called.\n            var script = doc.createElement("script");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don\'t get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === "[object process]") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && "onreadystatechange" in doc.createElement("script")) {\n        // For IE 68\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3), __webpack_require__(12)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanM/NGE4MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMsc0JBQXNCLEVBQUU7QUFDbEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgdW5kZWZpbmVkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZiAoZ2xvYmFsLnNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5leHRIYW5kbGUgPSAxOyAvLyBTcGVjIHNheXMgZ3JlYXRlciB0aGFuIHplcm9cbiAgICB2YXIgdGFza3NCeUhhbmRsZSA9IHt9O1xuICAgIHZhciBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICB2YXIgZG9jID0gZ2xvYmFsLmRvY3VtZW50O1xuICAgIHZhciByZWdpc3RlckltbWVkaWF0ZTtcblxuICAgIGZ1bmN0aW9uIHNldEltbWVkaWF0ZShjYWxsYmFjaykge1xuICAgICAgLy8gQ2FsbGJhY2sgY2FuIGVpdGhlciBiZSBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBuZXcgRnVuY3Rpb24oXCJcIiArIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIC8vIENvcHkgZnVuY3Rpb24gYXJndW1lbnRzXG4gICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2kgKyAxXTtcbiAgICAgIH1cbiAgICAgIC8vIFN0b3JlIGFuZCByZWdpc3RlciB0aGUgdGFza1xuICAgICAgdmFyIHRhc2sgPSB7IGNhbGxiYWNrOiBjYWxsYmFjaywgYXJnczogYXJncyB9O1xuICAgICAgdGFza3NCeUhhbmRsZVtuZXh0SGFuZGxlXSA9IHRhc2s7XG4gICAgICByZWdpc3RlckltbWVkaWF0ZShuZXh0SGFuZGxlKTtcbiAgICAgIHJldHVybiBuZXh0SGFuZGxlKys7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaGFuZGxlKSB7XG4gICAgICAgIGRlbGV0ZSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuKHRhc2spIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gdGFzay5jYWxsYmFjaztcbiAgICAgICAgdmFyIGFyZ3MgPSB0YXNrLmFyZ3M7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuSWZQcmVzZW50KGhhbmRsZSkge1xuICAgICAgICAvLyBGcm9tIHRoZSBzcGVjOiBcIldhaXQgdW50aWwgYW55IGludm9jYXRpb25zIG9mIHRoaXMgYWxnb3JpdGhtIHN0YXJ0ZWQgYmVmb3JlIHRoaXMgb25lIGhhdmUgY29tcGxldGVkLlwiXG4gICAgICAgIC8vIFNvIGlmIHdlJ3JlIGN1cnJlbnRseSBydW5uaW5nIGEgdGFzaywgd2UnbGwgbmVlZCB0byBkZWxheSB0aGlzIGludm9jYXRpb24uXG4gICAgICAgIGlmIChjdXJyZW50bHlSdW5uaW5nQVRhc2spIHtcbiAgICAgICAgICAgIC8vIERlbGF5IGJ5IGRvaW5nIGEgc2V0VGltZW91dC4gc2V0SW1tZWRpYXRlIHdhcyB0cmllZCBpbnN0ZWFkLCBidXQgaW4gRmlyZWZveCA3IGl0IGdlbmVyYXRlZCBhXG4gICAgICAgICAgICAvLyBcInRvbyBtdWNoIHJlY3Vyc2lvblwiIGVycm9yLlxuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGFzayA9IHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICAgICAgICAgIGlmICh0YXNrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBydW4odGFzayk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbW1lZGlhdGUoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHsgcnVuSWZQcmVzZW50KGhhbmRsZSk7IH0pO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhblVzZVBvc3RNZXNzYWdlKCkge1xuICAgICAgICAvLyBUaGUgdGVzdCBhZ2FpbnN0IGBpbXBvcnRTY3JpcHRzYCBwcmV2ZW50cyB0aGlzIGltcGxlbWVudGF0aW9uIGZyb20gYmVpbmcgaW5zdGFsbGVkIGluc2lkZSBhIHdlYiB3b3JrZXIsXG4gICAgICAgIC8vIHdoZXJlIGBnbG9iYWwucG9zdE1lc3NhZ2VgIG1lYW5zIHNvbWV0aGluZyBjb21wbGV0ZWx5IGRpZmZlcmVudCBhbmQgY2FuJ3QgYmUgdXNlZCBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgICBpZiAoZ2xvYmFsLnBvc3RNZXNzYWdlICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cykge1xuICAgICAgICAgICAgdmFyIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG9sZE9uTWVzc2FnZSA9IGdsb2JhbC5vbm1lc3NhZ2U7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShcIlwiLCBcIipcIik7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gb2xkT25NZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgLy8gSW5zdGFsbHMgYW4gZXZlbnQgaGFuZGxlciBvbiBgZ2xvYmFsYCBmb3IgdGhlIGBtZXNzYWdlYCBldmVudDogc2VlXG4gICAgICAgIC8vICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vRE9NL3dpbmRvdy5wb3N0TWVzc2FnZVxuICAgICAgICAvLyAqIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL2NvbW1zLmh0bWwjY3Jvc3NEb2N1bWVudE1lc3NhZ2VzXG5cbiAgICAgICAgdmFyIG1lc3NhZ2VQcmVmaXggPSBcInNldEltbWVkaWF0ZSRcIiArIE1hdGgucmFuZG9tKCkgKyBcIiRcIjtcbiAgICAgICAgdmFyIG9uR2xvYmFsTWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlID09PSBnbG9iYWwgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZXZlbnQuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEuaW5kZXhPZihtZXNzYWdlUHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudCgrZXZlbnQuZGF0YS5zbGljZShtZXNzYWdlUHJlZml4Lmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFsLmF0dGFjaEV2ZW50KFwib25tZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKG1lc3NhZ2VQcmVmaXggKyBoYW5kbGUsIFwiKlwiKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZShoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBodG1sID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIDxzY3JpcHQ+IGVsZW1lbnQ7IGl0cyByZWFkeXN0YXRlY2hhbmdlIGV2ZW50IHdpbGwgYmUgZmlyZWQgYXN5bmNocm9ub3VzbHkgb25jZSBpdCBpcyBpbnNlcnRlZFxuICAgICAgICAgICAgLy8gaW50byB0aGUgZG9jdW1lbnQuIERvIHNvLCB0aHVzIHF1ZXVpbmcgdXAgdGhlIHRhc2suIFJlbWVtYmVyIHRvIGNsZWFuIHVwIG9uY2UgaXQncyBiZWVuIGNhbGxlZC5cbiAgICAgICAgICAgIHZhciBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaHRtbC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgICAgIHNjcmlwdCA9IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaHRtbC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBJZiBzdXBwb3J0ZWQsIHdlIHNob3VsZCBhdHRhY2ggdG8gdGhlIHByb3RvdHlwZSBvZiBnbG9iYWwsIHNpbmNlIHRoYXQgaXMgd2hlcmUgc2V0VGltZW91dCBldCBhbC4gbGl2ZS5cbiAgICB2YXIgYXR0YWNoVG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGdsb2JhbCk7XG4gICAgYXR0YWNoVG8gPSBhdHRhY2hUbyAmJiBhdHRhY2hUby5zZXRUaW1lb3V0ID8gYXR0YWNoVG8gOiBnbG9iYWw7XG5cbiAgICAvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IGUuZy4gYnJvd3NlcmlmeSBlbnZpcm9ubWVudHMuXG4gICAgaWYgKHt9LnRvU3RyaW5nLmNhbGwoZ2xvYmFsLnByb2Nlc3MpID09PSBcIltvYmplY3QgcHJvY2Vzc11cIikge1xuICAgICAgICAvLyBGb3IgTm9kZS5qcyBiZWZvcmUgMC45XG4gICAgICAgIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGNhblVzZVBvc3RNZXNzYWdlKCkpIHtcbiAgICAgICAgLy8gRm9yIG5vbi1JRTEwIG1vZGVybiBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChnbG9iYWwuTWVzc2FnZUNoYW5uZWwpIHtcbiAgICAgICAgLy8gRm9yIHdlYiB3b3JrZXJzLCB3aGVyZSBzdXBwb3J0ZWRcbiAgICAgICAgaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZG9jICYmIFwib25yZWFkeXN0YXRlY2hhbmdlXCIgaW4gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIikpIHtcbiAgICAgICAgLy8gRm9yIElFIDbigJM4XG4gICAgICAgIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBvbGRlciBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCk7XG4gICAgfVxuXG4gICAgYXR0YWNoVG8uc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlO1xuICAgIGF0dGFjaFRvLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG59KHR5cGVvZiBzZWxmID09PSBcInVuZGVmaW5lZFwiID8gdHlwZW9mIGdsb2JhbCA9PT0gXCJ1bmRlZmluZWRcIiA/IHRoaXMgOiBnbG9iYWwgOiBzZWxmKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///13\n')},function(module,exports,__webpack_require__){eval("var apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(13);\nexports.setImmediate = setImmediate;\nexports.clearImmediate = clearImmediate;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3RpbWVycy1icm93c2VyaWZ5L21haW4uanM/YjA4OCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjE0LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkge1xuICBpZiAodGltZW91dCkge1xuICAgIHRpbWVvdXQuY2xvc2UoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbCh3aW5kb3csIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBzZXRpbW1lZGlhdGUgYXR0YWNoZXMgaXRzZWxmIHRvIHRoZSBnbG9iYWwgb2JqZWN0XG5yZXF1aXJlKFwic2V0aW1tZWRpYXRlXCIpO1xuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qc1xuLy8gbW9kdWxlIGlkID0gMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///14\n")}]);