!function(I){function Q(g){if(F[g])return F[g].exports;var B=F[g]={i:g,l:!1,exports:{}};return I[g].call(B.exports,B,B.exports,Q),B.l=!0,B.exports}var F={};Q.m=I,Q.c=F,Q.i=function(I){return I},Q.d=function(I,F,g){Q.o(I,F)||Object.defineProperty(I,F,{configurable:!1,enumerable:!0,get:g})},Q.n=function(I){var F=I&&I.__esModule?function(){return I.default}:function(){return I};return Q.d(F,"a",F),F},Q.o=function(I,Q){return Object.prototype.hasOwnProperty.call(I,Q)},Q.p="",Q(Q.s=12)}([function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(setImmediate, global) {;(function() {\n"use strict"\nfunction Vnode(tag, key, attrs0, children, text, dom) {\n\treturn {tag: tag, key: key, attrs: attrs0, children: children, text: text, dom: dom, domSize: undefined, state: undefined, _state: undefined, events: undefined, instance: undefined, skip: false}\n}\nVnode.normalize = function(node) {\n\tif (Array.isArray(node)) return Vnode("[", undefined, undefined, Vnode.normalizeChildren(node), undefined, undefined)\n\tif (node != null && typeof node !== "object") return Vnode("#", undefined, undefined, node === false ? "" : node, undefined, undefined)\n\treturn node\n}\nVnode.normalizeChildren = function normalizeChildren(children) {\n\tfor (var i = 0; i < children.length; i++) {\n\t\tchildren[i] = Vnode.normalize(children[i])\n\t}\n\treturn children\n}\nvar selectorParser = /(?:(^|#|\\.)([^#\\.\\[\\]]+))|(\\[(.+?)(?:\\s*=\\s*("|\'|)((?:\\\\["\'\\]]|.)*?)\\5)?\\])/g\nvar selectorCache = {}\nvar hasOwn = {}.hasOwnProperty\nfunction compileSelector(selector) {\n\tvar match, tag = "div", classes = [], attrs = {}\n\twhile (match = selectorParser.exec(selector)) {\n\t\tvar type = match[1], value = match[2]\n\t\tif (type === "" && value !== "") tag = value\n\t\telse if (type === "#") attrs.id = value\n\t\telse if (type === ".") classes.push(value)\n\t\telse if (match[3][0] === "[") {\n\t\t\tvar attrValue = match[6]\n\t\t\tif (attrValue) attrValue = attrValue.replace(/\\\\(["\'])/g, "$1").replace(/\\\\\\\\/g, "\\\\")\n\t\t\tif (match[4] === "class") classes.push(attrValue)\n\t\t\telse attrs[match[4]] = attrValue === "" ? attrValue : attrValue || true\n\t\t}\n\t}\n\tif (classes.length > 0) attrs.className = classes.join(" ")\n\treturn selectorCache[selector] = {tag: tag, attrs: attrs}\n}\nfunction execSelector(state, attrs, children) {\n\tvar hasAttrs = false, childList, text\n\tvar className = attrs.className || attrs.class\n\tfor (var key in state.attrs) {\n\t\tif (hasOwn.call(state.attrs, key)) {\n\t\t\tattrs[key] = state.attrs[key]\n\t\t}\n\t}\n\tif (className !== undefined) {\n\t\tif (attrs.class !== undefined) {\n\t\t\tattrs.class = undefined\n\t\t\tattrs.className = className\n\t\t}\n\t\tif (state.attrs.className != null) {\n\t\t\tattrs.className = state.attrs.className + " " + className\n\t\t}\n\t}\n\tfor (var key in attrs) {\n\t\tif (hasOwn.call(attrs, key) && key !== "key") {\n\t\t\thasAttrs = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif (Array.isArray(children) && children.length === 1 && children[0] != null && children[0].tag === "#") {\n\t\ttext = children[0].children\n\t} else {\n\t\tchildList = children\n\t}\n\treturn Vnode(state.tag, attrs.key, hasAttrs ? attrs : undefined, childList, text)\n}\nfunction hyperscript(selector) {\n\t// Because sloppy mode sucks\n\tvar attrs = arguments[1], start = 2, children\n\tif (selector == null || typeof selector !== "string" && typeof selector !== "function" && typeof selector.view !== "function") {\n\t\tthrow Error("The selector must be either a string or a component.");\n\t}\n\tif (typeof selector === "string") {\n\t\tvar cached = selectorCache[selector] || compileSelector(selector)\n\t}\n\tif (attrs == null) {\n\t\tattrs = {}\n\t} else if (typeof attrs !== "object" || attrs.tag != null || Array.isArray(attrs)) {\n\t\tattrs = {}\n\t\tstart = 1\n\t}\n\tif (arguments.length === start + 1) {\n\t\tchildren = arguments[start]\n\t\tif (!Array.isArray(children)) children = [children]\n\t} else {\n\t\tchildren = []\n\t\twhile (start < arguments.length) children.push(arguments[start++])\n\t}\n\tvar normalized = Vnode.normalizeChildren(children)\n\tif (typeof selector === "string") {\n\t\treturn execSelector(cached, attrs, normalized)\n\t} else {\n\t\treturn Vnode(selector, attrs.key, attrs, normalized)\n\t}\n}\nhyperscript.trust = function(html) {\n\tif (html == null) html = ""\n\treturn Vnode("<", undefined, undefined, html, undefined, undefined)\n}\nhyperscript.fragment = function(attrs1, children) {\n\treturn Vnode("[", attrs1.key, attrs1, Vnode.normalizeChildren(children), undefined, undefined)\n}\nvar m = hyperscript\n/** @constructor */\nvar PromisePolyfill = function(executor) {\n\tif (!(this instanceof PromisePolyfill)) throw new Error("Promise must be called with `new`")\n\tif (typeof executor !== "function") throw new TypeError("executor must be a function")\n\tvar self = this, resolvers = [], rejectors = [], resolveCurrent = handler(resolvers, true), rejectCurrent = handler(rejectors, false)\n\tvar instance = self._instance = {resolvers: resolvers, rejectors: rejectors}\n\tvar callAsync = typeof setImmediate === "function" ? setImmediate : setTimeout\n\tfunction handler(list, shouldAbsorb) {\n\t\treturn function execute(value) {\n\t\t\tvar then\n\t\t\ttry {\n\t\t\t\tif (shouldAbsorb && value != null && (typeof value === "object" || typeof value === "function") && typeof (then = value.then) === "function") {\n\t\t\t\t\tif (value === self) throw new TypeError("Promise can\'t be resolved w/ itself")\n\t\t\t\t\texecuteOnce(then.bind(value))\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcallAsync(function() {\n\t\t\t\t\t\tif (!shouldAbsorb && list.length === 0) console.error("Possible unhandled promise rejection:", value)\n\t\t\t\t\t\tfor (var i = 0; i < list.length; i++) list[i](value)\n\t\t\t\t\t\tresolvers.length = 0, rejectors.length = 0\n\t\t\t\t\t\tinstance.state = shouldAbsorb\n\t\t\t\t\t\tinstance.retry = function() {execute(value)}\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (e) {\n\t\t\t\trejectCurrent(e)\n\t\t\t}\n\t\t}\n\t}\n\tfunction executeOnce(then) {\n\t\tvar runs = 0\n\t\tfunction run(fn) {\n\t\t\treturn function(value) {\n\t\t\t\tif (runs++ > 0) return\n\t\t\t\tfn(value)\n\t\t\t}\n\t\t}\n\t\tvar onerror = run(rejectCurrent)\n\t\ttry {then(run(resolveCurrent), onerror)} catch (e) {onerror(e)}\n\t}\n\texecuteOnce(executor)\n}\nPromisePolyfill.prototype.then = function(onFulfilled, onRejection) {\n\tvar self = this, instance = self._instance\n\tfunction handle(callback, list, next, state) {\n\t\tlist.push(function(value) {\n\t\t\tif (typeof callback !== "function") next(value)\n\t\t\telse try {resolveNext(callback(value))} catch (e) {if (rejectNext) rejectNext(e)}\n\t\t})\n\t\tif (typeof instance.retry === "function" && state === instance.state) instance.retry()\n\t}\n\tvar resolveNext, rejectNext\n\tvar promise = new PromisePolyfill(function(resolve, reject) {resolveNext = resolve, rejectNext = reject})\n\thandle(onFulfilled, instance.resolvers, resolveNext, true), handle(onRejection, instance.rejectors, rejectNext, false)\n\treturn promise\n}\nPromisePolyfill.prototype.catch = function(onRejection) {\n\treturn this.then(null, onRejection)\n}\nPromisePolyfill.resolve = function(value) {\n\tif (value instanceof PromisePolyfill) return value\n\treturn new PromisePolyfill(function(resolve) {resolve(value)})\n}\nPromisePolyfill.reject = function(value) {\n\treturn new PromisePolyfill(function(resolve, reject) {reject(value)})\n}\nPromisePolyfill.all = function(list) {\n\treturn new PromisePolyfill(function(resolve, reject) {\n\t\tvar total = list.length, count = 0, values = []\n\t\tif (list.length === 0) resolve([])\n\t\telse for (var i = 0; i < list.length; i++) {\n\t\t\t(function(i) {\n\t\t\t\tfunction consume(value) {\n\t\t\t\t\tcount++\n\t\t\t\t\tvalues[i] = value\n\t\t\t\t\tif (count === total) resolve(values)\n\t\t\t\t}\n\t\t\t\tif (list[i] != null && (typeof list[i] === "object" || typeof list[i] === "function") && typeof list[i].then === "function") {\n\t\t\t\t\tlist[i].then(consume, reject)\n\t\t\t\t}\n\t\t\t\telse consume(list[i])\n\t\t\t})(i)\n\t\t}\n\t})\n}\nPromisePolyfill.race = function(list) {\n\treturn new PromisePolyfill(function(resolve, reject) {\n\t\tfor (var i = 0; i < list.length; i++) {\n\t\t\tlist[i].then(resolve, reject)\n\t\t}\n\t})\n}\nif (typeof window !== "undefined") {\n\tif (typeof window.Promise === "undefined") window.Promise = PromisePolyfill\n\tvar PromisePolyfill = window.Promise\n} else if (typeof global !== "undefined") {\n\tif (typeof global.Promise === "undefined") global.Promise = PromisePolyfill\n\tvar PromisePolyfill = global.Promise\n} else {\n}\nvar buildQueryString = function(object) {\n\tif (Object.prototype.toString.call(object) !== "[object Object]") return ""\n\tvar args = []\n\tfor (var key0 in object) {\n\t\tdestructure(key0, object[key0])\n\t}\n\treturn args.join("&")\n\tfunction destructure(key0, value) {\n\t\tif (Array.isArray(value)) {\n\t\t\tfor (var i = 0; i < value.length; i++) {\n\t\t\t\tdestructure(key0 + "[" + i + "]", value[i])\n\t\t\t}\n\t\t}\n\t\telse if (Object.prototype.toString.call(value) === "[object Object]") {\n\t\t\tfor (var i in value) {\n\t\t\t\tdestructure(key0 + "[" + i + "]", value[i])\n\t\t\t}\n\t\t}\n\t\telse args.push(encodeURIComponent(key0) + (value != null && value !== "" ? "=" + encodeURIComponent(value) : ""))\n\t}\n}\nvar FILE_PROTOCOL_REGEX = new RegExp("^file://", "i")\nvar _8 = function($window, Promise) {\n\tvar callbackCount = 0\n\tvar oncompletion\n\tfunction setCompletionCallback(callback) {oncompletion = callback}\n\tfunction finalizer() {\n\t\tvar count = 0\n\t\tfunction complete() {if (--count === 0 && typeof oncompletion === "function") oncompletion()}\n\t\treturn function finalize(promise0) {\n\t\t\tvar then0 = promise0.then\n\t\t\tpromise0.then = function() {\n\t\t\t\tcount++\n\t\t\t\tvar next = then0.apply(promise0, arguments)\n\t\t\t\tnext.then(complete, function(e) {\n\t\t\t\t\tcomplete()\n\t\t\t\t\tif (count === 0) throw e\n\t\t\t\t})\n\t\t\t\treturn finalize(next)\n\t\t\t}\n\t\t\treturn promise0\n\t\t}\n\t}\n\tfunction normalize(args, extra) {\n\t\tif (typeof args === "string") {\n\t\t\tvar url = args\n\t\t\targs = extra || {}\n\t\t\tif (args.url == null) args.url = url\n\t\t}\n\t\treturn args\n\t}\n\tfunction request(args, extra) {\n\t\tvar finalize = finalizer()\n\t\targs = normalize(args, extra)\n\t\tvar promise0 = new Promise(function(resolve, reject) {\n\t\t\tif (args.method == null) args.method = "GET"\n\t\t\targs.method = args.method.toUpperCase()\n\t\t\tvar useBody = (args.method === "GET" || args.method === "TRACE") ? false : (typeof args.useBody === "boolean" ? args.useBody : true)\n\t\t\tif (typeof args.serialize !== "function") args.serialize = typeof FormData !== "undefined" && args.data instanceof FormData ? function(value) {return value} : JSON.stringify\n\t\t\tif (typeof args.deserialize !== "function") args.deserialize = deserialize\n\t\t\tif (typeof args.extract !== "function") args.extract = extract\n\t\t\targs.url = interpolate(args.url, args.data)\n\t\t\tif (useBody) args.data = args.serialize(args.data)\n\t\t\telse args.url = assemble(args.url, args.data)\n\t\t\tvar xhr = new $window.XMLHttpRequest(),\n\t\t\t\taborted = false,\n\t\t\t\t_abort = xhr.abort\n\t\t\txhr.abort = function abort() {\n\t\t\t\taborted = true\n\t\t\t\t_abort.call(xhr)\n\t\t\t}\n\t\t\txhr.open(args.method, args.url, typeof args.async === "boolean" ? args.async : true, typeof args.user === "string" ? args.user : undefined, typeof args.password === "string" ? args.password : undefined)\n\t\t\tif (args.serialize === JSON.stringify && useBody) {\n\t\t\t\txhr.setRequestHeader("Content-Type", "application/json; charset=utf-8")\n\t\t\t}\n\t\t\tif (args.deserialize === deserialize) {\n\t\t\t\txhr.setRequestHeader("Accept", "application/json, text/*")\n\t\t\t}\n\t\t\tif (args.withCredentials) xhr.withCredentials = args.withCredentials\n\t\t\tfor (var key in args.headers) if ({}.hasOwnProperty.call(args.headers, key)) {\n\t\t\t\txhr.setRequestHeader(key, args.headers[key])\n\t\t\t}\n\t\t\tif (typeof args.config === "function") xhr = args.config(xhr, args) || xhr\n\t\t\txhr.onreadystatechange = function() {\n\t\t\t\t// Don\'t throw errors on xhr.abort().\n\t\t\t\tif(aborted) return\n\t\t\t\tif (xhr.readyState === 4) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvar response = (args.extract !== extract) ? args.extract(xhr, args) : args.deserialize(args.extract(xhr, args))\n\t\t\t\t\t\tif ((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304 || FILE_PROTOCOL_REGEX.test(args.url)) {\n\t\t\t\t\t\t\tresolve(cast(args.type, response))\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tvar error = new Error(xhr.responseText)\n\t\t\t\t\t\t\tfor (var key in response) error[key] = response[key]\n\t\t\t\t\t\t\treject(error)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (e) {\n\t\t\t\t\t\treject(e)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (useBody && (args.data != null)) xhr.send(args.data)\n\t\t\telse xhr.send()\n\t\t})\n\t\treturn args.background === true ? promise0 : finalize(promise0)\n\t}\n\tfunction jsonp(args, extra) {\n\t\tvar finalize = finalizer()\n\t\targs = normalize(args, extra)\n\t\tvar promise0 = new Promise(function(resolve, reject) {\n\t\t\tvar callbackName = args.callbackName || "_mithril_" + Math.round(Math.random() * 1e16) + "_" + callbackCount++\n\t\t\tvar script = $window.document.createElement("script")\n\t\t\t$window[callbackName] = function(data) {\n\t\t\t\tscript.parentNode.removeChild(script)\n\t\t\t\tresolve(cast(args.type, data))\n\t\t\t\tdelete $window[callbackName]\n\t\t\t}\n\t\t\tscript.onerror = function() {\n\t\t\t\tscript.parentNode.removeChild(script)\n\t\t\t\treject(new Error("JSONP request failed"))\n\t\t\t\tdelete $window[callbackName]\n\t\t\t}\n\t\t\tif (args.data == null) args.data = {}\n\t\t\targs.url = interpolate(args.url, args.data)\n\t\t\targs.data[args.callbackKey || "callback"] = callbackName\n\t\t\tscript.src = assemble(args.url, args.data)\n\t\t\t$window.document.documentElement.appendChild(script)\n\t\t})\n\t\treturn args.background === true? promise0 : finalize(promise0)\n\t}\n\tfunction interpolate(url, data) {\n\t\tif (data == null) return url\n\t\tvar tokens = url.match(/:[^\\/]+/gi) || []\n\t\tfor (var i = 0; i < tokens.length; i++) {\n\t\t\tvar key = tokens[i].slice(1)\n\t\t\tif (data[key] != null) {\n\t\t\t\turl = url.replace(tokens[i], data[key])\n\t\t\t}\n\t\t}\n\t\treturn url\n\t}\n\tfunction assemble(url, data) {\n\t\tvar querystring = buildQueryString(data)\n\t\tif (querystring !== "") {\n\t\t\tvar prefix = url.indexOf("?") < 0 ? "?" : "&"\n\t\t\turl += prefix + querystring\n\t\t}\n\t\treturn url\n\t}\n\tfunction deserialize(data) {\n\t\ttry {return data !== "" ? JSON.parse(data) : null}\n\t\tcatch (e) {throw new Error(data)}\n\t}\n\tfunction extract(xhr) {return xhr.responseText}\n\tfunction cast(type0, data) {\n\t\tif (typeof type0 === "function") {\n\t\t\tif (Array.isArray(data)) {\n\t\t\t\tfor (var i = 0; i < data.length; i++) {\n\t\t\t\t\tdata[i] = new type0(data[i])\n\t\t\t\t}\n\t\t\t}\n\t\t\telse return new type0(data)\n\t\t}\n\t\treturn data\n\t}\n\treturn {request: request, jsonp: jsonp, setCompletionCallback: setCompletionCallback}\n}\nvar requestService = _8(window, PromisePolyfill)\nvar coreRenderer = function($window) {\n\tvar $doc = $window.document\n\tvar $emptyFragment = $doc.createDocumentFragment()\n\tvar nameSpace = {\n\t\tsvg: "http://www.w3.org/2000/svg",\n\t\tmath: "http://www.w3.org/1998/Math/MathML"\n\t}\n\tvar onevent\n\tfunction setEventCallback(callback) {return onevent = callback}\n\tfunction getNameSpace(vnode) {\n\t\treturn vnode.attrs && vnode.attrs.xmlns || nameSpace[vnode.tag]\n\t}\n\t//create\n\tfunction createNodes(parent, vnodes, start, end, hooks, nextSibling, ns) {\n\t\tfor (var i = start; i < end; i++) {\n\t\t\tvar vnode = vnodes[i]\n\t\t\tif (vnode != null) {\n\t\t\t\tcreateNode(parent, vnode, hooks, ns, nextSibling)\n\t\t\t}\n\t\t}\n\t}\n\tfunction createNode(parent, vnode, hooks, ns, nextSibling) {\n\t\tvar tag = vnode.tag\n\t\tif (typeof tag === "string") {\n\t\t\tvnode.state = {}\n\t\t\tif (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks)\n\t\t\tswitch (tag) {\n\t\t\t\tcase "#": return createText(parent, vnode, nextSibling)\n\t\t\t\tcase "<": return createHTML(parent, vnode, nextSibling)\n\t\t\t\tcase "[": return createFragment(parent, vnode, hooks, ns, nextSibling)\n\t\t\t\tdefault: return createElement(parent, vnode, hooks, ns, nextSibling)\n\t\t\t}\n\t\t}\n\t\telse return createComponent(parent, vnode, hooks, ns, nextSibling)\n\t}\n\tfunction createText(parent, vnode, nextSibling) {\n\t\tvnode.dom = $doc.createTextNode(vnode.children)\n\t\tinsertNode(parent, vnode.dom, nextSibling)\n\t\treturn vnode.dom\n\t}\n\tfunction createHTML(parent, vnode, nextSibling) {\n\t\tvar match1 = vnode.children.match(/^\\s*?<(\\w+)/im) || []\n\t\tvar parent1 = {caption: "table", thead: "table", tbody: "table", tfoot: "table", tr: "tbody", th: "tr", td: "tr", colgroup: "table", col: "colgroup"}[match1[1]] || "div"\n\t\tvar temp = $doc.createElement(parent1)\n\t\ttemp.innerHTML = vnode.children\n\t\tvnode.dom = temp.firstChild\n\t\tvnode.domSize = temp.childNodes.length\n\t\tvar fragment = $doc.createDocumentFragment()\n\t\tvar child\n\t\twhile (child = temp.firstChild) {\n\t\t\tfragment.appendChild(child)\n\t\t}\n\t\tinsertNode(parent, fragment, nextSibling)\n\t\treturn fragment\n\t}\n\tfunction createFragment(parent, vnode, hooks, ns, nextSibling) {\n\t\tvar fragment = $doc.createDocumentFragment()\n\t\tif (vnode.children != null) {\n\t\t\tvar children = vnode.children\n\t\t\tcreateNodes(fragment, children, 0, children.length, hooks, null, ns)\n\t\t}\n\t\tvnode.dom = fragment.firstChild\n\t\tvnode.domSize = fragment.childNodes.length\n\t\tinsertNode(parent, fragment, nextSibling)\n\t\treturn fragment\n\t}\n\tfunction createElement(parent, vnode, hooks, ns, nextSibling) {\n\t\tvar tag = vnode.tag\n\t\tvar attrs2 = vnode.attrs\n\t\tvar is = attrs2 && attrs2.is\n\t\tns = getNameSpace(vnode) || ns\n\t\tvar element = ns ?\n\t\t\tis ? $doc.createElementNS(ns, tag, {is: is}) : $doc.createElementNS(ns, tag) :\n\t\t\tis ? $doc.createElement(tag, {is: is}) : $doc.createElement(tag)\n\t\tvnode.dom = element\n\t\tif (attrs2 != null) {\n\t\t\tsetAttrs(vnode, attrs2, ns)\n\t\t}\n\t\tinsertNode(parent, element, nextSibling)\n\t\tif (vnode.attrs != null && vnode.attrs.contenteditable != null) {\n\t\t\tsetContentEditable(vnode)\n\t\t}\n\t\telse {\n\t\t\tif (vnode.text != null) {\n\t\t\t\tif (vnode.text !== "") element.textContent = vnode.text\n\t\t\t\telse vnode.children = [Vnode("#", undefined, undefined, vnode.text, undefined, undefined)]\n\t\t\t}\n\t\t\tif (vnode.children != null) {\n\t\t\t\tvar children = vnode.children\n\t\t\t\tcreateNodes(element, children, 0, children.length, hooks, null, ns)\n\t\t\t\tsetLateAttrs(vnode)\n\t\t\t}\n\t\t}\n\t\treturn element\n\t}\n\tfunction initComponent(vnode, hooks) {\n\t\tvar sentinel\n\t\tif (typeof vnode.tag.view === "function") {\n\t\t\tvnode.state = Object.create(vnode.tag)\n\t\t\tsentinel = vnode.state.view\n\t\t\tif (sentinel.$$reentrantLock$$ != null) return $emptyFragment\n\t\t\tsentinel.$$reentrantLock$$ = true\n\t\t} else {\n\t\t\tvnode.state = void 0\n\t\t\tsentinel = vnode.tag\n\t\t\tif (sentinel.$$reentrantLock$$ != null) return $emptyFragment\n\t\t\tsentinel.$$reentrantLock$$ = true\n\t\t\tvnode.state = (vnode.tag.prototype != null && typeof vnode.tag.prototype.view === "function") ? new vnode.tag(vnode) : vnode.tag(vnode)\n\t\t}\n\t\tvnode._state = vnode.state\n\t\tif (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks)\n\t\tinitLifecycle(vnode._state, vnode, hooks)\n\t\tvnode.instance = Vnode.normalize(vnode._state.view.call(vnode.state, vnode))\n\t\tif (vnode.instance === vnode) throw Error("A view cannot return the vnode it received as argument")\n\t\tsentinel.$$reentrantLock$$ = null\n\t}\n\tfunction createComponent(parent, vnode, hooks, ns, nextSibling) {\n\t\tinitComponent(vnode, hooks)\n\t\tif (vnode.instance != null) {\n\t\t\tvar element = createNode(parent, vnode.instance, hooks, ns, nextSibling)\n\t\t\tvnode.dom = vnode.instance.dom\n\t\t\tvnode.domSize = vnode.dom != null ? vnode.instance.domSize : 0\n\t\t\tinsertNode(parent, element, nextSibling)\n\t\t\treturn element\n\t\t}\n\t\telse {\n\t\t\tvnode.domSize = 0\n\t\t\treturn $emptyFragment\n\t\t}\n\t}\n\t//update\n\tfunction updateNodes(parent, old, vnodes, recycling, hooks, nextSibling, ns) {\n\t\tif (old === vnodes || old == null && vnodes == null) return\n\t\telse if (old == null) createNodes(parent, vnodes, 0, vnodes.length, hooks, nextSibling, ns)\n\t\telse if (vnodes == null) removeNodes(old, 0, old.length, vnodes)\n\t\telse {\n\t\t\tif (old.length === vnodes.length) {\n\t\t\t\tvar isUnkeyed = false\n\t\t\t\tfor (var i = 0; i < vnodes.length; i++) {\n\t\t\t\t\tif (vnodes[i] != null && old[i] != null) {\n\t\t\t\t\t\tisUnkeyed = vnodes[i].key == null && old[i].key == null\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (isUnkeyed) {\n\t\t\t\t\tfor (var i = 0; i < old.length; i++) {\n\t\t\t\t\t\tif (old[i] === vnodes[i]) continue\n\t\t\t\t\t\telse if (old[i] == null && vnodes[i] != null) createNode(parent, vnodes[i], hooks, ns, getNextSibling(old, i + 1, nextSibling))\n\t\t\t\t\t\telse if (vnodes[i] == null) removeNodes(old, i, i + 1, vnodes)\n\t\t\t\t\t\telse updateNode(parent, old[i], vnodes[i], hooks, getNextSibling(old, i + 1, nextSibling), recycling, ns)\n\t\t\t\t\t}\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\trecycling = recycling || isRecyclable(old, vnodes)\n\t\t\tif (recycling) {\n\t\t\t\tvar pool = old.pool\n\t\t\t\told = old.concat(old.pool)\n\t\t\t}\n\t\t\tvar oldStart = 0, start = 0, oldEnd = old.length - 1, end = vnodes.length - 1, map\n\t\t\twhile (oldEnd >= oldStart && end >= start) {\n\t\t\t\tvar o = old[oldStart], v = vnodes[start]\n\t\t\t\tif (o === v && !recycling) oldStart++, start++\n\t\t\t\telse if (o == null) oldStart++\n\t\t\t\telse if (v == null) start++\n\t\t\t\telse if (o.key === v.key) {\n\t\t\t\t\tvar shouldRecycle = (pool != null && oldStart >= old.length - pool.length) || ((pool == null) && recycling)\n\t\t\t\t\toldStart++, start++\n\t\t\t\t\tupdateNode(parent, o, v, hooks, getNextSibling(old, oldStart, nextSibling), shouldRecycle, ns)\n\t\t\t\t\tif (recycling && o.tag === v.tag) insertNode(parent, toFragment(o), nextSibling)\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tvar o = old[oldEnd]\n\t\t\t\t\tif (o === v && !recycling) oldEnd--, start++\n\t\t\t\t\telse if (o == null) oldEnd--\n\t\t\t\t\telse if (v == null) start++\n\t\t\t\t\telse if (o.key === v.key) {\n\t\t\t\t\t\tvar shouldRecycle = (pool != null && oldEnd >= old.length - pool.length) || ((pool == null) && recycling)\n\t\t\t\t\t\tupdateNode(parent, o, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), shouldRecycle, ns)\n\t\t\t\t\t\tif (recycling || start < end) insertNode(parent, toFragment(o), getNextSibling(old, oldStart, nextSibling))\n\t\t\t\t\t\toldEnd--, start++\n\t\t\t\t\t}\n\t\t\t\t\telse break\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (oldEnd >= oldStart && end >= start) {\n\t\t\t\tvar o = old[oldEnd], v = vnodes[end]\n\t\t\t\tif (o === v && !recycling) oldEnd--, end--\n\t\t\t\telse if (o == null) oldEnd--\n\t\t\t\telse if (v == null) end--\n\t\t\t\telse if (o.key === v.key) {\n\t\t\t\t\tvar shouldRecycle = (pool != null && oldEnd >= old.length - pool.length) || ((pool == null) && recycling)\n\t\t\t\t\tupdateNode(parent, o, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), shouldRecycle, ns)\n\t\t\t\t\tif (recycling && o.tag === v.tag) insertNode(parent, toFragment(o), nextSibling)\n\t\t\t\t\tif (o.dom != null) nextSibling = o.dom\n\t\t\t\t\toldEnd--, end--\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (!map) map = getKeyMap(old, oldEnd)\n\t\t\t\t\tif (v != null) {\n\t\t\t\t\t\tvar oldIndex = map[v.key]\n\t\t\t\t\t\tif (oldIndex != null) {\n\t\t\t\t\t\t\tvar movable = old[oldIndex]\n\t\t\t\t\t\t\tvar shouldRecycle = (pool != null && oldIndex >= old.length - pool.length) || ((pool == null) && recycling)\n\t\t\t\t\t\t\tupdateNode(parent, movable, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), recycling, ns)\n\t\t\t\t\t\t\tinsertNode(parent, toFragment(movable), nextSibling)\n\t\t\t\t\t\t\told[oldIndex].skip = true\n\t\t\t\t\t\t\tif (movable.dom != null) nextSibling = movable.dom\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tvar dom = createNode(parent, v, hooks, ns, nextSibling)\n\t\t\t\t\t\t\tnextSibling = dom\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tend--\n\t\t\t\t}\n\t\t\t\tif (end < start) break\n\t\t\t}\n\t\t\tcreateNodes(parent, vnodes, start, end + 1, hooks, nextSibling, ns)\n\t\t\tremoveNodes(old, oldStart, oldEnd + 1, vnodes)\n\t\t}\n\t}\n\tfunction updateNode(parent, old, vnode, hooks, nextSibling, recycling, ns) {\n\t\tvar oldTag = old.tag, tag = vnode.tag\n\t\tif (oldTag === tag) {\n\t\t\tvnode.state = old.state\n\t\t\tvnode._state = old._state\n\t\t\tvnode.events = old.events\n\t\t\tif (!recycling && shouldNotUpdate(vnode, old)) return\n\t\t\tif (typeof oldTag === "string") {\n\t\t\t\tif (vnode.attrs != null) {\n\t\t\t\t\tif (recycling) {\n\t\t\t\t\t\tvnode.state = {}\n\t\t\t\t\t\tinitLifecycle(vnode.attrs, vnode, hooks)\n\t\t\t\t\t}\n\t\t\t\t\telse updateLifecycle(vnode.attrs, vnode, hooks)\n\t\t\t\t}\n\t\t\t\tswitch (oldTag) {\n\t\t\t\t\tcase "#": updateText(old, vnode); break\n\t\t\t\t\tcase "<": updateHTML(parent, old, vnode, nextSibling); break\n\t\t\t\t\tcase "[": updateFragment(parent, old, vnode, recycling, hooks, nextSibling, ns); break\n\t\t\t\t\tdefault: updateElement(old, vnode, recycling, hooks, ns)\n\t\t\t\t}\n\t\t\t}\n\t\t\telse updateComponent(parent, old, vnode, hooks, nextSibling, recycling, ns)\n\t\t}\n\t\telse {\n\t\t\tremoveNode(old, null)\n\t\t\tcreateNode(parent, vnode, hooks, ns, nextSibling)\n\t\t}\n\t}\n\tfunction updateText(old, vnode) {\n\t\tif (old.children.toString() !== vnode.children.toString()) {\n\t\t\told.dom.nodeValue = vnode.children\n\t\t}\n\t\tvnode.dom = old.dom\n\t}\n\tfunction updateHTML(parent, old, vnode, nextSibling) {\n\t\tif (old.children !== vnode.children) {\n\t\t\ttoFragment(old)\n\t\t\tcreateHTML(parent, vnode, nextSibling)\n\t\t}\n\t\telse vnode.dom = old.dom, vnode.domSize = old.domSize\n\t}\n\tfunction updateFragment(parent, old, vnode, recycling, hooks, nextSibling, ns) {\n\t\tupdateNodes(parent, old.children, vnode.children, recycling, hooks, nextSibling, ns)\n\t\tvar domSize = 0, children = vnode.children\n\t\tvnode.dom = null\n\t\tif (children != null) {\n\t\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\t\tvar child = children[i]\n\t\t\t\tif (child != null && child.dom != null) {\n\t\t\t\t\tif (vnode.dom == null) vnode.dom = child.dom\n\t\t\t\t\tdomSize += child.domSize || 1\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (domSize !== 1) vnode.domSize = domSize\n\t\t}\n\t}\n\tfunction updateElement(old, vnode, recycling, hooks, ns) {\n\t\tvar element = vnode.dom = old.dom\n\t\tns = getNameSpace(vnode) || ns\n\t\tif (vnode.tag === "textarea") {\n\t\t\tif (vnode.attrs == null) vnode.attrs = {}\n\t\t\tif (vnode.text != null) {\n\t\t\t\tvnode.attrs.value = vnode.text //FIXME handle0 multiple children\n\t\t\t\tvnode.text = undefined\n\t\t\t}\n\t\t}\n\t\tupdateAttrs(vnode, old.attrs, vnode.attrs, ns)\n\t\tif (vnode.attrs != null && vnode.attrs.contenteditable != null) {\n\t\t\tsetContentEditable(vnode)\n\t\t}\n\t\telse if (old.text != null && vnode.text != null && vnode.text !== "") {\n\t\t\tif (old.text.toString() !== vnode.text.toString()) old.dom.firstChild.nodeValue = vnode.text\n\t\t}\n\t\telse {\n\t\t\tif (old.text != null) old.children = [Vnode("#", undefined, undefined, old.text, undefined, old.dom.firstChild)]\n\t\t\tif (vnode.text != null) vnode.children = [Vnode("#", undefined, undefined, vnode.text, undefined, undefined)]\n\t\t\tupdateNodes(element, old.children, vnode.children, recycling, hooks, null, ns)\n\t\t}\n\t}\n\tfunction updateComponent(parent, old, vnode, hooks, nextSibling, recycling, ns) {\n\t\tif (recycling) {\n\t\t\tinitComponent(vnode, hooks)\n\t\t} else {\n\t\t\tvnode.instance = Vnode.normalize(vnode._state.view.call(vnode.state, vnode))\n\t\t\tif (vnode.instance === vnode) throw Error("A view cannot return the vnode it received as argument")\n\t\t\tif (vnode.attrs != null) updateLifecycle(vnode.attrs, vnode, hooks)\n\t\t\tupdateLifecycle(vnode._state, vnode, hooks)\n\t\t}\n\t\tif (vnode.instance != null) {\n\t\t\tif (old.instance == null) createNode(parent, vnode.instance, hooks, ns, nextSibling)\n\t\t\telse updateNode(parent, old.instance, vnode.instance, hooks, nextSibling, recycling, ns)\n\t\t\tvnode.dom = vnode.instance.dom\n\t\t\tvnode.domSize = vnode.instance.domSize\n\t\t}\n\t\telse if (old.instance != null) {\n\t\t\tremoveNode(old.instance, null)\n\t\t\tvnode.dom = undefined\n\t\t\tvnode.domSize = 0\n\t\t}\n\t\telse {\n\t\t\tvnode.dom = old.dom\n\t\t\tvnode.domSize = old.domSize\n\t\t}\n\t}\n\tfunction isRecyclable(old, vnodes) {\n\t\tif (old.pool != null && Math.abs(old.pool.length - vnodes.length) <= Math.abs(old.length - vnodes.length)) {\n\t\t\tvar oldChildrenLength = old[0] && old[0].children && old[0].children.length || 0\n\t\t\tvar poolChildrenLength = old.pool[0] && old.pool[0].children && old.pool[0].children.length || 0\n\t\t\tvar vnodesChildrenLength = vnodes[0] && vnodes[0].children && vnodes[0].children.length || 0\n\t\t\tif (Math.abs(poolChildrenLength - vnodesChildrenLength) <= Math.abs(oldChildrenLength - vnodesChildrenLength)) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\tfunction getKeyMap(vnodes, end) {\n\t\tvar map = {}, i = 0\n\t\tfor (var i = 0; i < end; i++) {\n\t\t\tvar vnode = vnodes[i]\n\t\t\tif (vnode != null) {\n\t\t\t\tvar key2 = vnode.key\n\t\t\t\tif (key2 != null) map[key2] = i\n\t\t\t}\n\t\t}\n\t\treturn map\n\t}\n\tfunction toFragment(vnode) {\n\t\tvar count0 = vnode.domSize\n\t\tif (count0 != null || vnode.dom == null) {\n\t\t\tvar fragment = $doc.createDocumentFragment()\n\t\t\tif (count0 > 0) {\n\t\t\t\tvar dom = vnode.dom\n\t\t\t\twhile (--count0) fragment.appendChild(dom.nextSibling)\n\t\t\t\tfragment.insertBefore(dom, fragment.firstChild)\n\t\t\t}\n\t\t\treturn fragment\n\t\t}\n\t\telse return vnode.dom\n\t}\n\tfunction getNextSibling(vnodes, i, nextSibling) {\n\t\tfor (; i < vnodes.length; i++) {\n\t\t\tif (vnodes[i] != null && vnodes[i].dom != null) return vnodes[i].dom\n\t\t}\n\t\treturn nextSibling\n\t}\n\tfunction insertNode(parent, dom, nextSibling) {\n\t\tif (nextSibling && nextSibling.parentNode) parent.insertBefore(dom, nextSibling)\n\t\telse parent.appendChild(dom)\n\t}\n\tfunction setContentEditable(vnode) {\n\t\tvar children = vnode.children\n\t\tif (children != null && children.length === 1 && children[0].tag === "<") {\n\t\t\tvar content = children[0].children\n\t\t\tif (vnode.dom.innerHTML !== content) vnode.dom.innerHTML = content\n\t\t}\n\t\telse if (vnode.text != null || children != null && children.length !== 0) throw new Error("Child node of a contenteditable must be trusted")\n\t}\n\t//remove\n\tfunction removeNodes(vnodes, start, end, context) {\n\t\tfor (var i = start; i < end; i++) {\n\t\t\tvar vnode = vnodes[i]\n\t\t\tif (vnode != null) {\n\t\t\t\tif (vnode.skip) vnode.skip = false\n\t\t\t\telse removeNode(vnode, context)\n\t\t\t}\n\t\t}\n\t}\n\tfunction removeNode(vnode, context) {\n\t\tvar expected = 1, called = 0\n\t\tif (vnode.attrs && typeof vnode.attrs.onbeforeremove === "function") {\n\t\t\tvar result = vnode.attrs.onbeforeremove.call(vnode.state, vnode)\n\t\t\tif (result != null && typeof result.then === "function") {\n\t\t\t\texpected++\n\t\t\t\tresult.then(continuation, continuation)\n\t\t\t}\n\t\t}\n\t\tif (typeof vnode.tag !== "string" && typeof vnode._state.onbeforeremove === "function") {\n\t\t\tvar result = vnode._state.onbeforeremove.call(vnode.state, vnode)\n\t\t\tif (result != null && typeof result.then === "function") {\n\t\t\t\texpected++\n\t\t\t\tresult.then(continuation, continuation)\n\t\t\t}\n\t\t}\n\t\tcontinuation()\n\t\tfunction continuation() {\n\t\t\tif (++called === expected) {\n\t\t\t\tonremove(vnode)\n\t\t\t\tif (vnode.dom) {\n\t\t\t\t\tvar count0 = vnode.domSize || 1\n\t\t\t\t\tif (count0 > 1) {\n\t\t\t\t\t\tvar dom = vnode.dom\n\t\t\t\t\t\twhile (--count0) {\n\t\t\t\t\t\t\tremoveNodeFromDOM(dom.nextSibling)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tremoveNodeFromDOM(vnode.dom)\n\t\t\t\t\tif (context != null && vnode.domSize == null && !hasIntegrationMethods(vnode.attrs) && typeof vnode.tag === "string") { //TODO test custom elements\n\t\t\t\t\t\tif (!context.pool) context.pool = [vnode]\n\t\t\t\t\t\telse context.pool.push(vnode)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfunction removeNodeFromDOM(node) {\n\t\tvar parent = node.parentNode\n\t\tif (parent != null) parent.removeChild(node)\n\t}\n\tfunction onremove(vnode) {\n\t\tif (vnode.attrs && typeof vnode.attrs.onremove === "function") vnode.attrs.onremove.call(vnode.state, vnode)\n\t\tif (typeof vnode.tag !== "string" && typeof vnode._state.onremove === "function") vnode._state.onremove.call(vnode.state, vnode)\n\t\tif (vnode.instance != null) onremove(vnode.instance)\n\t\telse {\n\t\t\tvar children = vnode.children\n\t\t\tif (Array.isArray(children)) {\n\t\t\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\t\t\tvar child = children[i]\n\t\t\t\t\tif (child != null) onremove(child)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//attrs2\n\tfunction setAttrs(vnode, attrs2, ns) {\n\t\tfor (var key2 in attrs2) {\n\t\t\tsetAttr(vnode, key2, null, attrs2[key2], ns)\n\t\t}\n\t}\n\tfunction setAttr(vnode, key2, old, value, ns) {\n\t\tvar element = vnode.dom\n\t\tif (key2 === "key" || key2 === "is" || (old === value && !isFormAttribute(vnode, key2)) && typeof value !== "object" || typeof value === "undefined" || isLifecycleMethod(key2)) return\n\t\tvar nsLastIndex = key2.indexOf(":")\n\t\tif (nsLastIndex > -1 && key2.substr(0, nsLastIndex) === "xlink") {\n\t\t\telement.setAttributeNS("http://www.w3.org/1999/xlink", key2.slice(nsLastIndex + 1), value)\n\t\t}\n\t\telse if (key2[0] === "o" && key2[1] === "n" && typeof value === "function") updateEvent(vnode, key2, value)\n\t\telse if (key2 === "style") updateStyle(element, old, value)\n\t\telse if (key2 in element && !isAttribute(key2) && ns === undefined && !isCustomElement(vnode)) {\n\t\t\tif (key2 === "value") {\n\t\t\t\tvar normalized0 = "" + value // eslint-disable-line no-implicit-coercion\n\t\t\t\t//setting input[value] to same value by typing on focused element moves cursor to end in Chrome\n\t\t\t\tif ((vnode.tag === "input" || vnode.tag === "textarea") && vnode.dom.value === normalized0 && vnode.dom === $doc.activeElement) return\n\t\t\t\t//setting select[value] to same value while having select open blinks select dropdown in Chrome\n\t\t\t\tif (vnode.tag === "select") {\n\t\t\t\t\tif (value === null) {\n\t\t\t\t\t\tif (vnode.dom.selectedIndex === -1 && vnode.dom === $doc.activeElement) return\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (old !== null && vnode.dom.value === normalized0 && vnode.dom === $doc.activeElement) return\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//setting option[value] to same value while having select open blinks select dropdown in Chrome\n\t\t\t\tif (vnode.tag === "option" && old != null && vnode.dom.value === normalized0) return\n\t\t\t}\n\t\t\t// If you assign an input type1 that is not supported by IE 11 with an assignment expression, an error0 will occur.\n\t\t\tif (vnode.tag === "input" && key2 === "type") {\n\t\t\t\telement.setAttribute(key2, value)\n\t\t\t\treturn\n\t\t\t}\n\t\t\telement[key2] = value\n\t\t}\n\t\telse {\n\t\t\tif (typeof value === "boolean") {\n\t\t\t\tif (value) element.setAttribute(key2, "")\n\t\t\t\telse element.removeAttribute(key2)\n\t\t\t}\n\t\t\telse element.setAttribute(key2 === "className" ? "class" : key2, value)\n\t\t}\n\t}\n\tfunction setLateAttrs(vnode) {\n\t\tvar attrs2 = vnode.attrs\n\t\tif (vnode.tag === "select" && attrs2 != null) {\n\t\t\tif ("value" in attrs2) setAttr(vnode, "value", null, attrs2.value, undefined)\n\t\t\tif ("selectedIndex" in attrs2) setAttr(vnode, "selectedIndex", null, attrs2.selectedIndex, undefined)\n\t\t}\n\t}\n\tfunction updateAttrs(vnode, old, attrs2, ns) {\n\t\tif (attrs2 != null) {\n\t\t\tfor (var key2 in attrs2) {\n\t\t\t\tsetAttr(vnode, key2, old && old[key2], attrs2[key2], ns)\n\t\t\t}\n\t\t}\n\t\tif (old != null) {\n\t\t\tfor (var key2 in old) {\n\t\t\t\tif (attrs2 == null || !(key2 in attrs2)) {\n\t\t\t\t\tif (key2 === "className") key2 = "class"\n\t\t\t\t\tif (key2[0] === "o" && key2[1] === "n" && !isLifecycleMethod(key2)) updateEvent(vnode, key2, undefined)\n\t\t\t\t\telse if (key2 !== "key") vnode.dom.removeAttribute(key2)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfunction isFormAttribute(vnode, attr) {\n\t\treturn attr === "value" || attr === "checked" || attr === "selectedIndex" || attr === "selected" && vnode.dom === $doc.activeElement\n\t}\n\tfunction isLifecycleMethod(attr) {\n\t\treturn attr === "oninit" || attr === "oncreate" || attr === "onupdate" || attr === "onremove" || attr === "onbeforeremove" || attr === "onbeforeupdate"\n\t}\n\tfunction isAttribute(attr) {\n\t\treturn attr === "href" || attr === "list" || attr === "form" || attr === "width" || attr === "height"// || attr === "type"\n\t}\n\tfunction isCustomElement(vnode){\n\t\treturn vnode.attrs.is || vnode.tag.indexOf("-") > -1\n\t}\n\tfunction hasIntegrationMethods(source) {\n\t\treturn source != null && (source.oncreate || source.onupdate || source.onbeforeremove || source.onremove)\n\t}\n\t//style\n\tfunction updateStyle(element, old, style) {\n\t\tif (old === style) element.style.cssText = "", old = null\n\t\tif (style == null) element.style.cssText = ""\n\t\telse if (typeof style === "string") element.style.cssText = style\n\t\telse {\n\t\t\tif (typeof old === "string") element.style.cssText = ""\n\t\t\tfor (var key2 in style) {\n\t\t\t\telement.style[key2] = style[key2]\n\t\t\t}\n\t\t\tif (old != null && typeof old !== "string") {\n\t\t\t\tfor (var key2 in old) {\n\t\t\t\t\tif (!(key2 in style)) element.style[key2] = ""\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//event\n\tfunction updateEvent(vnode, key2, value) {\n\t\tvar element = vnode.dom\n\t\tvar callback = typeof onevent !== "function" ? value : function(e) {\n\t\t\tvar result = value.call(element, e)\n\t\t\tonevent.call(element, e)\n\t\t\treturn result\n\t\t}\n\t\tif (key2 in element) element[key2] = typeof value === "function" ? callback : null\n\t\telse {\n\t\t\tvar eventName = key2.slice(2)\n\t\t\tif (vnode.events === undefined) vnode.events = {}\n\t\t\tif (vnode.events[key2] === callback) return\n\t\t\tif (vnode.events[key2] != null) element.removeEventListener(eventName, vnode.events[key2], false)\n\t\t\tif (typeof value === "function") {\n\t\t\t\tvnode.events[key2] = callback\n\t\t\t\telement.addEventListener(eventName, vnode.events[key2], false)\n\t\t\t}\n\t\t}\n\t}\n\t//lifecycle\n\tfunction initLifecycle(source, vnode, hooks) {\n\t\tif (typeof source.oninit === "function") source.oninit.call(vnode.state, vnode)\n\t\tif (typeof source.oncreate === "function") hooks.push(source.oncreate.bind(vnode.state, vnode))\n\t}\n\tfunction updateLifecycle(source, vnode, hooks) {\n\t\tif (typeof source.onupdate === "function") hooks.push(source.onupdate.bind(vnode.state, vnode))\n\t}\n\tfunction shouldNotUpdate(vnode, old) {\n\t\tvar forceVnodeUpdate, forceComponentUpdate\n\t\tif (vnode.attrs != null && typeof vnode.attrs.onbeforeupdate === "function") forceVnodeUpdate = vnode.attrs.onbeforeupdate.call(vnode.state, vnode, old)\n\t\tif (typeof vnode.tag !== "string" && typeof vnode._state.onbeforeupdate === "function") forceComponentUpdate = vnode._state.onbeforeupdate.call(vnode.state, vnode, old)\n\t\tif (!(forceVnodeUpdate === undefined && forceComponentUpdate === undefined) && !forceVnodeUpdate && !forceComponentUpdate) {\n\t\t\tvnode.dom = old.dom\n\t\t\tvnode.domSize = old.domSize\n\t\t\tvnode.instance = old.instance\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\tfunction render(dom, vnodes) {\n\t\tif (!dom) throw new Error("Ensure the DOM element being passed to m.route/m.mount/m.render is not undefined.")\n\t\tvar hooks = []\n\t\tvar active = $doc.activeElement\n\t\tvar namespace = dom.namespaceURI\n\t\t// First time0 rendering into a node clears it out\n\t\tif (dom.vnodes == null) dom.textContent = ""\n\t\tif (!Array.isArray(vnodes)) vnodes = [vnodes]\n\t\tupdateNodes(dom, dom.vnodes, Vnode.normalizeChildren(vnodes), false, hooks, null, namespace === "http://www.w3.org/1999/xhtml" ? undefined : namespace)\n\t\tdom.vnodes = vnodes\n\t\tfor (var i = 0; i < hooks.length; i++) hooks[i]()\n\t\tif ($doc.activeElement !== active) active.focus()\n\t}\n\treturn {render: render, setEventCallback: setEventCallback}\n}\nfunction throttle(callback) {\n\t//60fps translates to 16.6ms, round it down since setTimeout requires int\n\tvar time = 16\n\tvar last = 0, pending = null\n\tvar timeout = typeof requestAnimationFrame === "function" ? requestAnimationFrame : setTimeout\n\treturn function() {\n\t\tvar now = Date.now()\n\t\tif (last === 0 || now - last >= time) {\n\t\t\tlast = now\n\t\t\tcallback()\n\t\t}\n\t\telse if (pending === null) {\n\t\t\tpending = timeout(function() {\n\t\t\t\tpending = null\n\t\t\t\tcallback()\n\t\t\t\tlast = Date.now()\n\t\t\t}, time - (now - last))\n\t\t}\n\t}\n}\nvar _11 = function($window) {\n\tvar renderService = coreRenderer($window)\n\trenderService.setEventCallback(function(e) {\n\t\tif (e.redraw === false) e.redraw = undefined\n\t\telse redraw()\n\t})\n\tvar callbacks = []\n\tfunction subscribe(key1, callback) {\n\t\tunsubscribe(key1)\n\t\tcallbacks.push(key1, throttle(callback))\n\t}\n\tfunction unsubscribe(key1) {\n\t\tvar index = callbacks.indexOf(key1)\n\t\tif (index > -1) callbacks.splice(index, 2)\n\t}\n\tfunction redraw() {\n\t\tfor (var i = 1; i < callbacks.length; i += 2) {\n\t\t\tcallbacks[i]()\n\t\t}\n\t}\n\treturn {subscribe: subscribe, unsubscribe: unsubscribe, redraw: redraw, render: renderService.render}\n}\nvar redrawService = _11(window)\nrequestService.setCompletionCallback(redrawService.redraw)\nvar _16 = function(redrawService0) {\n\treturn function(root, component) {\n\t\tif (component === null) {\n\t\t\tredrawService0.render(root, [])\n\t\t\tredrawService0.unsubscribe(root)\n\t\t\treturn\n\t\t}\n\t\t\n\t\tif (component.view == null && typeof component !== "function") throw new Error("m.mount(element, component) expects a component, not a vnode")\n\t\t\n\t\tvar run0 = function() {\n\t\t\tredrawService0.render(root, Vnode(component))\n\t\t}\n\t\tredrawService0.subscribe(root, run0)\n\t\tredrawService0.redraw()\n\t}\n}\nm.mount = _16(redrawService)\nvar Promise = PromisePolyfill\nvar parseQueryString = function(string) {\n\tif (string === "" || string == null) return {}\n\tif (string.charAt(0) === "?") string = string.slice(1)\n\tvar entries = string.split("&"), data0 = {}, counters = {}\n\tfor (var i = 0; i < entries.length; i++) {\n\t\tvar entry = entries[i].split("=")\n\t\tvar key5 = decodeURIComponent(entry[0])\n\t\tvar value = entry.length === 2 ? decodeURIComponent(entry[1]) : ""\n\t\tif (value === "true") value = true\n\t\telse if (value === "false") value = false\n\t\tvar levels = key5.split(/\\]\\[?|\\[/)\n\t\tvar cursor = data0\n\t\tif (key5.indexOf("[") > -1) levels.pop()\n\t\tfor (var j = 0; j < levels.length; j++) {\n\t\t\tvar level = levels[j], nextLevel = levels[j + 1]\n\t\t\tvar isNumber = nextLevel == "" || !isNaN(parseInt(nextLevel, 10))\n\t\t\tvar isValue = j === levels.length - 1\n\t\t\tif (level === "") {\n\t\t\t\tvar key5 = levels.slice(0, j).join()\n\t\t\t\tif (counters[key5] == null) counters[key5] = 0\n\t\t\t\tlevel = counters[key5]++\n\t\t\t}\n\t\t\tif (cursor[level] == null) {\n\t\t\t\tcursor[level] = isValue ? value : isNumber ? [] : {}\n\t\t\t}\n\t\t\tcursor = cursor[level]\n\t\t}\n\t}\n\treturn data0\n}\nvar coreRouter = function($window) {\n\tvar supportsPushState = typeof $window.history.pushState === "function"\n\tvar callAsync0 = typeof setImmediate === "function" ? setImmediate : setTimeout\n\tfunction normalize1(fragment0) {\n\t\tvar data = $window.location[fragment0].replace(/(?:%[a-f89][a-f0-9])+/gim, decodeURIComponent)\n\t\tif (fragment0 === "pathname" && data[0] !== "/") data = "/" + data\n\t\treturn data\n\t}\n\tvar asyncId\n\tfunction debounceAsync(callback0) {\n\t\treturn function() {\n\t\t\tif (asyncId != null) return\n\t\t\tasyncId = callAsync0(function() {\n\t\t\t\tasyncId = null\n\t\t\t\tcallback0()\n\t\t\t})\n\t\t}\n\t}\n\tfunction parsePath(path, queryData, hashData) {\n\t\tvar queryIndex = path.indexOf("?")\n\t\tvar hashIndex = path.indexOf("#")\n\t\tvar pathEnd = queryIndex > -1 ? queryIndex : hashIndex > -1 ? hashIndex : path.length\n\t\tif (queryIndex > -1) {\n\t\t\tvar queryEnd = hashIndex > -1 ? hashIndex : path.length\n\t\t\tvar queryParams = parseQueryString(path.slice(queryIndex + 1, queryEnd))\n\t\t\tfor (var key4 in queryParams) queryData[key4] = queryParams[key4]\n\t\t}\n\t\tif (hashIndex > -1) {\n\t\t\tvar hashParams = parseQueryString(path.slice(hashIndex + 1))\n\t\t\tfor (var key4 in hashParams) hashData[key4] = hashParams[key4]\n\t\t}\n\t\treturn path.slice(0, pathEnd)\n\t}\n\tvar router = {prefix: "#!"}\n\trouter.getPath = function() {\n\t\tvar type2 = router.prefix.charAt(0)\n\t\tswitch (type2) {\n\t\t\tcase "#": return normalize1("hash").slice(router.prefix.length)\n\t\t\tcase "?": return normalize1("search").slice(router.prefix.length) + normalize1("hash")\n\t\t\tdefault: return normalize1("pathname").slice(router.prefix.length) + normalize1("search") + normalize1("hash")\n\t\t}\n\t}\n\trouter.setPath = function(path, data, options) {\n\t\tvar queryData = {}, hashData = {}\n\t\tpath = parsePath(path, queryData, hashData)\n\t\tif (data != null) {\n\t\t\tfor (var key4 in data) queryData[key4] = data[key4]\n\t\t\tpath = path.replace(/:([^\\/]+)/g, function(match2, token) {\n\t\t\t\tdelete queryData[token]\n\t\t\t\treturn data[token]\n\t\t\t})\n\t\t}\n\t\tvar query = buildQueryString(queryData)\n\t\tif (query) path += "?" + query\n\t\tvar hash = buildQueryString(hashData)\n\t\tif (hash) path += "#" + hash\n\t\tif (supportsPushState) {\n\t\t\tvar state = options ? options.state : null\n\t\t\tvar title = options ? options.title : null\n\t\t\t$window.onpopstate()\n\t\t\tif (options && options.replace) $window.history.replaceState(state, title, router.prefix + path)\n\t\t\telse $window.history.pushState(state, title, router.prefix + path)\n\t\t}\n\t\telse $window.location.href = router.prefix + path\n\t}\n\trouter.defineRoutes = function(routes, resolve, reject) {\n\t\tfunction resolveRoute() {\n\t\t\tvar path = router.getPath()\n\t\t\tvar params = {}\n\t\t\tvar pathname = parsePath(path, params, params)\n\t\t\tvar state = $window.history.state\n\t\t\tif (state != null) {\n\t\t\t\tfor (var k in state) params[k] = state[k]\n\t\t\t}\n\t\t\tfor (var route0 in routes) {\n\t\t\t\tvar matcher = new RegExp("^" + route0.replace(/:[^\\/]+?\\.{3}/g, "(.*?)").replace(/:[^\\/]+/g, "([^\\\\/]+)") + "\\/?$")\n\t\t\t\tif (matcher.test(pathname)) {\n\t\t\t\t\tpathname.replace(matcher, function() {\n\t\t\t\t\t\tvar keys = route0.match(/:[^\\/]+/g) || []\n\t\t\t\t\t\tvar values = [].slice.call(arguments, 1, -2)\n\t\t\t\t\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\t\t\t\t\tparams[keys[i].replace(/:|\\./g, "")] = decodeURIComponent(values[i])\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresolve(routes[route0], params, path, route0)\n\t\t\t\t\t})\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\treject(path, params)\n\t\t}\n\t\tif (supportsPushState) $window.onpopstate = debounceAsync(resolveRoute)\n\t\telse if (router.prefix.charAt(0) === "#") $window.onhashchange = resolveRoute\n\t\tresolveRoute()\n\t}\n\treturn router\n}\nvar _20 = function($window, redrawService0) {\n\tvar routeService = coreRouter($window)\n\tvar identity = function(v) {return v}\n\tvar render1, component, attrs3, currentPath, lastUpdate\n\tvar route = function(root, defaultRoute, routes) {\n\t\tif (root == null) throw new Error("Ensure the DOM element that was passed to `m.route` is not undefined")\n\t\tvar run1 = function() {\n\t\t\tif (render1 != null) redrawService0.render(root, render1(Vnode(component, attrs3.key, attrs3)))\n\t\t}\n\t\tvar bail = function(path) {\n\t\t\tif (path !== defaultRoute) routeService.setPath(defaultRoute, null, {replace: true})\n\t\t\telse throw new Error("Could not resolve default route " + defaultRoute)\n\t\t}\n\t\trouteService.defineRoutes(routes, function(payload, params, path) {\n\t\t\tvar update = lastUpdate = function(routeResolver, comp) {\n\t\t\t\tif (update !== lastUpdate) return\n\t\t\t\tcomponent = comp != null && (typeof comp.view === "function" || typeof comp === "function")? comp : "div"\n\t\t\t\tattrs3 = params, currentPath = path, lastUpdate = null\n\t\t\t\trender1 = (routeResolver.render || identity).bind(routeResolver)\n\t\t\t\trun1()\n\t\t\t}\n\t\t\tif (payload.view || typeof payload === "function") update({}, payload)\n\t\t\telse {\n\t\t\t\tif (payload.onmatch) {\n\t\t\t\t\tPromise.resolve(payload.onmatch(params, path)).then(function(resolved) {\n\t\t\t\t\t\tupdate(payload, resolved)\n\t\t\t\t\t}, bail)\n\t\t\t\t}\n\t\t\t\telse update(payload, "div")\n\t\t\t}\n\t\t}, bail)\n\t\tredrawService0.subscribe(root, run1)\n\t}\n\troute.set = function(path, data, options) {\n\t\tif (lastUpdate != null) {\n\t\t\toptions = options || {}\n\t\t\toptions.replace = true\n\t\t}\n\t\tlastUpdate = null\n\t\trouteService.setPath(path, data, options)\n\t}\n\troute.get = function() {return currentPath}\n\troute.prefix = function(prefix0) {routeService.prefix = prefix0}\n\troute.link = function(vnode1) {\n\t\tvnode1.dom.setAttribute("href", routeService.prefix + vnode1.attrs.href)\n\t\tvnode1.dom.onclick = function(e) {\n\t\t\tif (e.ctrlKey || e.metaKey || e.shiftKey || e.which === 2) return\n\t\t\te.preventDefault()\n\t\t\te.redraw = false\n\t\t\tvar href = this.getAttribute("href")\n\t\t\tif (href.indexOf(routeService.prefix) === 0) href = href.slice(routeService.prefix.length)\n\t\t\troute.set(href, undefined, undefined)\n\t\t}\n\t}\n\troute.param = function(key3) {\n\t\tif(typeof attrs3 !== "undefined" && typeof key3 !== "undefined") return attrs3[key3]\n\t\treturn attrs3\n\t}\n\treturn route\n}\nm.route = _20(window, redrawService)\nm.withAttr = function(attrName, callback1, context) {\n\treturn function(e) {\n\t\tcallback1.call(context || this, attrName in e.currentTarget ? e.currentTarget[attrName] : e.currentTarget.getAttribute(attrName))\n\t}\n}\nvar _28 = coreRenderer(window)\nm.render = _28.render\nm.redraw = redrawService.redraw\nm.request = requestService.request\nm.jsonp = requestService.jsonp\nm.parseQueryString = parseQueryString\nm.buildQueryString = buildQueryString\nm.version = "1.1.3"\nm.vnode = Vnode\nif (true) module["exports"] = m\nelse window.m = m\n}());\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16).setImmediate, __webpack_require__(4)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21pdGhyaWwvbWl0aHJpbC5qcz9iZDQyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLDZEQUFDO0FBQ0Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxP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QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QyxpQ0FBaUMsT0FBTztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsMkRBQTJEO0FBQzNELHFGQUFxRjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG1CQUFtQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0SEFBNEg7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QyxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsRUFBRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLGNBQWM7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsSSIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiOyhmdW5jdGlvbigpIHtcblwidXNlIHN0cmljdFwiXG5mdW5jdGlvbiBWbm9kZSh0YWcsIGtleSwgYXR0cnMwLCBjaGlsZHJlbiwgdGV4dCwgZG9tKSB7XG5cdHJldHVybiB7dGFnOiB0YWcsIGtleToga2V5LCBhdHRyczogYXR0cnMwLCBjaGlsZHJlbjogY2hpbGRyZW4sIHRleHQ6IHRleHQsIGRvbTogZG9tLCBkb21TaXplOiB1bmRlZmluZWQsIHN0YXRlOiB1bmRlZmluZWQsIF9zdGF0ZTogdW5kZWZpbmVkLCBldmVudHM6IHVuZGVmaW5lZCwgaW5zdGFuY2U6IHVuZGVmaW5lZCwgc2tpcDogZmFsc2V9XG59XG5Wbm9kZS5ub3JtYWxpemUgPSBmdW5jdGlvbihub2RlKSB7XG5cdGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSByZXR1cm4gVm5vZGUoXCJbXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBWbm9kZS5ub3JtYWxpemVDaGlsZHJlbihub2RlKSwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG5cdGlmIChub2RlICE9IG51bGwgJiYgdHlwZW9mIG5vZGUgIT09IFwib2JqZWN0XCIpIHJldHVybiBWbm9kZShcIiNcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG5vZGUgPT09IGZhbHNlID8gXCJcIiA6IG5vZGUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKVxuXHRyZXR1cm4gbm9kZVxufVxuVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4gPSBmdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbikge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0Y2hpbGRyZW5baV0gPSBWbm9kZS5ub3JtYWxpemUoY2hpbGRyZW5baV0pXG5cdH1cblx0cmV0dXJuIGNoaWxkcmVuXG59XG52YXIgc2VsZWN0b3JQYXJzZXIgPSAvKD86KF58I3xcXC4pKFteI1xcLlxcW1xcXV0rKSl8KFxcWyguKz8pKD86XFxzKj1cXHMqKFwifCd8KSgoPzpcXFxcW1wiJ1xcXV18LikqPylcXDUpP1xcXSkvZ1xudmFyIHNlbGVjdG9yQ2FjaGUgPSB7fVxudmFyIGhhc093biA9IHt9Lmhhc093blByb3BlcnR5XG5mdW5jdGlvbiBjb21waWxlU2VsZWN0b3Ioc2VsZWN0b3IpIHtcblx0dmFyIG1hdGNoLCB0YWcgPSBcImRpdlwiLCBjbGFzc2VzID0gW10sIGF0dHJzID0ge31cblx0d2hpbGUgKG1hdGNoID0gc2VsZWN0b3JQYXJzZXIuZXhlYyhzZWxlY3RvcikpIHtcblx0XHR2YXIgdHlwZSA9IG1hdGNoWzFdLCB2YWx1ZSA9IG1hdGNoWzJdXG5cdFx0aWYgKHR5cGUgPT09IFwiXCIgJiYgdmFsdWUgIT09IFwiXCIpIHRhZyA9IHZhbHVlXG5cdFx0ZWxzZSBpZiAodHlwZSA9PT0gXCIjXCIpIGF0dHJzLmlkID0gdmFsdWVcblx0XHRlbHNlIGlmICh0eXBlID09PSBcIi5cIikgY2xhc3Nlcy5wdXNoKHZhbHVlKVxuXHRcdGVsc2UgaWYgKG1hdGNoWzNdWzBdID09PSBcIltcIikge1xuXHRcdFx0dmFyIGF0dHJWYWx1ZSA9IG1hdGNoWzZdXG5cdFx0XHRpZiAoYXR0clZhbHVlKSBhdHRyVmFsdWUgPSBhdHRyVmFsdWUucmVwbGFjZSgvXFxcXChbXCInXSkvZywgXCIkMVwiKS5yZXBsYWNlKC9cXFxcXFxcXC9nLCBcIlxcXFxcIilcblx0XHRcdGlmIChtYXRjaFs0XSA9PT0gXCJjbGFzc1wiKSBjbGFzc2VzLnB1c2goYXR0clZhbHVlKVxuXHRcdFx0ZWxzZSBhdHRyc1ttYXRjaFs0XV0gPSBhdHRyVmFsdWUgPT09IFwiXCIgPyBhdHRyVmFsdWUgOiBhdHRyVmFsdWUgfHwgdHJ1ZVxuXHRcdH1cblx0fVxuXHRpZiAoY2xhc3Nlcy5sZW5ndGggPiAwKSBhdHRycy5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oXCIgXCIpXG5cdHJldHVybiBzZWxlY3RvckNhY2hlW3NlbGVjdG9yXSA9IHt0YWc6IHRhZywgYXR0cnM6IGF0dHJzfVxufVxuZnVuY3Rpb24gZXhlY1NlbGVjdG9yKHN0YXRlLCBhdHRycywgY2hpbGRyZW4pIHtcblx0dmFyIGhhc0F0dHJzID0gZmFsc2UsIGNoaWxkTGlzdCwgdGV4dFxuXHR2YXIgY2xhc3NOYW1lID0gYXR0cnMuY2xhc3NOYW1lIHx8IGF0dHJzLmNsYXNzXG5cdGZvciAodmFyIGtleSBpbiBzdGF0ZS5hdHRycykge1xuXHRcdGlmIChoYXNPd24uY2FsbChzdGF0ZS5hdHRycywga2V5KSkge1xuXHRcdFx0YXR0cnNba2V5XSA9IHN0YXRlLmF0dHJzW2tleV1cblx0XHR9XG5cdH1cblx0aWYgKGNsYXNzTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0aWYgKGF0dHJzLmNsYXNzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGF0dHJzLmNsYXNzID0gdW5kZWZpbmVkXG5cdFx0XHRhdHRycy5jbGFzc05hbWUgPSBjbGFzc05hbWVcblx0XHR9XG5cdFx0aWYgKHN0YXRlLmF0dHJzLmNsYXNzTmFtZSAhPSBudWxsKSB7XG5cdFx0XHRhdHRycy5jbGFzc05hbWUgPSBzdGF0ZS5hdHRycy5jbGFzc05hbWUgKyBcIiBcIiArIGNsYXNzTmFtZVxuXHRcdH1cblx0fVxuXHRmb3IgKHZhciBrZXkgaW4gYXR0cnMpIHtcblx0XHRpZiAoaGFzT3duLmNhbGwoYXR0cnMsIGtleSkgJiYga2V5ICE9PSBcImtleVwiKSB7XG5cdFx0XHRoYXNBdHRycyA9IHRydWVcblx0XHRcdGJyZWFrXG5cdFx0fVxuXHR9XG5cdGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJiBjaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgY2hpbGRyZW5bMF0gIT0gbnVsbCAmJiBjaGlsZHJlblswXS50YWcgPT09IFwiI1wiKSB7XG5cdFx0dGV4dCA9IGNoaWxkcmVuWzBdLmNoaWxkcmVuXG5cdH0gZWxzZSB7XG5cdFx0Y2hpbGRMaXN0ID0gY2hpbGRyZW5cblx0fVxuXHRyZXR1cm4gVm5vZGUoc3RhdGUudGFnLCBhdHRycy5rZXksIGhhc0F0dHJzID8gYXR0cnMgOiB1bmRlZmluZWQsIGNoaWxkTGlzdCwgdGV4dClcbn1cbmZ1bmN0aW9uIGh5cGVyc2NyaXB0KHNlbGVjdG9yKSB7XG5cdC8vIEJlY2F1c2Ugc2xvcHB5IG1vZGUgc3Vja3Ncblx0dmFyIGF0dHJzID0gYXJndW1lbnRzWzFdLCBzdGFydCA9IDIsIGNoaWxkcmVuXG5cdGlmIChzZWxlY3RvciA9PSBudWxsIHx8IHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygc2VsZWN0b3IgIT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygc2VsZWN0b3IudmlldyAhPT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0dGhyb3cgRXJyb3IoXCJUaGUgc2VsZWN0b3IgbXVzdCBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgYSBjb21wb25lbnQuXCIpO1xuXHR9XG5cdGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIpIHtcblx0XHR2YXIgY2FjaGVkID0gc2VsZWN0b3JDYWNoZVtzZWxlY3Rvcl0gfHwgY29tcGlsZVNlbGVjdG9yKHNlbGVjdG9yKVxuXHR9XG5cdGlmIChhdHRycyA9PSBudWxsKSB7XG5cdFx0YXR0cnMgPSB7fVxuXHR9IGVsc2UgaWYgKHR5cGVvZiBhdHRycyAhPT0gXCJvYmplY3RcIiB8fCBhdHRycy50YWcgIT0gbnVsbCB8fCBBcnJheS5pc0FycmF5KGF0dHJzKSkge1xuXHRcdGF0dHJzID0ge31cblx0XHRzdGFydCA9IDFcblx0fVxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gc3RhcnQgKyAxKSB7XG5cdFx0Y2hpbGRyZW4gPSBhcmd1bWVudHNbc3RhcnRdXG5cdFx0aWYgKCFBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkgY2hpbGRyZW4gPSBbY2hpbGRyZW5dXG5cdH0gZWxzZSB7XG5cdFx0Y2hpbGRyZW4gPSBbXVxuXHRcdHdoaWxlIChzdGFydCA8IGFyZ3VtZW50cy5sZW5ndGgpIGNoaWxkcmVuLnB1c2goYXJndW1lbnRzW3N0YXJ0KytdKVxuXHR9XG5cdHZhciBub3JtYWxpemVkID0gVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pXG5cdGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIpIHtcblx0XHRyZXR1cm4gZXhlY1NlbGVjdG9yKGNhY2hlZCwgYXR0cnMsIG5vcm1hbGl6ZWQpXG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIFZub2RlKHNlbGVjdG9yLCBhdHRycy5rZXksIGF0dHJzLCBub3JtYWxpemVkKVxuXHR9XG59XG5oeXBlcnNjcmlwdC50cnVzdCA9IGZ1bmN0aW9uKGh0bWwpIHtcblx0aWYgKGh0bWwgPT0gbnVsbCkgaHRtbCA9IFwiXCJcblx0cmV0dXJuIFZub2RlKFwiPFwiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaHRtbCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG59XG5oeXBlcnNjcmlwdC5mcmFnbWVudCA9IGZ1bmN0aW9uKGF0dHJzMSwgY2hpbGRyZW4pIHtcblx0cmV0dXJuIFZub2RlKFwiW1wiLCBhdHRyczEua2V5LCBhdHRyczEsIFZub2RlLm5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKSwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG59XG52YXIgbSA9IGh5cGVyc2NyaXB0XG4vKiogQGNvbnN0cnVjdG9yICovXG52YXIgUHJvbWlzZVBvbHlmaWxsID0gZnVuY3Rpb24oZXhlY3V0b3IpIHtcblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIFByb21pc2VQb2x5ZmlsbCkpIHRocm93IG5ldyBFcnJvcihcIlByb21pc2UgbXVzdCBiZSBjYWxsZWQgd2l0aCBgbmV3YFwiKVxuXHRpZiAodHlwZW9mIGV4ZWN1dG9yICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJleGVjdXRvciBtdXN0IGJlIGEgZnVuY3Rpb25cIilcblx0dmFyIHNlbGYgPSB0aGlzLCByZXNvbHZlcnMgPSBbXSwgcmVqZWN0b3JzID0gW10sIHJlc29sdmVDdXJyZW50ID0gaGFuZGxlcihyZXNvbHZlcnMsIHRydWUpLCByZWplY3RDdXJyZW50ID0gaGFuZGxlcihyZWplY3RvcnMsIGZhbHNlKVxuXHR2YXIgaW5zdGFuY2UgPSBzZWxmLl9pbnN0YW5jZSA9IHtyZXNvbHZlcnM6IHJlc29sdmVycywgcmVqZWN0b3JzOiByZWplY3RvcnN9XG5cdHZhciBjYWxsQXN5bmMgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBzZXRJbW1lZGlhdGUgOiBzZXRUaW1lb3V0XG5cdGZ1bmN0aW9uIGhhbmRsZXIobGlzdCwgc2hvdWxkQWJzb3JiKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGV4ZWN1dGUodmFsdWUpIHtcblx0XHRcdHZhciB0aGVuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAoc2hvdWxkQWJzb3JiICYmIHZhbHVlICE9IG51bGwgJiYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikgJiYgdHlwZW9mICh0aGVuID0gdmFsdWUudGhlbikgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdGlmICh2YWx1ZSA9PT0gc2VsZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByb21pc2UgY2FuJ3QgYmUgcmVzb2x2ZWQgdy8gaXRzZWxmXCIpXG5cdFx0XHRcdFx0ZXhlY3V0ZU9uY2UodGhlbi5iaW5kKHZhbHVlKSlcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRjYWxsQXN5bmMoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRpZiAoIXNob3VsZEFic29yYiAmJiBsaXN0Lmxlbmd0aCA9PT0gMCkgY29uc29sZS5lcnJvcihcIlBvc3NpYmxlIHVuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbjpcIiwgdmFsdWUpXG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIGxpc3RbaV0odmFsdWUpXG5cdFx0XHRcdFx0XHRyZXNvbHZlcnMubGVuZ3RoID0gMCwgcmVqZWN0b3JzLmxlbmd0aCA9IDBcblx0XHRcdFx0XHRcdGluc3RhbmNlLnN0YXRlID0gc2hvdWxkQWJzb3JiXG5cdFx0XHRcdFx0XHRpbnN0YW5jZS5yZXRyeSA9IGZ1bmN0aW9uKCkge2V4ZWN1dGUodmFsdWUpfVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGNhdGNoIChlKSB7XG5cdFx0XHRcdHJlamVjdEN1cnJlbnQoZSlcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gZXhlY3V0ZU9uY2UodGhlbikge1xuXHRcdHZhciBydW5zID0gMFxuXHRcdGZ1bmN0aW9uIHJ1bihmbikge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdGlmIChydW5zKysgPiAwKSByZXR1cm5cblx0XHRcdFx0Zm4odmFsdWUpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHZhciBvbmVycm9yID0gcnVuKHJlamVjdEN1cnJlbnQpXG5cdFx0dHJ5IHt0aGVuKHJ1bihyZXNvbHZlQ3VycmVudCksIG9uZXJyb3IpfSBjYXRjaCAoZSkge29uZXJyb3IoZSl9XG5cdH1cblx0ZXhlY3V0ZU9uY2UoZXhlY3V0b3IpXG59XG5Qcm9taXNlUG9seWZpbGwucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbihvbkZ1bGZpbGxlZCwgb25SZWplY3Rpb24pIHtcblx0dmFyIHNlbGYgPSB0aGlzLCBpbnN0YW5jZSA9IHNlbGYuX2luc3RhbmNlXG5cdGZ1bmN0aW9uIGhhbmRsZShjYWxsYmFjaywgbGlzdCwgbmV4dCwgc3RhdGUpIHtcblx0XHRsaXN0LnB1c2goZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikgbmV4dCh2YWx1ZSlcblx0XHRcdGVsc2UgdHJ5IHtyZXNvbHZlTmV4dChjYWxsYmFjayh2YWx1ZSkpfSBjYXRjaCAoZSkge2lmIChyZWplY3ROZXh0KSByZWplY3ROZXh0KGUpfVxuXHRcdH0pXG5cdFx0aWYgKHR5cGVvZiBpbnN0YW5jZS5yZXRyeSA9PT0gXCJmdW5jdGlvblwiICYmIHN0YXRlID09PSBpbnN0YW5jZS5zdGF0ZSkgaW5zdGFuY2UucmV0cnkoKVxuXHR9XG5cdHZhciByZXNvbHZlTmV4dCwgcmVqZWN0TmV4dFxuXHR2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlUG9seWZpbGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7cmVzb2x2ZU5leHQgPSByZXNvbHZlLCByZWplY3ROZXh0ID0gcmVqZWN0fSlcblx0aGFuZGxlKG9uRnVsZmlsbGVkLCBpbnN0YW5jZS5yZXNvbHZlcnMsIHJlc29sdmVOZXh0LCB0cnVlKSwgaGFuZGxlKG9uUmVqZWN0aW9uLCBpbnN0YW5jZS5yZWplY3RvcnMsIHJlamVjdE5leHQsIGZhbHNlKVxuXHRyZXR1cm4gcHJvbWlzZVxufVxuUHJvbWlzZVBvbHlmaWxsLnByb3RvdHlwZS5jYXRjaCA9IGZ1bmN0aW9uKG9uUmVqZWN0aW9uKSB7XG5cdHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3Rpb24pXG59XG5Qcm9taXNlUG9seWZpbGwucmVzb2x2ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2VQb2x5ZmlsbCkgcmV0dXJuIHZhbHVlXG5cdHJldHVybiBuZXcgUHJvbWlzZVBvbHlmaWxsKGZ1bmN0aW9uKHJlc29sdmUpIHtyZXNvbHZlKHZhbHVlKX0pXG59XG5Qcm9taXNlUG9seWZpbGwucmVqZWN0ID0gZnVuY3Rpb24odmFsdWUpIHtcblx0cmV0dXJuIG5ldyBQcm9taXNlUG9seWZpbGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7cmVqZWN0KHZhbHVlKX0pXG59XG5Qcm9taXNlUG9seWZpbGwuYWxsID0gZnVuY3Rpb24obGlzdCkge1xuXHRyZXR1cm4gbmV3IFByb21pc2VQb2x5ZmlsbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHR2YXIgdG90YWwgPSBsaXN0Lmxlbmd0aCwgY291bnQgPSAwLCB2YWx1ZXMgPSBbXVxuXHRcdGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkgcmVzb2x2ZShbXSlcblx0XHRlbHNlIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdFx0KGZ1bmN0aW9uKGkpIHtcblx0XHRcdFx0ZnVuY3Rpb24gY29uc3VtZSh2YWx1ZSkge1xuXHRcdFx0XHRcdGNvdW50Kytcblx0XHRcdFx0XHR2YWx1ZXNbaV0gPSB2YWx1ZVxuXHRcdFx0XHRcdGlmIChjb3VudCA9PT0gdG90YWwpIHJlc29sdmUodmFsdWVzKVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChsaXN0W2ldICE9IG51bGwgJiYgKHR5cGVvZiBsaXN0W2ldID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBsaXN0W2ldID09PSBcImZ1bmN0aW9uXCIpICYmIHR5cGVvZiBsaXN0W2ldLnRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdGxpc3RbaV0udGhlbihjb25zdW1lLCByZWplY3QpXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBjb25zdW1lKGxpc3RbaV0pXG5cdFx0XHR9KShpKVxuXHRcdH1cblx0fSlcbn1cblByb21pc2VQb2x5ZmlsbC5yYWNlID0gZnVuY3Rpb24obGlzdCkge1xuXHRyZXR1cm4gbmV3IFByb21pc2VQb2x5ZmlsbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHRcdGxpc3RbaV0udGhlbihyZXNvbHZlLCByZWplY3QpXG5cdFx0fVxuXHR9KVxufVxuaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcblx0aWYgKHR5cGVvZiB3aW5kb3cuUHJvbWlzZSA9PT0gXCJ1bmRlZmluZWRcIikgd2luZG93LlByb21pc2UgPSBQcm9taXNlUG9seWZpbGxcblx0dmFyIFByb21pc2VQb2x5ZmlsbCA9IHdpbmRvdy5Qcm9taXNlXG59IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcblx0aWYgKHR5cGVvZiBnbG9iYWwuUHJvbWlzZSA9PT0gXCJ1bmRlZmluZWRcIikgZ2xvYmFsLlByb21pc2UgPSBQcm9taXNlUG9seWZpbGxcblx0dmFyIFByb21pc2VQb2x5ZmlsbCA9IGdsb2JhbC5Qcm9taXNlXG59IGVsc2Uge1xufVxudmFyIGJ1aWxkUXVlcnlTdHJpbmcgPSBmdW5jdGlvbihvYmplY3QpIHtcblx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpICE9PSBcIltvYmplY3QgT2JqZWN0XVwiKSByZXR1cm4gXCJcIlxuXHR2YXIgYXJncyA9IFtdXG5cdGZvciAodmFyIGtleTAgaW4gb2JqZWN0KSB7XG5cdFx0ZGVzdHJ1Y3R1cmUoa2V5MCwgb2JqZWN0W2tleTBdKVxuXHR9XG5cdHJldHVybiBhcmdzLmpvaW4oXCImXCIpXG5cdGZ1bmN0aW9uIGRlc3RydWN0dXJlKGtleTAsIHZhbHVlKSB7XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGRlc3RydWN0dXJlKGtleTAgKyBcIltcIiArIGkgKyBcIl1cIiwgdmFsdWVbaV0pXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09IFwiW29iamVjdCBPYmplY3RdXCIpIHtcblx0XHRcdGZvciAodmFyIGkgaW4gdmFsdWUpIHtcblx0XHRcdFx0ZGVzdHJ1Y3R1cmUoa2V5MCArIFwiW1wiICsgaSArIFwiXVwiLCB2YWx1ZVtpXSlcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBhcmdzLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleTApICsgKHZhbHVlICE9IG51bGwgJiYgdmFsdWUgIT09IFwiXCIgPyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkgOiBcIlwiKSlcblx0fVxufVxudmFyIEZJTEVfUFJPVE9DT0xfUkVHRVggPSBuZXcgUmVnRXhwKFwiXmZpbGU6Ly9cIiwgXCJpXCIpXG52YXIgXzggPSBmdW5jdGlvbigkd2luZG93LCBQcm9taXNlKSB7XG5cdHZhciBjYWxsYmFja0NvdW50ID0gMFxuXHR2YXIgb25jb21wbGV0aW9uXG5cdGZ1bmN0aW9uIHNldENvbXBsZXRpb25DYWxsYmFjayhjYWxsYmFjaykge29uY29tcGxldGlvbiA9IGNhbGxiYWNrfVxuXHRmdW5jdGlvbiBmaW5hbGl6ZXIoKSB7XG5cdFx0dmFyIGNvdW50ID0gMFxuXHRcdGZ1bmN0aW9uIGNvbXBsZXRlKCkge2lmICgtLWNvdW50ID09PSAwICYmIHR5cGVvZiBvbmNvbXBsZXRpb24gPT09IFwiZnVuY3Rpb25cIikgb25jb21wbGV0aW9uKCl9XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGZpbmFsaXplKHByb21pc2UwKSB7XG5cdFx0XHR2YXIgdGhlbjAgPSBwcm9taXNlMC50aGVuXG5cdFx0XHRwcm9taXNlMC50aGVuID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNvdW50Kytcblx0XHRcdFx0dmFyIG5leHQgPSB0aGVuMC5hcHBseShwcm9taXNlMCwgYXJndW1lbnRzKVxuXHRcdFx0XHRuZXh0LnRoZW4oY29tcGxldGUsIGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0XHRjb21wbGV0ZSgpXG5cdFx0XHRcdFx0aWYgKGNvdW50ID09PSAwKSB0aHJvdyBlXG5cdFx0XHRcdH0pXG5cdFx0XHRcdHJldHVybiBmaW5hbGl6ZShuZXh0KVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHByb21pc2UwXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIG5vcm1hbGl6ZShhcmdzLCBleHRyYSkge1xuXHRcdGlmICh0eXBlb2YgYXJncyA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0dmFyIHVybCA9IGFyZ3Ncblx0XHRcdGFyZ3MgPSBleHRyYSB8fCB7fVxuXHRcdFx0aWYgKGFyZ3MudXJsID09IG51bGwpIGFyZ3MudXJsID0gdXJsXG5cdFx0fVxuXHRcdHJldHVybiBhcmdzXG5cdH1cblx0ZnVuY3Rpb24gcmVxdWVzdChhcmdzLCBleHRyYSkge1xuXHRcdHZhciBmaW5hbGl6ZSA9IGZpbmFsaXplcigpXG5cdFx0YXJncyA9IG5vcm1hbGl6ZShhcmdzLCBleHRyYSlcblx0XHR2YXIgcHJvbWlzZTAgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHRcdGlmIChhcmdzLm1ldGhvZCA9PSBudWxsKSBhcmdzLm1ldGhvZCA9IFwiR0VUXCJcblx0XHRcdGFyZ3MubWV0aG9kID0gYXJncy5tZXRob2QudG9VcHBlckNhc2UoKVxuXHRcdFx0dmFyIHVzZUJvZHkgPSAoYXJncy5tZXRob2QgPT09IFwiR0VUXCIgfHwgYXJncy5tZXRob2QgPT09IFwiVFJBQ0VcIikgPyBmYWxzZSA6ICh0eXBlb2YgYXJncy51c2VCb2R5ID09PSBcImJvb2xlYW5cIiA/IGFyZ3MudXNlQm9keSA6IHRydWUpXG5cdFx0XHRpZiAodHlwZW9mIGFyZ3Muc2VyaWFsaXplICE9PSBcImZ1bmN0aW9uXCIpIGFyZ3Muc2VyaWFsaXplID0gdHlwZW9mIEZvcm1EYXRhICE9PSBcInVuZGVmaW5lZFwiICYmIGFyZ3MuZGF0YSBpbnN0YW5jZW9mIEZvcm1EYXRhID8gZnVuY3Rpb24odmFsdWUpIHtyZXR1cm4gdmFsdWV9IDogSlNPTi5zdHJpbmdpZnlcblx0XHRcdGlmICh0eXBlb2YgYXJncy5kZXNlcmlhbGl6ZSAhPT0gXCJmdW5jdGlvblwiKSBhcmdzLmRlc2VyaWFsaXplID0gZGVzZXJpYWxpemVcblx0XHRcdGlmICh0eXBlb2YgYXJncy5leHRyYWN0ICE9PSBcImZ1bmN0aW9uXCIpIGFyZ3MuZXh0cmFjdCA9IGV4dHJhY3Rcblx0XHRcdGFyZ3MudXJsID0gaW50ZXJwb2xhdGUoYXJncy51cmwsIGFyZ3MuZGF0YSlcblx0XHRcdGlmICh1c2VCb2R5KSBhcmdzLmRhdGEgPSBhcmdzLnNlcmlhbGl6ZShhcmdzLmRhdGEpXG5cdFx0XHRlbHNlIGFyZ3MudXJsID0gYXNzZW1ibGUoYXJncy51cmwsIGFyZ3MuZGF0YSlcblx0XHRcdHZhciB4aHIgPSBuZXcgJHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpLFxuXHRcdFx0XHRhYm9ydGVkID0gZmFsc2UsXG5cdFx0XHRcdF9hYm9ydCA9IHhoci5hYm9ydFxuXHRcdFx0eGhyLmFib3J0ID0gZnVuY3Rpb24gYWJvcnQoKSB7XG5cdFx0XHRcdGFib3J0ZWQgPSB0cnVlXG5cdFx0XHRcdF9hYm9ydC5jYWxsKHhocilcblx0XHRcdH1cblx0XHRcdHhoci5vcGVuKGFyZ3MubWV0aG9kLCBhcmdzLnVybCwgdHlwZW9mIGFyZ3MuYXN5bmMgPT09IFwiYm9vbGVhblwiID8gYXJncy5hc3luYyA6IHRydWUsIHR5cGVvZiBhcmdzLnVzZXIgPT09IFwic3RyaW5nXCIgPyBhcmdzLnVzZXIgOiB1bmRlZmluZWQsIHR5cGVvZiBhcmdzLnBhc3N3b3JkID09PSBcInN0cmluZ1wiID8gYXJncy5wYXNzd29yZCA6IHVuZGVmaW5lZClcblx0XHRcdGlmIChhcmdzLnNlcmlhbGl6ZSA9PT0gSlNPTi5zdHJpbmdpZnkgJiYgdXNlQm9keSkge1xuXHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiLCBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIilcblx0XHRcdH1cblx0XHRcdGlmIChhcmdzLmRlc2VyaWFsaXplID09PSBkZXNlcmlhbGl6ZSkge1xuXHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkFjY2VwdFwiLCBcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvKlwiKVxuXHRcdFx0fVxuXHRcdFx0aWYgKGFyZ3Mud2l0aENyZWRlbnRpYWxzKSB4aHIud2l0aENyZWRlbnRpYWxzID0gYXJncy53aXRoQ3JlZGVudGlhbHNcblx0XHRcdGZvciAodmFyIGtleSBpbiBhcmdzLmhlYWRlcnMpIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFyZ3MuaGVhZGVycywga2V5KSkge1xuXHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIGFyZ3MuaGVhZGVyc1trZXldKVxuXHRcdFx0fVxuXHRcdFx0aWYgKHR5cGVvZiBhcmdzLmNvbmZpZyA9PT0gXCJmdW5jdGlvblwiKSB4aHIgPSBhcmdzLmNvbmZpZyh4aHIsIGFyZ3MpIHx8IHhoclxuXHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBEb24ndCB0aHJvdyBlcnJvcnMgb24geGhyLmFib3J0KCkuXG5cdFx0XHRcdGlmKGFib3J0ZWQpIHJldHVyblxuXHRcdFx0XHRpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0dmFyIHJlc3BvbnNlID0gKGFyZ3MuZXh0cmFjdCAhPT0gZXh0cmFjdCkgPyBhcmdzLmV4dHJhY3QoeGhyLCBhcmdzKSA6IGFyZ3MuZGVzZXJpYWxpemUoYXJncy5leHRyYWN0KHhociwgYXJncykpXG5cdFx0XHRcdFx0XHRpZiAoKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDApIHx8IHhoci5zdGF0dXMgPT09IDMwNCB8fCBGSUxFX1BST1RPQ09MX1JFR0VYLnRlc3QoYXJncy51cmwpKSB7XG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoY2FzdChhcmdzLnR5cGUsIHJlc3BvbnNlKSlcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR2YXIgZXJyb3IgPSBuZXcgRXJyb3IoeGhyLnJlc3BvbnNlVGV4dClcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIga2V5IGluIHJlc3BvbnNlKSBlcnJvcltrZXldID0gcmVzcG9uc2Vba2V5XVxuXHRcdFx0XHRcdFx0XHRyZWplY3QoZXJyb3IpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0XHRyZWplY3QoZSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICh1c2VCb2R5ICYmIChhcmdzLmRhdGEgIT0gbnVsbCkpIHhoci5zZW5kKGFyZ3MuZGF0YSlcblx0XHRcdGVsc2UgeGhyLnNlbmQoKVxuXHRcdH0pXG5cdFx0cmV0dXJuIGFyZ3MuYmFja2dyb3VuZCA9PT0gdHJ1ZSA/IHByb21pc2UwIDogZmluYWxpemUocHJvbWlzZTApXG5cdH1cblx0ZnVuY3Rpb24ganNvbnAoYXJncywgZXh0cmEpIHtcblx0XHR2YXIgZmluYWxpemUgPSBmaW5hbGl6ZXIoKVxuXHRcdGFyZ3MgPSBub3JtYWxpemUoYXJncywgZXh0cmEpXG5cdFx0dmFyIHByb21pc2UwID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0XHR2YXIgY2FsbGJhY2tOYW1lID0gYXJncy5jYWxsYmFja05hbWUgfHwgXCJfbWl0aHJpbF9cIiArIE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDFlMTYpICsgXCJfXCIgKyBjYWxsYmFja0NvdW50Kytcblx0XHRcdHZhciBzY3JpcHQgPSAkd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIilcblx0XHRcdCR3aW5kb3dbY2FsbGJhY2tOYW1lXSA9IGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdFx0c2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KVxuXHRcdFx0XHRyZXNvbHZlKGNhc3QoYXJncy50eXBlLCBkYXRhKSlcblx0XHRcdFx0ZGVsZXRlICR3aW5kb3dbY2FsbGJhY2tOYW1lXVxuXHRcdFx0fVxuXHRcdFx0c2NyaXB0Lm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KVxuXHRcdFx0XHRyZWplY3QobmV3IEVycm9yKFwiSlNPTlAgcmVxdWVzdCBmYWlsZWRcIikpXG5cdFx0XHRcdGRlbGV0ZSAkd2luZG93W2NhbGxiYWNrTmFtZV1cblx0XHRcdH1cblx0XHRcdGlmIChhcmdzLmRhdGEgPT0gbnVsbCkgYXJncy5kYXRhID0ge31cblx0XHRcdGFyZ3MudXJsID0gaW50ZXJwb2xhdGUoYXJncy51cmwsIGFyZ3MuZGF0YSlcblx0XHRcdGFyZ3MuZGF0YVthcmdzLmNhbGxiYWNrS2V5IHx8IFwiY2FsbGJhY2tcIl0gPSBjYWxsYmFja05hbWVcblx0XHRcdHNjcmlwdC5zcmMgPSBhc3NlbWJsZShhcmdzLnVybCwgYXJncy5kYXRhKVxuXHRcdFx0JHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoc2NyaXB0KVxuXHRcdH0pXG5cdFx0cmV0dXJuIGFyZ3MuYmFja2dyb3VuZCA9PT0gdHJ1ZT8gcHJvbWlzZTAgOiBmaW5hbGl6ZShwcm9taXNlMClcblx0fVxuXHRmdW5jdGlvbiBpbnRlcnBvbGF0ZSh1cmwsIGRhdGEpIHtcblx0XHRpZiAoZGF0YSA9PSBudWxsKSByZXR1cm4gdXJsXG5cdFx0dmFyIHRva2VucyA9IHVybC5tYXRjaCgvOlteXFwvXSsvZ2kpIHx8IFtdXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBrZXkgPSB0b2tlbnNbaV0uc2xpY2UoMSlcblx0XHRcdGlmIChkYXRhW2tleV0gIT0gbnVsbCkge1xuXHRcdFx0XHR1cmwgPSB1cmwucmVwbGFjZSh0b2tlbnNbaV0sIGRhdGFba2V5XSlcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHVybFxuXHR9XG5cdGZ1bmN0aW9uIGFzc2VtYmxlKHVybCwgZGF0YSkge1xuXHRcdHZhciBxdWVyeXN0cmluZyA9IGJ1aWxkUXVlcnlTdHJpbmcoZGF0YSlcblx0XHRpZiAocXVlcnlzdHJpbmcgIT09IFwiXCIpIHtcblx0XHRcdHZhciBwcmVmaXggPSB1cmwuaW5kZXhPZihcIj9cIikgPCAwID8gXCI/XCIgOiBcIiZcIlxuXHRcdFx0dXJsICs9IHByZWZpeCArIHF1ZXJ5c3RyaW5nXG5cdFx0fVxuXHRcdHJldHVybiB1cmxcblx0fVxuXHRmdW5jdGlvbiBkZXNlcmlhbGl6ZShkYXRhKSB7XG5cdFx0dHJ5IHtyZXR1cm4gZGF0YSAhPT0gXCJcIiA/IEpTT04ucGFyc2UoZGF0YSkgOiBudWxsfVxuXHRcdGNhdGNoIChlKSB7dGhyb3cgbmV3IEVycm9yKGRhdGEpfVxuXHR9XG5cdGZ1bmN0aW9uIGV4dHJhY3QoeGhyKSB7cmV0dXJuIHhoci5yZXNwb25zZVRleHR9XG5cdGZ1bmN0aW9uIGNhc3QodHlwZTAsIGRhdGEpIHtcblx0XHRpZiAodHlwZW9mIHR5cGUwID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGRhdGFbaV0gPSBuZXcgdHlwZTAoZGF0YVtpXSlcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSByZXR1cm4gbmV3IHR5cGUwKGRhdGEpXG5cdFx0fVxuXHRcdHJldHVybiBkYXRhXG5cdH1cblx0cmV0dXJuIHtyZXF1ZXN0OiByZXF1ZXN0LCBqc29ucDoganNvbnAsIHNldENvbXBsZXRpb25DYWxsYmFjazogc2V0Q29tcGxldGlvbkNhbGxiYWNrfVxufVxudmFyIHJlcXVlc3RTZXJ2aWNlID0gXzgod2luZG93LCBQcm9taXNlUG9seWZpbGwpXG52YXIgY29yZVJlbmRlcmVyID0gZnVuY3Rpb24oJHdpbmRvdykge1xuXHR2YXIgJGRvYyA9ICR3aW5kb3cuZG9jdW1lbnRcblx0dmFyICRlbXB0eUZyYWdtZW50ID0gJGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcblx0dmFyIG5hbWVTcGFjZSA9IHtcblx0XHRzdmc6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcblx0XHRtYXRoOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIlxuXHR9XG5cdHZhciBvbmV2ZW50XG5cdGZ1bmN0aW9uIHNldEV2ZW50Q2FsbGJhY2soY2FsbGJhY2spIHtyZXR1cm4gb25ldmVudCA9IGNhbGxiYWNrfVxuXHRmdW5jdGlvbiBnZXROYW1lU3BhY2Uodm5vZGUpIHtcblx0XHRyZXR1cm4gdm5vZGUuYXR0cnMgJiYgdm5vZGUuYXR0cnMueG1sbnMgfHwgbmFtZVNwYWNlW3Zub2RlLnRhZ11cblx0fVxuXHQvL2NyZWF0ZVxuXHRmdW5jdGlvbiBjcmVhdGVOb2RlcyhwYXJlbnQsIHZub2Rlcywgc3RhcnQsIGVuZCwgaG9va3MsIG5leHRTaWJsaW5nLCBucykge1xuXHRcdGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG5cdFx0XHR2YXIgdm5vZGUgPSB2bm9kZXNbaV1cblx0XHRcdGlmICh2bm9kZSAhPSBudWxsKSB7XG5cdFx0XHRcdGNyZWF0ZU5vZGUocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlTm9kZShwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKSB7XG5cdFx0dmFyIHRhZyA9IHZub2RlLnRhZ1xuXHRcdGlmICh0eXBlb2YgdGFnID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHR2bm9kZS5zdGF0ZSA9IHt9XG5cdFx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCkgaW5pdExpZmVjeWNsZSh2bm9kZS5hdHRycywgdm5vZGUsIGhvb2tzKVxuXHRcdFx0c3dpdGNoICh0YWcpIHtcblx0XHRcdFx0Y2FzZSBcIiNcIjogcmV0dXJuIGNyZWF0ZVRleHQocGFyZW50LCB2bm9kZSwgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdGNhc2UgXCI8XCI6IHJldHVybiBjcmVhdGVIVE1MKHBhcmVudCwgdm5vZGUsIG5leHRTaWJsaW5nKVxuXHRcdFx0XHRjYXNlIFwiW1wiOiByZXR1cm4gY3JlYXRlRnJhZ21lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdFx0ZGVmYXVsdDogcmV0dXJuIGNyZWF0ZUVsZW1lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSByZXR1cm4gY3JlYXRlQ29tcG9uZW50KHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlVGV4dChwYXJlbnQsIHZub2RlLCBuZXh0U2libGluZykge1xuXHRcdHZub2RlLmRvbSA9ICRkb2MuY3JlYXRlVGV4dE5vZGUodm5vZGUuY2hpbGRyZW4pXG5cdFx0aW5zZXJ0Tm9kZShwYXJlbnQsIHZub2RlLmRvbSwgbmV4dFNpYmxpbmcpXG5cdFx0cmV0dXJuIHZub2RlLmRvbVxuXHR9XG5cdGZ1bmN0aW9uIGNyZWF0ZUhUTUwocGFyZW50LCB2bm9kZSwgbmV4dFNpYmxpbmcpIHtcblx0XHR2YXIgbWF0Y2gxID0gdm5vZGUuY2hpbGRyZW4ubWF0Y2goL15cXHMqPzwoXFx3KykvaW0pIHx8IFtdXG5cdFx0dmFyIHBhcmVudDEgPSB7Y2FwdGlvbjogXCJ0YWJsZVwiLCB0aGVhZDogXCJ0YWJsZVwiLCB0Ym9keTogXCJ0YWJsZVwiLCB0Zm9vdDogXCJ0YWJsZVwiLCB0cjogXCJ0Ym9keVwiLCB0aDogXCJ0clwiLCB0ZDogXCJ0clwiLCBjb2xncm91cDogXCJ0YWJsZVwiLCBjb2w6IFwiY29sZ3JvdXBcIn1bbWF0Y2gxWzFdXSB8fCBcImRpdlwiXG5cdFx0dmFyIHRlbXAgPSAkZG9jLmNyZWF0ZUVsZW1lbnQocGFyZW50MSlcblx0XHR0ZW1wLmlubmVySFRNTCA9IHZub2RlLmNoaWxkcmVuXG5cdFx0dm5vZGUuZG9tID0gdGVtcC5maXJzdENoaWxkXG5cdFx0dm5vZGUuZG9tU2l6ZSA9IHRlbXAuY2hpbGROb2Rlcy5sZW5ndGhcblx0XHR2YXIgZnJhZ21lbnQgPSAkZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuXHRcdHZhciBjaGlsZFxuXHRcdHdoaWxlIChjaGlsZCA9IHRlbXAuZmlyc3RDaGlsZCkge1xuXHRcdFx0ZnJhZ21lbnQuYXBwZW5kQ2hpbGQoY2hpbGQpXG5cdFx0fVxuXHRcdGluc2VydE5vZGUocGFyZW50LCBmcmFnbWVudCwgbmV4dFNpYmxpbmcpXG5cdFx0cmV0dXJuIGZyYWdtZW50XG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlRnJhZ21lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZykge1xuXHRcdHZhciBmcmFnbWVudCA9ICRkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG5cdFx0aWYgKHZub2RlLmNoaWxkcmVuICE9IG51bGwpIHtcblx0XHRcdHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuXG5cdFx0XHRjcmVhdGVOb2RlcyhmcmFnbWVudCwgY2hpbGRyZW4sIDAsIGNoaWxkcmVuLmxlbmd0aCwgaG9va3MsIG51bGwsIG5zKVxuXHRcdH1cblx0XHR2bm9kZS5kb20gPSBmcmFnbWVudC5maXJzdENoaWxkXG5cdFx0dm5vZGUuZG9tU2l6ZSA9IGZyYWdtZW50LmNoaWxkTm9kZXMubGVuZ3RoXG5cdFx0aW5zZXJ0Tm9kZShwYXJlbnQsIGZyYWdtZW50LCBuZXh0U2libGluZylcblx0XHRyZXR1cm4gZnJhZ21lbnRcblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVFbGVtZW50KHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpIHtcblx0XHR2YXIgdGFnID0gdm5vZGUudGFnXG5cdFx0dmFyIGF0dHJzMiA9IHZub2RlLmF0dHJzXG5cdFx0dmFyIGlzID0gYXR0cnMyICYmIGF0dHJzMi5pc1xuXHRcdG5zID0gZ2V0TmFtZVNwYWNlKHZub2RlKSB8fCBuc1xuXHRcdHZhciBlbGVtZW50ID0gbnMgP1xuXHRcdFx0aXMgPyAkZG9jLmNyZWF0ZUVsZW1lbnROUyhucywgdGFnLCB7aXM6IGlzfSkgOiAkZG9jLmNyZWF0ZUVsZW1lbnROUyhucywgdGFnKSA6XG5cdFx0XHRpcyA/ICRkb2MuY3JlYXRlRWxlbWVudCh0YWcsIHtpczogaXN9KSA6ICRkb2MuY3JlYXRlRWxlbWVudCh0YWcpXG5cdFx0dm5vZGUuZG9tID0gZWxlbWVudFxuXHRcdGlmIChhdHRyczIgIT0gbnVsbCkge1xuXHRcdFx0c2V0QXR0cnModm5vZGUsIGF0dHJzMiwgbnMpXG5cdFx0fVxuXHRcdGluc2VydE5vZGUocGFyZW50LCBlbGVtZW50LCBuZXh0U2libGluZylcblx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCAmJiB2bm9kZS5hdHRycy5jb250ZW50ZWRpdGFibGUgIT0gbnVsbCkge1xuXHRcdFx0c2V0Q29udGVudEVkaXRhYmxlKHZub2RlKVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGlmICh2bm9kZS50ZXh0ICE9IG51bGwpIHtcblx0XHRcdFx0aWYgKHZub2RlLnRleHQgIT09IFwiXCIpIGVsZW1lbnQudGV4dENvbnRlbnQgPSB2bm9kZS50ZXh0XG5cdFx0XHRcdGVsc2Ugdm5vZGUuY2hpbGRyZW4gPSBbVm5vZGUoXCIjXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB2bm9kZS50ZXh0LCB1bmRlZmluZWQsIHVuZGVmaW5lZCldXG5cdFx0XHR9XG5cdFx0XHRpZiAodm5vZGUuY2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0XHR2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlblxuXHRcdFx0XHRjcmVhdGVOb2RlcyhlbGVtZW50LCBjaGlsZHJlbiwgMCwgY2hpbGRyZW4ubGVuZ3RoLCBob29rcywgbnVsbCwgbnMpXG5cdFx0XHRcdHNldExhdGVBdHRycyh2bm9kZSlcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGVsZW1lbnRcblx0fVxuXHRmdW5jdGlvbiBpbml0Q29tcG9uZW50KHZub2RlLCBob29rcykge1xuXHRcdHZhciBzZW50aW5lbFxuXHRcdGlmICh0eXBlb2Ygdm5vZGUudGFnLnZpZXcgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0dm5vZGUuc3RhdGUgPSBPYmplY3QuY3JlYXRlKHZub2RlLnRhZylcblx0XHRcdHNlbnRpbmVsID0gdm5vZGUuc3RhdGUudmlld1xuXHRcdFx0aWYgKHNlbnRpbmVsLiQkcmVlbnRyYW50TG9jayQkICE9IG51bGwpIHJldHVybiAkZW1wdHlGcmFnbWVudFxuXHRcdFx0c2VudGluZWwuJCRyZWVudHJhbnRMb2NrJCQgPSB0cnVlXG5cdFx0fSBlbHNlIHtcblx0XHRcdHZub2RlLnN0YXRlID0gdm9pZCAwXG5cdFx0XHRzZW50aW5lbCA9IHZub2RlLnRhZ1xuXHRcdFx0aWYgKHNlbnRpbmVsLiQkcmVlbnRyYW50TG9jayQkICE9IG51bGwpIHJldHVybiAkZW1wdHlGcmFnbWVudFxuXHRcdFx0c2VudGluZWwuJCRyZWVudHJhbnRMb2NrJCQgPSB0cnVlXG5cdFx0XHR2bm9kZS5zdGF0ZSA9ICh2bm9kZS50YWcucHJvdG90eXBlICE9IG51bGwgJiYgdHlwZW9mIHZub2RlLnRhZy5wcm90b3R5cGUudmlldyA9PT0gXCJmdW5jdGlvblwiKSA/IG5ldyB2bm9kZS50YWcodm5vZGUpIDogdm5vZGUudGFnKHZub2RlKVxuXHRcdH1cblx0XHR2bm9kZS5fc3RhdGUgPSB2bm9kZS5zdGF0ZVxuXHRcdGlmICh2bm9kZS5hdHRycyAhPSBudWxsKSBpbml0TGlmZWN5Y2xlKHZub2RlLmF0dHJzLCB2bm9kZSwgaG9va3MpXG5cdFx0aW5pdExpZmVjeWNsZSh2bm9kZS5fc3RhdGUsIHZub2RlLCBob29rcylcblx0XHR2bm9kZS5pbnN0YW5jZSA9IFZub2RlLm5vcm1hbGl6ZSh2bm9kZS5fc3RhdGUudmlldy5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSkpXG5cdFx0aWYgKHZub2RlLmluc3RhbmNlID09PSB2bm9kZSkgdGhyb3cgRXJyb3IoXCJBIHZpZXcgY2Fubm90IHJldHVybiB0aGUgdm5vZGUgaXQgcmVjZWl2ZWQgYXMgYXJndW1lbnRcIilcblx0XHRzZW50aW5lbC4kJHJlZW50cmFudExvY2skJCA9IG51bGxcblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVDb21wb25lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZykge1xuXHRcdGluaXRDb21wb25lbnQodm5vZGUsIGhvb2tzKVxuXHRcdGlmICh2bm9kZS5pbnN0YW5jZSAhPSBudWxsKSB7XG5cdFx0XHR2YXIgZWxlbWVudCA9IGNyZWF0ZU5vZGUocGFyZW50LCB2bm9kZS5pbnN0YW5jZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdHZub2RlLmRvbSA9IHZub2RlLmluc3RhbmNlLmRvbVxuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IHZub2RlLmRvbSAhPSBudWxsID8gdm5vZGUuaW5zdGFuY2UuZG9tU2l6ZSA6IDBcblx0XHRcdGluc2VydE5vZGUocGFyZW50LCBlbGVtZW50LCBuZXh0U2libGluZylcblx0XHRcdHJldHVybiBlbGVtZW50XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IDBcblx0XHRcdHJldHVybiAkZW1wdHlGcmFnbWVudFxuXHRcdH1cblx0fVxuXHQvL3VwZGF0ZVxuXHRmdW5jdGlvbiB1cGRhdGVOb2RlcyhwYXJlbnQsIG9sZCwgdm5vZGVzLCByZWN5Y2xpbmcsIGhvb2tzLCBuZXh0U2libGluZywgbnMpIHtcblx0XHRpZiAob2xkID09PSB2bm9kZXMgfHwgb2xkID09IG51bGwgJiYgdm5vZGVzID09IG51bGwpIHJldHVyblxuXHRcdGVsc2UgaWYgKG9sZCA9PSBudWxsKSBjcmVhdGVOb2RlcyhwYXJlbnQsIHZub2RlcywgMCwgdm5vZGVzLmxlbmd0aCwgaG9va3MsIG5leHRTaWJsaW5nLCBucylcblx0XHRlbHNlIGlmICh2bm9kZXMgPT0gbnVsbCkgcmVtb3ZlTm9kZXMob2xkLCAwLCBvbGQubGVuZ3RoLCB2bm9kZXMpXG5cdFx0ZWxzZSB7XG5cdFx0XHRpZiAob2xkLmxlbmd0aCA9PT0gdm5vZGVzLmxlbmd0aCkge1xuXHRcdFx0XHR2YXIgaXNVbmtleWVkID0gZmFsc2Vcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB2bm9kZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRpZiAodm5vZGVzW2ldICE9IG51bGwgJiYgb2xkW2ldICE9IG51bGwpIHtcblx0XHRcdFx0XHRcdGlzVW5rZXllZCA9IHZub2Rlc1tpXS5rZXkgPT0gbnVsbCAmJiBvbGRbaV0ua2V5ID09IG51bGxcblx0XHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChpc1Vua2V5ZWQpIHtcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG9sZC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0aWYgKG9sZFtpXSA9PT0gdm5vZGVzW2ldKSBjb250aW51ZVxuXHRcdFx0XHRcdFx0ZWxzZSBpZiAob2xkW2ldID09IG51bGwgJiYgdm5vZGVzW2ldICE9IG51bGwpIGNyZWF0ZU5vZGUocGFyZW50LCB2bm9kZXNbaV0sIGhvb2tzLCBucywgZ2V0TmV4dFNpYmxpbmcob2xkLCBpICsgMSwgbmV4dFNpYmxpbmcpKVxuXHRcdFx0XHRcdFx0ZWxzZSBpZiAodm5vZGVzW2ldID09IG51bGwpIHJlbW92ZU5vZGVzKG9sZCwgaSwgaSArIDEsIHZub2Rlcylcblx0XHRcdFx0XHRcdGVsc2UgdXBkYXRlTm9kZShwYXJlbnQsIG9sZFtpXSwgdm5vZGVzW2ldLCBob29rcywgZ2V0TmV4dFNpYmxpbmcob2xkLCBpICsgMSwgbmV4dFNpYmxpbmcpLCByZWN5Y2xpbmcsIG5zKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmVjeWNsaW5nID0gcmVjeWNsaW5nIHx8IGlzUmVjeWNsYWJsZShvbGQsIHZub2Rlcylcblx0XHRcdGlmIChyZWN5Y2xpbmcpIHtcblx0XHRcdFx0dmFyIHBvb2wgPSBvbGQucG9vbFxuXHRcdFx0XHRvbGQgPSBvbGQuY29uY2F0KG9sZC5wb29sKVxuXHRcdFx0fVxuXHRcdFx0dmFyIG9sZFN0YXJ0ID0gMCwgc3RhcnQgPSAwLCBvbGRFbmQgPSBvbGQubGVuZ3RoIC0gMSwgZW5kID0gdm5vZGVzLmxlbmd0aCAtIDEsIG1hcFxuXHRcdFx0d2hpbGUgKG9sZEVuZCA+PSBvbGRTdGFydCAmJiBlbmQgPj0gc3RhcnQpIHtcblx0XHRcdFx0dmFyIG8gPSBvbGRbb2xkU3RhcnRdLCB2ID0gdm5vZGVzW3N0YXJ0XVxuXHRcdFx0XHRpZiAobyA9PT0gdiAmJiAhcmVjeWNsaW5nKSBvbGRTdGFydCsrLCBzdGFydCsrXG5cdFx0XHRcdGVsc2UgaWYgKG8gPT0gbnVsbCkgb2xkU3RhcnQrK1xuXHRcdFx0XHRlbHNlIGlmICh2ID09IG51bGwpIHN0YXJ0Kytcblx0XHRcdFx0ZWxzZSBpZiAoby5rZXkgPT09IHYua2V5KSB7XG5cdFx0XHRcdFx0dmFyIHNob3VsZFJlY3ljbGUgPSAocG9vbCAhPSBudWxsICYmIG9sZFN0YXJ0ID49IG9sZC5sZW5ndGggLSBwb29sLmxlbmd0aCkgfHwgKChwb29sID09IG51bGwpICYmIHJlY3ljbGluZylcblx0XHRcdFx0XHRvbGRTdGFydCsrLCBzdGFydCsrXG5cdFx0XHRcdFx0dXBkYXRlTm9kZShwYXJlbnQsIG8sIHYsIGhvb2tzLCBnZXROZXh0U2libGluZyhvbGQsIG9sZFN0YXJ0LCBuZXh0U2libGluZyksIHNob3VsZFJlY3ljbGUsIG5zKVxuXHRcdFx0XHRcdGlmIChyZWN5Y2xpbmcgJiYgby50YWcgPT09IHYudGFnKSBpbnNlcnROb2RlKHBhcmVudCwgdG9GcmFnbWVudChvKSwgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0dmFyIG8gPSBvbGRbb2xkRW5kXVxuXHRcdFx0XHRcdGlmIChvID09PSB2ICYmICFyZWN5Y2xpbmcpIG9sZEVuZC0tLCBzdGFydCsrXG5cdFx0XHRcdFx0ZWxzZSBpZiAobyA9PSBudWxsKSBvbGRFbmQtLVxuXHRcdFx0XHRcdGVsc2UgaWYgKHYgPT0gbnVsbCkgc3RhcnQrK1xuXHRcdFx0XHRcdGVsc2UgaWYgKG8ua2V5ID09PSB2LmtleSkge1xuXHRcdFx0XHRcdFx0dmFyIHNob3VsZFJlY3ljbGUgPSAocG9vbCAhPSBudWxsICYmIG9sZEVuZCA+PSBvbGQubGVuZ3RoIC0gcG9vbC5sZW5ndGgpIHx8ICgocG9vbCA9PSBudWxsKSAmJiByZWN5Y2xpbmcpXG5cdFx0XHRcdFx0XHR1cGRhdGVOb2RlKHBhcmVudCwgbywgdiwgaG9va3MsIGdldE5leHRTaWJsaW5nKG9sZCwgb2xkRW5kICsgMSwgbmV4dFNpYmxpbmcpLCBzaG91bGRSZWN5Y2xlLCBucylcblx0XHRcdFx0XHRcdGlmIChyZWN5Y2xpbmcgfHwgc3RhcnQgPCBlbmQpIGluc2VydE5vZGUocGFyZW50LCB0b0ZyYWdtZW50KG8pLCBnZXROZXh0U2libGluZyhvbGQsIG9sZFN0YXJ0LCBuZXh0U2libGluZykpXG5cdFx0XHRcdFx0XHRvbGRFbmQtLSwgc3RhcnQrK1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIGJyZWFrXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHdoaWxlIChvbGRFbmQgPj0gb2xkU3RhcnQgJiYgZW5kID49IHN0YXJ0KSB7XG5cdFx0XHRcdHZhciBvID0gb2xkW29sZEVuZF0sIHYgPSB2bm9kZXNbZW5kXVxuXHRcdFx0XHRpZiAobyA9PT0gdiAmJiAhcmVjeWNsaW5nKSBvbGRFbmQtLSwgZW5kLS1cblx0XHRcdFx0ZWxzZSBpZiAobyA9PSBudWxsKSBvbGRFbmQtLVxuXHRcdFx0XHRlbHNlIGlmICh2ID09IG51bGwpIGVuZC0tXG5cdFx0XHRcdGVsc2UgaWYgKG8ua2V5ID09PSB2LmtleSkge1xuXHRcdFx0XHRcdHZhciBzaG91bGRSZWN5Y2xlID0gKHBvb2wgIT0gbnVsbCAmJiBvbGRFbmQgPj0gb2xkLmxlbmd0aCAtIHBvb2wubGVuZ3RoKSB8fCAoKHBvb2wgPT0gbnVsbCkgJiYgcmVjeWNsaW5nKVxuXHRcdFx0XHRcdHVwZGF0ZU5vZGUocGFyZW50LCBvLCB2LCBob29rcywgZ2V0TmV4dFNpYmxpbmcob2xkLCBvbGRFbmQgKyAxLCBuZXh0U2libGluZyksIHNob3VsZFJlY3ljbGUsIG5zKVxuXHRcdFx0XHRcdGlmIChyZWN5Y2xpbmcgJiYgby50YWcgPT09IHYudGFnKSBpbnNlcnROb2RlKHBhcmVudCwgdG9GcmFnbWVudChvKSwgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdFx0aWYgKG8uZG9tICE9IG51bGwpIG5leHRTaWJsaW5nID0gby5kb21cblx0XHRcdFx0XHRvbGRFbmQtLSwgZW5kLS1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRpZiAoIW1hcCkgbWFwID0gZ2V0S2V5TWFwKG9sZCwgb2xkRW5kKVxuXHRcdFx0XHRcdGlmICh2ICE9IG51bGwpIHtcblx0XHRcdFx0XHRcdHZhciBvbGRJbmRleCA9IG1hcFt2LmtleV1cblx0XHRcdFx0XHRcdGlmIChvbGRJbmRleCAhPSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBtb3ZhYmxlID0gb2xkW29sZEluZGV4XVxuXHRcdFx0XHRcdFx0XHR2YXIgc2hvdWxkUmVjeWNsZSA9IChwb29sICE9IG51bGwgJiYgb2xkSW5kZXggPj0gb2xkLmxlbmd0aCAtIHBvb2wubGVuZ3RoKSB8fCAoKHBvb2wgPT0gbnVsbCkgJiYgcmVjeWNsaW5nKVxuXHRcdFx0XHRcdFx0XHR1cGRhdGVOb2RlKHBhcmVudCwgbW92YWJsZSwgdiwgaG9va3MsIGdldE5leHRTaWJsaW5nKG9sZCwgb2xkRW5kICsgMSwgbmV4dFNpYmxpbmcpLCByZWN5Y2xpbmcsIG5zKVxuXHRcdFx0XHRcdFx0XHRpbnNlcnROb2RlKHBhcmVudCwgdG9GcmFnbWVudChtb3ZhYmxlKSwgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdFx0XHRcdG9sZFtvbGRJbmRleF0uc2tpcCA9IHRydWVcblx0XHRcdFx0XHRcdFx0aWYgKG1vdmFibGUuZG9tICE9IG51bGwpIG5leHRTaWJsaW5nID0gbW92YWJsZS5kb21cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR2YXIgZG9tID0gY3JlYXRlTm9kZShwYXJlbnQsIHYsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdFx0XHRcdG5leHRTaWJsaW5nID0gZG9tXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVuZC0tXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGVuZCA8IHN0YXJ0KSBicmVha1xuXHRcdFx0fVxuXHRcdFx0Y3JlYXRlTm9kZXMocGFyZW50LCB2bm9kZXMsIHN0YXJ0LCBlbmQgKyAxLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKVxuXHRcdFx0cmVtb3ZlTm9kZXMob2xkLCBvbGRTdGFydCwgb2xkRW5kICsgMSwgdm5vZGVzKVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVOb2RlKHBhcmVudCwgb2xkLCB2bm9kZSwgaG9va3MsIG5leHRTaWJsaW5nLCByZWN5Y2xpbmcsIG5zKSB7XG5cdFx0dmFyIG9sZFRhZyA9IG9sZC50YWcsIHRhZyA9IHZub2RlLnRhZ1xuXHRcdGlmIChvbGRUYWcgPT09IHRhZykge1xuXHRcdFx0dm5vZGUuc3RhdGUgPSBvbGQuc3RhdGVcblx0XHRcdHZub2RlLl9zdGF0ZSA9IG9sZC5fc3RhdGVcblx0XHRcdHZub2RlLmV2ZW50cyA9IG9sZC5ldmVudHNcblx0XHRcdGlmICghcmVjeWNsaW5nICYmIHNob3VsZE5vdFVwZGF0ZSh2bm9kZSwgb2xkKSkgcmV0dXJuXG5cdFx0XHRpZiAodHlwZW9mIG9sZFRhZyA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCkge1xuXHRcdFx0XHRcdGlmIChyZWN5Y2xpbmcpIHtcblx0XHRcdFx0XHRcdHZub2RlLnN0YXRlID0ge31cblx0XHRcdFx0XHRcdGluaXRMaWZlY3ljbGUodm5vZGUuYXR0cnMsIHZub2RlLCBob29rcylcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB1cGRhdGVMaWZlY3ljbGUodm5vZGUuYXR0cnMsIHZub2RlLCBob29rcylcblx0XHRcdFx0fVxuXHRcdFx0XHRzd2l0Y2ggKG9sZFRhZykge1xuXHRcdFx0XHRcdGNhc2UgXCIjXCI6IHVwZGF0ZVRleHQob2xkLCB2bm9kZSk7IGJyZWFrXG5cdFx0XHRcdFx0Y2FzZSBcIjxcIjogdXBkYXRlSFRNTChwYXJlbnQsIG9sZCwgdm5vZGUsIG5leHRTaWJsaW5nKTsgYnJlYWtcblx0XHRcdFx0XHRjYXNlIFwiW1wiOiB1cGRhdGVGcmFnbWVudChwYXJlbnQsIG9sZCwgdm5vZGUsIHJlY3ljbGluZywgaG9va3MsIG5leHRTaWJsaW5nLCBucyk7IGJyZWFrXG5cdFx0XHRcdFx0ZGVmYXVsdDogdXBkYXRlRWxlbWVudChvbGQsIHZub2RlLCByZWN5Y2xpbmcsIGhvb2tzLCBucylcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSB1cGRhdGVDb21wb25lbnQocGFyZW50LCBvbGQsIHZub2RlLCBob29rcywgbmV4dFNpYmxpbmcsIHJlY3ljbGluZywgbnMpXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0cmVtb3ZlTm9kZShvbGQsIG51bGwpXG5cdFx0XHRjcmVhdGVOb2RlKHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZVRleHQob2xkLCB2bm9kZSkge1xuXHRcdGlmIChvbGQuY2hpbGRyZW4udG9TdHJpbmcoKSAhPT0gdm5vZGUuY2hpbGRyZW4udG9TdHJpbmcoKSkge1xuXHRcdFx0b2xkLmRvbS5ub2RlVmFsdWUgPSB2bm9kZS5jaGlsZHJlblxuXHRcdH1cblx0XHR2bm9kZS5kb20gPSBvbGQuZG9tXG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlSFRNTChwYXJlbnQsIG9sZCwgdm5vZGUsIG5leHRTaWJsaW5nKSB7XG5cdFx0aWYgKG9sZC5jaGlsZHJlbiAhPT0gdm5vZGUuY2hpbGRyZW4pIHtcblx0XHRcdHRvRnJhZ21lbnQob2xkKVxuXHRcdFx0Y3JlYXRlSFRNTChwYXJlbnQsIHZub2RlLCBuZXh0U2libGluZylcblx0XHR9XG5cdFx0ZWxzZSB2bm9kZS5kb20gPSBvbGQuZG9tLCB2bm9kZS5kb21TaXplID0gb2xkLmRvbVNpemVcblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVGcmFnbWVudChwYXJlbnQsIG9sZCwgdm5vZGUsIHJlY3ljbGluZywgaG9va3MsIG5leHRTaWJsaW5nLCBucykge1xuXHRcdHVwZGF0ZU5vZGVzKHBhcmVudCwgb2xkLmNoaWxkcmVuLCB2bm9kZS5jaGlsZHJlbiwgcmVjeWNsaW5nLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKVxuXHRcdHZhciBkb21TaXplID0gMCwgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlblxuXHRcdHZub2RlLmRvbSA9IG51bGxcblx0XHRpZiAoY2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgY2hpbGQgPSBjaGlsZHJlbltpXVxuXHRcdFx0XHRpZiAoY2hpbGQgIT0gbnVsbCAmJiBjaGlsZC5kb20gIT0gbnVsbCkge1xuXHRcdFx0XHRcdGlmICh2bm9kZS5kb20gPT0gbnVsbCkgdm5vZGUuZG9tID0gY2hpbGQuZG9tXG5cdFx0XHRcdFx0ZG9tU2l6ZSArPSBjaGlsZC5kb21TaXplIHx8IDFcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGRvbVNpemUgIT09IDEpIHZub2RlLmRvbVNpemUgPSBkb21TaXplXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUVsZW1lbnQob2xkLCB2bm9kZSwgcmVjeWNsaW5nLCBob29rcywgbnMpIHtcblx0XHR2YXIgZWxlbWVudCA9IHZub2RlLmRvbSA9IG9sZC5kb21cblx0XHRucyA9IGdldE5hbWVTcGFjZSh2bm9kZSkgfHwgbnNcblx0XHRpZiAodm5vZGUudGFnID09PSBcInRleHRhcmVhXCIpIHtcblx0XHRcdGlmICh2bm9kZS5hdHRycyA9PSBudWxsKSB2bm9kZS5hdHRycyA9IHt9XG5cdFx0XHRpZiAodm5vZGUudGV4dCAhPSBudWxsKSB7XG5cdFx0XHRcdHZub2RlLmF0dHJzLnZhbHVlID0gdm5vZGUudGV4dCAvL0ZJWE1FIGhhbmRsZTAgbXVsdGlwbGUgY2hpbGRyZW5cblx0XHRcdFx0dm5vZGUudGV4dCA9IHVuZGVmaW5lZFxuXHRcdFx0fVxuXHRcdH1cblx0XHR1cGRhdGVBdHRycyh2bm9kZSwgb2xkLmF0dHJzLCB2bm9kZS5hdHRycywgbnMpXG5cdFx0aWYgKHZub2RlLmF0dHJzICE9IG51bGwgJiYgdm5vZGUuYXR0cnMuY29udGVudGVkaXRhYmxlICE9IG51bGwpIHtcblx0XHRcdHNldENvbnRlbnRFZGl0YWJsZSh2bm9kZSlcblx0XHR9XG5cdFx0ZWxzZSBpZiAob2xkLnRleHQgIT0gbnVsbCAmJiB2bm9kZS50ZXh0ICE9IG51bGwgJiYgdm5vZGUudGV4dCAhPT0gXCJcIikge1xuXHRcdFx0aWYgKG9sZC50ZXh0LnRvU3RyaW5nKCkgIT09IHZub2RlLnRleHQudG9TdHJpbmcoKSkgb2xkLmRvbS5maXJzdENoaWxkLm5vZGVWYWx1ZSA9IHZub2RlLnRleHRcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRpZiAob2xkLnRleHQgIT0gbnVsbCkgb2xkLmNoaWxkcmVuID0gW1Zub2RlKFwiI1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgb2xkLnRleHQsIHVuZGVmaW5lZCwgb2xkLmRvbS5maXJzdENoaWxkKV1cblx0XHRcdGlmICh2bm9kZS50ZXh0ICE9IG51bGwpIHZub2RlLmNoaWxkcmVuID0gW1Zub2RlKFwiI1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdm5vZGUudGV4dCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXVxuXHRcdFx0dXBkYXRlTm9kZXMoZWxlbWVudCwgb2xkLmNoaWxkcmVuLCB2bm9kZS5jaGlsZHJlbiwgcmVjeWNsaW5nLCBob29rcywgbnVsbCwgbnMpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUNvbXBvbmVudChwYXJlbnQsIG9sZCwgdm5vZGUsIGhvb2tzLCBuZXh0U2libGluZywgcmVjeWNsaW5nLCBucykge1xuXHRcdGlmIChyZWN5Y2xpbmcpIHtcblx0XHRcdGluaXRDb21wb25lbnQodm5vZGUsIGhvb2tzKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2bm9kZS5pbnN0YW5jZSA9IFZub2RlLm5vcm1hbGl6ZSh2bm9kZS5fc3RhdGUudmlldy5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSkpXG5cdFx0XHRpZiAodm5vZGUuaW5zdGFuY2UgPT09IHZub2RlKSB0aHJvdyBFcnJvcihcIkEgdmlldyBjYW5ub3QgcmV0dXJuIHRoZSB2bm9kZSBpdCByZWNlaXZlZCBhcyBhcmd1bWVudFwiKVxuXHRcdFx0aWYgKHZub2RlLmF0dHJzICE9IG51bGwpIHVwZGF0ZUxpZmVjeWNsZSh2bm9kZS5hdHRycywgdm5vZGUsIGhvb2tzKVxuXHRcdFx0dXBkYXRlTGlmZWN5Y2xlKHZub2RlLl9zdGF0ZSwgdm5vZGUsIGhvb2tzKVxuXHRcdH1cblx0XHRpZiAodm5vZGUuaW5zdGFuY2UgIT0gbnVsbCkge1xuXHRcdFx0aWYgKG9sZC5pbnN0YW5jZSA9PSBudWxsKSBjcmVhdGVOb2RlKHBhcmVudCwgdm5vZGUuaW5zdGFuY2UsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0XHRlbHNlIHVwZGF0ZU5vZGUocGFyZW50LCBvbGQuaW5zdGFuY2UsIHZub2RlLmluc3RhbmNlLCBob29rcywgbmV4dFNpYmxpbmcsIHJlY3ljbGluZywgbnMpXG5cdFx0XHR2bm9kZS5kb20gPSB2bm9kZS5pbnN0YW5jZS5kb21cblx0XHRcdHZub2RlLmRvbVNpemUgPSB2bm9kZS5pbnN0YW5jZS5kb21TaXplXG5cdFx0fVxuXHRcdGVsc2UgaWYgKG9sZC5pbnN0YW5jZSAhPSBudWxsKSB7XG5cdFx0XHRyZW1vdmVOb2RlKG9sZC5pbnN0YW5jZSwgbnVsbClcblx0XHRcdHZub2RlLmRvbSA9IHVuZGVmaW5lZFxuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IDBcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHR2bm9kZS5kb20gPSBvbGQuZG9tXG5cdFx0XHR2bm9kZS5kb21TaXplID0gb2xkLmRvbVNpemVcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gaXNSZWN5Y2xhYmxlKG9sZCwgdm5vZGVzKSB7XG5cdFx0aWYgKG9sZC5wb29sICE9IG51bGwgJiYgTWF0aC5hYnMob2xkLnBvb2wubGVuZ3RoIC0gdm5vZGVzLmxlbmd0aCkgPD0gTWF0aC5hYnMob2xkLmxlbmd0aCAtIHZub2Rlcy5sZW5ndGgpKSB7XG5cdFx0XHR2YXIgb2xkQ2hpbGRyZW5MZW5ndGggPSBvbGRbMF0gJiYgb2xkWzBdLmNoaWxkcmVuICYmIG9sZFswXS5jaGlsZHJlbi5sZW5ndGggfHwgMFxuXHRcdFx0dmFyIHBvb2xDaGlsZHJlbkxlbmd0aCA9IG9sZC5wb29sWzBdICYmIG9sZC5wb29sWzBdLmNoaWxkcmVuICYmIG9sZC5wb29sWzBdLmNoaWxkcmVuLmxlbmd0aCB8fCAwXG5cdFx0XHR2YXIgdm5vZGVzQ2hpbGRyZW5MZW5ndGggPSB2bm9kZXNbMF0gJiYgdm5vZGVzWzBdLmNoaWxkcmVuICYmIHZub2Rlc1swXS5jaGlsZHJlbi5sZW5ndGggfHwgMFxuXHRcdFx0aWYgKE1hdGguYWJzKHBvb2xDaGlsZHJlbkxlbmd0aCAtIHZub2Rlc0NoaWxkcmVuTGVuZ3RoKSA8PSBNYXRoLmFicyhvbGRDaGlsZHJlbkxlbmd0aCAtIHZub2Rlc0NoaWxkcmVuTGVuZ3RoKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2Vcblx0fVxuXHRmdW5jdGlvbiBnZXRLZXlNYXAodm5vZGVzLCBlbmQpIHtcblx0XHR2YXIgbWFwID0ge30sIGkgPSAwXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBlbmQ7IGkrKykge1xuXHRcdFx0dmFyIHZub2RlID0gdm5vZGVzW2ldXG5cdFx0XHRpZiAodm5vZGUgIT0gbnVsbCkge1xuXHRcdFx0XHR2YXIga2V5MiA9IHZub2RlLmtleVxuXHRcdFx0XHRpZiAoa2V5MiAhPSBudWxsKSBtYXBba2V5Ml0gPSBpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBtYXBcblx0fVxuXHRmdW5jdGlvbiB0b0ZyYWdtZW50KHZub2RlKSB7XG5cdFx0dmFyIGNvdW50MCA9IHZub2RlLmRvbVNpemVcblx0XHRpZiAoY291bnQwICE9IG51bGwgfHwgdm5vZGUuZG9tID09IG51bGwpIHtcblx0XHRcdHZhciBmcmFnbWVudCA9ICRkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG5cdFx0XHRpZiAoY291bnQwID4gMCkge1xuXHRcdFx0XHR2YXIgZG9tID0gdm5vZGUuZG9tXG5cdFx0XHRcdHdoaWxlICgtLWNvdW50MCkgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZG9tLm5leHRTaWJsaW5nKVxuXHRcdFx0XHRmcmFnbWVudC5pbnNlcnRCZWZvcmUoZG9tLCBmcmFnbWVudC5maXJzdENoaWxkKVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZyYWdtZW50XG5cdFx0fVxuXHRcdGVsc2UgcmV0dXJuIHZub2RlLmRvbVxuXHR9XG5cdGZ1bmN0aW9uIGdldE5leHRTaWJsaW5nKHZub2RlcywgaSwgbmV4dFNpYmxpbmcpIHtcblx0XHRmb3IgKDsgaSA8IHZub2Rlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKHZub2Rlc1tpXSAhPSBudWxsICYmIHZub2Rlc1tpXS5kb20gIT0gbnVsbCkgcmV0dXJuIHZub2Rlc1tpXS5kb21cblx0XHR9XG5cdFx0cmV0dXJuIG5leHRTaWJsaW5nXG5cdH1cblx0ZnVuY3Rpb24gaW5zZXJ0Tm9kZShwYXJlbnQsIGRvbSwgbmV4dFNpYmxpbmcpIHtcblx0XHRpZiAobmV4dFNpYmxpbmcgJiYgbmV4dFNpYmxpbmcucGFyZW50Tm9kZSkgcGFyZW50Lmluc2VydEJlZm9yZShkb20sIG5leHRTaWJsaW5nKVxuXHRcdGVsc2UgcGFyZW50LmFwcGVuZENoaWxkKGRvbSlcblx0fVxuXHRmdW5jdGlvbiBzZXRDb250ZW50RWRpdGFibGUodm5vZGUpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlblxuXHRcdGlmIChjaGlsZHJlbiAhPSBudWxsICYmIGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBjaGlsZHJlblswXS50YWcgPT09IFwiPFwiKSB7XG5cdFx0XHR2YXIgY29udGVudCA9IGNoaWxkcmVuWzBdLmNoaWxkcmVuXG5cdFx0XHRpZiAodm5vZGUuZG9tLmlubmVySFRNTCAhPT0gY29udGVudCkgdm5vZGUuZG9tLmlubmVySFRNTCA9IGNvbnRlbnRcblx0XHR9XG5cdFx0ZWxzZSBpZiAodm5vZGUudGV4dCAhPSBudWxsIHx8IGNoaWxkcmVuICE9IG51bGwgJiYgY2hpbGRyZW4ubGVuZ3RoICE9PSAwKSB0aHJvdyBuZXcgRXJyb3IoXCJDaGlsZCBub2RlIG9mIGEgY29udGVudGVkaXRhYmxlIG11c3QgYmUgdHJ1c3RlZFwiKVxuXHR9XG5cdC8vcmVtb3ZlXG5cdGZ1bmN0aW9uIHJlbW92ZU5vZGVzKHZub2Rlcywgc3RhcnQsIGVuZCwgY29udGV4dCkge1xuXHRcdGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG5cdFx0XHR2YXIgdm5vZGUgPSB2bm9kZXNbaV1cblx0XHRcdGlmICh2bm9kZSAhPSBudWxsKSB7XG5cdFx0XHRcdGlmICh2bm9kZS5za2lwKSB2bm9kZS5za2lwID0gZmFsc2Vcblx0XHRcdFx0ZWxzZSByZW1vdmVOb2RlKHZub2RlLCBjb250ZXh0KVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiByZW1vdmVOb2RlKHZub2RlLCBjb250ZXh0KSB7XG5cdFx0dmFyIGV4cGVjdGVkID0gMSwgY2FsbGVkID0gMFxuXHRcdGlmICh2bm9kZS5hdHRycyAmJiB0eXBlb2Ygdm5vZGUuYXR0cnMub25iZWZvcmVyZW1vdmUgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0dmFyIHJlc3VsdCA9IHZub2RlLmF0dHJzLm9uYmVmb3JlcmVtb3ZlLmNhbGwodm5vZGUuc3RhdGUsIHZub2RlKVxuXHRcdFx0aWYgKHJlc3VsdCAhPSBudWxsICYmIHR5cGVvZiByZXN1bHQudGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdGV4cGVjdGVkKytcblx0XHRcdFx0cmVzdWx0LnRoZW4oY29udGludWF0aW9uLCBjb250aW51YXRpb24pXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICh0eXBlb2Ygdm5vZGUudGFnICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiB2bm9kZS5fc3RhdGUub25iZWZvcmVyZW1vdmUgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0dmFyIHJlc3VsdCA9IHZub2RlLl9zdGF0ZS5vbmJlZm9yZXJlbW92ZS5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSlcblx0XHRcdGlmIChyZXN1bHQgIT0gbnVsbCAmJiB0eXBlb2YgcmVzdWx0LnRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRleHBlY3RlZCsrXG5cdFx0XHRcdHJlc3VsdC50aGVuKGNvbnRpbnVhdGlvbiwgY29udGludWF0aW9uKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRjb250aW51YXRpb24oKVxuXHRcdGZ1bmN0aW9uIGNvbnRpbnVhdGlvbigpIHtcblx0XHRcdGlmICgrK2NhbGxlZCA9PT0gZXhwZWN0ZWQpIHtcblx0XHRcdFx0b25yZW1vdmUodm5vZGUpXG5cdFx0XHRcdGlmICh2bm9kZS5kb20pIHtcblx0XHRcdFx0XHR2YXIgY291bnQwID0gdm5vZGUuZG9tU2l6ZSB8fCAxXG5cdFx0XHRcdFx0aWYgKGNvdW50MCA+IDEpIHtcblx0XHRcdFx0XHRcdHZhciBkb20gPSB2bm9kZS5kb21cblx0XHRcdFx0XHRcdHdoaWxlICgtLWNvdW50MCkge1xuXHRcdFx0XHRcdFx0XHRyZW1vdmVOb2RlRnJvbURPTShkb20ubmV4dFNpYmxpbmcpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJlbW92ZU5vZGVGcm9tRE9NKHZub2RlLmRvbSlcblx0XHRcdFx0XHRpZiAoY29udGV4dCAhPSBudWxsICYmIHZub2RlLmRvbVNpemUgPT0gbnVsbCAmJiAhaGFzSW50ZWdyYXRpb25NZXRob2RzKHZub2RlLmF0dHJzKSAmJiB0eXBlb2Ygdm5vZGUudGFnID09PSBcInN0cmluZ1wiKSB7IC8vVE9ETyB0ZXN0IGN1c3RvbSBlbGVtZW50c1xuXHRcdFx0XHRcdFx0aWYgKCFjb250ZXh0LnBvb2wpIGNvbnRleHQucG9vbCA9IFt2bm9kZV1cblx0XHRcdFx0XHRcdGVsc2UgY29udGV4dC5wb29sLnB1c2godm5vZGUpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHJlbW92ZU5vZGVGcm9tRE9NKG5vZGUpIHtcblx0XHR2YXIgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlXG5cdFx0aWYgKHBhcmVudCAhPSBudWxsKSBwYXJlbnQucmVtb3ZlQ2hpbGQobm9kZSlcblx0fVxuXHRmdW5jdGlvbiBvbnJlbW92ZSh2bm9kZSkge1xuXHRcdGlmICh2bm9kZS5hdHRycyAmJiB0eXBlb2Ygdm5vZGUuYXR0cnMub25yZW1vdmUgPT09IFwiZnVuY3Rpb25cIikgdm5vZGUuYXR0cnMub25yZW1vdmUuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpXG5cdFx0aWYgKHR5cGVvZiB2bm9kZS50YWcgIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHZub2RlLl9zdGF0ZS5vbnJlbW92ZSA9PT0gXCJmdW5jdGlvblwiKSB2bm9kZS5fc3RhdGUub25yZW1vdmUuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpXG5cdFx0aWYgKHZub2RlLmluc3RhbmNlICE9IG51bGwpIG9ucmVtb3ZlKHZub2RlLmluc3RhbmNlKVxuXHRcdGVsc2Uge1xuXHRcdFx0dmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW5cblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0dmFyIGNoaWxkID0gY2hpbGRyZW5baV1cblx0XHRcdFx0XHRpZiAoY2hpbGQgIT0gbnVsbCkgb25yZW1vdmUoY2hpbGQpXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0Ly9hdHRyczJcblx0ZnVuY3Rpb24gc2V0QXR0cnModm5vZGUsIGF0dHJzMiwgbnMpIHtcblx0XHRmb3IgKHZhciBrZXkyIGluIGF0dHJzMikge1xuXHRcdFx0c2V0QXR0cih2bm9kZSwga2V5MiwgbnVsbCwgYXR0cnMyW2tleTJdLCBucylcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gc2V0QXR0cih2bm9kZSwga2V5Miwgb2xkLCB2YWx1ZSwgbnMpIHtcblx0XHR2YXIgZWxlbWVudCA9IHZub2RlLmRvbVxuXHRcdGlmIChrZXkyID09PSBcImtleVwiIHx8IGtleTIgPT09IFwiaXNcIiB8fCAob2xkID09PSB2YWx1ZSAmJiAhaXNGb3JtQXR0cmlidXRlKHZub2RlLCBrZXkyKSkgJiYgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIiB8fCBpc0xpZmVjeWNsZU1ldGhvZChrZXkyKSkgcmV0dXJuXG5cdFx0dmFyIG5zTGFzdEluZGV4ID0ga2V5Mi5pbmRleE9mKFwiOlwiKVxuXHRcdGlmIChuc0xhc3RJbmRleCA+IC0xICYmIGtleTIuc3Vic3RyKDAsIG5zTGFzdEluZGV4KSA9PT0gXCJ4bGlua1wiKSB7XG5cdFx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZU5TKFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLCBrZXkyLnNsaWNlKG5zTGFzdEluZGV4ICsgMSksIHZhbHVlKVxuXHRcdH1cblx0XHRlbHNlIGlmIChrZXkyWzBdID09PSBcIm9cIiAmJiBrZXkyWzFdID09PSBcIm5cIiAmJiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikgdXBkYXRlRXZlbnQodm5vZGUsIGtleTIsIHZhbHVlKVxuXHRcdGVsc2UgaWYgKGtleTIgPT09IFwic3R5bGVcIikgdXBkYXRlU3R5bGUoZWxlbWVudCwgb2xkLCB2YWx1ZSlcblx0XHRlbHNlIGlmIChrZXkyIGluIGVsZW1lbnQgJiYgIWlzQXR0cmlidXRlKGtleTIpICYmIG5zID09PSB1bmRlZmluZWQgJiYgIWlzQ3VzdG9tRWxlbWVudCh2bm9kZSkpIHtcblx0XHRcdGlmIChrZXkyID09PSBcInZhbHVlXCIpIHtcblx0XHRcdFx0dmFyIG5vcm1hbGl6ZWQwID0gXCJcIiArIHZhbHVlIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8taW1wbGljaXQtY29lcmNpb25cblx0XHRcdFx0Ly9zZXR0aW5nIGlucHV0W3ZhbHVlXSB0byBzYW1lIHZhbHVlIGJ5IHR5cGluZyBvbiBmb2N1c2VkIGVsZW1lbnQgbW92ZXMgY3Vyc29yIHRvIGVuZCBpbiBDaHJvbWVcblx0XHRcdFx0aWYgKCh2bm9kZS50YWcgPT09IFwiaW5wdXRcIiB8fCB2bm9kZS50YWcgPT09IFwidGV4dGFyZWFcIikgJiYgdm5vZGUuZG9tLnZhbHVlID09PSBub3JtYWxpemVkMCAmJiB2bm9kZS5kb20gPT09ICRkb2MuYWN0aXZlRWxlbWVudCkgcmV0dXJuXG5cdFx0XHRcdC8vc2V0dGluZyBzZWxlY3RbdmFsdWVdIHRvIHNhbWUgdmFsdWUgd2hpbGUgaGF2aW5nIHNlbGVjdCBvcGVuIGJsaW5rcyBzZWxlY3QgZHJvcGRvd24gaW4gQ2hyb21lXG5cdFx0XHRcdGlmICh2bm9kZS50YWcgPT09IFwic2VsZWN0XCIpIHtcblx0XHRcdFx0XHRpZiAodmFsdWUgPT09IG51bGwpIHtcblx0XHRcdFx0XHRcdGlmICh2bm9kZS5kb20uc2VsZWN0ZWRJbmRleCA9PT0gLTEgJiYgdm5vZGUuZG9tID09PSAkZG9jLmFjdGl2ZUVsZW1lbnQpIHJldHVyblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpZiAob2xkICE9PSBudWxsICYmIHZub2RlLmRvbS52YWx1ZSA9PT0gbm9ybWFsaXplZDAgJiYgdm5vZGUuZG9tID09PSAkZG9jLmFjdGl2ZUVsZW1lbnQpIHJldHVyblxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHQvL3NldHRpbmcgb3B0aW9uW3ZhbHVlXSB0byBzYW1lIHZhbHVlIHdoaWxlIGhhdmluZyBzZWxlY3Qgb3BlbiBibGlua3Mgc2VsZWN0IGRyb3Bkb3duIGluIENocm9tZVxuXHRcdFx0XHRpZiAodm5vZGUudGFnID09PSBcIm9wdGlvblwiICYmIG9sZCAhPSBudWxsICYmIHZub2RlLmRvbS52YWx1ZSA9PT0gbm9ybWFsaXplZDApIHJldHVyblxuXHRcdFx0fVxuXHRcdFx0Ly8gSWYgeW91IGFzc2lnbiBhbiBpbnB1dCB0eXBlMSB0aGF0IGlzIG5vdCBzdXBwb3J0ZWQgYnkgSUUgMTEgd2l0aCBhbiBhc3NpZ25tZW50IGV4cHJlc3Npb24sIGFuIGVycm9yMCB3aWxsIG9jY3VyLlxuXHRcdFx0aWYgKHZub2RlLnRhZyA9PT0gXCJpbnB1dFwiICYmIGtleTIgPT09IFwidHlwZVwiKSB7XG5cdFx0XHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleTIsIHZhbHVlKVxuXHRcdFx0XHRyZXR1cm5cblx0XHRcdH1cblx0XHRcdGVsZW1lbnRba2V5Ml0gPSB2YWx1ZVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiKSB7XG5cdFx0XHRcdGlmICh2YWx1ZSkgZWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5MiwgXCJcIilcblx0XHRcdFx0ZWxzZSBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShrZXkyKVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSBlbGVtZW50LnNldEF0dHJpYnV0ZShrZXkyID09PSBcImNsYXNzTmFtZVwiID8gXCJjbGFzc1wiIDoga2V5MiwgdmFsdWUpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHNldExhdGVBdHRycyh2bm9kZSkge1xuXHRcdHZhciBhdHRyczIgPSB2bm9kZS5hdHRyc1xuXHRcdGlmICh2bm9kZS50YWcgPT09IFwic2VsZWN0XCIgJiYgYXR0cnMyICE9IG51bGwpIHtcblx0XHRcdGlmIChcInZhbHVlXCIgaW4gYXR0cnMyKSBzZXRBdHRyKHZub2RlLCBcInZhbHVlXCIsIG51bGwsIGF0dHJzMi52YWx1ZSwgdW5kZWZpbmVkKVxuXHRcdFx0aWYgKFwic2VsZWN0ZWRJbmRleFwiIGluIGF0dHJzMikgc2V0QXR0cih2bm9kZSwgXCJzZWxlY3RlZEluZGV4XCIsIG51bGwsIGF0dHJzMi5zZWxlY3RlZEluZGV4LCB1bmRlZmluZWQpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUF0dHJzKHZub2RlLCBvbGQsIGF0dHJzMiwgbnMpIHtcblx0XHRpZiAoYXR0cnMyICE9IG51bGwpIHtcblx0XHRcdGZvciAodmFyIGtleTIgaW4gYXR0cnMyKSB7XG5cdFx0XHRcdHNldEF0dHIodm5vZGUsIGtleTIsIG9sZCAmJiBvbGRba2V5Ml0sIGF0dHJzMltrZXkyXSwgbnMpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChvbGQgIT0gbnVsbCkge1xuXHRcdFx0Zm9yICh2YXIga2V5MiBpbiBvbGQpIHtcblx0XHRcdFx0aWYgKGF0dHJzMiA9PSBudWxsIHx8ICEoa2V5MiBpbiBhdHRyczIpKSB7XG5cdFx0XHRcdFx0aWYgKGtleTIgPT09IFwiY2xhc3NOYW1lXCIpIGtleTIgPSBcImNsYXNzXCJcblx0XHRcdFx0XHRpZiAoa2V5MlswXSA9PT0gXCJvXCIgJiYga2V5MlsxXSA9PT0gXCJuXCIgJiYgIWlzTGlmZWN5Y2xlTWV0aG9kKGtleTIpKSB1cGRhdGVFdmVudCh2bm9kZSwga2V5MiwgdW5kZWZpbmVkKVxuXHRcdFx0XHRcdGVsc2UgaWYgKGtleTIgIT09IFwia2V5XCIpIHZub2RlLmRvbS5yZW1vdmVBdHRyaWJ1dGUoa2V5Milcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBpc0Zvcm1BdHRyaWJ1dGUodm5vZGUsIGF0dHIpIHtcblx0XHRyZXR1cm4gYXR0ciA9PT0gXCJ2YWx1ZVwiIHx8IGF0dHIgPT09IFwiY2hlY2tlZFwiIHx8IGF0dHIgPT09IFwic2VsZWN0ZWRJbmRleFwiIHx8IGF0dHIgPT09IFwic2VsZWN0ZWRcIiAmJiB2bm9kZS5kb20gPT09ICRkb2MuYWN0aXZlRWxlbWVudFxuXHR9XG5cdGZ1bmN0aW9uIGlzTGlmZWN5Y2xlTWV0aG9kKGF0dHIpIHtcblx0XHRyZXR1cm4gYXR0ciA9PT0gXCJvbmluaXRcIiB8fCBhdHRyID09PSBcIm9uY3JlYXRlXCIgfHwgYXR0ciA9PT0gXCJvbnVwZGF0ZVwiIHx8IGF0dHIgPT09IFwib25yZW1vdmVcIiB8fCBhdHRyID09PSBcIm9uYmVmb3JlcmVtb3ZlXCIgfHwgYXR0ciA9PT0gXCJvbmJlZm9yZXVwZGF0ZVwiXG5cdH1cblx0ZnVuY3Rpb24gaXNBdHRyaWJ1dGUoYXR0cikge1xuXHRcdHJldHVybiBhdHRyID09PSBcImhyZWZcIiB8fCBhdHRyID09PSBcImxpc3RcIiB8fCBhdHRyID09PSBcImZvcm1cIiB8fCBhdHRyID09PSBcIndpZHRoXCIgfHwgYXR0ciA9PT0gXCJoZWlnaHRcIi8vIHx8IGF0dHIgPT09IFwidHlwZVwiXG5cdH1cblx0ZnVuY3Rpb24gaXNDdXN0b21FbGVtZW50KHZub2RlKXtcblx0XHRyZXR1cm4gdm5vZGUuYXR0cnMuaXMgfHwgdm5vZGUudGFnLmluZGV4T2YoXCItXCIpID4gLTFcblx0fVxuXHRmdW5jdGlvbiBoYXNJbnRlZ3JhdGlvbk1ldGhvZHMoc291cmNlKSB7XG5cdFx0cmV0dXJuIHNvdXJjZSAhPSBudWxsICYmIChzb3VyY2Uub25jcmVhdGUgfHwgc291cmNlLm9udXBkYXRlIHx8IHNvdXJjZS5vbmJlZm9yZXJlbW92ZSB8fCBzb3VyY2Uub25yZW1vdmUpXG5cdH1cblx0Ly9zdHlsZVxuXHRmdW5jdGlvbiB1cGRhdGVTdHlsZShlbGVtZW50LCBvbGQsIHN0eWxlKSB7XG5cdFx0aWYgKG9sZCA9PT0gc3R5bGUpIGVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IFwiXCIsIG9sZCA9IG51bGxcblx0XHRpZiAoc3R5bGUgPT0gbnVsbCkgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gXCJcIlxuXHRcdGVsc2UgaWYgKHR5cGVvZiBzdHlsZSA9PT0gXCJzdHJpbmdcIikgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gc3R5bGVcblx0XHRlbHNlIHtcblx0XHRcdGlmICh0eXBlb2Ygb2xkID09PSBcInN0cmluZ1wiKSBlbGVtZW50LnN0eWxlLmNzc1RleHQgPSBcIlwiXG5cdFx0XHRmb3IgKHZhciBrZXkyIGluIHN0eWxlKSB7XG5cdFx0XHRcdGVsZW1lbnQuc3R5bGVba2V5Ml0gPSBzdHlsZVtrZXkyXVxuXHRcdFx0fVxuXHRcdFx0aWYgKG9sZCAhPSBudWxsICYmIHR5cGVvZiBvbGQgIT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0Zm9yICh2YXIga2V5MiBpbiBvbGQpIHtcblx0XHRcdFx0XHRpZiAoIShrZXkyIGluIHN0eWxlKSkgZWxlbWVudC5zdHlsZVtrZXkyXSA9IFwiXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHQvL2V2ZW50XG5cdGZ1bmN0aW9uIHVwZGF0ZUV2ZW50KHZub2RlLCBrZXkyLCB2YWx1ZSkge1xuXHRcdHZhciBlbGVtZW50ID0gdm5vZGUuZG9tXG5cdFx0dmFyIGNhbGxiYWNrID0gdHlwZW9mIG9uZXZlbnQgIT09IFwiZnVuY3Rpb25cIiA/IHZhbHVlIDogZnVuY3Rpb24oZSkge1xuXHRcdFx0dmFyIHJlc3VsdCA9IHZhbHVlLmNhbGwoZWxlbWVudCwgZSlcblx0XHRcdG9uZXZlbnQuY2FsbChlbGVtZW50LCBlKVxuXHRcdFx0cmV0dXJuIHJlc3VsdFxuXHRcdH1cblx0XHRpZiAoa2V5MiBpbiBlbGVtZW50KSBlbGVtZW50W2tleTJdID0gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBjYWxsYmFjayA6IG51bGxcblx0XHRlbHNlIHtcblx0XHRcdHZhciBldmVudE5hbWUgPSBrZXkyLnNsaWNlKDIpXG5cdFx0XHRpZiAodm5vZGUuZXZlbnRzID09PSB1bmRlZmluZWQpIHZub2RlLmV2ZW50cyA9IHt9XG5cdFx0XHRpZiAodm5vZGUuZXZlbnRzW2tleTJdID09PSBjYWxsYmFjaykgcmV0dXJuXG5cdFx0XHRpZiAodm5vZGUuZXZlbnRzW2tleTJdICE9IG51bGwpIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIHZub2RlLmV2ZW50c1trZXkyXSwgZmFsc2UpXG5cdFx0XHRpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0dm5vZGUuZXZlbnRzW2tleTJdID0gY2FsbGJhY2tcblx0XHRcdFx0ZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgdm5vZGUuZXZlbnRzW2tleTJdLCBmYWxzZSlcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0Ly9saWZlY3ljbGVcblx0ZnVuY3Rpb24gaW5pdExpZmVjeWNsZShzb3VyY2UsIHZub2RlLCBob29rcykge1xuXHRcdGlmICh0eXBlb2Ygc291cmNlLm9uaW5pdCA9PT0gXCJmdW5jdGlvblwiKSBzb3VyY2Uub25pbml0LmNhbGwodm5vZGUuc3RhdGUsIHZub2RlKVxuXHRcdGlmICh0eXBlb2Ygc291cmNlLm9uY3JlYXRlID09PSBcImZ1bmN0aW9uXCIpIGhvb2tzLnB1c2goc291cmNlLm9uY3JlYXRlLmJpbmQodm5vZGUuc3RhdGUsIHZub2RlKSlcblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVMaWZlY3ljbGUoc291cmNlLCB2bm9kZSwgaG9va3MpIHtcblx0XHRpZiAodHlwZW9mIHNvdXJjZS5vbnVwZGF0ZSA9PT0gXCJmdW5jdGlvblwiKSBob29rcy5wdXNoKHNvdXJjZS5vbnVwZGF0ZS5iaW5kKHZub2RlLnN0YXRlLCB2bm9kZSkpXG5cdH1cblx0ZnVuY3Rpb24gc2hvdWxkTm90VXBkYXRlKHZub2RlLCBvbGQpIHtcblx0XHR2YXIgZm9yY2VWbm9kZVVwZGF0ZSwgZm9yY2VDb21wb25lbnRVcGRhdGVcblx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCAmJiB0eXBlb2Ygdm5vZGUuYXR0cnMub25iZWZvcmV1cGRhdGUgPT09IFwiZnVuY3Rpb25cIikgZm9yY2VWbm9kZVVwZGF0ZSA9IHZub2RlLmF0dHJzLm9uYmVmb3JldXBkYXRlLmNhbGwodm5vZGUuc3RhdGUsIHZub2RlLCBvbGQpXG5cdFx0aWYgKHR5cGVvZiB2bm9kZS50YWcgIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHZub2RlLl9zdGF0ZS5vbmJlZm9yZXVwZGF0ZSA9PT0gXCJmdW5jdGlvblwiKSBmb3JjZUNvbXBvbmVudFVwZGF0ZSA9IHZub2RlLl9zdGF0ZS5vbmJlZm9yZXVwZGF0ZS5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSwgb2xkKVxuXHRcdGlmICghKGZvcmNlVm5vZGVVcGRhdGUgPT09IHVuZGVmaW5lZCAmJiBmb3JjZUNvbXBvbmVudFVwZGF0ZSA9PT0gdW5kZWZpbmVkKSAmJiAhZm9yY2VWbm9kZVVwZGF0ZSAmJiAhZm9yY2VDb21wb25lbnRVcGRhdGUpIHtcblx0XHRcdHZub2RlLmRvbSA9IG9sZC5kb21cblx0XHRcdHZub2RlLmRvbVNpemUgPSBvbGQuZG9tU2l6ZVxuXHRcdFx0dm5vZGUuaW5zdGFuY2UgPSBvbGQuaW5zdGFuY2Vcblx0XHRcdHJldHVybiB0cnVlXG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZVxuXHR9XG5cdGZ1bmN0aW9uIHJlbmRlcihkb20sIHZub2Rlcykge1xuXHRcdGlmICghZG9tKSB0aHJvdyBuZXcgRXJyb3IoXCJFbnN1cmUgdGhlIERPTSBlbGVtZW50IGJlaW5nIHBhc3NlZCB0byBtLnJvdXRlL20ubW91bnQvbS5yZW5kZXIgaXMgbm90IHVuZGVmaW5lZC5cIilcblx0XHR2YXIgaG9va3MgPSBbXVxuXHRcdHZhciBhY3RpdmUgPSAkZG9jLmFjdGl2ZUVsZW1lbnRcblx0XHR2YXIgbmFtZXNwYWNlID0gZG9tLm5hbWVzcGFjZVVSSVxuXHRcdC8vIEZpcnN0IHRpbWUwIHJlbmRlcmluZyBpbnRvIGEgbm9kZSBjbGVhcnMgaXQgb3V0XG5cdFx0aWYgKGRvbS52bm9kZXMgPT0gbnVsbCkgZG9tLnRleHRDb250ZW50ID0gXCJcIlxuXHRcdGlmICghQXJyYXkuaXNBcnJheSh2bm9kZXMpKSB2bm9kZXMgPSBbdm5vZGVzXVxuXHRcdHVwZGF0ZU5vZGVzKGRvbSwgZG9tLnZub2RlcywgVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4odm5vZGVzKSwgZmFsc2UsIGhvb2tzLCBudWxsLCBuYW1lc3BhY2UgPT09IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiID8gdW5kZWZpbmVkIDogbmFtZXNwYWNlKVxuXHRcdGRvbS52bm9kZXMgPSB2bm9kZXNcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSBob29rc1tpXSgpXG5cdFx0aWYgKCRkb2MuYWN0aXZlRWxlbWVudCAhPT0gYWN0aXZlKSBhY3RpdmUuZm9jdXMoKVxuXHR9XG5cdHJldHVybiB7cmVuZGVyOiByZW5kZXIsIHNldEV2ZW50Q2FsbGJhY2s6IHNldEV2ZW50Q2FsbGJhY2t9XG59XG5mdW5jdGlvbiB0aHJvdHRsZShjYWxsYmFjaykge1xuXHQvLzYwZnBzIHRyYW5zbGF0ZXMgdG8gMTYuNm1zLCByb3VuZCBpdCBkb3duIHNpbmNlIHNldFRpbWVvdXQgcmVxdWlyZXMgaW50XG5cdHZhciB0aW1lID0gMTZcblx0dmFyIGxhc3QgPSAwLCBwZW5kaW5nID0gbnVsbFxuXHR2YXIgdGltZW91dCA9IHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09IFwiZnVuY3Rpb25cIiA/IHJlcXVlc3RBbmltYXRpb25GcmFtZSA6IHNldFRpbWVvdXRcblx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBub3cgPSBEYXRlLm5vdygpXG5cdFx0aWYgKGxhc3QgPT09IDAgfHwgbm93IC0gbGFzdCA+PSB0aW1lKSB7XG5cdFx0XHRsYXN0ID0gbm93XG5cdFx0XHRjYWxsYmFjaygpXG5cdFx0fVxuXHRcdGVsc2UgaWYgKHBlbmRpbmcgPT09IG51bGwpIHtcblx0XHRcdHBlbmRpbmcgPSB0aW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRwZW5kaW5nID0gbnVsbFxuXHRcdFx0XHRjYWxsYmFjaygpXG5cdFx0XHRcdGxhc3QgPSBEYXRlLm5vdygpXG5cdFx0XHR9LCB0aW1lIC0gKG5vdyAtIGxhc3QpKVxuXHRcdH1cblx0fVxufVxudmFyIF8xMSA9IGZ1bmN0aW9uKCR3aW5kb3cpIHtcblx0dmFyIHJlbmRlclNlcnZpY2UgPSBjb3JlUmVuZGVyZXIoJHdpbmRvdylcblx0cmVuZGVyU2VydmljZS5zZXRFdmVudENhbGxiYWNrKGZ1bmN0aW9uKGUpIHtcblx0XHRpZiAoZS5yZWRyYXcgPT09IGZhbHNlKSBlLnJlZHJhdyA9IHVuZGVmaW5lZFxuXHRcdGVsc2UgcmVkcmF3KClcblx0fSlcblx0dmFyIGNhbGxiYWNrcyA9IFtdXG5cdGZ1bmN0aW9uIHN1YnNjcmliZShrZXkxLCBjYWxsYmFjaykge1xuXHRcdHVuc3Vic2NyaWJlKGtleTEpXG5cdFx0Y2FsbGJhY2tzLnB1c2goa2V5MSwgdGhyb3R0bGUoY2FsbGJhY2spKVxuXHR9XG5cdGZ1bmN0aW9uIHVuc3Vic2NyaWJlKGtleTEpIHtcblx0XHR2YXIgaW5kZXggPSBjYWxsYmFja3MuaW5kZXhPZihrZXkxKVxuXHRcdGlmIChpbmRleCA+IC0xKSBjYWxsYmFja3Muc3BsaWNlKGluZGV4LCAyKVxuXHR9XG5cdGZ1bmN0aW9uIHJlZHJhdygpIHtcblx0XHRmb3IgKHZhciBpID0gMTsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkgKz0gMikge1xuXHRcdFx0Y2FsbGJhY2tzW2ldKClcblx0XHR9XG5cdH1cblx0cmV0dXJuIHtzdWJzY3JpYmU6IHN1YnNjcmliZSwgdW5zdWJzY3JpYmU6IHVuc3Vic2NyaWJlLCByZWRyYXc6IHJlZHJhdywgcmVuZGVyOiByZW5kZXJTZXJ2aWNlLnJlbmRlcn1cbn1cbnZhciByZWRyYXdTZXJ2aWNlID0gXzExKHdpbmRvdylcbnJlcXVlc3RTZXJ2aWNlLnNldENvbXBsZXRpb25DYWxsYmFjayhyZWRyYXdTZXJ2aWNlLnJlZHJhdylcbnZhciBfMTYgPSBmdW5jdGlvbihyZWRyYXdTZXJ2aWNlMCkge1xuXHRyZXR1cm4gZnVuY3Rpb24ocm9vdCwgY29tcG9uZW50KSB7XG5cdFx0aWYgKGNvbXBvbmVudCA9PT0gbnVsbCkge1xuXHRcdFx0cmVkcmF3U2VydmljZTAucmVuZGVyKHJvb3QsIFtdKVxuXHRcdFx0cmVkcmF3U2VydmljZTAudW5zdWJzY3JpYmUocm9vdClcblx0XHRcdHJldHVyblxuXHRcdH1cblx0XHRcblx0XHRpZiAoY29tcG9uZW50LnZpZXcgPT0gbnVsbCAmJiB0eXBlb2YgY29tcG9uZW50ICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcihcIm0ubW91bnQoZWxlbWVudCwgY29tcG9uZW50KSBleHBlY3RzIGEgY29tcG9uZW50LCBub3QgYSB2bm9kZVwiKVxuXHRcdFxuXHRcdHZhciBydW4wID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZWRyYXdTZXJ2aWNlMC5yZW5kZXIocm9vdCwgVm5vZGUoY29tcG9uZW50KSlcblx0XHR9XG5cdFx0cmVkcmF3U2VydmljZTAuc3Vic2NyaWJlKHJvb3QsIHJ1bjApXG5cdFx0cmVkcmF3U2VydmljZTAucmVkcmF3KClcblx0fVxufVxubS5tb3VudCA9IF8xNihyZWRyYXdTZXJ2aWNlKVxudmFyIFByb21pc2UgPSBQcm9taXNlUG9seWZpbGxcbnZhciBwYXJzZVF1ZXJ5U3RyaW5nID0gZnVuY3Rpb24oc3RyaW5nKSB7XG5cdGlmIChzdHJpbmcgPT09IFwiXCIgfHwgc3RyaW5nID09IG51bGwpIHJldHVybiB7fVxuXHRpZiAoc3RyaW5nLmNoYXJBdCgwKSA9PT0gXCI/XCIpIHN0cmluZyA9IHN0cmluZy5zbGljZSgxKVxuXHR2YXIgZW50cmllcyA9IHN0cmluZy5zcGxpdChcIiZcIiksIGRhdGEwID0ge30sIGNvdW50ZXJzID0ge31cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGVudHJ5ID0gZW50cmllc1tpXS5zcGxpdChcIj1cIilcblx0XHR2YXIga2V5NSA9IGRlY29kZVVSSUNvbXBvbmVudChlbnRyeVswXSlcblx0XHR2YXIgdmFsdWUgPSBlbnRyeS5sZW5ndGggPT09IDIgPyBkZWNvZGVVUklDb21wb25lbnQoZW50cnlbMV0pIDogXCJcIlxuXHRcdGlmICh2YWx1ZSA9PT0gXCJ0cnVlXCIpIHZhbHVlID0gdHJ1ZVxuXHRcdGVsc2UgaWYgKHZhbHVlID09PSBcImZhbHNlXCIpIHZhbHVlID0gZmFsc2Vcblx0XHR2YXIgbGV2ZWxzID0ga2V5NS5zcGxpdCgvXFxdXFxbP3xcXFsvKVxuXHRcdHZhciBjdXJzb3IgPSBkYXRhMFxuXHRcdGlmIChrZXk1LmluZGV4T2YoXCJbXCIpID4gLTEpIGxldmVscy5wb3AoKVxuXHRcdGZvciAodmFyIGogPSAwOyBqIDwgbGV2ZWxzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHR2YXIgbGV2ZWwgPSBsZXZlbHNbal0sIG5leHRMZXZlbCA9IGxldmVsc1tqICsgMV1cblx0XHRcdHZhciBpc051bWJlciA9IG5leHRMZXZlbCA9PSBcIlwiIHx8ICFpc05hTihwYXJzZUludChuZXh0TGV2ZWwsIDEwKSlcblx0XHRcdHZhciBpc1ZhbHVlID0gaiA9PT0gbGV2ZWxzLmxlbmd0aCAtIDFcblx0XHRcdGlmIChsZXZlbCA9PT0gXCJcIikge1xuXHRcdFx0XHR2YXIga2V5NSA9IGxldmVscy5zbGljZSgwLCBqKS5qb2luKClcblx0XHRcdFx0aWYgKGNvdW50ZXJzW2tleTVdID09IG51bGwpIGNvdW50ZXJzW2tleTVdID0gMFxuXHRcdFx0XHRsZXZlbCA9IGNvdW50ZXJzW2tleTVdKytcblx0XHRcdH1cblx0XHRcdGlmIChjdXJzb3JbbGV2ZWxdID09IG51bGwpIHtcblx0XHRcdFx0Y3Vyc29yW2xldmVsXSA9IGlzVmFsdWUgPyB2YWx1ZSA6IGlzTnVtYmVyID8gW10gOiB7fVxuXHRcdFx0fVxuXHRcdFx0Y3Vyc29yID0gY3Vyc29yW2xldmVsXVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gZGF0YTBcbn1cbnZhciBjb3JlUm91dGVyID0gZnVuY3Rpb24oJHdpbmRvdykge1xuXHR2YXIgc3VwcG9ydHNQdXNoU3RhdGUgPSB0eXBlb2YgJHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSA9PT0gXCJmdW5jdGlvblwiXG5cdHZhciBjYWxsQXN5bmMwID0gdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiID8gc2V0SW1tZWRpYXRlIDogc2V0VGltZW91dFxuXHRmdW5jdGlvbiBub3JtYWxpemUxKGZyYWdtZW50MCkge1xuXHRcdHZhciBkYXRhID0gJHdpbmRvdy5sb2NhdGlvbltmcmFnbWVudDBdLnJlcGxhY2UoLyg/OiVbYS1mODldW2EtZjAtOV0pKy9naW0sIGRlY29kZVVSSUNvbXBvbmVudClcblx0XHRpZiAoZnJhZ21lbnQwID09PSBcInBhdGhuYW1lXCIgJiYgZGF0YVswXSAhPT0gXCIvXCIpIGRhdGEgPSBcIi9cIiArIGRhdGFcblx0XHRyZXR1cm4gZGF0YVxuXHR9XG5cdHZhciBhc3luY0lkXG5cdGZ1bmN0aW9uIGRlYm91bmNlQXN5bmMoY2FsbGJhY2swKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKGFzeW5jSWQgIT0gbnVsbCkgcmV0dXJuXG5cdFx0XHRhc3luY0lkID0gY2FsbEFzeW5jMChmdW5jdGlvbigpIHtcblx0XHRcdFx0YXN5bmNJZCA9IG51bGxcblx0XHRcdFx0Y2FsbGJhY2swKClcblx0XHRcdH0pXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHBhcnNlUGF0aChwYXRoLCBxdWVyeURhdGEsIGhhc2hEYXRhKSB7XG5cdFx0dmFyIHF1ZXJ5SW5kZXggPSBwYXRoLmluZGV4T2YoXCI/XCIpXG5cdFx0dmFyIGhhc2hJbmRleCA9IHBhdGguaW5kZXhPZihcIiNcIilcblx0XHR2YXIgcGF0aEVuZCA9IHF1ZXJ5SW5kZXggPiAtMSA/IHF1ZXJ5SW5kZXggOiBoYXNoSW5kZXggPiAtMSA/IGhhc2hJbmRleCA6IHBhdGgubGVuZ3RoXG5cdFx0aWYgKHF1ZXJ5SW5kZXggPiAtMSkge1xuXHRcdFx0dmFyIHF1ZXJ5RW5kID0gaGFzaEluZGV4ID4gLTEgPyBoYXNoSW5kZXggOiBwYXRoLmxlbmd0aFxuXHRcdFx0dmFyIHF1ZXJ5UGFyYW1zID0gcGFyc2VRdWVyeVN0cmluZyhwYXRoLnNsaWNlKHF1ZXJ5SW5kZXggKyAxLCBxdWVyeUVuZCkpXG5cdFx0XHRmb3IgKHZhciBrZXk0IGluIHF1ZXJ5UGFyYW1zKSBxdWVyeURhdGFba2V5NF0gPSBxdWVyeVBhcmFtc1trZXk0XVxuXHRcdH1cblx0XHRpZiAoaGFzaEluZGV4ID4gLTEpIHtcblx0XHRcdHZhciBoYXNoUGFyYW1zID0gcGFyc2VRdWVyeVN0cmluZyhwYXRoLnNsaWNlKGhhc2hJbmRleCArIDEpKVxuXHRcdFx0Zm9yICh2YXIga2V5NCBpbiBoYXNoUGFyYW1zKSBoYXNoRGF0YVtrZXk0XSA9IGhhc2hQYXJhbXNba2V5NF1cblx0XHR9XG5cdFx0cmV0dXJuIHBhdGguc2xpY2UoMCwgcGF0aEVuZClcblx0fVxuXHR2YXIgcm91dGVyID0ge3ByZWZpeDogXCIjIVwifVxuXHRyb3V0ZXIuZ2V0UGF0aCA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0eXBlMiA9IHJvdXRlci5wcmVmaXguY2hhckF0KDApXG5cdFx0c3dpdGNoICh0eXBlMikge1xuXHRcdFx0Y2FzZSBcIiNcIjogcmV0dXJuIG5vcm1hbGl6ZTEoXCJoYXNoXCIpLnNsaWNlKHJvdXRlci5wcmVmaXgubGVuZ3RoKVxuXHRcdFx0Y2FzZSBcIj9cIjogcmV0dXJuIG5vcm1hbGl6ZTEoXCJzZWFyY2hcIikuc2xpY2Uocm91dGVyLnByZWZpeC5sZW5ndGgpICsgbm9ybWFsaXplMShcImhhc2hcIilcblx0XHRcdGRlZmF1bHQ6IHJldHVybiBub3JtYWxpemUxKFwicGF0aG5hbWVcIikuc2xpY2Uocm91dGVyLnByZWZpeC5sZW5ndGgpICsgbm9ybWFsaXplMShcInNlYXJjaFwiKSArIG5vcm1hbGl6ZTEoXCJoYXNoXCIpXG5cdFx0fVxuXHR9XG5cdHJvdXRlci5zZXRQYXRoID0gZnVuY3Rpb24ocGF0aCwgZGF0YSwgb3B0aW9ucykge1xuXHRcdHZhciBxdWVyeURhdGEgPSB7fSwgaGFzaERhdGEgPSB7fVxuXHRcdHBhdGggPSBwYXJzZVBhdGgocGF0aCwgcXVlcnlEYXRhLCBoYXNoRGF0YSlcblx0XHRpZiAoZGF0YSAhPSBudWxsKSB7XG5cdFx0XHRmb3IgKHZhciBrZXk0IGluIGRhdGEpIHF1ZXJ5RGF0YVtrZXk0XSA9IGRhdGFba2V5NF1cblx0XHRcdHBhdGggPSBwYXRoLnJlcGxhY2UoLzooW15cXC9dKykvZywgZnVuY3Rpb24obWF0Y2gyLCB0b2tlbikge1xuXHRcdFx0XHRkZWxldGUgcXVlcnlEYXRhW3Rva2VuXVxuXHRcdFx0XHRyZXR1cm4gZGF0YVt0b2tlbl1cblx0XHRcdH0pXG5cdFx0fVxuXHRcdHZhciBxdWVyeSA9IGJ1aWxkUXVlcnlTdHJpbmcocXVlcnlEYXRhKVxuXHRcdGlmIChxdWVyeSkgcGF0aCArPSBcIj9cIiArIHF1ZXJ5XG5cdFx0dmFyIGhhc2ggPSBidWlsZFF1ZXJ5U3RyaW5nKGhhc2hEYXRhKVxuXHRcdGlmIChoYXNoKSBwYXRoICs9IFwiI1wiICsgaGFzaFxuXHRcdGlmIChzdXBwb3J0c1B1c2hTdGF0ZSkge1xuXHRcdFx0dmFyIHN0YXRlID0gb3B0aW9ucyA/IG9wdGlvbnMuc3RhdGUgOiBudWxsXG5cdFx0XHR2YXIgdGl0bGUgPSBvcHRpb25zID8gb3B0aW9ucy50aXRsZSA6IG51bGxcblx0XHRcdCR3aW5kb3cub25wb3BzdGF0ZSgpXG5cdFx0XHRpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlcGxhY2UpICR3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoc3RhdGUsIHRpdGxlLCByb3V0ZXIucHJlZml4ICsgcGF0aClcblx0XHRcdGVsc2UgJHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZShzdGF0ZSwgdGl0bGUsIHJvdXRlci5wcmVmaXggKyBwYXRoKVxuXHRcdH1cblx0XHRlbHNlICR3aW5kb3cubG9jYXRpb24uaHJlZiA9IHJvdXRlci5wcmVmaXggKyBwYXRoXG5cdH1cblx0cm91dGVyLmRlZmluZVJvdXRlcyA9IGZ1bmN0aW9uKHJvdXRlcywgcmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0ZnVuY3Rpb24gcmVzb2x2ZVJvdXRlKCkge1xuXHRcdFx0dmFyIHBhdGggPSByb3V0ZXIuZ2V0UGF0aCgpXG5cdFx0XHR2YXIgcGFyYW1zID0ge31cblx0XHRcdHZhciBwYXRobmFtZSA9IHBhcnNlUGF0aChwYXRoLCBwYXJhbXMsIHBhcmFtcylcblx0XHRcdHZhciBzdGF0ZSA9ICR3aW5kb3cuaGlzdG9yeS5zdGF0ZVxuXHRcdFx0aWYgKHN0YXRlICE9IG51bGwpIHtcblx0XHRcdFx0Zm9yICh2YXIgayBpbiBzdGF0ZSkgcGFyYW1zW2tdID0gc3RhdGVba11cblx0XHRcdH1cblx0XHRcdGZvciAodmFyIHJvdXRlMCBpbiByb3V0ZXMpIHtcblx0XHRcdFx0dmFyIG1hdGNoZXIgPSBuZXcgUmVnRXhwKFwiXlwiICsgcm91dGUwLnJlcGxhY2UoLzpbXlxcL10rP1xcLnszfS9nLCBcIiguKj8pXCIpLnJlcGxhY2UoLzpbXlxcL10rL2csIFwiKFteXFxcXC9dKylcIikgKyBcIlxcLz8kXCIpXG5cdFx0XHRcdGlmIChtYXRjaGVyLnRlc3QocGF0aG5hbWUpKSB7XG5cdFx0XHRcdFx0cGF0aG5hbWUucmVwbGFjZShtYXRjaGVyLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHZhciBrZXlzID0gcm91dGUwLm1hdGNoKC86W15cXC9dKy9nKSB8fCBbXVxuXHRcdFx0XHRcdFx0dmFyIHZhbHVlcyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxLCAtMilcblx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRwYXJhbXNba2V5c1tpXS5yZXBsYWNlKC86fFxcLi9nLCBcIlwiKV0gPSBkZWNvZGVVUklDb21wb25lbnQodmFsdWVzW2ldKVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmVzb2x2ZShyb3V0ZXNbcm91dGUwXSwgcGFyYW1zLCBwYXRoLCByb3V0ZTApXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmVqZWN0KHBhdGgsIHBhcmFtcylcblx0XHR9XG5cdFx0aWYgKHN1cHBvcnRzUHVzaFN0YXRlKSAkd2luZG93Lm9ucG9wc3RhdGUgPSBkZWJvdW5jZUFzeW5jKHJlc29sdmVSb3V0ZSlcblx0XHRlbHNlIGlmIChyb3V0ZXIucHJlZml4LmNoYXJBdCgwKSA9PT0gXCIjXCIpICR3aW5kb3cub25oYXNoY2hhbmdlID0gcmVzb2x2ZVJvdXRlXG5cdFx0cmVzb2x2ZVJvdXRlKClcblx0fVxuXHRyZXR1cm4gcm91dGVyXG59XG52YXIgXzIwID0gZnVuY3Rpb24oJHdpbmRvdywgcmVkcmF3U2VydmljZTApIHtcblx0dmFyIHJvdXRlU2VydmljZSA9IGNvcmVSb3V0ZXIoJHdpbmRvdylcblx0dmFyIGlkZW50aXR5ID0gZnVuY3Rpb24odikge3JldHVybiB2fVxuXHR2YXIgcmVuZGVyMSwgY29tcG9uZW50LCBhdHRyczMsIGN1cnJlbnRQYXRoLCBsYXN0VXBkYXRlXG5cdHZhciByb3V0ZSA9IGZ1bmN0aW9uKHJvb3QsIGRlZmF1bHRSb3V0ZSwgcm91dGVzKSB7XG5cdFx0aWYgKHJvb3QgPT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKFwiRW5zdXJlIHRoZSBET00gZWxlbWVudCB0aGF0IHdhcyBwYXNzZWQgdG8gYG0ucm91dGVgIGlzIG5vdCB1bmRlZmluZWRcIilcblx0XHR2YXIgcnVuMSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKHJlbmRlcjEgIT0gbnVsbCkgcmVkcmF3U2VydmljZTAucmVuZGVyKHJvb3QsIHJlbmRlcjEoVm5vZGUoY29tcG9uZW50LCBhdHRyczMua2V5LCBhdHRyczMpKSlcblx0XHR9XG5cdFx0dmFyIGJhaWwgPSBmdW5jdGlvbihwYXRoKSB7XG5cdFx0XHRpZiAocGF0aCAhPT0gZGVmYXVsdFJvdXRlKSByb3V0ZVNlcnZpY2Uuc2V0UGF0aChkZWZhdWx0Um91dGUsIG51bGwsIHtyZXBsYWNlOiB0cnVlfSlcblx0XHRcdGVsc2UgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IHJlc29sdmUgZGVmYXVsdCByb3V0ZSBcIiArIGRlZmF1bHRSb3V0ZSlcblx0XHR9XG5cdFx0cm91dGVTZXJ2aWNlLmRlZmluZVJvdXRlcyhyb3V0ZXMsIGZ1bmN0aW9uKHBheWxvYWQsIHBhcmFtcywgcGF0aCkge1xuXHRcdFx0dmFyIHVwZGF0ZSA9IGxhc3RVcGRhdGUgPSBmdW5jdGlvbihyb3V0ZVJlc29sdmVyLCBjb21wKSB7XG5cdFx0XHRcdGlmICh1cGRhdGUgIT09IGxhc3RVcGRhdGUpIHJldHVyblxuXHRcdFx0XHRjb21wb25lbnQgPSBjb21wICE9IG51bGwgJiYgKHR5cGVvZiBjb21wLnZpZXcgPT09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgY29tcCA9PT0gXCJmdW5jdGlvblwiKT8gY29tcCA6IFwiZGl2XCJcblx0XHRcdFx0YXR0cnMzID0gcGFyYW1zLCBjdXJyZW50UGF0aCA9IHBhdGgsIGxhc3RVcGRhdGUgPSBudWxsXG5cdFx0XHRcdHJlbmRlcjEgPSAocm91dGVSZXNvbHZlci5yZW5kZXIgfHwgaWRlbnRpdHkpLmJpbmQocm91dGVSZXNvbHZlcilcblx0XHRcdFx0cnVuMSgpXG5cdFx0XHR9XG5cdFx0XHRpZiAocGF5bG9hZC52aWV3IHx8IHR5cGVvZiBwYXlsb2FkID09PSBcImZ1bmN0aW9uXCIpIHVwZGF0ZSh7fSwgcGF5bG9hZClcblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRpZiAocGF5bG9hZC5vbm1hdGNoKSB7XG5cdFx0XHRcdFx0UHJvbWlzZS5yZXNvbHZlKHBheWxvYWQub25tYXRjaChwYXJhbXMsIHBhdGgpKS50aGVuKGZ1bmN0aW9uKHJlc29sdmVkKSB7XG5cdFx0XHRcdFx0XHR1cGRhdGUocGF5bG9hZCwgcmVzb2x2ZWQpXG5cdFx0XHRcdFx0fSwgYmFpbClcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHVwZGF0ZShwYXlsb2FkLCBcImRpdlwiKVxuXHRcdFx0fVxuXHRcdH0sIGJhaWwpXG5cdFx0cmVkcmF3U2VydmljZTAuc3Vic2NyaWJlKHJvb3QsIHJ1bjEpXG5cdH1cblx0cm91dGUuc2V0ID0gZnVuY3Rpb24ocGF0aCwgZGF0YSwgb3B0aW9ucykge1xuXHRcdGlmIChsYXN0VXBkYXRlICE9IG51bGwpIHtcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cdFx0XHRvcHRpb25zLnJlcGxhY2UgPSB0cnVlXG5cdFx0fVxuXHRcdGxhc3RVcGRhdGUgPSBudWxsXG5cdFx0cm91dGVTZXJ2aWNlLnNldFBhdGgocGF0aCwgZGF0YSwgb3B0aW9ucylcblx0fVxuXHRyb3V0ZS5nZXQgPSBmdW5jdGlvbigpIHtyZXR1cm4gY3VycmVudFBhdGh9XG5cdHJvdXRlLnByZWZpeCA9IGZ1bmN0aW9uKHByZWZpeDApIHtyb3V0ZVNlcnZpY2UucHJlZml4ID0gcHJlZml4MH1cblx0cm91dGUubGluayA9IGZ1bmN0aW9uKHZub2RlMSkge1xuXHRcdHZub2RlMS5kb20uc2V0QXR0cmlidXRlKFwiaHJlZlwiLCByb3V0ZVNlcnZpY2UucHJlZml4ICsgdm5vZGUxLmF0dHJzLmhyZWYpXG5cdFx0dm5vZGUxLmRvbS5vbmNsaWNrID0gZnVuY3Rpb24oZSkge1xuXHRcdFx0aWYgKGUuY3RybEtleSB8fCBlLm1ldGFLZXkgfHwgZS5zaGlmdEtleSB8fCBlLndoaWNoID09PSAyKSByZXR1cm5cblx0XHRcdGUucHJldmVudERlZmF1bHQoKVxuXHRcdFx0ZS5yZWRyYXcgPSBmYWxzZVxuXHRcdFx0dmFyIGhyZWYgPSB0aGlzLmdldEF0dHJpYnV0ZShcImhyZWZcIilcblx0XHRcdGlmIChocmVmLmluZGV4T2Yocm91dGVTZXJ2aWNlLnByZWZpeCkgPT09IDApIGhyZWYgPSBocmVmLnNsaWNlKHJvdXRlU2VydmljZS5wcmVmaXgubGVuZ3RoKVxuXHRcdFx0cm91dGUuc2V0KGhyZWYsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKVxuXHRcdH1cblx0fVxuXHRyb3V0ZS5wYXJhbSA9IGZ1bmN0aW9uKGtleTMpIHtcblx0XHRpZih0eXBlb2YgYXR0cnMzICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBrZXkzICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gYXR0cnMzW2tleTNdXG5cdFx0cmV0dXJuIGF0dHJzM1xuXHR9XG5cdHJldHVybiByb3V0ZVxufVxubS5yb3V0ZSA9IF8yMCh3aW5kb3csIHJlZHJhd1NlcnZpY2UpXG5tLndpdGhBdHRyID0gZnVuY3Rpb24oYXR0ck5hbWUsIGNhbGxiYWNrMSwgY29udGV4dCkge1xuXHRyZXR1cm4gZnVuY3Rpb24oZSkge1xuXHRcdGNhbGxiYWNrMS5jYWxsKGNvbnRleHQgfHwgdGhpcywgYXR0ck5hbWUgaW4gZS5jdXJyZW50VGFyZ2V0ID8gZS5jdXJyZW50VGFyZ2V0W2F0dHJOYW1lXSA6IGUuY3VycmVudFRhcmdldC5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpKVxuXHR9XG59XG52YXIgXzI4ID0gY29yZVJlbmRlcmVyKHdpbmRvdylcbm0ucmVuZGVyID0gXzI4LnJlbmRlclxubS5yZWRyYXcgPSByZWRyYXdTZXJ2aWNlLnJlZHJhd1xubS5yZXF1ZXN0ID0gcmVxdWVzdFNlcnZpY2UucmVxdWVzdFxubS5qc29ucCA9IHJlcXVlc3RTZXJ2aWNlLmpzb25wXG5tLnBhcnNlUXVlcnlTdHJpbmcgPSBwYXJzZVF1ZXJ5U3RyaW5nXG5tLmJ1aWxkUXVlcnlTdHJpbmcgPSBidWlsZFF1ZXJ5U3RyaW5nXG5tLnZlcnNpb24gPSBcIjEuMS4zXCJcbm0udm5vZGUgPSBWbm9kZVxuaWYgKHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIpIG1vZHVsZVtcImV4cG9ydHNcIl0gPSBtXG5lbHNlIHdpbmRvdy5tID0gbVxufSgpKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbWl0aHJpbC9taXRocmlsLmpzXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n')},function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\nexports.fakeClick = exports.hexToRgba = exports.popoverContent = exports.summary = exports.legend = exports.ta2stuff = exports.spliceLinksForNode = exports.findNode = exports.findNodeIndex = exports.clickVar = exports.reset = exports.nodes = exports.allNodes = exports.valueKey = exports.zparams = exports.logArray = exports.righttab = exports.summaryHold = exports.subset = exports.lefttab = exports.timeColor = exports.varColor = exports.nomColor = exports.gr2Color = exports.gr1Color = exports.dvColor = exports.csColor = exports.cdb = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();\n\nvar _arguments = arguments;\nexports.main = main;\nexports.getVariableData = getVariableData;\nexports.forceSwitch = forceSwitch;\nexports.helpmaterials = helpmaterials;\nexports.lockDescription = lockDescription;\nexports.estimate = estimate;\nexports.runPreprocess = runPreprocess;\nexports.erase = erase;\nexports.tabLeft = tabLeft;\nexports.tabRight = tabRight;\nexports.panelPlots = panelPlots;\nexports.borderState = borderState;\nexports.subsetSelect = subsetSelect;\nexports.endsession = endsession;\nexports.listpipelines = listpipelines;\nexports.executepipeline = executepipeline;\nexports.expandrightpanel = expandrightpanel;\nexports.resultsplotinit = resultsplotinit;\nexports.genconfdata = genconfdata;\nexports.confusionmatrix = confusionmatrix;\nexports.bivariatePlot = bivariatePlot;\nexports.setxTable = setxTable;\nexports.exportpipeline = exportpipeline;\nexports.deletepipeline = deletepipeline;\n\nvar _mithril = __webpack_require__(0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _plots = __webpack_require__(2);\n\n__webpack_require__(13);\n\n__webpack_require__(3);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n//import \'../pkgs/hopscotch/dist/js/my_hopscotch_tour.js\';\n\n// hostname default - the app will use it to obtain the variable metadata\n// (ddi) and pre-processed data info if the file id is supplied as an\n// argument (for ex., gui.html?dfId=17), but hostname isn\'t.\n// Edit it to suit your installation.\n// (NOTE that if the file id isn\'t supplied, the app will default to the\n// local files specified below!)\n// NEW: it is also possible now to supply complete urls for the ddi and\n// the tab-delimited data file; the parameters are ddiurl and dataurl.\n// These new parameters are optional. If they are not supplied, the app\n// will go the old route - will try to cook standard dataverse urls\n// for both the data and metadata, if the file id is supplied; or the\n// local files if nothing is supplied.\n\n\n//-------------------------------------------------\n// NOTE: global variables are now set in the index.html file.\n//    Developers, see /template/index.html\n//-------------------------------------------------\n\n// for debugging - if not in production, prints args and returns them\nvar cdb = exports.cdb = function cdb(_) {\n    return production || console.log.apply(undefined, _arguments) && _arguments;\n};\n\nvar k = 4; // strength parameter for group attraction/repulsion\nvar tutorial_mode = true;\nvar first_load = true;\n\n// initial color scale used to establish the initial colors of nodes\n// allNodes.push() below establishes a field for the master node array allNodes called "nodeCol" and assigns a color from this scale to that field\n// everything there after should refer to the nodeCol and not the color scale, this enables us to update colors and pass the variable type to R based on its coloring\nvar colors = d3.scale.category20();\nvar csColor = exports.csColor = \'#419641\';\nvar dvColor = exports.dvColor = \'#28a4c9\';\nvar gr1Color = exports.gr1Color = \'#14bdcc\'; // initially was #24a4c9\', but that is dvColor, and we track some properties by color assuming them unique\nvar gr1Opacity = [0, 1];\nvar gr2Color = exports.gr2Color = \'#ffcccc\';\nvar gr2Opacity = [0, 1];\n\nvar grayColor = \'#c0c0c0\';\nvar nomColor = exports.nomColor = \'#ff6600\';\nvar varColor = exports.varColor = \'#f0f8ff\'; // d3.rgb("aliceblue");\nvar taggedColor = \'#f5f5f5\'; // d3.rgb("whitesmoke");\nvar timeColor = exports.timeColor = \'#2d6ca2\';\n\nvar lefttab = exports.lefttab = \'tab1\'; // current tab in left panel\nvar subset = exports.subset = false;\nvar summaryHold = exports.summaryHold = false;\nvar righttab = exports.righttab = \'btnModels\'; // current tab in right panel\n\n// transformation toolbar options\nvar t = void 0,\n    typeTransform = void 0;\nvar transformList = \'log(d) exp(d) d^2 sqrt(d) interact(d,e)\'.split(\' \');\nvar transformVar = \'\';\n\n// var list for each space contain variables in original data\n// plus trans in that space\nvar trans = [];\nvar preprocess = {}; // hold pre-processed data\nvar spaces = [];\n\n// layout function constants\nvar layoutAdd = "add";\nvar layoutMove = "move";\n\n// Radius of circle\nvar allR = 40;\nvar ind1 = [(allR + 30) * Math.cos(1.3), -1 * (allR + 30) * Math.sin(1.3), 5]; // cx, cy, r  values for indicator lights\nvar ind2 = [(allR + 30) * Math.cos(1.1), -1 * (allR + 30) * Math.sin(1.1), 5]; // cx, cy, r  values for indicator lights\n\n\n// space index\nvar myspace = 0;\n\nvar forcetoggle = ["true"];\nvar locktoggle = true;\nvar priv = true;\n\n// swandive is our graceful fail for d3m\n// swandive set to true if task is in failset\nvar swandive = false;\nvar failset = ["TIMESERIESFORECASTING", "GRAPHMATCHING", "LINKPREDICTION", "timeSeriesForecasting", "graphMatching", "linkPrediction"];\n\nvar logArray = exports.logArray = [];\nvar zparams = exports.zparams = {\n    zdata: [],\n    zedges: [],\n    ztime: [],\n    znom: [],\n    zcross: [],\n    zmodel: "",\n    zvars: [],\n    zdv: [],\n    zgroup1: [],\n    zgroup2: [], // hard coding to two groups for present experiments, but will eventually make zgroup array of arrays, with zgroup.lenght the number of groups\n    zdataurl: "",\n    zd3mdata: "", //these take the place of zdataurl for d3m, because data is in two placees. eventually will generalize\n    zd3mtarget: "",\n    zsubset: [],\n    zsetx: [],\n    zmodelcount: 0,\n    zplot: [],\n    zsessionid: "",\n    zdatacite: ""\n};\n\nvar modelCount = 0;\nvar valueKey = exports.valueKey = [];\nvar allNodes = exports.allNodes = [];\nvar allResults = [];\nvar nodes = exports.nodes = [];\nvar links = [];\nvar mods = {};\nvar estimated = false;\nvar rightClickLast = false;\nvar selInteract = false;\nvar callHistory = []; // transform and subset calls\nvar mytarget = "";\n\nvar configurations = {};\nvar dataschema = {};\n\n//eventually read this from the schema with real descriptions\n// metrics, tasks, and subtasks as specified in D3M schemas\n// MEAN SQUARED ERROR IS SET TO SAME AS RMSE. MSE is in schema but not proto\nvar d3mMetrics = { metricUndefined: ["description", "METRIC_UNDEFINED", 0],\n    accuracy: ["description", "ACCURACY", 1],\n    f1: ["description", "F1", 2],\n    f1Micro: ["description", "F1_MICRO", 3],\n    f1Macro: ["description", "F1_MACRO", 4],\n    rocAuc: ["description", "ROC_AUC", 5],\n    rocAucMicro: ["description", "ROC_AUC_MICRO", 6],\n    rocAucMacro: ["description", "ROC_AUC_MACRO", 7],\n    meanSquaredError: ["description", "ROOT_MEAN_SQUARED_ERROR", 8],\n    rootMeanSquaredError: ["description", "ROOT_MEAN_SQUARED_ERROR", 8],\n    rootMeanSquaredErrorAvg: ["description", "ROOT_MEAN_SQUARED_ERROR_AVG", 9],\n    meanAbsoluteError: ["description", "MEAN_ABSOLUTE_ERROR", 10],\n    rSquared: ["description", "R_SQUARED", 11],\n    normalizedMutualInformation: ["description", "NORMALIZED_MUTUAL_INFORMATION", 12],\n    jaccardSimilarityScore: ["description", "JACCARD_SIMILARITY_SCORE", 13],\n    executionTime: ["description", "EXECUTION_TIME", 14] };\n\nvar d3mTaskType = { taskTypeUndefined: ["description", "TASK_TYPE_UNDEFINED", 0], classification: ["description", "CLASSIFICATION", 1],\n    regression: ["description", "REGRESSION", 2],\n    similarityMatching: ["description", "SIMILARITY_MATCHING", 3],\n    linkPrediction: ["description", "LINK_PREDICTION", 4],\n    vertexNomination: ["description", "VERTEX_NOMINATION", 5],\n    communityDetection: ["description", "COMMUNITY_DETECTION", 6],\n    graphMatching: ["description", "GRAPH_MATCHING", 7],\n    timeseriesForecasting: ["description", "TIMESERIES_FORECASTING", 8],\n    collaborativeFiltering: ["description", "COLLABORATIVE_FILTERING", 9] };\n\nvar d3mTaskSubtype = { taskSubtypeUndefined: ["description", "TASK_SUBTYPE_UNDEFINED", 0],\n    subtypeNone: ["description", "NONE", 1],\n    binary: ["description", "BINARY", 2],\n    multiClass: ["description", "MULTICLASS", 3],\n    multiLabel: ["description", "MULTILABEL", 4],\n    uniVariate: ["description", "UNIVARIATE", 5],\n    multiVariate: ["description", "MULTIVARIATE", 6],\n    overlapping: ["description", "OVERLAPPING", 7],\n    nonOverlapping: ["description", "NONOVERLAPPING", 8] };\n\nvar d3mOutputType = { outputUndefined: ["description", "OUTPUT_TYPE_UNDEFINED ", 0],\n    classLabel: ["description", "CLASS_LABEL", 1],\n    probability: ["description", "PROBABILITY", 2],\n    real: ["description", "REAL", 3],\n    nodeID: ["description", "NODE_ID", 4],\n    vectorClassLabel: ["description", "VECTOR_CLASS_LABEL", 5],\n    vectorStochastic: ["description", "VECTOR_STOCHASTIC", 6],\n    vectorReal: ["description", "VECTOR_REAL", 7],\n    file: ["description", "FILE", 8] };\n\nvar d3mProblemDescription = {\n    taskType: [2, "DEFAULT"],\n    taskSubtype: [1, "DEFAFULT"],\n    outputType: [3, "DEFAULT"],\n    metric: [4, "DEFAULT"],\n    taskDescription: "" };\n\nvar svg = void 0,\n    width = void 0,\n    height = void 0,\n    div = void 0,\n    estimateLadda = void 0,\n    selectLadda = void 0;\nvar arc1 = void 0,\n    arc3 = void 0,\n    arc4 = void 0,\n    arcInd1 = void 0,\n    arcInd2 = void 0;\n\nvar arcInd1Limits = [0, 0.3];\nvar arcInd2Limits = [0.35, 0.65];\n\nvar byId = function byId(id) {\n    return document.getElementById(id);\n};\n\n// page reload linked to btnReset\nvar reset = exports.reset = function reloadPage() {\n    location.reload();\n};\n\nvar dataurl = "";\nfunction main(fileid, hostname, ddiurl, dataurl, apikey) {\n    dataurl = dataurl;\n    if (production && fileid == "") {\n        alert("Error: No fileid has been provided.");\n        throw new Error("Error: No fileid has been provided.");\n    }\n\n    var dataverseurl = hostname ? "https://" + hostname : production ? DATAVERSE_URL : "http://localhost:8080";\n\n    if (fileid && !dataurl) {\n        // file id supplied; assume we are dealing with dataverse and cook a standard dataverse data access url\n        // with the fileid supplied and the hostname we have supplied or configured\n        dataurl = dataverseurl + "/api/access/datafile/" + fileid;\n        // rp; temporarily remove this\n        dataurl = dataurl + "?key=" + apikey;\n    }\n    cdb(\'--dataurl: \' + dataurl);\n    cdb(\'--dataverseurl: \' + dataverseurl);\n    svg = d3.select("#whitespace");\n\n    var tempWidth = d3.select("#main.left").style("width");\n    width = tempWidth.substring(0, tempWidth.length - 2);\n    height = $(window).height() - 120; // Hard coding for header and footer and bottom margin.\n\n    estimateLadda = Ladda.create(byId("btnEstimate"));\n    selectLadda = Ladda.create(byId("btnSelect"));\n\n    var colorTime = false;\n    var colorCS = false;\n\n    var depVar = false;\n    var subsetdiv = false;\n    var setxdiv = false;\n\n    // width and height for histgrams\n    var barwidth = 1.3 * allR;\n    var barheight = 0.5 * allR;\n    var barPadding = 0.35;\n    var barnumber = 7;\n\n    // arcs for denoting pebble characteristics\n    var arc = function arc(start, end) {\n        return d3.svg.arc().innerRadius(allR + 5).outerRadius(allR + 20).startAngle(start).endAngle(end);\n    };\n    var arcInd = function arcInd(arclimits) {\n        return d3.svg.arc().innerRadius(allR + 22).outerRadius(allR + 37).startAngle(arclimits[0]).endAngle(arclimits[1]);\n    };\n\n    var _ref = [arc(0, 3.2), arc(1.1, 2.2)],\n        arc0 = _ref[0],\n        arc2 = _ref[1];\n    //arc1 = arc(1.3, 2.3);\n\n    arc1 = arc(0, 1);\n    arc3 = arc(2.3, 3.3);\n    arc4 = arc(4.3, 5.3);\n\n    arcInd1 = arcInd(arcInd1Limits);\n    arcInd2 = arcInd(arcInd2Limits);\n\n    // indicators for showing membership above arcs\n    // let indicator = (degree) => d3.svg.circle()\n    //     .cx( allR )//(allR+35) * Math.sin(degree))\n    //     .cy( allR )//(allR+35) * Math.cos(degree))\n    //     .r(3);\n    // ind1 = indicator(1);\n    // ind2 = indicator(1.2);\n\n    // from .csv\n    var dataset2 = [];\n    var lablArray = [];\n    var hold = [];\n    var subsetNodes = [];\n\n    // collapsable user log\n    $(\'#collapseLog\').on(\'shown.bs.collapse\', function () {\n        return d3.select("#collapseLog div.panel-body").selectAll("p").data(logArray).enter().append("p").text(function (d) {\n            return d;\n        });\n    });\n    $(\'#collapseLog\').on(\'hidden.bs.collapse\', function () {\n        return d3.select("#collapseLog div.panel-body").selectAll("p").remove();\n    });\n\n    //set start from user input, then assume locations are consistent based on d3m directory structure (alternatively can make each of these locations be set by user)\n    var d3mRootPath = "";\n    var d3mDataName = "";\n    var d3mData = null;\n    var d3mTarget = null;\n    var d3mPreprocess = "";\n    var d3mPS = "";\n    var d3mDS = "";\n\n    // default to California PUMS subset (should, doesn\'t actually do that)\n    var data = \'data/\' + (false ? \'PUMS5small\' : \'fearonLaitin\');\n    var metadataurl = ddiurl || (fileid ? dataverseurl + \'/api/meta/datafile/\' + fileid : data + \'.xml\');\n    // read pre-processed metadata and data\n    var pURL = dataurl ? dataurl + \'&format=prep\' : data + \'.json\';\n\n    if (d3m_mode) {\n        pURL = d3mPreprocess;\n        // zparams.zdataurl = start+\'/data/trainDatamerged.tsv\';   // "start" path no longer exists\n        // zparams.zdata = d3mDataName;   // this is now going to be filled in using problem schema field\n    } else if (!production) {\n        zparams.zdataurl = \'data/fearonLaitin.tsv\';\n    }\n\n    /*\n    Loads all external data in the following order (logic is not included):\n    1. Retrieve the configuration information\n    2. Set \'configurations\'\n    3. Read the problem schema and set \'d3mProblemDescription\'\n    4. Read the data schema and set \'dataschema\'\n    5. Read in zelig models (not for d3m)\n    6. Read in zeligchoice models (not for d3m)\n    7. Start the user session\n    8. Call runPreprocess(...)\n    9. Call readPreprocess(...)\n    10. Build allNodes[] using preprocessed information\n    11. Add dataschema information to allNodes (when in d3m_mode)\n    12. Call scaffolding() and start her up\n    */\n\n    Promise.resolve(d3m_mode && _mithril2.default.request({\n        method: "POST",\n        url: "/config/d3m-config/json/latest"\n    }).then(function (result) {\n        configurations = JSON.parse(JSON.stringify(result));\n        d3mRootPath = configurations.training_data_root;\n        d3mRootPath = d3mRootPath.replace(/\\/data/, \'\');\n        d3mDataName = configurations.name;\n        //  d3mData = configurations.training_data_root+"/trainData.csv";\n        // d3mTarget = configurations.training_data_root+"/trainTargets.csv";\n        d3mPS = configurations.problem_schema_url;\n        d3mDS = configurations.dataset_schema_url;\n\n        console.log("Configurations: ");\n        console.log(configurations);\n\n        // these are the two lines that cut the config paths after "TwoRavens/"\n        //d3mTarget = d3mTarget.split("TwoRavens/").pop();\n        //d3mData = d3mData.split("TwoRavens/").pop();\n\n        pURL = \'rook-custom/rook-files/\' + d3mDataName + \'/preprocess/preprocess.json\';\n        d3mPreprocess = pURL;\n    })).then(function (_) {\n        return _mithril2.default.request({\n            method: "GET",\n            url: "/config/d3m-config/get-problem-data-file-info"\n        }).then(function (result) {\n            // some simple logic to get the paths right\n            // note that if neither exist, stay as default which is null\n            if (result.data[\'trainData.csv\'].exists == true) d3mData = result.data[\'trainData.csv\'].path;else if (result.data[\'trainData.csv.gz\'].exists == true) d3mData = result.data[\'trainData.csv.gz\'].path;\n\n            if (result.data[\'trainTargets.csv\'].exists == true) d3mTarget = result.data[\'trainTargets.csv\'].path;else if (result.data[\'trainTargets.csv.gz\'].exists == true) d3mTarget = result.data[\'trainTargets.csv.gz\'].path;\n\n            zparams.zd3mdata = d3mData;\n            zparams.zd3mtarget = d3mTarget;\n        });\n    }).then(function () {\n        return new Promise(function (resolve, reject) {\n            // read in problem schema and we\'ll make a call to start the session with TA2. if we get this far, data are guaranteed to exist for the frontend\n            if (!d3m_mode) return resolve();\n\n            d3.json(d3mPS, function (_, data) {\n                console.log("prob schema data: ", data);\n                mytarget = data.target.field;\n\n                var temp = "";\n                if (!d3m_mode) {\n                    temp = xml.documentElement.getElementsByTagName("fileName"); // Note: presently xml is no longer being read from Dataverse metadata anywhere\n                    zparams.zdata = temp[0].childNodes[0].nodeValue;\n                    var cite = xml.documentElement.getElementsByTagName("biblCit");\n                    // clean citation so POST is valid json\n                    zparams.zdatacite = cite[0].childNodes[0].nodeValue.replace(/\\&/g, "and").replace(/\\;/g, ",").replace(/\\%/g, "-");\n                    $(\'#cite div.panel-body\').text(zparams.zdatacite);\n                } else {\n                    zparams.zdata = data.datasets[0]; // read the dataset name from the problem schema\n                }\n                // dataset name trimmed to 12 chars\n                var dataname = zparams.zdata;\n                if (!d3m_mode) {\n                    dataname = zparams.zdata.replace(/\\.(.*)/, \'\'); // drop file extension\n                }\n\n                d3.select("#dataName").html(dataname);\n                // Put dataset name, from meta-data, into page title\n                d3.select("title").html("TwoRavens " + dataname);\n\n                //This adds a ink to problemDescription.txt in the ticker\n                /*\n                let aTag = document.createElement(\'a\');\n                aTag.setAttribute(\'href\', `${d3mRootPath}/${data.descriptionFile}`);\n                aTag.setAttribute(\'id\', "probdesc");\n                aTag.setAttribute(\'target\', "_blank");\n                aTag.textContent = "Problem Description";\n                document.getElementById("ticker").appendChild(aTag);\n                 */\n\n                if (data.taskType in d3mTaskType) {\n                    d3mProblemDescription.taskType = data.taskType; //[d3mTaskType[data.taskType][2],d3mTaskType[data.taskType][1]]; console.log(d3mProblemDescription);\n                } else {\n                    d3mProblemDescription.taskType = "taskTypeUndefined";\n                    //   alert("Specified task type, " + data.taskType + ", is not valid.");\n                }\n\n                if (data.taskSubType in d3mTaskSubtype) {\n                    d3mProblemDescription.taskSubtype = data.taskSubType;\n                    //[d3mTaskSubtype[data.taskSubType][2],d3mTaskSubtype[data.taskSubType][1]];\n                } else {\n                    d3mProblemDescription.taskSubtype = "taskSubtypeUndefined";\n                    //     alert("Specified task subtype, " + data.taskSubType + ", is not valid.")\n                }\n                if (data.metric in d3mMetrics) {\n                    d3mProblemDescription.metric = data.metric; //[d3mMetrics[data.metric][2],d3mMetrics[data.metric][1]];\n                } else {\n                    d3mProblemDescription.metric = "metricUndefined";\n                    // alert("Specified metric type, " + data.metric + ", is not valid.");\n                }\n                if (data.outputType in d3mOutputType) {\n                    d3mProblemDescription.outputType = data.outputType; //[d3mOutputType[data.outputType][2],d3mOutputType[data.outputType][1]];\n                } else {\n                    d3mProblemDescription.outputType = "outputUndefined";\n                    //  alert("Specified output type, " + data.outputType + ", is not valid.");\n                }\n\n                d3mProblemDescription.taskDescription = data.descriptionFile;\n\n                document.getElementById("btnType").click();\n\n                // making it case insensitive because the case seems to disagree all too often\n                if (failset.indexOf(d3mProblemDescription.taskType.toUpperCase()) == -1) resolve();else {\n                    swandive = true;\n                    resolve();\n                }\n            });\n        });\n    }).then(function () {\n        return new Promise(function (resolve, reject) {\n            // get the data schema\n            if (!d3m_mode) {\n                return resolve();\n            }\n\n            // read the data schema and set dataschema\n            d3.json(d3mDS, function (_, data) {\n                dataschema = JSON.parse(JSON.stringify(data));\n\n                // if swandive, we have to set valueKey here so that left panel can populate\n                if (swandive) {\n                    var datavars = dataschema.trainData.trainData;\n                    if (datavars !== undefined) {\n                        for (var i = 0; i < datavars.length; i++) {\n                            valueKey.push(datavars[i].varName);\n                        }\n                    }\n                    var targetvars = dataschema.trainData.trainTargets;\n                    if (targetvars !== undefined) {\n                        for (var _i = 0; _i < targetvars.length; _i++) {\n                            valueKey.push(targetvars[_i].varName);\n                        }\n                    }\n                    if (valueKey.length == 0)\n                        // end session if neither trainData nor trainTargets?\n                        alert("no trainData or trainTargest in data description file. valueKey length is 0");\n                }\n\n                console.log("data schema data: ", dataschema);\n                resolve();\n            });\n        });\n    }).then(function () {\n        return new Promise(function (resolve, reject) {\n            // read in zelig models\n            if (d3m_mode) return resolve();\n            // read zelig models and populate model list in right panel\n            d3.json("data/zelig5models.json", function (err, data) {\n                if (err) return reject(err);\n                cdb("zelig models json: ", data);\n                for (var key in data.zelig5models) {\n                    if (data.zelig5models.hasOwnProperty(key)) mods[data.zelig5models[key].name[0]] = data.zelig5models[key].description[0];\n                }resolve();\n            });\n        });\n    }).then(function () {\n        return new Promise(function (resolve, reject) {\n            // read in zelig choice models\n            if (d3m_mode) return resolve();\n            d3.json("data/zelig5choicemodels.json", function (err, data) {\n                if (err) return reject(err);\n                cdb("zelig choice models json: ", data);\n                for (var key in data.zelig5choicemodels) {\n                    if (data.zelig5choicemodels.hasOwnProperty(key)) mods[data.zelig5choicemodels[key].name[0]] = data.zelig5choicemodels[key].description[0];\n                }\n                resolve();\n            });\n        });\n    }).then(function () {\n        return new Promise(function (resolve, reject) {\n            // call to django to start the session\n            if (!d3m_mode) return resolve();\n            //rpc StartSession(SessionRequest) returns (SessionResponse) {}\n\n            var user_agent = "some agent";\n            var version = "some version";\n            var SessionRequest = { user_agent: user_agent, version: version };\n\n            var jsonout = JSON.stringify(SessionRequest);\n            var urlcall = d3mURL + "/startsession";\n            var solajsonout = "grpcrequest=" + jsonout;\n            console.log("SessionRequest: ");\n            console.log(solajsonout);\n            console.log("urlcall: ", urlcall);\n\n            if (tutorial_mode) {\n                // && first_load){\n                var dl_content = "<p>This tool can guide you to solve an empirical problem in the dataset listed above.</p><p>These messages will teach you the steps to take to find and submit a solution.</p>";\n                var reset_content = "<p>You can always start a problem over by using this reset button.</p>";\n                var depvar_id = mytarget + "biggroup";\n                var problem_initialized_tour = {\n                    "id": "dataset_launch",\n                    "i18n": {\n                        "doneBtn": \'Ok\'\n                    },\n                    "steps": [{\n                        "target": "dataName", //document.querySelectorAll("#dataName"),\n                        "placement": "bottom",\n                        "title": "Welcome to TwoRavens Solver",\n                        "content": dl_content,\n                        "showCTAButton": true,\n                        "ctaLabel": "Disable these messages",\n                        "onCTA": function onCTA() {\n                            hopscotch.endTour(true);\n                            tutorial_mode = false;\n                        }\n                    }, {\n                        "target": "btnReset",\n                        "placement": "bottom",\n                        "title": "Restart Any Problem Here",\n                        "content": reset_content,\n                        "showCTAButton": true,\n                        "ctaLabel": "Disable these messages",\n                        "onCTA": function onCTA() {\n                            hopscotch.endTour(true);\n                            tutorial_mode = false;\n                        }\n                    }, {\n                        "target": "btnEstimate",\n                        "placement": "left",\n                        "title": "Solve Problem",\n                        "content": "<p>The current green button is generally the next step to follow to move the system forward.</p><p>Click this Solve button to tell the tool to find a solution to the problem.</p>",\n                        "showCTAButton": true,\n                        "ctaLabel": "Disable these messages",\n                        "onCTA": function onCTA() {\n                            hopscotch.endTour(true);\n                            tutorial_mode = false;\n                        }\n                    }, {\n                        "target": depvar_id, //"classbiggroup",\n                        "placement": "left",\n                        "title": "Target Variable",\n                        "content": "This is the variable, " + mytarget + ", we are trying to predict.  This center panel graphically represents the problem currently being attempted.",\n                        "showCTAButton": true,\n                        "ctaLabel": "Disable these messages",\n                        "onCTA": function onCTA() {\n                            hopscotch.endTour(true);\n                            tutorial_mode = false;\n                        }\n                    }, {\n                        "target": "gr1hull",\n                        "placement": "right",\n                        "title": "Explanation Set",\n                        "content": "This set of variables can potentially predict the target.",\n                        "showCTAButton": true,\n                        "ctaLabel": "Disable these messages",\n                        "onCTA": function onCTA() {\n                            hopscotch.endTour(true);\n                            tutorial_mode = false;\n                        }\n                    }, {\n                        "target": "displacement",\n                        "placement": "right",\n                        "title": "Variable List",\n                        "content": "<p>Click on any variable name here if you wish to remove it from the problem solution.</p><p>You likely do not need to adjust the problem representation in the center panel.</p>",\n                        "showCTAButton": true,\n                        "ctaLabel": "Disable these messages",\n                        "onCTA": function onCTA() {\n                            hopscotch.endTour(true);\n                            tutorial_mode = false;\n                        }\n                    }, {\n                        "target": "btnEndSession",\n                        "placement": "bottom",\n                        "title": "Finish Problem",\n                        "content": "If the solution reported back seems acceptable, then finish this problem by clicking this End Session button.",\n                        "showCTAButton": true,\n                        "ctaLabel": "Disable these messages",\n                        "onCTA": function onCTA() {\n                            hopscotch.endTour(true);\n                            tutorial_mode = false;\n                        }\n                    }],\n                    "showCloseButton": false,\n                    "scrollDuration": 300,\n                    "onEnd": function onEnd() {\n                        first_load = false;\n                    }\n                };\n                console.log("Starting Hopscotch Tour");\n                hopscotch.startTour(problem_initialized_tour);\n                console.log("Ending Hopscotch Tour");\n            };\n\n            function ssSuccess(btn, SessionResponse) {\n                console.log("startsession: ", SessionResponse);\n                zparams.zsessionid = SessionResponse.context.sessionId;\n                resolve();\n            }\n\n            function ssFail(btn) {\n                alert("StartSession has failed.");\n                reject();\n            }\n\n            makeCorsRequest(urlcall, "nobutton", ssSuccess, ssFail, solajsonout);\n        });\n    }).then(function (_) {\n        return _mithril2.default.request(pURL);\n    }).then(function (data) {\n        // success means pURL exists, call readPreprocess()\n        if (!swandive) readPreprocess(data);\n    }, function (_) {\n        // fail means pURL doesn\'t exist, call runPreprocess(), which writes preprocess.json and then does what readPreprocess does\n        if (!swandive) runPreprocess(d3mData, d3mTarget, d3mDataName);\n    }).then(function () {\n        return new Promise(function (resolve, reject) {\n            if (swandive) resolve();\n\n            var vars = Object.keys(preprocess);\n\n            // temporary values for hold that correspond to histogram bins\n            hold = [.6, .2, .9, .8, .1, .3, .4];\n            for (var i = 0; i < vars.length; i++) {\n                // valueKey[i] = vars[i].attributes.name.nodeValue;\n                // lablArray[i] = varsXML[i].getElementsByTagName("labl").length == 0 ?\n                // "no label" :\n                // varsXML[i].getElementsByTagName("labl")[0].childNodes[0].nodeValue;\n                // let datasetcount = d3.layout.histogram()\n                //     .bins(barnumber).frequency(false)\n                //     ([0, 0, 0, 0, 0]);\n                valueKey[i] = vars[i];\n                lablArray[i] = "no label";\n                // contains all the preprocessed data we have for the variable, as well as UI data pertinent to that variable,\n                // such as setx values (if the user has selected them) and pebble coordinates\n                var obj = {\n                    id: i,\n                    reflexive: false,\n                    name: valueKey[i],\n                    labl: lablArray[i],\n                    data: [5, 15, 20, 0, 5, 15, 20],\n                    count: hold,\n                    nodeCol: colors(i),\n                    baseCol: colors(i),\n                    strokeColor: _plots.selVarColor,\n                    strokeWidth: "1",\n                    subsetplot: false,\n                    subsetrange: ["", ""],\n                    setxplot: false,\n                    setxvals: ["", ""],\n                    grayout: false,\n                    group1: false,\n                    group2: false,\n                    forefront: false\n                };\n                jQuery.extend(true, obj, preprocess[valueKey[i]]);\n                allNodes.push(obj);\n            };\n            resolve();\n        });\n    }).then(function () {\n        return new Promise(function (resolve, reject) {\n            // adding in d3mDescription if d3m_mode\n            if (!d3m_mode || swandive) return resolve();\n            // adding in d3mDescription to allNodes\n            var datavars = dataschema.trainData.trainData;\n            for (var i = 0; i < datavars.length; i++) {\n                var myi = findNodeIndex(datavars[i].varName);\n                var d3mDescription = { d3mDescription: datavars[i] };\n                allNodes[myi] = Object.assign(allNodes[myi], d3mDescription);\n            }\n            console.log(allNodes);\n            resolve();\n        });\n    }).then(function () {\n        // final step: start her up\n        //  .then(() => new Promise((resolve, reject) => {\n        if (swandive) {\n            scaffolding(swandive);\n        } else {\n            scaffolding(layout);\n            if (d3m_mode) {\n                zPop();\n            } else {\n                dataDownload();\n            }\n        }\n        // resolve();\n    });\n}\n\nvar $fill = function $fill(obj, op, d1, d2) {\n    return d3.select(obj).transition().attr(\'fill-opacity\', op).delay(d1).duration(d2);\n};\nvar fill = function fill(d, id, op, d1, d2) {\n    return $fill(\'#\' + id + d.id, op, d1, d2);\n};\nvar fillThis = function fillThis(self, op, d1, d2) {\n    return $fill(self, op, d1, d2);\n};\n\n// scaffolding is called after all external data are guaranteed to have been read to completion. this populates the left panel with variable names, the right panel with model names, the transformation tool, an the associated mouseovers. its callback is layout(), which initializes the modeling space\nfunction scaffolding(callback) {\n    var _this = this;\n\n    console.log("SCAFFOLDING");\n    // establishing the transformation element\n    //    d3.select("#transformations")\n    //      .append("input")\n    //     .attr("id", "tInput")\n    //    .attr("class", "form-control")\n    //   .attr("type", "text")\n    //  .attr("value", "Variable transformation");\n\n    // variable dropdown\n    d3.select("#transformations").append("ul").attr("id", "transSel").style("display", "none").style("background-color", varColor).selectAll(\'li\').data(["a", "b"]) //set to variables in model space as they\'re added\n    .enter().append("li").text(function (d) {\n        return d;\n    });\n\n    // function dropdown\n    d3.select("#transformations").append("ul").attr("id", "transList").style("display", "none").style("background-color", varColor).selectAll(\'li\').data(transformList).enter().append("li").text(function (d) {\n        return d;\n    });\n\n    if (!d3m_mode) {\n        // No variable transformation in present d3m mode\n\n        $(\'#tInput\').click(function () {\n            var t = byId(\'transSel\').style.display;\n            if (t !== "none") {\n                // if variable list is displayed when input is clicked...\n                $(\'#transSel\').fadeOut(100);\n                return false;\n            }\n            var t1 = byId(\'transList\').style.display;\n            if (t1 !== "none") {\n                // if function list is displayed when input is clicked...\n                $(\'#transList\').fadeOut(100);\n                return false;\n            }\n\n            // highlight the text\n            $(_this).select();\n            var pos = $(\'#tInput\').offset();\n            pos.top += $(\'#tInput\').width();\n            $(\'#transSel\').fadeIn(100);\n            return false;\n        });\n\n        var n;\n        $(\'#tInput\').keyup(function (evt) {\n            var t = byId(\'transSel\').style.display;\n            var t1 = byId(\'transList\').style.display;\n            if (t != "none") $(\'#transSel\').fadeOut(100);else if (t1 != "none") $(\'#transList\').fadeOut(100);\n\n            if (evt.keyCode == 13) {\n                // keyup on Enter\n                n = $(\'#tInput\').val();\n                var t = transParse(n = n);\n                if (!t) return;\n                transform(n = t.slice(0, t.length - 1), t = t[t.length - 1], typeTransform = false);\n            }\n        });\n\n        var t;\n        $(\'#transList li\').click(function (evt) {\n            // if interact is selected, show variable list again\n            if ($(this).text() == "interact(d,e)") {\n                $(\'#tInput\').val(tvar.concat(\'*\'));\n                selInteract = true;\n                $(this).parent().fandeOut(100);\n                $(\'#transSel\').fadeIn(100);\n                evt.stopPropagation();\n                return;\n            }\n\n            var tvar = $(\'#tInput\').val();\n            var tfunc = $(this).text().replace("d", "_transvar0");\n            var tcall = $(this).text().replace("d", tvar);\n            $(\'#tInput\').val(tcall);\n            $(this).parent().fadeOut(100);\n            evt.stopPropagation();\n            transform(n = tvar, t = tfunc, typeTransform = false);\n        });\n    };\n\n    d3.select("#models").style(\'height\', 2000).style(\'overfill\', \'scroll\');\n\n    if (!d3m_mode) {\n        d3.select("#models").selectAll("p").data(Object.keys(mods)).enter().append("p").attr("id", "_model_".concat).text(function (d) {\n            return d;\n        }).style(\'background-color\', function (d) {\n            return varColor;\n        }).attr("data-container", "body").attr("data-toggle", "popover").attr("data-trigger", "hover").attr("data-placement", "top").attr("data-html", "true").attr("onmouseover", "$(this).popover(\'toggle\');").attr("onmouseout", "$(this).popover(\'toggle\');").attr("data-original-title", "Model Description").attr("data-content", function (d) {\n            return mods[d];\n        });\n    }\n    if (d3m_mode) {\n\n        //\n\n        toggleRightButtons("tasks");\n\n        d3.select("#types").selectAll("p").data(Object.keys(d3mTaskType)).enter().append("p").attr("id", function (d) {\n            return d + ".types";\n        }).text(function (d) {\n            return d;\n        }).attr(\'class\', function (d) {\n            if (d3mProblemDescription.taskType == d.toString()) {\n                return \'item-select\';\n            } else {\n                if (locktoggle) return \'item-default item-lineout\';\n                return \'item-default\';\n            }\n        }).attr("data-container", "body").attr("data-toggle", "popover").attr("data-trigger", "hover").attr("data-placement", "top").attr("data-html", "true").attr("onmouseover", "$(this).popover(\'toggle\');").attr("onmouseout", "$(this).popover(\'toggle\');").attr("data-original-title", "Task Description").attr("data-content", function (d) {\n            return d3mTaskType[d][1];\n        });\n\n        d3.select("#subtypes").selectAll("p").data(Object.keys(d3mTaskSubtype)).enter().append("p").attr("id", function (d) {\n            return d + ".subtypes";\n        }).text(function (d) {\n            return d;\n        }).attr(\'class\', function (d) {\n            if (d3mProblemDescription.taskSubtype == d.toString()) {\n                return \'item-select\';\n            } else {\n                if (locktoggle) return \'item-default item-lineout\';\n                return \'item-default\';\n            }\n        }).attr("data-container", "body").attr("data-toggle", "popover").attr("data-trigger", "hover").attr("data-placement", "top").attr("data-html", "true").attr("onmouseover", "$(this).popover(\'toggle\');").attr("onmouseout", "$(this).popover(\'toggle\');").attr("data-original-title", "Task Subtype Desc.").attr("data-content", function (d) {\n            return d3mTaskSubtype[d][1];\n        });\n\n        d3.select("#metrics").selectAll("p").data(Object.keys(d3mMetrics)).enter().append("p").attr("id", function (d) {\n            return d + ".metrics";\n        }).text(function (d) {\n            return d;\n        }).attr(\'class\', function (d) {\n            if (d3mProblemDescription.metric == d.toString()) {\n                return \'item-select\';\n            } else {\n                if (locktoggle) return \'item-default item-lineout\';\n                return \'item-default\';\n            }\n        }).attr("data-container", "body").attr("data-toggle", "popover").attr("data-trigger", "hover").attr("data-placement", "top").attr("data-html", "true").attr("onmouseover", "$(this).popover(\'toggle\');").attr("onmouseout", "$(this).popover(\'toggle\');").attr("data-original-title", "Metric Description").attr("data-content", function (d) {\n            return d3mMetrics[d][1];\n        });\n\n        d3.select("#outputs").selectAll("p").data(Object.keys(d3mOutputType)).enter().append("p").attr("id", function (d) {\n            return d + ".outputs";\n        }).text(function (d) {\n            return d;\n        }).attr(\'class\', function (d) {\n            if (d3mProblemDescription.outputType == d.toString()) {\n                return \'item-select\';\n            } else {\n                if (locktoggle) return \'item-default item-lineout\';\n                return \'item-default\';\n            }\n        }).attr("data-container", "body").attr("data-toggle", "popover").attr("data-trigger", "hover").attr("data-placement", "top").attr("data-html", "true").attr("onmouseover", "$(this).popover(\'toggle\');").attr("onmouseout", "$(this).popover(\'toggle\');").attr("data-original-title", "Output Description").attr("data-content", function (d) {\n            return d3mOutputType[d][1];\n        });\n    }\n\n    // call layout() because at this point all scaffolding is up and ready\n    if (typeof callback == "function") {\n        callback(false, true);\n        _mithril2.default.redraw();\n    } else {\n        _mithril2.default.redraw();\n    }\n\n    // if swandive, after scaffolding is up, just grey things out\n    if (swandive) {\n        // perhaps want to allow users to unlcok and select things?\n        document.getElementById(\'btnLock\').classList.add(\'noshow\');\n        document.getElementById(\'btnForce\').classList.add(\'noshow\');\n        document.getElementById(\'btnEraser\').classList.add(\'noshow\');\n        document.getElementById(\'btnSubset\').classList.add(\'noshow\');\n        document.getElementById(\'main\').style.backgroundColor = \'grey\';\n        document.getElementById(\'whitespace\').style.backgroundColor = \'grey\';\n    }\n}\n\nvar splice = function splice(color, text) {\n    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        args[_key - 2] = arguments[_key];\n    }\n\n    args.forEach(function (x) {\n        if (color != x[0]) return;\n        var idx = zparams[x[1]].indexOf(text);\n        idx > -1 && zparams[x[1]].splice(idx, 1);\n    });\n};\n\nvar clickVar = exports.clickVar = void 0;\n\nfunction layout(v, v2) {\n    var myValues = [];\n    exports.nodes = nodes = [];\n    links = [];\n\n    svg.append("svg:defs").append("svg:marker").attr("id", "group1-arrow").attr(\'viewBox\', \'0 -5 15 15\').attr("refX", 2.5).attr("refY", 0).attr("markerWidth", 3).attr("markerHeight", 3).attr("orient", "auto").append("path").attr(\'d\', \'M0,-5L10,0L0,5\').style("fill", gr1Color);\n\n    svg.append("svg:defs").append("svg:marker").attr("id", "group2-arrow").attr(\'viewBox\', \'0 -5 15 15\').attr("refX", 2.5).attr("refY", 0).attr("markerWidth", 3).attr("markerHeight", 3).attr("orient", "auto").append("path").attr(\'d\', \'M0,-5L10,0L0,5\').style("fill", gr2Color);\n\n    var line = svg.append("line").style(\'fill\', \'none\').style(\'stroke\', gr1Color).style(\'stroke-width\', 5).attr("marker-end", "url(#group1-arrow)");\n\n    var line2 = svg.append("line").style(\'fill\', \'none\').style(\'stroke\', gr2Color).style(\'stroke-width\', 5).attr("marker-end", "url(#group2-arrow)");;\n\n    var visbackground = d3.select("#whitespace").append("svg").attr("width", width).attr("height", height);\n\n    visbackground.append("path") // note lines, are behind group hulls of which there is a white and colored semi transparent layer\n    .attr("id", \'gr1background\').style("fill", \'#ffffff\').style("stroke", \'#ffffff\').style("stroke-width", 2.5 * allR).style(\'stroke-linejoin\', \'round\').style("opacity", 1);\n\n    var vis2background = d3.select("#whitespace").append("svg").attr("width", width).attr("height", height);\n\n    vis2background.append("path").attr("id", \'gr1background\').style("fill", \'#ffffff\').style("stroke", \'#ffffff\').style("stroke-width", 2.5 * allR).style(\'stroke-linejoin\', \'round\').style("opacity", 1);\n\n    var vis = d3.select("#whitespace").append("svg").attr("width", width).attr("height", height);\n\n    vis.append("path").attr("id", \'gr1hull\').style("fill", gr1Color).style("stroke", gr1Color).style("stroke-width", 2.5 * allR).style(\'stroke-linejoin\', \'round\');\n\n    var vis2 = d3.select("#whitespace").append("svg").attr("width", width).attr("height", height);\n\n    vis2.append("path").style("fill", gr2Color).style("stroke", gr2Color).style("stroke-width", 2.5 * allR).style(\'stroke-linejoin\', \'round\');\n\n    if (v == layoutAdd || v == layoutMove) {\n        for (var j = 0; j < zparams.zvars.length; j++) {\n            var ii = findNodeIndex(zparams.zvars[j]);\n            if (allNodes[ii].grayout) continue;\n            nodes.push(allNodes[ii]);\n            var selectMe = zparams.zvars[j].replace(/\\W/g, "_");\n            selectMe = "#".concat(selectMe);\n            d3.select(selectMe).style(\'background-color\', function () {\n                return hexToRgba(nodes[j].strokeColor);\n            });\n        }\n\n        for (var j = 0; j < zparams.zedges.length; j++) {\n            var mysrc = nodeIndex(zparams.zedges[j][0]);\n            var mytgt = nodeIndex(zparams.zedges[j][1]);\n            links.push({\n                source: nodes[mysrc],\n                target: nodes[mytgt],\n                left: false,\n                right: true\n            });\n        }\n    } else {\n        if (d3m_mode) {\n            //nodes = [findNode(mytarget)];               // Only add dependent variable on startup\n            exports.nodes = nodes = allNodes.slice(1, allNodes.length); // Add all but first variable on startup (assumes 0 position is d3m index variable)\n            for (var _j = 0; _j < nodes.length; _j++) {\n                //populate zvars array\n                if (nodes[_j].name != mytarget) {\n                    nodes[_j].group1 = true;\n                    zparams.zgroup1.push(nodes[_j].name); // write all names (except d3m index and the dependent variable) to zgroup1 array\n                };\n            };\n        } else if (allNodes.length > 2) {\n            exports.nodes = nodes = [allNodes[0], allNodes[1], allNodes[2]];\n            links = [{\n                source: nodes[1],\n                target: nodes[0],\n                left: false,\n                right: true\n            }, {\n                source: nodes[0],\n                target: nodes[2],\n                left: false,\n                right: true\n            }];\n        } else if (allNodes.length === 2) {\n            exports.nodes = nodes = [allNodes[0], allNodes[1]];\n            links = [{\n                source: nodes[1],\n                target: nodes[0],\n                left: false,\n                right: true\n            }];\n        } else if (allNodes.length === 1) {\n            exports.nodes = nodes = [allNodes[0]];\n        } else {\n            alert("There are zero variables in the metadata.");\n            return;\n        }\n    }\n\n    panelPlots(); // after nodes is populated, add subset and (if !d3m_mode) setx panels\n\n    var force = d3.layout.force().nodes(nodes).links(links).size([width, height]).linkDistance(150).charge(-800).on(\'tick\', tick);\n\n    // define arrow markers for graph links\n    svg.append(\'svg:defs\').append(\'svg:marker\').attr(\'id\', \'end-arrow\').attr(\'viewBox\', \'0 -5 10 10\').attr(\'refX\', 6).attr(\'markerWidth\', 3).attr(\'markerHeight\', 3).attr(\'orient\', \'auto\').append(\'svg:path\').attr(\'d\', \'M0,-5L10,0L0,5\').style(\'fill\', \'#000\');\n\n    svg.append(\'svg:defs\').append(\'svg:marker\').attr(\'id\', \'start-arrow\').attr(\'viewBox\', \'0 -5 10 10\').attr(\'refX\', 4).attr(\'markerWidth\', 3).attr(\'markerHeight\', 3).attr(\'orient\', \'auto\').append(\'svg:path\').attr(\'d\', \'M10,-5L0,0L10,5\').style(\'fill\', \'#000\');\n\n    // line displayed when dragging new nodes\n    var drag_line = svg.append(\'svg:path\').attr(\'class\', \'link dragline hidden\').attr(\'d\', \'M0,0L0,0\');\n\n    // handles to link and node element groups\n    var path = svg.append(\'svg:g\').selectAll(\'path\'),\n        circle = svg.append(\'svg:g\').selectAll(\'g\');\n    //line = svg.append(\'svg:g\').selectAll(\'line\');\n\n    // mouse event vars\n    var selected_node = null,\n        selected_link = null,\n        mousedown_link = null,\n        mousedown_node = null,\n        mouseup_node = null;\n\n    function resetMouseVars() {\n        mousedown_node = null;\n        mouseup_node = null;\n        mousedown_link = null;\n    }\n\n    // update force layout (called automatically each iteration)\n    function tick() {\n\n        function findcoords(findnames, allnames, coords, lengthen) {\n            var fcoords = new Array(findnames.length); // found coordinates\n            var addlocation = 0;\n            if (findnames.length > 0) {\n                for (var j = 0; j < findnames.length; j++) {\n                    addlocation = allnames.indexOf(findnames[j]);\n                    fcoords[j] = coords[addlocation];\n                };\n            };\n\n            if (lengthen) {\n                // d3.geom.hull returns null for two points, and fails if three points are in a line,\n                // so this puts a couple points slightly off the line for two points, or around a singleton.\n                if (fcoords.length == 2) {\n                    var deltax = fcoords[0][0] - fcoords[1][0];\n                    var deltay = fcoords[0][1] - fcoords[1][1];\n                    fcoords.push([(fcoords[0][0] + fcoords[1][0]) / 2 + deltay / 20, (fcoords[0][1] + fcoords[1][1]) / 2 + deltax / 20]);\n                    fcoords.push([(fcoords[0][0] + fcoords[1][0]) / 2 - deltay / 20, (fcoords[0][1] + fcoords[1][1]) / 2 - deltax / 20]);\n                }\n                if (fcoords.length == 1) {\n                    var delta = allR * 0.2;\n                    fcoords.push([fcoords[0][0] + delta, fcoords[0][1]]);\n                    fcoords.push([fcoords[0][0] - delta, fcoords[0][1]]);\n                    fcoords.push([fcoords[0][0], fcoords[0][1] + delta]);\n                    fcoords.push([fcoords[0][0], fcoords[0][1] - delta]);\n                }\n            }\n            return fcoords;\n        };\n\n        // d3.geom.hull returns null for two points, and fails if three points are in a line,\n        // so this puts a couple points slightly off the line for two points, or around a singleton.\n        function lengthencoords(coords) {\n            if (coords.length == 2) {\n                var deltax = coords[0][0] - coords[1][0];\n                var deltay = coords[0][1] - coords[1][1];\n                coords.push([(coords[0][0] + coords[1][0]) / 2 + deltay / 20, (coords[0][1] + coords[1][1]) / 2 + deltax / 20]);\n                coords.push([(coords[0][0] + coords[1][0]) / 2 - deltay / 20, (coords[0][1] + coords[1][1]) / 2 - deltax / 20]);\n            }\n            if (coords.length == 1) {\n                var delta = allR * 0.2;\n                coords.push([coords[0][0] + delta, coords[0][1]]);\n                coords.push([coords[0][0] - delta, coords[0][1]]);\n                coords.push([coords[0][0], coords[0][1] + delta]);\n                coords.push([coords[0][0], coords[0][1] - delta]);\n            }\n            return coords;\n        };\n\n        var coords = nodes.map(function (d) {\n            return [d.x, d.y];\n        });\n        var gr1coords = findcoords(zparams.zgroup1, zparams.zvars, coords, true);\n        var gr2coords = findcoords(zparams.zgroup2, zparams.zvars, coords, true);\n        var depcoords = findcoords(zparams.zdv, zparams.zvars, coords, false);\n\n        // draw convex hull around independent variables, if three or more coordinates given\n        // note, d3.geom.hull returns null if shorter coordinate set than 3,\n        // so findcoords() function has option to lengthen the coordinates returned to bypass this\n        if (gr1coords.length > 2) {\n            line.style("opacity", 1);\n            visbackground.style("opacity", 1);\n            vis.style("opacity", 0.3);\n            var myhull = d3.geom.hull(gr1coords);\n\n            vis.selectAll("path").data([myhull]) // returns null if less than three coordinates\n            .attr("d", function (d) {\n                return "M" + d.join("L") + "Z";\n            });\n            visbackground.selectAll("path").data([myhull]) // returns null if less than three coordinates\n            .attr("d", function (d) {\n                return "M" + d.join("L") + "Z";\n            });\n\n            //var p = d3.geom.polygon(indcoords).centroid();  // Seems to go strange sometimes\n            var p = jamescentroid(gr1coords);\n\n            if (depcoords.length > 0) {\n                var q = depcoords[0]; // Note, only using first dep var currently\n                //var r = findboundary(p,q,gr1coords);        // An approach to find the exact boundary, not presently working\n                var ldeltaX = q[0] - p[0],\n                    ldeltaY = q[1] - p[1],\n                    ldist = Math.sqrt(ldeltaX * ldeltaX + ldeltaY * ldeltaY),\n                    lnormX = 0,\n                    lnormY = 0,\n                    lsourcePadding = allR + 7,\n                    ltargetPadding = allR + 10;\n\n                if (ldist > 0) {\n                    lnormX = ldeltaX / ldist;\n                    lnormY = ldeltaY / ldist;\n                };\n\n                line.attr("x1", p[0] + lsourcePadding * lnormX) // or r[0] if findboundary works\n                .attr("y1", p[1] + lsourcePadding * lnormY) // or r[1] if findboundary works\n                .attr("x2", q[0] - ltargetPadding * lnormX).attr("y2", q[1] - ltargetPadding * lnormY);\n            };\n\n            // group members attract each other, repulse non-group members\n            nodes.forEach(function (n) {\n                var sign = n.group1 ? 1 : -1; //was: Math.sign( zparams.zgroup1.indexOf(n.name) +0.5 );  // 1 if n in group, -1 if n not in group;\n                var ldeltaX = p[0] - n.x,\n                    ldeltaY = p[1] - n.y,\n                    ldist = Math.sqrt(ldeltaX * ldeltaX + ldeltaY * ldeltaY);\n                lnormX = 0, lnormY = 0;\n\n                if (ldist > 0) {\n                    lnormX = ldeltaX / ldist;\n                    lnormY = ldeltaY / ldist;\n                };\n\n                n.x += Math.min(lnormX, ldeltaX / 100) * k * sign * force.alpha();\n                n.y += Math.min(lnormY, ldeltaY / 100) * k * sign * force.alpha();\n            });\n        } else {\n            visbackground.style("opacity", 0);\n\n            vis.style("opacity", 0);\n            //            vis.style("opacity", 0);\n            line.style("opacity", 0);\n        };\n\n        if (gr2coords.length > 2) {\n            line2.style("opacity", 1);\n            vis2background.style("opacity", 1);\n            vis2.style("opacity", 0.3);\n            var myhull = d3.geom.hull(gr2coords);\n            vis2.selectAll("path").data([myhull]) // returns null if less than three coordinates\n            .attr("d", function (d) {\n                return "M" + d.join("L") + "Z";\n            });\n            vis2background.selectAll("path").data([myhull]) // returns null if less than three coordinates\n            .attr("d", function (d) {\n                return "M" + d.join("L") + "Z";\n            });\n\n            //var p = d3.geom.polygon(indcoords).centroid();  // Seems to go strange sometimes\n            var p = jamescentroid(gr2coords);\n\n            if (depcoords.length > 0) {\n                var q = depcoords[0]; // Note, only using first dep var currently\n                var ldeltaX = q[0] - p[0],\n                    ldeltaY = q[1] - p[1],\n                    ldist = Math.sqrt(ldeltaX * ldeltaX + ldeltaY * ldeltaY),\n                    lnormX = ldeltaX / ldist,\n                    lnormY = ldeltaY / ldist,\n                    lsourcePadding = allR + 7,\n                    ltargetPadding = allR + 10;\n\n                line2.attr("x1", p[0] + lsourcePadding * lnormX).attr("y1", p[1] + lsourcePadding * lnormY).attr("x2", q[0] - ltargetPadding * lnormX).attr("y2", q[1] - ltargetPadding * lnormY);\n            };\n\n            // group members attract each other, repulse non-group members\n            nodes.forEach(function (n) {\n                var sign = n.group2 ? 1 : -1; // was: Math.sign( zparams.zgroup2.indexOf(n.name) +0.5 );  // 1 if n in group, -1 if n not in group;\n                var ldeltaX = p[0] - n.x,\n                    ldeltaY = p[1] - n.y,\n                    ldist = Math.sqrt(ldeltaX * ldeltaX + ldeltaY * ldeltaY),\n                    lnormX = 0,\n                    lnormY = 0;\n\n                if (ldist > 0) {\n                    lnormX = ldeltaX / ldist;\n                    lnormY = ldeltaY / ldist;\n                };\n\n                n.x += Math.min(lnormX, ldeltaX / 100) * k * sign * force.alpha();\n                n.y += Math.min(lnormY, ldeltaY / 100) * k * sign * force.alpha();\n            });\n        } else {\n            vis2background.style("opacity", 0);\n            vis2.style("opacity", 0);\n            line2.style("opacity", 0);\n        };\n\n        // draw directed edges with proper padding from node centers\n        path.attr(\'d\', function (d) {\n            var deltaX = d.target.x - d.source.x,\n                deltaY = d.target.y - d.source.y,\n                dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY),\n                normX = deltaX / dist,\n                normY = deltaY / dist,\n                sourcePadding = d.left ? allR + 5 : allR,\n                targetPadding = d.right ? allR + 5 : allR,\n                sourceX = d.source.x + sourcePadding * normX,\n                sourceY = d.source.y + sourcePadding * normY,\n                targetX = d.target.x - targetPadding * normX,\n                targetY = d.target.y - targetPadding * normY;\n            return \'M\' + sourceX + \',\' + sourceY + \'L\' + targetX + \',\' + targetY;\n        });\n\n        circle.attr(\'transform\', function (d) {\n            return \'translate(\' + d.x + \',\' + d.y + \')\';\n        });\n\n        circle.selectAll(\'circle\') // Shrink/expand pebbles that join/leave groups\n        .transition().duration(100).attr(\'r\', function (d) {\n            return setPebbleRadius(d);\n        });\n    }\n\n    exports.clickVar = clickVar = function clickVar() {\n        // every time a variable in leftpanel is clicked, nodes updates and background color changes\n        if (findNodeIndex(this.id, true).grayout) return;\n        zparams.zvars = [];\n        var text = d3.select(this).text();\n        var node = findNode(text);\n        if (nodes.map(function (n) {\n            return n.name;\n        }).includes(text)) {\n            nodes.splice(node.index, 1);\n            spliceLinksForNode(node);\n            splice(node.strokeColor, text, [dvColor, \'zdv\'], [csColor, \'zcross\'], [timeColor, \'ztime\'], [nomColor, \'znom\']);\n\n            if (node.group1) {\n                // remove node name from group lists (should use adaptation of splice-by-color)\n                node.group1 = false;\n                zparams.zgroup1.splice(zparams.zgroup1.indexOf(node.name), 1);\n            };\n            if (node.group2) {\n                node.group2 = false;\n                zparams.zgroup2.splice(zparams.zgroup2.indexOf(node.name), 1);\n            };\n\n            nodeReset(node);\n            legend();\n        } else {\n            nodes.push(node);\n            if (nodes.length === 0) nodes[0].reflexive = true;\n        }\n        zparams.zvars = nodes.map(function (n) {\n            return n.name;\n        }); // adding this to keep it current (or should we rely on nodes.map(n => n.name) for variable list?)\n        panelPlots();\n        restart();\n    };\n\n    d3.select("#models").selectAll("p") // models tab\n    //  d3.select("#Display_content")\n    .on("click", function () {\n        var myColor = d3.select(this).style(\'background-color\');\n        d3.select("#models").selectAll("p").style(\'background-color\', varColor);\n        d3.select(this).style(\'background-color\', function (d) {\n            if (d3.rgb(myColor).toString() === varColor.toString()) {\n                zparams.zmodel = d.toString();\n                return hexToRgba(_plots.selVarColor);\n            } else {\n                zparams.zmodel = \'\';\n                return varColor;\n            }\n        });\n        restart();\n    });\n\n    d3.select("#types").selectAll("p") // models tab\n    //  d3.select("#Display_content")\n    .on("click", function () {\n        if (locktoggle) return;\n        if (this.className == "item-select") {\n            return;\n        } else {\n            d3.select("#types").select("p.item-select").attr(\'class\', \'item-default\');\n            d3mProblemDescription.taskType = this.innerHTML.toString();\n            d3.select(this).attr(\'class\', "item-select");\n        }\n        restart();\n        updateSchema("taskType", d3mProblemDescription, d3mTaskType);\n    });\n\n    d3.select("#subtypes").selectAll("p").on("click", function () {\n        if (locktoggle) return;\n        if (this.className == "item-select") {\n            return;\n        } else {\n            d3.select("#subtypes").select("p.item-select").attr(\'class\', \'item-default\');\n            d3mProblemDescription.taskSubtype = this.innerHTML.toString();\n            d3.select(this).attr(\'class\', "item-select");\n        }\n        restart();\n        updateSchema("taskSubtype", d3mProblemDescription, d3mTaskSubtype);\n    });\n\n    d3.select("#metrics").selectAll("p").on("click", function () {\n        if (locktoggle) return;\n        if (this.className == "item-select") {\n            return;\n            //         d3mProblemDescription.metric = ["",""];\n            //        this.className="item-default";\n        } else {\n            d3.select("#metrics").select("p.item-select").attr(\'class\', \'item-default\');\n            d3mProblemDescription.metric = this.innerHTML.toString();\n            d3.select(this).attr(\'class\', "item-select");\n        }\n        restart();\n        updateSchema("metric", d3mProblemDescription, d3mMetrics);\n    });\n\n    d3.select("#outputs").selectAll("p").on("click", function () {\n        if (locktoggle) return;\n        if (this.className == "item-select") {\n            return;\n        } else {\n            d3.select("#outputs").select("p.item-select").attr(\'class\', \'item-default\');\n            d3mProblemDescription.outputType = this.innerHTML.toString();\n            d3.select(this).attr(\'class\', "item-select");\n        }\n        restart();\n        updateSchema("outputType", d3mProblemDescription, d3mOutputType);\n    });\n\n    // update graph (called when needed)\n    function restart() {\n        // nodes.id is pegged to allNodes, i.e. the order in which variables are read in\n        // nodes.index is floating and depends on updates to nodes.  a variables index changes when new variables are added.\n        circle.call(force.drag);\n        if (forcetoggle[0] == "true") {\n            force.gravity(0.1);\n            force.charge(function (d) {\n                return setPebbleCharge(d);\n            });\n            force.start();\n            force.linkStrength(1);\n            k = 4; // strength parameter for group attraction/repulsion\n            if (zparams.zgroup1.length > 0 & zparams.zgroup2.length > 0) {\n                // scale down by number of active groups\n                k = 2.5;\n            }\n        } else {\n            force.gravity(0);\n            force.charge(0);\n            force.linkStrength(0);\n            k = 0;\n        }\n        force.resume();\n\n        // path (link) group\n        path = path.data(links);\n\n        // update existing links\n        // VJD: dashed links between pebbles are "selected". this is disabled for now\n        path.classed(\'selected\', function (x) {\n            return null;\n        }).style(\'marker-start\', function (x) {\n            return x.left ? \'url(#start-arrow)\' : \'\';\n        }).style(\'marker-end\', function (x) {\n            return x.right ? \'url(#end-arrow)\' : \'\';\n        });\n\n        // add new links\n        path.enter().append(\'svg:path\').attr(\'class\', \'link\').classed(\'selected\', function (x) {\n            return null;\n        }).style(\'marker-start\', function (x) {\n            return x.left ? \'url(#start-arrow)\' : \'\';\n        }).style(\'marker-end\', function (x) {\n            return x.right ? \'url(#end-arrow)\' : \'\';\n        }).on(\'mousedown\', function (d) {\n            // do we ever need to select a link? make it delete..\n            var obj = JSON.stringify(d);\n            for (var j = 0; j < links.length; j++) {\n                if (obj === JSON.stringify(links[j])) links.splice(j, 1);\n            }\n        });\n\n        // remove old links\n        path.exit().remove();\n\n        // circle (node) group\n        circle = circle.data(nodes, function (x) {\n            return x.id;\n        });\n\n        // update existing nodes (reflexive & selected visual states)\n        // d3.rgb is the function adjusting the color here\n        circle.selectAll(\'circle\').classed(\'reflexive\', function (x) {\n            return x.reflexive;\n        }).style(\'fill\', function (x) {\n            return d3.rgb(x.nodeCol);\n        }).style(\'stroke\', function (x) {\n            return d3.rgb(x.strokeColor);\n        }).style(\'stroke-width\', function (x) {\n            return x.strokeWidth;\n        });\n\n        // add new nodes\n        var g = circle.enter().append(\'svg:g\').attr(\'id\', function (x) {\n            return x.name + \'biggroup\';\n        });\n\n        // add plot\n        g.each(function (d) {\n            d3.select(this);\n            if (d.plottype == \'continuous\') (0, _plots.densityNode)(d, this);else if (d.plottype == \'bar\') (0, _plots.barsNode)(d, this);\n        });\n\n        var append = function append(str, attr) {\n            return function (x) {\n                return str + x[attr || \'id\'];\n            };\n        };\n\n        g.append("path").attr("id", append(\'dvArc\')).attr("d", arc3).style("fill", dvColor).attr("fill-opacity", 0).on(\'mouseover\', function (d) {\n            fillThis(this, .3, 0, 100);\n            fill(d, \'dvText\', .9, 0, 100);\n        }).on(\'mouseout\', function (d) {\n            fillThis(this, 0, 100, 500);\n            fill(d, \'dvText\', 0, 100, 500);\n        }).on(\'click\', function (d) {\n            setColors(d, dvColor);\n            legend(dvColor);\n            restart();\n        });\n\n        g.append("text").attr("id", append(\'dvText\')).attr("x", 6).attr("dy", 11.5).attr("fill-opacity", 0).append("textPath").attr("xlink:href", append(\'#dvArc\')).text("Dep Var");\n\n        g.append("path").attr("id", append(\'nomArc\')).attr("d", arc4).style("fill", nomColor).attr("fill-opacity", 0).on(\'mouseover\', function (d) {\n            if (d.defaultNumchar == "character") return;\n            fillThis(this, .3, 0, 100);\n            fill(d, "nomText", .9, 0, 100);\n        }).on(\'mouseout\', function (d) {\n            if (d.defaultNumchar == "character") return;\n            fillThis(this, 0, 100, 500);\n            fill(d, "nomText", 0, 100, 500);\n        }).on(\'click\', function (d) {\n            if (d.defaultNumchar == "character") return;\n            setColors(d, nomColor);\n            legend(nomColor);\n            restart();\n        });\n\n        g.append("text").attr("id", append("nomText")).attr("x", 6).attr("dy", 11.5).attr("fill-opacity", 0).append("textPath").attr("xlink:href", append("#nomArc")).text("Nominal");\n\n        g.append("path").attr("id", append(\'grArc\')).attr("d", arc1).style("fill", gr1Color).attr("fill-opacity", 0).on(\'mouseover\', function (d) {\n            fill(d, "gr1indicator", .3, 0, 100);\n            fill(d, "gr2indicator", .3, 0, 100);\n            fillThis(this, .3, 0, 100);\n            fill(d, \'grText\', .9, 0, 100);\n        }).on(\'mouseout\', function (d) {\n            fill(d, "gr1indicator", 0, 100, 500);\n            fill(d, "gr2indicator", 0, 100, 500);\n            fillThis(this, 0, 100, 500);\n            fill(d, \'grText\', 0, 100, 500);\n        }).on(\'click\', function (d) {\n            //d.group1 = !d.group1;      // This might be easier, but currently set in setColors()\n            setColors(d, gr1Color);\n            legend(gr1Color);\n            restart();\n        });\n\n        g.append("path").attr("id", append(\'gr1indicator\')).attr("d", arcInd1).style("fill", gr1Color) // something like: zparams.zgroup1.indexOf(node.name) > -1  ?  #FFFFFF : gr1Color)\n        .attr("fill-opacity", 0).on(\'mouseover\', function (d) {\n            fillThis(this, .3, 0, 100);\n            fill(d, "grArc", .1, 0, 100);\n            fill(d, \'grText\', .9, 0, 100);\n        }).on(\'mouseout\', function (d) {\n            fillThis(this, 0, 100, 500);\n            fill(d, "grArc", 0, 100, 500);\n            fill(d, \'grText\', 0, 100, 500);\n        }).on(\'click\', function (d) {\n            //d.group1 = !d.group1;      // This might be easier, but currently set in setColors()\n            setColors(d, gr1Color);\n            legend(gr1Color);\n            restart();\n        });\n\n        g.append("path").attr("id", append(\'gr2indicator\')).attr("d", arcInd2).style("fill", gr2Color) // something like: zparams.zgroup1.indexOf(node.name) > -1  ?  #FFFFFF : gr1Color)\n        .attr("fill-opacity", 0).on(\'mouseover\', function (d) {\n            fillThis(this, .3, 0, 100);\n            fill(d, "grArc", .1, 0, 100);\n            fill(d, \'grText\', .9, 0, 100);\n        }).on(\'mouseout\', function (d) {\n            fillThis(this, 0, 100, 500);\n            fill(d, "grArc", 0, 100, 500);\n            fill(d, \'grText\', 0, 100, 500);\n        }).on(\'click\', function (d) {\n            //d.group2 = !d.group2;      // This might be easier, but currently set in setColors()\n            setColors(d, gr2Color);\n            legend(gr2Color);\n            restart();\n        });\n\n        g.append("text").attr("id", append(\'grText\')).attr("x", 6).attr("dy", 11.5).attr("fill-opacity", 0).append("textPath").attr("xlink:href", append(\'#grArc\')).text("Groups");\n\n        g.append(\'svg:circle\').attr(\'class\', \'node\').attr(\'r\', function (d) {\n            return setPebbleRadius(d);\n        }).style(\'pointer-events\', \'inherit\').style(\'fill\', function (d) {\n            return d.nodeCol;\n        }).style(\'opacity\', "0.5").style(\'stroke\', function (d) {\n            return d3.rgb(d.strokeColor).toString();\n        }).classed(\'reflexive\', function (d) {\n            return d.reflexive;\n        }).on(\'dblclick\', function (_) {\n            d3.event.stopPropagation(); // stop click from bubbling\n            exports.summaryHold = summaryHold = true;\n        }).on(\'contextmenu\', function (d) {\n            // right click on node\n            d3.event.preventDefault();\n            d3.event.stopPropagation();\n\n            rightClickLast = true;\n            mousedown_node = d;\n            selected_node = mousedown_node === selected_node ? null : mousedown_node;\n            selected_link = null;\n\n            // reposition drag line\n            drag_line.style(\'marker-end\', \'url(#end-arrow)\').classed(\'hidden\', false).attr(\'d\', \'M\' + mousedown_node.x + \',\' + mousedown_node.y + \'L\' + mousedown_node.x + \',\' + mousedown_node.y);\n\n            svg.on(\'mousemove\', mousemove);\n            restart();\n        }).on(\'mouseup\', function (d) {\n            d3.event.stopPropagation();\n\n            if (rightClickLast) {\n                rightClickLast = false;\n                return;\n            }\n            if (!mousedown_node) return;\n\n            // needed by FF\n            drag_line.classed(\'hidden\', true).style(\'marker-end\', \'\');\n\n            // check for drag-to-self\n            mouseup_node = d;\n            if (mouseup_node === mousedown_node) {\n                resetMouseVars();\n                return;\n            }\n\n            // unenlarge target node\n            d3.select(this).attr(\'transform\', \'\');\n\n            // add link to graph (update if exists)\n            // NB: links are strictly source < target; arrows separately specified by booleans\n            var source, target, direction;\n            if (mousedown_node.id < mouseup_node.id) {\n                source = mousedown_node;\n                target = mouseup_node;\n                direction = \'right\';\n            } else {\n                source = mouseup_node;\n                target = mousedown_node;\n                direction = \'left\';\n            }\n\n            var link = links.filter(function (x) {\n                return x.source == source && x.target == target;\n            })[0];\n            if (link) {\n                link[direction] = true;\n            } else {\n                link = {\n                    source: source,\n                    target: target,\n                    left: false,\n                    right: false\n                };\n                link[direction] = true;\n                links.push(link);\n            }\n\n            // select new link\n            selected_link = link;\n            selected_node = null;\n            svg.on(\'mousemove\', null);\n\n            resetMouseVars();\n            restart();\n        });\n\n        // show node names\n        g.append(\'svg:text\').attr(\'x\', 0).attr(\'y\', 15).attr(\'class\', \'id\').text(function (d) {\n            return d.name;\n        });\n\n        // show summary stats on mouseover\n        // SVG doesn\'t support text wrapping, use html instead\n        g.selectAll("circle.node").on("mouseover", function (d) {\n            tabLeft(\'tab3\');\n            varSummary(d);\n            d.forefront = true;\n\n            byId(\'transformations\').setAttribute(\'style\', \'display:block\');\n            byId("transSel").selectedIndex = d.id;\n            transformVar = valueKey[d.id];\n\n            fill(d, "dvArc", .1, 0, 100);\n            fill(d, "dvText", .5, 0, 100);\n            fill(d, "grArc", .1, 0, 100);\n            fill(d, "grText", .5, 0, 100);\n            //fill(d, "gr1indicator", .1, 0, 100);\n            //fill(d, "gr1indicatorText", .1, 0, 100);\n            //fill(d, "gr2indicator", .1, 0, 100);\n            //fill(d, "gr2indicatorText", .1, 0, 100);\n\n            if (d.defaultNumchar == "numeric") {\n                fill(d, "nomArc", .1, 0, 100);\n                fill(d, "nomText", .5, 0, 100);\n            }\n            fill(d, "csArc", .1, 0, 100);\n            fill(d, "csText", .5, 0, 100);\n            fill(d, "timeArc", .1, 0, 100);\n            fill(d, "timeText", .5, 0, 100);\n\n            _mithril2.default.redraw();\n        }).on(\'mouseout\', function (d) {\n            d.forefront = false;\n            summaryHold || tabLeft(subset ? \'tab2\' : \'tab1\');\n            \'csArc csText timeArc timeText dvArc dvText nomArc nomText grArc grText\'.split(\' \').map(function (x) {\n                return fill(d, x, 0, 100, 500);\n            });\n            _mithril2.default.redraw();\n        });\n\n        // the transformation variable list is silently updated as pebbles are added/removed\n        d3.select("#transSel").selectAll(\'li\').remove();\n\n        d3.select("#transSel").selectAll(\'li\').data(nodes.map(function (x) {\n            return x.name;\n        })) // set to variables in model space as they\'re added\n        .enter().append("li").text(function (d) {\n            return d;\n        });\n\n        if (!d3m_mode) {\n            $(\'#transSel li\').click(function (evt) {\n                // if \'interaction\' is the selected function, don\'t show the function list again\n                if (selInteract) {\n                    var n = $(\'#tInput\').val().concat($(this).text());\n                    $(\'#tInput\').val(n);\n                    evt.stopPropagation();\n                    var t = transParse(n = n);\n                    if (!t) return;\n                    $(this).parent().fadeOut(100);\n                    transform(n = t.slice(0, t.length - 1), t = t[t.length - 1], typeTransform = false);\n                    return;\n                }\n\n                $(\'#tInput\').val($(this).text());\n                $(this).parent().fadeOut(100);\n                $(\'#transList\').fadeIn(100);\n                evt.stopPropagation();\n            });\n        };\n\n        // remove old nodes\n        circle.exit().remove();\n        force.start();\n    }\n\n    function mousedown(d) {\n        // prevent I-bar on drag\n        d3.event.preventDefault();\n        // because :active only works in WebKit?\n        svg.classed(\'active\', true);\n        if (d3.event.ctrlKey || mousedown_node || mousedown_link) return;\n        restart();\n    }\n\n    function mousemove(d) {\n        if (!mousedown_node) return;\n        // update drag line\n        drag_line.attr(\'d\', \'M\' + mousedown_node.x + \',\' + mousedown_node.y + \'L\' + d3.mouse(this)[0] + \',\' + d3.mouse(this)[1]);\n    }\n\n    function mouseup(d) {\n        if (mousedown_node) {\n            drag_line.classed(\'hidden\', true).style(\'marker-end\', \'\');\n        }\n        // because :active only works in WebKit?\n        svg.classed(\'active\', false);\n        // clear mouse event vars\n        resetMouseVars();\n    }\n\n    // app starts here\n    svg.attr(\'id\', function () {\n        return "whitespace".concat(myspace);\n    }).attr(\'height\', height).on(\'mousedown\', function () {\n        mousedown(this);\n    }).on(\'mouseup\', function () {\n        mouseup(this);\n    });\n\n    d3.select(window).on(\'click\', function () {\n        // all clicks will bubble here unless event.stopPropagation()\n        $(\'#transList\').fadeOut(100);\n        $(\'#transSel\').fadeOut(100);\n    });\n\n    restart(); // initializes force.layout()\n    fakeClick();\n\n    if (v2 & d3m_mode) {\n        var click_ev = document.createEvent("MouseEvents");\n        // initialize the event\n        click_ev.initEvent("click", true /* bubble */, true /* cancelable */);\n        // trigger the event\n        var clickID = "dvArc" + findNodeIndex(mytarget);\n        document.getElementById(clickID).dispatchEvent(click_ev);\n    }\n}\n\nvar find = function find($nodes, name) {\n    for (var i in $nodes) {\n        if ($nodes[i].name == name) return $nodes[i].id;\n    }\n};\n\n// returns id\nvar findNodeIndex = exports.findNodeIndex = function findNodeIndex(name, all) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n        for (var _iterator = allNodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var node = _step.value;\n\n            if (node.name === name) {\n                //cdb(\'Yes!\' + allNodes[i].id);\n                return all ? node : node.id;\n            }\n        }\n    } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n            }\n        } finally {\n            if (_didIteratorError) {\n                throw _iteratorError;\n            }\n        }\n    }\n};\n\nvar nodeIndex = function nodeIndex(nodeName) {\n    for (var i in nodes) {\n        if (nodes[i].name == nodeName) return i;\n    }\n};\n\nvar findNode = exports.findNode = function findNode(nodeName) {\n    for (var i in allNodes) {\n        if (allNodes[i].name == nodeName) return allNodes[i];\n    }\n};\n\n/*\n    Retrieve the variable list from the preprocess data.\n    This helps handle the new format and (temporarily)\n    the older format in production (rp 8.14.2017)\n */\nfunction getVariableData(jsonData) {\n    /* "new" response:\n    {\n        "dataset" : {...}\n        "variables" : {\n            "var1" : {...}, (etc)\n        }\n    }\n    "old" response\n    {\n         "var1" : {...},\n         (etc)\n    }*/\n    return jsonData.hasOwnProperty(\'variables\') ? jsonData.variables : jsonData;\n}\n\n// function called by force button\nfunction forceSwitch() {\n    forcetoggle = [forcetoggle[0] == \'true\' ? \'false\' : \'true\'];\n    if (forcetoggle[0] === "false") {\n        byId(\'btnForce\').setAttribute("class", "btn active");\n    } else {\n        byId(\'btnForce\').setAttribute("class", "btn btn-default");\n        fakeClick();\n    }\n}\n\nfunction helpmaterials(type) {\n    if (type == "video") {\n        var win = window.open("http://2ra.vn/demos/d3mintegrationdemo.mp4", \'_blank\');\n        win.focus();\n    } else {\n        var win = window.open("http://2ra.vn/papers/tworavens-d3mguide.pdf", \'_blank\');\n        win.focus();\n    }\n    console.log(type);\n}\n\nfunction lockDescription() {\n    locktoggle = locktoggle ? false : true;\n    var temp = void 0;\n    var i = void 0;\n    if (!locktoggle) {\n        document.getElementById(\'btnLock\').setAttribute("class", "btn btn-default");\n        temp = document.getElementById(\'rightContentArea\').querySelectorAll("p.item-lineout");\n        for (i = 0; i < temp.length; i++) {\n            temp[i].classList.remove("item-lineout");\n        }\n    } else {\n        document.getElementById(\'btnLock\').setAttribute("class", "btn active");\n        temp = document.getElementById(\'metrics\').querySelectorAll("p.item-default");\n        console.log(temp);\n        for (i = 0; i < temp.length; i++) {\n            temp[i].classList.add("item-lineout");\n        }\n        temp = document.getElementById(\'types\').querySelectorAll("p.item-default");\n        for (i = 0; i < temp.length; i++) {\n            temp[i].classList.add("item-lineout");\n        }\n        temp = document.getElementById(\'subtypes\').querySelectorAll("p.item-default");\n        for (i = 0; i < temp.length; i++) {\n            temp[i].classList.add("item-lineout");\n        }\n        temp = document.getElementById(\'outputs\').querySelectorAll("p.item-default");\n        for (i = 0; i < temp.length; i++) {\n            temp[i].classList.add("item-lineout");\n        }\n        fakeClick();\n    }\n}\n\nvar spliceLinksForNode = exports.spliceLinksForNode = function spliceLinksForNode(node) {\n    return links.filter(function (l) {\n        return l.source === node || l.target === node;\n    }).map(function (x) {\n        return links.splice(links.indexOf(x), 1);\n    });\n};\n\nfunction zPop() {\n    if (dataurl) zparams.zdataurl = dataurl;\n    zparams.zmodelcount = modelCount;\n    zparams.zedges = [];\n    zparams.zvars = [];\n    for (var j = 0; j < nodes.length; j++) {\n        //populate zvars array\n        zparams.zvars.push(nodes[j].name);\n        var temp = nodes[j].id;\n        zparams.zsetx[j] = allNodes[temp].setxvals;\n        zparams.zsubset[j] = allNodes[temp].subsetrange;\n    }\n    for (var _j2 = 0; _j2 < links.length; _j2++) {\n        //populate zedges array\n        //correct the source target ordering for Zelig\n        var srctgt = links[_j2].left == false ? [links[_j2].source.name, links[_j2].target.name] : [links[_j2].target.name, links[_j2].source.name];\n        zparams.zedges.push(srctgt);\n    }\n}\n\nfunction estimate(btn) {\n    if (!d3m_mode) {\n        var estimateSuccess = function estimateSuccess(btn, json) {\n            //  toggleRightButtons("all");\n            estimateLadda.stop(); // stop spinner\n            allResults.push(json);\n            cdb("json in: ", json);\n\n            if (!estimated) byId("results").removeChild(byId("resultsHolder"));\n\n            estimated = true;\n            d3.select("#results").style("display", "block");\n\n            d3.select("#resultsView").style("display", "block");\n\n            d3.select("#modelView").style("display", "block");\n\n            // programmatic click on Results button\n            $("#btnResults").trigger("click");\n\n            var model = "Model".concat(modelCount = modelCount + 1);\n\n            function modCol() {\n                d3.select("#modelView").selectAll("p").style(\'background-color\', hexToRgba(varColor));\n            }\n            modCol();\n\n            d3.select("#modelView").insert("p", ":first-child") // top stack for results\n            .attr("id", model).text(model).style(\'background-color\', hexToRgba(_plots.selVarColor)).on("click", function () {\n                var a = this.style.backgroundColor.replace(/\\s*/g, "");\n                var b = hexToRgba(_plots.selVarColor).replace(/\\s*/g, "");\n                if (a.substr(0, 17) == b.substr(0, 17)) return; // escape function if displayed model is clicked\n                modCol();\n                d3.select(this).style(\'background-color\', hexToRgba(_plots.selVarColor));\n                viz(this.id);\n            });\n\n            var rCall = [];\n            rCall[0] = json.call;\n            showLog("estimate", rCall);\n\n            viz(model);\n        };\n\n        var estimateFail = function estimateFail(btn) {\n            estimateLadda.stop(); // stop spinner\n            estimated = true;\n        };\n\n        var selectorSuccess = function selectorSuccess(btn, json) {\n            d3.select("#ticker").text("Suggested variables and percent improvement on RMSE: " + json.vars);\n            cdb("selectorSuccess: ", json);\n        };\n\n        var selectorFail = function selectorFail(btn) {\n            alert("Selector Fail");\n        };\n\n        if (production && zparams.zsessionid == \'\') {\n            alert("Warning: Data download is not complete. Try again soon.");\n            return;\n        }\n\n        zPop();\n        // write links to file & run R CMD\n        // package the output as JSON\n        // add call history and package the zparams object as JSON\n        zparams.callHistory = callHistory;\n        var jsonout = JSON.stringify(zparams);\n\n        var urlcall = rappURL + "zeligapp"; //base.concat(jsonout);\n        var solajsonout = "solaJSON=" + jsonout;\n        cdb("urlcall out: ", urlcall);\n        cdb("POST out: ", solajsonout);\n        console.log("estimate: ", solajsonout);\n\n        zparams.allVars = valueKey.slice(10, 25); // because the URL is too long...\n        jsonout = JSON.stringify(zparams);\n        var selectorurlcall = rappURL + "selectorapp";\n\n        estimateLadda.start(); // start spinner\n        makeCorsRequest(urlcall, btn, estimateSuccess, estimateFail, solajsonout);\n    } else if (swandive) {\n        var sendPipelineSuccess = function sendPipelineSuccess(btn, PipelineCreateResult) {\n            //rpc GetExecutePipelineResults(PipelineExecuteResultsRequest) returns (stream PipelineExecuteResult) {}\n            console.log(PipelineCreateResult);\n            estimateLadda.stop(); // stop spinner\n\n\n            $("#btnEstimate").removeClass("btn-success");\n            $("#btnEstimate").addClass("btn-default");\n            $("#btnEndSession").removeClass("btn-default");\n            $("#btnEndSession").addClass("btn-success");\n\n            var allPipelineInfo = {};\n            for (var i = 0; i < PipelineCreateResult.length; i++) {\n                if (PipelineCreateResult[i].pipelineId in allPipelineInfo) {\n                    allPipelineInfo[PipelineCreateResult[i].pipelineId] = Object.assign(allPipelineInfo[PipelineCreateResult[i].pipelineId], PipelineCreateResult[i]);\n                } else {\n                    allPipelineInfo[PipelineCreateResult[i].pipelineId] = PipelineCreateResult[i];\n                }\n            }\n            console.log(allPipelineInfo);\n            // to get all pipeline ids: Object.keys(allPipelineInfo)\n\n            //////////////////////////\n\n            function tabulate(data, columns, divid) {\n                var table = d3.select(divid).append(\'table\');\n                var thead = table.append(\'thead\');\n                var tbody = table.append(\'tbody\');\n\n                // append the header row\n                thead.append(\'tr\').selectAll(\'th\').data(columns).enter().append(\'th\').text(function (column) {\n                    return column;\n                });\n\n                // create a row for each object in the data\n                var rows = tbody.selectAll(\'tr\').data(data).enter().append(\'tr\').attr(\'class\', function (d, i) {\n                    if (i == 0) return \'item-select\';else return \'item-default\';\n                });\n\n                // create a cell in each row for each column\n                var cells = rows.selectAll(\'td\').data(function (row) {\n                    return columns.map(function (column) {\n                        return { column: column, value: row[column] };\n                    });\n                }).enter().append(\'td\').text(function (d) {\n                    return d.value;\n                }).on("click", function (d) {\n                    var myrow = this.parentElement;\n                    if (myrow.className == "item-select") {\n                        return;\n                    } else {\n                        d3.select(divid).select("tr.item-select").attr(\'class\', \'item-default\');\n                        d3.select(myrow).attr(\'class\', "item-select");\n                        if (divid == \'#setxRight\') {\n                            resultsplotinit(allPipelineInfo[myrow.firstChild.innerText], dvvalues);\n                        }\n                    }\n                });\n\n                // this is code to add a checkbox to each row of pipeline results table\n                /*\n                d3.select(divid).selectAll("tr")\n                .append("input")\n                .attr("type", "checkbox")\n                .style("float","right");\n                 */\n\n                return table;\n            }\n\n            var resultstable = [];\n            for (var key in allPipelineInfo) {\n                var myid = "";\n                var mymetric = "";\n                var myval = "";\n                var myscores = allPipelineInfo[key].pipelineInfo.scores;\n                for (var i = 0; i < myscores.length; i++) {\n                    //if(i==0) {myid=key;}\n                    //   else myid="";\n                    myid = key;\n                    mymetric = myscores[i].metric;\n                    myval = +myscores[i].value.toFixed(3);\n                    resultstable.push({ "PipelineID": myid, "Metric": mymetric, "Score": myval });\n                }\n            }\n\n            // render the table\n            tabulate(resultstable, [\'PipelineID\', \'Metric\', \'Score\'], \'#results\');\n            /////////////////////////\n\n            toggleRightButtons("all");\n            document.getElementById("btnResults").click();\n\n            // export pipeline request\n            exportpipeline(resultstable[1].PipelineID);\n\n            // I don\'t think we need these until we are handling streaming pipelines\n            // They are set up and called, but don\'t actually render anything for the user\n\n            // this is our function for the ListPipelines of API\n            listpipelines();\n\n            //let pipelineid = PipelineCreateResult.pipelineid;\n            var pipeline_ids = Object.keys(allPipelineInfo);\n            var PipelineExecuteResultsRequest = { context: context, pipeline_ids: pipeline_ids };\n            _jsonout = JSON.stringify(PipelineExecuteResultsRequest);\n            var urlcall = d3mURL + "/getexecutepipelineresults";\n            var solajsonout = "grpcrequest=" + _jsonout;\n            console.log("GetExecutePipelineResults: ");\n            console.log(solajsonout);\n            console.log(urlcall);\n\n            function getExecutePipeSuccess(btn, PipelineExecuteResult) {\n                console.log(PipelineExecuteResult);\n                // call to initialize the main plot\n                // dvvalues and predvals should eventually be contained in the pipeline object itself\n            }\n            function getExecutePipeFail(btn) {\n                console.log("GetExecutePipelineResults failed");\n            }\n            makeCorsRequest(urlcall, "nobutton", getExecutePipeSuccess, getExecutePipeFail, solajsonout);\n        };\n\n        var sendPipelineFail = function sendPipelineFail(btn) {\n            console.log("pipeline to django failed");\n        };\n\n        // d3m_mode and swandive is true\n        zPop();\n        zparams.callHistory = callHistory;\n        var _jsonout = JSON.stringify(zparams);\n        console.log(_jsonout);\n\n        var myvki = valueKey.indexOf(mytarget);\n        if (myvki != -1) {\n            valueKey.splice(myvki, 1);\n        }\n\n        var context = apiSession(zparams.zsessionid);\n        var uri = { features: zparams.zd3mdata, target: zparams.zd3mtarget };\n\n        var trainFeatures = apiFeatureShortPath(valueKey, uri.features); // putting in short paths (no filename) for current API usage\n        var targetFeatures = apiFeatureShortPath(mytarget, uri.target); // putting in short paths (no filename) for current API usage\n\n        var task = d3mTaskType[d3mProblemDescription.taskType][1];\n        var taskSubtype = d3mTaskSubtype[d3mProblemDescription.taskSubtype][1];\n        var output = d3mOutputType[d3mProblemDescription.outputType][1];\n        var metrics = [d3mMetrics[d3mProblemDescription.metric][1]];\n        var taskDescription = d3mProblemDescription.taskDescriptionription;\n        var maxPipelines = 5; //user to specify this eventually?\n\n        var PipelineCreateRequest = { context: context, trainFeatures: trainFeatures, task: task, taskSubtype: taskSubtype, taskDescription: taskDescription, output: output, metrics: metrics, targetFeatures: targetFeatures, maxPipelines: maxPipelines };\n\n        var _jsonout = JSON.stringify(PipelineCreateRequest);\n\n        var _urlcall = d3mURL + "/createpipeline";\n        var solajsonout = "grpcrequest=" + _jsonout;\n\n        console.log(_urlcall);\n        console.log(solajsonout);\n\n\n        estimateLadda.start(); // start spinner\n        makeCorsRequest(_urlcall, "nobutton", sendPipelineSuccess, sendPipelineFail, solajsonout);\n    } else {\n        var createPipelineSuccess = function createPipelineSuccess(btn, json) {\n            estimateLadda.stop(); // stop spinner\n\n            $("#btnEstimate").removeClass("btn-success");\n            $("#btnEstimate").addClass("btn-default");\n            $("#btnEndSession").removeClass("btn-default");\n            $("#btnEndSession").addClass("btn-success");\n\n            var trainFeatures = apiFeatureShortPath(json.predictors, _uri.features); // putting in short paths (no filename) for current API usage\n            var targetFeatures = apiFeatureShortPath(json.depvar, _uri.target); // putting in short paths (no filename) for current API usage\n            var task = d3mTaskType[d3mProblemDescription.taskType][1];\n            var taskSubtype = d3mTaskSubtype[d3mProblemDescription.taskSubtype][1];\n            var output = d3mOutputType[d3mProblemDescription.outputType][1];\n            var metrics = [d3mMetrics[d3mProblemDescription.metric][1]];\n            var taskDescription = d3mProblemDescription.taskDescriptionription;\n            var maxPipelines = 5; //user to specify this eventually?\n\n            setxTable(json.predictors);\n            var dvvalues = json.dvvalues;\n\n            var PipelineCreateRequest = { context: _context, trainFeatures: trainFeatures, task: task, taskSubtype: taskSubtype, taskDescription: taskDescription, output: output, metrics: metrics, targetFeatures: targetFeatures, maxPipelines: maxPipelines };\n\n            var jsonout = JSON.stringify(PipelineCreateRequest);\n\n            var urlcall = d3mURL + "/createpipeline";\n            var solajsonout = "grpcrequest=" + jsonout;\n\n            console.log(urlcall);\n            console.log(solajsonout);\n            function sendPipelineSuccess(btn, PipelineCreateResult) {\n                //rpc GetExecutePipelineResults(PipelineExecuteResultsRequest) returns (stream PipelineExecuteResult) {}\n                console.log(PipelineCreateResult);\n\n                var allPipelineInfo = {};\n                for (var i = 0; i < PipelineCreateResult.length; i++) {\n                    if (PipelineCreateResult[i].pipelineId in allPipelineInfo) {\n                        allPipelineInfo[PipelineCreateResult[i].pipelineId] = Object.assign(allPipelineInfo[PipelineCreateResult[i].pipelineId], PipelineCreateResult[i]);\n                    } else {\n                        allPipelineInfo[PipelineCreateResult[i].pipelineId] = PipelineCreateResult[i];\n                    }\n                }\n                console.log(allPipelineInfo);\n                // to get all pipeline ids: Object.keys(allPipelineInfo)\n\n                //////////////////////////\n\n                function tabulate(data, columns, divid) {\n                    var table = d3.select(divid).append(\'table\');\n                    var thead = table.append(\'thead\');\n                    var tbody = table.append(\'tbody\');\n\n                    // append the header row\n                    thead.append(\'tr\').selectAll(\'th\').data(columns).enter().append(\'th\').text(function (column) {\n                        return column;\n                    });\n\n                    // create a row for each object in the data\n                    var rows = tbody.selectAll(\'tr\').data(data).enter().append(\'tr\').attr(\'class\', function (d, i) {\n                        if (i == 0) return \'item-select\';else return \'item-default\';\n                    });\n\n                    // create a cell in each row for each column\n                    var cells = rows.selectAll(\'td\').data(function (row) {\n                        return columns.map(function (column) {\n                            return { column: column, value: row[column] };\n                        });\n                    }).enter().append(\'td\').text(function (d) {\n                        return d.value;\n                    }).on("click", function (d) {\n                        var myrow = this.parentElement;\n                        if (myrow.className == "item-select") {\n                            return;\n                        } else {\n                            d3.select(divid).select("tr.item-select").attr(\'class\', \'item-default\');\n                            d3.select(myrow).attr(\'class\', "item-select");\n                            if (divid == \'#setxRight\') {\n                                resultsplotinit(allPipelineInfo[myrow.firstChild.innerText], dvvalues);\n                            }\n                        }\n                    });\n\n                    // this is code to add a checkbox to each row of pipeline results table\n                    /*\n                    d3.select(divid).selectAll("tr")\n                    .append("input")\n                    .attr("type", "checkbox")\n                    .style("float","right");\n                     */\n\n                    return table;\n                }\n\n                var resultstable = [];\n                for (var key in allPipelineInfo) {\n                    // don\'t report the pipeline to user if it has failed\n                    if (allPipelineInfo[key].responseInfo.status.details == "Pipeline Failed") {\n                        continue;\n                    }\n                    var myid = "";\n                    var mymetric = "";\n                    var myval = "";\n                    var myscores = allPipelineInfo[key].pipelineInfo.scores;\n                    for (var i = 0; i < myscores.length; i++) {\n                        //if(i==0) {myid=key;}\n                        //   else myid="";\n                        myid = key;\n                        mymetric = myscores[i].metric;\n                        myval = +myscores[i].value.toFixed(3);\n                        resultstable.push({ "PipelineID": myid, "Metric": mymetric, "Score": myval });\n                    }\n                }\n\n                // render the table\n                tabulate(resultstable, [\'PipelineID\', \'Metric\', \'Score\'], \'#results\');\n                tabulate(resultstable, [\'PipelineID\', \'Metric\', \'Score\'], \'#setxRight\');\n                /////////////////////////\n\n                toggleRightButtons("all");\n                document.getElementById("btnResults").click();\n\n                // this initializes the main\n                // this piece here is the first pipeline through: allPipelineInfo[resultstable[1].PipelineID]\n                //resultsplotinit(allPipelineInfo[resultstable[1].PipelineID], dvvalues);\n                exportpipeline(resultstable[1].PipelineID);\n\n                // I don\'t think we need these until we are handling streaming pipelines\n                // They are set up and called, but don\'t actually render anything for the user\n\n                // this is our function for the ListPipelines of API\n                listpipelines();\n\n                //let pipelineid = PipelineCreateResult.pipelineid;\n                var pipeline_ids = Object.keys(allPipelineInfo);\n                var PipelineExecuteResultsRequest = { context: _context, pipeline_ids: pipeline_ids };\n                jsonout = JSON.stringify(PipelineExecuteResultsRequest);\n                var urlcall = d3mURL + "/getexecutepipelineresults";\n                var solajsonout = "grpcrequest=" + jsonout;\n                console.log("GetExecutePipelineResults: ");\n                console.log(solajsonout);\n                console.log(urlcall);\n\n                function getExecutePipeSuccess(btn, PipelineExecuteResult) {\n                    console.log(PipelineExecuteResult);\n                    // call to initialize the main plot\n                    // dvvalues and predvals should eventually be contained in the pipeline object itself\n                }\n                function getExecutePipeFail(btn) {\n                    console.log("GetExecutePipelineResults failed");\n                }\n                makeCorsRequest(urlcall, "nobutton", getExecutePipeSuccess, getExecutePipeFail, solajsonout);\n            }\n\n            function sendPipelineFail(btn) {\n                console.log("pipeline to django failed");\n            }\n\n            makeCorsRequest(urlcall, "nobutton", sendPipelineSuccess, sendPipelineFail, solajsonout);\n        };\n\n        var createPipelineFail = function createPipelineFail(btn) {\n            estimateLadda.stop(); // stop spinner\n            estimated = true;\n        };\n\n        // we are in d3m_mode no swandive\n        // rpc CreatePipelines(PipelineCreateRequest) returns (stream PipelineCreateResult) {}\n        zPop();\n        zparams.callHistory = callHistory;\n        var jsonout = JSON.stringify(zparams);\n        console.log(jsonout);\n\n        var _context = apiSession(zparams.zsessionid);\n        var _uri = { features: zparams.zd3mdata, target: zparams.zd3mtarget };\n\n        var urlcall = rappURL + "pipelineapp";\n\n        var solajsonout = "solaJSON=" + jsonout;\n        cdb("urlcall out: ", urlcall);\n        cdb("POST out: ", solajsonout);\n\n        estimateLadda.start(); // start spinner\n        makeCorsRequest(urlcall, btn, createPipelineSuccess, createPipelineFail, solajsonout);\n    }\n}\n\nfunction runPreprocess(dataloc, targetloc, datastub) {\n    var url = rappURL + \'preprocessapp\';\n    console.log("GOING TO RUN THE PREPROCESSAPP");\n    var json = JSON.stringify({ data: dataloc, target: targetloc, datastub: datastub }); //, preprocess: preprocessloc});\n    console.log(\'urlcall out: \', url);\n    console.log(\'POST out: \', json);\n    var data = new FormData();\n    data.append(\'solaJSON\', json);\n    return _mithril2.default.request({ method: \'POST\', url: url, data: data, async: false }).then(function (data) {\n        console.log(\'json in RIGHT HERE: \', data);\n\n        //two lines from readPreprocess()\n        priv = data.dataset.private || priv;\n        Object.keys(data.variables).forEach(function (k) {\n            return preprocess[k] = data.variables[k];\n        });\n\n        return data;\n    }, function (_) {\n        console.log(\'preprocess failed\');\n        alert(\'preprocess failed. ending user session.\');\n        endsession();\n    });\n}\n\nvar ta2stuff = exports.ta2stuff = function ta2stuff(_) {\n    return console.log(d3mProblemDescription);\n};\n\nfunction dataDownload() {\n    zPop();\n    // write links to file & run R CMD\n\n    //package the output as JSON\n    // add call history and package the zparams object as JSON\n    var jsonout = JSON.stringify(zparams);\n    var btn = "nobutton";\n\n    var urlcall = rappURL + "dataapp";\n    var solajsonout = "solaJSON=" + jsonout;\n    cdb("urlcall out: ", urlcall);\n    cdb("POST out: ", solajsonout);\n\n    var downloadSuccess = function downloadSuccess(btn, json) {\n        console.log(\'datadownload: \', json);\n        cdb(\'dataDownload json in: \', json);\n        zparams.zsessionid = json.sessionid[0];\n        // set link URL\n        byId("logID").href = \'\' + (production ? rappURL + \'log_dir/log_\' : \'rook/log_\') + zparams.zsessionid + \'.txt\';\n    };\n    var downloadFail = function downloadFail(_) {\n        return cdb(\'Data have not been downloaded\');\n    };\n    makeCorsRequest(urlcall, btn, downloadSuccess, downloadFail, solajsonout);\n}\n\nfunction viz(mym) {\n    var mym = +mym.substr(5, 5) - 1;\n\n    function removeKids(parent) {\n        while (parent.firstChild) {\n            parent.removeChild(parent.firstChild);\n        }\n    }\n\n    removeKids(byId("resultsView"));\n\n    var json = allResults[mym];\n\n    // pipe in figures to right panel\n    var filelist = new Array();\n    for (var i in json.images) {\n        var zfig = document.createElement("img");\n        zfig.setAttribute("src", json.images[i]);\n        zfig.setAttribute(\'width\', 200);\n        zfig.setAttribute(\'height\', 200);\n        byId("resultsView").appendChild(zfig);\n    }\n\n    // write the results table\n    var resultsArray = [];\n    for (var key in json.sumInfo) {\n        if (key == \'colnames\') continue;\n        resultsArray.push(json.sumInfo[key]);\n    }\n\n    var table = d3.select("#resultsView").append("p").append("table");\n\n    var thead = table.append("thead");\n    thead.append("tr").selectAll("th").data(json.sumInfo.colnames).enter().append("th").text(function (d) {\n        return d;\n    });\n\n    var tbody = table.append("tbody");\n    tbody.selectAll("tr").data(resultsArray).enter().append("tr").selectAll("td").data(function (d) {\n        return d;\n    }).enter().append("td").text(function (d) {\n        var myNum = Number(d);\n        if (isNaN(myNum)) return d;\n        return myNum.toPrecision(3);\n    }).on("mouseover", function () {\n        d3.select(this).style("background-color", "aliceblue");\n    }) // for no discernable reason\n    .on("mouseout", function () {\n        d3.select(this).style("background-color", "#F9F9F9");\n    }); //(but maybe we\'ll think of one)\n\n    d3.select("#resultsView").append("p").html(function () {\n        return "<b>Formula: </b>".concat(json.call[0]);\n    });\n\n    _mithril2.default.redraw();\n}\n\n// parses the transformation input. variable names are often nested inside one another, e.g., ethwar, war, wars, and so this is handled\nfunction transParse(n) {\n    var out2 = [];\n    var t2 = n;\n    var k2 = 0;\n    var subMe2 = "_transvar".concat(k2);\n    var indexed = [];\n\n    // out2 is all matched variables, indexed is an array, each element is an object that contains the matched variables starting index and finishing index.  e.g., n="wars+2", out2=[war, wars], indexed=[{0,2},{0,3}]\n    for (var i in valueKey) {\n        var m2 = n.match(valueKey[i]);\n        if (m2 != null) out2.push(m2[0]);\n\n        var re = new RegExp(valueKey[i], "g");\n        var s = n.search(re);\n        if (s != -1) indexed.push({ from: s, to: s + valueKey[i].length });\n    }\n\n    // nested loop not good, but indexed is not likely to be very large.\n    // if a variable is nested, it is removed from out2\n    // notice, loop is backwards so that index changes don\'t affect the splice\n    cdb("indexed ", indexed);\n    for (var i = indexed.length - 1; i > -1; i--) {\n        for (var j = indexed.length - 1; j > -1; j--) {\n            if (i === j) continue;\n            if (indexed[i].from >= indexed[j].from & indexed[i].to <= indexed[j].to) {\n                cdb(i, " is nested in ", j);\n                out2.splice(i, 1);\n            }\n        }\n    }\n\n    for (var i in out2) {\n        t2 = t2.replace(out2[i], subMe2); //something that\'ll never be a variable name\n        k2 = k2 + 1;\n        subMe2 = "_transvar".concat(k2);\n    }\n\n    if (out2.length > 0) {\n        out2.push(t2);\n        cdb("new out ", out2);\n        return out2;\n    } else {\n        alert("No variable name found. Perhaps check your spelling?");\n        return null;\n    }\n}\n\n/**\n  n = name of column/node\n  t = selected transformation\n */\nfunction transform(n, t, typeTransform) {\n    if (production && zparams.zsessionid == "") {\n        alert("Warning: Data download is not complete. Try again soon.");\n        return;\n    }\n    if (!typeTransform) t = t.replace("+", "_plus_"); // can\'t send the plus operator\n\n    cdb(\'name of col: \' + n);\n    cdb(\'transformation: \' + t);\n\n    var btn = byId(\'btnEstimate\');\n\n    // find the node by name\n    var myn = findNodeIndex(n[0], true);\n\n    if (typeof myn === "undefined") {\n        myn = findNodeIndex(n, true);\n    }\n\n    var outtypes = {\n        varnamesTypes: n,\n        interval: myn.interval,\n        numchar: myn.numchar,\n        nature: myn.nature,\n        binary: myn.binary\n    };\n\n    cdb(myn);\n    // if typeTransform but we already have the metadata\n    if (typeTransform) {\n        if (myn.nature == "nominal" & typeof myn.plotvalues !== "undefined") {\n            myn.plottype = "bar";\n            (0, _plots.barsNode)(myn);\n            panelPlots();\n            return;\n        } else if (myn.nature != "nominal" & typeof myn.plotx !== "undefined") {\n            myn.plottype = "continuous";\n            (0, _plots.densityNode)(myn);\n            panelPlots();\n            return;\n        }\n    }\n\n    //package the output as JSON\n    var transformstuff = {\n        zdataurl: dataurl,\n        zvars: myn.name,\n        zsessionid: zparams.zsessionid,\n        transform: t,\n        callHistory: callHistory,\n        typeTransform: typeTransform,\n        typeStuff: outtypes\n    };\n    var jsonout = JSON.stringify(transformstuff);\n    var urlcall = rappURL + "transformapp";\n    var solajsonout = "solaJSON=" + jsonout;\n    cdb("urlcall out: " + urlcall);\n    cdb("POST out: " + solajsonout);\n\n    function transformSuccess(btn, json) {\n        estimateLadda.stop();\n        cdb("json in: " + JSON.stringify(json));\n\n        // Is this a typeTransform?\n        if (json.typeTransform[0]) {\n            // Yes. We\'re updating an existing node\n            d3.json(json.url, function (err, data) {\n                if (err) return console.warn(err);\n                var node = void 0;\n                for (var key in data) {\n                    node = findNodeIndex(key, true);\n                    if (!node) continue;\n                    jQuery.extend(true, node, data[key]);\n                    node.plottype === "continuous" ? (0, _plots.densityNode)(node) : node.plottype === "bar" ? (0, _plots.barsNode)(node) : null;\n                }\n                fakeClick();\n                panelPlots();\n                node && cdb(node);\n            });\n        } else {\n            /* No, we have a new node here--e.g. the transformed column\n                 example response: {\n                 "call":["t_year_2"],\n                 "url":["data/preprocessSubset_BACCBC78-7DD9-4482-B31D-6EB01C3A0C95.txt"],\n                 "trans":["year","_transvar0^2"],\n                 "typeTransform":[false]\n               }\n            */\n            callHistory.push({\n                func: "transform",\n                zvars: n,\n                transform: t\n            });\n\n            var subseted = false;\n            var rCall = [];\n\n            rCall[0] = json.call;\n            var newVar = rCall[0][0];\n\n            trans.push(newVar);\n\n            // Read the preprocess file containing values\n            // for the transformed variable\n            //\n            d3.json(json.url, function (error, json) {\n                if (error) return console.warn(error);\n\n                var jsondata = getVariableData(json);\n\n                for (var key in jsondata) {\n                    var myIndex = findNodeIndex(key);\n                    if (typeof myIndex !== "undefined") {\n                        alert("Invalid transformation: this variable name already exists.");\n                        return;\n                    }\n                    // add transformed variable to the current space\n                    var i = allNodes.length; // get new index\n                    var obj1 = {\n                        id: i,\n                        reflexive: false,\n                        name: key,\n                        labl: "transformlabel",\n                        data: [5, 15, 20, 0, 5, 15, 20],\n                        count: [.6, .2, .9, .8, .1, .3, .4],\n                        nodeCol: colors(i),\n                        baseCol: colors(i),\n                        strokeColor: _plots.selVarColor,\n                        strokeWidth: "1",\n                        subsetplot: false,\n                        subsetrange: ["", ""],\n                        setxplot: false,\n                        setxvals: ["", ""],\n                        grayout: false,\n                        defaultInterval: jsondata[key].interval,\n                        defaultNumchar: jsondata[key].numchar,\n                        defaultNature: jsondata[key].nature,\n                        defaultBinary: jsondata[key].binary\n                    };\n\n                    jQuery.extend(true, obj1, jsondata[key]);\n                    allNodes.push(obj1);\n\n                    valueKey.push(newVar);\n                    nodes.push(allNodes[i]);\n                    fakeClick();\n                    panelPlots();\n\n                    if (allNodes[i].plottype === "continuous") {\n                        (0, _plots.densityNode)(allNodes[i]);\n                    } else if (allNodes[i].plottype === "bar") {\n                        (0, _plots.barsNode)(allNodes[i]);\n                    }\n\n                    _mithril2.default.redraw();\n                }\n            });\n\n            showLog(\'transform\', rCall);\n        }\n    }\n\n    function transformFail(btn) {\n        alert("transform fail");\n        estimateLadda.stop();\n    }\n\n    estimateLadda.start(); // start spinner\n    makeCorsRequest(urlcall, btn, transformSuccess, transformFail, solajsonout);\n}\n\n// below from http://www.html5rocks.com/en/tutorials/cors/ for cross-origin resource sharing\n// Create the XHR object.\nfunction createCORSRequest(method, url, callback) {\n    var xhr = new XMLHttpRequest();\n    if ("withCredentials" in xhr) {\n        // XHR for Chrome/Firefox/Opera/Safari.\n        xhr.open(method, url, true);\n    } else if (typeof XDomainRequest != "undefined") {\n        // XDomainRequest for IE.\n        xhr = new XDomainRequest();\n        xhr.open(method, url);\n    } else {\n        // CORS not supported.\n        xhr = null;\n    }\n    // xhr.setRequestHeader(\'Content-Type\', \'text/plain\');\n    xhr.setRequestHeader(\'Content-Type\', \'application/x-www-form-urlencoded\');\n    return xhr;\n}\n\n// Make the actual CORS request.\nfunction makeCorsRequest(url, btn, callback, warningcallback, jsonstring) {\n    var xhr = createCORSRequest(\'POST\', url);\n    if (!xhr) {\n        alert(\'CORS not supported\');\n        return;\n    }\n    // Response handlers for asynchronous load\n    // onload or onreadystatechange?\n\n    xhr.onload = function () {\n        var text = xhr.responseText;\n        cdb("text ", text);\n\n        try {\n            var json = JSON.parse(text); // should wrap in try / catch\n            var names = Object.keys(json);\n        } catch (err) {\n            estimateLadda.stop();\n            selectLadda.stop();\n            cdb(err);\n            alert(\'Error: Could not parse incoming JSON.\');\n        }\n\n        if (names[0] == "warning") {\n            warningcallback(btn);\n            alert("Warning: " + json.warning);\n        } else {\n            callback(btn, json);\n        }\n    };\n    xhr.onerror = function () {\n        // note: xhr.readystate should be 4 and status should be 200. a status of 0 occurs when the url is too large\n        xhr.status == 0 ? alert(\'There was an error making the request. xmlhttprequest status is 0.\') : xhr.readyState != 4 ? alert(\'There was an error making the request. xmlhttprequest readystate is not 4.\') : alert(\'Woops, there was an error making the request.\');\n        cdb(xhr);\n        estimateLadda.stop();\n        selectLadda.stop();\n    };\n    xhr.send(jsonstring);\n}\n\nvar legend = exports.legend = function legend(_) {\n    borderState();\n    _mithril2.default.redraw();\n};\n\n// programmatically deselect every selected variable\nfunction erase() {\n    leftpanelMedium();\n    rightpanelMedium();\n    tabLeft(\'tab1\');\n    jQuery.fn.d3Click = function () {\n        this.children().each(function (i, e) {\n            var mycol = d3.rgb(this.style.backgroundColor);\n            if (mycol.toString() === varColor.toString()) return;\n            var evt = document.createEvent("MouseEvents");\n            evt.initMouseEvent("click", true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);\n            e.dispatchEvent(evt);\n        });\n    };\n    $("#varList").d3Click();\n}\n\n// http://www.tutorials2learn.com/tutorials/scripts/javascript/xml-parser-javascript.html\nfunction loadXMLDoc(XMLname) {\n    var xmlDoc;\n    if (window.XMLHttpRequest) {\n        xmlDoc = new window.XMLHttpRequest();\n        xmlDoc.open("GET", XMLname, false);\n        xmlDoc.send("");\n        return xmlDoc.responseXML;\n    }\n    // IE 5 and IE 6\n    else if (ActiveXObject("Microsoft.XMLDOM")) {\n            xmlDoc = new ActiveXObject("Microsoft.XMLDOM");\n            xmlDoc.async = false;\n            xmlDoc.load(XMLname);\n            return xmlDoc;\n        }\n    alert("Error loading document!");\n}\n\nfunction tabLeft(tab) {\n    byId(\'tab1\').style.display = \'none\';\n    byId(\'tab2\').style.display = \'none\';\n    byId(\'tab3\').style.display = \'none\';\n    byId(tab).style.display = \'block\';\n    if (tab != \'tab3\') {\n        exports.subset = subset = tab == \'tab2\';\n        exports.summaryHold = summaryHold = false;\n    }\n    exports.lefttab = lefttab = tab;\n}\n\nfunction tabRight(tab) {\n    var select = function select(cls) {\n        var panel = d3.select("#rightpanel");\n        return cls ? panel.attr(\'class\', cls) : panel.attr(\'class\');\n    };\n    var cls = "sidepanel container clearfix";\n    var toggleR = function toggleR() {\n        select(function () {\n            var expand = cls + \' expandpanel\';\n            return this.getAttribute("class") === expand ? cls : expand;\n        });\n    };\n    var toggleRFull = function toggleRFull() {\n        select(function () {\n            var expand = cls + \' expandpanelfull\';\n            return this.getAttribute("class") === expand ? cls : expand;\n        });\n    };\n    if (tab === "btnModels") select(cls);else if (tab === "btnSetx") righttab === "btnSetx" || select() === cls && toggleRFull();else if (tab === "btnResults") !estimated ? select(cls) : righttab === "btnResults" || select() === cls && toggleR();\n    exports.righttab = righttab = tab;\n}\n\nvar summary = exports.summary = { data: [] };\n\nfunction varSummary(d) {\n    var t1 = \'Mean:, Median:, Most Freq:, Occurrences:, Median Freq:, Occurrences:, Least Freq:, Occurrences:, Std Dev:, Minimum:, Maximum:, Invalid:, Valid:, Uniques:, Herfindahl\'.split(\', \');\n\n    var rint = d3.format(\'r\');\n    var str = function str(x, p) {\n        return (+x).toPrecision(p || 4).toString();\n    };\n    var t2 = priv && d.meanCI ? [str(d.mean, 2) + \' (\' + str(d.meanCI.lowerBound, 2) + \' - \' + str(d.meanCI.upperBound, 2) + \')\', str(d.median), d.mode, rint(d.freqmode), d.mid, rint(d.freqmid), d.fewest, rint(d.freqfewest), str(d.sd), str(d.min), str(d.max), rint(d.invalid), rint(d.valid), rint(d.uniques), str(d.herfindahl)] : [str(d.mean), str(d.median), d.mode, rint(d.freqmode), d.mid, rint(d.freqmid), d.fewest, rint(d.freqfewest), str(d.sd), str(d.min), str(d.max), rint(d.invalid), rint(d.valid), rint(d.uniques), str(d.herfindahl)];\n\n    summary.data = [];\n    t1.forEach(function (e, i) {\n        return !t2[i].includes(\'NaN\') && t2[i] != \'NA\' && t2[i] != \'\' && summary.data.push([e, t2[i]]);\n    });\n\n    summary.name = d.name;\n    summary.labl = d.labl;\n\n    d3.select(\'#tab3\').selectAll(\'svg\').remove();\n\n    if (!d.plottype) return;\n    d.plottype == \'continuous\' ? (0, _plots.density)(d, \'varSummary\', priv) : d.plottype == "bar" ? (0, _plots.bars)(d, \'varSummary\', priv) : d3.select("#tab3") // no graph to draw, but still need to remove previous graph\n    .selectAll("svg").remove();\n}\n\nvar popoverContent = exports.popoverContent = function popoverContent(d) {\n    if (swandive) return;\n    var text = \'\';\n    var _ref2 = [d3.format(\'r\'), function (val, int) {\n        return (+val).toPrecision(int).toString();\n    }],\n        rint = _ref2[0],\n        prec = _ref2[1];\n\n    var div = function div(field, name, val) {\n        if (field != \'NA\') text += \'<div class=\\\'form-group\\\'><label class=\\\'col-sm-4 control-label\\\'>\' + name + \'</label><div class=\\\'col-sm-6\\\'><p class=\\\'form-control-static\\\'>\' + (val || field) + \'</p></div></div>\';\n    };\n    d.labl != \'\' && div(d.labl, \'Label\');\n    div(d.mean, \'Mean\', priv && d.meanCI ? prec(d.mean, 2) + \' (\' + prec(d.meanCI.lowerBound, 2) + \' - \' + prec(d.meanCI.upperBound, 2) + \')\' : prec(d.mean, 4));\n    div(d.median, \'Median\', prec(d.median, 4));\n    div(d.mode, \'Most Freq\');\n    div(d.freqmode, \'Occurrences\', rint(d.freqmode));\n    div(d.mid, \'Median Freq\');\n    div(d.freqmid, \'Occurrences\', rint(d.freqmid));\n    div(d.fewest, \'Least Freq\');\n    div(d.freqfewest, \'Occurrences\', rint(d.freqfewest));\n    div(d.sd, \'Stand Dev\', prec(d.sd, 4));\n    div(d.max, \'Maximum\', prec(d.max, 4));\n    div(d.min, \'Minimum\', prec(d.min, 4));\n    div(d.invalid, \'Invalid\', rint(d.invalid));\n    div(d.valid, \'Valid\', rint(d.valid));\n    div(d.uniques, \'Uniques\', rint(d.uniques));\n    div(d.herfindahl, \'Herfindahl\', prec(d.herfindahl, 4));\n    return text;\n};\n\nfunction popupX(d) {\n    var tsf = d3.format(".4r");\n    var rint = d3.format("r");\n    //Create the tooltip label\n    d3.select("#tooltip").style("left", tempX + "px").style("top", tempY + "px").select("#tooltiptext").html("<div class=\'form-group\'><label class=\'col-sm-4 control-label\'>Mean</label><div class=\'col-sm-6\'><p class=\'form-control-static\'>" + tsf(d.mean) + "</p></div></div>" + "<div class=\'form-group\'><label class=\'col-sm-4 control-label\'>Median</label><div class=\'col-sm-6\'><p class=\'form-control-static\'>" + tsf(d.median) + "</p></div></div>" + "<div class=\'form-group\'><label class=\'col-sm-4 control-label\'>Mode</label><div class=\'col-sm-6\'><p class=\'form-control-static\'>" + d.mode + "</p></div></div>" + "<div class=\'form-group\'><label class=\'col-sm-4 control-label\'>Stand Dev</label><div class=\'col-sm-6\'><p class=\'form-control-static\'>" + tsf(d.sd) + "</p></div></div>" + "<div class=\'form-group\'><label class=\'col-sm-4 control-label\'>Maximum</label><div class=\'col-sm-6\'><p class=\'form-control-static\'>" + tsf(d.max) + "</p></div></div>" + "<div class=\'form-group\'><label class=\'col-sm-4 control-label\'>Minimum</label><div class=\'col-sm-6\'><p class=\'form-control-static\'>" + tsf(d.min) + "</p></div></div>" + "<div class=\'form-group\'><label class=\'col-sm-4 control-label\'>Valid</label><div class=\'col-sm-6\'><p class=\'form-control-static\'>" + rint(d.valid) + "</p></div></div>" + "<div class=\'form-group\'><label class=\'col-sm-4 control-label\'>Invalid</label><div class=\'col-sm-6\'><p class=\'form-control-static\'>" + rint(d.invalid) + "</p></div></div>");\n}\n\nfunction panelPlots() {\n    if (d3m_mode) {\n        document.getElementById(\'btnSubset\').classList.add(\'noshow\');\n    }\n    // build arrays from nodes in main\n    var vars = [];\n    var ids = [];\n    nodes.forEach(function (n) {\n        vars.push(n.name.replace(/\\(|\\)/g, \'\'));\n        ids.push(n.id);\n    });\n\n    //remove all plots, could be smarter here\n    d3.select(\'#setxLeft\').selectAll(\'svg\').remove();\n    d3.select(\'#tab2\').selectAll(\'svg\').remove();\n    for (var i = 0; i < vars.length; i++) {\n        if (allNodes[ids[i]].valid == 0) // this was a silent error... very frustrating...\n            continue;\n        var node = allNodes[ids[i]];\n        node.setxplot = false;\n        node.subsetplot = false;\n        if (node.plottype === "continuous" & node.setxplot == false) {\n            node.setxplot = true;\n            (0, _plots.density)(node, div = "setxLeft", priv);\n            node.subsetplot = true;\n            (0, _plots.density)(node, div = "subset", priv);\n        } else if (node.plottype === "bar" & node.setxplot == false) {\n            node.setxplot = true;\n            (0, _plots.bars)(node, div = "setxLeft", priv);\n            node.subsetplot = true;\n            (0, _plots.barsSubset)(node);\n        }\n    }\n\n    d3.select("#setxLeft").selectAll("svg").each(function () {\n        d3.select(this);\n        var regstr = /(.+)_setxLeft_(\\d+)/;\n        var myname = regstr.exec(this.id);\n        var nodeid = myname[2];\n        myname = myname[1];\n        if (!vars.includes(myname)) {\n            allNodes[nodeid].setxplot = false;\n            var temp = "#".concat(myname, "_setxLeft_", nodeid);\n            d3.select(temp).remove();\n            allNodes[nodeid].subsetplot = false;\n            temp = "#".concat(myname, "_tab2_", nodeid);\n            d3.select(temp).remove();\n        }\n    });\n}\n\n// easy functions to collapse panels to base\nfunction rightpanelMedium() {\n    d3.select("#rightpanel").attr("class", "sidepanel container clearfix");\n}\n\nfunction leftpanelMedium() {\n    d3.select("#leftpanel").attr("class", "sidepanel container clearfix");\n}\n\n// converts color codes\nvar hexToRgba = exports.hexToRgba = function hexToRgba(hex) {\n    var int = parseInt(hex.replace(\'#\', \'\'), 16);\n    return \'rgba(\' + [int >> 16 & 255, int >> 8 & 255, int & 255, \'0.5\'].join(\',\') + \')\';\n};\n\n// takes node and color and updates zparams\nfunction setColors(n, c) {\n    if (n.strokeWidth == \'1\') {\n        if (c == gr1Color) {\n            var tempindex = zparams.zgroup1.indexOf(n.name);\n            if (tempindex > -1) {\n                n.group1 = false;\n                zparams.zgroup1.splice(tempindex, 1);\n            } else {\n                n.group1 = true;\n                zparams.zgroup1.push(n.name);\n            };\n        } else if (c == gr2Color) {\n            var tempindex = zparams.zgroup2.indexOf(n.name);\n            if (tempindex > -1) {\n                n.group2 = false;\n                zparams.zgroup2.splice(tempindex, 1);\n            } else {\n                n.group2 = true;\n                zparams.zgroup2.push(n.name);\n            };\n        } else {\n            // adding time, cs, dv, nom to node with no stroke\n            n.strokeWidth = \'4\';\n            n.strokeColor = c;\n            n.nodeCol = taggedColor;\n            var push = function push(_ref3) {\n                var _ref4 = _slicedToArray(_ref3, 2),\n                    color = _ref4[0],\n                    key = _ref4[1];\n\n                if (color != c) return;\n                zparams[key] = Array.isArray(zparams[key]) ? zparams[key] : [];\n                zparams[key].push(n.name);\n                if (key == \'znom\') {\n                    findNodeIndex(n.name, true).nature = "nominal";\n                    transform(n.name, t = null, typeTransform = true);\n                }\n                if (key == \'zdv\') {\n                    // remove group memberships from dv\'s\n                    if (n.group1) {\n                        n.group1 = false;\n                        zparams.zgroup1.splice(zparams.zgroup1.indexOf(n.name), 1);\n                    };\n                    if (n.group2) {\n                        n.group2 = false;\n                        zparams.zgroup2.splice(zparams.zgroup2.indexOf(n.name), 1);\n                    };\n                }\n            };\n            [[dvColor, \'zdv\'], [csColor, \'zcross\'], [timeColor, \'ztime\'], [nomColor, \'znom\']].forEach(push);\n        }\n    } else if (n.strokeWidth == \'4\') {\n        if (c == n.strokeColor) {\n            // deselecting time, cs, dv, nom\n            n.strokeWidth = \'1\';\n            n.strokeColor = _plots.selVarColor;\n            n.nodeCol = colors(n.id);\n            splice(c, n.name, [dvColor, \'zdv\'], [csColor, \'zcross\'], [timeColor, \'ztime\'], [nomColor, \'znom\']);\n            if (nomColor == c && zparams.znom.includes(n.name)) {\n                findNodeIndex(n.name, true).nature = findNodeIndex(n.name, true).defaultNature;\n                transform(n.name, t = null, typeTransform = true);\n            }\n        } else {\n            // deselecting time, cs, dv, nom AND changing it to time, cs, dv, nom\n            splice(n.strokeColor, n.name, [dvColor, \'zdv\'], [csColor, \'zcross\'], [timeColor, \'ztime\'], [nomColor, \'znom\']);\n            if (nomColor == n.strokeColor && zparams.znom.includes(n.name)) {\n                findNodeIndex(n.name, true).nature = findNodeIndex(n.name, true).defaultNature;\n                transform(n.name, t = null, typeTransform = true);\n            }\n            n.strokeColor = c;\n            if (dvColor == c) {\n                var dvname = n.name;\n                zparams.zdv.push(dvname);\n                if (n.group1) {\n                    // remove group memberships from dv\'s\n                    ngroup1 = false;\n                    zparams.zgroup1.splice(zparams.zgroup1.indexOf(dvname), 1);\n                };\n                if (n.group2) {\n                    ngroup2 = false;\n                    zparams.zgroup2.splice(zparams.zgroup2.indexOf(dvname), 1);\n                };\n            } else if (csColor == c) zparams.zcross.push(n.name);else if (timeColor == c) zparams.ztime.push(n.name);else if (nomColor == c) {\n                zparams.znom.push(n.name);\n                findNodeIndex(n.name, true).nature = "nominal";\n                transform(n.name, t = null, typeTransform = true);\n            }\n        }\n    }\n}\n\nfunction borderState() {\n    zparams.zdv.length > 0 ? $(\'#dvButton .rectColor svg circle\').attr(\'stroke\', dvColor) : $(\'#dvButton\').css(\'border-color\', \'#ccc\');\n    zparams.zcross.length > 0 ? $(\'#csButton .rectColor svg circle\').attr(\'stroke\', csColor) : $(\'#csButton\').css(\'border-color\', \'#ccc\');\n    zparams.ztime.length > 0 ? $(\'#timeButton .rectColor svg circle\').attr(\'stroke\', timeColor) : $(\'#timeButton\').css(\'border-color\', \'#ccc\');\n    zparams.znom.length > 0 ? $(\'#nomButton .rectColor svg circle\').attr(\'stroke\', nomColor) : $(\'#nomButton\').css(\'border-color\', \'#ccc\');\n    zparams.zgroup1.length > 0 ? $(\'#gr1Button .rectColor svg circle\').attr(\'stroke\', gr1Color).attr(\'fill\', gr1Color).attr(\'fill-opacity\', 0.6).attr(\'stroke-opacity\', 0) : $(\'#gr1Button\').css(\'border-color\', \'#ccc\');\n    zparams.zgroup2.length > 0 ? $(\'#gr2Button .rectColor svg circle\').attr(\'stroke\', gr2Color).attr(\'fill\', gr2Color).attr(\'fill-opacity\', 0.6).attr(\'stroke-opacity\', 0) : $(\'#gr2Button\').css(\'border-color\', \'#ccc\');\n}\n\n// small appearance resets, but perhaps this will become a hard reset back to all original allNode values?\nfunction nodeReset(n) {\n    n.strokeColor = _plots.selVarColor;\n    n.strokeWidth = "1";\n    n.nodeCol = n.baseCol;\n}\n\nfunction subsetSelect(btn) {\n    if (dataurl) zparams.zdataurl = dataurl;\n    if (production && zparams.zsessionid == "") {\n        alert("Warning: Data download is not complete. Try again soon.");\n        return;\n    }\n    zparams.zvars = [];\n    zparams.zplot = [];\n    var subsetEmpty = true;\n    // is this the same as zPop()?\n    for (var j = 0; j < nodes.length; j++) {\n        // populate zvars and zsubset arrays\n        zparams.zvars.push(nodes[j].name);\n        var temp = nodes[j].id;\n        zparams.zsubset[j] = allNodes[temp].subsetrange;\n        if (zparams.zsubset[j].length > 0) {\n            if (zparams.zsubset[j][0] != "") zparams.zsubset[j][0] = Number(zparams.zsubset[j][0]);\n            if (zparams.zsubset[j][1] != "") zparams.zsubset[j][1] = Number(zparams.zsubset[j][1]);\n        }\n        zparams.zplot.push(allNodes[temp].plottype);\n        if (zparams.zsubset[j][1] != "") subsetEmpty = false; // only need to check one\n    }\n\n    if (subsetEmpty == true) {\n        alert("Warning: No new subset selected.");\n        return;\n    }\n\n    var outtypes = [];\n    for (var j = 0; j < allNodes.length; j++) {\n        outtypes.push({\n            varnamesTypes: allNodes[j].name,\n            nature: allNodes[j].nature,\n            numchar: allNodes[j].numchar,\n            binary: allNodes[j].binary,\n            interval: allNodes[j].interval\n        });\n    }\n\n    var subsetstuff = {\n        zdataurl: zparams.zdataurl,\n        zvars: zparams.zvars,\n        zsubset: zparams.zsubset,\n        zsessionid: zparams.zsessionid,\n        zplot: zparams.zplot,\n        callHistory: callHistory,\n        typeStuff: outtypes\n    };\n\n    var jsonout = JSON.stringify(subsetstuff);\n    var urlcall = rappURL + "subsetapp";\n    var solajsonout = "solaJSON=" + jsonout;\n    cdb("urlcall out: ", urlcall);\n    cdb("POST out: ", solajsonout);\n\n    function subsetSelectSuccess(btn, json) {\n        selectLadda.stop(); // stop motion\n        $("#btnVariables").trigger("click"); // programmatic clicks\n        $("#btnModels").trigger("click");\n\n        var grayOuts = [];\n        var rCall = [];\n        rCall[0] = json.call;\n\n        // store contents of the pre-subset space\n        zPop();\n        var myNodes = jQuery.extend(true, [], allNodes);\n        var myParams = jQuery.extend(true, {}, zparams);\n        var myTrans = jQuery.extend(true, [], trans);\n        var myForce = jQuery.extend(true, [], forcetoggle);\n        var myPreprocess = jQuery.extend(true, {}, preprocess);\n        var myLog = jQuery.extend(true, [], logArray);\n        var myHistory = jQuery.extend(true, [], callHistory);\n\n        spaces[myspace] = {\n            "allNodes": myNodes,\n            "zparams": myParams,\n            "trans": myTrans,\n            "force": myForce,\n            "preprocess": myPreprocess,\n            "logArray": myLog,\n            "callHistory": myHistory\n        };\n\n        // remove pre-subset svg\n        var selectMe = "#m".concat(myspace);\n        d3.select(selectMe).attr(\'class\', \'item\');\n        selectMe = "#whitespace".concat(myspace);\n        d3.select(selectMe).remove();\n\n        myspace = spaces.length;\n        callHistory.push({\n            func: "subset",\n            zvars: jQuery.extend(true, [], zparams.zvars),\n            zsubset: jQuery.extend(true, [], zparams.zsubset),\n            zplot: jQuery.extend(true, [], zparams.zplot)\n        });\n\n        // this is to be used to gray out and remove listeners for variables that have been subsetted out of the data\n        function varOut(v) {\n            // if in nodes, remove gray out in left panel\n            // make unclickable in left panel\n            for (var i = 0; i < v.length; i++) {\n                var selectMe = v[i].replace(/\\W/g, "_");\n                byId(selectMe).style.color = hexToRgba(grayColor);\n                selectMe = "p#".concat(selectMe);\n                d3.select(selectMe).on("click", null);\n            }\n        }\n\n        showLog(\'subset\', rCall);\n        reWriteLog();\n\n        d3.select("#innercarousel").append(\'div\').attr(\'class\', \'item active\').attr(\'id\', function () {\n            return "m".concat(myspace.toString());\n        }).append(\'svg\').attr(\'id\', \'whitespace\');\n        svg = d3.select("#whitespace");\n\n        d3.json(json.url, function (error, json) {\n            if (error) {\n                return console.warn(error);\n            }\n            var jsondata = getVariableData(json);\n\n            for (var key in jsondata) {\n                var myIndex = findNodeIndex(key);\n\n                allNodes[myIndex].plotx = undefined;\n                allNodes[myIndex].ploty = undefined;\n                allNodes[myIndex].plotvalues = undefined;\n                allNodes[myIndex].plottype = "";\n\n                jQuery.extend(true, allNodes[myIndex], jsondata[key]);\n                allNodes[myIndex].subsetplot = false;\n                allNodes[myIndex].subsetrange = ["", ""];\n                allNodes[myIndex].setxplot = false;\n                allNodes[myIndex].setxvals = ["", ""];\n\n                if (allNodes[myIndex].valid == 0) {\n                    grayOuts.push(allNodes[myIndex].name);\n                    allNodes[myIndex].grayout = true;\n                }\n            }\n            rePlot();\n\n            layout(layoutAdd);\n        });\n\n        varOut(grayOuts);\n    }\n\n    selectLadda.start(); //start button motion\n    makeCorsRequest(urlcall, btn, subsetSelectSuccess, function (btn) {\n        return selectLadda.stop();\n    }, solajsonout);\n}\n\nfunction readPreprocess(data) {\n    console.log(data);\n    return new Promise(function (resolve, _) {\n        priv = data.dataset.private || priv;\n        Object.keys(data.variables).forEach(function (k) {\n            return preprocess[k] = data.variables[k];\n        });\n        resolve();\n    });\n}\n\n// removes all the children svgs inside subset and setx divs\nfunction rePlot() {\n    d3.select(\'#tab2\').selectAll(\'svg\').remove();\n    d3.select(\'#setx\').selectAll(\'svg\').remove();\n    allNodes.forEach(function (n) {\n        return n.setxplot = n.subsetplot = false;\n    });\n}\n\nvar showLog = function showLog(val, rCall) {\n    logArray.push((val + \': \').concat(rCall[0]));\n    _mithril2.default.redraw();\n};\n\nfunction reWriteLog() {\n    d3.select("#collapseLog div.panel-body").selectAll("p").remove();\n    d3.select("#collapseLog div.panel-body").selectAll("p").data(logArray).enter().append("p").text(function (d) {\n        return d;\n    });\n}\n\n// acts as if the user clicked in whitespace. useful when restart() is outside of scope\nvar fakeClick = exports.fakeClick = function fakeClick() {\n    var ws = "#whitespace".concat(myspace);\n    // d3 and programmatic events don\'t mesh well, here\'s a SO workaround that looks good but uses jquery...\n    jQuery.fn.d3Click = function () {\n        this.each(function (i, e) {\n            var evt = document.createEvent("MouseEvents");\n            evt.initMouseEvent("mousedown", true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);\n            e.dispatchEvent(evt);\n        });\n    };\n    $(ws).d3Click();\n    d3.select(ws).classed(\'active\', false);\n};\n\n//EndSession(SessionContext) returns (Response) {}\nfunction endsession() {\n    var SessionContext = apiSession(zparams.zsessionid);\n\n    var jsonout = JSON.stringify(SessionContext);\n\n    var urlcall = d3mURL + "/endsession";\n    var solajsonout = "grpcrequest=" + jsonout;\n    console.log("EndSession: ");\n    console.log(solajsonout);\n    console.log("urlcall: ", urlcall);\n\n    function endSuccess(btn, Response) {\n        console.log(Response);\n    }\n\n    function endFail(btn) {\n        console.log("end session failed");\n    }\n\n    makeCorsRequest(urlcall, "nobutton", endSuccess, endFail, solajsonout);\n}\n\n//rpc ListPipelines(PipelineListRequest) returns (PipelineListResult) {}\n// pipes is an array of pipeline IDs\nfunction listpipelines() {\n    var context = apiSession(zparams.zsessionid);\n    var PipeLineListRequest = { context: context };\n\n    var jsonout = JSON.stringify(PipeLineListRequest);\n\n    var urlcall = d3mURL + "/listpipelines";\n    var solajsonout = "grpcrequest=" + jsonout;\n    console.log("PipelineListRequest: ");\n    console.log(solajsonout);\n    console.log(urlcall);\n\n    function listPipesSuccess(btn, PipelineListResult) {\n        console.log(PipelineListResult);\n        //hardcoded pipes for now\n        var pipes = PipelineListResult.pipelineIds;\n\n        /*\n        pipes.unshift("place");\n        console.log(pipes);\n        d3.select("#results").selectAll("p")\n        .data(pipes)\n        .enter()\n        .append("p")\n        .attr("id", "_pipe_".concat)\n        .text(d => d)\n        .attr(\'class\', \'item-default\')\n        .on("click", function() {\n            if(this.className=="item-select") {\n                return;\n            } else {\n                d3.select("#results").select("p.item-select")\n                .attr(\'class\', \'item-default\');\n                d3.select(this).attr(\'class\',"item-select");\n            }});\n         pipes.shift();\n          d3.select("#setxRight").selectAll("p")\n        .data(pipes)\n        .enter()\n        .append("p")\n        .attr("id", "_setxpipe_".concat)\n        .text(d => d)\n        .attr(\'class\', \'item-default\')\n        .on("click", function() {\n            if(this.className=="item-select") {\n            return;\n            } else {\n            d3.select("#setxRight").select("p.item-select")\n            .attr(\'class\', \'item-default\');\n            d3.select(this).attr(\'class\',"item-select");\n            }});\n         */\n    }\n\n    function listPipesFail(btn) {\n        console.log("list pipelines failed");\n    }\n\n    makeCorsRequest(urlcall, "nobutton", listPipesSuccess, listPipesFail, solajsonout);\n}\n\n// rpc ExecutePipeline(PipelineExecuteRequest) returns (stream PipelineExecuteResult) {}\nfunction executepipeline() {\n    var context = apiSession(zparams.zsessionid);\n    var tablerow = document.getElementById(\'setxRight\').querySelector(\'tr.item-select\');\n    if (tablerow == null) {\n        alert("Please select a pipeline to execute on.");return;\n    }\n    var pipelineId = tablerow.firstChild.innerText;\n\n    zPop();\n    zparams.callHistory = callHistory;\n    var jsonout = JSON.stringify(zparams);\n\n    var predictFeatures = apiFeature(zparams.zvars, "<<DATA_URI>>");\n    var data = [];\n\n    //this will just set zparams.zsetx to the mean, which is default for setx plots\n    //note that if setxplot is modified, it will NOT == "" because zparams.zsetx is modified when the setx plot slider is moved for the first time\n    for (var i = 0; i < zparams.zvars.length; i++) {\n        var mydata = [];\n        var mymean = allNodes[findNodeIndex(zparams.zvars[i])].mean;\n        if (zparams.zsetx[i][0] == "") {\n            mydata[0] = mymean;\n        } else if (zparams.zsetx[i][0] != mymean) {\n            mydata[0] = zparams.zsetx[i][0];\n        }\n        if (zparams.zsetx[i][1] == "") {\n            mydata[1] = allNodes[findNodeIndex(zparams.zvars[i])].mean;\n        } else if (zparams.zsetx[i][1] != mymean) {\n            mydata[1] = zparams.zsetx[i][1];\n        }\n        data.push(mydata);\n    }\n\n    var PipelineExecuteRequest = { context: context, pipelineId: pipelineId, predictFeatures: predictFeatures, data: data };\n\n    jsonout = JSON.stringify(PipelineExecuteRequest);\n\n    var urlcall = d3mURL + "/executepipeline";\n    var solajsonout = "grpcrequest=" + jsonout;\n    console.log("PipelineExecuteRequest: ");\n    console.log(solajsonout);\n    console.log("urlcall: ", urlcall);\n\n    function executePipeSuccess(btn, PipelineExecuteResult) {\n        alert("pipeline executed");\n        console.log(PipelineExecuteResult);\n    }\n\n    function executePipeFail(btn) {\n        console.log("execute pipelines failed");\n    }\n\n    makeCorsRequest(urlcall, "nobutton", executePipeSuccess, executePipeFail, solajsonout);\n}\n\n// this is our call to django to update the problem schema\n// rpc UpdateProblemSchema(UpdateProblemSchemaRequest) returns (Response) {}\nfunction updateSchema(type, updates, lookup) {\n    var context = apiSession(zparams.zsessionid);\n    var ReplaceProblemSchemaField = _defineProperty({}, type, lookup[updates[type]][1]);\n    //    let valuenum = lookup[updates[type]][2];\n    var UpdateProblemSchemaRequest = { ReplaceProblemSchemaField: ReplaceProblemSchemaField, context: context };\n\n    var jsonout = JSON.stringify(UpdateProblemSchemaRequest);\n\n    var urlcall = d3mURL + "/updateproblemschema";\n    var solajsonout = "grpcrequest=" + jsonout;\n    console.log("UpdateProblemSchemaRequest: ");\n    console.log(solajsonout);\n    console.log("urlcall: ", urlcall);\n\n    function usSuccess(btn, Response) {\n        console.log(Response);\n    }\n\n    function usFail(btn) {\n        console.log("update schema failed");\n    }\n\n    makeCorsRequest(urlcall, "nobutton", usSuccess, usFail, solajsonout);\n}\n\n// Find something centerish to the vertices of a convex hull\n// (specifically, the center of the bounding box)\nfunction jamescentroid(coord) {\n    var minx = coord[0][0],\n        maxx = coord[0][0],\n        miny = coord[0][1],\n        maxy = coord[0][1];\n    for (var j = 1; j < coord.length; j++) {\n        if (coord[j][0] < minx) minx = coord[j][0];\n        if (coord[j][1] < miny) miny = coord[j][1];\n        if (coord[j][0] > maxx) maxx = coord[j][0];\n        if (coord[j][1] > maxy) maxy = coord[j][1];\n    };\n    return [(minx + maxx) / 2, (miny + maxy) / 2];\n};\n\n// Define each pebble radius.\n// Presently, most pebbles are scaled to radius set by global allR.\n// Members of groups are scaled down if group gets large.\nfunction setPebbleRadius(d) {\n    if (d.group1 || d.group2) {\n        // if a member of a group, need to calculate radius size\n        var uppersize = 7;\n        var ng1 = d.group1 ? zparams.zgroup1.length : 1; // size of group1, if a member of group 1\n        var ng2 = d.group2 ? zparams.zgroup2.length : 1; // size of group2, if a member of group 2\n        var maxng = Math.max(ng1, ng2); // size of the largest group variable is member of\n        return maxng > uppersize ? allR * Math.sqrt(uppersize / maxng) : allR; // keep total area of pebbles bounded to pi * allR^2 * uppersize, thus shrinking radius for pebbles in larger groups\n    } else {\n            return allR; // nongroup members get the common global radius\n        }\n};\n\n// Define each pebble charge.\n// This was the previous charge setting:\n//return ((zparams.zgroup1.indexOf(node.name) < 0 ) & (zparams.zgroup2.indexOf(node.name) < 0 ))   ? -800 : -400;  // -1 is the value if no index position found\nfunction setPebbleCharge(d) {\n    if (d.group1 || d.group2) {\n        if (d.forefront) {\n            // pebbles packed in groups repel others on mouseover\n            return -1000;\n        }\n        var uppersize = 7;\n        var ng1 = d.group1 ? zparams.zgroup1.length : 1; // size of group1, if a member of group 1\n        var ng2 = d.group2 ? zparams.zgroup2.length : 1; // size of group2, if a member of group 2\n        var maxng = Math.max(ng1, ng2); // size of the largest group variable is member of\n        return maxng > uppersize ? -400 * (uppersize / maxng) : -400; // decrease charge as pebbles become smaller, so they can pack together\n    } else {\n        return -800;\n    }\n};\n\nfunction expandrightpanel() {\n    document.getElementById(\'rightpanel\').classList.add("expandpanelfull");\n    console.log("HERE");\n}\n\nfunction toggleRightButtons(set) {\n\n    function setWidths(btns) {\n        var mywidth = 100 / btns.length;\n        mywidth = mywidth.toString() + \'%\';\n        var expandwidth = \'35%\';\n        var shrinkwidth = 65 / (btns.length - 1);\n        shrinkwidth = shrinkwidth.toString() + \'%\';\n        var mylis = document.getElementById(\'rightpanel\').querySelectorAll(".accordian li");\n        // hardly ever runs on the page\n        for (var i = 0; i < mylis.length; i++) {\n            mylis[i].style.width = mywidth;\n            mylis[i].addEventListener(\'mouseover\', function () {\n                for (var j = 0; j < mylis.length; j++) {\n                    mylis[j].style.width = shrinkwidth;\n                }\n                this.style.width = expandwidth;\n            });\n            mylis[i].addEventListener(\'mouseout\', function () {\n                for (var j = 0; j < mylis.length; j++) {\n                    mylis[j].style.width = mywidth;\n                }\n            });\n        }\n    }\n\n    if (set == "tasks") {\n\n        document.getElementById(\'btnModels\').classList.add("noshow");\n        document.getElementById(\'btnSetx\').classList.add("noshow");\n        document.getElementById(\'btnResults\').classList.add("noshow");\n\n        var mybtns = document.getElementById(\'rightpanelbuttons\').querySelectorAll(".btn:not(.noshow)");\n        setWidths(mybtns);\n    } else if (set == "all") {\n        // first remove noshow class\n        var _mybtns = document.getElementById(\'rightpanelbuttons\').querySelectorAll(".noshow");\n        for (var i = 0; i < _mybtns.length; i++) {\n            _mybtns[i].classList.remove("noshow");\n        }\n\n        // droping models for d3m_mode\n        document.getElementById(\'btnModels\').classList.add("noshow");\n\n        // if swandive, dropping setx\n        if (swandive) document.getElementById(\'btnSetx\').classList.add("noshow");\n\n        // then select all the buttons\n        _mybtns = document.getElementById(\'rightpanelbuttons\').querySelectorAll(".btn:not(.noshow)");\n        setWidths(_mybtns);\n    }\n    if (set == "models") {\n        document.getElementById(\'btnModels\').style.display = \'inline\';\n        document.getElementById(\'btnSetx\').style.display = \'inline\';\n        document.getElementById(\'btnResults\').style.display = \'inline\';\n\n        document.getElementById(\'btnType\').style.display = \'none\';\n        document.getElementById(\'btnSubtype\').style.display = \'none\';\n        document.getElementById(\'btnMetrics\').style.display = \'none\';\n        document.getElementById(\'btnOutputs\').style.display = \'none\';\n    }\n}\n\nfunction resultsplotinit(pid, dvvalues) {\n    // presumably we\'ll be reading in results from a path\n    // for now it\'s just hardcoded\n    console.log(pid);\n    var predfile = pid.pipelineInfo.predictResultData.file_1;\n    var predvals = [];\n\n    for (var i = 0; i < predfile.length; i++) {\n        predvals.push(Number(predfile[i].preds));\n    }\n\n    // only do this for classification tasks\n    if (d3mTaskType[d3mProblemDescription.taskType][1] == "CLASSIFICATION") {\n        genconfdata(dvvalues, predvals);\n    } else {\n        var xdata = "Actual";\n        var ydata = "Predicted";\n        bivariatePlot(dvvalues, predvals, xdata, ydata);\n    }\n}\nfunction genconfdata(dvvalues, predvals) {\n    // FOR TESTING\n    dvvalues = predvals.slice(0);\n    for (var i = 0; i < dvvalues.length; i++) {\n        var randomnumber = Math.floor(Math.random() * (2 - -2 + 1)) + -2;\n        dvvalues[i] = dvvalues[i] + randomnumber;\n    }\n\n    // done for testing. drop above when dvvalues are real values returned by R when pipeline is constructed\n\n    function onlyUnique(value, index, self) {\n        return self.indexOf(value) === index;\n    }\n\n    var mycounts = [];\n    var mypairs = [];\n\n    // this should eventually be just read from the URI in pipeline\n    // let dvvalues = [1,1,1,2,3,2,3,3,3,3,3,2,3,2,1,2,3,4,4];\n    // let predvals = [1,2,3,2,3,1,3,3,3,2,2,1,3,3,1,2,3,4,3];\n\n    // combine actuals and predicted, and get all unique elements\n    var myuniques = dvvalues.concat(predvals);\n    myuniques = myuniques.filter(onlyUnique);\n    //  console.log(myuniques);\n\n    // create two arrays: mycounts initialized to 0, mypairs have elements set to all possible pairs of uniques\n    // looked into solutions other than nested fors, but Internet suggest performance is just fine this way\n    for (var _i2 = 0; _i2 < myuniques.length; _i2++) {\n        var tempcount = [];\n        var temppair = [];\n        for (var j = 0; j < myuniques.length; j++) {\n            mycounts.push(0);\n            mypairs.push(+myuniques[_i2] + \',\' + myuniques[j]);\n        }\n    }\n\n    //  console.log(mypairs);\n    // line up actuals and predicted, and increment mycounts at index where mypair has a match for the \'actual,predicted\'\n    for (var _i3 = 0; _i3 < dvvalues.length; _i3++) {\n        //   console.log(dvvalues[i]);\n        //   console.log(predvals[i]);\n        var _temppair = +dvvalues[_i3] + \',\' + predvals[_i3];\n        var myindex = mypairs.indexOf(_temppair);\n        mycounts[myindex] += 1;\n    }\n    //  console.log(mycounts);\n\n    var confdata = [],\n        size = myuniques.length;\n\n    // another loop... this builds the array of arrays from the flat array mycounts for input to confusionsmatrix function\n    while (mycounts.length > 0) {\n        confdata.push(mycounts.splice(0, size));\n    } // console.log(confdata);\n\n    // call confusionmatrix\n    confusionmatrix(confdata, myuniques);\n}\nfunction confusionmatrix(matrixdata, classes) {\n    d3.select("#setxMiddle").html("");\n    d3.select("#setxMiddle").select("svg").remove();\n\n    // adapted from this block: https://bl.ocks.org/arpitnarechania/dbf03d8ef7fffa446379d59db6354bac\n    var mainwidth = document.getElementById(\'main\').clientWidth;\n    var mainheight = document.getElementById(\'main\').clientHeight;\n\n    var condiv = document.createElement(\'div\');\n    condiv.id = "confusioncontainer";\n    condiv.style.display = "inline-block";\n    condiv.style.width = +(mainwidth * .25) + \'px\';\n    condiv.style.marginLeft = \'20px\';\n    condiv.style.height = +(mainheight * .4) + \'px\';\n    condiv.style.float = "left";\n    document.getElementById(\'setxMiddle\').appendChild(condiv);\n\n    var legdiv = document.createElement(\'div\');\n    legdiv.id = "confusionlegend";\n    legdiv.style.width = +(mainwidth * .07) + \'px\';\n    legdiv.style.marginLeft = \'20px\';\n    legdiv.style.height = +(mainheight * .4) + \'px\';\n    legdiv.style.display = "inline-block";\n\n    document.getElementById(\'setxMiddle\').appendChild(legdiv);\n\n    var margin = { top: 20, right: 10, bottom: 0, left: 50 };\n\n    function Matrix(options) {\n\n        var width = options.width,\n            height = options.height,\n            data = options.data,\n            container = options.container,\n            labelsData = options.labels,\n            startColor = options.start_color,\n            endColor = options.end_color;\n\n        var widthLegend = options.widthLegend;\n\n        if (!data) {\n            throw new Error(\'Please pass data\');\n        }\n\n        if (!Array.isArray(data) || !data.length || !Array.isArray(data[0])) {\n            throw new Error(\'It should be a 2-D array\');\n        }\n\n        var maxValue = d3.max(data, function (layer) {\n            return d3.max(layer, function (d) {\n                return d;\n            });\n        });\n        var minValue = d3.min(data, function (layer) {\n            return d3.min(layer, function (d) {\n                return d;\n            });\n        });\n\n        var numrows = data.length;\n        var numcols = data[0].length;\n\n        var svg = d3.select(container).append("svg").attr("width", width + margin.left + margin.right).attr("height", height + margin.top + margin.bottom).append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");\n\n        var background = svg.append("rect").style("stroke", "black").style("stroke-width", "2px").attr("width", width).attr("height", height);\n\n        var x = d3.scale.ordinal().domain(d3.range(numcols)).rangeBands([0, width]);\n\n        var y = d3.scale.ordinal().domain(d3.range(numrows)).rangeBands([0, height]);\n\n        var colorMap = d3.scale.linear().domain([minValue, maxValue]).range([startColor, endColor]);\n\n        var row = svg.selectAll(".row").data(data).enter().append("g").attr("class", "row").attr("transform", function (d, i) {\n            return "translate(0," + y(i) + ")";\n        });\n\n        var cell = row.selectAll(".cell").data(function (d) {\n            return d;\n        }).enter().append("g").attr("class", "cell").attr("transform", function (d, i) {\n            return "translate(" + x(i) + ", 0)";\n        });\n\n        cell.append(\'rect\').attr("width", x.rangeBand()).attr("height", y.rangeBand()).style("stroke-width", 0);\n\n        cell.append("text").attr("dy", ".32em").attr("x", x.rangeBand() / 2).attr("y", y.rangeBand() / 2).attr("text-anchor", "middle").style("fill", function (d, i) {\n            return d >= maxValue / 2 ? \'white\' : \'black\';\n        }).text(function (d, i) {\n            return d;\n        });\n\n        row.selectAll(".cell").data(function (d, i) {\n            return data[i];\n        }).style("fill", colorMap);\n\n        // this portion of the code isn\'t as robust to sizing. column labels not rendering in the right place\n        var labels = svg.append(\'g\').attr(\'class\', "labels");\n\n        var columnLabels = labels.selectAll(".column-label").data(labelsData).enter().append("g").attr("class", "column-label").attr("transform", function (d, i) {\n            // let temp = "translate(" + x(i) + "," + (height+20) + ")"; // this in particular looks to be the cause\n            //  console.log(temp);\n            return "translate(" + x(i) + "," + (height + 30) + ")";\n        });\n\n        columnLabels.append("line").style("stroke", "black").style("stroke-width", "1px").attr("x1", x.rangeBand() / 2).attr("x2", x.rangeBand() / 2).attr("y1", 0).attr("y2", 5);\n\n        columnLabels.append("text").attr("x", 30).attr("y", y.rangeBand() / 2).attr("dy", ".22em").attr("text-anchor", "end").attr("transform", "rotate(-60)").text(function (d, i) {\n            return d;\n        });\n\n        var rowLabels = labels.selectAll(".row-label").data(labelsData).enter().append("g").attr("class", "row-label").attr("transform", function (d, i) {\n            return "translate(" + 0 + "," + y(i) + ")";\n        });\n\n        rowLabels.append("line").style("stroke", "black").style("stroke-width", "1px").attr("x1", 0).attr("x2", -5).attr("y1", y.rangeBand() / 2).attr("y2", y.rangeBand() / 2);\n\n        rowLabels.append("text").attr("x", -8).attr("y", y.rangeBand() / 2).attr("dy", ".32em").attr("text-anchor", "end").text(function (d, i) {\n            return d;\n        });\n\n        var key = d3.select("#confusionlegend").append("svg").attr("width", widthLegend).attr("height", height + margin.top + margin.bottom);\n\n        var legend = key.append("defs").append("svg:linearGradient").attr("id", "gradient").attr("x1", "100%").attr("y1", "0%").attr("x2", "100%").attr("y2", "100%").attr("spreadMethod", "pad");\n\n        legend.append("stop").attr("offset", "0%").attr("stop-color", endColor).attr("stop-opacity", 1);\n\n        legend.append("stop").attr("offset", "100%").attr("stop-color", startColor).attr("stop-opacity", 1);\n\n        key.append("rect").attr("width", widthLegend / 2 - 10).attr("height", height).style("fill", "url(#gradient)").attr("transform", "translate(0," + margin.top + ")");\n\n        // this y is for the legend\n        y = d3.scale.linear().range([height, 0]).domain([minValue, maxValue]);\n\n        var yAxis = d3.svg.axis().scale(y).orient("right");\n\n        key.append("g").attr("class", "y axis").attr("transform", "translate(41," + margin.top + ")").call(yAxis);\n    }\n\n    // The table generation function. Used for the table of performance measures, not the confusion matrix\n    function tabulate(data, columns) {\n        var table = d3.select("#setxMiddle").append("table").attr("style", "margin-left: " + margin.left + "px"),\n            thead = table.append("thead"),\n            tbody = table.append("tbody");\n\n        // append the header row\n        thead.append("tr").selectAll("th").data(columns).enter().append("th").text(function (column) {\n            return column;\n        });\n\n        // create a row for each object in the data\n        var rows = tbody.selectAll("tr").data(data).enter().append("tr");\n\n        // create a cell in each row for each column\n        var cells = rows.selectAll("td").data(function (row) {\n            return columns.map(function (column) {\n                return { column: column, value: row[column] };\n            });\n        }).enter().append("td").attr("style", "font-family: Courier") // sets the font style\n        .html(function (d) {\n            return d.value;\n        });\n\n        return table;\n    }\n\n    // this code is all for producing a table with performance measures\n    //var confusionMatrix = [[169, 10],[7, 46]];\n    var tp = matrixdata[0][0];\n    var fn = matrixdata[0][1];\n    var fp = matrixdata[1][0];\n    var tn = matrixdata[1][1];\n\n    var p = tp + fn;\n    var n = fp + tn;\n\n    var accuracy = (tp + tn) / (p + n);\n    var f1 = 2 * tp / (2 * tp + fp + fn);\n    var precision = tp / (tp + fp);\n    var recall = tp / (tp + fn);\n\n    accuracy = Math.round(accuracy * 100) / 100;\n    f1 = Math.round(f1 * 100) / 100;\n    precision = Math.round(precision * 100) / 100;\n    recall = Math.round(recall * 100) / 100;\n\n    var computedData = [];\n    computedData.push({ "F1": f1, "PRECISION": precision, "RECALL": recall, "ACCURACY": accuracy });\n\n    Matrix({\n        container: \'#confusioncontainer\',\n        data: matrixdata,\n        labels: classes,\n        start_color: \'#ffffff\',\n        end_color: \'#e67e22\',\n        width: mainwidth * .15,\n        height: mainheight * .25,\n        widthLegend: mainwidth * .05\n    });\n\n    // not rendering this table for right now, left all the code in place though. maybe we use it eventually\n    //  var table = tabulate(computedData, ["F1", "PRECISION","RECALL","ACCURACY"]);\n\n}\n\n// scatterplot function to go to plots.js to be reused\nfunction bivariatePlot(x_Axis, y_Axis, x_Axis_name, y_Axis_name) {\n\n    d3.select("#setxMiddle").html("");\n    d3.select("#setxMiddle").select("svg").remove();\n\n    var mainwidth = document.getElementById(\'main\').clientWidth;\n    var mainheight = document.getElementById(\'main\').clientHeight;\n\n    // scatter plot\n\n    var data_plot = [];\n    var nanCount = 0;\n    for (var i = 0; i < x_Axis.length; i++) {\n        if (isNaN(x_Axis[i]) || isNaN(y_Axis[i])) {\n            nanCount++;\n        } else {\n            var newNumber1 = x_Axis[i];\n            var newNumber2 = y_Axis[i];\n            data_plot.push({ xaxis: newNumber1, yaxis: newNumber2, score: Math.random() * 100 });\n        }\n    }\n\n    var margin = { top: 35, right: 35, bottom: 35, left: 35 },\n        width = mainwidth * .25 - margin.left - margin.right,\n        height = mainwidth * .25 - margin.top - margin.bottom;\n    var padding = 100;\n\n    var min_x = d3.min(data_plot, function (d, i) {\n        return data_plot[i].xaxis;\n    });\n    var max_x = d3.max(data_plot, function (d, i) {\n        return data_plot[i].xaxis;\n    });\n    var avg_x = (max_x - min_x) / 10;\n    var min_y = d3.min(data_plot, function (d, i) {\n        return data_plot[i].yaxis;\n    });\n    var max_y = d3.max(data_plot, function (d, i) {\n        return data_plot[i].yaxis;\n    });\n    var avg_y = (max_y - min_y) / 10;\n\n    var xScale = d3.scale.linear().domain([min_x - avg_x, max_x + avg_x]).range([0, width]);\n\n    var yScale = d3.scale.linear().domain([min_y - avg_y, max_y + avg_y]).range([height, 0]);\n\n    var xAxis = d3.svg.axis().scale(xScale).orient(\'bottom\').tickSize(-height);\n\n    var yAxis = d3.svg.axis().scale(yScale).orient(\'left\').ticks(5).tickSize(-width);\n\n    var zoom = d3.behavior.zoom().x(xScale).y(yScale).scaleExtent([1, 10]).on("zoom", zoomed);\n\n    var chart_scatter = d3.select(\'#setxMiddle\').append(\'svg:svg\').attr(\'width\', width + margin.right + margin.left).attr(\'height\', height + margin.top + margin.bottom);\n    // .call(zoom); dropping this for now, until the line zooms properly\n\n    var main1 = chart_scatter.append(\'g\').attr(\'transform\', \'translate(\' + margin.left + \',\' + margin.top + \')\').attr(\'width\', width + margin.right + margin.left).attr(\'height\', height + margin.top + margin.bottom).attr(\'class\', \'main\');\n\n    var gX = main1.append(\'g\').attr(\'transform\', \'translate(0,\' + height + \')\').attr(\'class\', \'x axis\').call(xAxis);\n\n    var gY = main1.append(\'g\').attr(\'transform\', \'translate(0,0)\').attr(\'class\', \'y axis\').call(yAxis);\n\n    var clip = main1.append("defs").append("svg:clipPath").attr("id", "clip").append("svg:rect").attr("id", "clip-rect").attr("x", "0").attr("y", "0").attr(\'width\', width).attr(\'height\', height);\n\n    main1.append("g").attr("clip-path", "url(#clip)").selectAll("circle").data(data_plot).enter().append("circle").attr("cx", function (d, i) {\n        return xScale(data_plot[i].xaxis);\n    }).attr("cy", function (d, i) {\n        return yScale(data_plot[i].yaxis);\n    }).attr("r", 2).style("fill", "#B71C1C");\n\n    chart_scatter.append("text").attr("text-anchor", "middle") // this makes it easy to centre the text as the transform is applied to the anchor\n    .attr("transform", "translate(" + padding / 5 + "," + height / 2 + ")rotate(-90)") // text is drawn off the screen top left, move down and out and rotate\n    .text(y_Axis_name).style("fill", "#424242").style("text-indent", "20px").style("font-size", "12px").style("font-weight", "bold");\n\n    chart_scatter.append("text").attr("text-anchor", "middle") // this makes it easy to centre the text as the transform is applied to the anchor\n    .attr("transform", "translate(" + width / 2 + "," + (height + padding / 2) + ")") // centre below axis\n    .text(x_Axis_name).style("fill", "#424242").style("text-indent", "20px").style("font-size", "12px").style("font-weight", "bold");\n\n    main1.append("line").attr("x1", xScale(min_x)).attr("y1", yScale(min_x)).attr("x2", xScale(max_x)).attr("y2", yScale(max_x)).attr("stroke-width", 2).attr("stroke", "black");\n\n    function zoomed() {\n        var panX = d3.event.translate[0];\n        var panY = d3.event.translate[1];\n        var scale = d3.event.scale;\n\n        panX = panX > 10 ? 10 : panX;\n        var maxX = -(scale - 1) * width - 10;\n        panX = panX < maxX ? maxX : panX;\n\n        panY = panY > 10 ? 10 : panY;\n        var maxY = -(scale - 1) * height - 10;\n        panY = panY < maxY ? maxY : panY;\n\n        zoom.translate([panX, panY]);\n\n        main1.select(".x.axis").call(xAxis);\n        main1.select(".y.axis").call(yAxis);\n        main1.selectAll("circle").attr("cx", function (d, i) {\n            console.log("circle x ", xScale(5));\n            return xScale(data_plot[i].xaxis);\n        }).attr("cy", function (d, i) {\n            return yScale(data_plot[i].yaxis);\n        }).attr("r", 2.5).style("fill", "#B71C1C");\n\n        // below doesn\'t work, so I\'m just dropping the zoom\n        main1.select("line").attr("x1", function (d, i) {\n            return xScale(min_x);\n        }).attr("y1", function (d, i) {\n            return xScale(min_x);\n        }).attr("x2", function (d, i) {\n            return xScale(max_x);\n        }).attr("y2", function (d, i) {\n            return yScale(max_x);\n        }).attr("stroke-width", 2).attr("stroke", "black");\n    }\n\n    //  d3.select("#NAcount").text("There are " + nanCount + " number of NA values in the relation.");\n\n}\n\nfunction setxTable(features) {\n    function tabulate(data, columns) {\n        var table = d3.select(\'#setxRightBottomLeft\').append(\'table\');\n        var thead = table.append(\'thead\');\n        var tbody = table.append(\'tbody\');\n\n        // append the header row\n        thead.append(\'tr\').selectAll(\'th\').data(columns).enter().append(\'th\').text(function (column) {\n            return column;\n        });\n\n        // create a row for each object in the data\n        var rows = tbody.selectAll(\'tr\').data(data).enter().append(\'tr\');\n\n        // create a cell in each row for each column\n        var cells = rows.selectAll(\'td\').data(function (row) {\n            return columns.map(function (column) {\n                return { column: column, value: row[column] };\n            });\n        }).enter().append(\'td\').text(function (d) {\n            return d.value;\n        }).attr(\'id\', function (d, i) {\n            var rowname = this.parentElement.firstChild.innerText;\n            return rowname + d.column;\n        });\n\n        return table;\n    }\n\n    var mydata = [];\n    for (var i = 0; i < features.length; i++) {\n        if (allNodes[findNodeIndex(features[i])].valid == 0) {\n            xval = 0;\n            x1val = 0;\n            mydata.push({ "Variables": features[i], "From": xval, "To": x1val });\n            continue;\n        }\n\n        var myi = i + 1;\n        var mysvg = features[i] + "_setxLeft_" + myi;\n        var xval = document.getElementById(mysvg).querySelector(\'.xval\').innerHTML;\n        var x1val = document.getElementById(mysvg).querySelector(\'.x1val\').innerHTML;\n        xval = xval.split("x: ").pop();\n        x1val = x1val.split("x1: ").pop();\n        console.log(xval);\n        console.log(mysvg);\n\n        mydata.push({ "Variables": features[i], "From": xval, "To": x1val });\n    }\n\n    // render the table(s)\n    tabulate(mydata, [\'Variables\', \'From\', \'To\']); // 2 column table\n}\n\n//rpc ExportPipeline(PipelineExportRequest) returns (Response) {}\nfunction exportpipeline(pipelineId) {\n    console.log(pipelineId);\n    var context = apiSession(zparams.zsessionid);\n    var pipelineExecUri = "<<EXECUTABLE_URI>>"; // uri to persist executable of requested pipeline w/ session preprocessing\n\n    var PipelineExportRequest = { context: context, pipelineId: pipelineId, pipelineExecUri: pipelineExecUri };\n\n    var jsonout = JSON.stringify(PipelineExportRequest);\n\n    var urlcall = d3mURL + "/exportpipeline";\n    var solajsonout = "grpcrequest=" + jsonout;\n\n    console.log(urlcall);\n    console.log(solajsonout);\n\n    function exportSuccess(btn, Response) {\n        var alertmessage = "Executable for " + pipelineId + " has been written";\n        alert(alertmessage);\n        console.log(Response);\n    }\n\n    function exportFail(btn) {\n        console.log("export pipeline failed");\n    }\n\n    makeCorsRequest(urlcall, "nobutton", exportSuccess, exportFail, solajsonout);\n}\n\nfunction deletepipeline() {\n    console.log("DELETE CALLED");\n}\n\n// D3M API HELPERS\n// because these get built in various places, pulling them out for easy manipulation\nfunction apiFeature(vars, uri) {\n    var out = [];\n    for (var i = 0; i < vars.length; i++) {\n        out.push({ featureId: vars[i], dataUri: uri });\n    }\n    return out;\n}\n\nfunction apiFeatureShortPath(vars, uri) {\n    var out = [];\n    var shortUri = uri.substring(0, uri.lastIndexOf("/"));\n    for (var i = 0; i < vars.length; i++) {\n        out.push({ featureId: vars[i], dataUri: shortUri });\n    }\n    return out;\n}\n\n// silly but perhaps useful if in the future SessionContext requires more things (as suggest by core)\nfunction apiSession(context) {\n    return { "session_id": context };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvYXBwL2FwcC5qcz9mNTEyIl0sIm5hbWVzIjpbIm1haW4iLCJnZXRWYXJpYWJsZURhdGEiLCJmb3JjZVN3aXRjaCIsImhlbHBtYXRlcmlhbHMiLCJsb2NrRGVzY3JpcHRpb24iLCJlc3RpbWF0ZSIsInJ1blByZXByb2Nlc3MiLCJlcmFzZSIsInRhYkxlZnQiLCJ0YWJSaWdodCIsInBhbmVsUGxvdHMiLCJib3JkZXJTdGF0ZSIsInN1YnNldFNlbGVjdCIsImVuZHNlc3Npb24iLCJsaXN0cGlwZWxpbmVzIiwiZXhlY3V0ZXBpcGVsaW5lIiwiZXhwYW5kcmlnaHRwYW5lbCIsInJlc3VsdHNwbG90aW5pdCIsImdlbmNvbmZkYXRhIiwiY29uZnVzaW9ubWF0cml4IiwiYml2YXJpYXRlUGxvdCIsInNldHhUYWJsZSIsImV4cG9ydHBpcGVsaW5lIiwiZGVsZXRlcGlwZWxpbmUiLCJjZGIiLCJwcm9kdWN0aW9uIiwiY29uc29sZSIsImxvZyIsImFwcGx5IiwiayIsInR1dG9yaWFsX21vZGUiLCJmaXJzdF9sb2FkIiwiY29sb3JzIiwiZDMiLCJzY2FsZSIsImNhdGVnb3J5MjAiLCJjc0NvbG9yIiwiZHZDb2xvciIsImdyMUNvbG9yIiwiZ3IxT3BhY2l0eSIsImdyMkNvbG9yIiwiZ3IyT3BhY2l0eSIsImdyYXlDb2xvciIsIm5vbUNvbG9yIiwidmFyQ29sb3IiLCJ0YWdnZWRDb2xvciIsInRpbWVDb2xvciIsImxlZnR0YWIiLCJzdWJzZXQiLCJzdW1tYXJ5SG9sZCIsInJpZ2h0dGFiIiwidCIsInR5cGVUcmFuc2Zvcm0iLCJ0cmFuc2Zvcm1MaXN0Iiwic3BsaXQiLCJ0cmFuc2Zvcm1WYXIiLCJ0cmFucyIsInByZXByb2Nlc3MiLCJzcGFjZXMiLCJsYXlvdXRBZGQiLCJsYXlvdXRNb3ZlIiwiYWxsUiIsImluZDEiLCJNYXRoIiwiY29zIiwic2luIiwiaW5kMiIsIm15c3BhY2UiLCJmb3JjZXRvZ2dsZSIsImxvY2t0b2dnbGUiLCJwcml2Iiwic3dhbmRpdmUiLCJmYWlsc2V0IiwibG9nQXJyYXkiLCJ6cGFyYW1zIiwiemRhdGEiLCJ6ZWRnZXMiLCJ6dGltZSIsInpub20iLCJ6Y3Jvc3MiLCJ6bW9kZWwiLCJ6dmFycyIsInpkdiIsInpncm91cDEiLCJ6Z3JvdXAyIiwiemRhdGF1cmwiLCJ6ZDNtZGF0YSIsInpkM210YXJnZXQiLCJ6c3Vic2V0IiwienNldHgiLCJ6bW9kZWxjb3VudCIsInpwbG90IiwienNlc3Npb25pZCIsInpkYXRhY2l0ZSIsIm1vZGVsQ291bnQiLCJ2YWx1ZUtleSIsImFsbE5vZGVzIiwiYWxsUmVzdWx0cyIsIm5vZGVzIiwibGlua3MiLCJtb2RzIiwiZXN0aW1hdGVkIiwicmlnaHRDbGlja0xhc3QiLCJzZWxJbnRlcmFjdCIsImNhbGxIaXN0b3J5IiwibXl0YXJnZXQiLCJjb25maWd1cmF0aW9ucyIsImRhdGFzY2hlbWEiLCJkM21NZXRyaWNzIiwibWV0cmljVW5kZWZpbmVkIiwiYWNjdXJhY3kiLCJmMSIsImYxTWljcm8iLCJmMU1hY3JvIiwicm9jQXVjIiwicm9jQXVjTWljcm8iLCJyb2NBdWNNYWNybyIsIm1lYW5TcXVhcmVkRXJyb3IiLCJyb290TWVhblNxdWFyZWRFcnJvciIsInJvb3RNZWFuU3F1YXJlZEVycm9yQXZnIiwibWVhbkFic29sdXRlRXJyb3IiLCJyU3F1YXJlZCIsIm5vcm1hbGl6ZWRNdXR1YWxJbmZvcm1hdGlvbiIsImphY2NhcmRTaW1pbGFyaXR5U2NvcmUiLCJleGVjdXRpb25UaW1lIiwiZDNtVGFza1R5cGUiLCJ0YXNrVHlwZVVuZGVmaW5lZCIsImNsYXNzaWZpY2F0aW9uIiwicmVncmVzc2lvbiIsInNpbWlsYXJpdHlNYXRjaGluZyIsImxpbmtQcmVkaWN0aW9uIiwidmVydGV4Tm9taW5hdGlvbiIsImNvbW11bml0eURldGVjdGlvbiIsImdyYXBoTWF0Y2hpbmciLCJ0aW1lc2VyaWVzRm9yZWNhc3RpbmciLCJjb2xsYWJvcmF0aXZlRmlsdGVyaW5nIiwiZDNtVGFza1N1YnR5cGUiLCJ0YXNrU3VidHlwZVVuZGVmaW5lZCIsInN1YnR5cGVOb25lIiwiYmluYXJ5IiwibXVsdGlDbGFzcyIsIm11bHRpTGFiZWwiLCJ1bmlWYXJpYXRlIiwibXVsdGlWYXJpYXRlIiwib3ZlcmxhcHBpbmciLCJub25PdmVybGFwcGluZyIsImQzbU91dHB1dFR5cGUiLCJvdXRwdXRVbmRlZmluZWQiLCJjbGFzc0xhYmVsIiwicHJvYmFiaWxpdHkiLCJyZWFsIiwibm9kZUlEIiwidmVjdG9yQ2xhc3NMYWJlbCIsInZlY3RvclN0b2NoYXN0aWMiLCJ2ZWN0b3JSZWFsIiwiZmlsZSIsImQzbVByb2JsZW1EZXNjcmlwdGlvbiIsInRhc2tUeXBlIiwidGFza1N1YnR5cGUiLCJvdXRwdXRUeXBlIiwibWV0cmljIiwidGFza0Rlc2NyaXB0aW9uIiwic3ZnIiwid2lkdGgiLCJoZWlnaHQiLCJkaXYiLCJlc3RpbWF0ZUxhZGRhIiwic2VsZWN0TGFkZGEiLCJhcmMxIiwiYXJjMyIsImFyYzQiLCJhcmNJbmQxIiwiYXJjSW5kMiIsImFyY0luZDFMaW1pdHMiLCJhcmNJbmQyTGltaXRzIiwiYnlJZCIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJpZCIsInJlc2V0IiwicmVsb2FkUGFnZSIsImxvY2F0aW9uIiwicmVsb2FkIiwiZGF0YXVybCIsImZpbGVpZCIsImhvc3RuYW1lIiwiZGRpdXJsIiwiYXBpa2V5IiwiYWxlcnQiLCJFcnJvciIsImRhdGF2ZXJzZXVybCIsIkRBVEFWRVJTRV9VUkwiLCJzZWxlY3QiLCJ0ZW1wV2lkdGgiLCJzdHlsZSIsInN1YnN0cmluZyIsImxlbmd0aCIsIiQiLCJ3aW5kb3ciLCJMYWRkYSIsImNyZWF0ZSIsImNvbG9yVGltZSIsImNvbG9yQ1MiLCJkZXBWYXIiLCJzdWJzZXRkaXYiLCJzZXR4ZGl2IiwiYmFyd2lkdGgiLCJiYXJoZWlnaHQiLCJiYXJQYWRkaW5nIiwiYmFybnVtYmVyIiwiYXJjIiwic3RhcnQiLCJlbmQiLCJpbm5lclJhZGl1cyIsIm91dGVyUmFkaXVzIiwic3RhcnRBbmdsZSIsImVuZEFuZ2xlIiwiYXJjSW5kIiwiYXJjbGltaXRzIiwiYXJjMCIsImFyYzIiLCJkYXRhc2V0MiIsImxhYmxBcnJheSIsImhvbGQiLCJzdWJzZXROb2RlcyIsIm9uIiwic2VsZWN0QWxsIiwiZGF0YSIsImVudGVyIiwiYXBwZW5kIiwidGV4dCIsImQiLCJyZW1vdmUiLCJkM21Sb290UGF0aCIsImQzbURhdGFOYW1lIiwiZDNtRGF0YSIsImQzbVRhcmdldCIsImQzbVByZXByb2Nlc3MiLCJkM21QUyIsImQzbURTIiwibWV0YWRhdGF1cmwiLCJwVVJMIiwiZDNtX21vZGUiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlcXVlc3QiLCJtZXRob2QiLCJ1cmwiLCJ0aGVuIiwicmVzdWx0IiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5IiwidHJhaW5pbmdfZGF0YV9yb290IiwicmVwbGFjZSIsIm5hbWUiLCJwcm9ibGVtX3NjaGVtYV91cmwiLCJkYXRhc2V0X3NjaGVtYV91cmwiLCJleGlzdHMiLCJwYXRoIiwicmVqZWN0IiwianNvbiIsIl8iLCJ0YXJnZXQiLCJmaWVsZCIsInRlbXAiLCJ4bWwiLCJkb2N1bWVudEVsZW1lbnQiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsImNoaWxkTm9kZXMiLCJub2RlVmFsdWUiLCJjaXRlIiwiZGF0YXNldHMiLCJkYXRhbmFtZSIsImh0bWwiLCJ0YXNrU3ViVHlwZSIsImRlc2NyaXB0aW9uRmlsZSIsImNsaWNrIiwiaW5kZXhPZiIsInRvVXBwZXJDYXNlIiwiZGF0YXZhcnMiLCJ0cmFpbkRhdGEiLCJ1bmRlZmluZWQiLCJpIiwicHVzaCIsInZhck5hbWUiLCJ0YXJnZXR2YXJzIiwidHJhaW5UYXJnZXRzIiwiZXJyIiwia2V5IiwiemVsaWc1bW9kZWxzIiwiaGFzT3duUHJvcGVydHkiLCJkZXNjcmlwdGlvbiIsInplbGlnNWNob2ljZW1vZGVscyIsInVzZXJfYWdlbnQiLCJ2ZXJzaW9uIiwiU2Vzc2lvblJlcXVlc3QiLCJqc29ub3V0IiwidXJsY2FsbCIsImQzbVVSTCIsInNvbGFqc29ub3V0IiwiZGxfY29udGVudCIsInJlc2V0X2NvbnRlbnQiLCJkZXB2YXJfaWQiLCJwcm9ibGVtX2luaXRpYWxpemVkX3RvdXIiLCJob3BzY290Y2giLCJlbmRUb3VyIiwic3RhcnRUb3VyIiwic3NTdWNjZXNzIiwiYnRuIiwiU2Vzc2lvblJlc3BvbnNlIiwiY29udGV4dCIsInNlc3Npb25JZCIsInNzRmFpbCIsIm1ha2VDb3JzUmVxdWVzdCIsInJlYWRQcmVwcm9jZXNzIiwidmFycyIsIk9iamVjdCIsImtleXMiLCJvYmoiLCJyZWZsZXhpdmUiLCJsYWJsIiwiY291bnQiLCJub2RlQ29sIiwiYmFzZUNvbCIsInN0cm9rZUNvbG9yIiwic3Ryb2tlV2lkdGgiLCJzdWJzZXRwbG90Iiwic3Vic2V0cmFuZ2UiLCJzZXR4cGxvdCIsInNldHh2YWxzIiwiZ3JheW91dCIsImdyb3VwMSIsImdyb3VwMiIsImZvcmVmcm9udCIsImpRdWVyeSIsImV4dGVuZCIsIm15aSIsImZpbmROb2RlSW5kZXgiLCJkM21EZXNjcmlwdGlvbiIsImFzc2lnbiIsInNjYWZmb2xkaW5nIiwibGF5b3V0IiwielBvcCIsImRhdGFEb3dubG9hZCIsIiRmaWxsIiwib3AiLCJkMSIsImQyIiwidHJhbnNpdGlvbiIsImF0dHIiLCJkZWxheSIsImR1cmF0aW9uIiwiZmlsbCIsImZpbGxUaGlzIiwic2VsZiIsImNhbGxiYWNrIiwiZGlzcGxheSIsImZhZGVPdXQiLCJ0MSIsInBvcyIsIm9mZnNldCIsInRvcCIsImZhZGVJbiIsIm4iLCJrZXl1cCIsImV2dCIsImtleUNvZGUiLCJ2YWwiLCJ0cmFuc1BhcnNlIiwidHJhbnNmb3JtIiwic2xpY2UiLCJ0dmFyIiwiY29uY2F0IiwicGFyZW50IiwiZmFuZGVPdXQiLCJzdG9wUHJvcGFnYXRpb24iLCJ0ZnVuYyIsInRjYWxsIiwidG9nZ2xlUmlnaHRCdXR0b25zIiwidG9TdHJpbmciLCJyZWRyYXciLCJjbGFzc0xpc3QiLCJhZGQiLCJiYWNrZ3JvdW5kQ29sb3IiLCJzcGxpY2UiLCJjb2xvciIsImFyZ3MiLCJmb3JFYWNoIiwieCIsImlkeCIsImNsaWNrVmFyIiwidiIsInYyIiwibXlWYWx1ZXMiLCJsaW5lIiwibGluZTIiLCJ2aXNiYWNrZ3JvdW5kIiwidmlzMmJhY2tncm91bmQiLCJ2aXMiLCJ2aXMyIiwiaiIsImlpIiwic2VsZWN0TWUiLCJoZXhUb1JnYmEiLCJteXNyYyIsIm5vZGVJbmRleCIsIm15dGd0Iiwic291cmNlIiwibGVmdCIsInJpZ2h0IiwiZm9yY2UiLCJzaXplIiwibGlua0Rpc3RhbmNlIiwiY2hhcmdlIiwidGljayIsImRyYWdfbGluZSIsImNpcmNsZSIsInNlbGVjdGVkX25vZGUiLCJzZWxlY3RlZF9saW5rIiwibW91c2Vkb3duX2xpbmsiLCJtb3VzZWRvd25fbm9kZSIsIm1vdXNldXBfbm9kZSIsInJlc2V0TW91c2VWYXJzIiwiZmluZGNvb3JkcyIsImZpbmRuYW1lcyIsImFsbG5hbWVzIiwiY29vcmRzIiwibGVuZ3RoZW4iLCJmY29vcmRzIiwiQXJyYXkiLCJhZGRsb2NhdGlvbiIsImRlbHRheCIsImRlbHRheSIsImRlbHRhIiwibGVuZ3RoZW5jb29yZHMiLCJtYXAiLCJ5IiwiZ3IxY29vcmRzIiwiZ3IyY29vcmRzIiwiZGVwY29vcmRzIiwibXlodWxsIiwiZ2VvbSIsImh1bGwiLCJqb2luIiwicCIsImphbWVzY2VudHJvaWQiLCJxIiwibGRlbHRhWCIsImxkZWx0YVkiLCJsZGlzdCIsInNxcnQiLCJsbm9ybVgiLCJsbm9ybVkiLCJsc291cmNlUGFkZGluZyIsImx0YXJnZXRQYWRkaW5nIiwic2lnbiIsIm1pbiIsImFscGhhIiwiZGVsdGFYIiwiZGVsdGFZIiwiZGlzdCIsIm5vcm1YIiwibm9ybVkiLCJzb3VyY2VQYWRkaW5nIiwidGFyZ2V0UGFkZGluZyIsInNvdXJjZVgiLCJzb3VyY2VZIiwidGFyZ2V0WCIsInRhcmdldFkiLCJzZXRQZWJibGVSYWRpdXMiLCJub2RlIiwiZmluZE5vZGUiLCJpbmNsdWRlcyIsImluZGV4Iiwic3BsaWNlTGlua3NGb3JOb2RlIiwibm9kZVJlc2V0IiwibGVnZW5kIiwicmVzdGFydCIsIm15Q29sb3IiLCJyZ2IiLCJjbGFzc05hbWUiLCJpbm5lckhUTUwiLCJ1cGRhdGVTY2hlbWEiLCJjYWxsIiwiZHJhZyIsImdyYXZpdHkiLCJzZXRQZWJibGVDaGFyZ2UiLCJsaW5rU3RyZW5ndGgiLCJyZXN1bWUiLCJjbGFzc2VkIiwiZXhpdCIsImciLCJlYWNoIiwicGxvdHR5cGUiLCJzdHIiLCJzZXRDb2xvcnMiLCJkZWZhdWx0TnVtY2hhciIsImV2ZW50IiwicHJldmVudERlZmF1bHQiLCJtb3VzZW1vdmUiLCJkaXJlY3Rpb24iLCJsaW5rIiwiZmlsdGVyIiwidmFyU3VtbWFyeSIsInNldEF0dHJpYnV0ZSIsInNlbGVjdGVkSW5kZXgiLCJtb3VzZWRvd24iLCJjdHJsS2V5IiwibW91c2UiLCJtb3VzZXVwIiwiZmFrZUNsaWNrIiwiY2xpY2tfZXYiLCJjcmVhdGVFdmVudCIsImluaXRFdmVudCIsImNsaWNrSUQiLCJkaXNwYXRjaEV2ZW50IiwiZmluZCIsIiRub2RlcyIsImFsbCIsIm5vZGVOYW1lIiwianNvbkRhdGEiLCJ2YXJpYWJsZXMiLCJ0eXBlIiwid2luIiwib3BlbiIsImZvY3VzIiwicXVlcnlTZWxlY3RvckFsbCIsImwiLCJzcmN0Z3QiLCJlc3RpbWF0ZVN1Y2Nlc3MiLCJzdG9wIiwicmVtb3ZlQ2hpbGQiLCJ0cmlnZ2VyIiwibW9kZWwiLCJtb2RDb2wiLCJpbnNlcnQiLCJhIiwiYiIsInN1YnN0ciIsInZpeiIsInJDYWxsIiwic2hvd0xvZyIsImVzdGltYXRlRmFpbCIsInNlbGVjdG9yU3VjY2VzcyIsInNlbGVjdG9yRmFpbCIsInJhcHBVUkwiLCJhbGxWYXJzIiwic2VsZWN0b3J1cmxjYWxsIiwic2VuZFBpcGVsaW5lU3VjY2VzcyIsIlBpcGVsaW5lQ3JlYXRlUmVzdWx0IiwicmVtb3ZlQ2xhc3MiLCJhZGRDbGFzcyIsImFsbFBpcGVsaW5lSW5mbyIsInBpcGVsaW5lSWQiLCJ0YWJ1bGF0ZSIsImNvbHVtbnMiLCJkaXZpZCIsInRhYmxlIiwidGhlYWQiLCJ0Ym9keSIsImNvbHVtbiIsInJvd3MiLCJjZWxscyIsInJvdyIsInZhbHVlIiwibXlyb3ciLCJwYXJlbnRFbGVtZW50IiwiZmlyc3RDaGlsZCIsImlubmVyVGV4dCIsImR2dmFsdWVzIiwicmVzdWx0c3RhYmxlIiwibXlpZCIsIm15bWV0cmljIiwibXl2YWwiLCJteXNjb3JlcyIsInBpcGVsaW5lSW5mbyIsInNjb3JlcyIsInRvRml4ZWQiLCJQaXBlbGluZUlEIiwicGlwZWxpbmVfaWRzIiwiUGlwZWxpbmVFeGVjdXRlUmVzdWx0c1JlcXVlc3QiLCJnZXRFeGVjdXRlUGlwZVN1Y2Nlc3MiLCJQaXBlbGluZUV4ZWN1dGVSZXN1bHQiLCJnZXRFeGVjdXRlUGlwZUZhaWwiLCJzZW5kUGlwZWxpbmVGYWlsIiwibXl2a2kiLCJhcGlTZXNzaW9uIiwidXJpIiwiZmVhdHVyZXMiLCJ0cmFpbkZlYXR1cmVzIiwiYXBpRmVhdHVyZVNob3J0UGF0aCIsInRhcmdldEZlYXR1cmVzIiwidGFzayIsIm91dHB1dCIsIm1ldHJpY3MiLCJ0YXNrRGVzY3JpcHRpb25yaXB0aW9uIiwibWF4UGlwZWxpbmVzIiwiUGlwZWxpbmVDcmVhdGVSZXF1ZXN0IiwiY3JlYXRlUGlwZWxpbmVTdWNjZXNzIiwicHJlZGljdG9ycyIsImRlcHZhciIsInJlc3BvbnNlSW5mbyIsInN0YXR1cyIsImRldGFpbHMiLCJjcmVhdGVQaXBlbGluZUZhaWwiLCJkYXRhbG9jIiwidGFyZ2V0bG9jIiwiZGF0YXN0dWIiLCJGb3JtRGF0YSIsImFzeW5jIiwiZGF0YXNldCIsInByaXZhdGUiLCJ0YTJzdHVmZiIsImRvd25sb2FkU3VjY2VzcyIsInNlc3Npb25pZCIsImhyZWYiLCJkb3dubG9hZEZhaWwiLCJteW0iLCJyZW1vdmVLaWRzIiwiZmlsZWxpc3QiLCJpbWFnZXMiLCJ6ZmlnIiwiY3JlYXRlRWxlbWVudCIsImFwcGVuZENoaWxkIiwicmVzdWx0c0FycmF5Iiwic3VtSW5mbyIsImNvbG5hbWVzIiwibXlOdW0iLCJOdW1iZXIiLCJpc05hTiIsInRvUHJlY2lzaW9uIiwib3V0MiIsInQyIiwiazIiLCJzdWJNZTIiLCJpbmRleGVkIiwibTIiLCJtYXRjaCIsInJlIiwiUmVnRXhwIiwicyIsInNlYXJjaCIsImZyb20iLCJ0byIsIm15biIsIm91dHR5cGVzIiwidmFybmFtZXNUeXBlcyIsImludGVydmFsIiwibnVtY2hhciIsIm5hdHVyZSIsInBsb3R2YWx1ZXMiLCJwbG90eCIsInRyYW5zZm9ybXN0dWZmIiwidHlwZVN0dWZmIiwidHJhbnNmb3JtU3VjY2VzcyIsIndhcm4iLCJmdW5jIiwic3Vic2V0ZWQiLCJuZXdWYXIiLCJlcnJvciIsImpzb25kYXRhIiwibXlJbmRleCIsIm9iajEiLCJkZWZhdWx0SW50ZXJ2YWwiLCJkZWZhdWx0TmF0dXJlIiwiZGVmYXVsdEJpbmFyeSIsInRyYW5zZm9ybUZhaWwiLCJjcmVhdGVDT1JTUmVxdWVzdCIsInhociIsIlhNTEh0dHBSZXF1ZXN0IiwiWERvbWFpblJlcXVlc3QiLCJzZXRSZXF1ZXN0SGVhZGVyIiwid2FybmluZ2NhbGxiYWNrIiwianNvbnN0cmluZyIsIm9ubG9hZCIsInJlc3BvbnNlVGV4dCIsIm5hbWVzIiwid2FybmluZyIsIm9uZXJyb3IiLCJyZWFkeVN0YXRlIiwic2VuZCIsImxlZnRwYW5lbE1lZGl1bSIsInJpZ2h0cGFuZWxNZWRpdW0iLCJmbiIsImQzQ2xpY2siLCJjaGlsZHJlbiIsImUiLCJteWNvbCIsImluaXRNb3VzZUV2ZW50IiwibG9hZFhNTERvYyIsIlhNTG5hbWUiLCJ4bWxEb2MiLCJyZXNwb25zZVhNTCIsIkFjdGl2ZVhPYmplY3QiLCJsb2FkIiwidGFiIiwicGFuZWwiLCJjbHMiLCJ0b2dnbGVSIiwiZXhwYW5kIiwiZ2V0QXR0cmlidXRlIiwidG9nZ2xlUkZ1bGwiLCJzdW1tYXJ5IiwicmludCIsImZvcm1hdCIsIm1lYW5DSSIsIm1lYW4iLCJsb3dlckJvdW5kIiwidXBwZXJCb3VuZCIsIm1lZGlhbiIsIm1vZGUiLCJmcmVxbW9kZSIsIm1pZCIsImZyZXFtaWQiLCJmZXdlc3QiLCJmcmVxZmV3ZXN0Iiwic2QiLCJtYXgiLCJpbnZhbGlkIiwidmFsaWQiLCJ1bmlxdWVzIiwiaGVyZmluZGFobCIsInBvcG92ZXJDb250ZW50IiwiaW50IiwicHJlYyIsInBvcHVwWCIsInRzZiIsInRlbXBYIiwidGVtcFkiLCJpZHMiLCJyZWdzdHIiLCJteW5hbWUiLCJleGVjIiwibm9kZWlkIiwicGFyc2VJbnQiLCJoZXgiLCJjIiwidGVtcGluZGV4IiwiaXNBcnJheSIsImR2bmFtZSIsIm5ncm91cDEiLCJuZ3JvdXAyIiwiY3NzIiwic3Vic2V0RW1wdHkiLCJzdWJzZXRzdHVmZiIsInN1YnNldFNlbGVjdFN1Y2Nlc3MiLCJncmF5T3V0cyIsIm15Tm9kZXMiLCJteVBhcmFtcyIsIm15VHJhbnMiLCJteUZvcmNlIiwibXlQcmVwcm9jZXNzIiwibXlMb2ciLCJteUhpc3RvcnkiLCJ2YXJPdXQiLCJyZVdyaXRlTG9nIiwicGxvdHkiLCJyZVBsb3QiLCJ3cyIsIlNlc3Npb25Db250ZXh0IiwiZW5kU3VjY2VzcyIsIlJlc3BvbnNlIiwiZW5kRmFpbCIsIlBpcGVMaW5lTGlzdFJlcXVlc3QiLCJsaXN0UGlwZXNTdWNjZXNzIiwiUGlwZWxpbmVMaXN0UmVzdWx0IiwicGlwZXMiLCJwaXBlbGluZUlkcyIsImxpc3RQaXBlc0ZhaWwiLCJ0YWJsZXJvdyIsInF1ZXJ5U2VsZWN0b3IiLCJwcmVkaWN0RmVhdHVyZXMiLCJhcGlGZWF0dXJlIiwibXlkYXRhIiwibXltZWFuIiwiUGlwZWxpbmVFeGVjdXRlUmVxdWVzdCIsImV4ZWN1dGVQaXBlU3VjY2VzcyIsImV4ZWN1dGVQaXBlRmFpbCIsInVwZGF0ZXMiLCJsb29rdXAiLCJSZXBsYWNlUHJvYmxlbVNjaGVtYUZpZWxkIiwiVXBkYXRlUHJvYmxlbVNjaGVtYVJlcXVlc3QiLCJ1c1N1Y2Nlc3MiLCJ1c0ZhaWwiLCJjb29yZCIsIm1pbngiLCJtYXh4IiwibWlueSIsIm1heHkiLCJ1cHBlcnNpemUiLCJuZzEiLCJuZzIiLCJtYXhuZyIsInNldCIsInNldFdpZHRocyIsImJ0bnMiLCJteXdpZHRoIiwiZXhwYW5kd2lkdGgiLCJzaHJpbmt3aWR0aCIsIm15bGlzIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm15YnRucyIsInBpZCIsInByZWRmaWxlIiwicHJlZGljdFJlc3VsdERhdGEiLCJmaWxlXzEiLCJwcmVkdmFscyIsInByZWRzIiwieGRhdGEiLCJ5ZGF0YSIsInJhbmRvbW51bWJlciIsImZsb29yIiwicmFuZG9tIiwib25seVVuaXF1ZSIsIm15Y291bnRzIiwibXlwYWlycyIsIm15dW5pcXVlcyIsInRlbXBjb3VudCIsInRlbXBwYWlyIiwibXlpbmRleCIsImNvbmZkYXRhIiwibWF0cml4ZGF0YSIsImNsYXNzZXMiLCJtYWlud2lkdGgiLCJjbGllbnRXaWR0aCIsIm1haW5oZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJjb25kaXYiLCJtYXJnaW5MZWZ0IiwiZmxvYXQiLCJsZWdkaXYiLCJtYXJnaW4iLCJib3R0b20iLCJNYXRyaXgiLCJvcHRpb25zIiwiY29udGFpbmVyIiwibGFiZWxzRGF0YSIsImxhYmVscyIsInN0YXJ0Q29sb3IiLCJzdGFydF9jb2xvciIsImVuZENvbG9yIiwiZW5kX2NvbG9yIiwid2lkdGhMZWdlbmQiLCJtYXhWYWx1ZSIsImxheWVyIiwibWluVmFsdWUiLCJudW1yb3dzIiwibnVtY29scyIsImJhY2tncm91bmQiLCJvcmRpbmFsIiwiZG9tYWluIiwicmFuZ2UiLCJyYW5nZUJhbmRzIiwiY29sb3JNYXAiLCJsaW5lYXIiLCJjZWxsIiwicmFuZ2VCYW5kIiwiY29sdW1uTGFiZWxzIiwicm93TGFiZWxzIiwieUF4aXMiLCJheGlzIiwib3JpZW50IiwidHAiLCJmcCIsInRuIiwicHJlY2lzaW9uIiwicmVjYWxsIiwicm91bmQiLCJjb21wdXRlZERhdGEiLCJ4X0F4aXMiLCJ5X0F4aXMiLCJ4X0F4aXNfbmFtZSIsInlfQXhpc19uYW1lIiwiZGF0YV9wbG90IiwibmFuQ291bnQiLCJuZXdOdW1iZXIxIiwibmV3TnVtYmVyMiIsInhheGlzIiwieWF4aXMiLCJzY29yZSIsInBhZGRpbmciLCJtaW5feCIsIm1heF94IiwiYXZnX3giLCJtaW5feSIsIm1heF95IiwiYXZnX3kiLCJ4U2NhbGUiLCJ5U2NhbGUiLCJ4QXhpcyIsInRpY2tTaXplIiwidGlja3MiLCJ6b29tIiwiYmVoYXZpb3IiLCJzY2FsZUV4dGVudCIsInpvb21lZCIsImNoYXJ0X3NjYXR0ZXIiLCJtYWluMSIsImdYIiwiZ1kiLCJjbGlwIiwicGFuWCIsInRyYW5zbGF0ZSIsInBhblkiLCJtYXhYIiwibWF4WSIsInJvd25hbWUiLCJ4dmFsIiwieDF2YWwiLCJteXN2ZyIsInBvcCIsInBpcGVsaW5lRXhlY1VyaSIsIlBpcGVsaW5lRXhwb3J0UmVxdWVzdCIsImV4cG9ydFN1Y2Nlc3MiLCJhbGVydG1lc3NhZ2UiLCJleHBvcnRGYWlsIiwib3V0IiwiZmVhdHVyZUlkIiwiZGF0YVVyaSIsInNob3J0VXJpIiwibGFzdEluZGV4T2YiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7UUF5TWdCQSxJLEdBQUFBLEk7UUFtdkRBQyxlLEdBQUFBLGU7UUFpQkFDLFcsR0FBQUEsVztRQVVBQyxhLEdBQUFBLGE7UUFXQUMsZSxHQUFBQSxlO1FBeURBQyxRLEdBQUFBLFE7UUEyZEFDLGEsR0FBQUEsYTtRQW1hQUMsSyxHQUFBQSxLO1FBb0NBQyxPLEdBQUFBLE87UUFZQUMsUSxHQUFBQSxRO1FBMEdBQyxVLEdBQUFBLFU7UUFnS0FDLFcsR0FBQUEsVztRQTRCQUMsWSxHQUFBQSxZO1FBeU5BQyxVLEdBQUFBLFU7UUF3QkFDLGEsR0FBQUEsYTtRQWlFQUMsZSxHQUFBQSxlO1FBa0lBQyxnQixHQUFBQSxnQjtRQTBFQUMsZSxHQUFBQSxlO1FBc0JBQyxXLEdBQUFBLFc7UUEyREFDLGUsR0FBQUEsZTtRQStSQUMsYSxHQUFBQSxhO1FBdU1BQyxTLEdBQUFBLFM7UUFpRUFDLGMsR0FBQUEsYztRQTRCQUMsYyxHQUFBQSxjOztBQWo0SWhCOzs7O0FBRUE7O0FBRUE7O0FBQ0E7Ozs7OztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDTyxJQUFJQyxvQkFBTSxTQUFOQSxHQUFNO0FBQUEsV0FBS0MsY0FBY0MsUUFBUUMsR0FBUixDQUFZQyxLQUFaLHFDQUFuQjtBQUFBLENBQVY7O0FBRVAsSUFBSUMsSUFBSSxDQUFSLEMsQ0FBVztBQUNYLElBQUlDLGdCQUFnQixJQUFwQjtBQUNBLElBQUlDLGFBQWEsSUFBakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSUMsU0FBU0MsR0FBR0MsS0FBSCxDQUFTQyxVQUFULEVBQWI7QUFDTyxJQUFJQyw0QkFBVSxTQUFkO0FBQ0EsSUFBSUMsNEJBQVUsU0FBZDtBQUNBLElBQUlDLDhCQUFXLFNBQWYsQyxDQUEyQjtBQUNsQyxJQUFJQyxhQUFhLENBQUMsQ0FBRCxFQUFHLENBQUgsQ0FBakI7QUFDTyxJQUFJQyw4QkFBVyxTQUFmO0FBQ1AsSUFBSUMsYUFBYSxDQUFDLENBQUQsRUFBRyxDQUFILENBQWpCOztBQUVBLElBQUlDLFlBQVksU0FBaEI7QUFDTyxJQUFJQyw4QkFBVyxTQUFmO0FBQ0EsSUFBSUMsOEJBQVcsU0FBZixDLENBQTBCO0FBQ2pDLElBQUlDLGNBQWMsU0FBbEIsQyxDQUE2QjtBQUN0QixJQUFJQyxnQ0FBWSxTQUFoQjs7QUFFQSxJQUFJQyw0QkFBVSxNQUFkLEMsQ0FBc0I7QUFDdEIsSUFBSUMsMEJBQVMsS0FBYjtBQUNBLElBQUlDLG9DQUFjLEtBQWxCO0FBQ0EsSUFBSUMsOEJBQVcsV0FBZixDLENBQTRCOztBQUVuQztBQUNBLElBQUlDLFVBQUo7QUFBQSxJQUFPQyxzQkFBUDtBQUNBLElBQUlDLGdCQUFnQiwwQ0FBMENDLEtBQTFDLENBQWdELEdBQWhELENBQXBCO0FBQ0EsSUFBSUMsZUFBZSxFQUFuQjs7QUFFQTtBQUNBO0FBQ0EsSUFBSUMsUUFBUSxFQUFaO0FBQ0EsSUFBSUMsYUFBYSxFQUFqQixDLENBQXFCO0FBQ3JCLElBQUlDLFNBQVMsRUFBYjs7QUFFQTtBQUNBLElBQU1DLFlBQVksS0FBbEI7QUFDQSxJQUFNQyxhQUFhLE1BQW5COztBQUVBO0FBQ0EsSUFBSUMsT0FBTyxFQUFYO0FBQ0EsSUFBSUMsT0FBTyxDQUFDLENBQUNELE9BQUssRUFBTixJQUFZRSxLQUFLQyxHQUFMLENBQVMsR0FBVCxDQUFiLEVBQTRCLENBQUMsQ0FBRCxJQUFJSCxPQUFLLEVBQVQsSUFBZUUsS0FBS0UsR0FBTCxDQUFTLEdBQVQsQ0FBM0MsRUFBeUQsQ0FBekQsQ0FBWCxDLENBQXVFO0FBQ3ZFLElBQUlDLE9BQU8sQ0FBQyxDQUFDTCxPQUFLLEVBQU4sSUFBWUUsS0FBS0MsR0FBTCxDQUFTLEdBQVQsQ0FBYixFQUE0QixDQUFDLENBQUQsSUFBSUgsT0FBSyxFQUFULElBQWVFLEtBQUtFLEdBQUwsQ0FBUyxHQUFULENBQTNDLEVBQXlELENBQXpELENBQVgsQyxDQUF1RTs7O0FBR3ZFO0FBQ0EsSUFBSUUsVUFBVSxDQUFkOztBQUVBLElBQUlDLGNBQWMsQ0FBQyxNQUFELENBQWxCO0FBQ0EsSUFBSUMsYUFBYSxJQUFqQjtBQUNBLElBQUlDLE9BQU8sSUFBWDs7QUFFQTtBQUNBO0FBQ0EsSUFBSUMsV0FBVyxLQUFmO0FBQ0EsSUFBSUMsVUFBVSxDQUFDLHVCQUFELEVBQXlCLGVBQXpCLEVBQXlDLGdCQUF6QyxFQUEwRCx1QkFBMUQsRUFBa0YsZUFBbEYsRUFBa0csZ0JBQWxHLENBQWQ7O0FBRU8sSUFBSUMsOEJBQVcsRUFBZjtBQUNBLElBQUlDLDRCQUFVO0FBQ2pCQyxXQUFPLEVBRFU7QUFFakJDLFlBQVEsRUFGUztBQUdqQkMsV0FBTyxFQUhVO0FBSWpCQyxVQUFNLEVBSlc7QUFLakJDLFlBQVEsRUFMUztBQU1qQkMsWUFBUSxFQU5TO0FBT2pCQyxXQUFPLEVBUFU7QUFRakJDLFNBQUssRUFSWTtBQVNqQkMsYUFBUyxFQVRRO0FBVWpCQyxhQUFTLEVBVlEsRUFVRTtBQUNuQkMsY0FBVSxFQVhPO0FBWWpCQyxjQUFVLEVBWk8sRUFZSDtBQUNkQyxnQkFBWSxFQWJLO0FBY2pCQyxhQUFTLEVBZFE7QUFlakJDLFdBQU8sRUFmVTtBQWdCakJDLGlCQUFhLENBaEJJO0FBaUJqQkMsV0FBTyxFQWpCVTtBQWtCakJDLGdCQUFZLEVBbEJLO0FBbUJqQkMsZUFBVztBQW5CTSxDQUFkOztBQXNCUCxJQUFJQyxhQUFhLENBQWpCO0FBQ08sSUFBSUMsOEJBQVcsRUFBZjtBQUNBLElBQUlDLDhCQUFXLEVBQWY7QUFDUCxJQUFJQyxhQUFhLEVBQWpCO0FBQ08sSUFBSUMsd0JBQVEsRUFBWjtBQUNQLElBQUlDLFFBQVEsRUFBWjtBQUNBLElBQUlDLE9BQU8sRUFBWDtBQUNBLElBQUlDLFlBQVksS0FBaEI7QUFDQSxJQUFJQyxpQkFBaUIsS0FBckI7QUFDQSxJQUFJQyxjQUFjLEtBQWxCO0FBQ0EsSUFBSUMsY0FBYyxFQUFsQixDLENBQXNCO0FBQ3RCLElBQUlDLFdBQVcsRUFBZjs7QUFFQSxJQUFJQyxpQkFBaUIsRUFBckI7QUFDQSxJQUFJQyxhQUFhLEVBQWpCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUlDLGFBQWEsRUFBRUMsaUJBQWdCLENBQUMsYUFBRCxFQUFnQixrQkFBaEIsRUFBcUMsQ0FBckMsQ0FBbEI7QUFDYkMsY0FBVyxDQUFDLGFBQUQsRUFBZ0IsVUFBaEIsRUFBNkIsQ0FBN0IsQ0FERTtBQUVqQkMsUUFBRyxDQUFDLGFBQUQsRUFBZ0IsSUFBaEIsRUFBdUIsQ0FBdkIsQ0FGYztBQUdqQkMsYUFBUSxDQUFDLGFBQUQsRUFBZ0IsVUFBaEIsRUFBNkIsQ0FBN0IsQ0FIUztBQUlqQkMsYUFBUSxDQUFDLGFBQUQsRUFBZ0IsVUFBaEIsRUFBNkIsQ0FBN0IsQ0FKUztBQUtqQkMsWUFBTyxDQUFDLGFBQUQsRUFBZ0IsU0FBaEIsRUFBNEIsQ0FBNUIsQ0FMVTtBQU1qQkMsaUJBQVksQ0FBQyxhQUFELEVBQWdCLGVBQWhCLEVBQWtDLENBQWxDLENBTks7QUFPakJDLGlCQUFZLENBQUMsYUFBRCxFQUFnQixlQUFoQixFQUFrQyxDQUFsQyxDQVBLO0FBUWpCQyxzQkFBaUIsQ0FBQyxhQUFELEVBQWdCLHlCQUFoQixFQUEyQyxDQUEzQyxDQVJBO0FBU2pCQywwQkFBcUIsQ0FBQyxhQUFELEVBQWdCLHlCQUFoQixFQUE0QyxDQUE1QyxDQVRKO0FBVWpCQyw2QkFBd0IsQ0FBQyxhQUFELEVBQWdCLDZCQUFoQixFQUFnRCxDQUFoRCxDQVZQO0FBV2pCQyx1QkFBa0IsQ0FBQyxhQUFELEVBQWdCLHFCQUFoQixFQUF3QyxFQUF4QyxDQVhEO0FBWWpCQyxjQUFTLENBQUMsYUFBRCxFQUFnQixXQUFoQixFQUE4QixFQUE5QixDQVpRO0FBYWpCQyxpQ0FBNEIsQ0FBQyxhQUFELEVBQWdCLCtCQUFoQixFQUFrRCxFQUFsRCxDQWJYO0FBY2JDLDRCQUF1QixDQUFDLGFBQUQsRUFBZ0IsMEJBQWhCLEVBQTZDLEVBQTdDLENBZFY7QUFlYkMsbUJBQWMsQ0FBQyxhQUFELEVBQWdCLGdCQUFoQixFQUFtQyxFQUFuQyxDQWZELEVBQWpCOztBQWlCQSxJQUFJQyxjQUFjLEVBQUNDLG1CQUFrQixDQUFDLGFBQUQsRUFBZSxxQkFBZixFQUFzQyxDQUF0QyxDQUFuQixFQUE0REMsZ0JBQWUsQ0FBQyxhQUFELEVBQWdCLGdCQUFoQixFQUFtQyxDQUFuQyxDQUEzRTtBQUNsQkMsZ0JBQVcsQ0FBQyxhQUFELEVBQWdCLFlBQWhCLEVBQStCLENBQS9CLENBRE87QUFFbEJDLHdCQUFtQixDQUFDLGFBQUQsRUFBZ0IscUJBQWhCLEVBQXdDLENBQXhDLENBRkQ7QUFHbEJDLG9CQUFlLENBQUMsYUFBRCxFQUFnQixpQkFBaEIsRUFBb0MsQ0FBcEMsQ0FIRztBQUlsQkMsc0JBQWlCLENBQUMsYUFBRCxFQUFnQixtQkFBaEIsRUFBc0MsQ0FBdEMsQ0FKQztBQUtsQkMsd0JBQW1CLENBQUMsYUFBRCxFQUFnQixxQkFBaEIsRUFBd0MsQ0FBeEMsQ0FMRDtBQU1sQkMsbUJBQWMsQ0FBQyxhQUFELEVBQWdCLGdCQUFoQixFQUFtQyxDQUFuQyxDQU5JO0FBT2xCQywyQkFBc0IsQ0FBQyxhQUFELEVBQWdCLHdCQUFoQixFQUEyQyxDQUEzQyxDQVBKO0FBUWRDLDRCQUF1QixDQUFDLGFBQUQsRUFBZ0IseUJBQWhCLEVBQTRDLENBQTVDLENBUlQsRUFBbEI7O0FBVUEsSUFBSUMsaUJBQWlCLEVBQUNDLHNCQUFxQixDQUFDLGFBQUQsRUFBZ0Isd0JBQWhCLEVBQTBDLENBQTFDLENBQXRCO0FBQ3JCQyxpQkFBWSxDQUFDLGFBQUQsRUFBZSxNQUFmLEVBQXNCLENBQXRCLENBRFM7QUFFakJDLFlBQU8sQ0FBQyxhQUFELEVBQWdCLFFBQWhCLEVBQTJCLENBQTNCLENBRlU7QUFHckJDLGdCQUFXLENBQUMsYUFBRCxFQUFnQixZQUFoQixFQUErQixDQUEvQixDQUhVO0FBSXJCQyxnQkFBVyxDQUFDLGFBQUQsRUFBZ0IsWUFBaEIsRUFBK0IsQ0FBL0IsQ0FKVTtBQUtyQkMsZ0JBQVcsQ0FBQyxhQUFELEVBQWdCLFlBQWhCLEVBQStCLENBQS9CLENBTFU7QUFNckJDLGtCQUFhLENBQUMsYUFBRCxFQUFnQixjQUFoQixFQUFpQyxDQUFqQyxDQU5RO0FBT3JCQyxpQkFBWSxDQUFDLGFBQUQsRUFBZ0IsYUFBaEIsRUFBZ0MsQ0FBaEMsQ0FQUztBQVFqQkMsb0JBQWUsQ0FBQyxhQUFELEVBQWdCLGdCQUFoQixFQUFtQyxDQUFuQyxDQVJFLEVBQXJCOztBQVVBLElBQUlDLGdCQUFnQixFQUFDQyxpQkFBZ0IsQ0FBQyxhQUFELEVBQWUsd0JBQWYsRUFBeUMsQ0FBekMsQ0FBakI7QUFDcEJDLGdCQUFXLENBQUMsYUFBRCxFQUFlLGFBQWYsRUFBOEIsQ0FBOUIsQ0FEUztBQUVwQkMsaUJBQVksQ0FBQyxhQUFELEVBQWUsYUFBZixFQUE4QixDQUE5QixDQUZRO0FBR3BCQyxVQUFLLENBQUMsYUFBRCxFQUFlLE1BQWYsRUFBdUIsQ0FBdkIsQ0FIZTtBQUlwQkMsWUFBTyxDQUFDLGFBQUQsRUFBZSxTQUFmLEVBQTBCLENBQTFCLENBSmE7QUFLcEJDLHNCQUFpQixDQUFDLGFBQUQsRUFBZSxvQkFBZixFQUFxQyxDQUFyQyxDQUxHO0FBTWhCQyxzQkFBaUIsQ0FBQyxhQUFELEVBQWUsbUJBQWYsRUFBb0MsQ0FBcEMsQ0FORDtBQU9oQkMsZ0JBQVcsQ0FBQyxhQUFELEVBQWUsYUFBZixFQUE4QixDQUE5QixDQVBLO0FBUWhCQyxVQUFLLENBQUMsYUFBRCxFQUFlLE1BQWYsRUFBc0IsQ0FBdEIsQ0FSVyxFQUFwQjs7QUFVQSxJQUFJQyx3QkFBd0I7QUFDNUJDLGNBQVUsQ0FBQyxDQUFELEVBQUcsU0FBSCxDQURrQjtBQUU1QkMsaUJBQWEsQ0FBQyxDQUFELEVBQUcsVUFBSCxDQUZlO0FBRzVCQyxnQkFBWSxDQUFDLENBQUQsRUFBRyxTQUFILENBSGdCO0FBSXhCQyxZQUFRLENBQUMsQ0FBRCxFQUFHLFNBQUgsQ0FKZ0I7QUFLeEJDLHFCQUFpQixFQUxPLEVBQTVCOztBQVFBLElBQUlDLFlBQUo7QUFBQSxJQUFTQyxjQUFUO0FBQUEsSUFBZ0JDLGVBQWhCO0FBQUEsSUFBd0JDLFlBQXhCO0FBQUEsSUFBNkJDLHNCQUE3QjtBQUFBLElBQTRDQyxvQkFBNUM7QUFDQSxJQUFJQyxhQUFKO0FBQUEsSUFBVUMsYUFBVjtBQUFBLElBQWdCQyxhQUFoQjtBQUFBLElBQXNCQyxnQkFBdEI7QUFBQSxJQUErQkMsZ0JBQS9COztBQUVBLElBQUlDLGdCQUFnQixDQUFDLENBQUQsRUFBRyxHQUFILENBQXBCO0FBQ0EsSUFBSUMsZ0JBQWdCLENBQUMsSUFBRCxFQUFNLElBQU4sQ0FBcEI7O0FBRUEsSUFBSUMsT0FBTyxTQUFQQSxJQUFPO0FBQUEsV0FBTUMsU0FBU0MsY0FBVCxDQUF3QkMsRUFBeEIsQ0FBTjtBQUFBLENBQVg7O0FBRUE7QUFDTyxJQUFNQyx3QkFBUSxTQUFTQyxVQUFULEdBQXNCO0FBQ3pDQyxhQUFTQyxNQUFUO0FBQ0QsQ0FGTTs7QUFLUCxJQUFJQyxVQUFVLEVBQWQ7QUFDTyxTQUFTdkwsSUFBVCxDQUFjd0wsTUFBZCxFQUFzQkMsUUFBdEIsRUFBZ0NDLE1BQWhDLEVBQXdDSCxPQUF4QyxFQUFpREksTUFBakQsRUFBeUQ7QUFDNURKLGNBQVVBLE9BQVY7QUFDQSxRQUFJOUosY0FBYytKLFVBQVUsRUFBNUIsRUFBZ0M7QUFDNUJJLGNBQU0scUNBQU47QUFDQSxjQUFNLElBQUlDLEtBQUosQ0FBVSxxQ0FBVixDQUFOO0FBQ0g7O0FBRUQsUUFBSUMsZUFBZUwsV0FBVyxhQUFhQSxRQUF4QixHQUNmaEssYUFBYXNLLGFBQWIsR0FDQSx1QkFGSjs7QUFJQSxRQUFJUCxVQUFVLENBQUNELE9BQWYsRUFBd0I7QUFDcEI7QUFDQTtBQUNBQSxrQkFBVU8sZUFBZSx1QkFBZixHQUF5Q04sTUFBbkQ7QUFDQTtBQUNBRCxrQkFBVUEsVUFBVSxPQUFWLEdBQW9CSSxNQUE5QjtBQUNIO0FBQ0RuSyxRQUFJLGdCQUFnQitKLE9BQXBCO0FBQ0EvSixRQUFJLHFCQUFxQnNLLFlBQXpCO0FBQ0E1QixVQUFNakksR0FBRytKLE1BQUgsQ0FBVSxhQUFWLENBQU47O0FBRUEsUUFBSUMsWUFBWWhLLEdBQUcrSixNQUFILENBQVUsWUFBVixFQUF3QkUsS0FBeEIsQ0FBOEIsT0FBOUIsQ0FBaEI7QUFDQS9CLFlBQVE4QixVQUFVRSxTQUFWLENBQW9CLENBQXBCLEVBQXVCRixVQUFVRyxNQUFWLEdBQW1CLENBQTFDLENBQVI7QUFDQWhDLGFBQVNpQyxFQUFFQyxNQUFGLEVBQVVsQyxNQUFWLEtBQXFCLEdBQTlCLENBeEI0RCxDQXdCekI7O0FBRW5DRSxvQkFBZ0JpQyxNQUFNQyxNQUFOLENBQWF6QixLQUFLLGFBQUwsQ0FBYixDQUFoQjtBQUNBUixrQkFBY2dDLE1BQU1DLE1BQU4sQ0FBYXpCLEtBQUssV0FBTCxDQUFiLENBQWQ7O0FBRUEsUUFBSTBCLFlBQVksS0FBaEI7QUFDQSxRQUFJQyxVQUFVLEtBQWQ7O0FBRUEsUUFBSUMsU0FBUyxLQUFiO0FBQ0EsUUFBSUMsWUFBWSxLQUFoQjtBQUNBLFFBQUlDLFVBQVUsS0FBZDs7QUFFQTtBQUNBLFFBQUlDLFdBQVcsTUFBTWpKLElBQXJCO0FBQ0EsUUFBSWtKLFlBQVksTUFBTWxKLElBQXRCO0FBQ0EsUUFBSW1KLGFBQWEsSUFBakI7QUFDQSxRQUFJQyxZQUFZLENBQWhCOztBQUVBO0FBQ0EsUUFBSUMsTUFBTSxTQUFOQSxHQUFNLENBQUNDLEtBQUQsRUFBUUMsR0FBUjtBQUFBLGVBQWdCbkwsR0FBR2lJLEdBQUgsQ0FBT2dELEdBQVAsR0FDckJHLFdBRHFCLENBQ1R4SixPQUFPLENBREUsRUFFckJ5SixXQUZxQixDQUVUekosT0FBTyxFQUZFLEVBR3JCMEosVUFIcUIsQ0FHVkosS0FIVSxFQUlyQkssUUFKcUIsQ0FJWkosR0FKWSxDQUFoQjtBQUFBLEtBQVY7QUFLQSxRQUFJSyxTQUFTLFNBQVRBLE1BQVMsQ0FBQ0MsU0FBRDtBQUFBLGVBQWV6TCxHQUFHaUksR0FBSCxDQUFPZ0QsR0FBUCxHQUN2QkcsV0FEdUIsQ0FDWHhKLE9BQU8sRUFESSxFQUV2QnlKLFdBRnVCLENBRVh6SixPQUFPLEVBRkksRUFHdkIwSixVQUh1QixDQUdaRyxVQUFVLENBQVYsQ0FIWSxFQUl2QkYsUUFKdUIsQ0FJZEUsVUFBVSxDQUFWLENBSmMsQ0FBZjtBQUFBLEtBQWI7O0FBaEQ0RCxlQXNEekMsQ0FBQ1IsSUFBSSxDQUFKLEVBQU8sR0FBUCxDQUFELEVBQWNBLElBQUksR0FBSixFQUFTLEdBQVQsQ0FBZCxDQXREeUM7QUFBQSxRQXNEdkRTLElBdER1RDtBQUFBLFFBc0RqREMsSUF0RGlEO0FBdUQ1RDs7QUFDQXBELFdBQU8wQyxJQUFJLENBQUosRUFBTSxDQUFOLENBQVA7QUFDQXpDLFdBQU95QyxJQUFJLEdBQUosRUFBUyxHQUFULENBQVA7QUFDQXhDLFdBQU93QyxJQUFJLEdBQUosRUFBUyxHQUFULENBQVA7O0FBRUF2QyxjQUFVOEMsT0FBTzVDLGFBQVAsQ0FBVjtBQUNBRCxjQUFVNkMsT0FBTzNDLGFBQVAsQ0FBVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQUkrQyxXQUFXLEVBQWY7QUFDQSxRQUFJQyxZQUFZLEVBQWhCO0FBQ0EsUUFBSUMsT0FBTyxFQUFYO0FBQ0EsUUFBSUMsY0FBYyxFQUFsQjs7QUFFQTtBQUNBM0IsTUFBRSxjQUFGLEVBQWtCNEIsRUFBbEIsQ0FBcUIsbUJBQXJCLEVBQTBDO0FBQUEsZUFBTWhNLEdBQUcrSixNQUFILENBQVUsNkJBQVYsRUFBeUNrQyxTQUF6QyxDQUFtRCxHQUFuRCxFQUMzQ0MsSUFEMkMsQ0FDdEMxSixRQURzQyxFQUUzQzJKLEtBRjJDLEdBRzNDQyxNQUgyQyxDQUdwQyxHQUhvQyxFQUkzQ0MsSUFKMkMsQ0FJdEM7QUFBQSxtQkFBS0MsQ0FBTDtBQUFBLFNBSnNDLENBQU47QUFBQSxLQUExQztBQUtBbEMsTUFBRSxjQUFGLEVBQWtCNEIsRUFBbEIsQ0FBcUIsb0JBQXJCLEVBQTJDO0FBQUEsZUFBTWhNLEdBQUcrSixNQUFILENBQVUsNkJBQVYsRUFBeUNrQyxTQUF6QyxDQUFtRCxHQUFuRCxFQUM1Q00sTUFENEMsRUFBTjtBQUFBLEtBQTNDOztBQUdBO0FBQ0EsUUFBSUMsY0FBYyxFQUFsQjtBQUNBLFFBQUlDLGNBQWMsRUFBbEI7QUFDQSxRQUFJQyxVQUFVLElBQWQ7QUFDQSxRQUFJQyxZQUFZLElBQWhCO0FBQ0EsUUFBSUMsZ0JBQWdCLEVBQXBCO0FBQ0EsUUFBSUMsUUFBUSxFQUFaO0FBQ0EsUUFBSUMsUUFBUSxFQUFaOztBQUVBO0FBQ0EsUUFBSVosT0FBTyxXQUFXLFFBQVEsWUFBUixHQUF1QixjQUFsQyxDQUFYO0FBQ0EsUUFBSWEsY0FBY3RELFdBQVdGLFNBQVlNLFlBQVosMkJBQThDTixNQUE5QyxHQUF5RDJDLE9BQU8sTUFBM0UsQ0FBbEI7QUFDQTtBQUNBLFFBQUljLE9BQU8xRCxVQUFhQSxPQUFiLG9CQUFxQzRDLE9BQU8sT0FBdkQ7O0FBRUEsUUFBR2UsUUFBSCxFQUFhO0FBQ1RELGVBQU9KLGFBQVA7QUFDQTtBQUNBO0FBQ0gsS0FKRCxNQUlPLElBQUcsQ0FBQ3BOLFVBQUosRUFBZ0I7QUFDbkJpRCxnQkFBUVcsUUFBUixHQUFtQix1QkFBbkI7QUFDSDs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7OztBQWdCQThKLFlBQVFDLE9BQVIsQ0FBZ0JGLFlBQVksa0JBQUVHLE9BQUYsQ0FBVTtBQUNsQ0MsZ0JBQVEsTUFEMEI7QUFFbENDLGFBQUs7QUFGNkIsS0FBVixFQUkzQkMsSUFKMkIsQ0FJdEIsVUFBU0MsTUFBVCxFQUFpQjtBQUNuQi9JLHlCQUFrQmdKLEtBQUtDLEtBQUwsQ0FBV0QsS0FBS0UsU0FBTCxDQUFlSCxNQUFmLENBQVgsQ0FBbEI7QUFDQWhCLHNCQUFjL0gsZUFBZW1KLGtCQUE3QjtBQUNBcEIsc0JBQWNBLFlBQVlxQixPQUFaLENBQW9CLFFBQXBCLEVBQTZCLEVBQTdCLENBQWQ7QUFDQXBCLHNCQUFjaEksZUFBZXFKLElBQTdCO0FBQ0Y7QUFDQztBQUNDakIsZ0JBQVFwSSxlQUFlc0osa0JBQXZCO0FBQ0FqQixnQkFBUXJJLGVBQWV1SixrQkFBdkI7O0FBRUV2TyxnQkFBUUMsR0FBUixDQUFZLGtCQUFaO0FBQ0FELGdCQUFRQyxHQUFSLENBQVkrRSxjQUFaOztBQUVGO0FBQ0E7QUFDQTs7QUFFQXVJLGVBQUssNEJBQTBCUCxXQUExQixHQUFzQyw2QkFBM0M7QUFDQUcsd0JBQWNJLElBQWQ7QUFDSCxLQXZCMkIsQ0FBNUIsRUF3QkNPLElBeEJELENBd0JNO0FBQUEsZUFBSyxrQkFBRUgsT0FBRixDQUFVO0FBQ2pCQyxvQkFBUSxLQURTO0FBRWpCQyxpQkFBSztBQUZZLFNBQVYsRUFJVkMsSUFKVSxDQUlMLFVBQVNDLE1BQVQsRUFBaUI7QUFDbkI7QUFDQTtBQUNBLGdCQUFHQSxPQUFPdEIsSUFBUCxDQUFZLGVBQVosRUFBNkIrQixNQUE3QixJQUFxQyxJQUF4QyxFQUNJdkIsVUFBUWMsT0FBT3RCLElBQVAsQ0FBWSxlQUFaLEVBQTZCZ0MsSUFBckMsQ0FESixLQUVLLElBQUdWLE9BQU90QixJQUFQLENBQVksa0JBQVosRUFBZ0MrQixNQUFoQyxJQUF3QyxJQUEzQyxFQUNEdkIsVUFBUWMsT0FBT3RCLElBQVAsQ0FBWSxrQkFBWixFQUFnQ2dDLElBQXhDOztBQUVKLGdCQUFHVixPQUFPdEIsSUFBUCxDQUFZLGtCQUFaLEVBQWdDK0IsTUFBaEMsSUFBd0MsSUFBM0MsRUFDSXRCLFlBQVVhLE9BQU90QixJQUFQLENBQVksa0JBQVosRUFBZ0NnQyxJQUExQyxDQURKLEtBRUssSUFBR1YsT0FBT3RCLElBQVAsQ0FBWSxxQkFBWixFQUFtQytCLE1BQW5DLElBQTJDLElBQTlDLEVBQ0R0QixZQUFVYSxPQUFPdEIsSUFBUCxDQUFZLHFCQUFaLEVBQW1DZ0MsSUFBN0M7O0FBRUp6TCxvQkFBUVksUUFBUixHQUFtQnFKLE9BQW5CO0FBQ0FqSyxvQkFBUWEsVUFBUixHQUFxQnFKLFNBQXJCO0FBQ0gsU0FuQlUsQ0FBTDtBQUFBLEtBeEJOLEVBNENDWSxJQTVDRCxDQTRDTTtBQUFBLGVBQU0sSUFBSUwsT0FBSixDQUFZLFVBQUNDLE9BQUQsRUFBVWdCLE1BQVYsRUFBcUI7QUFDckM7QUFDQSxnQkFBSSxDQUFDbEIsUUFBTCxFQUNJLE9BQU9FLFNBQVA7O0FBRUpuTixlQUFHb08sSUFBSCxDQUFRdkIsS0FBUixFQUFlLFVBQUN3QixDQUFELEVBQUluQyxJQUFKLEVBQWE7QUFDeEJ6TSx3QkFBUUMsR0FBUixDQUFZLG9CQUFaLEVBQWtDd00sSUFBbEM7QUFDQTFILDJCQUFXMEgsS0FBS29DLE1BQUwsQ0FBWUMsS0FBdkI7O0FBRUosb0JBQUlDLE9BQUssRUFBVDtBQUNBLG9CQUFHLENBQUN2QixRQUFKLEVBQWM7QUFDVnVCLDJCQUFPQyxJQUFJQyxlQUFKLENBQW9CQyxvQkFBcEIsQ0FBeUMsVUFBekMsQ0FBUCxDQURVLENBQ3VEO0FBQ2pFbE0sNEJBQVFDLEtBQVIsR0FBZ0I4TCxLQUFLLENBQUwsRUFBUUksVUFBUixDQUFtQixDQUFuQixFQUFzQkMsU0FBdEM7QUFDQSx3QkFBSUMsT0FBT0wsSUFBSUMsZUFBSixDQUFvQkMsb0JBQXBCLENBQXlDLFNBQXpDLENBQVg7QUFDQTtBQUNBbE0sNEJBQVFtQixTQUFSLEdBQW9Ca0wsS0FBSyxDQUFMLEVBQVFGLFVBQVIsQ0FBbUIsQ0FBbkIsRUFBc0JDLFNBQXRCLENBQ2ZoQixPQURlLENBQ1AsS0FETyxFQUNBLEtBREEsRUFFZkEsT0FGZSxDQUVQLEtBRk8sRUFFQSxHQUZBLEVBR2ZBLE9BSGUsQ0FHUCxLQUhPLEVBR0EsR0FIQSxDQUFwQjtBQUlBekQsc0JBQUUsc0JBQUYsRUFBMEJpQyxJQUExQixDQUErQjVKLFFBQVFtQixTQUF2QztBQUNILGlCQVZELE1BVU87QUFDSG5CLDRCQUFRQyxLQUFSLEdBQWdCd0osS0FBSzZDLFFBQUwsQ0FBYyxDQUFkLENBQWhCLENBREcsQ0FDMkM7QUFDakQ7QUFDRDtBQUNBLG9CQUFJQyxXQUFXdk0sUUFBUUMsS0FBdkI7QUFDQSxvQkFBRyxDQUFDdUssUUFBSixFQUFjO0FBQ1YrQiwrQkFBV3ZNLFFBQVFDLEtBQVIsQ0FBY21MLE9BQWQsQ0FBc0IsUUFBdEIsRUFBZ0MsRUFBaEMsQ0FBWCxDQURVLENBQ3NDO0FBQ25EOztBQUVEN04sbUJBQUcrSixNQUFILENBQVUsV0FBVixFQUF1QmtGLElBQXZCLENBQTRCRCxRQUE1QjtBQUNBO0FBQ0FoUCxtQkFBRytKLE1BQUgsQ0FBVSxPQUFWLEVBQW1Ca0YsSUFBbkIsQ0FBd0IsZUFBZUQsUUFBdkM7O0FBRVE7QUFDSjs7Ozs7Ozs7O0FBU0Esb0JBQUc5QyxLQUFLdEUsUUFBTCxJQUFpQmhDLFdBQXBCLEVBQWlDO0FBQzdCK0IsMENBQXNCQyxRQUF0QixHQUFpQ3NFLEtBQUt0RSxRQUF0QyxDQUQ2QixDQUNrQjtBQUNsRCxpQkFGRCxNQUVPO0FBQ0hELDBDQUFzQkMsUUFBdEIsR0FBaUMsbUJBQWpDO0FBQ0g7QUFDQTs7QUFFRCxvQkFBR3NFLEtBQUtnRCxXQUFMLElBQW9CM0ksY0FBdkIsRUFBdUM7QUFDbkNvQiwwQ0FBc0JFLFdBQXRCLEdBQW9DcUUsS0FBS2dELFdBQXpDO0FBQ0E7QUFDQyxpQkFITCxNQUdXO0FBQ0h2SCwwQ0FBc0JFLFdBQXRCLEdBQW9DLHNCQUFwQztBQUNMO0FBQ0U7QUFDTCxvQkFBR3FFLEtBQUtuRSxNQUFMLElBQWVwRCxVQUFsQixFQUE4QjtBQUMxQmdELDBDQUFzQkksTUFBdEIsR0FBK0JtRSxLQUFLbkUsTUFBcEMsQ0FEMEIsQ0FDaUI7QUFDOUMsaUJBRkQsTUFFTztBQUNISiwwQ0FBc0JJLE1BQXRCLEdBQStCLGlCQUEvQjtBQUNEO0FBQ0U7QUFDTCxvQkFBR21FLEtBQUtwRSxVQUFMLElBQW1CYixhQUF0QixFQUFxQztBQUNqQ1UsMENBQXNCRyxVQUF0QixHQUFtQ29FLEtBQUtwRSxVQUF4QyxDQURpQyxDQUNrQjtBQUN0RCxpQkFGRCxNQUVPO0FBQ0hILDBDQUFzQkcsVUFBdEIsR0FBbUMsaUJBQW5DO0FBQ0Y7QUFDRDs7QUFFREgsc0NBQXNCSyxlQUF0QixHQUF3Q2tFLEtBQUtpRCxlQUE3Qzs7QUFHQXBHLHlCQUFTQyxjQUFULENBQXdCLFNBQXhCLEVBQW1Db0csS0FBbkM7O0FBRUo7QUFDSSxvQkFBRzdNLFFBQVE4TSxPQUFSLENBQWdCMUgsc0JBQXNCQyxRQUF0QixDQUErQjBILFdBQS9CLEVBQWhCLEtBQWlFLENBQUMsQ0FBckUsRUFDSW5DLFVBREosS0FFSztBQUNEN0ssK0JBQVMsSUFBVDtBQUNBNks7QUFDSDtBQUNKLGFBN0VEO0FBOEVILFNBbkZPLENBQU47QUFBQSxLQTVDTixFQWdJS0ksSUFoSUwsQ0FnSVU7QUFBQSxlQUFNLElBQUlMLE9BQUosQ0FBWSxVQUFDQyxPQUFELEVBQVVnQixNQUFWLEVBQXFCO0FBQUU7QUFDM0MsZ0JBQUksQ0FBQ2xCLFFBQUwsRUFBYztBQUFDLHVCQUFPRSxTQUFQO0FBQWtCOztBQUVqQztBQUNBbk4sZUFBR29PLElBQUgsQ0FBUXRCLEtBQVIsRUFBZSxVQUFDdUIsQ0FBRCxFQUFJbkMsSUFBSixFQUFhO0FBQ3hCeEgsNkJBQWMrSSxLQUFLQyxLQUFMLENBQVdELEtBQUtFLFNBQUwsQ0FBZXpCLElBQWYsQ0FBWCxDQUFkOztBQUVBO0FBQ0Esb0JBQUc1SixRQUFILEVBQWE7QUFDVCx3QkFBSWlOLFdBQVc3SyxXQUFXOEssU0FBWCxDQUFxQkEsU0FBcEM7QUFDQSx3QkFBR0QsYUFBYUUsU0FBaEIsRUFBMkI7QUFDdkIsNkJBQUksSUFBSUMsSUFBSSxDQUFaLEVBQWVBLElBQUlILFNBQVNwRixNQUE1QixFQUFvQ3VGLEdBQXBDLEVBQXlDO0FBQ3JDNUwscUNBQVM2TCxJQUFULENBQWNKLFNBQVNHLENBQVQsRUFBWUUsT0FBMUI7QUFDSDtBQUNKO0FBQ0Qsd0JBQUlDLGFBQWFuTCxXQUFXOEssU0FBWCxDQUFxQk0sWUFBdEM7QUFDQSx3QkFBR0QsZUFBZUosU0FBbEIsRUFBNkI7QUFDekIsNkJBQUksSUFBSUMsS0FBSSxDQUFaLEVBQWVBLEtBQUlHLFdBQVcxRixNQUE5QixFQUFzQ3VGLElBQXRDLEVBQTJDO0FBQ3ZDNUwscUNBQVM2TCxJQUFULENBQWNFLFdBQVdILEVBQVgsRUFBY0UsT0FBNUI7QUFDSDtBQUNKO0FBQ0Qsd0JBQUc5TCxTQUFTcUcsTUFBVCxJQUFpQixDQUFwQjtBQUNJO0FBQ0FSLDhCQUFNLDZFQUFOO0FBQ1A7O0FBRURsSyx3QkFBUUMsR0FBUixDQUFZLG9CQUFaLEVBQWtDZ0YsVUFBbEM7QUFDQXlJO0FBQ0gsYUF4QkQ7QUF5QkgsU0E3QlcsQ0FBTjtBQUFBLEtBaElWLEVBOEpLSSxJQTlKTCxDQThKVTtBQUFBLGVBQU0sSUFBSUwsT0FBSixDQUFZLFVBQUNDLE9BQUQsRUFBVWdCLE1BQVYsRUFBcUI7QUFBRTtBQUMzQyxnQkFBSWxCLFFBQUosRUFDSSxPQUFPRSxTQUFQO0FBQ0o7QUFDQW5OLGVBQUdvTyxJQUFILENBQVEsd0JBQVIsRUFBa0MsVUFBQzJCLEdBQUQsRUFBTTdELElBQU4sRUFBZTtBQUM3QyxvQkFBSTZELEdBQUosRUFDSSxPQUFPNUIsT0FBTzRCLEdBQVAsQ0FBUDtBQUNKeFEsb0JBQUkscUJBQUosRUFBMkIyTSxJQUEzQjtBQUNBLHFCQUFLLElBQUk4RCxHQUFULElBQWdCOUQsS0FBSytELFlBQXJCO0FBQ0ksd0JBQUkvRCxLQUFLK0QsWUFBTCxDQUFrQkMsY0FBbEIsQ0FBaUNGLEdBQWpDLENBQUosRUFDSTdMLEtBQUsrSCxLQUFLK0QsWUFBTCxDQUFrQkQsR0FBbEIsRUFBdUJsQyxJQUF2QixDQUE0QixDQUE1QixDQUFMLElBQXVDNUIsS0FBSytELFlBQUwsQ0FBa0JELEdBQWxCLEVBQXVCRyxXQUF2QixDQUFtQyxDQUFuQyxDQUF2QztBQUZSLGlCQUdBaEQ7QUFDSCxhQVJEO0FBU0gsU0FiVyxDQUFOO0FBQUEsS0E5SlYsRUE0S0tJLElBNUtMLENBNEtVO0FBQUEsZUFBTSxJQUFJTCxPQUFKLENBQVksVUFBQ0MsT0FBRCxFQUFVZ0IsTUFBVixFQUFxQjtBQUFFO0FBQzNDLGdCQUFJbEIsUUFBSixFQUNJLE9BQU9FLFNBQVA7QUFDSm5OLGVBQUdvTyxJQUFILENBQVEsOEJBQVIsRUFBd0MsVUFBQzJCLEdBQUQsRUFBTTdELElBQU4sRUFBZTtBQUNuRCxvQkFBSTZELEdBQUosRUFDSSxPQUFPNUIsT0FBTzRCLEdBQVAsQ0FBUDtBQUNKeFEsb0JBQUksNEJBQUosRUFBa0MyTSxJQUFsQztBQUNBLHFCQUFLLElBQUk4RCxHQUFULElBQWdCOUQsS0FBS2tFLGtCQUFyQixFQUF5QztBQUNyQyx3QkFBSWxFLEtBQUtrRSxrQkFBTCxDQUF3QkYsY0FBeEIsQ0FBdUNGLEdBQXZDLENBQUosRUFDSTdMLEtBQUsrSCxLQUFLa0Usa0JBQUwsQ0FBd0JKLEdBQXhCLEVBQTZCbEMsSUFBN0IsQ0FBa0MsQ0FBbEMsQ0FBTCxJQUE2QzVCLEtBQUtrRSxrQkFBTCxDQUF3QkosR0FBeEIsRUFBNkJHLFdBQTdCLENBQXlDLENBQXpDLENBQTdDO0FBQ1A7QUFDTGhEO0FBQ0MsYUFURDtBQVVILFNBYlcsQ0FBTjtBQUFBLEtBNUtWLEVBMExLSSxJQTFMTCxDQTBMVTtBQUFBLGVBQU0sSUFBSUwsT0FBSixDQUFZLFVBQUNDLE9BQUQsRUFBVWdCLE1BQVYsRUFBcUI7QUFBRTtBQUN2QyxnQkFBSSxDQUFDbEIsUUFBTCxFQUNJLE9BQU9FLFNBQVA7QUFDSjs7QUFFQSxnQkFBSWtELGFBQWEsWUFBakI7QUFDQSxnQkFBSUMsVUFBVSxjQUFkO0FBQ0EsZ0JBQUlDLGlCQUFlLEVBQUNGLHNCQUFELEVBQVlDLGdCQUFaLEVBQW5COztBQUVBLGdCQUFJRSxVQUFVL0MsS0FBS0UsU0FBTCxDQUFlNEMsY0FBZixDQUFkO0FBQ0EsZ0JBQUlFLFVBQVVDLFNBQVMsZUFBdkI7QUFDQSxnQkFBSUMsY0FBYyxpQkFBaUJILE9BQW5DO0FBQ0EvUSxvQkFBUUMsR0FBUixDQUFZLGtCQUFaO0FBQ0FELG9CQUFRQyxHQUFSLENBQVlpUixXQUFaO0FBQ0FsUixvQkFBUUMsR0FBUixDQUFZLFdBQVosRUFBeUIrUSxPQUF6Qjs7QUFFQSxnQkFBRzVRLGFBQUgsRUFBaUI7QUFBRTtBQUNmLG9CQUFJK1EsYUFBYSxnTEFBakI7QUFDQSxvQkFBSUMsZ0JBQWdCLHdFQUFwQjtBQUNBLG9CQUFJQyxZQUFZdE0sV0FBVyxVQUEzQjtBQUNBLG9CQUFJdU0sMkJBQTJCO0FBQzdCLDBCQUFNLGdCQUR1QjtBQUU1Qiw0QkFBUTtBQUNQLG1DQUFVO0FBREgscUJBRm9CO0FBSzdCLDZCQUFTLENBQ1A7QUFDRSxrQ0FBVSxVQURaLEVBQ3dCO0FBQ3RCLHFDQUFhLFFBRmY7QUFHRSxpQ0FBUyw2QkFIWDtBQUlFLG1DQUFXSCxVQUpiO0FBS0UseUNBQWdCLElBTGxCO0FBTUUsb0NBQVksd0JBTmQ7QUFPRSxpQ0FBUyxpQkFBVztBQUNsQkksc0NBQVVDLE9BQVYsQ0FBa0IsSUFBbEI7QUFDQXBSLDRDQUFnQixLQUFoQjtBQUNEO0FBVkgscUJBRE8sRUFhUDtBQUNFLGtDQUFVLFVBRFo7QUFFRSxxQ0FBYSxRQUZmO0FBR0UsaUNBQVMsMEJBSFg7QUFJRSxtQ0FBV2dSLGFBSmI7QUFLRSx5Q0FBZ0IsSUFMbEI7QUFNRSxvQ0FBWSx3QkFOZDtBQU9FLGlDQUFTLGlCQUFXO0FBQ2xCRyxzQ0FBVUMsT0FBVixDQUFrQixJQUFsQjtBQUNBcFIsNENBQWdCLEtBQWhCO0FBQ0Q7QUFWSCxxQkFiTyxFQXlCUDtBQUNFLGtDQUFVLGFBRFo7QUFFRSxxQ0FBYSxNQUZmO0FBR0UsaUNBQVMsZUFIWDtBQUlFLG1DQUFXLG9MQUpiO0FBS0UseUNBQWdCLElBTGxCO0FBTUUsb0NBQVksd0JBTmQ7QUFPRSxpQ0FBUyxpQkFBVztBQUNsQm1SLHNDQUFVQyxPQUFWLENBQWtCLElBQWxCO0FBQ0FwUiw0Q0FBZ0IsS0FBaEI7QUFDRDtBQVZILHFCQXpCTyxFQXFDUDtBQUNFLGtDQUFVaVIsU0FEWixFQUN1QjtBQUNyQixxQ0FBYSxNQUZmO0FBR0UsaUNBQVMsaUJBSFg7QUFJRSxtQ0FBVywyQkFBMkJ0TSxRQUEzQixHQUFzQyw4R0FKbkQ7QUFLRSx5Q0FBZ0IsSUFMbEI7QUFNRSxvQ0FBWSx3QkFOZDtBQU9FLGlDQUFTLGlCQUFXO0FBQ2xCd00sc0NBQVVDLE9BQVYsQ0FBa0IsSUFBbEI7QUFDQXBSLDRDQUFnQixLQUFoQjtBQUNEO0FBVkgscUJBckNPLEVBaURQO0FBQ0Usa0NBQVUsU0FEWjtBQUVFLHFDQUFhLE9BRmY7QUFHRSxpQ0FBUyxpQkFIWDtBQUlFLG1DQUFXLDJEQUpiO0FBS0UseUNBQWdCLElBTGxCO0FBTUUsb0NBQVksd0JBTmQ7QUFPRSxpQ0FBUyxpQkFBVztBQUNsQm1SLHNDQUFVQyxPQUFWLENBQWtCLElBQWxCO0FBQ0FwUiw0Q0FBZ0IsS0FBaEI7QUFDRDtBQVZILHFCQWpETyxFQTZEUDtBQUNFLGtDQUFVLGNBRFo7QUFFRSxxQ0FBYSxPQUZmO0FBR0UsaUNBQVMsZUFIWDtBQUlFLG1DQUFXLG1MQUpiO0FBS0UseUNBQWdCLElBTGxCO0FBTUUsb0NBQVksd0JBTmQ7QUFPRSxpQ0FBUyxpQkFBVztBQUNsQm1SLHNDQUFVQyxPQUFWLENBQWtCLElBQWxCO0FBQ0FwUiw0Q0FBZ0IsS0FBaEI7QUFDRDtBQVZILHFCQTdETyxFQXlFUDtBQUNFLGtDQUFVLGVBRFo7QUFFRSxxQ0FBYSxRQUZmO0FBR0UsaUNBQVMsZ0JBSFg7QUFJRSxtQ0FBVywrR0FKYjtBQUtFLHlDQUFnQixJQUxsQjtBQU1FLG9DQUFZLHdCQU5kO0FBT0UsaUNBQVMsaUJBQVc7QUFDbEJtUixzQ0FBVUMsT0FBVixDQUFrQixJQUFsQjtBQUNBcFIsNENBQWdCLEtBQWhCO0FBQ0Q7QUFWSCxxQkF6RU8sQ0FMb0I7QUEyRjdCLHVDQUFrQixLQTNGVztBQTRGN0Isc0NBQWtCLEdBNUZXO0FBNkY3Qiw2QkFBVSxpQkFBVztBQUNoQkMscUNBQWEsS0FBYjtBQUNBO0FBL0Z3QixpQkFBL0I7QUFpR0FMLHdCQUFRQyxHQUFSLENBQVkseUJBQVo7QUFDQXNSLDBCQUFVRSxTQUFWLENBQW9CSCx3QkFBcEI7QUFDQXRSLHdCQUFRQyxHQUFSLENBQVksdUJBQVo7QUFDSDs7QUFFRCxxQkFBU3lSLFNBQVQsQ0FBbUJDLEdBQW5CLEVBQXdCQyxlQUF4QixFQUF5QztBQUNyQzVSLHdCQUFRQyxHQUFSLENBQVksZ0JBQVosRUFBOEIyUixlQUE5QjtBQUNBNU8sd0JBQVFrQixVQUFSLEdBQW1CME4sZ0JBQWdCQyxPQUFoQixDQUF3QkMsU0FBM0M7QUFDQXBFO0FBQ0g7O0FBRUQscUJBQVNxRSxNQUFULENBQWdCSixHQUFoQixFQUFxQjtBQUNqQnpILHNCQUFNLDBCQUFOO0FBQ0F3RTtBQUNIOztBQUVEc0QsNEJBQWdCaEIsT0FBaEIsRUFBeUIsVUFBekIsRUFBcUNVLFNBQXJDLEVBQWdESyxNQUFoRCxFQUF3RGIsV0FBeEQ7QUFDUCxTQXRJVyxDQUFOO0FBQUEsS0ExTFYsRUFpVUNwRCxJQWpVRCxDQWlVTTtBQUFBLGVBQUssa0JBQUVILE9BQUYsQ0FBVUosSUFBVixDQUFMO0FBQUEsS0FqVU4sRUFrVUNPLElBbFVELENBa1VNLGdCQUFRO0FBQUU7QUFDWixZQUFHLENBQUNqTCxRQUFKLEVBQ0lvUCxlQUFleEYsSUFBZjtBQUNILEtBclVMLEVBcVVPLGFBQUs7QUFBRTtBQUNWLFlBQUcsQ0FBQzVKLFFBQUosRUFDSWpFLGNBQWNxTyxPQUFkLEVBQXVCQyxTQUF2QixFQUFrQ0YsV0FBbEM7QUFDSCxLQXhVTCxFQXlVQ2MsSUF6VUQsQ0F5VU07QUFBQSxlQUFNLElBQUlMLE9BQUosQ0FBWSxVQUFDQyxPQUFELEVBQVVnQixNQUFWLEVBQXFCO0FBQ3pDLGdCQUFHN0wsUUFBSCxFQUNJNks7O0FBRUosZ0JBQUl3RSxPQUFPQyxPQUFPQyxJQUFQLENBQVlyUSxVQUFaLENBQVg7O0FBRUE7QUFDQXNLLG1CQUFPLENBQUMsRUFBRCxFQUFLLEVBQUwsRUFBUyxFQUFULEVBQWEsRUFBYixFQUFpQixFQUFqQixFQUFxQixFQUFyQixFQUF5QixFQUF6QixDQUFQO0FBQ0EsaUJBQUssSUFBSTRELElBQUksQ0FBYixFQUFnQkEsSUFBSWlDLEtBQUt4SCxNQUF6QixFQUFpQ3VGLEdBQWpDLEVBQXNDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E1TCx5QkFBUzRMLENBQVQsSUFBY2lDLEtBQUtqQyxDQUFMLENBQWQ7QUFDQTdELDBCQUFVNkQsQ0FBVixJQUFlLFVBQWY7QUFDQTtBQUNBO0FBQ0Esb0JBQUlvQyxNQUFNO0FBQ043SSx3QkFBSXlHLENBREU7QUFFTnFDLCtCQUFXLEtBRkw7QUFHTmpFLDBCQUFNaEssU0FBUzRMLENBQVQsQ0FIQTtBQUlOc0MsMEJBQU1uRyxVQUFVNkQsQ0FBVixDQUpBO0FBS054RCwwQkFBTSxDQUFDLENBQUQsRUFBSSxFQUFKLEVBQVEsRUFBUixFQUFZLENBQVosRUFBZSxDQUFmLEVBQWtCLEVBQWxCLEVBQXNCLEVBQXRCLENBTEE7QUFNTitGLDJCQUFPbkcsSUFORDtBQU9Ob0csNkJBQVNuUyxPQUFPMlAsQ0FBUCxDQVBIO0FBUU55Qyw2QkFBU3BTLE9BQU8yUCxDQUFQLENBUkg7QUFTTjBDLG1EQVRNO0FBVU5DLGlDQUFhLEdBVlA7QUFXTkMsZ0NBQVksS0FYTjtBQVlOQyxpQ0FBYSxDQUFDLEVBQUQsRUFBSyxFQUFMLENBWlA7QUFhTkMsOEJBQVUsS0FiSjtBQWNOQyw4QkFBVSxDQUFDLEVBQUQsRUFBSyxFQUFMLENBZEo7QUFlTkMsNkJBQVMsS0FmSDtBQWdCTkMsNEJBQVEsS0FoQkY7QUFpQk5DLDRCQUFRLEtBakJGO0FBa0JOQywrQkFBVztBQWxCTCxpQkFBVjtBQW9CQUMsdUJBQU9DLE1BQVAsQ0FBYyxJQUFkLEVBQW9CakIsR0FBcEIsRUFBeUJ0USxXQUFXc0MsU0FBUzRMLENBQVQsQ0FBWCxDQUF6QjtBQUNBM0wseUJBQVM0TCxJQUFULENBQWNtQyxHQUFkO0FBQ0g7QUFDRDNFO0FBQ0gsU0E1Q1csQ0FBTjtBQUFBLEtBelVOLEVBc1hDSSxJQXRYRCxDQXNYTTtBQUFBLGVBQU0sSUFBSUwsT0FBSixDQUFZLFVBQUNDLE9BQUQsRUFBVWdCLE1BQVYsRUFBcUI7QUFBRTtBQUMzQyxnQkFBRyxDQUFDbEIsUUFBRCxJQUFhM0ssUUFBaEIsRUFDSSxPQUFPNkssU0FBUDtBQUNKO0FBQ0EsZ0JBQUlvQyxXQUFXN0ssV0FBVzhLLFNBQVgsQ0FBcUJBLFNBQXBDO0FBQ0EsaUJBQUksSUFBSUUsSUFBSSxDQUFaLEVBQWVBLElBQUlILFNBQVNwRixNQUE1QixFQUFvQ3VGLEdBQXBDLEVBQXlDO0FBQ3JDLG9CQUFJc0QsTUFBTUMsY0FBYzFELFNBQVNHLENBQVQsRUFBWUUsT0FBMUIsQ0FBVjtBQUNBLG9CQUFJc0QsaUJBQWlCLEVBQUNBLGdCQUFlM0QsU0FBU0csQ0FBVCxDQUFoQixFQUFyQjtBQUNBM0wseUJBQVNpUCxHQUFULElBQWdCcEIsT0FBT3VCLE1BQVAsQ0FBY3BQLFNBQVNpUCxHQUFULENBQWQsRUFBNkJFLGNBQTdCLENBQWhCO0FBQ0g7QUFDRHpULG9CQUFRQyxHQUFSLENBQVlxRSxRQUFaO0FBQ0FvSjtBQUNILFNBWlcsQ0FBTjtBQUFBLEtBdFhOLEVBbVlDSSxJQW5ZRCxDQW1ZTSxZQUFPO0FBQUU7QUFDZjtBQUNJLFlBQUdqTCxRQUFILEVBQWE7QUFDVDhRLHdCQUFZOVEsUUFBWjtBQUNILFNBRkQsTUFFTztBQUNIOFEsd0JBQVlDLE1BQVo7QUFDQSxnQkFBSXBHLFFBQUosRUFBYztBQUNWcUc7QUFDSCxhQUZELE1BRU87QUFDSEM7QUFDSDtBQUNKO0FBQ0Y7QUFDRixLQWhaRDtBQWlaSDs7QUFHRCxJQUFJQyxRQUFRLFNBQVJBLEtBQVEsQ0FBQzFCLEdBQUQsRUFBTTJCLEVBQU4sRUFBVUMsRUFBVixFQUFjQyxFQUFkO0FBQUEsV0FBcUIzVCxHQUFHK0osTUFBSCxDQUFVK0gsR0FBVixFQUFlOEIsVUFBZixHQUM1QkMsSUFENEIsQ0FDdkIsY0FEdUIsRUFDUEosRUFETyxFQUU1QkssS0FGNEIsQ0FFdEJKLEVBRnNCLEVBRzVCSyxRQUg0QixDQUduQkosRUFIbUIsQ0FBckI7QUFBQSxDQUFaO0FBSUEsSUFBSUssT0FBTyxTQUFQQSxJQUFPLENBQUMxSCxDQUFELEVBQUlyRCxFQUFKLEVBQVF3SyxFQUFSLEVBQVlDLEVBQVosRUFBZ0JDLEVBQWhCO0FBQUEsV0FBdUJILE1BQU0sTUFBTXZLLEVBQU4sR0FBV3FELEVBQUVyRCxFQUFuQixFQUF1QndLLEVBQXZCLEVBQTJCQyxFQUEzQixFQUErQkMsRUFBL0IsQ0FBdkI7QUFBQSxDQUFYO0FBQ0EsSUFBSU0sV0FBVyxTQUFYQSxRQUFXLENBQUNDLElBQUQsRUFBT1QsRUFBUCxFQUFXQyxFQUFYLEVBQWVDLEVBQWY7QUFBQSxXQUFzQkgsTUFBTVUsSUFBTixFQUFZVCxFQUFaLEVBQWdCQyxFQUFoQixFQUFvQkMsRUFBcEIsQ0FBdEI7QUFBQSxDQUFmOztBQUVBO0FBQ0EsU0FBU1AsV0FBVCxDQUFxQmUsUUFBckIsRUFBK0I7QUFBQTs7QUFDL0IxVSxZQUFRQyxHQUFSLENBQVksYUFBWjtBQUNJO0FBQ0o7QUFDRTtBQUNDO0FBQ0M7QUFDQztBQUNDOztBQUVGO0FBQ0FNLE9BQUcrSixNQUFILENBQVUsa0JBQVYsRUFDS3FDLE1BREwsQ0FDWSxJQURaLEVBRUt5SCxJQUZMLENBRVUsSUFGVixFQUVnQixVQUZoQixFQUdLNUosS0FITCxDQUdXLFNBSFgsRUFHc0IsTUFIdEIsRUFJS0EsS0FKTCxDQUlXLGtCQUpYLEVBSStCdEosUUFKL0IsRUFLS3NMLFNBTEwsQ0FLZSxJQUxmLEVBTUtDLElBTkwsQ0FNVSxDQUFDLEdBQUQsRUFBTSxHQUFOLENBTlYsRUFNc0I7QUFOdEIsS0FPS0MsS0FQTCxHQVFLQyxNQVJMLENBUVksSUFSWixFQVNLQyxJQVRMLENBU1U7QUFBQSxlQUFLQyxDQUFMO0FBQUEsS0FUVjs7QUFXQTtBQUNBdE0sT0FBRytKLE1BQUgsQ0FBVSxrQkFBVixFQUNLcUMsTUFETCxDQUNZLElBRFosRUFFS3lILElBRkwsQ0FFVSxJQUZWLEVBRWdCLFdBRmhCLEVBR0s1SixLQUhMLENBR1csU0FIWCxFQUdzQixNQUh0QixFQUlLQSxLQUpMLENBSVcsa0JBSlgsRUFJK0J0SixRQUovQixFQUtLc0wsU0FMTCxDQUtlLElBTGYsRUFNS0MsSUFOTCxDQU1VOUssYUFOVixFQU9LK0ssS0FQTCxHQVFLQyxNQVJMLENBUVksSUFSWixFQVNLQyxJQVRMLENBU1U7QUFBQSxlQUFLQyxDQUFMO0FBQUEsS0FUVjs7QUFXQSxRQUFHLENBQUNXLFFBQUosRUFBYTtBQUFLOztBQUVkN0MsVUFBRSxTQUFGLEVBQWFnRixLQUFiLENBQW1CLFlBQU07QUFDckIsZ0JBQUlsTyxJQUFJNEgsS0FBSyxVQUFMLEVBQWlCbUIsS0FBakIsQ0FBdUJtSyxPQUEvQjtBQUNBLGdCQUFJbFQsTUFBTSxNQUFWLEVBQWtCO0FBQUU7QUFDaEJrSixrQkFBRSxXQUFGLEVBQWVpSyxPQUFmLENBQXVCLEdBQXZCO0FBQ0EsdUJBQU8sS0FBUDtBQUNIO0FBQ0QsZ0JBQUlDLEtBQUt4TCxLQUFLLFdBQUwsRUFBa0JtQixLQUFsQixDQUF3Qm1LLE9BQWpDO0FBQ0EsZ0JBQUlFLE9BQU8sTUFBWCxFQUFtQjtBQUFFO0FBQ2pCbEssa0JBQUUsWUFBRixFQUFnQmlLLE9BQWhCLENBQXdCLEdBQXhCO0FBQ0EsdUJBQU8sS0FBUDtBQUNIOztBQUVEO0FBQ0FqSyxxQkFBUUwsTUFBUjtBQUNBLGdCQUFJd0ssTUFBTW5LLEVBQUUsU0FBRixFQUFhb0ssTUFBYixFQUFWO0FBQ0FELGdCQUFJRSxHQUFKLElBQVdySyxFQUFFLFNBQUYsRUFBYWxDLEtBQWIsRUFBWDtBQUNBa0MsY0FBRSxXQUFGLEVBQWVzSyxNQUFmLENBQXNCLEdBQXRCO0FBQ0EsbUJBQU8sS0FBUDtBQUNILFNBbEJEOztBQW9CQSxZQUFJQyxDQUFKO0FBQ0F2SyxVQUFFLFNBQUYsRUFBYXdLLEtBQWIsQ0FBbUIsZUFBTztBQUN0QixnQkFBSTFULElBQUk0SCxLQUFLLFVBQUwsRUFBaUJtQixLQUFqQixDQUF1Qm1LLE9BQS9CO0FBQ0EsZ0JBQUlFLEtBQUt4TCxLQUFLLFdBQUwsRUFBa0JtQixLQUFsQixDQUF3Qm1LLE9BQWpDO0FBQ0EsZ0JBQUlsVCxLQUFLLE1BQVQsRUFBaUJrSixFQUFFLFdBQUYsRUFBZWlLLE9BQWYsQ0FBdUIsR0FBdkIsRUFBakIsS0FDSyxJQUFJQyxNQUFNLE1BQVYsRUFBa0JsSyxFQUFFLFlBQUYsRUFBZ0JpSyxPQUFoQixDQUF3QixHQUF4Qjs7QUFFdkIsZ0JBQUlRLElBQUlDLE9BQUosSUFBZSxFQUFuQixFQUF1QjtBQUFFO0FBQ3JCSCxvQkFBSXZLLEVBQUUsU0FBRixFQUFhMkssR0FBYixFQUFKO0FBQ0Esb0JBQUk3VCxJQUFJOFQsV0FBV0wsSUFBRUEsQ0FBYixDQUFSO0FBQ0Esb0JBQUksQ0FBQ3pULENBQUwsRUFDSTtBQUNKK1QsMEJBQVVOLElBQUl6VCxFQUFFZ1UsS0FBRixDQUFRLENBQVIsRUFBV2hVLEVBQUVpSixNQUFGLEdBQVcsQ0FBdEIsQ0FBZCxFQUF3Q2pKLElBQUlBLEVBQUVBLEVBQUVpSixNQUFGLEdBQVcsQ0FBYixDQUE1QyxFQUE2RGhKLGdCQUFnQixLQUE3RTtBQUNIO0FBQ0osU0FiRDs7QUFlQSxZQUFJRCxDQUFKO0FBQ0FrSixVQUFFLGVBQUYsRUFBbUJnRixLQUFuQixDQUF5QixVQUFTeUYsR0FBVCxFQUFhO0FBQ2xDO0FBQ0EsZ0JBQUl6SyxFQUFFLElBQUYsRUFBUWlDLElBQVIsTUFBa0IsZUFBdEIsRUFBdUM7QUFDbkNqQyxrQkFBRSxTQUFGLEVBQWEySyxHQUFiLENBQWlCSSxLQUFLQyxNQUFMLENBQVksR0FBWixDQUFqQjtBQUNBOVEsOEJBQWMsSUFBZDtBQUNBOEYsa0JBQUUsSUFBRixFQUFRaUwsTUFBUixHQUFpQkMsUUFBakIsQ0FBMEIsR0FBMUI7QUFDQWxMLGtCQUFFLFdBQUYsRUFBZXNLLE1BQWYsQ0FBc0IsR0FBdEI7QUFDQUcsb0JBQUlVLGVBQUo7QUFDQTtBQUNIOztBQUVELGdCQUFJSixPQUFPL0ssRUFBRSxTQUFGLEVBQWEySyxHQUFiLEVBQVg7QUFDQSxnQkFBSVMsUUFBUXBMLEVBQUUsSUFBRixFQUFRaUMsSUFBUixHQUFld0IsT0FBZixDQUF1QixHQUF2QixFQUE0QixZQUE1QixDQUFaO0FBQ0EsZ0JBQUk0SCxRQUFRckwsRUFBRSxJQUFGLEVBQVFpQyxJQUFSLEdBQWV3QixPQUFmLENBQXVCLEdBQXZCLEVBQTRCc0gsSUFBNUIsQ0FBWjtBQUNBL0ssY0FBRSxTQUFGLEVBQWEySyxHQUFiLENBQWlCVSxLQUFqQjtBQUNBckwsY0FBRSxJQUFGLEVBQVFpTCxNQUFSLEdBQWlCaEIsT0FBakIsQ0FBeUIsR0FBekI7QUFDQVEsZ0JBQUlVLGVBQUo7QUFDQU4sc0JBQVVOLElBQUlRLElBQWQsRUFBb0JqVSxJQUFJc1UsS0FBeEIsRUFBK0JyVSxnQkFBZ0IsS0FBL0M7QUFDSCxTQWxCRDtBQW1CSDs7QUFFRG5CLE9BQUcrSixNQUFILENBQVUsU0FBVixFQUNLRSxLQURMLENBQ1csUUFEWCxFQUNxQixJQURyQixFQUVLQSxLQUZMLENBRVcsVUFGWCxFQUV1QixRQUZ2Qjs7QUFJQSxRQUFHLENBQUNnRCxRQUFKLEVBQWE7QUFDYmpOLFdBQUcrSixNQUFILENBQVUsU0FBVixFQUFxQmtDLFNBQXJCLENBQStCLEdBQS9CLEVBQ0tDLElBREwsQ0FDVTBGLE9BQU9DLElBQVAsQ0FBWTFOLElBQVosQ0FEVixFQUVLZ0ksS0FGTCxHQUdLQyxNQUhMLENBR1ksR0FIWixFQUlLeUgsSUFKTCxDQUlVLElBSlYsRUFJZ0IsVUFBVXVCLE1BSjFCLEVBS0svSSxJQUxMLENBS1U7QUFBQSxtQkFBS0MsQ0FBTDtBQUFBLFNBTFYsRUFNS3JDLEtBTkwsQ0FNVyxrQkFOWCxFQU0rQjtBQUFBLG1CQUFLdEosUUFBTDtBQUFBLFNBTi9CLEVBT0trVCxJQVBMLENBT1UsZ0JBUFYsRUFPNEIsTUFQNUIsRUFRS0EsSUFSTCxDQVFVLGFBUlYsRUFReUIsU0FSekIsRUFTS0EsSUFUTCxDQVNVLGNBVFYsRUFTMEIsT0FUMUIsRUFVS0EsSUFWTCxDQVVVLGdCQVZWLEVBVTRCLEtBVjVCLEVBV0tBLElBWEwsQ0FXVSxXQVhWLEVBV3VCLE1BWHZCLEVBWUtBLElBWkwsQ0FZVSxhQVpWLEVBWXlCLDRCQVp6QixFQWFLQSxJQWJMLENBYVUsWUFiVixFQWF3Qiw0QkFieEIsRUFjS0EsSUFkTCxDQWNVLHFCQWRWLEVBY2lDLG1CQWRqQyxFQWVLQSxJQWZMLENBZVUsY0FmVixFQWUwQjtBQUFBLG1CQUFLMVAsS0FBS21JLENBQUwsQ0FBTDtBQUFBLFNBZjFCO0FBZ0JDO0FBQ0QsUUFBR1csUUFBSCxFQUFhOztBQUVUOztBQUVBeUksMkJBQW1CLE9BQW5COztBQUVBMVYsV0FBRytKLE1BQUgsQ0FBVSxRQUFWLEVBQW9Ca0MsU0FBcEIsQ0FBOEIsR0FBOUIsRUFDQ0MsSUFERCxDQUNNMEYsT0FBT0MsSUFBUCxDQUFZak0sV0FBWixDQUROLEVBRUN1RyxLQUZELEdBR0NDLE1BSEQsQ0FHUSxHQUhSLEVBSUN5SCxJQUpELENBSU0sSUFKTixFQUlZO0FBQUEsbUJBQUt2SCxJQUFJLFFBQVQ7QUFBQSxTQUpaLEVBS0NELElBTEQsQ0FLTTtBQUFBLG1CQUFLQyxDQUFMO0FBQUEsU0FMTixFQU1DdUgsSUFORCxDQU1NLE9BTk4sRUFNZSxhQUFJO0FBQ2IsZ0JBQUlsTSxzQkFBc0JDLFFBQXRCLElBQWtDMEUsRUFBRXFKLFFBQUYsRUFBdEMsRUFBbUQ7QUFDbkQsdUJBQU8sYUFBUDtBQUNDLGFBRkQsTUFFTztBQUNQLG9CQUFHdlQsVUFBSCxFQUFlLE9BQU8sMkJBQVA7QUFDZix1QkFBTyxjQUFQO0FBQ0M7QUFDQSxTQWJQLEVBY0N5UixJQWRELENBY00sZ0JBZE4sRUFjd0IsTUFkeEIsRUFlQ0EsSUFmRCxDQWVNLGFBZk4sRUFlcUIsU0FmckIsRUFnQkNBLElBaEJELENBZ0JNLGNBaEJOLEVBZ0JzQixPQWhCdEIsRUFpQkNBLElBakJELENBaUJNLGdCQWpCTixFQWlCd0IsS0FqQnhCLEVBa0JDQSxJQWxCRCxDQWtCTSxXQWxCTixFQWtCbUIsTUFsQm5CLEVBbUJDQSxJQW5CRCxDQW1CTSxhQW5CTixFQW1CcUIsNEJBbkJyQixFQW9CQ0EsSUFwQkQsQ0FvQk0sWUFwQk4sRUFvQm9CLDRCQXBCcEIsRUFxQkNBLElBckJELENBcUJNLHFCQXJCTixFQXFCNkIsa0JBckI3QixFQXNCQ0EsSUF0QkQsQ0FzQk0sY0F0Qk4sRUFzQnNCO0FBQUEsbUJBQUtqTyxZQUFZMEcsQ0FBWixFQUFlLENBQWYsQ0FBTDtBQUFBLFNBdEJ0Qjs7QUF3QkF0TSxXQUFHK0osTUFBSCxDQUFVLFdBQVYsRUFBdUJrQyxTQUF2QixDQUFpQyxHQUFqQyxFQUNDQyxJQURELENBQ00wRixPQUFPQyxJQUFQLENBQVl0TCxjQUFaLENBRE4sRUFFQzRGLEtBRkQsR0FHQ0MsTUFIRCxDQUdRLEdBSFIsRUFJQ3lILElBSkQsQ0FJTSxJQUpOLEVBSVk7QUFBQSxtQkFBS3ZILElBQUksV0FBVDtBQUFBLFNBSlosRUFLQ0QsSUFMRCxDQUtNO0FBQUEsbUJBQUtDLENBQUw7QUFBQSxTQUxOLEVBTUN1SCxJQU5ELENBTU0sT0FOTixFQU1lLGFBQUk7QUFDYixnQkFBSWxNLHNCQUFzQkUsV0FBdEIsSUFBcUN5RSxFQUFFcUosUUFBRixFQUF6QyxFQUFzRDtBQUN0RCx1QkFBTyxhQUFQO0FBQ0MsYUFGRCxNQUVPO0FBQ1Asb0JBQUd2VCxVQUFILEVBQWUsT0FBTywyQkFBUDtBQUNmLHVCQUFPLGNBQVA7QUFDQztBQUNBLFNBYlAsRUFjQ3lSLElBZEQsQ0FjTSxnQkFkTixFQWN3QixNQWR4QixFQWVDQSxJQWZELENBZU0sYUFmTixFQWVxQixTQWZyQixFQWdCQ0EsSUFoQkQsQ0FnQk0sY0FoQk4sRUFnQnNCLE9BaEJ0QixFQWlCQ0EsSUFqQkQsQ0FpQk0sZ0JBakJOLEVBaUJ3QixLQWpCeEIsRUFrQkNBLElBbEJELENBa0JNLFdBbEJOLEVBa0JtQixNQWxCbkIsRUFtQkNBLElBbkJELENBbUJNLGFBbkJOLEVBbUJxQiw0QkFuQnJCLEVBb0JDQSxJQXBCRCxDQW9CTSxZQXBCTixFQW9Cb0IsNEJBcEJwQixFQXFCQ0EsSUFyQkQsQ0FxQk0scUJBckJOLEVBcUI2QixvQkFyQjdCLEVBc0JDQSxJQXRCRCxDQXNCTSxjQXRCTixFQXNCc0I7QUFBQSxtQkFBS3ROLGVBQWUrRixDQUFmLEVBQWtCLENBQWxCLENBQUw7QUFBQSxTQXRCdEI7O0FBd0JBdE0sV0FBRytKLE1BQUgsQ0FBVSxVQUFWLEVBQXNCa0MsU0FBdEIsQ0FBZ0MsR0FBaEMsRUFDQ0MsSUFERCxDQUNNMEYsT0FBT0MsSUFBUCxDQUFZbE4sVUFBWixDQUROLEVBRUN3SCxLQUZELEdBR0NDLE1BSEQsQ0FHUSxHQUhSLEVBSUN5SCxJQUpELENBSU0sSUFKTixFQUlZO0FBQUEsbUJBQUt2SCxJQUFJLFVBQVQ7QUFBQSxTQUpaLEVBS0NELElBTEQsQ0FLTTtBQUFBLG1CQUFLQyxDQUFMO0FBQUEsU0FMTixFQU1DdUgsSUFORCxDQU1NLE9BTk4sRUFNZSxhQUFJO0FBQ2IsZ0JBQUlsTSxzQkFBc0JJLE1BQXRCLElBQWdDdUUsRUFBRXFKLFFBQUYsRUFBcEMsRUFBaUQ7QUFDL0MsdUJBQU8sYUFBUDtBQUNELGFBRkQsTUFFTztBQUNMLG9CQUFHdlQsVUFBSCxFQUFlLE9BQU8sMkJBQVA7QUFDZix1QkFBTyxjQUFQO0FBQ0Q7QUFDQSxTQWJQLEVBY0N5UixJQWRELENBY00sZ0JBZE4sRUFjd0IsTUFkeEIsRUFlQ0EsSUFmRCxDQWVNLGFBZk4sRUFlcUIsU0FmckIsRUFnQkNBLElBaEJELENBZ0JNLGNBaEJOLEVBZ0JzQixPQWhCdEIsRUFpQkNBLElBakJELENBaUJNLGdCQWpCTixFQWlCd0IsS0FqQnhCLEVBa0JDQSxJQWxCRCxDQWtCTSxXQWxCTixFQWtCbUIsTUFsQm5CLEVBbUJDQSxJQW5CRCxDQW1CTSxhQW5CTixFQW1CcUIsNEJBbkJyQixFQW9CQ0EsSUFwQkQsQ0FvQk0sWUFwQk4sRUFvQm9CLDRCQXBCcEIsRUFxQkNBLElBckJELENBcUJNLHFCQXJCTixFQXFCNkIsb0JBckI3QixFQXNCQ0EsSUF0QkQsQ0FzQk0sY0F0Qk4sRUFzQnNCO0FBQUEsbUJBQUtsUCxXQUFXMkgsQ0FBWCxFQUFjLENBQWQsQ0FBTDtBQUFBLFNBdEJ0Qjs7QUF3QkF0TSxXQUFHK0osTUFBSCxDQUFVLFVBQVYsRUFBc0JrQyxTQUF0QixDQUFnQyxHQUFoQyxFQUNDQyxJQURELENBQ00wRixPQUFPQyxJQUFQLENBQVk1SyxhQUFaLENBRE4sRUFFQ2tGLEtBRkQsR0FHQ0MsTUFIRCxDQUdRLEdBSFIsRUFJQ3lILElBSkQsQ0FJTSxJQUpOLEVBSVk7QUFBQSxtQkFBS3ZILElBQUksVUFBVDtBQUFBLFNBSlosRUFLQ0QsSUFMRCxDQUtNO0FBQUEsbUJBQUtDLENBQUw7QUFBQSxTQUxOLEVBTUN1SCxJQU5ELENBTU0sT0FOTixFQU1lLGFBQUk7QUFDYixnQkFBSWxNLHNCQUFzQkcsVUFBdEIsSUFBb0N3RSxFQUFFcUosUUFBRixFQUF4QyxFQUFxRDtBQUNyRCx1QkFBTyxhQUFQO0FBQ0MsYUFGRCxNQUVPO0FBQ1Asb0JBQUd2VCxVQUFILEVBQWUsT0FBTywyQkFBUDtBQUNmLHVCQUFPLGNBQVA7QUFDQztBQUNBLFNBYlAsRUFjQ3lSLElBZEQsQ0FjTSxnQkFkTixFQWN3QixNQWR4QixFQWVDQSxJQWZELENBZU0sYUFmTixFQWVxQixTQWZyQixFQWdCQ0EsSUFoQkQsQ0FnQk0sY0FoQk4sRUFnQnNCLE9BaEJ0QixFQWlCQ0EsSUFqQkQsQ0FpQk0sZ0JBakJOLEVBaUJ3QixLQWpCeEIsRUFrQkNBLElBbEJELENBa0JNLFdBbEJOLEVBa0JtQixNQWxCbkIsRUFtQkNBLElBbkJELENBbUJNLGFBbkJOLEVBbUJxQiw0QkFuQnJCLEVBb0JDQSxJQXBCRCxDQW9CTSxZQXBCTixFQW9Cb0IsNEJBcEJwQixFQXFCQ0EsSUFyQkQsQ0FxQk0scUJBckJOLEVBcUI2QixvQkFyQjdCLEVBc0JDQSxJQXRCRCxDQXNCTSxjQXRCTixFQXNCc0I7QUFBQSxtQkFBSzVNLGNBQWNxRixDQUFkLEVBQWlCLENBQWpCLENBQUw7QUFBQSxTQXRCdEI7QUF3Qkg7O0FBRUQ7QUFDQSxRQUFJLE9BQU82SCxRQUFQLElBQW1CLFVBQXZCLEVBQW1DO0FBQy9CQSxpQkFBUyxLQUFULEVBQWUsSUFBZjtBQUNBLDBCQUFFeUIsTUFBRjtBQUNILEtBSEQsTUFHTztBQUNILDBCQUFFQSxNQUFGO0FBQ0g7O0FBRUQ7QUFDQSxRQUFHdFQsUUFBSCxFQUFhO0FBQ2I7QUFDSXlHLGlCQUFTQyxjQUFULENBQXdCLFNBQXhCLEVBQW1DNk0sU0FBbkMsQ0FBNkNDLEdBQTdDLENBQWlELFFBQWpEO0FBQ0EvTSxpQkFBU0MsY0FBVCxDQUF3QixVQUF4QixFQUFvQzZNLFNBQXBDLENBQThDQyxHQUE5QyxDQUFrRCxRQUFsRDtBQUNBL00saUJBQVNDLGNBQVQsQ0FBd0IsV0FBeEIsRUFBcUM2TSxTQUFyQyxDQUErQ0MsR0FBL0MsQ0FBbUQsUUFBbkQ7QUFDQS9NLGlCQUFTQyxjQUFULENBQXdCLFdBQXhCLEVBQXFDNk0sU0FBckMsQ0FBK0NDLEdBQS9DLENBQW1ELFFBQW5EO0FBQ0EvTSxpQkFBU0MsY0FBVCxDQUF3QixNQUF4QixFQUFnQ2lCLEtBQWhDLENBQXNDOEwsZUFBdEMsR0FBc0QsTUFBdEQ7QUFDQWhOLGlCQUFTQyxjQUFULENBQXdCLFlBQXhCLEVBQXNDaUIsS0FBdEMsQ0FBNEM4TCxlQUE1QyxHQUE0RCxNQUE1RDtBQUNIO0FBQ0o7O0FBRUQsSUFBSUMsU0FBUyxTQUFUQSxNQUFTLENBQUNDLEtBQUQsRUFBUTVKLElBQVIsRUFBMEI7QUFBQSxzQ0FBVDZKLElBQVM7QUFBVEEsWUFBUztBQUFBOztBQUNuQ0EsU0FBS0MsT0FBTCxDQUFhLGFBQUs7QUFDZCxZQUFJRixTQUFTRyxFQUFFLENBQUYsQ0FBYixFQUNJO0FBQ0osWUFBSUMsTUFBTTVULFFBQVEyVCxFQUFFLENBQUYsQ0FBUixFQUFjL0csT0FBZCxDQUFzQmhELElBQXRCLENBQVY7QUFDQWdLLGNBQU0sQ0FBQyxDQUFQLElBQVk1VCxRQUFRMlQsRUFBRSxDQUFGLENBQVIsRUFBY0osTUFBZCxDQUFxQkssR0FBckIsRUFBMEIsQ0FBMUIsQ0FBWjtBQUNILEtBTEQ7QUFNSCxDQVBEOztBQVNPLElBQUlDLG9DQUFKOztBQUVQLFNBQVNqRCxNQUFULENBQWdCa0QsQ0FBaEIsRUFBa0JDLEVBQWxCLEVBQXNCO0FBQ2xCLFFBQUlDLFdBQVcsRUFBZjtBQUNBLFlBMzJCT3hTLEtBMjJCUCxXQUFRLEVBQVI7QUFDQUMsWUFBUSxFQUFSOztBQUVBK0QsUUFBSW1FLE1BQUosQ0FBVyxVQUFYLEVBQXVCQSxNQUF2QixDQUE4QixZQUE5QixFQUNLeUgsSUFETCxDQUNVLElBRFYsRUFDZ0IsY0FEaEIsRUFFS0EsSUFGTCxDQUVVLFNBRlYsRUFFcUIsWUFGckIsRUFHS0EsSUFITCxDQUdVLE1BSFYsRUFHa0IsR0FIbEIsRUFJS0EsSUFKTCxDQUlVLE1BSlYsRUFJa0IsQ0FKbEIsRUFLS0EsSUFMTCxDQUtVLGFBTFYsRUFLeUIsQ0FMekIsRUFNS0EsSUFOTCxDQU1VLGNBTlYsRUFNMEIsQ0FOMUIsRUFPS0EsSUFQTCxDQU9VLFFBUFYsRUFPb0IsTUFQcEIsRUFRS3pILE1BUkwsQ0FRWSxNQVJaLEVBU0t5SCxJQVRMLENBU1UsR0FUVixFQVNlLGdCQVRmLEVBVUs1SixLQVZMLENBVVcsTUFWWCxFQVVtQjVKLFFBVm5COztBQVlBNEgsUUFBSW1FLE1BQUosQ0FBVyxVQUFYLEVBQXVCQSxNQUF2QixDQUE4QixZQUE5QixFQUNLeUgsSUFETCxDQUNVLElBRFYsRUFDZ0IsY0FEaEIsRUFFS0EsSUFGTCxDQUVVLFNBRlYsRUFFcUIsWUFGckIsRUFHS0EsSUFITCxDQUdVLE1BSFYsRUFHa0IsR0FIbEIsRUFJS0EsSUFKTCxDQUlVLE1BSlYsRUFJa0IsQ0FKbEIsRUFLS0EsSUFMTCxDQUtVLGFBTFYsRUFLeUIsQ0FMekIsRUFNS0EsSUFOTCxDQU1VLGNBTlYsRUFNMEIsQ0FOMUIsRUFPS0EsSUFQTCxDQU9VLFFBUFYsRUFPb0IsTUFQcEIsRUFRS3pILE1BUkwsQ0FRWSxNQVJaLEVBU0t5SCxJQVRMLENBU1UsR0FUVixFQVNlLGdCQVRmLEVBVUs1SixLQVZMLENBVVcsTUFWWCxFQVVtQjFKLFFBVm5COztBQVlBLFFBQUltVyxPQUFPek8sSUFBSW1FLE1BQUosQ0FBVyxNQUFYLEVBQ05uQyxLQURNLENBQ0EsTUFEQSxFQUNRLE1BRFIsRUFFTkEsS0FGTSxDQUVBLFFBRkEsRUFFVTVKLFFBRlYsRUFHTjRKLEtBSE0sQ0FHQSxjQUhBLEVBR2dCLENBSGhCLEVBSU40SixJQUpNLENBSUQsWUFKQyxFQUlhLG9CQUpiLENBQVg7O0FBTUEsUUFBSThDLFFBQVExTyxJQUFJbUUsTUFBSixDQUFXLE1BQVgsRUFDUG5DLEtBRE8sQ0FDRCxNQURDLEVBQ08sTUFEUCxFQUVQQSxLQUZPLENBRUQsUUFGQyxFQUVTMUosUUFGVCxFQUdQMEosS0FITyxDQUdELGNBSEMsRUFHZSxDQUhmLEVBSVA0SixJQUpPLENBSUYsWUFKRSxFQUlZLG9CQUpaLENBQVosQ0FJOEM7O0FBRTlDLFFBQUkrQyxnQkFBZ0I1VyxHQUFHK0osTUFBSCxDQUFVLGFBQVYsRUFBeUJxQyxNQUF6QixDQUFnQyxLQUFoQyxFQUNmeUgsSUFEZSxDQUNWLE9BRFUsRUFDRDNMLEtBREMsRUFFZjJMLElBRmUsQ0FFVixRQUZVLEVBRUExTCxNQUZBLENBQXBCOztBQUlBeU8sa0JBQWN4SyxNQUFkLENBQXFCLE1BQXJCLEVBQTZCO0FBQTdCLEtBQ0t5SCxJQURMLENBQ1UsSUFEVixFQUNnQixlQURoQixFQUVLNUosS0FGTCxDQUVXLE1BRlgsRUFFbUIsU0FGbkIsRUFHS0EsS0FITCxDQUdXLFFBSFgsRUFHcUIsU0FIckIsRUFJS0EsS0FKTCxDQUlXLGNBSlgsRUFJMkIsTUFBSXJJLElBSi9CLEVBS0txSSxLQUxMLENBS1csaUJBTFgsRUFLNkIsT0FMN0IsRUFNS0EsS0FOTCxDQU1XLFNBTlgsRUFNc0IsQ0FOdEI7O0FBUUEsUUFBSTRNLGlCQUFpQjdXLEdBQUcrSixNQUFILENBQVUsYUFBVixFQUF5QnFDLE1BQXpCLENBQWdDLEtBQWhDLEVBQ2hCeUgsSUFEZ0IsQ0FDWCxPQURXLEVBQ0YzTCxLQURFLEVBRWhCMkwsSUFGZ0IsQ0FFWCxRQUZXLEVBRUQxTCxNQUZDLENBQXJCOztBQUlBME8sbUJBQWV6SyxNQUFmLENBQXNCLE1BQXRCLEVBQ0t5SCxJQURMLENBQ1UsSUFEVixFQUNnQixlQURoQixFQUVLNUosS0FGTCxDQUVXLE1BRlgsRUFFbUIsU0FGbkIsRUFHS0EsS0FITCxDQUdXLFFBSFgsRUFHcUIsU0FIckIsRUFJS0EsS0FKTCxDQUlXLGNBSlgsRUFJMkIsTUFBSXJJLElBSi9CLEVBS0txSSxLQUxMLENBS1csaUJBTFgsRUFLNkIsT0FMN0IsRUFNS0EsS0FOTCxDQU1XLFNBTlgsRUFNc0IsQ0FOdEI7O0FBUUEsUUFBSTZNLE1BQU05VyxHQUFHK0osTUFBSCxDQUFVLGFBQVYsRUFBeUJxQyxNQUF6QixDQUFnQyxLQUFoQyxFQUNMeUgsSUFESyxDQUNBLE9BREEsRUFDUzNMLEtBRFQsRUFFTDJMLElBRkssQ0FFQSxRQUZBLEVBRVUxTCxNQUZWLENBQVY7O0FBSUEyTyxRQUFJMUssTUFBSixDQUFXLE1BQVgsRUFDS3lILElBREwsQ0FDVSxJQURWLEVBQ2dCLFNBRGhCLEVBRUs1SixLQUZMLENBRVcsTUFGWCxFQUVtQjVKLFFBRm5CLEVBR0s0SixLQUhMLENBR1csUUFIWCxFQUdxQjVKLFFBSHJCLEVBSUs0SixLQUpMLENBSVcsY0FKWCxFQUkyQixNQUFJckksSUFKL0IsRUFLS3FJLEtBTEwsQ0FLVyxpQkFMWCxFQUs2QixPQUw3Qjs7QUFPQSxRQUFJOE0sT0FBTy9XLEdBQUcrSixNQUFILENBQVUsYUFBVixFQUF5QnFDLE1BQXpCLENBQWdDLEtBQWhDLEVBQ055SCxJQURNLENBQ0QsT0FEQyxFQUNRM0wsS0FEUixFQUVOMkwsSUFGTSxDQUVELFFBRkMsRUFFUzFMLE1BRlQsQ0FBWDs7QUFJQTRPLFNBQUszSyxNQUFMLENBQVksTUFBWixFQUNLbkMsS0FETCxDQUNXLE1BRFgsRUFDbUIxSixRQURuQixFQUVLMEosS0FGTCxDQUVXLFFBRlgsRUFFcUIxSixRQUZyQixFQUdLMEosS0FITCxDQUdXLGNBSFgsRUFHMkIsTUFBSXJJLElBSC9CLEVBSUtxSSxLQUpMLENBSVcsaUJBSlgsRUFJNkIsT0FKN0I7O0FBTUEsUUFBSXNNLEtBQUs3VSxTQUFMLElBQWtCNlUsS0FBSzVVLFVBQTNCLEVBQXVDO0FBQ25DLGFBQUssSUFBSXFWLElBQUksQ0FBYixFQUFnQkEsSUFBSXZVLFFBQVFPLEtBQVIsQ0FBY21ILE1BQWxDLEVBQTBDNk0sR0FBMUMsRUFBK0M7QUFDM0MsZ0JBQUlDLEtBQUtoRSxjQUFjeFEsUUFBUU8sS0FBUixDQUFjZ1UsQ0FBZCxDQUFkLENBQVQ7QUFDQSxnQkFBSWpULFNBQVNrVCxFQUFULEVBQWF2RSxPQUFqQixFQUNJO0FBQ0p6TyxrQkFBTTBMLElBQU4sQ0FBVzVMLFNBQVNrVCxFQUFULENBQVg7QUFDQSxnQkFBSUMsV0FBV3pVLFFBQVFPLEtBQVIsQ0FBY2dVLENBQWQsRUFBaUJuSixPQUFqQixDQUF5QixLQUF6QixFQUFnQyxHQUFoQyxDQUFmO0FBQ0FxSix1QkFBVyxJQUFJOUIsTUFBSixDQUFXOEIsUUFBWCxDQUFYO0FBQ0FsWCxlQUFHK0osTUFBSCxDQUFVbU4sUUFBVixFQUFvQmpOLEtBQXBCLENBQTBCLGtCQUExQixFQUE4QztBQUFBLHVCQUFNa04sVUFBVWxULE1BQU0rUyxDQUFOLEVBQVM1RSxXQUFuQixDQUFOO0FBQUEsYUFBOUM7QUFDSDs7QUFFRCxhQUFLLElBQUk0RSxJQUFJLENBQWIsRUFBZ0JBLElBQUl2VSxRQUFRRSxNQUFSLENBQWV3SCxNQUFuQyxFQUEyQzZNLEdBQTNDLEVBQWdEO0FBQzVDLGdCQUFJSSxRQUFRQyxVQUFVNVUsUUFBUUUsTUFBUixDQUFlcVUsQ0FBZixFQUFrQixDQUFsQixDQUFWLENBQVo7QUFDQSxnQkFBSU0sUUFBUUQsVUFBVTVVLFFBQVFFLE1BQVIsQ0FBZXFVLENBQWYsRUFBa0IsQ0FBbEIsQ0FBVixDQUFaO0FBQ0E5UyxrQkFBTXlMLElBQU4sQ0FBVztBQUNQNEgsd0JBQVF0VCxNQUFNbVQsS0FBTixDQUREO0FBRVA5SSx3QkFBUXJLLE1BQU1xVCxLQUFOLENBRkQ7QUFHUEUsc0JBQU0sS0FIQztBQUlQQyx1QkFBTztBQUpBLGFBQVg7QUFNSDtBQUNKLEtBckJELE1BcUJPO0FBQ0gsWUFBR3hLLFFBQUgsRUFBYTtBQUNUO0FBQ0Esb0JBdjlCRGhKLEtBdTlCQyxXQUFRRixTQUFTbVIsS0FBVCxDQUFlLENBQWYsRUFBaUJuUixTQUFTb0csTUFBMUIsQ0FBUixDQUZTLENBRXFDO0FBQzlDLGlCQUFLLElBQUk2TSxLQUFJLENBQWIsRUFBZ0JBLEtBQUkvUyxNQUFNa0csTUFBMUIsRUFBa0M2TSxJQUFsQyxFQUF1QztBQUFFO0FBQ3JDLG9CQUFJL1MsTUFBTStTLEVBQU4sRUFBU2xKLElBQVQsSUFBaUJ0SixRQUFyQixFQUErQjtBQUMzQlAsMEJBQU0rUyxFQUFOLEVBQVNyRSxNQUFULEdBQWtCLElBQWxCO0FBQ0FsUSw0QkFBUVMsT0FBUixDQUFnQnlNLElBQWhCLENBQXFCMUwsTUFBTStTLEVBQU4sRUFBU2xKLElBQTlCLEVBRjJCLENBRVc7QUFDekM7QUFDSjtBQUNKLFNBVEQsTUFTTyxJQUFJL0osU0FBU29HLE1BQVQsR0FBa0IsQ0FBdEIsRUFBeUI7QUFDNUIsb0JBLzlCRGxHLEtBKzlCQyxXQUFRLENBQUNGLFNBQVMsQ0FBVCxDQUFELEVBQWNBLFNBQVMsQ0FBVCxDQUFkLEVBQTJCQSxTQUFTLENBQVQsQ0FBM0IsQ0FBUjtBQUNBRyxvQkFBUSxDQUFDO0FBQ0xxVCx3QkFBUXRULE1BQU0sQ0FBTixDQURIO0FBRUxxSyx3QkFBUXJLLE1BQU0sQ0FBTixDQUZIO0FBR0x1VCxzQkFBTSxLQUhEO0FBSUxDLHVCQUFPO0FBSkYsYUFBRCxFQUtMO0FBQ0NGLHdCQUFRdFQsTUFBTSxDQUFOLENBRFQ7QUFFQ3FLLHdCQUFRckssTUFBTSxDQUFOLENBRlQ7QUFHQ3VULHNCQUFNLEtBSFA7QUFJQ0MsdUJBQU87QUFKUixhQUxLLENBQVI7QUFXSCxTQWJNLE1BYUEsSUFBSTFULFNBQVNvRyxNQUFULEtBQW9CLENBQXhCLEVBQTJCO0FBQzlCLG9CQTUrQkRsRyxLQTQrQkMsV0FBUSxDQUFDRixTQUFTLENBQVQsQ0FBRCxFQUFjQSxTQUFTLENBQVQsQ0FBZCxDQUFSO0FBQ0FHLG9CQUFRLENBQUM7QUFDTHFULHdCQUFRdFQsTUFBTSxDQUFOLENBREg7QUFFTHFLLHdCQUFRckssTUFBTSxDQUFOLENBRkg7QUFHTHVULHNCQUFNLEtBSEQ7QUFJTEMsdUJBQU87QUFKRixhQUFELENBQVI7QUFNSCxTQVJNLE1BUUEsSUFBSTFULFNBQVNvRyxNQUFULEtBQW9CLENBQXhCLEVBQTJCO0FBQzlCLG9CQXAvQkRsRyxLQW8vQkMsV0FBUSxDQUFDRixTQUFTLENBQVQsQ0FBRCxDQUFSO0FBQ0gsU0FGTSxNQUVBO0FBQ0g0RixrQkFBTSwyQ0FBTjtBQUNBO0FBQ0g7QUFDSjs7QUFFRGxMLGlCQWxKa0IsQ0FrSko7O0FBRWQsUUFBSWlaLFFBQVExWCxHQUFHcVQsTUFBSCxDQUFVcUUsS0FBVixHQUNQelQsS0FETyxDQUNEQSxLQURDLEVBRVBDLEtBRk8sQ0FFREEsS0FGQyxFQUdQeVQsSUFITyxDQUdGLENBQUN6UCxLQUFELEVBQVFDLE1BQVIsQ0FIRSxFQUlQeVAsWUFKTyxDQUlNLEdBSk4sRUFLUEMsTUFMTyxDQUtBLENBQUMsR0FMRCxFQU1QN0wsRUFOTyxDQU1KLE1BTkksRUFNSThMLElBTkosQ0FBWjs7QUFRQTtBQUNBN1AsUUFBSW1FLE1BQUosQ0FBVyxVQUFYLEVBQXVCQSxNQUF2QixDQUE4QixZQUE5QixFQUNLeUgsSUFETCxDQUNVLElBRFYsRUFDZ0IsV0FEaEIsRUFFS0EsSUFGTCxDQUVVLFNBRlYsRUFFcUIsWUFGckIsRUFHS0EsSUFITCxDQUdVLE1BSFYsRUFHa0IsQ0FIbEIsRUFJS0EsSUFKTCxDQUlVLGFBSlYsRUFJeUIsQ0FKekIsRUFLS0EsSUFMTCxDQUtVLGNBTFYsRUFLMEIsQ0FMMUIsRUFNS0EsSUFOTCxDQU1VLFFBTlYsRUFNb0IsTUFOcEIsRUFPS3pILE1BUEwsQ0FPWSxVQVBaLEVBUUt5SCxJQVJMLENBUVUsR0FSVixFQVFlLGdCQVJmLEVBU0s1SixLQVRMLENBU1csTUFUWCxFQVNtQixNQVRuQjs7QUFXQWhDLFFBQUltRSxNQUFKLENBQVcsVUFBWCxFQUF1QkEsTUFBdkIsQ0FBOEIsWUFBOUIsRUFDS3lILElBREwsQ0FDVSxJQURWLEVBQ2dCLGFBRGhCLEVBRUtBLElBRkwsQ0FFVSxTQUZWLEVBRXFCLFlBRnJCLEVBR0tBLElBSEwsQ0FHVSxNQUhWLEVBR2tCLENBSGxCLEVBSUtBLElBSkwsQ0FJVSxhQUpWLEVBSXlCLENBSnpCLEVBS0tBLElBTEwsQ0FLVSxjQUxWLEVBSzBCLENBTDFCLEVBTUtBLElBTkwsQ0FNVSxRQU5WLEVBTW9CLE1BTnBCLEVBT0t6SCxNQVBMLENBT1ksVUFQWixFQVFLeUgsSUFSTCxDQVFVLEdBUlYsRUFRZSxpQkFSZixFQVNLNUosS0FUTCxDQVNXLE1BVFgsRUFTbUIsTUFUbkI7O0FBV0E7QUFDQSxRQUFJOE4sWUFBWTlQLElBQUltRSxNQUFKLENBQVcsVUFBWCxFQUNYeUgsSUFEVyxDQUNOLE9BRE0sRUFDRyxzQkFESCxFQUVYQSxJQUZXLENBRU4sR0FGTSxFQUVELFVBRkMsQ0FBaEI7O0FBSUE7QUFDQSxRQUFJM0YsT0FBT2pHLElBQUltRSxNQUFKLENBQVcsT0FBWCxFQUFvQkgsU0FBcEIsQ0FBOEIsTUFBOUIsQ0FBWDtBQUFBLFFBQ0krTCxTQUFTL1AsSUFBSW1FLE1BQUosQ0FBVyxPQUFYLEVBQW9CSCxTQUFwQixDQUE4QixHQUE5QixDQURiO0FBRUk7O0FBRUo7QUFDQSxRQUFJZ00sZ0JBQWdCLElBQXBCO0FBQUEsUUFDSUMsZ0JBQWdCLElBRHBCO0FBQUEsUUFFSUMsaUJBQWlCLElBRnJCO0FBQUEsUUFHSUMsaUJBQWlCLElBSHJCO0FBQUEsUUFJSUMsZUFBZSxJQUpuQjs7QUFNQSxhQUFTQyxjQUFULEdBQTBCO0FBQ3RCRix5QkFBaUIsSUFBakI7QUFDQUMsdUJBQWUsSUFBZjtBQUNBRix5QkFBaUIsSUFBakI7QUFDSDs7QUFFRDtBQUNBLGFBQVNMLElBQVQsR0FBZ0I7O0FBR1osaUJBQVNTLFVBQVQsQ0FBb0JDLFNBQXBCLEVBQThCQyxRQUE5QixFQUF1Q0MsTUFBdkMsRUFBOENDLFFBQTlDLEVBQXVEO0FBQ25ELGdCQUFJQyxVQUFVLElBQUlDLEtBQUosQ0FBVUwsVUFBVXJPLE1BQXBCLENBQWQsQ0FEbUQsQ0FDTjtBQUM3QyxnQkFBSTJPLGNBQWMsQ0FBbEI7QUFDQSxnQkFBR04sVUFBVXJPLE1BQVYsR0FBaUIsQ0FBcEIsRUFBc0I7QUFDbEIscUJBQUssSUFBSTZNLElBQUksQ0FBYixFQUFnQkEsSUFBSXdCLFVBQVVyTyxNQUE5QixFQUFzQzZNLEdBQXRDLEVBQTJDO0FBQ3ZDOEIsa0NBQWNMLFNBQVNwSixPQUFULENBQWlCbUosVUFBVXhCLENBQVYsQ0FBakIsQ0FBZDtBQUNBNEIsNEJBQVE1QixDQUFSLElBQWEwQixPQUFPSSxXQUFQLENBQWI7QUFDSDtBQUNKOztBQUVELGdCQUFHSCxRQUFILEVBQVk7QUFDUjtBQUNBO0FBQ0Esb0JBQUlDLFFBQVF6TyxNQUFSLElBQWtCLENBQXRCLEVBQXdCO0FBQ3BCLHdCQUFJNE8sU0FBU0gsUUFBUSxDQUFSLEVBQVcsQ0FBWCxJQUFlQSxRQUFRLENBQVIsRUFBVyxDQUFYLENBQTVCO0FBQ0Esd0JBQUlJLFNBQVNKLFFBQVEsQ0FBUixFQUFXLENBQVgsSUFBZUEsUUFBUSxDQUFSLEVBQVcsQ0FBWCxDQUE1QjtBQUNBQSw0QkFBUWpKLElBQVIsQ0FBYSxDQUFDLENBQUNpSixRQUFRLENBQVIsRUFBVyxDQUFYLElBQWdCQSxRQUFRLENBQVIsRUFBVyxDQUFYLENBQWpCLElBQWdDLENBQWhDLEdBQW9DSSxTQUFPLEVBQTVDLEVBQWdELENBQUNKLFFBQVEsQ0FBUixFQUFXLENBQVgsSUFBZUEsUUFBUSxDQUFSLEVBQVcsQ0FBWCxDQUFoQixJQUErQixDQUEvQixHQUFtQ0csU0FBTyxFQUExRixDQUFiO0FBQ0FILDRCQUFRakosSUFBUixDQUFhLENBQUMsQ0FBQ2lKLFFBQVEsQ0FBUixFQUFXLENBQVgsSUFBZ0JBLFFBQVEsQ0FBUixFQUFXLENBQVgsQ0FBakIsSUFBZ0MsQ0FBaEMsR0FBb0NJLFNBQU8sRUFBNUMsRUFBZ0QsQ0FBQ0osUUFBUSxDQUFSLEVBQVcsQ0FBWCxJQUFlQSxRQUFRLENBQVIsRUFBVyxDQUFYLENBQWhCLElBQStCLENBQS9CLEdBQW1DRyxTQUFPLEVBQTFGLENBQWI7QUFDSDtBQUNELG9CQUFJSCxRQUFRek8sTUFBUixJQUFrQixDQUF0QixFQUF3QjtBQUNwQix3QkFBSThPLFFBQVFyWCxPQUFPLEdBQW5CO0FBQ0FnWCw0QkFBUWpKLElBQVIsQ0FBYSxDQUFDaUosUUFBUSxDQUFSLEVBQVcsQ0FBWCxJQUFnQkssS0FBakIsRUFBd0JMLFFBQVEsQ0FBUixFQUFXLENBQVgsQ0FBeEIsQ0FBYjtBQUNBQSw0QkFBUWpKLElBQVIsQ0FBYSxDQUFDaUosUUFBUSxDQUFSLEVBQVcsQ0FBWCxJQUFnQkssS0FBakIsRUFBd0JMLFFBQVEsQ0FBUixFQUFXLENBQVgsQ0FBeEIsQ0FBYjtBQUNBQSw0QkFBUWpKLElBQVIsQ0FBYSxDQUFDaUosUUFBUSxDQUFSLEVBQVcsQ0FBWCxDQUFELEVBQWdCQSxRQUFRLENBQVIsRUFBVyxDQUFYLElBQWdCSyxLQUFoQyxDQUFiO0FBQ0FMLDRCQUFRakosSUFBUixDQUFhLENBQUNpSixRQUFRLENBQVIsRUFBVyxDQUFYLENBQUQsRUFBZ0JBLFFBQVEsQ0FBUixFQUFXLENBQVgsSUFBZ0JLLEtBQWhDLENBQWI7QUFDSDtBQUNKO0FBQ0QsbUJBQVFMLE9BQVI7QUFDSDs7QUFFRDtBQUNBO0FBQ0EsaUJBQVNNLGNBQVQsQ0FBd0JSLE1BQXhCLEVBQStCO0FBQzNCLGdCQUFJQSxPQUFPdk8sTUFBUCxJQUFpQixDQUFyQixFQUF1QjtBQUNuQixvQkFBSTRPLFNBQVNMLE9BQU8sQ0FBUCxFQUFVLENBQVYsSUFBY0EsT0FBTyxDQUFQLEVBQVUsQ0FBVixDQUEzQjtBQUNBLG9CQUFJTSxTQUFTTixPQUFPLENBQVAsRUFBVSxDQUFWLElBQWNBLE9BQU8sQ0FBUCxFQUFVLENBQVYsQ0FBM0I7QUFDQUEsdUJBQU8vSSxJQUFQLENBQVksQ0FBQyxDQUFDK0ksT0FBTyxDQUFQLEVBQVUsQ0FBVixJQUFlQSxPQUFPLENBQVAsRUFBVSxDQUFWLENBQWhCLElBQThCLENBQTlCLEdBQWtDTSxTQUFPLEVBQTFDLEVBQThDLENBQUNOLE9BQU8sQ0FBUCxFQUFVLENBQVYsSUFBY0EsT0FBTyxDQUFQLEVBQVUsQ0FBVixDQUFmLElBQTZCLENBQTdCLEdBQWlDSyxTQUFPLEVBQXRGLENBQVo7QUFDQUwsdUJBQU8vSSxJQUFQLENBQVksQ0FBQyxDQUFDK0ksT0FBTyxDQUFQLEVBQVUsQ0FBVixJQUFlQSxPQUFPLENBQVAsRUFBVSxDQUFWLENBQWhCLElBQThCLENBQTlCLEdBQWtDTSxTQUFPLEVBQTFDLEVBQThDLENBQUNOLE9BQU8sQ0FBUCxFQUFVLENBQVYsSUFBY0EsT0FBTyxDQUFQLEVBQVUsQ0FBVixDQUFmLElBQTZCLENBQTdCLEdBQWlDSyxTQUFPLEVBQXRGLENBQVo7QUFDSDtBQUNELGdCQUFJTCxPQUFPdk8sTUFBUCxJQUFpQixDQUFyQixFQUF1QjtBQUNuQixvQkFBSThPLFFBQVFyWCxPQUFPLEdBQW5CO0FBQ0E4Vyx1QkFBTy9JLElBQVAsQ0FBWSxDQUFDK0ksT0FBTyxDQUFQLEVBQVUsQ0FBVixJQUFlTyxLQUFoQixFQUF1QlAsT0FBTyxDQUFQLEVBQVUsQ0FBVixDQUF2QixDQUFaO0FBQ0FBLHVCQUFPL0ksSUFBUCxDQUFZLENBQUMrSSxPQUFPLENBQVAsRUFBVSxDQUFWLElBQWVPLEtBQWhCLEVBQXVCUCxPQUFPLENBQVAsRUFBVSxDQUFWLENBQXZCLENBQVo7QUFDQUEsdUJBQU8vSSxJQUFQLENBQVksQ0FBQytJLE9BQU8sQ0FBUCxFQUFVLENBQVYsQ0FBRCxFQUFlQSxPQUFPLENBQVAsRUFBVSxDQUFWLElBQWVPLEtBQTlCLENBQVo7QUFDQVAsdUJBQU8vSSxJQUFQLENBQVksQ0FBQytJLE9BQU8sQ0FBUCxFQUFVLENBQVYsQ0FBRCxFQUFlQSxPQUFPLENBQVAsRUFBVSxDQUFWLElBQWVPLEtBQTlCLENBQVo7QUFDSDtBQUNELG1CQUFRUCxNQUFSO0FBQ0g7O0FBRUQsWUFBSUEsU0FBU3pVLE1BQU1rVixHQUFOLENBQVUsVUFBUzdNLENBQVQsRUFBWTtBQUFHLG1CQUFPLENBQUVBLEVBQUU4SixDQUFKLEVBQU85SixFQUFFOE0sQ0FBVCxDQUFQO0FBQXFCLFNBQTlDLENBQWI7QUFDQSxZQUFJQyxZQUFZZCxXQUFXOVYsUUFBUVMsT0FBbkIsRUFBNEJULFFBQVFPLEtBQXBDLEVBQTJDMFYsTUFBM0MsRUFBbUQsSUFBbkQsQ0FBaEI7QUFDQSxZQUFJWSxZQUFZZixXQUFXOVYsUUFBUVUsT0FBbkIsRUFBNEJWLFFBQVFPLEtBQXBDLEVBQTJDMFYsTUFBM0MsRUFBbUQsSUFBbkQsQ0FBaEI7QUFDQSxZQUFJYSxZQUFZaEIsV0FBVzlWLFFBQVFRLEdBQW5CLEVBQXdCUixRQUFRTyxLQUFoQyxFQUF1QzBWLE1BQXZDLEVBQStDLEtBQS9DLENBQWhCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQUdXLFVBQVVsUCxNQUFWLEdBQW1CLENBQXRCLEVBQXdCO0FBQ3BCdU0saUJBQUt6TSxLQUFMLENBQVcsU0FBWCxFQUFzQixDQUF0QjtBQUNBMk0sMEJBQWMzTSxLQUFkLENBQW9CLFNBQXBCLEVBQStCLENBQS9CO0FBQ0E2TSxnQkFBSTdNLEtBQUosQ0FBVSxTQUFWLEVBQXFCLEdBQXJCO0FBQ0EsZ0JBQUl1UCxTQUFTeFosR0FBR3laLElBQUgsQ0FBUUMsSUFBUixDQUFhTCxTQUFiLENBQWI7O0FBRUF2QyxnQkFBSTdLLFNBQUosQ0FBYyxNQUFkLEVBQ0tDLElBREwsQ0FDVSxDQUFDc04sTUFBRCxDQURWLEVBQ3NCO0FBRHRCLGFBRUszRixJQUZMLENBRVUsR0FGVixFQUVlLFVBQVN2SCxDQUFULEVBQVk7QUFBRSx1QkFBTyxNQUFNQSxFQUFFcU4sSUFBRixDQUFPLEdBQVAsQ0FBTixHQUFvQixHQUEzQjtBQUFpQyxhQUY5RDtBQUdBL0MsMEJBQWMzSyxTQUFkLENBQXdCLE1BQXhCLEVBQ0tDLElBREwsQ0FDVSxDQUFDc04sTUFBRCxDQURWLEVBQ3NCO0FBRHRCLGFBRUszRixJQUZMLENBRVUsR0FGVixFQUVlLFVBQVN2SCxDQUFULEVBQVk7QUFBRSx1QkFBTyxNQUFNQSxFQUFFcU4sSUFBRixDQUFPLEdBQVAsQ0FBTixHQUFvQixHQUEzQjtBQUFpQyxhQUY5RDs7QUFJQTtBQUNBLGdCQUFJQyxJQUFJQyxjQUFjUixTQUFkLENBQVI7O0FBRUEsZ0JBQUdFLFVBQVVwUCxNQUFWLEdBQWlCLENBQXBCLEVBQXNCO0FBQ2xCLG9CQUFJMlAsSUFBSVAsVUFBVSxDQUFWLENBQVIsQ0FEa0IsQ0FDNEI7QUFDOUM7QUFDQSxvQkFBSVEsVUFBVUQsRUFBRSxDQUFGLElBQU9GLEVBQUUsQ0FBRixDQUFyQjtBQUFBLG9CQUNJSSxVQUFVRixFQUFFLENBQUYsSUFBT0YsRUFBRSxDQUFGLENBRHJCO0FBQUEsb0JBRUlLLFFBQVFuWSxLQUFLb1ksSUFBTCxDQUFVSCxVQUFVQSxPQUFWLEdBQW9CQyxVQUFVQSxPQUF4QyxDQUZaO0FBQUEsb0JBR0lHLFNBQVMsQ0FIYjtBQUFBLG9CQUlJQyxTQUFTLENBSmI7QUFBQSxvQkFLSUMsaUJBQWlCelksT0FBTyxDQUw1QjtBQUFBLG9CQU1JMFksaUJBQWlCMVksT0FBTyxFQU41Qjs7QUFRQSxvQkFBSXFZLFFBQVEsQ0FBWixFQUFjO0FBQ1ZFLDZCQUFTSixVQUFVRSxLQUFuQjtBQUNBRyw2QkFBU0osVUFBVUMsS0FBbkI7QUFDSDs7QUFFRHZELHFCQUFLN0MsSUFBTCxDQUFVLElBQVYsRUFBZ0IrRixFQUFFLENBQUYsSUFBUVMsaUJBQWlCRixNQUF6QyxFQUFvRDtBQUFwRCxpQkFDS3RHLElBREwsQ0FDVSxJQURWLEVBQ2dCK0YsRUFBRSxDQUFGLElBQVFTLGlCQUFpQkQsTUFEekMsRUFDb0Q7QUFEcEQsaUJBRUt2RyxJQUZMLENBRVUsSUFGVixFQUVnQmlHLEVBQUUsQ0FBRixJQUFPUSxpQkFBaUJILE1BRnhDLEVBR0t0RyxJQUhMLENBR1UsSUFIVixFQUdnQmlHLEVBQUUsQ0FBRixJQUFPUSxpQkFBaUJGLE1BSHhDO0FBSUg7O0FBRUQ7QUFDQW5XLGtCQUFNa1MsT0FBTixDQUFjLGFBQUs7QUFDZixvQkFBSW9FLE9BQVE1RixFQUFFaEMsTUFBSCxHQUFhLENBQWIsR0FBaUIsQ0FBQyxDQUE3QixDQURlLENBQ29CO0FBQ25DLG9CQUFJb0gsVUFBVUgsRUFBRSxDQUFGLElBQU9qRixFQUFFeUIsQ0FBdkI7QUFBQSxvQkFDSTRELFVBQVVKLEVBQUUsQ0FBRixJQUFPakYsRUFBRXlFLENBRHZCO0FBQUEsb0JBRUlhLFFBQVFuWSxLQUFLb1ksSUFBTCxDQUFVSCxVQUFVQSxPQUFWLEdBQW9CQyxVQUFVQSxPQUF4QyxDQUZaO0FBR0lHLHlCQUFTLENBQVQsRUFDQUMsU0FBUyxDQURUOztBQUdKLG9CQUFJSCxRQUFRLENBQVosRUFBYztBQUNWRSw2QkFBU0osVUFBVUUsS0FBbkI7QUFDQUcsNkJBQVNKLFVBQVVDLEtBQW5CO0FBQ0g7O0FBRUR0RixrQkFBRXlCLENBQUYsSUFBT3RVLEtBQUswWSxHQUFMLENBQVNMLE1BQVQsRUFBa0JKLFVBQVEsR0FBMUIsSUFBa0NuYSxDQUFsQyxHQUFzQzJhLElBQXRDLEdBQStDN0MsTUFBTStDLEtBQU4sRUFBdEQ7QUFDQTlGLGtCQUFFeUUsQ0FBRixJQUFPdFgsS0FBSzBZLEdBQUwsQ0FBU0osTUFBVCxFQUFrQkosVUFBUSxHQUExQixJQUFrQ3BhLENBQWxDLEdBQXNDMmEsSUFBdEMsR0FBK0M3QyxNQUFNK0MsS0FBTixFQUF0RDtBQUNILGFBZkQ7QUFpQkgsU0F4REQsTUF3REs7QUFDRDdELDBCQUFjM00sS0FBZCxDQUFvQixTQUFwQixFQUErQixDQUEvQjs7QUFFQTZNLGdCQUFJN00sS0FBSixDQUFVLFNBQVYsRUFBcUIsQ0FBckI7QUFDWjtBQUNZeU0saUJBQUt6TSxLQUFMLENBQVcsU0FBWCxFQUFzQixDQUF0QjtBQUNIOztBQUVELFlBQUdxUCxVQUFVblAsTUFBVixHQUFtQixDQUF0QixFQUF3QjtBQUNwQndNLGtCQUFNMU0sS0FBTixDQUFZLFNBQVosRUFBdUIsQ0FBdkI7QUFDQTRNLDJCQUFlNU0sS0FBZixDQUFxQixTQUFyQixFQUFnQyxDQUFoQztBQUNBOE0saUJBQUs5TSxLQUFMLENBQVcsU0FBWCxFQUFzQixHQUF0QjtBQUNBLGdCQUFJdVAsU0FBU3haLEdBQUd5WixJQUFILENBQVFDLElBQVIsQ0FBYUosU0FBYixDQUFiO0FBQ0F2QyxpQkFBSzlLLFNBQUwsQ0FBZSxNQUFmLEVBQ0tDLElBREwsQ0FDVSxDQUFDc04sTUFBRCxDQURWLEVBQ3NCO0FBRHRCLGFBRUszRixJQUZMLENBRVUsR0FGVixFQUVlLFVBQVN2SCxDQUFULEVBQVk7QUFBRSx1QkFBTyxNQUFNQSxFQUFFcU4sSUFBRixDQUFPLEdBQVAsQ0FBTixHQUFvQixHQUEzQjtBQUFpQyxhQUY5RDtBQUdBOUMsMkJBQWU1SyxTQUFmLENBQXlCLE1BQXpCLEVBQ0tDLElBREwsQ0FDVSxDQUFDc04sTUFBRCxDQURWLEVBQ3NCO0FBRHRCLGFBRUszRixJQUZMLENBRVUsR0FGVixFQUVlLFVBQVN2SCxDQUFULEVBQVk7QUFBRSx1QkFBTyxNQUFNQSxFQUFFcU4sSUFBRixDQUFPLEdBQVAsQ0FBTixHQUFvQixHQUEzQjtBQUFpQyxhQUY5RDs7QUFJQTtBQUNBLGdCQUFJQyxJQUFJQyxjQUFjUCxTQUFkLENBQVI7O0FBRUEsZ0JBQUdDLFVBQVVwUCxNQUFWLEdBQWlCLENBQXBCLEVBQXNCO0FBQ2xCLG9CQUFJMlAsSUFBSVAsVUFBVSxDQUFWLENBQVIsQ0FEa0IsQ0FDZ0M7QUFDbEQsb0JBQUlRLFVBQVVELEVBQUUsQ0FBRixJQUFPRixFQUFFLENBQUYsQ0FBckI7QUFBQSxvQkFDSUksVUFBVUYsRUFBRSxDQUFGLElBQU9GLEVBQUUsQ0FBRixDQURyQjtBQUFBLG9CQUVJSyxRQUFRblksS0FBS29ZLElBQUwsQ0FBVUgsVUFBVUEsT0FBVixHQUFvQkMsVUFBVUEsT0FBeEMsQ0FGWjtBQUFBLG9CQUdJRyxTQUFTSixVQUFVRSxLQUh2QjtBQUFBLG9CQUlJRyxTQUFTSixVQUFVQyxLQUp2QjtBQUFBLG9CQUtJSSxpQkFBaUJ6WSxPQUFPLENBTDVCO0FBQUEsb0JBTUkwWSxpQkFBaUIxWSxPQUFPLEVBTjVCOztBQVFBK1Usc0JBQU05QyxJQUFOLENBQVcsSUFBWCxFQUFpQitGLEVBQUUsQ0FBRixJQUFRUyxpQkFBaUJGLE1BQTFDLEVBQ0t0RyxJQURMLENBQ1UsSUFEVixFQUNnQitGLEVBQUUsQ0FBRixJQUFRUyxpQkFBaUJELE1BRHpDLEVBRUt2RyxJQUZMLENBRVUsSUFGVixFQUVnQmlHLEVBQUUsQ0FBRixJQUFPUSxpQkFBaUJILE1BRnhDLEVBR0t0RyxJQUhMLENBR1UsSUFIVixFQUdnQmlHLEVBQUUsQ0FBRixJQUFPUSxpQkFBaUJGLE1BSHhDO0FBSUg7O0FBRUQ7QUFDQW5XLGtCQUFNa1MsT0FBTixDQUFjLGFBQUs7QUFDZixvQkFBSW9FLE9BQVE1RixFQUFFL0IsTUFBSCxHQUFhLENBQWIsR0FBaUIsQ0FBQyxDQUE3QixDQURlLENBQ2tCO0FBQ2pDLG9CQUFJbUgsVUFBVUgsRUFBRSxDQUFGLElBQU9qRixFQUFFeUIsQ0FBdkI7QUFBQSxvQkFDSTRELFVBQVVKLEVBQUUsQ0FBRixJQUFPakYsRUFBRXlFLENBRHZCO0FBQUEsb0JBRUlhLFFBQVFuWSxLQUFLb1ksSUFBTCxDQUFVSCxVQUFVQSxPQUFWLEdBQW9CQyxVQUFVQSxPQUF4QyxDQUZaO0FBQUEsb0JBR0lHLFNBQVMsQ0FIYjtBQUFBLG9CQUlJQyxTQUFTLENBSmI7O0FBTUEsb0JBQUlILFFBQVEsQ0FBWixFQUFjO0FBQ1ZFLDZCQUFTSixVQUFVRSxLQUFuQjtBQUNBRyw2QkFBU0osVUFBVUMsS0FBbkI7QUFDSDs7QUFFRHRGLGtCQUFFeUIsQ0FBRixJQUFPdFUsS0FBSzBZLEdBQUwsQ0FBU0wsTUFBVCxFQUFrQkosVUFBUSxHQUExQixJQUFrQ25hLENBQWxDLEdBQXNDMmEsSUFBdEMsR0FBK0M3QyxNQUFNK0MsS0FBTixFQUF0RDtBQUNBOUYsa0JBQUV5RSxDQUFGLElBQU90WCxLQUFLMFksR0FBTCxDQUFTSixNQUFULEVBQWtCSixVQUFRLEdBQTFCLElBQWtDcGEsQ0FBbEMsR0FBc0MyYSxJQUF0QyxHQUErQzdDLE1BQU0rQyxLQUFOLEVBQXREO0FBQ0gsYUFmRDtBQWtCSCxTQWxERCxNQWtESztBQUNENUQsMkJBQWU1TSxLQUFmLENBQXFCLFNBQXJCLEVBQWdDLENBQWhDO0FBQ0E4TSxpQkFBSzlNLEtBQUwsQ0FBVyxTQUFYLEVBQXNCLENBQXRCO0FBQ0EwTSxrQkFBTTFNLEtBQU4sQ0FBWSxTQUFaLEVBQXVCLENBQXZCO0FBQ0g7O0FBRUQ7QUFDQWlFLGFBQUsyRixJQUFMLENBQVUsR0FBVixFQUFlLGFBQUs7QUFDaEIsZ0JBQUk2RyxTQUFTcE8sRUFBRWdDLE1BQUYsQ0FBUzhILENBQVQsR0FBYTlKLEVBQUVpTCxNQUFGLENBQVNuQixDQUFuQztBQUFBLGdCQUNJdUUsU0FBU3JPLEVBQUVnQyxNQUFGLENBQVM4SyxDQUFULEdBQWE5TSxFQUFFaUwsTUFBRixDQUFTNkIsQ0FEbkM7QUFBQSxnQkFFSXdCLE9BQU85WSxLQUFLb1ksSUFBTCxDQUFVUSxTQUFTQSxNQUFULEdBQWtCQyxTQUFTQSxNQUFyQyxDQUZYO0FBQUEsZ0JBR0lFLFFBQVFILFNBQVNFLElBSHJCO0FBQUEsZ0JBSUlFLFFBQVFILFNBQVNDLElBSnJCO0FBQUEsZ0JBS0lHLGdCQUFnQnpPLEVBQUVrTCxJQUFGLEdBQVM1VixPQUFPLENBQWhCLEdBQW9CQSxJQUx4QztBQUFBLGdCQU1Jb1osZ0JBQWdCMU8sRUFBRW1MLEtBQUYsR0FBVTdWLE9BQU8sQ0FBakIsR0FBcUJBLElBTnpDO0FBQUEsZ0JBT0lxWixVQUFVM08sRUFBRWlMLE1BQUYsQ0FBU25CLENBQVQsR0FBYzJFLGdCQUFnQkYsS0FQNUM7QUFBQSxnQkFRSUssVUFBVTVPLEVBQUVpTCxNQUFGLENBQVM2QixDQUFULEdBQWMyQixnQkFBZ0JELEtBUjVDO0FBQUEsZ0JBU0lLLFVBQVU3TyxFQUFFZ0MsTUFBRixDQUFTOEgsQ0FBVCxHQUFjNEUsZ0JBQWdCSCxLQVQ1QztBQUFBLGdCQVVJTyxVQUFVOU8sRUFBRWdDLE1BQUYsQ0FBUzhLLENBQVQsR0FBYzRCLGdCQUFnQkYsS0FWNUM7QUFXQSx5QkFBV0csT0FBWCxTQUFzQkMsT0FBdEIsU0FBaUNDLE9BQWpDLFNBQTRDQyxPQUE1QztBQUNILFNBYkQ7O0FBZUFwRCxlQUFPbkUsSUFBUCxDQUFZLFdBQVosRUFBeUI7QUFBQSxtQkFBSyxlQUFldkgsRUFBRThKLENBQWpCLEdBQXFCLEdBQXJCLEdBQTJCOUosRUFBRThNLENBQTdCLEdBQWlDLEdBQXRDO0FBQUEsU0FBekI7O0FBRUFwQixlQUFPL0wsU0FBUCxDQUFpQixRQUFqQixFQUFxQztBQUFyQyxTQUNLMkgsVUFETCxHQUVLRyxRQUZMLENBRWMsR0FGZCxFQUdLRixJQUhMLENBR1UsR0FIVixFQUdlO0FBQUEsbUJBQUt3SCxnQkFBZ0IvTyxDQUFoQixDQUFMO0FBQUEsU0FIZjtBQUtIOztBQUVELFlBMVpPZ0ssUUEwWlAsY0FBVyxvQkFBVztBQUNsQjtBQUNBLFlBQUlyRCxjQUFjLEtBQUtoSyxFQUFuQixFQUF1QixJQUF2QixFQUE2QnlKLE9BQWpDLEVBQ0k7QUFDSmpRLGdCQUFRTyxLQUFSLEdBQWdCLEVBQWhCO0FBQ0EsWUFBSXFKLE9BQU9yTSxHQUFHK0osTUFBSCxDQUFVLElBQVYsRUFBZ0JzQyxJQUFoQixFQUFYO0FBQ0EsWUFBSWlQLE9BQU9DLFNBQVNsUCxJQUFULENBQVg7QUFDQSxZQUFJcEksTUFBTWtWLEdBQU4sQ0FBVTtBQUFBLG1CQUFLeEUsRUFBRTdHLElBQVA7QUFBQSxTQUFWLEVBQXVCME4sUUFBdkIsQ0FBZ0NuUCxJQUFoQyxDQUFKLEVBQTJDO0FBQ3ZDcEksa0JBQU0rUixNQUFOLENBQWFzRixLQUFLRyxLQUFsQixFQUF5QixDQUF6QjtBQUNBQywrQkFBbUJKLElBQW5CO0FBQ0F0RixtQkFBT3NGLEtBQUtsSixXQUFaLEVBQXlCL0YsSUFBekIsRUFBK0IsQ0FBQ2pNLE9BQUQsRUFBVSxLQUFWLENBQS9CLEVBQWlELENBQUNELE9BQUQsRUFBVSxRQUFWLENBQWpELEVBQXNFLENBQUNVLFNBQUQsRUFBWSxPQUFaLENBQXRFLEVBQTRGLENBQUNILFFBQUQsRUFBVyxNQUFYLENBQTVGOztBQUVBLGdCQUFHNGEsS0FBSzNJLE1BQVIsRUFBZTtBQUFpQjtBQUM1QjJJLHFCQUFLM0ksTUFBTCxHQUFjLEtBQWQ7QUFDQWxRLHdCQUFRUyxPQUFSLENBQWdCOFMsTUFBaEIsQ0FBdUJ2VCxRQUFRUyxPQUFSLENBQWdCbU0sT0FBaEIsQ0FBd0JpTSxLQUFLeE4sSUFBN0IsQ0FBdkIsRUFBMEQsQ0FBMUQ7QUFDSDtBQUNELGdCQUFHd04sS0FBSzFJLE1BQVIsRUFBZTtBQUNYMEkscUJBQUsxSSxNQUFMLEdBQWMsS0FBZDtBQUNBblEsd0JBQVFVLE9BQVIsQ0FBZ0I2UyxNQUFoQixDQUF1QnZULFFBQVFVLE9BQVIsQ0FBZ0JrTSxPQUFoQixDQUF3QmlNLEtBQUt4TixJQUE3QixDQUF2QixFQUEwRCxDQUExRDtBQUNIOztBQUVENk4sc0JBQVVMLElBQVY7QUFDQU07QUFDSCxTQWhCRCxNQWdCTztBQUNIM1gsa0JBQU0wTCxJQUFOLENBQVcyTCxJQUFYO0FBQ0EsZ0JBQUlyWCxNQUFNa0csTUFBTixLQUFpQixDQUFyQixFQUF3QmxHLE1BQU0sQ0FBTixFQUFTOE4sU0FBVCxHQUFxQixJQUFyQjtBQUMzQjtBQUNEdFAsZ0JBQVFPLEtBQVIsR0FBZ0JpQixNQUFNa1YsR0FBTixDQUFVO0FBQUEsbUJBQUt4RSxFQUFFN0csSUFBUDtBQUFBLFNBQVYsQ0FBaEIsQ0EzQmtCLENBMkJ3QjtBQUMxQ3JQO0FBQ0FvZDtBQUNILEtBOUJEOztBQWdDQTdiLE9BQUcrSixNQUFILENBQVUsU0FBVixFQUFxQmtDLFNBQXJCLENBQStCLEdBQS9CLEVBQW9DO0FBQ2hDO0FBREosS0FFS0QsRUFGTCxDQUVRLE9BRlIsRUFFaUIsWUFBVztBQUNwQixZQUFJOFAsVUFBVTliLEdBQUcrSixNQUFILENBQVUsSUFBVixFQUFnQkUsS0FBaEIsQ0FBc0Isa0JBQXRCLENBQWQ7QUFDQWpLLFdBQUcrSixNQUFILENBQVUsU0FBVixFQUFxQmtDLFNBQXJCLENBQStCLEdBQS9CLEVBQ0toQyxLQURMLENBQ1csa0JBRFgsRUFDK0J0SixRQUQvQjtBQUVBWCxXQUFHK0osTUFBSCxDQUFVLElBQVYsRUFDS0UsS0FETCxDQUNXLGtCQURYLEVBQytCLGFBQUs7QUFDNUIsZ0JBQUlqSyxHQUFHK2IsR0FBSCxDQUFPRCxPQUFQLEVBQWdCbkcsUUFBaEIsT0FBK0JoVixTQUFTZ1YsUUFBVCxFQUFuQyxFQUF3RDtBQUNwRGxULHdCQUFRTSxNQUFSLEdBQWlCdUosRUFBRXFKLFFBQUYsRUFBakI7QUFDQSx1QkFBT3dCLDZCQUFQO0FBQ0gsYUFIRCxNQUdPO0FBQ0gxVSx3QkFBUU0sTUFBUixHQUFpQixFQUFqQjtBQUNBLHVCQUFPcEMsUUFBUDtBQUNIO0FBQ0osU0FUTDtBQVVBa2I7QUFDSCxLQWpCTDs7QUFtQkE3YixPQUFHK0osTUFBSCxDQUFVLFFBQVYsRUFBb0JrQyxTQUFwQixDQUE4QixHQUE5QixFQUFtQztBQUNuQztBQURBLEtBRUNELEVBRkQsQ0FFSSxPQUZKLEVBRWEsWUFBVztBQUNwQixZQUFHNUosVUFBSCxFQUFlO0FBQ2YsWUFBRyxLQUFLNFosU0FBTCxJQUFnQixhQUFuQixFQUFrQztBQUM5QjtBQUNILFNBRkQsTUFFTztBQUNIaGMsZUFBRytKLE1BQUgsQ0FBVSxRQUFWLEVBQW9CQSxNQUFwQixDQUEyQixlQUEzQixFQUNDOEosSUFERCxDQUNNLE9BRE4sRUFDZSxjQURmO0FBRUFsTSxrQ0FBc0JDLFFBQXRCLEdBQWlDLEtBQUtxVSxTQUFMLENBQWV0RyxRQUFmLEVBQWpDO0FBQ0EzVixlQUFHK0osTUFBSCxDQUFVLElBQVYsRUFBZ0I4SixJQUFoQixDQUFxQixPQUFyQixFQUE2QixhQUE3QjtBQUNIO0FBQ0RnSTtBQUNBSyxxQkFBYSxVQUFiLEVBQXlCdlUscUJBQXpCLEVBQWdEL0IsV0FBaEQ7QUFDQyxLQWRMOztBQWdCQTVGLE9BQUcrSixNQUFILENBQVUsV0FBVixFQUF1QmtDLFNBQXZCLENBQWlDLEdBQWpDLEVBQ0NELEVBREQsQ0FDSSxPQURKLEVBQ2EsWUFBVztBQUNwQixZQUFHNUosVUFBSCxFQUFlO0FBQ2YsWUFBRyxLQUFLNFosU0FBTCxJQUFnQixhQUFuQixFQUFrQztBQUM5QjtBQUNILFNBRkQsTUFFTztBQUNIaGMsZUFBRytKLE1BQUgsQ0FBVSxXQUFWLEVBQXVCQSxNQUF2QixDQUE4QixlQUE5QixFQUNDOEosSUFERCxDQUNNLE9BRE4sRUFDZSxjQURmO0FBRUFsTSxrQ0FBc0JFLFdBQXRCLEdBQW9DLEtBQUtvVSxTQUFMLENBQWV0RyxRQUFmLEVBQXBDO0FBQ0EzVixlQUFHK0osTUFBSCxDQUFVLElBQVYsRUFBZ0I4SixJQUFoQixDQUFxQixPQUFyQixFQUE2QixhQUE3QjtBQUNIO0FBQ0RnSTtBQUNBSyxxQkFBYSxhQUFiLEVBQTRCdlUscUJBQTVCLEVBQW1EcEIsY0FBbkQ7QUFDQyxLQWJMOztBQWVBdkcsT0FBRytKLE1BQUgsQ0FBVSxVQUFWLEVBQXNCa0MsU0FBdEIsQ0FBZ0MsR0FBaEMsRUFDQ0QsRUFERCxDQUNJLE9BREosRUFDYSxZQUFXO0FBQ3BCLFlBQUc1SixVQUFILEVBQWU7QUFDZixZQUFHLEtBQUs0WixTQUFMLElBQWdCLGFBQW5CLEVBQWtDO0FBQzlCO0FBQ1Q7QUFDQztBQUNLLFNBSkQsTUFJTztBQUNIaGMsZUFBRytKLE1BQUgsQ0FBVSxVQUFWLEVBQXNCQSxNQUF0QixDQUE2QixlQUE3QixFQUNDOEosSUFERCxDQUNNLE9BRE4sRUFDZSxjQURmO0FBRUFsTSxrQ0FBc0JJLE1BQXRCLEdBQStCLEtBQUtrVSxTQUFMLENBQWV0RyxRQUFmLEVBQS9CO0FBQ0EzVixlQUFHK0osTUFBSCxDQUFVLElBQVYsRUFBZ0I4SixJQUFoQixDQUFxQixPQUFyQixFQUE2QixhQUE3QjtBQUNIO0FBQ0RnSTtBQUNBSyxxQkFBYSxRQUFiLEVBQXVCdlUscUJBQXZCLEVBQThDaEQsVUFBOUM7QUFDQyxLQWZMOztBQWlCQTNFLE9BQUcrSixNQUFILENBQVUsVUFBVixFQUFzQmtDLFNBQXRCLENBQWdDLEdBQWhDLEVBQ0NELEVBREQsQ0FDSSxPQURKLEVBQ2EsWUFBVztBQUNwQixZQUFHNUosVUFBSCxFQUFlO0FBQ2YsWUFBRyxLQUFLNFosU0FBTCxJQUFnQixhQUFuQixFQUFrQztBQUM5QjtBQUNILFNBRkQsTUFFTztBQUNIaGMsZUFBRytKLE1BQUgsQ0FBVSxVQUFWLEVBQXNCQSxNQUF0QixDQUE2QixlQUE3QixFQUNDOEosSUFERCxDQUNNLE9BRE4sRUFDZSxjQURmO0FBRUFsTSxrQ0FBc0JHLFVBQXRCLEdBQW1DLEtBQUttVSxTQUFMLENBQWV0RyxRQUFmLEVBQW5DO0FBQ0EzVixlQUFHK0osTUFBSCxDQUFVLElBQVYsRUFBZ0I4SixJQUFoQixDQUFxQixPQUFyQixFQUE2QixhQUE3QjtBQUNIO0FBQ0RnSTtBQUNBSyxxQkFBYSxZQUFiLEVBQTJCdlUscUJBQTNCLEVBQWtEVixhQUFsRDtBQUNDLEtBYkw7O0FBZUE7QUFDQSxhQUFTNFUsT0FBVCxHQUFtQjtBQUNmO0FBQ0E7QUFDQTdELGVBQU9tRSxJQUFQLENBQVl6RSxNQUFNMEUsSUFBbEI7QUFDQSxZQUFJamEsWUFBWSxDQUFaLEtBQWtCLE1BQXRCLEVBQThCO0FBQzFCdVYsa0JBQU0yRSxPQUFOLENBQWMsR0FBZDtBQUNBM0Usa0JBQU1HLE1BQU4sQ0FBYTtBQUFBLHVCQUFLeUUsZ0JBQWdCaFEsQ0FBaEIsQ0FBTDtBQUFBLGFBQWI7QUFDQW9MLGtCQUFNeE0sS0FBTjtBQUNBd00sa0JBQU02RSxZQUFOLENBQW1CLENBQW5CO0FBQ0EzYyxnQkFBSSxDQUFKLENBTDBCLENBS3dCO0FBQ2xELGdCQUFJNkMsUUFBUVMsT0FBUixDQUFnQmlILE1BQWhCLEdBQXlCLENBQTFCLEdBQWdDMUgsUUFBUVUsT0FBUixDQUFnQmdILE1BQWhCLEdBQXlCLENBQTVELEVBQWdFO0FBQUc7QUFDL0R2SyxvQkFBSSxHQUFKO0FBQ0g7QUFDSixTQVRELE1BU087QUFDSDhYLGtCQUFNMkUsT0FBTixDQUFjLENBQWQ7QUFDQTNFLGtCQUFNRyxNQUFOLENBQWEsQ0FBYjtBQUNBSCxrQkFBTTZFLFlBQU4sQ0FBbUIsQ0FBbkI7QUFDQTNjLGdCQUFJLENBQUo7QUFDSDtBQUNEOFgsY0FBTThFLE1BQU47O0FBRUE7QUFDQXRPLGVBQU9BLEtBQUtoQyxJQUFMLENBQVVoSSxLQUFWLENBQVA7O0FBRUE7QUFDQTtBQUNBZ0ssYUFBS3VPLE9BQUwsQ0FBYSxVQUFiLEVBQXlCO0FBQUEsbUJBQUssSUFBTDtBQUFBLFNBQXpCLEVBQ0t4UyxLQURMLENBQ1csY0FEWCxFQUMyQjtBQUFBLG1CQUFLbU0sRUFBRW9CLElBQUYsR0FBUyxtQkFBVCxHQUErQixFQUFwQztBQUFBLFNBRDNCLEVBRUt2TixLQUZMLENBRVcsWUFGWCxFQUV5QjtBQUFBLG1CQUFLbU0sRUFBRXFCLEtBQUYsR0FBVSxpQkFBVixHQUE4QixFQUFuQztBQUFBLFNBRnpCOztBQUlBO0FBQ0F2SixhQUFLL0IsS0FBTCxHQUFhQyxNQUFiLENBQW9CLFVBQXBCLEVBQ0t5SCxJQURMLENBQ1UsT0FEVixFQUNtQixNQURuQixFQUVLNEksT0FGTCxDQUVhLFVBRmIsRUFFeUI7QUFBQSxtQkFBSyxJQUFMO0FBQUEsU0FGekIsRUFHS3hTLEtBSEwsQ0FHVyxjQUhYLEVBRzJCO0FBQUEsbUJBQUttTSxFQUFFb0IsSUFBRixHQUFTLG1CQUFULEdBQStCLEVBQXBDO0FBQUEsU0FIM0IsRUFJS3ZOLEtBSkwsQ0FJVyxZQUpYLEVBSXlCO0FBQUEsbUJBQUttTSxFQUFFcUIsS0FBRixHQUFVLGlCQUFWLEdBQThCLEVBQW5DO0FBQUEsU0FKekIsRUFLS3pMLEVBTEwsQ0FLUSxXQUxSLEVBS3FCLFVBQVNNLENBQVQsRUFBWTtBQUFFO0FBQzNCLGdCQUFJd0YsTUFBTXJFLEtBQUtFLFNBQUwsQ0FBZXJCLENBQWYsQ0FBVjtBQUNBLGlCQUFLLElBQUkwSyxJQUFJLENBQWIsRUFBZ0JBLElBQUk5UyxNQUFNaUcsTUFBMUIsRUFBa0M2TSxHQUFsQyxFQUF1QztBQUNuQyxvQkFBSWxGLFFBQVFyRSxLQUFLRSxTQUFMLENBQWV6SixNQUFNOFMsQ0FBTixDQUFmLENBQVosRUFDSTlTLE1BQU04UixNQUFOLENBQWFnQixDQUFiLEVBQWdCLENBQWhCO0FBQ1A7QUFDSixTQVhMOztBQWFBO0FBQ0E5SSxhQUFLd08sSUFBTCxHQUFZblEsTUFBWjs7QUFFQTtBQUNBeUwsaUJBQVNBLE9BQU85TCxJQUFQLENBQVlqSSxLQUFaLEVBQW1CO0FBQUEsbUJBQUttUyxFQUFFbk4sRUFBUDtBQUFBLFNBQW5CLENBQVQ7O0FBRUE7QUFDQTtBQUNBK08sZUFBTy9MLFNBQVAsQ0FBaUIsUUFBakIsRUFDS3dRLE9BREwsQ0FDYSxXQURiLEVBQzBCO0FBQUEsbUJBQUtyRyxFQUFFckUsU0FBUDtBQUFBLFNBRDFCLEVBRUs5SCxLQUZMLENBRVcsTUFGWCxFQUVtQjtBQUFBLG1CQUFLakssR0FBRytiLEdBQUgsQ0FBTzNGLEVBQUVsRSxPQUFULENBQUw7QUFBQSxTQUZuQixFQUdLakksS0FITCxDQUdXLFFBSFgsRUFHcUI7QUFBQSxtQkFBS2pLLEdBQUcrYixHQUFILENBQU8zRixFQUFFaEUsV0FBVCxDQUFMO0FBQUEsU0FIckIsRUFJS25JLEtBSkwsQ0FJVyxjQUpYLEVBSTJCO0FBQUEsbUJBQUttTSxFQUFFL0QsV0FBUDtBQUFBLFNBSjNCOztBQU1BO0FBQ0EsWUFBSXNLLElBQUkzRSxPQUFPN0wsS0FBUCxHQUNIQyxNQURHLENBQ0ksT0FESixFQUVIeUgsSUFGRyxDQUVFLElBRkYsRUFFUTtBQUFBLG1CQUFLdUMsRUFBRXRJLElBQUYsR0FBUyxVQUFkO0FBQUEsU0FGUixDQUFSOztBQUlBO0FBQ0E2TyxVQUFFQyxJQUFGLENBQU8sVUFBU3RRLENBQVQsRUFBWTtBQUNmdE0sZUFBRytKLE1BQUgsQ0FBVSxJQUFWO0FBQ0EsZ0JBQUl1QyxFQUFFdVEsUUFBRixJQUFjLFlBQWxCLEVBQWdDLHdCQUFZdlEsQ0FBWixFQUFlLElBQWYsRUFBaEMsS0FDSyxJQUFJQSxFQUFFdVEsUUFBRixJQUFjLEtBQWxCLEVBQXlCLHFCQUFTdlEsQ0FBVCxFQUFZLElBQVo7QUFDakMsU0FKRDs7QUFNQSxZQUFJRixTQUFTLFNBQVRBLE1BQVMsQ0FBQzBRLEdBQUQsRUFBTWpKLElBQU47QUFBQSxtQkFBZTtBQUFBLHVCQUFLaUosTUFBTTFHLEVBQUV2QyxRQUFRLElBQVYsQ0FBWDtBQUFBLGFBQWY7QUFBQSxTQUFiOztBQUVBOEksVUFBRXZRLE1BQUYsQ0FBUyxNQUFULEVBQ0t5SCxJQURMLENBQ1UsSUFEVixFQUNnQnpILE9BQU8sT0FBUCxDQURoQixFQUVLeUgsSUFGTCxDQUVVLEdBRlYsRUFFZXJMLElBRmYsRUFHS3lCLEtBSEwsQ0FHVyxNQUhYLEVBR21CN0osT0FIbkIsRUFJS3lULElBSkwsQ0FJVSxjQUpWLEVBSTBCLENBSjFCLEVBS0s3SCxFQUxMLENBS1EsV0FMUixFQUtxQixVQUFTTSxDQUFULEVBQVk7QUFDekIySCxxQkFBUyxJQUFULEVBQWUsRUFBZixFQUFtQixDQUFuQixFQUFzQixHQUF0QjtBQUNBRCxpQkFBSzFILENBQUwsRUFBUSxRQUFSLEVBQWtCLEVBQWxCLEVBQXNCLENBQXRCLEVBQXlCLEdBQXpCO0FBQ0gsU0FSTCxFQVNLTixFQVRMLENBU1EsVUFUUixFQVNvQixVQUFTTSxDQUFULEVBQVk7QUFDeEIySCxxQkFBUyxJQUFULEVBQWUsQ0FBZixFQUFrQixHQUFsQixFQUF1QixHQUF2QjtBQUNBRCxpQkFBSzFILENBQUwsRUFBUSxRQUFSLEVBQWtCLENBQWxCLEVBQXFCLEdBQXJCLEVBQTBCLEdBQTFCO0FBQ0gsU0FaTCxFQWFLTixFQWJMLENBYVEsT0FiUixFQWFpQixhQUFLO0FBQ2QrUSxzQkFBVXpRLENBQVYsRUFBYWxNLE9BQWI7QUFDQXdiLG1CQUFPeGIsT0FBUDtBQUNBeWI7QUFDSCxTQWpCTDs7QUFtQkFjLFVBQUV2USxNQUFGLENBQVMsTUFBVCxFQUNLeUgsSUFETCxDQUNVLElBRFYsRUFDZ0J6SCxPQUFPLFFBQVAsQ0FEaEIsRUFFS3lILElBRkwsQ0FFVSxHQUZWLEVBRWUsQ0FGZixFQUdLQSxJQUhMLENBR1UsSUFIVixFQUdnQixJQUhoQixFQUlLQSxJQUpMLENBSVUsY0FKVixFQUkwQixDQUoxQixFQUtLekgsTUFMTCxDQUtZLFVBTFosRUFNS3lILElBTkwsQ0FNVSxZQU5WLEVBTXdCekgsT0FBTyxRQUFQLENBTnhCLEVBT0tDLElBUEwsQ0FPVSxTQVBWOztBQVNBc1EsVUFBRXZRLE1BQUYsQ0FBUyxNQUFULEVBQ0t5SCxJQURMLENBQ1UsSUFEVixFQUNnQnpILE9BQU8sUUFBUCxDQURoQixFQUVLeUgsSUFGTCxDQUVVLEdBRlYsRUFFZXBMLElBRmYsRUFHS3dCLEtBSEwsQ0FHVyxNQUhYLEVBR21CdkosUUFIbkIsRUFJS21ULElBSkwsQ0FJVSxjQUpWLEVBSTBCLENBSjFCLEVBS0s3SCxFQUxMLENBS1EsV0FMUixFQUtxQixVQUFTTSxDQUFULEVBQVk7QUFDekIsZ0JBQUlBLEVBQUUwUSxjQUFGLElBQW9CLFdBQXhCLEVBQXFDO0FBQ3JDL0kscUJBQVMsSUFBVCxFQUFlLEVBQWYsRUFBbUIsQ0FBbkIsRUFBc0IsR0FBdEI7QUFDQUQsaUJBQUsxSCxDQUFMLEVBQVEsU0FBUixFQUFtQixFQUFuQixFQUF1QixDQUF2QixFQUEwQixHQUExQjtBQUNILFNBVEwsRUFVS04sRUFWTCxDQVVRLFVBVlIsRUFVb0IsVUFBU00sQ0FBVCxFQUFZO0FBQ3hCLGdCQUFJQSxFQUFFMFEsY0FBRixJQUFvQixXQUF4QixFQUFxQztBQUNyQy9JLHFCQUFTLElBQVQsRUFBZSxDQUFmLEVBQWtCLEdBQWxCLEVBQXVCLEdBQXZCO0FBQ0FELGlCQUFLMUgsQ0FBTCxFQUFRLFNBQVIsRUFBbUIsQ0FBbkIsRUFBc0IsR0FBdEIsRUFBMkIsR0FBM0I7QUFDSCxTQWRMLEVBZUtOLEVBZkwsQ0FlUSxPQWZSLEVBZWlCLFVBQVNNLENBQVQsRUFBWTtBQUNyQixnQkFBSUEsRUFBRTBRLGNBQUYsSUFBb0IsV0FBeEIsRUFBcUM7QUFDckNELHNCQUFVelEsQ0FBVixFQUFhNUwsUUFBYjtBQUNBa2IsbUJBQU9sYixRQUFQO0FBQ0FtYjtBQUNILFNBcEJMOztBQXNCQWMsVUFBRXZRLE1BQUYsQ0FBUyxNQUFULEVBQ0t5SCxJQURMLENBQ1UsSUFEVixFQUNnQnpILE9BQU8sU0FBUCxDQURoQixFQUVLeUgsSUFGTCxDQUVVLEdBRlYsRUFFZSxDQUZmLEVBR0tBLElBSEwsQ0FHVSxJQUhWLEVBR2dCLElBSGhCLEVBSUtBLElBSkwsQ0FJVSxjQUpWLEVBSTBCLENBSjFCLEVBS0t6SCxNQUxMLENBS1ksVUFMWixFQU1LeUgsSUFOTCxDQU1VLFlBTlYsRUFNd0J6SCxPQUFPLFNBQVAsQ0FOeEIsRUFPS0MsSUFQTCxDQU9VLFNBUFY7O0FBU0FzUSxVQUFFdlEsTUFBRixDQUFTLE1BQVQsRUFDS3lILElBREwsQ0FDVSxJQURWLEVBQ2dCekgsT0FBTyxPQUFQLENBRGhCLEVBRUt5SCxJQUZMLENBRVUsR0FGVixFQUVldEwsSUFGZixFQUdLMEIsS0FITCxDQUdXLE1BSFgsRUFHb0I1SixRQUhwQixFQUlLd1QsSUFKTCxDQUlVLGNBSlYsRUFJMEIsQ0FKMUIsRUFLSzdILEVBTEwsQ0FLUSxXQUxSLEVBS3FCLFVBQVNNLENBQVQsRUFBWTtBQUN6QjBILGlCQUFLMUgsQ0FBTCxFQUFRLGNBQVIsRUFBd0IsRUFBeEIsRUFBNEIsQ0FBNUIsRUFBK0IsR0FBL0I7QUFDQTBILGlCQUFLMUgsQ0FBTCxFQUFRLGNBQVIsRUFBd0IsRUFBeEIsRUFBNEIsQ0FBNUIsRUFBK0IsR0FBL0I7QUFDQTJILHFCQUFTLElBQVQsRUFBZSxFQUFmLEVBQW1CLENBQW5CLEVBQXNCLEdBQXRCO0FBQ0FELGlCQUFLMUgsQ0FBTCxFQUFRLFFBQVIsRUFBa0IsRUFBbEIsRUFBc0IsQ0FBdEIsRUFBeUIsR0FBekI7QUFDSCxTQVZMLEVBV0tOLEVBWEwsQ0FXUSxVQVhSLEVBV29CLFVBQVNNLENBQVQsRUFBWTtBQUN4QjBILGlCQUFLMUgsQ0FBTCxFQUFRLGNBQVIsRUFBd0IsQ0FBeEIsRUFBMkIsR0FBM0IsRUFBZ0MsR0FBaEM7QUFDQTBILGlCQUFLMUgsQ0FBTCxFQUFRLGNBQVIsRUFBd0IsQ0FBeEIsRUFBMkIsR0FBM0IsRUFBZ0MsR0FBaEM7QUFDQTJILHFCQUFTLElBQVQsRUFBZSxDQUFmLEVBQWtCLEdBQWxCLEVBQXVCLEdBQXZCO0FBQ0FELGlCQUFLMUgsQ0FBTCxFQUFRLFFBQVIsRUFBa0IsQ0FBbEIsRUFBcUIsR0FBckIsRUFBMEIsR0FBMUI7QUFDSCxTQWhCTCxFQWlCS04sRUFqQkwsQ0FpQlEsT0FqQlIsRUFpQmlCLGFBQUs7QUFDZDtBQUNBK1Esc0JBQVV6USxDQUFWLEVBQWFqTSxRQUFiO0FBQ0F1YixtQkFBT3ZiLFFBQVA7QUFDQXdiO0FBQ0gsU0F0Qkw7O0FBd0JBYyxVQUFFdlEsTUFBRixDQUFTLE1BQVQsRUFDS3lILElBREwsQ0FDVSxJQURWLEVBQ2dCekgsT0FBTyxjQUFQLENBRGhCLEVBRUt5SCxJQUZMLENBRVUsR0FGVixFQUVlbkwsT0FGZixFQUdLdUIsS0FITCxDQUdXLE1BSFgsRUFHbUI1SixRQUhuQixFQUc4QjtBQUg5QixTQUlLd1QsSUFKTCxDQUlVLGNBSlYsRUFJMEIsQ0FKMUIsRUFLSzdILEVBTEwsQ0FLUSxXQUxSLEVBS3FCLFVBQVNNLENBQVQsRUFBWTtBQUN6QjJILHFCQUFTLElBQVQsRUFBZSxFQUFmLEVBQW1CLENBQW5CLEVBQXNCLEdBQXRCO0FBQ0FELGlCQUFLMUgsQ0FBTCxFQUFRLE9BQVIsRUFBaUIsRUFBakIsRUFBcUIsQ0FBckIsRUFBd0IsR0FBeEI7QUFDQTBILGlCQUFLMUgsQ0FBTCxFQUFRLFFBQVIsRUFBa0IsRUFBbEIsRUFBc0IsQ0FBdEIsRUFBeUIsR0FBekI7QUFDSCxTQVRMLEVBVUtOLEVBVkwsQ0FVUSxVQVZSLEVBVW9CLFVBQVNNLENBQVQsRUFBWTtBQUN4QjJILHFCQUFTLElBQVQsRUFBZSxDQUFmLEVBQWtCLEdBQWxCLEVBQXVCLEdBQXZCO0FBQ0FELGlCQUFLMUgsQ0FBTCxFQUFRLE9BQVIsRUFBaUIsQ0FBakIsRUFBb0IsR0FBcEIsRUFBeUIsR0FBekI7QUFDQTBILGlCQUFLMUgsQ0FBTCxFQUFRLFFBQVIsRUFBa0IsQ0FBbEIsRUFBcUIsR0FBckIsRUFBMEIsR0FBMUI7QUFDSCxTQWRMLEVBZUtOLEVBZkwsQ0FlUSxPQWZSLEVBZWlCLGFBQUs7QUFDZDtBQUNBK1Esc0JBQVV6USxDQUFWLEVBQWFqTSxRQUFiO0FBQ0F1YixtQkFBT3ZiLFFBQVA7QUFDQXdiO0FBQ0gsU0FwQkw7O0FBc0JDYyxVQUFFdlEsTUFBRixDQUFTLE1BQVQsRUFDSXlILElBREosQ0FDUyxJQURULEVBQ2V6SCxPQUFPLGNBQVAsQ0FEZixFQUVJeUgsSUFGSixDQUVTLEdBRlQsRUFFY2xMLE9BRmQsRUFHSXNCLEtBSEosQ0FHVSxNQUhWLEVBR2tCMUosUUFIbEIsRUFHNkI7QUFIN0IsU0FJSXNULElBSkosQ0FJUyxjQUpULEVBSXlCLENBSnpCLEVBS0k3SCxFQUxKLENBS08sV0FMUCxFQUtvQixVQUFTTSxDQUFULEVBQVk7QUFDekIySCxxQkFBUyxJQUFULEVBQWUsRUFBZixFQUFtQixDQUFuQixFQUFzQixHQUF0QjtBQUNBRCxpQkFBSzFILENBQUwsRUFBUSxPQUFSLEVBQWlCLEVBQWpCLEVBQXFCLENBQXJCLEVBQXdCLEdBQXhCO0FBQ0EwSCxpQkFBSzFILENBQUwsRUFBUSxRQUFSLEVBQWtCLEVBQWxCLEVBQXNCLENBQXRCLEVBQXlCLEdBQXpCO0FBQ0gsU0FUSixFQVVJTixFQVZKLENBVU8sVUFWUCxFQVVtQixVQUFTTSxDQUFULEVBQVk7QUFDeEIySCxxQkFBUyxJQUFULEVBQWUsQ0FBZixFQUFrQixHQUFsQixFQUF1QixHQUF2QjtBQUNBRCxpQkFBSzFILENBQUwsRUFBUSxPQUFSLEVBQWlCLENBQWpCLEVBQW9CLEdBQXBCLEVBQXlCLEdBQXpCO0FBQ0EwSCxpQkFBSzFILENBQUwsRUFBUSxRQUFSLEVBQWtCLENBQWxCLEVBQXFCLEdBQXJCLEVBQTBCLEdBQTFCO0FBQ0gsU0FkSixFQWVJTixFQWZKLENBZU8sT0FmUCxFQWVnQixhQUFLO0FBQ2Q7QUFDQStRLHNCQUFVelEsQ0FBVixFQUFhL0wsUUFBYjtBQUNBcWIsbUJBQU9yYixRQUFQO0FBQ0FzYjtBQUNILFNBcEJKOztBQXNCRGMsVUFBRXZRLE1BQUYsQ0FBUyxNQUFULEVBQ0t5SCxJQURMLENBQ1UsSUFEVixFQUNnQnpILE9BQU8sUUFBUCxDQURoQixFQUVLeUgsSUFGTCxDQUVVLEdBRlYsRUFFZSxDQUZmLEVBR0tBLElBSEwsQ0FHVSxJQUhWLEVBR2dCLElBSGhCLEVBSUtBLElBSkwsQ0FJVSxjQUpWLEVBSTBCLENBSjFCLEVBS0t6SCxNQUxMLENBS1ksVUFMWixFQU1LeUgsSUFOTCxDQU1VLFlBTlYsRUFNd0J6SCxPQUFPLFFBQVAsQ0FOeEIsRUFPS0MsSUFQTCxDQU9VLFFBUFY7O0FBU0FzUSxVQUFFdlEsTUFBRixDQUFTLFlBQVQsRUFDS3lILElBREwsQ0FDVSxPQURWLEVBQ21CLE1BRG5CLEVBRUtBLElBRkwsQ0FFVSxHQUZWLEVBRWU7QUFBQSxtQkFBS3dILGdCQUFnQi9PLENBQWhCLENBQUw7QUFBQSxTQUZmLEVBR0tyQyxLQUhMLENBR1csZ0JBSFgsRUFHNkIsU0FIN0IsRUFJS0EsS0FKTCxDQUlXLE1BSlgsRUFJbUI7QUFBQSxtQkFBS3FDLEVBQUU0RixPQUFQO0FBQUEsU0FKbkIsRUFLS2pJLEtBTEwsQ0FLVyxTQUxYLEVBS3NCLEtBTHRCLEVBTUtBLEtBTkwsQ0FNVyxRQU5YLEVBTXFCO0FBQUEsbUJBQUtqSyxHQUFHK2IsR0FBSCxDQUFPelAsRUFBRThGLFdBQVQsRUFBc0J1RCxRQUF0QixFQUFMO0FBQUEsU0FOckIsRUFPSzhHLE9BUEwsQ0FPYSxXQVBiLEVBTzBCO0FBQUEsbUJBQUtuUSxFQUFFeUYsU0FBUDtBQUFBLFNBUDFCLEVBUUsvRixFQVJMLENBUVEsVUFSUixFQVFvQixVQUFTcUMsQ0FBVCxFQUFZO0FBQ3hCck8sZUFBR2lkLEtBQUgsQ0FBUzFILGVBQVQsR0FEd0IsQ0FDSTtBQUM1QixvQkE3b0RMdlUsV0E2b0RLLGlCQUFjLElBQWQ7QUFDSCxTQVhMLEVBWUtnTCxFQVpMLENBWVEsYUFaUixFQVl1QixVQUFTTSxDQUFULEVBQVk7QUFDM0I7QUFDQXRNLGVBQUdpZCxLQUFILENBQVNDLGNBQVQ7QUFDQWxkLGVBQUdpZCxLQUFILENBQVMxSCxlQUFUOztBQUVBbFIsNkJBQWlCLElBQWpCO0FBQ0ErVCw2QkFBaUI5TCxDQUFqQjtBQUNBMkwsNEJBQWdCRyxtQkFBbUJILGFBQW5CLEdBQW1DLElBQW5DLEdBQTBDRyxjQUExRDtBQUNBRiw0QkFBZ0IsSUFBaEI7O0FBRUE7QUFDQUgsc0JBQ0s5TixLQURMLENBQ1csWUFEWCxFQUN5QixpQkFEekIsRUFFS3dTLE9BRkwsQ0FFYSxRQUZiLEVBRXVCLEtBRnZCLEVBR0s1SSxJQUhMLENBR1UsR0FIVixFQUdlLE1BQU11RSxlQUFlaEMsQ0FBckIsR0FBeUIsR0FBekIsR0FBK0JnQyxlQUFlZ0IsQ0FBOUMsR0FBa0QsR0FBbEQsR0FBd0RoQixlQUFlaEMsQ0FBdkUsR0FBMkUsR0FBM0UsR0FBaUZnQyxlQUFlZ0IsQ0FIL0c7O0FBS0FuUixnQkFBSStELEVBQUosQ0FBTyxXQUFQLEVBQW9CbVIsU0FBcEI7QUFDQXRCO0FBQ0gsU0E5QkwsRUErQks3UCxFQS9CTCxDQStCUSxTQS9CUixFQStCbUIsVUFBU00sQ0FBVCxFQUFZO0FBQ3ZCdE0sZUFBR2lkLEtBQUgsQ0FBUzFILGVBQVQ7O0FBRUEsZ0JBQUlsUixjQUFKLEVBQW9CO0FBQ2hCQSxpQ0FBaUIsS0FBakI7QUFDQTtBQUNIO0FBQ0QsZ0JBQUksQ0FBQytULGNBQUwsRUFBcUI7O0FBRXJCO0FBQ0FMLHNCQUNLMEUsT0FETCxDQUNhLFFBRGIsRUFDdUIsSUFEdkIsRUFFS3hTLEtBRkwsQ0FFVyxZQUZYLEVBRXlCLEVBRnpCOztBQUlBO0FBQ0FvTywyQkFBZS9MLENBQWY7QUFDQSxnQkFBSStMLGlCQUFpQkQsY0FBckIsRUFBcUM7QUFDakNFO0FBQ0E7QUFDSDs7QUFFRDtBQUNBdFksZUFBRytKLE1BQUgsQ0FBVSxJQUFWLEVBQWdCOEosSUFBaEIsQ0FBcUIsV0FBckIsRUFBa0MsRUFBbEM7O0FBRUE7QUFDQTtBQUNBLGdCQUFJMEQsTUFBSixFQUFZakosTUFBWixFQUFvQjhPLFNBQXBCO0FBQ0EsZ0JBQUloRixlQUFlblAsRUFBZixHQUFvQm9QLGFBQWFwUCxFQUFyQyxFQUF5QztBQUNyQ3NPLHlCQUFTYSxjQUFUO0FBQ0E5Six5QkFBUytKLFlBQVQ7QUFDQStFLDRCQUFZLE9BQVo7QUFDSCxhQUpELE1BSU87QUFDSDdGLHlCQUFTYyxZQUFUO0FBQ0EvSix5QkFBUzhKLGNBQVQ7QUFDQWdGLDRCQUFZLE1BQVo7QUFDSDs7QUFFRCxnQkFBSUMsT0FBT25aLE1BQU1vWixNQUFOLENBQWE7QUFBQSx1QkFBS2xILEVBQUVtQixNQUFGLElBQVlBLE1BQVosSUFBc0JuQixFQUFFOUgsTUFBRixJQUFZQSxNQUF2QztBQUFBLGFBQWIsRUFBNEQsQ0FBNUQsQ0FBWDtBQUNBLGdCQUFJK08sSUFBSixFQUFVO0FBQ05BLHFCQUFLRCxTQUFMLElBQWtCLElBQWxCO0FBQ0gsYUFGRCxNQUVPO0FBQ0hDLHVCQUFPO0FBQ0g5Riw0QkFBUUEsTUFETDtBQUVIakosNEJBQVFBLE1BRkw7QUFHSGtKLDBCQUFNLEtBSEg7QUFJSEMsMkJBQU87QUFKSixpQkFBUDtBQU1BNEYscUJBQUtELFNBQUwsSUFBa0IsSUFBbEI7QUFDQWxaLHNCQUFNeUwsSUFBTixDQUFXME4sSUFBWDtBQUNIOztBQUVEO0FBQ0FuRiw0QkFBZ0JtRixJQUFoQjtBQUNBcEYsNEJBQWdCLElBQWhCO0FBQ0FoUSxnQkFBSStELEVBQUosQ0FBTyxXQUFQLEVBQW9CLElBQXBCOztBQUVBc007QUFDQXVEO0FBQ0gsU0F6Rkw7O0FBMkZBO0FBQ0FjLFVBQUV2USxNQUFGLENBQVMsVUFBVCxFQUNLeUgsSUFETCxDQUNVLEdBRFYsRUFDZSxDQURmLEVBRUtBLElBRkwsQ0FFVSxHQUZWLEVBRWUsRUFGZixFQUdLQSxJQUhMLENBR1UsT0FIVixFQUdtQixJQUhuQixFQUlLeEgsSUFKTCxDQUlVO0FBQUEsbUJBQUtDLEVBQUV3QixJQUFQO0FBQUEsU0FKVjs7QUFNQTtBQUNBO0FBQ0E2TyxVQUFFMVEsU0FBRixDQUFZLGFBQVosRUFDS0QsRUFETCxDQUNRLFdBRFIsRUFDcUIsYUFBSztBQUNsQnpOLG9CQUFRLE1BQVI7QUFDQWdmLHVCQUFXalIsQ0FBWDtBQUNBQSxjQUFFdUcsU0FBRixHQUFjLElBQWQ7O0FBRUEvSixpQkFBSyxpQkFBTCxFQUF3QjBVLFlBQXhCLENBQXFDLE9BQXJDLEVBQThDLGVBQTlDO0FBQ0ExVSxpQkFBSyxVQUFMLEVBQWlCMlUsYUFBakIsR0FBaUNuUixFQUFFckQsRUFBbkM7QUFDQTNILDJCQUFld0MsU0FBU3dJLEVBQUVyRCxFQUFYLENBQWY7O0FBRUErSyxpQkFBSzFILENBQUwsRUFBUSxPQUFSLEVBQWlCLEVBQWpCLEVBQXFCLENBQXJCLEVBQXdCLEdBQXhCO0FBQ0EwSCxpQkFBSzFILENBQUwsRUFBUSxRQUFSLEVBQWtCLEVBQWxCLEVBQXNCLENBQXRCLEVBQXlCLEdBQXpCO0FBQ0EwSCxpQkFBSzFILENBQUwsRUFBUSxPQUFSLEVBQWlCLEVBQWpCLEVBQXFCLENBQXJCLEVBQXdCLEdBQXhCO0FBQ0EwSCxpQkFBSzFILENBQUwsRUFBUSxRQUFSLEVBQWtCLEVBQWxCLEVBQXNCLENBQXRCLEVBQXlCLEdBQXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQUlBLEVBQUUwUSxjQUFGLElBQW9CLFNBQXhCLEVBQW1DO0FBQy9CaEoscUJBQUsxSCxDQUFMLEVBQVEsUUFBUixFQUFrQixFQUFsQixFQUFzQixDQUF0QixFQUF5QixHQUF6QjtBQUNBMEgscUJBQUsxSCxDQUFMLEVBQVEsU0FBUixFQUFtQixFQUFuQixFQUF1QixDQUF2QixFQUEwQixHQUExQjtBQUNIO0FBQ0QwSCxpQkFBSzFILENBQUwsRUFBUSxPQUFSLEVBQWlCLEVBQWpCLEVBQXFCLENBQXJCLEVBQXdCLEdBQXhCO0FBQ0EwSCxpQkFBSzFILENBQUwsRUFBUSxRQUFSLEVBQWtCLEVBQWxCLEVBQXNCLENBQXRCLEVBQXlCLEdBQXpCO0FBQ0EwSCxpQkFBSzFILENBQUwsRUFBUSxTQUFSLEVBQW1CLEVBQW5CLEVBQXVCLENBQXZCLEVBQTBCLEdBQTFCO0FBQ0EwSCxpQkFBSzFILENBQUwsRUFBUSxVQUFSLEVBQW9CLEVBQXBCLEVBQXdCLENBQXhCLEVBQTJCLEdBQTNCOztBQUVBLDhCQUFFc0osTUFBRjtBQUNILFNBN0JMLEVBOEJLNUosRUE5QkwsQ0E4QlEsVUE5QlIsRUE4Qm9CLGFBQUs7QUFDakJNLGNBQUV1RyxTQUFGLEdBQWMsS0FBZDtBQUNBN1IsMkJBQWV6QyxRQUFRd0MsU0FBUyxNQUFULEdBQWtCLE1BQTFCLENBQWY7QUFDQSxxRkFBeUVNLEtBQXpFLENBQStFLEdBQS9FLEVBQW9GOFgsR0FBcEYsQ0FBd0Y7QUFBQSx1QkFBS25GLEtBQUsxSCxDQUFMLEVBQVE4SixDQUFSLEVBQVcsQ0FBWCxFQUFjLEdBQWQsRUFBbUIsR0FBbkIsQ0FBTDtBQUFBLGFBQXhGO0FBQ0EsOEJBQUVSLE1BQUY7QUFDSCxTQW5DTDs7QUFxQ0E7QUFDQTVWLFdBQUcrSixNQUFILENBQVUsV0FBVixFQUNLa0MsU0FETCxDQUNlLElBRGYsRUFFS00sTUFGTDs7QUFJQXZNLFdBQUcrSixNQUFILENBQVUsV0FBVixFQUNLa0MsU0FETCxDQUNlLElBRGYsRUFFS0MsSUFGTCxDQUVVakksTUFBTWtWLEdBQU4sQ0FBVTtBQUFBLG1CQUFLL0MsRUFBRXRJLElBQVA7QUFBQSxTQUFWLENBRlYsRUFFa0M7QUFGbEMsU0FHSzNCLEtBSEwsR0FJS0MsTUFKTCxDQUlZLElBSlosRUFLS0MsSUFMTCxDQUtVO0FBQUEsbUJBQUtDLENBQUw7QUFBQSxTQUxWOztBQU9BLFlBQUcsQ0FBQ1csUUFBSixFQUFhO0FBQ1Q3QyxjQUFFLGNBQUYsRUFBa0JnRixLQUFsQixDQUF3QixVQUFTeUYsR0FBVCxFQUFjO0FBQ2xDO0FBQ0Esb0JBQUl2USxXQUFKLEVBQWlCO0FBQ2Isd0JBQUlxUSxJQUFJdkssRUFBRSxTQUFGLEVBQWEySyxHQUFiLEdBQW1CSyxNQUFuQixDQUEwQmhMLEVBQUUsSUFBRixFQUFRaUMsSUFBUixFQUExQixDQUFSO0FBQ0FqQyxzQkFBRSxTQUFGLEVBQWEySyxHQUFiLENBQWlCSixDQUFqQjtBQUNBRSx3QkFBSVUsZUFBSjtBQUNBLHdCQUFJclUsSUFBSThULFdBQVdMLElBQUlBLENBQWYsQ0FBUjtBQUNBLHdCQUFJLENBQUN6VCxDQUFMLEVBQVE7QUFDUmtKLHNCQUFFLElBQUYsRUFBUWlMLE1BQVIsR0FBaUJoQixPQUFqQixDQUF5QixHQUF6QjtBQUNBWSw4QkFBVU4sSUFBSXpULEVBQUVnVSxLQUFGLENBQVEsQ0FBUixFQUFXaFUsRUFBRWlKLE1BQUYsR0FBVyxDQUF0QixDQUFkLEVBQXdDakosSUFBSUEsRUFBRUEsRUFBRWlKLE1BQUYsR0FBVyxDQUFiLENBQTVDLEVBQTZEaEosZ0JBQWdCLEtBQTdFO0FBQ0E7QUFDSDs7QUFFRGlKLGtCQUFFLFNBQUYsRUFBYTJLLEdBQWIsQ0FBaUIzSyxFQUFFLElBQUYsRUFBUWlDLElBQVIsRUFBakI7QUFDQWpDLGtCQUFFLElBQUYsRUFBUWlMLE1BQVIsR0FBaUJoQixPQUFqQixDQUF5QixHQUF6QjtBQUNBakssa0JBQUUsWUFBRixFQUFnQnNLLE1BQWhCLENBQXVCLEdBQXZCO0FBQ0FHLG9CQUFJVSxlQUFKO0FBQ0gsYUFqQkQ7QUFrQkg7O0FBRUQ7QUFDQXlDLGVBQU8wRSxJQUFQLEdBQWNuUSxNQUFkO0FBQ0FtTCxjQUFNeE0sS0FBTjtBQUNIOztBQUVELGFBQVN3UyxTQUFULENBQW1CcFIsQ0FBbkIsRUFBc0I7QUFDbEI7QUFDQXRNLFdBQUdpZCxLQUFILENBQVNDLGNBQVQ7QUFDQTtBQUNBalYsWUFBSXdVLE9BQUosQ0FBWSxRQUFaLEVBQXNCLElBQXRCO0FBQ0EsWUFBSXpjLEdBQUdpZCxLQUFILENBQVNVLE9BQVQsSUFBb0J2RixjQUFwQixJQUFzQ0QsY0FBMUMsRUFBMEQ7QUFDMUQwRDtBQUNIOztBQUVELGFBQVNzQixTQUFULENBQW1CN1EsQ0FBbkIsRUFBc0I7QUFDbEIsWUFBSSxDQUFDOEwsY0FBTCxFQUNJO0FBQ0o7QUFDQUwsa0JBQVVsRSxJQUFWLENBQWUsR0FBZixFQUFvQixNQUFNdUUsZUFBZWhDLENBQXJCLEdBQXlCLEdBQXpCLEdBQStCZ0MsZUFBZWdCLENBQTlDLEdBQWtELEdBQWxELEdBQXdEcFosR0FBRzRkLEtBQUgsQ0FBUyxJQUFULEVBQWUsQ0FBZixDQUF4RCxHQUE0RSxHQUE1RSxHQUFrRjVkLEdBQUc0ZCxLQUFILENBQVMsSUFBVCxFQUFlLENBQWYsQ0FBdEc7QUFDSDs7QUFFRCxhQUFTQyxPQUFULENBQWlCdlIsQ0FBakIsRUFBb0I7QUFDaEIsWUFBSThMLGNBQUosRUFBb0I7QUFDaEJMLHNCQUNLMEUsT0FETCxDQUNhLFFBRGIsRUFDdUIsSUFEdkIsRUFFS3hTLEtBRkwsQ0FFVyxZQUZYLEVBRXlCLEVBRnpCO0FBR0g7QUFDRDtBQUNBaEMsWUFBSXdVLE9BQUosQ0FBWSxRQUFaLEVBQXNCLEtBQXRCO0FBQ0E7QUFDQW5FO0FBQ0g7O0FBRUQ7QUFDQXJRLFFBQUk0TCxJQUFKLENBQVMsSUFBVCxFQUFlO0FBQUEsZUFBTSxhQUFhdUIsTUFBYixDQUFvQmxULE9BQXBCLENBQU47QUFBQSxLQUFmLEVBQ0syUixJQURMLENBQ1UsUUFEVixFQUNvQjFMLE1BRHBCLEVBRUs2RCxFQUZMLENBRVEsV0FGUixFQUVxQixZQUFXO0FBQUMwUixrQkFBVSxJQUFWO0FBQWlCLEtBRmxELEVBR0sxUixFQUhMLENBR1EsU0FIUixFQUdtQixZQUFXO0FBQUM2UixnQkFBUSxJQUFSO0FBQWUsS0FIOUM7O0FBS0E3ZCxPQUFHK0osTUFBSCxDQUFVTSxNQUFWLEVBQ0syQixFQURMLENBQ1EsT0FEUixFQUNpQixZQUFNO0FBQ2Y7QUFDQTVCLFVBQUUsWUFBRixFQUFnQmlLLE9BQWhCLENBQXdCLEdBQXhCO0FBQ0FqSyxVQUFFLFdBQUYsRUFBZWlLLE9BQWYsQ0FBdUIsR0FBdkI7QUFDSCxLQUxMOztBQU9Bd0gsY0FuN0JrQixDQW03QlA7QUFDWGlDOztBQUVBLFFBQUd0SCxLQUFLdkosUUFBUixFQUFrQjtBQUNkLFlBQUk4USxXQUFXaFYsU0FBU2lWLFdBQVQsQ0FBcUIsYUFBckIsQ0FBZjtBQUNBO0FBQ0FELGlCQUFTRSxTQUFULENBQW1CLE9BQW5CLEVBQTRCLElBQTVCLENBQWlDLFlBQWpDLEVBQStDLElBQS9DLENBQW9ELGdCQUFwRDtBQUNBO0FBQ0EsWUFBSUMsVUFBVSxVQUFRakwsY0FBY3pPLFFBQWQsQ0FBdEI7QUFDQXVFLGlCQUFTQyxjQUFULENBQXdCa1YsT0FBeEIsRUFBaUNDLGFBQWpDLENBQStDSixRQUEvQztBQUNIO0FBQ0o7O0FBR0QsSUFBSUssT0FBTyxTQUFQQSxJQUFPLENBQUNDLE1BQUQsRUFBU3ZRLElBQVQsRUFBa0I7QUFDekIsU0FBSyxJQUFJNEIsQ0FBVCxJQUFjMk8sTUFBZDtBQUNJLFlBQUlBLE9BQU8zTyxDQUFQLEVBQVU1QixJQUFWLElBQWtCQSxJQUF0QixFQUE0QixPQUFPdVEsT0FBTzNPLENBQVAsRUFBVXpHLEVBQWpCO0FBRGhDO0FBRUgsQ0FIRDs7QUFLQTtBQUNPLElBQUlnSyx3Q0FBZ0IsU0FBaEJBLGFBQWdCLENBQUNuRixJQUFELEVBQU93USxHQUFQLEVBQWU7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFDdEMsNkJBQWlCdmEsUUFBakIsOEhBQTJCO0FBQUEsZ0JBQWxCdVgsSUFBa0I7O0FBQ3ZCLGdCQUFJQSxLQUFLeE4sSUFBTCxLQUFjQSxJQUFsQixFQUF3QjtBQUNwQjtBQUNBLHVCQUFPd1EsTUFBS2hELElBQUwsR0FBWUEsS0FBS3JTLEVBQXhCO0FBQ0g7QUFDSjtBQU5xQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBT3pDLENBUE07O0FBU1AsSUFBSW9PLFlBQVksU0FBWkEsU0FBWSxXQUFZO0FBQ3hCLFNBQUssSUFBSTNILENBQVQsSUFBY3pMLEtBQWQ7QUFDSSxZQUFJQSxNQUFNeUwsQ0FBTixFQUFTNUIsSUFBVCxJQUFpQnlRLFFBQXJCLEVBQStCLE9BQU83TyxDQUFQO0FBRG5DO0FBRUgsQ0FIRDs7QUFLTyxJQUFJNkwsOEJBQVcsU0FBWEEsUUFBVyxXQUFZO0FBQzlCLFNBQUssSUFBSTdMLENBQVQsSUFBYzNMLFFBQWQ7QUFDSSxZQUFJQSxTQUFTMkwsQ0FBVCxFQUFZNUIsSUFBWixJQUFvQnlRLFFBQXhCLEVBQWtDLE9BQU94YSxTQUFTMkwsQ0FBVCxDQUFQO0FBRHRDO0FBRUgsQ0FITTs7QUFLUDs7Ozs7QUFLTyxTQUFTMVIsZUFBVCxDQUF5QndnQixRQUF6QixFQUFtQztBQUN0Qzs7Ozs7Ozs7Ozs7O0FBWUEsV0FBT0EsU0FBU3RPLGNBQVQsQ0FBd0IsV0FBeEIsSUFBdUNzTyxTQUFTQyxTQUFoRCxHQUE0REQsUUFBbkU7QUFDSDs7QUFFRDtBQUNPLFNBQVN2Z0IsV0FBVCxHQUF1QjtBQUMxQmtFLGtCQUFjLENBQUNBLFlBQVksQ0FBWixLQUFrQixNQUFsQixHQUEyQixPQUEzQixHQUFxQyxNQUF0QyxDQUFkO0FBQ0EsUUFBSUEsWUFBWSxDQUFaLE1BQW1CLE9BQXZCLEVBQWdDO0FBQzVCMkcsYUFBSyxVQUFMLEVBQWlCMFUsWUFBakIsQ0FBOEIsT0FBOUIsRUFBdUMsWUFBdkM7QUFDSCxLQUZELE1BRU87QUFDSDFVLGFBQUssVUFBTCxFQUFpQjBVLFlBQWpCLENBQThCLE9BQTlCLEVBQXVDLGlCQUF2QztBQUNBTTtBQUNIO0FBQ0o7O0FBRU0sU0FBUzVmLGFBQVQsQ0FBdUJ3Z0IsSUFBdkIsRUFBNkI7QUFDaEMsUUFBR0EsUUFBTSxPQUFULEVBQWlCO0FBQ2IsWUFBSUMsTUFBTXRVLE9BQU91VSxJQUFQLENBQVksNENBQVosRUFBMEQsUUFBMUQsQ0FBVjtBQUNBRCxZQUFJRSxLQUFKO0FBQ0gsS0FIRCxNQUdLO0FBQ0QsWUFBSUYsTUFBTXRVLE9BQU91VSxJQUFQLENBQVksNkNBQVosRUFBMkQsUUFBM0QsQ0FBVjtBQUNBRCxZQUFJRSxLQUFKO0FBQ0g7QUFDRHBmLFlBQVFDLEdBQVIsQ0FBWWdmLElBQVo7QUFDSDs7QUFFTSxTQUFTdmdCLGVBQVQsR0FBMkI7QUFDOUJpRSxpQkFBYUEsYUFBYSxLQUFiLEdBQXFCLElBQWxDO0FBQ0EsUUFBSW9NLGFBQUo7QUFDQSxRQUFJa0IsVUFBSjtBQUNBLFFBQUksQ0FBQ3ROLFVBQUwsRUFBaUI7QUFDYjJHLGlCQUFTQyxjQUFULENBQXdCLFNBQXhCLEVBQW1Dd1UsWUFBbkMsQ0FBZ0QsT0FBaEQsRUFBeUQsaUJBQXpEO0FBQ0FoUCxlQUFPekYsU0FBU0MsY0FBVCxDQUF3QixrQkFBeEIsRUFBNEM4VixnQkFBNUMsQ0FBNkQsZ0JBQTdELENBQVA7QUFDQSxhQUFLcFAsSUFBSSxDQUFULEVBQVlBLElBQUlsQixLQUFLckUsTUFBckIsRUFBNkJ1RixHQUE3QixFQUFrQztBQUM5QmxCLGlCQUFLa0IsQ0FBTCxFQUFRbUcsU0FBUixDQUFrQnRKLE1BQWxCLENBQXlCLGNBQXpCO0FBQ0g7QUFDSixLQU5ELE1BTU87QUFDSHhELGlCQUFTQyxjQUFULENBQXdCLFNBQXhCLEVBQW1Dd1UsWUFBbkMsQ0FBZ0QsT0FBaEQsRUFBeUQsWUFBekQ7QUFDQWhQLGVBQU96RixTQUFTQyxjQUFULENBQXdCLFNBQXhCLEVBQW1DOFYsZ0JBQW5DLENBQW9ELGdCQUFwRCxDQUFQO0FBQ0FyZixnQkFBUUMsR0FBUixDQUFZOE8sSUFBWjtBQUNBLGFBQUtrQixJQUFJLENBQVQsRUFBWUEsSUFBSWxCLEtBQUtyRSxNQUFyQixFQUE2QnVGLEdBQTdCLEVBQWtDO0FBQzlCbEIsaUJBQUtrQixDQUFMLEVBQVFtRyxTQUFSLENBQWtCQyxHQUFsQixDQUFzQixjQUF0QjtBQUNIO0FBQ0R0SCxlQUFPekYsU0FBU0MsY0FBVCxDQUF3QixPQUF4QixFQUFpQzhWLGdCQUFqQyxDQUFrRCxnQkFBbEQsQ0FBUDtBQUNBLGFBQUtwUCxJQUFJLENBQVQsRUFBWUEsSUFBSWxCLEtBQUtyRSxNQUFyQixFQUE2QnVGLEdBQTdCLEVBQWtDO0FBQzlCbEIsaUJBQUtrQixDQUFMLEVBQVFtRyxTQUFSLENBQWtCQyxHQUFsQixDQUFzQixjQUF0QjtBQUNIO0FBQ0R0SCxlQUFPekYsU0FBU0MsY0FBVCxDQUF3QixVQUF4QixFQUFvQzhWLGdCQUFwQyxDQUFxRCxnQkFBckQsQ0FBUDtBQUNBLGFBQUtwUCxJQUFJLENBQVQsRUFBWUEsSUFBSWxCLEtBQUtyRSxNQUFyQixFQUE2QnVGLEdBQTdCLEVBQWtDO0FBQzlCbEIsaUJBQUtrQixDQUFMLEVBQVFtRyxTQUFSLENBQWtCQyxHQUFsQixDQUFzQixjQUF0QjtBQUNIO0FBQ0R0SCxlQUFPekYsU0FBU0MsY0FBVCxDQUF3QixTQUF4QixFQUFtQzhWLGdCQUFuQyxDQUFvRCxnQkFBcEQsQ0FBUDtBQUNBLGFBQUtwUCxJQUFJLENBQVQsRUFBWUEsSUFBSWxCLEtBQUtyRSxNQUFyQixFQUE2QnVGLEdBQTdCLEVBQWtDO0FBQzlCbEIsaUJBQUtrQixDQUFMLEVBQVFtRyxTQUFSLENBQWtCQyxHQUFsQixDQUFzQixjQUF0QjtBQUNIO0FBQ0RnSTtBQUNIO0FBQ0o7O0FBRU0sSUFBSXBDLGtEQUFxQixTQUFyQkEsa0JBQXFCO0FBQUEsV0FBUXhYLE1BQ25Db1osTUFEbUMsQ0FDNUI7QUFBQSxlQUFLeUIsRUFBRXhILE1BQUYsS0FBYStELElBQWIsSUFBcUJ5RCxFQUFFelEsTUFBRixLQUFhZ04sSUFBdkM7QUFBQSxLQUQ0QixFQUVuQ25DLEdBRm1DLENBRS9CO0FBQUEsZUFBS2pWLE1BQU04UixNQUFOLENBQWE5UixNQUFNbUwsT0FBTixDQUFjK0csQ0FBZCxDQUFiLEVBQStCLENBQS9CLENBQUw7QUFBQSxLQUYrQixDQUFSO0FBQUEsQ0FBekI7O0FBSVAsU0FBUzlDLElBQVQsR0FBZ0I7QUFDWixRQUFJaEssT0FBSixFQUFhN0csUUFBUVcsUUFBUixHQUFtQmtHLE9BQW5CO0FBQ2I3RyxZQUFRZ0IsV0FBUixHQUFzQkksVUFBdEI7QUFDQXBCLFlBQVFFLE1BQVIsR0FBaUIsRUFBakI7QUFDQUYsWUFBUU8sS0FBUixHQUFnQixFQUFoQjtBQUNBLFNBQUssSUFBSWdVLElBQUksQ0FBYixFQUFnQkEsSUFBSS9TLE1BQU1rRyxNQUExQixFQUFrQzZNLEdBQWxDLEVBQXVDO0FBQUU7QUFDckN2VSxnQkFBUU8sS0FBUixDQUFjMk0sSUFBZCxDQUFtQjFMLE1BQU0rUyxDQUFOLEVBQVNsSixJQUE1QjtBQUNBLFlBQUlVLE9BQU92SyxNQUFNK1MsQ0FBTixFQUFTL04sRUFBcEI7QUFDQXhHLGdCQUFRZSxLQUFSLENBQWN3VCxDQUFkLElBQW1CalQsU0FBU3lLLElBQVQsRUFBZWlFLFFBQWxDO0FBQ0FoUSxnQkFBUWMsT0FBUixDQUFnQnlULENBQWhCLElBQXFCalQsU0FBU3lLLElBQVQsRUFBZStELFdBQXBDO0FBQ0g7QUFDRCxTQUFLLElBQUl5RSxNQUFJLENBQWIsRUFBZ0JBLE1BQUk5UyxNQUFNaUcsTUFBMUIsRUFBa0M2TSxLQUFsQyxFQUF1QztBQUFFO0FBQ3JDO0FBQ0EsWUFBSWdJLFNBQVM5YSxNQUFNOFMsR0FBTixFQUFTUSxJQUFULElBQWlCLEtBQWpCLEdBQ1QsQ0FBQ3RULE1BQU04UyxHQUFOLEVBQVNPLE1BQVQsQ0FBZ0J6SixJQUFqQixFQUF1QjVKLE1BQU04UyxHQUFOLEVBQVMxSSxNQUFULENBQWdCUixJQUF2QyxDQURTLEdBRVQsQ0FBQzVKLE1BQU04UyxHQUFOLEVBQVMxSSxNQUFULENBQWdCUixJQUFqQixFQUF1QjVKLE1BQU04UyxHQUFOLEVBQVNPLE1BQVQsQ0FBZ0J6SixJQUF2QyxDQUZKO0FBR0FyTCxnQkFBUUUsTUFBUixDQUFlZ04sSUFBZixDQUFvQnFQLE1BQXBCO0FBQ0g7QUFDSjs7QUFFTSxTQUFTNWdCLFFBQVQsQ0FBa0JnVCxHQUFsQixFQUF1QjtBQUMxQixRQUFHLENBQUNuRSxRQUFKLEVBQWE7QUFBQSxZQXVCSmdTLGVBdkJJLEdBdUJiLFNBQVNBLGVBQVQsQ0FBeUI3TixHQUF6QixFQUE4QmhELElBQTlCLEVBQW9DO0FBQ2xDO0FBQ0UvRiwwQkFBYzZXLElBQWQsR0FGZ0MsQ0FFVjtBQUN0QmxiLHVCQUFXMkwsSUFBWCxDQUFnQnZCLElBQWhCO0FBQ0E3TyxnQkFBSSxXQUFKLEVBQWlCNk8sSUFBakI7O0FBRUEsZ0JBQUksQ0FBQ2hLLFNBQUwsRUFBZ0IwRSxLQUFLLFNBQUwsRUFBZ0JxVyxXQUFoQixDQUE0QnJXLEtBQUssZUFBTCxDQUE1Qjs7QUFFaEIxRSx3QkFBWSxJQUFaO0FBQ0FwRSxlQUFHK0osTUFBSCxDQUFVLFVBQVYsRUFDS0UsS0FETCxDQUNXLFNBRFgsRUFDc0IsT0FEdEI7O0FBR0FqSyxlQUFHK0osTUFBSCxDQUFVLGNBQVYsRUFDS0UsS0FETCxDQUNXLFNBRFgsRUFDc0IsT0FEdEI7O0FBR0FqSyxlQUFHK0osTUFBSCxDQUFVLFlBQVYsRUFDS0UsS0FETCxDQUNXLFNBRFgsRUFDc0IsT0FEdEI7O0FBSUE7QUFDQUcsY0FBRSxhQUFGLEVBQWlCZ1YsT0FBakIsQ0FBeUIsT0FBekI7O0FBRUEsZ0JBQUlDLFFBQVEsUUFBUWpLLE1BQVIsQ0FBZXZSLGFBQWFBLGFBQWEsQ0FBekMsQ0FBWjs7QUFFQSxxQkFBU3liLE1BQVQsR0FBa0I7QUFDZHRmLG1CQUFHK0osTUFBSCxDQUFVLFlBQVYsRUFDS2tDLFNBREwsQ0FDZSxHQURmLEVBRUtoQyxLQUZMLENBRVcsa0JBRlgsRUFFK0JrTixVQUFVeFcsUUFBVixDQUYvQjtBQUdIO0FBQ0QyZTs7QUFFQXRmLGVBQUcrSixNQUFILENBQVUsWUFBVixFQUNLd1YsTUFETCxDQUNZLEdBRFosRUFDaUIsY0FEakIsRUFDaUM7QUFEakMsYUFFSzFMLElBRkwsQ0FFVSxJQUZWLEVBRWdCd0wsS0FGaEIsRUFHS2hULElBSEwsQ0FHVWdULEtBSFYsRUFJS3BWLEtBSkwsQ0FJVyxrQkFKWCxFQUkrQmtOLDZCQUovQixFQUtLbkwsRUFMTCxDQUtRLE9BTFIsRUFLaUIsWUFBVztBQUNwQixvQkFBSXdULElBQUksS0FBS3ZWLEtBQUwsQ0FBVzhMLGVBQVgsQ0FBMkJsSSxPQUEzQixDQUFtQyxNQUFuQyxFQUEyQyxFQUEzQyxDQUFSO0FBQ0Esb0JBQUk0UixJQUFJdEksOEJBQXVCdEosT0FBdkIsQ0FBK0IsTUFBL0IsRUFBdUMsRUFBdkMsQ0FBUjtBQUNBLG9CQUFJMlIsRUFBRUUsTUFBRixDQUFTLENBQVQsRUFBWSxFQUFaLEtBQW1CRCxFQUFFQyxNQUFGLENBQVMsQ0FBVCxFQUFZLEVBQVosQ0FBdkIsRUFDSSxPQUpnQixDQUlSO0FBQ1pKO0FBQ0F0ZixtQkFBRytKLE1BQUgsQ0FBVSxJQUFWLEVBQ0tFLEtBREwsQ0FDVyxrQkFEWCxFQUMrQmtOLDZCQUQvQjtBQUVBd0ksb0JBQUksS0FBSzFXLEVBQVQ7QUFDSCxhQWRMOztBQWdCQSxnQkFBSTJXLFFBQVEsRUFBWjtBQUNBQSxrQkFBTSxDQUFOLElBQVd4UixLQUFLK04sSUFBaEI7QUFDQTBELG9CQUFRLFVBQVIsRUFBb0JELEtBQXBCOztBQUVBRCxnQkFBSU4sS0FBSjtBQUNILFNBM0VZOztBQUFBLFlBNkVKUyxZQTdFSSxHQTZFYixTQUFTQSxZQUFULENBQXNCMU8sR0FBdEIsRUFBMkI7QUFDdkIvSSwwQkFBYzZXLElBQWQsR0FEdUIsQ0FDRDtBQUN0QjlhLHdCQUFZLElBQVo7QUFDSCxTQWhGWTs7QUFBQSxZQWtGSjJiLGVBbEZJLEdBa0ZiLFNBQVNBLGVBQVQsQ0FBeUIzTyxHQUF6QixFQUE4QmhELElBQTlCLEVBQW9DO0FBQ2hDcE8sZUFBRytKLE1BQUgsQ0FBVSxTQUFWLEVBQ0tzQyxJQURMLENBQ1UsMERBQTBEK0IsS0FBS3VELElBRHpFO0FBRUFwUyxnQkFBSSxtQkFBSixFQUF5QjZPLElBQXpCO0FBQ0gsU0F0Rlk7O0FBQUEsWUF3Rko0UixZQXhGSSxHQXdGYixTQUFTQSxZQUFULENBQXNCNU8sR0FBdEIsRUFBMkI7QUFDdkJ6SCxrQkFBTSxlQUFOO0FBQ0gsU0ExRlk7O0FBQ2IsWUFBSW5LLGNBQWNpRCxRQUFRa0IsVUFBUixJQUFzQixFQUF4QyxFQUE0QztBQUN4Q2dHLGtCQUFNLHlEQUFOO0FBQ0E7QUFDSDs7QUFFRDJKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E3USxnQkFBUThCLFdBQVIsR0FBc0JBLFdBQXRCO0FBQ0EsWUFBSWlNLFVBQVUvQyxLQUFLRSxTQUFMLENBQWVsTCxPQUFmLENBQWQ7O0FBRUEsWUFBSWdPLFVBQVV3UCxVQUFVLFVBQXhCLENBYmEsQ0FhdUI7QUFDcEMsWUFBSXRQLGNBQWMsY0FBY0gsT0FBaEM7QUFDQWpSLFlBQUksZUFBSixFQUFxQmtSLE9BQXJCO0FBQ0FsUixZQUFJLFlBQUosRUFBa0JvUixXQUFsQjtBQUNBbFIsZ0JBQVFDLEdBQVIsQ0FBWSxZQUFaLEVBQTBCaVIsV0FBMUI7O0FBRUFsTyxnQkFBUXlkLE9BQVIsR0FBa0JwYyxTQUFTb1IsS0FBVCxDQUFlLEVBQWYsRUFBbUIsRUFBbkIsQ0FBbEIsQ0FuQmEsQ0FtQjZCO0FBQzFDMUUsa0JBQVUvQyxLQUFLRSxTQUFMLENBQWVsTCxPQUFmLENBQVY7QUFDQSxZQUFJMGQsa0JBQWtCRixVQUFVLGFBQWhDOztBQXVFQTVYLHNCQUFjNkMsS0FBZCxHQTVGYSxDQTRGVTtBQUN2QnVHLHdCQUFnQmhCLE9BQWhCLEVBQXlCVyxHQUF6QixFQUE4QjZOLGVBQTlCLEVBQStDYSxZQUEvQyxFQUE2RG5QLFdBQTdEO0FBQ0MsS0E5RkQsTUE4Rk8sSUFBSXJPLFFBQUosRUFBYztBQUFBLFlBaUNKOGQsbUJBakNJLEdBaUNiLFNBQVNBLG1CQUFULENBQTZCaFAsR0FBN0IsRUFBa0NpUCxvQkFBbEMsRUFBd0Q7QUFDaEQ7QUFDSjVnQixvQkFBUUMsR0FBUixDQUFZMmdCLG9CQUFaO0FBQ0FoWSwwQkFBYzZXLElBQWQsR0FIb0QsQ0FHOUI7OztBQUd0QjlVLGNBQUUsY0FBRixFQUFrQmtXLFdBQWxCLENBQThCLGFBQTlCO0FBQ0FsVyxjQUFFLGNBQUYsRUFBa0JtVyxRQUFsQixDQUEyQixhQUEzQjtBQUNBblcsY0FBRSxnQkFBRixFQUFvQmtXLFdBQXBCLENBQWdDLGFBQWhDO0FBQ0FsVyxjQUFFLGdCQUFGLEVBQW9CbVcsUUFBcEIsQ0FBNkIsYUFBN0I7O0FBS0EsZ0JBQUlDLGtCQUFrQixFQUF0QjtBQUNBLGlCQUFLLElBQUk5USxJQUFJLENBQWIsRUFBZ0JBLElBQUUyUSxxQkFBcUJsVyxNQUF2QyxFQUErQ3VGLEdBQS9DLEVBQW9EO0FBQ2hELG9CQUFHMlEscUJBQXFCM1EsQ0FBckIsRUFBd0IrUSxVQUF4QixJQUFzQ0QsZUFBekMsRUFBMEQ7QUFDdERBLG9DQUFnQkgscUJBQXFCM1EsQ0FBckIsRUFBd0IrUSxVQUF4QyxJQUFvRDdPLE9BQU91QixNQUFQLENBQWNxTixnQkFBZ0JILHFCQUFxQjNRLENBQXJCLEVBQXdCK1EsVUFBeEMsQ0FBZCxFQUFrRUoscUJBQXFCM1EsQ0FBckIsQ0FBbEUsQ0FBcEQ7QUFDSCxpQkFGRCxNQUVPO0FBQ0g4USxvQ0FBZ0JILHFCQUFxQjNRLENBQXJCLEVBQXdCK1EsVUFBeEMsSUFBb0RKLHFCQUFxQjNRLENBQXJCLENBQXBEO0FBQ0g7QUFDSjtBQUNEalEsb0JBQVFDLEdBQVIsQ0FBWThnQixlQUFaO0FBQ0k7O0FBRUE7O0FBRUEscUJBQVNFLFFBQVQsQ0FBa0J4VSxJQUFsQixFQUF3QnlVLE9BQXhCLEVBQWlDQyxLQUFqQyxFQUF3QztBQUNwQyxvQkFBSUMsUUFBUTdnQixHQUFHK0osTUFBSCxDQUFVNlcsS0FBVixFQUFpQnhVLE1BQWpCLENBQXdCLE9BQXhCLENBQVo7QUFDQSxvQkFBSTBVLFFBQVFELE1BQU16VSxNQUFOLENBQWEsT0FBYixDQUFaO0FBQ0Esb0JBQUkyVSxRQUFRRixNQUFNelUsTUFBTixDQUFhLE9BQWIsQ0FBWjs7QUFFQTtBQUNBMFUsc0JBQU0xVSxNQUFOLENBQWEsSUFBYixFQUNDSCxTQURELENBQ1csSUFEWCxFQUVDQyxJQUZELENBRU15VSxPQUZOLEVBRWV4VSxLQUZmLEdBR0NDLE1BSEQsQ0FHUSxJQUhSLEVBSUNDLElBSkQsQ0FJTSxVQUFVMlUsTUFBVixFQUFrQjtBQUFFLDJCQUFPQSxNQUFQO0FBQWdCLGlCQUoxQzs7QUFNQTtBQUNBLG9CQUFJQyxPQUFPRixNQUFNOVUsU0FBTixDQUFnQixJQUFoQixFQUNWQyxJQURVLENBQ0xBLElBREssRUFFVkMsS0FGVSxHQUdWQyxNQUhVLENBR0gsSUFIRyxFQUlWeUgsSUFKVSxDQUlMLE9BSkssRUFJRyxVQUFTdkgsQ0FBVCxFQUFXb0QsQ0FBWCxFQUFjO0FBQ3RCLHdCQUFHQSxLQUFHLENBQU4sRUFBUyxPQUFPLGFBQVAsQ0FBVCxLQUNLLE9BQU8sY0FBUDtBQUNKLGlCQVBJLENBQVg7O0FBU0E7QUFDQSxvQkFBSXdSLFFBQVFELEtBQUtoVixTQUFMLENBQWUsSUFBZixFQUNYQyxJQURXLENBQ04sVUFBVWlWLEdBQVYsRUFBZTtBQUNmLDJCQUFPUixRQUFReEgsR0FBUixDQUFZLFVBQVU2SCxNQUFWLEVBQWtCO0FBQ2xCLCtCQUFPLEVBQUNBLFFBQVFBLE1BQVQsRUFBaUJJLE9BQU9ELElBQUlILE1BQUosQ0FBeEIsRUFBUDtBQUNDLHFCQUZiLENBQVA7QUFHQyxpQkFMSyxFQU1YN1UsS0FOVyxHQU9YQyxNQVBXLENBT0osSUFQSSxFQVFYQyxJQVJXLENBUU4sVUFBVUMsQ0FBVixFQUFhO0FBQ2YsMkJBQU9BLEVBQUU4VSxLQUFUO0FBQ0csaUJBVkssRUFXWHBWLEVBWFcsQ0FXUixPQVhRLEVBV0MsVUFBU00sQ0FBVCxFQUFZO0FBQ3JCLHdCQUFJK1UsUUFBUSxLQUFLQyxhQUFqQjtBQUNBLHdCQUFHRCxNQUFNckYsU0FBTixJQUFpQixhQUFwQixFQUFtQztBQUMvQjtBQUNILHFCQUZELE1BRU87QUFDSGhjLDJCQUFHK0osTUFBSCxDQUFVNlcsS0FBVixFQUFpQjdXLE1BQWpCLENBQXdCLGdCQUF4QixFQUNDOEosSUFERCxDQUNNLE9BRE4sRUFDZSxjQURmO0FBRUE3VCwyQkFBRytKLE1BQUgsQ0FBVXNYLEtBQVYsRUFBaUJ4TixJQUFqQixDQUFzQixPQUF0QixFQUE4QixhQUE5QjtBQUNBLDRCQUFHK00sU0FBTyxZQUFWLEVBQXdCO0FBQ3BCNWhCLDRDQUFnQndoQixnQkFBZ0JhLE1BQU1FLFVBQU4sQ0FBaUJDLFNBQWpDLENBQWhCLEVBQTZEQyxRQUE3RDtBQUNIO0FBQ0o7QUFBQyxpQkF0Qk0sQ0FBWjs7QUF3QkE7QUFDQTs7Ozs7OztBQU9BLHVCQUFPWixLQUFQO0FBQ0g7O0FBRUQsZ0JBQUlhLGVBQWUsRUFBbkI7QUFDQSxpQkFBSSxJQUFJMVIsR0FBUixJQUFld1EsZUFBZixFQUFnQztBQUM1QixvQkFBSW1CLE9BQU8sRUFBWDtBQUNBLG9CQUFJQyxXQUFXLEVBQWY7QUFDQSxvQkFBSUMsUUFBUSxFQUFaO0FBQ0Esb0JBQUlDLFdBQVd0QixnQkFBZ0J4USxHQUFoQixFQUFxQitSLFlBQXJCLENBQWtDQyxNQUFqRDtBQUNBLHFCQUFJLElBQUl0UyxJQUFJLENBQVosRUFBZUEsSUFBSW9TLFNBQVMzWCxNQUE1QixFQUFvQ3VGLEdBQXBDLEVBQXlDO0FBQ3JDO0FBQ0M7QUFDRGlTLDJCQUFLM1IsR0FBTDtBQUNBNFIsK0JBQVNFLFNBQVNwUyxDQUFULEVBQVkzSCxNQUFyQjtBQUNBOFosNEJBQU0sQ0FBQ0MsU0FBU3BTLENBQVQsRUFBWTBSLEtBQVosQ0FBa0JhLE9BQWxCLENBQTBCLENBQTFCLENBQVA7QUFDQVAsaUNBQWEvUixJQUFiLENBQWtCLEVBQUMsY0FBYWdTLElBQWQsRUFBbUIsVUFBU0MsUUFBNUIsRUFBc0MsU0FBUUMsS0FBOUMsRUFBbEI7QUFDSDtBQUNKOztBQUVEO0FBQ0FuQixxQkFBU2dCLFlBQVQsRUFBdUIsQ0FBQyxZQUFELEVBQWUsUUFBZixFQUF5QixPQUF6QixDQUF2QixFQUEwRCxVQUExRDtBQUNBOztBQUVBaE0sK0JBQW1CLEtBQW5CO0FBQ0EzTSxxQkFBU0MsY0FBVCxDQUF3QixZQUF4QixFQUFzQ29HLEtBQXRDOztBQUVBO0FBQ0EvUCwyQkFBZXFpQixhQUFhLENBQWIsRUFBZ0JRLFVBQS9COztBQUdBO0FBQ0E7O0FBRUE7QUFDQXJqQjs7QUFFQTtBQUNBLGdCQUFJc2pCLGVBQWV2USxPQUFPQyxJQUFQLENBQVkyTyxlQUFaLENBQW5CO0FBQ0EsZ0JBQUk0QixnQ0FBZ0MsRUFBQzlRLGdCQUFELEVBQVU2USwwQkFBVixFQUFwQztBQUNBM1IsdUJBQVUvQyxLQUFLRSxTQUFMLENBQWV5VSw2QkFBZixDQUFWO0FBQ0EsZ0JBQUkzUixVQUFVQyxTQUFTLDRCQUF2QjtBQUNBLGdCQUFJQyxjQUFjLGlCQUFpQkgsUUFBbkM7QUFDQS9RLG9CQUFRQyxHQUFSLENBQVksNkJBQVo7QUFDQUQsb0JBQVFDLEdBQVIsQ0FBWWlSLFdBQVo7QUFDQWxSLG9CQUFRQyxHQUFSLENBQVkrUSxPQUFaOztBQUVBLHFCQUFTNFIscUJBQVQsQ0FBK0JqUixHQUEvQixFQUFvQ2tSLHFCQUFwQyxFQUEyRDtBQUN2RDdpQix3QkFBUUMsR0FBUixDQUFZNGlCLHFCQUFaO0FBQ0E7QUFDQTtBQUNIO0FBQ0QscUJBQVNDLGtCQUFULENBQTZCblIsR0FBN0IsRUFBa0M7QUFDOUIzUix3QkFBUUMsR0FBUixDQUFZLGtDQUFaO0FBQ0g7QUFDRCtSLDRCQUFnQmhCLE9BQWhCLEVBQXlCLFVBQXpCLEVBQXFDNFIscUJBQXJDLEVBQTRERSxrQkFBNUQsRUFBZ0Y1UixXQUFoRjtBQUNILFNBMUtROztBQUFBLFlBNEtBNlIsZ0JBNUtBLEdBNEtULFNBQVNBLGdCQUFULENBQTBCcFIsR0FBMUIsRUFBK0I7QUFDM0IzUixvQkFBUUMsR0FBUixDQUFZLDJCQUFaO0FBQ0gsU0E5S1E7O0FBQUU7QUFDZjRUO0FBQ0E3USxnQkFBUThCLFdBQVIsR0FBc0JBLFdBQXRCO0FBQ0EsWUFBSWlNLFdBQVUvQyxLQUFLRSxTQUFMLENBQWVsTCxPQUFmLENBQWQ7QUFDQWhELGdCQUFRQyxHQUFSLENBQVk4USxRQUFaOztBQUVBLFlBQUlpUyxRQUFRM2UsU0FBU3VMLE9BQVQsQ0FBaUI3SyxRQUFqQixDQUFaO0FBQ0EsWUFBR2llLFNBQVMsQ0FBQyxDQUFiLEVBQWdCO0FBQ1ozZSxxQkFBU2tTLE1BQVQsQ0FBZ0J5TSxLQUFoQixFQUF1QixDQUF2QjtBQUNIOztBQUVELFlBQUluUixVQUFVb1IsV0FBV2pnQixRQUFRa0IsVUFBbkIsQ0FBZDtBQUNBLFlBQUlnZixNQUFNLEVBQUNDLFVBQVVuZ0IsUUFBUVksUUFBbkIsRUFBNkJpTCxRQUFPN0wsUUFBUWEsVUFBNUMsRUFBVjs7QUFFQSxZQUFJdWYsZ0JBQWNDLG9CQUFvQmhmLFFBQXBCLEVBQTZCNmUsSUFBSUMsUUFBakMsQ0FBbEIsQ0FkYSxDQWN1RDtBQUNwRSxZQUFJRyxpQkFBZUQsb0JBQW9CdGUsUUFBcEIsRUFBNkJtZSxJQUFJclUsTUFBakMsQ0FBbkIsQ0FmYSxDQWV1RDs7QUFFcEUsWUFBSTBVLE9BQU9wZCxZQUFZK0Isc0JBQXNCQyxRQUFsQyxFQUE0QyxDQUE1QyxDQUFYO0FBQ0EsWUFBSUMsY0FBY3RCLGVBQWVvQixzQkFBc0JFLFdBQXJDLEVBQWtELENBQWxELENBQWxCO0FBQ0EsWUFBSW9iLFNBQVNoYyxjQUFjVSxzQkFBc0JHLFVBQXBDLEVBQWdELENBQWhELENBQWI7QUFDQSxZQUFJb2IsVUFBVSxDQUFDdmUsV0FBV2dELHNCQUFzQkksTUFBakMsRUFBeUMsQ0FBekMsQ0FBRCxDQUFkO0FBQ0EsWUFBSUMsa0JBQWtCTCxzQkFBc0J3YixzQkFBNUM7QUFDQSxZQUFJQyxlQUFlLENBQW5CLENBdEJhLENBc0JTOztBQUV0QixZQUFJQyx3QkFBc0IsRUFBQy9SLGdCQUFELEVBQVV1Uiw0QkFBVixFQUF5QkcsVUFBekIsRUFBK0JuYix3QkFBL0IsRUFBNENHLGdDQUE1QyxFQUE2RGliLGNBQTdELEVBQXFFQyxnQkFBckUsRUFBOEVILDhCQUE5RSxFQUE4RkssMEJBQTlGLEVBQTFCOztBQUVBLFlBQUk1UyxXQUFVL0MsS0FBS0UsU0FBTCxDQUFlMFYscUJBQWYsQ0FBZDs7QUFFQSxZQUFJNVMsV0FBVUMsU0FBUyxpQkFBdkI7QUFDQSxZQUFJQyxjQUFjLGlCQUFpQkgsUUFBbkM7O0FBRUEvUSxnQkFBUUMsR0FBUixDQUFZK1EsUUFBWjtBQUNBaFIsZ0JBQVFDLEdBQVIsQ0FBWWlSLFdBQVo7OztBQWdKSXRJLHNCQUFjNkMsS0FBZCxHQWhMUyxDQWdMYztBQUN2QnVHLHdCQUFnQmhCLFFBQWhCLEVBQXlCLFVBQXpCLEVBQXFDMlAsbUJBQXJDLEVBQTBEb0MsZ0JBQTFELEVBQTRFN1IsV0FBNUU7QUFFWCxLQW5MTSxNQW1MRDtBQUFBLFlBaUJXMlMscUJBakJYLEdBaUJFLFNBQVNBLHFCQUFULENBQStCbFMsR0FBL0IsRUFBb0NoRCxJQUFwQyxFQUEwQztBQUN0Qy9GLDBCQUFjNlcsSUFBZCxHQURzQyxDQUNoQjs7QUFFdEI5VSxjQUFFLGNBQUYsRUFBa0JrVyxXQUFsQixDQUE4QixhQUE5QjtBQUNBbFcsY0FBRSxjQUFGLEVBQWtCbVcsUUFBbEIsQ0FBMkIsYUFBM0I7QUFDQW5XLGNBQUUsZ0JBQUYsRUFBb0JrVyxXQUFwQixDQUFnQyxhQUFoQztBQUNBbFcsY0FBRSxnQkFBRixFQUFvQm1XLFFBQXBCLENBQTZCLGFBQTdCOztBQUVBLGdCQUFJc0MsZ0JBQWNDLG9CQUFvQjFVLEtBQUttVixVQUF6QixFQUFvQ1osS0FBSUMsUUFBeEMsQ0FBbEIsQ0FSc0MsQ0FRa0M7QUFDeEUsZ0JBQUlHLGlCQUFlRCxvQkFBb0IxVSxLQUFLb1YsTUFBekIsRUFBZ0NiLEtBQUlyVSxNQUFwQyxDQUFuQixDQVRzQyxDQVNrQztBQUN4RSxnQkFBSTBVLE9BQU9wZCxZQUFZK0Isc0JBQXNCQyxRQUFsQyxFQUE0QyxDQUE1QyxDQUFYO0FBQ0EsZ0JBQUlDLGNBQWN0QixlQUFlb0Isc0JBQXNCRSxXQUFyQyxFQUFrRCxDQUFsRCxDQUFsQjtBQUNBLGdCQUFJb2IsU0FBU2hjLGNBQWNVLHNCQUFzQkcsVUFBcEMsRUFBZ0QsQ0FBaEQsQ0FBYjtBQUNBLGdCQUFJb2IsVUFBVSxDQUFDdmUsV0FBV2dELHNCQUFzQkksTUFBakMsRUFBeUMsQ0FBekMsQ0FBRCxDQUFkO0FBQ0EsZ0JBQUlDLGtCQUFrQkwsc0JBQXNCd2Isc0JBQTVDO0FBQ0EsZ0JBQUlDLGVBQWUsQ0FBbkIsQ0Fmc0MsQ0FlaEI7O0FBRXRCaGtCLHNCQUFVZ1AsS0FBS21WLFVBQWY7QUFDQSxnQkFBSTlCLFdBQVdyVCxLQUFLcVQsUUFBcEI7O0FBR0EsZ0JBQUk0Qix3QkFBc0IsRUFBQy9SLGlCQUFELEVBQVV1Uiw0QkFBVixFQUF5QkcsVUFBekIsRUFBK0JuYix3QkFBL0IsRUFBNENHLGdDQUE1QyxFQUE2RGliLGNBQTdELEVBQXFFQyxnQkFBckUsRUFBOEVILDhCQUE5RSxFQUE4RkssMEJBQTlGLEVBQTFCOztBQUVBLGdCQUFJNVMsVUFBVS9DLEtBQUtFLFNBQUwsQ0FBZTBWLHFCQUFmLENBQWQ7O0FBRUEsZ0JBQUk1UyxVQUFVQyxTQUFTLGlCQUF2QjtBQUNBLGdCQUFJQyxjQUFjLGlCQUFpQkgsT0FBbkM7O0FBRUEvUSxvQkFBUUMsR0FBUixDQUFZK1EsT0FBWjtBQUNBaFIsb0JBQVFDLEdBQVIsQ0FBWWlSLFdBQVo7QUFDQSxxQkFBU3lQLG1CQUFULENBQTZCaFAsR0FBN0IsRUFBa0NpUCxvQkFBbEMsRUFBd0Q7QUFDcEQ7QUFDQTVnQix3QkFBUUMsR0FBUixDQUFZMmdCLG9CQUFaOztBQUdBLG9CQUFJRyxrQkFBa0IsRUFBdEI7QUFDQSxxQkFBSyxJQUFJOVEsSUFBSSxDQUFiLEVBQWdCQSxJQUFFMlEscUJBQXFCbFcsTUFBdkMsRUFBK0N1RixHQUEvQyxFQUFvRDtBQUNoRCx3QkFBRzJRLHFCQUFxQjNRLENBQXJCLEVBQXdCK1EsVUFBeEIsSUFBc0NELGVBQXpDLEVBQTBEO0FBQ3REQSx3Q0FBZ0JILHFCQUFxQjNRLENBQXJCLEVBQXdCK1EsVUFBeEMsSUFBb0Q3TyxPQUFPdUIsTUFBUCxDQUFjcU4sZ0JBQWdCSCxxQkFBcUIzUSxDQUFyQixFQUF3QitRLFVBQXhDLENBQWQsRUFBa0VKLHFCQUFxQjNRLENBQXJCLENBQWxFLENBQXBEO0FBQ0gscUJBRkQsTUFFTztBQUNIOFEsd0NBQWdCSCxxQkFBcUIzUSxDQUFyQixFQUF3QitRLFVBQXhDLElBQW9ESixxQkFBcUIzUSxDQUFyQixDQUFwRDtBQUNIO0FBQ0o7QUFDRGpRLHdCQUFRQyxHQUFSLENBQVk4Z0IsZUFBWjtBQUNBOztBQUVBOztBQUVBLHlCQUFTRSxRQUFULENBQWtCeFUsSUFBbEIsRUFBd0J5VSxPQUF4QixFQUFpQ0MsS0FBakMsRUFBd0M7QUFDcEMsd0JBQUlDLFFBQVE3Z0IsR0FBRytKLE1BQUgsQ0FBVTZXLEtBQVYsRUFBaUJ4VSxNQUFqQixDQUF3QixPQUF4QixDQUFaO0FBQ0Esd0JBQUkwVSxRQUFRRCxNQUFNelUsTUFBTixDQUFhLE9BQWIsQ0FBWjtBQUNBLHdCQUFJMlUsUUFBUUYsTUFBTXpVLE1BQU4sQ0FBYSxPQUFiLENBQVo7O0FBRUE7QUFDQTBVLDBCQUFNMVUsTUFBTixDQUFhLElBQWIsRUFDQ0gsU0FERCxDQUNXLElBRFgsRUFFQ0MsSUFGRCxDQUVNeVUsT0FGTixFQUVleFUsS0FGZixHQUdDQyxNQUhELENBR1EsSUFIUixFQUlDQyxJQUpELENBSU0sVUFBVTJVLE1BQVYsRUFBa0I7QUFBRSwrQkFBT0EsTUFBUDtBQUFnQixxQkFKMUM7O0FBTUE7QUFDQSx3QkFBSUMsT0FBT0YsTUFBTTlVLFNBQU4sQ0FBZ0IsSUFBaEIsRUFDVkMsSUFEVSxDQUNMQSxJQURLLEVBRVZDLEtBRlUsR0FHVkMsTUFIVSxDQUdILElBSEcsRUFJVnlILElBSlUsQ0FJTCxPQUpLLEVBSUcsVUFBU3ZILENBQVQsRUFBV29ELENBQVgsRUFBYztBQUN0Qiw0QkFBR0EsS0FBRyxDQUFOLEVBQVMsT0FBTyxhQUFQLENBQVQsS0FDSyxPQUFPLGNBQVA7QUFDSixxQkFQSSxDQUFYOztBQVNBO0FBQ0Esd0JBQUl3UixRQUFRRCxLQUFLaFYsU0FBTCxDQUFlLElBQWYsRUFDWEMsSUFEVyxDQUNOLFVBQVVpVixHQUFWLEVBQWU7QUFDZiwrQkFBT1IsUUFBUXhILEdBQVIsQ0FBWSxVQUFVNkgsTUFBVixFQUFrQjtBQUNsQixtQ0FBTyxFQUFDQSxRQUFRQSxNQUFULEVBQWlCSSxPQUFPRCxJQUFJSCxNQUFKLENBQXhCLEVBQVA7QUFDQyx5QkFGYixDQUFQO0FBR0MscUJBTEssRUFNWDdVLEtBTlcsR0FPWEMsTUFQVyxDQU9KLElBUEksRUFRWEMsSUFSVyxDQVFOLFVBQVVDLENBQVYsRUFBYTtBQUNmLCtCQUFPQSxFQUFFOFUsS0FBVDtBQUNHLHFCQVZLLEVBV1hwVixFQVhXLENBV1IsT0FYUSxFQVdDLFVBQVNNLENBQVQsRUFBWTtBQUNyQiw0QkFBSStVLFFBQVEsS0FBS0MsYUFBakI7QUFDQSw0QkFBR0QsTUFBTXJGLFNBQU4sSUFBaUIsYUFBcEIsRUFBbUM7QUFDL0I7QUFDSCx5QkFGRCxNQUVPO0FBQ0hoYywrQkFBRytKLE1BQUgsQ0FBVTZXLEtBQVYsRUFBaUI3VyxNQUFqQixDQUF3QixnQkFBeEIsRUFDQzhKLElBREQsQ0FDTSxPQUROLEVBQ2UsY0FEZjtBQUVBN1QsK0JBQUcrSixNQUFILENBQVVzWCxLQUFWLEVBQWlCeE4sSUFBakIsQ0FBc0IsT0FBdEIsRUFBOEIsYUFBOUI7QUFDQSxnQ0FBRytNLFNBQU8sWUFBVixFQUF3QjtBQUNwQjVoQixnREFBZ0J3aEIsZ0JBQWdCYSxNQUFNRSxVQUFOLENBQWlCQyxTQUFqQyxDQUFoQixFQUE2REMsUUFBN0Q7QUFDSDtBQUNKO0FBQUMscUJBdEJNLENBQVo7O0FBd0JBO0FBQ0E7Ozs7Ozs7QUFPQSwyQkFBT1osS0FBUDtBQUNIOztBQUVELG9CQUFJYSxlQUFlLEVBQW5CO0FBQ0EscUJBQUksSUFBSTFSLEdBQVIsSUFBZXdRLGVBQWYsRUFBZ0M7QUFDaEM7QUFDSSx3QkFBR0EsZ0JBQWdCeFEsR0FBaEIsRUFBcUJ5VCxZQUFyQixDQUFrQ0MsTUFBbEMsQ0FBeUNDLE9BQXpDLElBQW9ELGlCQUF2RCxFQUEyRTtBQUN2RTtBQUNIO0FBQ0Qsd0JBQUloQyxPQUFPLEVBQVg7QUFDQSx3QkFBSUMsV0FBVyxFQUFmO0FBQ0Esd0JBQUlDLFFBQVEsRUFBWjtBQUNBLHdCQUFJQyxXQUFXdEIsZ0JBQWdCeFEsR0FBaEIsRUFBcUIrUixZQUFyQixDQUFrQ0MsTUFBakQ7QUFDQSx5QkFBSSxJQUFJdFMsSUFBSSxDQUFaLEVBQWVBLElBQUlvUyxTQUFTM1gsTUFBNUIsRUFBb0N1RixHQUFwQyxFQUF5QztBQUNyQztBQUNDO0FBQ0RpUywrQkFBSzNSLEdBQUw7QUFDQTRSLG1DQUFTRSxTQUFTcFMsQ0FBVCxFQUFZM0gsTUFBckI7QUFDQThaLGdDQUFNLENBQUNDLFNBQVNwUyxDQUFULEVBQVkwUixLQUFaLENBQWtCYSxPQUFsQixDQUEwQixDQUExQixDQUFQO0FBQ0FQLHFDQUFhL1IsSUFBYixDQUFrQixFQUFDLGNBQWFnUyxJQUFkLEVBQW1CLFVBQVNDLFFBQTVCLEVBQXNDLFNBQVFDLEtBQTlDLEVBQWxCO0FBQ0g7QUFDSjs7QUFFRDtBQUNBbkIseUJBQVNnQixZQUFULEVBQXVCLENBQUMsWUFBRCxFQUFlLFFBQWYsRUFBeUIsT0FBekIsQ0FBdkIsRUFBMEQsVUFBMUQ7QUFDQWhCLHlCQUFTZ0IsWUFBVCxFQUF1QixDQUFDLFlBQUQsRUFBZSxRQUFmLEVBQXlCLE9BQXpCLENBQXZCLEVBQTBELFlBQTFEO0FBQ0E7O0FBRUFoTSxtQ0FBbUIsS0FBbkI7QUFDQTNNLHlCQUFTQyxjQUFULENBQXdCLFlBQXhCLEVBQXNDb0csS0FBdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EvUCwrQkFBZXFpQixhQUFhLENBQWIsRUFBZ0JRLFVBQS9COztBQUdBO0FBQ0E7O0FBRUE7QUFDQXJqQjs7QUFFQTtBQUNBLG9CQUFJc2pCLGVBQWV2USxPQUFPQyxJQUFQLENBQVkyTyxlQUFaLENBQW5CO0FBQ0Esb0JBQUk0QixnQ0FBZ0MsRUFBQzlRLGlCQUFELEVBQVU2USwwQkFBVixFQUFwQztBQUNBM1IsMEJBQVUvQyxLQUFLRSxTQUFMLENBQWV5VSw2QkFBZixDQUFWO0FBQ0Esb0JBQUkzUixVQUFVQyxTQUFTLDRCQUF2QjtBQUNBLG9CQUFJQyxjQUFjLGlCQUFpQkgsT0FBbkM7QUFDQS9RLHdCQUFRQyxHQUFSLENBQVksNkJBQVo7QUFDQUQsd0JBQVFDLEdBQVIsQ0FBWWlSLFdBQVo7QUFDQWxSLHdCQUFRQyxHQUFSLENBQVkrUSxPQUFaOztBQUVBLHlCQUFTNFIscUJBQVQsQ0FBK0JqUixHQUEvQixFQUFvQ2tSLHFCQUFwQyxFQUEyRDtBQUN2RDdpQiw0QkFBUUMsR0FBUixDQUFZNGlCLHFCQUFaO0FBQ0E7QUFDQTtBQUNIO0FBQ0QseUJBQVNDLGtCQUFULENBQTZCblIsR0FBN0IsRUFBa0M7QUFDOUIzUiw0QkFBUUMsR0FBUixDQUFZLGtDQUFaO0FBQ0g7QUFDRCtSLGdDQUFnQmhCLE9BQWhCLEVBQXlCLFVBQXpCLEVBQXFDNFIscUJBQXJDLEVBQTRERSxrQkFBNUQsRUFBZ0Y1UixXQUFoRjtBQUNIOztBQUVELHFCQUFTNlIsZ0JBQVQsQ0FBMEJwUixHQUExQixFQUErQjtBQUMzQjNSLHdCQUFRQyxHQUFSLENBQVksMkJBQVo7QUFDSDs7QUFFRCtSLDRCQUFnQmhCLE9BQWhCLEVBQXlCLFVBQXpCLEVBQXFDMlAsbUJBQXJDLEVBQTBEb0MsZ0JBQTFELEVBQTRFN1IsV0FBNUU7QUFDSCxTQTdMSDs7QUFBQSxZQStMV2lULGtCQS9MWCxHQStMRSxTQUFTQSxrQkFBVCxDQUE0QnhTLEdBQTVCLEVBQWlDO0FBQzdCL0ksMEJBQWM2VyxJQUFkLEdBRDZCLENBQ1A7QUFDdEI5YSx3QkFBWSxJQUFaO0FBQ0gsU0FsTUg7O0FBQUU7QUFDSjtBQUNJa1A7QUFDQTdRLGdCQUFROEIsV0FBUixHQUFzQkEsV0FBdEI7QUFDQSxZQUFJaU0sVUFBVS9DLEtBQUtFLFNBQUwsQ0FBZWxMLE9BQWYsQ0FBZDtBQUNBaEQsZ0JBQVFDLEdBQVIsQ0FBWThRLE9BQVo7O0FBRUEsWUFBSWMsV0FBVW9SLFdBQVdqZ0IsUUFBUWtCLFVBQW5CLENBQWQ7QUFDQSxZQUFJZ2YsT0FBTSxFQUFDQyxVQUFVbmdCLFFBQVFZLFFBQW5CLEVBQTZCaUwsUUFBTzdMLFFBQVFhLFVBQTVDLEVBQVY7O0FBR0EsWUFBSW1OLFVBQVV3UCxVQUFVLGFBQXhCOztBQUVBLFlBQUl0UCxjQUFjLGNBQWNILE9BQWhDO0FBQ0FqUixZQUFJLGVBQUosRUFBcUJrUixPQUFyQjtBQUNBbFIsWUFBSSxZQUFKLEVBQWtCb1IsV0FBbEI7O0FBcUxBdEksc0JBQWM2QyxLQUFkLEdBcE1GLENBb015QjtBQUN2QnVHLHdCQUFnQmhCLE9BQWhCLEVBQXlCVyxHQUF6QixFQUE4QmtTLHFCQUE5QixFQUFxRE0sa0JBQXJELEVBQXlFalQsV0FBekU7QUFDUDtBQUNKOztBQUVNLFNBQVN0UyxhQUFULENBQXVCd2xCLE9BQXZCLEVBQWdDQyxTQUFoQyxFQUEyQ0MsUUFBM0MsRUFBcUQ7QUFDeEQsUUFBSXpXLE1BQU0yUyxVQUFVLGVBQXBCO0FBQ0F4Z0IsWUFBUUMsR0FBUixDQUFZLGdDQUFaO0FBQ0EsUUFBSTBPLE9BQU9YLEtBQUtFLFNBQUwsQ0FBZSxFQUFDekIsTUFBTTJYLE9BQVAsRUFBZ0J2VixRQUFRd1YsU0FBeEIsRUFBbUNDLFVBQVVBLFFBQTdDLEVBQWYsQ0FBWCxDQUh3RCxDQUcyQjtBQUNuRnRrQixZQUFRQyxHQUFSLENBQVksZUFBWixFQUE2QjROLEdBQTdCO0FBQ0E3TixZQUFRQyxHQUFSLENBQVksWUFBWixFQUEwQjBPLElBQTFCO0FBQ0EsUUFBSWxDLE9BQU8sSUFBSThYLFFBQUosRUFBWDtBQUNBOVgsU0FBS0UsTUFBTCxDQUFZLFVBQVosRUFBd0JnQyxJQUF4QjtBQUNBLFdBQU8sa0JBQUVoQixPQUFGLENBQVUsRUFBQ0MsUUFBUSxNQUFULEVBQWlCQyxLQUFLQSxHQUF0QixFQUEyQnBCLE1BQU1BLElBQWpDLEVBQXVDK1gsT0FBTSxLQUE3QyxFQUFWLEVBQ0YxVyxJQURFLENBQ0csZ0JBQVE7QUFDVjlOLGdCQUFRQyxHQUFSLENBQVksc0JBQVosRUFBb0N3TSxJQUFwQzs7QUFFQTtBQUNBN0osZUFBTzZKLEtBQUtnWSxPQUFMLENBQWFDLE9BQWIsSUFBd0I5aEIsSUFBL0I7QUFDQXVQLGVBQU9DLElBQVAsQ0FBWTNGLEtBQUt1UyxTQUFqQixFQUE0QnRJLE9BQTVCLENBQW9DO0FBQUEsbUJBQUszVSxXQUFXNUIsQ0FBWCxJQUFnQnNNLEtBQUt1UyxTQUFMLENBQWU3ZSxDQUFmLENBQXJCO0FBQUEsU0FBcEM7O0FBRUEsZUFBT3NNLElBQVA7QUFDSCxLQVRFLEVBU0EsYUFBSztBQUNKek0sZ0JBQVFDLEdBQVIsQ0FBWSxtQkFBWjtBQUNBaUssY0FBTSx5Q0FBTjtBQUNBL0s7QUFDSCxLQWJFLENBQVA7QUFjSDs7QUFFTSxJQUFJd2xCLDhCQUFXLFNBQVhBLFFBQVc7QUFBQSxXQUFLM2tCLFFBQVFDLEdBQVIsQ0FBWWlJLHFCQUFaLENBQUw7QUFBQSxDQUFmOztBQUVQLFNBQVM0TCxZQUFULEdBQXdCO0FBQ3BCRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFJOUMsVUFBVS9DLEtBQUtFLFNBQUwsQ0FBZWxMLE9BQWYsQ0FBZDtBQUNBLFFBQUkyTyxNQUFNLFVBQVY7O0FBRUEsUUFBSVgsVUFBVXdQLFVBQVUsU0FBeEI7QUFDQSxRQUFJdFAsY0FBYyxjQUFjSCxPQUFoQztBQUNBalIsUUFBSSxlQUFKLEVBQXFCa1IsT0FBckI7QUFDQWxSLFFBQUksWUFBSixFQUFrQm9SLFdBQWxCOztBQUVBLFFBQUkwVCxrQkFBa0IsU0FBbEJBLGVBQWtCLENBQUNqVCxHQUFELEVBQU1oRCxJQUFOLEVBQWU7QUFDakMzTyxnQkFBUUMsR0FBUixDQUFZLGdCQUFaLEVBQThCME8sSUFBOUI7QUFDQTdPLFlBQUksd0JBQUosRUFBOEI2TyxJQUE5QjtBQUNBM0wsZ0JBQVFrQixVQUFSLEdBQXFCeUssS0FBS2tXLFNBQUwsQ0FBZSxDQUFmLENBQXJCO0FBQ0E7QUFDQXhiLGFBQUssT0FBTCxFQUFjeWIsSUFBZCxTQUF3Qi9rQixhQUFheWdCLFVBQVUsY0FBdkIsR0FBd0MsV0FBaEUsSUFBK0V4ZCxRQUFRa0IsVUFBdkY7QUFDSCxLQU5EO0FBT0EsUUFBSTZnQixlQUFlLFNBQWZBLFlBQWU7QUFBQSxlQUFLamxCLElBQUksK0JBQUosQ0FBTDtBQUFBLEtBQW5CO0FBQ0FrUyxvQkFBZ0JoQixPQUFoQixFQUF5QlcsR0FBekIsRUFBOEJpVCxlQUE5QixFQUErQ0csWUFBL0MsRUFBNkQ3VCxXQUE3RDtBQUNIOztBQUVELFNBQVNnUCxHQUFULENBQWE4RSxHQUFiLEVBQWtCO0FBQ2QsUUFBSUEsTUFBTSxDQUFDQSxJQUFJL0UsTUFBSixDQUFXLENBQVgsRUFBYyxDQUFkLENBQUQsR0FBb0IsQ0FBOUI7O0FBRUEsYUFBU2dGLFVBQVQsQ0FBb0JyUCxNQUFwQixFQUE0QjtBQUN4QixlQUFPQSxPQUFPa00sVUFBZDtBQUNJbE0sbUJBQU84SixXQUFQLENBQW1COUosT0FBT2tNLFVBQTFCO0FBREo7QUFFSDs7QUFFRG1ELGVBQVc1YixLQUFLLGFBQUwsQ0FBWDs7QUFFQSxRQUFJc0YsT0FBT3BLLFdBQVd5Z0IsR0FBWCxDQUFYOztBQUVBO0FBQ0EsUUFBSUUsV0FBVyxJQUFJOUwsS0FBSixFQUFmO0FBQ0EsU0FBSyxJQUFJbkosQ0FBVCxJQUFjdEIsS0FBS3dXLE1BQW5CLEVBQTJCO0FBQ3ZCLFlBQUlDLE9BQU85YixTQUFTK2IsYUFBVCxDQUF1QixLQUF2QixDQUFYO0FBQ0FELGFBQUtySCxZQUFMLENBQWtCLEtBQWxCLEVBQXlCcFAsS0FBS3dXLE1BQUwsQ0FBWWxWLENBQVosQ0FBekI7QUFDQW1WLGFBQUtySCxZQUFMLENBQWtCLE9BQWxCLEVBQTJCLEdBQTNCO0FBQ0FxSCxhQUFLckgsWUFBTCxDQUFrQixRQUFsQixFQUE0QixHQUE1QjtBQUNBMVUsYUFBSyxhQUFMLEVBQW9CaWMsV0FBcEIsQ0FBZ0NGLElBQWhDO0FBQ0g7O0FBRUQ7QUFDQSxRQUFJRyxlQUFlLEVBQW5CO0FBQ0EsU0FBSyxJQUFJaFYsR0FBVCxJQUFnQjVCLEtBQUs2VyxPQUFyQixFQUE4QjtBQUMxQixZQUFJalYsT0FBTyxVQUFYLEVBQ0k7QUFDSmdWLHFCQUFhclYsSUFBYixDQUFrQnZCLEtBQUs2VyxPQUFMLENBQWFqVixHQUFiLENBQWxCO0FBQ0g7O0FBRUQsUUFBSTZRLFFBQVE3Z0IsR0FBRytKLE1BQUgsQ0FBVSxjQUFWLEVBQ1BxQyxNQURPLENBQ0EsR0FEQSxFQUVQQSxNQUZPLENBRUEsT0FGQSxDQUFaOztBQUlBLFFBQUkwVSxRQUFRRCxNQUFNelUsTUFBTixDQUFhLE9BQWIsQ0FBWjtBQUNBMFUsVUFBTTFVLE1BQU4sQ0FBYSxJQUFiLEVBQ0tILFNBREwsQ0FDZSxJQURmLEVBRUtDLElBRkwsQ0FFVWtDLEtBQUs2VyxPQUFMLENBQWFDLFFBRnZCLEVBR0svWSxLQUhMLEdBSUtDLE1BSkwsQ0FJWSxJQUpaLEVBS0tDLElBTEwsQ0FLVTtBQUFBLGVBQUtDLENBQUw7QUFBQSxLQUxWOztBQU9BLFFBQUl5VSxRQUFRRixNQUFNelUsTUFBTixDQUFhLE9BQWIsQ0FBWjtBQUNBMlUsVUFBTTlVLFNBQU4sQ0FBZ0IsSUFBaEIsRUFDS0MsSUFETCxDQUNVOFksWUFEVixFQUVLN1ksS0FGTCxHQUVhQyxNQUZiLENBRW9CLElBRnBCLEVBR0tILFNBSEwsQ0FHZSxJQUhmLEVBSUtDLElBSkwsQ0FJVTtBQUFBLGVBQUtJLENBQUw7QUFBQSxLQUpWLEVBS0tILEtBTEwsR0FLYUMsTUFMYixDQUtvQixJQUxwQixFQU1LQyxJQU5MLENBTVUsVUFBU0MsQ0FBVCxFQUFZO0FBQ2QsWUFBSTZZLFFBQVFDLE9BQU85WSxDQUFQLENBQVo7QUFDQSxZQUFJK1ksTUFBTUYsS0FBTixDQUFKLEVBQ0ksT0FBTzdZLENBQVA7QUFDSixlQUFPNlksTUFBTUcsV0FBTixDQUFrQixDQUFsQixDQUFQO0FBQ0gsS0FYTCxFQVlLdFosRUFaTCxDQVlRLFdBWlIsRUFZcUIsWUFBVztBQUN4QmhNLFdBQUcrSixNQUFILENBQVUsSUFBVixFQUFnQkUsS0FBaEIsQ0FBc0Isa0JBQXRCLEVBQTBDLFdBQTFDO0FBQ0gsS0FkTCxFQWNPO0FBZFAsS0FlSytCLEVBZkwsQ0FlUSxVQWZSLEVBZW9CLFlBQVc7QUFDdkJoTSxXQUFHK0osTUFBSCxDQUFVLElBQVYsRUFBZ0JFLEtBQWhCLENBQXNCLGtCQUF0QixFQUEwQyxTQUExQztBQUNILEtBakJMLEVBM0NjLENBNEROOztBQUVSakssT0FBRytKLE1BQUgsQ0FBVSxjQUFWLEVBQ0txQyxNQURMLENBQ1ksR0FEWixFQUVLNkMsSUFGTCxDQUVVO0FBQUEsZUFBTSxtQkFBbUJtRyxNQUFuQixDQUEwQmhILEtBQUsrTixJQUFMLENBQVUsQ0FBVixDQUExQixDQUFOO0FBQUEsS0FGVjs7QUFJQSxzQkFBRXZHLE1BQUY7QUFDSDs7QUFFRDtBQUNBLFNBQVNaLFVBQVQsQ0FBb0JMLENBQXBCLEVBQXVCO0FBQ25CLFFBQUk0USxPQUFPLEVBQVg7QUFDQSxRQUFJQyxLQUFLN1EsQ0FBVDtBQUNBLFFBQUk4USxLQUFLLENBQVQ7QUFDQSxRQUFJQyxTQUFTLFlBQVl0USxNQUFaLENBQW1CcVEsRUFBbkIsQ0FBYjtBQUNBLFFBQUlFLFVBQVUsRUFBZDs7QUFFQTtBQUNBLFNBQUssSUFBSWpXLENBQVQsSUFBYzVMLFFBQWQsRUFBd0I7QUFDcEIsWUFBSThoQixLQUFLalIsRUFBRWtSLEtBQUYsQ0FBUS9oQixTQUFTNEwsQ0FBVCxDQUFSLENBQVQ7QUFDQSxZQUFJa1csTUFBTSxJQUFWLEVBQ0lMLEtBQUs1VixJQUFMLENBQVVpVyxHQUFHLENBQUgsQ0FBVjs7QUFFSixZQUFJRSxLQUFLLElBQUlDLE1BQUosQ0FBV2ppQixTQUFTNEwsQ0FBVCxDQUFYLEVBQXdCLEdBQXhCLENBQVQ7QUFDQSxZQUFJc1csSUFBSXJSLEVBQUVzUixNQUFGLENBQVNILEVBQVQsQ0FBUjtBQUNBLFlBQUlFLEtBQUssQ0FBQyxDQUFWLEVBQ0lMLFFBQVFoVyxJQUFSLENBQWEsRUFBQ3VXLE1BQU1GLENBQVAsRUFBVUcsSUFBSUgsSUFBSWxpQixTQUFTNEwsQ0FBVCxFQUFZdkYsTUFBOUIsRUFBYjtBQUNQOztBQUVEO0FBQ0E7QUFDQTtBQUNBNUssUUFBSSxVQUFKLEVBQWdCb21CLE9BQWhCO0FBQ0EsU0FBSyxJQUFJalcsSUFBSWlXLFFBQVF4YixNQUFSLEdBQWlCLENBQTlCLEVBQWlDdUYsSUFBSSxDQUFDLENBQXRDLEVBQXlDQSxHQUF6QyxFQUE4QztBQUMxQyxhQUFLLElBQUlzSCxJQUFJMk8sUUFBUXhiLE1BQVIsR0FBaUIsQ0FBOUIsRUFBaUM2TSxJQUFJLENBQUMsQ0FBdEMsRUFBeUNBLEdBQXpDLEVBQThDO0FBQzFDLGdCQUFJdEgsTUFBTXNILENBQVYsRUFDSTtBQUNKLGdCQUFLMk8sUUFBUWpXLENBQVIsRUFBV3dXLElBQVgsSUFBbUJQLFFBQVEzTyxDQUFSLEVBQVdrUCxJQUEvQixHQUF3Q1AsUUFBUWpXLENBQVIsRUFBV3lXLEVBQVgsSUFBaUJSLFFBQVEzTyxDQUFSLEVBQVdtUCxFQUF4RSxFQUE2RTtBQUN6RTVtQixvQkFBSW1RLENBQUosRUFBTyxnQkFBUCxFQUF5QnNILENBQXpCO0FBQ0F1TyxxQkFBS3ZQLE1BQUwsQ0FBWXRHLENBQVosRUFBZSxDQUFmO0FBQ0g7QUFDSjtBQUNKOztBQUVELFNBQUssSUFBSUEsQ0FBVCxJQUFjNlYsSUFBZCxFQUFvQjtBQUNoQkMsYUFBS0EsR0FBRzNYLE9BQUgsQ0FBVzBYLEtBQUs3VixDQUFMLENBQVgsRUFBb0JnVyxNQUFwQixDQUFMLENBRGdCLENBQ2tCO0FBQ2xDRCxhQUFLQSxLQUFLLENBQVY7QUFDQUMsaUJBQVMsWUFBWXRRLE1BQVosQ0FBbUJxUSxFQUFuQixDQUFUO0FBQ0g7O0FBRUQsUUFBSUYsS0FBS3BiLE1BQUwsR0FBYyxDQUFsQixFQUFxQjtBQUNqQm9iLGFBQUs1VixJQUFMLENBQVU2VixFQUFWO0FBQ0FqbUIsWUFBSSxVQUFKLEVBQWdCZ21CLElBQWhCO0FBQ0EsZUFBUUEsSUFBUjtBQUNILEtBSkQsTUFJTztBQUNINWIsY0FBTSxzREFBTjtBQUNBLGVBQU8sSUFBUDtBQUNIO0FBQ0o7O0FBRUQ7Ozs7QUFJQSxTQUFTc0wsU0FBVCxDQUFtQk4sQ0FBbkIsRUFBc0J6VCxDQUF0QixFQUF5QkMsYUFBekIsRUFBd0M7QUFDcEMsUUFBSTNCLGNBQWNpRCxRQUFRa0IsVUFBUixJQUFzQixFQUF4QyxFQUE0QztBQUN4Q2dHLGNBQU0seURBQU47QUFDQTtBQUNIO0FBQ0QsUUFBSSxDQUFDeEksYUFBTCxFQUNJRCxJQUFJQSxFQUFFMk0sT0FBRixDQUFVLEdBQVYsRUFBZSxRQUFmLENBQUosQ0FOZ0MsQ0FNRjs7QUFFbEN0TyxRQUFJLGtCQUFrQm9WLENBQXRCO0FBQ0FwVixRQUFJLHFCQUFxQjJCLENBQXpCOztBQUVBLFFBQUlrUSxNQUFNdEksS0FBSyxhQUFMLENBQVY7O0FBRUE7QUFDQSxRQUFJc2QsTUFBTW5ULGNBQWMwQixFQUFFLENBQUYsQ0FBZCxFQUFvQixJQUFwQixDQUFWOztBQUVBLFFBQUksT0FBT3lSLEdBQVAsS0FBZSxXQUFuQixFQUFnQztBQUM1QkEsY0FBTW5ULGNBQWMwQixDQUFkLEVBQWlCLElBQWpCLENBQU47QUFDSDs7QUFFRCxRQUFJMFIsV0FBVztBQUNYQyx1QkFBZTNSLENBREo7QUFFWDRSLGtCQUFVSCxJQUFJRyxRQUZIO0FBR1hDLGlCQUFTSixJQUFJSSxPQUhGO0FBSVhDLGdCQUFRTCxJQUFJSyxNQUpEO0FBS1gvZixnQkFBUTBmLElBQUkxZjtBQUxELEtBQWY7O0FBUUFuSCxRQUFJNm1CLEdBQUo7QUFDQTtBQUNBLFFBQUlqbEIsYUFBSixFQUFtQjtBQUNmLFlBQUlpbEIsSUFBSUssTUFBSixJQUFjLFNBQWQsR0FBMEIsT0FBT0wsSUFBSU0sVUFBWCxLQUEwQixXQUF4RCxFQUFxRTtBQUNqRU4sZ0JBQUl2SixRQUFKLEdBQWUsS0FBZjtBQUNBLGlDQUFTdUosR0FBVDtBQUNBM25CO0FBQ0E7QUFDSCxTQUxELE1BS08sSUFBSTJuQixJQUFJSyxNQUFKLElBQWMsU0FBZCxHQUEwQixPQUFPTCxJQUFJTyxLQUFYLEtBQXFCLFdBQW5ELEVBQWdFO0FBQ25FUCxnQkFBSXZKLFFBQUosR0FBZSxZQUFmO0FBQ0Esb0NBQVl1SixHQUFaO0FBQ0EzbkI7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDQSxRQUFJbW9CLGlCQUFpQjtBQUNqQnhqQixrQkFBVWtHLE9BRE87QUFFakJ0RyxlQUFPb2pCLElBQUl0WSxJQUZNO0FBR2pCbkssb0JBQVlsQixRQUFRa0IsVUFISDtBQUlqQnNSLG1CQUFXL1QsQ0FKTTtBQUtqQnFELHFCQUFhQSxXQUxJO0FBTWpCcEQsdUJBQWVBLGFBTkU7QUFPakIwbEIsbUJBQVdSO0FBUE0sS0FBckI7QUFTQSxRQUFJN1YsVUFBVS9DLEtBQUtFLFNBQUwsQ0FBZWlaLGNBQWYsQ0FBZDtBQUNBLFFBQUluVyxVQUFVd1AsVUFBVSxjQUF4QjtBQUNBLFFBQUl0UCxjQUFjLGNBQWNILE9BQWhDO0FBQ0FqUixRQUFJLGtCQUFrQmtSLE9BQXRCO0FBQ0FsUixRQUFJLGVBQWVvUixXQUFuQjs7QUFFQSxhQUFTbVcsZ0JBQVQsQ0FBMEIxVixHQUExQixFQUErQmhELElBQS9CLEVBQXFDO0FBQ2pDL0Ysc0JBQWM2VyxJQUFkO0FBQ0EzZixZQUFJLGNBQWNrTyxLQUFLRSxTQUFMLENBQWVTLElBQWYsQ0FBbEI7O0FBRUE7QUFDQSxZQUFJQSxLQUFLak4sYUFBTCxDQUFtQixDQUFuQixDQUFKLEVBQTJCO0FBQ3ZCO0FBQ0FuQixlQUFHb08sSUFBSCxDQUFRQSxLQUFLZCxHQUFiLEVBQWtCLFVBQUN5QyxHQUFELEVBQU03RCxJQUFOLEVBQWU7QUFDN0Isb0JBQUk2RCxHQUFKLEVBQ0ksT0FBT3RRLFFBQVFzbkIsSUFBUixDQUFhaFgsR0FBYixDQUFQO0FBQ0osb0JBQUl1TCxhQUFKO0FBQ0EscUJBQUssSUFBSXRMLEdBQVQsSUFBZ0I5RCxJQUFoQixFQUFzQjtBQUNsQm9QLDJCQUFPckksY0FBY2pELEdBQWQsRUFBbUIsSUFBbkIsQ0FBUDtBQUNkLHdCQUFJLENBQUNzTCxJQUFMLEVBQ0k7QUFDVXhJLDJCQUFPQyxNQUFQLENBQWMsSUFBZCxFQUFvQnVJLElBQXBCLEVBQTBCcFAsS0FBSzhELEdBQUwsQ0FBMUI7QUFDQXNMLHlCQUFLdUIsUUFBTCxLQUFrQixZQUFsQixHQUFpQyx3QkFBWXZCLElBQVosQ0FBakMsR0FDSUEsS0FBS3VCLFFBQUwsS0FBa0IsS0FBbEIsR0FBMEIscUJBQVN2QixJQUFULENBQTFCLEdBQTJDLElBRC9DO0FBRUg7QUFDRHdDO0FBQ0FyZjtBQUNBNmMsd0JBQVEvYixJQUFJK2IsSUFBSixDQUFSO0FBQ0gsYUFmRDtBQWdCSCxTQWxCRCxNQWtCTztBQUNMOzs7Ozs7OztBQVFFL1csd0JBQVlvTCxJQUFaLENBQWlCO0FBQ2JxWCxzQkFBTSxXQURPO0FBRWJoa0IsdUJBQU8yUixDQUZNO0FBR2JNLDJCQUFXL1Q7QUFIRSxhQUFqQjs7QUFNQSxnQkFBSStsQixXQUFXLEtBQWY7QUFDQSxnQkFBSXJILFFBQVEsRUFBWjs7QUFFQUEsa0JBQU0sQ0FBTixJQUFXeFIsS0FBSytOLElBQWhCO0FBQ0EsZ0JBQUkrSyxTQUFTdEgsTUFBTSxDQUFOLEVBQVMsQ0FBVCxDQUFiOztBQUVBcmUsa0JBQU1vTyxJQUFOLENBQVd1WCxNQUFYOztBQUVBO0FBQ0E7QUFDQTtBQUNBbG5CLGVBQUdvTyxJQUFILENBQVFBLEtBQUtkLEdBQWIsRUFBa0IsVUFBUzZaLEtBQVQsRUFBZ0IvWSxJQUFoQixFQUFzQjtBQUNwQyxvQkFBSStZLEtBQUosRUFBVyxPQUFPMW5CLFFBQVFzbkIsSUFBUixDQUFhSSxLQUFiLENBQVA7O0FBRVgsb0JBQUlDLFdBQVdwcEIsZ0JBQWdCb1EsSUFBaEIsQ0FBZjs7QUFFQSxxQkFBSyxJQUFJNEIsR0FBVCxJQUFnQm9YLFFBQWhCLEVBQTBCO0FBQ3RCLHdCQUFJQyxVQUFVcFUsY0FBY2pELEdBQWQsQ0FBZDtBQUNBLHdCQUFJLE9BQU9xWCxPQUFQLEtBQW1CLFdBQXZCLEVBQW9DO0FBQ2hDMWQsOEJBQU0sNERBQU47QUFDQTtBQUNIO0FBQ0Q7QUFDQSx3QkFBSStGLElBQUkzTCxTQUFTb0csTUFBakIsQ0FQc0IsQ0FPSTtBQUMxQix3QkFBSW1kLE9BQU87QUFDUHJlLDRCQUFJeUcsQ0FERztBQUVQcUMsbUNBQVcsS0FGSjtBQUdQakUsOEJBQU1rQyxHQUhDO0FBSVBnQyw4QkFBTSxnQkFKQztBQUtQOUYsOEJBQU0sQ0FBQyxDQUFELEVBQUksRUFBSixFQUFRLEVBQVIsRUFBWSxDQUFaLEVBQWUsQ0FBZixFQUFrQixFQUFsQixFQUFzQixFQUF0QixDQUxDO0FBTVArRiwrQkFBTyxDQUFDLEVBQUQsRUFBSyxFQUFMLEVBQVMsRUFBVCxFQUFhLEVBQWIsRUFBaUIsRUFBakIsRUFBcUIsRUFBckIsRUFBeUIsRUFBekIsQ0FOQTtBQU9QQyxpQ0FBU25TLE9BQU8yUCxDQUFQLENBUEY7QUFRUHlDLGlDQUFTcFMsT0FBTzJQLENBQVAsQ0FSRjtBQVNQMEMsdURBVE87QUFVUEMscUNBQWEsR0FWTjtBQVdQQyxvQ0FBWSxLQVhMO0FBWVBDLHFDQUFhLENBQUMsRUFBRCxFQUFLLEVBQUwsQ0FaTjtBQWFQQyxrQ0FBVSxLQWJIO0FBY1BDLGtDQUFVLENBQUMsRUFBRCxFQUFLLEVBQUwsQ0FkSDtBQWVQQyxpQ0FBUyxLQWZGO0FBZ0JQNlUseUNBQWlCSCxTQUFTcFgsR0FBVCxFQUFjdVcsUUFoQnhCO0FBaUJQdkosd0NBQWdCb0ssU0FBU3BYLEdBQVQsRUFBY3dXLE9BakJ2QjtBQWtCUGdCLHVDQUFlSixTQUFTcFgsR0FBVCxFQUFjeVcsTUFsQnRCO0FBbUJQZ0IsdUNBQWVMLFNBQVNwWCxHQUFULEVBQWN0SjtBQW5CdEIscUJBQVg7O0FBc0JBb00sMkJBQU9DLE1BQVAsQ0FBYyxJQUFkLEVBQW9CdVUsSUFBcEIsRUFBMEJGLFNBQVNwWCxHQUFULENBQTFCO0FBQ0FqTSw2QkFBUzRMLElBQVQsQ0FBYzJYLElBQWQ7O0FBRUF4akIsNkJBQVM2TCxJQUFULENBQWN1WCxNQUFkO0FBQ0FqakIsMEJBQU0wTCxJQUFOLENBQVc1TCxTQUFTMkwsQ0FBVCxDQUFYO0FBQ0FvTztBQUNBcmY7O0FBRUEsd0JBQUlzRixTQUFTMkwsQ0FBVCxFQUFZbU4sUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN2QyxnREFBWTlZLFNBQVMyTCxDQUFULENBQVo7QUFDSCxxQkFGRCxNQUVPLElBQUkzTCxTQUFTMkwsQ0FBVCxFQUFZbU4sUUFBWixLQUF5QixLQUE3QixFQUFvQztBQUN2Qyw2Q0FBUzlZLFNBQVMyTCxDQUFULENBQVQ7QUFDSDs7QUFFRCxzQ0FBRWtHLE1BQUY7QUFDSDtBQUNKLGFBbkREOztBQXFEQWlLLG9CQUFRLFdBQVIsRUFBcUJELEtBQXJCO0FBQ0g7QUFDSjs7QUFFRCxhQUFTOEgsYUFBVCxDQUF1QnRXLEdBQXZCLEVBQTRCO0FBQ3hCekgsY0FBTSxnQkFBTjtBQUNBdEIsc0JBQWM2VyxJQUFkO0FBQ0g7O0FBRUQ3VyxrQkFBYzZDLEtBQWQsR0EzS29DLENBMktiO0FBQ3ZCdUcsb0JBQWdCaEIsT0FBaEIsRUFBeUJXLEdBQXpCLEVBQThCMFYsZ0JBQTlCLEVBQWdEWSxhQUFoRCxFQUErRC9XLFdBQS9EO0FBQ0g7O0FBRUQ7QUFDQTtBQUNBLFNBQVNnWCxpQkFBVCxDQUEyQnRhLE1BQTNCLEVBQW1DQyxHQUFuQyxFQUF3QzZHLFFBQXhDLEVBQWtEO0FBQzlDLFFBQUl5VCxNQUFNLElBQUlDLGNBQUosRUFBVjtBQUNBLFFBQUkscUJBQXFCRCxHQUF6QixFQUE4QjtBQUMxQjtBQUNBQSxZQUFJaEosSUFBSixDQUFTdlIsTUFBVCxFQUFpQkMsR0FBakIsRUFBc0IsSUFBdEI7QUFDSCxLQUhELE1BR08sSUFBSSxPQUFPd2EsY0FBUCxJQUF5QixXQUE3QixFQUEwQztBQUM3QztBQUNBRixjQUFNLElBQUlFLGNBQUosRUFBTjtBQUNBRixZQUFJaEosSUFBSixDQUFTdlIsTUFBVCxFQUFpQkMsR0FBakI7QUFDSCxLQUpNLE1BSUE7QUFDSDtBQUNBc2EsY0FBTSxJQUFOO0FBQ0g7QUFDRDtBQUNBQSxRQUFJRyxnQkFBSixDQUFxQixjQUFyQixFQUFxQyxtQ0FBckM7QUFDQSxXQUFPSCxHQUFQO0FBQ0g7O0FBRUQ7QUFDQSxTQUFTblcsZUFBVCxDQUF5Qm5FLEdBQXpCLEVBQThCOEQsR0FBOUIsRUFBbUMrQyxRQUFuQyxFQUE2QzZULGVBQTdDLEVBQThEQyxVQUE5RCxFQUEwRTtBQUN0RSxRQUFJTCxNQUFNRCxrQkFBa0IsTUFBbEIsRUFBMEJyYSxHQUExQixDQUFWO0FBQ0EsUUFBSSxDQUFDc2EsR0FBTCxFQUFVO0FBQ05qZSxjQUFNLG9CQUFOO0FBQ0E7QUFDSDtBQUNEO0FBQ0E7O0FBRUFpZSxRQUFJTSxNQUFKLEdBQWEsWUFBVztBQUNwQixZQUFJN2IsT0FBT3ViLElBQUlPLFlBQWY7QUFDQTVvQixZQUFJLE9BQUosRUFBYThNLElBQWI7O0FBRUEsWUFBSTtBQUNBLGdCQUFJK0IsT0FBT1gsS0FBS0MsS0FBTCxDQUFXckIsSUFBWCxDQUFYLENBREEsQ0FDNkI7QUFDN0IsZ0JBQUkrYixRQUFReFcsT0FBT0MsSUFBUCxDQUFZekQsSUFBWixDQUFaO0FBQ0gsU0FIRCxDQUdFLE9BQU8yQixHQUFQLEVBQVk7QUFDVjFILDBCQUFjNlcsSUFBZDtBQUNBNVcsd0JBQVk0VyxJQUFaO0FBQ0EzZixnQkFBSXdRLEdBQUo7QUFDQXBHLGtCQUFNLHVDQUFOO0FBQ0g7O0FBRUQsWUFBSXllLE1BQU0sQ0FBTixLQUFZLFNBQWhCLEVBQTJCO0FBQ3ZCSiw0QkFBZ0I1VyxHQUFoQjtBQUNBekgsa0JBQU0sY0FBY3lFLEtBQUtpYSxPQUF6QjtBQUNILFNBSEQsTUFHTztBQUNIbFUscUJBQVMvQyxHQUFULEVBQWNoRCxJQUFkO0FBQ0g7QUFDSixLQXBCRDtBQXFCQXdaLFFBQUlVLE9BQUosR0FBYyxZQUFXO0FBQ3JCO0FBQ0FWLFlBQUlsRSxNQUFKLElBQWMsQ0FBZCxHQUFrQi9aLE1BQU0sb0VBQU4sQ0FBbEIsR0FDSWllLElBQUlXLFVBQUosSUFBa0IsQ0FBbEIsR0FBc0I1ZSxNQUFNLDRFQUFOLENBQXRCLEdBQ0FBLE1BQU0sK0NBQU4sQ0FGSjtBQUdBcEssWUFBSXFvQixHQUFKO0FBQ0F2ZixzQkFBYzZXLElBQWQ7QUFDQTVXLG9CQUFZNFcsSUFBWjtBQUNILEtBUkQ7QUFTQTBJLFFBQUlZLElBQUosQ0FBU1AsVUFBVDtBQUNIOztBQUVNLElBQUlyTSwwQkFBUyxTQUFUQSxNQUFTLElBQUs7QUFDckJsZDtBQUNBLHNCQUFFa1gsTUFBRjtBQUNILENBSE07O0FBS1A7QUFDTyxTQUFTdFgsS0FBVCxHQUFpQjtBQUNwQm1xQjtBQUNBQztBQUNBbnFCLFlBQVEsTUFBUjtBQUNBdVUsV0FBTzZWLEVBQVAsQ0FBVUMsT0FBVixHQUFvQixZQUFXO0FBQzNCLGFBQUtDLFFBQUwsR0FBZ0JqTSxJQUFoQixDQUFxQixVQUFTbE4sQ0FBVCxFQUFZb1osQ0FBWixFQUFlO0FBQ2hDLGdCQUFJQyxRQUFRL29CLEdBQUcrYixHQUFILENBQU8sS0FBSzlSLEtBQUwsQ0FBVzhMLGVBQWxCLENBQVo7QUFDQSxnQkFBSWdULE1BQU1wVCxRQUFOLE9BQXFCaFYsU0FBU2dWLFFBQVQsRUFBekIsRUFDSTtBQUNKLGdCQUFJZCxNQUFNOUwsU0FBU2lWLFdBQVQsQ0FBcUIsYUFBckIsQ0FBVjtBQUNBbkosZ0JBQUltVSxjQUFKLENBQW1CLE9BQW5CLEVBQTRCLElBQTVCLEVBQWtDLElBQWxDLEVBQXdDM2UsTUFBeEMsRUFBZ0QsQ0FBaEQsRUFBbUQsQ0FBbkQsRUFBc0QsQ0FBdEQsRUFBeUQsQ0FBekQsRUFBNEQsQ0FBNUQsRUFBK0QsS0FBL0QsRUFBc0UsS0FBdEUsRUFBNkUsS0FBN0UsRUFBb0YsS0FBcEYsRUFBMkYsQ0FBM0YsRUFBOEYsSUFBOUY7QUFDQXllLGNBQUUzSyxhQUFGLENBQWdCdEosR0FBaEI7QUFDSCxTQVBEO0FBUUgsS0FURDtBQVVBekssTUFBRSxVQUFGLEVBQWN3ZSxPQUFkO0FBQ0g7O0FBRUQ7QUFDQSxTQUFTSyxVQUFULENBQW9CQyxPQUFwQixFQUE2QjtBQUN6QixRQUFJQyxNQUFKO0FBQ0EsUUFBSTllLE9BQU93ZCxjQUFYLEVBQTJCO0FBQ3ZCc0IsaUJBQVMsSUFBSTllLE9BQU93ZCxjQUFYLEVBQVQ7QUFDQXNCLGVBQU92SyxJQUFQLENBQVksS0FBWixFQUFtQnNLLE9BQW5CLEVBQTRCLEtBQTVCO0FBQ0FDLGVBQU9YLElBQVAsQ0FBWSxFQUFaO0FBQ0EsZUFBT1csT0FBT0MsV0FBZDtBQUNIO0FBQ0Q7QUFOQSxTQU9LLElBQUlDLGNBQWMsa0JBQWQsQ0FBSixFQUF1QztBQUN4Q0YscUJBQVMsSUFBSUUsYUFBSixDQUFrQixrQkFBbEIsQ0FBVDtBQUNBRixtQkFBT2xGLEtBQVAsR0FBZSxLQUFmO0FBQ0FrRixtQkFBT0csSUFBUCxDQUFZSixPQUFaO0FBQ0EsbUJBQU9DLE1BQVA7QUFDSDtBQUNEeGYsVUFBTSx5QkFBTjtBQUNIOztBQUVNLFNBQVNwTCxPQUFULENBQWlCZ3JCLEdBQWpCLEVBQXNCO0FBQ3pCemdCLFNBQUssTUFBTCxFQUFhbUIsS0FBYixDQUFtQm1LLE9BQW5CLEdBQTZCLE1BQTdCO0FBQ0F0TCxTQUFLLE1BQUwsRUFBYW1CLEtBQWIsQ0FBbUJtSyxPQUFuQixHQUE2QixNQUE3QjtBQUNBdEwsU0FBSyxNQUFMLEVBQWFtQixLQUFiLENBQW1CbUssT0FBbkIsR0FBNkIsTUFBN0I7QUFDQXRMLFNBQUt5Z0IsR0FBTCxFQUFVdGYsS0FBVixDQUFnQm1LLE9BQWhCLEdBQTBCLE9BQTFCO0FBQ0EsUUFBSW1WLE9BQU8sTUFBWCxFQUFtQjtBQUNmLGdCQS80Rkd4b0IsTUErNEZILFlBQVN3b0IsT0FBTyxNQUFoQjtBQUNBLGdCQS80Rkd2b0IsV0ErNEZILGlCQUFjLEtBQWQ7QUFDSDtBQUNELFlBbjVGT0YsT0FtNUZQLGFBQVV5b0IsR0FBVjtBQUNIOztBQUVNLFNBQVMvcUIsUUFBVCxDQUFrQitxQixHQUFsQixFQUF1QjtBQUMxQixRQUFJeGYsU0FBUyxTQUFUQSxNQUFTLE1BQU87QUFDaEIsWUFBSXlmLFFBQVF4cEIsR0FBRytKLE1BQUgsQ0FBVSxhQUFWLENBQVo7QUFDQSxlQUFPMGYsTUFBTUQsTUFBTTNWLElBQU4sQ0FBVyxPQUFYLEVBQW9CNFYsR0FBcEIsQ0FBTixHQUFpQ0QsTUFBTTNWLElBQU4sQ0FBVyxPQUFYLENBQXhDO0FBQ0gsS0FIRDtBQUlBLFFBQUk0VixNQUFNLDhCQUFWO0FBQ0EsUUFBSUMsVUFBVSxTQUFWQSxPQUFVLEdBQU07QUFDaEIzZixlQUFPLFlBQVc7QUFDZCxnQkFBSTRmLFNBQVNGLE1BQU0sY0FBbkI7QUFDQSxtQkFBTyxLQUFLRyxZQUFMLENBQWtCLE9BQWxCLE1BQStCRCxNQUEvQixHQUF3Q0YsR0FBeEMsR0FBOENFLE1BQXJEO0FBQ0gsU0FIRDtBQUlILEtBTEQ7QUFNQSxRQUFJRSxjQUFjLFNBQWRBLFdBQWMsR0FBTTtBQUNwQjlmLGVBQU8sWUFBVztBQUNYLGdCQUFJNGYsU0FBU0YsTUFBTSxrQkFBbkI7QUFDQSxtQkFBTyxLQUFLRyxZQUFMLENBQWtCLE9BQWxCLE1BQStCRCxNQUEvQixHQUF3Q0YsR0FBeEMsR0FBOENFLE1BQXJEO0FBQ0MsU0FIUjtBQUlILEtBTEQ7QUFNQSxRQUFJSixRQUFRLFdBQVosRUFBeUJ4ZixPQUFPMGYsR0FBUCxFQUF6QixLQUNLLElBQUlGLFFBQVEsU0FBWixFQUF1QnRvQixhQUFhLFNBQWIsSUFBMEI4SSxhQUFhMGYsR0FBYixJQUFvQkksYUFBOUMsQ0FBdkIsS0FDQSxJQUFJTixRQUFRLFlBQVosRUFBMEIsQ0FBQ25sQixTQUFELEdBQWEyRixPQUFPMGYsR0FBUCxDQUFiLEdBQzNCeG9CLGFBQWEsWUFBYixJQUE2QjhJLGFBQWEwZixHQUFiLElBQW9CQyxTQUR0QjtBQUUvQixZQXo2Rk96b0IsUUF5NkZQLGNBQVdzb0IsR0FBWDtBQUNIOztBQUVNLElBQUlPLDRCQUFVLEVBQUM1ZCxNQUFNLEVBQVAsRUFBZDs7QUFFUCxTQUFTcVIsVUFBVCxDQUFvQmpSLENBQXBCLEVBQXVCO0FBQ25CLFFBQUlnSSxLQUFLLHdLQUF3S2pULEtBQXhLLENBQThLLElBQTlLLENBQVQ7O0FBRUEsUUFBSTBvQixPQUFPL3BCLEdBQUdncUIsTUFBSCxDQUFVLEdBQVYsQ0FBWDtBQUNBLFFBQUlsTixNQUFNLFNBQU5BLEdBQU0sQ0FBQzFHLENBQUQsRUFBSXdELENBQUo7QUFBQSxlQUFVLENBQUMsQ0FBQ3hELENBQUYsRUFBS2tQLFdBQUwsQ0FBaUIxTCxLQUFLLENBQXRCLEVBQXlCakUsUUFBekIsRUFBVjtBQUFBLEtBQVY7QUFDQSxRQUFJNlAsS0FBS25qQixRQUFRaUssRUFBRTJkLE1BQVYsR0FDTCxDQUFDbk4sSUFBSXhRLEVBQUU0ZCxJQUFOLEVBQVksQ0FBWixJQUFpQixJQUFqQixHQUF3QnBOLElBQUl4USxFQUFFMmQsTUFBRixDQUFTRSxVQUFiLEVBQXlCLENBQXpCLENBQXhCLEdBQXNELEtBQXRELEdBQThEck4sSUFBSXhRLEVBQUUyZCxNQUFGLENBQVNHLFVBQWIsRUFBeUIsQ0FBekIsQ0FBOUQsR0FBNEYsR0FBN0YsRUFDQ3ROLElBQUl4USxFQUFFK2QsTUFBTixDQURELEVBQ2dCL2QsRUFBRWdlLElBRGxCLEVBQ3dCUCxLQUFLemQsRUFBRWllLFFBQVAsQ0FEeEIsRUFDMENqZSxFQUFFa2UsR0FENUMsRUFDaURULEtBQUt6ZCxFQUFFbWUsT0FBUCxDQURqRCxFQUNrRW5lLEVBQUVvZSxNQURwRSxFQUM0RVgsS0FBS3pkLEVBQUVxZSxVQUFQLENBRDVFLEVBRUM3TixJQUFJeFEsRUFBRXNlLEVBQU4sQ0FGRCxFQUVZOU4sSUFBSXhRLEVBQUVrTyxHQUFOLENBRlosRUFFd0JzQyxJQUFJeFEsRUFBRXVlLEdBQU4sQ0FGeEIsRUFFb0NkLEtBQUt6ZCxFQUFFd2UsT0FBUCxDQUZwQyxFQUVxRGYsS0FBS3pkLEVBQUV5ZSxLQUFQLENBRnJELEVBRW9FaEIsS0FBS3pkLEVBQUUwZSxPQUFQLENBRnBFLEVBRXFGbE8sSUFBSXhRLEVBQUUyZSxVQUFOLENBRnJGLENBREssR0FJTCxDQUFDbk8sSUFBSXhRLEVBQUU0ZCxJQUFOLENBQUQsRUFBY3BOLElBQUl4USxFQUFFK2QsTUFBTixDQUFkLEVBQTZCL2QsRUFBRWdlLElBQS9CLEVBQXFDUCxLQUFLemQsRUFBRWllLFFBQVAsQ0FBckMsRUFBdURqZSxFQUFFa2UsR0FBekQsRUFBOERULEtBQUt6ZCxFQUFFbWUsT0FBUCxDQUE5RCxFQUErRW5lLEVBQUVvZSxNQUFqRixFQUF5RlgsS0FBS3pkLEVBQUVxZSxVQUFQLENBQXpGLEVBQ0M3TixJQUFJeFEsRUFBRXNlLEVBQU4sQ0FERCxFQUNZOU4sSUFBSXhRLEVBQUVrTyxHQUFOLENBRFosRUFDd0JzQyxJQUFJeFEsRUFBRXVlLEdBQU4sQ0FEeEIsRUFDb0NkLEtBQUt6ZCxFQUFFd2UsT0FBUCxDQURwQyxFQUNxRGYsS0FBS3pkLEVBQUV5ZSxLQUFQLENBRHJELEVBQ29FaEIsS0FBS3pkLEVBQUUwZSxPQUFQLENBRHBFLEVBQ3FGbE8sSUFBSXhRLEVBQUUyZSxVQUFOLENBRHJGLENBSko7O0FBT0FuQixZQUFRNWQsSUFBUixHQUFlLEVBQWY7QUFDQW9JLE9BQUc2QixPQUFILENBQVcsVUFBQzJTLENBQUQsRUFBSXBaLENBQUo7QUFBQSxlQUFVLENBQUM4VixHQUFHOVYsQ0FBSCxFQUFNOEwsUUFBTixDQUFlLEtBQWYsQ0FBRCxJQUEwQmdLLEdBQUc5VixDQUFILEtBQVMsSUFBbkMsSUFBMkM4VixHQUFHOVYsQ0FBSCxLQUFTLEVBQXBELElBQTBEb2EsUUFBUTVkLElBQVIsQ0FBYXlELElBQWIsQ0FBa0IsQ0FBQ21aLENBQUQsRUFBSXRELEdBQUc5VixDQUFILENBQUosQ0FBbEIsQ0FBcEU7QUFBQSxLQUFYOztBQUVBb2EsWUFBUWhjLElBQVIsR0FBZXhCLEVBQUV3QixJQUFqQjtBQUNBZ2MsWUFBUTlYLElBQVIsR0FBZTFGLEVBQUUwRixJQUFqQjs7QUFFQWhTLE9BQUcrSixNQUFILENBQVUsT0FBVixFQUNLa0MsU0FETCxDQUNlLEtBRGYsRUFFS00sTUFGTDs7QUFJQSxRQUFJLENBQUNELEVBQUV1USxRQUFQLEVBQ0k7QUFDSnZRLE1BQUV1USxRQUFGLElBQWMsWUFBZCxHQUE2QixvQkFBUXZRLENBQVIsRUFBVyxZQUFYLEVBQXlCakssSUFBekIsQ0FBN0IsR0FDSWlLLEVBQUV1USxRQUFGLElBQWMsS0FBZCxHQUFzQixpQkFBS3ZRLENBQUwsRUFBUSxZQUFSLEVBQXNCakssSUFBdEIsQ0FBdEIsR0FDQXJDLEdBQUcrSixNQUFILENBQVUsT0FBVixFQUFtQjtBQUFuQixLQUNDa0MsU0FERCxDQUNXLEtBRFgsRUFFQ00sTUFGRCxFQUZKO0FBS0g7O0FBRU0sSUFBSTJlLDBDQUFpQixTQUFqQkEsY0FBaUIsSUFBSztBQUM3QixRQUFHNW9CLFFBQUgsRUFDSTtBQUNKLFFBQUkrSixPQUFPLEVBQVg7QUFINkIsZ0JBSVYsQ0FBQ3JNLEdBQUdncUIsTUFBSCxDQUFVLEdBQVYsQ0FBRCxFQUFpQixVQUFDalYsR0FBRCxFQUFNb1csR0FBTjtBQUFBLGVBQWMsQ0FBQyxDQUFDcFcsR0FBRixFQUFPdVEsV0FBUCxDQUFtQjZGLEdBQW5CLEVBQXdCeFYsUUFBeEIsRUFBZDtBQUFBLEtBQWpCLENBSlU7QUFBQSxRQUl4Qm9VLElBSndCO0FBQUEsUUFJbEJxQixJQUprQjs7QUFLN0IsUUFBSWhqQixNQUFNLFNBQU5BLEdBQU0sQ0FBQ21HLEtBQUQsRUFBUVQsSUFBUixFQUFjaUgsR0FBZCxFQUFzQjtBQUM1QixZQUFJeEcsU0FBUyxJQUFiLEVBQW1CbEMsK0VBQXlFeUIsSUFBekUsMEVBQTZJaUgsT0FBT3hHLEtBQXBKO0FBQ3RCLEtBRkQ7QUFHQWpDLE1BQUUwRixJQUFGLElBQVUsRUFBVixJQUFnQjVKLElBQUlrRSxFQUFFMEYsSUFBTixFQUFZLE9BQVosQ0FBaEI7QUFDQTVKLFFBQUlrRSxFQUFFNGQsSUFBTixFQUFZLE1BQVosRUFBb0I3bkIsUUFBUWlLLEVBQUUyZCxNQUFWLEdBQ2JtQixLQUFLOWUsRUFBRTRkLElBQVAsRUFBYSxDQUFiLENBRGEsVUFDT2tCLEtBQUs5ZSxFQUFFMmQsTUFBRixDQUFTRSxVQUFkLEVBQTBCLENBQTFCLENBRFAsV0FDeUNpQixLQUFLOWUsRUFBRTJkLE1BQUYsQ0FBU0csVUFBZCxFQUEwQixDQUExQixDQUR6QyxTQUVoQmdCLEtBQUs5ZSxFQUFFNGQsSUFBUCxFQUFhLENBQWIsQ0FGSjtBQUdBOWhCLFFBQUlrRSxFQUFFK2QsTUFBTixFQUFjLFFBQWQsRUFBd0JlLEtBQUs5ZSxFQUFFK2QsTUFBUCxFQUFlLENBQWYsQ0FBeEI7QUFDQWppQixRQUFJa0UsRUFBRWdlLElBQU4sRUFBWSxXQUFaO0FBQ0FsaUIsUUFBSWtFLEVBQUVpZSxRQUFOLEVBQWdCLGFBQWhCLEVBQWdDUixLQUFLemQsRUFBRWllLFFBQVAsQ0FBaEM7QUFDQW5pQixRQUFJa0UsRUFBRWtlLEdBQU4sRUFBVyxhQUFYO0FBQ0FwaUIsUUFBSWtFLEVBQUVtZSxPQUFOLEVBQWUsYUFBZixFQUE4QlYsS0FBS3pkLEVBQUVtZSxPQUFQLENBQTlCO0FBQ0FyaUIsUUFBSWtFLEVBQUVvZSxNQUFOLEVBQWMsWUFBZDtBQUNBdGlCLFFBQUlrRSxFQUFFcWUsVUFBTixFQUFrQixhQUFsQixFQUFpQ1osS0FBS3pkLEVBQUVxZSxVQUFQLENBQWpDO0FBQ0F2aUIsUUFBSWtFLEVBQUVzZSxFQUFOLEVBQVUsV0FBVixFQUF1QlEsS0FBSzllLEVBQUVzZSxFQUFQLEVBQVcsQ0FBWCxDQUF2QjtBQUNBeGlCLFFBQUlrRSxFQUFFdWUsR0FBTixFQUFXLFNBQVgsRUFBc0JPLEtBQUs5ZSxFQUFFdWUsR0FBUCxFQUFZLENBQVosQ0FBdEI7QUFDQXppQixRQUFJa0UsRUFBRWtPLEdBQU4sRUFBVyxTQUFYLEVBQXNCNFEsS0FBSzllLEVBQUVrTyxHQUFQLEVBQVksQ0FBWixDQUF0QjtBQUNBcFMsUUFBSWtFLEVBQUV3ZSxPQUFOLEVBQWUsU0FBZixFQUEwQmYsS0FBS3pkLEVBQUV3ZSxPQUFQLENBQTFCO0FBQ0ExaUIsUUFBSWtFLEVBQUV5ZSxLQUFOLEVBQWEsT0FBYixFQUFzQmhCLEtBQUt6ZCxFQUFFeWUsS0FBUCxDQUF0QjtBQUNBM2lCLFFBQUlrRSxFQUFFMGUsT0FBTixFQUFlLFNBQWYsRUFBMEJqQixLQUFLemQsRUFBRTBlLE9BQVAsQ0FBMUI7QUFDQTVpQixRQUFJa0UsRUFBRTJlLFVBQU4sRUFBa0IsWUFBbEIsRUFBZ0NHLEtBQUs5ZSxFQUFFMmUsVUFBUCxFQUFtQixDQUFuQixDQUFoQztBQUNBLFdBQU81ZSxJQUFQO0FBQ0gsQ0EzQk07O0FBNkJQLFNBQVNnZixNQUFULENBQWdCL2UsQ0FBaEIsRUFBbUI7QUFDZixRQUFJZ2YsTUFBTXRyQixHQUFHZ3FCLE1BQUgsQ0FBVSxLQUFWLENBQVY7QUFDQSxRQUFJRCxPQUFPL3BCLEdBQUdncUIsTUFBSCxDQUFVLEdBQVYsQ0FBWDtBQUNBO0FBQ0FocUIsT0FBRytKLE1BQUgsQ0FBVSxVQUFWLEVBQ0tFLEtBREwsQ0FDVyxNQURYLEVBQ21Cc2hCLFFBQVEsSUFEM0IsRUFFS3RoQixLQUZMLENBRVcsS0FGWCxFQUVrQnVoQixRQUFRLElBRjFCLEVBR0t6aEIsTUFITCxDQUdZLGNBSFosRUFJS2tGLElBSkwsQ0FJVSxvSUFBb0lxYyxJQUFJaGYsRUFBRTRkLElBQU4sQ0FBcEksR0FBa0osa0JBQWxKLEdBQ0YsbUlBREUsR0FDb0lvQixJQUFJaGYsRUFBRStkLE1BQU4sQ0FEcEksR0FDb0osa0JBRHBKLEdBRUYsaUlBRkUsR0FFa0kvZCxFQUFFZ2UsSUFGcEksR0FFMkksa0JBRjNJLEdBR0Ysc0lBSEUsR0FHdUlnQixJQUFJaGYsRUFBRXNlLEVBQU4sQ0FIdkksR0FHbUosa0JBSG5KLEdBSUYsb0lBSkUsR0FJcUlVLElBQUloZixFQUFFdWUsR0FBTixDQUpySSxHQUlrSixrQkFKbEosR0FLRixvSUFMRSxHQUtxSVMsSUFBSWhmLEVBQUVrTyxHQUFOLENBTHJJLEdBS2tKLGtCQUxsSixHQU1GLGtJQU5FLEdBTW1JdVAsS0FBS3pkLEVBQUV5ZSxLQUFQLENBTm5JLEdBTW1KLGtCQU5uSixHQU9GLG9JQVBFLEdBT3FJaEIsS0FBS3pkLEVBQUV3ZSxPQUFQLENBUHJJLEdBT3VKLGtCQVhqSztBQWFIOztBQUVNLFNBQVNyc0IsVUFBVCxHQUFzQjtBQUN6QixRQUFHd08sUUFBSCxFQUFhO0FBQ1RsRSxpQkFBU0MsY0FBVCxDQUF3QixXQUF4QixFQUFxQzZNLFNBQXJDLENBQStDQyxHQUEvQyxDQUFtRCxRQUFuRDtBQUNIO0FBQ0Q7QUFDQSxRQUFJbkUsT0FBTyxFQUFYO0FBQ0EsUUFBSThaLE1BQU0sRUFBVjtBQUNBeG5CLFVBQU1rUyxPQUFOLENBQWMsYUFBSztBQUNmeEUsYUFBS2hDLElBQUwsQ0FBVWdGLEVBQUU3RyxJQUFGLENBQU9ELE9BQVAsQ0FBZSxRQUFmLEVBQXlCLEVBQXpCLENBQVY7QUFDQTRkLFlBQUk5YixJQUFKLENBQVNnRixFQUFFMUwsRUFBWDtBQUNILEtBSEQ7O0FBS0E7QUFDQWpKLE9BQUcrSixNQUFILENBQVUsV0FBVixFQUF1QmtDLFNBQXZCLENBQWlDLEtBQWpDLEVBQXdDTSxNQUF4QztBQUNBdk0sT0FBRytKLE1BQUgsQ0FBVSxPQUFWLEVBQW1Ca0MsU0FBbkIsQ0FBNkIsS0FBN0IsRUFBb0NNLE1BQXBDO0FBQ0EsU0FBSyxJQUFJbUQsSUFBSSxDQUFiLEVBQWdCQSxJQUFJaUMsS0FBS3hILE1BQXpCLEVBQWlDdUYsR0FBakMsRUFBc0M7QUFDbEMsWUFBRzNMLFNBQVMwbkIsSUFBSS9iLENBQUosQ0FBVCxFQUFpQnFiLEtBQWpCLElBQXdCLENBQTNCLEVBQThCO0FBQzFCO0FBQ0osWUFBSXpQLE9BQU92WCxTQUFTMG5CLElBQUkvYixDQUFKLENBQVQsQ0FBWDtBQUNBNEwsYUFBSzlJLFFBQUwsR0FBZ0IsS0FBaEI7QUFDQThJLGFBQUtoSixVQUFMLEdBQWtCLEtBQWxCO0FBQ0EsWUFBSWdKLEtBQUt1QixRQUFMLEtBQWtCLFlBQWxCLEdBQWlDdkIsS0FBSzlJLFFBQUwsSUFBaUIsS0FBdEQsRUFBNkQ7QUFDekQ4SSxpQkFBSzlJLFFBQUwsR0FBZ0IsSUFBaEI7QUFDQSxnQ0FBUThJLElBQVIsRUFBY2xULE1BQU0sVUFBcEIsRUFBZ0MvRixJQUFoQztBQUNBaVosaUJBQUtoSixVQUFMLEdBQWtCLElBQWxCO0FBQ0EsZ0NBQVFnSixJQUFSLEVBQWNsVCxNQUFNLFFBQXBCLEVBQThCL0YsSUFBOUI7QUFDSCxTQUxELE1BS08sSUFBSWlaLEtBQUt1QixRQUFMLEtBQWtCLEtBQWxCLEdBQTBCdkIsS0FBSzlJLFFBQUwsSUFBaUIsS0FBL0MsRUFBc0Q7QUFDekQ4SSxpQkFBSzlJLFFBQUwsR0FBZ0IsSUFBaEI7QUFDQSw2QkFBSzhJLElBQUwsRUFBV2xULE1BQU0sVUFBakIsRUFBNkIvRixJQUE3QjtBQUNBaVosaUJBQUtoSixVQUFMLEdBQWtCLElBQWxCO0FBQ0EsbUNBQVdnSixJQUFYO0FBQ0g7QUFDSjs7QUFFR3RiLE9BQUcrSixNQUFILENBQVUsV0FBVixFQUF1QmtDLFNBQXZCLENBQWlDLEtBQWpDLEVBQ0MyUSxJQURELENBQ00sWUFBWTtBQUNaNWMsV0FBRytKLE1BQUgsQ0FBVSxJQUFWO0FBQ0EsWUFBSTJoQixTQUFTLHFCQUFiO0FBQ0EsWUFBSUMsU0FBU0QsT0FBT0UsSUFBUCxDQUFZLEtBQUszaUIsRUFBakIsQ0FBYjtBQUNBLFlBQUk0aUIsU0FBU0YsT0FBTyxDQUFQLENBQWI7QUFDQUEsaUJBQVNBLE9BQU8sQ0FBUCxDQUFUO0FBQ0EsWUFBSSxDQUFDaGEsS0FBSzZKLFFBQUwsQ0FBY21RLE1BQWQsQ0FBTCxFQUE0QjtBQUM1QjVuQixxQkFBUzhuQixNQUFULEVBQWlCclosUUFBakIsR0FBNEIsS0FBNUI7QUFDQSxnQkFBSWhFLE9BQU8sSUFBSTRHLE1BQUosQ0FBV3VXLE1BQVgsRUFBbUIsWUFBbkIsRUFBaUNFLE1BQWpDLENBQVg7QUFDQTdyQixlQUFHK0osTUFBSCxDQUFVeUUsSUFBVixFQUNDakMsTUFERDtBQUVBeEkscUJBQVM4bkIsTUFBVCxFQUFpQnZaLFVBQWpCLEdBQThCLEtBQTlCO0FBQ0E5RCxtQkFBTyxJQUFJNEcsTUFBSixDQUFXdVcsTUFBWCxFQUFtQixRQUFuQixFQUE2QkUsTUFBN0IsQ0FBUDtBQUNBN3JCLGVBQUcrSixNQUFILENBQVV5RSxJQUFWLEVBQ0NqQyxNQUREO0FBRUM7QUFDQSxLQWpCUDtBQWtCUDs7QUFHRDtBQUNBLFNBQVNtYyxnQkFBVCxHQUE0QjtBQUN4QjFvQixPQUFHK0osTUFBSCxDQUFVLGFBQVYsRUFDSzhKLElBREwsQ0FDVSxPQURWLEVBQ21CLDhCQURuQjtBQUVIOztBQUVELFNBQVM0VSxlQUFULEdBQTJCO0FBQ3ZCem9CLE9BQUcrSixNQUFILENBQVUsWUFBVixFQUNLOEosSUFETCxDQUNVLE9BRFYsRUFDbUIsOEJBRG5CO0FBRUg7O0FBRUQ7QUFDTyxJQUFJc0QsZ0NBQVksU0FBWkEsU0FBWSxNQUFPO0FBQzFCLFFBQUlnVSxNQUFNVyxTQUFTQyxJQUFJbGUsT0FBSixDQUFZLEdBQVosRUFBaUIsRUFBakIsQ0FBVCxFQUErQixFQUEvQixDQUFWO0FBQ0EscUJBQWUsQ0FBRXNkLE9BQU8sRUFBUixHQUFjLEdBQWYsRUFBcUJBLE9BQU8sQ0FBUixHQUFhLEdBQWpDLEVBQXNDQSxNQUFNLEdBQTVDLEVBQWlELEtBQWpELEVBQXdEeFIsSUFBeEQsQ0FBNkQsR0FBN0QsQ0FBZjtBQUNILENBSE07O0FBS1A7QUFDQSxTQUFTb0QsU0FBVCxDQUFtQnBJLENBQW5CLEVBQXNCcVgsQ0FBdEIsRUFBeUI7QUFDckIsUUFBSXJYLEVBQUV0QyxXQUFGLElBQWlCLEdBQXJCLEVBQTBCO0FBQ3RCLFlBQUkyWixLQUFLM3JCLFFBQVQsRUFBa0I7QUFDZCxnQkFBSTRyQixZQUFZeHBCLFFBQVFTLE9BQVIsQ0FBZ0JtTSxPQUFoQixDQUF3QnNGLEVBQUU3RyxJQUExQixDQUFoQjtBQUNBLGdCQUFJbWUsWUFBWSxDQUFDLENBQWpCLEVBQW1CO0FBQ2Z0WCxrQkFBRWhDLE1BQUYsR0FBVyxLQUFYO0FBQ0FsUSx3QkFBUVMsT0FBUixDQUFnQjhTLE1BQWhCLENBQXVCaVcsU0FBdkIsRUFBaUMsQ0FBakM7QUFDSCxhQUhELE1BR087QUFDSHRYLGtCQUFFaEMsTUFBRixHQUFXLElBQVg7QUFDQWxRLHdCQUFRUyxPQUFSLENBQWdCeU0sSUFBaEIsQ0FBcUJnRixFQUFFN0csSUFBdkI7QUFDSDtBQUNKLFNBVEQsTUFTTyxJQUFJa2UsS0FBS3pyQixRQUFULEVBQWtCO0FBQ3JCLGdCQUFJMHJCLFlBQVl4cEIsUUFBUVUsT0FBUixDQUFnQmtNLE9BQWhCLENBQXdCc0YsRUFBRTdHLElBQTFCLENBQWhCO0FBQ0EsZ0JBQUltZSxZQUFZLENBQUMsQ0FBakIsRUFBbUI7QUFDZnRYLGtCQUFFL0IsTUFBRixHQUFXLEtBQVg7QUFDQW5RLHdCQUFRVSxPQUFSLENBQWdCNlMsTUFBaEIsQ0FBdUJpVyxTQUF2QixFQUFpQyxDQUFqQztBQUNILGFBSEQsTUFHTztBQUNIdFgsa0JBQUUvQixNQUFGLEdBQVcsSUFBWDtBQUNBblEsd0JBQVFVLE9BQVIsQ0FBZ0J3TSxJQUFoQixDQUFxQmdGLEVBQUU3RyxJQUF2QjtBQUNIO0FBQ0osU0FUTSxNQVNBO0FBQ1A7QUFDQTZHLGNBQUV0QyxXQUFGLEdBQWdCLEdBQWhCO0FBQ0FzQyxjQUFFdkMsV0FBRixHQUFnQjRaLENBQWhCO0FBQ0FyWCxjQUFFekMsT0FBRixHQUFZdFIsV0FBWjtBQUNBLGdCQUFJK08sT0FBTyxTQUFQQSxJQUFPLFFBQWtCO0FBQUE7QUFBQSxvQkFBaEJzRyxLQUFnQjtBQUFBLG9CQUFUakcsR0FBUzs7QUFDekIsb0JBQUlpRyxTQUFTK1YsQ0FBYixFQUNJO0FBQ0p2cEIsd0JBQVF1TixHQUFSLElBQWU2SSxNQUFNcVQsT0FBTixDQUFjenBCLFFBQVF1TixHQUFSLENBQWQsSUFBOEJ2TixRQUFRdU4sR0FBUixDQUE5QixHQUE2QyxFQUE1RDtBQUNBdk4sd0JBQVF1TixHQUFSLEVBQWFMLElBQWIsQ0FBa0JnRixFQUFFN0csSUFBcEI7QUFDQSxvQkFBSWtDLE9BQU8sTUFBWCxFQUFtQjtBQUNmaUQsa0NBQWMwQixFQUFFN0csSUFBaEIsRUFBc0IsSUFBdEIsRUFBNEIyWSxNQUE1QixHQUFxQyxTQUFyQztBQUNBeFIsOEJBQVVOLEVBQUU3RyxJQUFaLEVBQWtCNU0sSUFBSSxJQUF0QixFQUE0QkMsZ0JBQWdCLElBQTVDO0FBQ0g7QUFDRCxvQkFBSTZPLE9BQU8sS0FBWCxFQUFpQjtBQUErQztBQUM1RCx3QkFBRzJFLEVBQUVoQyxNQUFMLEVBQVk7QUFDUmdDLDBCQUFFaEMsTUFBRixHQUFXLEtBQVg7QUFDQWxRLGdDQUFRUyxPQUFSLENBQWdCOFMsTUFBaEIsQ0FBdUJ2VCxRQUFRUyxPQUFSLENBQWdCbU0sT0FBaEIsQ0FBd0JzRixFQUFFN0csSUFBMUIsQ0FBdkIsRUFBdUQsQ0FBdkQ7QUFDSDtBQUNELHdCQUFHNkcsRUFBRS9CLE1BQUwsRUFBWTtBQUNSK0IsMEJBQUUvQixNQUFGLEdBQVcsS0FBWDtBQUNBblEsZ0NBQVFVLE9BQVIsQ0FBZ0I2UyxNQUFoQixDQUF1QnZULFFBQVFVLE9BQVIsQ0FBZ0JrTSxPQUFoQixDQUF3QnNGLEVBQUU3RyxJQUExQixDQUF2QixFQUF1RCxDQUF2RDtBQUNIO0FBQ0o7QUFDSixhQW5CRDtBQW9CQSxhQUFDLENBQUMxTixPQUFELEVBQVUsS0FBVixDQUFELEVBQW1CLENBQUNELE9BQUQsRUFBVSxRQUFWLENBQW5CLEVBQXdDLENBQUNVLFNBQUQsRUFBWSxPQUFaLENBQXhDLEVBQThELENBQUNILFFBQUQsRUFBVyxNQUFYLENBQTlELEVBQWtGeVYsT0FBbEYsQ0FBMEZ4RyxJQUExRjtBQUNDO0FBQ0osS0E5Q0QsTUE4Q08sSUFBSWdGLEVBQUV0QyxXQUFGLElBQWlCLEdBQXJCLEVBQTBCO0FBQzdCLFlBQUkyWixLQUFLclgsRUFBRXZDLFdBQVgsRUFBd0I7QUFBRTtBQUN0QnVDLGNBQUV0QyxXQUFGLEdBQWdCLEdBQWhCO0FBQ0FzQyxjQUFFdkMsV0FBRjtBQUNBdUMsY0FBRXpDLE9BQUYsR0FBWW5TLE9BQU80VSxFQUFFMUwsRUFBVCxDQUFaO0FBQ0ErTSxtQkFBT2dXLENBQVAsRUFBVXJYLEVBQUU3RyxJQUFaLEVBQWtCLENBQUMxTixPQUFELEVBQVUsS0FBVixDQUFsQixFQUFvQyxDQUFDRCxPQUFELEVBQVUsUUFBVixDQUFwQyxFQUF5RCxDQUFDVSxTQUFELEVBQVksT0FBWixDQUF6RCxFQUErRSxDQUFDSCxRQUFELEVBQVcsTUFBWCxDQUEvRTtBQUNBLGdCQUFJQSxZQUFZc3JCLENBQVosSUFBaUJ2cEIsUUFBUUksSUFBUixDQUFhMlksUUFBYixDQUFzQjdHLEVBQUU3RyxJQUF4QixDQUFyQixFQUFvRDtBQUNoRG1GLDhCQUFjMEIsRUFBRTdHLElBQWhCLEVBQXNCLElBQXRCLEVBQTRCMlksTUFBNUIsR0FBcUN4VCxjQUFjMEIsRUFBRTdHLElBQWhCLEVBQXNCLElBQXRCLEVBQTRCMFosYUFBakU7QUFDQXZTLDBCQUFVTixFQUFFN0csSUFBWixFQUFrQjVNLElBQUksSUFBdEIsRUFBNEJDLGdCQUFnQixJQUE1QztBQUNIO0FBQ0osU0FURCxNQVNPO0FBQUU7QUFDTDZVLG1CQUFPckIsRUFBRXZDLFdBQVQsRUFBc0J1QyxFQUFFN0csSUFBeEIsRUFBOEIsQ0FBQzFOLE9BQUQsRUFBVSxLQUFWLENBQTlCLEVBQWdELENBQUNELE9BQUQsRUFBVSxRQUFWLENBQWhELEVBQXFFLENBQUNVLFNBQUQsRUFBWSxPQUFaLENBQXJFLEVBQTJGLENBQUNILFFBQUQsRUFBVyxNQUFYLENBQTNGO0FBQ0EsZ0JBQUlBLFlBQVlpVSxFQUFFdkMsV0FBZCxJQUE2QjNQLFFBQVFJLElBQVIsQ0FBYTJZLFFBQWIsQ0FBc0I3RyxFQUFFN0csSUFBeEIsQ0FBakMsRUFBZ0U7QUFDNURtRiw4QkFBYzBCLEVBQUU3RyxJQUFoQixFQUFzQixJQUF0QixFQUE0QjJZLE1BQTVCLEdBQXFDeFQsY0FBYzBCLEVBQUU3RyxJQUFoQixFQUFzQixJQUF0QixFQUE0QjBaLGFBQWpFO0FBQ0F2UywwQkFBVU4sRUFBRTdHLElBQVosRUFBa0I1TSxJQUFJLElBQXRCLEVBQTRCQyxnQkFBZ0IsSUFBNUM7QUFDSDtBQUNEd1QsY0FBRXZDLFdBQUYsR0FBZ0I0WixDQUFoQjtBQUNBLGdCQUFJNXJCLFdBQVc0ckIsQ0FBZixFQUFpQjtBQUNiLG9CQUFJRyxTQUFTeFgsRUFBRTdHLElBQWY7QUFDQXJMLHdCQUFRUSxHQUFSLENBQVkwTSxJQUFaLENBQWlCd2MsTUFBakI7QUFDQSxvQkFBR3hYLEVBQUVoQyxNQUFMLEVBQVk7QUFBc0I7QUFDOUJ5Wiw4QkFBVSxLQUFWO0FBQ0EzcEIsNEJBQVFTLE9BQVIsQ0FBZ0I4UyxNQUFoQixDQUF1QnZULFFBQVFTLE9BQVIsQ0FBZ0JtTSxPQUFoQixDQUF3QjhjLE1BQXhCLENBQXZCLEVBQXVELENBQXZEO0FBQ0g7QUFDRCxvQkFBR3hYLEVBQUUvQixNQUFMLEVBQVk7QUFDUnlaLDhCQUFVLEtBQVY7QUFDQTVwQiw0QkFBUVUsT0FBUixDQUFnQjZTLE1BQWhCLENBQXVCdlQsUUFBUVUsT0FBUixDQUFnQmtNLE9BQWhCLENBQXdCOGMsTUFBeEIsQ0FBdkIsRUFBdUQsQ0FBdkQ7QUFDSDtBQUNKLGFBWEQsTUFZSyxJQUFJaHNCLFdBQVc2ckIsQ0FBZixFQUFrQnZwQixRQUFRSyxNQUFSLENBQWU2TSxJQUFmLENBQW9CZ0YsRUFBRTdHLElBQXRCLEVBQWxCLEtBQ0EsSUFBSWpOLGFBQWFtckIsQ0FBakIsRUFBb0J2cEIsUUFBUUcsS0FBUixDQUFjK00sSUFBZCxDQUFtQmdGLEVBQUU3RyxJQUFyQixFQUFwQixLQUNBLElBQUlwTixZQUFZc3JCLENBQWhCLEVBQW1CO0FBQ3BCdnBCLHdCQUFRSSxJQUFSLENBQWE4TSxJQUFiLENBQWtCZ0YsRUFBRTdHLElBQXBCO0FBQ0FtRiw4QkFBYzBCLEVBQUU3RyxJQUFoQixFQUFzQixJQUF0QixFQUE0QjJZLE1BQTVCLEdBQXFDLFNBQXJDO0FBQ0F4UiwwQkFBVU4sRUFBRTdHLElBQVosRUFBa0I1TSxJQUFJLElBQXRCLEVBQTRCQyxnQkFBZ0IsSUFBNUM7QUFDSDtBQUNKO0FBQ0o7QUFDSjs7QUFFTSxTQUFTekMsV0FBVCxHQUF1QjtBQUMxQitELFlBQVFRLEdBQVIsQ0FBWWtILE1BQVosR0FBcUIsQ0FBckIsR0FDSUMsRUFBRSxpQ0FBRixFQUFxQ3lKLElBQXJDLENBQTBDLFFBQTFDLEVBQW9EelQsT0FBcEQsQ0FESixHQUVJZ0ssRUFBRSxXQUFGLEVBQWVraUIsR0FBZixDQUFtQixjQUFuQixFQUFtQyxNQUFuQyxDQUZKO0FBR0E3cEIsWUFBUUssTUFBUixDQUFlcUgsTUFBZixHQUF3QixDQUF4QixHQUNJQyxFQUFFLGlDQUFGLEVBQXFDeUosSUFBckMsQ0FBMEMsUUFBMUMsRUFBb0QxVCxPQUFwRCxDQURKLEdBRUlpSyxFQUFFLFdBQUYsRUFBZWtpQixHQUFmLENBQW1CLGNBQW5CLEVBQW1DLE1BQW5DLENBRko7QUFHQTdwQixZQUFRRyxLQUFSLENBQWN1SCxNQUFkLEdBQXVCLENBQXZCLEdBQ0lDLEVBQUUsbUNBQUYsRUFBdUN5SixJQUF2QyxDQUE0QyxRQUE1QyxFQUFzRGhULFNBQXRELENBREosR0FFSXVKLEVBQUUsYUFBRixFQUFpQmtpQixHQUFqQixDQUFxQixjQUFyQixFQUFxQyxNQUFyQyxDQUZKO0FBR0E3cEIsWUFBUUksSUFBUixDQUFhc0gsTUFBYixHQUFzQixDQUF0QixHQUNJQyxFQUFFLGtDQUFGLEVBQXNDeUosSUFBdEMsQ0FBMkMsUUFBM0MsRUFBcURuVCxRQUFyRCxDQURKLEdBRUkwSixFQUFFLFlBQUYsRUFBZ0JraUIsR0FBaEIsQ0FBb0IsY0FBcEIsRUFBb0MsTUFBcEMsQ0FGSjtBQUdBN3BCLFlBQVFTLE9BQVIsQ0FBZ0JpSCxNQUFoQixHQUF5QixDQUF6QixHQUNJQyxFQUFFLGtDQUFGLEVBQXNDeUosSUFBdEMsQ0FBMkMsUUFBM0MsRUFBcUR4VCxRQUFyRCxFQUErRHdULElBQS9ELENBQW9FLE1BQXBFLEVBQTRFeFQsUUFBNUUsRUFBc0Z3VCxJQUF0RixDQUEyRixjQUEzRixFQUEyRyxHQUEzRyxFQUFnSEEsSUFBaEgsQ0FBcUgsZ0JBQXJILEVBQXVJLENBQXZJLENBREosR0FFSXpKLEVBQUUsWUFBRixFQUFnQmtpQixHQUFoQixDQUFvQixjQUFwQixFQUFvQyxNQUFwQyxDQUZKO0FBR0E3cEIsWUFBUVUsT0FBUixDQUFnQmdILE1BQWhCLEdBQXlCLENBQXpCLEdBQ0lDLEVBQUUsa0NBQUYsRUFBc0N5SixJQUF0QyxDQUEyQyxRQUEzQyxFQUFxRHRULFFBQXJELEVBQStEc1QsSUFBL0QsQ0FBb0UsTUFBcEUsRUFBNEV0VCxRQUE1RSxFQUFzRnNULElBQXRGLENBQTJGLGNBQTNGLEVBQTJHLEdBQTNHLEVBQWdIQSxJQUFoSCxDQUFxSCxnQkFBckgsRUFBdUksQ0FBdkksQ0FESixHQUVJekosRUFBRSxZQUFGLEVBQWdCa2lCLEdBQWhCLENBQW9CLGNBQXBCLEVBQW9DLE1BQXBDLENBRko7QUFHSDs7QUFFRDtBQUNBLFNBQVMzUSxTQUFULENBQW1CaEgsQ0FBbkIsRUFBc0I7QUFDbEJBLE1BQUV2QyxXQUFGO0FBQ0F1QyxNQUFFdEMsV0FBRixHQUFnQixHQUFoQjtBQUNBc0MsTUFBRXpDLE9BQUYsR0FBWXlDLEVBQUV4QyxPQUFkO0FBQ0g7O0FBRU0sU0FBU3hULFlBQVQsQ0FBc0J5UyxHQUF0QixFQUEyQjtBQUM5QixRQUFJOUgsT0FBSixFQUNJN0csUUFBUVcsUUFBUixHQUFtQmtHLE9BQW5CO0FBQ0osUUFBSTlKLGNBQWNpRCxRQUFRa0IsVUFBUixJQUFzQixFQUF4QyxFQUE0QztBQUN4Q2dHLGNBQU0seURBQU47QUFDQTtBQUNIO0FBQ0RsSCxZQUFRTyxLQUFSLEdBQWdCLEVBQWhCO0FBQ0FQLFlBQVFpQixLQUFSLEdBQWdCLEVBQWhCO0FBQ0EsUUFBSTZvQixjQUFjLElBQWxCO0FBQ0E7QUFDQSxTQUFLLElBQUl2VixJQUFJLENBQWIsRUFBZ0JBLElBQUkvUyxNQUFNa0csTUFBMUIsRUFBa0M2TSxHQUFsQyxFQUF1QztBQUFFO0FBQ3JDdlUsZ0JBQVFPLEtBQVIsQ0FBYzJNLElBQWQsQ0FBbUIxTCxNQUFNK1MsQ0FBTixFQUFTbEosSUFBNUI7QUFDQSxZQUFJVSxPQUFPdkssTUFBTStTLENBQU4sRUFBUy9OLEVBQXBCO0FBQ0F4RyxnQkFBUWMsT0FBUixDQUFnQnlULENBQWhCLElBQXFCalQsU0FBU3lLLElBQVQsRUFBZStELFdBQXBDO0FBQ0EsWUFBSTlQLFFBQVFjLE9BQVIsQ0FBZ0J5VCxDQUFoQixFQUFtQjdNLE1BQW5CLEdBQTRCLENBQWhDLEVBQW1DO0FBQy9CLGdCQUFJMUgsUUFBUWMsT0FBUixDQUFnQnlULENBQWhCLEVBQW1CLENBQW5CLEtBQXlCLEVBQTdCLEVBQ0l2VSxRQUFRYyxPQUFSLENBQWdCeVQsQ0FBaEIsRUFBbUIsQ0FBbkIsSUFBd0JvTyxPQUFPM2lCLFFBQVFjLE9BQVIsQ0FBZ0J5VCxDQUFoQixFQUFtQixDQUFuQixDQUFQLENBQXhCO0FBQ0osZ0JBQUl2VSxRQUFRYyxPQUFSLENBQWdCeVQsQ0FBaEIsRUFBbUIsQ0FBbkIsS0FBeUIsRUFBN0IsRUFDSXZVLFFBQVFjLE9BQVIsQ0FBZ0J5VCxDQUFoQixFQUFtQixDQUFuQixJQUF3Qm9PLE9BQU8zaUIsUUFBUWMsT0FBUixDQUFnQnlULENBQWhCLEVBQW1CLENBQW5CLENBQVAsQ0FBeEI7QUFDUDtBQUNEdlUsZ0JBQVFpQixLQUFSLENBQWNpTSxJQUFkLENBQW1CNUwsU0FBU3lLLElBQVQsRUFBZXFPLFFBQWxDO0FBQ0EsWUFBSXBhLFFBQVFjLE9BQVIsQ0FBZ0J5VCxDQUFoQixFQUFtQixDQUFuQixLQUF5QixFQUE3QixFQUNJdVYsY0FBYyxLQUFkLENBWitCLENBWVY7QUFDNUI7O0FBRUQsUUFBSUEsZUFBZSxJQUFuQixFQUF5QjtBQUNyQjVpQixjQUFNLGtDQUFOO0FBQ0E7QUFDSDs7QUFFRCxRQUFJMGMsV0FBVyxFQUFmO0FBQ0EsU0FBSyxJQUFJclAsSUFBSSxDQUFiLEVBQWdCQSxJQUFJalQsU0FBU29HLE1BQTdCLEVBQXFDNk0sR0FBckMsRUFBMEM7QUFDdENxUCxpQkFBUzFXLElBQVQsQ0FBYztBQUNWMlcsMkJBQWV2aUIsU0FBU2lULENBQVQsRUFBWWxKLElBRGpCO0FBRVYyWSxvQkFBUTFpQixTQUFTaVQsQ0FBVCxFQUFZeVAsTUFGVjtBQUdWRCxxQkFBU3ppQixTQUFTaVQsQ0FBVCxFQUFZd1AsT0FIWDtBQUlWOWYsb0JBQVEzQyxTQUFTaVQsQ0FBVCxFQUFZdFEsTUFKVjtBQUtWNmYsc0JBQVV4aUIsU0FBU2lULENBQVQsRUFBWXVQO0FBTFosU0FBZDtBQU9IOztBQUVELFFBQUlpRyxjQUFjO0FBQ2RwcEIsa0JBQVVYLFFBQVFXLFFBREo7QUFFZEosZUFBT1AsUUFBUU8sS0FGRDtBQUdkTyxpQkFBU2QsUUFBUWMsT0FISDtBQUlkSSxvQkFBWWxCLFFBQVFrQixVQUpOO0FBS2RELGVBQU9qQixRQUFRaUIsS0FMRDtBQU1kYSxxQkFBYUEsV0FOQztBQU9kc2lCLG1CQUFXUjtBQVBHLEtBQWxCOztBQVVBLFFBQUk3VixVQUFVL0MsS0FBS0UsU0FBTCxDQUFlNmUsV0FBZixDQUFkO0FBQ0EsUUFBSS9iLFVBQVV3UCxVQUFVLFdBQXhCO0FBQ0EsUUFBSXRQLGNBQWMsY0FBY0gsT0FBaEM7QUFDQWpSLFFBQUksZUFBSixFQUFxQmtSLE9BQXJCO0FBQ0FsUixRQUFJLFlBQUosRUFBa0JvUixXQUFsQjs7QUFFQSxhQUFTOGIsbUJBQVQsQ0FBNkJyYixHQUE3QixFQUFrQ2hELElBQWxDLEVBQXdDO0FBQ3BDOUYsb0JBQVk0VyxJQUFaLEdBRG9DLENBQ2hCO0FBQ3BCOVUsVUFBRSxlQUFGLEVBQW1CZ1YsT0FBbkIsQ0FBMkIsT0FBM0IsRUFGb0MsQ0FFQztBQUNyQ2hWLFVBQUUsWUFBRixFQUFnQmdWLE9BQWhCLENBQXdCLE9BQXhCOztBQUVBLFlBQUlzTixXQUFXLEVBQWY7QUFDQSxZQUFJOU0sUUFBUSxFQUFaO0FBQ0FBLGNBQU0sQ0FBTixJQUFXeFIsS0FBSytOLElBQWhCOztBQUVBO0FBQ0E3STtBQUNBLFlBQUlxWixVQUFVN1osT0FBT0MsTUFBUCxDQUFjLElBQWQsRUFBb0IsRUFBcEIsRUFBd0JoUCxRQUF4QixDQUFkO0FBQ0EsWUFBSTZvQixXQUFXOVosT0FBT0MsTUFBUCxDQUFjLElBQWQsRUFBb0IsRUFBcEIsRUFBd0J0USxPQUF4QixDQUFmO0FBQ0EsWUFBSW9xQixVQUFVL1osT0FBT0MsTUFBUCxDQUFjLElBQWQsRUFBb0IsRUFBcEIsRUFBd0J4UixLQUF4QixDQUFkO0FBQ0EsWUFBSXVyQixVQUFVaGEsT0FBT0MsTUFBUCxDQUFjLElBQWQsRUFBb0IsRUFBcEIsRUFBd0I1USxXQUF4QixDQUFkO0FBQ0EsWUFBSTRxQixlQUFlamEsT0FBT0MsTUFBUCxDQUFjLElBQWQsRUFBb0IsRUFBcEIsRUFBd0J2UixVQUF4QixDQUFuQjtBQUNBLFlBQUl3ckIsUUFBUWxhLE9BQU9DLE1BQVAsQ0FBYyxJQUFkLEVBQW9CLEVBQXBCLEVBQXdCdlEsUUFBeEIsQ0FBWjtBQUNBLFlBQUl5cUIsWUFBWW5hLE9BQU9DLE1BQVAsQ0FBYyxJQUFkLEVBQW9CLEVBQXBCLEVBQXdCeE8sV0FBeEIsQ0FBaEI7O0FBRUE5QyxlQUFPUyxPQUFQLElBQWtCO0FBQ2Qsd0JBQVl5cUIsT0FERTtBQUVkLHVCQUFXQyxRQUZHO0FBR2QscUJBQVNDLE9BSEs7QUFJZCxxQkFBU0MsT0FKSztBQUtkLDBCQUFjQyxZQUxBO0FBTWQsd0JBQVlDLEtBTkU7QUFPZCwyQkFBZUM7QUFQRCxTQUFsQjs7QUFVQTtBQUNBLFlBQUkvVixXQUFXLEtBQUs5QixNQUFMLENBQVlsVCxPQUFaLENBQWY7QUFDQWxDLFdBQUcrSixNQUFILENBQVVtTixRQUFWLEVBQW9CckQsSUFBcEIsQ0FBeUIsT0FBekIsRUFBa0MsTUFBbEM7QUFDQXFELG1CQUFXLGNBQWM5QixNQUFkLENBQXFCbFQsT0FBckIsQ0FBWDtBQUNBbEMsV0FBRytKLE1BQUgsQ0FBVW1OLFFBQVYsRUFBb0IzSyxNQUFwQjs7QUFFQXJLLGtCQUFVVCxPQUFPMEksTUFBakI7QUFDQTVGLG9CQUFZb0wsSUFBWixDQUFpQjtBQUNicVgsa0JBQU0sUUFETztBQUViaGtCLG1CQUFPOFAsT0FBT0MsTUFBUCxDQUFjLElBQWQsRUFBb0IsRUFBcEIsRUFBd0J0USxRQUFRTyxLQUFoQyxDQUZNO0FBR2JPLHFCQUFTdVAsT0FBT0MsTUFBUCxDQUFjLElBQWQsRUFBb0IsRUFBcEIsRUFBd0J0USxRQUFRYyxPQUFoQyxDQUhJO0FBSWJHLG1CQUFPb1AsT0FBT0MsTUFBUCxDQUFjLElBQWQsRUFBb0IsRUFBcEIsRUFBd0J0USxRQUFRaUIsS0FBaEM7QUFKTSxTQUFqQjs7QUFPQTtBQUNBLGlCQUFTd3BCLE1BQVQsQ0FBZ0IzVyxDQUFoQixFQUFtQjtBQUNmO0FBQ0E7QUFDQSxpQkFBSyxJQUFJN0csSUFBSSxDQUFiLEVBQWdCQSxJQUFJNkcsRUFBRXBNLE1BQXRCLEVBQThCdUYsR0FBOUIsRUFBbUM7QUFDL0Isb0JBQUl3SCxXQUFXWCxFQUFFN0csQ0FBRixFQUFLN0IsT0FBTCxDQUFhLEtBQWIsRUFBb0IsR0FBcEIsQ0FBZjtBQUNBL0UscUJBQUtvTyxRQUFMLEVBQWVqTixLQUFmLENBQXFCZ00sS0FBckIsR0FBNkJrQixVQUFVMVcsU0FBVixDQUE3QjtBQUNBeVcsMkJBQVcsS0FBSzlCLE1BQUwsQ0FBWThCLFFBQVosQ0FBWDtBQUNBbFgsbUJBQUcrSixNQUFILENBQVVtTixRQUFWLEVBQ0tsTCxFQURMLENBQ1EsT0FEUixFQUNpQixJQURqQjtBQUVIO0FBQ0o7O0FBRUQ2VCxnQkFBUSxRQUFSLEVBQWtCRCxLQUFsQjtBQUNBdU47O0FBRUFudEIsV0FBRytKLE1BQUgsQ0FBVSxnQkFBVixFQUNLcUMsTUFETCxDQUNZLEtBRFosRUFFS3lILElBRkwsQ0FFVSxPQUZWLEVBRW1CLGFBRm5CLEVBR0tBLElBSEwsQ0FHVSxJQUhWLEVBR2dCO0FBQUEsbUJBQU0sSUFBSXVCLE1BQUosQ0FBV2xULFFBQVF5VCxRQUFSLEVBQVgsQ0FBTjtBQUFBLFNBSGhCLEVBSUt2SixNQUpMLENBSVksS0FKWixFQUtLeUgsSUFMTCxDQUtVLElBTFYsRUFLZ0IsWUFMaEI7QUFNQTVMLGNBQU1qSSxHQUFHK0osTUFBSCxDQUFVLGFBQVYsQ0FBTjs7QUFFQS9KLFdBQUdvTyxJQUFILENBQVFBLEtBQUtkLEdBQWIsRUFBa0IsVUFBUzZaLEtBQVQsRUFBZ0IvWSxJQUFoQixFQUFzQjtBQUNwQyxnQkFBSStZLEtBQUosRUFBVTtBQUNOLHVCQUFPMW5CLFFBQVFzbkIsSUFBUixDQUFhSSxLQUFiLENBQVA7QUFDSDtBQUNELGdCQUFJQyxXQUFXcHBCLGdCQUFnQm9RLElBQWhCLENBQWY7O0FBRUEsaUJBQUssSUFBSTRCLEdBQVQsSUFBZ0JvWCxRQUFoQixFQUEwQjtBQUN0QixvQkFBSUMsVUFBVXBVLGNBQWNqRCxHQUFkLENBQWQ7O0FBRUFqTSx5QkFBU3NqQixPQUFULEVBQWtCVixLQUFsQixHQUEwQmxYLFNBQTFCO0FBQ0ExTCx5QkFBU3NqQixPQUFULEVBQWtCK0YsS0FBbEIsR0FBMEIzZCxTQUExQjtBQUNBMUwseUJBQVNzakIsT0FBVCxFQUFrQlgsVUFBbEIsR0FBK0JqWCxTQUEvQjtBQUNBMUwseUJBQVNzakIsT0FBVCxFQUFrQnhLLFFBQWxCLEdBQTZCLEVBQTdCOztBQUVBL0osdUJBQU9DLE1BQVAsQ0FBYyxJQUFkLEVBQW9CaFAsU0FBU3NqQixPQUFULENBQXBCLEVBQXVDRCxTQUFTcFgsR0FBVCxDQUF2QztBQUNBak0seUJBQVNzakIsT0FBVCxFQUFrQi9VLFVBQWxCLEdBQStCLEtBQS9CO0FBQ0F2Tyx5QkFBU3NqQixPQUFULEVBQWtCOVUsV0FBbEIsR0FBZ0MsQ0FBQyxFQUFELEVBQUssRUFBTCxDQUFoQztBQUNBeE8seUJBQVNzakIsT0FBVCxFQUFrQjdVLFFBQWxCLEdBQTZCLEtBQTdCO0FBQ0F6Tyx5QkFBU3NqQixPQUFULEVBQWtCNVUsUUFBbEIsR0FBNkIsQ0FBQyxFQUFELEVBQUssRUFBTCxDQUE3Qjs7QUFFQSxvQkFBSTFPLFNBQVNzakIsT0FBVCxFQUFrQjBELEtBQWxCLElBQTJCLENBQS9CLEVBQWtDO0FBQzlCMkIsNkJBQVMvYyxJQUFULENBQWM1TCxTQUFTc2pCLE9BQVQsRUFBa0J2WixJQUFoQztBQUNBL0osNkJBQVNzakIsT0FBVCxFQUFrQjNVLE9BQWxCLEdBQTRCLElBQTVCO0FBQ0g7QUFDSjtBQUNEMmE7O0FBRUFoYSxtQkFBTzNSLFNBQVA7QUFDSCxTQTVCRDs7QUE4QkF3ckIsZUFBT1IsUUFBUDtBQUNIOztBQUVEcGtCLGdCQUFZNEMsS0FBWixHQTlKOEIsQ0E4SlQ7QUFDckJ1RyxvQkFBZ0JoQixPQUFoQixFQUF5QlcsR0FBekIsRUFBOEJxYixtQkFBOUIsRUFBbUQ7QUFBQSxlQUFPbmtCLFlBQVk0VyxJQUFaLEVBQVA7QUFBQSxLQUFuRCxFQUE4RXZPLFdBQTlFO0FBQ0g7O0FBRUQsU0FBU2UsY0FBVCxDQUF3QnhGLElBQXhCLEVBQThCO0FBQzlCek0sWUFBUUMsR0FBUixDQUFZd00sSUFBWjtBQUNJLFdBQU8sSUFBSWdCLE9BQUosQ0FBWSxVQUFDQyxPQUFELEVBQVVrQixDQUFWLEVBQWdCO0FBQy9CaE0sZUFBTzZKLEtBQUtnWSxPQUFMLENBQWFDLE9BQWIsSUFBd0I5aEIsSUFBL0I7QUFDQXVQLGVBQU9DLElBQVAsQ0FBWTNGLEtBQUt1UyxTQUFqQixFQUE0QnRJLE9BQTVCLENBQW9DO0FBQUEsbUJBQUszVSxXQUFXNUIsQ0FBWCxJQUFnQnNNLEtBQUt1UyxTQUFMLENBQWU3ZSxDQUFmLENBQXJCO0FBQUEsU0FBcEM7QUFDQXVOO0FBQ0gsS0FKTSxDQUFQO0FBS0g7O0FBRUQ7QUFDQSxTQUFTa2dCLE1BQVQsR0FBa0I7QUFDZHJ0QixPQUFHK0osTUFBSCxDQUFVLE9BQVYsRUFDS2tDLFNBREwsQ0FDZSxLQURmLEVBRUtNLE1BRkw7QUFHQXZNLE9BQUcrSixNQUFILENBQVUsT0FBVixFQUNLa0MsU0FETCxDQUNlLEtBRGYsRUFFS00sTUFGTDtBQUdBeEksYUFBU29TLE9BQVQsQ0FBaUI7QUFBQSxlQUFLeEIsRUFBRW5DLFFBQUYsR0FBYW1DLEVBQUVyQyxVQUFGLEdBQWUsS0FBakM7QUFBQSxLQUFqQjtBQUNIOztBQUVELElBQUl1TixVQUFVLFNBQVZBLE9BQVUsQ0FBQzlLLEdBQUQsRUFBTTZLLEtBQU4sRUFBZ0I7QUFDMUJwZCxhQUFTbU4sSUFBVCxDQUFjLENBQUNvRixNQUFNLElBQVAsRUFBYUssTUFBYixDQUFvQndLLE1BQU0sQ0FBTixDQUFwQixDQUFkO0FBQ0Esc0JBQUVoSyxNQUFGO0FBQ0gsQ0FIRDs7QUFLQSxTQUFTdVgsVUFBVCxHQUFzQjtBQUNsQm50QixPQUFHK0osTUFBSCxDQUFVLDZCQUFWLEVBQXlDa0MsU0FBekMsQ0FBbUQsR0FBbkQsRUFDS00sTUFETDtBQUVBdk0sT0FBRytKLE1BQUgsQ0FBVSw2QkFBVixFQUF5Q2tDLFNBQXpDLENBQW1ELEdBQW5ELEVBQ0tDLElBREwsQ0FDVTFKLFFBRFYsRUFFSzJKLEtBRkwsR0FHS0MsTUFITCxDQUdZLEdBSFosRUFJS0MsSUFKTCxDQUlVO0FBQUEsZUFBS0MsQ0FBTDtBQUFBLEtBSlY7QUFLSDs7QUFFRDtBQUNPLElBQUl3UixnQ0FBWSxTQUFaQSxTQUFZLEdBQU07QUFDekIsUUFBSXdQLEtBQUssY0FBY2xZLE1BQWQsQ0FBcUJsVCxPQUFyQixDQUFUO0FBQ0E7QUFDQTRRLFdBQU82VixFQUFQLENBQVVDLE9BQVYsR0FBb0IsWUFBVztBQUMzQixhQUFLaE0sSUFBTCxDQUFVLFVBQUNsTixDQUFELEVBQUlvWixDQUFKLEVBQVU7QUFDaEIsZ0JBQUlqVSxNQUFNOUwsU0FBU2lWLFdBQVQsQ0FBcUIsYUFBckIsQ0FBVjtBQUNBbkosZ0JBQUltVSxjQUFKLENBQW1CLFdBQW5CLEVBQWdDLElBQWhDLEVBQXNDLElBQXRDLEVBQTRDM2UsTUFBNUMsRUFBb0QsQ0FBcEQsRUFBdUQsQ0FBdkQsRUFBMEQsQ0FBMUQsRUFBNkQsQ0FBN0QsRUFBZ0UsQ0FBaEUsRUFBbUUsS0FBbkUsRUFBMEUsS0FBMUUsRUFBaUYsS0FBakYsRUFBd0YsS0FBeEYsRUFBK0YsQ0FBL0YsRUFBa0csSUFBbEc7QUFDQXllLGNBQUUzSyxhQUFGLENBQWdCdEosR0FBaEI7QUFDSCxTQUpEO0FBS0gsS0FORDtBQU9BekssTUFBRWtqQixFQUFGLEVBQU0xRSxPQUFOO0FBQ0E1b0IsT0FBRytKLE1BQUgsQ0FBVXVqQixFQUFWLEVBQ0s3USxPQURMLENBQ2EsUUFEYixFQUN1QixLQUR2QjtBQUVILENBYk07O0FBa0JQO0FBQ08sU0FBUzdkLFVBQVQsR0FBc0I7QUFDekIsUUFBSTJ1QixpQkFBZ0I3SyxXQUFXamdCLFFBQVFrQixVQUFuQixDQUFwQjs7QUFFQSxRQUFJNk0sVUFBVS9DLEtBQUtFLFNBQUwsQ0FBZTRmLGNBQWYsQ0FBZDs7QUFFQSxRQUFJOWMsVUFBVUMsU0FBUyxhQUF2QjtBQUNBLFFBQUlDLGNBQWMsaUJBQWlCSCxPQUFuQztBQUNBL1EsWUFBUUMsR0FBUixDQUFZLGNBQVo7QUFDQUQsWUFBUUMsR0FBUixDQUFZaVIsV0FBWjtBQUNBbFIsWUFBUUMsR0FBUixDQUFZLFdBQVosRUFBeUIrUSxPQUF6Qjs7QUFFQSxhQUFTK2MsVUFBVCxDQUFvQnBjLEdBQXBCLEVBQXlCcWMsUUFBekIsRUFBbUM7QUFDL0JodUIsZ0JBQVFDLEdBQVIsQ0FBWSt0QixRQUFaO0FBQ0g7O0FBRUQsYUFBU0MsT0FBVCxDQUFpQnRjLEdBQWpCLEVBQXNCO0FBQ2xCM1IsZ0JBQVFDLEdBQVIsQ0FBWSxvQkFBWjtBQUNIOztBQUVEK1Isb0JBQWdCaEIsT0FBaEIsRUFBeUIsVUFBekIsRUFBcUMrYyxVQUFyQyxFQUFpREUsT0FBakQsRUFBMEQvYyxXQUExRDtBQUNIOztBQUVEO0FBQ0E7QUFDTyxTQUFTOVIsYUFBVCxHQUF5QjtBQUM1QixRQUFJeVMsVUFBVW9SLFdBQVdqZ0IsUUFBUWtCLFVBQW5CLENBQWQ7QUFDQSxRQUFJZ3FCLHNCQUFvQixFQUFDcmMsZ0JBQUQsRUFBeEI7O0FBRUEsUUFBSWQsVUFBVS9DLEtBQUtFLFNBQUwsQ0FBZWdnQixtQkFBZixDQUFkOztBQUVBLFFBQUlsZCxVQUFVQyxTQUFTLGdCQUF2QjtBQUNBLFFBQUlDLGNBQWMsaUJBQWlCSCxPQUFuQztBQUNBL1EsWUFBUUMsR0FBUixDQUFZLHVCQUFaO0FBQ0FELFlBQVFDLEdBQVIsQ0FBWWlSLFdBQVo7QUFDQWxSLFlBQVFDLEdBQVIsQ0FBWStRLE9BQVo7O0FBRUEsYUFBU21kLGdCQUFULENBQTBCeGMsR0FBMUIsRUFBK0J5YyxrQkFBL0IsRUFBbUQ7QUFDL0NwdUIsZ0JBQVFDLEdBQVIsQ0FBWW11QixrQkFBWjtBQUNBO0FBQ0EsWUFBSUMsUUFBUUQsbUJBQW1CRSxXQUEvQjs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQ0g7O0FBRUQsYUFBU0MsYUFBVCxDQUF1QjVjLEdBQXZCLEVBQTRCO0FBQ3hCM1IsZ0JBQVFDLEdBQVIsQ0FBWSx1QkFBWjtBQUNIOztBQUVEK1Isb0JBQWdCaEIsT0FBaEIsRUFBeUIsVUFBekIsRUFBcUNtZCxnQkFBckMsRUFBdURJLGFBQXZELEVBQXNFcmQsV0FBdEU7QUFDSDs7QUFFRDtBQUNPLFNBQVM3UixlQUFULEdBQTJCO0FBQzlCLFFBQUl3UyxVQUFVb1IsV0FBV2pnQixRQUFRa0IsVUFBbkIsQ0FBZDtBQUNBLFFBQUlzcUIsV0FBV2xsQixTQUFTQyxjQUFULENBQXdCLFdBQXhCLEVBQXFDa2xCLGFBQXJDLENBQW1ELGdCQUFuRCxDQUFmO0FBQ0EsUUFBR0QsWUFBWSxJQUFmLEVBQXFCO0FBQUN0a0IsY0FBTSx5Q0FBTixFQUFrRDtBQUFRO0FBQ2hGLFFBQUk4VyxhQUFXd04sU0FBUzFNLFVBQVQsQ0FBb0JDLFNBQW5DOztBQUVBbE87QUFDQTdRLFlBQVE4QixXQUFSLEdBQXNCQSxXQUF0QjtBQUNBLFFBQUlpTSxVQUFVL0MsS0FBS0UsU0FBTCxDQUFlbEwsT0FBZixDQUFkOztBQUVBLFFBQUkwckIsa0JBQWtCQyxXQUFXM3JCLFFBQVFPLEtBQW5CLEVBQXlCLGNBQXpCLENBQXRCO0FBQ0EsUUFBSWtKLE9BQU8sRUFBWDs7QUFFQTtBQUNBO0FBQ0EsU0FBSSxJQUFJd0QsSUFBRyxDQUFYLEVBQWNBLElBQUVqTixRQUFRTyxLQUFSLENBQWNtSCxNQUE5QixFQUFzQ3VGLEdBQXRDLEVBQTJDO0FBQ3ZDLFlBQUkyZSxTQUFTLEVBQWI7QUFDQSxZQUFJQyxTQUFTdnFCLFNBQVNrUCxjQUFjeFEsUUFBUU8sS0FBUixDQUFjME0sQ0FBZCxDQUFkLENBQVQsRUFBMEN3YSxJQUF2RDtBQUNBLFlBQUd6bkIsUUFBUWUsS0FBUixDQUFja00sQ0FBZCxFQUFpQixDQUFqQixLQUFxQixFQUF4QixFQUE0QjtBQUN4QjJlLG1CQUFPLENBQVAsSUFBVUMsTUFBVjtBQUNILFNBRkQsTUFFTyxJQUFHN3JCLFFBQVFlLEtBQVIsQ0FBY2tNLENBQWQsRUFBaUIsQ0FBakIsS0FBcUI0ZSxNQUF4QixFQUErQjtBQUNsQ0QsbUJBQU8sQ0FBUCxJQUFVNXJCLFFBQVFlLEtBQVIsQ0FBY2tNLENBQWQsRUFBaUIsQ0FBakIsQ0FBVjtBQUNIO0FBQ0QsWUFBR2pOLFFBQVFlLEtBQVIsQ0FBY2tNLENBQWQsRUFBaUIsQ0FBakIsS0FBcUIsRUFBeEIsRUFBNEI7QUFDeEIyZSxtQkFBTyxDQUFQLElBQVV0cUIsU0FBU2tQLGNBQWN4USxRQUFRTyxLQUFSLENBQWMwTSxDQUFkLENBQWQsQ0FBVCxFQUEwQ3dhLElBQXBEO0FBQ0gsU0FGRCxNQUVPLElBQUd6bkIsUUFBUWUsS0FBUixDQUFja00sQ0FBZCxFQUFpQixDQUFqQixLQUFxQjRlLE1BQXhCLEVBQStCO0FBQ2xDRCxtQkFBTyxDQUFQLElBQVU1ckIsUUFBUWUsS0FBUixDQUFja00sQ0FBZCxFQUFpQixDQUFqQixDQUFWO0FBQ0g7QUFDRHhELGFBQUt5RCxJQUFMLENBQVUwZSxNQUFWO0FBQ0g7O0FBRUQsUUFBSUUseUJBQXVCLEVBQUNqZCxnQkFBRCxFQUFVbVAsc0JBQVYsRUFBc0IwTixnQ0FBdEIsRUFBdUNqaUIsVUFBdkMsRUFBM0I7O0FBRUFzRSxjQUFVL0MsS0FBS0UsU0FBTCxDQUFlNGdCLHNCQUFmLENBQVY7O0FBRUEsUUFBSTlkLFVBQVVDLFNBQVMsa0JBQXZCO0FBQ0EsUUFBSUMsY0FBYyxpQkFBaUJILE9BQW5DO0FBQ0EvUSxZQUFRQyxHQUFSLENBQVksMEJBQVo7QUFDQUQsWUFBUUMsR0FBUixDQUFZaVIsV0FBWjtBQUNBbFIsWUFBUUMsR0FBUixDQUFZLFdBQVosRUFBeUIrUSxPQUF6Qjs7QUFFQSxhQUFTK2Qsa0JBQVQsQ0FBNEJwZCxHQUE1QixFQUFpQ2tSLHFCQUFqQyxFQUF3RDtBQUNwRDNZLGNBQU0sbUJBQU47QUFDQWxLLGdCQUFRQyxHQUFSLENBQVk0aUIscUJBQVo7QUFDSDs7QUFFRCxhQUFTbU0sZUFBVCxDQUF5QnJkLEdBQXpCLEVBQThCO0FBQzFCM1IsZ0JBQVFDLEdBQVIsQ0FBWSwwQkFBWjtBQUNIOztBQUVEK1Isb0JBQWdCaEIsT0FBaEIsRUFBeUIsVUFBekIsRUFBcUMrZCxrQkFBckMsRUFBeURDLGVBQXpELEVBQTBFOWQsV0FBMUU7QUFDSDs7QUFFRDtBQUNBO0FBQ0EsU0FBU3VMLFlBQVQsQ0FBc0J3QyxJQUF0QixFQUE0QmdRLE9BQTVCLEVBQXFDQyxNQUFyQyxFQUE2QztBQUN6QyxRQUFJcmQsVUFBVW9SLFdBQVdqZ0IsUUFBUWtCLFVBQW5CLENBQWQ7QUFDQSxRQUFJaXJCLGdEQUE0QmxRLElBQTVCLEVBQWtDaVEsT0FBT0QsUUFBUWhRLElBQVIsQ0FBUCxFQUFzQixDQUF0QixDQUFsQyxDQUFKO0FBQ0o7QUFDSSxRQUFJbVEsNkJBQTZCLEVBQUNELG9EQUFELEVBQTJCdGQsZ0JBQTNCLEVBQWpDOztBQUVBLFFBQUlkLFVBQVUvQyxLQUFLRSxTQUFMLENBQWVraEIsMEJBQWYsQ0FBZDs7QUFFQSxRQUFJcGUsVUFBVUMsU0FBUyxzQkFBdkI7QUFDQSxRQUFJQyxjQUFjLGlCQUFpQkgsT0FBbkM7QUFDQS9RLFlBQVFDLEdBQVIsQ0FBWSw4QkFBWjtBQUNBRCxZQUFRQyxHQUFSLENBQVlpUixXQUFaO0FBQ0FsUixZQUFRQyxHQUFSLENBQVksV0FBWixFQUF5QitRLE9BQXpCOztBQUVBLGFBQVNxZSxTQUFULENBQW1CMWQsR0FBbkIsRUFBd0JxYyxRQUF4QixFQUFrQztBQUM5Qmh1QixnQkFBUUMsR0FBUixDQUFZK3RCLFFBQVo7QUFDSDs7QUFFRCxhQUFTc0IsTUFBVCxDQUFnQjNkLEdBQWhCLEVBQXFCO0FBQ2pCM1IsZ0JBQVFDLEdBQVIsQ0FBWSxzQkFBWjtBQUNIOztBQUVEK1Isb0JBQWdCaEIsT0FBaEIsRUFBeUIsVUFBekIsRUFBcUNxZSxTQUFyQyxFQUFnREMsTUFBaEQsRUFBd0RwZSxXQUF4RDtBQUNIOztBQUdEO0FBQ0E7QUFDQSxTQUFTa0osYUFBVCxDQUF1Qm1WLEtBQXZCLEVBQTZCO0FBQ3pCLFFBQUlDLE9BQU9ELE1BQU0sQ0FBTixFQUFTLENBQVQsQ0FBWDtBQUFBLFFBQ0lFLE9BQU9GLE1BQU0sQ0FBTixFQUFTLENBQVQsQ0FEWDtBQUFBLFFBRUlHLE9BQU9ILE1BQU0sQ0FBTixFQUFTLENBQVQsQ0FGWDtBQUFBLFFBR0lJLE9BQU9KLE1BQU0sQ0FBTixFQUFTLENBQVQsQ0FIWDtBQUlBLFNBQUksSUFBSWhZLElBQUksQ0FBWixFQUFlQSxJQUFFZ1ksTUFBTTdrQixNQUF2QixFQUErQjZNLEdBQS9CLEVBQW1DO0FBQy9CLFlBQUlnWSxNQUFNaFksQ0FBTixFQUFTLENBQVQsSUFBY2lZLElBQWxCLEVBQXdCQSxPQUFPRCxNQUFNaFksQ0FBTixFQUFTLENBQVQsQ0FBUDtBQUN4QixZQUFJZ1ksTUFBTWhZLENBQU4sRUFBUyxDQUFULElBQWNtWSxJQUFsQixFQUF3QkEsT0FBT0gsTUFBTWhZLENBQU4sRUFBUyxDQUFULENBQVA7QUFDeEIsWUFBSWdZLE1BQU1oWSxDQUFOLEVBQVMsQ0FBVCxJQUFja1ksSUFBbEIsRUFBd0JBLE9BQU9GLE1BQU1oWSxDQUFOLEVBQVMsQ0FBVCxDQUFQO0FBQ3hCLFlBQUlnWSxNQUFNaFksQ0FBTixFQUFTLENBQVQsSUFBY29ZLElBQWxCLEVBQXdCQSxPQUFPSixNQUFNaFksQ0FBTixFQUFTLENBQVQsQ0FBUDtBQUMzQjtBQUNHLFdBQU0sQ0FBQyxDQUFDaVksT0FBT0MsSUFBUixJQUFjLENBQWYsRUFBa0IsQ0FBQ0MsT0FBT0MsSUFBUixJQUFjLENBQWhDLENBQU47QUFDUDs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxTQUFTL1QsZUFBVCxDQUF5Qi9PLENBQXpCLEVBQTJCO0FBQ3ZCLFFBQUdBLEVBQUVxRyxNQUFGLElBQVlyRyxFQUFFc0csTUFBakIsRUFBd0I7QUFBSTtBQUN4QixZQUFJeWMsWUFBWSxDQUFoQjtBQUNBLFlBQUlDLE1BQU9oakIsRUFBRXFHLE1BQUgsR0FBYWxRLFFBQVFTLE9BQVIsQ0FBZ0JpSCxNQUE3QixHQUFzQyxDQUFoRCxDQUZvQixDQUVvQztBQUN4RCxZQUFJb2xCLE1BQU9qakIsRUFBRXNHLE1BQUgsR0FBYW5RLFFBQVFVLE9BQVIsQ0FBZ0JnSCxNQUE3QixHQUFzQyxDQUFoRCxDQUhvQixDQUdvQztBQUN4RCxZQUFJcWxCLFFBQVExdEIsS0FBSytvQixHQUFMLENBQVN5RSxHQUFULEVBQWFDLEdBQWIsQ0FBWixDQUpvQixDQUlnRTtBQUNwRixlQUFRQyxRQUFNSCxTQUFQLEdBQW9CenRCLE9BQUtFLEtBQUtvWSxJQUFMLENBQVVtVixZQUFVRyxLQUFwQixDQUF6QixHQUFzRDV0QixJQUE3RCxDQUxvQixDQUtnRTtBQUN2RixLQU5ELE1BTUs7QUFDRCxtQkFBT0EsSUFBUCxDQURDLENBQ21GO0FBQ3ZGO0FBQ0o7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsU0FBUzBhLGVBQVQsQ0FBeUJoUSxDQUF6QixFQUEyQjtBQUN2QixRQUFHQSxFQUFFcUcsTUFBRixJQUFZckcsRUFBRXNHLE1BQWpCLEVBQXdCO0FBQ3BCLFlBQUd0RyxFQUFFdUcsU0FBTCxFQUFlO0FBQXlDO0FBQ3BELG1CQUFPLENBQUMsSUFBUjtBQUNIO0FBQ0QsWUFBSXdjLFlBQVksQ0FBaEI7QUFDQSxZQUFJQyxNQUFPaGpCLEVBQUVxRyxNQUFILEdBQWFsUSxRQUFRUyxPQUFSLENBQWdCaUgsTUFBN0IsR0FBc0MsQ0FBaEQsQ0FMb0IsQ0FLb0M7QUFDeEQsWUFBSW9sQixNQUFPampCLEVBQUVzRyxNQUFILEdBQWFuUSxRQUFRVSxPQUFSLENBQWdCZ0gsTUFBN0IsR0FBc0MsQ0FBaEQsQ0FOb0IsQ0FNb0M7QUFDeEQsWUFBSXFsQixRQUFRMXRCLEtBQUsrb0IsR0FBTCxDQUFTeUUsR0FBVCxFQUFhQyxHQUFiLENBQVosQ0FQb0IsQ0FPZ0U7QUFDcEYsZUFBUUMsUUFBTUgsU0FBUCxHQUFvQixDQUFDLEdBQUQsSUFBTUEsWUFBVUcsS0FBaEIsQ0FBcEIsR0FBNkMsQ0FBQyxHQUFyRCxDQVJvQixDQVFnRTtBQUN2RixLQVRELE1BU0s7QUFDRCxlQUFPLENBQUMsR0FBUjtBQUNIO0FBQ0o7O0FBRU0sU0FBU3p3QixnQkFBVCxHQUE0QjtBQUMvQmdLLGFBQVNDLGNBQVQsQ0FBd0IsWUFBeEIsRUFBc0M2TSxTQUF0QyxDQUFnREMsR0FBaEQsQ0FBb0QsaUJBQXBEO0FBQ0FyVyxZQUFRQyxHQUFSLENBQVksTUFBWjtBQUNIOztBQUVELFNBQVNnVyxrQkFBVCxDQUE0QitaLEdBQTVCLEVBQWlDOztBQUU3QixhQUFTQyxTQUFULENBQW1CQyxJQUFuQixFQUF5QjtBQUNyQixZQUFJQyxVQUFVLE1BQUlELEtBQUt4bEIsTUFBdkI7QUFDQXlsQixrQkFBVUEsUUFBUWphLFFBQVIsS0FBcUIsR0FBL0I7QUFDQSxZQUFJa2EsY0FBYyxLQUFsQjtBQUNBLFlBQUlDLGNBQWMsTUFBSUgsS0FBS3hsQixNQUFMLEdBQVksQ0FBaEIsQ0FBbEI7QUFDQTJsQixzQkFBY0EsWUFBWW5hLFFBQVosS0FBeUIsR0FBdkM7QUFDQSxZQUFJb2EsUUFBUWhuQixTQUFTQyxjQUFULENBQXdCLFlBQXhCLEVBQXNDOFYsZ0JBQXRDLENBQXVELGVBQXZELENBQVo7QUFDQTtBQUNBLGFBQUssSUFBSXBQLElBQUksQ0FBYixFQUFnQkEsSUFBSXFnQixNQUFNNWxCLE1BQTFCLEVBQWtDdUYsR0FBbEMsRUFBdUM7QUFDbkNxZ0Isa0JBQU1yZ0IsQ0FBTixFQUFTekYsS0FBVCxDQUFlL0IsS0FBZixHQUFxQjBuQixPQUFyQjtBQUNBRyxrQkFBTXJnQixDQUFOLEVBQVNzZ0IsZ0JBQVQsQ0FBMEIsV0FBMUIsRUFBdUMsWUFBVztBQUN4QixxQkFBSSxJQUFJaFosSUFBSSxDQUFaLEVBQWVBLElBQUkrWSxNQUFNNWxCLE1BQXpCLEVBQWlDNk0sR0FBakMsRUFBc0M7QUFDdEMrWSwwQkFBTS9ZLENBQU4sRUFBUy9NLEtBQVQsQ0FBZS9CLEtBQWYsR0FBcUI0bkIsV0FBckI7QUFDQztBQUNELHFCQUFLN2xCLEtBQUwsQ0FBVy9CLEtBQVgsR0FBaUIybkIsV0FBakI7QUFDQyxhQUwzQjtBQU1BRSxrQkFBTXJnQixDQUFOLEVBQVNzZ0IsZ0JBQVQsQ0FBMEIsVUFBMUIsRUFBc0MsWUFBVztBQUN2QixxQkFBSSxJQUFJaFosSUFBSSxDQUFaLEVBQWVBLElBQUkrWSxNQUFNNWxCLE1BQXpCLEVBQWlDNk0sR0FBakMsRUFBc0M7QUFDdEMrWSwwQkFBTS9ZLENBQU4sRUFBUy9NLEtBQVQsQ0FBZS9CLEtBQWYsR0FBcUIwbkIsT0FBckI7QUFDQztBQUNBLGFBSjNCO0FBS0g7QUFFSjs7QUFFRCxRQUFHSCxPQUFLLE9BQVIsRUFBaUI7O0FBRWIxbUIsaUJBQVNDLGNBQVQsQ0FBd0IsV0FBeEIsRUFBcUM2TSxTQUFyQyxDQUErQ0MsR0FBL0MsQ0FBbUQsUUFBbkQ7QUFDQS9NLGlCQUFTQyxjQUFULENBQXdCLFNBQXhCLEVBQW1DNk0sU0FBbkMsQ0FBNkNDLEdBQTdDLENBQWlELFFBQWpEO0FBQ0EvTSxpQkFBU0MsY0FBVCxDQUF3QixZQUF4QixFQUFzQzZNLFNBQXRDLENBQWdEQyxHQUFoRCxDQUFvRCxRQUFwRDs7QUFHQSxZQUFJbWEsU0FBU2xuQixTQUFTQyxjQUFULENBQXdCLG1CQUF4QixFQUE2QzhWLGdCQUE3QyxDQUE4RCxtQkFBOUQsQ0FBYjtBQUNBNFEsa0JBQVVPLE1BQVY7QUFHSCxLQVhELE1BV08sSUFBSVIsT0FBSyxLQUFULEVBQWdCO0FBQ25CO0FBQ0EsWUFBSVEsVUFBU2xuQixTQUFTQyxjQUFULENBQXdCLG1CQUF4QixFQUE2QzhWLGdCQUE3QyxDQUE4RCxTQUE5RCxDQUFiO0FBQ0EsYUFBSyxJQUFJcFAsSUFBSSxDQUFiLEVBQWdCQSxJQUFJdWdCLFFBQU85bEIsTUFBM0IsRUFBbUN1RixHQUFuQyxFQUF3QztBQUNwQ3VnQixvQkFBT3ZnQixDQUFQLEVBQVVtRyxTQUFWLENBQW9CdEosTUFBcEIsQ0FBMkIsUUFBM0I7QUFDSDs7QUFFRDtBQUNBeEQsaUJBQVNDLGNBQVQsQ0FBd0IsV0FBeEIsRUFBcUM2TSxTQUFyQyxDQUErQ0MsR0FBL0MsQ0FBbUQsUUFBbkQ7O0FBRUE7QUFDQSxZQUFHeFQsUUFBSCxFQUNJeUcsU0FBU0MsY0FBVCxDQUF3QixTQUF4QixFQUFtQzZNLFNBQW5DLENBQTZDQyxHQUE3QyxDQUFpRCxRQUFqRDs7QUFFSjtBQUNBbWEsa0JBQVNsbkIsU0FBU0MsY0FBVCxDQUF3QixtQkFBeEIsRUFBNkM4VixnQkFBN0MsQ0FBOEQsbUJBQTlELENBQVQ7QUFDQTRRLGtCQUFVTyxPQUFWO0FBRUg7QUFDRCxRQUFHUixPQUFLLFFBQVIsRUFBa0I7QUFDZDFtQixpQkFBU0MsY0FBVCxDQUF3QixXQUF4QixFQUFxQ2lCLEtBQXJDLENBQTJDbUssT0FBM0MsR0FBcUQsUUFBckQ7QUFDQXJMLGlCQUFTQyxjQUFULENBQXdCLFNBQXhCLEVBQW1DaUIsS0FBbkMsQ0FBeUNtSyxPQUF6QyxHQUFtRCxRQUFuRDtBQUNBckwsaUJBQVNDLGNBQVQsQ0FBd0IsWUFBeEIsRUFBc0NpQixLQUF0QyxDQUE0Q21LLE9BQTVDLEdBQXNELFFBQXREOztBQUVBckwsaUJBQVNDLGNBQVQsQ0FBd0IsU0FBeEIsRUFBbUNpQixLQUFuQyxDQUF5Q21LLE9BQXpDLEdBQW1ELE1BQW5EO0FBQ0FyTCxpQkFBU0MsY0FBVCxDQUF3QixZQUF4QixFQUFzQ2lCLEtBQXRDLENBQTRDbUssT0FBNUMsR0FBc0QsTUFBdEQ7QUFDQXJMLGlCQUFTQyxjQUFULENBQXdCLFlBQXhCLEVBQXNDaUIsS0FBdEMsQ0FBNENtSyxPQUE1QyxHQUFzRCxNQUF0RDtBQUNBckwsaUJBQVNDLGNBQVQsQ0FBd0IsWUFBeEIsRUFBc0NpQixLQUF0QyxDQUE0Q21LLE9BQTVDLEdBQXNELE1BQXREO0FBQ0g7QUFDSjs7QUFFTSxTQUFTcFYsZUFBVCxDQUF5Qmt4QixHQUF6QixFQUE4QnpPLFFBQTlCLEVBQXdDO0FBQzNDO0FBQ0E7QUFDQWhpQixZQUFRQyxHQUFSLENBQVl3d0IsR0FBWjtBQUNBLFFBQUlDLFdBQVdELElBQUluTyxZQUFKLENBQWlCcU8saUJBQWpCLENBQW1DQyxNQUFsRDtBQUNBLFFBQUlDLFdBQVcsRUFBZjs7QUFFQSxTQUFJLElBQUk1Z0IsSUFBSSxDQUFaLEVBQWVBLElBQUl5Z0IsU0FBU2htQixNQUE1QixFQUFvQ3VGLEdBQXBDLEVBQXlDO0FBQ3JDNGdCLGlCQUFTM2dCLElBQVQsQ0FBY3lWLE9BQU8rSyxTQUFTemdCLENBQVQsRUFBWTZnQixLQUFuQixDQUFkO0FBQ0g7O0FBRUQ7QUFDQSxRQUFHM3FCLFlBQVkrQixzQkFBc0JDLFFBQWxDLEVBQTRDLENBQTVDLEtBQWtELGdCQUFyRCxFQUF1RTtBQUNuRTNJLG9CQUFZd2lCLFFBQVosRUFBc0I2TyxRQUF0QjtBQUNILEtBRkQsTUFFTztBQUNILFlBQUlFLFFBQVEsUUFBWjtBQUNBLFlBQUlDLFFBQVEsV0FBWjtBQUNBdHhCLHNCQUFjc2lCLFFBQWQsRUFBd0I2TyxRQUF4QixFQUFrQ0UsS0FBbEMsRUFBeUNDLEtBQXpDO0FBRUg7QUFFSjtBQUNNLFNBQVN4eEIsV0FBVCxDQUFzQndpQixRQUF0QixFQUFnQzZPLFFBQWhDLEVBQTBDO0FBQzdDO0FBQ0E3TyxlQUFXNk8sU0FBU3BiLEtBQVQsQ0FBZSxDQUFmLENBQVg7QUFDQSxTQUFJLElBQUl4RixJQUFJLENBQVosRUFBZUEsSUFBSStSLFNBQVN0WCxNQUE1QixFQUFvQ3VGLEdBQXBDLEVBQXlDO0FBQ3JDLFlBQUlnaEIsZUFBZTV1QixLQUFLNnVCLEtBQUwsQ0FBVzd1QixLQUFLOHVCLE1BQUwsTUFBaUIsSUFBSSxDQUFDLENBQUwsR0FBUyxDQUExQixDQUFYLElBQTJDLENBQUMsQ0FBL0Q7QUFDQW5QLGlCQUFTL1IsQ0FBVCxJQUFjK1IsU0FBUy9SLENBQVQsSUFBY2doQixZQUE1QjtBQUNIOztBQUVEOztBQUVBLGFBQVNHLFVBQVQsQ0FBb0J6UCxLQUFwQixFQUEyQjNGLEtBQTNCLEVBQWtDdkgsSUFBbEMsRUFBd0M7QUFDcEMsZUFBT0EsS0FBSzdFLE9BQUwsQ0FBYStSLEtBQWIsTUFBd0IzRixLQUEvQjtBQUNIOztBQUVELFFBQUlxVixXQUFXLEVBQWY7QUFDQSxRQUFJQyxVQUFVLEVBQWQ7O0FBRUE7QUFDRDtBQUNBOztBQUVDO0FBQ0EsUUFBSUMsWUFBWXZQLFNBQVNyTSxNQUFULENBQWdCa2IsUUFBaEIsQ0FBaEI7QUFDQVUsZ0JBQVlBLFVBQVUxVCxNQUFWLENBQWlCdVQsVUFBakIsQ0FBWjtBQUNGOztBQUVFO0FBQ0E7QUFDQSxTQUFJLElBQUluaEIsTUFBSSxDQUFaLEVBQWVBLE1BQUlzaEIsVUFBVTdtQixNQUE3QixFQUFxQ3VGLEtBQXJDLEVBQTBDO0FBQ3RDLFlBQUl1aEIsWUFBWSxFQUFoQjtBQUNBLFlBQUlDLFdBQVcsRUFBZjtBQUNBLGFBQUksSUFBSWxhLElBQUksQ0FBWixFQUFlQSxJQUFJZ2EsVUFBVTdtQixNQUE3QixFQUFxQzZNLEdBQXJDLEVBQTBDO0FBQ3RDOFoscUJBQVNuaEIsSUFBVCxDQUFjLENBQWQ7QUFDQW9oQixvQkFBUXBoQixJQUFSLENBQWEsQ0FBQ3FoQixVQUFVdGhCLEdBQVYsQ0FBRCxHQUFjLEdBQWQsR0FBa0JzaEIsVUFBVWhhLENBQVYsQ0FBL0I7QUFDSDtBQUNKOztBQUVIO0FBQ0U7QUFDQSxTQUFLLElBQUl0SCxNQUFJLENBQWIsRUFBZ0JBLE1BQUkrUixTQUFTdFgsTUFBN0IsRUFBcUN1RixLQUFyQyxFQUEwQztBQUN6QztBQUNBO0FBQ0csWUFBSXdoQixZQUFXLENBQUN6UCxTQUFTL1IsR0FBVCxDQUFELEdBQWEsR0FBYixHQUFpQjRnQixTQUFTNWdCLEdBQVQsQ0FBaEM7QUFDQSxZQUFJeWhCLFVBQVVKLFFBQVExaEIsT0FBUixDQUFnQjZoQixTQUFoQixDQUFkO0FBQ0FKLGlCQUFTSyxPQUFULEtBQXFCLENBQXJCO0FBQ0g7QUFDSDs7QUFFRSxRQUFJQyxXQUFXLEVBQWY7QUFBQSxRQUFtQnpaLE9BQU9xWixVQUFVN21CLE1BQXBDOztBQUVBO0FBQ0EsV0FBTzJtQixTQUFTM21CLE1BQVQsR0FBa0IsQ0FBekI7QUFDSWluQixpQkFBU3poQixJQUFULENBQWNtaEIsU0FBUzlhLE1BQVQsQ0FBZ0IsQ0FBaEIsRUFBbUIyQixJQUFuQixDQUFkO0FBREosS0FuRDZDLENBc0Q5Qzs7QUFFQztBQUNBelksb0JBQWdCa3lCLFFBQWhCLEVBQTBCSixTQUExQjtBQUNIO0FBQ00sU0FBUzl4QixlQUFULENBQXlCbXlCLFVBQXpCLEVBQXFDQyxPQUFyQyxFQUE4QztBQUNqRHR4QixPQUFHK0osTUFBSCxDQUFVLGFBQVYsRUFBeUJrRixJQUF6QixDQUE4QixFQUE5QjtBQUNBalAsT0FBRytKLE1BQUgsQ0FBVSxhQUFWLEVBQXlCQSxNQUF6QixDQUFnQyxLQUFoQyxFQUF1Q3dDLE1BQXZDOztBQUVBO0FBQ0EsUUFBSWdsQixZQUFZeG9CLFNBQVNDLGNBQVQsQ0FBd0IsTUFBeEIsRUFBZ0N3b0IsV0FBaEQ7QUFDQSxRQUFJQyxhQUFhMW9CLFNBQVNDLGNBQVQsQ0FBd0IsTUFBeEIsRUFBZ0Mwb0IsWUFBakQ7O0FBRUEsUUFBSUMsU0FBUzVvQixTQUFTK2IsYUFBVCxDQUF1QixLQUF2QixDQUFiO0FBQ0E2TSxXQUFPMW9CLEVBQVAsR0FBVSxvQkFBVjtBQUNBMG9CLFdBQU8xbkIsS0FBUCxDQUFhbUssT0FBYixHQUFxQixjQUFyQjtBQUNBdWQsV0FBTzFuQixLQUFQLENBQWEvQixLQUFiLEdBQW1CLEVBQUVxcEIsWUFBVSxHQUFaLElBQWlCLElBQXBDO0FBQ0FJLFdBQU8xbkIsS0FBUCxDQUFhMm5CLFVBQWIsR0FBd0IsTUFBeEI7QUFDQUQsV0FBTzFuQixLQUFQLENBQWE5QixNQUFiLEdBQW9CLEVBQUVzcEIsYUFBVyxFQUFiLElBQWlCLElBQXJDO0FBQ0FFLFdBQU8xbkIsS0FBUCxDQUFhNG5CLEtBQWIsR0FBbUIsTUFBbkI7QUFDQTlvQixhQUFTQyxjQUFULENBQXdCLFlBQXhCLEVBQXNDK2IsV0FBdEMsQ0FBa0Q0TSxNQUFsRDs7QUFFQSxRQUFJRyxTQUFTL29CLFNBQVMrYixhQUFULENBQXVCLEtBQXZCLENBQWI7QUFDQWdOLFdBQU83b0IsRUFBUCxHQUFVLGlCQUFWO0FBQ0E2b0IsV0FBTzduQixLQUFQLENBQWEvQixLQUFiLEdBQW1CLEVBQUVxcEIsWUFBVSxHQUFaLElBQWlCLElBQXBDO0FBQ0FPLFdBQU83bkIsS0FBUCxDQUFhMm5CLFVBQWIsR0FBd0IsTUFBeEI7QUFDQUUsV0FBTzduQixLQUFQLENBQWE5QixNQUFiLEdBQW9CLEVBQUVzcEIsYUFBVyxFQUFiLElBQWlCLElBQXJDO0FBQ0FLLFdBQU83bkIsS0FBUCxDQUFhbUssT0FBYixHQUFxQixjQUFyQjs7QUFFQXJMLGFBQVNDLGNBQVQsQ0FBd0IsWUFBeEIsRUFBc0MrYixXQUF0QyxDQUFrRCtNLE1BQWxEOztBQUdBLFFBQUlDLFNBQVMsRUFBQ3RkLEtBQUssRUFBTixFQUFVZ0QsT0FBTyxFQUFqQixFQUFxQnVhLFFBQVEsQ0FBN0IsRUFBZ0N4YSxNQUFNLEVBQXRDLEVBQWI7O0FBRUEsYUFBU3lhLE1BQVQsQ0FBZ0JDLE9BQWhCLEVBQXlCOztBQUVyQixZQUFJaHFCLFFBQVFncUIsUUFBUWhxQixLQUFwQjtBQUFBLFlBQ0FDLFNBQVMrcEIsUUFBUS9wQixNQURqQjtBQUFBLFlBRUErRCxPQUFPZ21CLFFBQVFobUIsSUFGZjtBQUFBLFlBR0FpbUIsWUFBWUQsUUFBUUMsU0FIcEI7QUFBQSxZQUlBQyxhQUFhRixRQUFRRyxNQUpyQjtBQUFBLFlBS0FDLGFBQWFKLFFBQVFLLFdBTHJCO0FBQUEsWUFNQUMsV0FBV04sUUFBUU8sU0FObkI7O0FBUUEsWUFBSUMsY0FBY1IsUUFBUVEsV0FBMUI7O0FBRUEsWUFBRyxDQUFDeG1CLElBQUosRUFBUztBQUNMLGtCQUFNLElBQUl0QyxLQUFKLENBQVUsa0JBQVYsQ0FBTjtBQUNIOztBQUVELFlBQUcsQ0FBQ2lQLE1BQU1xVCxPQUFOLENBQWNoZ0IsSUFBZCxDQUFELElBQXdCLENBQUNBLEtBQUsvQixNQUE5QixJQUF3QyxDQUFDME8sTUFBTXFULE9BQU4sQ0FBY2hnQixLQUFLLENBQUwsQ0FBZCxDQUE1QyxFQUFtRTtBQUMvRCxrQkFBTSxJQUFJdEMsS0FBSixDQUFVLDBCQUFWLENBQU47QUFDSDs7QUFFRCxZQUFJK29CLFdBQVczeUIsR0FBRzZxQixHQUFILENBQU8zZSxJQUFQLEVBQWEsVUFBUzBtQixLQUFULEVBQWdCO0FBQUUsbUJBQU81eUIsR0FBRzZxQixHQUFILENBQU8rSCxLQUFQLEVBQWMsVUFBU3RtQixDQUFULEVBQVk7QUFBRSx1QkFBT0EsQ0FBUDtBQUFXLGFBQXZDLENBQVA7QUFBa0QsU0FBakYsQ0FBZjtBQUNBLFlBQUl1bUIsV0FBVzd5QixHQUFHd2EsR0FBSCxDQUFPdE8sSUFBUCxFQUFhLFVBQVMwbUIsS0FBVCxFQUFnQjtBQUFFLG1CQUFPNXlCLEdBQUd3YSxHQUFILENBQU9vWSxLQUFQLEVBQWMsVUFBU3RtQixDQUFULEVBQVk7QUFBRSx1QkFBT0EsQ0FBUDtBQUFXLGFBQXZDLENBQVA7QUFBa0QsU0FBakYsQ0FBZjs7QUFFQSxZQUFJd21CLFVBQVU1bUIsS0FBSy9CLE1BQW5CO0FBQ0EsWUFBSTRvQixVQUFVN21CLEtBQUssQ0FBTCxFQUFRL0IsTUFBdEI7O0FBRUEsWUFBSWxDLE1BQU1qSSxHQUFHK0osTUFBSCxDQUFVb29CLFNBQVYsRUFBcUIvbEIsTUFBckIsQ0FBNEIsS0FBNUIsRUFDVHlILElBRFMsQ0FDSixPQURJLEVBQ0szTCxRQUFRNnBCLE9BQU92YSxJQUFmLEdBQXNCdWEsT0FBT3RhLEtBRGxDLEVBRVQ1RCxJQUZTLENBRUosUUFGSSxFQUVNMUwsU0FBUzRwQixPQUFPdGQsR0FBaEIsR0FBc0JzZCxPQUFPQyxNQUZuQyxFQUdUNWxCLE1BSFMsQ0FHRixHQUhFLEVBSVR5SCxJQUpTLENBSUosV0FKSSxFQUlTLGVBQWVrZSxPQUFPdmEsSUFBdEIsR0FBNkIsR0FBN0IsR0FBbUN1YSxPQUFPdGQsR0FBMUMsR0FBZ0QsR0FKekQsQ0FBVjs7QUFNQSxZQUFJdWUsYUFBYS9xQixJQUFJbUUsTUFBSixDQUFXLE1BQVgsRUFDaEJuQyxLQURnQixDQUNWLFFBRFUsRUFDQSxPQURBLEVBRWhCQSxLQUZnQixDQUVWLGNBRlUsRUFFTSxLQUZOLEVBR2hCNEosSUFIZ0IsQ0FHWCxPQUhXLEVBR0YzTCxLQUhFLEVBSWhCMkwsSUFKZ0IsQ0FJWCxRQUpXLEVBSUQxTCxNQUpDLENBQWpCOztBQU1BLFlBQUlpTyxJQUFJcFcsR0FBR0MsS0FBSCxDQUFTZ3pCLE9BQVQsR0FDUEMsTUFETyxDQUNBbHpCLEdBQUdtekIsS0FBSCxDQUFTSixPQUFULENBREEsRUFFUEssVUFGTyxDQUVJLENBQUMsQ0FBRCxFQUFJbHJCLEtBQUosQ0FGSixDQUFSOztBQUlBLFlBQUlrUixJQUFJcFosR0FBR0MsS0FBSCxDQUFTZ3pCLE9BQVQsR0FDUEMsTUFETyxDQUNBbHpCLEdBQUdtekIsS0FBSCxDQUFTTCxPQUFULENBREEsRUFFUE0sVUFGTyxDQUVJLENBQUMsQ0FBRCxFQUFJanJCLE1BQUosQ0FGSixDQUFSOztBQUlBLFlBQUlrckIsV0FBV3J6QixHQUFHQyxLQUFILENBQVNxekIsTUFBVCxHQUNkSixNQURjLENBQ1AsQ0FBQ0wsUUFBRCxFQUFVRixRQUFWLENBRE8sRUFFZFEsS0FGYyxDQUVSLENBQUNiLFVBQUQsRUFBYUUsUUFBYixDQUZRLENBQWY7O0FBSUEsWUFBSXJSLE1BQU1sWixJQUFJZ0UsU0FBSixDQUFjLE1BQWQsRUFDVEMsSUFEUyxDQUNKQSxJQURJLEVBRVRDLEtBRlMsR0FFREMsTUFGQyxDQUVNLEdBRk4sRUFHVHlILElBSFMsQ0FHSixPQUhJLEVBR0ssS0FITCxFQUlUQSxJQUpTLENBSUosV0FKSSxFQUlTLFVBQVN2SCxDQUFULEVBQVlvRCxDQUFaLEVBQWU7QUFBRSxtQkFBTyxpQkFBaUIwSixFQUFFMUosQ0FBRixDQUFqQixHQUF3QixHQUEvQjtBQUFxQyxTQUovRCxDQUFWOztBQU1BLFlBQUk2akIsT0FBT3BTLElBQUlsVixTQUFKLENBQWMsT0FBZCxFQUNWQyxJQURVLENBQ0wsVUFBU0ksQ0FBVCxFQUFZO0FBQUUsbUJBQU9BLENBQVA7QUFBVyxTQURwQixFQUVWSCxLQUZVLEdBRUZDLE1BRkUsQ0FFSyxHQUZMLEVBR1Z5SCxJQUhVLENBR0wsT0FISyxFQUdJLE1BSEosRUFJVkEsSUFKVSxDQUlMLFdBSkssRUFJUSxVQUFTdkgsQ0FBVCxFQUFZb0QsQ0FBWixFQUFlO0FBQUUsbUJBQU8sZUFBZTBHLEVBQUUxRyxDQUFGLENBQWYsR0FBc0IsTUFBN0I7QUFBc0MsU0FKL0QsQ0FBWDs7QUFNQTZqQixhQUFLbm5CLE1BQUwsQ0FBWSxNQUFaLEVBQ0N5SCxJQURELENBQ00sT0FETixFQUNldUMsRUFBRW9kLFNBQUYsRUFEZixFQUVDM2YsSUFGRCxDQUVNLFFBRk4sRUFFZ0J1RixFQUFFb2EsU0FBRixFQUZoQixFQUdDdnBCLEtBSEQsQ0FHTyxjQUhQLEVBR3VCLENBSHZCOztBQUtBc3BCLGFBQUtubkIsTUFBTCxDQUFZLE1BQVosRUFDQ3lILElBREQsQ0FDTSxJQUROLEVBQ1ksT0FEWixFQUVDQSxJQUZELENBRU0sR0FGTixFQUVXdUMsRUFBRW9kLFNBQUYsS0FBZ0IsQ0FGM0IsRUFHQzNmLElBSEQsQ0FHTSxHQUhOLEVBR1d1RixFQUFFb2EsU0FBRixLQUFnQixDQUgzQixFQUlDM2YsSUFKRCxDQUlNLGFBSk4sRUFJcUIsUUFKckIsRUFLQzVKLEtBTEQsQ0FLTyxNQUxQLEVBS2UsVUFBU3FDLENBQVQsRUFBWW9ELENBQVosRUFBZTtBQUFFLG1CQUFPcEQsS0FBS3FtQixXQUFTLENBQWQsR0FBa0IsT0FBbEIsR0FBNEIsT0FBbkM7QUFBNkMsU0FMN0UsRUFNQ3RtQixJQU5ELENBTU0sVUFBU0MsQ0FBVCxFQUFZb0QsQ0FBWixFQUFlO0FBQUUsbUJBQU9wRCxDQUFQO0FBQVcsU0FObEM7O0FBUUE2VSxZQUFJbFYsU0FBSixDQUFjLE9BQWQsRUFDQ0MsSUFERCxDQUNNLFVBQVNJLENBQVQsRUFBWW9ELENBQVosRUFBZTtBQUFFLG1CQUFPeEQsS0FBS3dELENBQUwsQ0FBUDtBQUFpQixTQUR4QyxFQUVDekYsS0FGRCxDQUVPLE1BRlAsRUFFZW9wQixRQUZmOztBQUlBO0FBQ0EsWUFBSWhCLFNBQVNwcUIsSUFBSW1FLE1BQUosQ0FBVyxHQUFYLEVBQ1p5SCxJQURZLENBQ1AsT0FETyxFQUNFLFFBREYsQ0FBYjs7QUFHQSxZQUFJNGYsZUFBZXBCLE9BQU9wbUIsU0FBUCxDQUFpQixlQUFqQixFQUNsQkMsSUFEa0IsQ0FDYmttQixVQURhLEVBRWxCam1CLEtBRmtCLEdBRVZDLE1BRlUsQ0FFSCxHQUZHLEVBR2xCeUgsSUFIa0IsQ0FHYixPQUhhLEVBR0osY0FISSxFQUlsQkEsSUFKa0IsQ0FJYixXQUphLEVBSUEsVUFBU3ZILENBQVQsRUFBWW9ELENBQVosRUFBZTtBQUM3QjtBQUNEO0FBQ0UsbUJBQU8sZUFBZTBHLEVBQUUxRyxDQUFGLENBQWYsR0FBc0IsR0FBdEIsSUFBNkJ2SCxTQUFPLEVBQXBDLElBQTBDLEdBQWpEO0FBQXVELFNBUDFDLENBQW5COztBQVNBc3JCLHFCQUFhcm5CLE1BQWIsQ0FBb0IsTUFBcEIsRUFDQ25DLEtBREQsQ0FDTyxRQURQLEVBQ2lCLE9BRGpCLEVBRUNBLEtBRkQsQ0FFTyxjQUZQLEVBRXVCLEtBRnZCLEVBR0M0SixJQUhELENBR00sSUFITixFQUdZdUMsRUFBRW9kLFNBQUYsS0FBZ0IsQ0FINUIsRUFJQzNmLElBSkQsQ0FJTSxJQUpOLEVBSVl1QyxFQUFFb2QsU0FBRixLQUFnQixDQUo1QixFQUtDM2YsSUFMRCxDQUtNLElBTE4sRUFLWSxDQUxaLEVBTUNBLElBTkQsQ0FNTSxJQU5OLEVBTVksQ0FOWjs7QUFRQTRmLHFCQUFhcm5CLE1BQWIsQ0FBb0IsTUFBcEIsRUFDQ3lILElBREQsQ0FDTSxHQUROLEVBQ1csRUFEWCxFQUVDQSxJQUZELENBRU0sR0FGTixFQUVXdUYsRUFBRW9hLFNBQUYsS0FBZ0IsQ0FGM0IsRUFHQzNmLElBSEQsQ0FHTSxJQUhOLEVBR1ksT0FIWixFQUlDQSxJQUpELENBSU0sYUFKTixFQUlxQixLQUpyQixFQUtDQSxJQUxELENBS00sV0FMTixFQUttQixhQUxuQixFQU1DeEgsSUFORCxDQU1NLFVBQVNDLENBQVQsRUFBWW9ELENBQVosRUFBZTtBQUFFLG1CQUFPcEQsQ0FBUDtBQUFXLFNBTmxDOztBQVFBLFlBQUlvbkIsWUFBWXJCLE9BQU9wbUIsU0FBUCxDQUFpQixZQUFqQixFQUNmQyxJQURlLENBQ1ZrbUIsVUFEVSxFQUVmam1CLEtBRmUsR0FFUEMsTUFGTyxDQUVBLEdBRkEsRUFHZnlILElBSGUsQ0FHVixPQUhVLEVBR0QsV0FIQyxFQUlmQSxJQUplLENBSVYsV0FKVSxFQUlHLFVBQVN2SCxDQUFULEVBQVlvRCxDQUFaLEVBQWU7QUFBRSxtQkFBTyxlQUFlLENBQWYsR0FBbUIsR0FBbkIsR0FBeUIwSixFQUFFMUosQ0FBRixDQUF6QixHQUFnQyxHQUF2QztBQUE2QyxTQUpqRSxDQUFoQjs7QUFNQWdrQixrQkFBVXRuQixNQUFWLENBQWlCLE1BQWpCLEVBQ0NuQyxLQURELENBQ08sUUFEUCxFQUNpQixPQURqQixFQUVDQSxLQUZELENBRU8sY0FGUCxFQUV1QixLQUZ2QixFQUdDNEosSUFIRCxDQUdNLElBSE4sRUFHWSxDQUhaLEVBSUNBLElBSkQsQ0FJTSxJQUpOLEVBSVksQ0FBQyxDQUpiLEVBS0NBLElBTEQsQ0FLTSxJQUxOLEVBS1l1RixFQUFFb2EsU0FBRixLQUFnQixDQUw1QixFQU1DM2YsSUFORCxDQU1NLElBTk4sRUFNWXVGLEVBQUVvYSxTQUFGLEtBQWdCLENBTjVCOztBQVFBRSxrQkFBVXRuQixNQUFWLENBQWlCLE1BQWpCLEVBQ0N5SCxJQURELENBQ00sR0FETixFQUNXLENBQUMsQ0FEWixFQUVDQSxJQUZELENBRU0sR0FGTixFQUVXdUYsRUFBRW9hLFNBQUYsS0FBZ0IsQ0FGM0IsRUFHQzNmLElBSEQsQ0FHTSxJQUhOLEVBR1ksT0FIWixFQUlDQSxJQUpELENBSU0sYUFKTixFQUlxQixLQUpyQixFQUtDeEgsSUFMRCxDQUtNLFVBQVNDLENBQVQsRUFBWW9ELENBQVosRUFBZTtBQUFFLG1CQUFPcEQsQ0FBUDtBQUFXLFNBTGxDOztBQU9BLFlBQUkwRCxNQUFNaFEsR0FBRytKLE1BQUgsQ0FBVSxrQkFBVixFQUNUcUMsTUFEUyxDQUNGLEtBREUsRUFFVHlILElBRlMsQ0FFSixPQUZJLEVBRUs2ZSxXQUZMLEVBR1Q3ZSxJQUhTLENBR0osUUFISSxFQUdNMUwsU0FBUzRwQixPQUFPdGQsR0FBaEIsR0FBc0JzZCxPQUFPQyxNQUhuQyxDQUFWOztBQUtBLFlBQUlwVyxTQUFTNUwsSUFDWjVELE1BRFksQ0FDTCxNQURLLEVBRVpBLE1BRlksQ0FFTCxvQkFGSyxFQUdaeUgsSUFIWSxDQUdQLElBSE8sRUFHRCxVQUhDLEVBSVpBLElBSlksQ0FJUCxJQUpPLEVBSUQsTUFKQyxFQUtaQSxJQUxZLENBS1AsSUFMTyxFQUtELElBTEMsRUFNWkEsSUFOWSxDQU1QLElBTk8sRUFNRCxNQU5DLEVBT1pBLElBUFksQ0FPUCxJQVBPLEVBT0QsTUFQQyxFQVFaQSxJQVJZLENBUVAsY0FSTyxFQVFTLEtBUlQsQ0FBYjs7QUFVQStILGVBQ0N4UCxNQURELENBQ1EsTUFEUixFQUVDeUgsSUFGRCxDQUVNLFFBRk4sRUFFZ0IsSUFGaEIsRUFHQ0EsSUFIRCxDQUdNLFlBSE4sRUFHb0IyZSxRQUhwQixFQUlDM2UsSUFKRCxDQUlNLGNBSk4sRUFJc0IsQ0FKdEI7O0FBTUErSCxlQUNDeFAsTUFERCxDQUNRLE1BRFIsRUFFQ3lILElBRkQsQ0FFTSxRQUZOLEVBRWdCLE1BRmhCLEVBR0NBLElBSEQsQ0FHTSxZQUhOLEVBR29CeWUsVUFIcEIsRUFJQ3plLElBSkQsQ0FJTSxjQUpOLEVBSXNCLENBSnRCOztBQU1BN0QsWUFBSTVELE1BQUosQ0FBVyxNQUFYLEVBQ0N5SCxJQURELENBQ00sT0FETixFQUNlNmUsY0FBWSxDQUFaLEdBQWMsRUFEN0IsRUFFQzdlLElBRkQsQ0FFTSxRQUZOLEVBRWdCMUwsTUFGaEIsRUFHQzhCLEtBSEQsQ0FHTyxNQUhQLEVBR2UsZ0JBSGYsRUFJQzRKLElBSkQsQ0FJTSxXQUpOLEVBSW1CLGlCQUFpQmtlLE9BQU90ZCxHQUF4QixHQUE4QixHQUpqRDs7QUFNQTtBQUNBMkUsWUFBSXBaLEdBQUdDLEtBQUgsQ0FBU3F6QixNQUFULEdBQ0hILEtBREcsQ0FDRyxDQUFDaHJCLE1BQUQsRUFBUyxDQUFULENBREgsRUFFSCtxQixNQUZHLENBRUksQ0FBQ0wsUUFBRCxFQUFXRixRQUFYLENBRkosQ0FBSjs7QUFJQSxZQUFJZ0IsUUFBUTN6QixHQUFHaUksR0FBSCxDQUFPMnJCLElBQVAsR0FDWDN6QixLQURXLENBQ0xtWixDQURLLEVBRVh5YSxNQUZXLENBRUosT0FGSSxDQUFaOztBQUlBN2pCLFlBQUk1RCxNQUFKLENBQVcsR0FBWCxFQUNDeUgsSUFERCxDQUNNLE9BRE4sRUFDZSxRQURmLEVBRUNBLElBRkQsQ0FFTSxXQUZOLEVBRW1CLGtCQUFrQmtlLE9BQU90ZCxHQUF6QixHQUErQixHQUZsRCxFQUdDMEgsSUFIRCxDQUdNd1gsS0FITjtBQUtIOztBQUVEO0FBQ0EsYUFBU2pULFFBQVQsQ0FBa0J4VSxJQUFsQixFQUF3QnlVLE9BQXhCLEVBQWlDO0FBQzdCLFlBQUlFLFFBQVE3Z0IsR0FBRytKLE1BQUgsQ0FBVSxhQUFWLEVBQXlCcUMsTUFBekIsQ0FBZ0MsT0FBaEMsRUFDWHlILElBRFcsQ0FDTixPQURNLEVBQ0csa0JBQWtCa2UsT0FBT3ZhLElBQXpCLEdBQStCLElBRGxDLENBQVo7QUFBQSxZQUVBc0osUUFBUUQsTUFBTXpVLE1BQU4sQ0FBYSxPQUFiLENBRlI7QUFBQSxZQUdBMlUsUUFBUUYsTUFBTXpVLE1BQU4sQ0FBYSxPQUFiLENBSFI7O0FBS0E7QUFDQTBVLGNBQU0xVSxNQUFOLENBQWEsSUFBYixFQUNDSCxTQURELENBQ1csSUFEWCxFQUVDQyxJQUZELENBRU15VSxPQUZOLEVBR0N4VSxLQUhELEdBSUNDLE1BSkQsQ0FJUSxJQUpSLEVBS0NDLElBTEQsQ0FLTSxVQUFTMlUsTUFBVCxFQUFpQjtBQUFFLG1CQUFPQSxNQUFQO0FBQWdCLFNBTHpDOztBQU9BO0FBQ0EsWUFBSUMsT0FBT0YsTUFBTTlVLFNBQU4sQ0FBZ0IsSUFBaEIsRUFDVkMsSUFEVSxDQUNMQSxJQURLLEVBRVZDLEtBRlUsR0FHVkMsTUFIVSxDQUdILElBSEcsQ0FBWDs7QUFLQTtBQUNBLFlBQUk4VSxRQUFRRCxLQUFLaFYsU0FBTCxDQUFlLElBQWYsRUFDWEMsSUFEVyxDQUNOLFVBQVNpVixHQUFULEVBQWM7QUFDZCxtQkFBT1IsUUFBUXhILEdBQVIsQ0FBWSxVQUFTNkgsTUFBVCxFQUFpQjtBQUNqQix1QkFBTyxFQUFDQSxRQUFRQSxNQUFULEVBQWlCSSxPQUFPRCxJQUFJSCxNQUFKLENBQXhCLEVBQVA7QUFDQyxhQUZiLENBQVA7QUFHQyxTQUxLLEVBTVg3VSxLQU5XLEdBT1hDLE1BUFcsQ0FPSixJQVBJLEVBUVh5SCxJQVJXLENBUU4sT0FSTSxFQVFHLHNCQVJILEVBUTJCO0FBUjNCLFNBU1g1RSxJQVRXLENBU04sVUFBUzNDLENBQVQsRUFBWTtBQUFFLG1CQUFPQSxFQUFFOFUsS0FBVDtBQUFpQixTQVR6QixDQUFaOztBQVdBLGVBQU9QLEtBQVA7QUFDSDs7QUFJRDtBQUNBO0FBQ0EsUUFBSWlULEtBQUt6QyxXQUFXLENBQVgsRUFBYyxDQUFkLENBQVQ7QUFDQSxRQUFJMUksS0FBSzBJLFdBQVcsQ0FBWCxFQUFjLENBQWQsQ0FBVDtBQUNBLFFBQUkwQyxLQUFLMUMsV0FBVyxDQUFYLEVBQWMsQ0FBZCxDQUFUO0FBQ0EsUUFBSTJDLEtBQUszQyxXQUFXLENBQVgsRUFBYyxDQUFkLENBQVQ7O0FBRUEsUUFBSXpYLElBQUlrYSxLQUFLbkwsRUFBYjtBQUNBLFFBQUloVSxJQUFJb2YsS0FBS0MsRUFBYjs7QUFFQSxRQUFJbnZCLFdBQVcsQ0FBQ2l2QixLQUFHRSxFQUFKLEtBQVNwYSxJQUFFakYsQ0FBWCxDQUFmO0FBQ0EsUUFBSTdQLEtBQUssSUFBRWd2QixFQUFGLElBQU0sSUFBRUEsRUFBRixHQUFLQyxFQUFMLEdBQVFwTCxFQUFkLENBQVQ7QUFDQSxRQUFJc0wsWUFBWUgsTUFBSUEsS0FBR0MsRUFBUCxDQUFoQjtBQUNBLFFBQUlHLFNBQVNKLE1BQUlBLEtBQUduTCxFQUFQLENBQWI7O0FBRUE5akIsZUFBVy9DLEtBQUtxeUIsS0FBTCxDQUFXdHZCLFdBQVcsR0FBdEIsSUFBNkIsR0FBeEM7QUFDQUMsU0FBS2hELEtBQUtxeUIsS0FBTCxDQUFXcnZCLEtBQUssR0FBaEIsSUFBdUIsR0FBNUI7QUFDQW12QixnQkFBWW55QixLQUFLcXlCLEtBQUwsQ0FBV0YsWUFBWSxHQUF2QixJQUE4QixHQUExQztBQUNBQyxhQUFTcHlCLEtBQUtxeUIsS0FBTCxDQUFXRCxTQUFTLEdBQXBCLElBQTJCLEdBQXBDOztBQUVBLFFBQUlFLGVBQWUsRUFBbkI7QUFDQUEsaUJBQWF6a0IsSUFBYixDQUFrQixFQUFDLE1BQUs3SyxFQUFOLEVBQVUsYUFBWW12QixTQUF0QixFQUFnQyxVQUFTQyxNQUF6QyxFQUFnRCxZQUFXcnZCLFFBQTNELEVBQWxCOztBQUVBb3RCLFdBQU87QUFDQUUsbUJBQVkscUJBRFo7QUFFQWptQixjQUFZbWxCLFVBRlo7QUFHQWdCLGdCQUFZZixPQUhaO0FBSUFpQixxQkFBYyxTQUpkO0FBS0FFLG1CQUFZLFNBTFo7QUFNQXZxQixlQUFRcXBCLFlBQVksR0FOcEI7QUFPQXBwQixnQkFBU3NwQixhQUFhLEdBUHRCO0FBUUFpQixxQkFBY25CLFlBQVU7QUFSeEIsS0FBUDs7QUFXQTtBQUNGOztBQUdEOztBQUdEO0FBQ08sU0FBU3B5QixhQUFULENBQXVCazFCLE1BQXZCLEVBQStCQyxNQUEvQixFQUF1Q0MsV0FBdkMsRUFBb0RDLFdBQXBELEVBQWlFOztBQUVwRXgwQixPQUFHK0osTUFBSCxDQUFVLGFBQVYsRUFBeUJrRixJQUF6QixDQUE4QixFQUE5QjtBQUNBalAsT0FBRytKLE1BQUgsQ0FBVSxhQUFWLEVBQXlCQSxNQUF6QixDQUFnQyxLQUFoQyxFQUF1Q3dDLE1BQXZDOztBQUVBLFFBQUlnbEIsWUFBWXhvQixTQUFTQyxjQUFULENBQXdCLE1BQXhCLEVBQWdDd29CLFdBQWhEO0FBQ0EsUUFBSUMsYUFBYTFvQixTQUFTQyxjQUFULENBQXdCLE1BQXhCLEVBQWdDMG9CLFlBQWpEOztBQUVBOztBQUVBLFFBQUkrQyxZQUFZLEVBQWhCO0FBQ0EsUUFBSUMsV0FBVyxDQUFmO0FBQ0EsU0FBSyxJQUFJaGxCLElBQUksQ0FBYixFQUFnQkEsSUFBSTJrQixPQUFPbHFCLE1BQTNCLEVBQW1DdUYsR0FBbkMsRUFBd0M7QUFDcEMsWUFBSTJWLE1BQU1nUCxPQUFPM2tCLENBQVAsQ0FBTixLQUFvQjJWLE1BQU1pUCxPQUFPNWtCLENBQVAsQ0FBTixDQUF4QixFQUEwQztBQUN0Q2dsQjtBQUNILFNBRkQsTUFFTztBQUNILGdCQUFJQyxhQUFhTixPQUFPM2tCLENBQVAsQ0FBakI7QUFDQSxnQkFBSWtsQixhQUFhTixPQUFPNWtCLENBQVAsQ0FBakI7QUFDQStrQixzQkFBVTlrQixJQUFWLENBQWUsRUFBQ2tsQixPQUFPRixVQUFSLEVBQW9CRyxPQUFPRixVQUEzQixFQUF1Q0csT0FBT2p6QixLQUFLOHVCLE1BQUwsS0FBZ0IsR0FBOUQsRUFBZjtBQUVIO0FBQ0o7O0FBR0QsUUFBSW1CLFNBQVMsRUFBQ3RkLEtBQUssRUFBTixFQUFVZ0QsT0FBTyxFQUFqQixFQUFxQnVhLFFBQVEsRUFBN0IsRUFBaUN4YSxNQUFNLEVBQXZDLEVBQWI7QUFBQSxRQUNFdFAsUUFBUXFwQixZQUFVLEdBQVYsR0FBZVEsT0FBT3ZhLElBQXRCLEdBQTZCdWEsT0FBT3RhLEtBRDlDO0FBQUEsUUFFRXRQLFNBQVNvcEIsWUFBVSxHQUFWLEdBQWdCUSxPQUFPdGQsR0FBdkIsR0FBNkJzZCxPQUFPQyxNQUYvQztBQUdBLFFBQUlnRCxVQUFVLEdBQWQ7O0FBRUEsUUFBSUMsUUFBUWoxQixHQUFHd2EsR0FBSCxDQUFPaWEsU0FBUCxFQUFrQixVQUFVbm9CLENBQVYsRUFBYW9ELENBQWIsRUFBZ0I7QUFDM0IsZUFBTytrQixVQUFVL2tCLENBQVYsRUFBYW1sQixLQUFwQjtBQUNDLEtBRlIsQ0FBWjtBQUdBLFFBQUlLLFFBQVFsMUIsR0FBRzZxQixHQUFILENBQU80SixTQUFQLEVBQWtCLFVBQVVub0IsQ0FBVixFQUFhb0QsQ0FBYixFQUFnQjtBQUMzQixlQUFPK2tCLFVBQVUva0IsQ0FBVixFQUFhbWxCLEtBQXBCO0FBQ0MsS0FGUixDQUFaO0FBR0EsUUFBSU0sUUFBUSxDQUFDRCxRQUFRRCxLQUFULElBQWtCLEVBQTlCO0FBQ0EsUUFBSUcsUUFBUXAxQixHQUFHd2EsR0FBSCxDQUFPaWEsU0FBUCxFQUFrQixVQUFVbm9CLENBQVYsRUFBYW9ELENBQWIsRUFBZ0I7QUFDM0IsZUFBTytrQixVQUFVL2tCLENBQVYsRUFBYW9sQixLQUFwQjtBQUNDLEtBRlIsQ0FBWjtBQUdBLFFBQUlPLFFBQVFyMUIsR0FBRzZxQixHQUFILENBQU80SixTQUFQLEVBQWtCLFVBQVVub0IsQ0FBVixFQUFhb0QsQ0FBYixFQUFnQjtBQUMzQixlQUFPK2tCLFVBQVUva0IsQ0FBVixFQUFhb2xCLEtBQXBCO0FBQ0MsS0FGUixDQUFaO0FBR0EsUUFBSVEsUUFBUSxDQUFDRCxRQUFRRCxLQUFULElBQWtCLEVBQTlCOztBQUVBLFFBQUlHLFNBQVN2MUIsR0FBR0MsS0FBSCxDQUFTcXpCLE1BQVQsR0FDWkosTUFEWSxDQUNMLENBQUMrQixRQUFRRSxLQUFULEVBQWdCRCxRQUFRQyxLQUF4QixDQURLLEVBRVpoQyxLQUZZLENBRU4sQ0FBQyxDQUFELEVBQUlqckIsS0FBSixDQUZNLENBQWI7O0FBSUEsUUFBSXN0QixTQUFTeDFCLEdBQUdDLEtBQUgsQ0FBU3F6QixNQUFULEdBQ1pKLE1BRFksQ0FDTCxDQUFDa0MsUUFBUUUsS0FBVCxFQUFnQkQsUUFBUUMsS0FBeEIsQ0FESyxFQUVabkMsS0FGWSxDQUVOLENBQUNockIsTUFBRCxFQUFTLENBQVQsQ0FGTSxDQUFiOztBQUlBLFFBQUlzdEIsUUFBUXoxQixHQUFHaUksR0FBSCxDQUFPMnJCLElBQVAsR0FDWDN6QixLQURXLENBQ0xzMUIsTUFESyxFQUVYMUIsTUFGVyxDQUVKLFFBRkksRUFHWDZCLFFBSFcsQ0FHRixDQUFDdnRCLE1BSEMsQ0FBWjs7QUFLQSxRQUFJd3JCLFFBQVEzekIsR0FBR2lJLEdBQUgsQ0FBTzJyQixJQUFQLEdBQ1gzekIsS0FEVyxDQUNMdTFCLE1BREssRUFFWDNCLE1BRlcsQ0FFSixNQUZJLEVBR1g4QixLQUhXLENBR0wsQ0FISyxFQUlYRCxRQUpXLENBSUYsQ0FBQ3h0QixLQUpDLENBQVo7O0FBTUEsUUFBSTB0QixPQUFPNTFCLEdBQUc2MUIsUUFBSCxDQUFZRCxJQUFaLEdBQ1Z4ZixDQURVLENBQ1JtZixNQURRLEVBRVZuYyxDQUZVLENBRVJvYyxNQUZRLEVBR1ZNLFdBSFUsQ0FHRSxDQUFDLENBQUQsRUFBSSxFQUFKLENBSEYsRUFJVjlwQixFQUpVLENBSVAsTUFKTyxFQUlDK3BCLE1BSkQsQ0FBWDs7QUFNQSxRQUFJQyxnQkFBZ0JoMkIsR0FBRytKLE1BQUgsQ0FBVSxhQUFWLEVBQ25CcUMsTUFEbUIsQ0FDWixTQURZLEVBRW5CeUgsSUFGbUIsQ0FFZCxPQUZjLEVBRUwzTCxRQUFRNnBCLE9BQU90YSxLQUFmLEdBQXVCc2EsT0FBT3ZhLElBRnpCLEVBR25CM0QsSUFIbUIsQ0FHZCxRQUhjLEVBR0oxTCxTQUFTNHBCLE9BQU90ZCxHQUFoQixHQUFzQnNkLE9BQU9DLE1BSHpCLENBQXBCO0FBSUQ7O0FBRUMsUUFBSWlFLFFBQVFELGNBQWM1cEIsTUFBZCxDQUFxQixHQUFyQixFQUNYeUgsSUFEVyxDQUNOLFdBRE0sRUFDTyxlQUFla2UsT0FBT3ZhLElBQXRCLEdBQTZCLEdBQTdCLEdBQW1DdWEsT0FBT3RkLEdBQTFDLEdBQWdELEdBRHZELEVBRVhaLElBRlcsQ0FFTixPQUZNLEVBRUczTCxRQUFPNnBCLE9BQU90YSxLQUFkLEdBQXNCc2EsT0FBT3ZhLElBRmhDLEVBR1gzRCxJQUhXLENBR04sUUFITSxFQUdJMUwsU0FBUzRwQixPQUFPdGQsR0FBaEIsR0FBc0JzZCxPQUFPQyxNQUhqQyxFQUlYbmUsSUFKVyxDQUlOLE9BSk0sRUFJRyxNQUpILENBQVo7O0FBTUEsUUFBSXFpQixLQUFLRCxNQUFNN3BCLE1BQU4sQ0FBYSxHQUFiLEVBQ1J5SCxJQURRLENBQ0gsV0FERyxFQUNVLGlCQUFpQjFMLE1BQWpCLEdBQTBCLEdBRHBDLEVBRVIwTCxJQUZRLENBRUgsT0FGRyxFQUVNLFFBRk4sRUFHUnNJLElBSFEsQ0FHSHNaLEtBSEcsQ0FBVDs7QUFLQSxRQUFJVSxLQUFLRixNQUFNN3BCLE1BQU4sQ0FBYSxHQUFiLEVBQ1J5SCxJQURRLENBQ0gsV0FERyxFQUNVLGdCQURWLEVBRVJBLElBRlEsQ0FFSCxPQUZHLEVBRU0sUUFGTixFQUdSc0ksSUFIUSxDQUdId1gsS0FIRyxDQUFUOztBQUtBLFFBQUl5QyxPQUFPSCxNQUFNN3BCLE1BQU4sQ0FBYSxNQUFiLEVBQXFCQSxNQUFyQixDQUE0QixjQUE1QixFQUNWeUgsSUFEVSxDQUNMLElBREssRUFDQyxNQURELEVBRVZ6SCxNQUZVLENBRUgsVUFGRyxFQUdWeUgsSUFIVSxDQUdMLElBSEssRUFHQyxXQUhELEVBSVZBLElBSlUsQ0FJTCxHQUpLLEVBSUEsR0FKQSxFQUtWQSxJQUxVLENBS0wsR0FMSyxFQUtBLEdBTEEsRUFNVkEsSUFOVSxDQU1MLE9BTkssRUFNSTNMLEtBTkosRUFPVjJMLElBUFUsQ0FPTCxRQVBLLEVBT0sxTCxNQVBMLENBQVg7O0FBU0E4dEIsVUFBTTdwQixNQUFOLENBQWEsR0FBYixFQUFrQnlILElBQWxCLENBQXVCLFdBQXZCLEVBQW9DLFlBQXBDLEVBQ0M1SCxTQURELENBQ1csUUFEWCxFQUVDQyxJQUZELENBRU11b0IsU0FGTixFQUdDdG9CLEtBSEQsR0FJQ0MsTUFKRCxDQUlRLFFBSlIsRUFLQ3lILElBTEQsQ0FLTSxJQUxOLEVBS1ksVUFBVXZILENBQVYsRUFBYW9ELENBQWIsRUFBZ0I7QUFDdEIsZUFBTzZsQixPQUFPZCxVQUFVL2tCLENBQVYsRUFBYW1sQixLQUFwQixDQUFQO0FBQ0MsS0FQUCxFQVFDaGhCLElBUkQsQ0FRTSxJQVJOLEVBUVksVUFBVXZILENBQVYsRUFBYW9ELENBQWIsRUFBZ0I7QUFDdEIsZUFBTzhsQixPQUFPZixVQUFVL2tCLENBQVYsRUFBYW9sQixLQUFwQixDQUFQO0FBQ0MsS0FWUCxFQVdDamhCLElBWEQsQ0FXTSxHQVhOLEVBV1csQ0FYWCxFQVlDNUosS0FaRCxDQVlPLE1BWlAsRUFZZSxTQVpmOztBQWdCQStyQixrQkFBYzVwQixNQUFkLENBQXFCLE1BQXJCLEVBQ0N5SCxJQURELENBQ00sYUFETixFQUNxQixRQURyQixFQUNnQztBQURoQyxLQUVDQSxJQUZELENBRU0sV0FGTixFQUVtQixlQUFlbWhCLFVBQVUsQ0FBekIsR0FBNkIsR0FBN0IsR0FBb0M3c0IsU0FBUyxDQUE3QyxHQUFrRCxjQUZyRSxFQUVzRjtBQUZ0RixLQUdDa0UsSUFIRCxDQUdNbW9CLFdBSE4sRUFJQ3ZxQixLQUpELENBSU8sTUFKUCxFQUllLFNBSmYsRUFLQ0EsS0FMRCxDQUtPLGFBTFAsRUFLcUIsTUFMckIsRUFNQ0EsS0FORCxDQU1PLFdBTlAsRUFNbUIsTUFObkIsRUFPQ0EsS0FQRCxDQU9PLGFBUFAsRUFPcUIsTUFQckI7O0FBU0ErckIsa0JBQWM1cEIsTUFBZCxDQUFxQixNQUFyQixFQUNDeUgsSUFERCxDQUNNLGFBRE4sRUFDcUIsUUFEckIsRUFDZ0M7QUFEaEMsS0FFQ0EsSUFGRCxDQUVNLFdBRk4sRUFFbUIsZUFBZ0IzTCxRQUFRLENBQXhCLEdBQTZCLEdBQTdCLElBQW9DQyxTQUFVNnNCLFVBQVUsQ0FBeEQsSUFBOEQsR0FGakYsRUFFdUY7QUFGdkYsS0FHQzNvQixJQUhELENBR01rb0IsV0FITixFQUlDdHFCLEtBSkQsQ0FJTyxNQUpQLEVBSWUsU0FKZixFQUtDQSxLQUxELENBS08sYUFMUCxFQUtxQixNQUxyQixFQU1DQSxLQU5ELENBTU8sV0FOUCxFQU1tQixNQU5uQixFQU9DQSxLQVBELENBT08sYUFQUCxFQU9xQixNQVByQjs7QUFVQWdzQixVQUFNN3BCLE1BQU4sQ0FBYSxNQUFiLEVBQ0N5SCxJQURELENBQ00sSUFETixFQUNZMGhCLE9BQU9OLEtBQVAsQ0FEWixFQUVDcGhCLElBRkQsQ0FFTSxJQUZOLEVBRVkyaEIsT0FBT1AsS0FBUCxDQUZaLEVBR0NwaEIsSUFIRCxDQUdNLElBSE4sRUFHWTBoQixPQUFPTCxLQUFQLENBSFosRUFJQ3JoQixJQUpELENBSU0sSUFKTixFQUlZMmhCLE9BQU9OLEtBQVAsQ0FKWixFQUtDcmhCLElBTEQsQ0FLTSxjQUxOLEVBS3NCLENBTHRCLEVBTUNBLElBTkQsQ0FNTSxRQU5OLEVBTWdCLE9BTmhCOztBQVFBLGFBQVNraUIsTUFBVCxHQUFrQjtBQUNkLFlBQUlNLE9BQU9yMkIsR0FBR2lkLEtBQUgsQ0FBU3FaLFNBQVQsQ0FBbUIsQ0FBbkIsQ0FBWDtBQUNBLFlBQUlDLE9BQU92MkIsR0FBR2lkLEtBQUgsQ0FBU3FaLFNBQVQsQ0FBbUIsQ0FBbkIsQ0FBWDtBQUNBLFlBQUlyMkIsUUFBUUQsR0FBR2lkLEtBQUgsQ0FBU2hkLEtBQXJCOztBQUVBbzJCLGVBQU9BLE9BQU8sRUFBUCxHQUFZLEVBQVosR0FBaUJBLElBQXhCO0FBQ0EsWUFBSUcsT0FBTyxFQUFFdjJCLFFBQVEsQ0FBVixJQUFlaUksS0FBZixHQUF1QixFQUFsQztBQUNBbXVCLGVBQU9BLE9BQU9HLElBQVAsR0FBY0EsSUFBZCxHQUFxQkgsSUFBNUI7O0FBRUFFLGVBQU9BLE9BQU8sRUFBUCxHQUFZLEVBQVosR0FBaUJBLElBQXhCO0FBQ0EsWUFBSUUsT0FBTyxFQUFFeDJCLFFBQVEsQ0FBVixJQUFla0ksTUFBZixHQUF3QixFQUFuQztBQUNBb3VCLGVBQU9BLE9BQU9FLElBQVAsR0FBY0EsSUFBZCxHQUFxQkYsSUFBNUI7O0FBRUFYLGFBQUtVLFNBQUwsQ0FBZSxDQUFDRCxJQUFELEVBQU9FLElBQVAsQ0FBZjs7QUFHQU4sY0FBTWxzQixNQUFOLENBQWEsU0FBYixFQUF3Qm9TLElBQXhCLENBQTZCc1osS0FBN0I7QUFDQVEsY0FBTWxzQixNQUFOLENBQWEsU0FBYixFQUF3Qm9TLElBQXhCLENBQTZCd1gsS0FBN0I7QUFDQXNDLGNBQU1ocUIsU0FBTixDQUFnQixRQUFoQixFQUNDNEgsSUFERCxDQUNNLElBRE4sRUFDWSxVQUFVdkgsQ0FBVixFQUFhb0QsQ0FBYixFQUFnQjtBQUN0QmpRLG9CQUFRQyxHQUFSLENBQVksV0FBWixFQUF3QjYxQixPQUFPLENBQVAsQ0FBeEI7QUFDQSxtQkFBT0EsT0FBT2QsVUFBVS9rQixDQUFWLEVBQWFtbEIsS0FBcEIsQ0FBUDtBQUNDLFNBSlAsRUFLQ2hoQixJQUxELENBS00sSUFMTixFQUtZLFVBQVV2SCxDQUFWLEVBQWFvRCxDQUFiLEVBQWdCO0FBQ3RCLG1CQUFPOGxCLE9BQU9mLFVBQVUva0IsQ0FBVixFQUFhb2xCLEtBQXBCLENBQVA7QUFDQyxTQVBQLEVBUUNqaEIsSUFSRCxDQVFNLEdBUk4sRUFRVyxHQVJYLEVBU0M1SixLQVRELENBU08sTUFUUCxFQVNlLFNBVGY7O0FBWUQ7QUFDQ2dzQixjQUFNbHNCLE1BQU4sQ0FBYSxNQUFiLEVBQ0M4SixJQURELENBQ00sSUFETixFQUNZLFVBQVN2SCxDQUFULEVBQVlvRCxDQUFaLEVBQWU7QUFDckIsbUJBQU82bEIsT0FBT04sS0FBUCxDQUFQO0FBQ0MsU0FIUCxFQUlDcGhCLElBSkQsQ0FJTSxJQUpOLEVBSVksVUFBU3ZILENBQVQsRUFBWW9ELENBQVosRUFBZTtBQUNyQixtQkFBTzZsQixPQUFPTixLQUFQLENBQVA7QUFDQyxTQU5QLEVBT0NwaEIsSUFQRCxDQU9NLElBUE4sRUFPWSxVQUFTdkgsQ0FBVCxFQUFZb0QsQ0FBWixFQUFlO0FBQ3JCLG1CQUFPNmxCLE9BQU9MLEtBQVAsQ0FBUDtBQUNDLFNBVFAsRUFVQ3JoQixJQVZELENBVU0sSUFWTixFQVVZLFVBQVN2SCxDQUFULEVBQVlvRCxDQUFaLEVBQWU7QUFDckIsbUJBQU84bEIsT0FBT04sS0FBUCxDQUFQO0FBQ0MsU0FaUCxFQWFDcmhCLElBYkQsQ0FhTSxjQWJOLEVBYXNCLENBYnRCLEVBY0NBLElBZEQsQ0FjTSxRQWROLEVBY2dCLE9BZGhCO0FBZUg7O0FBSUg7O0FBR0Q7O0FBR00sU0FBU3pVLFNBQVQsQ0FBbUJ3akIsUUFBbkIsRUFBNkI7QUFDaEMsYUFBU2xDLFFBQVQsQ0FBa0J4VSxJQUFsQixFQUF3QnlVLE9BQXhCLEVBQWlDO0FBQzdCLFlBQUlFLFFBQVE3Z0IsR0FBRytKLE1BQUgsQ0FBVSxzQkFBVixFQUFrQ3FDLE1BQWxDLENBQXlDLE9BQXpDLENBQVo7QUFDQSxZQUFJMFUsUUFBUUQsTUFBTXpVLE1BQU4sQ0FBYSxPQUFiLENBQVo7QUFDQSxZQUFJMlUsUUFBUUYsTUFBTXpVLE1BQU4sQ0FBYSxPQUFiLENBQVo7O0FBRUE7QUFDQTBVLGNBQU0xVSxNQUFOLENBQWEsSUFBYixFQUNDSCxTQURELENBQ1csSUFEWCxFQUVDQyxJQUZELENBRU15VSxPQUZOLEVBRWV4VSxLQUZmLEdBR0NDLE1BSEQsQ0FHUSxJQUhSLEVBSUNDLElBSkQsQ0FJTSxVQUFVMlUsTUFBVixFQUFrQjtBQUFFLG1CQUFPQSxNQUFQO0FBQWdCLFNBSjFDOztBQU1BO0FBQ0EsWUFBSUMsT0FBT0YsTUFBTTlVLFNBQU4sQ0FBZ0IsSUFBaEIsRUFDVkMsSUFEVSxDQUNMQSxJQURLLEVBRVZDLEtBRlUsR0FHVkMsTUFIVSxDQUdILElBSEcsQ0FBWDs7QUFLQTtBQUNBLFlBQUk4VSxRQUFRRCxLQUFLaFYsU0FBTCxDQUFlLElBQWYsRUFDWEMsSUFEVyxDQUNOLFVBQVVpVixHQUFWLEVBQWU7QUFDZixtQkFBT1IsUUFBUXhILEdBQVIsQ0FBWSxVQUFVNkgsTUFBVixFQUFrQjtBQUNsQix1QkFBTyxFQUFDQSxRQUFRQSxNQUFULEVBQWlCSSxPQUFPRCxJQUFJSCxNQUFKLENBQXhCLEVBQVA7QUFDQyxhQUZiLENBQVA7QUFHQyxTQUxLLEVBTVg3VSxLQU5XLEdBT1hDLE1BUFcsQ0FPSixJQVBJLEVBUVhDLElBUlcsQ0FRTixVQUFVQyxDQUFWLEVBQWE7QUFBRSxtQkFBT0EsRUFBRThVLEtBQVQ7QUFBaUIsU0FSMUIsRUFTWHZOLElBVFcsQ0FTTixJQVRNLEVBU0QsVUFBU3ZILENBQVQsRUFBV29ELENBQVgsRUFBYztBQUNuQixnQkFBSWduQixVQUFVLEtBQUtwVixhQUFMLENBQW1CQyxVQUFuQixDQUE4QkMsU0FBNUM7QUFDQSxtQkFBT2tWLFVBQVVwcUIsRUFBRTBVLE1BQW5CO0FBQ0MsU0FaSyxDQUFaOztBQWNBLGVBQU9ILEtBQVA7QUFDSDs7QUFHRCxRQUFJd04sU0FBUyxFQUFiO0FBQ0EsU0FBSSxJQUFJM2UsSUFBSSxDQUFaLEVBQWVBLElBQUVrVCxTQUFTelksTUFBMUIsRUFBa0N1RixHQUFsQyxFQUF1QztBQUNuQyxZQUFHM0wsU0FBU2tQLGNBQWMyUCxTQUFTbFQsQ0FBVCxDQUFkLENBQVQsRUFBcUNxYixLQUFyQyxJQUE0QyxDQUEvQyxFQUFrRDtBQUM5QzRMLG1CQUFLLENBQUw7QUFDQUMsb0JBQU0sQ0FBTjtBQUNBdkksbUJBQU8xZSxJQUFQLENBQVksRUFBQyxhQUFZaVQsU0FBU2xULENBQVQsQ0FBYixFQUF5QixRQUFPaW5CLElBQWhDLEVBQXNDLE1BQUtDLEtBQTNDLEVBQVo7QUFDQTtBQUNIOztBQUVELFlBQUk1akIsTUFBTXRELElBQUUsQ0FBWjtBQUNBLFlBQUltbkIsUUFBUWpVLFNBQVNsVCxDQUFULElBQVksWUFBWixHQUF5QnNELEdBQXJDO0FBQ0EsWUFBSTJqQixPQUFPNXRCLFNBQVNDLGNBQVQsQ0FBd0I2dEIsS0FBeEIsRUFBK0IzSSxhQUEvQixDQUE2QyxPQUE3QyxFQUFzRGpTLFNBQWpFO0FBQ0EsWUFBSTJhLFFBQVE3dEIsU0FBU0MsY0FBVCxDQUF3QjZ0QixLQUF4QixFQUErQjNJLGFBQS9CLENBQTZDLFFBQTdDLEVBQXVEalMsU0FBbkU7QUFDQTBhLGVBQU9BLEtBQUt0MUIsS0FBTCxDQUFXLEtBQVgsRUFBa0J5MUIsR0FBbEIsRUFBUDtBQUNBRixnQkFBUUEsTUFBTXYxQixLQUFOLENBQVksTUFBWixFQUFvQnkxQixHQUFwQixFQUFSO0FBQ0FyM0IsZ0JBQVFDLEdBQVIsQ0FBWWkzQixJQUFaO0FBQ0FsM0IsZ0JBQVFDLEdBQVIsQ0FBWW0zQixLQUFaOztBQUVBeEksZUFBTzFlLElBQVAsQ0FBWSxFQUFDLGFBQVlpVCxTQUFTbFQsQ0FBVCxDQUFiLEVBQXlCLFFBQU9pbkIsSUFBaEMsRUFBc0MsTUFBS0MsS0FBM0MsRUFBWjtBQUNIOztBQUVEO0FBQ0FsVyxhQUFTMk4sTUFBVCxFQUFpQixDQUFDLFdBQUQsRUFBYyxNQUFkLEVBQXNCLElBQXRCLENBQWpCLEVBNURnQyxDQTREZTtBQUNsRDs7QUFHRDtBQUNPLFNBQVNodkIsY0FBVCxDQUF3Qm9oQixVQUF4QixFQUFvQztBQUN2Q2hoQixZQUFRQyxHQUFSLENBQVkrZ0IsVUFBWjtBQUNBLFFBQUluUCxVQUFVb1IsV0FBV2pnQixRQUFRa0IsVUFBbkIsQ0FBZDtBQUNBLFFBQUlvekIsa0JBQWtCLG9CQUF0QixDQUh1QyxDQUdLOztBQUU1QyxRQUFJQyx3QkFBc0IsRUFBQzFsQixnQkFBRCxFQUFVbVAsc0JBQVYsRUFBc0JzVyxnQ0FBdEIsRUFBMUI7O0FBRUEsUUFBSXZtQixVQUFVL0MsS0FBS0UsU0FBTCxDQUFlcXBCLHFCQUFmLENBQWQ7O0FBRUEsUUFBSXZtQixVQUFVQyxTQUFTLGlCQUF2QjtBQUNBLFFBQUlDLGNBQWMsaUJBQWlCSCxPQUFuQzs7QUFFQS9RLFlBQVFDLEdBQVIsQ0FBWStRLE9BQVo7QUFDQWhSLFlBQVFDLEdBQVIsQ0FBWWlSLFdBQVo7O0FBRUEsYUFBU3NtQixhQUFULENBQXVCN2xCLEdBQXZCLEVBQTRCcWMsUUFBNUIsRUFBc0M7QUFDbEMsWUFBSXlKLGVBQWUsb0JBQW9CelcsVUFBcEIsR0FBaUMsbUJBQXBEO0FBQ0E5VyxjQUFNdXRCLFlBQU47QUFDQXozQixnQkFBUUMsR0FBUixDQUFZK3RCLFFBQVo7QUFDSDs7QUFFRCxhQUFTMEosVUFBVCxDQUFvQi9sQixHQUFwQixFQUF5QjtBQUNyQjNSLGdCQUFRQyxHQUFSLENBQVksd0JBQVo7QUFDSDs7QUFFRCtSLG9CQUFnQmhCLE9BQWhCLEVBQXlCLFVBQXpCLEVBQXFDd21CLGFBQXJDLEVBQW9ERSxVQUFwRCxFQUFnRXhtQixXQUFoRTtBQUNIOztBQUVNLFNBQVNyUixjQUFULEdBQTJCO0FBQzlCRyxZQUFRQyxHQUFSLENBQVksZUFBWjtBQUNIOztBQUdEO0FBQ0E7QUFDQSxTQUFTMHVCLFVBQVQsQ0FBcUJ6YyxJQUFyQixFQUEyQmdSLEdBQTNCLEVBQWdDO0FBQzVCLFFBQUl5VSxNQUFNLEVBQVY7QUFDQSxTQUFJLElBQUkxbkIsSUFBSSxDQUFaLEVBQWVBLElBQUlpQyxLQUFLeEgsTUFBeEIsRUFBZ0N1RixHQUFoQyxFQUFxQztBQUNqQzBuQixZQUFJem5CLElBQUosQ0FBUyxFQUFDMG5CLFdBQVUxbEIsS0FBS2pDLENBQUwsQ0FBWCxFQUFtQjRuQixTQUFRM1UsR0FBM0IsRUFBVDtBQUNIO0FBQ0QsV0FBT3lVLEdBQVA7QUFDSDs7QUFFRCxTQUFTdFUsbUJBQVQsQ0FBOEJuUixJQUE5QixFQUFvQ2dSLEdBQXBDLEVBQXlDO0FBQ3JDLFFBQUl5VSxNQUFNLEVBQVY7QUFDQSxRQUFJRyxXQUFXNVUsSUFBSXpZLFNBQUosQ0FBYyxDQUFkLEVBQWlCeVksSUFBSTZVLFdBQUosQ0FBZ0IsR0FBaEIsQ0FBakIsQ0FBZjtBQUNBLFNBQUksSUFBSTluQixJQUFJLENBQVosRUFBZUEsSUFBSWlDLEtBQUt4SCxNQUF4QixFQUFnQ3VGLEdBQWhDLEVBQXFDO0FBQ2pDMG5CLFlBQUl6bkIsSUFBSixDQUFTLEVBQUMwbkIsV0FBVTFsQixLQUFLakMsQ0FBTCxDQUFYLEVBQW1CNG5CLFNBQVFDLFFBQTNCLEVBQVQ7QUFDSDtBQUNELFdBQU9ILEdBQVA7QUFDSDs7QUFHRDtBQUNBLFNBQVMxVSxVQUFULENBQXFCcFIsT0FBckIsRUFBOEI7QUFDMUIsV0FBTyxFQUFDLGNBQWFBLE9BQWQsRUFBUDtBQUNIIiwiZmlsZSI6IjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbSBmcm9tICdtaXRocmlsJztcblxuaW1wb3J0IHtiYXJzLCBiYXJzTm9kZSwgYmFyc1N1YnNldCwgZGVuc2l0eSwgZGVuc2l0eU5vZGUsIHNlbFZhckNvbG9yfSBmcm9tICcuL3Bsb3RzLmpzJztcblxuaW1wb3J0ICcuLi9wa2dzL2hvcHNjb3RjaC9kaXN0L2pzL2hvcHNjb3RjaC5qcyc7XG5pbXBvcnQgJy4uL3BrZ3MvaG9wc2NvdGNoL2Rpc3QvY3NzL2hvcHNjb3RjaC5jc3MnO1xuLy9pbXBvcnQgJy4uL3BrZ3MvaG9wc2NvdGNoL2Rpc3QvanMvbXlfaG9wc2NvdGNoX3RvdXIuanMnO1xuXG4vLyBob3N0bmFtZSBkZWZhdWx0IC0gdGhlIGFwcCB3aWxsIHVzZSBpdCB0byBvYnRhaW4gdGhlIHZhcmlhYmxlIG1ldGFkYXRhXG4vLyAoZGRpKSBhbmQgcHJlLXByb2Nlc3NlZCBkYXRhIGluZm8gaWYgdGhlIGZpbGUgaWQgaXMgc3VwcGxpZWQgYXMgYW5cbi8vIGFyZ3VtZW50IChmb3IgZXguLCBndWkuaHRtbD9kZklkPTE3KSwgYnV0IGhvc3RuYW1lIGlzbid0LlxuLy8gRWRpdCBpdCB0byBzdWl0IHlvdXIgaW5zdGFsbGF0aW9uLlxuLy8gKE5PVEUgdGhhdCBpZiB0aGUgZmlsZSBpZCBpc24ndCBzdXBwbGllZCwgdGhlIGFwcCB3aWxsIGRlZmF1bHQgdG8gdGhlXG4vLyBsb2NhbCBmaWxlcyBzcGVjaWZpZWQgYmVsb3chKVxuLy8gTkVXOiBpdCBpcyBhbHNvIHBvc3NpYmxlIG5vdyB0byBzdXBwbHkgY29tcGxldGUgdXJscyBmb3IgdGhlIGRkaSBhbmRcbi8vIHRoZSB0YWItZGVsaW1pdGVkIGRhdGEgZmlsZTsgdGhlIHBhcmFtZXRlcnMgYXJlIGRkaXVybCBhbmQgZGF0YXVybC5cbi8vIFRoZXNlIG5ldyBwYXJhbWV0ZXJzIGFyZSBvcHRpb25hbC4gSWYgdGhleSBhcmUgbm90IHN1cHBsaWVkLCB0aGUgYXBwXG4vLyB3aWxsIGdvIHRoZSBvbGQgcm91dGUgLSB3aWxsIHRyeSB0byBjb29rIHN0YW5kYXJkIGRhdGF2ZXJzZSB1cmxzXG4vLyBmb3IgYm90aCB0aGUgZGF0YSBhbmQgbWV0YWRhdGEsIGlmIHRoZSBmaWxlIGlkIGlzIHN1cHBsaWVkOyBvciB0aGVcbi8vIGxvY2FsIGZpbGVzIGlmIG5vdGhpbmcgaXMgc3VwcGxpZWQuXG5cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBOT1RFOiBnbG9iYWwgdmFyaWFibGVzIGFyZSBub3cgc2V0IGluIHRoZSBpbmRleC5odG1sIGZpbGUuXG4vLyAgICBEZXZlbG9wZXJzLCBzZWUgL3RlbXBsYXRlL2luZGV4Lmh0bWxcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyBmb3IgZGVidWdnaW5nIC0gaWYgbm90IGluIHByb2R1Y3Rpb24sIHByaW50cyBhcmdzIGFuZCByZXR1cm5zIHRoZW1cbmV4cG9ydCBsZXQgY2RiID0gXyA9PiBwcm9kdWN0aW9uIHx8IGNvbnNvbGUubG9nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgJiYgYXJndW1lbnRzO1xuXG5sZXQgayA9IDQ7IC8vIHN0cmVuZ3RoIHBhcmFtZXRlciBmb3IgZ3JvdXAgYXR0cmFjdGlvbi9yZXB1bHNpb25cbmxldCB0dXRvcmlhbF9tb2RlID0gdHJ1ZTtcbmxldCBmaXJzdF9sb2FkID0gdHJ1ZTtcblxuLy8gaW5pdGlhbCBjb2xvciBzY2FsZSB1c2VkIHRvIGVzdGFibGlzaCB0aGUgaW5pdGlhbCBjb2xvcnMgb2Ygbm9kZXNcbi8vIGFsbE5vZGVzLnB1c2goKSBiZWxvdyBlc3RhYmxpc2hlcyBhIGZpZWxkIGZvciB0aGUgbWFzdGVyIG5vZGUgYXJyYXkgYWxsTm9kZXMgY2FsbGVkIFwibm9kZUNvbFwiIGFuZCBhc3NpZ25zIGEgY29sb3IgZnJvbSB0aGlzIHNjYWxlIHRvIHRoYXQgZmllbGRcbi8vIGV2ZXJ5dGhpbmcgdGhlcmUgYWZ0ZXIgc2hvdWxkIHJlZmVyIHRvIHRoZSBub2RlQ29sIGFuZCBub3QgdGhlIGNvbG9yIHNjYWxlLCB0aGlzIGVuYWJsZXMgdXMgdG8gdXBkYXRlIGNvbG9ycyBhbmQgcGFzcyB0aGUgdmFyaWFibGUgdHlwZSB0byBSIGJhc2VkIG9uIGl0cyBjb2xvcmluZ1xubGV0IGNvbG9ycyA9IGQzLnNjYWxlLmNhdGVnb3J5MjAoKTtcbmV4cG9ydCBsZXQgY3NDb2xvciA9ICcjNDE5NjQxJztcbmV4cG9ydCBsZXQgZHZDb2xvciA9ICcjMjhhNGM5JztcbmV4cG9ydCBsZXQgZ3IxQ29sb3IgPSAnIzE0YmRjYyc7ICAvLyBpbml0aWFsbHkgd2FzICMyNGE0YzknLCBidXQgdGhhdCBpcyBkdkNvbG9yLCBhbmQgd2UgdHJhY2sgc29tZSBwcm9wZXJ0aWVzIGJ5IGNvbG9yIGFzc3VtaW5nIHRoZW0gdW5pcXVlXG5sZXQgZ3IxT3BhY2l0eSA9IFswLDFdO1xuZXhwb3J0IGxldCBncjJDb2xvciA9ICcjZmZjY2NjJztcbmxldCBncjJPcGFjaXR5ID0gWzAsMV07XG5cbmxldCBncmF5Q29sb3IgPSAnI2MwYzBjMCc7XG5leHBvcnQgbGV0IG5vbUNvbG9yID0gJyNmZjY2MDAnO1xuZXhwb3J0IGxldCB2YXJDb2xvciA9ICcjZjBmOGZmJzsgLy8gZDMucmdiKFwiYWxpY2VibHVlXCIpO1xubGV0IHRhZ2dlZENvbG9yID0gJyNmNWY1ZjUnOyAvLyBkMy5yZ2IoXCJ3aGl0ZXNtb2tlXCIpO1xuZXhwb3J0IGxldCB0aW1lQ29sb3IgPSAnIzJkNmNhMic7XG5cbmV4cG9ydCBsZXQgbGVmdHRhYiA9ICd0YWIxJzsgLy8gY3VycmVudCB0YWIgaW4gbGVmdCBwYW5lbFxuZXhwb3J0IGxldCBzdWJzZXQgPSBmYWxzZTtcbmV4cG9ydCBsZXQgc3VtbWFyeUhvbGQgPSBmYWxzZTtcbmV4cG9ydCBsZXQgcmlnaHR0YWIgPSAnYnRuTW9kZWxzJzsgLy8gY3VycmVudCB0YWIgaW4gcmlnaHQgcGFuZWxcblxuLy8gdHJhbnNmb3JtYXRpb24gdG9vbGJhciBvcHRpb25zXG5sZXQgdCwgdHlwZVRyYW5zZm9ybTtcbmxldCB0cmFuc2Zvcm1MaXN0ID0gJ2xvZyhkKSBleHAoZCkgZF4yIHNxcnQoZCkgaW50ZXJhY3QoZCxlKScuc3BsaXQoJyAnKTtcbmxldCB0cmFuc2Zvcm1WYXIgPSAnJztcblxuLy8gdmFyIGxpc3QgZm9yIGVhY2ggc3BhY2UgY29udGFpbiB2YXJpYWJsZXMgaW4gb3JpZ2luYWwgZGF0YVxuLy8gcGx1cyB0cmFucyBpbiB0aGF0IHNwYWNlXG5sZXQgdHJhbnMgPSBbXTtcbmxldCBwcmVwcm9jZXNzID0ge307IC8vIGhvbGQgcHJlLXByb2Nlc3NlZCBkYXRhXG5sZXQgc3BhY2VzID0gW107XG5cbi8vIGxheW91dCBmdW5jdGlvbiBjb25zdGFudHNcbmNvbnN0IGxheW91dEFkZCA9IFwiYWRkXCI7XG5jb25zdCBsYXlvdXRNb3ZlID0gXCJtb3ZlXCI7XG5cbi8vIFJhZGl1cyBvZiBjaXJjbGVcbmxldCBhbGxSID0gNDA7XG5sZXQgaW5kMSA9IFsoYWxsUiszMCkgKiBNYXRoLmNvcygxLjMpLCAtMSooYWxsUiszMCkgKiBNYXRoLnNpbigxLjMpLDVdIC8vIGN4LCBjeSwgciAgdmFsdWVzIGZvciBpbmRpY2F0b3IgbGlnaHRzXG5sZXQgaW5kMiA9IFsoYWxsUiszMCkgKiBNYXRoLmNvcygxLjEpLCAtMSooYWxsUiszMCkgKiBNYXRoLnNpbigxLjEpLDVdIC8vIGN4LCBjeSwgciAgdmFsdWVzIGZvciBpbmRpY2F0b3IgbGlnaHRzXG5cblxuLy8gc3BhY2UgaW5kZXhcbmxldCBteXNwYWNlID0gMDtcblxubGV0IGZvcmNldG9nZ2xlID0gW1widHJ1ZVwiXTtcbmxldCBsb2NrdG9nZ2xlID0gdHJ1ZTtcbmxldCBwcml2ID0gdHJ1ZTtcblxuLy8gc3dhbmRpdmUgaXMgb3VyIGdyYWNlZnVsIGZhaWwgZm9yIGQzbVxuLy8gc3dhbmRpdmUgc2V0IHRvIHRydWUgaWYgdGFzayBpcyBpbiBmYWlsc2V0XG5sZXQgc3dhbmRpdmUgPSBmYWxzZTtcbmxldCBmYWlsc2V0ID0gW1wiVElNRVNFUklFU0ZPUkVDQVNUSU5HXCIsXCJHUkFQSE1BVENISU5HXCIsXCJMSU5LUFJFRElDVElPTlwiLFwidGltZVNlcmllc0ZvcmVjYXN0aW5nXCIsXCJncmFwaE1hdGNoaW5nXCIsXCJsaW5rUHJlZGljdGlvblwiXTtcblxuZXhwb3J0IGxldCBsb2dBcnJheSA9IFtdO1xuZXhwb3J0IGxldCB6cGFyYW1zID0ge1xuICAgIHpkYXRhOiBbXSxcbiAgICB6ZWRnZXM6IFtdLFxuICAgIHp0aW1lOiBbXSxcbiAgICB6bm9tOiBbXSxcbiAgICB6Y3Jvc3M6IFtdLFxuICAgIHptb2RlbDogXCJcIixcbiAgICB6dmFyczogW10sXG4gICAgemR2OiBbXSxcbiAgICB6Z3JvdXAxOiBbXSxcbiAgICB6Z3JvdXAyOiBbXSwgICAgICAgLy8gaGFyZCBjb2RpbmcgdG8gdHdvIGdyb3VwcyBmb3IgcHJlc2VudCBleHBlcmltZW50cywgYnV0IHdpbGwgZXZlbnR1YWxseSBtYWtlIHpncm91cCBhcnJheSBvZiBhcnJheXMsIHdpdGggemdyb3VwLmxlbmdodCB0aGUgbnVtYmVyIG9mIGdyb3Vwc1xuICAgIHpkYXRhdXJsOiBcIlwiLFxuICAgIHpkM21kYXRhOiBcIlwiLCAvL3RoZXNlIHRha2UgdGhlIHBsYWNlIG9mIHpkYXRhdXJsIGZvciBkM20sIGJlY2F1c2UgZGF0YSBpcyBpbiB0d28gcGxhY2Vlcy4gZXZlbnR1YWxseSB3aWxsIGdlbmVyYWxpemVcbiAgICB6ZDNtdGFyZ2V0OiBcIlwiLFxuICAgIHpzdWJzZXQ6IFtdLFxuICAgIHpzZXR4OiBbXSxcbiAgICB6bW9kZWxjb3VudDogMCxcbiAgICB6cGxvdDogW10sXG4gICAgenNlc3Npb25pZDogXCJcIixcbiAgICB6ZGF0YWNpdGU6IFwiXCJcbn07XG5cbmxldCBtb2RlbENvdW50ID0gMDtcbmV4cG9ydCBsZXQgdmFsdWVLZXkgPSBbXTtcbmV4cG9ydCBsZXQgYWxsTm9kZXMgPSBbXTtcbmxldCBhbGxSZXN1bHRzID0gW107XG5leHBvcnQgbGV0IG5vZGVzID0gW107XG5sZXQgbGlua3MgPSBbXTtcbmxldCBtb2RzID0ge307XG5sZXQgZXN0aW1hdGVkID0gZmFsc2U7XG5sZXQgcmlnaHRDbGlja0xhc3QgPSBmYWxzZTtcbmxldCBzZWxJbnRlcmFjdCA9IGZhbHNlO1xubGV0IGNhbGxIaXN0b3J5ID0gW107IC8vIHRyYW5zZm9ybSBhbmQgc3Vic2V0IGNhbGxzXG5sZXQgbXl0YXJnZXQgPSBcIlwiO1xuXG5sZXQgY29uZmlndXJhdGlvbnMgPSB7fTtcbmxldCBkYXRhc2NoZW1hID0ge307XG5cbi8vZXZlbnR1YWxseSByZWFkIHRoaXMgZnJvbSB0aGUgc2NoZW1hIHdpdGggcmVhbCBkZXNjcmlwdGlvbnNcbi8vIG1ldHJpY3MsIHRhc2tzLCBhbmQgc3VidGFza3MgYXMgc3BlY2lmaWVkIGluIEQzTSBzY2hlbWFzXG4vLyBNRUFOIFNRVUFSRUQgRVJST1IgSVMgU0VUIFRPIFNBTUUgQVMgUk1TRS4gTVNFIGlzIGluIHNjaGVtYSBidXQgbm90IHByb3RvXG5sZXQgZDNtTWV0cmljcyA9IHsgbWV0cmljVW5kZWZpbmVkOltcImRlc2NyaXB0aW9uXCIsIFwiTUVUUklDX1VOREVGSU5FRFwiICwgMF0sXG4gICAgYWNjdXJhY3kgOiBbXCJkZXNjcmlwdGlvblwiLCBcIkFDQ1VSQUNZXCIgLCAxXSxcbmYxOltcImRlc2NyaXB0aW9uXCIsIFwiRjFcIiAsIDJdLFxuZjFNaWNybzpbXCJkZXNjcmlwdGlvblwiLCBcIkYxX01JQ1JPXCIgLCAzXSxcbmYxTWFjcm86W1wiZGVzY3JpcHRpb25cIiwgXCJGMV9NQUNST1wiICwgNF0sXG5yb2NBdWM6W1wiZGVzY3JpcHRpb25cIiwgXCJST0NfQVVDXCIgLCA1XSxcbnJvY0F1Y01pY3JvOltcImRlc2NyaXB0aW9uXCIsIFwiUk9DX0FVQ19NSUNST1wiICwgNl0sXG5yb2NBdWNNYWNybzpbXCJkZXNjcmlwdGlvblwiLCBcIlJPQ19BVUNfTUFDUk9cIiAsIDddLFxubWVhblNxdWFyZWRFcnJvcjpbXCJkZXNjcmlwdGlvblwiLCBcIlJPT1RfTUVBTl9TUVVBUkVEX0VSUk9SXCIsIDhdLFxucm9vdE1lYW5TcXVhcmVkRXJyb3I6W1wiZGVzY3JpcHRpb25cIiwgXCJST09UX01FQU5fU1FVQVJFRF9FUlJPUlwiICwgOF0sXG5yb290TWVhblNxdWFyZWRFcnJvckF2ZzpbXCJkZXNjcmlwdGlvblwiLCBcIlJPT1RfTUVBTl9TUVVBUkVEX0VSUk9SX0FWR1wiICwgOV0sXG5tZWFuQWJzb2x1dGVFcnJvcjpbXCJkZXNjcmlwdGlvblwiLCBcIk1FQU5fQUJTT0xVVEVfRVJST1JcIiAsIDEwXSxcbnJTcXVhcmVkOltcImRlc2NyaXB0aW9uXCIsIFwiUl9TUVVBUkVEXCIgLCAxMV0sXG5ub3JtYWxpemVkTXV0dWFsSW5mb3JtYXRpb246W1wiZGVzY3JpcHRpb25cIiwgXCJOT1JNQUxJWkVEX01VVFVBTF9JTkZPUk1BVElPTlwiICwgMTJdLFxuICAgIGphY2NhcmRTaW1pbGFyaXR5U2NvcmU6W1wiZGVzY3JpcHRpb25cIiwgXCJKQUNDQVJEX1NJTUlMQVJJVFlfU0NPUkVcIiAsIDEzXSxcbiAgICBleGVjdXRpb25UaW1lOltcImRlc2NyaXB0aW9uXCIsIFwiRVhFQ1VUSU9OX1RJTUVcIiAsIDE0XX07XG5cbmxldCBkM21UYXNrVHlwZSA9IHt0YXNrVHlwZVVuZGVmaW5lZDpbXCJkZXNjcmlwdGlvblwiLFwiVEFTS19UWVBFX1VOREVGSU5FRFwiLCAwXSxjbGFzc2lmaWNhdGlvbjpbXCJkZXNjcmlwdGlvblwiLCBcIkNMQVNTSUZJQ0FUSU9OXCIgLCAxXSxcbnJlZ3Jlc3Npb246W1wiZGVzY3JpcHRpb25cIiwgXCJSRUdSRVNTSU9OXCIgLCAyXSxcbnNpbWlsYXJpdHlNYXRjaGluZzpbXCJkZXNjcmlwdGlvblwiLCBcIlNJTUlMQVJJVFlfTUFUQ0hJTkdcIiAsIDNdLFxubGlua1ByZWRpY3Rpb246W1wiZGVzY3JpcHRpb25cIiwgXCJMSU5LX1BSRURJQ1RJT05cIiAsIDRdLFxudmVydGV4Tm9taW5hdGlvbjpbXCJkZXNjcmlwdGlvblwiLCBcIlZFUlRFWF9OT01JTkFUSU9OXCIgLCA1XSxcbmNvbW11bml0eURldGVjdGlvbjpbXCJkZXNjcmlwdGlvblwiLCBcIkNPTU1VTklUWV9ERVRFQ1RJT05cIiAsIDZdLFxuZ3JhcGhNYXRjaGluZzpbXCJkZXNjcmlwdGlvblwiLCBcIkdSQVBIX01BVENISU5HXCIgLCA3XSxcbnRpbWVzZXJpZXNGb3JlY2FzdGluZzpbXCJkZXNjcmlwdGlvblwiLCBcIlRJTUVTRVJJRVNfRk9SRUNBU1RJTkdcIiAsIDhdLFxuICAgIGNvbGxhYm9yYXRpdmVGaWx0ZXJpbmc6W1wiZGVzY3JpcHRpb25cIiwgXCJDT0xMQUJPUkFUSVZFX0ZJTFRFUklOR1wiICwgOV19O1xuXG5sZXQgZDNtVGFza1N1YnR5cGUgPSB7dGFza1N1YnR5cGVVbmRlZmluZWQ6W1wiZGVzY3JpcHRpb25cIiwgXCJUQVNLX1NVQlRZUEVfVU5ERUZJTkVEXCIsIDBdLFxuc3VidHlwZU5vbmU6W1wiZGVzY3JpcHRpb25cIixcIk5PTkVcIiwxXSxcbiAgICBiaW5hcnk6W1wiZGVzY3JpcHRpb25cIiwgXCJCSU5BUllcIiAsIDJdLFxubXVsdGlDbGFzczpbXCJkZXNjcmlwdGlvblwiLCBcIk1VTFRJQ0xBU1NcIiAsIDNdLFxubXVsdGlMYWJlbDpbXCJkZXNjcmlwdGlvblwiLCBcIk1VTFRJTEFCRUxcIiAsIDRdLFxudW5pVmFyaWF0ZTpbXCJkZXNjcmlwdGlvblwiLCBcIlVOSVZBUklBVEVcIiAsIDVdLFxubXVsdGlWYXJpYXRlOltcImRlc2NyaXB0aW9uXCIsIFwiTVVMVElWQVJJQVRFXCIgLCA2XSxcbm92ZXJsYXBwaW5nOltcImRlc2NyaXB0aW9uXCIsIFwiT1ZFUkxBUFBJTkdcIiAsIDddLFxuICAgIG5vbk92ZXJsYXBwaW5nOltcImRlc2NyaXB0aW9uXCIsIFwiTk9OT1ZFUkxBUFBJTkdcIiAsIDhdfTtcblxubGV0IGQzbU91dHB1dFR5cGUgPSB7b3V0cHV0VW5kZWZpbmVkOltcImRlc2NyaXB0aW9uXCIsXCJPVVRQVVRfVFlQRV9VTkRFRklORUQgXCIsIDBdLFxuY2xhc3NMYWJlbDpbXCJkZXNjcmlwdGlvblwiLFwiQ0xBU1NfTEFCRUxcIiwgMV0sXG5wcm9iYWJpbGl0eTpbXCJkZXNjcmlwdGlvblwiLFwiUFJPQkFCSUxJVFlcIiwgMl0sXG5yZWFsOltcImRlc2NyaXB0aW9uXCIsXCJSRUFMXCIsIDNdLFxubm9kZUlEOltcImRlc2NyaXB0aW9uXCIsXCJOT0RFX0lEXCIsIDRdLFxudmVjdG9yQ2xhc3NMYWJlbDpbXCJkZXNjcmlwdGlvblwiLFwiVkVDVE9SX0NMQVNTX0xBQkVMXCIsIDVdLFxuICAgIHZlY3RvclN0b2NoYXN0aWM6W1wiZGVzY3JpcHRpb25cIixcIlZFQ1RPUl9TVE9DSEFTVElDXCIsIDZdLFxuICAgIHZlY3RvclJlYWw6W1wiZGVzY3JpcHRpb25cIixcIlZFQ1RPUl9SRUFMXCIsIDddLFxuICAgIGZpbGU6W1wiZGVzY3JpcHRpb25cIixcIkZJTEVcIiw4XX07XG5cbmxldCBkM21Qcm9ibGVtRGVzY3JpcHRpb24gPSB7XG50YXNrVHlwZTogWzIsXCJERUZBVUxUXCJdLFxudGFza1N1YnR5cGU6IFsxLFwiREVGQUZVTFRcIl0sXG5vdXRwdXRUeXBlOiBbMyxcIkRFRkFVTFRcIl0sXG4gICAgbWV0cmljOiBbNCxcIkRFRkFVTFRcIl0sXG4gICAgdGFza0Rlc2NyaXB0aW9uOiBcIlwifTtcblxuXG5sZXQgc3ZnLCB3aWR0aCwgaGVpZ2h0LCBkaXYsIGVzdGltYXRlTGFkZGEsIHNlbGVjdExhZGRhO1xubGV0IGFyYzEsIGFyYzMsIGFyYzQsIGFyY0luZDEsIGFyY0luZDI7XG5cbmxldCBhcmNJbmQxTGltaXRzID0gWzAsMC4zXTtcbmxldCBhcmNJbmQyTGltaXRzID0gWzAuMzUsMC42NV07XG5cbmxldCBieUlkID0gaWQgPT4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuXG4vLyBwYWdlIHJlbG9hZCBsaW5rZWQgdG8gYnRuUmVzZXRcbmV4cG9ydCBjb25zdCByZXNldCA9IGZ1bmN0aW9uIHJlbG9hZFBhZ2UoKSB7XG4gIGxvY2F0aW9uLnJlbG9hZCgpO1xufVxuXG5cbmxldCBkYXRhdXJsID0gXCJcIjtcbmV4cG9ydCBmdW5jdGlvbiBtYWluKGZpbGVpZCwgaG9zdG5hbWUsIGRkaXVybCwgZGF0YXVybCwgYXBpa2V5KSB7XG4gICAgZGF0YXVybCA9IGRhdGF1cmw7XG4gICAgaWYgKHByb2R1Y3Rpb24gJiYgZmlsZWlkID09IFwiXCIpIHtcbiAgICAgICAgYWxlcnQoXCJFcnJvcjogTm8gZmlsZWlkIGhhcyBiZWVuIHByb3ZpZGVkLlwiKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3I6IE5vIGZpbGVpZCBoYXMgYmVlbiBwcm92aWRlZC5cIik7XG4gICAgfVxuXG4gICAgbGV0IGRhdGF2ZXJzZXVybCA9IGhvc3RuYW1lID8gXCJodHRwczovL1wiICsgaG9zdG5hbWUgOlxuICAgICAgICBwcm9kdWN0aW9uID8gREFUQVZFUlNFX1VSTCA6XG4gICAgICAgIFwiaHR0cDovL2xvY2FsaG9zdDo4MDgwXCI7XG5cbiAgICBpZiAoZmlsZWlkICYmICFkYXRhdXJsKSB7XG4gICAgICAgIC8vIGZpbGUgaWQgc3VwcGxpZWQ7IGFzc3VtZSB3ZSBhcmUgZGVhbGluZyB3aXRoIGRhdGF2ZXJzZSBhbmQgY29vayBhIHN0YW5kYXJkIGRhdGF2ZXJzZSBkYXRhIGFjY2VzcyB1cmxcbiAgICAgICAgLy8gd2l0aCB0aGUgZmlsZWlkIHN1cHBsaWVkIGFuZCB0aGUgaG9zdG5hbWUgd2UgaGF2ZSBzdXBwbGllZCBvciBjb25maWd1cmVkXG4gICAgICAgIGRhdGF1cmwgPSBkYXRhdmVyc2V1cmwgKyBcIi9hcGkvYWNjZXNzL2RhdGFmaWxlL1wiICsgZmlsZWlkO1xuICAgICAgICAvLyBycDsgdGVtcG9yYXJpbHkgcmVtb3ZlIHRoaXNcbiAgICAgICAgZGF0YXVybCA9IGRhdGF1cmwgKyBcIj9rZXk9XCIgKyBhcGlrZXk7XG4gICAgfVxuICAgIGNkYignLS1kYXRhdXJsOiAnICsgZGF0YXVybCk7XG4gICAgY2RiKCctLWRhdGF2ZXJzZXVybDogJyArIGRhdGF2ZXJzZXVybCk7XG4gICAgc3ZnID0gZDMuc2VsZWN0KFwiI3doaXRlc3BhY2VcIik7XG5cbiAgICBsZXQgdGVtcFdpZHRoID0gZDMuc2VsZWN0KFwiI21haW4ubGVmdFwiKS5zdHlsZShcIndpZHRoXCIpO1xuICAgIHdpZHRoID0gdGVtcFdpZHRoLnN1YnN0cmluZygwLCB0ZW1wV2lkdGgubGVuZ3RoIC0gMik7XG4gICAgaGVpZ2h0ID0gJCh3aW5kb3cpLmhlaWdodCgpIC0gMTIwOyAvLyBIYXJkIGNvZGluZyBmb3IgaGVhZGVyIGFuZCBmb290ZXIgYW5kIGJvdHRvbSBtYXJnaW4uXG5cbiAgICBlc3RpbWF0ZUxhZGRhID0gTGFkZGEuY3JlYXRlKGJ5SWQoXCJidG5Fc3RpbWF0ZVwiKSk7XG4gICAgc2VsZWN0TGFkZGEgPSBMYWRkYS5jcmVhdGUoYnlJZChcImJ0blNlbGVjdFwiKSk7XG5cbiAgICBsZXQgY29sb3JUaW1lID0gZmFsc2U7XG4gICAgbGV0IGNvbG9yQ1MgPSBmYWxzZTtcblxuICAgIGxldCBkZXBWYXIgPSBmYWxzZTtcbiAgICBsZXQgc3Vic2V0ZGl2ID0gZmFsc2U7XG4gICAgbGV0IHNldHhkaXYgPSBmYWxzZTtcblxuICAgIC8vIHdpZHRoIGFuZCBoZWlnaHQgZm9yIGhpc3RncmFtc1xuICAgIGxldCBiYXJ3aWR0aCA9IDEuMyAqIGFsbFI7XG4gICAgbGV0IGJhcmhlaWdodCA9IDAuNSAqIGFsbFI7XG4gICAgbGV0IGJhclBhZGRpbmcgPSAwLjM1O1xuICAgIGxldCBiYXJudW1iZXIgPSA3O1xuXG4gICAgLy8gYXJjcyBmb3IgZGVub3RpbmcgcGViYmxlIGNoYXJhY3RlcmlzdGljc1xuICAgIGxldCBhcmMgPSAoc3RhcnQsIGVuZCkgPT4gZDMuc3ZnLmFyYygpXG4gICAgICAgIC5pbm5lclJhZGl1cyhhbGxSICsgNSlcbiAgICAgICAgLm91dGVyUmFkaXVzKGFsbFIgKyAyMClcbiAgICAgICAgLnN0YXJ0QW5nbGUoc3RhcnQpXG4gICAgICAgIC5lbmRBbmdsZShlbmQpO1xuICAgIGxldCBhcmNJbmQgPSAoYXJjbGltaXRzKSA9PiBkMy5zdmcuYXJjKClcbiAgICAgICAgLmlubmVyUmFkaXVzKGFsbFIgKyAyMilcbiAgICAgICAgLm91dGVyUmFkaXVzKGFsbFIgKyAzNylcbiAgICAgICAgLnN0YXJ0QW5nbGUoYXJjbGltaXRzWzBdKVxuICAgICAgICAuZW5kQW5nbGUoYXJjbGltaXRzWzFdKTtcblxuICAgIGxldCBbYXJjMCwgYXJjMl0gPSBbYXJjKDAsIDMuMiksIGFyYygxLjEsIDIuMildO1xuICAgIC8vYXJjMSA9IGFyYygxLjMsIDIuMyk7XG4gICAgYXJjMSA9IGFyYygwLDEpO1xuICAgIGFyYzMgPSBhcmMoMi4zLCAzLjMpO1xuICAgIGFyYzQgPSBhcmMoNC4zLCA1LjMpO1xuXG4gICAgYXJjSW5kMSA9IGFyY0luZChhcmNJbmQxTGltaXRzKTtcbiAgICBhcmNJbmQyID0gYXJjSW5kKGFyY0luZDJMaW1pdHMpO1xuXG4gICAgLy8gaW5kaWNhdG9ycyBmb3Igc2hvd2luZyBtZW1iZXJzaGlwIGFib3ZlIGFyY3NcbiAgICAvLyBsZXQgaW5kaWNhdG9yID0gKGRlZ3JlZSkgPT4gZDMuc3ZnLmNpcmNsZSgpXG4gICAgLy8gICAgIC5jeCggYWxsUiApLy8oYWxsUiszNSkgKiBNYXRoLnNpbihkZWdyZWUpKVxuICAgIC8vICAgICAuY3koIGFsbFIgKS8vKGFsbFIrMzUpICogTWF0aC5jb3MoZGVncmVlKSlcbiAgICAvLyAgICAgLnIoMyk7XG4gICAgLy8gaW5kMSA9IGluZGljYXRvcigxKTtcbiAgICAvLyBpbmQyID0gaW5kaWNhdG9yKDEuMik7XG5cbiAgICAvLyBmcm9tIC5jc3ZcbiAgICBsZXQgZGF0YXNldDIgPSBbXTtcbiAgICBsZXQgbGFibEFycmF5ID0gW107XG4gICAgbGV0IGhvbGQgPSBbXTtcbiAgICBsZXQgc3Vic2V0Tm9kZXMgPSBbXTtcblxuICAgIC8vIGNvbGxhcHNhYmxlIHVzZXIgbG9nXG4gICAgJCgnI2NvbGxhcHNlTG9nJykub24oJ3Nob3duLmJzLmNvbGxhcHNlJywgKCkgPT4gZDMuc2VsZWN0KFwiI2NvbGxhcHNlTG9nIGRpdi5wYW5lbC1ib2R5XCIpLnNlbGVjdEFsbChcInBcIilcbiAgICAgICAgLmRhdGEobG9nQXJyYXkpXG4gICAgICAgIC5lbnRlcigpXG4gICAgICAgIC5hcHBlbmQoXCJwXCIpXG4gICAgICAgIC50ZXh0KGQgPT4gZCkpO1xuICAgICQoJyNjb2xsYXBzZUxvZycpLm9uKCdoaWRkZW4uYnMuY29sbGFwc2UnLCAoKSA9PiBkMy5zZWxlY3QoXCIjY29sbGFwc2VMb2cgZGl2LnBhbmVsLWJvZHlcIikuc2VsZWN0QWxsKFwicFwiKVxuICAgICAgICAucmVtb3ZlKCkpO1xuXG4gICAgLy9zZXQgc3RhcnQgZnJvbSB1c2VyIGlucHV0LCB0aGVuIGFzc3VtZSBsb2NhdGlvbnMgYXJlIGNvbnNpc3RlbnQgYmFzZWQgb24gZDNtIGRpcmVjdG9yeSBzdHJ1Y3R1cmUgKGFsdGVybmF0aXZlbHkgY2FuIG1ha2UgZWFjaCBvZiB0aGVzZSBsb2NhdGlvbnMgYmUgc2V0IGJ5IHVzZXIpXG4gICAgbGV0IGQzbVJvb3RQYXRoID0gXCJcIjtcbiAgICBsZXQgZDNtRGF0YU5hbWUgPSBcIlwiO1xuICAgIGxldCBkM21EYXRhID0gbnVsbDtcbiAgICBsZXQgZDNtVGFyZ2V0ID0gbnVsbDtcbiAgICBsZXQgZDNtUHJlcHJvY2VzcyA9IFwiXCI7XG4gICAgbGV0IGQzbVBTID0gXCJcIjtcbiAgICBsZXQgZDNtRFMgPSBcIlwiO1xuXG4gICAgLy8gZGVmYXVsdCB0byBDYWxpZm9ybmlhIFBVTVMgc3Vic2V0IChzaG91bGQsIGRvZXNuJ3QgYWN0dWFsbHkgZG8gdGhhdClcbiAgICBsZXQgZGF0YSA9ICdkYXRhLycgKyAoZmFsc2UgPyAnUFVNUzVzbWFsbCcgOiAnZmVhcm9uTGFpdGluJyk7XG4gICAgbGV0IG1ldGFkYXRhdXJsID0gZGRpdXJsIHx8IChmaWxlaWQgPyBgJHtkYXRhdmVyc2V1cmx9L2FwaS9tZXRhL2RhdGFmaWxlLyR7ZmlsZWlkfWAgOiBkYXRhICsgJy54bWwnKTtcbiAgICAvLyByZWFkIHByZS1wcm9jZXNzZWQgbWV0YWRhdGEgYW5kIGRhdGFcbiAgICBsZXQgcFVSTCA9IGRhdGF1cmwgPyBgJHtkYXRhdXJsfSZmb3JtYXQ9cHJlcGAgOiBkYXRhICsgJy5qc29uJztcblxuICAgIGlmKGQzbV9tb2RlKSB7XG4gICAgICAgIHBVUkwgPSBkM21QcmVwcm9jZXNzO1xuICAgICAgICAvLyB6cGFyYW1zLnpkYXRhdXJsID0gc3RhcnQrJy9kYXRhL3RyYWluRGF0YW1lcmdlZC50c3YnOyAgIC8vIFwic3RhcnRcIiBwYXRoIG5vIGxvbmdlciBleGlzdHNcbiAgICAgICAgLy8genBhcmFtcy56ZGF0YSA9IGQzbURhdGFOYW1lOyAgIC8vIHRoaXMgaXMgbm93IGdvaW5nIHRvIGJlIGZpbGxlZCBpbiB1c2luZyBwcm9ibGVtIHNjaGVtYSBmaWVsZFxuICAgIH0gZWxzZSBpZighcHJvZHVjdGlvbikge1xuICAgICAgICB6cGFyYW1zLnpkYXRhdXJsID0gJ2RhdGEvZmVhcm9uTGFpdGluLnRzdic7XG4gICAgfVxuXG4gICAgLypcbiAgICBMb2FkcyBhbGwgZXh0ZXJuYWwgZGF0YSBpbiB0aGUgZm9sbG93aW5nIG9yZGVyIChsb2dpYyBpcyBub3QgaW5jbHVkZWQpOlxuICAgIDEuIFJldHJpZXZlIHRoZSBjb25maWd1cmF0aW9uIGluZm9ybWF0aW9uXG4gICAgMi4gU2V0ICdjb25maWd1cmF0aW9ucydcbiAgICAzLiBSZWFkIHRoZSBwcm9ibGVtIHNjaGVtYSBhbmQgc2V0ICdkM21Qcm9ibGVtRGVzY3JpcHRpb24nXG4gICAgNC4gUmVhZCB0aGUgZGF0YSBzY2hlbWEgYW5kIHNldCAnZGF0YXNjaGVtYSdcbiAgICA1LiBSZWFkIGluIHplbGlnIG1vZGVscyAobm90IGZvciBkM20pXG4gICAgNi4gUmVhZCBpbiB6ZWxpZ2Nob2ljZSBtb2RlbHMgKG5vdCBmb3IgZDNtKVxuICAgIDcuIFN0YXJ0IHRoZSB1c2VyIHNlc3Npb25cbiAgICA4LiBDYWxsIHJ1blByZXByb2Nlc3MoLi4uKVxuICAgIDkuIENhbGwgcmVhZFByZXByb2Nlc3MoLi4uKVxuICAgIDEwLiBCdWlsZCBhbGxOb2Rlc1tdIHVzaW5nIHByZXByb2Nlc3NlZCBpbmZvcm1hdGlvblxuICAgIDExLiBBZGQgZGF0YXNjaGVtYSBpbmZvcm1hdGlvbiB0byBhbGxOb2RlcyAod2hlbiBpbiBkM21fbW9kZSlcbiAgICAxMi4gQ2FsbCBzY2FmZm9sZGluZygpIGFuZCBzdGFydCBoZXIgdXBcbiAgICAqL1xuXG4gICAgUHJvbWlzZS5yZXNvbHZlKGQzbV9tb2RlICYmIG0ucmVxdWVzdCh7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIHVybDogXCIvY29uZmlnL2QzbS1jb25maWcvanNvbi9sYXRlc3RcIlxuICAgIH0pXG4gICAgLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgIGNvbmZpZ3VyYXRpb25zID0gIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocmVzdWx0KSk7XG4gICAgICAgIGQzbVJvb3RQYXRoID0gY29uZmlndXJhdGlvbnMudHJhaW5pbmdfZGF0YV9yb290O1xuICAgICAgICBkM21Sb290UGF0aCA9IGQzbVJvb3RQYXRoLnJlcGxhY2UoL1xcL2RhdGEvLCcnKTtcbiAgICAgICAgZDNtRGF0YU5hbWUgPSBjb25maWd1cmF0aW9ucy5uYW1lO1xuICAgICAgLy8gIGQzbURhdGEgPSBjb25maWd1cmF0aW9ucy50cmFpbmluZ19kYXRhX3Jvb3QrXCIvdHJhaW5EYXRhLmNzdlwiO1xuICAgICAgIC8vIGQzbVRhcmdldCA9IGNvbmZpZ3VyYXRpb25zLnRyYWluaW5nX2RhdGFfcm9vdCtcIi90cmFpblRhcmdldHMuY3N2XCI7XG4gICAgICAgIGQzbVBTID0gY29uZmlndXJhdGlvbnMucHJvYmxlbV9zY2hlbWFfdXJsO1xuICAgICAgICBkM21EUyA9IGNvbmZpZ3VyYXRpb25zLmRhdGFzZXRfc2NoZW1hX3VybDtcblxuICAgICAgICAgIGNvbnNvbGUubG9nKFwiQ29uZmlndXJhdGlvbnM6IFwiKTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhjb25maWd1cmF0aW9ucyk7XG5cbiAgICAgICAgLy8gdGhlc2UgYXJlIHRoZSB0d28gbGluZXMgdGhhdCBjdXQgdGhlIGNvbmZpZyBwYXRocyBhZnRlciBcIlR3b1JhdmVucy9cIlxuICAgICAgICAvL2QzbVRhcmdldCA9IGQzbVRhcmdldC5zcGxpdChcIlR3b1JhdmVucy9cIikucG9wKCk7XG4gICAgICAgIC8vZDNtRGF0YSA9IGQzbURhdGEuc3BsaXQoXCJUd29SYXZlbnMvXCIpLnBvcCgpO1xuXG4gICAgICAgIHBVUkw9J3Jvb2stY3VzdG9tL3Jvb2stZmlsZXMvJytkM21EYXRhTmFtZSsnL3ByZXByb2Nlc3MvcHJlcHJvY2Vzcy5qc29uJztcbiAgICAgICAgZDNtUHJlcHJvY2Vzcz1wVVJMO1xuICAgIH0pKVxuICAgIC50aGVuKF8gPT4gbS5yZXF1ZXN0KHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICB1cmw6IFwiL2NvbmZpZy9kM20tY29uZmlnL2dldC1wcm9ibGVtLWRhdGEtZmlsZS1pbmZvXCJcbiAgICB9KVxuICAgIC50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAvLyBzb21lIHNpbXBsZSBsb2dpYyB0byBnZXQgdGhlIHBhdGhzIHJpZ2h0XG4gICAgICAgIC8vIG5vdGUgdGhhdCBpZiBuZWl0aGVyIGV4aXN0LCBzdGF5IGFzIGRlZmF1bHQgd2hpY2ggaXMgbnVsbFxuICAgICAgICBpZihyZXN1bHQuZGF0YVsndHJhaW5EYXRhLmNzdiddLmV4aXN0cz09dHJ1ZSlcbiAgICAgICAgICAgIGQzbURhdGE9cmVzdWx0LmRhdGFbJ3RyYWluRGF0YS5jc3YnXS5wYXRoO1xuICAgICAgICBlbHNlIGlmKHJlc3VsdC5kYXRhWyd0cmFpbkRhdGEuY3N2Lmd6J10uZXhpc3RzPT10cnVlKVxuICAgICAgICAgICAgZDNtRGF0YT1yZXN1bHQuZGF0YVsndHJhaW5EYXRhLmNzdi5neiddLnBhdGg7XG5cbiAgICAgICAgaWYocmVzdWx0LmRhdGFbJ3RyYWluVGFyZ2V0cy5jc3YnXS5leGlzdHM9PXRydWUpXG4gICAgICAgICAgICBkM21UYXJnZXQ9cmVzdWx0LmRhdGFbJ3RyYWluVGFyZ2V0cy5jc3YnXS5wYXRoO1xuICAgICAgICBlbHNlIGlmKHJlc3VsdC5kYXRhWyd0cmFpblRhcmdldHMuY3N2Lmd6J10uZXhpc3RzPT10cnVlKVxuICAgICAgICAgICAgZDNtVGFyZ2V0PXJlc3VsdC5kYXRhWyd0cmFpblRhcmdldHMuY3N2Lmd6J10ucGF0aDtcblxuICAgICAgICB6cGFyYW1zLnpkM21kYXRhID0gZDNtRGF0YTtcbiAgICAgICAgenBhcmFtcy56ZDNtdGFyZ2V0ID0gZDNtVGFyZ2V0O1xuICAgIH0pKVxuICAgIC50aGVuKCgpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIC8vIHJlYWQgaW4gcHJvYmxlbSBzY2hlbWEgYW5kIHdlJ2xsIG1ha2UgYSBjYWxsIHRvIHN0YXJ0IHRoZSBzZXNzaW9uIHdpdGggVEEyLiBpZiB3ZSBnZXQgdGhpcyBmYXIsIGRhdGEgYXJlIGd1YXJhbnRlZWQgdG8gZXhpc3QgZm9yIHRoZSBmcm9udGVuZFxuICAgICAgICAgICAgaWYgKCFkM21fbW9kZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuXG4gICAgICAgICAgICBkMy5qc29uKGQzbVBTLCAoXywgZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwicHJvYiBzY2hlbWEgZGF0YTogXCIsIGRhdGEpO1xuICAgICAgICAgICAgICAgIG15dGFyZ2V0ID0gZGF0YS50YXJnZXQuZmllbGQ7XG5cbiAgICAgICAgICAgIGxldCB0ZW1wPVwiXCI7XG4gICAgICAgICAgICBpZighZDNtX21vZGUpIHtcbiAgICAgICAgICAgICAgICB0ZW1wID0geG1sLmRvY3VtZW50RWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImZpbGVOYW1lXCIpOyAgICAgLy8gTm90ZTogcHJlc2VudGx5IHhtbCBpcyBubyBsb25nZXIgYmVpbmcgcmVhZCBmcm9tIERhdGF2ZXJzZSBtZXRhZGF0YSBhbnl3aGVyZVxuICAgICAgICAgICAgICAgIHpwYXJhbXMuemRhdGEgPSB0ZW1wWzBdLmNoaWxkTm9kZXNbMF0ubm9kZVZhbHVlO1xuICAgICAgICAgICAgICAgIGxldCBjaXRlID0geG1sLmRvY3VtZW50RWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImJpYmxDaXRcIik7XG4gICAgICAgICAgICAgICAgLy8gY2xlYW4gY2l0YXRpb24gc28gUE9TVCBpcyB2YWxpZCBqc29uXG4gICAgICAgICAgICAgICAgenBhcmFtcy56ZGF0YWNpdGUgPSBjaXRlWzBdLmNoaWxkTm9kZXNbMF0ubm9kZVZhbHVlXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXCYvZywgXCJhbmRcIilcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcOy9nLCBcIixcIilcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcJS9nLCBcIi1cIik7XG4gICAgICAgICAgICAgICAgJCgnI2NpdGUgZGl2LnBhbmVsLWJvZHknKS50ZXh0KHpwYXJhbXMuemRhdGFjaXRlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgenBhcmFtcy56ZGF0YSA9IGRhdGEuZGF0YXNldHNbMF07ICAgICAgICAgICAgIC8vIHJlYWQgdGhlIGRhdGFzZXQgbmFtZSBmcm9tIHRoZSBwcm9ibGVtIHNjaGVtYVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZGF0YXNldCBuYW1lIHRyaW1tZWQgdG8gMTIgY2hhcnNcbiAgICAgICAgICAgIGxldCBkYXRhbmFtZSA9IHpwYXJhbXMuemRhdGE7XG4gICAgICAgICAgICBpZighZDNtX21vZGUpIHtcbiAgICAgICAgICAgICAgICBkYXRhbmFtZSA9IHpwYXJhbXMuemRhdGEucmVwbGFjZSgvXFwuKC4qKS8sICcnKTsgLy8gZHJvcCBmaWxlIGV4dGVuc2lvblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkMy5zZWxlY3QoXCIjZGF0YU5hbWVcIikuaHRtbChkYXRhbmFtZSk7XG4gICAgICAgICAgICAvLyBQdXQgZGF0YXNldCBuYW1lLCBmcm9tIG1ldGEtZGF0YSwgaW50byBwYWdlIHRpdGxlXG4gICAgICAgICAgICBkMy5zZWxlY3QoXCJ0aXRsZVwiKS5odG1sKFwiVHdvUmF2ZW5zIFwiICsgZGF0YW5hbWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vVGhpcyBhZGRzIGEgaW5rIHRvIHByb2JsZW1EZXNjcmlwdGlvbi50eHQgaW4gdGhlIHRpY2tlclxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgbGV0IGFUYWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICAgICAgICAgICAgYVRhZy5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBgJHtkM21Sb290UGF0aH0vJHtkYXRhLmRlc2NyaXB0aW9uRmlsZX1gKTtcbiAgICAgICAgICAgICAgICBhVGFnLnNldEF0dHJpYnV0ZSgnaWQnLCBcInByb2JkZXNjXCIpO1xuICAgICAgICAgICAgICAgIGFUYWcuc2V0QXR0cmlidXRlKCd0YXJnZXQnLCBcIl9ibGFua1wiKTtcbiAgICAgICAgICAgICAgICBhVGFnLnRleHRDb250ZW50ID0gXCJQcm9ibGVtIERlc2NyaXB0aW9uXCI7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ0aWNrZXJcIikuYXBwZW5kQ2hpbGQoYVRhZyk7XG4gICAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgICBpZihkYXRhLnRhc2tUeXBlIGluIGQzbVRhc2tUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGQzbVByb2JsZW1EZXNjcmlwdGlvbi50YXNrVHlwZSA9IGRhdGEudGFza1R5cGU7Ly9bZDNtVGFza1R5cGVbZGF0YS50YXNrVHlwZV1bMl0sZDNtVGFza1R5cGVbZGF0YS50YXNrVHlwZV1bMV1dOyBjb25zb2xlLmxvZyhkM21Qcm9ibGVtRGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGQzbVByb2JsZW1EZXNjcmlwdGlvbi50YXNrVHlwZSA9IFwidGFza1R5cGVVbmRlZmluZWRcIjtcbiAgICAgICAgICAgICAgICAgLy8gICBhbGVydChcIlNwZWNpZmllZCB0YXNrIHR5cGUsIFwiICsgZGF0YS50YXNrVHlwZSArIFwiLCBpcyBub3QgdmFsaWQuXCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmKGRhdGEudGFza1N1YlR5cGUgaW4gZDNtVGFza1N1YnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZDNtUHJvYmxlbURlc2NyaXB0aW9uLnRhc2tTdWJ0eXBlID0gZGF0YS50YXNrU3ViVHlwZTtcbiAgICAgICAgICAgICAgICAgICAgLy9bZDNtVGFza1N1YnR5cGVbZGF0YS50YXNrU3ViVHlwZV1bMl0sZDNtVGFza1N1YnR5cGVbZGF0YS50YXNrU3ViVHlwZV1bMV1dO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZDNtUHJvYmxlbURlc2NyaXB0aW9uLnRhc2tTdWJ0eXBlID0gXCJ0YXNrU3VidHlwZVVuZGVmaW5lZFwiO1xuICAgICAgICAgICAgICAgICAgIC8vICAgICBhbGVydChcIlNwZWNpZmllZCB0YXNrIHN1YnR5cGUsIFwiICsgZGF0YS50YXNrU3ViVHlwZSArIFwiLCBpcyBub3QgdmFsaWQuXCIpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZihkYXRhLm1ldHJpYyBpbiBkM21NZXRyaWNzKSB7XG4gICAgICAgICAgICAgICAgICAgIGQzbVByb2JsZW1EZXNjcmlwdGlvbi5tZXRyaWMgPSBkYXRhLm1ldHJpYzsvL1tkM21NZXRyaWNzW2RhdGEubWV0cmljXVsyXSxkM21NZXRyaWNzW2RhdGEubWV0cmljXVsxXV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZDNtUHJvYmxlbURlc2NyaXB0aW9uLm1ldHJpYyA9IFwibWV0cmljVW5kZWZpbmVkXCI7XG4gICAgICAgICAgICAgICAgICAgLy8gYWxlcnQoXCJTcGVjaWZpZWQgbWV0cmljIHR5cGUsIFwiICsgZGF0YS5tZXRyaWMgKyBcIiwgaXMgbm90IHZhbGlkLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmKGRhdGEub3V0cHV0VHlwZSBpbiBkM21PdXRwdXRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGQzbVByb2JsZW1EZXNjcmlwdGlvbi5vdXRwdXRUeXBlID0gZGF0YS5vdXRwdXRUeXBlOy8vW2QzbU91dHB1dFR5cGVbZGF0YS5vdXRwdXRUeXBlXVsyXSxkM21PdXRwdXRUeXBlW2RhdGEub3V0cHV0VHlwZV1bMV1dO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGQzbVByb2JsZW1EZXNjcmlwdGlvbi5vdXRwdXRUeXBlID0gXCJvdXRwdXRVbmRlZmluZWRcIjtcbiAgICAgICAgICAgICAgICAgIC8vICBhbGVydChcIlNwZWNpZmllZCBvdXRwdXQgdHlwZSwgXCIgKyBkYXRhLm91dHB1dFR5cGUgKyBcIiwgaXMgbm90IHZhbGlkLlwiKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkM21Qcm9ibGVtRGVzY3JpcHRpb24udGFza0Rlc2NyaXB0aW9uID0gZGF0YS5kZXNjcmlwdGlvbkZpbGU7XG5cblxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiYnRuVHlwZVwiKS5jbGljaygpO1xuXG4gICAgICAgICAgICAvLyBtYWtpbmcgaXQgY2FzZSBpbnNlbnNpdGl2ZSBiZWNhdXNlIHRoZSBjYXNlIHNlZW1zIHRvIGRpc2FncmVlIGFsbCB0b28gb2Z0ZW5cbiAgICAgICAgICAgICAgICBpZihmYWlsc2V0LmluZGV4T2YoZDNtUHJvYmxlbURlc2NyaXB0aW9uLnRhc2tUeXBlLnRvVXBwZXJDYXNlKCkpID09IC0xKVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN3YW5kaXZlPXRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkpXG4gICAgICAgIC50aGVuKCgpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHsgLy8gZ2V0IHRoZSBkYXRhIHNjaGVtYVxuICAgICAgICAgICAgaWYgKCFkM21fbW9kZSl7cmV0dXJuIHJlc29sdmUoKTt9XG5cbiAgICAgICAgICAgIC8vIHJlYWQgdGhlIGRhdGEgc2NoZW1hIGFuZCBzZXQgZGF0YXNjaGVtYVxuICAgICAgICAgICAgZDMuanNvbihkM21EUywgKF8sIGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICBkYXRhc2NoZW1hID0gIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xuXG4gICAgICAgICAgICAgICAgLy8gaWYgc3dhbmRpdmUsIHdlIGhhdmUgdG8gc2V0IHZhbHVlS2V5IGhlcmUgc28gdGhhdCBsZWZ0IHBhbmVsIGNhbiBwb3B1bGF0ZVxuICAgICAgICAgICAgICAgIGlmKHN3YW5kaXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkYXRhdmFycyA9IGRhdGFzY2hlbWEudHJhaW5EYXRhLnRyYWluRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgaWYoZGF0YXZhcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGRhdGF2YXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVLZXkucHVzaChkYXRhdmFyc1tpXS52YXJOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0dmFycyA9IGRhdGFzY2hlbWEudHJhaW5EYXRhLnRyYWluVGFyZ2V0cztcbiAgICAgICAgICAgICAgICAgICAgaWYodGFyZ2V0dmFycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGFyZ2V0dmFycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlS2V5LnB1c2godGFyZ2V0dmFyc1tpXS52YXJOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZih2YWx1ZUtleS5sZW5ndGg9PTApXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlbmQgc2Vzc2lvbiBpZiBuZWl0aGVyIHRyYWluRGF0YSBub3IgdHJhaW5UYXJnZXRzP1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxlcnQoXCJubyB0cmFpbkRhdGEgb3IgdHJhaW5UYXJnZXN0IGluIGRhdGEgZGVzY3JpcHRpb24gZmlsZS4gdmFsdWVLZXkgbGVuZ3RoIGlzIDBcIik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJkYXRhIHNjaGVtYSBkYXRhOiBcIiwgZGF0YXNjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfSkpXG4gICAgICAgIC50aGVuKCgpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHsgLy8gcmVhZCBpbiB6ZWxpZyBtb2RlbHNcbiAgICAgICAgICAgIGlmIChkM21fbW9kZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgICAgICAgICAgLy8gcmVhZCB6ZWxpZyBtb2RlbHMgYW5kIHBvcHVsYXRlIG1vZGVsIGxpc3QgaW4gcmlnaHQgcGFuZWxcbiAgICAgICAgICAgIGQzLmpzb24oXCJkYXRhL3plbGlnNW1vZGVscy5qc29uXCIsIChlcnIsIGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgY2RiKFwiemVsaWcgbW9kZWxzIGpzb246IFwiLCBkYXRhKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gZGF0YS56ZWxpZzVtb2RlbHMpXG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLnplbGlnNW1vZGVscy5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kc1tkYXRhLnplbGlnNW1vZGVsc1trZXldLm5hbWVbMF1dID0gZGF0YS56ZWxpZzVtb2RlbHNba2V5XS5kZXNjcmlwdGlvblswXTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkpXG4gICAgICAgIC50aGVuKCgpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHsgLy8gcmVhZCBpbiB6ZWxpZyBjaG9pY2UgbW9kZWxzXG4gICAgICAgICAgICBpZiAoZDNtX21vZGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgICAgICAgIGQzLmpzb24oXCJkYXRhL3plbGlnNWNob2ljZW1vZGVscy5qc29uXCIsIChlcnIsIGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgY2RiKFwiemVsaWcgY2hvaWNlIG1vZGVscyBqc29uOiBcIiwgZGF0YSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIGRhdGEuemVsaWc1Y2hvaWNlbW9kZWxzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLnplbGlnNWNob2ljZW1vZGVscy5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kc1tkYXRhLnplbGlnNWNob2ljZW1vZGVsc1trZXldLm5hbWVbMF1dID0gZGF0YS56ZWxpZzVjaG9pY2Vtb2RlbHNba2V5XS5kZXNjcmlwdGlvblswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9KSlcbiAgICAgICAgLnRoZW4oKCkgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4geyAvLyBjYWxsIHRvIGRqYW5nbyB0byBzdGFydCB0aGUgc2Vzc2lvblxuICAgICAgICAgICAgICAgIGlmICghZDNtX21vZGUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgLy9ycGMgU3RhcnRTZXNzaW9uKFNlc3Npb25SZXF1ZXN0KSByZXR1cm5zIChTZXNzaW9uUmVzcG9uc2UpIHt9XG5cbiAgICAgICAgICAgICAgICBsZXQgdXNlcl9hZ2VudCA9IFwic29tZSBhZ2VudFwiO1xuICAgICAgICAgICAgICAgIGxldCB2ZXJzaW9uID0gXCJzb21lIHZlcnNpb25cIjtcbiAgICAgICAgICAgICAgICBsZXQgU2Vzc2lvblJlcXVlc3Q9e3VzZXJfYWdlbnQsdmVyc2lvbn07XG5cbiAgICAgICAgICAgICAgICB2YXIganNvbm91dCA9IEpTT04uc3RyaW5naWZ5KFNlc3Npb25SZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICB2YXIgdXJsY2FsbCA9IGQzbVVSTCArIFwiL3N0YXJ0c2Vzc2lvblwiO1xuICAgICAgICAgICAgICAgIHZhciBzb2xhanNvbm91dCA9IFwiZ3JwY3JlcXVlc3Q9XCIgKyBqc29ub3V0O1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU2Vzc2lvblJlcXVlc3Q6IFwiKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhzb2xhanNvbm91dCk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJ1cmxjYWxsOiBcIiwgdXJsY2FsbCk7XG5cbiAgICAgICAgICAgICAgICBpZih0dXRvcmlhbF9tb2RlKXsgLy8gJiYgZmlyc3RfbG9hZCl7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkbF9jb250ZW50ID0gXCI8cD5UaGlzIHRvb2wgY2FuIGd1aWRlIHlvdSB0byBzb2x2ZSBhbiBlbXBpcmljYWwgcHJvYmxlbSBpbiB0aGUgZGF0YXNldCBsaXN0ZWQgYWJvdmUuPC9wPjxwPlRoZXNlIG1lc3NhZ2VzIHdpbGwgdGVhY2ggeW91IHRoZSBzdGVwcyB0byB0YWtlIHRvIGZpbmQgYW5kIHN1Ym1pdCBhIHNvbHV0aW9uLjwvcD5cIjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc2V0X2NvbnRlbnQgPSBcIjxwPllvdSBjYW4gYWx3YXlzIHN0YXJ0IGEgcHJvYmxlbSBvdmVyIGJ5IHVzaW5nIHRoaXMgcmVzZXQgYnV0dG9uLjwvcD5cIlxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVwdmFyX2lkID0gbXl0YXJnZXQgKyBcImJpZ2dyb3VwXCI7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9ibGVtX2luaXRpYWxpemVkX3RvdXIgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgXCJpZFwiOiBcImRhdGFzZXRfbGF1bmNoXCIsXG4gICAgICAgICAgICAgICAgICAgICAgIFwiaTE4blwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcImRvbmVCdG5cIjonT2snXG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICBcInN0ZXBzXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCJkYXRhTmFtZVwiLCAvL2RvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIjZGF0YU5hbWVcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwicGxhY2VtZW50XCI6IFwiYm90dG9tXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwidGl0bGVcIjogXCJXZWxjb21lIHRvIFR3b1JhdmVucyBTb2x2ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjb250ZW50XCI6IGRsX2NvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwic2hvd0NUQUJ1dHRvblwiOnRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiY3RhTGFiZWxcIjogXCJEaXNhYmxlIHRoZXNlIG1lc3NhZ2VzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwib25DVEFcIjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9wc2NvdGNoLmVuZFRvdXIodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHV0b3JpYWxfbW9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCJidG5SZXNldFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcInBsYWNlbWVudFwiOiBcImJvdHRvbVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcInRpdGxlXCI6IFwiUmVzdGFydCBBbnkgUHJvYmxlbSBIZXJlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiY29udGVudFwiOiByZXNldF9jb250ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcInNob3dDVEFCdXR0b25cIjp0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImN0YUxhYmVsXCI6IFwiRGlzYWJsZSB0aGVzZSBtZXNzYWdlc1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcIm9uQ1RBXCI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvcHNjb3RjaC5lbmRUb3VyKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR1dG9yaWFsX21vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiYnRuRXN0aW1hdGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJwbGFjZW1lbnRcIjogXCJsZWZ0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwidGl0bGVcIjogXCJTb2x2ZSBQcm9ibGVtXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiY29udGVudFwiOiBcIjxwPlRoZSBjdXJyZW50IGdyZWVuIGJ1dHRvbiBpcyBnZW5lcmFsbHkgdGhlIG5leHQgc3RlcCB0byBmb2xsb3cgdG8gbW92ZSB0aGUgc3lzdGVtIGZvcndhcmQuPC9wPjxwPkNsaWNrIHRoaXMgU29sdmUgYnV0dG9uIHRvIHRlbGwgdGhlIHRvb2wgdG8gZmluZCBhIHNvbHV0aW9uIHRvIHRoZSBwcm9ibGVtLjwvcD5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzaG93Q1RBQnV0dG9uXCI6dHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjdGFMYWJlbFwiOiBcIkRpc2FibGUgdGhlc2UgbWVzc2FnZXNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvbkNUQVwiOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3BzY290Y2guZW5kVG91cih0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0dXRvcmlhbF9tb2RlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBkZXB2YXJfaWQsIC8vXCJjbGFzc2JpZ2dyb3VwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwicGxhY2VtZW50XCI6IFwibGVmdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcInRpdGxlXCI6IFwiVGFyZ2V0IFZhcmlhYmxlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiY29udGVudFwiOiBcIlRoaXMgaXMgdGhlIHZhcmlhYmxlLCBcIiArIG15dGFyZ2V0ICsgXCIsIHdlIGFyZSB0cnlpbmcgdG8gcHJlZGljdC4gIFRoaXMgY2VudGVyIHBhbmVsIGdyYXBoaWNhbGx5IHJlcHJlc2VudHMgdGhlIHByb2JsZW0gY3VycmVudGx5IGJlaW5nIGF0dGVtcHRlZC5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzaG93Q1RBQnV0dG9uXCI6dHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjdGFMYWJlbFwiOiBcIkRpc2FibGUgdGhlc2UgbWVzc2FnZXNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvbkNUQVwiOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3BzY290Y2guZW5kVG91cih0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0dXRvcmlhbF9tb2RlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBcImdyMWh1bGxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJwbGFjZW1lbnRcIjogXCJyaWdodFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcInRpdGxlXCI6IFwiRXhwbGFuYXRpb24gU2V0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiY29udGVudFwiOiBcIlRoaXMgc2V0IG9mIHZhcmlhYmxlcyBjYW4gcG90ZW50aWFsbHkgcHJlZGljdCB0aGUgdGFyZ2V0LlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcInNob3dDVEFCdXR0b25cIjp0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImN0YUxhYmVsXCI6IFwiRGlzYWJsZSB0aGVzZSBtZXNzYWdlc1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcIm9uQ1RBXCI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvcHNjb3RjaC5lbmRUb3VyKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR1dG9yaWFsX21vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IFwiZGlzcGxhY2VtZW50XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwicGxhY2VtZW50XCI6IFwicmlnaHRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0aXRsZVwiOiBcIlZhcmlhYmxlIExpc3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjb250ZW50XCI6IFwiPHA+Q2xpY2sgb24gYW55IHZhcmlhYmxlIG5hbWUgaGVyZSBpZiB5b3Ugd2lzaCB0byByZW1vdmUgaXQgZnJvbSB0aGUgcHJvYmxlbSBzb2x1dGlvbi48L3A+PHA+WW91IGxpa2VseSBkbyBub3QgbmVlZCB0byBhZGp1c3QgdGhlIHByb2JsZW0gcmVwcmVzZW50YXRpb24gaW4gdGhlIGNlbnRlciBwYW5lbC48L3A+XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwic2hvd0NUQUJ1dHRvblwiOnRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiY3RhTGFiZWxcIjogXCJEaXNhYmxlIHRoZXNlIG1lc3NhZ2VzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwib25DVEFcIjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9wc2NvdGNoLmVuZFRvdXIodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHV0b3JpYWxfbW9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0YXJnZXRcIjogXCJidG5FbmRTZXNzaW9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwicGxhY2VtZW50XCI6IFwiYm90dG9tXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwidGl0bGVcIjogXCJGaW5pc2ggUHJvYmxlbVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImNvbnRlbnRcIjogXCJJZiB0aGUgc29sdXRpb24gcmVwb3J0ZWQgYmFjayBzZWVtcyBhY2NlcHRhYmxlLCB0aGVuIGZpbmlzaCB0aGlzIHByb2JsZW0gYnkgY2xpY2tpbmcgdGhpcyBFbmQgU2Vzc2lvbiBidXR0b24uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwic2hvd0NUQUJ1dHRvblwiOnRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiY3RhTGFiZWxcIjogXCJEaXNhYmxlIHRoZXNlIG1lc3NhZ2VzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwib25DVEFcIjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9wc2NvdGNoLmVuZFRvdXIodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHV0b3JpYWxfbW9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgXCJzaG93Q2xvc2VCdXR0b25cIjpmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICBcInNjcm9sbER1cmF0aW9uXCI6IDMwMCxcbiAgICAgICAgICAgICAgICAgICAgICBcIm9uRW5kXCI6ICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0X2xvYWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJTdGFydGluZyBIb3BzY290Y2ggVG91clwiKTtcbiAgICAgICAgICAgICAgICAgICAgaG9wc2NvdGNoLnN0YXJ0VG91cihwcm9ibGVtX2luaXRpYWxpemVkX3RvdXIpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkVuZGluZyBIb3BzY290Y2ggVG91clwiKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gc3NTdWNjZXNzKGJ0biwgU2Vzc2lvblJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwic3RhcnRzZXNzaW9uOiBcIiwgU2Vzc2lvblJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgenBhcmFtcy56c2Vzc2lvbmlkPVNlc3Npb25SZXNwb25zZS5jb250ZXh0LnNlc3Npb25JZDtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNzRmFpbChidG4pIHtcbiAgICAgICAgICAgICAgICAgICAgYWxlcnQoXCJTdGFydFNlc3Npb24gaGFzIGZhaWxlZC5cIik7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdCgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1ha2VDb3JzUmVxdWVzdCh1cmxjYWxsLCBcIm5vYnV0dG9uXCIsIHNzU3VjY2Vzcywgc3NGYWlsLCBzb2xhanNvbm91dCk7XG4gICAgICAgIH0pKVxuICAgIC50aGVuKF8gPT4gbS5yZXF1ZXN0KHBVUkwpKVxuICAgIC50aGVuKGRhdGEgPT4geyAvLyBzdWNjZXNzIG1lYW5zIHBVUkwgZXhpc3RzLCBjYWxsIHJlYWRQcmVwcm9jZXNzKClcbiAgICAgICAgaWYoIXN3YW5kaXZlKVxuICAgICAgICAgICAgcmVhZFByZXByb2Nlc3MoZGF0YSlcbiAgICAgICAgfSwgXyA9PiB7IC8vIGZhaWwgbWVhbnMgcFVSTCBkb2Vzbid0IGV4aXN0LCBjYWxsIHJ1blByZXByb2Nlc3MoKSwgd2hpY2ggd3JpdGVzIHByZXByb2Nlc3MuanNvbiBhbmQgdGhlbiBkb2VzIHdoYXQgcmVhZFByZXByb2Nlc3MgZG9lc1xuICAgICAgICBpZighc3dhbmRpdmUpXG4gICAgICAgICAgICBydW5QcmVwcm9jZXNzKGQzbURhdGEsIGQzbVRhcmdldCwgZDNtRGF0YU5hbWUpO1xuICAgICAgICB9KVxuICAgIC50aGVuKCgpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgaWYoc3dhbmRpdmUpXG4gICAgICAgICAgICByZXNvbHZlKCk7XG5cbiAgICAgICAgbGV0IHZhcnMgPSBPYmplY3Qua2V5cyhwcmVwcm9jZXNzKTtcblxuICAgICAgICAvLyB0ZW1wb3JhcnkgdmFsdWVzIGZvciBob2xkIHRoYXQgY29ycmVzcG9uZCB0byBoaXN0b2dyYW0gYmluc1xuICAgICAgICBob2xkID0gWy42LCAuMiwgLjksIC44LCAuMSwgLjMsIC40XTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyB2YWx1ZUtleVtpXSA9IHZhcnNbaV0uYXR0cmlidXRlcy5uYW1lLm5vZGVWYWx1ZTtcbiAgICAgICAgICAgIC8vIGxhYmxBcnJheVtpXSA9IHZhcnNYTUxbaV0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJsYWJsXCIpLmxlbmd0aCA9PSAwID9cbiAgICAgICAgICAgIC8vIFwibm8gbGFiZWxcIiA6XG4gICAgICAgICAgICAvLyB2YXJzWE1MW2ldLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwibGFibFwiKVswXS5jaGlsZE5vZGVzWzBdLm5vZGVWYWx1ZTtcbiAgICAgICAgICAgIC8vIGxldCBkYXRhc2V0Y291bnQgPSBkMy5sYXlvdXQuaGlzdG9ncmFtKClcbiAgICAgICAgICAgIC8vICAgICAuYmlucyhiYXJudW1iZXIpLmZyZXF1ZW5jeShmYWxzZSlcbiAgICAgICAgICAgIC8vICAgICAoWzAsIDAsIDAsIDAsIDBdKTtcbiAgICAgICAgICAgIHZhbHVlS2V5W2ldID0gdmFyc1tpXTtcbiAgICAgICAgICAgIGxhYmxBcnJheVtpXSA9IFwibm8gbGFiZWxcIjtcbiAgICAgICAgICAgIC8vIGNvbnRhaW5zIGFsbCB0aGUgcHJlcHJvY2Vzc2VkIGRhdGEgd2UgaGF2ZSBmb3IgdGhlIHZhcmlhYmxlLCBhcyB3ZWxsIGFzIFVJIGRhdGEgcGVydGluZW50IHRvIHRoYXQgdmFyaWFibGUsXG4gICAgICAgICAgICAvLyBzdWNoIGFzIHNldHggdmFsdWVzIChpZiB0aGUgdXNlciBoYXMgc2VsZWN0ZWQgdGhlbSkgYW5kIHBlYmJsZSBjb29yZGluYXRlc1xuICAgICAgICAgICAgbGV0IG9iaiA9IHtcbiAgICAgICAgICAgICAgICBpZDogaSxcbiAgICAgICAgICAgICAgICByZWZsZXhpdmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG5hbWU6IHZhbHVlS2V5W2ldLFxuICAgICAgICAgICAgICAgIGxhYmw6IGxhYmxBcnJheVtpXSxcbiAgICAgICAgICAgICAgICBkYXRhOiBbNSwgMTUsIDIwLCAwLCA1LCAxNSwgMjBdLFxuICAgICAgICAgICAgICAgIGNvdW50OiBob2xkLFxuICAgICAgICAgICAgICAgIG5vZGVDb2w6IGNvbG9ycyhpKSxcbiAgICAgICAgICAgICAgICBiYXNlQ29sOiBjb2xvcnMoaSksXG4gICAgICAgICAgICAgICAgc3Ryb2tlQ29sb3I6IHNlbFZhckNvbG9yLFxuICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiBcIjFcIixcbiAgICAgICAgICAgICAgICBzdWJzZXRwbG90OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzdWJzZXRyYW5nZTogW1wiXCIsIFwiXCJdLFxuICAgICAgICAgICAgICAgIHNldHhwbG90OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzZXR4dmFsczogW1wiXCIsIFwiXCJdLFxuICAgICAgICAgICAgICAgIGdyYXlvdXQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGdyb3VwMTogZmFsc2UsXG4gICAgICAgICAgICAgICAgZ3JvdXAyOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBmb3JlZnJvbnQ6IGZhbHNlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgalF1ZXJ5LmV4dGVuZCh0cnVlLCBvYmosIHByZXByb2Nlc3NbdmFsdWVLZXlbaV1dKTtcbiAgICAgICAgICAgIGFsbE5vZGVzLnB1c2gob2JqKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgIH0pKVxuICAgIC50aGVuKCgpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHsgLy8gYWRkaW5nIGluIGQzbURlc2NyaXB0aW9uIGlmIGQzbV9tb2RlXG4gICAgICAgIGlmKCFkM21fbW9kZSB8fCBzd2FuZGl2ZSlcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgICAgIC8vIGFkZGluZyBpbiBkM21EZXNjcmlwdGlvbiB0byBhbGxOb2Rlc1xuICAgICAgICBsZXQgZGF0YXZhcnMgPSBkYXRhc2NoZW1hLnRyYWluRGF0YS50cmFpbkRhdGE7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBkYXRhdmFycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG15aSA9IGZpbmROb2RlSW5kZXgoZGF0YXZhcnNbaV0udmFyTmFtZSk7XG4gICAgICAgICAgICBsZXQgZDNtRGVzY3JpcHRpb24gPSB7ZDNtRGVzY3JpcHRpb246ZGF0YXZhcnNbaV19O1xuICAgICAgICAgICAgYWxsTm9kZXNbbXlpXSA9IE9iamVjdC5hc3NpZ24oYWxsTm9kZXNbbXlpXSwgZDNtRGVzY3JpcHRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nKGFsbE5vZGVzKTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgIH0pKVxuICAgIC50aGVuKCgpID0+ICB7IC8vIGZpbmFsIHN0ZXA6IHN0YXJ0IGhlciB1cFxuICAgIC8vICAudGhlbigoKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGlmKHN3YW5kaXZlKSB7XG4gICAgICAgICAgICBzY2FmZm9sZGluZyhzd2FuZGl2ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzY2FmZm9sZGluZyhsYXlvdXQpO1xuICAgICAgICAgICAgaWYgKGQzbV9tb2RlKSB7XG4gICAgICAgICAgICAgICAgelBvcCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRhRG93bmxvYWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgIC8vIHJlc29sdmUoKTtcbiAgICB9KVxufVxuXG5cbmxldCAkZmlsbCA9IChvYmosIG9wLCBkMSwgZDIpID0+IGQzLnNlbGVjdChvYmopLnRyYW5zaXRpb24oKVxuICAgIC5hdHRyKCdmaWxsLW9wYWNpdHknLCBvcClcbiAgICAuZGVsYXkoZDEpXG4gICAgLmR1cmF0aW9uKGQyKTtcbmxldCBmaWxsID0gKGQsIGlkLCBvcCwgZDEsIGQyKSA9PiAkZmlsbCgnIycgKyBpZCArIGQuaWQsIG9wLCBkMSwgZDIpO1xubGV0IGZpbGxUaGlzID0gKHNlbGYsIG9wLCBkMSwgZDIpID0+ICRmaWxsKHNlbGYsIG9wLCBkMSwgZDIpO1xuXG4vLyBzY2FmZm9sZGluZyBpcyBjYWxsZWQgYWZ0ZXIgYWxsIGV4dGVybmFsIGRhdGEgYXJlIGd1YXJhbnRlZWQgdG8gaGF2ZSBiZWVuIHJlYWQgdG8gY29tcGxldGlvbi4gdGhpcyBwb3B1bGF0ZXMgdGhlIGxlZnQgcGFuZWwgd2l0aCB2YXJpYWJsZSBuYW1lcywgdGhlIHJpZ2h0IHBhbmVsIHdpdGggbW9kZWwgbmFtZXMsIHRoZSB0cmFuc2Zvcm1hdGlvbiB0b29sLCBhbiB0aGUgYXNzb2NpYXRlZCBtb3VzZW92ZXJzLiBpdHMgY2FsbGJhY2sgaXMgbGF5b3V0KCksIHdoaWNoIGluaXRpYWxpemVzIHRoZSBtb2RlbGluZyBzcGFjZVxuZnVuY3Rpb24gc2NhZmZvbGRpbmcoY2FsbGJhY2spIHtcbmNvbnNvbGUubG9nKFwiU0NBRkZPTERJTkdcIik7XG4gICAgLy8gZXN0YWJsaXNoaW5nIHRoZSB0cmFuc2Zvcm1hdGlvbiBlbGVtZW50XG4vLyAgICBkMy5zZWxlY3QoXCIjdHJhbnNmb3JtYXRpb25zXCIpXG4gIC8vICAgICAgLmFwcGVuZChcImlucHV0XCIpXG4gICAvLyAgICAgLmF0dHIoXCJpZFwiLCBcInRJbnB1dFwiKVxuICAgIC8vICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJmb3JtLWNvbnRyb2xcIilcbiAgICAgLy8gICAuYXR0cihcInR5cGVcIiwgXCJ0ZXh0XCIpXG4gICAgICAvLyAgLmF0dHIoXCJ2YWx1ZVwiLCBcIlZhcmlhYmxlIHRyYW5zZm9ybWF0aW9uXCIpO1xuXG4gICAgLy8gdmFyaWFibGUgZHJvcGRvd25cbiAgICBkMy5zZWxlY3QoXCIjdHJhbnNmb3JtYXRpb25zXCIpXG4gICAgICAgIC5hcHBlbmQoXCJ1bFwiKVxuICAgICAgICAuYXR0cihcImlkXCIsIFwidHJhbnNTZWxcIilcbiAgICAgICAgLnN0eWxlKFwiZGlzcGxheVwiLCBcIm5vbmVcIilcbiAgICAgICAgLnN0eWxlKFwiYmFja2dyb3VuZC1jb2xvclwiLCB2YXJDb2xvcilcbiAgICAgICAgLnNlbGVjdEFsbCgnbGknKVxuICAgICAgICAuZGF0YShbXCJhXCIsIFwiYlwiXSkgLy9zZXQgdG8gdmFyaWFibGVzIGluIG1vZGVsIHNwYWNlIGFzIHRoZXkncmUgYWRkZWRcbiAgICAgICAgLmVudGVyKClcbiAgICAgICAgLmFwcGVuZChcImxpXCIpXG4gICAgICAgIC50ZXh0KGQgPT4gZCk7XG5cbiAgICAvLyBmdW5jdGlvbiBkcm9wZG93blxuICAgIGQzLnNlbGVjdChcIiN0cmFuc2Zvcm1hdGlvbnNcIilcbiAgICAgICAgLmFwcGVuZChcInVsXCIpXG4gICAgICAgIC5hdHRyKFwiaWRcIiwgXCJ0cmFuc0xpc3RcIilcbiAgICAgICAgLnN0eWxlKFwiZGlzcGxheVwiLCBcIm5vbmVcIilcbiAgICAgICAgLnN0eWxlKFwiYmFja2dyb3VuZC1jb2xvclwiLCB2YXJDb2xvcilcbiAgICAgICAgLnNlbGVjdEFsbCgnbGknKVxuICAgICAgICAuZGF0YSh0cmFuc2Zvcm1MaXN0KVxuICAgICAgICAuZW50ZXIoKVxuICAgICAgICAuYXBwZW5kKFwibGlcIilcbiAgICAgICAgLnRleHQoZCA9PiBkKTtcblxuICAgIGlmKCFkM21fbW9kZSl7ICAgIC8vIE5vIHZhcmlhYmxlIHRyYW5zZm9ybWF0aW9uIGluIHByZXNlbnQgZDNtIG1vZGVcblxuICAgICAgICAkKCcjdElucHV0JykuY2xpY2soKCkgPT4ge1xuICAgICAgICAgICAgdmFyIHQgPSBieUlkKCd0cmFuc1NlbCcpLnN0eWxlLmRpc3BsYXk7XG4gICAgICAgICAgICBpZiAodCAhPT0gXCJub25lXCIpIHsgLy8gaWYgdmFyaWFibGUgbGlzdCBpcyBkaXNwbGF5ZWQgd2hlbiBpbnB1dCBpcyBjbGlja2VkLi4uXG4gICAgICAgICAgICAgICAgJCgnI3RyYW5zU2VsJykuZmFkZU91dCgxMDApO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0MSA9IGJ5SWQoJ3RyYW5zTGlzdCcpLnN0eWxlLmRpc3BsYXk7XG4gICAgICAgICAgICBpZiAodDEgIT09IFwibm9uZVwiKSB7IC8vIGlmIGZ1bmN0aW9uIGxpc3QgaXMgZGlzcGxheWVkIHdoZW4gaW5wdXQgaXMgY2xpY2tlZC4uLlxuICAgICAgICAgICAgICAgICQoJyN0cmFuc0xpc3QnKS5mYWRlT3V0KDEwMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBoaWdobGlnaHQgdGhlIHRleHRcbiAgICAgICAgICAgICQodGhpcykuc2VsZWN0KCk7XG4gICAgICAgICAgICB2YXIgcG9zID0gJCgnI3RJbnB1dCcpLm9mZnNldCgpO1xuICAgICAgICAgICAgcG9zLnRvcCArPSAkKCcjdElucHV0Jykud2lkdGgoKTtcbiAgICAgICAgICAgICQoJyN0cmFuc1NlbCcpLmZhZGVJbigxMDApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgbjtcbiAgICAgICAgJCgnI3RJbnB1dCcpLmtleXVwKGV2dCA9PiB7XG4gICAgICAgICAgICB2YXIgdCA9IGJ5SWQoJ3RyYW5zU2VsJykuc3R5bGUuZGlzcGxheTtcbiAgICAgICAgICAgIHZhciB0MSA9IGJ5SWQoJ3RyYW5zTGlzdCcpLnN0eWxlLmRpc3BsYXk7XG4gICAgICAgICAgICBpZiAodCAhPSBcIm5vbmVcIikgJCgnI3RyYW5zU2VsJykuZmFkZU91dCgxMDApO1xuICAgICAgICAgICAgZWxzZSBpZiAodDEgIT0gXCJub25lXCIpICQoJyN0cmFuc0xpc3QnKS5mYWRlT3V0KDEwMCk7XG5cbiAgICAgICAgICAgIGlmIChldnQua2V5Q29kZSA9PSAxMykgeyAvLyBrZXl1cCBvbiBFbnRlclxuICAgICAgICAgICAgICAgIG4gPSAkKCcjdElucHV0JykudmFsKCk7XG4gICAgICAgICAgICAgICAgdmFyIHQgPSB0cmFuc1BhcnNlKG49bik7XG4gICAgICAgICAgICAgICAgaWYgKCF0KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtKG4gPSB0LnNsaWNlKDAsIHQubGVuZ3RoIC0gMSksIHQgPSB0W3QubGVuZ3RoIC0gMV0sIHR5cGVUcmFuc2Zvcm0gPSBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciB0O1xuICAgICAgICAkKCcjdHJhbnNMaXN0IGxpJykuY2xpY2soZnVuY3Rpb24oZXZ0KXtcbiAgICAgICAgICAgIC8vIGlmIGludGVyYWN0IGlzIHNlbGVjdGVkLCBzaG93IHZhcmlhYmxlIGxpc3QgYWdhaW5cbiAgICAgICAgICAgIGlmICgkKHRoaXMpLnRleHQoKSA9PSBcImludGVyYWN0KGQsZSlcIikge1xuICAgICAgICAgICAgICAgICQoJyN0SW5wdXQnKS52YWwodHZhci5jb25jYXQoJyonKSk7XG4gICAgICAgICAgICAgICAgc2VsSW50ZXJhY3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICQodGhpcykucGFyZW50KCkuZmFuZGVPdXQoMTAwKTtcbiAgICAgICAgICAgICAgICAkKCcjdHJhbnNTZWwnKS5mYWRlSW4oMTAwKTtcbiAgICAgICAgICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdHZhciA9ICQoJyN0SW5wdXQnKS52YWwoKTtcbiAgICAgICAgICAgIHZhciB0ZnVuYyA9ICQodGhpcykudGV4dCgpLnJlcGxhY2UoXCJkXCIsIFwiX3RyYW5zdmFyMFwiKTtcbiAgICAgICAgICAgIHZhciB0Y2FsbCA9ICQodGhpcykudGV4dCgpLnJlcGxhY2UoXCJkXCIsIHR2YXIpO1xuICAgICAgICAgICAgJCgnI3RJbnB1dCcpLnZhbCh0Y2FsbCk7XG4gICAgICAgICAgICAkKHRoaXMpLnBhcmVudCgpLmZhZGVPdXQoMTAwKTtcbiAgICAgICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIHRyYW5zZm9ybShuID0gdHZhciwgdCA9IHRmdW5jLCB0eXBlVHJhbnNmb3JtID0gZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgZDMuc2VsZWN0KFwiI21vZGVsc1wiKVxuICAgICAgICAuc3R5bGUoJ2hlaWdodCcsIDIwMDApXG4gICAgICAgIC5zdHlsZSgnb3ZlcmZpbGwnLCAnc2Nyb2xsJyk7XG5cbiAgICBpZighZDNtX21vZGUpe1xuICAgIGQzLnNlbGVjdChcIiNtb2RlbHNcIikuc2VsZWN0QWxsKFwicFwiKVxuICAgICAgICAuZGF0YShPYmplY3Qua2V5cyhtb2RzKSlcbiAgICAgICAgLmVudGVyKClcbiAgICAgICAgLmFwcGVuZChcInBcIilcbiAgICAgICAgLmF0dHIoXCJpZFwiLCBcIl9tb2RlbF9cIi5jb25jYXQpXG4gICAgICAgIC50ZXh0KGQgPT4gZClcbiAgICAgICAgLnN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJywgZCA9PiB2YXJDb2xvcilcbiAgICAgICAgLmF0dHIoXCJkYXRhLWNvbnRhaW5lclwiLCBcImJvZHlcIilcbiAgICAgICAgLmF0dHIoXCJkYXRhLXRvZ2dsZVwiLCBcInBvcG92ZXJcIilcbiAgICAgICAgLmF0dHIoXCJkYXRhLXRyaWdnZXJcIiwgXCJob3ZlclwiKVxuICAgICAgICAuYXR0cihcImRhdGEtcGxhY2VtZW50XCIsIFwidG9wXCIpXG4gICAgICAgIC5hdHRyKFwiZGF0YS1odG1sXCIsIFwidHJ1ZVwiKVxuICAgICAgICAuYXR0cihcIm9ubW91c2VvdmVyXCIsIFwiJCh0aGlzKS5wb3BvdmVyKCd0b2dnbGUnKTtcIilcbiAgICAgICAgLmF0dHIoXCJvbm1vdXNlb3V0XCIsIFwiJCh0aGlzKS5wb3BvdmVyKCd0b2dnbGUnKTtcIilcbiAgICAgICAgLmF0dHIoXCJkYXRhLW9yaWdpbmFsLXRpdGxlXCIsIFwiTW9kZWwgRGVzY3JpcHRpb25cIilcbiAgICAgICAgLmF0dHIoXCJkYXRhLWNvbnRlbnRcIiwgZCA9PiBtb2RzW2RdKTtcbiAgICB9XG4gICAgaWYoZDNtX21vZGUpIHtcblxuICAgICAgICAvL1xuXG4gICAgICAgIHRvZ2dsZVJpZ2h0QnV0dG9ucyhcInRhc2tzXCIpO1xuXG4gICAgICAgIGQzLnNlbGVjdChcIiN0eXBlc1wiKS5zZWxlY3RBbGwoXCJwXCIpXG4gICAgICAgIC5kYXRhKE9iamVjdC5rZXlzKGQzbVRhc2tUeXBlKSlcbiAgICAgICAgLmVudGVyKClcbiAgICAgICAgLmFwcGVuZChcInBcIilcbiAgICAgICAgLmF0dHIoXCJpZFwiLCBkID0+IGQgKyBcIi50eXBlc1wiKVxuICAgICAgICAudGV4dChkID0+IGQpXG4gICAgICAgIC5hdHRyKCdjbGFzcycsIGQ9PiB7XG4gICAgICAgICAgICAgIGlmIChkM21Qcm9ibGVtRGVzY3JpcHRpb24udGFza1R5cGUgPT0gZC50b1N0cmluZygpKXtcbiAgICAgICAgICAgICAgcmV0dXJuICdpdGVtLXNlbGVjdCc7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmKGxvY2t0b2dnbGUpIHJldHVybiAnaXRlbS1kZWZhdWx0IGl0ZW0tbGluZW91dCc7XG4gICAgICAgICAgICAgIHJldHVybiAnaXRlbS1kZWZhdWx0JztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAuYXR0cihcImRhdGEtY29udGFpbmVyXCIsIFwiYm9keVwiKVxuICAgICAgICAuYXR0cihcImRhdGEtdG9nZ2xlXCIsIFwicG9wb3ZlclwiKVxuICAgICAgICAuYXR0cihcImRhdGEtdHJpZ2dlclwiLCBcImhvdmVyXCIpXG4gICAgICAgIC5hdHRyKFwiZGF0YS1wbGFjZW1lbnRcIiwgXCJ0b3BcIilcbiAgICAgICAgLmF0dHIoXCJkYXRhLWh0bWxcIiwgXCJ0cnVlXCIpXG4gICAgICAgIC5hdHRyKFwib25tb3VzZW92ZXJcIiwgXCIkKHRoaXMpLnBvcG92ZXIoJ3RvZ2dsZScpO1wiKVxuICAgICAgICAuYXR0cihcIm9ubW91c2VvdXRcIiwgXCIkKHRoaXMpLnBvcG92ZXIoJ3RvZ2dsZScpO1wiKVxuICAgICAgICAuYXR0cihcImRhdGEtb3JpZ2luYWwtdGl0bGVcIiwgXCJUYXNrIERlc2NyaXB0aW9uXCIpXG4gICAgICAgIC5hdHRyKFwiZGF0YS1jb250ZW50XCIsIGQgPT4gZDNtVGFza1R5cGVbZF1bMV0pO1xuXG4gICAgICAgIGQzLnNlbGVjdChcIiNzdWJ0eXBlc1wiKS5zZWxlY3RBbGwoXCJwXCIpXG4gICAgICAgIC5kYXRhKE9iamVjdC5rZXlzKGQzbVRhc2tTdWJ0eXBlKSlcbiAgICAgICAgLmVudGVyKClcbiAgICAgICAgLmFwcGVuZChcInBcIilcbiAgICAgICAgLmF0dHIoXCJpZFwiLCBkID0+IGQgKyBcIi5zdWJ0eXBlc1wiKVxuICAgICAgICAudGV4dChkID0+IGQpXG4gICAgICAgIC5hdHRyKCdjbGFzcycsIGQ9PiB7XG4gICAgICAgICAgICAgIGlmIChkM21Qcm9ibGVtRGVzY3JpcHRpb24udGFza1N1YnR5cGUgPT0gZC50b1N0cmluZygpKXtcbiAgICAgICAgICAgICAgcmV0dXJuICdpdGVtLXNlbGVjdCc7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmKGxvY2t0b2dnbGUpIHJldHVybiAnaXRlbS1kZWZhdWx0IGl0ZW0tbGluZW91dCc7XG4gICAgICAgICAgICAgIHJldHVybiAnaXRlbS1kZWZhdWx0JztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAuYXR0cihcImRhdGEtY29udGFpbmVyXCIsIFwiYm9keVwiKVxuICAgICAgICAuYXR0cihcImRhdGEtdG9nZ2xlXCIsIFwicG9wb3ZlclwiKVxuICAgICAgICAuYXR0cihcImRhdGEtdHJpZ2dlclwiLCBcImhvdmVyXCIpXG4gICAgICAgIC5hdHRyKFwiZGF0YS1wbGFjZW1lbnRcIiwgXCJ0b3BcIilcbiAgICAgICAgLmF0dHIoXCJkYXRhLWh0bWxcIiwgXCJ0cnVlXCIpXG4gICAgICAgIC5hdHRyKFwib25tb3VzZW92ZXJcIiwgXCIkKHRoaXMpLnBvcG92ZXIoJ3RvZ2dsZScpO1wiKVxuICAgICAgICAuYXR0cihcIm9ubW91c2VvdXRcIiwgXCIkKHRoaXMpLnBvcG92ZXIoJ3RvZ2dsZScpO1wiKVxuICAgICAgICAuYXR0cihcImRhdGEtb3JpZ2luYWwtdGl0bGVcIiwgXCJUYXNrIFN1YnR5cGUgRGVzYy5cIilcbiAgICAgICAgLmF0dHIoXCJkYXRhLWNvbnRlbnRcIiwgZCA9PiBkM21UYXNrU3VidHlwZVtkXVsxXSk7XG5cbiAgICAgICAgZDMuc2VsZWN0KFwiI21ldHJpY3NcIikuc2VsZWN0QWxsKFwicFwiKVxuICAgICAgICAuZGF0YShPYmplY3Qua2V5cyhkM21NZXRyaWNzKSlcbiAgICAgICAgLmVudGVyKClcbiAgICAgICAgLmFwcGVuZChcInBcIilcbiAgICAgICAgLmF0dHIoXCJpZFwiLCBkID0+IGQgKyBcIi5tZXRyaWNzXCIpXG4gICAgICAgIC50ZXh0KGQgPT4gZClcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgZD0+IHtcbiAgICAgICAgICAgICAgaWYgKGQzbVByb2JsZW1EZXNjcmlwdGlvbi5tZXRyaWMgPT0gZC50b1N0cmluZygpKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2l0ZW0tc2VsZWN0JztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZihsb2NrdG9nZ2xlKSByZXR1cm4gJ2l0ZW0tZGVmYXVsdCBpdGVtLWxpbmVvdXQnO1xuICAgICAgICAgICAgICAgIHJldHVybiAnaXRlbS1kZWZhdWx0JztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAuYXR0cihcImRhdGEtY29udGFpbmVyXCIsIFwiYm9keVwiKVxuICAgICAgICAuYXR0cihcImRhdGEtdG9nZ2xlXCIsIFwicG9wb3ZlclwiKVxuICAgICAgICAuYXR0cihcImRhdGEtdHJpZ2dlclwiLCBcImhvdmVyXCIpXG4gICAgICAgIC5hdHRyKFwiZGF0YS1wbGFjZW1lbnRcIiwgXCJ0b3BcIilcbiAgICAgICAgLmF0dHIoXCJkYXRhLWh0bWxcIiwgXCJ0cnVlXCIpXG4gICAgICAgIC5hdHRyKFwib25tb3VzZW92ZXJcIiwgXCIkKHRoaXMpLnBvcG92ZXIoJ3RvZ2dsZScpO1wiKVxuICAgICAgICAuYXR0cihcIm9ubW91c2VvdXRcIiwgXCIkKHRoaXMpLnBvcG92ZXIoJ3RvZ2dsZScpO1wiKVxuICAgICAgICAuYXR0cihcImRhdGEtb3JpZ2luYWwtdGl0bGVcIiwgXCJNZXRyaWMgRGVzY3JpcHRpb25cIilcbiAgICAgICAgLmF0dHIoXCJkYXRhLWNvbnRlbnRcIiwgZCA9PiBkM21NZXRyaWNzW2RdWzFdKTtcblxuICAgICAgICBkMy5zZWxlY3QoXCIjb3V0cHV0c1wiKS5zZWxlY3RBbGwoXCJwXCIpXG4gICAgICAgIC5kYXRhKE9iamVjdC5rZXlzKGQzbU91dHB1dFR5cGUpKVxuICAgICAgICAuZW50ZXIoKVxuICAgICAgICAuYXBwZW5kKFwicFwiKVxuICAgICAgICAuYXR0cihcImlkXCIsIGQgPT4gZCArIFwiLm91dHB1dHNcIilcbiAgICAgICAgLnRleHQoZCA9PiBkKVxuICAgICAgICAuYXR0cignY2xhc3MnLCBkPT4ge1xuICAgICAgICAgICAgICBpZiAoZDNtUHJvYmxlbURlc2NyaXB0aW9uLm91dHB1dFR5cGUgPT0gZC50b1N0cmluZygpKXtcbiAgICAgICAgICAgICAgcmV0dXJuICdpdGVtLXNlbGVjdCc7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmKGxvY2t0b2dnbGUpIHJldHVybiAnaXRlbS1kZWZhdWx0IGl0ZW0tbGluZW91dCc7XG4gICAgICAgICAgICAgIHJldHVybiAnaXRlbS1kZWZhdWx0JztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAuYXR0cihcImRhdGEtY29udGFpbmVyXCIsIFwiYm9keVwiKVxuICAgICAgICAuYXR0cihcImRhdGEtdG9nZ2xlXCIsIFwicG9wb3ZlclwiKVxuICAgICAgICAuYXR0cihcImRhdGEtdHJpZ2dlclwiLCBcImhvdmVyXCIpXG4gICAgICAgIC5hdHRyKFwiZGF0YS1wbGFjZW1lbnRcIiwgXCJ0b3BcIilcbiAgICAgICAgLmF0dHIoXCJkYXRhLWh0bWxcIiwgXCJ0cnVlXCIpXG4gICAgICAgIC5hdHRyKFwib25tb3VzZW92ZXJcIiwgXCIkKHRoaXMpLnBvcG92ZXIoJ3RvZ2dsZScpO1wiKVxuICAgICAgICAuYXR0cihcIm9ubW91c2VvdXRcIiwgXCIkKHRoaXMpLnBvcG92ZXIoJ3RvZ2dsZScpO1wiKVxuICAgICAgICAuYXR0cihcImRhdGEtb3JpZ2luYWwtdGl0bGVcIiwgXCJPdXRwdXQgRGVzY3JpcHRpb25cIilcbiAgICAgICAgLmF0dHIoXCJkYXRhLWNvbnRlbnRcIiwgZCA9PiBkM21PdXRwdXRUeXBlW2RdWzFdKTtcblxuICAgIH1cblxuICAgIC8vIGNhbGwgbGF5b3V0KCkgYmVjYXVzZSBhdCB0aGlzIHBvaW50IGFsbCBzY2FmZm9sZGluZyBpcyB1cCBhbmQgcmVhZHlcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYWxsYmFjayhmYWxzZSx0cnVlKTtcbiAgICAgICAgbS5yZWRyYXcoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBtLnJlZHJhdygpO1xuICAgIH1cblxuICAgIC8vIGlmIHN3YW5kaXZlLCBhZnRlciBzY2FmZm9sZGluZyBpcyB1cCwganVzdCBncmV5IHRoaW5ncyBvdXRcbiAgICBpZihzd2FuZGl2ZSkge1xuICAgIC8vIHBlcmhhcHMgd2FudCB0byBhbGxvdyB1c2VycyB0byB1bmxjb2sgYW5kIHNlbGVjdCB0aGluZ3M/XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdidG5Mb2NrJykuY2xhc3NMaXN0LmFkZCgnbm9zaG93Jyk7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdidG5Gb3JjZScpLmNsYXNzTGlzdC5hZGQoJ25vc2hvdycpO1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYnRuRXJhc2VyJykuY2xhc3NMaXN0LmFkZCgnbm9zaG93Jyk7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdidG5TdWJzZXQnKS5jbGFzc0xpc3QuYWRkKCdub3Nob3cnKTtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21haW4nKS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9J2dyZXknO1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnd2hpdGVzcGFjZScpLnN0eWxlLmJhY2tncm91bmRDb2xvcj0nZ3JleSc7XG4gICAgfVxufVxuXG5sZXQgc3BsaWNlID0gKGNvbG9yLCB0ZXh0LCAuLi5hcmdzKSA9PiB7XG4gICAgYXJncy5mb3JFYWNoKHggPT4ge1xuICAgICAgICBpZiAoY29sb3IgIT0geFswXSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGlkeCA9IHpwYXJhbXNbeFsxXV0uaW5kZXhPZih0ZXh0KTtcbiAgICAgICAgaWR4ID4gLTEgJiYgenBhcmFtc1t4WzFdXS5zcGxpY2UoaWR4LCAxKTtcbiAgICB9KTtcbn07XG5cbmV4cG9ydCBsZXQgY2xpY2tWYXI7XG5cbmZ1bmN0aW9uIGxheW91dCh2LHYyKSB7XG4gICAgdmFyIG15VmFsdWVzID0gW107XG4gICAgbm9kZXMgPSBbXTtcbiAgICBsaW5rcyA9IFtdO1xuXG4gICAgc3ZnLmFwcGVuZChcInN2ZzpkZWZzXCIpLmFwcGVuZChcInN2ZzptYXJrZXJcIilcbiAgICAgICAgLmF0dHIoXCJpZFwiLCBcImdyb3VwMS1hcnJvd1wiKVxuICAgICAgICAuYXR0cigndmlld0JveCcsICcwIC01IDE1IDE1JylcbiAgICAgICAgLmF0dHIoXCJyZWZYXCIsIDIuNSlcbiAgICAgICAgLmF0dHIoXCJyZWZZXCIsIDApXG4gICAgICAgIC5hdHRyKFwibWFya2VyV2lkdGhcIiwgMylcbiAgICAgICAgLmF0dHIoXCJtYXJrZXJIZWlnaHRcIiwgMylcbiAgICAgICAgLmF0dHIoXCJvcmllbnRcIiwgXCJhdXRvXCIpXG4gICAgICAgIC5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgIC5hdHRyKCdkJywgJ00wLC01TDEwLDBMMCw1JylcbiAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBncjFDb2xvcik7XG5cbiAgICBzdmcuYXBwZW5kKFwic3ZnOmRlZnNcIikuYXBwZW5kKFwic3ZnOm1hcmtlclwiKVxuICAgICAgICAuYXR0cihcImlkXCIsIFwiZ3JvdXAyLWFycm93XCIpXG4gICAgICAgIC5hdHRyKCd2aWV3Qm94JywgJzAgLTUgMTUgMTUnKVxuICAgICAgICAuYXR0cihcInJlZlhcIiwgMi41KVxuICAgICAgICAuYXR0cihcInJlZllcIiwgMClcbiAgICAgICAgLmF0dHIoXCJtYXJrZXJXaWR0aFwiLCAzKVxuICAgICAgICAuYXR0cihcIm1hcmtlckhlaWdodFwiLCAzKVxuICAgICAgICAuYXR0cihcIm9yaWVudFwiLCBcImF1dG9cIilcbiAgICAgICAgLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgLmF0dHIoJ2QnLCAnTTAsLTVMMTAsMEwwLDUnKVxuICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGdyMkNvbG9yKTtcblxuICAgIHZhciBsaW5lID0gc3ZnLmFwcGVuZChcImxpbmVcIilcbiAgICAgICAgLnN0eWxlKCdmaWxsJywgJ25vbmUnKVxuICAgICAgICAuc3R5bGUoJ3N0cm9rZScsIGdyMUNvbG9yKVxuICAgICAgICAuc3R5bGUoJ3N0cm9rZS13aWR0aCcsIDUpXG4gICAgICAgIC5hdHRyKFwibWFya2VyLWVuZFwiLCBcInVybCgjZ3JvdXAxLWFycm93KVwiKTtcblxuICAgIHZhciBsaW5lMiA9IHN2Zy5hcHBlbmQoXCJsaW5lXCIpXG4gICAgICAgIC5zdHlsZSgnZmlsbCcsICdub25lJylcbiAgICAgICAgLnN0eWxlKCdzdHJva2UnLCBncjJDb2xvcilcbiAgICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLCA1KVxuICAgICAgICAuYXR0cihcIm1hcmtlci1lbmRcIiwgXCJ1cmwoI2dyb3VwMi1hcnJvdylcIik7O1xuXG4gICAgdmFyIHZpc2JhY2tncm91bmQgPSBkMy5zZWxlY3QoXCIjd2hpdGVzcGFjZVwiKS5hcHBlbmQoXCJzdmdcIilcbiAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCB3aWR0aClcbiAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgaGVpZ2h0KTtcblxuICAgIHZpc2JhY2tncm91bmQuYXBwZW5kKFwicGF0aFwiKSAvLyBub3RlIGxpbmVzLCBhcmUgYmVoaW5kIGdyb3VwIGh1bGxzIG9mIHdoaWNoIHRoZXJlIGlzIGEgd2hpdGUgYW5kIGNvbG9yZWQgc2VtaSB0cmFuc3BhcmVudCBsYXllclxuICAgICAgICAuYXR0cihcImlkXCIsICdncjFiYWNrZ3JvdW5kJylcbiAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCAnI2ZmZmZmZicpXG4gICAgICAgIC5zdHlsZShcInN0cm9rZVwiLCAnI2ZmZmZmZicpXG4gICAgICAgIC5zdHlsZShcInN0cm9rZS13aWR0aFwiLCAyLjUqYWxsUilcbiAgICAgICAgLnN0eWxlKCdzdHJva2UtbGluZWpvaW4nLCdyb3VuZCcpXG4gICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMSk7XG5cbiAgICB2YXIgdmlzMmJhY2tncm91bmQgPSBkMy5zZWxlY3QoXCIjd2hpdGVzcGFjZVwiKS5hcHBlbmQoXCJzdmdcIilcbiAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCB3aWR0aClcbiAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgaGVpZ2h0KTtcblxuICAgIHZpczJiYWNrZ3JvdW5kLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgLmF0dHIoXCJpZFwiLCAnZ3IxYmFja2dyb3VuZCcpXG4gICAgICAgIC5zdHlsZShcImZpbGxcIiwgJyNmZmZmZmYnKVxuICAgICAgICAuc3R5bGUoXCJzdHJva2VcIiwgJyNmZmZmZmYnKVxuICAgICAgICAuc3R5bGUoXCJzdHJva2Utd2lkdGhcIiwgMi41KmFsbFIpXG4gICAgICAgIC5zdHlsZSgnc3Ryb2tlLWxpbmVqb2luJywncm91bmQnKVxuICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDEpO1xuXG4gICAgdmFyIHZpcyA9IGQzLnNlbGVjdChcIiN3aGl0ZXNwYWNlXCIpLmFwcGVuZChcInN2Z1wiKVxuICAgICAgICAuYXR0cihcIndpZHRoXCIsIHdpZHRoKVxuICAgICAgICAuYXR0cihcImhlaWdodFwiLCBoZWlnaHQpO1xuXG4gICAgdmlzLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgLmF0dHIoXCJpZFwiLCAnZ3IxaHVsbCcpXG4gICAgICAgIC5zdHlsZShcImZpbGxcIiwgZ3IxQ29sb3IpXG4gICAgICAgIC5zdHlsZShcInN0cm9rZVwiLCBncjFDb2xvcilcbiAgICAgICAgLnN0eWxlKFwic3Ryb2tlLXdpZHRoXCIsIDIuNSphbGxSKVxuICAgICAgICAuc3R5bGUoJ3N0cm9rZS1saW5lam9pbicsJ3JvdW5kJyk7XG5cbiAgICB2YXIgdmlzMiA9IGQzLnNlbGVjdChcIiN3aGl0ZXNwYWNlXCIpLmFwcGVuZChcInN2Z1wiKVxuICAgICAgICAuYXR0cihcIndpZHRoXCIsIHdpZHRoKVxuICAgICAgICAuYXR0cihcImhlaWdodFwiLCBoZWlnaHQpO1xuXG4gICAgdmlzMi5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgIC5zdHlsZShcImZpbGxcIiwgZ3IyQ29sb3IpXG4gICAgICAgIC5zdHlsZShcInN0cm9rZVwiLCBncjJDb2xvcilcbiAgICAgICAgLnN0eWxlKFwic3Ryb2tlLXdpZHRoXCIsIDIuNSphbGxSKVxuICAgICAgICAuc3R5bGUoJ3N0cm9rZS1saW5lam9pbicsJ3JvdW5kJyk7XG5cbiAgICBpZiAodiA9PSBsYXlvdXRBZGQgfHwgdiA9PSBsYXlvdXRNb3ZlKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgenBhcmFtcy56dmFycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIGlpID0gZmluZE5vZGVJbmRleCh6cGFyYW1zLnp2YXJzW2pdKTtcbiAgICAgICAgICAgIGlmIChhbGxOb2Rlc1tpaV0uZ3JheW91dClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIG5vZGVzLnB1c2goYWxsTm9kZXNbaWldKTtcbiAgICAgICAgICAgIHZhciBzZWxlY3RNZSA9IHpwYXJhbXMuenZhcnNbal0ucmVwbGFjZSgvXFxXL2csIFwiX1wiKTtcbiAgICAgICAgICAgIHNlbGVjdE1lID0gXCIjXCIuY29uY2F0KHNlbGVjdE1lKTtcbiAgICAgICAgICAgIGQzLnNlbGVjdChzZWxlY3RNZSkuc3R5bGUoJ2JhY2tncm91bmQtY29sb3InLCAoKSA9PiBoZXhUb1JnYmEobm9kZXNbal0uc3Ryb2tlQ29sb3IpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgenBhcmFtcy56ZWRnZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBteXNyYyA9IG5vZGVJbmRleCh6cGFyYW1zLnplZGdlc1tqXVswXSk7XG4gICAgICAgICAgICB2YXIgbXl0Z3QgPSBub2RlSW5kZXgoenBhcmFtcy56ZWRnZXNbal1bMV0pO1xuICAgICAgICAgICAgbGlua3MucHVzaCh7XG4gICAgICAgICAgICAgICAgc291cmNlOiBub2Rlc1tteXNyY10sXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBub2Rlc1tteXRndF0sXG4gICAgICAgICAgICAgICAgbGVmdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYoZDNtX21vZGUpIHtcbiAgICAgICAgICAgIC8vbm9kZXMgPSBbZmluZE5vZGUobXl0YXJnZXQpXTsgICAgICAgICAgICAgICAvLyBPbmx5IGFkZCBkZXBlbmRlbnQgdmFyaWFibGUgb24gc3RhcnR1cFxuICAgICAgICAgICAgbm9kZXMgPSBhbGxOb2Rlcy5zbGljZSgxLGFsbE5vZGVzLmxlbmd0aCk7ICAgIC8vIEFkZCBhbGwgYnV0IGZpcnN0IHZhcmlhYmxlIG9uIHN0YXJ0dXAgKGFzc3VtZXMgMCBwb3NpdGlvbiBpcyBkM20gaW5kZXggdmFyaWFibGUpXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG5vZGVzLmxlbmd0aDsgaisrKSB7IC8vcG9wdWxhdGUgenZhcnMgYXJyYXlcbiAgICAgICAgICAgICAgICBpZiAobm9kZXNbal0ubmFtZSAhPSBteXRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICBub2Rlc1tqXS5ncm91cDEgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB6cGFyYW1zLnpncm91cDEucHVzaChub2Rlc1tqXS5uYW1lKTsgIC8vIHdyaXRlIGFsbCBuYW1lcyAoZXhjZXB0IGQzbSBpbmRleCBhbmQgdGhlIGRlcGVuZGVudCB2YXJpYWJsZSkgdG8gemdyb3VwMSBhcnJheVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGFsbE5vZGVzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIG5vZGVzID0gW2FsbE5vZGVzWzBdLCBhbGxOb2Rlc1sxXSwgYWxsTm9kZXNbMl1dO1xuICAgICAgICAgICAgbGlua3MgPSBbe1xuICAgICAgICAgICAgICAgIHNvdXJjZTogbm9kZXNbMV0sXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBub2Rlc1swXSxcbiAgICAgICAgICAgICAgICBsZWZ0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICByaWdodDogdHJ1ZVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHNvdXJjZTogbm9kZXNbMF0sXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBub2Rlc1syXSxcbiAgICAgICAgICAgICAgICBsZWZ0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICByaWdodDogdHJ1ZVxuICAgICAgICAgICAgfV07XG4gICAgICAgIH0gZWxzZSBpZiAoYWxsTm9kZXMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICBub2RlcyA9IFthbGxOb2Rlc1swXSwgYWxsTm9kZXNbMV1dO1xuICAgICAgICAgICAgbGlua3MgPSBbe1xuICAgICAgICAgICAgICAgIHNvdXJjZTogbm9kZXNbMV0sXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBub2Rlc1swXSxcbiAgICAgICAgICAgICAgICBsZWZ0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICByaWdodDogdHJ1ZVxuICAgICAgICAgICAgfV07XG4gICAgICAgIH0gZWxzZSBpZiAoYWxsTm9kZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBub2RlcyA9IFthbGxOb2Rlc1swXV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbGVydChcIlRoZXJlIGFyZSB6ZXJvIHZhcmlhYmxlcyBpbiB0aGUgbWV0YWRhdGEuXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcGFuZWxQbG90cygpOyAvLyBhZnRlciBub2RlcyBpcyBwb3B1bGF0ZWQsIGFkZCBzdWJzZXQgYW5kIChpZiAhZDNtX21vZGUpIHNldHggcGFuZWxzXG5cbiAgICB2YXIgZm9yY2UgPSBkMy5sYXlvdXQuZm9yY2UoKVxuICAgICAgICAubm9kZXMobm9kZXMpXG4gICAgICAgIC5saW5rcyhsaW5rcylcbiAgICAgICAgLnNpemUoW3dpZHRoLCBoZWlnaHRdKVxuICAgICAgICAubGlua0Rpc3RhbmNlKDE1MClcbiAgICAgICAgLmNoYXJnZSgtODAwKVxuICAgICAgICAub24oJ3RpY2snLCB0aWNrKTtcblxuICAgIC8vIGRlZmluZSBhcnJvdyBtYXJrZXJzIGZvciBncmFwaCBsaW5rc1xuICAgIHN2Zy5hcHBlbmQoJ3N2ZzpkZWZzJykuYXBwZW5kKCdzdmc6bWFya2VyJylcbiAgICAgICAgLmF0dHIoJ2lkJywgJ2VuZC1hcnJvdycpXG4gICAgICAgIC5hdHRyKCd2aWV3Qm94JywgJzAgLTUgMTAgMTAnKVxuICAgICAgICAuYXR0cigncmVmWCcsIDYpXG4gICAgICAgIC5hdHRyKCdtYXJrZXJXaWR0aCcsIDMpXG4gICAgICAgIC5hdHRyKCdtYXJrZXJIZWlnaHQnLCAzKVxuICAgICAgICAuYXR0cignb3JpZW50JywgJ2F1dG8nKVxuICAgICAgICAuYXBwZW5kKCdzdmc6cGF0aCcpXG4gICAgICAgIC5hdHRyKCdkJywgJ00wLC01TDEwLDBMMCw1JylcbiAgICAgICAgLnN0eWxlKCdmaWxsJywgJyMwMDAnKTtcblxuICAgIHN2Zy5hcHBlbmQoJ3N2ZzpkZWZzJykuYXBwZW5kKCdzdmc6bWFya2VyJylcbiAgICAgICAgLmF0dHIoJ2lkJywgJ3N0YXJ0LWFycm93JylcbiAgICAgICAgLmF0dHIoJ3ZpZXdCb3gnLCAnMCAtNSAxMCAxMCcpXG4gICAgICAgIC5hdHRyKCdyZWZYJywgNClcbiAgICAgICAgLmF0dHIoJ21hcmtlcldpZHRoJywgMylcbiAgICAgICAgLmF0dHIoJ21hcmtlckhlaWdodCcsIDMpXG4gICAgICAgIC5hdHRyKCdvcmllbnQnLCAnYXV0bycpXG4gICAgICAgIC5hcHBlbmQoJ3N2ZzpwYXRoJylcbiAgICAgICAgLmF0dHIoJ2QnLCAnTTEwLC01TDAsMEwxMCw1JylcbiAgICAgICAgLnN0eWxlKCdmaWxsJywgJyMwMDAnKTtcblxuICAgIC8vIGxpbmUgZGlzcGxheWVkIHdoZW4gZHJhZ2dpbmcgbmV3IG5vZGVzXG4gICAgdmFyIGRyYWdfbGluZSA9IHN2Zy5hcHBlbmQoJ3N2ZzpwYXRoJylcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2xpbmsgZHJhZ2xpbmUgaGlkZGVuJylcbiAgICAgICAgLmF0dHIoJ2QnLCAnTTAsMEwwLDAnKTtcblxuICAgIC8vIGhhbmRsZXMgdG8gbGluayBhbmQgbm9kZSBlbGVtZW50IGdyb3Vwc1xuICAgIHZhciBwYXRoID0gc3ZnLmFwcGVuZCgnc3ZnOmcnKS5zZWxlY3RBbGwoJ3BhdGgnKSxcbiAgICAgICAgY2lyY2xlID0gc3ZnLmFwcGVuZCgnc3ZnOmcnKS5zZWxlY3RBbGwoJ2cnKTtcbiAgICAgICAgLy9saW5lID0gc3ZnLmFwcGVuZCgnc3ZnOmcnKS5zZWxlY3RBbGwoJ2xpbmUnKTtcblxuICAgIC8vIG1vdXNlIGV2ZW50IHZhcnNcbiAgICB2YXIgc2VsZWN0ZWRfbm9kZSA9IG51bGwsXG4gICAgICAgIHNlbGVjdGVkX2xpbmsgPSBudWxsLFxuICAgICAgICBtb3VzZWRvd25fbGluayA9IG51bGwsXG4gICAgICAgIG1vdXNlZG93bl9ub2RlID0gbnVsbCxcbiAgICAgICAgbW91c2V1cF9ub2RlID0gbnVsbDtcblxuICAgIGZ1bmN0aW9uIHJlc2V0TW91c2VWYXJzKCkge1xuICAgICAgICBtb3VzZWRvd25fbm9kZSA9IG51bGw7XG4gICAgICAgIG1vdXNldXBfbm9kZSA9IG51bGw7XG4gICAgICAgIG1vdXNlZG93bl9saW5rID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgZm9yY2UgbGF5b3V0IChjYWxsZWQgYXV0b21hdGljYWxseSBlYWNoIGl0ZXJhdGlvbilcbiAgICBmdW5jdGlvbiB0aWNrKCkge1xuXG5cbiAgICAgICAgZnVuY3Rpb24gZmluZGNvb3JkcyhmaW5kbmFtZXMsYWxsbmFtZXMsY29vcmRzLGxlbmd0aGVuKXtcbiAgICAgICAgICAgIHZhciBmY29vcmRzID0gbmV3IEFycmF5KGZpbmRuYW1lcy5sZW5ndGgpOyAgIC8vIGZvdW5kIGNvb3JkaW5hdGVzXG4gICAgICAgICAgICB2YXIgYWRkbG9jYXRpb24gPSAwO1xuICAgICAgICAgICAgaWYoZmluZG5hbWVzLmxlbmd0aD4wKXtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGZpbmRuYW1lcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBhZGRsb2NhdGlvbiA9IGFsbG5hbWVzLmluZGV4T2YoZmluZG5hbWVzW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgZmNvb3Jkc1tqXSA9IGNvb3Jkc1thZGRsb2NhdGlvbl07XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmKGxlbmd0aGVuKXtcbiAgICAgICAgICAgICAgICAvLyBkMy5nZW9tLmh1bGwgcmV0dXJucyBudWxsIGZvciB0d28gcG9pbnRzLCBhbmQgZmFpbHMgaWYgdGhyZWUgcG9pbnRzIGFyZSBpbiBhIGxpbmUsXG4gICAgICAgICAgICAgICAgLy8gc28gdGhpcyBwdXRzIGEgY291cGxlIHBvaW50cyBzbGlnaHRseSBvZmYgdGhlIGxpbmUgZm9yIHR3byBwb2ludHMsIG9yIGFyb3VuZCBhIHNpbmdsZXRvbi5cbiAgICAgICAgICAgICAgICBpZiAoZmNvb3Jkcy5sZW5ndGggPT0gMil7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWx0YXggPSBmY29vcmRzWzBdWzBdLSBmY29vcmRzWzFdWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVsdGF5ID0gZmNvb3Jkc1swXVsxXS0gZmNvb3Jkc1sxXVsxXTtcbiAgICAgICAgICAgICAgICAgICAgZmNvb3Jkcy5wdXNoKFsoZmNvb3Jkc1swXVswXSArIGZjb29yZHNbMV1bMF0pLzIgKyBkZWx0YXkvMjAsIChmY29vcmRzWzBdWzFdKyBmY29vcmRzWzFdWzFdKS8yICsgZGVsdGF4LzIwXSk7XG4gICAgICAgICAgICAgICAgICAgIGZjb29yZHMucHVzaChbKGZjb29yZHNbMF1bMF0gKyBmY29vcmRzWzFdWzBdKS8yIC0gZGVsdGF5LzIwLCAoZmNvb3Jkc1swXVsxXSsgZmNvb3Jkc1sxXVsxXSkvMiAtIGRlbHRheC8yMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZmNvb3Jkcy5sZW5ndGggPT0gMSl7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWx0YSA9IGFsbFIgKiAwLjI7XG4gICAgICAgICAgICAgICAgICAgIGZjb29yZHMucHVzaChbZmNvb3Jkc1swXVswXSArIGRlbHRhLCBmY29vcmRzWzBdWzFdXSk7XG4gICAgICAgICAgICAgICAgICAgIGZjb29yZHMucHVzaChbZmNvb3Jkc1swXVswXSAtIGRlbHRhLCBmY29vcmRzWzBdWzFdXSk7XG4gICAgICAgICAgICAgICAgICAgIGZjb29yZHMucHVzaChbZmNvb3Jkc1swXVswXSwgZmNvb3Jkc1swXVsxXSArIGRlbHRhXSk7XG4gICAgICAgICAgICAgICAgICAgIGZjb29yZHMucHVzaChbZmNvb3Jkc1swXVswXSwgZmNvb3Jkc1swXVsxXSAtIGRlbHRhXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChmY29vcmRzKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBkMy5nZW9tLmh1bGwgcmV0dXJucyBudWxsIGZvciB0d28gcG9pbnRzLCBhbmQgZmFpbHMgaWYgdGhyZWUgcG9pbnRzIGFyZSBpbiBhIGxpbmUsXG4gICAgICAgIC8vIHNvIHRoaXMgcHV0cyBhIGNvdXBsZSBwb2ludHMgc2xpZ2h0bHkgb2ZmIHRoZSBsaW5lIGZvciB0d28gcG9pbnRzLCBvciBhcm91bmQgYSBzaW5nbGV0b24uXG4gICAgICAgIGZ1bmN0aW9uIGxlbmd0aGVuY29vcmRzKGNvb3Jkcyl7XG4gICAgICAgICAgICBpZiAoY29vcmRzLmxlbmd0aCA9PSAyKXtcbiAgICAgICAgICAgICAgICB2YXIgZGVsdGF4ID0gY29vcmRzWzBdWzBdLSBjb29yZHNbMV1bMF07XG4gICAgICAgICAgICAgICAgdmFyIGRlbHRheSA9IGNvb3Jkc1swXVsxXS0gY29vcmRzWzFdWzFdO1xuICAgICAgICAgICAgICAgIGNvb3Jkcy5wdXNoKFsoY29vcmRzWzBdWzBdICsgY29vcmRzWzFdWzBdKS8yICsgZGVsdGF5LzIwLCAoY29vcmRzWzBdWzFdKyBjb29yZHNbMV1bMV0pLzIgKyBkZWx0YXgvMjBdKTtcbiAgICAgICAgICAgICAgICBjb29yZHMucHVzaChbKGNvb3Jkc1swXVswXSArIGNvb3Jkc1sxXVswXSkvMiAtIGRlbHRheS8yMCwgKGNvb3Jkc1swXVsxXSsgY29vcmRzWzFdWzFdKS8yIC0gZGVsdGF4LzIwXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29vcmRzLmxlbmd0aCA9PSAxKXtcbiAgICAgICAgICAgICAgICB2YXIgZGVsdGEgPSBhbGxSICogMC4yO1xuICAgICAgICAgICAgICAgIGNvb3Jkcy5wdXNoKFtjb29yZHNbMF1bMF0gKyBkZWx0YSwgY29vcmRzWzBdWzFdXSk7XG4gICAgICAgICAgICAgICAgY29vcmRzLnB1c2goW2Nvb3Jkc1swXVswXSAtIGRlbHRhLCBjb29yZHNbMF1bMV1dKTtcbiAgICAgICAgICAgICAgICBjb29yZHMucHVzaChbY29vcmRzWzBdWzBdLCBjb29yZHNbMF1bMV0gKyBkZWx0YV0pO1xuICAgICAgICAgICAgICAgIGNvb3Jkcy5wdXNoKFtjb29yZHNbMF1bMF0sIGNvb3Jkc1swXVsxXSAtIGRlbHRhXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKGNvb3Jkcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGNvb3JkcyA9IG5vZGVzLm1hcChmdW5jdGlvbihkKSB7ICByZXR1cm4gWyBkLngsIGQueV07IH0pO1xuICAgICAgICB2YXIgZ3IxY29vcmRzID0gZmluZGNvb3Jkcyh6cGFyYW1zLnpncm91cDEsIHpwYXJhbXMuenZhcnMsIGNvb3JkcywgdHJ1ZSk7XG4gICAgICAgIHZhciBncjJjb29yZHMgPSBmaW5kY29vcmRzKHpwYXJhbXMuemdyb3VwMiwgenBhcmFtcy56dmFycywgY29vcmRzLCB0cnVlKTtcbiAgICAgICAgdmFyIGRlcGNvb3JkcyA9IGZpbmRjb29yZHMoenBhcmFtcy56ZHYsIHpwYXJhbXMuenZhcnMsIGNvb3JkcywgZmFsc2UpO1xuXG4gICAgICAgIC8vIGRyYXcgY29udmV4IGh1bGwgYXJvdW5kIGluZGVwZW5kZW50IHZhcmlhYmxlcywgaWYgdGhyZWUgb3IgbW9yZSBjb29yZGluYXRlcyBnaXZlblxuICAgICAgICAvLyBub3RlLCBkMy5nZW9tLmh1bGwgcmV0dXJucyBudWxsIGlmIHNob3J0ZXIgY29vcmRpbmF0ZSBzZXQgdGhhbiAzLFxuICAgICAgICAvLyBzbyBmaW5kY29vcmRzKCkgZnVuY3Rpb24gaGFzIG9wdGlvbiB0byBsZW5ndGhlbiB0aGUgY29vcmRpbmF0ZXMgcmV0dXJuZWQgdG8gYnlwYXNzIHRoaXNcbiAgICAgICAgaWYoZ3IxY29vcmRzLmxlbmd0aCA+IDIpe1xuICAgICAgICAgICAgbGluZS5zdHlsZShcIm9wYWNpdHlcIiwgMSk7XG4gICAgICAgICAgICB2aXNiYWNrZ3JvdW5kLnN0eWxlKFwib3BhY2l0eVwiLCAxKTtcbiAgICAgICAgICAgIHZpcy5zdHlsZShcIm9wYWNpdHlcIiwgMC4zKTtcbiAgICAgICAgICAgIHZhciBteWh1bGwgPSBkMy5nZW9tLmh1bGwoZ3IxY29vcmRzKTtcblxuICAgICAgICAgICAgdmlzLnNlbGVjdEFsbChcInBhdGhcIilcbiAgICAgICAgICAgICAgICAuZGF0YShbbXlodWxsXSkgICAvLyByZXR1cm5zIG51bGwgaWYgbGVzcyB0aGFuIHRocmVlIGNvb3JkaW5hdGVzXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJkXCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIFwiTVwiICsgZC5qb2luKFwiTFwiKSArIFwiWlwiOyB9KTtcbiAgICAgICAgICAgIHZpc2JhY2tncm91bmQuc2VsZWN0QWxsKFwicGF0aFwiKVxuICAgICAgICAgICAgICAgIC5kYXRhKFtteWh1bGxdKSAgIC8vIHJldHVybnMgbnVsbCBpZiBsZXNzIHRoYW4gdGhyZWUgY29vcmRpbmF0ZXNcbiAgICAgICAgICAgICAgICAuYXR0cihcImRcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gXCJNXCIgKyBkLmpvaW4oXCJMXCIpICsgXCJaXCI7IH0pO1xuXG4gICAgICAgICAgICAvL3ZhciBwID0gZDMuZ2VvbS5wb2x5Z29uKGluZGNvb3JkcykuY2VudHJvaWQoKTsgIC8vIFNlZW1zIHRvIGdvIHN0cmFuZ2Ugc29tZXRpbWVzXG4gICAgICAgICAgICB2YXIgcCA9IGphbWVzY2VudHJvaWQoZ3IxY29vcmRzKTtcblxuICAgICAgICAgICAgaWYoZGVwY29vcmRzLmxlbmd0aD4wKXtcbiAgICAgICAgICAgICAgICB2YXIgcSA9IGRlcGNvb3Jkc1swXTsgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90ZSwgb25seSB1c2luZyBmaXJzdCBkZXAgdmFyIGN1cnJlbnRseVxuICAgICAgICAgICAgICAgIC8vdmFyIHIgPSBmaW5kYm91bmRhcnkocCxxLGdyMWNvb3Jkcyk7ICAgICAgICAvLyBBbiBhcHByb2FjaCB0byBmaW5kIHRoZSBleGFjdCBib3VuZGFyeSwgbm90IHByZXNlbnRseSB3b3JraW5nXG4gICAgICAgICAgICAgICAgdmFyIGxkZWx0YVggPSBxWzBdIC0gcFswXSxcbiAgICAgICAgICAgICAgICAgICAgbGRlbHRhWSA9IHFbMV0gLSBwWzFdLFxuICAgICAgICAgICAgICAgICAgICBsZGlzdCA9IE1hdGguc3FydChsZGVsdGFYICogbGRlbHRhWCArIGxkZWx0YVkgKiBsZGVsdGFZKSxcbiAgICAgICAgICAgICAgICAgICAgbG5vcm1YID0gMCxcbiAgICAgICAgICAgICAgICAgICAgbG5vcm1ZID0gMCxcbiAgICAgICAgICAgICAgICAgICAgbHNvdXJjZVBhZGRpbmcgPSBhbGxSICsgNyxcbiAgICAgICAgICAgICAgICAgICAgbHRhcmdldFBhZGRpbmcgPSBhbGxSICsgMTA7XG5cbiAgICAgICAgICAgICAgICBpZiAobGRpc3QgPiAwKXtcbiAgICAgICAgICAgICAgICAgICAgbG5vcm1YID0gbGRlbHRhWCAvIGxkaXN0O1xuICAgICAgICAgICAgICAgICAgICBsbm9ybVkgPSBsZGVsdGFZIC8gbGRpc3Q7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGxpbmUuYXR0cihcIngxXCIsIHBbMF0gKyAobHNvdXJjZVBhZGRpbmcgKiBsbm9ybVgpKSAgIC8vIG9yIHJbMF0gaWYgZmluZGJvdW5kYXJ5IHdvcmtzXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieTFcIiwgcFsxXSArIChsc291cmNlUGFkZGluZyAqIGxub3JtWSkpICAgLy8gb3IgclsxXSBpZiBmaW5kYm91bmRhcnkgd29ya3NcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ4MlwiLCBxWzBdLSAobHRhcmdldFBhZGRpbmcgKiBsbm9ybVgpKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcInkyXCIsIHFbMV0tIChsdGFyZ2V0UGFkZGluZyAqIGxub3JtWSkpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gZ3JvdXAgbWVtYmVycyBhdHRyYWN0IGVhY2ggb3RoZXIsIHJlcHVsc2Ugbm9uLWdyb3VwIG1lbWJlcnNcbiAgICAgICAgICAgIG5vZGVzLmZvckVhY2gobiA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIHNpZ24gPSAobi5ncm91cDEpID8gMSA6IC0xOyAgICAvL3dhczogTWF0aC5zaWduKCB6cGFyYW1zLnpncm91cDEuaW5kZXhPZihuLm5hbWUpICswLjUgKTsgIC8vIDEgaWYgbiBpbiBncm91cCwgLTEgaWYgbiBub3QgaW4gZ3JvdXA7XG4gICAgICAgICAgICAgICAgdmFyIGxkZWx0YVggPSBwWzBdIC0gbi54LFxuICAgICAgICAgICAgICAgICAgICBsZGVsdGFZID0gcFsxXSAtIG4ueSxcbiAgICAgICAgICAgICAgICAgICAgbGRpc3QgPSBNYXRoLnNxcnQobGRlbHRhWCAqIGxkZWx0YVggKyBsZGVsdGFZICogbGRlbHRhWSk7XG4gICAgICAgICAgICAgICAgICAgIGxub3JtWCA9IDAsXG4gICAgICAgICAgICAgICAgICAgIGxub3JtWSA9IDA7XG5cbiAgICAgICAgICAgICAgICBpZiAobGRpc3QgPiAwKXtcbiAgICAgICAgICAgICAgICAgICAgbG5vcm1YID0gbGRlbHRhWCAvIGxkaXN0O1xuICAgICAgICAgICAgICAgICAgICBsbm9ybVkgPSBsZGVsdGFZIC8gbGRpc3Q7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIG4ueCArPSBNYXRoLm1pbihsbm9ybVggLCBsZGVsdGFYLzEwMCApICogayAqIHNpZ24gICAqIGZvcmNlLmFscGhhKCk7XG4gICAgICAgICAgICAgICAgbi55ICs9IE1hdGgubWluKGxub3JtWSAsIGxkZWx0YVkvMTAwICkgKiBrICogc2lnbiAgICogZm9yY2UuYWxwaGEoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgdmlzYmFja2dyb3VuZC5zdHlsZShcIm9wYWNpdHlcIiwgMCk7XG5cbiAgICAgICAgICAgIHZpcy5zdHlsZShcIm9wYWNpdHlcIiwgMCk7XG4vLyAgICAgICAgICAgIHZpcy5zdHlsZShcIm9wYWNpdHlcIiwgMCk7XG4gICAgICAgICAgICBsaW5lLnN0eWxlKFwib3BhY2l0eVwiLCAwKTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZihncjJjb29yZHMubGVuZ3RoID4gMil7XG4gICAgICAgICAgICBsaW5lMi5zdHlsZShcIm9wYWNpdHlcIiwgMSk7XG4gICAgICAgICAgICB2aXMyYmFja2dyb3VuZC5zdHlsZShcIm9wYWNpdHlcIiwgMSk7XG4gICAgICAgICAgICB2aXMyLnN0eWxlKFwib3BhY2l0eVwiLCAwLjMpO1xuICAgICAgICAgICAgdmFyIG15aHVsbCA9IGQzLmdlb20uaHVsbChncjJjb29yZHMpO1xuICAgICAgICAgICAgdmlzMi5zZWxlY3RBbGwoXCJwYXRoXCIpXG4gICAgICAgICAgICAgICAgLmRhdGEoW215aHVsbF0pICAgLy8gcmV0dXJucyBudWxsIGlmIGxlc3MgdGhhbiB0aHJlZSBjb29yZGluYXRlc1xuICAgICAgICAgICAgICAgIC5hdHRyKFwiZFwiLCBmdW5jdGlvbihkKSB7IHJldHVybiBcIk1cIiArIGQuam9pbihcIkxcIikgKyBcIlpcIjsgfSk7XG4gICAgICAgICAgICB2aXMyYmFja2dyb3VuZC5zZWxlY3RBbGwoXCJwYXRoXCIpXG4gICAgICAgICAgICAgICAgLmRhdGEoW215aHVsbF0pICAgLy8gcmV0dXJucyBudWxsIGlmIGxlc3MgdGhhbiB0aHJlZSBjb29yZGluYXRlc1xuICAgICAgICAgICAgICAgIC5hdHRyKFwiZFwiLCBmdW5jdGlvbihkKSB7IHJldHVybiBcIk1cIiArIGQuam9pbihcIkxcIikgKyBcIlpcIjsgfSk7XG5cbiAgICAgICAgICAgIC8vdmFyIHAgPSBkMy5nZW9tLnBvbHlnb24oaW5kY29vcmRzKS5jZW50cm9pZCgpOyAgLy8gU2VlbXMgdG8gZ28gc3RyYW5nZSBzb21ldGltZXNcbiAgICAgICAgICAgIHZhciBwID0gamFtZXNjZW50cm9pZChncjJjb29yZHMpO1xuXG4gICAgICAgICAgICBpZihkZXBjb29yZHMubGVuZ3RoPjApe1xuICAgICAgICAgICAgICAgIHZhciBxID0gZGVwY29vcmRzWzBdOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90ZSwgb25seSB1c2luZyBmaXJzdCBkZXAgdmFyIGN1cnJlbnRseVxuICAgICAgICAgICAgICAgIHZhciBsZGVsdGFYID0gcVswXSAtIHBbMF0sXG4gICAgICAgICAgICAgICAgICAgIGxkZWx0YVkgPSBxWzFdIC0gcFsxXSxcbiAgICAgICAgICAgICAgICAgICAgbGRpc3QgPSBNYXRoLnNxcnQobGRlbHRhWCAqIGxkZWx0YVggKyBsZGVsdGFZICogbGRlbHRhWSksXG4gICAgICAgICAgICAgICAgICAgIGxub3JtWCA9IGxkZWx0YVggLyBsZGlzdCxcbiAgICAgICAgICAgICAgICAgICAgbG5vcm1ZID0gbGRlbHRhWSAvIGxkaXN0LFxuICAgICAgICAgICAgICAgICAgICBsc291cmNlUGFkZGluZyA9IGFsbFIgKyA3LFxuICAgICAgICAgICAgICAgICAgICBsdGFyZ2V0UGFkZGluZyA9IGFsbFIgKyAxMDtcblxuICAgICAgICAgICAgICAgIGxpbmUyLmF0dHIoXCJ4MVwiLCBwWzBdICsgKGxzb3VyY2VQYWRkaW5nICogbG5vcm1YKSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ5MVwiLCBwWzFdICsgKGxzb3VyY2VQYWRkaW5nICogbG5vcm1ZKSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ4MlwiLCBxWzBdLSAobHRhcmdldFBhZGRpbmcgKiBsbm9ybVgpKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcInkyXCIsIHFbMV0tIChsdGFyZ2V0UGFkZGluZyAqIGxub3JtWSkpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gZ3JvdXAgbWVtYmVycyBhdHRyYWN0IGVhY2ggb3RoZXIsIHJlcHVsc2Ugbm9uLWdyb3VwIG1lbWJlcnNcbiAgICAgICAgICAgIG5vZGVzLmZvckVhY2gobiA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIHNpZ24gPSAobi5ncm91cDIpID8gMSA6IC0xOyAgLy8gd2FzOiBNYXRoLnNpZ24oIHpwYXJhbXMuemdyb3VwMi5pbmRleE9mKG4ubmFtZSkgKzAuNSApOyAgLy8gMSBpZiBuIGluIGdyb3VwLCAtMSBpZiBuIG5vdCBpbiBncm91cDtcbiAgICAgICAgICAgICAgICB2YXIgbGRlbHRhWCA9IHBbMF0gLSBuLngsXG4gICAgICAgICAgICAgICAgICAgIGxkZWx0YVkgPSBwWzFdIC0gbi55LFxuICAgICAgICAgICAgICAgICAgICBsZGlzdCA9IE1hdGguc3FydChsZGVsdGFYICogbGRlbHRhWCArIGxkZWx0YVkgKiBsZGVsdGFZKSxcbiAgICAgICAgICAgICAgICAgICAgbG5vcm1YID0gMCxcbiAgICAgICAgICAgICAgICAgICAgbG5vcm1ZID0gMDtcblxuICAgICAgICAgICAgICAgIGlmIChsZGlzdCA+IDApe1xuICAgICAgICAgICAgICAgICAgICBsbm9ybVggPSBsZGVsdGFYIC8gbGRpc3Q7XG4gICAgICAgICAgICAgICAgICAgIGxub3JtWSA9IGxkZWx0YVkgLyBsZGlzdDtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgbi54ICs9IE1hdGgubWluKGxub3JtWCAsIGxkZWx0YVgvMTAwICkgKiBrICogc2lnbiAgICogZm9yY2UuYWxwaGEoKTtcbiAgICAgICAgICAgICAgICBuLnkgKz0gTWF0aC5taW4obG5vcm1ZICwgbGRlbHRhWS8xMDAgKSAqIGsgKiBzaWduICAgKiBmb3JjZS5hbHBoYSgpO1xuICAgICAgICAgICAgfSk7XG5cblxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHZpczJiYWNrZ3JvdW5kLnN0eWxlKFwib3BhY2l0eVwiLCAwKTtcbiAgICAgICAgICAgIHZpczIuc3R5bGUoXCJvcGFjaXR5XCIsIDApO1xuICAgICAgICAgICAgbGluZTIuc3R5bGUoXCJvcGFjaXR5XCIsIDApO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGRyYXcgZGlyZWN0ZWQgZWRnZXMgd2l0aCBwcm9wZXIgcGFkZGluZyBmcm9tIG5vZGUgY2VudGVyc1xuICAgICAgICBwYXRoLmF0dHIoJ2QnLCBkID0+IHtcbiAgICAgICAgICAgIHZhciBkZWx0YVggPSBkLnRhcmdldC54IC0gZC5zb3VyY2UueCxcbiAgICAgICAgICAgICAgICBkZWx0YVkgPSBkLnRhcmdldC55IC0gZC5zb3VyY2UueSxcbiAgICAgICAgICAgICAgICBkaXN0ID0gTWF0aC5zcXJ0KGRlbHRhWCAqIGRlbHRhWCArIGRlbHRhWSAqIGRlbHRhWSksXG4gICAgICAgICAgICAgICAgbm9ybVggPSBkZWx0YVggLyBkaXN0LFxuICAgICAgICAgICAgICAgIG5vcm1ZID0gZGVsdGFZIC8gZGlzdCxcbiAgICAgICAgICAgICAgICBzb3VyY2VQYWRkaW5nID0gZC5sZWZ0ID8gYWxsUiArIDUgOiBhbGxSLFxuICAgICAgICAgICAgICAgIHRhcmdldFBhZGRpbmcgPSBkLnJpZ2h0ID8gYWxsUiArIDUgOiBhbGxSLFxuICAgICAgICAgICAgICAgIHNvdXJjZVggPSBkLnNvdXJjZS54ICsgKHNvdXJjZVBhZGRpbmcgKiBub3JtWCksXG4gICAgICAgICAgICAgICAgc291cmNlWSA9IGQuc291cmNlLnkgKyAoc291cmNlUGFkZGluZyAqIG5vcm1ZKSxcbiAgICAgICAgICAgICAgICB0YXJnZXRYID0gZC50YXJnZXQueCAtICh0YXJnZXRQYWRkaW5nICogbm9ybVgpLFxuICAgICAgICAgICAgICAgIHRhcmdldFkgPSBkLnRhcmdldC55IC0gKHRhcmdldFBhZGRpbmcgKiBub3JtWSk7XG4gICAgICAgICAgICByZXR1cm4gYE0ke3NvdXJjZVh9LCR7c291cmNlWX1MJHt0YXJnZXRYfSwke3RhcmdldFl9YDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY2lyY2xlLmF0dHIoJ3RyYW5zZm9ybScsIGQgPT4gJ3RyYW5zbGF0ZSgnICsgZC54ICsgJywnICsgZC55ICsgJyknKTtcblxuICAgICAgICBjaXJjbGUuc2VsZWN0QWxsKCdjaXJjbGUnKSAgICAgICAgICAgLy8gU2hyaW5rL2V4cGFuZCBwZWJibGVzIHRoYXQgam9pbi9sZWF2ZSBncm91cHNcbiAgICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgIC5kdXJhdGlvbigxMDApXG4gICAgICAgICAgICAuYXR0cigncicsIGQgPT4gc2V0UGViYmxlUmFkaXVzKGQpKTtcblxuICAgIH1cblxuICAgIGNsaWNrVmFyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIGV2ZXJ5IHRpbWUgYSB2YXJpYWJsZSBpbiBsZWZ0cGFuZWwgaXMgY2xpY2tlZCwgbm9kZXMgdXBkYXRlcyBhbmQgYmFja2dyb3VuZCBjb2xvciBjaGFuZ2VzXG4gICAgICAgIGlmIChmaW5kTm9kZUluZGV4KHRoaXMuaWQsIHRydWUpLmdyYXlvdXQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHpwYXJhbXMuenZhcnMgPSBbXTtcbiAgICAgICAgbGV0IHRleHQgPSBkMy5zZWxlY3QodGhpcykudGV4dCgpO1xuICAgICAgICBsZXQgbm9kZSA9IGZpbmROb2RlKHRleHQpO1xuICAgICAgICBpZiAobm9kZXMubWFwKG4gPT4gbi5uYW1lKS5pbmNsdWRlcyh0ZXh0KSkge1xuICAgICAgICAgICAgbm9kZXMuc3BsaWNlKG5vZGUuaW5kZXgsIDEpO1xuICAgICAgICAgICAgc3BsaWNlTGlua3NGb3JOb2RlKG5vZGUpO1xuICAgICAgICAgICAgc3BsaWNlKG5vZGUuc3Ryb2tlQ29sb3IsIHRleHQsIFtkdkNvbG9yLCAnemR2J10sIFtjc0NvbG9yLCAnemNyb3NzJ10sIFt0aW1lQ29sb3IsICd6dGltZSddLCBbbm9tQ29sb3IsICd6bm9tJ10pO1xuXG4gICAgICAgICAgICBpZihub2RlLmdyb3VwMSl7ICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBub2RlIG5hbWUgZnJvbSBncm91cCBsaXN0cyAoc2hvdWxkIHVzZSBhZGFwdGF0aW9uIG9mIHNwbGljZS1ieS1jb2xvcilcbiAgICAgICAgICAgICAgICBub2RlLmdyb3VwMSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHpwYXJhbXMuemdyb3VwMS5zcGxpY2UoenBhcmFtcy56Z3JvdXAxLmluZGV4T2Yobm9kZS5uYW1lKSwxKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZihub2RlLmdyb3VwMil7XG4gICAgICAgICAgICAgICAgbm9kZS5ncm91cDIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB6cGFyYW1zLnpncm91cDIuc3BsaWNlKHpwYXJhbXMuemdyb3VwMi5pbmRleE9mKG5vZGUubmFtZSksMSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBub2RlUmVzZXQobm9kZSk7XG4gICAgICAgICAgICBsZWdlbmQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICBpZiAobm9kZXMubGVuZ3RoID09PSAwKSBub2Rlc1swXS5yZWZsZXhpdmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHpwYXJhbXMuenZhcnMgPSBub2Rlcy5tYXAobiA9PiBuLm5hbWUpICAgIC8vIGFkZGluZyB0aGlzIHRvIGtlZXAgaXQgY3VycmVudCAob3Igc2hvdWxkIHdlIHJlbHkgb24gbm9kZXMubWFwKG4gPT4gbi5uYW1lKSBmb3IgdmFyaWFibGUgbGlzdD8pXG4gICAgICAgIHBhbmVsUGxvdHMoKTtcbiAgICAgICAgcmVzdGFydCgpO1xuICAgIH1cblxuICAgIGQzLnNlbGVjdChcIiNtb2RlbHNcIikuc2VsZWN0QWxsKFwicFwiKSAvLyBtb2RlbHMgdGFiXG4gICAgICAgIC8vICBkMy5zZWxlY3QoXCIjRGlzcGxheV9jb250ZW50XCIpXG4gICAgICAgIC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIG15Q29sb3IgPSBkMy5zZWxlY3QodGhpcykuc3R5bGUoJ2JhY2tncm91bmQtY29sb3InKTtcbiAgICAgICAgICAgIGQzLnNlbGVjdChcIiNtb2RlbHNcIikuc2VsZWN0QWxsKFwicFwiKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnYmFja2dyb3VuZC1jb2xvcicsIHZhckNvbG9yKTtcbiAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnYmFja2dyb3VuZC1jb2xvcicsIGQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZDMucmdiKG15Q29sb3IpLnRvU3RyaW5nKCkgPT09IHZhckNvbG9yLnRvU3RyaW5nKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHpwYXJhbXMuem1vZGVsID0gZC50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhleFRvUmdiYShzZWxWYXJDb2xvcik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB6cGFyYW1zLnptb2RlbCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhckNvbG9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXN0YXJ0KCk7XG4gICAgICAgIH0pO1xuXG4gICAgZDMuc2VsZWN0KFwiI3R5cGVzXCIpLnNlbGVjdEFsbChcInBcIikgLy8gbW9kZWxzIHRhYlxuICAgIC8vICBkMy5zZWxlY3QoXCIjRGlzcGxheV9jb250ZW50XCIpXG4gICAgLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmKGxvY2t0b2dnbGUpIHJldHVybjtcbiAgICAgICAgaWYodGhpcy5jbGFzc05hbWU9PVwiaXRlbS1zZWxlY3RcIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZDMuc2VsZWN0KFwiI3R5cGVzXCIpLnNlbGVjdChcInAuaXRlbS1zZWxlY3RcIilcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdpdGVtLWRlZmF1bHQnKTtcbiAgICAgICAgICAgIGQzbVByb2JsZW1EZXNjcmlwdGlvbi50YXNrVHlwZSA9IHRoaXMuaW5uZXJIVE1MLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuYXR0cignY2xhc3MnLFwiaXRlbS1zZWxlY3RcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdGFydCgpO1xuICAgICAgICB1cGRhdGVTY2hlbWEoXCJ0YXNrVHlwZVwiLCBkM21Qcm9ibGVtRGVzY3JpcHRpb24sIGQzbVRhc2tUeXBlKTtcbiAgICAgICAgfSk7XG5cbiAgICBkMy5zZWxlY3QoXCIjc3VidHlwZXNcIikuc2VsZWN0QWxsKFwicFwiKVxuICAgIC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZihsb2NrdG9nZ2xlKSByZXR1cm47XG4gICAgICAgIGlmKHRoaXMuY2xhc3NOYW1lPT1cIml0ZW0tc2VsZWN0XCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGQzLnNlbGVjdChcIiNzdWJ0eXBlc1wiKS5zZWxlY3QoXCJwLml0ZW0tc2VsZWN0XCIpXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnaXRlbS1kZWZhdWx0Jyk7XG4gICAgICAgICAgICBkM21Qcm9ibGVtRGVzY3JpcHRpb24udGFza1N1YnR5cGUgPSB0aGlzLmlubmVySFRNTC50b1N0cmluZygpO1xuICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmF0dHIoJ2NsYXNzJyxcIml0ZW0tc2VsZWN0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3RhcnQoKTtcbiAgICAgICAgdXBkYXRlU2NoZW1hKFwidGFza1N1YnR5cGVcIiwgZDNtUHJvYmxlbURlc2NyaXB0aW9uLCBkM21UYXNrU3VidHlwZSk7XG4gICAgICAgIH0pO1xuXG4gICAgZDMuc2VsZWN0KFwiI21ldHJpY3NcIikuc2VsZWN0QWxsKFwicFwiKVxuICAgIC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZihsb2NrdG9nZ2xlKSByZXR1cm47XG4gICAgICAgIGlmKHRoaXMuY2xhc3NOYW1lPT1cIml0ZW0tc2VsZWN0XCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgIC8vICAgICAgICAgZDNtUHJvYmxlbURlc2NyaXB0aW9uLm1ldHJpYyA9IFtcIlwiLFwiXCJdO1xuICAgIC8vICAgICAgICB0aGlzLmNsYXNzTmFtZT1cIml0ZW0tZGVmYXVsdFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZDMuc2VsZWN0KFwiI21ldHJpY3NcIikuc2VsZWN0KFwicC5pdGVtLXNlbGVjdFwiKVxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2l0ZW0tZGVmYXVsdCcpO1xuICAgICAgICAgICAgZDNtUHJvYmxlbURlc2NyaXB0aW9uLm1ldHJpYyA9IHRoaXMuaW5uZXJIVE1MLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuYXR0cignY2xhc3MnLFwiaXRlbS1zZWxlY3RcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdGFydCgpO1xuICAgICAgICB1cGRhdGVTY2hlbWEoXCJtZXRyaWNcIiwgZDNtUHJvYmxlbURlc2NyaXB0aW9uLCBkM21NZXRyaWNzKTtcbiAgICAgICAgfSk7XG5cbiAgICBkMy5zZWxlY3QoXCIjb3V0cHV0c1wiKS5zZWxlY3RBbGwoXCJwXCIpXG4gICAgLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmKGxvY2t0b2dnbGUpIHJldHVybjtcbiAgICAgICAgaWYodGhpcy5jbGFzc05hbWU9PVwiaXRlbS1zZWxlY3RcIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZDMuc2VsZWN0KFwiI291dHB1dHNcIikuc2VsZWN0KFwicC5pdGVtLXNlbGVjdFwiKVxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2l0ZW0tZGVmYXVsdCcpO1xuICAgICAgICAgICAgZDNtUHJvYmxlbURlc2NyaXB0aW9uLm91dHB1dFR5cGUgPSB0aGlzLmlubmVySFRNTC50b1N0cmluZygpO1xuICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmF0dHIoJ2NsYXNzJyxcIml0ZW0tc2VsZWN0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3RhcnQoKTtcbiAgICAgICAgdXBkYXRlU2NoZW1hKFwib3V0cHV0VHlwZVwiLCBkM21Qcm9ibGVtRGVzY3JpcHRpb24sIGQzbU91dHB1dFR5cGUpO1xuICAgICAgICB9KTtcblxuICAgIC8vIHVwZGF0ZSBncmFwaCAoY2FsbGVkIHdoZW4gbmVlZGVkKVxuICAgIGZ1bmN0aW9uIHJlc3RhcnQoKSB7XG4gICAgICAgIC8vIG5vZGVzLmlkIGlzIHBlZ2dlZCB0byBhbGxOb2RlcywgaS5lLiB0aGUgb3JkZXIgaW4gd2hpY2ggdmFyaWFibGVzIGFyZSByZWFkIGluXG4gICAgICAgIC8vIG5vZGVzLmluZGV4IGlzIGZsb2F0aW5nIGFuZCBkZXBlbmRzIG9uIHVwZGF0ZXMgdG8gbm9kZXMuICBhIHZhcmlhYmxlcyBpbmRleCBjaGFuZ2VzIHdoZW4gbmV3IHZhcmlhYmxlcyBhcmUgYWRkZWQuXG4gICAgICAgIGNpcmNsZS5jYWxsKGZvcmNlLmRyYWcpO1xuICAgICAgICBpZiAoZm9yY2V0b2dnbGVbMF0gPT0gXCJ0cnVlXCIpIHtcbiAgICAgICAgICAgIGZvcmNlLmdyYXZpdHkoMC4xKTtcbiAgICAgICAgICAgIGZvcmNlLmNoYXJnZShkID0+IHNldFBlYmJsZUNoYXJnZShkKSk7XG4gICAgICAgICAgICBmb3JjZS5zdGFydCgpO1xuICAgICAgICAgICAgZm9yY2UubGlua1N0cmVuZ3RoKDEpO1xuICAgICAgICAgICAgayA9IDQ7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdHJlbmd0aCBwYXJhbWV0ZXIgZm9yIGdyb3VwIGF0dHJhY3Rpb24vcmVwdWxzaW9uXG4gICAgICAgICAgICBpZigoenBhcmFtcy56Z3JvdXAxLmxlbmd0aCA+IDApICYgKHpwYXJhbXMuemdyb3VwMi5sZW5ndGggPiAwICkpeyAgLy8gc2NhbGUgZG93biBieSBudW1iZXIgb2YgYWN0aXZlIGdyb3Vwc1xuICAgICAgICAgICAgICAgIGsgPSAyLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3JjZS5ncmF2aXR5KDApO1xuICAgICAgICAgICAgZm9yY2UuY2hhcmdlKDApO1xuICAgICAgICAgICAgZm9yY2UubGlua1N0cmVuZ3RoKDApO1xuICAgICAgICAgICAgayA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yY2UucmVzdW1lKCk7XG5cbiAgICAgICAgLy8gcGF0aCAobGluaykgZ3JvdXBcbiAgICAgICAgcGF0aCA9IHBhdGguZGF0YShsaW5rcyk7XG5cbiAgICAgICAgLy8gdXBkYXRlIGV4aXN0aW5nIGxpbmtzXG4gICAgICAgIC8vIFZKRDogZGFzaGVkIGxpbmtzIGJldHdlZW4gcGViYmxlcyBhcmUgXCJzZWxlY3RlZFwiLiB0aGlzIGlzIGRpc2FibGVkIGZvciBub3dcbiAgICAgICAgcGF0aC5jbGFzc2VkKCdzZWxlY3RlZCcsIHggPT4gbnVsbClcbiAgICAgICAgICAgIC5zdHlsZSgnbWFya2VyLXN0YXJ0JywgeCA9PiB4LmxlZnQgPyAndXJsKCNzdGFydC1hcnJvdyknIDogJycpXG4gICAgICAgICAgICAuc3R5bGUoJ21hcmtlci1lbmQnLCB4ID0+IHgucmlnaHQgPyAndXJsKCNlbmQtYXJyb3cpJyA6ICcnKTtcblxuICAgICAgICAvLyBhZGQgbmV3IGxpbmtzXG4gICAgICAgIHBhdGguZW50ZXIoKS5hcHBlbmQoJ3N2ZzpwYXRoJylcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdsaW5rJylcbiAgICAgICAgICAgIC5jbGFzc2VkKCdzZWxlY3RlZCcsIHggPT4gbnVsbClcbiAgICAgICAgICAgIC5zdHlsZSgnbWFya2VyLXN0YXJ0JywgeCA9PiB4LmxlZnQgPyAndXJsKCNzdGFydC1hcnJvdyknIDogJycpXG4gICAgICAgICAgICAuc3R5bGUoJ21hcmtlci1lbmQnLCB4ID0+IHgucmlnaHQgPyAndXJsKCNlbmQtYXJyb3cpJyA6ICcnKVxuICAgICAgICAgICAgLm9uKCdtb3VzZWRvd24nLCBmdW5jdGlvbihkKSB7IC8vIGRvIHdlIGV2ZXIgbmVlZCB0byBzZWxlY3QgYSBsaW5rPyBtYWtlIGl0IGRlbGV0ZS4uXG4gICAgICAgICAgICAgICAgdmFyIG9iaiA9IEpTT04uc3RyaW5naWZ5KGQpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGlua3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9iaiA9PT0gSlNPTi5zdHJpbmdpZnkobGlua3Nbal0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgbGlua3Muc3BsaWNlKGosIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHJlbW92ZSBvbGQgbGlua3NcbiAgICAgICAgcGF0aC5leGl0KCkucmVtb3ZlKCk7XG5cbiAgICAgICAgLy8gY2lyY2xlIChub2RlKSBncm91cFxuICAgICAgICBjaXJjbGUgPSBjaXJjbGUuZGF0YShub2RlcywgeCA9PiB4LmlkKTtcblxuICAgICAgICAvLyB1cGRhdGUgZXhpc3Rpbmcgbm9kZXMgKHJlZmxleGl2ZSAmIHNlbGVjdGVkIHZpc3VhbCBzdGF0ZXMpXG4gICAgICAgIC8vIGQzLnJnYiBpcyB0aGUgZnVuY3Rpb24gYWRqdXN0aW5nIHRoZSBjb2xvciBoZXJlXG4gICAgICAgIGNpcmNsZS5zZWxlY3RBbGwoJ2NpcmNsZScpXG4gICAgICAgICAgICAuY2xhc3NlZCgncmVmbGV4aXZlJywgeCA9PiB4LnJlZmxleGl2ZSlcbiAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIHggPT4gZDMucmdiKHgubm9kZUNvbCkpXG4gICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsIHggPT4gZDMucmdiKHguc3Ryb2tlQ29sb3IpKVxuICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLCB4ID0+IHguc3Ryb2tlV2lkdGgpO1xuXG4gICAgICAgIC8vIGFkZCBuZXcgbm9kZXNcbiAgICAgICAgbGV0IGcgPSBjaXJjbGUuZW50ZXIoKVxuICAgICAgICAgICAgLmFwcGVuZCgnc3ZnOmcnKVxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgeCA9PiB4Lm5hbWUgKyAnYmlnZ3JvdXAnKTtcblxuICAgICAgICAvLyBhZGQgcGxvdFxuICAgICAgICBnLmVhY2goZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpO1xuICAgICAgICAgICAgaWYgKGQucGxvdHR5cGUgPT0gJ2NvbnRpbnVvdXMnKSBkZW5zaXR5Tm9kZShkLCB0aGlzKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGQucGxvdHR5cGUgPT0gJ2JhcicpIGJhcnNOb2RlKGQsIHRoaXMpO1xuICAgICAgICB9KTtcblxuICAgICAgICBsZXQgYXBwZW5kID0gKHN0ciwgYXR0cikgPT4geCA9PiBzdHIgKyB4W2F0dHIgfHwgJ2lkJ107XG5cbiAgICAgICAgZy5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsIGFwcGVuZCgnZHZBcmMnKSlcbiAgICAgICAgICAgIC5hdHRyKFwiZFwiLCBhcmMzKVxuICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBkdkNvbG9yKVxuICAgICAgICAgICAgLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIGZpbGxUaGlzKHRoaXMsIC4zLCAwLCAxMDApO1xuICAgICAgICAgICAgICAgIGZpbGwoZCwgJ2R2VGV4dCcsIC45LCAwLCAxMDApO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgZmlsbFRoaXModGhpcywgMCwgMTAwLCA1MDApO1xuICAgICAgICAgICAgICAgIGZpbGwoZCwgJ2R2VGV4dCcsIDAsIDEwMCwgNTAwKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ2NsaWNrJywgZCA9PiB7XG4gICAgICAgICAgICAgICAgc2V0Q29sb3JzKGQsIGR2Q29sb3IpO1xuICAgICAgICAgICAgICAgIGxlZ2VuZChkdkNvbG9yKTtcbiAgICAgICAgICAgICAgICByZXN0YXJ0KCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgYXBwZW5kKCdkdlRleHQnKSlcbiAgICAgICAgICAgIC5hdHRyKFwieFwiLCA2KVxuICAgICAgICAgICAgLmF0dHIoXCJkeVwiLCAxMS41KVxuICAgICAgICAgICAgLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgIC5hcHBlbmQoXCJ0ZXh0UGF0aFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ4bGluazpocmVmXCIsIGFwcGVuZCgnI2R2QXJjJykpXG4gICAgICAgICAgICAudGV4dChcIkRlcCBWYXJcIik7XG5cbiAgICAgICAgZy5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsIGFwcGVuZCgnbm9tQXJjJykpXG4gICAgICAgICAgICAuYXR0cihcImRcIiwgYXJjNClcbiAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgbm9tQ29sb3IpXG4gICAgICAgICAgICAuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGQuZGVmYXVsdE51bWNoYXIgPT0gXCJjaGFyYWN0ZXJcIikgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGZpbGxUaGlzKHRoaXMsIC4zLCAwLCAxMDApO1xuICAgICAgICAgICAgICAgIGZpbGwoZCwgXCJub21UZXh0XCIsIC45LCAwLCAxMDApO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGQuZGVmYXVsdE51bWNoYXIgPT0gXCJjaGFyYWN0ZXJcIikgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGZpbGxUaGlzKHRoaXMsIDAsIDEwMCwgNTAwKTtcbiAgICAgICAgICAgICAgICBmaWxsKGQsIFwibm9tVGV4dFwiLCAwLCAxMDAsIDUwMCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdjbGljaycsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZC5kZWZhdWx0TnVtY2hhciA9PSBcImNoYXJhY3RlclwiKSByZXR1cm47XG4gICAgICAgICAgICAgICAgc2V0Q29sb3JzKGQsIG5vbUNvbG9yKTtcbiAgICAgICAgICAgICAgICBsZWdlbmQobm9tQ29sb3IpO1xuICAgICAgICAgICAgICAgIHJlc3RhcnQoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIGcuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBhcHBlbmQoXCJub21UZXh0XCIpKVxuICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIDYpXG4gICAgICAgICAgICAuYXR0cihcImR5XCIsIDExLjUpXG4gICAgICAgICAgICAuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgLmFwcGVuZChcInRleHRQYXRoXCIpXG4gICAgICAgICAgICAuYXR0cihcInhsaW5rOmhyZWZcIiwgYXBwZW5kKFwiI25vbUFyY1wiKSlcbiAgICAgICAgICAgIC50ZXh0KFwiTm9taW5hbFwiKTtcblxuICAgICAgICBnLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgYXBwZW5kKCdnckFyYycpKVxuICAgICAgICAgICAgLmF0dHIoXCJkXCIsIGFyYzEpXG4gICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsICBncjFDb2xvcilcbiAgICAgICAgICAgIC5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICBmaWxsKGQsIFwiZ3IxaW5kaWNhdG9yXCIsIC4zLCAwLCAxMDApO1xuICAgICAgICAgICAgICAgIGZpbGwoZCwgXCJncjJpbmRpY2F0b3JcIiwgLjMsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgZmlsbFRoaXModGhpcywgLjMsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgZmlsbChkLCAnZ3JUZXh0JywgLjksIDAsIDEwMCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICBmaWxsKGQsIFwiZ3IxaW5kaWNhdG9yXCIsIDAsIDEwMCwgNTAwKTtcbiAgICAgICAgICAgICAgICBmaWxsKGQsIFwiZ3IyaW5kaWNhdG9yXCIsIDAsIDEwMCwgNTAwKTtcbiAgICAgICAgICAgICAgICBmaWxsVGhpcyh0aGlzLCAwLCAxMDAsIDUwMCk7XG4gICAgICAgICAgICAgICAgZmlsbChkLCAnZ3JUZXh0JywgMCwgMTAwLCA1MDApO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignY2xpY2snLCBkID0+IHtcbiAgICAgICAgICAgICAgICAvL2QuZ3JvdXAxID0gIWQuZ3JvdXAxOyAgICAgIC8vIFRoaXMgbWlnaHQgYmUgZWFzaWVyLCBidXQgY3VycmVudGx5IHNldCBpbiBzZXRDb2xvcnMoKVxuICAgICAgICAgICAgICAgIHNldENvbG9ycyhkLCBncjFDb2xvcik7XG4gICAgICAgICAgICAgICAgbGVnZW5kKGdyMUNvbG9yKTtcbiAgICAgICAgICAgICAgICByZXN0YXJ0KCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBnLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgYXBwZW5kKCdncjFpbmRpY2F0b3InKSlcbiAgICAgICAgICAgIC5hdHRyKFwiZFwiLCBhcmNJbmQxKVxuICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBncjFDb2xvcikgIC8vIHNvbWV0aGluZyBsaWtlOiB6cGFyYW1zLnpncm91cDEuaW5kZXhPZihub2RlLm5hbWUpID4gLTEgID8gICNGRkZGRkYgOiBncjFDb2xvcilcbiAgICAgICAgICAgIC5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICBmaWxsVGhpcyh0aGlzLCAuMywgMCwgMTAwKTtcbiAgICAgICAgICAgICAgICBmaWxsKGQsIFwiZ3JBcmNcIiwgLjEsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgZmlsbChkLCAnZ3JUZXh0JywgLjksIDAsIDEwMCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICBmaWxsVGhpcyh0aGlzLCAwLCAxMDAsIDUwMCk7XG4gICAgICAgICAgICAgICAgZmlsbChkLCBcImdyQXJjXCIsIDAsIDEwMCwgNTAwKTtcbiAgICAgICAgICAgICAgICBmaWxsKGQsICdnclRleHQnLCAwLCAxMDAsIDUwMCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdjbGljaycsIGQgPT4ge1xuICAgICAgICAgICAgICAgIC8vZC5ncm91cDEgPSAhZC5ncm91cDE7ICAgICAgLy8gVGhpcyBtaWdodCBiZSBlYXNpZXIsIGJ1dCBjdXJyZW50bHkgc2V0IGluIHNldENvbG9ycygpXG4gICAgICAgICAgICAgICAgc2V0Q29sb3JzKGQsIGdyMUNvbG9yKTtcbiAgICAgICAgICAgICAgICBsZWdlbmQoZ3IxQ29sb3IpO1xuICAgICAgICAgICAgICAgIHJlc3RhcnQoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICBnLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgYXBwZW5kKCdncjJpbmRpY2F0b3InKSlcbiAgICAgICAgICAgIC5hdHRyKFwiZFwiLCBhcmNJbmQyKVxuICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBncjJDb2xvcikgIC8vIHNvbWV0aGluZyBsaWtlOiB6cGFyYW1zLnpncm91cDEuaW5kZXhPZihub2RlLm5hbWUpID4gLTEgID8gICNGRkZGRkYgOiBncjFDb2xvcilcbiAgICAgICAgICAgIC5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICBmaWxsVGhpcyh0aGlzLCAuMywgMCwgMTAwKTtcbiAgICAgICAgICAgICAgICBmaWxsKGQsIFwiZ3JBcmNcIiwgLjEsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgZmlsbChkLCAnZ3JUZXh0JywgLjksIDAsIDEwMCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICBmaWxsVGhpcyh0aGlzLCAwLCAxMDAsIDUwMCk7XG4gICAgICAgICAgICAgICAgZmlsbChkLCBcImdyQXJjXCIsIDAsIDEwMCwgNTAwKTtcbiAgICAgICAgICAgICAgICBmaWxsKGQsICdnclRleHQnLCAwLCAxMDAsIDUwMCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdjbGljaycsIGQgPT4ge1xuICAgICAgICAgICAgICAgIC8vZC5ncm91cDIgPSAhZC5ncm91cDI7ICAgICAgLy8gVGhpcyBtaWdodCBiZSBlYXNpZXIsIGJ1dCBjdXJyZW50bHkgc2V0IGluIHNldENvbG9ycygpXG4gICAgICAgICAgICAgICAgc2V0Q29sb3JzKGQsIGdyMkNvbG9yKTtcbiAgICAgICAgICAgICAgICBsZWdlbmQoZ3IyQ29sb3IpO1xuICAgICAgICAgICAgICAgIHJlc3RhcnQoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIGcuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBhcHBlbmQoJ2dyVGV4dCcpKVxuICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIDYpXG4gICAgICAgICAgICAuYXR0cihcImR5XCIsIDExLjUpXG4gICAgICAgICAgICAuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgLmFwcGVuZChcInRleHRQYXRoXCIpXG4gICAgICAgICAgICAuYXR0cihcInhsaW5rOmhyZWZcIiwgYXBwZW5kKCcjZ3JBcmMnKSlcbiAgICAgICAgICAgIC50ZXh0KFwiR3JvdXBzXCIpO1xuXG4gICAgICAgIGcuYXBwZW5kKCdzdmc6Y2lyY2xlJylcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdub2RlJylcbiAgICAgICAgICAgIC5hdHRyKCdyJywgZCA9PiBzZXRQZWJibGVSYWRpdXMoZCkpXG4gICAgICAgICAgICAuc3R5bGUoJ3BvaW50ZXItZXZlbnRzJywgJ2luaGVyaXQnKVxuICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgZCA9PiBkLm5vZGVDb2wpXG4gICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCBcIjAuNVwiKVxuICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCBkID0+IGQzLnJnYihkLnN0cm9rZUNvbG9yKS50b1N0cmluZygpKVxuICAgICAgICAgICAgLmNsYXNzZWQoJ3JlZmxleGl2ZScsIGQgPT4gZC5yZWZsZXhpdmUpXG4gICAgICAgICAgICAub24oJ2RibGNsaWNrJywgZnVuY3Rpb24oXykge1xuICAgICAgICAgICAgICAgIGQzLmV2ZW50LnN0b3BQcm9wYWdhdGlvbigpOyAvLyBzdG9wIGNsaWNrIGZyb20gYnViYmxpbmdcbiAgICAgICAgICAgICAgICBzdW1tYXJ5SG9sZCA9IHRydWU7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdjb250ZXh0bWVudScsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAvLyByaWdodCBjbGljayBvbiBub2RlXG4gICAgICAgICAgICAgICAgZDMuZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBkMy5ldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAgICAgICAgIHJpZ2h0Q2xpY2tMYXN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBtb3VzZWRvd25fbm9kZSA9IGQ7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRfbm9kZSA9IG1vdXNlZG93bl9ub2RlID09PSBzZWxlY3RlZF9ub2RlID8gbnVsbCA6IG1vdXNlZG93bl9ub2RlO1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkX2xpbmsgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgLy8gcmVwb3NpdGlvbiBkcmFnIGxpbmVcbiAgICAgICAgICAgICAgICBkcmFnX2xpbmVcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdtYXJrZXItZW5kJywgJ3VybCgjZW5kLWFycm93KScpXG4gICAgICAgICAgICAgICAgICAgIC5jbGFzc2VkKCdoaWRkZW4nLCBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCAnTScgKyBtb3VzZWRvd25fbm9kZS54ICsgJywnICsgbW91c2Vkb3duX25vZGUueSArICdMJyArIG1vdXNlZG93bl9ub2RlLnggKyAnLCcgKyBtb3VzZWRvd25fbm9kZS55KTtcblxuICAgICAgICAgICAgICAgIHN2Zy5vbignbW91c2Vtb3ZlJywgbW91c2Vtb3ZlKTtcbiAgICAgICAgICAgICAgICByZXN0YXJ0KCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdtb3VzZXVwJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIGQzLmV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJpZ2h0Q2xpY2tMYXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0Q2xpY2tMYXN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFtb3VzZWRvd25fbm9kZSkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgLy8gbmVlZGVkIGJ5IEZGXG4gICAgICAgICAgICAgICAgZHJhZ19saW5lXG4gICAgICAgICAgICAgICAgICAgIC5jbGFzc2VkKCdoaWRkZW4nLCB0cnVlKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ21hcmtlci1lbmQnLCAnJyk7XG5cbiAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgZHJhZy10by1zZWxmXG4gICAgICAgICAgICAgICAgbW91c2V1cF9ub2RlID0gZDtcbiAgICAgICAgICAgICAgICBpZiAobW91c2V1cF9ub2RlID09PSBtb3VzZWRvd25fbm9kZSkge1xuICAgICAgICAgICAgICAgICAgICByZXNldE1vdXNlVmFycygpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gdW5lbmxhcmdlIHRhcmdldCBub2RlXG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmF0dHIoJ3RyYW5zZm9ybScsICcnKTtcblxuICAgICAgICAgICAgICAgIC8vIGFkZCBsaW5rIHRvIGdyYXBoICh1cGRhdGUgaWYgZXhpc3RzKVxuICAgICAgICAgICAgICAgIC8vIE5COiBsaW5rcyBhcmUgc3RyaWN0bHkgc291cmNlIDwgdGFyZ2V0OyBhcnJvd3Mgc2VwYXJhdGVseSBzcGVjaWZpZWQgYnkgYm9vbGVhbnNcbiAgICAgICAgICAgICAgICB2YXIgc291cmNlLCB0YXJnZXQsIGRpcmVjdGlvbjtcbiAgICAgICAgICAgICAgICBpZiAobW91c2Vkb3duX25vZGUuaWQgPCBtb3VzZXVwX25vZGUuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlID0gbW91c2Vkb3duX25vZGU7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IG1vdXNldXBfbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gJ3JpZ2h0JztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2UgPSBtb3VzZXVwX25vZGU7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IG1vdXNlZG93bl9ub2RlO1xuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSAnbGVmdCc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IGxpbmsgPSBsaW5rcy5maWx0ZXIoeCA9PiB4LnNvdXJjZSA9PSBzb3VyY2UgJiYgeC50YXJnZXQgPT0gdGFyZ2V0KVswXTtcbiAgICAgICAgICAgICAgICBpZiAobGluaykge1xuICAgICAgICAgICAgICAgICAgICBsaW5rW2RpcmVjdGlvbl0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmsgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodDogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgbGlua1tkaXJlY3Rpb25dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbGlua3MucHVzaChsaW5rKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBzZWxlY3QgbmV3IGxpbmtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZF9saW5rID0gbGluaztcbiAgICAgICAgICAgICAgICBzZWxlY3RlZF9ub2RlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBzdmcub24oJ21vdXNlbW92ZScsIG51bGwpO1xuXG4gICAgICAgICAgICAgICAgcmVzZXRNb3VzZVZhcnMoKTtcbiAgICAgICAgICAgICAgICByZXN0YXJ0KCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAvLyBzaG93IG5vZGUgbmFtZXNcbiAgICAgICAgZy5hcHBlbmQoJ3N2Zzp0ZXh0JylcbiAgICAgICAgICAgIC5hdHRyKCd4JywgMClcbiAgICAgICAgICAgIC5hdHRyKCd5JywgMTUpXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnaWQnKVxuICAgICAgICAgICAgLnRleHQoZCA9PiBkLm5hbWUpO1xuXG4gICAgICAgIC8vIHNob3cgc3VtbWFyeSBzdGF0cyBvbiBtb3VzZW92ZXJcbiAgICAgICAgLy8gU1ZHIGRvZXNuJ3Qgc3VwcG9ydCB0ZXh0IHdyYXBwaW5nLCB1c2UgaHRtbCBpbnN0ZWFkXG4gICAgICAgIGcuc2VsZWN0QWxsKFwiY2lyY2xlLm5vZGVcIilcbiAgICAgICAgICAgIC5vbihcIm1vdXNlb3ZlclwiLCBkID0+IHtcbiAgICAgICAgICAgICAgICB0YWJMZWZ0KCd0YWIzJyk7XG4gICAgICAgICAgICAgICAgdmFyU3VtbWFyeShkKTtcbiAgICAgICAgICAgICAgICBkLmZvcmVmcm9udCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBieUlkKCd0cmFuc2Zvcm1hdGlvbnMnKS5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2Rpc3BsYXk6YmxvY2snKTtcbiAgICAgICAgICAgICAgICBieUlkKFwidHJhbnNTZWxcIikuc2VsZWN0ZWRJbmRleCA9IGQuaWQ7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtVmFyID0gdmFsdWVLZXlbZC5pZF07XG5cbiAgICAgICAgICAgICAgICBmaWxsKGQsIFwiZHZBcmNcIiwgLjEsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgZmlsbChkLCBcImR2VGV4dFwiLCAuNSwgMCwgMTAwKTtcbiAgICAgICAgICAgICAgICBmaWxsKGQsIFwiZ3JBcmNcIiwgLjEsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgZmlsbChkLCBcImdyVGV4dFwiLCAuNSwgMCwgMTAwKTtcbiAgICAgICAgICAgICAgICAvL2ZpbGwoZCwgXCJncjFpbmRpY2F0b3JcIiwgLjEsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgLy9maWxsKGQsIFwiZ3IxaW5kaWNhdG9yVGV4dFwiLCAuMSwgMCwgMTAwKTtcbiAgICAgICAgICAgICAgICAvL2ZpbGwoZCwgXCJncjJpbmRpY2F0b3JcIiwgLjEsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgLy9maWxsKGQsIFwiZ3IyaW5kaWNhdG9yVGV4dFwiLCAuMSwgMCwgMTAwKTtcblxuICAgICAgICAgICAgICAgIGlmIChkLmRlZmF1bHROdW1jaGFyID09IFwibnVtZXJpY1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGwoZCwgXCJub21BcmNcIiwgLjEsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgICAgIGZpbGwoZCwgXCJub21UZXh0XCIsIC41LCAwLCAxMDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaWxsKGQsIFwiY3NBcmNcIiwgLjEsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgZmlsbChkLCBcImNzVGV4dFwiLCAuNSwgMCwgMTAwKTtcbiAgICAgICAgICAgICAgICBmaWxsKGQsIFwidGltZUFyY1wiLCAuMSwgMCwgMTAwKTtcbiAgICAgICAgICAgICAgICBmaWxsKGQsIFwidGltZVRleHRcIiwgLjUsIDAsIDEwMCk7XG5cbiAgICAgICAgICAgICAgICBtLnJlZHJhdygpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBkID0+IHtcbiAgICAgICAgICAgICAgICBkLmZvcmVmcm9udCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHN1bW1hcnlIb2xkIHx8IHRhYkxlZnQoc3Vic2V0ID8gJ3RhYjInIDogJ3RhYjEnKTtcbiAgICAgICAgICAgICAgICAnY3NBcmMgY3NUZXh0IHRpbWVBcmMgdGltZVRleHQgZHZBcmMgZHZUZXh0IG5vbUFyYyBub21UZXh0IGdyQXJjIGdyVGV4dCcuc3BsaXQoJyAnKS5tYXAoeCA9PiBmaWxsKGQsIHgsIDAsIDEwMCwgNTAwKSk7XG4gICAgICAgICAgICAgICAgbS5yZWRyYXcoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHRoZSB0cmFuc2Zvcm1hdGlvbiB2YXJpYWJsZSBsaXN0IGlzIHNpbGVudGx5IHVwZGF0ZWQgYXMgcGViYmxlcyBhcmUgYWRkZWQvcmVtb3ZlZFxuICAgICAgICBkMy5zZWxlY3QoXCIjdHJhbnNTZWxcIilcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoJ2xpJylcbiAgICAgICAgICAgIC5yZW1vdmUoKTtcblxuICAgICAgICBkMy5zZWxlY3QoXCIjdHJhbnNTZWxcIilcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoJ2xpJylcbiAgICAgICAgICAgIC5kYXRhKG5vZGVzLm1hcCh4ID0+IHgubmFtZSkpIC8vIHNldCB0byB2YXJpYWJsZXMgaW4gbW9kZWwgc3BhY2UgYXMgdGhleSdyZSBhZGRlZFxuICAgICAgICAgICAgLmVudGVyKClcbiAgICAgICAgICAgIC5hcHBlbmQoXCJsaVwiKVxuICAgICAgICAgICAgLnRleHQoZCA9PiBkKTtcblxuICAgICAgICBpZighZDNtX21vZGUpe1xuICAgICAgICAgICAgJCgnI3RyYW5zU2VsIGxpJykuY2xpY2soZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgJ2ludGVyYWN0aW9uJyBpcyB0aGUgc2VsZWN0ZWQgZnVuY3Rpb24sIGRvbid0IHNob3cgdGhlIGZ1bmN0aW9uIGxpc3QgYWdhaW5cbiAgICAgICAgICAgICAgICBpZiAoc2VsSW50ZXJhY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSAkKCcjdElucHV0JykudmFsKCkuY29uY2F0KCQodGhpcykudGV4dCgpKTtcbiAgICAgICAgICAgICAgICAgICAgJCgnI3RJbnB1dCcpLnZhbChuKTtcbiAgICAgICAgICAgICAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IHRyYW5zUGFyc2UobiA9IG4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXQpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5wYXJlbnQoKS5mYWRlT3V0KDEwMCk7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybShuID0gdC5zbGljZSgwLCB0Lmxlbmd0aCAtIDEpLCB0ID0gdFt0Lmxlbmd0aCAtIDFdLCB0eXBlVHJhbnNmb3JtID0gZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgJCgnI3RJbnB1dCcpLnZhbCgkKHRoaXMpLnRleHQoKSk7XG4gICAgICAgICAgICAgICAgJCh0aGlzKS5wYXJlbnQoKS5mYWRlT3V0KDEwMCk7XG4gICAgICAgICAgICAgICAgJCgnI3RyYW5zTGlzdCcpLmZhZGVJbigxMDApO1xuICAgICAgICAgICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHJlbW92ZSBvbGQgbm9kZXNcbiAgICAgICAgY2lyY2xlLmV4aXQoKS5yZW1vdmUoKTtcbiAgICAgICAgZm9yY2Uuc3RhcnQoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb3VzZWRvd24oZCkge1xuICAgICAgICAvLyBwcmV2ZW50IEktYmFyIG9uIGRyYWdcbiAgICAgICAgZDMuZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgLy8gYmVjYXVzZSA6YWN0aXZlIG9ubHkgd29ya3MgaW4gV2ViS2l0P1xuICAgICAgICBzdmcuY2xhc3NlZCgnYWN0aXZlJywgdHJ1ZSk7XG4gICAgICAgIGlmIChkMy5ldmVudC5jdHJsS2V5IHx8IG1vdXNlZG93bl9ub2RlIHx8IG1vdXNlZG93bl9saW5rKSByZXR1cm47XG4gICAgICAgIHJlc3RhcnQoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb3VzZW1vdmUoZCkge1xuICAgICAgICBpZiAoIW1vdXNlZG93bl9ub2RlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyB1cGRhdGUgZHJhZyBsaW5lXG4gICAgICAgIGRyYWdfbGluZS5hdHRyKCdkJywgJ00nICsgbW91c2Vkb3duX25vZGUueCArICcsJyArIG1vdXNlZG93bl9ub2RlLnkgKyAnTCcgKyBkMy5tb3VzZSh0aGlzKVswXSArICcsJyArIGQzLm1vdXNlKHRoaXMpWzFdKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb3VzZXVwKGQpIHtcbiAgICAgICAgaWYgKG1vdXNlZG93bl9ub2RlKSB7XG4gICAgICAgICAgICBkcmFnX2xpbmVcbiAgICAgICAgICAgICAgICAuY2xhc3NlZCgnaGlkZGVuJywgdHJ1ZSlcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ21hcmtlci1lbmQnLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYmVjYXVzZSA6YWN0aXZlIG9ubHkgd29ya3MgaW4gV2ViS2l0P1xuICAgICAgICBzdmcuY2xhc3NlZCgnYWN0aXZlJywgZmFsc2UpO1xuICAgICAgICAvLyBjbGVhciBtb3VzZSBldmVudCB2YXJzXG4gICAgICAgIHJlc2V0TW91c2VWYXJzKCk7XG4gICAgfVxuXG4gICAgLy8gYXBwIHN0YXJ0cyBoZXJlXG4gICAgc3ZnLmF0dHIoJ2lkJywgKCkgPT4gXCJ3aGl0ZXNwYWNlXCIuY29uY2F0KG15c3BhY2UpKVxuICAgICAgICAuYXR0cignaGVpZ2h0JywgaGVpZ2h0KVxuICAgICAgICAub24oJ21vdXNlZG93bicsIGZ1bmN0aW9uKCkge21vdXNlZG93bih0aGlzKTt9KVxuICAgICAgICAub24oJ21vdXNldXAnLCBmdW5jdGlvbigpIHttb3VzZXVwKHRoaXMpO30pO1xuXG4gICAgZDMuc2VsZWN0KHdpbmRvdylcbiAgICAgICAgLm9uKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICAgIC8vIGFsbCBjbGlja3Mgd2lsbCBidWJibGUgaGVyZSB1bmxlc3MgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgICAgICAgICQoJyN0cmFuc0xpc3QnKS5mYWRlT3V0KDEwMCk7XG4gICAgICAgICAgICAkKCcjdHJhbnNTZWwnKS5mYWRlT3V0KDEwMCk7XG4gICAgICAgIH0pO1xuXG4gICAgcmVzdGFydCgpOyAvLyBpbml0aWFsaXplcyBmb3JjZS5sYXlvdXQoKVxuICAgIGZha2VDbGljaygpO1xuXG4gICAgaWYodjIgJiBkM21fbW9kZSkge1xuICAgICAgICB2YXIgY2xpY2tfZXYgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIk1vdXNlRXZlbnRzXCIpO1xuICAgICAgICAvLyBpbml0aWFsaXplIHRoZSBldmVudFxuICAgICAgICBjbGlja19ldi5pbml0RXZlbnQoXCJjbGlja1wiLCB0cnVlIC8qIGJ1YmJsZSAqLywgdHJ1ZSAvKiBjYW5jZWxhYmxlICovKTtcbiAgICAgICAgLy8gdHJpZ2dlciB0aGUgZXZlbnRcbiAgICAgICAgbGV0IGNsaWNrSUQgPSBcImR2QXJjXCIrZmluZE5vZGVJbmRleChteXRhcmdldCk7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNsaWNrSUQpLmRpc3BhdGNoRXZlbnQoY2xpY2tfZXYpO1xuICAgIH1cbn1cblxuXG5sZXQgZmluZCA9ICgkbm9kZXMsIG5hbWUpID0+IHtcbiAgICBmb3IgKGxldCBpIGluICRub2RlcylcbiAgICAgICAgaWYgKCRub2Rlc1tpXS5uYW1lID09IG5hbWUpIHJldHVybiAkbm9kZXNbaV0uaWQ7XG59O1xuXG4vLyByZXR1cm5zIGlkXG5leHBvcnQgbGV0IGZpbmROb2RlSW5kZXggPSAobmFtZSwgYWxsKSA9PiB7XG4gICAgZm9yIChsZXQgbm9kZSBvZiBhbGxOb2Rlcykge1xuICAgICAgICBpZiAobm9kZS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgICAvL2NkYignWWVzIScgKyBhbGxOb2Rlc1tpXS5pZCk7XG4gICAgICAgICAgICByZXR1cm4gYWxsPyBub2RlIDogbm9kZS5pZDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmxldCBub2RlSW5kZXggPSBub2RlTmFtZSA9PiB7XG4gICAgZm9yIChsZXQgaSBpbiBub2RlcylcbiAgICAgICAgaWYgKG5vZGVzW2ldLm5hbWUgPT0gbm9kZU5hbWUpIHJldHVybiBpO1xufTtcblxuZXhwb3J0IGxldCBmaW5kTm9kZSA9IG5vZGVOYW1lID0+IHtcbiAgICBmb3IgKGxldCBpIGluIGFsbE5vZGVzKVxuICAgICAgICBpZiAoYWxsTm9kZXNbaV0ubmFtZSA9PSBub2RlTmFtZSkgcmV0dXJuIGFsbE5vZGVzW2ldO1xufTtcblxuLypcbiAgICBSZXRyaWV2ZSB0aGUgdmFyaWFibGUgbGlzdCBmcm9tIHRoZSBwcmVwcm9jZXNzIGRhdGEuXG4gICAgVGhpcyBoZWxwcyBoYW5kbGUgdGhlIG5ldyBmb3JtYXQgYW5kICh0ZW1wb3JhcmlseSlcbiAgICB0aGUgb2xkZXIgZm9ybWF0IGluIHByb2R1Y3Rpb24gKHJwIDguMTQuMjAxNylcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFZhcmlhYmxlRGF0YShqc29uRGF0YSkge1xuICAgIC8qIFwibmV3XCIgcmVzcG9uc2U6XG4gICAge1xuICAgICAgICBcImRhdGFzZXRcIiA6IHsuLi59XG4gICAgICAgIFwidmFyaWFibGVzXCIgOiB7XG4gICAgICAgICAgICBcInZhcjFcIiA6IHsuLi59LCAoZXRjKVxuICAgICAgICB9XG4gICAgfVxuICAgIFwib2xkXCIgcmVzcG9uc2VcbiAgICB7XG4gICAgICAgICBcInZhcjFcIiA6IHsuLi59LFxuICAgICAgICAgKGV0YylcbiAgICB9Ki9cbiAgICByZXR1cm4ganNvbkRhdGEuaGFzT3duUHJvcGVydHkoJ3ZhcmlhYmxlcycpID8ganNvbkRhdGEudmFyaWFibGVzIDoganNvbkRhdGE7XG59XG5cbi8vIGZ1bmN0aW9uIGNhbGxlZCBieSBmb3JjZSBidXR0b25cbmV4cG9ydCBmdW5jdGlvbiBmb3JjZVN3aXRjaCgpIHtcbiAgICBmb3JjZXRvZ2dsZSA9IFtmb3JjZXRvZ2dsZVswXSA9PSAndHJ1ZScgPyAnZmFsc2UnIDogJ3RydWUnXTtcbiAgICBpZiAoZm9yY2V0b2dnbGVbMF0gPT09IFwiZmFsc2VcIikge1xuICAgICAgICBieUlkKCdidG5Gb3JjZScpLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiYnRuIGFjdGl2ZVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBieUlkKCdidG5Gb3JjZScpLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiYnRuIGJ0bi1kZWZhdWx0XCIpO1xuICAgICAgICBmYWtlQ2xpY2soKTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoZWxwbWF0ZXJpYWxzKHR5cGUpIHtcbiAgICBpZih0eXBlPT1cInZpZGVvXCIpe1xuICAgICAgICB2YXIgd2luID0gd2luZG93Lm9wZW4oXCJodHRwOi8vMnJhLnZuL2RlbW9zL2QzbWludGVncmF0aW9uZGVtby5tcDRcIiwgJ19ibGFuaycpO1xuICAgICAgICB3aW4uZm9jdXMoKTtcbiAgICB9ZWxzZXtcbiAgICAgICAgdmFyIHdpbiA9IHdpbmRvdy5vcGVuKFwiaHR0cDovLzJyYS52bi9wYXBlcnMvdHdvcmF2ZW5zLWQzbWd1aWRlLnBkZlwiLCAnX2JsYW5rJyk7XG4gICAgICAgIHdpbi5mb2N1cygpO1xuICAgIH1cbiAgICBjb25zb2xlLmxvZyh0eXBlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvY2tEZXNjcmlwdGlvbigpIHtcbiAgICBsb2NrdG9nZ2xlID0gbG9ja3RvZ2dsZSA/IGZhbHNlIDogdHJ1ZTtcbiAgICBsZXQgdGVtcDtcbiAgICBsZXQgaTtcbiAgICBpZiAoIWxvY2t0b2dnbGUpIHtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2J0bkxvY2snKS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImJ0biBidG4tZGVmYXVsdFwiKTtcbiAgICAgICAgdGVtcCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyaWdodENvbnRlbnRBcmVhJykucXVlcnlTZWxlY3RvckFsbChcInAuaXRlbS1saW5lb3V0XCIpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGVtcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGVtcFtpXS5jbGFzc0xpc3QucmVtb3ZlKFwiaXRlbS1saW5lb3V0XCIpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2J0bkxvY2snKS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImJ0biBhY3RpdmVcIik7XG4gICAgICAgIHRlbXAgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWV0cmljcycpLnF1ZXJ5U2VsZWN0b3JBbGwoXCJwLml0ZW0tZGVmYXVsdFwiKTtcbiAgICAgICAgY29uc29sZS5sb2codGVtcCk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0ZW1wLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0ZW1wW2ldLmNsYXNzTGlzdC5hZGQoXCJpdGVtLWxpbmVvdXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGVtcCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0eXBlcycpLnF1ZXJ5U2VsZWN0b3JBbGwoXCJwLml0ZW0tZGVmYXVsdFwiKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRlbXAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRlbXBbaV0uY2xhc3NMaXN0LmFkZChcIml0ZW0tbGluZW91dFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0ZW1wID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N1YnR5cGVzJykucXVlcnlTZWxlY3RvckFsbChcInAuaXRlbS1kZWZhdWx0XCIpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGVtcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGVtcFtpXS5jbGFzc0xpc3QuYWRkKFwiaXRlbS1saW5lb3V0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHRlbXAgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnb3V0cHV0cycpLnF1ZXJ5U2VsZWN0b3JBbGwoXCJwLml0ZW0tZGVmYXVsdFwiKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRlbXAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRlbXBbaV0uY2xhc3NMaXN0LmFkZChcIml0ZW0tbGluZW91dFwiKTtcbiAgICAgICAgfVxuICAgICAgICBmYWtlQ2xpY2soKTtcbiAgICB9XG59XG5cbmV4cG9ydCBsZXQgc3BsaWNlTGlua3NGb3JOb2RlID0gbm9kZSA9PiBsaW5rc1xuICAgIC5maWx0ZXIobCA9PiBsLnNvdXJjZSA9PT0gbm9kZSB8fCBsLnRhcmdldCA9PT0gbm9kZSlcbiAgICAubWFwKHggPT4gbGlua3Muc3BsaWNlKGxpbmtzLmluZGV4T2YoeCksIDEpKTtcblxuZnVuY3Rpb24gelBvcCgpIHtcbiAgICBpZiAoZGF0YXVybCkgenBhcmFtcy56ZGF0YXVybCA9IGRhdGF1cmw7XG4gICAgenBhcmFtcy56bW9kZWxjb3VudCA9IG1vZGVsQ291bnQ7XG4gICAgenBhcmFtcy56ZWRnZXMgPSBbXTtcbiAgICB6cGFyYW1zLnp2YXJzID0gW107XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBub2Rlcy5sZW5ndGg7IGorKykgeyAvL3BvcHVsYXRlIHp2YXJzIGFycmF5XG4gICAgICAgIHpwYXJhbXMuenZhcnMucHVzaChub2Rlc1tqXS5uYW1lKTtcbiAgICAgICAgbGV0IHRlbXAgPSBub2Rlc1tqXS5pZDtcbiAgICAgICAgenBhcmFtcy56c2V0eFtqXSA9IGFsbE5vZGVzW3RlbXBdLnNldHh2YWxzO1xuICAgICAgICB6cGFyYW1zLnpzdWJzZXRbal0gPSBhbGxOb2Rlc1t0ZW1wXS5zdWJzZXRyYW5nZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBsaW5rcy5sZW5ndGg7IGorKykgeyAvL3BvcHVsYXRlIHplZGdlcyBhcnJheVxuICAgICAgICAvL2NvcnJlY3QgdGhlIHNvdXJjZSB0YXJnZXQgb3JkZXJpbmcgZm9yIFplbGlnXG4gICAgICAgIGxldCBzcmN0Z3QgPSBsaW5rc1tqXS5sZWZ0ID09IGZhbHNlID9cbiAgICAgICAgICAgIFtsaW5rc1tqXS5zb3VyY2UubmFtZSwgbGlua3Nbal0udGFyZ2V0Lm5hbWVdIDpcbiAgICAgICAgICAgIFtsaW5rc1tqXS50YXJnZXQubmFtZSwgbGlua3Nbal0uc291cmNlLm5hbWVdO1xuICAgICAgICB6cGFyYW1zLnplZGdlcy5wdXNoKHNyY3RndCk7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZXN0aW1hdGUoYnRuKSB7XG4gICAgaWYoIWQzbV9tb2RlKXtcbiAgICBpZiAocHJvZHVjdGlvbiAmJiB6cGFyYW1zLnpzZXNzaW9uaWQgPT0gJycpIHtcbiAgICAgICAgYWxlcnQoXCJXYXJuaW5nOiBEYXRhIGRvd25sb2FkIGlzIG5vdCBjb21wbGV0ZS4gVHJ5IGFnYWluIHNvb24uXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgelBvcCgpO1xuICAgIC8vIHdyaXRlIGxpbmtzIHRvIGZpbGUgJiBydW4gUiBDTURcbiAgICAvLyBwYWNrYWdlIHRoZSBvdXRwdXQgYXMgSlNPTlxuICAgIC8vIGFkZCBjYWxsIGhpc3RvcnkgYW5kIHBhY2thZ2UgdGhlIHpwYXJhbXMgb2JqZWN0IGFzIEpTT05cbiAgICB6cGFyYW1zLmNhbGxIaXN0b3J5ID0gY2FsbEhpc3Rvcnk7XG4gICAgdmFyIGpzb25vdXQgPSBKU09OLnN0cmluZ2lmeSh6cGFyYW1zKTtcblxuICAgIHZhciB1cmxjYWxsID0gcmFwcFVSTCArIFwiemVsaWdhcHBcIjsgLy9iYXNlLmNvbmNhdChqc29ub3V0KTtcbiAgICB2YXIgc29sYWpzb25vdXQgPSBcInNvbGFKU09OPVwiICsganNvbm91dDtcbiAgICBjZGIoXCJ1cmxjYWxsIG91dDogXCIsIHVybGNhbGwpO1xuICAgIGNkYihcIlBPU1Qgb3V0OiBcIiwgc29sYWpzb25vdXQpO1xuICAgIGNvbnNvbGUubG9nKFwiZXN0aW1hdGU6IFwiLCBzb2xhanNvbm91dCk7XG5cbiAgICB6cGFyYW1zLmFsbFZhcnMgPSB2YWx1ZUtleS5zbGljZSgxMCwgMjUpOyAvLyBiZWNhdXNlIHRoZSBVUkwgaXMgdG9vIGxvbmcuLi5cbiAgICBqc29ub3V0ID0gSlNPTi5zdHJpbmdpZnkoenBhcmFtcyk7XG4gICAgdmFyIHNlbGVjdG9ydXJsY2FsbCA9IHJhcHBVUkwgKyBcInNlbGVjdG9yYXBwXCI7XG5cbiAgICBmdW5jdGlvbiBlc3RpbWF0ZVN1Y2Nlc3MoYnRuLCBqc29uKSB7XG4gICAgICAvLyAgdG9nZ2xlUmlnaHRCdXR0b25zKFwiYWxsXCIpO1xuICAgICAgICBlc3RpbWF0ZUxhZGRhLnN0b3AoKTsgLy8gc3RvcCBzcGlubmVyXG4gICAgICAgIGFsbFJlc3VsdHMucHVzaChqc29uKTtcbiAgICAgICAgY2RiKFwianNvbiBpbjogXCIsIGpzb24pO1xuXG4gICAgICAgIGlmICghZXN0aW1hdGVkKSBieUlkKFwicmVzdWx0c1wiKS5yZW1vdmVDaGlsZChieUlkKFwicmVzdWx0c0hvbGRlclwiKSk7XG5cbiAgICAgICAgZXN0aW1hdGVkID0gdHJ1ZTtcbiAgICAgICAgZDMuc2VsZWN0KFwiI3Jlc3VsdHNcIilcbiAgICAgICAgICAgIC5zdHlsZShcImRpc3BsYXlcIiwgXCJibG9ja1wiKTtcblxuICAgICAgICBkMy5zZWxlY3QoXCIjcmVzdWx0c1ZpZXdcIilcbiAgICAgICAgICAgIC5zdHlsZShcImRpc3BsYXlcIiwgXCJibG9ja1wiKTtcblxuICAgICAgICBkMy5zZWxlY3QoXCIjbW9kZWxWaWV3XCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJkaXNwbGF5XCIsIFwiYmxvY2tcIik7XG5cblxuICAgICAgICAvLyBwcm9ncmFtbWF0aWMgY2xpY2sgb24gUmVzdWx0cyBidXR0b25cbiAgICAgICAgJChcIiNidG5SZXN1bHRzXCIpLnRyaWdnZXIoXCJjbGlja1wiKTtcblxuICAgICAgICBsZXQgbW9kZWwgPSBcIk1vZGVsXCIuY29uY2F0KG1vZGVsQ291bnQgPSBtb2RlbENvdW50ICsgMSk7XG5cbiAgICAgICAgZnVuY3Rpb24gbW9kQ29sKCkge1xuICAgICAgICAgICAgZDMuc2VsZWN0KFwiI21vZGVsVmlld1wiKVxuICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoXCJwXCIpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJywgaGV4VG9SZ2JhKHZhckNvbG9yKSk7XG4gICAgICAgIH1cbiAgICAgICAgbW9kQ29sKCk7XG5cbiAgICAgICAgZDMuc2VsZWN0KFwiI21vZGVsVmlld1wiKVxuICAgICAgICAgICAgLmluc2VydChcInBcIiwgXCI6Zmlyc3QtY2hpbGRcIikgLy8gdG9wIHN0YWNrIGZvciByZXN1bHRzXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsIG1vZGVsKVxuICAgICAgICAgICAgLnRleHQobW9kZWwpXG4gICAgICAgICAgICAuc3R5bGUoJ2JhY2tncm91bmQtY29sb3InLCBoZXhUb1JnYmEoc2VsVmFyQ29sb3IpKVxuICAgICAgICAgICAgLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGEgPSB0aGlzLnN0eWxlLmJhY2tncm91bmRDb2xvci5yZXBsYWNlKC9cXHMqL2csIFwiXCIpO1xuICAgICAgICAgICAgICAgIHZhciBiID0gaGV4VG9SZ2JhKHNlbFZhckNvbG9yKS5yZXBsYWNlKC9cXHMqL2csIFwiXCIpO1xuICAgICAgICAgICAgICAgIGlmIChhLnN1YnN0cigwLCAxNykgPT0gYi5zdWJzdHIoMCwgMTcpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIGVzY2FwZSBmdW5jdGlvbiBpZiBkaXNwbGF5ZWQgbW9kZWwgaXMgY2xpY2tlZFxuICAgICAgICAgICAgICAgIG1vZENvbCgpO1xuICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ2JhY2tncm91bmQtY29sb3InLCBoZXhUb1JnYmEoc2VsVmFyQ29sb3IpKTtcbiAgICAgICAgICAgICAgICB2aXoodGhpcy5pZCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBsZXQgckNhbGwgPSBbXTtcbiAgICAgICAgckNhbGxbMF0gPSBqc29uLmNhbGw7XG4gICAgICAgIHNob3dMb2coXCJlc3RpbWF0ZVwiLCByQ2FsbCk7XG5cbiAgICAgICAgdml6KG1vZGVsKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlc3RpbWF0ZUZhaWwoYnRuKSB7XG4gICAgICAgIGVzdGltYXRlTGFkZGEuc3RvcCgpOyAvLyBzdG9wIHNwaW5uZXJcbiAgICAgICAgZXN0aW1hdGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZWxlY3RvclN1Y2Nlc3MoYnRuLCBqc29uKSB7XG4gICAgICAgIGQzLnNlbGVjdChcIiN0aWNrZXJcIilcbiAgICAgICAgICAgIC50ZXh0KFwiU3VnZ2VzdGVkIHZhcmlhYmxlcyBhbmQgcGVyY2VudCBpbXByb3ZlbWVudCBvbiBSTVNFOiBcIiArIGpzb24udmFycyk7XG4gICAgICAgIGNkYihcInNlbGVjdG9yU3VjY2VzczogXCIsIGpzb24pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNlbGVjdG9yRmFpbChidG4pIHtcbiAgICAgICAgYWxlcnQoXCJTZWxlY3RvciBGYWlsXCIpO1xuICAgIH1cblxuICAgIGVzdGltYXRlTGFkZGEuc3RhcnQoKTsgLy8gc3RhcnQgc3Bpbm5lclxuICAgIG1ha2VDb3JzUmVxdWVzdCh1cmxjYWxsLCBidG4sIGVzdGltYXRlU3VjY2VzcywgZXN0aW1hdGVGYWlsLCBzb2xhanNvbm91dCk7XG4gICAgfSBlbHNlIGlmIChzd2FuZGl2ZSkgeyAvLyBkM21fbW9kZSBhbmQgc3dhbmRpdmUgaXMgdHJ1ZVxuICAgICAgICAgICAgelBvcCgpO1xuICAgICAgICAgICAgenBhcmFtcy5jYWxsSGlzdG9yeSA9IGNhbGxIaXN0b3J5O1xuICAgICAgICAgICAgdmFyIGpzb25vdXQgPSBKU09OLnN0cmluZ2lmeSh6cGFyYW1zKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGpzb25vdXQpO1xuXG4gICAgICAgICAgICBsZXQgbXl2a2kgPSB2YWx1ZUtleS5pbmRleE9mKG15dGFyZ2V0KTtcbiAgICAgICAgICAgIGlmKG15dmtpICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVLZXkuc3BsaWNlKG15dmtpLCAxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGNvbnRleHQgPSBhcGlTZXNzaW9uKHpwYXJhbXMuenNlc3Npb25pZCk7XG4gICAgICAgICAgICBsZXQgdXJpID0ge2ZlYXR1cmVzOiB6cGFyYW1zLnpkM21kYXRhLCB0YXJnZXQ6enBhcmFtcy56ZDNtdGFyZ2V0fTtcblxuICAgICAgICAgICAgbGV0IHRyYWluRmVhdHVyZXM9YXBpRmVhdHVyZVNob3J0UGF0aCh2YWx1ZUtleSx1cmkuZmVhdHVyZXMpOyAgICAgICAvLyBwdXR0aW5nIGluIHNob3J0IHBhdGhzIChubyBmaWxlbmFtZSkgZm9yIGN1cnJlbnQgQVBJIHVzYWdlXG4gICAgICAgICAgICBsZXQgdGFyZ2V0RmVhdHVyZXM9YXBpRmVhdHVyZVNob3J0UGF0aChteXRhcmdldCx1cmkudGFyZ2V0KTsgICAgICAgIC8vIHB1dHRpbmcgaW4gc2hvcnQgcGF0aHMgKG5vIGZpbGVuYW1lKSBmb3IgY3VycmVudCBBUEkgdXNhZ2VcblxuICAgICAgICAgICAgbGV0IHRhc2sgPSBkM21UYXNrVHlwZVtkM21Qcm9ibGVtRGVzY3JpcHRpb24udGFza1R5cGVdWzFdO1xuICAgICAgICAgICAgbGV0IHRhc2tTdWJ0eXBlID0gZDNtVGFza1N1YnR5cGVbZDNtUHJvYmxlbURlc2NyaXB0aW9uLnRhc2tTdWJ0eXBlXVsxXTtcbiAgICAgICAgICAgIGxldCBvdXRwdXQgPSBkM21PdXRwdXRUeXBlW2QzbVByb2JsZW1EZXNjcmlwdGlvbi5vdXRwdXRUeXBlXVsxXTtcbiAgICAgICAgICAgIGxldCBtZXRyaWNzID0gW2QzbU1ldHJpY3NbZDNtUHJvYmxlbURlc2NyaXB0aW9uLm1ldHJpY11bMV1dO1xuICAgICAgICAgICAgbGV0IHRhc2tEZXNjcmlwdGlvbiA9IGQzbVByb2JsZW1EZXNjcmlwdGlvbi50YXNrRGVzY3JpcHRpb25yaXB0aW9uO1xuICAgICAgICAgICAgbGV0IG1heFBpcGVsaW5lcyA9IDU7IC8vdXNlciB0byBzcGVjaWZ5IHRoaXMgZXZlbnR1YWxseT9cblxuICAgICAgICAgICAgbGV0IFBpcGVsaW5lQ3JlYXRlUmVxdWVzdD17Y29udGV4dCwgdHJhaW5GZWF0dXJlcywgdGFzaywgdGFza1N1YnR5cGUsIHRhc2tEZXNjcmlwdGlvbiwgb3V0cHV0LCBtZXRyaWNzLCB0YXJnZXRGZWF0dXJlcywgbWF4UGlwZWxpbmVzfTtcblxuICAgICAgICAgICAgbGV0IGpzb25vdXQgPSBKU09OLnN0cmluZ2lmeShQaXBlbGluZUNyZWF0ZVJlcXVlc3QpO1xuXG4gICAgICAgICAgICBsZXQgdXJsY2FsbCA9IGQzbVVSTCArIFwiL2NyZWF0ZXBpcGVsaW5lXCI7XG4gICAgICAgICAgICB2YXIgc29sYWpzb25vdXQgPSBcImdycGNyZXF1ZXN0PVwiICsganNvbm91dDtcblxuICAgICAgICAgICAgY29uc29sZS5sb2codXJsY2FsbCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhzb2xhanNvbm91dCk7XG4gICAgICAgICAgICBmdW5jdGlvbiBzZW5kUGlwZWxpbmVTdWNjZXNzKGJ0biwgUGlwZWxpbmVDcmVhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9ycGMgR2V0RXhlY3V0ZVBpcGVsaW5lUmVzdWx0cyhQaXBlbGluZUV4ZWN1dGVSZXN1bHRzUmVxdWVzdCkgcmV0dXJucyAoc3RyZWFtIFBpcGVsaW5lRXhlY3V0ZVJlc3VsdCkge31cbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhQaXBlbGluZUNyZWF0ZVJlc3VsdCk7XG4gICAgICAgICAgICAgICAgZXN0aW1hdGVMYWRkYS5zdG9wKCk7IC8vIHN0b3Agc3Bpbm5lclxuXG5cbiAgICAgICAgICAgICAgICAkKFwiI2J0bkVzdGltYXRlXCIpLnJlbW92ZUNsYXNzKFwiYnRuLXN1Y2Nlc3NcIik7XG4gICAgICAgICAgICAgICAgJChcIiNidG5Fc3RpbWF0ZVwiKS5hZGRDbGFzcyhcImJ0bi1kZWZhdWx0XCIpO1xuICAgICAgICAgICAgICAgICQoXCIjYnRuRW5kU2Vzc2lvblwiKS5yZW1vdmVDbGFzcyhcImJ0bi1kZWZhdWx0XCIpO1xuICAgICAgICAgICAgICAgICQoXCIjYnRuRW5kU2Vzc2lvblwiKS5hZGRDbGFzcyhcImJ0bi1zdWNjZXNzXCIpO1xuXG5cblxuXG4gICAgICAgICAgICAgICAgbGV0IGFsbFBpcGVsaW5lSW5mbyA9IHt9O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpPFBpcGVsaW5lQ3JlYXRlUmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKFBpcGVsaW5lQ3JlYXRlUmVzdWx0W2ldLnBpcGVsaW5lSWQgaW4gYWxsUGlwZWxpbmVJbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxQaXBlbGluZUluZm9bUGlwZWxpbmVDcmVhdGVSZXN1bHRbaV0ucGlwZWxpbmVJZF09T2JqZWN0LmFzc2lnbihhbGxQaXBlbGluZUluZm9bUGlwZWxpbmVDcmVhdGVSZXN1bHRbaV0ucGlwZWxpbmVJZF0sUGlwZWxpbmVDcmVhdGVSZXN1bHRbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxsUGlwZWxpbmVJbmZvW1BpcGVsaW5lQ3JlYXRlUmVzdWx0W2ldLnBpcGVsaW5lSWRdPVBpcGVsaW5lQ3JlYXRlUmVzdWx0W2ldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGFsbFBpcGVsaW5lSW5mbyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIGdldCBhbGwgcGlwZWxpbmUgaWRzOiBPYmplY3Qua2V5cyhhbGxQaXBlbGluZUluZm8pXG5cbiAgICAgICAgICAgICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiB0YWJ1bGF0ZShkYXRhLCBjb2x1bW5zLCBkaXZpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhYmxlID0gZDMuc2VsZWN0KGRpdmlkKS5hcHBlbmQoJ3RhYmxlJylcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aGVhZCA9IHRhYmxlLmFwcGVuZCgndGhlYWQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyXHR0Ym9keSA9IHRhYmxlLmFwcGVuZCgndGJvZHknKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXBwZW5kIHRoZSBoZWFkZXIgcm93XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGVhZC5hcHBlbmQoJ3RyJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoJ3RoJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5kYXRhKGNvbHVtbnMpLmVudGVyKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RoJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uIChjb2x1bW4pIHsgcmV0dXJuIGNvbHVtbjsgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBhIHJvdyBmb3IgZWFjaCBvYmplY3QgaW4gdGhlIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByb3dzID0gdGJvZHkuc2VsZWN0QWxsKCd0cicpXG4gICAgICAgICAgICAgICAgICAgICAgICAuZGF0YShkYXRhKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmVudGVyKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RyJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihpPT0wKSByZXR1cm4gJ2l0ZW0tc2VsZWN0JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgcmV0dXJuICdpdGVtLWRlZmF1bHQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY3JlYXRlIGEgY2VsbCBpbiBlYWNoIHJvdyBmb3IgZWFjaCBjb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjZWxscyA9IHJvd3Muc2VsZWN0QWxsKCd0ZCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAuZGF0YShmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29sdW1ucy5tYXAoZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7Y29sdW1uOiBjb2x1bW4sIHZhbHVlOiByb3dbY29sdW1uXX07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmVudGVyKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3RkJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBteXJvdyA9IHRoaXMucGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihteXJvdy5jbGFzc05hbWU9PVwiaXRlbS1zZWxlY3RcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KGRpdmlkKS5zZWxlY3QoXCJ0ci5pdGVtLXNlbGVjdFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnaXRlbS1kZWZhdWx0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdChteXJvdykuYXR0cignY2xhc3MnLFwiaXRlbS1zZWxlY3RcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGRpdmlkPT0nI3NldHhSaWdodCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHNwbG90aW5pdChhbGxQaXBlbGluZUluZm9bbXlyb3cuZmlyc3RDaGlsZC5pbm5lclRleHRdLCBkdnZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9fSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgY29kZSB0byBhZGQgYSBjaGVja2JveCB0byBlYWNoIHJvdyBvZiBwaXBlbGluZSByZXN1bHRzIHRhYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KGRpdmlkKS5zZWxlY3RBbGwoXCJ0clwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChcImlucHV0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInR5cGVcIiwgXCJjaGVja2JveFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwiZmxvYXRcIixcInJpZ2h0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YWJsZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHRzdGFibGUgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBrZXkgaW4gYWxsUGlwZWxpbmVJbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbXlpZCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbXltZXRyaWMgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG15dmFsID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBteXNjb3JlcyA9IGFsbFBpcGVsaW5lSW5mb1trZXldLnBpcGVsaW5lSW5mby5zY29yZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbXlzY29yZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2lmKGk9PTApIHtteWlkPWtleTt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgZWxzZSBteWlkPVwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXlpZD1rZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXltZXRyaWM9bXlzY29yZXNbaV0ubWV0cmljO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG15dmFsPStteXNjb3Jlc1tpXS52YWx1ZS50b0ZpeGVkKDMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHN0YWJsZS5wdXNoKHtcIlBpcGVsaW5lSURcIjpteWlkLFwiTWV0cmljXCI6bXltZXRyaWMsIFwiU2NvcmVcIjpteXZhbH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gcmVuZGVyIHRoZSB0YWJsZVxuICAgICAgICAgICAgICAgICAgICB0YWJ1bGF0ZShyZXN1bHRzdGFibGUsIFsnUGlwZWxpbmVJRCcsICdNZXRyaWMnLCAnU2NvcmUnXSwgJyNyZXN1bHRzJyk7XG4gICAgICAgICAgICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgICAgICAgICAgICAgICAgICB0b2dnbGVSaWdodEJ1dHRvbnMoXCJhbGxcIik7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiYnRuUmVzdWx0c1wiKS5jbGljaygpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGV4cG9ydCBwaXBlbGluZSByZXF1ZXN0XG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydHBpcGVsaW5lKHJlc3VsdHN0YWJsZVsxXS5QaXBlbGluZUlEKTtcblxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEkgZG9uJ3QgdGhpbmsgd2UgbmVlZCB0aGVzZSB1bnRpbCB3ZSBhcmUgaGFuZGxpbmcgc3RyZWFtaW5nIHBpcGVsaW5lc1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGV5IGFyZSBzZXQgdXAgYW5kIGNhbGxlZCwgYnV0IGRvbid0IGFjdHVhbGx5IHJlbmRlciBhbnl0aGluZyBmb3IgdGhlIHVzZXJcblxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIG91ciBmdW5jdGlvbiBmb3IgdGhlIExpc3RQaXBlbGluZXMgb2YgQVBJXG4gICAgICAgICAgICAgICAgICAgIGxpc3RwaXBlbGluZXMoKTtcblxuICAgICAgICAgICAgICAgICAgICAvL2xldCBwaXBlbGluZWlkID0gUGlwZWxpbmVDcmVhdGVSZXN1bHQucGlwZWxpbmVpZDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBpcGVsaW5lX2lkcyA9IE9iamVjdC5rZXlzKGFsbFBpcGVsaW5lSW5mbyk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBQaXBlbGluZUV4ZWN1dGVSZXN1bHRzUmVxdWVzdCA9IHtjb250ZXh0LCBwaXBlbGluZV9pZHN9O1xuICAgICAgICAgICAgICAgICAgICBqc29ub3V0ID0gSlNPTi5zdHJpbmdpZnkoUGlwZWxpbmVFeGVjdXRlUmVzdWx0c1JlcXVlc3QpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdXJsY2FsbCA9IGQzbVVSTCArIFwiL2dldGV4ZWN1dGVwaXBlbGluZXJlc3VsdHNcIjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNvbGFqc29ub3V0ID0gXCJncnBjcmVxdWVzdD1cIiArIGpzb25vdXQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiR2V0RXhlY3V0ZVBpcGVsaW5lUmVzdWx0czogXCIpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhzb2xhanNvbm91dCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHVybGNhbGwpO1xuXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdldEV4ZWN1dGVQaXBlU3VjY2VzcyhidG4sIFBpcGVsaW5lRXhlY3V0ZVJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coUGlwZWxpbmVFeGVjdXRlUmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbGwgdG8gaW5pdGlhbGl6ZSB0aGUgbWFpbiBwbG90XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkdnZhbHVlcyBhbmQgcHJlZHZhbHMgc2hvdWxkIGV2ZW50dWFsbHkgYmUgY29udGFpbmVkIGluIHRoZSBwaXBlbGluZSBvYmplY3QgaXRzZWxmXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2V0RXhlY3V0ZVBpcGVGYWlsIChidG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiR2V0RXhlY3V0ZVBpcGVsaW5lUmVzdWx0cyBmYWlsZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWFrZUNvcnNSZXF1ZXN0KHVybGNhbGwsIFwibm9idXR0b25cIiwgZ2V0RXhlY3V0ZVBpcGVTdWNjZXNzLCBnZXRFeGVjdXRlUGlwZUZhaWwsIHNvbGFqc29ub3V0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzZW5kUGlwZWxpbmVGYWlsKGJ0bikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInBpcGVsaW5lIHRvIGRqYW5nbyBmYWlsZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZXN0aW1hdGVMYWRkYS5zdGFydCgpOyAvLyBzdGFydCBzcGlubmVyXG4gICAgICAgICAgICAgICAgbWFrZUNvcnNSZXF1ZXN0KHVybGNhbGwsIFwibm9idXR0b25cIiwgc2VuZFBpcGVsaW5lU3VjY2Vzcywgc2VuZFBpcGVsaW5lRmFpbCwgc29sYWpzb25vdXQpO1xuXG4gICAgfWVsc2UgeyAvLyB3ZSBhcmUgaW4gZDNtX21vZGUgbm8gc3dhbmRpdmVcbiAgICAgICAgLy8gcnBjIENyZWF0ZVBpcGVsaW5lcyhQaXBlbGluZUNyZWF0ZVJlcXVlc3QpIHJldHVybnMgKHN0cmVhbSBQaXBlbGluZUNyZWF0ZVJlc3VsdCkge31cbiAgICAgICAgICAgIHpQb3AoKTtcbiAgICAgICAgICAgIHpwYXJhbXMuY2FsbEhpc3RvcnkgPSBjYWxsSGlzdG9yeTtcbiAgICAgICAgICAgIHZhciBqc29ub3V0ID0gSlNPTi5zdHJpbmdpZnkoenBhcmFtcyk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhqc29ub3V0KTtcblxuICAgICAgICAgICAgbGV0IGNvbnRleHQgPSBhcGlTZXNzaW9uKHpwYXJhbXMuenNlc3Npb25pZCk7XG4gICAgICAgICAgICBsZXQgdXJpID0ge2ZlYXR1cmVzOiB6cGFyYW1zLnpkM21kYXRhLCB0YXJnZXQ6enBhcmFtcy56ZDNtdGFyZ2V0fTtcblxuXG4gICAgICAgICAgICB2YXIgdXJsY2FsbCA9IHJhcHBVUkwgKyBcInBpcGVsaW5lYXBwXCI7XG5cbiAgICAgICAgICAgIHZhciBzb2xhanNvbm91dCA9IFwic29sYUpTT049XCIgKyBqc29ub3V0O1xuICAgICAgICAgICAgY2RiKFwidXJsY2FsbCBvdXQ6IFwiLCB1cmxjYWxsKTtcbiAgICAgICAgICAgIGNkYihcIlBPU1Qgb3V0OiBcIiwgc29sYWpzb25vdXQpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVQaXBlbGluZVN1Y2Nlc3MoYnRuLCBqc29uKSB7XG4gICAgICAgICAgICAgICAgZXN0aW1hdGVMYWRkYS5zdG9wKCk7IC8vIHN0b3Agc3Bpbm5lclxuXG4gICAgICAgICAgICAgICAgJChcIiNidG5Fc3RpbWF0ZVwiKS5yZW1vdmVDbGFzcyhcImJ0bi1zdWNjZXNzXCIpO1xuICAgICAgICAgICAgICAgICQoXCIjYnRuRXN0aW1hdGVcIikuYWRkQ2xhc3MoXCJidG4tZGVmYXVsdFwiKTtcbiAgICAgICAgICAgICAgICAkKFwiI2J0bkVuZFNlc3Npb25cIikucmVtb3ZlQ2xhc3MoXCJidG4tZGVmYXVsdFwiKTtcbiAgICAgICAgICAgICAgICAkKFwiI2J0bkVuZFNlc3Npb25cIikuYWRkQ2xhc3MoXCJidG4tc3VjY2Vzc1wiKTtcblxuICAgICAgICAgICAgICAgIGxldCB0cmFpbkZlYXR1cmVzPWFwaUZlYXR1cmVTaG9ydFBhdGgoanNvbi5wcmVkaWN0b3JzLHVyaS5mZWF0dXJlcyk7ICAgIC8vIHB1dHRpbmcgaW4gc2hvcnQgcGF0aHMgKG5vIGZpbGVuYW1lKSBmb3IgY3VycmVudCBBUEkgdXNhZ2VcbiAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0RmVhdHVyZXM9YXBpRmVhdHVyZVNob3J0UGF0aChqc29uLmRlcHZhcix1cmkudGFyZ2V0KTsgICAgICAgICAvLyBwdXR0aW5nIGluIHNob3J0IHBhdGhzIChubyBmaWxlbmFtZSkgZm9yIGN1cnJlbnQgQVBJIHVzYWdlXG4gICAgICAgICAgICAgICAgbGV0IHRhc2sgPSBkM21UYXNrVHlwZVtkM21Qcm9ibGVtRGVzY3JpcHRpb24udGFza1R5cGVdWzFdO1xuICAgICAgICAgICAgICAgIGxldCB0YXNrU3VidHlwZSA9IGQzbVRhc2tTdWJ0eXBlW2QzbVByb2JsZW1EZXNjcmlwdGlvbi50YXNrU3VidHlwZV1bMV07XG4gICAgICAgICAgICAgICAgbGV0IG91dHB1dCA9IGQzbU91dHB1dFR5cGVbZDNtUHJvYmxlbURlc2NyaXB0aW9uLm91dHB1dFR5cGVdWzFdO1xuICAgICAgICAgICAgICAgIGxldCBtZXRyaWNzID0gW2QzbU1ldHJpY3NbZDNtUHJvYmxlbURlc2NyaXB0aW9uLm1ldHJpY11bMV1dO1xuICAgICAgICAgICAgICAgIGxldCB0YXNrRGVzY3JpcHRpb24gPSBkM21Qcm9ibGVtRGVzY3JpcHRpb24udGFza0Rlc2NyaXB0aW9ucmlwdGlvbjtcbiAgICAgICAgICAgICAgICBsZXQgbWF4UGlwZWxpbmVzID0gNTsgLy91c2VyIHRvIHNwZWNpZnkgdGhpcyBldmVudHVhbGx5P1xuXG4gICAgICAgICAgICAgICAgc2V0eFRhYmxlKGpzb24ucHJlZGljdG9ycyk7XG4gICAgICAgICAgICAgICAgbGV0IGR2dmFsdWVzID0ganNvbi5kdnZhbHVlcztcblxuXG4gICAgICAgICAgICAgICAgbGV0IFBpcGVsaW5lQ3JlYXRlUmVxdWVzdD17Y29udGV4dCwgdHJhaW5GZWF0dXJlcywgdGFzaywgdGFza1N1YnR5cGUsIHRhc2tEZXNjcmlwdGlvbiwgb3V0cHV0LCBtZXRyaWNzLCB0YXJnZXRGZWF0dXJlcywgbWF4UGlwZWxpbmVzfTtcblxuICAgICAgICAgICAgICAgIGxldCBqc29ub3V0ID0gSlNPTi5zdHJpbmdpZnkoUGlwZWxpbmVDcmVhdGVSZXF1ZXN0KTtcblxuICAgICAgICAgICAgICAgIGxldCB1cmxjYWxsID0gZDNtVVJMICsgXCIvY3JlYXRlcGlwZWxpbmVcIjtcbiAgICAgICAgICAgICAgICB2YXIgc29sYWpzb25vdXQgPSBcImdycGNyZXF1ZXN0PVwiICsganNvbm91dDtcblxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHVybGNhbGwpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHNvbGFqc29ub3V0KTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzZW5kUGlwZWxpbmVTdWNjZXNzKGJ0biwgUGlwZWxpbmVDcmVhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9ycGMgR2V0RXhlY3V0ZVBpcGVsaW5lUmVzdWx0cyhQaXBlbGluZUV4ZWN1dGVSZXN1bHRzUmVxdWVzdCkgcmV0dXJucyAoc3RyZWFtIFBpcGVsaW5lRXhlY3V0ZVJlc3VsdCkge31cbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coUGlwZWxpbmVDcmVhdGVSZXN1bHQpO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IGFsbFBpcGVsaW5lSW5mbyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaTxQaXBlbGluZUNyZWF0ZVJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoUGlwZWxpbmVDcmVhdGVSZXN1bHRbaV0ucGlwZWxpbmVJZCBpbiBhbGxQaXBlbGluZUluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxQaXBlbGluZUluZm9bUGlwZWxpbmVDcmVhdGVSZXN1bHRbaV0ucGlwZWxpbmVJZF09T2JqZWN0LmFzc2lnbihhbGxQaXBlbGluZUluZm9bUGlwZWxpbmVDcmVhdGVSZXN1bHRbaV0ucGlwZWxpbmVJZF0sUGlwZWxpbmVDcmVhdGVSZXN1bHRbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxQaXBlbGluZUluZm9bUGlwZWxpbmVDcmVhdGVSZXN1bHRbaV0ucGlwZWxpbmVJZF09UGlwZWxpbmVDcmVhdGVSZXN1bHRbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYWxsUGlwZWxpbmVJbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gZ2V0IGFsbCBwaXBlbGluZSBpZHM6IE9iamVjdC5rZXlzKGFsbFBpcGVsaW5lSW5mbylcblxuICAgICAgICAgICAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHRhYnVsYXRlKGRhdGEsIGNvbHVtbnMsIGRpdmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFibGUgPSBkMy5zZWxlY3QoZGl2aWQpLmFwcGVuZCgndGFibGUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRoZWFkID0gdGFibGUuYXBwZW5kKCd0aGVhZCcpXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXJcdHRib2R5ID0gdGFibGUuYXBwZW5kKCd0Ym9keScpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhcHBlbmQgdGhlIGhlYWRlciByb3dcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoZWFkLmFwcGVuZCgndHInKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgndGgnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmRhdGEoY29sdW1ucykuZW50ZXIoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgndGgnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24gKGNvbHVtbikgeyByZXR1cm4gY29sdW1uOyB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY3JlYXRlIGEgcm93IGZvciBlYWNoIG9iamVjdCBpbiB0aGUgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJvd3MgPSB0Ym9keS5zZWxlY3RBbGwoJ3RyJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5kYXRhKGRhdGEpXG4gICAgICAgICAgICAgICAgICAgICAgICAuZW50ZXIoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgndHInKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJyxmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGk9PTApIHJldHVybiAnaXRlbS1zZWxlY3QnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSByZXR1cm4gJ2l0ZW0tZGVmYXVsdCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGUgYSBjZWxsIGluIGVhY2ggcm93IGZvciBlYWNoIGNvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNlbGxzID0gcm93cy5zZWxlY3RBbGwoJ3RkJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5kYXRhKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2x1bW5zLm1hcChmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtjb2x1bW46IGNvbHVtbiwgdmFsdWU6IHJvd1tjb2x1bW5dfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuZW50ZXIoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgndGQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAub24oXCJjbGlja1wiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG15cm93ID0gdGhpcy5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKG15cm93LmNsYXNzTmFtZT09XCJpdGVtLXNlbGVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3QoZGl2aWQpLnNlbGVjdChcInRyLml0ZW0tc2VsZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdpdGVtLWRlZmF1bHQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KG15cm93KS5hdHRyKCdjbGFzcycsXCJpdGVtLXNlbGVjdFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZGl2aWQ9PScjc2V0eFJpZ2h0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0c3Bsb3Rpbml0KGFsbFBpcGVsaW5lSW5mb1tteXJvdy5maXJzdENoaWxkLmlubmVyVGV4dF0sIGR2dmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH19KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBjb2RlIHRvIGFkZCBhIGNoZWNrYm94IHRvIGVhY2ggcm93IG9mIHBpcGVsaW5lIHJlc3VsdHMgdGFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3QoZGl2aWQpLnNlbGVjdEFsbChcInRyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKFwiaW5wdXRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwidHlwZVwiLCBcImNoZWNrYm94XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJmbG9hdFwiLFwicmlnaHRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdHN0YWJsZSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGtleSBpbiBhbGxQaXBlbGluZUluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZG9uJ3QgcmVwb3J0IHRoZSBwaXBlbGluZSB0byB1c2VyIGlmIGl0IGhhcyBmYWlsZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGFsbFBpcGVsaW5lSW5mb1trZXldLnJlc3BvbnNlSW5mby5zdGF0dXMuZGV0YWlscyA9PSBcIlBpcGVsaW5lIEZhaWxlZFwiKSAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG15aWQgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG15bWV0cmljID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBteXZhbCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbXlzY29yZXMgPSBhbGxQaXBlbGluZUluZm9ba2V5XS5waXBlbGluZUluZm8uc2NvcmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG15c2NvcmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pZihpPT0wKSB7bXlpZD1rZXk7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGVsc2UgbXlpZD1cIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG15aWQ9a2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG15bWV0cmljPW15c2NvcmVzW2ldLm1ldHJpYztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBteXZhbD0rbXlzY29yZXNbaV0udmFsdWUudG9GaXhlZCgzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzdGFibGUucHVzaCh7XCJQaXBlbGluZUlEXCI6bXlpZCxcIk1ldHJpY1wiOm15bWV0cmljLCBcIlNjb3JlXCI6bXl2YWx9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbmRlciB0aGUgdGFibGVcbiAgICAgICAgICAgICAgICAgICAgdGFidWxhdGUocmVzdWx0c3RhYmxlLCBbJ1BpcGVsaW5lSUQnLCAnTWV0cmljJywgJ1Njb3JlJ10sICcjcmVzdWx0cycpO1xuICAgICAgICAgICAgICAgICAgICB0YWJ1bGF0ZShyZXN1bHRzdGFibGUsIFsnUGlwZWxpbmVJRCcsICdNZXRyaWMnLCAnU2NvcmUnXSwgJyNzZXR4UmlnaHQnKTtcbiAgICAgICAgICAgICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgICAgICAgICAgICAgICAgIHRvZ2dsZVJpZ2h0QnV0dG9ucyhcImFsbFwiKTtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJidG5SZXN1bHRzXCIpLmNsaWNrKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBpbml0aWFsaXplcyB0aGUgbWFpblxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHBpZWNlIGhlcmUgaXMgdGhlIGZpcnN0IHBpcGVsaW5lIHRocm91Z2g6IGFsbFBpcGVsaW5lSW5mb1tyZXN1bHRzdGFibGVbMV0uUGlwZWxpbmVJRF1cbiAgICAgICAgICAgICAgICAgICAgLy9yZXN1bHRzcGxvdGluaXQoYWxsUGlwZWxpbmVJbmZvW3Jlc3VsdHN0YWJsZVsxXS5QaXBlbGluZUlEXSwgZHZ2YWx1ZXMpO1xuICAgICAgICAgICAgICAgICAgICBleHBvcnRwaXBlbGluZShyZXN1bHRzdGFibGVbMV0uUGlwZWxpbmVJRCk7XG5cblxuICAgICAgICAgICAgICAgICAgICAvLyBJIGRvbid0IHRoaW5rIHdlIG5lZWQgdGhlc2UgdW50aWwgd2UgYXJlIGhhbmRsaW5nIHN0cmVhbWluZyBwaXBlbGluZXNcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhleSBhcmUgc2V0IHVwIGFuZCBjYWxsZWQsIGJ1dCBkb24ndCBhY3R1YWxseSByZW5kZXIgYW55dGhpbmcgZm9yIHRoZSB1c2VyXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBvdXIgZnVuY3Rpb24gZm9yIHRoZSBMaXN0UGlwZWxpbmVzIG9mIEFQSVxuICAgICAgICAgICAgICAgICAgICBsaXN0cGlwZWxpbmVzKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy9sZXQgcGlwZWxpbmVpZCA9IFBpcGVsaW5lQ3JlYXRlUmVzdWx0LnBpcGVsaW5laWQ7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwaXBlbGluZV9pZHMgPSBPYmplY3Qua2V5cyhhbGxQaXBlbGluZUluZm8pO1xuICAgICAgICAgICAgICAgICAgICBsZXQgUGlwZWxpbmVFeGVjdXRlUmVzdWx0c1JlcXVlc3QgPSB7Y29udGV4dCwgcGlwZWxpbmVfaWRzfTtcbiAgICAgICAgICAgICAgICAgICAganNvbm91dCA9IEpTT04uc3RyaW5naWZ5KFBpcGVsaW5lRXhlY3V0ZVJlc3VsdHNSZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHVybGNhbGwgPSBkM21VUkwgKyBcIi9nZXRleGVjdXRlcGlwZWxpbmVyZXN1bHRzXCI7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzb2xhanNvbm91dCA9IFwiZ3JwY3JlcXVlc3Q9XCIgKyBqc29ub3V0O1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkdldEV4ZWN1dGVQaXBlbGluZVJlc3VsdHM6IFwiKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coc29sYWpzb25vdXQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyh1cmxjYWxsKTtcblxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZXRFeGVjdXRlUGlwZVN1Y2Nlc3MoYnRuLCBQaXBlbGluZUV4ZWN1dGVSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFBpcGVsaW5lRXhlY3V0ZVJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYWxsIHRvIGluaXRpYWxpemUgdGhlIG1haW4gcGxvdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZHZ2YWx1ZXMgYW5kIHByZWR2YWxzIHNob3VsZCBldmVudHVhbGx5IGJlIGNvbnRhaW5lZCBpbiB0aGUgcGlwZWxpbmUgb2JqZWN0IGl0c2VsZlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdldEV4ZWN1dGVQaXBlRmFpbCAoYnRuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkdldEV4ZWN1dGVQaXBlbGluZVJlc3VsdHMgZmFpbGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1ha2VDb3JzUmVxdWVzdCh1cmxjYWxsLCBcIm5vYnV0dG9uXCIsIGdldEV4ZWN1dGVQaXBlU3VjY2VzcywgZ2V0RXhlY3V0ZVBpcGVGYWlsLCBzb2xhanNvbm91dCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gc2VuZFBpcGVsaW5lRmFpbChidG4pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJwaXBlbGluZSB0byBkamFuZ28gZmFpbGVkXCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1ha2VDb3JzUmVxdWVzdCh1cmxjYWxsLCBcIm5vYnV0dG9uXCIsIHNlbmRQaXBlbGluZVN1Y2Nlc3MsIHNlbmRQaXBlbGluZUZhaWwsIHNvbGFqc29ub3V0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gY3JlYXRlUGlwZWxpbmVGYWlsKGJ0bikge1xuICAgICAgICAgICAgICAgIGVzdGltYXRlTGFkZGEuc3RvcCgpOyAvLyBzdG9wIHNwaW5uZXJcbiAgICAgICAgICAgICAgICBlc3RpbWF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlc3RpbWF0ZUxhZGRhLnN0YXJ0KCk7IC8vIHN0YXJ0IHNwaW5uZXJcbiAgICAgICAgICAgIG1ha2VDb3JzUmVxdWVzdCh1cmxjYWxsLCBidG4sIGNyZWF0ZVBpcGVsaW5lU3VjY2VzcywgY3JlYXRlUGlwZWxpbmVGYWlsLCBzb2xhanNvbm91dCk7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcnVuUHJlcHJvY2VzcyhkYXRhbG9jLCB0YXJnZXRsb2MsIGRhdGFzdHViKSB7XG4gICAgbGV0IHVybCA9IHJhcHBVUkwgKyAncHJlcHJvY2Vzc2FwcCc7XG4gICAgY29uc29sZS5sb2coXCJHT0lORyBUTyBSVU4gVEhFIFBSRVBST0NFU1NBUFBcIik7XG4gICAgbGV0IGpzb24gPSBKU09OLnN0cmluZ2lmeSh7ZGF0YTogZGF0YWxvYywgdGFyZ2V0OiB0YXJnZXRsb2MsIGRhdGFzdHViOiBkYXRhc3R1Yn0pOyAvLywgcHJlcHJvY2VzczogcHJlcHJvY2Vzc2xvY30pO1xuICAgIGNvbnNvbGUubG9nKCd1cmxjYWxsIG91dDogJywgdXJsKTtcbiAgICBjb25zb2xlLmxvZygnUE9TVCBvdXQ6ICcsIGpzb24pO1xuICAgIGxldCBkYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgZGF0YS5hcHBlbmQoJ3NvbGFKU09OJywganNvbik7XG4gICAgcmV0dXJuIG0ucmVxdWVzdCh7bWV0aG9kOiAnUE9TVCcsIHVybDogdXJsLCBkYXRhOiBkYXRhLCBhc3luYzpmYWxzZX0pXG4gICAgICAgIC50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2pzb24gaW4gUklHSFQgSEVSRTogJywgZGF0YSk7XG5cbiAgICAgICAgICAgIC8vdHdvIGxpbmVzIGZyb20gcmVhZFByZXByb2Nlc3MoKVxuICAgICAgICAgICAgcHJpdiA9IGRhdGEuZGF0YXNldC5wcml2YXRlIHx8IHByaXY7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhkYXRhLnZhcmlhYmxlcykuZm9yRWFjaChrID0+IHByZXByb2Nlc3Nba10gPSBkYXRhLnZhcmlhYmxlc1trXSk7XG5cbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9LCBfID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdwcmVwcm9jZXNzIGZhaWxlZCcpO1xuICAgICAgICAgICAgYWxlcnQoJ3ByZXByb2Nlc3MgZmFpbGVkLiBlbmRpbmcgdXNlciBzZXNzaW9uLicpO1xuICAgICAgICAgICAgZW5kc2Vzc2lvbigpO1xuICAgICAgICB9KTtcbn1cblxuZXhwb3J0IGxldCB0YTJzdHVmZiA9IF8gPT4gY29uc29sZS5sb2coZDNtUHJvYmxlbURlc2NyaXB0aW9uKTtcblxuZnVuY3Rpb24gZGF0YURvd25sb2FkKCkge1xuICAgIHpQb3AoKTtcbiAgICAvLyB3cml0ZSBsaW5rcyB0byBmaWxlICYgcnVuIFIgQ01EXG5cbiAgICAvL3BhY2thZ2UgdGhlIG91dHB1dCBhcyBKU09OXG4gICAgLy8gYWRkIGNhbGwgaGlzdG9yeSBhbmQgcGFja2FnZSB0aGUgenBhcmFtcyBvYmplY3QgYXMgSlNPTlxuICAgIHZhciBqc29ub3V0ID0gSlNPTi5zdHJpbmdpZnkoenBhcmFtcyk7XG4gICAgdmFyIGJ0biA9IFwibm9idXR0b25cIjtcblxuICAgIHZhciB1cmxjYWxsID0gcmFwcFVSTCArIFwiZGF0YWFwcFwiO1xuICAgIHZhciBzb2xhanNvbm91dCA9IFwic29sYUpTT049XCIgKyBqc29ub3V0O1xuICAgIGNkYihcInVybGNhbGwgb3V0OiBcIiwgdXJsY2FsbCk7XG4gICAgY2RiKFwiUE9TVCBvdXQ6IFwiLCBzb2xhanNvbm91dCk7XG5cbiAgICBsZXQgZG93bmxvYWRTdWNjZXNzID0gKGJ0biwganNvbikgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygnZGF0YWRvd25sb2FkOiAnLCBqc29uKTtcbiAgICAgICAgY2RiKCdkYXRhRG93bmxvYWQganNvbiBpbjogJywganNvbik7XG4gICAgICAgIHpwYXJhbXMuenNlc3Npb25pZCA9IGpzb24uc2Vzc2lvbmlkWzBdO1xuICAgICAgICAvLyBzZXQgbGluayBVUkxcbiAgICAgICAgYnlJZChcImxvZ0lEXCIpLmhyZWYgPSBgJHtwcm9kdWN0aW9uID8gcmFwcFVSTCArICdsb2dfZGlyL2xvZ18nIDogJ3Jvb2svbG9nXycgfSR7enBhcmFtcy56c2Vzc2lvbmlkfS50eHRgO1xuICAgIH07XG4gICAgbGV0IGRvd25sb2FkRmFpbCA9IF8gPT4gY2RiKCdEYXRhIGhhdmUgbm90IGJlZW4gZG93bmxvYWRlZCcpO1xuICAgIG1ha2VDb3JzUmVxdWVzdCh1cmxjYWxsLCBidG4sIGRvd25sb2FkU3VjY2VzcywgZG93bmxvYWRGYWlsLCBzb2xhanNvbm91dCk7XG59XG5cbmZ1bmN0aW9uIHZpeihteW0pIHtcbiAgICB2YXIgbXltID0gK215bS5zdWJzdHIoNSwgNSkgLSAxO1xuXG4gICAgZnVuY3Rpb24gcmVtb3ZlS2lkcyhwYXJlbnQpIHtcbiAgICAgICAgd2hpbGUgKHBhcmVudC5maXJzdENoaWxkKVxuICAgICAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKHBhcmVudC5maXJzdENoaWxkKTtcbiAgICB9XG5cbiAgICByZW1vdmVLaWRzKGJ5SWQoXCJyZXN1bHRzVmlld1wiKSk7XG5cbiAgICBsZXQganNvbiA9IGFsbFJlc3VsdHNbbXltXTtcblxuICAgIC8vIHBpcGUgaW4gZmlndXJlcyB0byByaWdodCBwYW5lbFxuICAgIHZhciBmaWxlbGlzdCA9IG5ldyBBcnJheTtcbiAgICBmb3IgKHZhciBpIGluIGpzb24uaW1hZ2VzKSB7XG4gICAgICAgIHZhciB6ZmlnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcbiAgICAgICAgemZpZy5zZXRBdHRyaWJ1dGUoXCJzcmNcIiwganNvbi5pbWFnZXNbaV0pO1xuICAgICAgICB6ZmlnLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAyMDApO1xuICAgICAgICB6ZmlnLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgMjAwKTtcbiAgICAgICAgYnlJZChcInJlc3VsdHNWaWV3XCIpLmFwcGVuZENoaWxkKHpmaWcpO1xuICAgIH1cblxuICAgIC8vIHdyaXRlIHRoZSByZXN1bHRzIHRhYmxlXG4gICAgdmFyIHJlc3VsdHNBcnJheSA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBqc29uLnN1bUluZm8pIHtcbiAgICAgICAgaWYgKGtleSA9PSAnY29sbmFtZXMnKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIHJlc3VsdHNBcnJheS5wdXNoKGpzb24uc3VtSW5mb1trZXldKTtcbiAgICB9XG5cbiAgICB2YXIgdGFibGUgPSBkMy5zZWxlY3QoXCIjcmVzdWx0c1ZpZXdcIilcbiAgICAgICAgLmFwcGVuZChcInBcIilcbiAgICAgICAgLmFwcGVuZChcInRhYmxlXCIpO1xuXG4gICAgdmFyIHRoZWFkID0gdGFibGUuYXBwZW5kKFwidGhlYWRcIik7XG4gICAgdGhlYWQuYXBwZW5kKFwidHJcIilcbiAgICAgICAgLnNlbGVjdEFsbChcInRoXCIpXG4gICAgICAgIC5kYXRhKGpzb24uc3VtSW5mby5jb2xuYW1lcylcbiAgICAgICAgLmVudGVyKClcbiAgICAgICAgLmFwcGVuZChcInRoXCIpXG4gICAgICAgIC50ZXh0KGQgPT4gZCk7XG5cbiAgICB2YXIgdGJvZHkgPSB0YWJsZS5hcHBlbmQoXCJ0Ym9keVwiKTtcbiAgICB0Ym9keS5zZWxlY3RBbGwoXCJ0clwiKVxuICAgICAgICAuZGF0YShyZXN1bHRzQXJyYXkpXG4gICAgICAgIC5lbnRlcigpLmFwcGVuZChcInRyXCIpXG4gICAgICAgIC5zZWxlY3RBbGwoXCJ0ZFwiKVxuICAgICAgICAuZGF0YShkID0+IGQpXG4gICAgICAgIC5lbnRlcigpLmFwcGVuZChcInRkXCIpXG4gICAgICAgIC50ZXh0KGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHZhciBteU51bSA9IE51bWJlcihkKTtcbiAgICAgICAgICAgIGlmIChpc05hTihteU51bSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgICByZXR1cm4gbXlOdW0udG9QcmVjaXNpb24oMyk7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbihcIm1vdXNlb3ZlclwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5zdHlsZShcImJhY2tncm91bmQtY29sb3JcIiwgXCJhbGljZWJsdWVcIik7XG4gICAgICAgIH0pIC8vIGZvciBubyBkaXNjZXJuYWJsZSByZWFzb25cbiAgICAgICAgLm9uKFwibW91c2VvdXRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuc3R5bGUoXCJiYWNrZ3JvdW5kLWNvbG9yXCIsIFwiI0Y5RjlGOVwiKTtcbiAgICAgICAgfSk7IC8vKGJ1dCBtYXliZSB3ZSdsbCB0aGluayBvZiBvbmUpXG5cbiAgICBkMy5zZWxlY3QoXCIjcmVzdWx0c1ZpZXdcIilcbiAgICAgICAgLmFwcGVuZChcInBcIilcbiAgICAgICAgLmh0bWwoKCkgPT4gXCI8Yj5Gb3JtdWxhOiA8L2I+XCIuY29uY2F0KGpzb24uY2FsbFswXSkpO1xuXG4gICAgbS5yZWRyYXcoKTtcbn1cblxuLy8gcGFyc2VzIHRoZSB0cmFuc2Zvcm1hdGlvbiBpbnB1dC4gdmFyaWFibGUgbmFtZXMgYXJlIG9mdGVuIG5lc3RlZCBpbnNpZGUgb25lIGFub3RoZXIsIGUuZy4sIGV0aHdhciwgd2FyLCB3YXJzLCBhbmQgc28gdGhpcyBpcyBoYW5kbGVkXG5mdW5jdGlvbiB0cmFuc1BhcnNlKG4pIHtcbiAgICB2YXIgb3V0MiA9IFtdO1xuICAgIHZhciB0MiA9IG47XG4gICAgdmFyIGsyID0gMDtcbiAgICB2YXIgc3ViTWUyID0gXCJfdHJhbnN2YXJcIi5jb25jYXQoazIpO1xuICAgIHZhciBpbmRleGVkID0gW107XG5cbiAgICAvLyBvdXQyIGlzIGFsbCBtYXRjaGVkIHZhcmlhYmxlcywgaW5kZXhlZCBpcyBhbiBhcnJheSwgZWFjaCBlbGVtZW50IGlzIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBtYXRjaGVkIHZhcmlhYmxlcyBzdGFydGluZyBpbmRleCBhbmQgZmluaXNoaW5nIGluZGV4LiAgZS5nLiwgbj1cIndhcnMrMlwiLCBvdXQyPVt3YXIsIHdhcnNdLCBpbmRleGVkPVt7MCwyfSx7MCwzfV1cbiAgICBmb3IgKHZhciBpIGluIHZhbHVlS2V5KSB7XG4gICAgICAgIHZhciBtMiA9IG4ubWF0Y2godmFsdWVLZXlbaV0pO1xuICAgICAgICBpZiAobTIgIT0gbnVsbClcbiAgICAgICAgICAgIG91dDIucHVzaChtMlswXSk7XG5cbiAgICAgICAgdmFyIHJlID0gbmV3IFJlZ0V4cCh2YWx1ZUtleVtpXSwgXCJnXCIpO1xuICAgICAgICB2YXIgcyA9IG4uc2VhcmNoKHJlKTtcbiAgICAgICAgaWYgKHMgIT0gLTEpXG4gICAgICAgICAgICBpbmRleGVkLnB1c2goe2Zyb206IHMsIHRvOiBzICsgdmFsdWVLZXlbaV0ubGVuZ3RofSk7XG4gICAgfVxuXG4gICAgLy8gbmVzdGVkIGxvb3Agbm90IGdvb2QsIGJ1dCBpbmRleGVkIGlzIG5vdCBsaWtlbHkgdG8gYmUgdmVyeSBsYXJnZS5cbiAgICAvLyBpZiBhIHZhcmlhYmxlIGlzIG5lc3RlZCwgaXQgaXMgcmVtb3ZlZCBmcm9tIG91dDJcbiAgICAvLyBub3RpY2UsIGxvb3AgaXMgYmFja3dhcmRzIHNvIHRoYXQgaW5kZXggY2hhbmdlcyBkb24ndCBhZmZlY3QgdGhlIHNwbGljZVxuICAgIGNkYihcImluZGV4ZWQgXCIsIGluZGV4ZWQpO1xuICAgIGZvciAodmFyIGkgPSBpbmRleGVkLmxlbmd0aCAtIDE7IGkgPiAtMTsgaS0tKSB7XG4gICAgICAgIGZvciAodmFyIGogPSBpbmRleGVkLmxlbmd0aCAtIDE7IGogPiAtMTsgai0tKSB7XG4gICAgICAgICAgICBpZiAoaSA9PT0gailcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICgoaW5kZXhlZFtpXS5mcm9tID49IGluZGV4ZWRbal0uZnJvbSkgJiAoaW5kZXhlZFtpXS50byA8PSBpbmRleGVkW2pdLnRvKSkge1xuICAgICAgICAgICAgICAgIGNkYihpLCBcIiBpcyBuZXN0ZWQgaW4gXCIsIGopO1xuICAgICAgICAgICAgICAgIG91dDIuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSBpbiBvdXQyKSB7XG4gICAgICAgIHQyID0gdDIucmVwbGFjZShvdXQyW2ldLCBzdWJNZTIpOyAvL3NvbWV0aGluZyB0aGF0J2xsIG5ldmVyIGJlIGEgdmFyaWFibGUgbmFtZVxuICAgICAgICBrMiA9IGsyICsgMTtcbiAgICAgICAgc3ViTWUyID0gXCJfdHJhbnN2YXJcIi5jb25jYXQoazIpO1xuICAgIH1cblxuICAgIGlmIChvdXQyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgb3V0Mi5wdXNoKHQyKTtcbiAgICAgICAgY2RiKFwibmV3IG91dCBcIiwgb3V0Mik7XG4gICAgICAgIHJldHVybiAob3V0Mik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYWxlcnQoXCJObyB2YXJpYWJsZSBuYW1lIGZvdW5kLiBQZXJoYXBzIGNoZWNrIHlvdXIgc3BlbGxpbmc/XCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cbi8qKlxuICBuID0gbmFtZSBvZiBjb2x1bW4vbm9kZVxuICB0ID0gc2VsZWN0ZWQgdHJhbnNmb3JtYXRpb25cbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtKG4sIHQsIHR5cGVUcmFuc2Zvcm0pIHtcbiAgICBpZiAocHJvZHVjdGlvbiAmJiB6cGFyYW1zLnpzZXNzaW9uaWQgPT0gXCJcIikge1xuICAgICAgICBhbGVydChcIldhcm5pbmc6IERhdGEgZG93bmxvYWQgaXMgbm90IGNvbXBsZXRlLiBUcnkgYWdhaW4gc29vbi5cIik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0eXBlVHJhbnNmb3JtKVxuICAgICAgICB0ID0gdC5yZXBsYWNlKFwiK1wiLCBcIl9wbHVzX1wiKTsgLy8gY2FuJ3Qgc2VuZCB0aGUgcGx1cyBvcGVyYXRvclxuXG4gICAgY2RiKCduYW1lIG9mIGNvbDogJyArIG4pO1xuICAgIGNkYigndHJhbnNmb3JtYXRpb246ICcgKyB0KTtcblxuICAgIHZhciBidG4gPSBieUlkKCdidG5Fc3RpbWF0ZScpO1xuXG4gICAgLy8gZmluZCB0aGUgbm9kZSBieSBuYW1lXG4gICAgdmFyIG15biA9IGZpbmROb2RlSW5kZXgoblswXSwgdHJ1ZSk7XG5cbiAgICBpZiAodHlwZW9mIG15biA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBteW4gPSBmaW5kTm9kZUluZGV4KG4sIHRydWUpO1xuICAgIH1cblxuICAgIHZhciBvdXR0eXBlcyA9IHtcbiAgICAgICAgdmFybmFtZXNUeXBlczogbixcbiAgICAgICAgaW50ZXJ2YWw6IG15bi5pbnRlcnZhbCxcbiAgICAgICAgbnVtY2hhcjogbXluLm51bWNoYXIsXG4gICAgICAgIG5hdHVyZTogbXluLm5hdHVyZSxcbiAgICAgICAgYmluYXJ5OiBteW4uYmluYXJ5XG4gICAgfTtcblxuICAgIGNkYihteW4pO1xuICAgIC8vIGlmIHR5cGVUcmFuc2Zvcm0gYnV0IHdlIGFscmVhZHkgaGF2ZSB0aGUgbWV0YWRhdGFcbiAgICBpZiAodHlwZVRyYW5zZm9ybSkge1xuICAgICAgICBpZiAobXluLm5hdHVyZSA9PSBcIm5vbWluYWxcIiAmIHR5cGVvZiBteW4ucGxvdHZhbHVlcyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgbXluLnBsb3R0eXBlID0gXCJiYXJcIjtcbiAgICAgICAgICAgIGJhcnNOb2RlKG15bik7XG4gICAgICAgICAgICBwYW5lbFBsb3RzKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAobXluLm5hdHVyZSAhPSBcIm5vbWluYWxcIiAmIHR5cGVvZiBteW4ucGxvdHggIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIG15bi5wbG90dHlwZSA9IFwiY29udGludW91c1wiO1xuICAgICAgICAgICAgZGVuc2l0eU5vZGUobXluKTtcbiAgICAgICAgICAgIHBhbmVsUGxvdHMoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vcGFja2FnZSB0aGUgb3V0cHV0IGFzIEpTT05cbiAgICB2YXIgdHJhbnNmb3Jtc3R1ZmYgPSB7XG4gICAgICAgIHpkYXRhdXJsOiBkYXRhdXJsLFxuICAgICAgICB6dmFyczogbXluLm5hbWUsXG4gICAgICAgIHpzZXNzaW9uaWQ6IHpwYXJhbXMuenNlc3Npb25pZCxcbiAgICAgICAgdHJhbnNmb3JtOiB0LFxuICAgICAgICBjYWxsSGlzdG9yeTogY2FsbEhpc3RvcnksXG4gICAgICAgIHR5cGVUcmFuc2Zvcm06IHR5cGVUcmFuc2Zvcm0sXG4gICAgICAgIHR5cGVTdHVmZjogb3V0dHlwZXNcbiAgICB9O1xuICAgIHZhciBqc29ub3V0ID0gSlNPTi5zdHJpbmdpZnkodHJhbnNmb3Jtc3R1ZmYpO1xuICAgIHZhciB1cmxjYWxsID0gcmFwcFVSTCArIFwidHJhbnNmb3JtYXBwXCI7XG4gICAgdmFyIHNvbGFqc29ub3V0ID0gXCJzb2xhSlNPTj1cIiArIGpzb25vdXQ7XG4gICAgY2RiKFwidXJsY2FsbCBvdXQ6IFwiICsgdXJsY2FsbCk7XG4gICAgY2RiKFwiUE9TVCBvdXQ6IFwiICsgc29sYWpzb25vdXQpO1xuXG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtU3VjY2VzcyhidG4sIGpzb24pIHtcbiAgICAgICAgZXN0aW1hdGVMYWRkYS5zdG9wKCk7XG4gICAgICAgIGNkYihcImpzb24gaW46IFwiICsgSlNPTi5zdHJpbmdpZnkoanNvbikpO1xuXG4gICAgICAgIC8vIElzIHRoaXMgYSB0eXBlVHJhbnNmb3JtP1xuICAgICAgICBpZiAoanNvbi50eXBlVHJhbnNmb3JtWzBdKSB7XG4gICAgICAgICAgICAvLyBZZXMuIFdlJ3JlIHVwZGF0aW5nIGFuIGV4aXN0aW5nIG5vZGVcbiAgICAgICAgICAgIGQzLmpzb24oanNvbi51cmwsIChlcnIsIGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKGVycik7XG4gICAgICAgICAgICAgICAgbGV0IG5vZGU7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGZpbmROb2RlSW5kZXgoa2V5LCB0cnVlKTtcblx0XHQgICAgaWYgKCFub2RlKVxuXHRcdCAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5leHRlbmQodHJ1ZSwgbm9kZSwgZGF0YVtrZXldKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5wbG90dHlwZSA9PT0gXCJjb250aW51b3VzXCIgPyBkZW5zaXR5Tm9kZShub2RlKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnBsb3R0eXBlID09PSBcImJhclwiID8gYmFyc05vZGUobm9kZSkgOiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmYWtlQ2xpY2soKTtcbiAgICAgICAgICAgICAgICBwYW5lbFBsb3RzKCk7XG4gICAgICAgICAgICAgICAgbm9kZSAmJiBjZGIobm9kZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvKiBObywgd2UgaGF2ZSBhIG5ldyBub2RlIGhlcmUtLWUuZy4gdGhlIHRyYW5zZm9ybWVkIGNvbHVtblxuICAgICAgICAgICAgICAgZXhhbXBsZSByZXNwb25zZToge1xuICAgICAgICAgICAgICAgXCJjYWxsXCI6W1widF95ZWFyXzJcIl0sXG4gICAgICAgICAgICAgICBcInVybFwiOltcImRhdGEvcHJlcHJvY2Vzc1N1YnNldF9CQUNDQkM3OC03REQ5LTQ0ODItQjMxRC02RUIwMUMzQTBDOTUudHh0XCJdLFxuICAgICAgICAgICAgICAgXCJ0cmFuc1wiOltcInllYXJcIixcIl90cmFuc3ZhcjBeMlwiXSxcbiAgICAgICAgICAgICAgIFwidHlwZVRyYW5zZm9ybVwiOltmYWxzZV1cbiAgICAgICAgICAgICB9XG4gICAgICAgICAgKi9cbiAgICAgICAgICAgIGNhbGxIaXN0b3J5LnB1c2goe1xuICAgICAgICAgICAgICAgIGZ1bmM6IFwidHJhbnNmb3JtXCIsXG4gICAgICAgICAgICAgICAgenZhcnM6IG4sXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiB0XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIHN1YnNldGVkID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgckNhbGwgPSBbXTtcblxuICAgICAgICAgICAgckNhbGxbMF0gPSBqc29uLmNhbGw7XG4gICAgICAgICAgICB2YXIgbmV3VmFyID0gckNhbGxbMF1bMF07XG5cbiAgICAgICAgICAgIHRyYW5zLnB1c2gobmV3VmFyKTtcblxuICAgICAgICAgICAgLy8gUmVhZCB0aGUgcHJlcHJvY2VzcyBmaWxlIGNvbnRhaW5pbmcgdmFsdWVzXG4gICAgICAgICAgICAvLyBmb3IgdGhlIHRyYW5zZm9ybWVkIHZhcmlhYmxlXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgZDMuanNvbihqc29uLnVybCwgZnVuY3Rpb24oZXJyb3IsIGpzb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHJldHVybiBjb25zb2xlLndhcm4oZXJyb3IpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGpzb25kYXRhID0gZ2V0VmFyaWFibGVEYXRhKGpzb24pO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGpzb25kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBteUluZGV4ID0gZmluZE5vZGVJbmRleChrZXkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG15SW5kZXggIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsZXJ0KFwiSW52YWxpZCB0cmFuc2Zvcm1hdGlvbjogdGhpcyB2YXJpYWJsZSBuYW1lIGFscmVhZHkgZXhpc3RzLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgdHJhbnNmb3JtZWQgdmFyaWFibGUgdG8gdGhlIGN1cnJlbnQgc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBhbGxOb2Rlcy5sZW5ndGg7ICAvLyBnZXQgbmV3IGluZGV4XG4gICAgICAgICAgICAgICAgICAgIHZhciBvYmoxID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZsZXhpdmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZToga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFibDogXCJ0cmFuc2Zvcm1sYWJlbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogWzUsIDE1LCAyMCwgMCwgNSwgMTUsIDIwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50OiBbLjYsIC4yLCAuOSwgLjgsIC4xLCAuMywgLjRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZUNvbDogY29sb3JzKGkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZUNvbDogY29sb3JzKGkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlQ29sb3I6IHNlbFZhckNvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IFwiMVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2V0cGxvdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzZXRyYW5nZTogW1wiXCIsIFwiXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0eHBsb3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0eHZhbHM6IFtcIlwiLCBcIlwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyYXlvdXQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdEludGVydmFsOiBqc29uZGF0YVtrZXldLmludGVydmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdE51bWNoYXI6IGpzb25kYXRhW2tleV0ubnVtY2hhcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHROYXR1cmU6IGpzb25kYXRhW2tleV0ubmF0dXJlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdEJpbmFyeToganNvbmRhdGFba2V5XS5iaW5hcnlcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXh0ZW5kKHRydWUsIG9iajEsIGpzb25kYXRhW2tleV0pO1xuICAgICAgICAgICAgICAgICAgICBhbGxOb2Rlcy5wdXNoKG9iajEpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlS2V5LnB1c2gobmV3VmFyKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMucHVzaChhbGxOb2Rlc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIGZha2VDbGljaygpO1xuICAgICAgICAgICAgICAgICAgICBwYW5lbFBsb3RzKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFsbE5vZGVzW2ldLnBsb3R0eXBlID09PSBcImNvbnRpbnVvdXNcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVuc2l0eU5vZGUoYWxsTm9kZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFsbE5vZGVzW2ldLnBsb3R0eXBlID09PSBcImJhclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXJzTm9kZShhbGxOb2Rlc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBtLnJlZHJhdygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBzaG93TG9nKCd0cmFuc2Zvcm0nLCByQ2FsbCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm1GYWlsKGJ0bikge1xuICAgICAgICBhbGVydChcInRyYW5zZm9ybSBmYWlsXCIpO1xuICAgICAgICBlc3RpbWF0ZUxhZGRhLnN0b3AoKTtcbiAgICB9XG5cbiAgICBlc3RpbWF0ZUxhZGRhLnN0YXJ0KCk7IC8vIHN0YXJ0IHNwaW5uZXJcbiAgICBtYWtlQ29yc1JlcXVlc3QodXJsY2FsbCwgYnRuLCB0cmFuc2Zvcm1TdWNjZXNzLCB0cmFuc2Zvcm1GYWlsLCBzb2xhanNvbm91dCk7XG59XG5cbi8vIGJlbG93IGZyb20gaHR0cDovL3d3dy5odG1sNXJvY2tzLmNvbS9lbi90dXRvcmlhbHMvY29ycy8gZm9yIGNyb3NzLW9yaWdpbiByZXNvdXJjZSBzaGFyaW5nXG4vLyBDcmVhdGUgdGhlIFhIUiBvYmplY3QuXG5mdW5jdGlvbiBjcmVhdGVDT1JTUmVxdWVzdChtZXRob2QsIHVybCwgY2FsbGJhY2spIHtcbiAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgaWYgKFwid2l0aENyZWRlbnRpYWxzXCIgaW4geGhyKSB7XG4gICAgICAgIC8vIFhIUiBmb3IgQ2hyb21lL0ZpcmVmb3gvT3BlcmEvU2FmYXJpLlxuICAgICAgICB4aHIub3BlbihtZXRob2QsIHVybCwgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgWERvbWFpblJlcXVlc3QgIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAvLyBYRG9tYWluUmVxdWVzdCBmb3IgSUUuXG4gICAgICAgIHhociA9IG5ldyBYRG9tYWluUmVxdWVzdCgpO1xuICAgICAgICB4aHIub3BlbihtZXRob2QsIHVybCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ09SUyBub3Qgc3VwcG9ydGVkLlxuICAgICAgICB4aHIgPSBudWxsO1xuICAgIH1cbiAgICAvLyB4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC1UeXBlJywgJ3RleHQvcGxhaW4nKTtcbiAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC1UeXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcpO1xuICAgIHJldHVybiB4aHI7XG59XG5cbi8vIE1ha2UgdGhlIGFjdHVhbCBDT1JTIHJlcXVlc3QuXG5mdW5jdGlvbiBtYWtlQ29yc1JlcXVlc3QodXJsLCBidG4sIGNhbGxiYWNrLCB3YXJuaW5nY2FsbGJhY2ssIGpzb25zdHJpbmcpIHtcbiAgICB2YXIgeGhyID0gY3JlYXRlQ09SU1JlcXVlc3QoJ1BPU1QnLCB1cmwpO1xuICAgIGlmICgheGhyKSB7XG4gICAgICAgIGFsZXJ0KCdDT1JTIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBSZXNwb25zZSBoYW5kbGVycyBmb3IgYXN5bmNocm9ub3VzIGxvYWRcbiAgICAvLyBvbmxvYWQgb3Igb25yZWFkeXN0YXRlY2hhbmdlP1xuXG4gICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdGV4dCA9IHhoci5yZXNwb25zZVRleHQ7XG4gICAgICAgIGNkYihcInRleHQgXCIsIHRleHQpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIganNvbiA9IEpTT04ucGFyc2UodGV4dCk7IC8vIHNob3VsZCB3cmFwIGluIHRyeSAvIGNhdGNoXG4gICAgICAgICAgICB2YXIgbmFtZXMgPSBPYmplY3Qua2V5cyhqc29uKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBlc3RpbWF0ZUxhZGRhLnN0b3AoKTtcbiAgICAgICAgICAgIHNlbGVjdExhZGRhLnN0b3AoKTtcbiAgICAgICAgICAgIGNkYihlcnIpO1xuICAgICAgICAgICAgYWxlcnQoJ0Vycm9yOiBDb3VsZCBub3QgcGFyc2UgaW5jb21pbmcgSlNPTi4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuYW1lc1swXSA9PSBcIndhcm5pbmdcIikge1xuICAgICAgICAgICAgd2FybmluZ2NhbGxiYWNrKGJ0bik7XG4gICAgICAgICAgICBhbGVydChcIldhcm5pbmc6IFwiICsganNvbi53YXJuaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGJ0biwganNvbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIG5vdGU6IHhoci5yZWFkeXN0YXRlIHNob3VsZCBiZSA0IGFuZCBzdGF0dXMgc2hvdWxkIGJlIDIwMC4gYSBzdGF0dXMgb2YgMCBvY2N1cnMgd2hlbiB0aGUgdXJsIGlzIHRvbyBsYXJnZVxuICAgICAgICB4aHIuc3RhdHVzID09IDAgPyBhbGVydCgnVGhlcmUgd2FzIGFuIGVycm9yIG1ha2luZyB0aGUgcmVxdWVzdC4geG1saHR0cHJlcXVlc3Qgc3RhdHVzIGlzIDAuJykgOlxuICAgICAgICAgICAgeGhyLnJlYWR5U3RhdGUgIT0gNCA/IGFsZXJ0KCdUaGVyZSB3YXMgYW4gZXJyb3IgbWFraW5nIHRoZSByZXF1ZXN0LiB4bWxodHRwcmVxdWVzdCByZWFkeXN0YXRlIGlzIG5vdCA0LicpIDpcbiAgICAgICAgICAgIGFsZXJ0KCdXb29wcywgdGhlcmUgd2FzIGFuIGVycm9yIG1ha2luZyB0aGUgcmVxdWVzdC4nKTtcbiAgICAgICAgY2RiKHhocik7XG4gICAgICAgIGVzdGltYXRlTGFkZGEuc3RvcCgpO1xuICAgICAgICBzZWxlY3RMYWRkYS5zdG9wKCk7XG4gICAgfTtcbiAgICB4aHIuc2VuZChqc29uc3RyaW5nKTtcbn1cblxuZXhwb3J0IGxldCBsZWdlbmQgPSBfID0+IHtcbiAgICBib3JkZXJTdGF0ZSgpO1xuICAgIG0ucmVkcmF3KCk7XG59O1xuXG4vLyBwcm9ncmFtbWF0aWNhbGx5IGRlc2VsZWN0IGV2ZXJ5IHNlbGVjdGVkIHZhcmlhYmxlXG5leHBvcnQgZnVuY3Rpb24gZXJhc2UoKSB7XG4gICAgbGVmdHBhbmVsTWVkaXVtKCk7XG4gICAgcmlnaHRwYW5lbE1lZGl1bSgpO1xuICAgIHRhYkxlZnQoJ3RhYjEnKTtcbiAgICBqUXVlcnkuZm4uZDNDbGljayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNoaWxkcmVuKCkuZWFjaChmdW5jdGlvbihpLCBlKSB7XG4gICAgICAgICAgICB2YXIgbXljb2wgPSBkMy5yZ2IodGhpcy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IpO1xuICAgICAgICAgICAgaWYgKG15Y29sLnRvU3RyaW5nKCkgPT09IHZhckNvbG9yLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiTW91c2VFdmVudHNcIik7XG4gICAgICAgICAgICBldnQuaW5pdE1vdXNlRXZlbnQoXCJjbGlja1wiLCB0cnVlLCB0cnVlLCB3aW5kb3csIDAsIDAsIDAsIDAsIDAsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAwLCBudWxsKTtcbiAgICAgICAgICAgIGUuZGlzcGF0Y2hFdmVudChldnQpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgICQoXCIjdmFyTGlzdFwiKS5kM0NsaWNrKCk7XG59XG5cbi8vIGh0dHA6Ly93d3cudHV0b3JpYWxzMmxlYXJuLmNvbS90dXRvcmlhbHMvc2NyaXB0cy9qYXZhc2NyaXB0L3htbC1wYXJzZXItamF2YXNjcmlwdC5odG1sXG5mdW5jdGlvbiBsb2FkWE1MRG9jKFhNTG5hbWUpIHtcbiAgICB2YXIgeG1sRG9jO1xuICAgIGlmICh3aW5kb3cuWE1MSHR0cFJlcXVlc3QpIHtcbiAgICAgICAgeG1sRG9jID0gbmV3IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICB4bWxEb2Mub3BlbihcIkdFVFwiLCBYTUxuYW1lLCBmYWxzZSk7XG4gICAgICAgIHhtbERvYy5zZW5kKFwiXCIpO1xuICAgICAgICByZXR1cm4geG1sRG9jLnJlc3BvbnNlWE1MO1xuICAgIH1cbiAgICAvLyBJRSA1IGFuZCBJRSA2XG4gICAgZWxzZSBpZiAoQWN0aXZlWE9iamVjdChcIk1pY3Jvc29mdC5YTUxET01cIikpIHtcbiAgICAgICAgeG1sRG9jID0gbmV3IEFjdGl2ZVhPYmplY3QoXCJNaWNyb3NvZnQuWE1MRE9NXCIpO1xuICAgICAgICB4bWxEb2MuYXN5bmMgPSBmYWxzZTtcbiAgICAgICAgeG1sRG9jLmxvYWQoWE1MbmFtZSk7XG4gICAgICAgIHJldHVybiB4bWxEb2M7XG4gICAgfVxuICAgIGFsZXJ0KFwiRXJyb3IgbG9hZGluZyBkb2N1bWVudCFcIik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0YWJMZWZ0KHRhYikge1xuICAgIGJ5SWQoJ3RhYjEnKS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIGJ5SWQoJ3RhYjInKS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIGJ5SWQoJ3RhYjMnKS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIGJ5SWQodGFiKS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICBpZiAodGFiICE9ICd0YWIzJykge1xuICAgICAgICBzdWJzZXQgPSB0YWIgPT0gJ3RhYjInO1xuICAgICAgICBzdW1tYXJ5SG9sZCA9IGZhbHNlO1xuICAgIH1cbiAgICBsZWZ0dGFiID0gdGFiO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGFiUmlnaHQodGFiKSB7XG4gICAgbGV0IHNlbGVjdCA9IGNscyA9PiB7XG4gICAgICAgIGxldCBwYW5lbCA9IGQzLnNlbGVjdChcIiNyaWdodHBhbmVsXCIpO1xuICAgICAgICByZXR1cm4gY2xzID8gcGFuZWwuYXR0cignY2xhc3MnLCBjbHMpIDogcGFuZWwuYXR0cignY2xhc3MnKTtcbiAgICB9O1xuICAgIGxldCBjbHMgPSBcInNpZGVwYW5lbCBjb250YWluZXIgY2xlYXJmaXhcIjtcbiAgICBsZXQgdG9nZ2xlUiA9ICgpID0+IHtcbiAgICAgICAgc2VsZWN0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbGV0IGV4cGFuZCA9IGNscyArICcgZXhwYW5kcGFuZWwnO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgPT09IGV4cGFuZCA/IGNscyA6IGV4cGFuZDtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBsZXQgdG9nZ2xlUkZ1bGwgPSAoKSA9PiB7XG4gICAgICAgIHNlbGVjdChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgIGxldCBleHBhbmQgPSBjbHMgKyAnIGV4cGFuZHBhbmVsZnVsbCc7XG4gICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSA9PT0gZXhwYW5kID8gY2xzIDogZXhwYW5kO1xuICAgICAgICAgICAgICAgfSk7XG4gICAgfTtcbiAgICBpZiAodGFiID09PSBcImJ0bk1vZGVsc1wiKSBzZWxlY3QoY2xzKTtcbiAgICBlbHNlIGlmICh0YWIgPT09IFwiYnRuU2V0eFwiKSByaWdodHRhYiA9PT0gXCJidG5TZXR4XCIgfHwgc2VsZWN0KCkgPT09IGNscyAmJiB0b2dnbGVSRnVsbCgpO1xuICAgIGVsc2UgaWYgKHRhYiA9PT0gXCJidG5SZXN1bHRzXCIpICFlc3RpbWF0ZWQgPyBzZWxlY3QoY2xzKSA6XG4gICAgICAgIHJpZ2h0dGFiID09PSBcImJ0blJlc3VsdHNcIiB8fCBzZWxlY3QoKSA9PT0gY2xzICYmIHRvZ2dsZVIoKTtcbiAgICByaWdodHRhYiA9IHRhYjtcbn1cblxuZXhwb3J0IGxldCBzdW1tYXJ5ID0ge2RhdGE6IFtdfTtcblxuZnVuY3Rpb24gdmFyU3VtbWFyeShkKSB7XG4gICAgbGV0IHQxID0gJ01lYW46LCBNZWRpYW46LCBNb3N0IEZyZXE6LCBPY2N1cnJlbmNlczosIE1lZGlhbiBGcmVxOiwgT2NjdXJyZW5jZXM6LCBMZWFzdCBGcmVxOiwgT2NjdXJyZW5jZXM6LCBTdGQgRGV2OiwgTWluaW11bTosIE1heGltdW06LCBJbnZhbGlkOiwgVmFsaWQ6LCBVbmlxdWVzOiwgSGVyZmluZGFobCcuc3BsaXQoJywgJyk7XG5cbiAgICBsZXQgcmludCA9IGQzLmZvcm1hdCgncicpO1xuICAgIGxldCBzdHIgPSAoeCwgcCkgPT4gKCt4KS50b1ByZWNpc2lvbihwIHx8IDQpLnRvU3RyaW5nKCk7XG4gICAgbGV0IHQyID0gcHJpdiAmJiBkLm1lYW5DSSA/XG4gICAgICAgIFtzdHIoZC5tZWFuLCAyKSArICcgKCcgKyBzdHIoZC5tZWFuQ0kubG93ZXJCb3VuZCwgMikgKyAnIC0gJyArIHN0cihkLm1lYW5DSS51cHBlckJvdW5kLCAyKSArICcpJyxcbiAgICAgICAgIHN0cihkLm1lZGlhbiksIGQubW9kZSwgcmludChkLmZyZXFtb2RlKSwgZC5taWQsIHJpbnQoZC5mcmVxbWlkKSwgZC5mZXdlc3QsIHJpbnQoZC5mcmVxZmV3ZXN0KSxcbiAgICAgICAgIHN0cihkLnNkKSwgc3RyKGQubWluKSwgc3RyKGQubWF4KSwgcmludChkLmludmFsaWQpLCByaW50KGQudmFsaWQpLCByaW50KGQudW5pcXVlcyksIHN0cihkLmhlcmZpbmRhaGwpXSA6XG4gICAgICAgIFtzdHIoZC5tZWFuKSwgc3RyKGQubWVkaWFuKSwgZC5tb2RlLCByaW50KGQuZnJlcW1vZGUpLCBkLm1pZCwgcmludChkLmZyZXFtaWQpLCBkLmZld2VzdCwgcmludChkLmZyZXFmZXdlc3QpLFxuICAgICAgICAgc3RyKGQuc2QpLCBzdHIoZC5taW4pLCBzdHIoZC5tYXgpLCByaW50KGQuaW52YWxpZCksIHJpbnQoZC52YWxpZCksIHJpbnQoZC51bmlxdWVzKSwgc3RyKGQuaGVyZmluZGFobCldO1xuXG4gICAgc3VtbWFyeS5kYXRhID0gW107XG4gICAgdDEuZm9yRWFjaCgoZSwgaSkgPT4gIXQyW2ldLmluY2x1ZGVzKCdOYU4nKSAmJiB0MltpXSAhPSAnTkEnICYmIHQyW2ldICE9ICcnICYmIHN1bW1hcnkuZGF0YS5wdXNoKFtlLCB0MltpXV0pKTtcblxuICAgIHN1bW1hcnkubmFtZSA9IGQubmFtZTtcbiAgICBzdW1tYXJ5LmxhYmwgPSBkLmxhYmw7XG5cbiAgICBkMy5zZWxlY3QoJyN0YWIzJylcbiAgICAgICAgLnNlbGVjdEFsbCgnc3ZnJylcbiAgICAgICAgLnJlbW92ZSgpO1xuXG4gICAgaWYgKCFkLnBsb3R0eXBlKVxuICAgICAgICByZXR1cm47XG4gICAgZC5wbG90dHlwZSA9PSAnY29udGludW91cycgPyBkZW5zaXR5KGQsICd2YXJTdW1tYXJ5JywgcHJpdikgOlxuICAgICAgICBkLnBsb3R0eXBlID09IFwiYmFyXCIgPyBiYXJzKGQsICd2YXJTdW1tYXJ5JywgcHJpdikgOlxuICAgICAgICBkMy5zZWxlY3QoXCIjdGFiM1wiKSAvLyBubyBncmFwaCB0byBkcmF3LCBidXQgc3RpbGwgbmVlZCB0byByZW1vdmUgcHJldmlvdXMgZ3JhcGhcbiAgICAgICAgLnNlbGVjdEFsbChcInN2Z1wiKVxuICAgICAgICAucmVtb3ZlKCk7XG59XG5cbmV4cG9ydCBsZXQgcG9wb3ZlckNvbnRlbnQgPSBkID0+IHtcbiAgICBpZihzd2FuZGl2ZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCB0ZXh0ID0gJyc7XG4gICAgbGV0IFtyaW50LCBwcmVjXSA9IFtkMy5mb3JtYXQoJ3InKSwgKHZhbCwgaW50KSA9PiAoK3ZhbCkudG9QcmVjaXNpb24oaW50KS50b1N0cmluZygpXTtcbiAgICBsZXQgZGl2ID0gKGZpZWxkLCBuYW1lLCB2YWwpID0+IHtcbiAgICAgICAgaWYgKGZpZWxkICE9ICdOQScpIHRleHQgKz0gYDxkaXYgY2xhc3M9J2Zvcm0tZ3JvdXAnPjxsYWJlbCBjbGFzcz0nY29sLXNtLTQgY29udHJvbC1sYWJlbCc+JHtuYW1lfTwvbGFiZWw+PGRpdiBjbGFzcz0nY29sLXNtLTYnPjxwIGNsYXNzPSdmb3JtLWNvbnRyb2wtc3RhdGljJz4ke3ZhbCB8fCBmaWVsZH08L3A+PC9kaXY+PC9kaXY+YDtcbiAgICB9O1xuICAgIGQubGFibCAhPSAnJyAmJiBkaXYoZC5sYWJsLCAnTGFiZWwnKTtcbiAgICBkaXYoZC5tZWFuLCAnTWVhbicsIHByaXYgJiYgZC5tZWFuQ0kgP1xuICAgICAgICBgJHtwcmVjKGQubWVhbiwgMil9ICgke3ByZWMoZC5tZWFuQ0kubG93ZXJCb3VuZCwgMil9IC0gJHtwcmVjKGQubWVhbkNJLnVwcGVyQm91bmQsIDIpfSlgIDpcbiAgICAgICAgcHJlYyhkLm1lYW4sIDQpKTtcbiAgICBkaXYoZC5tZWRpYW4sICdNZWRpYW4nLCBwcmVjKGQubWVkaWFuLCA0KSk7XG4gICAgZGl2KGQubW9kZSwgJ01vc3QgRnJlcScpO1xuICAgIGRpdihkLmZyZXFtb2RlLCAnT2NjdXJyZW5jZXMnLCAgcmludChkLmZyZXFtb2RlKSk7XG4gICAgZGl2KGQubWlkLCAnTWVkaWFuIEZyZXEnKTtcbiAgICBkaXYoZC5mcmVxbWlkLCAnT2NjdXJyZW5jZXMnLCByaW50KGQuZnJlcW1pZCkpO1xuICAgIGRpdihkLmZld2VzdCwgJ0xlYXN0IEZyZXEnKTtcbiAgICBkaXYoZC5mcmVxZmV3ZXN0LCAnT2NjdXJyZW5jZXMnLCByaW50KGQuZnJlcWZld2VzdCkpO1xuICAgIGRpdihkLnNkLCAnU3RhbmQgRGV2JywgcHJlYyhkLnNkLCA0KSk7XG4gICAgZGl2KGQubWF4LCAnTWF4aW11bScsIHByZWMoZC5tYXgsIDQpKTtcbiAgICBkaXYoZC5taW4sICdNaW5pbXVtJywgcHJlYyhkLm1pbiwgNCkpO1xuICAgIGRpdihkLmludmFsaWQsICdJbnZhbGlkJywgcmludChkLmludmFsaWQpKTtcbiAgICBkaXYoZC52YWxpZCwgJ1ZhbGlkJywgcmludChkLnZhbGlkKSk7XG4gICAgZGl2KGQudW5pcXVlcywgJ1VuaXF1ZXMnLCByaW50KGQudW5pcXVlcykpO1xuICAgIGRpdihkLmhlcmZpbmRhaGwsICdIZXJmaW5kYWhsJywgcHJlYyhkLmhlcmZpbmRhaGwsIDQpKTtcbiAgICByZXR1cm4gdGV4dDtcbn1cblxuZnVuY3Rpb24gcG9wdXBYKGQpIHtcbiAgICB2YXIgdHNmID0gZDMuZm9ybWF0KFwiLjRyXCIpO1xuICAgIHZhciByaW50ID0gZDMuZm9ybWF0KFwiclwiKTtcbiAgICAvL0NyZWF0ZSB0aGUgdG9vbHRpcCBsYWJlbFxuICAgIGQzLnNlbGVjdChcIiN0b29sdGlwXCIpXG4gICAgICAgIC5zdHlsZShcImxlZnRcIiwgdGVtcFggKyBcInB4XCIpXG4gICAgICAgIC5zdHlsZShcInRvcFwiLCB0ZW1wWSArIFwicHhcIilcbiAgICAgICAgLnNlbGVjdChcIiN0b29sdGlwdGV4dFwiKVxuICAgICAgICAuaHRtbChcIjxkaXYgY2xhc3M9J2Zvcm0tZ3JvdXAnPjxsYWJlbCBjbGFzcz0nY29sLXNtLTQgY29udHJvbC1sYWJlbCc+TWVhbjwvbGFiZWw+PGRpdiBjbGFzcz0nY29sLXNtLTYnPjxwIGNsYXNzPSdmb3JtLWNvbnRyb2wtc3RhdGljJz5cIiArIHRzZihkLm1lYW4pICsgXCI8L3A+PC9kaXY+PC9kaXY+XCIgK1xuICAgICAgICAgICAgXCI8ZGl2IGNsYXNzPSdmb3JtLWdyb3VwJz48bGFiZWwgY2xhc3M9J2NvbC1zbS00IGNvbnRyb2wtbGFiZWwnPk1lZGlhbjwvbGFiZWw+PGRpdiBjbGFzcz0nY29sLXNtLTYnPjxwIGNsYXNzPSdmb3JtLWNvbnRyb2wtc3RhdGljJz5cIiArIHRzZihkLm1lZGlhbikgKyBcIjwvcD48L2Rpdj48L2Rpdj5cIiArXG4gICAgICAgICAgICBcIjxkaXYgY2xhc3M9J2Zvcm0tZ3JvdXAnPjxsYWJlbCBjbGFzcz0nY29sLXNtLTQgY29udHJvbC1sYWJlbCc+TW9kZTwvbGFiZWw+PGRpdiBjbGFzcz0nY29sLXNtLTYnPjxwIGNsYXNzPSdmb3JtLWNvbnRyb2wtc3RhdGljJz5cIiArIGQubW9kZSArIFwiPC9wPjwvZGl2PjwvZGl2PlwiICtcbiAgICAgICAgICAgIFwiPGRpdiBjbGFzcz0nZm9ybS1ncm91cCc+PGxhYmVsIGNsYXNzPSdjb2wtc20tNCBjb250cm9sLWxhYmVsJz5TdGFuZCBEZXY8L2xhYmVsPjxkaXYgY2xhc3M9J2NvbC1zbS02Jz48cCBjbGFzcz0nZm9ybS1jb250cm9sLXN0YXRpYyc+XCIgKyB0c2YoZC5zZCkgKyBcIjwvcD48L2Rpdj48L2Rpdj5cIiArXG4gICAgICAgICAgICBcIjxkaXYgY2xhc3M9J2Zvcm0tZ3JvdXAnPjxsYWJlbCBjbGFzcz0nY29sLXNtLTQgY29udHJvbC1sYWJlbCc+TWF4aW11bTwvbGFiZWw+PGRpdiBjbGFzcz0nY29sLXNtLTYnPjxwIGNsYXNzPSdmb3JtLWNvbnRyb2wtc3RhdGljJz5cIiArIHRzZihkLm1heCkgKyBcIjwvcD48L2Rpdj48L2Rpdj5cIiArXG4gICAgICAgICAgICBcIjxkaXYgY2xhc3M9J2Zvcm0tZ3JvdXAnPjxsYWJlbCBjbGFzcz0nY29sLXNtLTQgY29udHJvbC1sYWJlbCc+TWluaW11bTwvbGFiZWw+PGRpdiBjbGFzcz0nY29sLXNtLTYnPjxwIGNsYXNzPSdmb3JtLWNvbnRyb2wtc3RhdGljJz5cIiArIHRzZihkLm1pbikgKyBcIjwvcD48L2Rpdj48L2Rpdj5cIiArXG4gICAgICAgICAgICBcIjxkaXYgY2xhc3M9J2Zvcm0tZ3JvdXAnPjxsYWJlbCBjbGFzcz0nY29sLXNtLTQgY29udHJvbC1sYWJlbCc+VmFsaWQ8L2xhYmVsPjxkaXYgY2xhc3M9J2NvbC1zbS02Jz48cCBjbGFzcz0nZm9ybS1jb250cm9sLXN0YXRpYyc+XCIgKyByaW50KGQudmFsaWQpICsgXCI8L3A+PC9kaXY+PC9kaXY+XCIgK1xuICAgICAgICAgICAgXCI8ZGl2IGNsYXNzPSdmb3JtLWdyb3VwJz48bGFiZWwgY2xhc3M9J2NvbC1zbS00IGNvbnRyb2wtbGFiZWwnPkludmFsaWQ8L2xhYmVsPjxkaXYgY2xhc3M9J2NvbC1zbS02Jz48cCBjbGFzcz0nZm9ybS1jb250cm9sLXN0YXRpYyc+XCIgKyByaW50KGQuaW52YWxpZCkgKyBcIjwvcD48L2Rpdj48L2Rpdj5cIlxuICAgICAgICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFuZWxQbG90cygpIHtcbiAgICBpZihkM21fbW9kZSkge1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYnRuU3Vic2V0JykuY2xhc3NMaXN0LmFkZCgnbm9zaG93Jyk7XG4gICAgfVxuICAgIC8vIGJ1aWxkIGFycmF5cyBmcm9tIG5vZGVzIGluIG1haW5cbiAgICBsZXQgdmFycyA9IFtdO1xuICAgIGxldCBpZHMgPSBbXTtcbiAgICBub2Rlcy5mb3JFYWNoKG4gPT4ge1xuICAgICAgICB2YXJzLnB1c2gobi5uYW1lLnJlcGxhY2UoL1xcKHxcXCkvZywgJycpKTtcbiAgICAgICAgaWRzLnB1c2gobi5pZCk7XG4gICAgfSk7XG5cbiAgICAvL3JlbW92ZSBhbGwgcGxvdHMsIGNvdWxkIGJlIHNtYXJ0ZXIgaGVyZVxuICAgIGQzLnNlbGVjdCgnI3NldHhMZWZ0Jykuc2VsZWN0QWxsKCdzdmcnKS5yZW1vdmUoKTtcbiAgICBkMy5zZWxlY3QoJyN0YWIyJykuc2VsZWN0QWxsKCdzdmcnKS5yZW1vdmUoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYoYWxsTm9kZXNbaWRzW2ldXS52YWxpZD09MCkgLy8gdGhpcyB3YXMgYSBzaWxlbnQgZXJyb3IuLi4gdmVyeSBmcnVzdHJhdGluZy4uLlxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGxldCBub2RlID0gYWxsTm9kZXNbaWRzW2ldXTtcbiAgICAgICAgbm9kZS5zZXR4cGxvdCA9IGZhbHNlO1xuICAgICAgICBub2RlLnN1YnNldHBsb3QgPSBmYWxzZTtcbiAgICAgICAgaWYgKG5vZGUucGxvdHR5cGUgPT09IFwiY29udGludW91c1wiICYgbm9kZS5zZXR4cGxvdCA9PSBmYWxzZSkge1xuICAgICAgICAgICAgbm9kZS5zZXR4cGxvdCA9IHRydWU7XG4gICAgICAgICAgICBkZW5zaXR5KG5vZGUsIGRpdiA9IFwic2V0eExlZnRcIiwgcHJpdik7XG4gICAgICAgICAgICBub2RlLnN1YnNldHBsb3QgPSB0cnVlO1xuICAgICAgICAgICAgZGVuc2l0eShub2RlLCBkaXYgPSBcInN1YnNldFwiLCBwcml2KTtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlLnBsb3R0eXBlID09PSBcImJhclwiICYgbm9kZS5zZXR4cGxvdCA9PSBmYWxzZSkge1xuICAgICAgICAgICAgbm9kZS5zZXR4cGxvdCA9IHRydWU7XG4gICAgICAgICAgICBiYXJzKG5vZGUsIGRpdiA9IFwic2V0eExlZnRcIiwgcHJpdik7XG4gICAgICAgICAgICBub2RlLnN1YnNldHBsb3QgPSB0cnVlO1xuICAgICAgICAgICAgYmFyc1N1YnNldChub2RlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgICAgICBkMy5zZWxlY3QoXCIjc2V0eExlZnRcIikuc2VsZWN0QWxsKFwic3ZnXCIpXG4gICAgICAgIC5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpO1xuICAgICAgICAgICAgICB2YXIgcmVnc3RyID0gLyguKylfc2V0eExlZnRfKFxcZCspLztcbiAgICAgICAgICAgICAgdmFyIG15bmFtZSA9IHJlZ3N0ci5leGVjKHRoaXMuaWQpO1xuICAgICAgICAgICAgICB2YXIgbm9kZWlkID0gbXluYW1lWzJdO1xuICAgICAgICAgICAgICBteW5hbWUgPSBteW5hbWVbMV07XG4gICAgICAgICAgICAgIGlmICghdmFycy5pbmNsdWRlcyhteW5hbWUpKSB7XG4gICAgICAgICAgICAgIGFsbE5vZGVzW25vZGVpZF0uc2V0eHBsb3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgbGV0IHRlbXAgPSBcIiNcIi5jb25jYXQobXluYW1lLCBcIl9zZXR4TGVmdF9cIiwgbm9kZWlkKTtcbiAgICAgICAgICAgICAgZDMuc2VsZWN0KHRlbXApXG4gICAgICAgICAgICAgIC5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgYWxsTm9kZXNbbm9kZWlkXS5zdWJzZXRwbG90ID0gZmFsc2U7XG4gICAgICAgICAgICAgIHRlbXAgPSBcIiNcIi5jb25jYXQobXluYW1lLCBcIl90YWIyX1wiLCBub2RlaWQpO1xuICAgICAgICAgICAgICBkMy5zZWxlY3QodGVtcClcbiAgICAgICAgICAgICAgLnJlbW92ZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xufVxuXG5cbi8vIGVhc3kgZnVuY3Rpb25zIHRvIGNvbGxhcHNlIHBhbmVscyB0byBiYXNlXG5mdW5jdGlvbiByaWdodHBhbmVsTWVkaXVtKCkge1xuICAgIGQzLnNlbGVjdChcIiNyaWdodHBhbmVsXCIpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJzaWRlcGFuZWwgY29udGFpbmVyIGNsZWFyZml4XCIpO1xufVxuXG5mdW5jdGlvbiBsZWZ0cGFuZWxNZWRpdW0oKSB7XG4gICAgZDMuc2VsZWN0KFwiI2xlZnRwYW5lbFwiKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwic2lkZXBhbmVsIGNvbnRhaW5lciBjbGVhcmZpeFwiKTtcbn1cblxuLy8gY29udmVydHMgY29sb3IgY29kZXNcbmV4cG9ydCBsZXQgaGV4VG9SZ2JhID0gaGV4ID0+IHtcbiAgICBsZXQgaW50ID0gcGFyc2VJbnQoaGV4LnJlcGxhY2UoJyMnLCAnJyksIDE2KTtcbiAgICByZXR1cm4gYHJnYmEoJHtbKGludCA+PiAxNikgJiAyNTUsIChpbnQgPj4gOCkgJiAyNTUsIGludCAmIDI1NSwgJzAuNSddLmpvaW4oJywnKX0pYDtcbn07XG5cbi8vIHRha2VzIG5vZGUgYW5kIGNvbG9yIGFuZCB1cGRhdGVzIHpwYXJhbXNcbmZ1bmN0aW9uIHNldENvbG9ycyhuLCBjKSB7XG4gICAgaWYgKG4uc3Ryb2tlV2lkdGggPT0gJzEnKSB7XG4gICAgICAgIGlmIChjID09IGdyMUNvbG9yKXtcbiAgICAgICAgICAgIHZhciB0ZW1waW5kZXggPSB6cGFyYW1zLnpncm91cDEuaW5kZXhPZihuLm5hbWUpO1xuICAgICAgICAgICAgaWYgKHRlbXBpbmRleCA+IC0xKXtcbiAgICAgICAgICAgICAgICBuLmdyb3VwMSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHpwYXJhbXMuemdyb3VwMS5zcGxpY2UodGVtcGluZGV4LDEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuLmdyb3VwMSA9IHRydWU7XG4gICAgICAgICAgICAgICAgenBhcmFtcy56Z3JvdXAxLnB1c2gobi5uYW1lKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoYyA9PSBncjJDb2xvcil7XG4gICAgICAgICAgICB2YXIgdGVtcGluZGV4ID0genBhcmFtcy56Z3JvdXAyLmluZGV4T2Yobi5uYW1lKTtcbiAgICAgICAgICAgIGlmICh0ZW1waW5kZXggPiAtMSl7XG4gICAgICAgICAgICAgICAgbi5ncm91cDIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB6cGFyYW1zLnpncm91cDIuc3BsaWNlKHRlbXBpbmRleCwxKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbi5ncm91cDIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHpwYXJhbXMuemdyb3VwMi5wdXNoKG4ubmFtZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBhZGRpbmcgdGltZSwgY3MsIGR2LCBub20gdG8gbm9kZSB3aXRoIG5vIHN0cm9rZVxuICAgICAgICBuLnN0cm9rZVdpZHRoID0gJzQnO1xuICAgICAgICBuLnN0cm9rZUNvbG9yID0gYztcbiAgICAgICAgbi5ub2RlQ29sID0gdGFnZ2VkQ29sb3I7XG4gICAgICAgIGxldCBwdXNoID0gKFtjb2xvciwga2V5XSkgPT4ge1xuICAgICAgICAgICAgaWYgKGNvbG9yICE9IGMpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgenBhcmFtc1trZXldID0gQXJyYXkuaXNBcnJheSh6cGFyYW1zW2tleV0pID8genBhcmFtc1trZXldIDogW107XG4gICAgICAgICAgICB6cGFyYW1zW2tleV0ucHVzaChuLm5hbWUpO1xuICAgICAgICAgICAgaWYgKGtleSA9PSAnem5vbScpIHtcbiAgICAgICAgICAgICAgICBmaW5kTm9kZUluZGV4KG4ubmFtZSwgdHJ1ZSkubmF0dXJlID0gXCJub21pbmFsXCI7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtKG4ubmFtZSwgdCA9IG51bGwsIHR5cGVUcmFuc2Zvcm0gPSB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrZXkgPT0gJ3pkdicpeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgZ3JvdXAgbWVtYmVyc2hpcHMgZnJvbSBkdidzXG4gICAgICAgICAgICAgICAgaWYobi5ncm91cDEpe1xuICAgICAgICAgICAgICAgICAgICBuLmdyb3VwMSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB6cGFyYW1zLnpncm91cDEuc3BsaWNlKHpwYXJhbXMuemdyb3VwMS5pbmRleE9mKG4ubmFtZSksMSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZihuLmdyb3VwMil7XG4gICAgICAgICAgICAgICAgICAgIG4uZ3JvdXAyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHpwYXJhbXMuemdyb3VwMi5zcGxpY2UoenBhcmFtcy56Z3JvdXAyLmluZGV4T2Yobi5uYW1lKSwxKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBbW2R2Q29sb3IsICd6ZHYnXSwgW2NzQ29sb3IsICd6Y3Jvc3MnXSwgW3RpbWVDb2xvciwgJ3p0aW1lJ10sIFtub21Db2xvciwgJ3pub20nXV0uZm9yRWFjaChwdXNoKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAobi5zdHJva2VXaWR0aCA9PSAnNCcpIHtcbiAgICAgICAgaWYgKGMgPT0gbi5zdHJva2VDb2xvcikgeyAvLyBkZXNlbGVjdGluZyB0aW1lLCBjcywgZHYsIG5vbVxuICAgICAgICAgICAgbi5zdHJva2VXaWR0aCA9ICcxJztcbiAgICAgICAgICAgIG4uc3Ryb2tlQ29sb3IgPSBzZWxWYXJDb2xvcjtcbiAgICAgICAgICAgIG4ubm9kZUNvbCA9IGNvbG9ycyhuLmlkKTtcbiAgICAgICAgICAgIHNwbGljZShjLCBuLm5hbWUsIFtkdkNvbG9yLCAnemR2J10sIFtjc0NvbG9yLCAnemNyb3NzJ10sIFt0aW1lQ29sb3IsICd6dGltZSddLCBbbm9tQ29sb3IsICd6bm9tJ10pO1xuICAgICAgICAgICAgaWYgKG5vbUNvbG9yID09IGMgJiYgenBhcmFtcy56bm9tLmluY2x1ZGVzKG4ubmFtZSkpIHtcbiAgICAgICAgICAgICAgICBmaW5kTm9kZUluZGV4KG4ubmFtZSwgdHJ1ZSkubmF0dXJlID0gZmluZE5vZGVJbmRleChuLm5hbWUsIHRydWUpLmRlZmF1bHROYXR1cmU7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtKG4ubmFtZSwgdCA9IG51bGwsIHR5cGVUcmFuc2Zvcm0gPSB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHsgLy8gZGVzZWxlY3RpbmcgdGltZSwgY3MsIGR2LCBub20gQU5EIGNoYW5naW5nIGl0IHRvIHRpbWUsIGNzLCBkdiwgbm9tXG4gICAgICAgICAgICBzcGxpY2Uobi5zdHJva2VDb2xvciwgbi5uYW1lLCBbZHZDb2xvciwgJ3pkdiddLCBbY3NDb2xvciwgJ3pjcm9zcyddLCBbdGltZUNvbG9yLCAnenRpbWUnXSwgW25vbUNvbG9yLCAnem5vbSddKTtcbiAgICAgICAgICAgIGlmIChub21Db2xvciA9PSBuLnN0cm9rZUNvbG9yICYmIHpwYXJhbXMuem5vbS5pbmNsdWRlcyhuLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgZmluZE5vZGVJbmRleChuLm5hbWUsIHRydWUpLm5hdHVyZSA9IGZpbmROb2RlSW5kZXgobi5uYW1lLCB0cnVlKS5kZWZhdWx0TmF0dXJlO1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybShuLm5hbWUsIHQgPSBudWxsLCB0eXBlVHJhbnNmb3JtID0gdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuLnN0cm9rZUNvbG9yID0gYztcbiAgICAgICAgICAgIGlmIChkdkNvbG9yID09IGMpe1xuICAgICAgICAgICAgICAgIHZhciBkdm5hbWUgPSBuLm5hbWU7XG4gICAgICAgICAgICAgICAgenBhcmFtcy56ZHYucHVzaChkdm5hbWUpO1xuICAgICAgICAgICAgICAgIGlmKG4uZ3JvdXAxKXsgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgZ3JvdXAgbWVtYmVyc2hpcHMgZnJvbSBkdidzXG4gICAgICAgICAgICAgICAgICAgIG5ncm91cDEgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgenBhcmFtcy56Z3JvdXAxLnNwbGljZSh6cGFyYW1zLnpncm91cDEuaW5kZXhPZihkdm5hbWUpLDEpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYobi5ncm91cDIpe1xuICAgICAgICAgICAgICAgICAgICBuZ3JvdXAyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHpwYXJhbXMuemdyb3VwMi5zcGxpY2UoenBhcmFtcy56Z3JvdXAyLmluZGV4T2YoZHZuYW1lKSwxKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY3NDb2xvciA9PSBjKSB6cGFyYW1zLnpjcm9zcy5wdXNoKG4ubmFtZSk7XG4gICAgICAgICAgICBlbHNlIGlmICh0aW1lQ29sb3IgPT0gYykgenBhcmFtcy56dGltZS5wdXNoKG4ubmFtZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChub21Db2xvciA9PSBjKSB7XG4gICAgICAgICAgICAgICAgenBhcmFtcy56bm9tLnB1c2gobi5uYW1lKTtcbiAgICAgICAgICAgICAgICBmaW5kTm9kZUluZGV4KG4ubmFtZSwgdHJ1ZSkubmF0dXJlID0gXCJub21pbmFsXCI7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtKG4ubmFtZSwgdCA9IG51bGwsIHR5cGVUcmFuc2Zvcm0gPSB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJvcmRlclN0YXRlKCkge1xuICAgIHpwYXJhbXMuemR2Lmxlbmd0aCA+IDAgP1xuICAgICAgICAkKCcjZHZCdXR0b24gLnJlY3RDb2xvciBzdmcgY2lyY2xlJykuYXR0cignc3Ryb2tlJywgZHZDb2xvcikgOlxuICAgICAgICAkKCcjZHZCdXR0b24nKS5jc3MoJ2JvcmRlci1jb2xvcicsICcjY2NjJyk7XG4gICAgenBhcmFtcy56Y3Jvc3MubGVuZ3RoID4gMCA/XG4gICAgICAgICQoJyNjc0J1dHRvbiAucmVjdENvbG9yIHN2ZyBjaXJjbGUnKS5hdHRyKCdzdHJva2UnLCBjc0NvbG9yKSA6XG4gICAgICAgICQoJyNjc0J1dHRvbicpLmNzcygnYm9yZGVyLWNvbG9yJywgJyNjY2MnKTtcbiAgICB6cGFyYW1zLnp0aW1lLmxlbmd0aCA+IDAgP1xuICAgICAgICAkKCcjdGltZUJ1dHRvbiAucmVjdENvbG9yIHN2ZyBjaXJjbGUnKS5hdHRyKCdzdHJva2UnLCB0aW1lQ29sb3IpIDpcbiAgICAgICAgJCgnI3RpbWVCdXR0b24nKS5jc3MoJ2JvcmRlci1jb2xvcicsICcjY2NjJyk7XG4gICAgenBhcmFtcy56bm9tLmxlbmd0aCA+IDAgP1xuICAgICAgICAkKCcjbm9tQnV0dG9uIC5yZWN0Q29sb3Igc3ZnIGNpcmNsZScpLmF0dHIoJ3N0cm9rZScsIG5vbUNvbG9yKSA6XG4gICAgICAgICQoJyNub21CdXR0b24nKS5jc3MoJ2JvcmRlci1jb2xvcicsICcjY2NjJyk7XG4gICAgenBhcmFtcy56Z3JvdXAxLmxlbmd0aCA+IDAgP1xuICAgICAgICAkKCcjZ3IxQnV0dG9uIC5yZWN0Q29sb3Igc3ZnIGNpcmNsZScpLmF0dHIoJ3N0cm9rZScsIGdyMUNvbG9yKS5hdHRyKCdmaWxsJywgZ3IxQ29sb3IpLmF0dHIoJ2ZpbGwtb3BhY2l0eScsIDAuNikuYXR0cignc3Ryb2tlLW9wYWNpdHknLCAwKSA6XG4gICAgICAgICQoJyNncjFCdXR0b24nKS5jc3MoJ2JvcmRlci1jb2xvcicsICcjY2NjJyk7XG4gICAgenBhcmFtcy56Z3JvdXAyLmxlbmd0aCA+IDAgP1xuICAgICAgICAkKCcjZ3IyQnV0dG9uIC5yZWN0Q29sb3Igc3ZnIGNpcmNsZScpLmF0dHIoJ3N0cm9rZScsIGdyMkNvbG9yKS5hdHRyKCdmaWxsJywgZ3IyQ29sb3IpLmF0dHIoJ2ZpbGwtb3BhY2l0eScsIDAuNikuYXR0cignc3Ryb2tlLW9wYWNpdHknLCAwKSA6XG4gICAgICAgICQoJyNncjJCdXR0b24nKS5jc3MoJ2JvcmRlci1jb2xvcicsICcjY2NjJyk7XG59XG5cbi8vIHNtYWxsIGFwcGVhcmFuY2UgcmVzZXRzLCBidXQgcGVyaGFwcyB0aGlzIHdpbGwgYmVjb21lIGEgaGFyZCByZXNldCBiYWNrIHRvIGFsbCBvcmlnaW5hbCBhbGxOb2RlIHZhbHVlcz9cbmZ1bmN0aW9uIG5vZGVSZXNldChuKSB7XG4gICAgbi5zdHJva2VDb2xvciA9IHNlbFZhckNvbG9yO1xuICAgIG4uc3Ryb2tlV2lkdGggPSBcIjFcIjtcbiAgICBuLm5vZGVDb2wgPSBuLmJhc2VDb2w7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdWJzZXRTZWxlY3QoYnRuKSB7XG4gICAgaWYgKGRhdGF1cmwpXG4gICAgICAgIHpwYXJhbXMuemRhdGF1cmwgPSBkYXRhdXJsO1xuICAgIGlmIChwcm9kdWN0aW9uICYmIHpwYXJhbXMuenNlc3Npb25pZCA9PSBcIlwiKSB7XG4gICAgICAgIGFsZXJ0KFwiV2FybmluZzogRGF0YSBkb3dubG9hZCBpcyBub3QgY29tcGxldGUuIFRyeSBhZ2FpbiBzb29uLlwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB6cGFyYW1zLnp2YXJzID0gW107XG4gICAgenBhcmFtcy56cGxvdCA9IFtdO1xuICAgIHZhciBzdWJzZXRFbXB0eSA9IHRydWU7XG4gICAgLy8gaXMgdGhpcyB0aGUgc2FtZSBhcyB6UG9wKCk/XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBub2Rlcy5sZW5ndGg7IGorKykgeyAvLyBwb3B1bGF0ZSB6dmFycyBhbmQgenN1YnNldCBhcnJheXNcbiAgICAgICAgenBhcmFtcy56dmFycy5wdXNoKG5vZGVzW2pdLm5hbWUpO1xuICAgICAgICB2YXIgdGVtcCA9IG5vZGVzW2pdLmlkO1xuICAgICAgICB6cGFyYW1zLnpzdWJzZXRbal0gPSBhbGxOb2Rlc1t0ZW1wXS5zdWJzZXRyYW5nZTtcbiAgICAgICAgaWYgKHpwYXJhbXMuenN1YnNldFtqXS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpZiAoenBhcmFtcy56c3Vic2V0W2pdWzBdICE9IFwiXCIpXG4gICAgICAgICAgICAgICAgenBhcmFtcy56c3Vic2V0W2pdWzBdID0gTnVtYmVyKHpwYXJhbXMuenN1YnNldFtqXVswXSk7XG4gICAgICAgICAgICBpZiAoenBhcmFtcy56c3Vic2V0W2pdWzFdICE9IFwiXCIpXG4gICAgICAgICAgICAgICAgenBhcmFtcy56c3Vic2V0W2pdWzFdID0gTnVtYmVyKHpwYXJhbXMuenN1YnNldFtqXVsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgenBhcmFtcy56cGxvdC5wdXNoKGFsbE5vZGVzW3RlbXBdLnBsb3R0eXBlKTtcbiAgICAgICAgaWYgKHpwYXJhbXMuenN1YnNldFtqXVsxXSAhPSBcIlwiKVxuICAgICAgICAgICAgc3Vic2V0RW1wdHkgPSBmYWxzZTsgLy8gb25seSBuZWVkIHRvIGNoZWNrIG9uZVxuICAgIH1cblxuICAgIGlmIChzdWJzZXRFbXB0eSA9PSB0cnVlKSB7XG4gICAgICAgIGFsZXJ0KFwiV2FybmluZzogTm8gbmV3IHN1YnNldCBzZWxlY3RlZC5cIik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgb3V0dHlwZXMgPSBbXTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGFsbE5vZGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIG91dHR5cGVzLnB1c2goe1xuICAgICAgICAgICAgdmFybmFtZXNUeXBlczogYWxsTm9kZXNbal0ubmFtZSxcbiAgICAgICAgICAgIG5hdHVyZTogYWxsTm9kZXNbal0ubmF0dXJlLFxuICAgICAgICAgICAgbnVtY2hhcjogYWxsTm9kZXNbal0ubnVtY2hhcixcbiAgICAgICAgICAgIGJpbmFyeTogYWxsTm9kZXNbal0uYmluYXJ5LFxuICAgICAgICAgICAgaW50ZXJ2YWw6IGFsbE5vZGVzW2pdLmludGVydmFsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBzdWJzZXRzdHVmZiA9IHtcbiAgICAgICAgemRhdGF1cmw6IHpwYXJhbXMuemRhdGF1cmwsXG4gICAgICAgIHp2YXJzOiB6cGFyYW1zLnp2YXJzLFxuICAgICAgICB6c3Vic2V0OiB6cGFyYW1zLnpzdWJzZXQsXG4gICAgICAgIHpzZXNzaW9uaWQ6IHpwYXJhbXMuenNlc3Npb25pZCxcbiAgICAgICAgenBsb3Q6IHpwYXJhbXMuenBsb3QsXG4gICAgICAgIGNhbGxIaXN0b3J5OiBjYWxsSGlzdG9yeSxcbiAgICAgICAgdHlwZVN0dWZmOiBvdXR0eXBlc1xuICAgIH07XG5cbiAgICB2YXIganNvbm91dCA9IEpTT04uc3RyaW5naWZ5KHN1YnNldHN0dWZmKTtcbiAgICB2YXIgdXJsY2FsbCA9IHJhcHBVUkwgKyBcInN1YnNldGFwcFwiO1xuICAgIHZhciBzb2xhanNvbm91dCA9IFwic29sYUpTT049XCIgKyBqc29ub3V0O1xuICAgIGNkYihcInVybGNhbGwgb3V0OiBcIiwgdXJsY2FsbCk7XG4gICAgY2RiKFwiUE9TVCBvdXQ6IFwiLCBzb2xhanNvbm91dCk7XG5cbiAgICBmdW5jdGlvbiBzdWJzZXRTZWxlY3RTdWNjZXNzKGJ0biwganNvbikge1xuICAgICAgICBzZWxlY3RMYWRkYS5zdG9wKCk7IC8vIHN0b3AgbW90aW9uXG4gICAgICAgICQoXCIjYnRuVmFyaWFibGVzXCIpLnRyaWdnZXIoXCJjbGlja1wiKTsgLy8gcHJvZ3JhbW1hdGljIGNsaWNrc1xuICAgICAgICAkKFwiI2J0bk1vZGVsc1wiKS50cmlnZ2VyKFwiY2xpY2tcIik7XG5cbiAgICAgICAgdmFyIGdyYXlPdXRzID0gW107XG4gICAgICAgIHZhciByQ2FsbCA9IFtdO1xuICAgICAgICByQ2FsbFswXSA9IGpzb24uY2FsbDtcblxuICAgICAgICAvLyBzdG9yZSBjb250ZW50cyBvZiB0aGUgcHJlLXN1YnNldCBzcGFjZVxuICAgICAgICB6UG9wKCk7XG4gICAgICAgIHZhciBteU5vZGVzID0galF1ZXJ5LmV4dGVuZCh0cnVlLCBbXSwgYWxsTm9kZXMpO1xuICAgICAgICB2YXIgbXlQYXJhbXMgPSBqUXVlcnkuZXh0ZW5kKHRydWUsIHt9LCB6cGFyYW1zKTtcbiAgICAgICAgdmFyIG15VHJhbnMgPSBqUXVlcnkuZXh0ZW5kKHRydWUsIFtdLCB0cmFucyk7XG4gICAgICAgIHZhciBteUZvcmNlID0galF1ZXJ5LmV4dGVuZCh0cnVlLCBbXSwgZm9yY2V0b2dnbGUpO1xuICAgICAgICB2YXIgbXlQcmVwcm9jZXNzID0galF1ZXJ5LmV4dGVuZCh0cnVlLCB7fSwgcHJlcHJvY2Vzcyk7XG4gICAgICAgIHZhciBteUxvZyA9IGpRdWVyeS5leHRlbmQodHJ1ZSwgW10sIGxvZ0FycmF5KTtcbiAgICAgICAgdmFyIG15SGlzdG9yeSA9IGpRdWVyeS5leHRlbmQodHJ1ZSwgW10sIGNhbGxIaXN0b3J5KTtcblxuICAgICAgICBzcGFjZXNbbXlzcGFjZV0gPSB7XG4gICAgICAgICAgICBcImFsbE5vZGVzXCI6IG15Tm9kZXMsXG4gICAgICAgICAgICBcInpwYXJhbXNcIjogbXlQYXJhbXMsXG4gICAgICAgICAgICBcInRyYW5zXCI6IG15VHJhbnMsXG4gICAgICAgICAgICBcImZvcmNlXCI6IG15Rm9yY2UsXG4gICAgICAgICAgICBcInByZXByb2Nlc3NcIjogbXlQcmVwcm9jZXNzLFxuICAgICAgICAgICAgXCJsb2dBcnJheVwiOiBteUxvZyxcbiAgICAgICAgICAgIFwiY2FsbEhpc3RvcnlcIjogbXlIaXN0b3J5XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gcmVtb3ZlIHByZS1zdWJzZXQgc3ZnXG4gICAgICAgIHZhciBzZWxlY3RNZSA9IFwiI21cIi5jb25jYXQobXlzcGFjZSk7XG4gICAgICAgIGQzLnNlbGVjdChzZWxlY3RNZSkuYXR0cignY2xhc3MnLCAnaXRlbScpO1xuICAgICAgICBzZWxlY3RNZSA9IFwiI3doaXRlc3BhY2VcIi5jb25jYXQobXlzcGFjZSk7XG4gICAgICAgIGQzLnNlbGVjdChzZWxlY3RNZSkucmVtb3ZlKCk7XG5cbiAgICAgICAgbXlzcGFjZSA9IHNwYWNlcy5sZW5ndGg7XG4gICAgICAgIGNhbGxIaXN0b3J5LnB1c2goe1xuICAgICAgICAgICAgZnVuYzogXCJzdWJzZXRcIixcbiAgICAgICAgICAgIHp2YXJzOiBqUXVlcnkuZXh0ZW5kKHRydWUsIFtdLCB6cGFyYW1zLnp2YXJzKSxcbiAgICAgICAgICAgIHpzdWJzZXQ6IGpRdWVyeS5leHRlbmQodHJ1ZSwgW10sIHpwYXJhbXMuenN1YnNldCksXG4gICAgICAgICAgICB6cGxvdDogalF1ZXJ5LmV4dGVuZCh0cnVlLCBbXSwgenBhcmFtcy56cGxvdClcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gdGhpcyBpcyB0byBiZSB1c2VkIHRvIGdyYXkgb3V0IGFuZCByZW1vdmUgbGlzdGVuZXJzIGZvciB2YXJpYWJsZXMgdGhhdCBoYXZlIGJlZW4gc3Vic2V0dGVkIG91dCBvZiB0aGUgZGF0YVxuICAgICAgICBmdW5jdGlvbiB2YXJPdXQodikge1xuICAgICAgICAgICAgLy8gaWYgaW4gbm9kZXMsIHJlbW92ZSBncmF5IG91dCBpbiBsZWZ0IHBhbmVsXG4gICAgICAgICAgICAvLyBtYWtlIHVuY2xpY2thYmxlIGluIGxlZnQgcGFuZWxcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBzZWxlY3RNZSA9IHZbaV0ucmVwbGFjZSgvXFxXL2csIFwiX1wiKTtcbiAgICAgICAgICAgICAgICBieUlkKHNlbGVjdE1lKS5zdHlsZS5jb2xvciA9IGhleFRvUmdiYShncmF5Q29sb3IpO1xuICAgICAgICAgICAgICAgIHNlbGVjdE1lID0gXCJwI1wiLmNvbmNhdChzZWxlY3RNZSk7XG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KHNlbGVjdE1lKVxuICAgICAgICAgICAgICAgICAgICAub24oXCJjbGlja1wiLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNob3dMb2coJ3N1YnNldCcsIHJDYWxsKTtcbiAgICAgICAgcmVXcml0ZUxvZygpO1xuXG4gICAgICAgIGQzLnNlbGVjdChcIiNpbm5lcmNhcm91c2VsXCIpXG4gICAgICAgICAgICAuYXBwZW5kKCdkaXYnKVxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2l0ZW0gYWN0aXZlJylcbiAgICAgICAgICAgIC5hdHRyKCdpZCcsICgpID0+IFwibVwiLmNvbmNhdChteXNwYWNlLnRvU3RyaW5nKCkpKVxuICAgICAgICAgICAgLmFwcGVuZCgnc3ZnJylcbiAgICAgICAgICAgIC5hdHRyKCdpZCcsICd3aGl0ZXNwYWNlJyk7XG4gICAgICAgIHN2ZyA9IGQzLnNlbGVjdChcIiN3aGl0ZXNwYWNlXCIpO1xuXG4gICAgICAgIGQzLmpzb24oanNvbi51cmwsIGZ1bmN0aW9uKGVycm9yLCBqc29uKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3Ipe1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGpzb25kYXRhID0gZ2V0VmFyaWFibGVEYXRhKGpzb24pO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4ganNvbmRhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgbXlJbmRleCA9IGZpbmROb2RlSW5kZXgoa2V5KTtcblxuICAgICAgICAgICAgICAgIGFsbE5vZGVzW215SW5kZXhdLnBsb3R4ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGFsbE5vZGVzW215SW5kZXhdLnBsb3R5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGFsbE5vZGVzW215SW5kZXhdLnBsb3R2YWx1ZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgYWxsTm9kZXNbbXlJbmRleF0ucGxvdHR5cGUgPSBcIlwiO1xuXG4gICAgICAgICAgICAgICAgalF1ZXJ5LmV4dGVuZCh0cnVlLCBhbGxOb2Rlc1tteUluZGV4XSwganNvbmRhdGFba2V5XSk7XG4gICAgICAgICAgICAgICAgYWxsTm9kZXNbbXlJbmRleF0uc3Vic2V0cGxvdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGFsbE5vZGVzW215SW5kZXhdLnN1YnNldHJhbmdlID0gW1wiXCIsIFwiXCJdO1xuICAgICAgICAgICAgICAgIGFsbE5vZGVzW215SW5kZXhdLnNldHhwbG90ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYWxsTm9kZXNbbXlJbmRleF0uc2V0eHZhbHMgPSBbXCJcIiwgXCJcIl07XG5cbiAgICAgICAgICAgICAgICBpZiAoYWxsTm9kZXNbbXlJbmRleF0udmFsaWQgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBncmF5T3V0cy5wdXNoKGFsbE5vZGVzW215SW5kZXhdLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBhbGxOb2Rlc1tteUluZGV4XS5ncmF5b3V0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZVBsb3QoKTtcblxuICAgICAgICAgICAgbGF5b3V0KGxheW91dEFkZCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhck91dChncmF5T3V0cyk7XG4gICAgfVxuXG4gICAgc2VsZWN0TGFkZGEuc3RhcnQoKTsgLy9zdGFydCBidXR0b24gbW90aW9uXG4gICAgbWFrZUNvcnNSZXF1ZXN0KHVybGNhbGwsIGJ0biwgc3Vic2V0U2VsZWN0U3VjY2VzcywgYnRuID0+IHNlbGVjdExhZGRhLnN0b3AoKSwgc29sYWpzb25vdXQpO1xufVxuXG5mdW5jdGlvbiByZWFkUHJlcHJvY2VzcyhkYXRhKSB7XG5jb25zb2xlLmxvZyhkYXRhKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIF8pID0+IHtcbiAgICAgICAgcHJpdiA9IGRhdGEuZGF0YXNldC5wcml2YXRlIHx8IHByaXY7XG4gICAgICAgIE9iamVjdC5rZXlzKGRhdGEudmFyaWFibGVzKS5mb3JFYWNoKGsgPT4gcHJlcHJvY2Vzc1trXSA9IGRhdGEudmFyaWFibGVzW2tdKTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgIH0pO1xufVxuXG4vLyByZW1vdmVzIGFsbCB0aGUgY2hpbGRyZW4gc3ZncyBpbnNpZGUgc3Vic2V0IGFuZCBzZXR4IGRpdnNcbmZ1bmN0aW9uIHJlUGxvdCgpIHtcbiAgICBkMy5zZWxlY3QoJyN0YWIyJylcbiAgICAgICAgLnNlbGVjdEFsbCgnc3ZnJylcbiAgICAgICAgLnJlbW92ZSgpO1xuICAgIGQzLnNlbGVjdCgnI3NldHgnKVxuICAgICAgICAuc2VsZWN0QWxsKCdzdmcnKVxuICAgICAgICAucmVtb3ZlKCk7XG4gICAgYWxsTm9kZXMuZm9yRWFjaChuID0+IG4uc2V0eHBsb3QgPSBuLnN1YnNldHBsb3QgPSBmYWxzZSk7XG59XG5cbmxldCBzaG93TG9nID0gKHZhbCwgckNhbGwpID0+IHtcbiAgICBsb2dBcnJheS5wdXNoKCh2YWwgKyAnOiAnKS5jb25jYXQockNhbGxbMF0pKTtcbiAgICBtLnJlZHJhdygpO1xufVxuXG5mdW5jdGlvbiByZVdyaXRlTG9nKCkge1xuICAgIGQzLnNlbGVjdChcIiNjb2xsYXBzZUxvZyBkaXYucGFuZWwtYm9keVwiKS5zZWxlY3RBbGwoXCJwXCIpXG4gICAgICAgIC5yZW1vdmUoKTtcbiAgICBkMy5zZWxlY3QoXCIjY29sbGFwc2VMb2cgZGl2LnBhbmVsLWJvZHlcIikuc2VsZWN0QWxsKFwicFwiKVxuICAgICAgICAuZGF0YShsb2dBcnJheSlcbiAgICAgICAgLmVudGVyKClcbiAgICAgICAgLmFwcGVuZChcInBcIilcbiAgICAgICAgLnRleHQoZCA9PiBkKTtcbn1cblxuLy8gYWN0cyBhcyBpZiB0aGUgdXNlciBjbGlja2VkIGluIHdoaXRlc3BhY2UuIHVzZWZ1bCB3aGVuIHJlc3RhcnQoKSBpcyBvdXRzaWRlIG9mIHNjb3BlXG5leHBvcnQgbGV0IGZha2VDbGljayA9ICgpID0+IHtcbiAgICBsZXQgd3MgPSBcIiN3aGl0ZXNwYWNlXCIuY29uY2F0KG15c3BhY2UpO1xuICAgIC8vIGQzIGFuZCBwcm9ncmFtbWF0aWMgZXZlbnRzIGRvbid0IG1lc2ggd2VsbCwgaGVyZSdzIGEgU08gd29ya2Fyb3VuZCB0aGF0IGxvb2tzIGdvb2QgYnV0IHVzZXMganF1ZXJ5Li4uXG4gICAgalF1ZXJ5LmZuLmQzQ2xpY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5lYWNoKChpLCBlKSA9PiB7XG4gICAgICAgICAgICBsZXQgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJNb3VzZUV2ZW50c1wiKTtcbiAgICAgICAgICAgIGV2dC5pbml0TW91c2VFdmVudChcIm1vdXNlZG93blwiLCB0cnVlLCB0cnVlLCB3aW5kb3csIDAsIDAsIDAsIDAsIDAsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAwLCBudWxsKTtcbiAgICAgICAgICAgIGUuZGlzcGF0Y2hFdmVudChldnQpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgICQod3MpLmQzQ2xpY2soKTtcbiAgICBkMy5zZWxlY3Qod3MpXG4gICAgICAgIC5jbGFzc2VkKCdhY3RpdmUnLCBmYWxzZSk7XG59O1xuXG5cblxuXG4vL0VuZFNlc3Npb24oU2Vzc2lvbkNvbnRleHQpIHJldHVybnMgKFJlc3BvbnNlKSB7fVxuZXhwb3J0IGZ1bmN0aW9uIGVuZHNlc3Npb24oKSB7XG4gICAgbGV0IFNlc3Npb25Db250ZXh0PSBhcGlTZXNzaW9uKHpwYXJhbXMuenNlc3Npb25pZCk7XG5cbiAgICB2YXIganNvbm91dCA9IEpTT04uc3RyaW5naWZ5KFNlc3Npb25Db250ZXh0KTtcblxuICAgIHZhciB1cmxjYWxsID0gZDNtVVJMICsgXCIvZW5kc2Vzc2lvblwiO1xuICAgIHZhciBzb2xhanNvbm91dCA9IFwiZ3JwY3JlcXVlc3Q9XCIgKyBqc29ub3V0O1xuICAgIGNvbnNvbGUubG9nKFwiRW5kU2Vzc2lvbjogXCIpXG4gICAgY29uc29sZS5sb2coc29sYWpzb25vdXQpO1xuICAgIGNvbnNvbGUubG9nKFwidXJsY2FsbDogXCIsIHVybGNhbGwpO1xuXG4gICAgZnVuY3Rpb24gZW5kU3VjY2VzcyhidG4sIFJlc3BvbnNlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFJlc3BvbnNlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbmRGYWlsKGJ0bikge1xuICAgICAgICBjb25zb2xlLmxvZyhcImVuZCBzZXNzaW9uIGZhaWxlZFwiKTtcbiAgICB9XG5cbiAgICBtYWtlQ29yc1JlcXVlc3QodXJsY2FsbCwgXCJub2J1dHRvblwiLCBlbmRTdWNjZXNzLCBlbmRGYWlsLCBzb2xhanNvbm91dCk7XG59XG5cbi8vcnBjIExpc3RQaXBlbGluZXMoUGlwZWxpbmVMaXN0UmVxdWVzdCkgcmV0dXJucyAoUGlwZWxpbmVMaXN0UmVzdWx0KSB7fVxuLy8gcGlwZXMgaXMgYW4gYXJyYXkgb2YgcGlwZWxpbmUgSURzXG5leHBvcnQgZnVuY3Rpb24gbGlzdHBpcGVsaW5lcygpIHtcbiAgICBsZXQgY29udGV4dCA9IGFwaVNlc3Npb24oenBhcmFtcy56c2Vzc2lvbmlkKTtcbiAgICBsZXQgUGlwZUxpbmVMaXN0UmVxdWVzdD17Y29udGV4dH07XG5cbiAgICB2YXIganNvbm91dCA9IEpTT04uc3RyaW5naWZ5KFBpcGVMaW5lTGlzdFJlcXVlc3QpO1xuXG4gICAgdmFyIHVybGNhbGwgPSBkM21VUkwgKyBcIi9saXN0cGlwZWxpbmVzXCI7XG4gICAgdmFyIHNvbGFqc29ub3V0ID0gXCJncnBjcmVxdWVzdD1cIiArIGpzb25vdXQ7XG4gICAgY29uc29sZS5sb2coXCJQaXBlbGluZUxpc3RSZXF1ZXN0OiBcIik7XG4gICAgY29uc29sZS5sb2coc29sYWpzb25vdXQpO1xuICAgIGNvbnNvbGUubG9nKHVybGNhbGwpO1xuXG4gICAgZnVuY3Rpb24gbGlzdFBpcGVzU3VjY2VzcyhidG4sIFBpcGVsaW5lTGlzdFJlc3VsdCkge1xuICAgICAgICBjb25zb2xlLmxvZyhQaXBlbGluZUxpc3RSZXN1bHQpO1xuICAgICAgICAvL2hhcmRjb2RlZCBwaXBlcyBmb3Igbm93XG4gICAgICAgIGxldCBwaXBlcyA9IFBpcGVsaW5lTGlzdFJlc3VsdC5waXBlbGluZUlkcztcblxuICAgICAgICAvKlxuICAgICAgICBwaXBlcy51bnNoaWZ0KFwicGxhY2VcIik7XG4gICAgICAgIGNvbnNvbGUubG9nKHBpcGVzKTtcbiAgICAgICAgZDMuc2VsZWN0KFwiI3Jlc3VsdHNcIikuc2VsZWN0QWxsKFwicFwiKVxuICAgICAgICAuZGF0YShwaXBlcylcbiAgICAgICAgLmVudGVyKClcbiAgICAgICAgLmFwcGVuZChcInBcIilcbiAgICAgICAgLmF0dHIoXCJpZFwiLCBcIl9waXBlX1wiLmNvbmNhdClcbiAgICAgICAgLnRleHQoZCA9PiBkKVxuICAgICAgICAuYXR0cignY2xhc3MnLCAnaXRlbS1kZWZhdWx0JylcbiAgICAgICAgLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZih0aGlzLmNsYXNzTmFtZT09XCJpdGVtLXNlbGVjdFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkMy5zZWxlY3QoXCIjcmVzdWx0c1wiKS5zZWxlY3QoXCJwLml0ZW0tc2VsZWN0XCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2l0ZW0tZGVmYXVsdCcpO1xuICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5hdHRyKCdjbGFzcycsXCJpdGVtLXNlbGVjdFwiKTtcbiAgICAgICAgICAgIH19KTtcblxuICAgICAgICBwaXBlcy5zaGlmdCgpO1xuXG5cbiAgICAgICAgZDMuc2VsZWN0KFwiI3NldHhSaWdodFwiKS5zZWxlY3RBbGwoXCJwXCIpXG4gICAgICAgIC5kYXRhKHBpcGVzKVxuICAgICAgICAuZW50ZXIoKVxuICAgICAgICAuYXBwZW5kKFwicFwiKVxuICAgICAgICAuYXR0cihcImlkXCIsIFwiX3NldHhwaXBlX1wiLmNvbmNhdClcbiAgICAgICAgLnRleHQoZCA9PiBkKVxuICAgICAgICAuYXR0cignY2xhc3MnLCAnaXRlbS1kZWZhdWx0JylcbiAgICAgICAgLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZih0aGlzLmNsYXNzTmFtZT09XCJpdGVtLXNlbGVjdFwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZDMuc2VsZWN0KFwiI3NldHhSaWdodFwiKS5zZWxlY3QoXCJwLml0ZW0tc2VsZWN0XCIpXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnaXRlbS1kZWZhdWx0Jyk7XG4gICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuYXR0cignY2xhc3MnLFwiaXRlbS1zZWxlY3RcIik7XG4gICAgICAgICAgICB9fSk7XG4gICAgICAgICAqL1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RQaXBlc0ZhaWwoYnRuKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwibGlzdCBwaXBlbGluZXMgZmFpbGVkXCIpO1xuICAgIH1cblxuICAgIG1ha2VDb3JzUmVxdWVzdCh1cmxjYWxsLCBcIm5vYnV0dG9uXCIsIGxpc3RQaXBlc1N1Y2Nlc3MsIGxpc3RQaXBlc0ZhaWwsIHNvbGFqc29ub3V0KTtcbn1cblxuLy8gcnBjIEV4ZWN1dGVQaXBlbGluZShQaXBlbGluZUV4ZWN1dGVSZXF1ZXN0KSByZXR1cm5zIChzdHJlYW0gUGlwZWxpbmVFeGVjdXRlUmVzdWx0KSB7fVxuZXhwb3J0IGZ1bmN0aW9uIGV4ZWN1dGVwaXBlbGluZSgpIHtcbiAgICBsZXQgY29udGV4dCA9IGFwaVNlc3Npb24oenBhcmFtcy56c2Vzc2lvbmlkKTtcbiAgICBsZXQgdGFibGVyb3cgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2V0eFJpZ2h0JykucXVlcnlTZWxlY3RvcigndHIuaXRlbS1zZWxlY3QnKTtcbiAgICBpZih0YWJsZXJvdyA9PSBudWxsKSB7YWxlcnQoXCJQbGVhc2Ugc2VsZWN0IGEgcGlwZWxpbmUgdG8gZXhlY3V0ZSBvbi5cIik7IHJldHVybjt9XG4gICAgbGV0IHBpcGVsaW5lSWQ9dGFibGVyb3cuZmlyc3RDaGlsZC5pbm5lclRleHQ7XG5cbiAgICB6UG9wKCk7XG4gICAgenBhcmFtcy5jYWxsSGlzdG9yeSA9IGNhbGxIaXN0b3J5O1xuICAgIGxldCBqc29ub3V0ID0gSlNPTi5zdHJpbmdpZnkoenBhcmFtcyk7XG5cbiAgICBsZXQgcHJlZGljdEZlYXR1cmVzID0gYXBpRmVhdHVyZSh6cGFyYW1zLnp2YXJzLFwiPDxEQVRBX1VSST4+XCIpO1xuICAgIGxldCBkYXRhID0gW107XG5cbiAgICAvL3RoaXMgd2lsbCBqdXN0IHNldCB6cGFyYW1zLnpzZXR4IHRvIHRoZSBtZWFuLCB3aGljaCBpcyBkZWZhdWx0IGZvciBzZXR4IHBsb3RzXG4gICAgLy9ub3RlIHRoYXQgaWYgc2V0eHBsb3QgaXMgbW9kaWZpZWQsIGl0IHdpbGwgTk9UID09IFwiXCIgYmVjYXVzZSB6cGFyYW1zLnpzZXR4IGlzIG1vZGlmaWVkIHdoZW4gdGhlIHNldHggcGxvdCBzbGlkZXIgaXMgbW92ZWQgZm9yIHRoZSBmaXJzdCB0aW1lXG4gICAgZm9yKGxldCBpID0wOyBpPHpwYXJhbXMuenZhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG15ZGF0YSA9IFtdO1xuICAgICAgICBsZXQgbXltZWFuID0gYWxsTm9kZXNbZmluZE5vZGVJbmRleCh6cGFyYW1zLnp2YXJzW2ldKV0ubWVhbjtcbiAgICAgICAgaWYoenBhcmFtcy56c2V0eFtpXVswXT09XCJcIikge1xuICAgICAgICAgICAgbXlkYXRhWzBdPW15bWVhbjtcbiAgICAgICAgfSBlbHNlIGlmKHpwYXJhbXMuenNldHhbaV1bMF0hPW15bWVhbil7XG4gICAgICAgICAgICBteWRhdGFbMF09enBhcmFtcy56c2V0eFtpXVswXTtcbiAgICAgICAgfVxuICAgICAgICBpZih6cGFyYW1zLnpzZXR4W2ldWzFdPT1cIlwiKSB7XG4gICAgICAgICAgICBteWRhdGFbMV09YWxsTm9kZXNbZmluZE5vZGVJbmRleCh6cGFyYW1zLnp2YXJzW2ldKV0ubWVhbjtcbiAgICAgICAgfSBlbHNlIGlmKHpwYXJhbXMuenNldHhbaV1bMV0hPW15bWVhbil7XG4gICAgICAgICAgICBteWRhdGFbMV09enBhcmFtcy56c2V0eFtpXVsxXTtcbiAgICAgICAgfVxuICAgICAgICBkYXRhLnB1c2gobXlkYXRhKTtcbiAgICB9XG5cbiAgICBsZXQgUGlwZWxpbmVFeGVjdXRlUmVxdWVzdD17Y29udGV4dCwgcGlwZWxpbmVJZCwgcHJlZGljdEZlYXR1cmVzLCBkYXRhfTtcblxuICAgIGpzb25vdXQgPSBKU09OLnN0cmluZ2lmeShQaXBlbGluZUV4ZWN1dGVSZXF1ZXN0KTtcblxuICAgIHZhciB1cmxjYWxsID0gZDNtVVJMICsgXCIvZXhlY3V0ZXBpcGVsaW5lXCI7XG4gICAgdmFyIHNvbGFqc29ub3V0ID0gXCJncnBjcmVxdWVzdD1cIiArIGpzb25vdXQ7XG4gICAgY29uc29sZS5sb2coXCJQaXBlbGluZUV4ZWN1dGVSZXF1ZXN0OiBcIik7XG4gICAgY29uc29sZS5sb2coc29sYWpzb25vdXQpO1xuICAgIGNvbnNvbGUubG9nKFwidXJsY2FsbDogXCIsIHVybGNhbGwpO1xuXG4gICAgZnVuY3Rpb24gZXhlY3V0ZVBpcGVTdWNjZXNzKGJ0biwgUGlwZWxpbmVFeGVjdXRlUmVzdWx0KSB7XG4gICAgICAgIGFsZXJ0KFwicGlwZWxpbmUgZXhlY3V0ZWRcIik7XG4gICAgICAgIGNvbnNvbGUubG9nKFBpcGVsaW5lRXhlY3V0ZVJlc3VsdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhlY3V0ZVBpcGVGYWlsKGJ0bikge1xuICAgICAgICBjb25zb2xlLmxvZyhcImV4ZWN1dGUgcGlwZWxpbmVzIGZhaWxlZFwiKTtcbiAgICB9XG5cbiAgICBtYWtlQ29yc1JlcXVlc3QodXJsY2FsbCwgXCJub2J1dHRvblwiLCBleGVjdXRlUGlwZVN1Y2Nlc3MsIGV4ZWN1dGVQaXBlRmFpbCwgc29sYWpzb25vdXQpO1xufVxuXG4vLyB0aGlzIGlzIG91ciBjYWxsIHRvIGRqYW5nbyB0byB1cGRhdGUgdGhlIHByb2JsZW0gc2NoZW1hXG4vLyBycGMgVXBkYXRlUHJvYmxlbVNjaGVtYShVcGRhdGVQcm9ibGVtU2NoZW1hUmVxdWVzdCkgcmV0dXJucyAoUmVzcG9uc2UpIHt9XG5mdW5jdGlvbiB1cGRhdGVTY2hlbWEodHlwZSwgdXBkYXRlcywgbG9va3VwKSB7XG4gICAgbGV0IGNvbnRleHQgPSBhcGlTZXNzaW9uKHpwYXJhbXMuenNlc3Npb25pZCk7XG4gICAgbGV0IFJlcGxhY2VQcm9ibGVtU2NoZW1hRmllbGQ9e1t0eXBlXTpsb29rdXBbdXBkYXRlc1t0eXBlXV1bMV19O1xuLy8gICAgbGV0IHZhbHVlbnVtID0gbG9va3VwW3VwZGF0ZXNbdHlwZV1dWzJdO1xuICAgIGxldCBVcGRhdGVQcm9ibGVtU2NoZW1hUmVxdWVzdCA9IHtSZXBsYWNlUHJvYmxlbVNjaGVtYUZpZWxkLGNvbnRleHR9O1xuXG4gICAgbGV0IGpzb25vdXQgPSBKU09OLnN0cmluZ2lmeShVcGRhdGVQcm9ibGVtU2NoZW1hUmVxdWVzdCk7XG5cbiAgICBsZXQgdXJsY2FsbCA9IGQzbVVSTCArIFwiL3VwZGF0ZXByb2JsZW1zY2hlbWFcIjtcbiAgICBsZXQgc29sYWpzb25vdXQgPSBcImdycGNyZXF1ZXN0PVwiICsganNvbm91dDtcbiAgICBjb25zb2xlLmxvZyhcIlVwZGF0ZVByb2JsZW1TY2hlbWFSZXF1ZXN0OiBcIik7XG4gICAgY29uc29sZS5sb2coc29sYWpzb25vdXQpO1xuICAgIGNvbnNvbGUubG9nKFwidXJsY2FsbDogXCIsIHVybGNhbGwpO1xuXG4gICAgZnVuY3Rpb24gdXNTdWNjZXNzKGJ0biwgUmVzcG9uc2UpIHtcbiAgICAgICAgY29uc29sZS5sb2coUmVzcG9uc2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVzRmFpbChidG4pIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJ1cGRhdGUgc2NoZW1hIGZhaWxlZFwiKTtcbiAgICB9XG5cbiAgICBtYWtlQ29yc1JlcXVlc3QodXJsY2FsbCwgXCJub2J1dHRvblwiLCB1c1N1Y2Nlc3MsIHVzRmFpbCwgc29sYWpzb25vdXQpO1xufVxuXG5cbi8vIEZpbmQgc29tZXRoaW5nIGNlbnRlcmlzaCB0byB0aGUgdmVydGljZXMgb2YgYSBjb252ZXggaHVsbFxuLy8gKHNwZWNpZmljYWxseSwgdGhlIGNlbnRlciBvZiB0aGUgYm91bmRpbmcgYm94KVxuZnVuY3Rpb24gamFtZXNjZW50cm9pZChjb29yZCl7XG4gICAgdmFyIG1pbnggPSBjb29yZFswXVswXSxcbiAgICAgICAgbWF4eCA9IGNvb3JkWzBdWzBdLFxuICAgICAgICBtaW55ID0gY29vcmRbMF1bMV0sXG4gICAgICAgIG1heHkgPSBjb29yZFswXVsxXTtcbiAgICBmb3IodmFyIGogPSAxOyBqPGNvb3JkLmxlbmd0aDsgaisrKXtcbiAgICAgICAgaWYgKGNvb3JkW2pdWzBdIDwgbWlueCkgbWlueCA9IGNvb3JkW2pdWzBdO1xuICAgICAgICBpZiAoY29vcmRbal1bMV0gPCBtaW55KSBtaW55ID0gY29vcmRbal1bMV07XG4gICAgICAgIGlmIChjb29yZFtqXVswXSA+IG1heHgpIG1heHggPSBjb29yZFtqXVswXTtcbiAgICAgICAgaWYgKGNvb3JkW2pdWzFdID4gbWF4eSkgbWF4eSA9IGNvb3JkW2pdWzFdO1xuICAgIH07XG4gICAgICAgIHJldHVyblsobWlueCArIG1heHgpLzIsIChtaW55ICsgbWF4eSkvMl07XG59O1xuXG4vLyBEZWZpbmUgZWFjaCBwZWJibGUgcmFkaXVzLlxuLy8gUHJlc2VudGx5LCBtb3N0IHBlYmJsZXMgYXJlIHNjYWxlZCB0byByYWRpdXMgc2V0IGJ5IGdsb2JhbCBhbGxSLlxuLy8gTWVtYmVycyBvZiBncm91cHMgYXJlIHNjYWxlZCBkb3duIGlmIGdyb3VwIGdldHMgbGFyZ2UuXG5mdW5jdGlvbiBzZXRQZWJibGVSYWRpdXMoZCl7XG4gICAgaWYoZC5ncm91cDEgfHwgZC5ncm91cDIpeyAgIC8vIGlmIGEgbWVtYmVyIG9mIGEgZ3JvdXAsIG5lZWQgdG8gY2FsY3VsYXRlIHJhZGl1cyBzaXplXG4gICAgICAgIHZhciB1cHBlcnNpemUgPSA3XG4gICAgICAgIHZhciBuZzEgPSAoZC5ncm91cDEpID8genBhcmFtcy56Z3JvdXAxLmxlbmd0aCA6IDE7ICAgICAgLy8gc2l6ZSBvZiBncm91cDEsIGlmIGEgbWVtYmVyIG9mIGdyb3VwIDFcbiAgICAgICAgdmFyIG5nMiA9IChkLmdyb3VwMikgPyB6cGFyYW1zLnpncm91cDIubGVuZ3RoIDogMTsgICAgICAvLyBzaXplIG9mIGdyb3VwMiwgaWYgYSBtZW1iZXIgb2YgZ3JvdXAgMlxuICAgICAgICB2YXIgbWF4bmcgPSBNYXRoLm1heChuZzEsbmcyKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzaXplIG9mIHRoZSBsYXJnZXN0IGdyb3VwIHZhcmlhYmxlIGlzIG1lbWJlciBvZlxuICAgICAgICByZXR1cm4gKG1heG5nPnVwcGVyc2l6ZSkgPyBhbGxSKk1hdGguc3FydCh1cHBlcnNpemUvbWF4bmcpIDogYWxsUjsgICAgICAgICAgICAgICAgICAvLyBrZWVwIHRvdGFsIGFyZWEgb2YgcGViYmxlcyBib3VuZGVkIHRvIHBpICogYWxsUl4yICogdXBwZXJzaXplLCB0aHVzIHNocmlua2luZyByYWRpdXMgZm9yIHBlYmJsZXMgaW4gbGFyZ2VyIGdyb3Vwc1xuICAgIH1lbHNle1xuICAgICAgICByZXR1cm4gYWxsUiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBub25ncm91cCBtZW1iZXJzIGdldCB0aGUgY29tbW9uIGdsb2JhbCByYWRpdXNcbiAgICB9XG59O1xuXG4vLyBEZWZpbmUgZWFjaCBwZWJibGUgY2hhcmdlLlxuLy8gVGhpcyB3YXMgdGhlIHByZXZpb3VzIGNoYXJnZSBzZXR0aW5nOlxuLy9yZXR1cm4gKCh6cGFyYW1zLnpncm91cDEuaW5kZXhPZihub2RlLm5hbWUpIDwgMCApICYgKHpwYXJhbXMuemdyb3VwMi5pbmRleE9mKG5vZGUubmFtZSkgPCAwICkpICAgPyAtODAwIDogLTQwMDsgIC8vIC0xIGlzIHRoZSB2YWx1ZSBpZiBubyBpbmRleCBwb3NpdGlvbiBmb3VuZFxuZnVuY3Rpb24gc2V0UGViYmxlQ2hhcmdlKGQpe1xuICAgIGlmKGQuZ3JvdXAxIHx8IGQuZ3JvdXAyKXtcbiAgICAgICAgaWYoZC5mb3JlZnJvbnQpeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwZWJibGVzIHBhY2tlZCBpbiBncm91cHMgcmVwZWwgb3RoZXJzIG9uIG1vdXNlb3ZlclxuICAgICAgICAgICAgcmV0dXJuIC0xMDAwXG4gICAgICAgIH1cbiAgICAgICAgdmFyIHVwcGVyc2l6ZSA9IDdcbiAgICAgICAgdmFyIG5nMSA9IChkLmdyb3VwMSkgPyB6cGFyYW1zLnpncm91cDEubGVuZ3RoIDogMTsgICAgICAvLyBzaXplIG9mIGdyb3VwMSwgaWYgYSBtZW1iZXIgb2YgZ3JvdXAgMVxuICAgICAgICB2YXIgbmcyID0gKGQuZ3JvdXAyKSA/IHpwYXJhbXMuemdyb3VwMi5sZW5ndGggOiAxOyAgICAgIC8vIHNpemUgb2YgZ3JvdXAyLCBpZiBhIG1lbWJlciBvZiBncm91cCAyXG4gICAgICAgIHZhciBtYXhuZyA9IE1hdGgubWF4KG5nMSxuZzIpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNpemUgb2YgdGhlIGxhcmdlc3QgZ3JvdXAgdmFyaWFibGUgaXMgbWVtYmVyIG9mXG4gICAgICAgIHJldHVybiAobWF4bmc+dXBwZXJzaXplKSA/IC00MDAqKHVwcGVyc2l6ZS9tYXhuZykgOiAtNDAwOyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRlY3JlYXNlIGNoYXJnZSBhcyBwZWJibGVzIGJlY29tZSBzbWFsbGVyLCBzbyB0aGV5IGNhbiBwYWNrIHRvZ2V0aGVyXG4gICAgfWVsc2V7XG4gICAgICAgIHJldHVybiAtODAwXG4gICAgfVxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGV4cGFuZHJpZ2h0cGFuZWwoKSB7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3JpZ2h0cGFuZWwnKS5jbGFzc0xpc3QuYWRkKFwiZXhwYW5kcGFuZWxmdWxsXCIpXG4gICAgY29uc29sZS5sb2coXCJIRVJFXCIpO1xufVxuXG5mdW5jdGlvbiB0b2dnbGVSaWdodEJ1dHRvbnMoc2V0KSB7XG5cbiAgICBmdW5jdGlvbiBzZXRXaWR0aHMoYnRucykge1xuICAgICAgICBsZXQgbXl3aWR0aCA9IDEwMC9idG5zLmxlbmd0aDtcbiAgICAgICAgbXl3aWR0aCA9IG15d2lkdGgudG9TdHJpbmcoKSArICclJztcbiAgICAgICAgbGV0IGV4cGFuZHdpZHRoID0gJzM1JSc7XG4gICAgICAgIGxldCBzaHJpbmt3aWR0aCA9IDY1LyhidG5zLmxlbmd0aC0xKTtcbiAgICAgICAgc2hyaW5rd2lkdGggPSBzaHJpbmt3aWR0aC50b1N0cmluZygpICsgJyUnO1xuICAgICAgICBsZXQgbXlsaXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmlnaHRwYW5lbCcpLnF1ZXJ5U2VsZWN0b3JBbGwoXCIuYWNjb3JkaWFuIGxpXCIpO1xuICAgICAgICAvLyBoYXJkbHkgZXZlciBydW5zIG9uIHRoZSBwYWdlXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXlsaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG15bGlzW2ldLnN0eWxlLndpZHRoPW15d2lkdGg7XG4gICAgICAgICAgICBteWxpc1tpXS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBqID0gMDsgaiA8IG15bGlzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG15bGlzW2pdLnN0eWxlLndpZHRoPXNocmlua3dpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3R5bGUud2lkdGg9ZXhwYW5kd2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbXlsaXNbaV0uYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBqID0gMDsgaiA8IG15bGlzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG15bGlzW2pdLnN0eWxlLndpZHRoPW15d2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGlmKHNldD09XCJ0YXNrc1wiKSB7XG5cbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2J0bk1vZGVscycpLmNsYXNzTGlzdC5hZGQoXCJub3Nob3dcIik7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdidG5TZXR4JykuY2xhc3NMaXN0LmFkZChcIm5vc2hvd1wiKTtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2J0blJlc3VsdHMnKS5jbGFzc0xpc3QuYWRkKFwibm9zaG93XCIpO1xuXG5cbiAgICAgICAgbGV0IG15YnRucyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyaWdodHBhbmVsYnV0dG9ucycpLnF1ZXJ5U2VsZWN0b3JBbGwoXCIuYnRuOm5vdCgubm9zaG93KVwiKTtcbiAgICAgICAgc2V0V2lkdGhzKG15YnRucyk7XG5cblxuICAgIH0gZWxzZSBpZiAoc2V0PT1cImFsbFwiKSB7XG4gICAgICAgIC8vIGZpcnN0IHJlbW92ZSBub3Nob3cgY2xhc3NcbiAgICAgICAgbGV0IG15YnRucyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyaWdodHBhbmVsYnV0dG9ucycpLnF1ZXJ5U2VsZWN0b3JBbGwoXCIubm9zaG93XCIpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG15YnRucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbXlidG5zW2ldLmNsYXNzTGlzdC5yZW1vdmUoXCJub3Nob3dcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkcm9waW5nIG1vZGVscyBmb3IgZDNtX21vZGVcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2J0bk1vZGVscycpLmNsYXNzTGlzdC5hZGQoXCJub3Nob3dcIik7XG5cbiAgICAgICAgLy8gaWYgc3dhbmRpdmUsIGRyb3BwaW5nIHNldHhcbiAgICAgICAgaWYoc3dhbmRpdmUpXG4gICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYnRuU2V0eCcpLmNsYXNzTGlzdC5hZGQoXCJub3Nob3dcIik7XG5cbiAgICAgICAgLy8gdGhlbiBzZWxlY3QgYWxsIHRoZSBidXR0b25zXG4gICAgICAgIG15YnRucyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyaWdodHBhbmVsYnV0dG9ucycpLnF1ZXJ5U2VsZWN0b3JBbGwoXCIuYnRuOm5vdCgubm9zaG93KVwiKTtcbiAgICAgICAgc2V0V2lkdGhzKG15YnRucyk7XG5cbiAgICB9XG4gICAgaWYoc2V0PT1cIm1vZGVsc1wiKSB7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdidG5Nb2RlbHMnKS5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZSc7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdidG5TZXR4Jykuc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUnO1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYnRuUmVzdWx0cycpLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lJztcblxuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYnRuVHlwZScpLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdidG5TdWJ0eXBlJykuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2J0bk1ldHJpY3MnKS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYnRuT3V0cHV0cycpLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzdWx0c3Bsb3Rpbml0KHBpZCwgZHZ2YWx1ZXMpIHtcbiAgICAvLyBwcmVzdW1hYmx5IHdlJ2xsIGJlIHJlYWRpbmcgaW4gcmVzdWx0cyBmcm9tIGEgcGF0aFxuICAgIC8vIGZvciBub3cgaXQncyBqdXN0IGhhcmRjb2RlZFxuICAgIGNvbnNvbGUubG9nKHBpZCk7XG4gICAgbGV0IHByZWRmaWxlID0gcGlkLnBpcGVsaW5lSW5mby5wcmVkaWN0UmVzdWx0RGF0YS5maWxlXzE7XG4gICAgbGV0IHByZWR2YWxzID0gW107XG5cbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgcHJlZGZpbGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcHJlZHZhbHMucHVzaChOdW1iZXIocHJlZGZpbGVbaV0ucHJlZHMpKTtcbiAgICB9XG5cbiAgICAvLyBvbmx5IGRvIHRoaXMgZm9yIGNsYXNzaWZpY2F0aW9uIHRhc2tzXG4gICAgaWYoZDNtVGFza1R5cGVbZDNtUHJvYmxlbURlc2NyaXB0aW9uLnRhc2tUeXBlXVsxXSA9PSBcIkNMQVNTSUZJQ0FUSU9OXCIpIHtcbiAgICAgICAgZ2VuY29uZmRhdGEoZHZ2YWx1ZXMsIHByZWR2YWxzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgeGRhdGEgPSBcIkFjdHVhbFwiO1xuICAgICAgICBsZXQgeWRhdGEgPSBcIlByZWRpY3RlZFwiO1xuICAgICAgICBiaXZhcmlhdGVQbG90KGR2dmFsdWVzLCBwcmVkdmFscywgeGRhdGEsIHlkYXRhKTtcblxuICAgIH1cblxufVxuZXhwb3J0IGZ1bmN0aW9uIGdlbmNvbmZkYXRhIChkdnZhbHVlcywgcHJlZHZhbHMpIHtcbiAgICAvLyBGT1IgVEVTVElOR1xuICAgIGR2dmFsdWVzID0gcHJlZHZhbHMuc2xpY2UoMCk7XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGR2dmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciByYW5kb21udW1iZXIgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoMiAtIC0yICsgMSkpICsgLTI7XG4gICAgICAgIGR2dmFsdWVzW2ldID0gZHZ2YWx1ZXNbaV0gKyByYW5kb21udW1iZXI7XG4gICAgfVxuXG4gICAgLy8gZG9uZSBmb3IgdGVzdGluZy4gZHJvcCBhYm92ZSB3aGVuIGR2dmFsdWVzIGFyZSByZWFsIHZhbHVlcyByZXR1cm5lZCBieSBSIHdoZW4gcGlwZWxpbmUgaXMgY29uc3RydWN0ZWRcblxuICAgIGZ1bmN0aW9uIG9ubHlVbmlxdWUodmFsdWUsIGluZGV4LCBzZWxmKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmluZGV4T2YodmFsdWUpID09PSBpbmRleDtcbiAgICB9XG5cbiAgICBsZXQgbXljb3VudHMgPSBbXTtcbiAgICBsZXQgbXlwYWlycyA9IFtdO1xuXG4gICAgLy8gdGhpcyBzaG91bGQgZXZlbnR1YWxseSBiZSBqdXN0IHJlYWQgZnJvbSB0aGUgVVJJIGluIHBpcGVsaW5lXG4gICAvLyBsZXQgZHZ2YWx1ZXMgPSBbMSwxLDEsMiwzLDIsMywzLDMsMywzLDIsMywyLDEsMiwzLDQsNF07XG4gICAvLyBsZXQgcHJlZHZhbHMgPSBbMSwyLDMsMiwzLDEsMywzLDMsMiwyLDEsMywzLDEsMiwzLDQsM107XG5cbiAgICAvLyBjb21iaW5lIGFjdHVhbHMgYW5kIHByZWRpY3RlZCwgYW5kIGdldCBhbGwgdW5pcXVlIGVsZW1lbnRzXG4gICAgbGV0IG15dW5pcXVlcyA9IGR2dmFsdWVzLmNvbmNhdChwcmVkdmFscyk7XG4gICAgbXl1bmlxdWVzID0gbXl1bmlxdWVzLmZpbHRlcihvbmx5VW5pcXVlKTtcbiAgLy8gIGNvbnNvbGUubG9nKG15dW5pcXVlcyk7XG5cbiAgICAvLyBjcmVhdGUgdHdvIGFycmF5czogbXljb3VudHMgaW5pdGlhbGl6ZWQgdG8gMCwgbXlwYWlycyBoYXZlIGVsZW1lbnRzIHNldCB0byBhbGwgcG9zc2libGUgcGFpcnMgb2YgdW5pcXVlc1xuICAgIC8vIGxvb2tlZCBpbnRvIHNvbHV0aW9ucyBvdGhlciB0aGFuIG5lc3RlZCBmb3JzLCBidXQgSW50ZXJuZXQgc3VnZ2VzdCBwZXJmb3JtYW5jZSBpcyBqdXN0IGZpbmUgdGhpcyB3YXlcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgbXl1bmlxdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCB0ZW1wY291bnQgPSBbXTtcbiAgICAgICAgbGV0IHRlbXBwYWlyID0gW107XG4gICAgICAgIGZvcihsZXQgaiA9IDA7IGogPCBteXVuaXF1ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIG15Y291bnRzLnB1c2goMCk7XG4gICAgICAgICAgICBteXBhaXJzLnB1c2goK215dW5pcXVlc1tpXSsnLCcrbXl1bmlxdWVzW2pdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAvLyAgY29uc29sZS5sb2cobXlwYWlycyk7XG4gICAgLy8gbGluZSB1cCBhY3R1YWxzIGFuZCBwcmVkaWN0ZWQsIGFuZCBpbmNyZW1lbnQgbXljb3VudHMgYXQgaW5kZXggd2hlcmUgbXlwYWlyIGhhcyBhIG1hdGNoIGZvciB0aGUgJ2FjdHVhbCxwcmVkaWN0ZWQnXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkdnZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAvLyAgIGNvbnNvbGUubG9nKGR2dmFsdWVzW2ldKTtcbiAgICAgLy8gICBjb25zb2xlLmxvZyhwcmVkdmFsc1tpXSk7XG4gICAgICAgIGxldCB0ZW1wcGFpciA9ICtkdnZhbHVlc1tpXSsnLCcrcHJlZHZhbHNbaV07XG4gICAgICAgIGxldCBteWluZGV4ID0gbXlwYWlycy5pbmRleE9mKHRlbXBwYWlyKTtcbiAgICAgICAgbXljb3VudHNbbXlpbmRleF0gKz0gMTtcbiAgICB9XG4gIC8vICBjb25zb2xlLmxvZyhteWNvdW50cyk7XG5cbiAgICBsZXQgY29uZmRhdGEgPSBbXSwgc2l6ZSA9IG15dW5pcXVlcy5sZW5ndGg7XG5cbiAgICAvLyBhbm90aGVyIGxvb3AuLi4gdGhpcyBidWlsZHMgdGhlIGFycmF5IG9mIGFycmF5cyBmcm9tIHRoZSBmbGF0IGFycmF5IG15Y291bnRzIGZvciBpbnB1dCB0byBjb25mdXNpb25zbWF0cml4IGZ1bmN0aW9uXG4gICAgd2hpbGUgKG15Y291bnRzLmxlbmd0aCA+IDApXG4gICAgICAgIGNvbmZkYXRhLnB1c2gobXljb3VudHMuc3BsaWNlKDAsIHNpemUpKTtcblxuICAgLy8gY29uc29sZS5sb2coY29uZmRhdGEpO1xuXG4gICAgLy8gY2FsbCBjb25mdXNpb25tYXRyaXhcbiAgICBjb25mdXNpb25tYXRyaXgoY29uZmRhdGEsIG15dW5pcXVlcyk7XG59XG5leHBvcnQgZnVuY3Rpb24gY29uZnVzaW9ubWF0cml4KG1hdHJpeGRhdGEsIGNsYXNzZXMpIHtcbiAgICBkMy5zZWxlY3QoXCIjc2V0eE1pZGRsZVwiKS5odG1sKFwiXCIpO1xuICAgIGQzLnNlbGVjdChcIiNzZXR4TWlkZGxlXCIpLnNlbGVjdChcInN2Z1wiKS5yZW1vdmUoKTtcblxuICAgIC8vIGFkYXB0ZWQgZnJvbSB0aGlzIGJsb2NrOiBodHRwczovL2JsLm9ja3Mub3JnL2FycGl0bmFyZWNoYW5pYS9kYmYwM2Q4ZWY3ZmZmYTQ0NjM3OWQ1OWRiNjM1NGJhY1xuICAgIGxldCBtYWlud2lkdGggPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWFpbicpLmNsaWVudFdpZHRoO1xuICAgIGxldCBtYWluaGVpZ2h0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21haW4nKS5jbGllbnRIZWlnaHQ7XG5cbiAgICBsZXQgY29uZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29uZGl2LmlkPVwiY29uZnVzaW9uY29udGFpbmVyXCI7XG4gICAgY29uZGl2LnN0eWxlLmRpc3BsYXk9XCJpbmxpbmUtYmxvY2tcIjtcbiAgICBjb25kaXYuc3R5bGUud2lkdGg9KyhtYWlud2lkdGgqLjI1KSsncHgnO1xuICAgIGNvbmRpdi5zdHlsZS5tYXJnaW5MZWZ0PScyMHB4JztcbiAgICBjb25kaXYuc3R5bGUuaGVpZ2h0PSsobWFpbmhlaWdodCouNCkrJ3B4JztcbiAgICBjb25kaXYuc3R5bGUuZmxvYXQ9XCJsZWZ0XCI7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NldHhNaWRkbGUnKS5hcHBlbmRDaGlsZChjb25kaXYpO1xuXG4gICAgbGV0IGxlZ2RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGxlZ2Rpdi5pZD1cImNvbmZ1c2lvbmxlZ2VuZFwiO1xuICAgIGxlZ2Rpdi5zdHlsZS53aWR0aD0rKG1haW53aWR0aCouMDcpKydweCc7XG4gICAgbGVnZGl2LnN0eWxlLm1hcmdpbkxlZnQ9JzIwcHgnO1xuICAgIGxlZ2Rpdi5zdHlsZS5oZWlnaHQ9KyhtYWluaGVpZ2h0Ki40KSsncHgnO1xuICAgIGxlZ2Rpdi5zdHlsZS5kaXNwbGF5PVwiaW5saW5lLWJsb2NrXCI7XG5cbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2V0eE1pZGRsZScpLmFwcGVuZENoaWxkKGxlZ2Rpdik7XG5cblxuICAgIHZhciBtYXJnaW4gPSB7dG9wOiAyMCwgcmlnaHQ6IDEwLCBib3R0b206IDAsIGxlZnQ6IDUwfTtcblxuICAgIGZ1bmN0aW9uIE1hdHJpeChvcHRpb25zKSB7XG5cbiAgICAgICAgbGV0IHdpZHRoID0gb3B0aW9ucy53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQsXG4gICAgICAgIGRhdGEgPSBvcHRpb25zLmRhdGEsXG4gICAgICAgIGNvbnRhaW5lciA9IG9wdGlvbnMuY29udGFpbmVyLFxuICAgICAgICBsYWJlbHNEYXRhID0gb3B0aW9ucy5sYWJlbHMsXG4gICAgICAgIHN0YXJ0Q29sb3IgPSBvcHRpb25zLnN0YXJ0X2NvbG9yLFxuICAgICAgICBlbmRDb2xvciA9IG9wdGlvbnMuZW5kX2NvbG9yO1xuXG4gICAgICAgIGxldCB3aWR0aExlZ2VuZCA9IG9wdGlvbnMud2lkdGhMZWdlbmQ7XG5cbiAgICAgICAgaWYoIWRhdGEpe1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgcGFzcyBkYXRhJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZighQXJyYXkuaXNBcnJheShkYXRhKSB8fCAhZGF0YS5sZW5ndGggfHwgIUFycmF5LmlzQXJyYXkoZGF0YVswXSkpe1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJdCBzaG91bGQgYmUgYSAyLUQgYXJyYXknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBtYXhWYWx1ZSA9IGQzLm1heChkYXRhLCBmdW5jdGlvbihsYXllcikgeyByZXR1cm4gZDMubWF4KGxheWVyLCBmdW5jdGlvbihkKSB7IHJldHVybiBkOyB9KTsgfSk7XG4gICAgICAgIGxldCBtaW5WYWx1ZSA9IGQzLm1pbihkYXRhLCBmdW5jdGlvbihsYXllcikgeyByZXR1cm4gZDMubWluKGxheWVyLCBmdW5jdGlvbihkKSB7IHJldHVybiBkOyB9KTsgfSk7XG5cbiAgICAgICAgbGV0IG51bXJvd3MgPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgbGV0IG51bWNvbHMgPSBkYXRhWzBdLmxlbmd0aDtcblxuICAgICAgICBsZXQgc3ZnID0gZDMuc2VsZWN0KGNvbnRhaW5lcikuYXBwZW5kKFwic3ZnXCIpXG4gICAgICAgIC5hdHRyKFwid2lkdGhcIiwgd2lkdGggKyBtYXJnaW4ubGVmdCArIG1hcmdpbi5yaWdodClcbiAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgaGVpZ2h0ICsgbWFyZ2luLnRvcCArIG1hcmdpbi5ib3R0b20pXG4gICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgbWFyZ2luLmxlZnQgKyBcIixcIiArIG1hcmdpbi50b3AgKyBcIilcIik7XG5cbiAgICAgICAgbGV0IGJhY2tncm91bmQgPSBzdmcuYXBwZW5kKFwicmVjdFwiKVxuICAgICAgICAuc3R5bGUoXCJzdHJva2VcIiwgXCJibGFja1wiKVxuICAgICAgICAuc3R5bGUoXCJzdHJva2Utd2lkdGhcIiwgXCIycHhcIilcbiAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCB3aWR0aClcbiAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgaGVpZ2h0KTtcblxuICAgICAgICBsZXQgeCA9IGQzLnNjYWxlLm9yZGluYWwoKVxuICAgICAgICAuZG9tYWluKGQzLnJhbmdlKG51bWNvbHMpKVxuICAgICAgICAucmFuZ2VCYW5kcyhbMCwgd2lkdGhdKTtcblxuICAgICAgICBsZXQgeSA9IGQzLnNjYWxlLm9yZGluYWwoKVxuICAgICAgICAuZG9tYWluKGQzLnJhbmdlKG51bXJvd3MpKVxuICAgICAgICAucmFuZ2VCYW5kcyhbMCwgaGVpZ2h0XSk7XG5cbiAgICAgICAgbGV0IGNvbG9yTWFwID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLmRvbWFpbihbbWluVmFsdWUsbWF4VmFsdWVdKVxuICAgICAgICAucmFuZ2UoW3N0YXJ0Q29sb3IsIGVuZENvbG9yXSk7XG5cbiAgICAgICAgbGV0IHJvdyA9IHN2Zy5zZWxlY3RBbGwoXCIucm93XCIpXG4gICAgICAgIC5kYXRhKGRhdGEpXG4gICAgICAgIC5lbnRlcigpLmFwcGVuZChcImdcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInJvd1wiKVxuICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBmdW5jdGlvbihkLCBpKSB7IHJldHVybiBcInRyYW5zbGF0ZSgwLFwiICsgeShpKSArIFwiKVwiOyB9KTtcblxuICAgICAgICBsZXQgY2VsbCA9IHJvdy5zZWxlY3RBbGwoXCIuY2VsbFwiKVxuICAgICAgICAuZGF0YShmdW5jdGlvbihkKSB7IHJldHVybiBkOyB9KVxuICAgICAgICAuZW50ZXIoKS5hcHBlbmQoXCJnXCIpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJjZWxsXCIpXG4gICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uKGQsIGkpIHsgcmV0dXJuIFwidHJhbnNsYXRlKFwiICsgeChpKSArIFwiLCAwKVwiOyB9KTtcblxuICAgICAgICBjZWxsLmFwcGVuZCgncmVjdCcpXG4gICAgICAgIC5hdHRyKFwid2lkdGhcIiwgeC5yYW5nZUJhbmQoKSlcbiAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgeS5yYW5nZUJhbmQoKSlcbiAgICAgICAgLnN0eWxlKFwic3Ryb2tlLXdpZHRoXCIsIDApO1xuXG4gICAgICAgIGNlbGwuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAuYXR0cihcImR5XCIsIFwiLjMyZW1cIilcbiAgICAgICAgLmF0dHIoXCJ4XCIsIHgucmFuZ2VCYW5kKCkgLyAyKVxuICAgICAgICAuYXR0cihcInlcIiwgeS5yYW5nZUJhbmQoKSAvIDIpXG4gICAgICAgIC5hdHRyKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIilcbiAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBmdW5jdGlvbihkLCBpKSB7IHJldHVybiBkID49IG1heFZhbHVlLzIgPyAnd2hpdGUnIDogJ2JsYWNrJzsgfSlcbiAgICAgICAgLnRleHQoZnVuY3Rpb24oZCwgaSkgeyByZXR1cm4gZDsgfSk7XG5cbiAgICAgICAgcm93LnNlbGVjdEFsbChcIi5jZWxsXCIpXG4gICAgICAgIC5kYXRhKGZ1bmN0aW9uKGQsIGkpIHsgcmV0dXJuIGRhdGFbaV07IH0pXG4gICAgICAgIC5zdHlsZShcImZpbGxcIiwgY29sb3JNYXApO1xuXG4gICAgICAgIC8vIHRoaXMgcG9ydGlvbiBvZiB0aGUgY29kZSBpc24ndCBhcyByb2J1c3QgdG8gc2l6aW5nLiBjb2x1bW4gbGFiZWxzIG5vdCByZW5kZXJpbmcgaW4gdGhlIHJpZ2h0IHBsYWNlXG4gICAgICAgIGxldCBsYWJlbHMgPSBzdmcuYXBwZW5kKCdnJylcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgXCJsYWJlbHNcIik7XG5cbiAgICAgICAgbGV0IGNvbHVtbkxhYmVscyA9IGxhYmVscy5zZWxlY3RBbGwoXCIuY29sdW1uLWxhYmVsXCIpXG4gICAgICAgIC5kYXRhKGxhYmVsc0RhdGEpXG4gICAgICAgIC5lbnRlcigpLmFwcGVuZChcImdcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImNvbHVtbi1sYWJlbFwiKVxuICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICAgLy8gbGV0IHRlbXAgPSBcInRyYW5zbGF0ZShcIiArIHgoaSkgKyBcIixcIiArIChoZWlnaHQrMjApICsgXCIpXCI7IC8vIHRoaXMgaW4gcGFydGljdWxhciBsb29rcyB0byBiZSB0aGUgY2F1c2VcbiAgICAgICAgICAgIC8vICBjb25zb2xlLmxvZyh0ZW1wKTtcbiAgICAgICAgICAgICAgcmV0dXJuIFwidHJhbnNsYXRlKFwiICsgeChpKSArIFwiLFwiICsgKGhlaWdodCszMCkgKyBcIilcIjsgfSk7XG5cbiAgICAgICAgY29sdW1uTGFiZWxzLmFwcGVuZChcImxpbmVcIilcbiAgICAgICAgLnN0eWxlKFwic3Ryb2tlXCIsIFwiYmxhY2tcIilcbiAgICAgICAgLnN0eWxlKFwic3Ryb2tlLXdpZHRoXCIsIFwiMXB4XCIpXG4gICAgICAgIC5hdHRyKFwieDFcIiwgeC5yYW5nZUJhbmQoKSAvIDIpXG4gICAgICAgIC5hdHRyKFwieDJcIiwgeC5yYW5nZUJhbmQoKSAvIDIpXG4gICAgICAgIC5hdHRyKFwieTFcIiwgMClcbiAgICAgICAgLmF0dHIoXCJ5MlwiLCA1KTtcblxuICAgICAgICBjb2x1bW5MYWJlbHMuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAuYXR0cihcInhcIiwgMzApXG4gICAgICAgIC5hdHRyKFwieVwiLCB5LnJhbmdlQmFuZCgpIC8gMilcbiAgICAgICAgLmF0dHIoXCJkeVwiLCBcIi4yMmVtXCIpXG4gICAgICAgIC5hdHRyKFwidGV4dC1hbmNob3JcIiwgXCJlbmRcIilcbiAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJyb3RhdGUoLTYwKVwiKVxuICAgICAgICAudGV4dChmdW5jdGlvbihkLCBpKSB7IHJldHVybiBkOyB9KTtcblxuICAgICAgICBsZXQgcm93TGFiZWxzID0gbGFiZWxzLnNlbGVjdEFsbChcIi5yb3ctbGFiZWxcIilcbiAgICAgICAgLmRhdGEobGFiZWxzRGF0YSlcbiAgICAgICAgLmVudGVyKCkuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwicm93LWxhYmVsXCIpXG4gICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uKGQsIGkpIHsgcmV0dXJuIFwidHJhbnNsYXRlKFwiICsgMCArIFwiLFwiICsgeShpKSArIFwiKVwiOyB9KTtcblxuICAgICAgICByb3dMYWJlbHMuYXBwZW5kKFwibGluZVwiKVxuICAgICAgICAuc3R5bGUoXCJzdHJva2VcIiwgXCJibGFja1wiKVxuICAgICAgICAuc3R5bGUoXCJzdHJva2Utd2lkdGhcIiwgXCIxcHhcIilcbiAgICAgICAgLmF0dHIoXCJ4MVwiLCAwKVxuICAgICAgICAuYXR0cihcIngyXCIsIC01KVxuICAgICAgICAuYXR0cihcInkxXCIsIHkucmFuZ2VCYW5kKCkgLyAyKVxuICAgICAgICAuYXR0cihcInkyXCIsIHkucmFuZ2VCYW5kKCkgLyAyKTtcblxuICAgICAgICByb3dMYWJlbHMuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAuYXR0cihcInhcIiwgLTgpXG4gICAgICAgIC5hdHRyKFwieVwiLCB5LnJhbmdlQmFuZCgpIC8gMilcbiAgICAgICAgLmF0dHIoXCJkeVwiLCBcIi4zMmVtXCIpXG4gICAgICAgIC5hdHRyKFwidGV4dC1hbmNob3JcIiwgXCJlbmRcIilcbiAgICAgICAgLnRleHQoZnVuY3Rpb24oZCwgaSkgeyByZXR1cm4gZDsgfSk7XG5cbiAgICAgICAgbGV0IGtleSA9IGQzLnNlbGVjdChcIiNjb25mdXNpb25sZWdlbmRcIilcbiAgICAgICAgLmFwcGVuZChcInN2Z1wiKVxuICAgICAgICAuYXR0cihcIndpZHRoXCIsIHdpZHRoTGVnZW5kKVxuICAgICAgICAuYXR0cihcImhlaWdodFwiLCBoZWlnaHQgKyBtYXJnaW4udG9wICsgbWFyZ2luLmJvdHRvbSk7XG5cbiAgICAgICAgbGV0IGxlZ2VuZCA9IGtleVxuICAgICAgICAuYXBwZW5kKFwiZGVmc1wiKVxuICAgICAgICAuYXBwZW5kKFwic3ZnOmxpbmVhckdyYWRpZW50XCIpXG4gICAgICAgIC5hdHRyKFwiaWRcIiwgXCJncmFkaWVudFwiKVxuICAgICAgICAuYXR0cihcIngxXCIsIFwiMTAwJVwiKVxuICAgICAgICAuYXR0cihcInkxXCIsIFwiMCVcIilcbiAgICAgICAgLmF0dHIoXCJ4MlwiLCBcIjEwMCVcIilcbiAgICAgICAgLmF0dHIoXCJ5MlwiLCBcIjEwMCVcIilcbiAgICAgICAgLmF0dHIoXCJzcHJlYWRNZXRob2RcIiwgXCJwYWRcIik7XG5cbiAgICAgICAgbGVnZW5kXG4gICAgICAgIC5hcHBlbmQoXCJzdG9wXCIpXG4gICAgICAgIC5hdHRyKFwib2Zmc2V0XCIsIFwiMCVcIilcbiAgICAgICAgLmF0dHIoXCJzdG9wLWNvbG9yXCIsIGVuZENvbG9yKVxuICAgICAgICAuYXR0cihcInN0b3Atb3BhY2l0eVwiLCAxKTtcblxuICAgICAgICBsZWdlbmRcbiAgICAgICAgLmFwcGVuZChcInN0b3BcIilcbiAgICAgICAgLmF0dHIoXCJvZmZzZXRcIiwgXCIxMDAlXCIpXG4gICAgICAgIC5hdHRyKFwic3RvcC1jb2xvclwiLCBzdGFydENvbG9yKVxuICAgICAgICAuYXR0cihcInN0b3Atb3BhY2l0eVwiLCAxKTtcblxuICAgICAgICBrZXkuYXBwZW5kKFwicmVjdFwiKVxuICAgICAgICAuYXR0cihcIndpZHRoXCIsIHdpZHRoTGVnZW5kLzItMTApXG4gICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGhlaWdodClcbiAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBcInVybCgjZ3JhZGllbnQpXCIpXG4gICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsXCIgKyBtYXJnaW4udG9wICsgXCIpXCIpO1xuXG4gICAgICAgIC8vIHRoaXMgeSBpcyBmb3IgdGhlIGxlZ2VuZFxuICAgICAgICB5ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLnJhbmdlKFtoZWlnaHQsIDBdKVxuICAgICAgICAuZG9tYWluKFttaW5WYWx1ZSwgbWF4VmFsdWVdKTtcblxuICAgICAgICBsZXQgeUF4aXMgPSBkMy5zdmcuYXhpcygpXG4gICAgICAgIC5zY2FsZSh5KVxuICAgICAgICAub3JpZW50KFwicmlnaHRcIik7XG5cbiAgICAgICAga2V5LmFwcGVuZChcImdcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInkgYXhpc1wiKVxuICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSg0MSxcIiArIG1hcmdpbi50b3AgKyBcIilcIilcbiAgICAgICAgLmNhbGwoeUF4aXMpXG5cbiAgICB9XG5cbiAgICAvLyBUaGUgdGFibGUgZ2VuZXJhdGlvbiBmdW5jdGlvbi4gVXNlZCBmb3IgdGhlIHRhYmxlIG9mIHBlcmZvcm1hbmNlIG1lYXN1cmVzLCBub3QgdGhlIGNvbmZ1c2lvbiBtYXRyaXhcbiAgICBmdW5jdGlvbiB0YWJ1bGF0ZShkYXRhLCBjb2x1bW5zKSB7XG4gICAgICAgIHZhciB0YWJsZSA9IGQzLnNlbGVjdChcIiNzZXR4TWlkZGxlXCIpLmFwcGVuZChcInRhYmxlXCIpXG4gICAgICAgIC5hdHRyKFwic3R5bGVcIiwgXCJtYXJnaW4tbGVmdDogXCIgKyBtYXJnaW4ubGVmdCArXCJweFwiKSxcbiAgICAgICAgdGhlYWQgPSB0YWJsZS5hcHBlbmQoXCJ0aGVhZFwiKSxcbiAgICAgICAgdGJvZHkgPSB0YWJsZS5hcHBlbmQoXCJ0Ym9keVwiKTtcblxuICAgICAgICAvLyBhcHBlbmQgdGhlIGhlYWRlciByb3dcbiAgICAgICAgdGhlYWQuYXBwZW5kKFwidHJcIilcbiAgICAgICAgLnNlbGVjdEFsbChcInRoXCIpXG4gICAgICAgIC5kYXRhKGNvbHVtbnMpXG4gICAgICAgIC5lbnRlcigpXG4gICAgICAgIC5hcHBlbmQoXCJ0aFwiKVxuICAgICAgICAudGV4dChmdW5jdGlvbihjb2x1bW4pIHsgcmV0dXJuIGNvbHVtbjsgfSk7XG5cbiAgICAgICAgLy8gY3JlYXRlIGEgcm93IGZvciBlYWNoIG9iamVjdCBpbiB0aGUgZGF0YVxuICAgICAgICB2YXIgcm93cyA9IHRib2R5LnNlbGVjdEFsbChcInRyXCIpXG4gICAgICAgIC5kYXRhKGRhdGEpXG4gICAgICAgIC5lbnRlcigpXG4gICAgICAgIC5hcHBlbmQoXCJ0clwiKTtcblxuICAgICAgICAvLyBjcmVhdGUgYSBjZWxsIGluIGVhY2ggcm93IGZvciBlYWNoIGNvbHVtblxuICAgICAgICB2YXIgY2VsbHMgPSByb3dzLnNlbGVjdEFsbChcInRkXCIpXG4gICAgICAgIC5kYXRhKGZ1bmN0aW9uKHJvdykge1xuICAgICAgICAgICAgICByZXR1cm4gY29sdW1ucy5tYXAoZnVuY3Rpb24oY29sdW1uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge2NvbHVtbjogY29sdW1uLCB2YWx1ZTogcm93W2NvbHVtbl19O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgIC5lbnRlcigpXG4gICAgICAgIC5hcHBlbmQoXCJ0ZFwiKVxuICAgICAgICAuYXR0cihcInN0eWxlXCIsIFwiZm9udC1mYW1pbHk6IENvdXJpZXJcIikgLy8gc2V0cyB0aGUgZm9udCBzdHlsZVxuICAgICAgICAuaHRtbChmdW5jdGlvbihkKSB7IHJldHVybiBkLnZhbHVlOyB9KTtcblxuICAgICAgICByZXR1cm4gdGFibGU7XG4gICAgfVxuXG5cblxuICAgIC8vIHRoaXMgY29kZSBpcyBhbGwgZm9yIHByb2R1Y2luZyBhIHRhYmxlIHdpdGggcGVyZm9ybWFuY2UgbWVhc3VyZXNcbiAgICAvL3ZhciBjb25mdXNpb25NYXRyaXggPSBbWzE2OSwgMTBdLFs3LCA0Nl1dO1xuICAgIHZhciB0cCA9IG1hdHJpeGRhdGFbMF1bMF07XG4gICAgdmFyIGZuID0gbWF0cml4ZGF0YVswXVsxXTtcbiAgICB2YXIgZnAgPSBtYXRyaXhkYXRhWzFdWzBdO1xuICAgIHZhciB0biA9IG1hdHJpeGRhdGFbMV1bMV07XG5cbiAgICB2YXIgcCA9IHRwICsgZm47XG4gICAgdmFyIG4gPSBmcCArIHRuO1xuXG4gICAgdmFyIGFjY3VyYWN5ID0gKHRwK3RuKS8ocCtuKTtcbiAgICB2YXIgZjEgPSAyKnRwLygyKnRwK2ZwK2ZuKTtcbiAgICB2YXIgcHJlY2lzaW9uID0gdHAvKHRwK2ZwKTtcbiAgICB2YXIgcmVjYWxsID0gdHAvKHRwK2ZuKTtcblxuICAgIGFjY3VyYWN5ID0gTWF0aC5yb3VuZChhY2N1cmFjeSAqIDEwMCkgLyAxMDBcbiAgICBmMSA9IE1hdGgucm91bmQoZjEgKiAxMDApIC8gMTAwXG4gICAgcHJlY2lzaW9uID0gTWF0aC5yb3VuZChwcmVjaXNpb24gKiAxMDApIC8gMTAwXG4gICAgcmVjYWxsID0gTWF0aC5yb3VuZChyZWNhbGwgKiAxMDApIC8gMTAwXG5cbiAgICB2YXIgY29tcHV0ZWREYXRhID0gW107XG4gICAgY29tcHV0ZWREYXRhLnB1c2goe1wiRjFcIjpmMSwgXCJQUkVDSVNJT05cIjpwcmVjaXNpb24sXCJSRUNBTExcIjpyZWNhbGwsXCJBQ0NVUkFDWVwiOmFjY3VyYWN5fSk7XG5cbiAgICBNYXRyaXgoe1xuICAgICAgICAgICBjb250YWluZXIgOiAnI2NvbmZ1c2lvbmNvbnRhaW5lcicsXG4gICAgICAgICAgIGRhdGEgICAgICA6IG1hdHJpeGRhdGEsXG4gICAgICAgICAgIGxhYmVscyAgICA6IGNsYXNzZXMsXG4gICAgICAgICAgIHN0YXJ0X2NvbG9yIDogJyNmZmZmZmYnLFxuICAgICAgICAgICBlbmRfY29sb3IgOiAnI2U2N2UyMicsXG4gICAgICAgICAgIHdpZHRoIDogbWFpbndpZHRoICogLjE1LFxuICAgICAgICAgICBoZWlnaHQgOiBtYWluaGVpZ2h0ICogLjI1LFxuICAgICAgICAgICB3aWR0aExlZ2VuZCA6IG1haW53aWR0aCouMDVcbiAgICAgICAgICAgfSk7XG5cbiAgICAvLyBub3QgcmVuZGVyaW5nIHRoaXMgdGFibGUgZm9yIHJpZ2h0IG5vdywgbGVmdCBhbGwgdGhlIGNvZGUgaW4gcGxhY2UgdGhvdWdoLiBtYXliZSB3ZSB1c2UgaXQgZXZlbnR1YWxseVxuICAvLyAgdmFyIHRhYmxlID0gdGFidWxhdGUoY29tcHV0ZWREYXRhLCBbXCJGMVwiLCBcIlBSRUNJU0lPTlwiLFwiUkVDQUxMXCIsXCJBQ0NVUkFDWVwiXSk7XG5cblxufVxuXG5cbi8vIHNjYXR0ZXJwbG90IGZ1bmN0aW9uIHRvIGdvIHRvIHBsb3RzLmpzIHRvIGJlIHJldXNlZFxuZXhwb3J0IGZ1bmN0aW9uIGJpdmFyaWF0ZVBsb3QoeF9BeGlzLCB5X0F4aXMsIHhfQXhpc19uYW1lLCB5X0F4aXNfbmFtZSkge1xuXG4gICAgZDMuc2VsZWN0KFwiI3NldHhNaWRkbGVcIikuaHRtbChcIlwiKTtcbiAgICBkMy5zZWxlY3QoXCIjc2V0eE1pZGRsZVwiKS5zZWxlY3QoXCJzdmdcIikucmVtb3ZlKCk7XG5cbiAgICBsZXQgbWFpbndpZHRoID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21haW4nKS5jbGllbnRXaWR0aDtcbiAgICBsZXQgbWFpbmhlaWdodCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtYWluJykuY2xpZW50SGVpZ2h0O1xuXG4gICAgLy8gc2NhdHRlciBwbG90XG5cbiAgICBsZXQgZGF0YV9wbG90ID0gW107XG4gICAgdmFyIG5hbkNvdW50ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhfQXhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaXNOYU4oeF9BeGlzW2ldKSB8fCBpc05hTih5X0F4aXNbaV0pKSB7XG4gICAgICAgICAgICBuYW5Db3VudCsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG5ld051bWJlcjEgPSB4X0F4aXNbaV07XG4gICAgICAgICAgICB2YXIgbmV3TnVtYmVyMiA9IHlfQXhpc1tpXTtcbiAgICAgICAgICAgIGRhdGFfcGxvdC5wdXNoKHt4YXhpczogbmV3TnVtYmVyMSwgeWF4aXM6IG5ld051bWJlcjIsIHNjb3JlOiBNYXRoLnJhbmRvbSgpICogMTAwfSk7XG5cbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgdmFyIG1hcmdpbiA9IHt0b3A6IDM1LCByaWdodDogMzUsIGJvdHRvbTogMzUsIGxlZnQ6IDM1fVxuICAgICwgd2lkdGggPSBtYWlud2lkdGgqLjI1LSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodFxuICAgICwgaGVpZ2h0ID0gbWFpbndpZHRoKi4yNSAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xuICAgIHZhciBwYWRkaW5nID0gMTAwO1xuXG4gICAgdmFyIG1pbl94ID0gZDMubWluKGRhdGFfcGxvdCwgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFfcGxvdFtpXS54YXhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgdmFyIG1heF94ID0gZDMubWF4KGRhdGFfcGxvdCwgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFfcGxvdFtpXS54YXhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgdmFyIGF2Z194ID0gKG1heF94IC0gbWluX3gpIC8gMTA7XG4gICAgdmFyIG1pbl95ID0gZDMubWluKGRhdGFfcGxvdCwgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFfcGxvdFtpXS55YXhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgdmFyIG1heF95ID0gZDMubWF4KGRhdGFfcGxvdCwgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFfcGxvdFtpXS55YXhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgdmFyIGF2Z195ID0gKG1heF95IC0gbWluX3kpIC8gMTA7XG5cbiAgICB2YXIgeFNjYWxlID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAuZG9tYWluKFttaW5feCAtIGF2Z194LCBtYXhfeCArIGF2Z194XSlcbiAgICAucmFuZ2UoWzAsIHdpZHRoXSk7XG5cbiAgICB2YXIgeVNjYWxlID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAuZG9tYWluKFttaW5feSAtIGF2Z195LCBtYXhfeSArIGF2Z195XSlcbiAgICAucmFuZ2UoW2hlaWdodCwgMF0pO1xuXG4gICAgdmFyIHhBeGlzID0gZDMuc3ZnLmF4aXMoKVxuICAgIC5zY2FsZSh4U2NhbGUpXG4gICAgLm9yaWVudCgnYm90dG9tJylcbiAgICAudGlja1NpemUoLWhlaWdodCk7XG5cbiAgICB2YXIgeUF4aXMgPSBkMy5zdmcuYXhpcygpXG4gICAgLnNjYWxlKHlTY2FsZSlcbiAgICAub3JpZW50KCdsZWZ0JylcbiAgICAudGlja3MoNSlcbiAgICAudGlja1NpemUoLXdpZHRoKTtcblxuICAgIHZhciB6b29tID0gZDMuYmVoYXZpb3Iuem9vbSgpXG4gICAgLngoeFNjYWxlKVxuICAgIC55KHlTY2FsZSlcbiAgICAuc2NhbGVFeHRlbnQoWzEsIDEwXSlcbiAgICAub24oXCJ6b29tXCIsIHpvb21lZCk7XG5cbiAgICB2YXIgY2hhcnRfc2NhdHRlciA9IGQzLnNlbGVjdCgnI3NldHhNaWRkbGUnKVxuICAgIC5hcHBlbmQoJ3N2ZzpzdmcnKVxuICAgIC5hdHRyKCd3aWR0aCcsIHdpZHRoICsgbWFyZ2luLnJpZ2h0ICsgbWFyZ2luLmxlZnQpXG4gICAgLmF0dHIoJ2hlaWdodCcsIGhlaWdodCArIG1hcmdpbi50b3AgKyBtYXJnaW4uYm90dG9tKTtcbiAgIC8vIC5jYWxsKHpvb20pOyBkcm9wcGluZyB0aGlzIGZvciBub3csIHVudGlsIHRoZSBsaW5lIHpvb21zIHByb3Blcmx5XG5cbiAgICB2YXIgbWFpbjEgPSBjaGFydF9zY2F0dGVyLmFwcGVuZCgnZycpXG4gICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIG1hcmdpbi5sZWZ0ICsgJywnICsgbWFyZ2luLnRvcCArICcpJylcbiAgICAuYXR0cignd2lkdGgnLCB3aWR0aCsgbWFyZ2luLnJpZ2h0ICsgbWFyZ2luLmxlZnQpXG4gICAgLmF0dHIoJ2hlaWdodCcsIGhlaWdodCArIG1hcmdpbi50b3AgKyBtYXJnaW4uYm90dG9tKVxuICAgIC5hdHRyKCdjbGFzcycsICdtYWluJyk7XG5cbiAgICBsZXQgZ1ggPSBtYWluMS5hcHBlbmQoJ2cnKVxuICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsJyArIGhlaWdodCArICcpJylcbiAgICAuYXR0cignY2xhc3MnLCAneCBheGlzJylcbiAgICAuY2FsbCh4QXhpcyk7XG5cbiAgICBsZXQgZ1kgPSBtYWluMS5hcHBlbmQoJ2cnKVxuICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsMCknKVxuICAgIC5hdHRyKCdjbGFzcycsICd5IGF4aXMnKVxuICAgIC5jYWxsKHlBeGlzKTtcblxuICAgIHZhciBjbGlwID0gbWFpbjEuYXBwZW5kKFwiZGVmc1wiKS5hcHBlbmQoXCJzdmc6Y2xpcFBhdGhcIilcbiAgICAuYXR0cihcImlkXCIsIFwiY2xpcFwiKVxuICAgIC5hcHBlbmQoXCJzdmc6cmVjdFwiKVxuICAgIC5hdHRyKFwiaWRcIiwgXCJjbGlwLXJlY3RcIilcbiAgICAuYXR0cihcInhcIiwgXCIwXCIpXG4gICAgLmF0dHIoXCJ5XCIsIFwiMFwiKVxuICAgIC5hdHRyKCd3aWR0aCcsIHdpZHRoKVxuICAgIC5hdHRyKCdoZWlnaHQnLCBoZWlnaHQpO1xuXG4gICAgbWFpbjEuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xpcC1wYXRoXCIsIFwidXJsKCNjbGlwKVwiKVxuICAgIC5zZWxlY3RBbGwoXCJjaXJjbGVcIilcbiAgICAuZGF0YShkYXRhX3Bsb3QpXG4gICAgLmVudGVyKClcbiAgICAuYXBwZW5kKFwiY2lyY2xlXCIpXG4gICAgLmF0dHIoXCJjeFwiLCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgIHJldHVybiB4U2NhbGUoZGF0YV9wbG90W2ldLnhheGlzKTtcbiAgICAgICAgICB9KVxuICAgIC5hdHRyKFwiY3lcIiwgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICByZXR1cm4geVNjYWxlKGRhdGFfcGxvdFtpXS55YXhpcyk7XG4gICAgICAgICAgfSlcbiAgICAuYXR0cihcInJcIiwgMilcbiAgICAuc3R5bGUoXCJmaWxsXCIsIFwiI0I3MUMxQ1wiKVxuICAgIDtcblxuXG4gICAgY2hhcnRfc2NhdHRlci5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKSAgLy8gdGhpcyBtYWtlcyBpdCBlYXN5IHRvIGNlbnRyZSB0aGUgdGV4dCBhcyB0aGUgdHJhbnNmb3JtIGlzIGFwcGxpZWQgdG8gdGhlIGFuY2hvclxuICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgcGFkZGluZyAvIDUgKyBcIixcIiArIChoZWlnaHQgLyAyKSArIFwiKXJvdGF0ZSgtOTApXCIpICAvLyB0ZXh0IGlzIGRyYXduIG9mZiB0aGUgc2NyZWVuIHRvcCBsZWZ0LCBtb3ZlIGRvd24gYW5kIG91dCBhbmQgcm90YXRlXG4gICAgLnRleHQoeV9BeGlzX25hbWUpXG4gICAgLnN0eWxlKFwiZmlsbFwiLCBcIiM0MjQyNDJcIilcbiAgICAuc3R5bGUoXCJ0ZXh0LWluZGVudFwiLFwiMjBweFwiKVxuICAgIC5zdHlsZShcImZvbnQtc2l6ZVwiLFwiMTJweFwiKVxuICAgIC5zdHlsZShcImZvbnQtd2VpZ2h0XCIsXCJib2xkXCIpO1xuXG4gICAgY2hhcnRfc2NhdHRlci5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKSAgLy8gdGhpcyBtYWtlcyBpdCBlYXN5IHRvIGNlbnRyZSB0aGUgdGV4dCBhcyB0aGUgdHJhbnNmb3JtIGlzIGFwcGxpZWQgdG8gdGhlIGFuY2hvclxuICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgKHdpZHRoIC8gMikgKyBcIixcIiArIChoZWlnaHQgKyAocGFkZGluZyAvIDIpKSArIFwiKVwiKSAgLy8gY2VudHJlIGJlbG93IGF4aXNcbiAgICAudGV4dCh4X0F4aXNfbmFtZSlcbiAgICAuc3R5bGUoXCJmaWxsXCIsIFwiIzQyNDI0MlwiKVxuICAgIC5zdHlsZShcInRleHQtaW5kZW50XCIsXCIyMHB4XCIpXG4gICAgLnN0eWxlKFwiZm9udC1zaXplXCIsXCIxMnB4XCIpXG4gICAgLnN0eWxlKFwiZm9udC13ZWlnaHRcIixcImJvbGRcIik7XG5cblxuICAgIG1haW4xLmFwcGVuZChcImxpbmVcIilcbiAgICAuYXR0cihcIngxXCIsIHhTY2FsZShtaW5feCkpXG4gICAgLmF0dHIoXCJ5MVwiLCB5U2NhbGUobWluX3gpKVxuICAgIC5hdHRyKFwieDJcIiwgeFNjYWxlKG1heF94KSlcbiAgICAuYXR0cihcInkyXCIsIHlTY2FsZShtYXhfeCkpXG4gICAgLmF0dHIoXCJzdHJva2Utd2lkdGhcIiwgMilcbiAgICAuYXR0cihcInN0cm9rZVwiLCBcImJsYWNrXCIpO1xuXG4gICAgZnVuY3Rpb24gem9vbWVkKCkge1xuICAgICAgICB2YXIgcGFuWCA9IGQzLmV2ZW50LnRyYW5zbGF0ZVswXTtcbiAgICAgICAgdmFyIHBhblkgPSBkMy5ldmVudC50cmFuc2xhdGVbMV07XG4gICAgICAgIHZhciBzY2FsZSA9IGQzLmV2ZW50LnNjYWxlO1xuXG4gICAgICAgIHBhblggPSBwYW5YID4gMTAgPyAxMCA6IHBhblg7XG4gICAgICAgIHZhciBtYXhYID0gLShzY2FsZSAtIDEpICogd2lkdGggLSAxMDtcbiAgICAgICAgcGFuWCA9IHBhblggPCBtYXhYID8gbWF4WCA6IHBhblg7XG5cbiAgICAgICAgcGFuWSA9IHBhblkgPiAxMCA/IDEwIDogcGFuWTtcbiAgICAgICAgdmFyIG1heFkgPSAtKHNjYWxlIC0gMSkgKiBoZWlnaHQgLSAxMDtcbiAgICAgICAgcGFuWSA9IHBhblkgPCBtYXhZID8gbWF4WSA6IHBhblk7XG5cbiAgICAgICAgem9vbS50cmFuc2xhdGUoW3BhblgsIHBhblldKTtcblxuXG4gICAgICAgIG1haW4xLnNlbGVjdChcIi54LmF4aXNcIikuY2FsbCh4QXhpcyk7XG4gICAgICAgIG1haW4xLnNlbGVjdChcIi55LmF4aXNcIikuY2FsbCh5QXhpcyk7XG4gICAgICAgIG1haW4xLnNlbGVjdEFsbChcImNpcmNsZVwiKVxuICAgICAgICAuYXR0cihcImN4XCIsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY2lyY2xlIHggXCIseFNjYWxlKDUpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHhTY2FsZShkYXRhX3Bsb3RbaV0ueGF4aXMpO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAuYXR0cihcImN5XCIsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB5U2NhbGUoZGF0YV9wbG90W2ldLnlheGlzKTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoXCJyXCIsIDIuNSlcbiAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBcIiNCNzFDMUNcIilcbiAgICAgICAgO1xuXG4gICAgICAgLy8gYmVsb3cgZG9lc24ndCB3b3JrLCBzbyBJJ20ganVzdCBkcm9wcGluZyB0aGUgem9vbVxuICAgICAgICBtYWluMS5zZWxlY3QoXCJsaW5lXCIpXG4gICAgICAgIC5hdHRyKFwieDFcIiwgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgICByZXR1cm4geFNjYWxlKG1pbl94KTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoXCJ5MVwiLCBmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB4U2NhbGUobWluX3gpO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAuYXR0cihcIngyXCIsIGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHhTY2FsZShtYXhfeCk7XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgIC5hdHRyKFwieTJcIiwgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgICByZXR1cm4geVNjYWxlKG1heF94KTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoXCJzdHJva2Utd2lkdGhcIiwgMilcbiAgICAgICAgLmF0dHIoXCJzdHJva2VcIiwgXCJibGFja1wiKTtcbiAgICB9XG5cblxuXG4gIC8vICBkMy5zZWxlY3QoXCIjTkFjb3VudFwiKS50ZXh0KFwiVGhlcmUgYXJlIFwiICsgbmFuQ291bnQgKyBcIiBudW1iZXIgb2YgTkEgdmFsdWVzIGluIHRoZSByZWxhdGlvbi5cIik7XG5cblxufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBzZXR4VGFibGUoZmVhdHVyZXMpIHtcbiAgICBmdW5jdGlvbiB0YWJ1bGF0ZShkYXRhLCBjb2x1bW5zKSB7XG4gICAgICAgIHZhciB0YWJsZSA9IGQzLnNlbGVjdCgnI3NldHhSaWdodEJvdHRvbUxlZnQnKS5hcHBlbmQoJ3RhYmxlJylcbiAgICAgICAgdmFyIHRoZWFkID0gdGFibGUuYXBwZW5kKCd0aGVhZCcpXG4gICAgICAgIHZhclx0dGJvZHkgPSB0YWJsZS5hcHBlbmQoJ3Rib2R5Jyk7XG5cbiAgICAgICAgLy8gYXBwZW5kIHRoZSBoZWFkZXIgcm93XG4gICAgICAgIHRoZWFkLmFwcGVuZCgndHInKVxuICAgICAgICAuc2VsZWN0QWxsKCd0aCcpXG4gICAgICAgIC5kYXRhKGNvbHVtbnMpLmVudGVyKClcbiAgICAgICAgLmFwcGVuZCgndGgnKVxuICAgICAgICAudGV4dChmdW5jdGlvbiAoY29sdW1uKSB7IHJldHVybiBjb2x1bW47IH0pO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBhIHJvdyBmb3IgZWFjaCBvYmplY3QgaW4gdGhlIGRhdGFcbiAgICAgICAgdmFyIHJvd3MgPSB0Ym9keS5zZWxlY3RBbGwoJ3RyJylcbiAgICAgICAgLmRhdGEoZGF0YSlcbiAgICAgICAgLmVudGVyKClcbiAgICAgICAgLmFwcGVuZCgndHInKTtcblxuICAgICAgICAvLyBjcmVhdGUgYSBjZWxsIGluIGVhY2ggcm93IGZvciBlYWNoIGNvbHVtblxuICAgICAgICB2YXIgY2VsbHMgPSByb3dzLnNlbGVjdEFsbCgndGQnKVxuICAgICAgICAuZGF0YShmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgICAgIHJldHVybiBjb2x1bW5zLm1hcChmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge2NvbHVtbjogY29sdW1uLCB2YWx1ZTogcm93W2NvbHVtbl19O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgIC5lbnRlcigpXG4gICAgICAgIC5hcHBlbmQoJ3RkJylcbiAgICAgICAgLnRleHQoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQudmFsdWU7IH0pXG4gICAgICAgIC5hdHRyKCdpZCcsZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgIGxldCByb3duYW1lID0gdGhpcy5wYXJlbnRFbGVtZW50LmZpcnN0Q2hpbGQuaW5uZXJUZXh0O1xuICAgICAgICAgICAgICByZXR1cm4gcm93bmFtZSArIGQuY29sdW1uO1xuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGFibGU7XG4gICAgfVxuXG5cbiAgICBsZXQgbXlkYXRhID0gW107XG4gICAgZm9yKGxldCBpID0gMDsgaTxmZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZihhbGxOb2Rlc1tmaW5kTm9kZUluZGV4KGZlYXR1cmVzW2ldKV0udmFsaWQ9PTApIHtcbiAgICAgICAgICAgIHh2YWw9MDtcbiAgICAgICAgICAgIHgxdmFsPTA7XG4gICAgICAgICAgICBteWRhdGEucHVzaCh7XCJWYXJpYWJsZXNcIjpmZWF0dXJlc1tpXSxcIkZyb21cIjp4dmFsLCBcIlRvXCI6eDF2YWx9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG15aSA9IGkrMTtcbiAgICAgICAgbGV0IG15c3ZnID0gZmVhdHVyZXNbaV0rXCJfc2V0eExlZnRfXCIrbXlpO1xuICAgICAgICBsZXQgeHZhbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG15c3ZnKS5xdWVyeVNlbGVjdG9yKCcueHZhbCcpLmlubmVySFRNTDtcbiAgICAgICAgbGV0IHgxdmFsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobXlzdmcpLnF1ZXJ5U2VsZWN0b3IoJy54MXZhbCcpLmlubmVySFRNTDtcbiAgICAgICAgeHZhbCA9IHh2YWwuc3BsaXQoXCJ4OiBcIikucG9wKClcbiAgICAgICAgeDF2YWwgPSB4MXZhbC5zcGxpdChcIngxOiBcIikucG9wKClcbiAgICAgICAgY29uc29sZS5sb2coeHZhbCk7XG4gICAgICAgIGNvbnNvbGUubG9nKG15c3ZnKTtcblxuICAgICAgICBteWRhdGEucHVzaCh7XCJWYXJpYWJsZXNcIjpmZWF0dXJlc1tpXSxcIkZyb21cIjp4dmFsLCBcIlRvXCI6eDF2YWx9KTtcbiAgICB9XG5cbiAgICAvLyByZW5kZXIgdGhlIHRhYmxlKHMpXG4gICAgdGFidWxhdGUobXlkYXRhLCBbJ1ZhcmlhYmxlcycsICdGcm9tJywgJ1RvJ10pOyAvLyAyIGNvbHVtbiB0YWJsZVxufVxuXG5cbi8vcnBjIEV4cG9ydFBpcGVsaW5lKFBpcGVsaW5lRXhwb3J0UmVxdWVzdCkgcmV0dXJucyAoUmVzcG9uc2UpIHt9XG5leHBvcnQgZnVuY3Rpb24gZXhwb3J0cGlwZWxpbmUocGlwZWxpbmVJZCkge1xuICAgIGNvbnNvbGUubG9nKHBpcGVsaW5lSWQpO1xuICAgIGxldCBjb250ZXh0ID0gYXBpU2Vzc2lvbih6cGFyYW1zLnpzZXNzaW9uaWQpO1xuICAgIGxldCBwaXBlbGluZUV4ZWNVcmkgPSBcIjw8RVhFQ1VUQUJMRV9VUkk+PlwiOyAvLyB1cmkgdG8gcGVyc2lzdCBleGVjdXRhYmxlIG9mIHJlcXVlc3RlZCBwaXBlbGluZSB3LyBzZXNzaW9uIHByZXByb2Nlc3NpbmdcblxuICAgIGxldCBQaXBlbGluZUV4cG9ydFJlcXVlc3Q9e2NvbnRleHQsIHBpcGVsaW5lSWQsIHBpcGVsaW5lRXhlY1VyaX07XG5cbiAgICBsZXQganNvbm91dCA9IEpTT04uc3RyaW5naWZ5KFBpcGVsaW5lRXhwb3J0UmVxdWVzdCk7XG5cbiAgICBsZXQgdXJsY2FsbCA9IGQzbVVSTCArIFwiL2V4cG9ydHBpcGVsaW5lXCI7XG4gICAgbGV0IHNvbGFqc29ub3V0ID0gXCJncnBjcmVxdWVzdD1cIiArIGpzb25vdXQ7XG5cbiAgICBjb25zb2xlLmxvZyh1cmxjYWxsKTtcbiAgICBjb25zb2xlLmxvZyhzb2xhanNvbm91dCk7XG5cbiAgICBmdW5jdGlvbiBleHBvcnRTdWNjZXNzKGJ0biwgUmVzcG9uc2UpIHtcbiAgICAgICAgbGV0IGFsZXJ0bWVzc2FnZSA9IFwiRXhlY3V0YWJsZSBmb3IgXCIgKyBwaXBlbGluZUlkICsgXCIgaGFzIGJlZW4gd3JpdHRlblwiO1xuICAgICAgICBhbGVydChhbGVydG1lc3NhZ2UpO1xuICAgICAgICBjb25zb2xlLmxvZyhSZXNwb25zZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhwb3J0RmFpbChidG4pIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJleHBvcnQgcGlwZWxpbmUgZmFpbGVkXCIpO1xuICAgIH1cblxuICAgIG1ha2VDb3JzUmVxdWVzdCh1cmxjYWxsLCBcIm5vYnV0dG9uXCIsIGV4cG9ydFN1Y2Nlc3MsIGV4cG9ydEZhaWwsIHNvbGFqc29ub3V0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlbGV0ZXBpcGVsaW5lICgpIHtcbiAgICBjb25zb2xlLmxvZyhcIkRFTEVURSBDQUxMRURcIik7XG59XG5cblxuLy8gRDNNIEFQSSBIRUxQRVJTXG4vLyBiZWNhdXNlIHRoZXNlIGdldCBidWlsdCBpbiB2YXJpb3VzIHBsYWNlcywgcHVsbGluZyB0aGVtIG91dCBmb3IgZWFzeSBtYW5pcHVsYXRpb25cbmZ1bmN0aW9uIGFwaUZlYXR1cmUgKHZhcnMsIHVyaSkge1xuICAgIGxldCBvdXQgPSBbXTtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgdmFycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBvdXQucHVzaCh7ZmVhdHVyZUlkOnZhcnNbaV0sZGF0YVVyaTp1cml9KTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn1cblxuZnVuY3Rpb24gYXBpRmVhdHVyZVNob3J0UGF0aCAodmFycywgdXJpKSB7XG4gICAgbGV0IG91dCA9IFtdO1xuICAgIGxldCBzaG9ydFVyaSA9IHVyaS5zdWJzdHJpbmcoMCwgdXJpLmxhc3RJbmRleE9mKFwiL1wiKSk7XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IHZhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgb3V0LnB1c2goe2ZlYXR1cmVJZDp2YXJzW2ldLGRhdGFVcmk6c2hvcnRVcml9KTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn1cblxuXG4vLyBzaWxseSBidXQgcGVyaGFwcyB1c2VmdWwgaWYgaW4gdGhlIGZ1dHVyZSBTZXNzaW9uQ29udGV4dCByZXF1aXJlcyBtb3JlIHRoaW5ncyAoYXMgc3VnZ2VzdCBieSBjb3JlKVxuZnVuY3Rpb24gYXBpU2Vzc2lvbiAoY29udGV4dCkge1xuICAgIHJldHVybiB7XCJzZXNzaW9uX2lkXCI6Y29udGV4dH07XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9hc3NldHMvYXBwL2FwcC5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1\n')},function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();\n\nexports.density = density;\nexports.bars = bars;\nexports.barsSubset = barsSubset;\nexports.densityNode = densityNode;\nexports.barsNode = barsNode;\nvar d3Color = \'#1f77b4\'; // d3\'s default blue\nvar selVarColor = exports.selVarColor = \'#fa8072\'; // d3.rgb("salmon");\n\n// function to use d3 to graph density plots with preprocessed data\nfunction density(node, div, priv) {\n    div = { subset: \'#tab2\', setxLeft: \'#setxLeft\', varSummary: \'#tab3\' }[div];\n    if (!div) return alert("Error: incorrect div selected for plots");\n\n    var _ref = [node.plotx, node.ploty],\n        xVals = _ref[0],\n        yVals = _ref[1];\n\n    if (priv && node.plotCI) {\n        var _map = [\'upperBound\', \'lowerBound\'].map(function (bound) {\n            return xVals.map(function (x, i) {\n                return { x: +x, y: +node.plotCI[bound][i] };\n            });\n        }),\n            _map2 = _slicedToArray(_map, 2),\n            _upperError = _map2[0],\n            _lowerError = _map2[1];\n\n        console.log(\'upperError\\n\', _upperError);\n    }\n\n    var tempWidth = d3.select(div).style("width");\n    var width = tempWidth.substring(0, tempWidth.length - 2);\n\n    var tw = document.getElementById(\'main\').offsetWidth;\n\n    var tempHeight = d3.select(div).style("height");\n    var height = tempHeight.substring(0, tempHeight.length - 2);\n    var margin = {\n        top: 20,\n        right: 20,\n        bottom: 53,\n        left: 10\n    };\n\n    // Need to fix automatic width and height settings for leftpanel (#tab2, #tab3)\n    if (div == "#tab3") {\n        width = 0.7 * (width - margin.left - margin.right), height = 0.3 * (height - margin.top - margin.bottom);\n    } else if (div == "#tab2") {\n        width = 200;\n        height = 120;\n    } else if (div == "#setxLeft") {\n        width = tw * .185 - margin.left - margin.right; //rightpanel.expand is 40 percent, setxLeft to 50 percent, toggle bar is 16px, padding, it\'s all about .185\n        height = width * .6; //height to width is .6\n    } else {\n        width = 0.35 * (width - margin.left - margin.right), height = 0.25 * (height - margin.top - margin.bottom);\n    };\n\n    var x = d3.scale.linear().domain([d3.min(xVals), d3.max(xVals)]).range([0, width]);\n    var invx = d3.scale.linear().range([d3.min(xVals), d3.max(xVals)]).domain([0, width]);\n    var y = d3.scale.linear().domain([d3.min(yVals), d3.max(yVals)]).range([height, 0]);\n    var xAxis = d3.svg.axis().scale(x).ticks(5).orient("bottom");\n    var yAxis = d3.svg.axis().scale(y).orient("left");\n    var brush = d3.svg.brush().x(x).extent(node.subsetrange).on("brush", brushed);\n    var brush2 = d3.svg.brush().x(x).on("brush", brushed2);\n    var area = d3.svg.area().interpolate("monotone").x(function (d) {\n        return x(d.x);\n    }).y0(height).y1(function (d) {\n        return y(d.y);\n    });\n    var line = d3.svg.line().x(function (d) {\n        return x(d.x);\n    }).y(function (d) {\n        return y(d.y);\n    }).interpolate("monotone");\n\n    // cumbersome to treat "tab3" differently, but works for now\n    // tab3, has an issue, that unless width height hardcoded, they grow with each additional graph.\n    if (div == "#tab3") {\n        var plotsvg = d3.select(div).selectAll("svg").remove();\n        plotsvg = d3.select(div).append("svg").attr("id", function () {\n            return node.name.toString().concat(div.substr(1));\n        }).style("width", 300) // set height to the height of #main.left\n        .style("height", 200).append("g").attr("transform", \'translate(\' + margin.left + \',\' + margin.top + \')\');\n    } else {\n        var plotsvg = d3.select(div).append("svg").attr("id", function () {\n            return node.name.toString().replace(/\\(|\\)/g, "").concat("_", div.substr(1), "_", node.id);\n        }).style("width", width + margin.left + margin.right) //setting height to the height of #main.left\n        .style("height", height + margin.top + margin.bottom).append("g").attr("transform", \'translate(\' + margin.left + \',\' + margin.top + \')\');\n    };\n    plotsvg.append("path").datum(xVals.map(function (x, i) {\n        return { x: +x, y: +node.ploty[i] };\n    })).attr("class", "area").attr("d", area);\n\n    //add upper bound\n    priv && node.plotCI && plotsvg.append("path").attr("class", "upperError").datum(upperError).attr("d", area);\n\n    //add lower bound\n    priv && node.plotCI && plotsvg.append("path").attr("class", "lowerError").datum(lowerError).attr("d", area);\n\n    plotsvg.append("g").attr("class", "x axis").attr("transform", "translate(0," + height + ")").call(xAxis);\n\n    plotsvg.append("text").attr("x", width / 2).attr("y", 0 - margin.top / 2).attr("text-anchor", "middle").style("font-size", "12px").text(node.name);\n\n    // add brush if subset\n    if (div == "#tab2") {\n        plotsvg.append("text").attr("id", "range").attr("x", 25).attr("y", height + 40).text(function () {\n            return "Range: ".concat(d3.min(xVals).toPrecision(4), " to ", d3.max(xVals).toPrecision(4));\n        });\n        plotsvg.append("g").attr("class", "x brush").call(brush).selectAll("rect").attr("height", height);\n    }\n\n    // add z lines and sliders setx\n    if (div == "#setxLeft") {\n        plotsvg.append("text").attr("id", "range") // this is bad practice, id is not unique\n        .attr(\'class\', \'xval\').attr("x", 25).attr("y", height + 40).text(function () {\n            return "x: ".concat((+node.mean).toPrecision(4));\n        });\n\n        plotsvg.append("text").attr("id", "range2") // this is bad practice, id is not unique\n        .attr(\'class\', \'x1val\').attr("x", 25).attr("y", height + 50).text(function (_) {\n            var returnval = "x1: ".concat((+node.mean).toPrecision(4));\n            return returnval;\n        });\n\n        // create tick marks at all zscores in the bounds of the data\n        var lineFunction = d3.svg.line().x(function (d) {\n            return d.x;\n        }).y(function (d) {\n            return d.y;\n        }).interpolate("linear");\n\n        var colSeq = ["#A2CD5A", "orange", "red"]; // will cycle through color sequence, and then repeat last color\n        var lineData = new Array();\n\n        var zLower = -1 * (d3.min(xVals) - node.mean) / node.sd; // zscore of lower bound\n        var zUpper = (d3.max(xVals) - node.mean) / node.sd; // zscore of upper bound\n\n        for (var i = 0; i < zUpper; i++) {\n            lineData = [{\n                "x": x(+node.mean + i * node.sd),\n                "y": height * .7\n            }, {\n                "x": x(+node.mean + i * node.sd),\n                "y": height * .9\n            }];\n            plotsvg.append("path").attr("d", lineFunction([lineData[0], lineData[1]])).attr("stroke", colSeq[d3.min([i, colSeq.length - 1])]).attr("stroke-width", 1.5).attr("fill", "none");\n        }\n\n        for (var i = 1; i < zLower; i++) {\n            lineData = [{\n                "x": x(+node.mean - i * node.sd),\n                "y": height * .7\n            }, {\n                "x": x(+node.mean - i * node.sd),\n                "y": height * .9\n            }];\n            plotsvg.append("path").attr("d", lineFunction([lineData[0], lineData[1]])).attr("stroke", colSeq[d3.min([i, colSeq.length - 1])]).attr("stroke-width", 1.5).attr("fill", "none");\n        }\n\n        // initialize slider components\n        var slideBox = plotsvg.append("g").attr("class", "x axis").attr("transform", "translate(0," + height * .8 + ")").call(d3.svg.axis().scale(x).ticks(0).orient("bottom"));\n        var slider = plotsvg.append("g").attr("class", "slider").call(brush);\n        var handle = slider.append("polygon").attr("class", "handle").attr("transform", "translate(0," + height * .7 + ")").attr("points", function (_) {\n            var s = 6;\n            var xnm = node.setxvals[0] == \'\' ? x(node.mean) : x(node.setxvals[0]);\n            return xnm - s + "," + -s + " " + (xnm + s) + "," + -s + " " + xnm + "," + s * 1.3;\n        });\n        var slider2 = plotsvg.append("g").attr("class", "slider").call(brush2);\n        var handle2 = slider2.append("polygon").attr("class", "handle").attr("transform", "translate(0," + height * .9 + ")").attr("points", function (_) {\n            var s = 6;\n            var xnm = node.setxvals[1] == \'\' ? x(node.mean) : x(node.setxvals[1]);\n            return xnm - s + "," + s + " " + (xnm + s) + "," + s + " " + xnm + "," + -s * 1.3;\n        });\n    }\n\n    // brushing functions\n    function brushed() {\n        if (div == "#tab2") {\n            plotsvg.select("text#range").text(function () {\n                return brush.empty() ? "Range: ".concat(d3.min(xVals).toPrecision(4), " to ", d3.max(xVals).toPrecision(4)) : "Range: ".concat(brush.extent()[0].toPrecision(4), " to ", brush.extent()[1].toPrecision(4));\n            });\n            node.subsetrange = brush.extent()[0].toPrecision(4) != brush.extent()[1].toPrecision(4) ? [brush.extent()[0].toPrecision(4), brush.extent()[1].toPrecision(4)] : ["", ""];\n        } else if (div == "#setxLeft") {\n            var value = brush.extent()[0];\n            var s = 6;\n            if (d3.event.sourceEvent) {\n                value = x.invert(d3.mouse(this)[0]);\n                brush.extent([value, value]);\n            }\n\n            // set x position of slider center\n            var xpos = x(value);\n            if (value > d3.max(xVals)) {\n                // dragged past max\n                xpos = x(d3.max(xVals));\n            } else if (value < d3.min(xVals)) {\n                // dragged past min\n                xpos = x(d3.min(xVals));\n            } else {\n                var m = +node.mean;\n                var sd = +node.sd;\n                var zScore = (value - m) / sd; // z-score\n                var zRound = Math.round(zScore); // nearest integer z-score\n                if (.1 > Math.abs(zRound - zScore)) // snap to integer z-score\n                    xpos = x(m + zRound * sd);\n            }\n\n            // create slider symbol and text\n            handle.attr("points", function (_) {\n                return xpos - s + "," + -s + " " + (xpos + s) + "," + -s + " " + xpos + "," + s * 1.3;\n            });\n            plotsvg.select("text#range").text(function (_) {\n                var returnval = "x: ".concat(invx(xpos).toPrecision(4));\n                var xval = invx(xpos).toPrecision(4);\n                var mycell = node.name + "From"; // hardcoded here\n                if (document.getElementById(mycell)) {\n                    document.getElementById(mycell).innerText = xval;\n                }\n                return returnval;\n            });\n            node.setxvals[0] = invx(xpos).toPrecision(4);\n        }\n    }\n\n    // certainly a more clever way to do this, but for now it\'s basically copied with brush and handle changes to brush2 and handle2 and #range to #range2 and setxvals[0] to setxvals[1]\n    function brushed2() {\n        var value = brush2.extent()[0];\n        var s = 6; // scaling for triangle shape\n\n        if (d3.event.sourceEvent) {\n            value = x.invert(d3.mouse(this)[0]);\n            brush2.extent([value, value]);\n        }\n\n        // set x position of slider center\n        var xpos = x(value);\n        if (value > d3.max(xVals)) {\n            // dragged past max\n            xpos = x(d3.max(xVals));\n        } else if (value < d3.min(xVals)) {\n            // dragged past min\n            xpos = x(d3.min(xVals));\n        } else {\n            var m = +node.mean;\n            var sd = +node.sd;\n            var zScore = (value - m) / sd; // z-score\n            var zRound = Math.round(zScore); // nearest integer z-score\n            if (.1 > Math.abs(zRound - zScore)) // snap to integer z-score\n                xpos = x(m + zRound * sd);\n        }\n\n        // create slider symbol and text\n        handle2.attr("points", function (_) {\n            return xpos - s + "," + s + " " + (xpos + s) + "," + s + " " + xpos + "," + -s * 1.3;\n        });\n        plotsvg.select("text#range2").text(function (_) {\n            var returnval = "x1: ".concat(invx(xpos).toPrecision(4));\n            var x1val = invx(xpos).toPrecision(4);\n            var mycell = node.name + "To"; // hardcoded here\n            if (document.getElementById(mycell)) {\n                document.getElementById(mycell).innerText = x1val;\n            }\n            return returnval;\n        });\n        node.setxvals[1] = invx(xpos).toPrecision(4);\n    }\n}\n\nfunction bars(node, div, priv) {\n    // Histogram spacing\n    var barPadding = .015; // Space between bars\n    var topScale = 1.2; // Multiplicative factor to assign space at top within graph - currently removed from implementation\n    var plotXaxis = true;\n\n    // Data\n    var keys = Object.keys(node.plotvalues);\n    var yVals = new Array();\n    var ciUpperVals = new Array();\n    var ciLowerVals = new Array();\n    var ciSize;\n\n    var xVals = new Array();\n    var yValKey = new Array();\n\n    if (node.nature == "nominal") {\n        var xi = 0;\n        for (var i = 0; i < keys.length; i++) {\n            if (node.plotvalues[keys[i]] == 0) continue;\n            yVals[xi] = node.plotvalues[keys[i]];\n            xVals[xi] = xi;\n            if (priv) {\n                if (node.plotvaluesCI) {\n                    ciLowerVals[xi] = node.plotValuesCI.lowerBound[keys[i]];\n                    ciUpperVals[xi] = node.plotValuesCI.upperBound[keys[i]];\n                }\n                ciSize = ciUpperVals[xi] - ciLowerVals[xi];\n            };\n\n            yValKey.push({\n                y: yVals[xi],\n                x: keys[i]\n            });\n            xi = xi + 1;\n        }\n        yValKey.sort(function (a, b) {\n            return b.y - a.y;\n        }); // array of objects, each object has y, the same as yVals, and x, the category\n        yVals.sort(function (a, b) {\n            return b - a;\n        }); // array of y values, the height of the bars\n        ciUpperVals.sort(function (a, b) {\n            return b.y - a.y;\n        }); // ?\n        ciLowerVals.sort(function (a, b) {\n            return b.y - a.y;\n        }); // ?\n    } else {\n        for (var i = 0; i < keys.length; i++) {\n            // console.log("plotvalues in bars");\n            yVals[i] = node.plotvalues[keys[i]];\n            xVals[i] = Number(keys[i]);\n            if (priv) {\n                if (node.plotvaluesCI) {\n                    ciLowerVals[i] = node.plotvaluesCI.lowerBound[keys[i]];\n                    ciUpperVals[i] = node.plotvaluesCI.upperBound[keys[i]];\n                }\n                ciSize = ciUpperVals[i] - ciLowerVals[i];\n            }\n        }\n    }\n\n    if (yVals.length > 15 & node.numchar == "numeric" || yVals.length > 5 & node.numchar == "character") plotXaxis = false;\n    var maxY = d3.max(yVals); // in the future, set maxY to the value of the maximum confidence limit\n    if (priv && node.plotvaluesCI) maxY = d3.max(ciUpperVals);\n    var minX = d3.min(xVals);\n    var maxX = d3.max(xVals);\n\n    var mydiv = void 0;\n    if (div == "setxLeft") mydiv = "#setxLeft";else if (div == "varSummary") mydiv = "#tab3";else return alert("Error: incorrect div selected for plots");\n\n    var tempWidth = d3.select(mydiv).style("width");\n    var width = tempWidth.substring(0, tempWidth.length - 2);\n    var tempHeight = d3.select(mydiv).style("height");\n    var height = tempHeight.substring(0, tempHeight.length - 2);\n\n    var margin = {\n        top: 20,\n        right: 20,\n        bottom: 53,\n        left: 10\n    };\n    var tw = document.getElementById(\'main\').offsetWidth;\n\n    // Need to fix automatic width and height settings for leftpanel (#tab2, #tab3)\n    if (mydiv == "#tab3") {\n        width = 0.7 * (width - margin.left - margin.right);\n        height = 0.3 * (height - margin.top - margin.bottom);\n    } else if (mydiv == "#setxLeft") {\n        //width = 200;\n        //height = 120;\n        width = tw * .185 - margin.left - margin.right; //rightpanel.expand is 40 percent, setxLeft to 50 percent, toggle bar is 16px, padding, it\'s all about .185\n        height = width * .6; //height to width is .6\n    } else {\n        width = 0.35 * (width - margin.left - margin.right);\n        height = 0.25 * (height - margin.top - margin.bottom);\n    };\n\n    if (priv && node.stabilityBin) {\n        var x = d3.scale.linear().domain([minX - 0.5, maxX + 1.5]).range([0, width]);\n    } else {\n        var x = d3.scale.linear().domain([minX - 0.5, maxX + 0.5]).range([0, width]);\n    }\n\n    var invx = d3.scale.linear().range([minX - 0.5, maxX + 0.5]).domain([0, width]);\n\n    var y = d3.scale.linear().domain([0, maxY]).range([0, height]);\n\n    var xAxis = d3.svg.axis().scale(x).ticks(yVals.length).orient("bottom");\n\n    var yAxis = d3.svg.axis().scale(y).orient("left");\n\n    var brush = d3.svg.brush().x(x).extent(function () {\n        return node.subsetrange.length == 1 ? [node.subsetrange[0], node.subsetrange[0]] : node.subsetrange;\n    }).on("brush", brushed);\n\n    var brush2 = d3.svg.brush().x(x).on("brush", brushed2);\n\n    // Create SVG element\n    // cumbersome to treat "tab3" differently, but works for now\n    // tab3, has an issue, that unless width height hardcoded, they grow with each additional graph.\n    if (mydiv == "#tab3") {\n        var plotsvg = d3.select(mydiv).selectAll("svg").remove();\n\n        var plotsvg = d3.select(mydiv).append("svg").attr("id", function () {\n            return node.name.toString().concat(mydiv.substr(1));\n        }).style("width", 300) //setting height to the height of #main.left\n        .style("height", 200).append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");\n    } else {\n        var plotsvg = d3.select(mydiv).append("svg").attr("id", function () {\n            var myname = node.name.toString();\n            myname = myname.replace(/\\(|\\)/g, "");\n            return myname.concat("_", mydiv.substr(1), "_", node.id);\n        }).style("width", width + margin.left + margin.right) //setting height to the height of #main.left\n        .style("height", height + margin.top + margin.bottom).append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");\n    };\n\n    var rectWidth = x(minX + 0.5 - 2 * barPadding); //the "width" is the coordinate of the end of the first bar\n\n    plotsvg.selectAll("rect").data(yVals).enter().append("rect").attr("x", function (d, i) {\n        return x(xVals[i] - 0.5 + barPadding);\n    }).attr("y", function (d) {\n        return y(maxY - d);\n    }).attr("width", rectWidth).attr("height", y).attr("fill", "#1f77b4");\n\n    // draw error bars, threshold line and extra bin\n    if (priv) {\n        if (yVals.length <= 20) {\n            plotsvg.selectAll("line").data(ciUpperVals).enter().append("line").style("stroke", "black").attr("x1", function (d, i) {\n                return x(xVals[i] - 0.5 + barPadding) + rectWidth / 2;\n            }).attr("y1", function (d) {\n                return y(maxY - d);\n            }).attr("x2", function (d, i) {\n                return x(xVals[i] - 0.5 + barPadding) + rectWidth / 2;\n            }).attr("y2", function (d) {\n                var y2 = y(maxY - d + ciSize);\n                return y2 >= y(maxY) ? y(maxY) : y2;\n            });\n\n            //draw top ticks on error bars\n            //need to fix the height of the graphs - the tops of error bars are getting cut off\n            plotsvg.selectAll(".topTick").data(ciUpperVals).enter().append("line").attr("class", "topTick").style("stroke", "black").attr("x1", function (d, i) {\n                if (yVals.length > 20) {\n                    return x(xVals[i] - 0.5 + barPadding); //make tick bigger to increase visibility\n                } else {\n                    return x(xVals[i] - 0.5 + barPadding) + 0.4 * rectWidth;\n                }\n            }).attr("y1", function (d) {\n                return y(maxY - d);\n            }).attr("x2", function (d, i) {\n                if (yVals.length > 20) {\n                    return x(xVals[i] - 0.5 + barPadding) + rectWidth; //make tick bigger to increase visibility\n                } else {\n                    return x(xVals[i] - 0.5 + barPadding) + 0.6 * rectWidth;\n                }\n            }).attr("y2", function (d) {\n                return y(maxY - d);\n            });\n\n            // draw bottom ticks of error bars\n            plotsvg.selectAll(".bottomTick").data(ciLowerVals).enter().append("line").attr("class", "bottomTick").style("stroke", "black").attr("x1", function (d, i) {\n                if (yVals.length > 20) {\n                    return x(xVals[i] - 0.5 + barPadding);\n                } else {\n                    return x(xVals[i] - 0.5 + barPadding) + 0.4 * rectWidth;\n                }\n            }).attr("y1", function (d) {\n                return y(maxY - d);\n            }).attr("x2", function (d, i) {\n                if (yVals.length > 20) {\n                    return x(xVals[i] - 0.5 + barPadding) + rectWidth;\n                } else {\n                    return x(xVals[i] - 0.5 + barPadding) + 0.6 * rectWidth;\n                }\n            }).attr("y2", function (d) {\n                return y(maxY - d);\n            });\n        } else {\n            plotsvg.selectAll(".denseError").data(yVals).enter().append("rect").attr("class", "denseError").attr("x", function (d, i) {\n                return x(xVals[i] - 0.5 + barPadding);\n            }).attr("y", function (d) {\n                return y(maxY - d) - .1 * y(d);\n            }).attr("width", rectWidth).attr("height", function (d) {\n                return y(maxY - d) + .1 * y(d) - (y(maxY - d) - .1 * y(d));\n            }).attr("fill", "silver");\n        }\n\n        //if statement for stability histograms\n        //extra stability bin\n        if (node.stabilityBin) {\n            plotsvg.append("rect").attr("x", x(maxX + 0.5 - barPadding)).attr("y", y(maxY) - node.stabilityBin).attr("width", rectWidth).attr("height", node.stabilityBin).attr("fill", "silver");\n        }\n\n        //threshold line\n        if (node.threshold) {\n            plotsvg.append("line").style("stroke", "black").attr("x1", x(minX - 0.5 + barPadding)).attr("y1", y(maxY) - node.threshold).attr("x2", function () {\n                console.log("stabilityBin");\n                console.log(node.stabilityBin);\n                if (node.stabilityBin) {\n                    return x(maxX + 0.5 - barPadding) + rectWidth;\n                } else {\n                    return x(maxX + 0.5 - barPadding);\n                }\n            }).attr("y2", y(maxY) - node.threshold);\n        }\n    }\n\n    if (plotXaxis) {\n        plotsvg.append("g").attr("class", "x axis").attr("transform", "translate(0," + height + ")").call(xAxis);\n    }\n\n    plotsvg.append("text").attr("x", width / 2).attr("y", 0 - margin.top / 2).attr("text-anchor", "middle").style("font-size", "12px").text(node.name);\n\n    if (mydiv == "#setxLeft") {\n        plotsvg.append("text").attr("id", "range") // bad practice, not unique\n        .attr(\'class\', \'xval\').attr("x", 25).attr("y", height + 40).text(function () {\n            if (node.nature === "nominal") {\n                var t = Math.round(yValKey.length / 2) - 1;\n                var mycell = node.name + "From"; // hardcoded here\n                if (document.getElementById(mycell)) {\n                    document.getElementById(mycell).innerText = yValKey[t].x;\n                }\n                return "x: " + yValKey[t].x;\n            } else {\n                var _mycell = node.name + "From"; // hardcoded here\n                if (document.getElementById(_mycell)) {\n                    document.getElementById(_mycell).innerText = (+node.mean).toPrecision(4).toString();\n                }\n                return "x: ".concat((+node.mean).toPrecision(4).toString());\n            }\n        });\n\n        plotsvg.append("text").attr("id", "range2") //bad practice, not unique\n        .attr(\'class\', \'x1val\').attr("x", 25).attr("y", height + 50).text(function () {\n            if (node.nature === "nominal") {\n                var t = Math.round(yValKey.length / 2) - 1;\n                return "x1: " + yValKey[t].x;\n            } else {\n                return "x1: ".concat((+node.mean).toPrecision(4).toString());\n            }\n        });\n\n        // create tick marks at all zscores in the bounds of the data\n        var lineFunction = d3.svg.line().x(function (d) {\n            return d.x;\n        }).y(function (d) {\n            return d.y;\n        }).interpolate("linear");\n\n        var colSeq = ["#A2CD5A", "orange", "red"]; // will cycle through color sequence, and then repeat last color\n        var lineData = new Array();\n\n        var zLower = -1 * (minX - node.mean) / node.sd; // zscore of lower bound\n        var zUpper = (maxX - node.mean) / node.sd; // zscore of upper bound\n\n        for (var i = 0; i < zUpper; i++) {\n            lineData = [{\n                "x": x(+node.mean + i * node.sd),\n                "y": height * .7\n            }, {\n                "x": x(+node.mean + i * node.sd),\n                "y": height * .9\n            }];\n            plotsvg.append("path").attr("d", lineFunction([lineData[0], lineData[1]])).attr("stroke", colSeq[d3.min([i, colSeq.length - 1])]).attr("stroke-width", 1.5).attr("fill", "none");\n        }\n\n        for (var i = 1; i < zLower; i++) {\n            lineData = [{\n                "x": x(+node.mean - i * node.sd),\n                "y": height * .7\n            }, {\n                "x": x(+node.mean - i * node.sd),\n                "y": height * .9\n            }];\n            plotsvg.append("path").attr("d", lineFunction([lineData[0], lineData[1]])).attr("stroke", colSeq[d3.min([i, colSeq.length - 1])]).attr("stroke-width", 1.5).attr("fill", "none");\n        }\n\n        for (var i = d3.min(xVals); i <= d3.max(xVals); i++) {\n            lineData = [{\n                "x": x(i),\n                "y": height * .75\n            }, {\n                "x": x(i),\n                "y": height * .85\n            }];\n            plotsvg.append("path").attr("d", lineFunction([lineData[0], lineData[1]])).attr("stroke", "black").attr("stroke-width", 1).attr("fill", "none");\n        }\n\n        // initialize slider components\n        var slideBox = plotsvg.append("g").attr("class", "x axis").attr("transform", "translate(0," + height * .8 + ")").call(d3.svg.axis().scale(x).ticks(0).orient("bottom"));\n\n        var slider = plotsvg.append("g").attr("class", "slider").call(brush);\n        var slider2 = plotsvg.append("g").attr("class", "slider").call(brush2);\n\n        var points = function points(i) {\n            return function (d) {\n                var xnm = void 0,\n                    s = 6;\n                if (node.setxvals[i] == \'\') {\n                    // if nominal, use the median frequency as the position for the setx slider\n                    xnm = node.nature == \'nominal\' ? x(Math.round(xVals.length / 2) - 1) : x(node.mean);\n                } else {\n                    xnm = x(node.setxvals[i]);\n                };\n                return xnm - s + \',\' + -s + \' \' + (xnm + s) + \',\' + -s + \' \' + xnm + \',\' + s * 1.3;\n            };\n        };\n        var handle = slider.append("polygon").attr("class", "handle").attr("transform", "translate(0," + height * .7 + ")").attr("points", points(0));\n        var handle2 = slider2.append("polygon").attr("class", "handle").attr("transform", "translate(0," + height * .9 + ")").attr("points", points(1));\n    }\n\n    function twoSF(x) {\n        var tsf = d3.format(".2r"); // format to two significant figures after the decimal place\n        return tsf(x).replace(/0+$/, "").replace(/\\.$/, ""); // trim trailing zeros after a period, and any orphaned period\n    }\n\n    // brushing functions\n    function brushed() {\n        var value = brush.extent()[0];\n        var s = 6;\n\n        if (d3.event.sourceEvent) {\n            value = x.invert(d3.mouse(this)[0]);\n            brush.extent([value, value]);\n        }\n\n        // set x position of slider center\n        var xpos = x(value);\n        if (value > maxX) {\n            // dragged past max\n            xpos = x(maxX);\n        } else if (value < minX) {\n            // dragged past min\n            xpos = x(minX);\n        } else {\n            var m = +node.mean;\n            var sd = +node.sd;\n            var zScore = (value - m) / sd; // z-score\n            var zRound = Math.round(zScore); // nearest integer z-score\n            if (.1 > Math.abs(Math.round(value) - value)) {\n                // snap to integer\n                xpos = x(Math.round(value));\n            } else if (.1 > Math.abs(zRound - zScore)) {\n                // snap to integer z-score\n                xpos = x(m + zRound * sd);\n            }\n        }\n\n        // create slider symbol and text\n        handle.attr("points", function (d) {\n            return xpos - s + "," + -s + " " + (xpos + s) + "," + -s + " " + xpos + "," + s * 1.3;\n        });\n        plotsvg.select("text#range").text(function () {\n            if (node.nature === "nominal") {\n                var mycell = node.name + "From"; // hardcoded here\n                if (document.getElementById(mycell)) {\n                    document.getElementById(mycell).innerText = yValKey[Math.round(invx(xpos))].x;\n                }\n                return "x: " + yValKey[Math.round(invx(xpos))].x;\n            } else {\n                var _mycell2 = node.name + "From"; // hardcoded here\n                if (document.getElementById(_mycell2)) {\n                    document.getElementById(_mycell2).innerText = +invx(xpos).toPrecision(4).toString();\n                }\n                return "x: ".concat(+invx(xpos).toPrecision(4).toString());\n            }\n        });\n        node.setxvals[0] = +invx(xpos).toPrecision(4);\n    }\n\n    // certainly a more clever way to do this, but for now it\'s basically copied with brush and handle changes to brush2 and handle2 and #range to #range2 and setxvals[0] to setxvals[1]\n    function brushed2() {\n        var value = brush2.extent()[0];\n        var s = 6; // scaling for triangle shape\n\n        if (d3.event.sourceEvent) {\n            value = x.invert(d3.mouse(this)[0]);\n            brush2.extent([value, value]);\n        }\n\n        // set x position of slider center\n        var xpos = x(value);\n        if (value > maxX) {\n            // dragged past max\n            xpos = x(maxX);\n        } else if (value < minX) {\n            // dragged past min\n            xpos = x(minX);\n        } else {\n            var m = +node.mean;\n            var sd = +node.sd;\n            var zScore = (value - m) / sd; // z-score\n            var zRound = Math.round(zScore); // nearest integer z-score\n            if (.1 > Math.abs(Math.round(value) - value)) {\n                // snap to integer\n                xpos = x(Math.round(value));\n            } else if (.1 > Math.abs(zRound - zScore)) {\n                // snap to integer z-score\n                xpos = x(m + zRound * sd);\n            }\n        }\n\n        // create slider symbol and text\n        handle2.attr("points", function (d) {\n            return xpos - s + "," + s + " " + (xpos + s) + "," + s + " " + xpos + "," + -s * 1.3;\n        });\n        plotsvg.select("text#range2").text(function () {\n            if (node.nature === "nominal") {\n                var mycell = node.name + "To"; // hardcoded here\n                if (document.getElementById(mycell)) {\n                    document.getElementById(mycell).innerText = yValKey[Math.round(invx(xpos))].x;\n                }\n                return "x1: " + yValKey[Math.round(invx(xpos))].x;\n            } else {\n                var _mycell3 = node.name + "To"; // hardcoded here\n                if (document.getElementById(_mycell3)) {\n                    document.getElementById(_mycell3).innerText = +invx(xpos).toPrecision(4).toString();\n                }\n                return "x1: ".concat(+invx(xpos).toPrecision(4).toString());\n            }\n        });\n        node.setxvals[1] = +invx(xpos).toPrecision(4);\n    }\n}\n\n// draws barplots in subset tab\nfunction barsSubset(node) {\n    // if untouched, set node.subsetrange to an empty array, meaning all values selected by default\n    if (node.subsetrange[0] == "" & node.subsetrange[1] == "") {\n        node.subsetrange = [];\n    }\n\n    // Histogram spacing\n    var barPadding = .015; // Space between bars\n    var topScale = 1.2; // Multiplicative factor to assign space at top within graph - currently removed from implementation\n    var plotXaxis = true;\n\n    // Variable name\n    var myname = node.name.toString();\n    myname = myname.replace(/\\(|\\)/g, "");\n\n    // Data\n    var keys = Object.keys(node.plotvalues);\n    var yVals = new Array();\n    var xVals = new Array();\n    var yValKey = new Array();\n\n    var xi = 0;\n    for (var i = 0; i < keys.length; i++) {\n        if (node.plotvalues[keys[i]] == 0) continue;\n        yVals[xi] = node.plotvalues[keys[i]];\n        xVals[xi] = xi;\n        yValKey.push({\n            y: yVals[xi],\n            x: keys[i]\n        });\n        xi = xi + 1;\n    }\n    if (node.nature === "nominal") {\n        // if nominal, orders bars left to right, highest frequency to lowest\n        yValKey.sort(function (a, b) {\n            return b.y - a.y;\n        }); // array of objects, each object has y, the same as yVals, and x, the category\n        yVals.sort(function (a, b) {\n            return b - a;\n        }); // array of y values, the height of the bars\n    }\n\n    plotXaxis = false;\n\n    var maxY = d3.max(yVals);\n    var minX = d3.min(xVals);\n    var maxX = d3.max(xVals);\n    var gname = ["subsetyes", "subsetno"];\n\n    var yVals2 = [];\n    var yVals1 = [];\n    for (i = 0; i < yVals.length; i++) {\n        yVals1.push({\n            y0: maxY - yVals[i],\n            y1: yVals[i],\n            col: d3Color\n        });\n        yVals2.push({\n            y0: 0,\n            y1: maxY - yVals[i],\n            col: "transparent"\n        });\n    }\n    var freqs = [yVals1, yVals2];\n\n    // y0 is the starting point\n    // y1 is the length of the bar\n\n    var mydiv = "#tab2";\n    var width = 200;\n    var height = 120;\n    var margin = {\n        top: 20,\n        right: 20,\n        bottom: 53,\n        left: 50\n    };\n\n    var x = d3.scale.linear().domain([minX - 0.5, maxX + 0.5]).range([0, width]);\n\n    var invx = d3.scale.linear().range([minX - 0.5, maxX + 0.5]).domain([0, width]);\n\n    var y = d3.scale.linear().domain([0, maxY]).range([0, height]);\n\n    var xAxis = d3.svg.axis().scale(x).ticks(yVals.length).orient("bottom");\n\n    var yAxis = d3.svg.axis().scale(y).orient("left");\n\n    //Create SVG element\n    var plotsvg = d3.select(mydiv).append("svg").attr("id", function () {\n        return myname.concat("_", mydiv.substr(1), "_", node.id);\n    }).style("width", width + margin.left + margin.right) //setting height to the height of #main.left\n    .style("height", height + margin.top + margin.bottom).append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");\n\n    var freq = plotsvg.selectAll("g.freq").data(freqs).enter().append("g").attr("class", "freq").attr("name", function (d, i) {\n        return myname.concat(gname[i]);\n    });\n\n    var rect = freq.selectAll("rect").data(Object).enter().append("rect").attr("class", "bar").attr("name", function (d, i) {\n        return xVals[i];\n    }).attr("x", function (d, i) {\n        return x(xVals[i] - 0.5 + barPadding);\n    }).attr("y", function (d) {\n        return y(d.y0);\n    }).attr("width", x(minX + 0.5 - 2 * barPadding)) // the "width" is the coordinate of the end of the first bar\n    .attr("height", function (d) {\n        return y(d.y1);\n    }).style("fill", function (d, i) {\n        if (node.subsetrange.length > 0 & d.col === d3Color & $.inArray(xVals[i].toString(), node.subsetrange) > -1) {\n            return selVarColor;\n        } else {\n            return d.col;\n        }\n    }).on("click", function () {\n        var selectMe = this;\n        var selectName = this.getAttribute("name");\n        if (this.parentNode.getAttribute("name") == myname.concat("subsetno")) {\n            selectMe = $(\'[name="\' + myname.concat("subsetyes") + \'"]\').children(\'[name="\' + selectName + \'"]\')[0];\n        }\n        d3.select(selectMe).style("fill", function (d, i) {\n            var myCol = "";\n            if (this.style.fill === selVarColor) {\n                var myindex = node.subsetrange.indexOf(this.getAttribute("name"));\n                node.subsetrange.splice(myindex, 1);\n                myCol = d3Color;\n            } else {\n                node.subsetrange.push(this.getAttribute("name"));\n                myCol = selVarColor;\n            }\n            return myCol;\n        });\n        plotsvg.select("text#selectrange").text(function () {\n            if (node.subsetrange.length == 0) {\n                return "Selected: all values";\n            } else {\n                var a = node.subsetrange;\n                var selecteds = new Array();\n                a.forEach(function (val) {\n                    selecteds.push(yValKey[val].x);\n                });\n                return "Selected: " + selecteds;\n            }\n        });\n    }).on("mouseover", function () {\n        var i = this.getAttribute("name");\n        plotsvg.select("text#mymouseover").text(function () {\n            return yValKey[i].x + ": " + yValKey[i].y;\n        });\n    }).on("mouseout", function () {\n        var i = this.getAttribute("name");\n        plotsvg.select("text#mymouseover").text(function () {\n            return "Value: Frequency";\n        });\n    });\n\n    if (plotXaxis) {\n        plotsvg.append("g").attr("class", "x axis").attr("transform", "translate(0," + height + ")").call(xAxis);\n    } else {\n        plotsvg.append("text").attr("id", "mymouseover").attr("x", 25).attr("y", height + 20).text(function () {\n            return "Value: Frequency";\n        });\n    }\n\n    plotsvg.append("text").attr("x", width / 2).attr("y", 0 - margin.top / 2).attr("text-anchor", "middle").style("font-size", "12px").text(myname);\n\n    plotsvg.append("text").attr("id", "selectrange").attr("x", 25).attr("y", height + 40).text(function () {\n        if (node.subsetrange.length == 0) return "Selected: all values";\n        var selecteds = new Array();\n        node.subsetrange.forEach(function (val) {\n            return selecteds.push(yValKey[val].x);\n        });\n        return "Selected: " + selecteds;\n    });\n}\n\nfunction densityNode(node, obj) {\n    var myname = node.name.toString().concat("nodeplot");\n\n    if (typeof obj === "undefined") {\n        var obj = document.getElementById(node.name.toString() + "biggroup");\n        // if obj contains an svg element, remove it. this removes any plot inside the node\n        if (d3.select(obj).selectAll("svg")[0].length > 0) d3.select(obj).selectAll("svg").remove();\n    }\n\n    var yVals = node.ploty;\n    var xVals = node.plotx;\n    // array of objects\n    var data2 = node.plotx.map(function (x, i) {\n        return { x: +x, y: +node.ploty[i] };\n    });\n\n    var width = 60; // hardcoded, should be set automatically\n    var height = 30;\n    var margin = {\n        top: 20,\n        right: 10,\n        bottom: 53,\n        left: 10\n    };\n\n    var x = d3.scale.linear().domain([d3.min(xVals), d3.max(xVals)]).range([0, width]);\n\n    var y = d3.scale.linear().domain([d3.min(yVals), d3.max(yVals)]).range([height, 0]);\n\n    var area = d3.svg.area().interpolate("monotone").x(function (d) {\n        return x(d.x);\n    }).y0(height).y1(function (d) {\n        return y(d.y);\n    });\n\n    var plotsvg = d3.select(obj).insert("svg", ":first-child").attr("x", -40) // NOTE: Not sure exactly why these numbers work, but these hardcoded values seem to position the plot inside g correctly.  this shouldn\'t be hardcoded in the future\n    .attr("y", -45).attr("id", function () {\n        return myname;\n    }).style("width", width).style("height", height).append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");\n\n    plotsvg.append("path").datum(data2).attr("class", "area").attr("d", area);\n}\n\nfunction barsNode(node, obj) {\n    var myname = node.name.toString().concat("nodeplot");\n\n    if (typeof obj === "undefined") {\n        var obj = document.getElementById(node.name.toString() + "biggroup");\n        // if obj contains an svg element, remove it. this removes any plot inside the node\n        if (d3.select(obj).selectAll("svg")[0].length > 0) {\n            d3.select(obj).selectAll("svg").remove();\n        }\n    }\n\n    // Histogram spacing\n    var barPadding = .015; // Space between bars\n    var topScale = 1.2; // Multiplicative factor to assign space at top within graph - currently removed from implementation\n\n    // Data\n    var keys = Object.keys(node.plotvalues);\n    var yVals = new Array();\n    var xVals = new Array();\n    var yValKey = new Array();\n\n    if (node.nature === "nominal") {\n        var xi = 0;\n        for (var i = 0; i < keys.length; i++) {\n            if (node.plotvalues[keys[i]] == 0) continue;\n            yVals[xi] = node.plotvalues[keys[i]];\n            xVals[xi] = xi;\n            yValKey.push({ y: yVals[xi], x: keys[i] });\n            xi = xi + 1;\n        }\n        yValKey.sort(function (a, b) {\n            return b.y - a.y;\n        }); // array of objects, each object has y, the same as yVals, and x, the category\n        yVals.sort(function (a, b) {\n            return b - a;\n        }); // array of y values, the height of the bars\n    } else {\n        for (var i = 0; i < keys.length; i++) {\n            yVals[i] = node.plotvalues[keys[i]];\n            xVals[i] = Number(keys[i]);\n        }\n    }\n\n    var maxY = d3.max(yVals);\n    var minX = d3.min(xVals);\n    var maxX = d3.max(xVals);\n\n    var width = 60;\n    var height = 30;\n    var margin = {\n        top: 20,\n        right: 10,\n        bottom: 53,\n        left: 10\n    };\n\n    var x = d3.scale.linear().domain([minX - 0.5, maxX + 0.5]).range([0, width]);\n\n    var invx = d3.scale.linear().range([minX - 0.5, maxX + 0.5]).domain([0, width]);\n\n    var y = d3.scale.linear().domain([0, maxY]).range([0, height]);\n\n    //Create SVG element\n    var plotsvg = d3.select(obj).insert("svg", ":first-child").attr("x", -40).attr("y", -45).attr("id", function () {\n        return myname;\n    }).style("width", width) // set height to the height of #main.left\n    .style("height", height).append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");\n\n    plotsvg.selectAll("rect").data(yVals).enter().append("rect").attr("x", function (d, i) {\n        return x(xVals[i] - 0.5 + barPadding);\n    }).attr("y", function (d) {\n        return y(maxY - d);\n    }).attr("width", x(minX + 0.5 - 2 * barPadding)) // the "width" is the coordinate of the end of the first bar\n    .attr("height", y).attr("fill", "#1f77b4");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvYXBwL3Bsb3RzLmpzP2JmMWYiXSwibmFtZXMiOlsiZGVuc2l0eSIsImJhcnMiLCJiYXJzU3Vic2V0IiwiZGVuc2l0eU5vZGUiLCJiYXJzTm9kZSIsImQzQ29sb3IiLCJzZWxWYXJDb2xvciIsIm5vZGUiLCJkaXYiLCJwcml2Iiwic3Vic2V0Iiwic2V0eExlZnQiLCJ2YXJTdW1tYXJ5IiwiYWxlcnQiLCJwbG90eCIsInBsb3R5IiwieFZhbHMiLCJ5VmFscyIsInBsb3RDSSIsIm1hcCIsIngiLCJpIiwieSIsImJvdW5kIiwidXBwZXJFcnJvciIsImxvd2VyRXJyb3IiLCJjb25zb2xlIiwibG9nIiwidGVtcFdpZHRoIiwiZDMiLCJzZWxlY3QiLCJzdHlsZSIsIndpZHRoIiwic3Vic3RyaW5nIiwibGVuZ3RoIiwidHciLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwib2Zmc2V0V2lkdGgiLCJ0ZW1wSGVpZ2h0IiwiaGVpZ2h0IiwibWFyZ2luIiwidG9wIiwicmlnaHQiLCJib3R0b20iLCJsZWZ0Iiwic2NhbGUiLCJsaW5lYXIiLCJkb21haW4iLCJtaW4iLCJtYXgiLCJyYW5nZSIsImludngiLCJ4QXhpcyIsInN2ZyIsImF4aXMiLCJ0aWNrcyIsIm9yaWVudCIsInlBeGlzIiwiYnJ1c2giLCJleHRlbnQiLCJzdWJzZXRyYW5nZSIsIm9uIiwiYnJ1c2hlZCIsImJydXNoMiIsImJydXNoZWQyIiwiYXJlYSIsImludGVycG9sYXRlIiwiZCIsInkwIiwieTEiLCJsaW5lIiwicGxvdHN2ZyIsInNlbGVjdEFsbCIsInJlbW92ZSIsImFwcGVuZCIsImF0dHIiLCJuYW1lIiwidG9TdHJpbmciLCJjb25jYXQiLCJzdWJzdHIiLCJyZXBsYWNlIiwiaWQiLCJkYXR1bSIsImNhbGwiLCJ0ZXh0IiwidG9QcmVjaXNpb24iLCJtZWFuIiwicmV0dXJudmFsIiwibGluZUZ1bmN0aW9uIiwiY29sU2VxIiwibGluZURhdGEiLCJBcnJheSIsInpMb3dlciIsInNkIiwielVwcGVyIiwic2xpZGVCb3giLCJzbGlkZXIiLCJoYW5kbGUiLCJzIiwieG5tIiwic2V0eHZhbHMiLCJzbGlkZXIyIiwiaGFuZGxlMiIsImVtcHR5IiwidmFsdWUiLCJldmVudCIsInNvdXJjZUV2ZW50IiwiaW52ZXJ0IiwibW91c2UiLCJ4cG9zIiwibSIsInpTY29yZSIsInpSb3VuZCIsIk1hdGgiLCJyb3VuZCIsImFicyIsInh2YWwiLCJteWNlbGwiLCJpbm5lclRleHQiLCJ4MXZhbCIsImJhclBhZGRpbmciLCJ0b3BTY2FsZSIsInBsb3RYYXhpcyIsImtleXMiLCJPYmplY3QiLCJwbG90dmFsdWVzIiwiY2lVcHBlclZhbHMiLCJjaUxvd2VyVmFscyIsImNpU2l6ZSIsInlWYWxLZXkiLCJuYXR1cmUiLCJ4aSIsInBsb3R2YWx1ZXNDSSIsInBsb3RWYWx1ZXNDSSIsImxvd2VyQm91bmQiLCJ1cHBlckJvdW5kIiwicHVzaCIsInNvcnQiLCJhIiwiYiIsIk51bWJlciIsIm51bWNoYXIiLCJtYXhZIiwibWluWCIsIm1heFgiLCJteWRpdiIsInN0YWJpbGl0eUJpbiIsIm15bmFtZSIsInJlY3RXaWR0aCIsImRhdGEiLCJlbnRlciIsInkyIiwidGhyZXNob2xkIiwidCIsInBvaW50cyIsInR3b1NGIiwidHNmIiwiZm9ybWF0IiwiZ25hbWUiLCJ5VmFsczIiLCJ5VmFsczEiLCJjb2wiLCJmcmVxcyIsImZyZXEiLCJyZWN0IiwiJCIsImluQXJyYXkiLCJzZWxlY3RNZSIsInNlbGVjdE5hbWUiLCJnZXRBdHRyaWJ1dGUiLCJwYXJlbnROb2RlIiwiY2hpbGRyZW4iLCJteUNvbCIsImZpbGwiLCJteWluZGV4IiwiaW5kZXhPZiIsInNwbGljZSIsInNlbGVjdGVkcyIsImZvckVhY2giLCJ2YWwiLCJvYmoiLCJkYXRhMiIsImluc2VydCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7UUFJZ0JBLE8sR0FBQUEsTztRQXFVQUMsSSxHQUFBQSxJO1FBK2hCQUMsVSxHQUFBQSxVO1FBNk5BQyxXLEdBQUFB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QURMLENBQ1VySSxLQURWLEVBRUtzSSxLQUZMLEdBR0s1RSxNQUhMLENBR1ksTUFIWixFQUlLQyxJQUpMLENBSVUsR0FKVixFQUllLFVBQUNSLENBQUQsRUFBSS9DLENBQUo7QUFBQSxlQUFXRCxFQUFFSixNQUFNSyxDQUFOLElBQVcsR0FBWCxHQUFpQm9HLFVBQW5CLENBQVg7QUFBQSxLQUpmLEVBS0s3QyxJQUxMLENBS1UsR0FMVixFQUtlO0FBQUEsZUFBTXRELEVBQUV5SCxPQUFPM0UsQ0FBVCxDQUFOO0FBQUEsS0FMZixFQU1LUSxJQU5MLENBTVUsT0FOVixFQU1tQnhELEVBQUU0SCxPQUFPLEdBQVAsR0FBYSxJQUFJdkIsVUFBbkIsQ0FObkIsRUFNbUQ7QUFObkQsS0FPSzdDLElBUEwsQ0FPVSxRQVBWLEVBT29CdEQsQ0FQcEIsRUFRS3NELElBUkwsQ0FRVSxNQVJWLEVBUWtCLFNBUmxCO0FBU0giLCJmaWxlIjoiMi5qcyIsInNvdXJjZXNDb250ZW50IjpbImxldCBkM0NvbG9yID0gJyMxZjc3YjQnOyAvLyBkMydzIGRlZmF1bHQgYmx1ZVxuZXhwb3J0IGxldCBzZWxWYXJDb2xvciA9ICcjZmE4MDcyJzsgLy8gZDMucmdiKFwic2FsbW9uXCIpO1xuXG4vLyBmdW5jdGlvbiB0byB1c2UgZDMgdG8gZ3JhcGggZGVuc2l0eSBwbG90cyB3aXRoIHByZXByb2Nlc3NlZCBkYXRhXG5leHBvcnQgZnVuY3Rpb24gZGVuc2l0eShub2RlLCBkaXYsIHByaXYpIHtcbiAgICBkaXYgPSB7c3Vic2V0OiAnI3RhYjInLCBzZXR4TGVmdDogJyNzZXR4TGVmdCcsIHZhclN1bW1hcnk6ICcjdGFiMyd9W2Rpdl07XG4gICAgaWYgKCFkaXYpXG4gICAgICAgIHJldHVybiBhbGVydChcIkVycm9yOiBpbmNvcnJlY3QgZGl2IHNlbGVjdGVkIGZvciBwbG90c1wiKTtcblxuICAgIGxldCBbeFZhbHMsIHlWYWxzXSA9IFtub2RlLnBsb3R4LCBub2RlLnBsb3R5XTtcbiAgICBpZiAocHJpdiAmJiBub2RlLnBsb3RDSSkge1xuICAgICAgICBsZXQgW3VwcGVyRXJyb3IsIGxvd2VyRXJyb3JdID0gWyd1cHBlckJvdW5kJywgJ2xvd2VyQm91bmQnXS5tYXAoXG4gICAgICAgICAgICBib3VuZCA9PiB4VmFscy5tYXAoKHgsIGkpID0+ICh7eDogK3gsIHk6ICtub2RlLnBsb3RDSVtib3VuZF1baV19KSkpO1xuICAgICAgICBjb25zb2xlLmxvZygndXBwZXJFcnJvclxcbicsIHVwcGVyRXJyb3IpO1xuICAgIH1cblxuICAgIHZhciB0ZW1wV2lkdGggPSBkMy5zZWxlY3QoZGl2KS5zdHlsZShcIndpZHRoXCIpO1xuICAgIHZhciB3aWR0aCA9IHRlbXBXaWR0aC5zdWJzdHJpbmcoMCwgKHRlbXBXaWR0aC5sZW5ndGggLSAyKSk7XG4gICAgXG4gICAgbGV0IHR3ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21haW4nKS5vZmZzZXRXaWR0aDtcbiAgICBcbiAgICB2YXIgdGVtcEhlaWdodCA9IGQzLnNlbGVjdChkaXYpLnN0eWxlKFwiaGVpZ2h0XCIpO1xuICAgIHZhciBoZWlnaHQgPSB0ZW1wSGVpZ2h0LnN1YnN0cmluZygwLCAodGVtcEhlaWdodC5sZW5ndGggLSAyKSk7XG4gICAgdmFyIG1hcmdpbiA9IHtcbiAgICAgICAgdG9wOiAyMCxcbiAgICAgICAgcmlnaHQ6IDIwLFxuICAgICAgICBib3R0b206IDUzLFxuICAgICAgICBsZWZ0OiAxMFxuICAgIH07XG5cbiAgICAvLyBOZWVkIHRvIGZpeCBhdXRvbWF0aWMgd2lkdGggYW5kIGhlaWdodCBzZXR0aW5ncyBmb3IgbGVmdHBhbmVsICgjdGFiMiwgI3RhYjMpXG4gICAgaWYgKGRpdiA9PSBcIiN0YWIzXCIpIHtcbiAgICAgICAgd2lkdGggPSAwLjcgKiAod2lkdGggLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodCksXG4gICAgICAgIGhlaWdodCA9IDAuMyAqIChoZWlnaHQgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbSk7XG4gICAgfSBlbHNlIGlmIChkaXYgPT0gXCIjdGFiMlwiKSB7XG4gICAgICAgIHdpZHRoID0gMjAwO1xuICAgICAgICBoZWlnaHQgPSAxMjA7XG4gICAgfSBlbHNlIGlmIChkaXYgPT0gXCIjc2V0eExlZnRcIikge1xuICAgICAgICB3aWR0aD10dyouMTg1LW1hcmdpbi5sZWZ0LW1hcmdpbi5yaWdodDsgLy9yaWdodHBhbmVsLmV4cGFuZCBpcyA0MCBwZXJjZW50LCBzZXR4TGVmdCB0byA1MCBwZXJjZW50LCB0b2dnbGUgYmFyIGlzIDE2cHgsIHBhZGRpbmcsIGl0J3MgYWxsIGFib3V0IC4xODVcbiAgICAgICAgaGVpZ2h0PXdpZHRoKi42OyAvL2hlaWdodCB0byB3aWR0aCBpcyAuNlxuICAgIH0gZWxzZSB7XG4gICAgICAgIHdpZHRoID0gMC4zNSAqICh3aWR0aCAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0KSxcbiAgICAgICAgaGVpZ2h0ID0gMC4yNSAqIChoZWlnaHQgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbSk7XG4gICAgfTtcblxuICAgIHZhciB4ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLmRvbWFpbihbZDMubWluKHhWYWxzKSwgZDMubWF4KHhWYWxzKV0pXG4gICAgICAgIC5yYW5nZShbMCwgd2lkdGhdKTtcbiAgICB2YXIgaW52eCA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgIC5yYW5nZShbZDMubWluKHhWYWxzKSwgZDMubWF4KHhWYWxzKV0pXG4gICAgICAgIC5kb21haW4oWzAsIHdpZHRoXSk7XG4gICAgdmFyIHkgPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAuZG9tYWluKFtkMy5taW4oeVZhbHMpLCBkMy5tYXgoeVZhbHMpXSlcbiAgICAgICAgLnJhbmdlKFtoZWlnaHQsIDBdKTtcbiAgICB2YXIgeEF4aXMgPSBkMy5zdmcuYXhpcygpXG4gICAgICAgIC5zY2FsZSh4KVxuICAgICAgICAudGlja3MoNSlcbiAgICAgICAgLm9yaWVudChcImJvdHRvbVwiKTtcbiAgICB2YXIgeUF4aXMgPSBkMy5zdmcuYXhpcygpXG4gICAgICAgIC5zY2FsZSh5KVxuICAgICAgICAub3JpZW50KFwibGVmdFwiKTtcbiAgICB2YXIgYnJ1c2ggPSBkMy5zdmcuYnJ1c2goKVxuICAgICAgICAueCh4KVxuICAgICAgICAuZXh0ZW50KG5vZGUuc3Vic2V0cmFuZ2UpXG4gICAgICAgIC5vbihcImJydXNoXCIsIGJydXNoZWQpO1xuICAgIHZhciBicnVzaDIgPSBkMy5zdmcuYnJ1c2goKVxuICAgICAgICAueCh4KVxuICAgICAgICAub24oXCJicnVzaFwiLCBicnVzaGVkMik7XG4gICAgdmFyIGFyZWEgPSBkMy5zdmcuYXJlYSgpXG4gICAgICAgIC5pbnRlcnBvbGF0ZShcIm1vbm90b25lXCIpXG4gICAgICAgIC54KGQgPT4geChkLngpKVxuICAgICAgICAueTAoaGVpZ2h0KVxuICAgICAgICAueTEoZCA9PiB5KGQueSkpO1xuICAgIHZhciBsaW5lID0gZDMuc3ZnLmxpbmUoKVxuICAgICAgICAueChkID0+IHgoZC54KSlcbiAgICAgICAgLnkoZCA9PiB5KGQueSkpXG4gICAgICAgIC5pbnRlcnBvbGF0ZShcIm1vbm90b25lXCIpO1xuXG4gICAgLy8gY3VtYmVyc29tZSB0byB0cmVhdCBcInRhYjNcIiBkaWZmZXJlbnRseSwgYnV0IHdvcmtzIGZvciBub3dcbiAgICAvLyB0YWIzLCBoYXMgYW4gaXNzdWUsIHRoYXQgdW5sZXNzIHdpZHRoIGhlaWdodCBoYXJkY29kZWQsIHRoZXkgZ3JvdyB3aXRoIGVhY2ggYWRkaXRpb25hbCBncmFwaC5cbiAgICBpZiAoZGl2ID09IFwiI3RhYjNcIikge1xuICAgICAgICB2YXIgcGxvdHN2ZyA9IGQzLnNlbGVjdChkaXYpXG4gICAgICAgICAgICAuc2VsZWN0QWxsKFwic3ZnXCIpXG4gICAgICAgICAgICAucmVtb3ZlKCk7XG4gICAgICAgIHBsb3RzdmcgPSBkMy5zZWxlY3QoZGl2KVxuICAgICAgICAgICAgLmFwcGVuZChcInN2Z1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCAoKSA9PiBub2RlLm5hbWUudG9TdHJpbmcoKS5jb25jYXQoZGl2LnN1YnN0cigxKSkpXG4gICAgICAgICAgICAuc3R5bGUoXCJ3aWR0aFwiLCAzMDApIC8vIHNldCBoZWlnaHQgdG8gdGhlIGhlaWdodCBvZiAjbWFpbi5sZWZ0XG4gICAgICAgICAgICAuc3R5bGUoXCJoZWlnaHRcIiwgMjAwKVxuICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIGB0cmFuc2xhdGUoJHttYXJnaW4ubGVmdH0sJHttYXJnaW4udG9wfSlgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcGxvdHN2ZyA9IGQzLnNlbGVjdChkaXYpXG4gICAgICAgICAgICAuYXBwZW5kKFwic3ZnXCIpXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsICgpID0+IG5vZGUubmFtZS50b1N0cmluZygpXG4gICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFwofFxcKS9nLCBcIlwiKVxuICAgICAgICAgICAgICAgICAgLmNvbmNhdChcIl9cIiwgZGl2LnN1YnN0cigxKSwgXCJfXCIsIG5vZGUuaWQpKVxuICAgICAgICAgICAgLnN0eWxlKFwid2lkdGhcIiwgd2lkdGggKyBtYXJnaW4ubGVmdCArIG1hcmdpbi5yaWdodCkgLy9zZXR0aW5nIGhlaWdodCB0byB0aGUgaGVpZ2h0IG9mICNtYWluLmxlZnRcbiAgICAgICAgICAgIC5zdHlsZShcImhlaWdodFwiLCBoZWlnaHQgKyBtYXJnaW4udG9wICsgbWFyZ2luLmJvdHRvbSlcbiAgICAgICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBgdHJhbnNsYXRlKCR7bWFyZ2luLmxlZnR9LCR7bWFyZ2luLnRvcH0pYCk7XG4gICAgfTtcbiAgICBwbG90c3ZnLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgLmRhdHVtKHhWYWxzLm1hcCgoeCwgaSkgPT4gKHt4OiAreCwgeTogK25vZGUucGxvdHlbaV19KSkpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJhcmVhXCIpXG4gICAgICAgIC5hdHRyKFwiZFwiLCBhcmVhKTtcblxuICAgIC8vYWRkIHVwcGVyIGJvdW5kXG4gICAgcHJpdiAmJiBub2RlLnBsb3RDSSAmJiBwbG90c3ZnLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInVwcGVyRXJyb3JcIilcbiAgICAgICAgLmRhdHVtKHVwcGVyRXJyb3IpXG4gICAgICAgIC5hdHRyKFwiZFwiLCBhcmVhKTtcblxuICAgIC8vYWRkIGxvd2VyIGJvdW5kXG4gICAgcHJpdiAmJiBub2RlLnBsb3RDSSAmJiBwbG90c3ZnLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImxvd2VyRXJyb3JcIilcbiAgICAgICAgLmRhdHVtKGxvd2VyRXJyb3IpXG4gICAgICAgIC5hdHRyKFwiZFwiLCBhcmVhKTtcblxuICAgIHBsb3RzdmcuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwieCBheGlzXCIpXG4gICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsXCIgKyBoZWlnaHQgKyBcIilcIilcbiAgICAgICAgLmNhbGwoeEF4aXMpO1xuXG4gICAgcGxvdHN2Zy5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgIC5hdHRyKFwieFwiLCAod2lkdGggLyAyKSlcbiAgICAgICAgLmF0dHIoXCJ5XCIsIDAgLSAobWFyZ2luLnRvcCAvIDIpKVxuICAgICAgICAuYXR0cihcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpXG4gICAgICAgIC5zdHlsZShcImZvbnQtc2l6ZVwiLCBcIjEycHhcIilcbiAgICAgICAgLnRleHQobm9kZS5uYW1lKTtcblxuICAgIC8vIGFkZCBicnVzaCBpZiBzdWJzZXRcbiAgICBpZiAoZGl2ID09IFwiI3RhYjJcIikge1xuICAgICAgICBwbG90c3ZnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgXCJyYW5nZVwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIDI1KVxuICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIGhlaWdodCArIDQwKVxuICAgICAgICAgICAgLnRleHQoKCkgPT4gXCJSYW5nZTogXCIuY29uY2F0KGQzLm1pbih4VmFscykudG9QcmVjaXNpb24oNCksIFwiIHRvIFwiLCBkMy5tYXgoeFZhbHMpLnRvUHJlY2lzaW9uKDQpKSk7XG4gICAgICAgIHBsb3RzdmcuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInggYnJ1c2hcIilcbiAgICAgICAgICAgIC5jYWxsKGJydXNoKVxuICAgICAgICAgICAgLnNlbGVjdEFsbChcInJlY3RcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGhlaWdodCk7XG4gICAgfVxuXG4gICAgLy8gYWRkIHogbGluZXMgYW5kIHNsaWRlcnMgc2V0eFxuICAgIGlmIChkaXYgPT0gXCIjc2V0eExlZnRcIikge1xuICAgICAgICBwbG90c3ZnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgXCJyYW5nZVwiKSAvLyB0aGlzIGlzIGJhZCBwcmFjdGljZSwgaWQgaXMgbm90IHVuaXF1ZVxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywneHZhbCcpXG4gICAgICAgICAgICAuYXR0cihcInhcIiwgMjUpXG4gICAgICAgICAgICAuYXR0cihcInlcIiwgaGVpZ2h0ICsgNDApXG4gICAgICAgICAgICAudGV4dCgoKSA9PiBcIng6IFwiLmNvbmNhdCgoK25vZGUubWVhbikudG9QcmVjaXNpb24oNCkpKTtcblxuICAgICAgICBwbG90c3ZnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgXCJyYW5nZTJcIikgLy8gdGhpcyBpcyBiYWQgcHJhY3RpY2UsIGlkIGlzIG5vdCB1bmlxdWVcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsJ3gxdmFsJylcbiAgICAgICAgICAgIC5hdHRyKFwieFwiLCAyNSlcbiAgICAgICAgICAgIC5hdHRyKFwieVwiLCBoZWlnaHQgKyA1MClcbiAgICAgICAgICAgIC50ZXh0KCBfID0+IHtcbiAgICAgICAgICAgICAgICAgIGxldCByZXR1cm52YWwgPSBcIngxOiBcIi5jb25jYXQoKCtub2RlLm1lYW4pLnRvUHJlY2lzaW9uKDQpKTtcbiAgICAgICAgICAgICAgIHJldHVybiByZXR1cm52YWx9KTtcbiAgICAgICAgXG5cbiAgICAgICAgLy8gY3JlYXRlIHRpY2sgbWFya3MgYXQgYWxsIHpzY29yZXMgaW4gdGhlIGJvdW5kcyBvZiB0aGUgZGF0YVxuICAgICAgICB2YXIgbGluZUZ1bmN0aW9uID0gZDMuc3ZnLmxpbmUoKVxuICAgICAgICAgICAgLngoZCA9PiBkLngpXG4gICAgICAgICAgICAueShkID0+IGQueSlcbiAgICAgICAgICAgIC5pbnRlcnBvbGF0ZShcImxpbmVhclwiKTtcblxuICAgICAgICB2YXIgY29sU2VxID0gW1wiI0EyQ0Q1QVwiLCBcIm9yYW5nZVwiLCBcInJlZFwiXTsgLy8gd2lsbCBjeWNsZSB0aHJvdWdoIGNvbG9yIHNlcXVlbmNlLCBhbmQgdGhlbiByZXBlYXQgbGFzdCBjb2xvclxuICAgICAgICB2YXIgbGluZURhdGEgPSBuZXcgQXJyYXk7XG5cbiAgICAgICAgdmFyIHpMb3dlciA9IC0xICogKGQzLm1pbih4VmFscykgLSBub2RlLm1lYW4pIC8gbm9kZS5zZDsgLy8genNjb3JlIG9mIGxvd2VyIGJvdW5kXG4gICAgICAgIHZhciB6VXBwZXIgPSAoZDMubWF4KHhWYWxzKSAtIG5vZGUubWVhbikgLyBub2RlLnNkOyAvLyB6c2NvcmUgb2YgdXBwZXIgYm91bmRcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHpVcHBlcjsgaSsrKSB7XG4gICAgICAgICAgICBsaW5lRGF0YSA9IFt7XG4gICAgICAgICAgICAgICAgXCJ4XCI6IHgoK25vZGUubWVhbiArIGkgKiBub2RlLnNkKSxcbiAgICAgICAgICAgICAgICBcInlcIjogaGVpZ2h0ICogLjdcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBcInhcIjogeCgrbm9kZS5tZWFuICsgaSAqIG5vZGUuc2QpLFxuICAgICAgICAgICAgICAgIFwieVwiOiBoZWlnaHQgKiAuOVxuICAgICAgICAgICAgfV07XG4gICAgICAgICAgICBwbG90c3ZnLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImRcIiwgbGluZUZ1bmN0aW9uKFtsaW5lRGF0YVswXSwgbGluZURhdGFbMV1dKSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInN0cm9rZVwiLCBjb2xTZXFbZDMubWluKFtpLCBjb2xTZXEubGVuZ3RoIC0gMV0pXSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInN0cm9rZS13aWR0aFwiLCAxLjUpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJmaWxsXCIsIFwibm9uZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgekxvd2VyOyBpKyspIHtcbiAgICAgICAgICAgIGxpbmVEYXRhID0gW3tcbiAgICAgICAgICAgICAgICBcInhcIjogeCgrbm9kZS5tZWFuIC0gaSAqIG5vZGUuc2QpLFxuICAgICAgICAgICAgICAgIFwieVwiOiBoZWlnaHQgKiAuN1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIFwieFwiOiB4KCtub2RlLm1lYW4gLSBpICogbm9kZS5zZCksXG4gICAgICAgICAgICAgICAgXCJ5XCI6IGhlaWdodCAqIC45XG4gICAgICAgICAgICB9XTtcbiAgICAgICAgICAgIHBsb3RzdmcuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiZFwiLCBsaW5lRnVuY3Rpb24oW2xpbmVEYXRhWzBdLCBsaW5lRGF0YVsxXV0pKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwic3Ryb2tlXCIsIGNvbFNlcVtkMy5taW4oW2ksIGNvbFNlcS5sZW5ndGggLSAxXSldKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwic3Ryb2tlLXdpZHRoXCIsIDEuNSlcbiAgICAgICAgICAgICAgICAuYXR0cihcImZpbGxcIiwgXCJub25lXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaW5pdGlhbGl6ZSBzbGlkZXIgY29tcG9uZW50c1xuICAgICAgICB2YXIgc2xpZGVCb3ggPSBwbG90c3ZnLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJ4IGF4aXNcIilcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsXCIgKyBoZWlnaHQgKiAuOCArIFwiKVwiKVxuICAgICAgICAgICAgLmNhbGwoZDMuc3ZnLmF4aXMoKVxuICAgICAgICAgICAgICAgICAgLnNjYWxlKHgpXG4gICAgICAgICAgICAgICAgICAudGlja3MoMClcbiAgICAgICAgICAgICAgICAgIC5vcmllbnQoXCJib3R0b21cIikpO1xuICAgICAgICB2YXIgc2xpZGVyID0gcGxvdHN2Zy5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwic2xpZGVyXCIpXG4gICAgICAgICAgICAuY2FsbChicnVzaCk7XG4gICAgICAgIHZhciBoYW5kbGUgPSBzbGlkZXIuYXBwZW5kKFwicG9seWdvblwiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImhhbmRsZVwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCxcIiArIGhlaWdodCAqIC43ICsgXCIpXCIpXG4gICAgICAgICAgICAuYXR0cihcInBvaW50c1wiLCBfID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgcyA9IDY7XG4gICAgICAgICAgICAgICAgbGV0IHhubSA9IG5vZGUuc2V0eHZhbHNbMF0gPT0gJycgPyB4KG5vZGUubWVhbikgOiB4KG5vZGUuc2V0eHZhbHNbMF0pO1xuICAgICAgICAgICAgICAgIHJldHVybiAoeG5tIC0gcykgKyBcIixcIiArICgtcykgKyBcIiBcIiArICh4bm0gKyBzKSArIFwiLFwiICsgKC1zKSArIFwiIFwiICsgeG5tICsgXCIsXCIgKyAocyAqIDEuMyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgdmFyIHNsaWRlcjIgPSBwbG90c3ZnLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJzbGlkZXJcIilcbiAgICAgICAgICAgIC5jYWxsKGJydXNoMik7XG4gICAgICAgIHZhciBoYW5kbGUyID0gc2xpZGVyMi5hcHBlbmQoXCJwb2x5Z29uXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiaGFuZGxlXCIpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLFwiICsgaGVpZ2h0ICogLjkgKyBcIilcIilcbiAgICAgICAgICAgIC5hdHRyKFwicG9pbnRzXCIsIF8gPT4ge1xuICAgICAgICAgICAgICAgIGxldCBzID0gNjtcbiAgICAgICAgICAgICAgICBsZXQgeG5tID0gbm9kZS5zZXR4dmFsc1sxXSA9PSAnJyA/IHgobm9kZS5tZWFuKSA6IHgobm9kZS5zZXR4dmFsc1sxXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh4bm0gLSBzKSArIFwiLFwiICsgcyArIFwiIFwiICsgKHhubSArIHMpICsgXCIsXCIgKyBzICsgXCIgXCIgKyB4bm0gKyBcIixcIiArICgtcyAqIDEuMyk7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBicnVzaGluZyBmdW5jdGlvbnNcbiAgICBmdW5jdGlvbiBicnVzaGVkKCkge1xuICAgICAgICBpZiAoZGl2ID09IFwiI3RhYjJcIikge1xuICAgICAgICAgICAgcGxvdHN2Zy5zZWxlY3QoXCJ0ZXh0I3JhbmdlXCIpXG4gICAgICAgICAgICAgICAgLnRleHQoKCkgPT4gYnJ1c2guZW1wdHkoKSA/XG4gICAgICAgICAgICAgICAgICAgIFwiUmFuZ2U6IFwiLmNvbmNhdChkMy5taW4oeFZhbHMpLnRvUHJlY2lzaW9uKDQpLCBcIiB0byBcIiwgZDMubWF4KHhWYWxzKS50b1ByZWNpc2lvbig0KSkgOlxuICAgICAgICAgICAgICAgICAgICBcIlJhbmdlOiBcIi5jb25jYXQoKGJydXNoLmV4dGVudCgpWzBdKS50b1ByZWNpc2lvbig0KSwgXCIgdG8gXCIsIChicnVzaC5leHRlbnQoKVsxXSkudG9QcmVjaXNpb24oNCkpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG5vZGUuc3Vic2V0cmFuZ2UgPSBicnVzaC5leHRlbnQoKVswXS50b1ByZWNpc2lvbig0KSAhPSBicnVzaC5leHRlbnQoKVsxXS50b1ByZWNpc2lvbig0KSA/XG4gICAgICAgICAgICAgICAgWyhicnVzaC5leHRlbnQoKVswXSkudG9QcmVjaXNpb24oNCksIChicnVzaC5leHRlbnQoKVsxXSkudG9QcmVjaXNpb24oNCldIDpcbiAgICAgICAgICAgICAgICBbXCJcIiwgXCJcIl07XG4gICAgICAgIH0gZWxzZSBpZiAoZGl2ID09IFwiI3NldHhMZWZ0XCIpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGJydXNoLmV4dGVudCgpWzBdO1xuICAgICAgICAgICAgdmFyIHMgPSA2O1xuICAgICAgICAgICAgaWYgKGQzLmV2ZW50LnNvdXJjZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB4LmludmVydChkMy5tb3VzZSh0aGlzKVswXSk7XG4gICAgICAgICAgICAgICAgYnJ1c2guZXh0ZW50KFt2YWx1ZSwgdmFsdWVdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc2V0IHggcG9zaXRpb24gb2Ygc2xpZGVyIGNlbnRlclxuICAgICAgICAgICAgdmFyIHhwb3MgPSB4KHZhbHVlKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA+IGQzLm1heCh4VmFscykpIHsgLy8gZHJhZ2dlZCBwYXN0IG1heFxuICAgICAgICAgICAgICAgIHhwb3MgPSB4KGQzLm1heCh4VmFscykpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA8IGQzLm1pbih4VmFscykpIHsgLy8gZHJhZ2dlZCBwYXN0IG1pblxuICAgICAgICAgICAgICAgIHhwb3MgPSB4KGQzLm1pbih4VmFscykpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgbSA9ICtub2RlLm1lYW47XG4gICAgICAgICAgICAgICAgdmFyIHNkID0gK25vZGUuc2Q7XG4gICAgICAgICAgICAgICAgdmFyIHpTY29yZSA9ICh2YWx1ZSAtIG0pIC8gc2Q7IC8vIHotc2NvcmVcbiAgICAgICAgICAgICAgICB2YXIgelJvdW5kID0gTWF0aC5yb3VuZCh6U2NvcmUpOyAvLyBuZWFyZXN0IGludGVnZXIgei1zY29yZVxuICAgICAgICAgICAgICAgIGlmICguMSA+IE1hdGguYWJzKHpSb3VuZCAtIHpTY29yZSkpIC8vIHNuYXAgdG8gaW50ZWdlciB6LXNjb3JlXG4gICAgICAgICAgICAgICAgICAgIHhwb3MgPSB4KG0gKyAoelJvdW5kICogc2QpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY3JlYXRlIHNsaWRlciBzeW1ib2wgYW5kIHRleHRcbiAgICAgICAgICAgIGhhbmRsZS5hdHRyKFwicG9pbnRzXCIsIF8gPT4gKHhwb3MgLSBzKSArIFwiLFwiICsgKC1zKSArIFwiIFwiICsgKHhwb3MgKyBzKSArIFwiLFwiICsgKC1zKSArIFwiIFwiICsgeHBvcyArIFwiLFwiICsgKHMgKiAxLjMpKTtcbiAgICAgICAgICAgIHBsb3Rzdmcuc2VsZWN0KFwidGV4dCNyYW5nZVwiKVxuICAgICAgICAgICAgLnRleHQoXyA9PiB7XG4gICAgICAgICAgICAgICAgICBsZXQgcmV0dXJudmFsID0gXCJ4OiBcIi5jb25jYXQoKGludngoeHBvcykpLnRvUHJlY2lzaW9uKDQpKTtcbiAgICAgICAgICAgICAgICAgIGxldCB4dmFsID0gaW52eCh4cG9zKS50b1ByZWNpc2lvbig0KTtcbiAgICAgICAgICAgICAgICAgIGxldCBteWNlbGwgPSBub2RlLm5hbWUrXCJGcm9tXCI7IC8vIGhhcmRjb2RlZCBoZXJlXG4gICAgICAgICAgICAgICAgICBpZihkb2N1bWVudC5nZXRFbGVtZW50QnlJZChteWNlbGwpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG15Y2VsbCkuaW5uZXJUZXh0PXh2YWw7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmV0dXJudmFsfSk7XG4gICAgICAgICAgICBub2RlLnNldHh2YWxzWzBdID0gKGludngoeHBvcykpLnRvUHJlY2lzaW9uKDQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2VydGFpbmx5IGEgbW9yZSBjbGV2ZXIgd2F5IHRvIGRvIHRoaXMsIGJ1dCBmb3Igbm93IGl0J3MgYmFzaWNhbGx5IGNvcGllZCB3aXRoIGJydXNoIGFuZCBoYW5kbGUgY2hhbmdlcyB0byBicnVzaDIgYW5kIGhhbmRsZTIgYW5kICNyYW5nZSB0byAjcmFuZ2UyIGFuZCBzZXR4dmFsc1swXSB0byBzZXR4dmFsc1sxXVxuICAgIGZ1bmN0aW9uIGJydXNoZWQyKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBicnVzaDIuZXh0ZW50KClbMF07XG4gICAgICAgIHZhciBzID0gNjsgLy8gc2NhbGluZyBmb3IgdHJpYW5nbGUgc2hhcGVcblxuICAgICAgICBpZiAoZDMuZXZlbnQuc291cmNlRXZlbnQpIHtcbiAgICAgICAgICAgIHZhbHVlID0geC5pbnZlcnQoZDMubW91c2UodGhpcylbMF0pO1xuICAgICAgICAgICAgYnJ1c2gyLmV4dGVudChbdmFsdWUsIHZhbHVlXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgeCBwb3NpdGlvbiBvZiBzbGlkZXIgY2VudGVyXG4gICAgICAgIHZhciB4cG9zID0geCh2YWx1ZSk7XG4gICAgICAgIGlmICh2YWx1ZSA+IGQzLm1heCh4VmFscykpIHsgLy8gZHJhZ2dlZCBwYXN0IG1heFxuICAgICAgICAgICAgeHBvcyA9IHgoZDMubWF4KHhWYWxzKSk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPCBkMy5taW4oeFZhbHMpKSB7IC8vIGRyYWdnZWQgcGFzdCBtaW5cbiAgICAgICAgICAgIHhwb3MgPSB4KGQzLm1pbih4VmFscykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG0gPSArbm9kZS5tZWFuO1xuICAgICAgICAgICAgdmFyIHNkID0gK25vZGUuc2Q7XG4gICAgICAgICAgICB2YXIgelNjb3JlID0gKHZhbHVlIC0gbSkgLyBzZDsgLy8gei1zY29yZVxuICAgICAgICAgICAgdmFyIHpSb3VuZCA9IE1hdGgucm91bmQoelNjb3JlKTsgLy8gbmVhcmVzdCBpbnRlZ2VyIHotc2NvcmVcbiAgICAgICAgICAgIGlmICguMSA+IE1hdGguYWJzKHpSb3VuZCAtIHpTY29yZSkpIC8vIHNuYXAgdG8gaW50ZWdlciB6LXNjb3JlXG4gICAgICAgICAgICAgICAgeHBvcyA9IHgobSArICh6Um91bmQgKiBzZCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JlYXRlIHNsaWRlciBzeW1ib2wgYW5kIHRleHRcbiAgICAgICAgaGFuZGxlMi5hdHRyKFwicG9pbnRzXCIsIF8gPT4gKHhwb3MgLSBzKSArIFwiLFwiICsgcyArIFwiIFwiICsgKHhwb3MgKyBzKSArIFwiLFwiICsgcyArIFwiIFwiICsgeHBvcyArIFwiLFwiICsgKC1zICogMS4zKSk7XG4gICAgICAgIHBsb3Rzdmcuc2VsZWN0KFwidGV4dCNyYW5nZTJcIilcbiAgICAgICAgLnRleHQoXyA9PiB7XG4gICAgICAgICAgICAgIGxldCByZXR1cm52YWwgPSBcIngxOiBcIi5jb25jYXQoKGludngoeHBvcykpLnRvUHJlY2lzaW9uKDQpKTtcbiAgICAgICAgICAgICAgbGV0IHgxdmFsID0gaW52eCh4cG9zKS50b1ByZWNpc2lvbig0KTtcbiAgICAgICAgICAgICAgbGV0IG15Y2VsbCA9IG5vZGUubmFtZStcIlRvXCI7IC8vIGhhcmRjb2RlZCBoZXJlXG4gICAgICAgICAgICAgIGlmKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG15Y2VsbCkpIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChteWNlbGwpLmlubmVyVGV4dD14MXZhbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmV0dXJudmFsfSk7XG4gICAgICAgIG5vZGUuc2V0eHZhbHNbMV0gPSAoaW52eCh4cG9zKSkudG9QcmVjaXNpb24oNCk7XG4gICAgICAgIFxuICAgICAgICBcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBiYXJzKG5vZGUsIGRpdiwgcHJpdikge1xuICAgIC8vIEhpc3RvZ3JhbSBzcGFjaW5nXG4gICAgdmFyIGJhclBhZGRpbmcgPSAuMDE1OyAvLyBTcGFjZSBiZXR3ZWVuIGJhcnNcbiAgICB2YXIgdG9wU2NhbGUgPSAxLjI7IC8vIE11bHRpcGxpY2F0aXZlIGZhY3RvciB0byBhc3NpZ24gc3BhY2UgYXQgdG9wIHdpdGhpbiBncmFwaCAtIGN1cnJlbnRseSByZW1vdmVkIGZyb20gaW1wbGVtZW50YXRpb25cbiAgICB2YXIgcGxvdFhheGlzID0gdHJ1ZTtcblxuICAgIC8vIERhdGFcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG5vZGUucGxvdHZhbHVlcyk7XG4gICAgdmFyIHlWYWxzID0gbmV3IEFycmF5O1xuICAgIHZhciBjaVVwcGVyVmFscyA9IG5ldyBBcnJheTtcbiAgICB2YXIgY2lMb3dlclZhbHMgPSBuZXcgQXJyYXk7XG4gICAgdmFyIGNpU2l6ZTtcblxuICAgIHZhciB4VmFscyA9IG5ldyBBcnJheTtcbiAgICB2YXIgeVZhbEtleSA9IG5ldyBBcnJheTtcblxuICAgIGlmIChub2RlLm5hdHVyZSA9PSBcIm5vbWluYWxcIikge1xuICAgICAgICB2YXIgeGkgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChub2RlLnBsb3R2YWx1ZXNba2V5c1tpXV0gPT0gMClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHlWYWxzW3hpXSA9IG5vZGUucGxvdHZhbHVlc1trZXlzW2ldXTtcbiAgICAgICAgICAgIHhWYWxzW3hpXSA9IHhpO1xuICAgICAgICAgICAgaWYgKHByaXYpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5wbG90dmFsdWVzQ0kpIHtcbiAgICAgICAgICAgICAgICAgICAgY2lMb3dlclZhbHNbeGldID0gbm9kZS5wbG90VmFsdWVzQ0kubG93ZXJCb3VuZFtrZXlzW2ldXTtcbiAgICAgICAgICAgICAgICAgICAgY2lVcHBlclZhbHNbeGldID0gbm9kZS5wbG90VmFsdWVzQ0kudXBwZXJCb3VuZFtrZXlzW2ldXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2lTaXplID0gY2lVcHBlclZhbHNbeGldIC0gY2lMb3dlclZhbHNbeGldO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgeVZhbEtleS5wdXNoKHtcbiAgICAgICAgICAgICAgICB5OiB5VmFsc1t4aV0sXG4gICAgICAgICAgICAgICAgeDoga2V5c1tpXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB4aSA9IHhpICsgMTtcbiAgICAgICAgfVxuICAgICAgICB5VmFsS2V5LnNvcnQoKGEsIGIpID0+IGIueSAtIGEueSk7IC8vIGFycmF5IG9mIG9iamVjdHMsIGVhY2ggb2JqZWN0IGhhcyB5LCB0aGUgc2FtZSBhcyB5VmFscywgYW5kIHgsIHRoZSBjYXRlZ29yeVxuICAgICAgICB5VmFscy5zb3J0KChhLCBiKSA9PiBiIC0gYSk7IC8vIGFycmF5IG9mIHkgdmFsdWVzLCB0aGUgaGVpZ2h0IG9mIHRoZSBiYXJzXG4gICAgICAgIGNpVXBwZXJWYWxzLnNvcnQoKGEsIGIpID0+IGIueSAtIGEueSk7IC8vID9cbiAgICAgICAgY2lMb3dlclZhbHMuc29ydCgoYSwgYikgPT4gYi55IC0gYS55KTsgLy8gP1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcInBsb3R2YWx1ZXMgaW4gYmFyc1wiKTtcbiAgICAgICAgICAgIHlWYWxzW2ldID0gbm9kZS5wbG90dmFsdWVzW2tleXNbaV1dO1xuICAgICAgICAgICAgeFZhbHNbaV0gPSBOdW1iZXIoa2V5c1tpXSk7XG4gICAgICAgICAgICBpZiAocHJpdikge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLnBsb3R2YWx1ZXNDSSkge1xuICAgICAgICAgICAgICAgICAgICBjaUxvd2VyVmFsc1tpXSA9IG5vZGUucGxvdHZhbHVlc0NJLmxvd2VyQm91bmRba2V5c1tpXV07XG4gICAgICAgICAgICAgICAgICAgIGNpVXBwZXJWYWxzW2ldID0gbm9kZS5wbG90dmFsdWVzQ0kudXBwZXJCb3VuZFtrZXlzW2ldXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2lTaXplID0gY2lVcHBlclZhbHNbaV0gLSBjaUxvd2VyVmFsc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICgoeVZhbHMubGVuZ3RoID4gMTUgJiBub2RlLm51bWNoYXIgPT0gXCJudW1lcmljXCIpIHx8ICh5VmFscy5sZW5ndGggPiA1ICYgbm9kZS5udW1jaGFyID09IFwiY2hhcmFjdGVyXCIpKVxuICAgICAgICBwbG90WGF4aXMgPSBmYWxzZTtcbiAgICB2YXIgbWF4WSA9IGQzLm1heCh5VmFscyk7IC8vIGluIHRoZSBmdXR1cmUsIHNldCBtYXhZIHRvIHRoZSB2YWx1ZSBvZiB0aGUgbWF4aW11bSBjb25maWRlbmNlIGxpbWl0XG4gICAgaWYgKHByaXYgJiYgbm9kZS5wbG90dmFsdWVzQ0kpIG1heFkgPSBkMy5tYXgoY2lVcHBlclZhbHMpO1xuICAgIHZhciBtaW5YID0gZDMubWluKHhWYWxzKTtcbiAgICB2YXIgbWF4WCA9IGQzLm1heCh4VmFscyk7XG5cbiAgICBsZXQgbXlkaXY7XG4gICAgaWYgKGRpdiA9PSBcInNldHhMZWZ0XCIpIG15ZGl2ID0gXCIjc2V0eExlZnRcIjtcbiAgICBlbHNlIGlmIChkaXYgPT0gXCJ2YXJTdW1tYXJ5XCIpIG15ZGl2ID0gXCIjdGFiM1wiO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGFsZXJ0KFwiRXJyb3I6IGluY29ycmVjdCBkaXYgc2VsZWN0ZWQgZm9yIHBsb3RzXCIpO1xuXG4gICAgdmFyIHRlbXBXaWR0aCA9IGQzLnNlbGVjdChteWRpdikuc3R5bGUoXCJ3aWR0aFwiKVxuICAgIHZhciB3aWR0aCA9IHRlbXBXaWR0aC5zdWJzdHJpbmcoMCwgKHRlbXBXaWR0aC5sZW5ndGggLSAyKSk7XG4gICAgdmFyIHRlbXBIZWlnaHQgPSBkMy5zZWxlY3QobXlkaXYpLnN0eWxlKFwiaGVpZ2h0XCIpXG4gICAgdmFyIGhlaWdodCA9IHRlbXBIZWlnaHQuc3Vic3RyaW5nKDAsICh0ZW1wSGVpZ2h0Lmxlbmd0aCAtIDIpKTtcblxuICAgIHZhciBtYXJnaW4gPSB7XG4gICAgICAgIHRvcDogMjAsXG4gICAgICAgIHJpZ2h0OiAyMCxcbiAgICAgICAgYm90dG9tOiA1MyxcbiAgICAgICAgbGVmdDogMTBcbiAgICB9O1xuICAgIGxldCB0dyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtYWluJykub2Zmc2V0V2lkdGg7XG5cbiAgICAvLyBOZWVkIHRvIGZpeCBhdXRvbWF0aWMgd2lkdGggYW5kIGhlaWdodCBzZXR0aW5ncyBmb3IgbGVmdHBhbmVsICgjdGFiMiwgI3RhYjMpXG4gICAgaWYgKG15ZGl2ID09IFwiI3RhYjNcIikge1xuICAgICAgICB3aWR0aCA9IDAuNyAqICh3aWR0aCAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0KTtcbiAgICAgICAgaGVpZ2h0ID0gMC4zICogKGhlaWdodCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tKTtcbiAgICB9IGVsc2UgaWYgKG15ZGl2ID09IFwiI3NldHhMZWZ0XCIpIHtcbiAgICAgICAgLy93aWR0aCA9IDIwMDtcbiAgICAgICAgLy9oZWlnaHQgPSAxMjA7XG4gICAgICAgIHdpZHRoPXR3Ki4xODUtbWFyZ2luLmxlZnQtbWFyZ2luLnJpZ2h0OyAvL3JpZ2h0cGFuZWwuZXhwYW5kIGlzIDQwIHBlcmNlbnQsIHNldHhMZWZ0IHRvIDUwIHBlcmNlbnQsIHRvZ2dsZSBiYXIgaXMgMTZweCwgcGFkZGluZywgaXQncyBhbGwgYWJvdXQgLjE4NVxuICAgICAgICBoZWlnaHQ9d2lkdGgqLjY7IC8vaGVpZ2h0IHRvIHdpZHRoIGlzIC42XG4gICAgfSBlbHNlIHtcbiAgICAgICAgd2lkdGggPSAwLjM1ICogKHdpZHRoIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQpO1xuICAgICAgICBoZWlnaHQgPSAwLjI1ICogKGhlaWdodCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tKTtcbiAgICB9O1xuXG4gICAgaWYgKHByaXYgJiYgbm9kZS5zdGFiaWxpdHlCaW4pIHtcbiAgICAgICAgdmFyIHggPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAgICAgLmRvbWFpbihbbWluWCAtIDAuNSwgbWF4WCArIDEuNV0pXG4gICAgICAgICAgICAucmFuZ2UoWzAsIHdpZHRoXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHggPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAgICAgLmRvbWFpbihbbWluWCAtIDAuNSwgbWF4WCArIDAuNV0pXG4gICAgICAgICAgICAucmFuZ2UoWzAsIHdpZHRoXSk7XG4gICAgfVxuXG4gICAgdmFyIGludnggPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAucmFuZ2UoW21pblggLSAwLjUsIG1heFggKyAwLjVdKVxuICAgICAgICAuZG9tYWluKFswLCB3aWR0aF0pO1xuXG4gICAgdmFyIHkgPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAuZG9tYWluKFswLCBtYXhZXSlcbiAgICAgICAgLnJhbmdlKFswLCBoZWlnaHRdKTtcblxuICAgIHZhciB4QXhpcyA9IGQzLnN2Zy5heGlzKClcbiAgICAgICAgLnNjYWxlKHgpXG4gICAgICAgIC50aWNrcyh5VmFscy5sZW5ndGgpXG4gICAgICAgIC5vcmllbnQoXCJib3R0b21cIik7XG5cbiAgICB2YXIgeUF4aXMgPSBkMy5zdmcuYXhpcygpXG4gICAgICAgIC5zY2FsZSh5KVxuICAgICAgICAub3JpZW50KFwibGVmdFwiKTtcblxuICAgIHZhciBicnVzaCA9IGQzLnN2Zy5icnVzaCgpXG4gICAgICAgIC54KHgpXG4gICAgICAgIC5leHRlbnQoKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUuc3Vic2V0cmFuZ2UubGVuZ3RoID09IDEgP1xuICAgICAgICAgICAgICAgIFtub2RlLnN1YnNldHJhbmdlWzBdLCBub2RlLnN1YnNldHJhbmdlWzBdXVxuICAgICAgICAgICAgICAgIDogbm9kZS5zdWJzZXRyYW5nZTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKFwiYnJ1c2hcIiwgYnJ1c2hlZCk7XG5cbiAgICB2YXIgYnJ1c2gyID0gZDMuc3ZnLmJydXNoKClcbiAgICAgICAgLngoeClcbiAgICAgICAgLm9uKFwiYnJ1c2hcIiwgYnJ1c2hlZDIpO1xuXG4gICAgLy8gQ3JlYXRlIFNWRyBlbGVtZW50XG4gICAgLy8gY3VtYmVyc29tZSB0byB0cmVhdCBcInRhYjNcIiBkaWZmZXJlbnRseSwgYnV0IHdvcmtzIGZvciBub3dcbiAgICAvLyB0YWIzLCBoYXMgYW4gaXNzdWUsIHRoYXQgdW5sZXNzIHdpZHRoIGhlaWdodCBoYXJkY29kZWQsIHRoZXkgZ3JvdyB3aXRoIGVhY2ggYWRkaXRpb25hbCBncmFwaC5cbiAgICBpZiAobXlkaXYgPT0gXCIjdGFiM1wiKSB7XG4gICAgICAgIHZhciBwbG90c3ZnID0gZDMuc2VsZWN0KG15ZGl2KVxuICAgICAgICAgICAgLnNlbGVjdEFsbChcInN2Z1wiKVxuICAgICAgICAgICAgLnJlbW92ZSgpO1xuXG4gICAgICAgIHZhciBwbG90c3ZnID0gZDMuc2VsZWN0KG15ZGl2KVxuICAgICAgICAgICAgLmFwcGVuZChcInN2Z1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCAoKSA9PiBub2RlLm5hbWUudG9TdHJpbmcoKS5jb25jYXQobXlkaXYuc3Vic3RyKDEpKSlcbiAgICAgICAgICAgIC5zdHlsZShcIndpZHRoXCIsIDMwMCkgLy9zZXR0aW5nIGhlaWdodCB0byB0aGUgaGVpZ2h0IG9mICNtYWluLmxlZnRcbiAgICAgICAgICAgIC5zdHlsZShcImhlaWdodFwiLCAyMDApXG4gICAgICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBtYXJnaW4ubGVmdCArIFwiLFwiICsgbWFyZ2luLnRvcCArIFwiKVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcGxvdHN2ZyA9IGQzLnNlbGVjdChteWRpdilcbiAgICAgICAgICAgIC5hcHBlbmQoXCJzdmdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIG15bmFtZSA9IG5vZGUubmFtZS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIG15bmFtZSA9IG15bmFtZS5yZXBsYWNlKC9cXCh8XFwpL2csIFwiXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBteW5hbWUuY29uY2F0KFwiX1wiLCBteWRpdi5zdWJzdHIoMSksIFwiX1wiLCBub2RlLmlkKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuc3R5bGUoXCJ3aWR0aFwiLCB3aWR0aCArIG1hcmdpbi5sZWZ0ICsgbWFyZ2luLnJpZ2h0KSAvL3NldHRpbmcgaGVpZ2h0IHRvIHRoZSBoZWlnaHQgb2YgI21haW4ubGVmdFxuICAgICAgICAgICAgLnN0eWxlKFwiaGVpZ2h0XCIsIGhlaWdodCArIG1hcmdpbi50b3AgKyBtYXJnaW4uYm90dG9tKVxuICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgbWFyZ2luLmxlZnQgKyBcIixcIiArIG1hcmdpbi50b3AgKyBcIilcIik7XG4gICAgfTtcblxuICAgIHZhciByZWN0V2lkdGggPSB4KG1pblggKyAwLjUgLSAyICogYmFyUGFkZGluZyk7IC8vdGhlIFwid2lkdGhcIiBpcyB0aGUgY29vcmRpbmF0ZSBvZiB0aGUgZW5kIG9mIHRoZSBmaXJzdCBiYXJcblxuICAgIHBsb3Rzdmcuc2VsZWN0QWxsKFwicmVjdFwiKVxuICAgICAgICAuZGF0YSh5VmFscylcbiAgICAgICAgLmVudGVyKClcbiAgICAgICAgLmFwcGVuZChcInJlY3RcIilcbiAgICAgICAgLmF0dHIoXCJ4XCIsIChkLCBpKSA9PiB4KHhWYWxzW2ldIC0gMC41ICsgYmFyUGFkZGluZykpXG4gICAgICAgIC5hdHRyKFwieVwiLCBkID0+IHkobWF4WSAtIGQpKVxuICAgICAgICAuYXR0cihcIndpZHRoXCIsIHJlY3RXaWR0aClcbiAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgeSlcbiAgICAgICAgLmF0dHIoXCJmaWxsXCIsIFwiIzFmNzdiNFwiKTtcblxuICAgIC8vIGRyYXcgZXJyb3IgYmFycywgdGhyZXNob2xkIGxpbmUgYW5kIGV4dHJhIGJpblxuICAgIGlmIChwcml2KSB7XG4gICAgICAgIGlmICh5VmFscy5sZW5ndGggPD0gMjApIHtcbiAgICAgICAgICAgIHBsb3Rzdmcuc2VsZWN0QWxsKFwibGluZVwiKVxuICAgICAgICAgICAgICAgIC5kYXRhKGNpVXBwZXJWYWxzKVxuICAgICAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAgICAgLmFwcGVuZChcImxpbmVcIilcbiAgICAgICAgICAgICAgICAuc3R5bGUoXCJzdHJva2VcIiwgXCJibGFja1wiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieDFcIiwgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geCh4VmFsc1tpXSAtIDAuNSArIGJhclBhZGRpbmcpICsgcmVjdFdpZHRoIC8gMlxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgIFx0LmF0dHIoXCJ5MVwiLCBkID0+IHkobWF4WSAtIGQpKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieDJcIiwgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geCh4VmFsc1tpXSAtIDAuNSArIGJhclBhZGRpbmcpICsgcmVjdFdpZHRoIC8gMlxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ5MlwiLCBkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHkyID0geShtYXhZIC0gZCArIGNpU2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB5MiA+PSB5KG1heFkpID8geShtYXhZKSA6IHkyO1xuICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy9kcmF3IHRvcCB0aWNrcyBvbiBlcnJvciBiYXJzXG4gICAgICAgICAgICAvL25lZWQgdG8gZml4IHRoZSBoZWlnaHQgb2YgdGhlIGdyYXBocyAtIHRoZSB0b3BzIG9mIGVycm9yIGJhcnMgYXJlIGdldHRpbmcgY3V0IG9mZlxuICAgICAgICAgICAgcGxvdHN2Zy5zZWxlY3RBbGwoXCIudG9wVGlja1wiKVxuICAgICAgICAgICAgICAgIC5kYXRhKGNpVXBwZXJWYWxzKVxuICAgICAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAgICAgLmFwcGVuZChcImxpbmVcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwidG9wVGlja1wiKVxuICAgICAgICAgICAgICAgIC5zdHlsZShcInN0cm9rZVwiLCBcImJsYWNrXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ4MVwiLCBmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh5VmFscy5sZW5ndGggPiAyMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHgoeFZhbHNbaV0gLSAwLjUgKyBiYXJQYWRkaW5nKSAvL21ha2UgdGljayBiaWdnZXIgdG8gaW5jcmVhc2UgdmlzaWJpbGl0eVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHgoeFZhbHNbaV0gLSAwLjUgKyBiYXJQYWRkaW5nKSArIDAuNCAqIHJlY3RXaWR0aFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInkxXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHkobWF4WSAtIGQpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ4MlwiLCBmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh5VmFscy5sZW5ndGggPiAyMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHgoeFZhbHNbaV0gLSAwLjUgKyBiYXJQYWRkaW5nKSArIHJlY3RXaWR0aCAvL21ha2UgdGljayBiaWdnZXIgdG8gaW5jcmVhc2UgdmlzaWJpbGl0eVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHgoeFZhbHNbaV0gLSAwLjUgKyBiYXJQYWRkaW5nKSArIDAuNiAqIHJlY3RXaWR0aFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInkyXCIsIGQgPT4geShtYXhZIC0gZCkpO1xuXG4gICAgICAgICAgICAvLyBkcmF3IGJvdHRvbSB0aWNrcyBvZiBlcnJvciBiYXJzXG4gICAgICAgICAgICBwbG90c3ZnLnNlbGVjdEFsbChcIi5ib3R0b21UaWNrXCIpXG4gICAgICAgICAgICAgICAgLmRhdGEoY2lMb3dlclZhbHMpXG4gICAgICAgICAgICAgICAgLmVudGVyKClcbiAgICAgICAgICAgICAgICAuYXBwZW5kKFwibGluZVwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJib3R0b21UaWNrXCIpXG4gICAgICAgICAgICAgICAgLnN0eWxlKFwic3Ryb2tlXCIsIFwiYmxhY2tcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcIngxXCIsIGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHlWYWxzLmxlbmd0aCA+IDIwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geCh4VmFsc1tpXSAtIDAuNSArIGJhclBhZGRpbmcpXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geCh4VmFsc1tpXSAtIDAuNSArIGJhclBhZGRpbmcpICsgMC40ICogcmVjdFdpZHRoXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieTFcIiwgZCA9PiB5KG1heFkgLSBkKSlcbiAgICAgICAgICAgICAgICAuYXR0cihcIngyXCIsIGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHlWYWxzLmxlbmd0aCA+IDIwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geCh4VmFsc1tpXSAtIDAuNSArIGJhclBhZGRpbmcpICsgcmVjdFdpZHRoXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geCh4VmFsc1tpXSAtIDAuNSArIGJhclBhZGRpbmcpICsgMC42ICogcmVjdFdpZHRoXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieTJcIiwgZCA9PiB5KG1heFkgLSBkKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwbG90c3ZnLnNlbGVjdEFsbChcIi5kZW5zZUVycm9yXCIpXG4gICAgICAgICAgICAgICAgLmRhdGEoeVZhbHMpXG4gICAgICAgICAgICAgICAgLmVudGVyKClcbiAgICAgICAgICAgICAgICAuYXBwZW5kKFwicmVjdFwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJkZW5zZUVycm9yXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIChkLCBpKSA9PiB4KHhWYWxzW2ldIC0gMC41ICsgYmFyUGFkZGluZykpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIGQgPT4geShtYXhZIC0gZCkgLSAuMSAqIHkoZCkpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCByZWN0V2lkdGgpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgZCA9PiAoeShtYXhZIC0gZCkgKyAuMSAqIHkoZCkpIC0gKHkobWF4WSAtIGQpIC0gLjEgKiB5KGQpKSlcbiAgICAgICAgICAgICAgICAuYXR0cihcImZpbGxcIiwgXCJzaWx2ZXJcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvL2lmIHN0YXRlbWVudCBmb3Igc3RhYmlsaXR5IGhpc3RvZ3JhbXNcbiAgICAgICAgLy9leHRyYSBzdGFiaWxpdHkgYmluXG4gICAgICAgIGlmIChub2RlLnN0YWJpbGl0eUJpbikge1xuICAgICAgICAgICAgcGxvdHN2Zy5hcHBlbmQoXCJyZWN0XCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIHgobWF4WCArIDAuNSAtIGJhclBhZGRpbmcpKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieVwiLCB5KG1heFkpIC0gbm9kZS5zdGFiaWxpdHlCaW4pXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCByZWN0V2lkdGgpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgbm9kZS5zdGFiaWxpdHlCaW4pXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJmaWxsXCIsIFwic2lsdmVyXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy90aHJlc2hvbGQgbGluZVxuICAgICAgICBpZiAobm9kZS50aHJlc2hvbGQpIHtcbiAgICAgICAgICAgIHBsb3RzdmcuYXBwZW5kKFwibGluZVwiKVxuICAgICAgICAgICAgICAgIC5zdHlsZShcInN0cm9rZVwiLCBcImJsYWNrXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ4MVwiLCB4KG1pblggLSAwLjUgKyBiYXJQYWRkaW5nKSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInkxXCIsIHkobWF4WSkgLSBub2RlLnRocmVzaG9sZClcbiAgICAgICAgICAgICAgICAuYXR0cihcIngyXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInN0YWJpbGl0eUJpblwiKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2cobm9kZS5zdGFiaWxpdHlCaW4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5zdGFiaWxpdHlCaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB4KG1heFggKyAwLjUgLSBiYXJQYWRkaW5nKSArIHJlY3RXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB4KG1heFggKyAwLjUgLSBiYXJQYWRkaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ5MlwiLCB5KG1heFkpIC0gbm9kZS50aHJlc2hvbGQpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocGxvdFhheGlzKSB7XG4gICAgICAgIHBsb3RzdmcuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInggYXhpc1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCxcIiArIGhlaWdodCArIFwiKVwiKVxuICAgICAgICAgICAgLmNhbGwoeEF4aXMpO1xuICAgIH1cblxuICAgIHBsb3RzdmcuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAuYXR0cihcInhcIiwgKHdpZHRoIC8gMikpXG4gICAgICAgIC5hdHRyKFwieVwiLCAwIC0gKG1hcmdpbi50b3AgLyAyKSlcbiAgICAgICAgLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKVxuICAgICAgICAuc3R5bGUoXCJmb250LXNpemVcIiwgXCIxMnB4XCIpXG4gICAgICAgIC50ZXh0KG5vZGUubmFtZSk7XG5cbiAgICBpZiAobXlkaXYgPT0gXCIjc2V0eExlZnRcIikge1xuICAgICAgICBwbG90c3ZnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgXCJyYW5nZVwiKSAvLyBiYWQgcHJhY3RpY2UsIG5vdCB1bmlxdWVcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsJ3h2YWwnKVxuICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIDI1KVxuICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIGhlaWdodCArIDQwKVxuICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubmF0dXJlID09PSBcIm5vbWluYWxcIikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IE1hdGgucm91bmQoeVZhbEtleS5sZW5ndGggLyAyKSAtIDE7XG4gICAgICAgICAgICAgICAgICAgIGxldCBteWNlbGwgPSBub2RlLm5hbWUrXCJGcm9tXCI7IC8vIGhhcmRjb2RlZCBoZXJlXG4gICAgICAgICAgICAgICAgICAgIGlmKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG15Y2VsbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG15Y2VsbCkuaW5uZXJUZXh0PXlWYWxLZXlbdF0ueDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFwieDogXCIgKyB5VmFsS2V5W3RdLngpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBteWNlbGwgPSBub2RlLm5hbWUrXCJGcm9tXCI7IC8vIGhhcmRjb2RlZCBoZXJlXG4gICAgICAgICAgICAgICAgICAgIGlmKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG15Y2VsbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG15Y2VsbCkuaW5uZXJUZXh0PSgrbm9kZS5tZWFuKS50b1ByZWNpc2lvbig0KS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoXCJ4OiBcIi5jb25jYXQoKCtub2RlLm1lYW4pLnRvUHJlY2lzaW9uKDQpLnRvU3RyaW5nKCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBwbG90c3ZnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgXCJyYW5nZTJcIikgLy9iYWQgcHJhY3RpY2UsIG5vdCB1bmlxdWVcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsJ3gxdmFsJylcbiAgICAgICAgICAgIC5hdHRyKFwieFwiLCAyNSlcbiAgICAgICAgICAgIC5hdHRyKFwieVwiLCBoZWlnaHQgKyA1MClcbiAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLm5hdHVyZSA9PT0gXCJub21pbmFsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBNYXRoLnJvdW5kKHlWYWxLZXkubGVuZ3RoIC8gMikgLSAxO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFwieDE6IFwiICsgeVZhbEtleVt0XS54KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFwieDE6IFwiLmNvbmNhdCgoK25vZGUubWVhbikudG9QcmVjaXNpb24oNCkudG9TdHJpbmcoKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGNyZWF0ZSB0aWNrIG1hcmtzIGF0IGFsbCB6c2NvcmVzIGluIHRoZSBib3VuZHMgb2YgdGhlIGRhdGFcbiAgICAgICAgdmFyIGxpbmVGdW5jdGlvbiA9IGQzLnN2Zy5saW5lKClcbiAgICAgICAgICAgIC54KGQgPT4gZC54KVxuICAgICAgICAgICAgLnkoZCA9PiBkLnkpXG4gICAgICAgICAgICAuaW50ZXJwb2xhdGUoXCJsaW5lYXJcIik7XG5cbiAgICAgICAgdmFyIGNvbFNlcSA9IFtcIiNBMkNENUFcIiwgXCJvcmFuZ2VcIiwgXCJyZWRcIl07IC8vIHdpbGwgY3ljbGUgdGhyb3VnaCBjb2xvciBzZXF1ZW5jZSwgYW5kIHRoZW4gcmVwZWF0IGxhc3QgY29sb3JcbiAgICAgICAgdmFyIGxpbmVEYXRhID0gbmV3IEFycmF5O1xuXG4gICAgICAgIHZhciB6TG93ZXIgPSAtMSAqIChtaW5YIC0gbm9kZS5tZWFuKSAvIG5vZGUuc2Q7IC8vIHpzY29yZSBvZiBsb3dlciBib3VuZFxuICAgICAgICB2YXIgelVwcGVyID0gKG1heFggLSBub2RlLm1lYW4pIC8gbm9kZS5zZDsgLy8genNjb3JlIG9mIHVwcGVyIGJvdW5kXG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB6VXBwZXI7IGkrKykge1xuICAgICAgICAgICAgbGluZURhdGEgPSBbe1xuICAgICAgICAgICAgICAgIFwieFwiOiB4KCtub2RlLm1lYW4gKyBpICogbm9kZS5zZCksXG4gICAgICAgICAgICAgICAgXCJ5XCI6IGhlaWdodCAqIC43XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgXCJ4XCI6IHgoK25vZGUubWVhbiArIGkgKiBub2RlLnNkKSxcbiAgICAgICAgICAgICAgICBcInlcIjogaGVpZ2h0ICogLjlcbiAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgcGxvdHN2Zy5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJkXCIsIGxpbmVGdW5jdGlvbihbbGluZURhdGFbMF0sIGxpbmVEYXRhWzFdXSkpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJzdHJva2VcIiwgY29sU2VxW2QzLm1pbihbaSwgY29sU2VxLmxlbmd0aCAtIDFdKV0pXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJzdHJva2Utd2lkdGhcIiwgMS41KVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiZmlsbFwiLCBcIm5vbmVcIik7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHpMb3dlcjsgaSsrKSB7XG4gICAgICAgICAgICBsaW5lRGF0YSA9IFt7XG4gICAgICAgICAgICAgICAgXCJ4XCI6IHgoK25vZGUubWVhbiAtIGkgKiBub2RlLnNkKSxcbiAgICAgICAgICAgICAgICBcInlcIjogaGVpZ2h0ICogLjdcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBcInhcIjogeCgrbm9kZS5tZWFuIC0gaSAqIG5vZGUuc2QpLFxuICAgICAgICAgICAgICAgIFwieVwiOiBoZWlnaHQgKiAuOVxuICAgICAgICAgICAgfV07XG4gICAgICAgICAgICBwbG90c3ZnLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImRcIiwgbGluZUZ1bmN0aW9uKFtsaW5lRGF0YVswXSwgbGluZURhdGFbMV1dKSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInN0cm9rZVwiLCBjb2xTZXFbZDMubWluKFtpLCBjb2xTZXEubGVuZ3RoIC0gMV0pXSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInN0cm9rZS13aWR0aFwiLCAxLjUpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJmaWxsXCIsIFwibm9uZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSBkMy5taW4oeFZhbHMpOyBpIDw9IGQzLm1heCh4VmFscyk7IGkrKykge1xuICAgICAgICAgICAgbGluZURhdGEgPSBbe1xuICAgICAgICAgICAgICAgIFwieFwiOiB4KGkpLFxuICAgICAgICAgICAgICAgIFwieVwiOiBoZWlnaHQgKiAuNzVcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBcInhcIjogeChpKSxcbiAgICAgICAgICAgICAgICBcInlcIjogaGVpZ2h0ICogLjg1XG4gICAgICAgICAgICB9XTtcbiAgICAgICAgICAgIHBsb3RzdmcuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiZFwiLCBsaW5lRnVuY3Rpb24oW2xpbmVEYXRhWzBdLCBsaW5lRGF0YVsxXV0pKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwic3Ryb2tlXCIsIFwiYmxhY2tcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcInN0cm9rZS13aWR0aFwiLCAxKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiZmlsbFwiLCBcIm5vbmVcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpbml0aWFsaXplIHNsaWRlciBjb21wb25lbnRzXG4gICAgICAgIHZhciBzbGlkZUJveCA9IHBsb3RzdmcuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInggYXhpc1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCxcIiArIGhlaWdodCAqIC44ICsgXCIpXCIpXG4gICAgICAgICAgICAuY2FsbChkMy5zdmcuYXhpcygpXG4gICAgICAgICAgICAgICAgICAuc2NhbGUoeClcbiAgICAgICAgICAgICAgICAgIC50aWNrcygwKVxuICAgICAgICAgICAgICAgICAgLm9yaWVudChcImJvdHRvbVwiKSk7XG5cbiAgICAgICAgdmFyIHNsaWRlciA9IHBsb3RzdmcuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInNsaWRlclwiKVxuICAgICAgICAgICAgLmNhbGwoYnJ1c2gpO1xuICAgICAgICB2YXIgc2xpZGVyMiA9IHBsb3RzdmcuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInNsaWRlclwiKVxuICAgICAgICAgICAgLmNhbGwoYnJ1c2gyKTtcblxuICAgICAgICBsZXQgcG9pbnRzID0gaSA9PiBkID0+IHtcbiAgICAgICAgICAgIGxldCB4bm0sIHMgPSA2O1xuICAgICAgICAgICAgaWYgKG5vZGUuc2V0eHZhbHNbaV0gPT0gJycpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBub21pbmFsLCB1c2UgdGhlIG1lZGlhbiBmcmVxdWVuY3kgYXMgdGhlIHBvc2l0aW9uIGZvciB0aGUgc2V0eCBzbGlkZXJcbiAgICAgICAgICAgICAgICB4bm0gPSBub2RlLm5hdHVyZSA9PSAnbm9taW5hbCcgPyB4KE1hdGgucm91bmQoeFZhbHMubGVuZ3RoIC8gMikgLSAxKSA6IHgobm9kZS5tZWFuKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgeG5tID0geChub2RlLnNldHh2YWxzW2ldKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gYCR7eG5tIC0gc30sJHstc30gJHt4bm0gKyBzfSwkey1zfSAke3hubX0sJHtzICogMS4zfWA7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBoYW5kbGUgPSBzbGlkZXIuYXBwZW5kKFwicG9seWdvblwiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImhhbmRsZVwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCxcIiArIGhlaWdodCAqIC43ICsgXCIpXCIpXG4gICAgICAgICAgICAuYXR0cihcInBvaW50c1wiLCBwb2ludHMoMCkpO1xuICAgICAgICB2YXIgaGFuZGxlMiA9IHNsaWRlcjIuYXBwZW5kKFwicG9seWdvblwiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImhhbmRsZVwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCxcIiArIGhlaWdodCAqIC45ICsgXCIpXCIpXG4gICAgICAgICAgICAuYXR0cihcInBvaW50c1wiLCBwb2ludHMoMSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHR3b1NGKHgpIHtcbiAgICAgICAgdmFyIHRzZiA9IGQzLmZvcm1hdChcIi4yclwiKTsgLy8gZm9ybWF0IHRvIHR3byBzaWduaWZpY2FudCBmaWd1cmVzIGFmdGVyIHRoZSBkZWNpbWFsIHBsYWNlXG4gICAgICAgIHJldHVybiB0c2YoeCkucmVwbGFjZSgvMCskLywgXCJcIikucmVwbGFjZSgvXFwuJC8sIFwiXCIpOyAvLyB0cmltIHRyYWlsaW5nIHplcm9zIGFmdGVyIGEgcGVyaW9kLCBhbmQgYW55IG9ycGhhbmVkIHBlcmlvZFxuICAgIH1cblxuICAgIC8vIGJydXNoaW5nIGZ1bmN0aW9uc1xuICAgIGZ1bmN0aW9uIGJydXNoZWQoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGJydXNoLmV4dGVudCgpWzBdO1xuICAgICAgICB2YXIgcyA9IDY7XG5cbiAgICAgICAgaWYgKGQzLmV2ZW50LnNvdXJjZUV2ZW50KSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHguaW52ZXJ0KGQzLm1vdXNlKHRoaXMpWzBdKTtcbiAgICAgICAgICAgIGJydXNoLmV4dGVudChbdmFsdWUsIHZhbHVlXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgeCBwb3NpdGlvbiBvZiBzbGlkZXIgY2VudGVyXG4gICAgICAgIHZhciB4cG9zID0geCh2YWx1ZSk7XG4gICAgICAgIGlmICh2YWx1ZSA+IG1heFgpIHsgLy8gZHJhZ2dlZCBwYXN0IG1heFxuICAgICAgICAgICAgeHBvcyA9IHgobWF4WCk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPCBtaW5YKSB7IC8vIGRyYWdnZWQgcGFzdCBtaW5cbiAgICAgICAgICAgIHhwb3MgPSB4KG1pblgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG0gPSArbm9kZS5tZWFuO1xuICAgICAgICAgICAgdmFyIHNkID0gK25vZGUuc2Q7XG4gICAgICAgICAgICB2YXIgelNjb3JlID0gKHZhbHVlIC0gbSkgLyBzZDsgLy8gei1zY29yZVxuICAgICAgICAgICAgdmFyIHpSb3VuZCA9IE1hdGgucm91bmQoelNjb3JlKTsgLy8gbmVhcmVzdCBpbnRlZ2VyIHotc2NvcmVcbiAgICAgICAgICAgIGlmICguMSA+IE1hdGguYWJzKE1hdGgucm91bmQodmFsdWUpIC0gdmFsdWUpKSB7IC8vIHNuYXAgdG8gaW50ZWdlclxuICAgICAgICAgICAgICAgIHhwb3MgPSB4KE1hdGgucm91bmQodmFsdWUpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoLjEgPiBNYXRoLmFicyh6Um91bmQgLSB6U2NvcmUpKSB7IC8vIHNuYXAgdG8gaW50ZWdlciB6LXNjb3JlXG4gICAgICAgICAgICAgICAgeHBvcyA9IHgobSArICh6Um91bmQgKiBzZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JlYXRlIHNsaWRlciBzeW1ib2wgYW5kIHRleHRcbiAgICAgICAgaGFuZGxlLmF0dHIoXCJwb2ludHNcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgcmV0dXJuICh4cG9zIC0gcykgKyBcIixcIiArICgtcykgKyBcIiBcIiArICh4cG9zICsgcykgKyBcIixcIiArICgtcykgKyBcIiBcIiArIHhwb3MgKyBcIixcIiArIChzICogMS4zKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHBsb3Rzdmcuc2VsZWN0KFwidGV4dCNyYW5nZVwiKVxuICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubmF0dXJlID09PSBcIm5vbWluYWxcIikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbXljZWxsID0gbm9kZS5uYW1lK1wiRnJvbVwiOyAvLyBoYXJkY29kZWQgaGVyZVxuICAgICAgICAgICAgICAgICAgICBpZihkb2N1bWVudC5nZXRFbGVtZW50QnlJZChteWNlbGwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChteWNlbGwpLmlubmVyVGV4dD15VmFsS2V5W01hdGgucm91bmQoaW52eCh4cG9zKSldLng7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcIng6IFwiICsgeVZhbEtleVtNYXRoLnJvdW5kKGludngoeHBvcykpXS54KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbXljZWxsID0gbm9kZS5uYW1lK1wiRnJvbVwiOyAvLyBoYXJkY29kZWQgaGVyZVxuICAgICAgICAgICAgICAgICAgICBpZihkb2N1bWVudC5nZXRFbGVtZW50QnlJZChteWNlbGwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChteWNlbGwpLmlubmVyVGV4dD0rKGludngoeHBvcykpLnRvUHJlY2lzaW9uKDQpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcIng6IFwiLmNvbmNhdCgrKGludngoeHBvcykpLnRvUHJlY2lzaW9uKDQpLnRvU3RyaW5nKCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgbm9kZS5zZXR4dmFsc1swXSA9ICsoaW52eCh4cG9zKSkudG9QcmVjaXNpb24oNCk7XG4gICAgfVxuXG4gICAgLy8gY2VydGFpbmx5IGEgbW9yZSBjbGV2ZXIgd2F5IHRvIGRvIHRoaXMsIGJ1dCBmb3Igbm93IGl0J3MgYmFzaWNhbGx5IGNvcGllZCB3aXRoIGJydXNoIGFuZCBoYW5kbGUgY2hhbmdlcyB0byBicnVzaDIgYW5kIGhhbmRsZTIgYW5kICNyYW5nZSB0byAjcmFuZ2UyIGFuZCBzZXR4dmFsc1swXSB0byBzZXR4dmFsc1sxXVxuICAgIGZ1bmN0aW9uIGJydXNoZWQyKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBicnVzaDIuZXh0ZW50KClbMF07XG4gICAgICAgIHZhciBzID0gNjsgLy8gc2NhbGluZyBmb3IgdHJpYW5nbGUgc2hhcGVcblxuICAgICAgICBpZiAoZDMuZXZlbnQuc291cmNlRXZlbnQpIHtcbiAgICAgICAgICAgIHZhbHVlID0geC5pbnZlcnQoZDMubW91c2UodGhpcylbMF0pO1xuICAgICAgICAgICAgYnJ1c2gyLmV4dGVudChbdmFsdWUsIHZhbHVlXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgeCBwb3NpdGlvbiBvZiBzbGlkZXIgY2VudGVyXG4gICAgICAgIHZhciB4cG9zID0geCh2YWx1ZSk7XG4gICAgICAgIGlmICh2YWx1ZSA+IG1heFgpIHsgLy8gZHJhZ2dlZCBwYXN0IG1heFxuICAgICAgICAgICAgeHBvcyA9IHgobWF4WCk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPCBtaW5YKSB7IC8vIGRyYWdnZWQgcGFzdCBtaW5cbiAgICAgICAgICAgIHhwb3MgPSB4KG1pblgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG0gPSArbm9kZS5tZWFuO1xuICAgICAgICAgICAgdmFyIHNkID0gK25vZGUuc2Q7XG4gICAgICAgICAgICB2YXIgelNjb3JlID0gKHZhbHVlIC0gbSkgLyBzZDsgLy8gei1zY29yZVxuICAgICAgICAgICAgdmFyIHpSb3VuZCA9IE1hdGgucm91bmQoelNjb3JlKTsgLy8gbmVhcmVzdCBpbnRlZ2VyIHotc2NvcmVcbiAgICAgICAgICAgIGlmICguMSA+IE1hdGguYWJzKE1hdGgucm91bmQodmFsdWUpIC0gdmFsdWUpKSB7IC8vIHNuYXAgdG8gaW50ZWdlclxuICAgICAgICAgICAgICAgIHhwb3MgPSB4KE1hdGgucm91bmQodmFsdWUpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoLjEgPiBNYXRoLmFicyh6Um91bmQgLSB6U2NvcmUpKSB7IC8vIHNuYXAgdG8gaW50ZWdlciB6LXNjb3JlXG4gICAgICAgICAgICAgICAgeHBvcyA9IHgobSArICh6Um91bmQgKiBzZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JlYXRlIHNsaWRlciBzeW1ib2wgYW5kIHRleHRcbiAgICAgICAgaGFuZGxlMi5hdHRyKFwicG9pbnRzXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHJldHVybiAoeHBvcyAtIHMpICsgXCIsXCIgKyBzICsgXCIgXCIgKyAoeHBvcyArIHMpICsgXCIsXCIgKyBzICsgXCIgXCIgKyB4cG9zICsgXCIsXCIgKyAoLXMgKiAxLjMpO1xuICAgICAgICB9KTtcbiAgICAgICAgcGxvdHN2Zy5zZWxlY3QoXCJ0ZXh0I3JhbmdlMlwiKVxuICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubmF0dXJlID09PSBcIm5vbWluYWxcIikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbXljZWxsID0gbm9kZS5uYW1lK1wiVG9cIjsgLy8gaGFyZGNvZGVkIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgaWYoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobXljZWxsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobXljZWxsKS5pbm5lclRleHQ9eVZhbEtleVtNYXRoLnJvdW5kKGludngoeHBvcykpXS54O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoXCJ4MTogXCIgKyB5VmFsS2V5W01hdGgucm91bmQoaW52eCh4cG9zKSldLngpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBteWNlbGwgPSBub2RlLm5hbWUrXCJUb1wiOyAvLyBoYXJkY29kZWQgaGVyZVxuICAgICAgICAgICAgICAgICAgICBpZihkb2N1bWVudC5nZXRFbGVtZW50QnlJZChteWNlbGwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChteWNlbGwpLmlubmVyVGV4dD0rKGludngoeHBvcykpLnRvUHJlY2lzaW9uKDQpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcIngxOiBcIi5jb25jYXQoKyhpbnZ4KHhwb3MpKS50b1ByZWNpc2lvbig0KS50b1N0cmluZygpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIG5vZGUuc2V0eHZhbHNbMV0gPSArKGludngoeHBvcykpLnRvUHJlY2lzaW9uKDQpO1xuICAgIH1cbn1cblxuLy8gZHJhd3MgYmFycGxvdHMgaW4gc3Vic2V0IHRhYlxuZXhwb3J0IGZ1bmN0aW9uIGJhcnNTdWJzZXQobm9kZSkge1xuICAgIC8vIGlmIHVudG91Y2hlZCwgc2V0IG5vZGUuc3Vic2V0cmFuZ2UgdG8gYW4gZW1wdHkgYXJyYXksIG1lYW5pbmcgYWxsIHZhbHVlcyBzZWxlY3RlZCBieSBkZWZhdWx0XG4gICAgaWYgKG5vZGUuc3Vic2V0cmFuZ2VbMF0gPT0gXCJcIiAmIG5vZGUuc3Vic2V0cmFuZ2VbMV0gPT0gXCJcIikge1xuICAgICAgICBub2RlLnN1YnNldHJhbmdlID0gW107XG4gICAgfVxuXG4gICAgLy8gSGlzdG9ncmFtIHNwYWNpbmdcbiAgICB2YXIgYmFyUGFkZGluZyA9IC4wMTU7IC8vIFNwYWNlIGJldHdlZW4gYmFyc1xuICAgIHZhciB0b3BTY2FsZSA9IDEuMjsgLy8gTXVsdGlwbGljYXRpdmUgZmFjdG9yIHRvIGFzc2lnbiBzcGFjZSBhdCB0b3Agd2l0aGluIGdyYXBoIC0gY3VycmVudGx5IHJlbW92ZWQgZnJvbSBpbXBsZW1lbnRhdGlvblxuICAgIHZhciBwbG90WGF4aXMgPSB0cnVlO1xuXG4gICAgLy8gVmFyaWFibGUgbmFtZVxuICAgIHZhciBteW5hbWUgPSBub2RlLm5hbWUudG9TdHJpbmcoKTtcbiAgICBteW5hbWUgPSBteW5hbWUucmVwbGFjZSgvXFwofFxcKS9nLCBcIlwiKTtcblxuICAgIC8vIERhdGFcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG5vZGUucGxvdHZhbHVlcyk7XG4gICAgdmFyIHlWYWxzID0gbmV3IEFycmF5O1xuICAgIHZhciB4VmFscyA9IG5ldyBBcnJheTtcbiAgICB2YXIgeVZhbEtleSA9IG5ldyBBcnJheTtcblxuICAgIHZhciB4aSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChub2RlLnBsb3R2YWx1ZXNba2V5c1tpXV0gPT0gMClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB5VmFsc1t4aV0gPSBub2RlLnBsb3R2YWx1ZXNba2V5c1tpXV07XG4gICAgICAgIHhWYWxzW3hpXSA9IHhpO1xuICAgICAgICB5VmFsS2V5LnB1c2goe1xuICAgICAgICAgICAgeTogeVZhbHNbeGldLFxuICAgICAgICAgICAgeDoga2V5c1tpXVxuICAgICAgICB9KTtcbiAgICAgICAgeGkgPSB4aSArIDE7XG4gICAgfVxuICAgIGlmIChub2RlLm5hdHVyZSA9PT0gXCJub21pbmFsXCIpIHsgLy8gaWYgbm9taW5hbCwgb3JkZXJzIGJhcnMgbGVmdCB0byByaWdodCwgaGlnaGVzdCBmcmVxdWVuY3kgdG8gbG93ZXN0XG4gICAgICAgIHlWYWxLZXkuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYi55IC0gYS55XG4gICAgICAgIH0pOyAvLyBhcnJheSBvZiBvYmplY3RzLCBlYWNoIG9iamVjdCBoYXMgeSwgdGhlIHNhbWUgYXMgeVZhbHMsIGFuZCB4LCB0aGUgY2F0ZWdvcnlcbiAgICAgICAgeVZhbHMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYiAtIGFcbiAgICAgICAgfSk7IC8vIGFycmF5IG9mIHkgdmFsdWVzLCB0aGUgaGVpZ2h0IG9mIHRoZSBiYXJzXG4gICAgfVxuXG4gICAgcGxvdFhheGlzID0gZmFsc2U7XG5cbiAgICB2YXIgbWF4WSA9IGQzLm1heCh5VmFscyk7XG4gICAgdmFyIG1pblggPSBkMy5taW4oeFZhbHMpO1xuICAgIHZhciBtYXhYID0gZDMubWF4KHhWYWxzKTtcbiAgICB2YXIgZ25hbWUgPSBbXCJzdWJzZXR5ZXNcIiwgXCJzdWJzZXRub1wiXTtcblxuICAgIHZhciB5VmFsczIgPSBbXTtcbiAgICB2YXIgeVZhbHMxID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IHlWYWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHlWYWxzMS5wdXNoKHtcbiAgICAgICAgICAgIHkwOiBtYXhZIC0geVZhbHNbaV0sXG4gICAgICAgICAgICB5MTogeVZhbHNbaV0sXG4gICAgICAgICAgICBjb2w6IGQzQ29sb3JcbiAgICAgICAgfSk7XG4gICAgICAgIHlWYWxzMi5wdXNoKHtcbiAgICAgICAgICAgIHkwOiAwLFxuICAgICAgICAgICAgeTE6IG1heFkgLSB5VmFsc1tpXSxcbiAgICAgICAgICAgIGNvbDogXCJ0cmFuc3BhcmVudFwiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgZnJlcXMgPSBbeVZhbHMxLCB5VmFsczJdO1xuXG4gICAgLy8geTAgaXMgdGhlIHN0YXJ0aW5nIHBvaW50XG4gICAgLy8geTEgaXMgdGhlIGxlbmd0aCBvZiB0aGUgYmFyXG5cbiAgICB2YXIgbXlkaXYgPSBcIiN0YWIyXCI7XG4gICAgdmFyIHdpZHRoID0gMjAwO1xuICAgIHZhciBoZWlnaHQgPSAxMjA7XG4gICAgdmFyIG1hcmdpbiA9IHtcbiAgICAgICAgdG9wOiAyMCxcbiAgICAgICAgcmlnaHQ6IDIwLFxuICAgICAgICBib3R0b206IDUzLFxuICAgICAgICBsZWZ0OiA1MFxuICAgIH07XG5cbiAgICB2YXIgeCA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgIC5kb21haW4oW21pblggLSAwLjUsIG1heFggKyAwLjVdKVxuICAgICAgICAucmFuZ2UoWzAsIHdpZHRoXSk7XG5cbiAgICB2YXIgaW52eCA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgIC5yYW5nZShbbWluWCAtIDAuNSwgbWF4WCArIDAuNV0pXG4gICAgICAgIC5kb21haW4oWzAsIHdpZHRoXSk7XG5cbiAgICB2YXIgeSA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgIC5kb21haW4oWzAsIG1heFldKVxuICAgICAgICAucmFuZ2UoWzAsIGhlaWdodF0pO1xuXG4gICAgdmFyIHhBeGlzID0gZDMuc3ZnLmF4aXMoKVxuICAgICAgICAuc2NhbGUoeClcbiAgICAgICAgLnRpY2tzKHlWYWxzLmxlbmd0aClcbiAgICAgICAgLm9yaWVudChcImJvdHRvbVwiKTtcblxuICAgIHZhciB5QXhpcyA9IGQzLnN2Zy5heGlzKClcbiAgICAgICAgLnNjYWxlKHkpXG4gICAgICAgIC5vcmllbnQoXCJsZWZ0XCIpO1xuXG4gICAgLy9DcmVhdGUgU1ZHIGVsZW1lbnRcbiAgICB2YXIgcGxvdHN2ZyA9IGQzLnNlbGVjdChteWRpdilcbiAgICAgICAgLmFwcGVuZChcInN2Z1wiKVxuICAgICAgICAuYXR0cihcImlkXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG15bmFtZS5jb25jYXQoXCJfXCIsIG15ZGl2LnN1YnN0cigxKSwgXCJfXCIsIG5vZGUuaWQpO1xuICAgICAgICB9KVxuICAgICAgICAuc3R5bGUoXCJ3aWR0aFwiLCB3aWR0aCArIG1hcmdpbi5sZWZ0ICsgbWFyZ2luLnJpZ2h0KSAvL3NldHRpbmcgaGVpZ2h0IHRvIHRoZSBoZWlnaHQgb2YgI21haW4ubGVmdFxuICAgICAgICAuc3R5bGUoXCJoZWlnaHRcIiwgaGVpZ2h0ICsgbWFyZ2luLnRvcCArIG1hcmdpbi5ib3R0b20pXG4gICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgbWFyZ2luLmxlZnQgKyBcIixcIiArIG1hcmdpbi50b3AgKyBcIilcIik7XG5cbiAgICB2YXIgZnJlcSA9IHBsb3Rzdmcuc2VsZWN0QWxsKFwiZy5mcmVxXCIpXG4gICAgICAgIC5kYXRhKGZyZXFzKVxuICAgICAgICAuZW50ZXIoKS5hcHBlbmQoXCJnXCIpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJmcmVxXCIpXG4gICAgICAgIC5hdHRyKFwibmFtZVwiLCBmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4gbXluYW1lLmNvbmNhdChnbmFtZVtpXSk7XG4gICAgICAgIH0pO1xuXG4gICAgdmFyIHJlY3QgPSBmcmVxLnNlbGVjdEFsbChcInJlY3RcIilcbiAgICAgICAgLmRhdGEoT2JqZWN0KVxuICAgICAgICAuZW50ZXIoKS5hcHBlbmQoXCJyZWN0XCIpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJiYXJcIilcbiAgICAgICAgLmF0dHIoXCJuYW1lXCIsIGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiB4VmFsc1tpXTtcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoXCJ4XCIsIGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiB4KHhWYWxzW2ldIC0gMC41ICsgYmFyUGFkZGluZyk7XG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKFwieVwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICByZXR1cm4geShkLnkwKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCB4KG1pblggKyAwLjUgLSAyICogYmFyUGFkZGluZykpIC8vIHRoZSBcIndpZHRoXCIgaXMgdGhlIGNvb3JkaW5hdGUgb2YgdGhlIGVuZCBvZiB0aGUgZmlyc3QgYmFyXG4gICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHJldHVybiB5KGQueTEpO1xuICAgICAgICB9KVxuICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgIGlmIChub2RlLnN1YnNldHJhbmdlLmxlbmd0aCA+IDAgJiBkLmNvbCA9PT0gZDNDb2xvciAmICQuaW5BcnJheSh4VmFsc1tpXS50b1N0cmluZygpLCBub2RlLnN1YnNldHJhbmdlKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbFZhckNvbG9yO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZC5jb2w7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdE1lID0gdGhpcztcbiAgICAgICAgICAgIHZhciBzZWxlY3ROYW1lID0gdGhpcy5nZXRBdHRyaWJ1dGUoXCJuYW1lXCIpO1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50Tm9kZS5nZXRBdHRyaWJ1dGUoXCJuYW1lXCIpID09IG15bmFtZS5jb25jYXQoXCJzdWJzZXRub1wiKSkge1xuICAgICAgICAgICAgICAgIHNlbGVjdE1lID0gJCgnW25hbWU9XCInICsgbXluYW1lLmNvbmNhdChcInN1YnNldHllc1wiKSArICdcIl0nKS5jaGlsZHJlbignW25hbWU9XCInICsgc2VsZWN0TmFtZSArICdcIl0nKVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGQzLnNlbGVjdChzZWxlY3RNZSlcbiAgICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG15Q29sID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc3R5bGUuZmlsbCA9PT0gc2VsVmFyQ29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBteWluZGV4ID0gbm9kZS5zdWJzZXRyYW5nZS5pbmRleE9mKHRoaXMuZ2V0QXR0cmlidXRlKFwibmFtZVwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnN1YnNldHJhbmdlLnNwbGljZShteWluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG15Q29sID0gZDNDb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc3Vic2V0cmFuZ2UucHVzaCh0aGlzLmdldEF0dHJpYnV0ZShcIm5hbWVcIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbXlDb2wgPSBzZWxWYXJDb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbXlDb2w7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwbG90c3ZnLnNlbGVjdChcInRleHQjc2VsZWN0cmFuZ2VcIilcbiAgICAgICAgICAgICAgICAudGV4dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuc3Vic2V0cmFuZ2UubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoXCJTZWxlY3RlZDogYWxsIHZhbHVlc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gbm9kZS5zdWJzZXRyYW5nZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZWxlY3RlZHMgPSBuZXcgQXJyYXk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhLmZvckVhY2goZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRzLnB1c2goeVZhbEtleVt2YWxdLngpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoXCJTZWxlY3RlZDogXCIgKyBzZWxlY3RlZHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSlcbiAgICAgICAgLm9uKFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGkgPSB0aGlzLmdldEF0dHJpYnV0ZShcIm5hbWVcIik7XG4gICAgICAgICAgICBwbG90c3ZnLnNlbGVjdChcInRleHQjbXltb3VzZW92ZXJcIilcbiAgICAgICAgICAgICAgICAudGV4dCgoKSA9PiB5VmFsS2V5W2ldLnggKyBcIjogXCIgKyB5VmFsS2V5W2ldLnkpO1xuICAgICAgICB9KVxuICAgICAgICAub24oXCJtb3VzZW91dFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpID0gdGhpcy5nZXRBdHRyaWJ1dGUoXCJuYW1lXCIpO1xuICAgICAgICAgICAgcGxvdHN2Zy5zZWxlY3QoXCJ0ZXh0I215bW91c2VvdmVyXCIpXG4gICAgICAgICAgICAgICAgLnRleHQoKCkgPT4gXCJWYWx1ZTogRnJlcXVlbmN5XCIpO1xuICAgICAgICB9KTtcblxuICAgIGlmIChwbG90WGF4aXMpIHtcbiAgICAgICAgcGxvdHN2Zy5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwieCBheGlzXCIpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLFwiICsgaGVpZ2h0ICsgXCIpXCIpXG4gICAgICAgICAgICAuY2FsbCh4QXhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcGxvdHN2Zy5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsIFwibXltb3VzZW92ZXJcIilcbiAgICAgICAgICAgIC5hdHRyKFwieFwiLCAyNSlcbiAgICAgICAgICAgIC5hdHRyKFwieVwiLCBoZWlnaHQgKyAyMClcbiAgICAgICAgICAgIC50ZXh0KCgpID0+IFwiVmFsdWU6IEZyZXF1ZW5jeVwiKTtcbiAgICB9XG5cbiAgICBwbG90c3ZnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgLmF0dHIoXCJ4XCIsICh3aWR0aCAvIDIpKVxuICAgICAgICAuYXR0cihcInlcIiwgMCAtIChtYXJnaW4udG9wIC8gMikpXG4gICAgICAgIC5hdHRyKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIilcbiAgICAgICAgLnN0eWxlKFwiZm9udC1zaXplXCIsIFwiMTJweFwiKVxuICAgICAgICAudGV4dChteW5hbWUpO1xuXG4gICAgcGxvdHN2Zy5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgIC5hdHRyKFwiaWRcIiwgXCJzZWxlY3RyYW5nZVwiKVxuICAgICAgICAuYXR0cihcInhcIiwgMjUpXG4gICAgICAgIC5hdHRyKFwieVwiLCBoZWlnaHQgKyA0MClcbiAgICAgICAgLnRleHQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKG5vZGUuc3Vic2V0cmFuZ2UubGVuZ3RoID09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiU2VsZWN0ZWQ6IGFsbCB2YWx1ZXNcIjtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZHMgPSBuZXcgQXJyYXk7XG4gICAgICAgICAgICBub2RlLnN1YnNldHJhbmdlLmZvckVhY2godmFsID0+ICBzZWxlY3RlZHMucHVzaCh5VmFsS2V5W3ZhbF0ueCkpO1xuICAgICAgICAgICAgcmV0dXJuIFwiU2VsZWN0ZWQ6IFwiICsgc2VsZWN0ZWRzO1xuICAgICAgICB9KTtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gZGVuc2l0eU5vZGUobm9kZSwgb2JqKSB7XG4gICAgdmFyIG15bmFtZSA9IG5vZGUubmFtZS50b1N0cmluZygpLmNvbmNhdChcIm5vZGVwbG90XCIpO1xuXG4gICAgaWYgKHR5cGVvZiBvYmogPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdmFyIG9iaiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG5vZGUubmFtZS50b1N0cmluZygpICsgXCJiaWdncm91cFwiKTtcbiAgICAgICAgLy8gaWYgb2JqIGNvbnRhaW5zIGFuIHN2ZyBlbGVtZW50LCByZW1vdmUgaXQuIHRoaXMgcmVtb3ZlcyBhbnkgcGxvdCBpbnNpZGUgdGhlIG5vZGVcbiAgICAgICAgaWYgKGQzLnNlbGVjdChvYmopLnNlbGVjdEFsbChcInN2Z1wiKVswXS5sZW5ndGggPiAwKVxuICAgICAgICAgICAgZDMuc2VsZWN0KG9iaikuc2VsZWN0QWxsKFwic3ZnXCIpLnJlbW92ZSgpO1xuICAgIH1cblxuICAgIHZhciB5VmFscyA9IG5vZGUucGxvdHk7XG4gICAgdmFyIHhWYWxzID0gbm9kZS5wbG90eDtcbiAgICAvLyBhcnJheSBvZiBvYmplY3RzXG4gICAgbGV0IGRhdGEyID0gbm9kZS5wbG90eC5tYXAoKHgsIGkpID0+ICh7eDogK3gsIHk6ICtub2RlLnBsb3R5W2ldfSkpO1xuXG4gICAgdmFyIHdpZHRoID0gNjA7IC8vIGhhcmRjb2RlZCwgc2hvdWxkIGJlIHNldCBhdXRvbWF0aWNhbGx5XG4gICAgdmFyIGhlaWdodCA9IDMwO1xuICAgIHZhciBtYXJnaW4gPSB7XG4gICAgICAgIHRvcDogMjAsXG4gICAgICAgIHJpZ2h0OiAxMCxcbiAgICAgICAgYm90dG9tOiA1MyxcbiAgICAgICAgbGVmdDogMTBcbiAgICB9O1xuXG4gICAgdmFyIHggPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAuZG9tYWluKFtkMy5taW4oeFZhbHMpLCBkMy5tYXgoeFZhbHMpXSlcbiAgICAgICAgLnJhbmdlKFswLCB3aWR0aF0pO1xuXG4gICAgdmFyIHkgPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAuZG9tYWluKFtkMy5taW4oeVZhbHMpLCBkMy5tYXgoeVZhbHMpXSlcbiAgICAgICAgLnJhbmdlKFtoZWlnaHQsIDBdKTtcblxuICAgIHZhciBhcmVhID0gZDMuc3ZnLmFyZWEoKVxuICAgICAgICAuaW50ZXJwb2xhdGUoXCJtb25vdG9uZVwiKVxuICAgICAgICAueChkID0+IHgoZC54KSlcbiAgICAgICAgLnkwKGhlaWdodClcbiAgICAgICAgLnkxKGQgPT4geShkLnkpKTtcblxuICAgIHZhciBwbG90c3ZnID0gZDMuc2VsZWN0KG9iailcbiAgICAgICAgLmluc2VydChcInN2Z1wiLCBcIjpmaXJzdC1jaGlsZFwiKVxuICAgICAgICAuYXR0cihcInhcIiwgLTQwKSAvLyBOT1RFOiBOb3Qgc3VyZSBleGFjdGx5IHdoeSB0aGVzZSBudW1iZXJzIHdvcmssIGJ1dCB0aGVzZSBoYXJkY29kZWQgdmFsdWVzIHNlZW0gdG8gcG9zaXRpb24gdGhlIHBsb3QgaW5zaWRlIGcgY29ycmVjdGx5LiAgdGhpcyBzaG91bGRuJ3QgYmUgaGFyZGNvZGVkIGluIHRoZSBmdXR1cmVcbiAgICAgICAgLmF0dHIoXCJ5XCIsIC00NSlcbiAgICAgICAgLmF0dHIoXCJpZFwiLCAoKSA9PiBteW5hbWUpXG4gICAgICAgIC5zdHlsZShcIndpZHRoXCIsIHdpZHRoKVxuICAgICAgICAuc3R5bGUoXCJoZWlnaHRcIiwgaGVpZ2h0KVxuICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIG1hcmdpbi5sZWZ0ICsgXCIsXCIgKyBtYXJnaW4udG9wICsgXCIpXCIpO1xuXG4gICAgcGxvdHN2Zy5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgIC5kYXR1bShkYXRhMilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImFyZWFcIilcbiAgICAgICAgLmF0dHIoXCJkXCIsIGFyZWEpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYmFyc05vZGUobm9kZSwgb2JqKSB7XG4gICAgdmFyIG15bmFtZSA9IG5vZGUubmFtZS50b1N0cmluZygpLmNvbmNhdChcIm5vZGVwbG90XCIpO1xuXG4gICAgaWYgKHR5cGVvZiBvYmogPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdmFyIG9iaiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG5vZGUubmFtZS50b1N0cmluZygpICsgXCJiaWdncm91cFwiKTtcbiAgICAgICAgLy8gaWYgb2JqIGNvbnRhaW5zIGFuIHN2ZyBlbGVtZW50LCByZW1vdmUgaXQuIHRoaXMgcmVtb3ZlcyBhbnkgcGxvdCBpbnNpZGUgdGhlIG5vZGVcbiAgICAgICAgaWYgKGQzLnNlbGVjdChvYmopLnNlbGVjdEFsbChcInN2Z1wiKVswXS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBkMy5zZWxlY3Qob2JqKS5zZWxlY3RBbGwoXCJzdmdcIikucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBIaXN0b2dyYW0gc3BhY2luZ1xuICAgIHZhciBiYXJQYWRkaW5nID0gLjAxNTsgLy8gU3BhY2UgYmV0d2VlbiBiYXJzXG4gICAgdmFyIHRvcFNjYWxlID0gMS4yOyAvLyBNdWx0aXBsaWNhdGl2ZSBmYWN0b3IgdG8gYXNzaWduIHNwYWNlIGF0IHRvcCB3aXRoaW4gZ3JhcGggLSBjdXJyZW50bHkgcmVtb3ZlZCBmcm9tIGltcGxlbWVudGF0aW9uXG5cbiAgICAvLyBEYXRhXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhub2RlLnBsb3R2YWx1ZXMpO1xuICAgIHZhciB5VmFscyA9IG5ldyBBcnJheTtcbiAgICB2YXIgeFZhbHMgPSBuZXcgQXJyYXk7XG4gICAgdmFyIHlWYWxLZXkgPSBuZXcgQXJyYXk7XG5cbiAgICBpZiAobm9kZS5uYXR1cmUgPT09IFwibm9taW5hbFwiKSB7XG4gICAgICAgIHZhciB4aSA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKG5vZGUucGxvdHZhbHVlc1trZXlzW2ldXSA9PSAwKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgeVZhbHNbeGldID0gbm9kZS5wbG90dmFsdWVzW2tleXNbaV1dO1xuICAgICAgICAgICAgeFZhbHNbeGldID0geGk7XG4gICAgICAgICAgICB5VmFsS2V5LnB1c2goe3k6IHlWYWxzW3hpXSwgeDoga2V5c1tpXX0pO1xuICAgICAgICAgICAgeGkgPSB4aSArIDE7XG4gICAgICAgIH1cbiAgICAgICAgeVZhbEtleS5zb3J0KChhLCBiKSA9PiBiLnkgLSBhLnkpOyAvLyBhcnJheSBvZiBvYmplY3RzLCBlYWNoIG9iamVjdCBoYXMgeSwgdGhlIHNhbWUgYXMgeVZhbHMsIGFuZCB4LCB0aGUgY2F0ZWdvcnlcbiAgICAgICAgeVZhbHMuc29ydCgoYSwgYikgPT4gYiAtIGEpOyAvLyBhcnJheSBvZiB5IHZhbHVlcywgdGhlIGhlaWdodCBvZiB0aGUgYmFyc1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgeVZhbHNbaV0gPSBub2RlLnBsb3R2YWx1ZXNba2V5c1tpXV07XG4gICAgICAgICAgICB4VmFsc1tpXSA9IE51bWJlcihrZXlzW2ldKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBtYXhZID0gZDMubWF4KHlWYWxzKTtcbiAgICB2YXIgbWluWCA9IGQzLm1pbih4VmFscyk7XG4gICAgdmFyIG1heFggPSBkMy5tYXgoeFZhbHMpO1xuXG4gICAgdmFyIHdpZHRoID0gNjA7XG4gICAgdmFyIGhlaWdodCA9IDMwO1xuICAgIHZhciBtYXJnaW4gPSB7XG4gICAgICAgIHRvcDogMjAsXG4gICAgICAgIHJpZ2h0OiAxMCxcbiAgICAgICAgYm90dG9tOiA1MyxcbiAgICAgICAgbGVmdDogMTBcbiAgICB9O1xuXG4gICAgdmFyIHggPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAuZG9tYWluKFttaW5YIC0gMC41LCBtYXhYICsgMC41XSlcbiAgICAgICAgLnJhbmdlKFswLCB3aWR0aF0pO1xuXG4gICAgdmFyIGludnggPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAucmFuZ2UoW21pblggLSAwLjUsIG1heFggKyAwLjVdKVxuICAgICAgICAuZG9tYWluKFswLCB3aWR0aF0pO1xuXG4gICAgdmFyIHkgPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAuZG9tYWluKFswLCBtYXhZXSlcbiAgICAgICAgLnJhbmdlKFswLCBoZWlnaHRdKTtcblxuICAgIC8vQ3JlYXRlIFNWRyBlbGVtZW50XG4gICAgdmFyIHBsb3RzdmcgPSBkMy5zZWxlY3Qob2JqKVxuICAgICAgICAuaW5zZXJ0KFwic3ZnXCIsIFwiOmZpcnN0LWNoaWxkXCIpXG4gICAgICAgIC5hdHRyKFwieFwiLCAtNDApXG4gICAgICAgIC5hdHRyKFwieVwiLCAtNDUpXG4gICAgICAgIC5hdHRyKFwiaWRcIiwgKCkgPT4gbXluYW1lKVxuICAgICAgICAuc3R5bGUoXCJ3aWR0aFwiLCB3aWR0aCkgLy8gc2V0IGhlaWdodCB0byB0aGUgaGVpZ2h0IG9mICNtYWluLmxlZnRcbiAgICAgICAgLnN0eWxlKFwiaGVpZ2h0XCIsIGhlaWdodClcbiAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBtYXJnaW4ubGVmdCArIFwiLFwiICsgbWFyZ2luLnRvcCArIFwiKVwiKTtcblxuICAgIHBsb3Rzdmcuc2VsZWN0QWxsKFwicmVjdFwiKVxuICAgICAgICAuZGF0YSh5VmFscylcbiAgICAgICAgLmVudGVyKClcbiAgICAgICAgLmFwcGVuZChcInJlY3RcIilcbiAgICAgICAgLmF0dHIoXCJ4XCIsIChkLCBpKSA9PiAgeCh4VmFsc1tpXSAtIDAuNSArIGJhclBhZGRpbmcpKVxuICAgICAgICAuYXR0cihcInlcIiwgZCA9PiAgeShtYXhZIC0gZCkpXG4gICAgICAgIC5hdHRyKFwid2lkdGhcIiwgeChtaW5YICsgMC41IC0gMiAqIGJhclBhZGRpbmcpKSAvLyB0aGUgXCJ3aWR0aFwiIGlzIHRoZSBjb29yZGluYXRlIG9mIHRoZSBlbmQgb2YgdGhlIGZpcnN0IGJhclxuICAgICAgICAuYXR0cihcImhlaWdodFwiLCB5KVxuICAgICAgICAuYXR0cihcImZpbGxcIiwgXCIjMWY3N2I0XCIpO1xufVxuXG5cblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYXNzZXRzL2FwcC9wbG90cy5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2\n')},function(module,exports){eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvcGtncy9ob3BzY290Y2gvZGlzdC9jc3MvaG9wc2NvdGNoLmNzcz9mYzE2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYXNzZXRzL3BrZ3MvaG9wc2NvdGNoL2Rpc3QvY3NzL2hvcHNjb3RjaC5jc3Ncbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3\n")},function(module,exports){eval('var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function("return this")() || (1,eval)("this");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === "object")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it\'s\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzPzM2OTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUMiLCJmaWxlIjoiNC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBnO1xyXG5cclxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcclxuZyA9IChmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufSkoKTtcclxuXHJcbnRyeSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXHJcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLGV2YWwpKFwidGhpc1wiKTtcclxufSBjYXRjaChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZih0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKVxyXG5cdFx0ZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4\n')},function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.getClasses = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mithril = __webpack_require__(0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _app = __webpack_require__(1);\n\nvar app = _interopRequireWildcard(_app);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar getClasses = exports.getClasses = function getClasses(cls, panel) {\n    return cls + (panel.closed ? '.closepanel' : panel.side === 'left' && app.lefttab === 'tab2' ? '.expandpanel' : '');\n};\n\nvar Panel = function () {\n    function Panel() {\n        _classCallCheck(this, Panel);\n    }\n\n    _createClass(Panel, [{\n        key: 'oninit',\n        value: function oninit(vnode) {\n            this.closed = false;\n        }\n    }, {\n        key: 'view',\n        value: function view(vnode) {\n            var _this = this;\n\n            var _vnode$attrs = vnode.attrs,\n                side = _vnode$attrs.side,\n                title = _vnode$attrs.title;\n\n            var dot = [_mithril2.default.trust('&#9679;'), (0, _mithril2.default)('br')];\n            return (0, _mithril2.default)(getClasses('#' + side + 'panel.sidepanel.container.clearfix', this), (0, _mithril2.default)('#toggle' + (side === 'left' ? 'L' : 'R') + 'panelicon.panelbar[style=height: 100%]', (0, _mithril2.default)('span', { onclick: function onclick(_) {\n                    return _this.closed = !_this.closed;\n                } }, dot, dot, dot, dot)), (0, _mithril2.default)('#' + side + 'paneltitle.panel-heading.text-center', (0, _mithril2.default)(\"h3.panel-title\", title)), vnode.children[0], (0, _mithril2.default)(getClasses('.row-fluid', this), (0, _mithril2.default)('#' + side + 'panelcontent', (0, _mithril2.default)('#' + side + 'ContentArea[style=height: calc(100vh - 210px); overflow: auto]', vnode.children.slice(1)))));\n        }\n    }]);\n\n    return Panel;\n}();\n\nexports.default = Panel;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvYXBwL3ZpZXdzL1BhbmVsLmpzPzkyNGYiXSwibmFtZXMiOlsiYXBwIiwiZ2V0Q2xhc3NlcyIsImNscyIsInBhbmVsIiwiY2xvc2VkIiwic2lkZSIsImxlZnR0YWIiLCJQYW5lbCIsInZub2RlIiwiYXR0cnMiLCJ0aXRsZSIsImRvdCIsInRydXN0Iiwib25jbGljayIsImNoaWxkcmVuIiwic2xpY2UiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOzs7O0FBRUE7O0lBQVlBLEc7Ozs7Ozs7O0FBRUwsSUFBSUMsa0NBQWEsU0FBYkEsVUFBYSxDQUFTQyxHQUFULEVBQWNDLEtBQWQsRUFBcUI7QUFDekMsV0FBT0QsT0FBT0MsTUFBTUMsTUFBTixHQUFlLGFBQWYsR0FDVEQsTUFBTUUsSUFBTixLQUFlLE1BQWYsSUFBeUJMLElBQUlNLE9BQUosS0FBZ0IsTUFBMUMsR0FBb0QsY0FBcEQsR0FDQSxFQUZHLENBQVA7QUFHSCxDQUpNOztJQU1EQyxLOzs7Ozs7OytCQUNLQyxLLEVBQU87QUFDVixpQkFBS0osTUFBTCxHQUFjLEtBQWQ7QUFDSDs7OzZCQUVJSSxLLEVBQU87QUFBQTs7QUFBQSwrQkFDWUEsTUFBTUMsS0FEbEI7QUFBQSxnQkFDSEosSUFERyxnQkFDSEEsSUFERztBQUFBLGdCQUNHSyxLQURILGdCQUNHQSxLQURIOztBQUVSLGdCQUFNQyxNQUFNLENBQUMsa0JBQUVDLEtBQUYsQ0FBUSxTQUFSLENBQUQsRUFBcUIsdUJBQUUsSUFBRixDQUFyQixDQUFaO0FBQ0EsbUJBQU8sdUJBQUVYLGlCQUFlSSxJQUFmLHlDQUF5RCxJQUF6RCxDQUFGLEVBQ0gsb0NBQVlBLFNBQVMsTUFBVCxHQUFrQixHQUFsQixHQUF3QixHQUFwQyw4Q0FDRSx1QkFBRSxNQUFGLEVBQVUsRUFBQ1EsU0FBUztBQUFBLDJCQUFLLE1BQUtULE1BQUwsR0FBYyxDQUFDLE1BQUtBLE1BQXpCO0FBQUEsaUJBQVYsRUFBVixFQUFzRE8sR0FBdEQsRUFBMkRBLEdBQTNELEVBQWdFQSxHQUFoRSxFQUFxRUEsR0FBckUsQ0FERixDQURHLEVBR0gsNkJBQU1OLElBQU4sMkNBQ0UsdUJBQUUsZ0JBQUYsRUFBb0JLLEtBQXBCLENBREYsQ0FIRyxFQUtIRixNQUFNTSxRQUFOLENBQWUsQ0FBZixDQUxHLEVBTUgsdUJBQUViLFdBQVcsWUFBWCxFQUF5QixJQUF6QixDQUFGLEVBQ0UsNkJBQU1JLElBQU4sbUJBQ0UsNkJBQU1BLElBQU4scUVBQTRFRyxNQUFNTSxRQUFOLENBQWVDLEtBQWYsQ0FBcUIsQ0FBckIsQ0FBNUUsQ0FERixDQURGLENBTkcsQ0FBUDtBQVNIOzs7Ozs7a0JBR1VSLEsiLCJmaWxlIjoiNS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuXG5pbXBvcnQgKiBhcyBhcHAgZnJvbSAnLi4vYXBwJztcblxuZXhwb3J0IGxldCBnZXRDbGFzc2VzID0gZnVuY3Rpb24oY2xzLCBwYW5lbCkge1xuICAgIHJldHVybiBjbHMgKyAocGFuZWwuY2xvc2VkID8gJy5jbG9zZXBhbmVsJyA6IFxuICAgICAgICAocGFuZWwuc2lkZSA9PT0gJ2xlZnQnICYmIGFwcC5sZWZ0dGFiID09PSAndGFiMicpID8gJy5leHBhbmRwYW5lbCcgOiBcbiAgICAgICAgJycpO1xufTtcblxuY2xhc3MgUGFuZWwge1xuICAgIG9uaW5pdCh2bm9kZSkge1xuICAgICAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZpZXcodm5vZGUpIHtcbiAgICAgICAgbGV0IHtzaWRlLCB0aXRsZX0gPSB2bm9kZS5hdHRycztcbiAgICAgICAgY29uc3QgZG90ID0gW20udHJ1c3QoJyYjOTY3OTsnKSwgbSgnYnInKV07IFxuICAgICAgICByZXR1cm4gbShnZXRDbGFzc2VzKGAjJHtzaWRlfXBhbmVsLnNpZGVwYW5lbC5jb250YWluZXIuY2xlYXJmaXhgLCB0aGlzKSxcbiAgICAgICAgICAgIG0oYCN0b2dnbGUke3NpZGUgPT09ICdsZWZ0JyA/ICdMJyA6ICdSJ31wYW5lbGljb24ucGFuZWxiYXJbc3R5bGU9aGVpZ2h0OiAxMDAlXWAsXG4gICAgICAgICAgICAgIG0oJ3NwYW4nLCB7b25jbGljazogXyA9PiB0aGlzLmNsb3NlZCA9ICF0aGlzLmNsb3NlZH0sIGRvdCwgZG90LCBkb3QsIGRvdCkpLFxuICAgICAgICAgICAgbShgIyR7c2lkZX1wYW5lbHRpdGxlLnBhbmVsLWhlYWRpbmcudGV4dC1jZW50ZXJgLFxuICAgICAgICAgICAgICBtKFwiaDMucGFuZWwtdGl0bGVcIiwgdGl0bGUpKSxcbiAgICAgICAgICAgIHZub2RlLmNoaWxkcmVuWzBdLFxuICAgICAgICAgICAgbShnZXRDbGFzc2VzKCcucm93LWZsdWlkJywgdGhpcyksIFxuICAgICAgICAgICAgICBtKGAjJHtzaWRlfXBhbmVsY29udGVudGAsXG4gICAgICAgICAgICAgICAgbShgIyR7c2lkZX1Db250ZW50QXJlYVtzdHlsZT1oZWlnaHQ6IGNhbGMoMTAwdmggLSAyMTBweCk7IG92ZXJmbG93OiBhdXRvXWAsIHZub2RlLmNoaWxkcmVuLnNsaWNlKDEpKSkpKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBhbmVsO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYXNzZXRzL2FwcC92aWV3cy9QYW5lbC5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.or = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mithril = __webpack_require__(0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _app = __webpack_require__(1);\n\nvar app = _interopRequireWildcard(_app);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar or = exports.or = function or(side, val) {\n    var y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'block';\n    var n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'none';\n\n    return app[side + 'tab'] === val ? y : n;\n};\n\nvar PanelButton = function () {\n    function PanelButton() {\n        _classCallCheck(this, PanelButton);\n    }\n\n    _createClass(PanelButton, [{\n        key: 'view',\n        value: function view(vnode) {\n            var _vnode$attrs = vnode.attrs,\n                id = _vnode$attrs.id,\n                id2 = _vnode$attrs.id2,\n                classes = _vnode$attrs.classes,\n                onclick = _vnode$attrs.onclick,\n                style = _vnode$attrs.style,\n                title = _vnode$attrs.title;\n\n            var left = id2 ? true : false;\n            id2 = id2 || id;\n            return (0, _mithril2.default)('button#' + id + '.btn.' + (classes || or(left ? 'left' : 'right', id2, 'active', 'btn-default')) + '[type=button]', {\n                onclick: onclick || function (_) {\n                    return left ? app.tabLeft(id2) : app.tabRight(id2);\n                },\n                style: style,\n                title: title }, vnode.children);\n        }\n    }]);\n\n    return PanelButton;\n}();\n\nexports.default = PanelButton;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvYXBwL3ZpZXdzL1BhbmVsQnV0dG9uLmpzP2M4NTciXSwibmFtZXMiOlsiYXBwIiwib3IiLCJzaWRlIiwidmFsIiwieSIsIm4iLCJQYW5lbEJ1dHRvbiIsInZub2RlIiwiYXR0cnMiLCJpZCIsImlkMiIsImNsYXNzZXMiLCJvbmNsaWNrIiwic3R5bGUiLCJ0aXRsZSIsImxlZnQiLCJ0YWJMZWZ0IiwidGFiUmlnaHQiLCJjaGlsZHJlbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7Ozs7QUFFQTs7SUFBWUEsRzs7Ozs7Ozs7QUFFTCxJQUFJQyxrQkFBSyxTQUFMQSxFQUFLLENBQVNDLElBQVQsRUFBZUMsR0FBZixFQUF5QztBQUFBLFFBQXJCQyxDQUFxQix1RUFBbkIsT0FBbUI7QUFBQSxRQUFWQyxDQUFVLHVFQUFSLE1BQVE7O0FBQ3JELFdBQU9MLElBQUlFLE9BQU8sS0FBWCxNQUFzQkMsR0FBdEIsR0FBNEJDLENBQTVCLEdBQWdDQyxDQUF2QztBQUNILENBRk07O0lBSURDLFc7Ozs7Ozs7NkJBQ0dDLEssRUFBTztBQUFBLCtCQUN3Q0EsTUFBTUMsS0FEOUM7QUFBQSxnQkFDSEMsRUFERyxnQkFDSEEsRUFERztBQUFBLGdCQUNDQyxHQURELGdCQUNDQSxHQUREO0FBQUEsZ0JBQ01DLE9BRE4sZ0JBQ01BLE9BRE47QUFBQSxnQkFDZUMsT0FEZixnQkFDZUEsT0FEZjtBQUFBLGdCQUN3QkMsS0FEeEIsZ0JBQ3dCQSxLQUR4QjtBQUFBLGdCQUMrQkMsS0FEL0IsZ0JBQytCQSxLQUQvQjs7QUFFUixnQkFBSUMsT0FBT0wsTUFBTSxJQUFOLEdBQWEsS0FBeEI7QUFDQUEsa0JBQU1BLE9BQU9ELEVBQWI7QUFDQSxtQkFBTyxtQ0FBWUEsRUFBWixjQUFzQkUsV0FBV1YsR0FBR2MsT0FBTyxNQUFQLEdBQWdCLE9BQW5CLEVBQTRCTCxHQUE1QixFQUFpQyxRQUFqQyxFQUEyQyxhQUEzQyxDQUFqQyxxQkFBMkc7QUFDOUdFLHlCQUFTQSxXQUFZO0FBQUEsMkJBQUtHLE9BQU9mLElBQUlnQixPQUFKLENBQVlOLEdBQVosQ0FBUCxHQUEwQlYsSUFBSWlCLFFBQUosQ0FBYVAsR0FBYixDQUEvQjtBQUFBLGlCQUR5RjtBQUU5R0csdUJBQU9BLEtBRnVHO0FBRzlHQyx1QkFBT0EsS0FIdUcsRUFBM0csRUFJSFAsTUFBTVcsUUFKSCxDQUFQO0FBS0g7Ozs7OztrQkFHVVosVyIsImZpbGUiOiI2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCc7XG5cbmltcG9ydCAqIGFzIGFwcCBmcm9tICcuLi9hcHAnO1xuXG5leHBvcnQgbGV0IG9yID0gZnVuY3Rpb24oc2lkZSwgdmFsLCB5PSdibG9jaycsIG49J25vbmUnKSB7XG4gICAgcmV0dXJuIGFwcFtzaWRlICsgJ3RhYiddID09PSB2YWwgPyB5IDogbjtcbn07XG5cbmNsYXNzIFBhbmVsQnV0dG9uIHtcbiAgICB2aWV3KHZub2RlKSB7XG4gICAgICAgIGxldCB7aWQsIGlkMiwgY2xhc3Nlcywgb25jbGljaywgc3R5bGUsIHRpdGxlfSA9IHZub2RlLmF0dHJzO1xuICAgICAgICBsZXQgbGVmdCA9IGlkMiA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgaWQyID0gaWQyIHx8IGlkO1xuICAgICAgICByZXR1cm4gbShgYnV0dG9uIyR7aWR9LmJ0bi4ke2NsYXNzZXMgfHwgb3IobGVmdCA/ICdsZWZ0JyA6ICdyaWdodCcsIGlkMiwgJ2FjdGl2ZScsICdidG4tZGVmYXVsdCcpfVt0eXBlPWJ1dHRvbl1gLCB7XG4gICAgICAgICAgICBvbmNsaWNrOiBvbmNsaWNrIHx8IChfID0+IGxlZnQgPyBhcHAudGFiTGVmdChpZDIpIDogYXBwLnRhYlJpZ2h0KGlkMikpLFxuICAgICAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICAgICAgdGl0bGU6IHRpdGxlfSxcbiAgICAgICAgICAgIHZub2RlLmNoaWxkcmVuKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBhbmVsQnV0dG9uO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYXNzZXRzL2FwcC92aWV3cy9QYW5lbEJ1dHRvbi5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.searchIndex = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mithril = __webpack_require__(0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _app = __webpack_require__(1);\n\nvar app = _interopRequireWildcard(_app);\n\nvar _plots = __webpack_require__(2);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar searchIndex = exports.searchIndex = void 0;\n\nvar search = function search(val) {\n    var all = app.allNodes;\n    if (val === '') {\n        exports.searchIndex = searchIndex = null;\n        return app.valueKey = all.map(function (n) {\n            return n.name;\n        });\n    }\n\n    var matches = [],\n        others = [],\n        match = function match(n, key) {\n        return n[key].toLowerCase().includes(val.toLowerCase());\n    };\n\n    all.forEach(function (n) {\n        return match(n, 'name') || match(n, 'labl') ? matches.push(n) : others.push(n);\n    });\n    exports.searchIndex = searchIndex = matches.length;\n    app.valueKey = matches.concat(others).map(function (n) {\n        return n.name;\n    });\n};\n\nvar Search = function () {\n    function Search() {\n        _classCallCheck(this, Search);\n    }\n\n    _createClass(Search, [{\n        key: 'view',\n        value: function view(vnode) {\n            vnode.attrs.oninput = _mithril2.default.withAttr('value', search);\n            return (0, _mithril2.default)('input#searchvar.form-control[style=margin-bottom: 5px; width: 100%]', vnode.attrs);\n        }\n    }]);\n\n    return Search;\n}();\n\nexports.default = Search;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvYXBwL3ZpZXdzL1NlYXJjaC5qcz8xMzc4Il0sIm5hbWVzIjpbImFwcCIsInNlYXJjaEluZGV4Iiwic2VhcmNoIiwiYWxsIiwiYWxsTm9kZXMiLCJ2YWwiLCJ2YWx1ZUtleSIsIm1hcCIsIm4iLCJuYW1lIiwibWF0Y2hlcyIsIm90aGVycyIsIm1hdGNoIiwia2V5IiwidG9Mb3dlckNhc2UiLCJpbmNsdWRlcyIsImZvckVhY2giLCJwdXNoIiwibGVuZ3RoIiwiY29uY2F0IiwiU2VhcmNoIiwidm5vZGUiLCJhdHRycyIsIm9uaW5wdXQiLCJ3aXRoQXR0ciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7Ozs7QUFFQTs7SUFBWUEsRzs7QUFDWjs7Ozs7Ozs7QUFFTyxJQUFJQywwQ0FBSjs7QUFFUCxJQUFJQyxTQUFTLFNBQVRBLE1BQVMsTUFBTztBQUNoQixRQUFJQyxNQUFNSCxJQUFJSSxRQUFkO0FBQ0EsUUFBSUMsUUFBUSxFQUFaLEVBQWdCO0FBQ1osZ0JBTEdKLFdBS0gsaUJBQWMsSUFBZDtBQUNBLGVBQU9ELElBQUlNLFFBQUosR0FBZUgsSUFBSUksR0FBSixDQUFRO0FBQUEsbUJBQUtDLEVBQUVDLElBQVA7QUFBQSxTQUFSLENBQXRCO0FBQ0g7O0FBTGUsUUFNWEMsT0FOVyxHQU1nQixFQU5oQjtBQUFBLFFBTUZDLE1BTkUsR0FNb0IsRUFOcEI7QUFBQSxRQU1NQyxLQU5OLEdBTXdCLFNBQWxCQSxLQUFrQixDQUFDSixDQUFELEVBQUlLLEdBQUo7QUFBQSxlQUFZTCxFQUFFSyxHQUFGLEVBQU9DLFdBQVAsR0FBcUJDLFFBQXJCLENBQThCVixJQUFJUyxXQUFKLEVBQTlCLENBQVo7QUFBQSxLQU54Qjs7QUFPaEJYLFFBQUlhLE9BQUosQ0FBWTtBQUFBLGVBQUtKLE1BQU1KLENBQU4sRUFBUyxNQUFULEtBQW9CSSxNQUFNSixDQUFOLEVBQVMsTUFBVCxDQUFwQixHQUF1Q0UsUUFBUU8sSUFBUixDQUFhVCxDQUFiLENBQXZDLEdBQXlERyxPQUFPTSxJQUFQLENBQVlULENBQVosQ0FBOUQ7QUFBQSxLQUFaO0FBQ0EsWUFWT1AsV0FVUCxpQkFBY1MsUUFBUVEsTUFBdEI7QUFDQWxCLFFBQUlNLFFBQUosR0FBZUksUUFDVlMsTUFEVSxDQUNIUixNQURHLEVBRVZKLEdBRlUsQ0FFTjtBQUFBLGVBQUtDLEVBQUVDLElBQVA7QUFBQSxLQUZNLENBQWY7QUFHSCxDQVpEOztJQWNNVyxNOzs7Ozs7OzZCQUNHQyxLLEVBQU87QUFDUkEsa0JBQU1DLEtBQU4sQ0FBWUMsT0FBWixHQUFzQixrQkFBRUMsUUFBRixDQUFXLE9BQVgsRUFBb0J0QixNQUFwQixDQUF0QjtBQUNBLG1CQUFPLHVCQUFFLHFFQUFGLEVBQXlFbUIsTUFBTUMsS0FBL0UsQ0FBUDtBQUNIOzs7Ozs7a0JBR1VGLE0iLCJmaWxlIjoiNy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuXG5pbXBvcnQgKiBhcyBhcHAgZnJvbSAnLi4vYXBwJztcbmltcG9ydCB7c2VsVmFyQ29sb3J9IGZyb20gJy4uL3Bsb3RzJztcblxuZXhwb3J0IGxldCBzZWFyY2hJbmRleDtcblxubGV0IHNlYXJjaCA9IHZhbCA9PiB7XG4gICAgbGV0IGFsbCA9IGFwcC5hbGxOb2RlcztcbiAgICBpZiAodmFsID09PSAnJykge1xuICAgICAgICBzZWFyY2hJbmRleCA9IG51bGw7XG4gICAgICAgIHJldHVybiBhcHAudmFsdWVLZXkgPSBhbGwubWFwKG4gPT4gbi5uYW1lKTtcbiAgICB9XG4gICAgbGV0IFttYXRjaGVzLCBvdGhlcnMsIG1hdGNoXSA9IFtbXSwgW10sIChuLCBrZXkpID0+IG5ba2V5XS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHZhbC50b0xvd2VyQ2FzZSgpKV07XG4gICAgYWxsLmZvckVhY2gobiA9PiBtYXRjaChuLCAnbmFtZScpIHx8IG1hdGNoKG4sICdsYWJsJykgPyBtYXRjaGVzLnB1c2gobikgOiBvdGhlcnMucHVzaChuKSk7XG4gICAgc2VhcmNoSW5kZXggPSBtYXRjaGVzLmxlbmd0aDtcbiAgICBhcHAudmFsdWVLZXkgPSBtYXRjaGVzXG4gICAgICAgIC5jb25jYXQob3RoZXJzKVxuICAgICAgICAubWFwKG4gPT4gbi5uYW1lKTtcbn07XG5cbmNsYXNzIFNlYXJjaCB7XG4gICAgdmlldyh2bm9kZSkge1xuICAgICAgICB2bm9kZS5hdHRycy5vbmlucHV0ID0gbS53aXRoQXR0cigndmFsdWUnLCBzZWFyY2gpO1xuICAgICAgICByZXR1cm4gbSgnaW5wdXQjc2VhcmNodmFyLmZvcm0tY29udHJvbFtzdHlsZT1tYXJnaW4tYm90dG9tOiA1cHg7IHdpZHRoOiAxMDAlXScsIHZub2RlLmF0dHJzKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNlYXJjaDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Fzc2V0cy9hcHAvdmlld3MvU2VhcmNoLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mithril = __webpack_require__(0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _app = __webpack_require__(1);\n\nvar app = _interopRequireWildcard(_app);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Subpanel = function () {\n    function Subpanel() {\n        _classCallCheck(this, Subpanel);\n    }\n\n    _createClass(Subpanel, [{\n        key: 'oninit',\n        value: function oninit(vnode) {\n            this.hide = false;\n        }\n    }, {\n        key: 'view',\n        value: function view(vnode) {\n            var _this = this;\n\n            var title = vnode.attrs.title;\n            var legend = title === 'Legend';\n            var target = 'collapse' + title;\n            var z = app.zparams;\n            return (0, _mithril2.default)('#' + (legend ? \"legend.legendary\" : \"logdiv.logbox\") + '.panel.panel-default', {\n                style: { display: legend && z.ztime.length + z.zcross.length + z.zdv.length + z.znom.length || !legend && app.logArray.length > 0 ? 'block' : 'none' } }, (0, _mithril2.default)(\".panel-heading\", (0, _mithril2.default)(\"h3.panel-title\", title, (0, _mithril2.default)('span.glyphicon.glyphicon-large.glyphicon-chevron-' + (this.hide ? 'up' : 'down') + '.pull-right[data-target=#' + target + '][data-toggle=collapse][href=#' + target + ']', {\n                style: 'cursor: pointer',\n                onclick: function onclick(_) {\n                    return _this.hide = !_this.hide;\n                } }))), (0, _mithril2.default)('#' + target + '.panel-collapse.collapse.in', (0, _mithril2.default)(\".panel-body\", !legend ? app.logArray.map(function (x) {\n                return (0, _mithril2.default)('p', x);\n            }) : vnode.attrs.buttons.map(function (x) {\n                return (0, _mithril2.default)('#' + x[0] + '.clearfix.' + (z[x[1]].length === 0 ? \"hide\" : \"show\"), (0, _mithril2.default)(\".rectColor\", (0, _mithril2.default)(\"svg[style=width: 20px; height: 20px]\", (0, _mithril2.default)(\"circle[cx=10][cy=10][fill=white][r=9][stroke=black][stroke-width=2]\"))), (0, _mithril2.default)(\".rectLabel\", x[2]));\n            }))));\n        }\n    }]);\n\n    return Subpanel;\n}();\n\nexports.default = Subpanel;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvYXBwL3ZpZXdzL1N1YnBhbmVsLmpzP2ViYWIiXSwibmFtZXMiOlsiYXBwIiwiU3VicGFuZWwiLCJ2bm9kZSIsImhpZGUiLCJ0aXRsZSIsImF0dHJzIiwibGVnZW5kIiwidGFyZ2V0IiwieiIsInpwYXJhbXMiLCJzdHlsZSIsImRpc3BsYXkiLCJ6dGltZSIsImxlbmd0aCIsInpjcm9zcyIsInpkdiIsInpub20iLCJsb2dBcnJheSIsIm9uY2xpY2siLCJtYXAiLCJ4IiwiYnV0dG9ucyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7OztBQUVBOztJQUFZQSxHOzs7Ozs7OztJQUVOQyxROzs7Ozs7OytCQUNLQyxLLEVBQU87QUFDVixpQkFBS0MsSUFBTCxHQUFZLEtBQVo7QUFDSDs7OzZCQUVJRCxLLEVBQU87QUFBQTs7QUFDUixnQkFBSUUsUUFBUUYsTUFBTUcsS0FBTixDQUFZRCxLQUF4QjtBQUNBLGdCQUFJRSxTQUFTRixVQUFVLFFBQXZCO0FBQ0EsZ0JBQUlHLFNBQVMsYUFBYUgsS0FBMUI7QUFDQSxnQkFBSUksSUFBSVIsSUFBSVMsT0FBWjtBQUNBLG1CQUFPLDhCQUFNSCxTQUFTLGtCQUFULEdBQThCLGVBQXBDLDRCQUEyRTtBQUM5RUksdUJBQU8sRUFBQ0MsU0FBU0wsVUFBVUUsRUFBRUksS0FBRixDQUFRQyxNQUFSLEdBQWlCTCxFQUFFTSxNQUFGLENBQVNELE1BQTFCLEdBQW1DTCxFQUFFTyxHQUFGLENBQU1GLE1BQXpDLEdBQWtETCxFQUFFUSxJQUFGLENBQU9ILE1BQW5FLElBQTZFLENBQUNQLE1BQUQsSUFBV04sSUFBSWlCLFFBQUosQ0FBYUosTUFBYixHQUFzQixDQUE5RyxHQUFrSCxPQUFsSCxHQUE0SCxNQUF0SSxFQUR1RSxFQUEzRSxFQUVFLHVCQUFFLGdCQUFGLEVBQ0UsdUJBQUUsZ0JBQUYsRUFDRVQsS0FERixFQUVFLDhFQUFzRCxLQUFLRCxJQUFMLEdBQVksSUFBWixHQUFrQixNQUF4RSxrQ0FBMEdJLE1BQTFHLHNDQUFpSkEsTUFBakosUUFBNEo7QUFDeEpHLHVCQUFPLGlCQURpSjtBQUV4SlEseUJBQVM7QUFBQSwyQkFBSyxNQUFLZixJQUFMLEdBQVksQ0FBQyxNQUFLQSxJQUF2QjtBQUFBLGlCQUYrSSxFQUE1SixDQUZGLENBREYsQ0FGRixFQVFFLDZCQUFNSSxNQUFOLGtDQUNFLHVCQUFFLGFBQUYsRUFBaUIsQ0FBQ0QsTUFBRCxHQUFVTixJQUFJaUIsUUFBSixDQUFhRSxHQUFiLENBQWlCO0FBQUEsdUJBQUssdUJBQUUsR0FBRixFQUFPQyxDQUFQLENBQUw7QUFBQSxhQUFqQixDQUFWLEdBQTZDbEIsTUFBTUcsS0FBTixDQUFZZ0IsT0FBWixDQUFvQkYsR0FBcEIsQ0FBd0IsYUFBSztBQUN2Rix1QkFBTyw2QkFBTUMsRUFBRSxDQUFGLENBQU4sbUJBQXVCWixFQUFFWSxFQUFFLENBQUYsQ0FBRixFQUFRUCxNQUFSLEtBQW1CLENBQW5CLEdBQXVCLE1BQXZCLEdBQWdDLE1BQXZELEdBQ0UsdUJBQUUsWUFBRixFQUNFLHVCQUFFLHNDQUFGLEVBQ0UsdUJBQUUscUVBQUYsQ0FERixDQURGLENBREYsRUFJRSx1QkFBRSxZQUFGLEVBQWdCTyxFQUFFLENBQUYsQ0FBaEIsQ0FKRixDQUFQO0FBSWlDLGFBTHlCLENBQTlELENBREYsQ0FSRixDQUFQO0FBZUg7Ozs7OztrQkFHVW5CLFEiLCJmaWxlIjoiOC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuXG5pbXBvcnQgKiBhcyBhcHAgZnJvbSAnLi4vYXBwJztcblxuY2xhc3MgU3VicGFuZWwge1xuICAgIG9uaW5pdCh2bm9kZSkge1xuICAgICAgICB0aGlzLmhpZGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2aWV3KHZub2RlKSB7XG4gICAgICAgIGxldCB0aXRsZSA9IHZub2RlLmF0dHJzLnRpdGxlO1xuICAgICAgICBsZXQgbGVnZW5kID0gdGl0bGUgPT09ICdMZWdlbmQnO1xuICAgICAgICBsZXQgdGFyZ2V0ID0gJ2NvbGxhcHNlJyArIHRpdGxlO1xuICAgICAgICBsZXQgeiA9IGFwcC56cGFyYW1zO1xuICAgICAgICByZXR1cm4gbShgIyR7bGVnZW5kID8gXCJsZWdlbmQubGVnZW5kYXJ5XCIgOiBcImxvZ2Rpdi5sb2dib3hcIn0ucGFuZWwucGFuZWwtZGVmYXVsdGAsIHtcbiAgICAgICAgICAgIHN0eWxlOiB7ZGlzcGxheTogbGVnZW5kICYmIHouenRpbWUubGVuZ3RoICsgei56Y3Jvc3MubGVuZ3RoICsgei56ZHYubGVuZ3RoICsgei56bm9tLmxlbmd0aCB8fCAhbGVnZW5kICYmIGFwcC5sb2dBcnJheS5sZW5ndGggPiAwID8gJ2Jsb2NrJyA6ICdub25lJ319LFxuICAgICAgICAgICAgICAgICBtKFwiLnBhbmVsLWhlYWRpbmdcIixcbiAgICAgICAgICAgICAgICAgICBtKFwiaDMucGFuZWwtdGl0bGVcIixcbiAgICAgICAgICAgICAgICAgICAgIHRpdGxlLFxuICAgICAgICAgICAgICAgICAgICAgbShgc3Bhbi5nbHlwaGljb24uZ2x5cGhpY29uLWxhcmdlLmdseXBoaWNvbi1jaGV2cm9uLSR7dGhpcy5oaWRlID8gJ3VwJzogJ2Rvd24nfS5wdWxsLXJpZ2h0W2RhdGEtdGFyZ2V0PSMke3RhcmdldH1dW2RhdGEtdG9nZ2xlPWNvbGxhcHNlXVtocmVmPSMke3RhcmdldH1dYCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiAnY3Vyc29yOiBwb2ludGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICBvbmNsaWNrOiBfID0+IHRoaXMuaGlkZSA9ICF0aGlzLmhpZGV9KSkpLFxuICAgICAgICAgICAgICAgICBtKGAjJHt0YXJnZXR9LnBhbmVsLWNvbGxhcHNlLmNvbGxhcHNlLmluYCxcbiAgICAgICAgICAgICAgICAgICBtKFwiLnBhbmVsLWJvZHlcIiwgIWxlZ2VuZCA/IGFwcC5sb2dBcnJheS5tYXAoeCA9PiBtKCdwJywgeCkpIDogdm5vZGUuYXR0cnMuYnV0dG9ucy5tYXAoeCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtKGAjJHt4WzBdfS5jbGVhcmZpeC4ke3pbeFsxXV0ubGVuZ3RoID09PSAwID8gXCJoaWRlXCIgOiBcInNob3dcIn1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKFwiLnJlY3RDb2xvclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0oXCJzdmdbc3R5bGU9d2lkdGg6IDIwcHg7IGhlaWdodDogMjBweF1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0oXCJjaXJjbGVbY3g9MTBdW2N5PTEwXVtmaWxsPXdoaXRlXVtyPTldW3N0cm9rZT1ibGFja11bc3Ryb2tlLXdpZHRoPTJdXCIpKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0oXCIucmVjdExhYmVsXCIsIHhbMl0pKTt9KSkpKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFN1YnBhbmVsO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYXNzZXRzL2FwcC92aWV3cy9TdWJwYW5lbC5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8\n")},function(module,exports){eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvY3NzL2FwcC5jc3M/MmY3ZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiI5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Fzc2V0cy9jc3MvYXBwLmNzc1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9\n")},function(module,exports){eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvcGtncy9MYWRkYS9kaXN0L2xhZGRhLXRoZW1lbGVzcy5taW4uY3NzP2E2ZTEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYXNzZXRzL3BrZ3MvTGFkZGEvZGlzdC9sYWRkYS10aGVtZWxlc3MubWluLmNzc1xuLy8gbW9kdWxlIGlkID0gMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///10\n")},function(module,exports){eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvcGtncy9ib290c3RyYXAvY3NzL2Jvb3RzdHJhcC10aGVtZS5taW4uY3NzP2ZiNzQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYXNzZXRzL3BrZ3MvYm9vdHN0cmFwL2Nzcy9ib290c3RyYXAtdGhlbWUubWluLmNzc1xuLy8gbW9kdWxlIGlkID0gMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///11\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n__webpack_require__(11);\n\n__webpack_require__(9);\n\n__webpack_require__(10);\n\n__webpack_require__(3);\n\nvar _mithril = __webpack_require__(0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _app = __webpack_require__(1);\n\nvar app = _interopRequireWildcard(_app);\n\nvar _plots = __webpack_require__(2);\n\nvar plots = _interopRequireWildcard(_plots);\n\nvar _Panel = __webpack_require__(5);\n\nvar _Panel2 = _interopRequireDefault(_Panel);\n\nvar _PanelButton = __webpack_require__(6);\n\nvar _PanelButton2 = _interopRequireDefault(_PanelButton);\n\nvar _Search = __webpack_require__(7);\n\nvar _Search2 = _interopRequireDefault(_Search);\n\nvar _Subpanel = __webpack_require__(8);\n\nvar _Subpanel2 = _interopRequireDefault(_Subpanel);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar leftpanel = function leftpanel() {\n  return (0, _mithril2.default)(_Panel2.default, {\n    side: 'left',\n    title: 'Data Selection' }, (0, _mithril2.default)(\".btn-toolbar[role=toolbar][style=margin-left: .5em; margin-top: .5em]\", (0, _mithril2.default)(\".btn-group\", (0, _mithril2.default)(_PanelButton2.default, {\n    id: 'btnVariables',\n    id2: 'tab1',\n    title: 'Click variable name to add or remove the variable pebble from the modeling space.' }, 'Variables'), (0, _mithril2.default)(_PanelButton2.default, { id: 'btnSubset', id2: 'tab2' }, 'Subset')), (0, _mithril2.default)(_PanelButton2.default, {\n    id: 'btnSelect',\n    classes: 'btn-default.ladda-button[data-spinner-color=#000000][data-style=zoom-in]',\n    onclick: function onclick(_) {\n      return app.subsetSelect('btnSelect');\n    },\n    style: 'display: ' + (app.subset ? 'block' : 'none') + '; float: right; margin-right: 10px',\n    title: 'Subset data by the intersection of all selected values.' }, (0, _mithril2.default)('span.ladda-label[style=pointer-events: none]', 'Select'))), (0, _mithril2.default)('#tab1[style=display: ' + (0, _PanelButton.or)('left', 'tab1') + '; padding: 10px 8px; text-align: center]', (0, _mithril2.default)(_Search2.default, { placeholder: 'Search variables and labels' }), (0, _mithril2.default)('#varList[style=display: block]', app.valueKey.map(function (v, i) {\n    return (0, _mithril2.default)('p#' + v.replace(/\\W/g, '_'), {\n      style: {\n        'background-color': app.zparams.zdv.includes(v) ? app.hexToRgba(app.dvColor) : app.zparams.znom.includes(v) ? app.hexToRgba(app.nomColor) : app.nodes.map(function (n) {\n          return n.name;\n        }).includes(v) ? app.hexToRgba(plots.selVarColor) : app.varColor,\n        'border-color': '#000000',\n        'border-style': _Search.searchIndex && i < _Search.searchIndex ? 'solid' : 'none'\n      },\n      onclick: app.clickVar,\n      onmouseover: function onmouseover() {\n        $(this).popover('show');\n        $(\"body div.popover\").addClass(\"variables\");\n        $(\"body div.popover div.popover-content\").addClass(\"form-horizontal\");\n      },\n      onmouseout: \"$(this).popover('hide');\",\n      'data-container': 'body',\n      'data-content': app.popoverContent(app.findNodeIndex(v, true)),\n      'data-html': 'true',\n      'data-original-title': 'Summary Statistics',\n      'data-placement': 'right',\n      'data-toggle': 'popover',\n      'data-trigger': 'hover' }, v);\n  }))), (0, _mithril2.default)('#tab2[style=display: ' + (0, _PanelButton.or)('left', 'tab2') + '; margin-top: .5em]'), (0, _mithril2.default)('#tab3[style=height: 350px]', (0, _mithril2.default)('p[style=padding: .5em 1em; display: ' + (0, _PanelButton.or)('left', 'tab3') + ']', {\n    title: \"Select a variable from within the visualization in the center panel to view its summary statistics.\" }, (0, _mithril2.default)('center', (0, _mithril2.default)('b', app.summary.name), (0, _mithril2.default)('br'), (0, _mithril2.default)('i', app.summary.labl)), (0, _mithril2.default)('table', app.summary.data.map(function (tr) {\n    return (0, _mithril2.default)('tr', tr.map(function (td) {\n      return (0, _mithril2.default)('td', {\n        onmouseover: function onmouseover() {\n          this.style['background-color'] = 'aliceblue';\n        },\n        onmouseout: function onmouseout() {\n          this.style['background-color'] = '#f9f9f9';\n        } }, td);\n    }));\n  })))));\n};\n\nvar rightpanel = function rightpanel(mode) {\n  return mode ? (0, _mithril2.default)(_Panel2.default, {\n    side: 'right',\n    title: 'Result Exploration' }, (0, _mithril2.default)(\".btn-group.btn-group-justified[style=margin-top: .5em]\", (0, _mithril2.default)(_PanelButton2.default, { id: 'btnUnivariate' }, 'Univariate'), (0, _mithril2.default)(_PanelButton2.default, { id: 'btnBivariate' }, 'Bivariate')), (0, _mithril2.default)('#univariate[style=display: ' + (0, _PanelButton.or)('right', 'btnUnivariate') + ']'), (0, _mithril2.default)('#bivariate[style=display: ' + (0, _PanelButton.or)('right', 'btnBivariate') + ']')) : (0, _mithril2.default)(_Panel2.default, {\n    side: 'right',\n    title: 'Model Selection' }, (0, _mithril2.default)(\".accordian[style=margin-top: .5em]\", (0, _mithril2.default)(\"ul#rightpanelbuttons\", [(0, _mithril2.default)(\"li\", [(0, _mithril2.default)(_PanelButton2.default, { id: 'btnModels', style: 'width: 100%' }, 'Models')]), (0, _mithril2.default)(\"li\", [(0, _mithril2.default)(_PanelButton2.default, { id: 'btnSetx', style: 'width: 100%' }, 'Set Covar.')]), (0, _mithril2.default)(\"li\", [(0, _mithril2.default)(_PanelButton2.default, { id: 'btnResults', style: 'width: 100%' }, 'Results')]), (0, _mithril2.default)(\"li\", [(0, _mithril2.default)(_PanelButton2.default, { id: 'btnType', style: 'width: 100%' }, 'Task Type')]), (0, _mithril2.default)(\"li\", [(0, _mithril2.default)(_PanelButton2.default, { id: 'btnSubtype', style: 'width: 100%' }, 'Subtype')]), (0, _mithril2.default)(\"li\", [(0, _mithril2.default)(_PanelButton2.default, { id: 'btnMetrics', style: 'width: 100%' }, 'Metrics')]), (0, _mithril2.default)(\"li\", [(0, _mithril2.default)(_PanelButton2.default, { id: 'btnOutputs', style: 'width: 100%' }, 'Output')])])),\n  /*     m(\".btn-group.btn-group-justified#modelGroup[style=margin-top: .5em]\",\n         m(Button, {id: 'btnModels', style: 'width: 33%'}, 'Models'),\n         m(Button, {id: 'btnSetx', style: 'width: 34%'}, 'Set Covar.'),\n         m(Button, {id: 'btnResults', style: 'width: 33%'}, 'Results'),\n         m(Button, {id: 'btnType', style: 'width: 25%; display: none'}, 'Task Type'),\n         m(Button, {id: 'btnSubtype', style: 'width: 25%; display: none'}, 'Subtype'),\n         m(Button, {id: 'btnMetrics', style: 'width: 25%; display: none'}, 'Metrics'),\n         m(Button, {id: 'btnOutputs', style: 'width: 25%; display: none'}, 'Outputs')),   */\n  (0, _mithril2.default)('#results[style=display: ' + (0, _PanelButton.or)('right', 'btnResults') + '; margin-top: .5em]', (0, _mithril2.default)(\"#resultsView.container[style=float: right; overflow: auto; width: 80%; background-color: white; white-space: nowrap]\"), (0, _mithril2.default)('#modelView[style=display: none; float: left; width: 20%; background-color: white]'), (0, _mithril2.default)(\"p#resultsHolder[style=padding: .5em 1em]\")), (0, _mithril2.default)('#setx[style=display: ' + (0, _PanelButton.or)('right', 'btnSetx') + ']', (0, _mithril2.default)('#setxLeftAll[style=display:block; float: left; width: 30%; height:100%; background-color: white]', (0, _mithril2.default)('#setxLeft[style=display:block; float: left; width: 100%; height:95%; overflow:auto; background-color: white]')), (0, _mithril2.default)('#setxRightAll[style=display:block; float: left; width: 70%; height:100%; background-color: white]', (0, _mithril2.default)('#setxRightTop[style=display:block; float: left; width: 100%; height:65%; overflow:auto; background-color: white]', (0, _mithril2.default)('#setxMiddle[style=display:block; float: left; width: 70%; height:100%; background-color: white]'), (0, _mithril2.default)('#setxRight[style=display:block; float: right; width: 30%; height:100%; background-color: white]')), (0, _mithril2.default)('#setxRightBottom[style=display:block; float: left; width: 100%; height:35%; overflow:auto; background-color: white]', (0, _mithril2.default)('#setxRightBottomLeft[style=display:block; float: left; width: 75%; height:100%; background-color: white]'), (0, _mithril2.default)('#setxRightBottomMiddle[style=display:block; float: left; width: 15%; height:100%; background-color: white]', (0, _mithril2.default)(_PanelButton2.default, {\n    id: 'btnExecutePipe',\n    classes: 'btn-default.ladda-button[data-spinner-color=#000000][data-style=zoom-in]',\n    onclick: function onclick(_) {\n      return app.executepipeline('btnExecutePipe');\n    },\n    style: 'display:inline; float: left; margin-right: 10px',\n    title: 'Execute pipeline.' }, (0, _mithril2.default)('span.ladda-label[style=pointer-events: none]', 'Execute'))), (0, _mithril2.default)('#setxRightBottomRight[style=display:block; float: left; width: 10%; height:100%; background-color: white]')))), (0, _mithril2.default)('#models[style=display: ' + (0, _PanelButton.or)('right', 'btnModels') + '; padding: 6px 12px; text-align: center]'), (0, _mithril2.default)('#types[style=display: ' + (0, _PanelButton.or)('right', 'btnType') + '; padding: 6px 12px; text-align: center]'), (0, _mithril2.default)('#subtypes[style=display: ' + (0, _PanelButton.or)('right', 'btnSubtype') + '; padding: 6px 12px; text-align: center]'), (0, _mithril2.default)('#metrics[style=display: ' + (0, _PanelButton.or)('right', 'btnMetrics') + '; padding: 6px 12px; text-align: center]'), (0, _mithril2.default)('#outputs[style=display: ' + (0, _PanelButton.or)('right', 'btnOutputs') + '; padding: 6px 12px; text-align: center]'));\n};\n\nvar ticker = function ticker(mode) {\n  var link = function link(name) {\n    return (0, _mithril2.default)('a' + (name === mode ? '.active' : '') + '[href=/' + name + '][style=margin-right: 0.5em]', { oncreate: _mithril2.default.route.link }, name[0].toUpperCase() + name.slice(1));\n  };\n  return (0, _mithril2.default)('#ticker[style=background: #F9F9F9; bottom: 0; height: 40px; position: fixed; width: 100%; border-top: 1px solid #ADADAD]', link('model'), link('explore'), (0, _mithril2.default)(\"a#logID[href=somelink][target=_blank][style=margin-right: 0.5em]\", \"Replication\"));\n};\n\nvar Body = function () {\n  function Body() {\n    _classCallCheck(this, Body);\n  }\n\n  _createClass(Body, [{\n    key: 'oninit',\n    value: function oninit() {\n      this.about = false;\n      this.cite = false;\n      this.citeHidden = false;\n    }\n  }, {\n    key: 'oncreate',\n    value: function oncreate() {\n      var extract = function extract(name, key, offset, replace) {\n        key = key + '=';\n        var loc = window.location.toString();\n        var val = loc.indexOf(key) > 0 ? loc.substring(loc.indexOf(key) + offset) : '';\n        var idx = val.indexOf('&');\n        val = idx > 0 ? val.substring(0, idx) : val;\n        val = val.replace('#!/model', '');\n        console.log(name, ': ', val);\n        if (replace) val = val.replace(/%25/g, '%').replace(/%3A/g, ':').replace(/%2F/g, '/');\n        return val;\n      };\n      // let apikey = extract('apikey', 'key', 4);\n      app.main(extract('fileid', 'dfId', 5), extract('hostname', 'host', 5), extract('ddiurl', 'ddiurl', 7, true), extract('dataurl', 'dataurl', 8, true), extract('apikey', 'key', 4));\n    }\n  }, {\n    key: 'view',\n    value: function view(vnode) {\n      var _this = this;\n\n      var mode = vnode.attrs.mode;\n\n      return (0, _mithril2.default)('main', (0, _mithril2.default)(\"nav#navbar.navbar.navbar-default.navbar-fixed-top[role=navigation]\", (0, _mithril2.default)(\"a.navbar-brand[style=margin-left: 0]\", (0, _mithril2.default)(\"img[src=/static/images/TwoRavens.png][alt=TwoRavens][width=100][style=margin-left: 2em; margin-top: -0.5em]\", {\n        onmouseover: function onmouseover(_) {\n          return _this.about = true;\n        },\n        onmouseout: function onmouseout(_) {\n          return _this.about = false;\n        } })), (0, _mithril2.default)('#navbarNav[style=padding: 0.5em]', (0, _mithril2.default)('#dataField.field[style=margin-top: 0.5em; text-align: center]', (0, _mithril2.default)('h4#dataName[style=display: inline]', {\n        onclick: function onclick(_) {\n          return _this.cite = _this.citeHidden = !_this.citeHidden;\n        },\n        onmouseout: function onmouseout(_) {\n          return _this.citeHidden || (_this.cite = false);\n        },\n        onmouseover: function onmouseover(_) {\n          return _this.cite = true;\n        } }, \"Dataset Name\"), (0, _mithril2.default)('#cite.panel.panel-default[style=display: ' + (this.cite ? 'block' : 'none') + '; position: absolute; right: 50%; width: 380px; text-align: left; z-index: 50]', (0, _mithril2.default)(\".panel-body\")), (0, _mithril2.default)(\"button#btnEstimate.btn.btn-success.ladda-button.navbar-right[data-spinner-color=#000000][data-style=zoom-in][style=margin-left: 2em; margin-right: 1em]\", {\n        onclick: function onclick(_) {\n          return app.estimate('btnEstimate');\n        } }, (0, _mithril2.default)(\"span.ladda-label\", mode ? 'Explore' : 'Solve This Problem')), (0, _mithril2.default)(\"button#btnTA2.btn.btn-default.ladda-button.navbar-right[data-spinner-color=#000000][data-style=zoom-in][style=margin-left: 0.5em; margin-right: 1em]\", {\n        onclick: function onclick(_) {\n          return app.helpmaterials('manual');\n        } }, 'Help Manual ', (0, _mithril2.default)(\"span.glyphicon.glyphicon-book[style=color: #818181; font-size: 1em; pointer-events: none]\")), (0, _mithril2.default)(\"button#btnTA2.btn.btn-default.ladda-button.navbar-right[data-spinner-color=#000000][data-style=zoom-in][style=margin-left: 15em; margin-right: 0.5em]\", {\n        onclick: function onclick(_) {\n          return app.helpmaterials('video');\n        } }, 'Help Video ', (0, _mithril2.default)(\"span.glyphicon.glyphicon-expand[style=color: #818181; font-size: 1em; pointer-events: none]\")), (0, _mithril2.default)(\"button#btnReset.btn.btn-default.navbar-right[title=Reset][style=margin-left: 2.0em]\", {\n        onclick: app.reset }, (0, _mithril2.default)(\"span.glyphicon.glyphicon-repeat[style=color: #818181; font-size: 1em; pointer-events: none]\")), (0, _mithril2.default)(\"button#btnEndSession.btn.btn-default.navbar-right[title=Mark Problem Finished][style=margin-left: 2.0em]\", {\n        onclick: function onclick(_) {\n          return app.endsession();\n        } }, (0, _mithril2.default)(\"span.ladda-label\", 'Mark Problem Finished')), (0, _mithril2.default)('#transformations.transformTool', {\n        title: 'Construct transformations of existing variables using valid R syntax. For example, assuming a variable named d, you can enter \"log(d)\" or \"d^2\".' }))), (0, _mithril2.default)('#about.panel.panel-default[style=display: ' + (this.about ? 'block' : 'none') + '; left: 140px; position: absolute; width: 500px; z-index: 50]', (0, _mithril2.default)('.panel-body', 'TwoRavens v0.1 \"Dallas\" -- The Norse god Odin had two talking ravens as advisors, who would fly out into the world and report back all they observed. In the Norse, their names were \"Thought\" and \"Memory\". In our coming release, our thought-raven automatically advises on statistical model selection, while our memory-raven accumulates previous statistical models from Dataverse, to provide cummulative guidance and meta-analysis.'))), (0, _mithril2.default)('#main.left.carousel.slide.svg-leftpanel.svg-rightpanel[style=overflow: auto]', (0, _mithril2.default)(\"#innercarousel.carousel-inner\", (0, _mithril2.default)('#m0.item.active', (0, _mithril2.default)('svg#whitespace'))), (0, _mithril2.default)(\"#spacetools.spaceTool[style=z-index: 16]\", (0, _mithril2.default)(\"button#btnLock.btn.active[title=Lock selections of problem description.]\", {\n        onclick: app.lockDescription }, (0, _mithril2.default)(\"span.glyphicon.glyphicon-pencil\")), (0, _mithril2.default)(\"button#btnForce.btn.btn-default[title=Pin the variable pebbles to the page.]\", {\n        onclick: app.forceSwitch }, (0, _mithril2.default)(\"span.glyphicon.glyphicon-pushpin\")), (0, _mithril2.default)(\"button#btnEraser.btn.btn-default[title=Wipe all variables from the modeling space.]\", {\n        onclick: app.erase }, (0, _mithril2.default)(\"span.glyphicon.glyphicon-magnet\"))), (0, _mithril2.default)(_Subpanel2.default, {\n        title: \"Legend\",\n        buttons: [['timeButton', 'ztime', 'Time'], ['csButton', 'zcross', 'Cross Sec'], ['dvButton', 'zdv', 'Dep Var'], ['nomButton', 'znom', 'Nom Var'], ['gr1Button', 'zgroup1', 'Group 1'], ['gr2Button', 'zgroup2', 'Group 2']] }), (0, _mithril2.default)(_Subpanel2.default, { title: \"History\" }), ticker(mode), leftpanel(), rightpanel(mode)));\n    }\n  }]);\n\n  return Body;\n}();\n\n_mithril2.default.route(document.body, '/model', {\n  '/model': { render: function render() {\n      return (0, _mithril2.default)(Body);\n    } },\n  '/explore': { render: function render() {\n      return (0, _mithril2.default)(Body, { mode: 'explore' });\n    } }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvYXBwL2luZGV4LmpzPzMzYmUiXSwibmFtZXMiOlsiYXBwIiwicGxvdHMiLCJsZWZ0cGFuZWwiLCJzaWRlIiwidGl0bGUiLCJpZCIsImlkMiIsImNsYXNzZXMiLCJvbmNsaWNrIiwic3Vic2V0U2VsZWN0Iiwic3R5bGUiLCJzdWJzZXQiLCJwbGFjZWhvbGRlciIsInZhbHVlS2V5IiwibWFwIiwidiIsImkiLCJyZXBsYWNlIiwienBhcmFtcyIsInpkdiIsImluY2x1ZGVzIiwiaGV4VG9SZ2JhIiwiZHZDb2xvciIsInpub20iLCJub21Db2xvciIsIm5vZGVzIiwibiIsIm5hbWUiLCJzZWxWYXJDb2xvciIsInZhckNvbG9yIiwiY2xpY2tWYXIiLCJvbm1vdXNlb3ZlciIsIiQiLCJwb3BvdmVyIiwiYWRkQ2xhc3MiLCJvbm1vdXNlb3V0IiwicG9wb3ZlckNvbnRlbnQiLCJmaW5kTm9kZUluZGV4Iiwic3VtbWFyeSIsImxhYmwiLCJkYXRhIiwidHIiLCJ0ZCIsInJpZ2h0cGFuZWwiLCJtb2RlIiwiZXhlY3V0ZXBpcGVsaW5lIiwidGlja2VyIiwibGluayIsIm9uY3JlYXRlIiwicm91dGUiLCJ0b1VwcGVyQ2FzZSIsInNsaWNlIiwiQm9keSIsImFib3V0IiwiY2l0ZSIsImNpdGVIaWRkZW4iLCJleHRyYWN0Iiwia2V5Iiwib2Zmc2V0IiwibG9jIiwid2luZG93IiwibG9jYXRpb24iLCJ0b1N0cmluZyIsInZhbCIsImluZGV4T2YiLCJzdWJzdHJpbmciLCJpZHgiLCJjb25zb2xlIiwibG9nIiwibWFpbiIsInZub2RlIiwiYXR0cnMiLCJlc3RpbWF0ZSIsImhlbHBtYXRlcmlhbHMiLCJyZXNldCIsImVuZHNlc3Npb24iLCJsb2NrRGVzY3JpcHRpb24iLCJmb3JjZVN3aXRjaCIsImVyYXNlIiwiYnV0dG9ucyIsImRvY3VtZW50IiwiYm9keSIsInJlbmRlciJdLCJtYXBwaW5ncyI6Ijs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOztB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QixJQUFGLEVBQVEsRUFBQ1IsTUFBTSxTQUFQLEVBQVIsQ0FBTjtBQUFBLEtBQVQ7QUFGaUIsQ0FBakMiLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJy4uL3BrZ3MvYm9vdHN0cmFwL2Nzcy9ib290c3RyYXAtdGhlbWUubWluLmNzcyc7XG5pbXBvcnQgJy4uL2Nzcy9hcHAuY3NzJztcbmltcG9ydCAnLi4vcGtncy9MYWRkYS9kaXN0L2xhZGRhLXRoZW1lbGVzcy5taW4uY3NzJztcbmltcG9ydCAnLi4vcGtncy9ob3BzY290Y2gvZGlzdC9jc3MvaG9wc2NvdGNoLmNzcyc7XG5cbmltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuXG5pbXBvcnQgKiBhcyBhcHAgZnJvbSAnLi9hcHAnO1xuaW1wb3J0ICogYXMgcGxvdHMgZnJvbSAnLi9wbG90cyc7XG5pbXBvcnQgUGFuZWwgZnJvbSAnLi92aWV3cy9QYW5lbCc7XG5pbXBvcnQgQnV0dG9uLCB7b3J9IGZyb20gJy4vdmlld3MvUGFuZWxCdXR0b24nO1xuaW1wb3J0IFNlYXJjaCwge3NlYXJjaEluZGV4fSBmcm9tICcuL3ZpZXdzL1NlYXJjaCc7XG5pbXBvcnQgU3VicGFuZWwgZnJvbSAnLi92aWV3cy9TdWJwYW5lbCc7XG5cbmxldCBsZWZ0cGFuZWwgPSAoKSA9PiB7XG4gICAgcmV0dXJuIG0oUGFuZWwsIHtcbiAgICAgICAgc2lkZTogJ2xlZnQnLFxuICAgICAgICB0aXRsZTogJ0RhdGEgU2VsZWN0aW9uJ30sICAgICAgICBcbiAgICAgICAgbShcIi5idG4tdG9vbGJhcltyb2xlPXRvb2xiYXJdW3N0eWxlPW1hcmdpbi1sZWZ0OiAuNWVtOyBtYXJnaW4tdG9wOiAuNWVtXVwiLFxuICAgICAgICAgIG0oXCIuYnRuLWdyb3VwXCIsXG4gICAgICAgICAgICBtKEJ1dHRvbiwge1xuICAgICAgICAgICAgICBpZDogJ2J0blZhcmlhYmxlcycsIFxuICAgICAgICAgICAgICBpZDI6ICd0YWIxJyxcbiAgICAgICAgICAgICAgdGl0bGU6ICdDbGljayB2YXJpYWJsZSBuYW1lIHRvIGFkZCBvciByZW1vdmUgdGhlIHZhcmlhYmxlIHBlYmJsZSBmcm9tIHRoZSBtb2RlbGluZyBzcGFjZS4nfSwgXG4gICAgICAgICAgICAgICdWYXJpYWJsZXMnKSwgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICBtKEJ1dHRvbiwge2lkOiAnYnRuU3Vic2V0JywgaWQyOiAndGFiMid9LCAnU3Vic2V0JykpLFxuICAgICAgICAgIG0oQnV0dG9uLCB7XG4gICAgICAgICAgICBpZDogJ2J0blNlbGVjdCcsXG4gICAgICAgICAgICBjbGFzc2VzOiAnYnRuLWRlZmF1bHQubGFkZGEtYnV0dG9uW2RhdGEtc3Bpbm5lci1jb2xvcj0jMDAwMDAwXVtkYXRhLXN0eWxlPXpvb20taW5dJyxcbiAgICAgICAgICAgIG9uY2xpY2s6IF8gPT4gYXBwLnN1YnNldFNlbGVjdCgnYnRuU2VsZWN0JyksXG4gICAgICAgICAgICBzdHlsZTogYGRpc3BsYXk6ICR7YXBwLnN1YnNldCA/ICdibG9jaycgOiAnbm9uZSd9OyBmbG9hdDogcmlnaHQ7IG1hcmdpbi1yaWdodDogMTBweGAsXG4gICAgICAgICAgICB0aXRsZTogJ1N1YnNldCBkYXRhIGJ5IHRoZSBpbnRlcnNlY3Rpb24gb2YgYWxsIHNlbGVjdGVkIHZhbHVlcy4nfSxcbiAgICAgICAgICAgIG0oJ3NwYW4ubGFkZGEtbGFiZWxbc3R5bGU9cG9pbnRlci1ldmVudHM6IG5vbmVdJywgJ1NlbGVjdCcpKSksICAgICAgICAgXG4gICAgICAgIG0oYCN0YWIxW3N0eWxlPWRpc3BsYXk6ICR7b3IoJ2xlZnQnLCAndGFiMScpfTsgcGFkZGluZzogMTBweCA4cHg7IHRleHQtYWxpZ246IGNlbnRlcl1gLFxuICAgICAgICAgIG0oU2VhcmNoLCB7cGxhY2Vob2xkZXI6ICdTZWFyY2ggdmFyaWFibGVzIGFuZCBsYWJlbHMnfSksXG4gICAgICAgICAgbSgnI3Zhckxpc3Rbc3R5bGU9ZGlzcGxheTogYmxvY2tdJywgYXBwLnZhbHVlS2V5Lm1hcCgodiwgaSkgPT5cbiAgICAgICAgICAgIG0oYHAjJHt2LnJlcGxhY2UoL1xcVy9nLCAnXycpfWAsIHtcbiAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAnYmFja2dyb3VuZC1jb2xvcic6IGFwcC56cGFyYW1zLnpkdi5pbmNsdWRlcyh2KSA/IGFwcC5oZXhUb1JnYmEoYXBwLmR2Q29sb3IpIDpcbiAgICAgICAgICAgICAgICAgICBhcHAuenBhcmFtcy56bm9tLmluY2x1ZGVzKHYpID8gYXBwLmhleFRvUmdiYShhcHAubm9tQ29sb3IpIDpcbiAgICAgICAgICAgICAgICAgICBhcHAubm9kZXMubWFwKG4gPT4gbi5uYW1lKS5pbmNsdWRlcyh2KSA/IGFwcC5oZXhUb1JnYmEocGxvdHMuc2VsVmFyQ29sb3IpIDpcbiAgICAgICAgICAgICAgICAgICBhcHAudmFyQ29sb3IsXG4gICAgICAgICAgICAgICAgJ2JvcmRlci1jb2xvcic6ICcjMDAwMDAwJyxcbiAgICAgICAgICAgICAgICAnYm9yZGVyLXN0eWxlJzogc2VhcmNoSW5kZXggJiYgaSA8IHNlYXJjaEluZGV4ID8gJ3NvbGlkJyA6ICdub25lJyxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgb25jbGljazogYXBwLmNsaWNrVmFyLFxuICAgICAgICAgICAgICBvbm1vdXNlb3ZlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgJCh0aGlzKS5wb3BvdmVyKCdzaG93Jyk7XG4gICAgICAgICAgICAgICAgJChcImJvZHkgZGl2LnBvcG92ZXJcIilcbiAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoXCJ2YXJpYWJsZXNcIik7XG4gICAgICAgICAgICAgICAgJChcImJvZHkgZGl2LnBvcG92ZXIgZGl2LnBvcG92ZXItY29udGVudFwiKVxuICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhcImZvcm0taG9yaXpvbnRhbFwiKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgb25tb3VzZW91dDogXCIkKHRoaXMpLnBvcG92ZXIoJ2hpZGUnKTtcIixcbiAgICAgICAgICAgICAgJ2RhdGEtY29udGFpbmVyJzogJ2JvZHknLFxuICAgICAgICAgICAgICAnZGF0YS1jb250ZW50JzogYXBwLnBvcG92ZXJDb250ZW50KGFwcC5maW5kTm9kZUluZGV4KHYsIHRydWUpKSxcbiAgICAgICAgICAgICAgJ2RhdGEtaHRtbCc6ICd0cnVlJyxcbiAgICAgICAgICAgICAgJ2RhdGEtb3JpZ2luYWwtdGl0bGUnOiAnU3VtbWFyeSBTdGF0aXN0aWNzJyxcbiAgICAgICAgICAgICAgJ2RhdGEtcGxhY2VtZW50JzogJ3JpZ2h0JyxcbiAgICAgICAgICAgICAgJ2RhdGEtdG9nZ2xlJzogJ3BvcG92ZXInLFxuICAgICAgICAgICAgICAnZGF0YS10cmlnZ2VyJzogJ2hvdmVyJ30sXG4gICAgICAgICAgICAgIHYpKSkpLFxuICAgICAgICBtKGAjdGFiMltzdHlsZT1kaXNwbGF5OiAke29yKCdsZWZ0JywgJ3RhYjInKX07IG1hcmdpbi10b3A6IC41ZW1dYCksXG4gICAgICAgIG0oJyN0YWIzW3N0eWxlPWhlaWdodDogMzUwcHhdJyxcbiAgICAgICAgICBtKGBwW3N0eWxlPXBhZGRpbmc6IC41ZW0gMWVtOyBkaXNwbGF5OiAke29yKCdsZWZ0JywgJ3RhYjMnKX1dYCwge1xuICAgICAgICAgICAgdGl0bGU6IFwiU2VsZWN0IGEgdmFyaWFibGUgZnJvbSB3aXRoaW4gdGhlIHZpc3VhbGl6YXRpb24gaW4gdGhlIGNlbnRlciBwYW5lbCB0byB2aWV3IGl0cyBzdW1tYXJ5IHN0YXRpc3RpY3MuXCJ9LFxuICAgICAgICAgICAgbSgnY2VudGVyJyxcbiAgICAgICAgICAgICAgbSgnYicsIGFwcC5zdW1tYXJ5Lm5hbWUpLFxuICAgICAgICAgICAgICBtKCdicicpLFxuICAgICAgICAgICAgICBtKCdpJywgYXBwLnN1bW1hcnkubGFibCkpLFxuICAgICAgICAgICAgbSgndGFibGUnLCBhcHAuc3VtbWFyeS5kYXRhLm1hcChcbiAgICAgICAgICAgICAgdHIgPT4gbSgndHInLCB0ci5tYXAoXG4gICAgICAgICAgICAgICAgdGQgPT4gbSgndGQnLCB7XG4gICAgICAgICAgICAgICAgICBvbm1vdXNlb3ZlcjogZnVuY3Rpb24oKSB7dGhpcy5zdHlsZVsnYmFja2dyb3VuZC1jb2xvciddID0gJ2FsaWNlYmx1ZSd9LFxuICAgICAgICAgICAgICAgICAgb25tb3VzZW91dDogZnVuY3Rpb24oKSB7dGhpcy5zdHlsZVsnYmFja2dyb3VuZC1jb2xvciddID0gJyNmOWY5ZjknfX0sXG4gICAgICAgICAgICAgICAgICB0ZCkpKSkpKSkpO1xufTtcblxubGV0IHJpZ2h0cGFuZWwgPSBtb2RlID0+IG1vZGUgPyBtKFBhbmVsLCB7XG4gICAgc2lkZTogJ3JpZ2h0JywgXG4gICAgdGl0bGU6ICdSZXN1bHQgRXhwbG9yYXRpb24nfSxcbiAgICBtKFwiLmJ0bi1ncm91cC5idG4tZ3JvdXAtanVzdGlmaWVkW3N0eWxlPW1hcmdpbi10b3A6IC41ZW1dXCIsXG4gICAgICBtKEJ1dHRvbiwge2lkOiAnYnRuVW5pdmFyaWF0ZSd9LCAnVW5pdmFyaWF0ZScpLFxuICAgICAgbShCdXR0b24sIHtpZDogJ2J0bkJpdmFyaWF0ZSd9LCAnQml2YXJpYXRlJykpLFxuICAgIG0oYCN1bml2YXJpYXRlW3N0eWxlPWRpc3BsYXk6ICR7b3IoJ3JpZ2h0JywgJ2J0blVuaXZhcmlhdGUnKX1dYCksXG4gICAgbShgI2JpdmFyaWF0ZVtzdHlsZT1kaXNwbGF5OiAke29yKCdyaWdodCcsICdidG5CaXZhcmlhdGUnKX1dYCkpIDpcbiAgICBtKFBhbmVsLCB7XG4gICAgICBzaWRlOiAncmlnaHQnLCBcbiAgICAgIHRpdGxlOiAnTW9kZWwgU2VsZWN0aW9uJ30sXG4gICAgICBtKFwiLmFjY29yZGlhbltzdHlsZT1tYXJnaW4tdG9wOiAuNWVtXVwiLFxuICAgICAgICBtKFwidWwjcmlnaHRwYW5lbGJ1dHRvbnNcIixbXG4gICAgICAgICAgIG0oXCJsaVwiLFtcbiAgICAgICAgICAgICAgbShCdXR0b24sIHtpZDogJ2J0bk1vZGVscycsIHN0eWxlOiAnd2lkdGg6IDEwMCUnfSwgJ01vZGVscycpXSksXG4gICAgICAgICAgIG0oXCJsaVwiLFtcbiAgICAgICAgICAgICAgbShCdXR0b24sIHtpZDogJ2J0blNldHgnLCBzdHlsZTogJ3dpZHRoOiAxMDAlJ30sICdTZXQgQ292YXIuJyldKSxcbiAgICAgICAgICAgbShcImxpXCIsW1xuICAgICAgICAgICAgICBtKEJ1dHRvbiwge2lkOiAnYnRuUmVzdWx0cycsIHN0eWxlOiAnd2lkdGg6IDEwMCUnfSwgJ1Jlc3VsdHMnKV0pLFxuICAgICAgICAgICBtKFwibGlcIixbXG4gICAgICAgICAgICAgIG0oQnV0dG9uLCB7aWQ6ICdidG5UeXBlJywgc3R5bGU6ICd3aWR0aDogMTAwJSd9LCAnVGFzayBUeXBlJyksXSksXG4gICAgICAgICAgIG0oXCJsaVwiLFtcbiAgICAgICAgICAgICAgbShCdXR0b24sIHtpZDogJ2J0blN1YnR5cGUnLCBzdHlsZTogJ3dpZHRoOiAxMDAlJ30sICdTdWJ0eXBlJyksXSksXG4gICAgICAgICAgIG0oXCJsaVwiLFtcbiAgICAgICAgICAgICAgbShCdXR0b24sIHtpZDogJ2J0bk1ldHJpY3MnLCBzdHlsZTogJ3dpZHRoOiAxMDAlJ30sICdNZXRyaWNzJyldKSxcbiAgICAgICAgICAgbShcImxpXCIsW20oQnV0dG9uLCB7aWQ6ICdidG5PdXRwdXRzJywgc3R5bGU6ICd3aWR0aDogMTAwJSd9LCAnT3V0cHV0JyldKSxcbiAgICAgICAgICAgXSkpLFxuIC8qICAgICBtKFwiLmJ0bi1ncm91cC5idG4tZ3JvdXAtanVzdGlmaWVkI21vZGVsR3JvdXBbc3R5bGU9bWFyZ2luLXRvcDogLjVlbV1cIixcbiAgICAgICAgbShCdXR0b24sIHtpZDogJ2J0bk1vZGVscycsIHN0eWxlOiAnd2lkdGg6IDMzJSd9LCAnTW9kZWxzJyksXG4gICAgICAgIG0oQnV0dG9uLCB7aWQ6ICdidG5TZXR4Jywgc3R5bGU6ICd3aWR0aDogMzQlJ30sICdTZXQgQ292YXIuJyksXG4gICAgICAgIG0oQnV0dG9uLCB7aWQ6ICdidG5SZXN1bHRzJywgc3R5bGU6ICd3aWR0aDogMzMlJ30sICdSZXN1bHRzJyksXG4gICAgICAgIG0oQnV0dG9uLCB7aWQ6ICdidG5UeXBlJywgc3R5bGU6ICd3aWR0aDogMjUlOyBkaXNwbGF5OiBub25lJ30sICdUYXNrIFR5cGUnKSxcbiAgICAgICAgbShCdXR0b24sIHtpZDogJ2J0blN1YnR5cGUnLCBzdHlsZTogJ3dpZHRoOiAyNSU7IGRpc3BsYXk6IG5vbmUnfSwgJ1N1YnR5cGUnKSxcbiAgICAgICAgbShCdXR0b24sIHtpZDogJ2J0bk1ldHJpY3MnLCBzdHlsZTogJ3dpZHRoOiAyNSU7IGRpc3BsYXk6IG5vbmUnfSwgJ01ldHJpY3MnKSxcbiAgICAgICAgbShCdXR0b24sIHtpZDogJ2J0bk91dHB1dHMnLCBzdHlsZTogJ3dpZHRoOiAyNSU7IGRpc3BsYXk6IG5vbmUnfSwgJ091dHB1dHMnKSksICAgKi9cbiAgICAgIG0oYCNyZXN1bHRzW3N0eWxlPWRpc3BsYXk6ICR7b3IoJ3JpZ2h0JywgJ2J0blJlc3VsdHMnKX07IG1hcmdpbi10b3A6IC41ZW1dYCxcbiAgICAgICAgbShcIiNyZXN1bHRzVmlldy5jb250YWluZXJbc3R5bGU9ZmxvYXQ6IHJpZ2h0OyBvdmVyZmxvdzogYXV0bzsgd2lkdGg6IDgwJTsgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7IHdoaXRlLXNwYWNlOiBub3dyYXBdXCIpLFxuICAgICAgICBtKCcjbW9kZWxWaWV3W3N0eWxlPWRpc3BsYXk6IG5vbmU7IGZsb2F0OiBsZWZ0OyB3aWR0aDogMjAlOyBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZV0nKSxcbiAgICAgICAgbShcInAjcmVzdWx0c0hvbGRlcltzdHlsZT1wYWRkaW5nOiAuNWVtIDFlbV1cIikpLFxuICAgICAgbShgI3NldHhbc3R5bGU9ZGlzcGxheTogJHtvcigncmlnaHQnLCAnYnRuU2V0eCcpfV1gLFxuICAgICAgICBtKCcjc2V0eExlZnRBbGxbc3R5bGU9ZGlzcGxheTpibG9jazsgZmxvYXQ6IGxlZnQ7IHdpZHRoOiAzMCU7IGhlaWdodDoxMDAlOyBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZV0nLFxuICAgICAgICAgIG0oJyNzZXR4TGVmdFtzdHlsZT1kaXNwbGF5OmJsb2NrOyBmbG9hdDogbGVmdDsgd2lkdGg6IDEwMCU7IGhlaWdodDo5NSU7IG92ZXJmbG93OmF1dG87IGJhY2tncm91bmQtY29sb3I6IHdoaXRlXScpKSxcbiAgICAgICAgbSgnI3NldHhSaWdodEFsbFtzdHlsZT1kaXNwbGF5OmJsb2NrOyBmbG9hdDogbGVmdDsgd2lkdGg6IDcwJTsgaGVpZ2h0OjEwMCU7IGJhY2tncm91bmQtY29sb3I6IHdoaXRlXScsXG4gICAgICAgICAgbSgnI3NldHhSaWdodFRvcFtzdHlsZT1kaXNwbGF5OmJsb2NrOyBmbG9hdDogbGVmdDsgd2lkdGg6IDEwMCU7IGhlaWdodDo2NSU7IG92ZXJmbG93OmF1dG87IGJhY2tncm91bmQtY29sb3I6IHdoaXRlXScsXG4gICAgICAgICAgICBtKCcjc2V0eE1pZGRsZVtzdHlsZT1kaXNwbGF5OmJsb2NrOyBmbG9hdDogbGVmdDsgd2lkdGg6IDcwJTsgaGVpZ2h0OjEwMCU7IGJhY2tncm91bmQtY29sb3I6IHdoaXRlXScpLFxuICAgICAgICAgICAgbSgnI3NldHhSaWdodFtzdHlsZT1kaXNwbGF5OmJsb2NrOyBmbG9hdDogcmlnaHQ7IHdpZHRoOiAzMCU7IGhlaWdodDoxMDAlOyBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZV0nKSksXG4gICAgICAgIG0oJyNzZXR4UmlnaHRCb3R0b21bc3R5bGU9ZGlzcGxheTpibG9jazsgZmxvYXQ6IGxlZnQ7IHdpZHRoOiAxMDAlOyBoZWlnaHQ6MzUlOyBvdmVyZmxvdzphdXRvOyBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZV0nLFxuICAgICAgICAgIG0oJyNzZXR4UmlnaHRCb3R0b21MZWZ0W3N0eWxlPWRpc3BsYXk6YmxvY2s7IGZsb2F0OiBsZWZ0OyB3aWR0aDogNzUlOyBoZWlnaHQ6MTAwJTsgYmFja2dyb3VuZC1jb2xvcjogd2hpdGVdJyksXG4gICAgICAgICAgbSgnI3NldHhSaWdodEJvdHRvbU1pZGRsZVtzdHlsZT1kaXNwbGF5OmJsb2NrOyBmbG9hdDogbGVmdDsgd2lkdGg6IDE1JTsgaGVpZ2h0OjEwMCU7IGJhY2tncm91bmQtY29sb3I6IHdoaXRlXScsXG4gICAgICAgICAgICBtKEJ1dHRvbiwge1xuICAgICAgICAgICAgICBpZDogJ2J0bkV4ZWN1dGVQaXBlJyxcbiAgICAgICAgICAgICAgY2xhc3NlczogJ2J0bi1kZWZhdWx0LmxhZGRhLWJ1dHRvbltkYXRhLXNwaW5uZXItY29sb3I9IzAwMDAwMF1bZGF0YS1zdHlsZT16b29tLWluXScsXG4gICAgICAgICAgICAgIG9uY2xpY2s6IF8gPT4gYXBwLmV4ZWN1dGVwaXBlbGluZSgnYnRuRXhlY3V0ZVBpcGUnKSxcbiAgICAgICAgICAgICAgc3R5bGU6IGBkaXNwbGF5OmlubGluZTsgZmxvYXQ6IGxlZnQ7IG1hcmdpbi1yaWdodDogMTBweGAsXG4gICAgICAgICAgICAgIHRpdGxlOiAnRXhlY3V0ZSBwaXBlbGluZS4nfSxcbiAgICAgICAgICAgICAgbSgnc3Bhbi5sYWRkYS1sYWJlbFtzdHlsZT1wb2ludGVyLWV2ZW50czogbm9uZV0nLCAnRXhlY3V0ZScpKSksXG4gICAgICAgICAgbSgnI3NldHhSaWdodEJvdHRvbVJpZ2h0W3N0eWxlPWRpc3BsYXk6YmxvY2s7IGZsb2F0OiBsZWZ0OyB3aWR0aDogMTAlOyBoZWlnaHQ6MTAwJTsgYmFja2dyb3VuZC1jb2xvcjogd2hpdGVdJykpKSksXG4gICAgICBtKGAjbW9kZWxzW3N0eWxlPWRpc3BsYXk6ICR7b3IoJ3JpZ2h0JywgJ2J0bk1vZGVscycpfTsgcGFkZGluZzogNnB4IDEycHg7IHRleHQtYWxpZ246IGNlbnRlcl1gKSxcbiAgICAgIG0oYCN0eXBlc1tzdHlsZT1kaXNwbGF5OiAke29yKCdyaWdodCcsICdidG5UeXBlJyl9OyBwYWRkaW5nOiA2cHggMTJweDsgdGV4dC1hbGlnbjogY2VudGVyXWApLFxuICAgICAgbShgI3N1YnR5cGVzW3N0eWxlPWRpc3BsYXk6ICR7b3IoJ3JpZ2h0JywgJ2J0blN1YnR5cGUnKX07IHBhZGRpbmc6IDZweCAxMnB4OyB0ZXh0LWFsaWduOiBjZW50ZXJdYCksXG4gICAgICBtKGAjbWV0cmljc1tzdHlsZT1kaXNwbGF5OiAke29yKCdyaWdodCcsICdidG5NZXRyaWNzJyl9OyBwYWRkaW5nOiA2cHggMTJweDsgdGV4dC1hbGlnbjogY2VudGVyXWApLFxuICAgICAgbShgI291dHB1dHNbc3R5bGU9ZGlzcGxheTogJHtvcigncmlnaHQnLCAnYnRuT3V0cHV0cycpfTsgcGFkZGluZzogNnB4IDEycHg7IHRleHQtYWxpZ246IGNlbnRlcl1gKSk7XG5cblxuXG5sZXQgdGlja2VyID0gbW9kZSA9PiB7XG4gICAgbGV0IGxpbmsgPSBuYW1lID0+IG0oYGEke25hbWUgPT09IG1vZGUgPyAnLmFjdGl2ZScgOiAnJ31baHJlZj0vJHtuYW1lfV1bc3R5bGU9bWFyZ2luLXJpZ2h0OiAwLjVlbV1gLCB7b25jcmVhdGU6IG0ucm91dGUubGlua30sIG5hbWVbMF0udG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSkpO1xuICAgIHJldHVybiBtKCcjdGlja2VyW3N0eWxlPWJhY2tncm91bmQ6ICNGOUY5Rjk7IGJvdHRvbTogMDsgaGVpZ2h0OiA0MHB4OyBwb3NpdGlvbjogZml4ZWQ7IHdpZHRoOiAxMDAlOyBib3JkZXItdG9wOiAxcHggc29saWQgI0FEQURBRF0nLFxuICAgICAgICBsaW5rKCdtb2RlbCcpLFxuICAgICAgICBsaW5rKCdleHBsb3JlJyksXG4gICAgICAgIG0oXCJhI2xvZ0lEW2hyZWY9c29tZWxpbmtdW3RhcmdldD1fYmxhbmtdW3N0eWxlPW1hcmdpbi1yaWdodDogMC41ZW1dXCIsIFwiUmVwbGljYXRpb25cIikpO1xufTtcblxuXG5jbGFzcyBCb2R5IHtcbiAgICBvbmluaXQoKSB7XG4gICAgICAgIHRoaXMuYWJvdXQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jaXRlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2l0ZUhpZGRlbiA9IGZhbHNlO1xuICAgIH1cblxuICAgIG9uY3JlYXRlKCkge1xuICAgICAgICBsZXQgZXh0cmFjdCA9IChuYW1lLCBrZXksIG9mZnNldCwgcmVwbGFjZSkgPT4ge1xuICAgICAgICAgICAga2V5ID0ga2V5ICsgJz0nO1xuICAgICAgICAgICAgbGV0IGxvYyA9IHdpbmRvdy5sb2NhdGlvbi50b1N0cmluZygpO1xuICAgICAgICAgICAgbGV0IHZhbCA9IGxvYy5pbmRleE9mKGtleSkgPiAwID8gbG9jLnN1YnN0cmluZyhsb2MuaW5kZXhPZihrZXkpICsgb2Zmc2V0KSA6ICcnO1xuICAgICAgICAgICAgbGV0IGlkeCA9IHZhbC5pbmRleE9mKCcmJyk7XG4gICAgICAgICAgICB2YWwgPSBpZHggPiAwID8gdmFsLnN1YnN0cmluZygwLCBpZHgpIDogdmFsO1xuICAgICAgICAgICAgdmFsID0gdmFsLnJlcGxhY2UoJyMhL21vZGVsJywgJycpO1xuICAgICAgICAgICAgY29uc29sZS5sb2cobmFtZSwgJzogJywgdmFsKTtcbiAgICAgICAgICAgIGlmIChyZXBsYWNlKSB2YWwgPSB2YWxcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvJTI1L2csICclJylcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvJTNBL2csICc6JylcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvJTJGL2csICcvJyk7XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9O1xuICAgICAgICAvLyBsZXQgYXBpa2V5ID0gZXh0cmFjdCgnYXBpa2V5JywgJ2tleScsIDQpO1xuICAgICAgICBhcHAubWFpbihcbiAgICAgICAgICAgIGV4dHJhY3QoJ2ZpbGVpZCcsICdkZklkJywgNSksXG4gICAgICAgICAgICBleHRyYWN0KCdob3N0bmFtZScsICdob3N0JywgNSksXG4gICAgICAgICAgICBleHRyYWN0KCdkZGl1cmwnLCAnZGRpdXJsJywgNywgdHJ1ZSksXG4gICAgICAgICAgICBleHRyYWN0KCdkYXRhdXJsJywgJ2RhdGF1cmwnLCA4LCB0cnVlKSxcbiAgICAgICAgICAgIGV4dHJhY3QoJ2FwaWtleScsICdrZXknLCA0KSk7XG4gICAgfVxuXG4gICAgdmlldyh2bm9kZSkge1xuICAgICAgICBsZXQge21vZGV9ID0gdm5vZGUuYXR0cnM7XG4gICAgICAgIHJldHVybiBtKCdtYWluJyxcbiAgICAgICAgICAgIG0oXCJuYXYjbmF2YmFyLm5hdmJhci5uYXZiYXItZGVmYXVsdC5uYXZiYXItZml4ZWQtdG9wW3JvbGU9bmF2aWdhdGlvbl1cIixcbiAgICAgICAgICAgICAgbShcImEubmF2YmFyLWJyYW5kW3N0eWxlPW1hcmdpbi1sZWZ0OiAwXVwiLFxuICAgICAgICAgICAgICAgIG0oXCJpbWdbc3JjPS9zdGF0aWMvaW1hZ2VzL1R3b1JhdmVucy5wbmddW2FsdD1Ud29SYXZlbnNdW3dpZHRoPTEwMF1bc3R5bGU9bWFyZ2luLWxlZnQ6IDJlbTsgbWFyZ2luLXRvcDogLTAuNWVtXVwiLCB7XG4gICAgICAgICAgICAgICAgICBvbm1vdXNlb3ZlcjogXyA9PiB0aGlzLmFib3V0ID0gdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIG9ubW91c2VvdXQ6IF8gPT4gdGhpcy5hYm91dCA9IGZhbHNlfSkpLFxuICAgICAgICAgICAgICBtKCcjbmF2YmFyTmF2W3N0eWxlPXBhZGRpbmc6IDAuNWVtXScsXG4gICAgICAgICAgICAgICAgbSgnI2RhdGFGaWVsZC5maWVsZFtzdHlsZT1tYXJnaW4tdG9wOiAwLjVlbTsgdGV4dC1hbGlnbjogY2VudGVyXScsXG4gICAgICAgICAgICAgICAgICBtKCdoNCNkYXRhTmFtZVtzdHlsZT1kaXNwbGF5OiBpbmxpbmVdJywge1xuICAgICAgICAgICAgICAgICAgICBvbmNsaWNrOiBfID0+IHRoaXMuY2l0ZSA9IHRoaXMuY2l0ZUhpZGRlbiA9ICF0aGlzLmNpdGVIaWRkZW4sXG4gICAgICAgICAgICAgICAgICAgIG9ubW91c2VvdXQ6IF8gPT4gdGhpcy5jaXRlSGlkZGVuIHx8ICh0aGlzLmNpdGUgPSBmYWxzZSksXG4gICAgICAgICAgICAgICAgICAgIG9ubW91c2VvdmVyOiBfID0+IHRoaXMuY2l0ZSA9IHRydWV9LFxuICAgICAgICAgICAgICAgICAgICBcIkRhdGFzZXQgTmFtZVwiKSxcbiAgICAgICAgICAgICAgICAgIG0oYCNjaXRlLnBhbmVsLnBhbmVsLWRlZmF1bHRbc3R5bGU9ZGlzcGxheTogJHt0aGlzLmNpdGUgPyAnYmxvY2snIDogJ25vbmUnfTsgcG9zaXRpb246IGFic29sdXRlOyByaWdodDogNTAlOyB3aWR0aDogMzgwcHg7IHRleHQtYWxpZ246IGxlZnQ7IHotaW5kZXg6IDUwXWAsXG4gICAgICAgICAgICAgICAgICAgIG0oXCIucGFuZWwtYm9keVwiKSksXG4gICAgICAgICAgICAgICAgICBtKFwiYnV0dG9uI2J0bkVzdGltYXRlLmJ0bi5idG4tc3VjY2Vzcy5sYWRkYS1idXR0b24ubmF2YmFyLXJpZ2h0W2RhdGEtc3Bpbm5lci1jb2xvcj0jMDAwMDAwXVtkYXRhLXN0eWxlPXpvb20taW5dW3N0eWxlPW1hcmdpbi1sZWZ0OiAyZW07IG1hcmdpbi1yaWdodDogMWVtXVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIG9uY2xpY2s6IF8gPT4gYXBwLmVzdGltYXRlKCdidG5Fc3RpbWF0ZScpfSxcbiAgICAgICAgICAgICAgICAgICAgbShcInNwYW4ubGFkZGEtbGFiZWxcIiwgbW9kZSA/ICdFeHBsb3JlJyA6ICdTb2x2ZSBUaGlzIFByb2JsZW0nKSksXG4gICAgICAgICAgICAgICAgICBtKFwiYnV0dG9uI2J0blRBMi5idG4uYnRuLWRlZmF1bHQubGFkZGEtYnV0dG9uLm5hdmJhci1yaWdodFtkYXRhLXNwaW5uZXItY29sb3I9IzAwMDAwMF1bZGF0YS1zdHlsZT16b29tLWluXVtzdHlsZT1tYXJnaW4tbGVmdDogMC41ZW07IG1hcmdpbi1yaWdodDogMWVtXVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIG9uY2xpY2s6IF8gPT4gYXBwLmhlbHBtYXRlcmlhbHMoJ21hbnVhbCcpfSxcbiAgICAgICAgICAgICAgICAgICAgJ0hlbHAgTWFudWFsICcsbShcInNwYW4uZ2x5cGhpY29uLmdseXBoaWNvbi1ib29rW3N0eWxlPWNvbG9yOiAjODE4MTgxOyBmb250LXNpemU6IDFlbTsgcG9pbnRlci1ldmVudHM6IG5vbmVdXCIpKSxcbiAgICAgICAgICAgICAgICAgIG0oXCJidXR0b24jYnRuVEEyLmJ0bi5idG4tZGVmYXVsdC5sYWRkYS1idXR0b24ubmF2YmFyLXJpZ2h0W2RhdGEtc3Bpbm5lci1jb2xvcj0jMDAwMDAwXVtkYXRhLXN0eWxlPXpvb20taW5dW3N0eWxlPW1hcmdpbi1sZWZ0OiAxNWVtOyBtYXJnaW4tcmlnaHQ6IDAuNWVtXVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIG9uY2xpY2s6IF8gPT4gYXBwLmhlbHBtYXRlcmlhbHMoJ3ZpZGVvJyl9LFxuICAgICAgICAgICAgICAgICAgICAnSGVscCBWaWRlbyAnLG0oXCJzcGFuLmdseXBoaWNvbi5nbHlwaGljb24tZXhwYW5kW3N0eWxlPWNvbG9yOiAjODE4MTgxOyBmb250LXNpemU6IDFlbTsgcG9pbnRlci1ldmVudHM6IG5vbmVdXCIpKSxcbiAgICAgICAgICAgICAgICAgIG0oXCJidXR0b24jYnRuUmVzZXQuYnRuLmJ0bi1kZWZhdWx0Lm5hdmJhci1yaWdodFt0aXRsZT1SZXNldF1bc3R5bGU9bWFyZ2luLWxlZnQ6IDIuMGVtXVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIG9uY2xpY2s6IGFwcC5yZXNldH0sXG4gICAgICAgICAgICAgICAgICAgIG0oXCJzcGFuLmdseXBoaWNvbi5nbHlwaGljb24tcmVwZWF0W3N0eWxlPWNvbG9yOiAjODE4MTgxOyBmb250LXNpemU6IDFlbTsgcG9pbnRlci1ldmVudHM6IG5vbmVdXCIpKSxcbiAgICAgICAgICAgICAgICAgIG0oXCJidXR0b24jYnRuRW5kU2Vzc2lvbi5idG4uYnRuLWRlZmF1bHQubmF2YmFyLXJpZ2h0W3RpdGxlPU1hcmsgUHJvYmxlbSBGaW5pc2hlZF1bc3R5bGU9bWFyZ2luLWxlZnQ6IDIuMGVtXVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIG9uY2xpY2s6IF89PiBhcHAuZW5kc2Vzc2lvbigpfSxcbiAgICAgICAgICAgICAgICAgICAgbShcInNwYW4ubGFkZGEtbGFiZWxcIiwgJ01hcmsgUHJvYmxlbSBGaW5pc2hlZCcpKSxcbiAgICAgICAgICAgICAgICAgIG0oJyN0cmFuc2Zvcm1hdGlvbnMudHJhbnNmb3JtVG9vbCcsIHtcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICdDb25zdHJ1Y3QgdHJhbnNmb3JtYXRpb25zIG9mIGV4aXN0aW5nIHZhcmlhYmxlcyB1c2luZyB2YWxpZCBSIHN5bnRheC4gRm9yIGV4YW1wbGUsIGFzc3VtaW5nIGEgdmFyaWFibGUgbmFtZWQgZCwgeW91IGNhbiBlbnRlciBcImxvZyhkKVwiIG9yIFwiZF4yXCIuJ30pKSksXG4gICAgICAgICAgICAgIG0oYCNhYm91dC5wYW5lbC5wYW5lbC1kZWZhdWx0W3N0eWxlPWRpc3BsYXk6ICR7dGhpcy5hYm91dCA/ICdibG9jaycgOiAnbm9uZSd9OyBsZWZ0OiAxNDBweDsgcG9zaXRpb246IGFic29sdXRlOyB3aWR0aDogNTAwcHg7IHotaW5kZXg6IDUwXWAsXG4gICAgICAgICAgICAgICAgbSgnLnBhbmVsLWJvZHknLFxuICAgICAgICAgICAgICAgICAgJ1R3b1JhdmVucyB2MC4xIFwiRGFsbGFzXCIgLS0gVGhlIE5vcnNlIGdvZCBPZGluIGhhZCB0d28gdGFsa2luZyByYXZlbnMgYXMgYWR2aXNvcnMsIHdobyB3b3VsZCBmbHkgb3V0IGludG8gdGhlIHdvcmxkIGFuZCByZXBvcnQgYmFjayBhbGwgdGhleSBvYnNlcnZlZC4gSW4gdGhlIE5vcnNlLCB0aGVpciBuYW1lcyB3ZXJlIFwiVGhvdWdodFwiIGFuZCBcIk1lbW9yeVwiLiBJbiBvdXIgY29taW5nIHJlbGVhc2UsIG91ciB0aG91Z2h0LXJhdmVuIGF1dG9tYXRpY2FsbHkgYWR2aXNlcyBvbiBzdGF0aXN0aWNhbCBtb2RlbCBzZWxlY3Rpb24sIHdoaWxlIG91ciBtZW1vcnktcmF2ZW4gYWNjdW11bGF0ZXMgcHJldmlvdXMgc3RhdGlzdGljYWwgbW9kZWxzIGZyb20gRGF0YXZlcnNlLCB0byBwcm92aWRlIGN1bW11bGF0aXZlIGd1aWRhbmNlIGFuZCBtZXRhLWFuYWx5c2lzLicpKSksXG4gICAgICAgICAgICBtKGAjbWFpbi5sZWZ0LmNhcm91c2VsLnNsaWRlLnN2Zy1sZWZ0cGFuZWwuc3ZnLXJpZ2h0cGFuZWxbc3R5bGU9b3ZlcmZsb3c6IGF1dG9dYCxcbiAgICAgICAgICAgICAgbShcIiNpbm5lcmNhcm91c2VsLmNhcm91c2VsLWlubmVyXCIsXG4gICAgICAgICAgICAgICAgbSgnI20wLml0ZW0uYWN0aXZlJyxcbiAgICAgICAgICAgICAgICAgIG0oJ3N2ZyN3aGl0ZXNwYWNlJykpKSxcbiAgICAgICAgICAgICAgbShcIiNzcGFjZXRvb2xzLnNwYWNlVG9vbFtzdHlsZT16LWluZGV4OiAxNl1cIixcbiAgICAgICAgICAgICAgICBtKFwiYnV0dG9uI2J0bkxvY2suYnRuLmFjdGl2ZVt0aXRsZT1Mb2NrIHNlbGVjdGlvbnMgb2YgcHJvYmxlbSBkZXNjcmlwdGlvbi5dXCIsIHtcbiAgICAgICAgICAgICAgICAgIG9uY2xpY2s6IGFwcC5sb2NrRGVzY3JpcHRpb259LFxuICAgICAgICAgICAgICAgICAgbShcInNwYW4uZ2x5cGhpY29uLmdseXBoaWNvbi1wZW5jaWxcIikpLFxuICAgICAgICAgICAgICAgIG0oXCJidXR0b24jYnRuRm9yY2UuYnRuLmJ0bi1kZWZhdWx0W3RpdGxlPVBpbiB0aGUgdmFyaWFibGUgcGViYmxlcyB0byB0aGUgcGFnZS5dXCIsIHtcbiAgICAgICAgICAgICAgICAgIG9uY2xpY2s6IGFwcC5mb3JjZVN3aXRjaH0sXG4gICAgICAgICAgICAgICAgICBtKFwic3Bhbi5nbHlwaGljb24uZ2x5cGhpY29uLXB1c2hwaW5cIikpLFxuICAgICAgICAgICAgICAgIG0oXCJidXR0b24jYnRuRXJhc2VyLmJ0bi5idG4tZGVmYXVsdFt0aXRsZT1XaXBlIGFsbCB2YXJpYWJsZXMgZnJvbSB0aGUgbW9kZWxpbmcgc3BhY2UuXVwiLCB7XG4gICAgICAgICAgICAgICAgICBvbmNsaWNrOiBhcHAuZXJhc2V9LFxuICAgICAgICAgICAgICAgICAgbShcInNwYW4uZ2x5cGhpY29uLmdseXBoaWNvbi1tYWduZXRcIikpKSxcbiAgICAgICAgICAgICAgbShTdWJwYW5lbCwge1xuICAgICAgICAgICAgICAgIHRpdGxlOiBcIkxlZ2VuZFwiLFxuICAgICAgICAgICAgICAgIGJ1dHRvbnM6IFtcbiAgICAgICAgICAgICAgICAgIFsndGltZUJ1dHRvbicsICd6dGltZScsICdUaW1lJ10sXG4gICAgICAgICAgICAgICAgICBbJ2NzQnV0dG9uJywgJ3pjcm9zcycsICdDcm9zcyBTZWMnXSxcbiAgICAgICAgICAgICAgICAgIFsnZHZCdXR0b24nLCAnemR2JywgJ0RlcCBWYXInXSxcbiAgICAgICAgICAgICAgICAgIFsnbm9tQnV0dG9uJywgJ3pub20nLCAnTm9tIFZhciddLFxuICAgICAgICAgICAgICAgICAgWydncjFCdXR0b24nLCAnemdyb3VwMScsICdHcm91cCAxJ10sXG4gICAgICAgICAgICAgICAgICBbJ2dyMkJ1dHRvbicsICd6Z3JvdXAyJywgJ0dyb3VwIDInXV19KSxcbiAgICAgICAgICAgICAgbShTdWJwYW5lbCwge3RpdGxlOiBcIkhpc3RvcnlcIn0pLFxuICAgICAgICAgICAgICB0aWNrZXIobW9kZSksXG4gICAgICAgICAgICAgIGxlZnRwYW5lbCgpLFxuICAgICAgICAgICAgICByaWdodHBhbmVsKG1vZGUpKSk7XG4gICAgfVxufVxuXG5tLnJvdXRlKGRvY3VtZW50LmJvZHksICcvbW9kZWwnLCB7XG4gICAgJy9tb2RlbCc6IHtyZW5kZXI6ICgpID0+IG0oQm9keSl9LFxuICAgICcvZXhwbG9yZSc6IHtyZW5kZXI6ICgpID0+IG0oQm9keSwge21vZGU6ICdleHBsb3JlJ30pfVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9hc3NldHMvYXBwL2luZGV4LmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///12\n")},function(module,exports,__webpack_require__){"use strict";eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\nvar _typeof2 = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**! hopscotch - v0.3.1\n*\n* Copyright 2017 LinkedIn Corp. All rights reserved.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*     http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n(function (global, factory) {\n  ( false ? 'undefined' : _typeof2(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : global.hopscotch = factory();\n})(undefined, function () {\n  'use strict';\n\n  var _typeof = typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\" ? function (obj) {\n    return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);\n  } : function (obj) {\n    return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);\n  };\n\n  /* global document */\n\n  var Hopscotch;\n  var HopscotchBubble;\n  var HopscotchCalloutManager;\n  var HopscotchI18N;\n  var customI18N;\n  var customRenderer;\n  var customEscape;\n  var templateToUse = 'bubble_default';\n  var Sizzle = window.Sizzle || null;\n  var utils;\n  var callbacks;\n  var helpers;\n  var winLoadHandler;\n  var defaultOpts;\n  var winHopscotch;\n  var undefinedStr = 'undefined';\n  var waitingToStart = false;\n  var hasJquery = (typeof jQuery === 'undefined' ? 'undefined' : _typeof(jQuery)) !== undefinedStr;\n  var hasSessionStorage = false;\n  var isStorageWritable = false;\n  var validIdRegEx = /^[a-zA-Z]+[a-zA-Z0-9_-]*$/;\n  var rtlMatches = {\n    left: 'right',\n    right: 'left'\n  };\n\n  // If cookies are disabled, accessing sessionStorage can throw an error.\n  // sessionStorage could also throw an error in Safari on write (even though it exists).\n  // So, we'll try writing to sessionStorage to verify it's available.\n  try {\n    if (_typeof(window.sessionStorage) !== undefinedStr) {\n      hasSessionStorage = true;\n      sessionStorage.setItem('hopscotch.test.storage', 'ok');\n      sessionStorage.removeItem('hopscotch.test.storage');\n      isStorageWritable = true;\n    }\n  } catch (err) {}\n\n  defaultOpts = {\n    smoothScroll: true,\n    scrollDuration: 1000,\n    scrollTopMargin: 200,\n    showCloseButton: true,\n    showPrevButton: false,\n    showNextButton: true,\n    bubbleWidth: 280,\n    bubblePadding: 15,\n    arrowWidth: 20,\n    skipIfNoElement: true,\n    isRtl: false,\n    cookieName: 'hopscotch.tour.state'\n  };\n\n  if (!Array.isArray) {\n    Array.isArray = function (obj) {\n      return Object.prototype.toString.call(obj) === '[object Array]';\n    };\n  }\n\n  /**\n   * Called when the page is done loading.\n   *\n   * @private\n   */\n  winLoadHandler = function winLoadHandler() {\n    if (waitingToStart) {\n      winHopscotch.startTour();\n    }\n  };\n\n  /**\n   * utils\n   * =====\n   * A set of utility functions, mostly for standardizing to manipulate\n   * and extract information from the DOM. Basically these are things I\n   * would normally use jQuery for, but I don't want to require it for\n   * this framework.\n   *\n   * @private\n   */\n  utils = {\n    /**\n     * addClass\n     * ========\n     * Adds one or more classes to a DOM element.\n     *\n     * @private\n     */\n    addClass: function addClass(domEl, classToAdd) {\n      var domClasses, classToAddArr, setClass, i, len;\n\n      if (!domEl.className) {\n        domEl.className = classToAdd;\n      } else {\n        classToAddArr = classToAdd.split(/\\s+/);\n        domClasses = ' ' + domEl.className + ' ';\n        for (i = 0, len = classToAddArr.length; i < len; ++i) {\n          if (domClasses.indexOf(' ' + classToAddArr[i] + ' ') < 0) {\n            domClasses += classToAddArr[i] + ' ';\n          }\n        }\n        domEl.className = domClasses.replace(/^\\s+|\\s+$/g, '');\n      }\n    },\n\n    /**\n     * removeClass\n     * ===========\n     * Remove one or more classes from a DOM element.\n     *\n     * @private\n     */\n    removeClass: function removeClass(domEl, classToRemove) {\n      var domClasses, classToRemoveArr, currClass, i, len;\n\n      classToRemoveArr = classToRemove.split(/\\s+/);\n      domClasses = ' ' + domEl.className + ' ';\n      for (i = 0, len = classToRemoveArr.length; i < len; ++i) {\n        domClasses = domClasses.replace(' ' + classToRemoveArr[i] + ' ', ' ');\n      }\n      domEl.className = domClasses.replace(/^\\s+|\\s+$/g, '');\n    },\n\n    /**\n     * hasClass\n     * ========\n     * Determine if a given DOM element has a class.\n     */\n    hasClass: function hasClass(domEl, classToCheck) {\n      var classes;\n\n      if (!domEl.className) {\n        return false;\n      }\n      classes = ' ' + domEl.className + ' ';\n      return classes.indexOf(' ' + classToCheck + ' ') !== -1;\n    },\n\n    /**\n     * @private\n     */\n    getPixelValue: function getPixelValue(val) {\n      var valType = typeof val === 'undefined' ? 'undefined' : _typeof(val);\n      if (valType === 'number') {\n        return val;\n      }\n      if (valType === 'string') {\n        return parseInt(val, 10);\n      }\n      return 0;\n    },\n\n    /**\n     * Inspired by Python... returns val if it's defined, otherwise returns the default.\n     *\n     * @private\n     */\n    valOrDefault: function valOrDefault(val, valDefault) {\n      return (typeof val === 'undefined' ? 'undefined' : _typeof(val)) !== undefinedStr ? val : valDefault;\n    },\n\n    /**\n     * Invokes a single callback represented by an array.\n     * Example input: [\"my_fn\", \"arg1\", 2, \"arg3\"]\n     * @private\n     */\n    invokeCallbackArrayHelper: function invokeCallbackArrayHelper(arr) {\n      // Logic for a single callback\n      var fn;\n      if (Array.isArray(arr)) {\n        fn = helpers[arr[0]];\n        if (typeof fn === 'function') {\n          return fn.apply(this, arr.slice(1));\n        }\n      }\n    },\n\n    /**\n     * Invokes one or more callbacks. Array should have at most one level of nesting.\n     * Example input:\n     * [\"my_fn\", \"arg1\", 2, \"arg3\"]\n     * [[\"my_fn_1\", \"arg1\", \"arg2\"], [\"my_fn_2\", \"arg2-1\", \"arg2-2\"]]\n     * [[\"my_fn_1\", \"arg1\", \"arg2\"], function() { ... }]\n     * @private\n     */\n    invokeCallbackArray: function invokeCallbackArray(arr) {\n      var i, len;\n\n      if (Array.isArray(arr)) {\n        if (typeof arr[0] === 'string') {\n          // Assume there are no nested arrays. This is the one and only callback.\n          return utils.invokeCallbackArrayHelper(arr);\n        } else {\n          // assume an array\n          for (i = 0, len = arr.length; i < len; ++i) {\n            utils.invokeCallback(arr[i]);\n          }\n        }\n      }\n    },\n\n    /**\n     * Helper function for invoking a callback, whether defined as a function literal\n     * or an array that references a registered helper function.\n     * @private\n     */\n    invokeCallback: function invokeCallback(cb) {\n      if (typeof cb === 'function') {\n        return cb();\n      }\n      if (typeof cb === 'string' && helpers[cb]) {\n        // name of a helper\n        return helpers[cb]();\n      } else {\n        // assuming array\n        return utils.invokeCallbackArray(cb);\n      }\n    },\n\n    /**\n     * If stepCb (the step-specific helper callback) is passed in, then invoke\n     * it first. Then invoke tour-wide helper.\n     *\n     * @private\n     */\n    invokeEventCallbacks: function invokeEventCallbacks(evtType, stepCb) {\n      var cbArr = callbacks[evtType],\n          callback,\n          fn,\n          i,\n          len;\n\n      if (stepCb) {\n        return this.invokeCallback(stepCb);\n      }\n\n      for (i = 0, len = cbArr.length; i < len; ++i) {\n        this.invokeCallback(cbArr[i].cb);\n      }\n    },\n\n    /**\n     * @private\n     */\n    getScrollTop: function getScrollTop() {\n      var scrollTop;\n      if (_typeof(window.pageYOffset) !== undefinedStr) {\n        scrollTop = window.pageYOffset;\n      } else {\n        // Most likely IE <=8, which doesn't support pageYOffset\n        scrollTop = document.documentElement.scrollTop;\n      }\n      return scrollTop;\n    },\n\n    /**\n     * @private\n     */\n    getScrollLeft: function getScrollLeft() {\n      var scrollLeft;\n      if (_typeof(window.pageXOffset) !== undefinedStr) {\n        scrollLeft = window.pageXOffset;\n      } else {\n        // Most likely IE <=8, which doesn't support pageXOffset\n        scrollLeft = document.documentElement.scrollLeft;\n      }\n      return scrollLeft;\n    },\n\n    /**\n     * @private\n     */\n    getWindowHeight: function getWindowHeight() {\n      return window.innerHeight || document.documentElement.clientHeight;\n    },\n\n    /**\n     * @private\n     */\n    addEvtListener: function addEvtListener(el, evtName, fn) {\n      if (el) {\n        return el.addEventListener ? el.addEventListener(evtName, fn, false) : el.attachEvent('on' + evtName, fn);\n      }\n    },\n\n    /**\n     * @private\n     */\n    removeEvtListener: function removeEvtListener(el, evtName, fn) {\n      if (el) {\n        return el.removeEventListener ? el.removeEventListener(evtName, fn, false) : el.detachEvent('on' + evtName, fn);\n      }\n    },\n\n    documentIsReady: function documentIsReady() {\n      return document.readyState === 'complete';\n    },\n\n    /**\n     * @private\n     */\n    evtPreventDefault: function evtPreventDefault(evt) {\n      if (evt.preventDefault) {\n        evt.preventDefault();\n      } else if (event) {\n        event.returnValue = false;\n      }\n    },\n\n    /**\n     * @private\n     */\n    extend: function extend(obj1, obj2) {\n      var prop;\n      for (prop in obj2) {\n        if (obj2.hasOwnProperty(prop)) {\n          obj1[prop] = obj2[prop];\n        }\n      }\n    },\n\n    /**\n     * Helper function to get a single target DOM element. We will try to\n     * locate the DOM element through several ways, in the following order:\n     *\n     * 1) Passing the string into document.querySelector\n     * 2) Passing the string to jQuery, if it exists\n     * 3) Passing the string to Sizzle, if it exists\n     * 4) Calling document.getElementById if it is a plain id\n     *\n     * Default case is to assume the string is a plain id and call\n     * document.getElementById on it.\n     *\n     * @private\n     */\n    getStepTargetHelper: function getStepTargetHelper(target) {\n      var result = document.getElementById(target);\n\n      //Backwards compatibility: assume the string is an id\n      if (result) {\n        return result;\n      }\n      if (hasJquery) {\n        result = jQuery(target);\n        return result.length ? result[0] : null;\n      }\n      if (Sizzle) {\n        result = new Sizzle(target);\n        return result.length ? result[0] : null;\n      }\n      if (document.querySelector) {\n        try {\n          return document.querySelector(target);\n        } catch (err) {}\n      }\n      // Regex test for id. Following the HTML 4 spec for valid id formats.\n      // (http://www.w3.org/TR/html4/types.html#type-id)\n      if (/^#[a-zA-Z][\\w-_:.]*$/.test(target)) {\n        return document.getElementById(target.substring(1));\n      }\n\n      return null;\n    },\n\n    /**\n     * Given a step, returns the target DOM element associated with it. It is\n     * recommended to only assign one target per step. However, there are\n     * some use cases which require multiple step targets to be supplied. In\n     * this event, we will use the first target in the array that we can\n     * locate on the page. See the comments for getStepTargetHelper for more\n     * information.\n     *\n     * @private\n     */\n    getStepTarget: function getStepTarget(step) {\n      var queriedTarget;\n\n      if (!step || !step.target) {\n        return null;\n      }\n\n      if (typeof step.target === 'string') {\n        //Just one target to test. Check and return its results.\n        return utils.getStepTargetHelper(step.target);\n      } else if (Array.isArray(step.target)) {\n        // Multiple items to check. Check each and return the first success.\n        // Assuming they are all strings.\n        var i, len;\n\n        for (i = 0, len = step.target.length; i < len; i++) {\n          if (typeof step.target[i] === 'string') {\n            queriedTarget = utils.getStepTargetHelper(step.target[i]);\n\n            if (queriedTarget) {\n              return queriedTarget;\n            }\n          }\n        }\n        return null;\n      }\n\n      // Assume that the step.target is a DOM element\n      return step.target;\n    },\n\n    /**\n     * Convenience method for getting an i18n string. Returns custom i18n value\n     * or the default i18n value if no custom value exists.\n     *\n     * @private\n     */\n    getI18NString: function getI18NString(key) {\n      return customI18N[key] || HopscotchI18N[key];\n    },\n\n    // Tour session persistence for multi-page tours. Uses HTML5 sessionStorage if available, then\n    // falls back to using cookies.\n    //\n    // The following cookie-related logic is borrowed from:\n    // http://www.quirksmode.org/js/cookies.html\n\n    /**\n     * @private\n     */\n    setState: function setState(name, value, days) {\n      var expires = '',\n          date;\n\n      if (hasSessionStorage && isStorageWritable) {\n        try {\n          sessionStorage.setItem(name, value);\n        } catch (err) {\n          isStorageWritable = false;\n          this.setState(name, value, days);\n        }\n      } else {\n        if (hasSessionStorage) {\n          //Clear out existing sessionStorage key so the new value we set to cookie gets read.\n          //(If we're here, we've run into an error while trying to write to sessionStorage).\n          sessionStorage.removeItem(name);\n        }\n        if (days) {\n          date = new Date();\n          date.setTime(date.getTime() + days * 24 * 60 * 60 * 1000);\n          expires = '; expires=' + date.toGMTString();\n        }\n        document.cookie = name + '=' + value + expires + '; path=/';\n      }\n    },\n\n    /**\n     * @private\n     */\n    getState: function getState(name) {\n      var nameEQ = name + '=',\n          ca = document.cookie.split(';'),\n          i,\n          c,\n          state;\n\n      //return value from session storage if we have it\n      if (hasSessionStorage) {\n        state = sessionStorage.getItem(name);\n        if (state) {\n          return state;\n        }\n      }\n\n      //else, try cookies\n      for (i = 0; i < ca.length; i++) {\n        c = ca[i];\n        while (c.charAt(0) === ' ') {\n          c = c.substring(1, c.length);\n        }\n        if (c.indexOf(nameEQ) === 0) {\n          state = c.substring(nameEQ.length, c.length);\n          break;\n        }\n      }\n\n      return state;\n    },\n\n    /**\n     * @private\n     */\n    clearState: function clearState(name) {\n      if (hasSessionStorage) {\n        sessionStorage.removeItem(name);\n      } else {\n        this.setState(name, '', -1);\n      }\n    },\n\n    /**\n     * Originally called it orientation, but placement is more intuitive.\n     * Allowing both for now for backwards compatibility.\n     * @private\n     */\n    normalizePlacement: function normalizePlacement(step) {\n      if (!step.placement && step.orientation) {\n        step.placement = step.orientation;\n      }\n    },\n\n    /**\n     * If step is right-to-left enabled, flip the placement and xOffset, but only once.\n     * @private\n     */\n    flipPlacement: function flipPlacement(step) {\n      if (step.isRtl && !step._isFlipped) {\n        var props = ['orientation', 'placement'],\n            prop,\n            i;\n        if (step.xOffset) {\n          step.xOffset = -1 * this.getPixelValue(step.xOffset);\n        }\n        for (i in props) {\n          prop = props[i];\n          if (step.hasOwnProperty(prop) && rtlMatches.hasOwnProperty(step[prop])) {\n            step[prop] = rtlMatches[step[prop]];\n          }\n        }\n        step._isFlipped = true;\n      }\n    }\n  };\n\n  utils.addEvtListener(window, 'load', winLoadHandler);\n\n  callbacks = {\n    next: [],\n    prev: [],\n    start: [],\n    end: [],\n    show: [],\n    error: [],\n    close: []\n  };\n\n  /**\n   * helpers\n   * =======\n   * A map of functions to be used as callback listeners. Functions are\n   * added to and removed from the map using the functions\n   * Hopscotch.registerHelper() and Hopscotch.unregisterHelper().\n   */\n  helpers = {};\n\n  HopscotchI18N = {\n    stepNums: null,\n    nextBtn: 'Next',\n    prevBtn: 'Back',\n    doneBtn: 'Done',\n    skipBtn: 'Skip',\n    closeTooltip: 'Close'\n  };\n\n  customI18N = {}; // Developer's custom i18n strings goes here.\n\n  /**\n   * HopscotchBubble\n   *\n   * @class The HopscotchBubble class represents the view of a bubble. This class is also used for Hopscotch callouts.\n   */\n  HopscotchBubble = function HopscotchBubble(opt) {\n    this.init(opt);\n  };\n\n  HopscotchBubble.prototype = {\n    isShowing: false,\n\n    currStep: undefined,\n\n    /**\n     * setPosition\n     *\n     * Sets the position of the bubble using the bounding rectangle of the\n     * target element and the orientation and offset information specified by\n     * the JSON.\n     */\n    setPosition: function setPosition(step) {\n      var bubbleBoundingHeight,\n          bubbleBoundingWidth,\n          boundingRect,\n          top,\n          left,\n          arrowOffset,\n          verticalLeftPosition,\n          targetEl = utils.getStepTarget(step),\n          el = this.element,\n          arrowEl = this.arrowEl,\n          arrowPos = step.isRtl ? 'right' : 'left';\n\n      utils.flipPlacement(step);\n      utils.normalizePlacement(step);\n\n      bubbleBoundingWidth = el.offsetWidth;\n      bubbleBoundingHeight = el.offsetHeight;\n      utils.removeClass(el, 'fade-in-down fade-in-up fade-in-left fade-in-right');\n\n      // SET POSITION\n      boundingRect = targetEl.getBoundingClientRect();\n\n      verticalLeftPosition = step.isRtl ? boundingRect.right - bubbleBoundingWidth : boundingRect.left;\n\n      if (step.placement === 'top') {\n        top = boundingRect.top - bubbleBoundingHeight - this.opt.arrowWidth;\n        left = verticalLeftPosition;\n      } else if (step.placement === 'bottom') {\n        top = boundingRect.bottom + this.opt.arrowWidth;\n        left = verticalLeftPosition;\n      } else if (step.placement === 'left') {\n        top = boundingRect.top;\n        left = boundingRect.left - bubbleBoundingWidth - this.opt.arrowWidth;\n      } else if (step.placement === 'right') {\n        top = boundingRect.top;\n        left = boundingRect.right + this.opt.arrowWidth;\n      } else {\n        throw new Error('Bubble placement failed because step.placement is invalid or undefined!');\n      }\n\n      // SET (OR RESET) ARROW OFFSETS\n      if (step.arrowOffset !== 'center') {\n        arrowOffset = utils.getPixelValue(step.arrowOffset);\n      } else {\n        arrowOffset = step.arrowOffset;\n      }\n      if (!arrowOffset) {\n        arrowEl.style.top = '';\n        arrowEl.style[arrowPos] = '';\n      } else if (step.placement === 'top' || step.placement === 'bottom') {\n        arrowEl.style.top = '';\n        if (arrowOffset === 'center') {\n          arrowEl.style[arrowPos] = Math.floor(bubbleBoundingWidth / 2 - arrowEl.offsetWidth / 2) + 'px';\n        } else {\n          // Numeric pixel value\n          arrowEl.style[arrowPos] = arrowOffset + 'px';\n        }\n      } else if (step.placement === 'left' || step.placement === 'right') {\n        arrowEl.style[arrowPos] = '';\n        if (arrowOffset === 'center') {\n          arrowEl.style.top = Math.floor(bubbleBoundingHeight / 2 - arrowEl.offsetHeight / 2) + 'px';\n        } else {\n          // Numeric pixel value\n          arrowEl.style.top = arrowOffset + 'px';\n        }\n      }\n\n      // HORIZONTAL OFFSET\n      if (step.xOffset === 'center') {\n        left = boundingRect.left + targetEl.offsetWidth / 2 - bubbleBoundingWidth / 2;\n      } else {\n        left += utils.getPixelValue(step.xOffset);\n      }\n      // VERTICAL OFFSET\n      if (step.yOffset === 'center') {\n        top = boundingRect.top + targetEl.offsetHeight / 2 - bubbleBoundingHeight / 2;\n      } else {\n        top += utils.getPixelValue(step.yOffset);\n      }\n\n      // ADJUST TOP FOR SCROLL POSITION\n      if (!step.fixedElement) {\n        top += utils.getScrollTop();\n        left += utils.getScrollLeft();\n      }\n\n      // ACCOUNT FOR FIXED POSITION ELEMENTS\n      el.style.position = step.fixedElement ? 'fixed' : 'absolute';\n\n      el.style.top = top + 'px';\n      el.style.left = left + 'px';\n    },\n\n    /**\n     * Renders the bubble according to the step JSON.\n     *\n     * @param {Object} step Information defining how the bubble should look.\n     * @param {Number} idx The index of the step in the tour. Not used for callouts.\n     * @param {Function} callback Function to be invoked after rendering is finished.\n     */\n    render: function render(step, idx, callback) {\n      var el = this.element,\n          tourSpecificRenderer,\n          customTourData,\n          unsafe,\n          currTour,\n          totalSteps,\n          totalStepsI18n,\n          nextBtnText,\n          isLast,\n          i,\n          opts;\n\n      // Cache current step information.\n      if (step) {\n        this.currStep = step;\n      } else if (this.currStep) {\n        step = this.currStep;\n      }\n\n      // Check current tour for total number of steps and custom render data\n      if (this.opt.isTourBubble) {\n        currTour = winHopscotch.getCurrTour();\n        if (currTour) {\n          customTourData = currTour.customData;\n          tourSpecificRenderer = currTour.customRenderer;\n          step.isRtl = step.hasOwnProperty('isRtl') ? step.isRtl : currTour.hasOwnProperty('isRtl') ? currTour.isRtl : this.opt.isRtl;\n          unsafe = currTour.unsafe;\n          if (Array.isArray(currTour.steps)) {\n            totalSteps = currTour.steps.length;\n            totalStepsI18n = this._getStepI18nNum(this._getStepNum(totalSteps - 1));\n            isLast = this._getStepNum(idx) === this._getStepNum(totalSteps - 1);\n          }\n        }\n      } else {\n        customTourData = step.customData;\n        tourSpecificRenderer = step.customRenderer;\n        unsafe = step.unsafe;\n        step.isRtl = step.hasOwnProperty('isRtl') ? step.isRtl : this.opt.isRtl;\n      }\n\n      // Determine label for next button\n      if (isLast) {\n        nextBtnText = utils.getI18NString('doneBtn');\n      } else if (step.showSkip) {\n        nextBtnText = utils.getI18NString('skipBtn');\n      } else {\n        nextBtnText = utils.getI18NString('nextBtn');\n      }\n\n      utils.flipPlacement(step);\n      utils.normalizePlacement(step);\n\n      this.placement = step.placement;\n\n      // Setup the configuration options we want to pass along to the template\n      opts = {\n        i18n: {\n          prevBtn: utils.getI18NString('prevBtn'),\n          nextBtn: nextBtnText,\n          closeTooltip: utils.getI18NString('closeTooltip'),\n          stepNum: this._getStepI18nNum(this._getStepNum(idx)),\n          numSteps: totalStepsI18n\n        },\n        buttons: {\n          showPrev: utils.valOrDefault(step.showPrevButton, this.opt.showPrevButton) && this._getStepNum(idx) > 0,\n          showNext: utils.valOrDefault(step.showNextButton, this.opt.showNextButton),\n          showCTA: utils.valOrDefault(step.showCTAButton && step.ctaLabel, false),\n          ctaLabel: step.ctaLabel,\n          showClose: utils.valOrDefault(this.opt.showCloseButton, true)\n        },\n        step: {\n          num: idx,\n          isLast: utils.valOrDefault(isLast, false),\n          title: step.title || '',\n          content: step.content || '',\n          isRtl: step.isRtl,\n          placement: step.placement,\n          padding: utils.valOrDefault(step.padding, this.opt.bubblePadding),\n          width: utils.getPixelValue(step.width) || this.opt.bubbleWidth,\n          customData: step.customData || {}\n        },\n        tour: {\n          isTour: this.opt.isTourBubble,\n          numSteps: totalSteps,\n          unsafe: utils.valOrDefault(unsafe, false),\n          customData: customTourData || {}\n        }\n      };\n\n      // Render the bubble's content.\n      // Use tour renderer if available, then the global customRenderer if defined.\n      if (typeof tourSpecificRenderer === 'function') {\n        el.innerHTML = tourSpecificRenderer(opts);\n      } else if (typeof tourSpecificRenderer === 'string') {\n        if (!winHopscotch.templates || typeof winHopscotch.templates[tourSpecificRenderer] !== 'function') {\n          throw new Error('Bubble rendering failed - template \"' + tourSpecificRenderer + '\" is not a function.');\n        }\n        el.innerHTML = winHopscotch.templates[tourSpecificRenderer](opts);\n      } else if (customRenderer) {\n        el.innerHTML = customRenderer(opts);\n      } else {\n        if (!winHopscotch.templates || typeof winHopscotch.templates[templateToUse] !== 'function') {\n          throw new Error('Bubble rendering failed - template \"' + templateToUse + '\" is not a function.');\n        }\n        el.innerHTML = winHopscotch.templates[templateToUse](opts);\n      }\n\n      // Find arrow among new child elements.\n      var children = el.children;\n      var numChildren = children.length;\n      var node;\n      for (i = 0; i < numChildren; i++) {\n        node = children[i];\n\n        if (utils.hasClass(node, 'hopscotch-arrow')) {\n          this.arrowEl = node;\n        }\n      }\n\n      // Set z-index and arrow placement\n      el.style.zIndex = typeof step.zindex === 'number' ? step.zindex : '';\n      this._setArrow(step.placement);\n\n      // Set bubble positioning\n      // Make sure we're using visibility:hidden instead of display:none for height/width calculations.\n      this.hide(false);\n      this.setPosition(step);\n\n      // only want to adjust window scroll for non-fixed elements\n      if (callback) {\n        callback(!step.fixedElement);\n      }\n\n      return this;\n    },\n    /**\n     * Get step number considering steps that were skipped because their target wasn't found\n     *\n     * @private\n     */\n    _getStepNum: function _getStepNum(idx) {\n      var skippedStepsCount = 0,\n          stepIdx,\n          skippedSteps = winHopscotch.getSkippedStepsIndexes(),\n          i,\n          len = skippedSteps.length;\n      //count number of steps skipped before current step\n      for (i = 0; i < len; i++) {\n        stepIdx = skippedSteps[i];\n        if (stepIdx < idx) {\n          skippedStepsCount++;\n        }\n      }\n      return idx - skippedStepsCount;\n    },\n    /**\n     * Get the I18N step number for the current step.\n     *\n     * @private\n     */\n    _getStepI18nNum: function _getStepI18nNum(idx) {\n      var stepNumI18N = utils.getI18NString('stepNums');\n      if (stepNumI18N && idx < stepNumI18N.length) {\n        idx = stepNumI18N[idx];\n      } else {\n        idx = idx + 1;\n      }\n      return idx;\n    },\n\n    /**\n     * Sets which side the arrow is on.\n     *\n     * @private\n     */\n    _setArrow: function _setArrow(placement) {\n      utils.removeClass(this.arrowEl, 'down up right left');\n\n      // Whatever the orientation is, we want to arrow to appear\n      // \"opposite\" of the orientation. E.g., a top orientation\n      // requires a bottom arrow.\n      if (placement === 'top') {\n        utils.addClass(this.arrowEl, 'down');\n      } else if (placement === 'bottom') {\n        utils.addClass(this.arrowEl, 'up');\n      } else if (placement === 'left') {\n        utils.addClass(this.arrowEl, 'right');\n      } else if (placement === 'right') {\n        utils.addClass(this.arrowEl, 'left');\n      }\n    },\n\n    /**\n     * @private\n     */\n    _getArrowDirection: function _getArrowDirection() {\n      if (this.placement === 'top') {\n        return 'down';\n      }\n      if (this.placement === 'bottom') {\n        return 'up';\n      }\n      if (this.placement === 'left') {\n        return 'right';\n      }\n      if (this.placement === 'right') {\n        return 'left';\n      }\n    },\n\n    show: function show() {\n      var self = this,\n          fadeClass = 'fade-in-' + this._getArrowDirection(),\n          fadeDur = 1000;\n\n      utils.removeClass(this.element, 'hide');\n      utils.addClass(this.element, fadeClass);\n      setTimeout(function () {\n        utils.removeClass(self.element, 'invisible');\n      }, 50);\n      setTimeout(function () {\n        utils.removeClass(self.element, fadeClass);\n      }, fadeDur);\n      this.isShowing = true;\n      return this;\n    },\n\n    hide: function hide(remove) {\n      var el = this.element;\n\n      remove = utils.valOrDefault(remove, true);\n      el.style.top = '';\n      el.style.left = '';\n\n      // display: none\n      if (remove) {\n        utils.addClass(el, 'hide');\n        utils.removeClass(el, 'invisible');\n      }\n      // opacity: 0\n      else {\n          utils.removeClass(el, 'hide');\n          utils.addClass(el, 'invisible');\n        }\n      utils.removeClass(el, 'animate fade-in-up fade-in-down fade-in-right fade-in-left');\n      this.isShowing = false;\n      return this;\n    },\n\n    destroy: function destroy() {\n      var el = this.element;\n\n      if (el) {\n        el.parentNode.removeChild(el);\n      }\n      utils.removeEvtListener(el, 'click', this.clickCb);\n    },\n\n    _handleBubbleClick: function _handleBubbleClick(evt) {\n      var action;\n\n      // Override evt for IE8 as IE8 doesn't pass event but binds it to window\n      evt = evt || window.event; // get window.event if argument is falsy (in IE)\n\n      // get srcElement if target is falsy (IE)\n      var targetElement = evt.target || evt.srcElement;\n\n      //Recursively look up the parent tree until we find a match\n      //with one of the classes we're looking for, or the triggering element.\n      function findMatchRecur(el) {\n        /* We're going to make the assumption that we're not binding\n          * multiple event classes to the same element.\n          * (next + previous = wait... err... what?)\n          *\n          * In the odd event we end up with an element with multiple\n          * possible matches, the following priority order is applied:\n          * hopscotch-cta, hopscotch-next, hopscotch-prev, hopscotch-close\n          */\n        if (el === evt.currentTarget) {\n          return null;\n        }\n        if (utils.hasClass(el, 'hopscotch-cta')) {\n          return 'cta';\n        }\n        if (utils.hasClass(el, 'hopscotch-next')) {\n          return 'next';\n        }\n        if (utils.hasClass(el, 'hopscotch-prev')) {\n          return 'prev';\n        }\n        if (utils.hasClass(el, 'hopscotch-close')) {\n          return 'close';\n        }\n        /*else*/return findMatchRecur(el.parentElement);\n      }\n\n      action = findMatchRecur(targetElement);\n\n      //Now that we know what action we should take, let's take it.\n      if (action === 'cta') {\n        if (!this.opt.isTourBubble) {\n          // This is a callout. Close the callout when CTA is clicked.\n          winHopscotch.getCalloutManager().removeCallout(this.currStep.id);\n        }\n        // Call onCTA callback if one is provided\n        if (this.currStep.onCTA) {\n          utils.invokeCallback(this.currStep.onCTA);\n        }\n      } else if (action === 'next') {\n        winHopscotch.nextStep(true);\n      } else if (action === 'prev') {\n        winHopscotch.prevStep(true);\n      } else if (action === 'close') {\n        if (this.opt.isTourBubble) {\n          var currStepNum = winHopscotch.getCurrStepNum(),\n              currTour = winHopscotch.getCurrTour(),\n              doEndCallback = currStepNum === currTour.steps.length - 1;\n\n          utils.invokeEventCallbacks('close');\n\n          winHopscotch.endTour(true, doEndCallback);\n        } else {\n          if (this.opt.onClose) {\n            utils.invokeCallback(this.opt.onClose);\n          }\n          if (this.opt.id && !this.opt.isTourBubble) {\n            // Remove via the HopscotchCalloutManager.\n            // removeCallout() calls HopscotchBubble.destroy internally.\n            winHopscotch.getCalloutManager().removeCallout(this.opt.id);\n          } else {\n            this.destroy();\n          }\n        }\n\n        utils.evtPreventDefault(evt);\n      }\n      //Otherwise, do nothing. We didn't click on anything relevant.\n    },\n\n    init: function init(initOpt) {\n      var el = document.createElement('div'),\n          self = this,\n          resizeCooldown = false,\n\n      // for updating after window resize\n      onWinResize,\n          _appendToBody2,\n          children,\n          numChildren,\n          node,\n          i,\n          currTour,\n          opt;\n\n      //Register DOM element for this bubble.\n      this.element = el;\n\n      //Merge bubble options with defaults.\n      opt = {\n        showPrevButton: defaultOpts.showPrevButton,\n        showNextButton: defaultOpts.showNextButton,\n        bubbleWidth: defaultOpts.bubbleWidth,\n        bubblePadding: defaultOpts.bubblePadding,\n        arrowWidth: defaultOpts.arrowWidth,\n        isRtl: defaultOpts.isRtl,\n        showNumber: true,\n        isTourBubble: true\n      };\n      initOpt = (typeof initOpt === 'undefined' ? 'undefined' : _typeof(initOpt)) === undefinedStr ? {} : initOpt;\n      utils.extend(opt, initOpt);\n      this.opt = opt;\n\n      //Apply classes to bubble. Add \"animated\" for fade css animation\n      el.className = 'hopscotch-bubble animated';\n      if (!opt.isTourBubble) {\n        utils.addClass(el, 'hopscotch-callout no-number');\n      } else {\n        currTour = winHopscotch.getCurrTour();\n        if (currTour) {\n          utils.addClass(el, 'tour-' + currTour.id);\n        }\n      }\n\n      /**\n       * Not pretty, but IE8 doesn't support Function.bind(), so I'm\n       * relying on closures to keep a handle of \"this\".\n       * Reset position of bubble when window is resized\n       *\n       * @private\n       */\n      onWinResize = function onWinResize() {\n        if (resizeCooldown || !self.isShowing) {\n          return;\n        }\n\n        resizeCooldown = true;\n        setTimeout(function () {\n          self.setPosition(self.currStep);\n          resizeCooldown = false;\n        }, 100);\n      };\n\n      //Add listener to reset bubble position on window resize\n      utils.addEvtListener(window, 'resize', onWinResize);\n\n      //Create our click callback handler and keep a\n      //reference to it for later.\n      this.clickCb = function (evt) {\n        self._handleBubbleClick(evt);\n      };\n      utils.addEvtListener(el, 'click', this.clickCb);\n\n      //Hide the bubble by default\n      this.hide();\n\n      //Finally, append our new bubble to body once the DOM is ready.\n      if (utils.documentIsReady()) {\n        document.body.appendChild(el);\n      } else {\n        // Moz, webkit, Opera\n        if (document.addEventListener) {\n          _appendToBody2 = function appendToBody() {\n            document.removeEventListener('DOMContentLoaded', _appendToBody2);\n            window.removeEventListener('load', _appendToBody2);\n\n            document.body.appendChild(el);\n          };\n\n          document.addEventListener('DOMContentLoaded', _appendToBody2, false);\n        }\n        // IE\n        else {\n            _appendToBody2 = function _appendToBody() {\n              if (document.readyState === 'complete') {\n                document.detachEvent('onreadystatechange', _appendToBody2);\n                window.detachEvent('onload', _appendToBody2);\n                document.body.appendChild(el);\n              }\n            };\n\n            document.attachEvent('onreadystatechange', _appendToBody2);\n          }\n        utils.addEvtListener(window, 'load', _appendToBody2);\n      }\n    }\n  };\n\n  /**\n   * HopscotchCalloutManager\n   *\n   * @class Manages the creation and destruction of single callouts.\n   * @constructor\n   */\n  HopscotchCalloutManager = function HopscotchCalloutManager() {\n    var callouts = {},\n        calloutOpts = {};\n\n    /**\n     * createCallout\n     *\n     * Creates a standalone callout. This callout has the same API\n     * as a Hopscotch tour bubble.\n     *\n     * @param {Object} opt The options for the callout. For the most\n     * part, these are the same options as you would find in a tour\n     * step.\n     */\n    this.createCallout = function (opt) {\n      var callout;\n\n      if (opt.id) {\n        if (!validIdRegEx.test(opt.id)) {\n          throw new Error('Callout ID is using an invalid format. Use alphanumeric, underscores, and/or hyphens only. First character must be a letter.');\n        }\n        if (callouts[opt.id]) {\n          throw new Error('Callout by that id already exists. Please choose a unique id.');\n        }\n        if (!utils.getStepTarget(opt)) {\n          throw new Error('Must specify existing target element via \\'target\\' option.');\n        }\n        opt.showNextButton = opt.showPrevButton = false;\n        opt.isTourBubble = false;\n        callout = new HopscotchBubble(opt);\n        callouts[opt.id] = callout;\n        calloutOpts[opt.id] = opt;\n        callout.render(opt, null, function () {\n          callout.show();\n          if (opt.onShow) {\n            utils.invokeCallback(opt.onShow);\n          }\n        });\n      } else {\n        throw new Error('Must specify a callout id.');\n      }\n      return callout;\n    };\n\n    /**\n     * getCallout\n     *\n     * Returns a callout by its id.\n     *\n     * @param {String} id The id of the callout to fetch.\n     * @returns {Object} HopscotchBubble\n     */\n    this.getCallout = function (id) {\n      return callouts[id];\n    };\n\n    /**\n     * removeAllCallouts\n     *\n     * Removes all existing callouts.\n     */\n    this.removeAllCallouts = function () {\n      var calloutId;\n\n      for (calloutId in callouts) {\n        if (callouts.hasOwnProperty(calloutId)) {\n          this.removeCallout(calloutId);\n        }\n      }\n    };\n\n    /**\n     * removeCallout\n     *\n     * Removes an existing callout by id.\n     *\n     * @param {String} id The id of the callout to remove.\n     */\n    this.removeCallout = function (id) {\n      var callout = callouts[id];\n\n      callouts[id] = null;\n      calloutOpts[id] = null;\n      if (!callout) {\n        return;\n      }\n\n      callout.destroy();\n    };\n\n    /**\n     * refreshCalloutPositions\n     *\n     * Refresh the positions for all callouts known by the\n     * callout manager. Typically you'll use\n     * hopscotch.refreshBubblePosition() to refresh ALL\n     * bubbles instead of calling this directly.\n     */\n    this.refreshCalloutPositions = function () {\n      var calloutId, callout, opts;\n\n      for (calloutId in callouts) {\n        if (callouts.hasOwnProperty(calloutId) && calloutOpts.hasOwnProperty(calloutId)) {\n          callout = callouts[calloutId];\n          opts = calloutOpts[calloutId];\n          if (callout && opts) {\n            callout.setPosition(opts);\n          }\n        }\n      }\n    };\n  };\n\n  /**\n   * Hopscotch\n   *\n   * @class Creates the Hopscotch object. Used to manage tour progress and configurations.\n   * @constructor\n   * @param {Object} initOptions Options to be passed to `configure()`.\n   */\n  Hopscotch = function Hopscotch(initOptions) {\n    var self = this,\n\n    // for targetClickNextFn\n    bubble,\n        calloutMgr,\n        opt,\n        currTour,\n        currStepNum,\n        skippedSteps = {},\n        cookieTourId,\n        cookieTourStep,\n        cookieSkippedSteps = [],\n        _configure,\n\n\n    /**\n     * getBubble\n     *\n     * Singleton accessor function for retrieving or creating bubble object.\n     *\n     * @private\n     * @param setOptions {Boolean} when true, transfers configuration options to the bubble\n     * @returns {Object} HopscotchBubble\n     */\n    getBubble = function getBubble(setOptions) {\n      if (!bubble || !bubble.element || !bubble.element.parentNode) {\n        bubble = new HopscotchBubble(opt);\n      }\n      if (setOptions) {\n        utils.extend(bubble.opt, {\n          bubblePadding: getOption('bubblePadding'),\n          bubbleWidth: getOption('bubbleWidth'),\n          showNextButton: getOption('showNextButton'),\n          showPrevButton: getOption('showPrevButton'),\n          showCloseButton: getOption('showCloseButton'),\n          arrowWidth: getOption('arrowWidth'),\n          isRtl: getOption('isRtl')\n        });\n      }\n      return bubble;\n    },\n\n\n    /**\n     * Destroy the bubble currently associated with Hopscotch.\n     * This is done when we end the current tour.\n     *\n     * @private\n     */\n    destroyBubble = function destroyBubble() {\n      if (bubble) {\n        bubble.destroy();\n        bubble = null;\n      }\n    },\n\n\n    /**\n     * Convenience method for getting an option. Returns custom config option\n     * or the default config option if no custom value exists.\n     *\n     * @private\n     * @param name {String} config option name\n     * @returns {Object} config option value\n     */\n    getOption = function getOption(name) {\n      if (typeof opt === 'undefined') {\n        return defaultOpts[name];\n      }\n      return utils.valOrDefault(opt[name], defaultOpts[name]);\n    },\n\n\n    /**\n     * getCurrStep\n     *\n     * @private\n     * @returns {Object} the step object corresponding to the current value of currStepNum\n     */\n    getCurrStep = function getCurrStep() {\n      var step;\n\n      if (!currTour || currStepNum < 0 || currStepNum >= currTour.steps.length) {\n        step = null;\n      } else {\n        step = currTour.steps[currStepNum];\n      }\n\n      return step;\n    },\n\n\n    /**\n     * Used for nextOnTargetClick\n     *\n     * @private\n     */\n    targetClickNextFn = function targetClickNextFn() {\n      self.nextStep();\n    },\n\n\n    /**\n     * adjustWindowScroll\n     *\n     * Checks if the bubble or target element is partially or completely\n     * outside of the viewport. If it is, adjust the window scroll position\n     * to bring it back into the viewport.\n     *\n     * @private\n     * @param {Function} cb Callback to invoke after done scrolling.\n     */\n    adjustWindowScroll = function adjustWindowScroll(cb) {\n      var bubble = getBubble(),\n\n\n      // Calculate the bubble element top and bottom position\n      bubbleEl = bubble.element,\n          bubbleTop = utils.getPixelValue(bubbleEl.style.top),\n          bubbleBottom = bubbleTop + utils.getPixelValue(bubbleEl.offsetHeight),\n\n\n      // Calculate the target element top and bottom position\n      targetEl = utils.getStepTarget(getCurrStep()),\n          targetBounds = targetEl.getBoundingClientRect(),\n          targetElTop = targetBounds.top + utils.getScrollTop(),\n          targetElBottom = targetBounds.bottom + utils.getScrollTop(),\n\n\n      // The higher of the two: bubble or target\n      targetTop = bubbleTop < targetElTop ? bubbleTop : targetElTop,\n\n\n      // The lower of the two: bubble or target\n      targetBottom = bubbleBottom > targetElBottom ? bubbleBottom : targetElBottom,\n\n\n      // Calculate the current viewport top and bottom\n      windowTop = utils.getScrollTop(),\n          windowBottom = windowTop + utils.getWindowHeight(),\n\n\n      // This is our final target scroll value.\n      scrollToVal = targetTop - getOption('scrollTopMargin'),\n          scrollEl,\n          yuiAnim,\n          yuiEase,\n          direction,\n          scrollIncr,\n          scrollTimeout,\n          _scrollTimeoutFn;\n\n      // Target and bubble are both visible in viewport\n      if (targetTop >= windowTop && (targetTop <= windowTop + getOption('scrollTopMargin') || targetBottom <= windowBottom)) {\n        if (cb) {\n          cb();\n        } // HopscotchBubble.show\n      }\n\n      // Abrupt scroll to scroll target\n      else if (!getOption('smoothScroll')) {\n          window.scrollTo(0, scrollToVal);\n\n          if (cb) {\n            cb();\n          } // HopscotchBubble.show\n        }\n\n        // Smooth scroll to scroll target\n        else {\n            // Use YUI if it exists\n            if ((typeof YAHOO === 'undefined' ? 'undefined' : _typeof(YAHOO)) !== undefinedStr && _typeof(YAHOO.env) !== undefinedStr && _typeof(YAHOO.env.ua) !== undefinedStr && _typeof(YAHOO.util) !== undefinedStr && _typeof(YAHOO.util.Scroll) !== undefinedStr) {\n              scrollEl = YAHOO.env.ua.webkit ? document.body : document.documentElement;\n              yuiEase = YAHOO.util.Easing ? YAHOO.util.Easing.easeOut : undefined;\n              yuiAnim = new YAHOO.util.Scroll(scrollEl, {\n                scroll: { to: [0, scrollToVal] }\n              }, getOption('scrollDuration') / 1000, yuiEase);\n              yuiAnim.onComplete.subscribe(cb);\n              yuiAnim.animate();\n            }\n\n            // Use jQuery if it exists\n            else if (hasJquery) {\n                jQuery('body, html').animate({ scrollTop: scrollToVal }, getOption('scrollDuration'), cb);\n              }\n\n              // Use my crummy setInterval scroll solution if we're using plain, vanilla Javascript.\n              else {\n                  if (scrollToVal < 0) {\n                    scrollToVal = 0;\n                  }\n\n                  // 48 * 10 == 480ms scroll duration\n                  // make it slightly less than CSS transition duration because of\n                  // setInterval overhead.\n                  // To increase or decrease duration, change the divisor of scrollIncr.\n                  direction = windowTop > targetTop ? -1 : 1; // -1 means scrolling up, 1 means down\n                  scrollIncr = Math.abs(windowTop - scrollToVal) / (getOption('scrollDuration') / 10);\n                  _scrollTimeoutFn = function scrollTimeoutFn() {\n                    var scrollTop = utils.getScrollTop(),\n                        scrollTarget = scrollTop + direction * scrollIncr;\n\n                    if (direction > 0 && scrollTarget >= scrollToVal || direction < 0 && scrollTarget <= scrollToVal) {\n                      // Overshot our target. Just manually set to equal the target\n                      // and clear the interval\n                      scrollTarget = scrollToVal;\n                      if (cb) {\n                        cb();\n                      } // HopscotchBubble.show\n                      window.scrollTo(0, scrollTarget);\n                      return;\n                    }\n\n                    window.scrollTo(0, scrollTarget);\n\n                    if (utils.getScrollTop() === scrollTop) {\n                      // Couldn't scroll any further.\n                      if (cb) {\n                        cb();\n                      } // HopscotchBubble.show\n                      return;\n                    }\n\n                    // If we reached this point, that means there's still more to scroll.\n                    setTimeout(_scrollTimeoutFn, 10);\n                  };\n\n                  _scrollTimeoutFn();\n                }\n          }\n    },\n\n\n    /**\n     * goToStepWithTarget\n     *\n     * Helper function to increment the step number until a step is found where\n     * the step target exists or until we reach the end/beginning of the tour.\n     *\n     * @private\n     * @param {Number} direction Either 1 for incrementing or -1 for decrementing\n     * @param {Function} cb The callback function to be invoked when the step has been found\n     */\n    goToStepWithTarget = function goToStepWithTarget(direction, cb) {\n      var target, step, goToStepFn;\n\n      if (currStepNum + direction >= 0 && currStepNum + direction < currTour.steps.length) {\n\n        currStepNum += direction;\n        step = getCurrStep();\n\n        goToStepFn = function goToStepFn() {\n          target = utils.getStepTarget(step);\n\n          if (target) {\n            //this step was previously skipped, but now its target exists,\n            //remove this step from skipped steps set\n            if (skippedSteps[currStepNum]) {\n              delete skippedSteps[currStepNum];\n            }\n            // We're done! Return the step number via the callback.\n            cb(currStepNum);\n          } else {\n            //mark this step as skipped, since its target wasn't found\n            skippedSteps[currStepNum] = true;\n            // Haven't found a valid target yet. Recursively call\n            // goToStepWithTarget.\n            utils.invokeEventCallbacks('error');\n            goToStepWithTarget(direction, cb);\n          }\n        };\n\n        if (step.delay) {\n          setTimeout(goToStepFn, step.delay);\n        } else {\n          goToStepFn();\n        }\n      } else {\n        cb(-1); // signal that we didn't find any step with a valid target\n      }\n    },\n\n\n    /**\n     * changeStep\n     *\n     * Helper function to change step by going forwards or backwards 1.\n     * nextStep and prevStep are publicly accessible wrappers for this function.\n     *\n     * @private\n     * @param {Boolean} doCallbacks Flag for invoking onNext or onPrev callbacks\n     * @param {Number} direction Either 1 for \"next\" or -1 for \"prev\"\n     */\n    changeStep = function changeStep(doCallbacks, direction) {\n      var bubble = getBubble(),\n          self = this,\n          step,\n          origStep,\n          wasMultiPage,\n          changeStepCb;\n\n      bubble.hide();\n\n      doCallbacks = utils.valOrDefault(doCallbacks, true);\n\n      step = getCurrStep();\n\n      if (step.nextOnTargetClick) {\n        // Detach the listener when tour is moving to a different step\n        utils.removeEvtListener(utils.getStepTarget(step), 'click', targetClickNextFn);\n      }\n\n      origStep = step;\n      if (direction > 0) {\n        wasMultiPage = origStep.multipage;\n      } else {\n        wasMultiPage = currStepNum > 0 && currTour.steps[currStepNum - 1].multipage;\n      }\n\n      /**\n       * Callback for goToStepWithTarget\n       *\n       * @private\n       */\n      changeStepCb = function changeStepCb(stepNum) {\n        var doShowFollowingStep;\n\n        if (stepNum === -1) {\n          // Wasn't able to find a step with an existing element. End tour.\n          return this.endTour(true);\n        }\n\n        if (doCallbacks) {\n          if (direction > 0) {\n            doShowFollowingStep = utils.invokeEventCallbacks('next', origStep.onNext);\n          } else {\n            doShowFollowingStep = utils.invokeEventCallbacks('prev', origStep.onPrev);\n          }\n        }\n\n        // If the state of the tour is updated in a callback, assume the client\n        // doesn't want to go to next step since they specifically updated.\n        if (stepNum !== currStepNum) {\n          return;\n        }\n\n        if (wasMultiPage) {\n          // Update state for the next page\n          setStateHelper();\n\n          // Next step is on a different page, so no need to attempt to render it.\n          return;\n        }\n\n        doShowFollowingStep = utils.valOrDefault(doShowFollowingStep, true);\n\n        // If the onNext/onPrev callback returned false, halt the tour and\n        // don't show the next step.\n        if (doShowFollowingStep) {\n          this.showStep(stepNum);\n        } else {\n          // Halt tour (but don't clear state)\n          this.endTour(false);\n        }\n      };\n\n      if (!wasMultiPage && getOption('skipIfNoElement')) {\n        goToStepWithTarget(direction, function (stepNum) {\n          changeStepCb.call(self, stepNum);\n        });\n      } else if (currStepNum + direction >= 0 && currStepNum + direction < currTour.steps.length) {\n        // only try incrementing once, and invoke error callback if no target is found\n        currStepNum += direction;\n        step = getCurrStep();\n        if (!utils.getStepTarget(step) && !wasMultiPage) {\n          utils.invokeEventCallbacks('error');\n          return this.endTour(true, false);\n        }\n        changeStepCb.call(this, currStepNum);\n      } else if (currStepNum + direction === currTour.steps.length) {\n        return this.endTour();\n      }\n\n      return this;\n    },\n\n\n    /**\n     * loadTour\n     *\n     * Loads, but does not display, tour.\n     *\n     * @private\n     * @param tour The tour JSON object\n     */\n    loadTour = function loadTour(tour) {\n      var tmpOpt = {},\n          prop,\n          tourState,\n          tourStateValues;\n\n      // Set tour-specific configurations\n      for (prop in tour) {\n        if (tour.hasOwnProperty(prop) && prop !== 'id' && prop !== 'steps') {\n          tmpOpt[prop] = tour[prop];\n        }\n      }\n\n      //this.resetDefaultOptions(); // reset all options so there are no surprises\n      // TODO check number of config properties of tour\n      _configure.call(this, tmpOpt, true);\n\n      // Get existing tour state, if it exists.\n      tourState = utils.getState(getOption('cookieName'));\n      if (tourState) {\n        tourStateValues = tourState.split(':');\n        cookieTourId = tourStateValues[0]; // selecting tour is not supported by this framework.\n        cookieTourStep = tourStateValues[1];\n\n        if (tourStateValues.length > 2) {\n          cookieSkippedSteps = tourStateValues[2].split(',');\n        }\n\n        cookieTourStep = parseInt(cookieTourStep, 10);\n      }\n\n      return this;\n    },\n\n\n    /**\n     * Find the first step to show for a tour. (What is the first step with a\n     * target on the page?)\n     */\n    findStartingStep = function findStartingStep(startStepNum, savedSkippedSteps, cb) {\n      var step, target;\n\n      currStepNum = startStepNum || 0;\n      skippedSteps = savedSkippedSteps || {};\n      step = getCurrStep();\n      target = utils.getStepTarget(step);\n\n      if (target) {\n        // First step had an existing target.\n        cb(currStepNum);\n        return;\n      }\n\n      if (!target) {\n        // Previous target doesn't exist either. The user may have just\n        // clicked on a link that wasn't part of the tour. Another possibility is that\n        // the user clicked on the correct link, but the target is just missing for\n        // whatever reason. In either case, we should just advance until we find a step\n        // that has a target on the page or end the tour if we can't find such a step.\n        utils.invokeEventCallbacks('error');\n\n        //this step was skipped, since its target does not exist\n        skippedSteps[currStepNum] = true;\n\n        if (getOption('skipIfNoElement')) {\n          goToStepWithTarget(1, cb);\n          return;\n        } else {\n          currStepNum = -1;\n          cb(currStepNum);\n        }\n      }\n    },\n        showStepHelper = function showStepHelper(stepNum) {\n      var step = currTour.steps[stepNum],\n          bubble = getBubble(),\n          targetEl = utils.getStepTarget(step);\n\n      function showBubble() {\n        bubble.show();\n        utils.invokeEventCallbacks('show', step.onShow);\n      }\n\n      if (currStepNum !== stepNum && getCurrStep().nextOnTargetClick) {\n        // Detach the listener when tour is moving to a different step\n        utils.removeEvtListener(utils.getStepTarget(getCurrStep()), 'click', targetClickNextFn);\n      }\n\n      // Update bubble for current step\n      currStepNum = stepNum;\n\n      bubble.hide(false);\n\n      bubble.render(step, stepNum, function (adjustScroll) {\n        // when done adjusting window scroll, call showBubble helper fn\n        if (adjustScroll) {\n          adjustWindowScroll(showBubble);\n        } else {\n          showBubble();\n        }\n\n        // If we want to advance to next step when user clicks on target.\n        if (step.nextOnTargetClick) {\n          utils.addEvtListener(targetEl, 'click', targetClickNextFn);\n        }\n      });\n\n      setStateHelper();\n    },\n        setStateHelper = function setStateHelper() {\n      var cookieVal = currTour.id + ':' + currStepNum,\n          skipedStepIndexes = winHopscotch.getSkippedStepsIndexes();\n\n      if (skipedStepIndexes && skipedStepIndexes.length > 0) {\n        cookieVal += ':' + skipedStepIndexes.join(',');\n      }\n\n      utils.setState(getOption('cookieName'), cookieVal, 1);\n    },\n\n\n    /**\n     * init\n     *\n     * Initializes the Hopscotch object.\n     *\n     * @private\n     */\n    init = function init(initOptions) {\n      if (initOptions) {\n        //initOptions.cookieName = initOptions.cookieName || 'hopscotch.tour.state';\n        this.configure(initOptions);\n      }\n    };\n\n    /**\n     * getCalloutManager\n     *\n     * Gets the callout manager.\n     *\n     * @returns {Object} HopscotchCalloutManager\n     *\n     */\n    this.getCalloutManager = function () {\n      if ((typeof calloutMgr === 'undefined' ? 'undefined' : _typeof(calloutMgr)) === undefinedStr) {\n        calloutMgr = new HopscotchCalloutManager();\n      }\n\n      return calloutMgr;\n    };\n\n    /**\n     * startTour\n     *\n     * Begins the tour.\n     *\n     * @param {Object} tour The tour JSON object\n     * @stepNum {Number} stepNum __Optional__ The step number to start from\n     * @returns {Object} Hopscotch\n     *\n     */\n    this.startTour = function (tour, stepNum) {\n      var bubble,\n          currStepNum,\n          skippedSteps = {},\n          self = this;\n\n      // loadTour if we are calling startTour directly. (When we call startTour\n      // from window onLoad handler, we'll use currTour)\n      if (!currTour) {\n\n        // Sanity check! Is there a tour?\n        if (!tour) {\n          throw new Error('Tour data is required for startTour.');\n        }\n\n        // Check validity of tour ID. If invalid, throw an error.\n        if (!tour.id || !validIdRegEx.test(tour.id)) {\n          throw new Error('Tour ID is using an invalid format. Use alphanumeric, underscores, and/or hyphens only. First character must be a letter.');\n        }\n\n        currTour = tour;\n        loadTour.call(this, tour);\n      }\n\n      if ((typeof stepNum === 'undefined' ? 'undefined' : _typeof(stepNum)) !== undefinedStr) {\n        if (stepNum >= currTour.steps.length) {\n          throw new Error('Specified step number out of bounds.');\n        }\n        currStepNum = stepNum;\n      }\n\n      // If document isn't ready, wait for it to finish loading.\n      // (so that we can calculate positioning accurately)\n      if (!utils.documentIsReady()) {\n        waitingToStart = true;\n        return this;\n      }\n\n      if (typeof currStepNum === \"undefined\" && currTour.id === cookieTourId && (typeof cookieTourStep === 'undefined' ? 'undefined' : _typeof(cookieTourStep)) !== undefinedStr) {\n        currStepNum = cookieTourStep;\n        if (cookieSkippedSteps.length > 0) {\n          for (var i = 0, len = cookieSkippedSteps.length; i < len; i++) {\n            skippedSteps[cookieSkippedSteps[i]] = true;\n          }\n        }\n      } else if (!currStepNum) {\n        currStepNum = 0;\n      }\n\n      // Find the current step we should begin the tour on, and then actually start the tour.\n      findStartingStep(currStepNum, skippedSteps, function (stepNum) {\n        var target = stepNum !== -1 && utils.getStepTarget(currTour.steps[stepNum]);\n\n        if (!target) {\n          // Should we trigger onEnd callback? Let's err on the side of caution\n          // and not trigger it. Don't want weird stuff happening on a page that\n          // wasn't meant for the tour. Up to the developer to fix their tour.\n          self.endTour(false, false);\n          return;\n        }\n\n        utils.invokeEventCallbacks('start');\n\n        bubble = getBubble();\n        // TODO: do we still need this call to .hide()? No longer using opt.animate...\n        // Leaving it in for now to play it safe\n        bubble.hide(false); // make invisible for boundingRect calculations when opt.animate == true\n\n        self.isActive = true;\n\n        if (!utils.getStepTarget(getCurrStep())) {\n          // First step element doesn't exist\n          utils.invokeEventCallbacks('error');\n          if (getOption('skipIfNoElement')) {\n            self.nextStep(false);\n          }\n        } else {\n          self.showStep(stepNum);\n        }\n      });\n\n      return this;\n    };\n\n    /**\n     * showStep\n     *\n     * Skips to a specific step and renders the corresponding bubble.\n     *\n     * @stepNum {Number} stepNum The step number to show\n     * @returns {Object} Hopscotch\n     */\n    this.showStep = function (stepNum) {\n      var step = currTour.steps[stepNum],\n          prevStepNum = currStepNum;\n      if (!utils.getStepTarget(step)) {\n        currStepNum = stepNum;\n        utils.invokeEventCallbacks('error');\n        currStepNum = prevStepNum;\n        return;\n      }\n\n      if (step.delay) {\n        setTimeout(function () {\n          showStepHelper(stepNum);\n        }, step.delay);\n      } else {\n        showStepHelper(stepNum);\n      }\n      return this;\n    };\n\n    /**\n     * prevStep\n     *\n     * Jump to the previous step.\n     *\n     * @param {Boolean} doCallbacks Flag for invoking onPrev callback. Defaults to true.\n     * @returns {Object} Hopscotch\n     */\n    this.prevStep = function (doCallbacks) {\n      changeStep.call(this, doCallbacks, -1);\n      return this;\n    };\n\n    /**\n     * nextStep\n     *\n     * Jump to the next step.\n     *\n     * @param {Boolean} doCallbacks Flag for invoking onNext callback. Defaults to true.\n     * @returns {Object} Hopscotch\n     */\n    this.nextStep = function (doCallbacks) {\n      changeStep.call(this, doCallbacks, 1);\n      return this;\n    };\n\n    /**\n     * endTour\n     *\n     * Cancels out of an active tour.\n     *\n     * @param {Boolean} clearState Flag for clearing state. Defaults to true.\n     * @param {Boolean} doCallbacks Flag for invoking 'onEnd' callbacks. Defaults to true.\n     * @returns {Object} Hopscotch\n     */\n    this.endTour = function (clearState, doCallbacks) {\n      var bubble = getBubble(),\n          currentStep;\n\n      clearState = utils.valOrDefault(clearState, true);\n      doCallbacks = utils.valOrDefault(doCallbacks, true);\n\n      //remove event listener if current step had it added\n      if (currTour) {\n        currentStep = getCurrStep();\n        if (currentStep && currentStep.nextOnTargetClick) {\n          utils.removeEvtListener(utils.getStepTarget(currentStep), 'click', targetClickNextFn);\n        }\n      }\n\n      currStepNum = 0;\n      cookieTourStep = undefined;\n\n      bubble.hide();\n      if (clearState) {\n        utils.clearState(getOption('cookieName'));\n      }\n      if (this.isActive) {\n        this.isActive = false;\n\n        if (currTour && doCallbacks) {\n          utils.invokeEventCallbacks('end');\n        }\n      }\n\n      this.removeCallbacks(null, true);\n      this.resetDefaultOptions();\n      destroyBubble();\n\n      currTour = null;\n\n      return this;\n    };\n\n    /**\n     * getCurrTour\n     *\n     * @return {Object} The currently loaded tour.\n     */\n    this.getCurrTour = function () {\n      return currTour;\n    };\n\n    /**\n     * getCurrTarget\n     *\n     * @return {Object} The currently visible target.\n     */\n    this.getCurrTarget = function () {\n      return utils.getStepTarget(getCurrStep());\n    };\n\n    /**\n     * getCurrStepNum\n     *\n     * @return {number} The current zero-based step number.\n     */\n    this.getCurrStepNum = function () {\n      return currStepNum;\n    };\n\n    /**\n     * getSkippedStepsIndexes\n     *\n     * @return {Array} Array of skipped step indexes\n     */\n    this.getSkippedStepsIndexes = function () {\n      var skippedStepsIdxArray = [],\n          stepIds;\n\n      for (stepIds in skippedSteps) {\n        skippedStepsIdxArray.push(stepIds);\n      }\n\n      return skippedStepsIdxArray;\n    };\n\n    /**\n     * refreshBubblePosition\n     *\n     * Tell hopscotch that the position of the current tour element changed\n     * and the bubble therefore needs to be redrawn. Also refreshes position\n     * of all Hopscotch Callouts on the page.\n     *\n     * @returns {Object} Hopscotch\n     */\n    this.refreshBubblePosition = function () {\n      var currStep = getCurrStep();\n      if (currStep) {\n        getBubble().setPosition(currStep);\n      }\n      this.getCalloutManager().refreshCalloutPositions();\n      return this;\n    };\n\n    /**\n     * listen\n     *\n     * Adds a callback for one of the event types. Valid event types are:\n     *\n     * @param {string} evtType \"start\", \"end\", \"next\", \"prev\", \"show\", \"close\", or \"error\"\n     * @param {Function} cb The callback to add.\n     * @param {Boolean} isTourCb Flag indicating callback is from a tour definition.\n     *    For internal use only!\n     * @returns {Object} Hopscotch\n     */\n    this.listen = function (evtType, cb, isTourCb) {\n      if (evtType) {\n        callbacks[evtType].push({ cb: cb, fromTour: isTourCb });\n      }\n      return this;\n    };\n\n    /**\n     * unlisten\n     *\n     * Removes a callback for one of the event types, e.g. 'start', 'next', etc.\n     *\n     * @param {string} evtType \"start\", \"end\", \"next\", \"prev\", \"show\", \"close\", or \"error\"\n     * @param {Function} cb The callback to remove.\n     * @returns {Object} Hopscotch\n     */\n    this.unlisten = function (evtType, cb) {\n      var evtCallbacks = callbacks[evtType],\n          i,\n          len;\n\n      for (i = 0, len = evtCallbacks.length; i < len; ++i) {\n        if (evtCallbacks[i].cb === cb) {\n          evtCallbacks.splice(i, 1);\n        }\n      }\n      return this;\n    };\n\n    /**\n     * removeCallbacks\n     *\n     * Remove callbacks for hopscotch events. If tourOnly is set to true, only\n     * removes callbacks specified by a tour (callbacks set by external calls\n     * to hopscotch.configure or hopscotch.listen will not be removed). If\n     * evtName is null or undefined, callbacks for all events will be removed.\n     *\n     * @param {string} evtName Optional Event name for which we should remove callbacks\n     * @param {boolean} tourOnly Optional flag to indicate we should only remove callbacks added\n     *    by a tour. Defaults to false.\n     * @returns {Object} Hopscotch\n     */\n    this.removeCallbacks = function (evtName, tourOnly) {\n      var cbArr, i, len, evt;\n\n      // If evtName is null or undefined, remove callbacks for all events.\n      for (evt in callbacks) {\n        if (!evtName || evtName === evt) {\n          if (tourOnly) {\n            cbArr = callbacks[evt];\n            for (i = 0, len = cbArr.length; i < len; ++i) {\n              if (cbArr[i].fromTour) {\n                cbArr.splice(i--, 1);\n                --len;\n              }\n            }\n          } else {\n            callbacks[evt] = [];\n          }\n        }\n      }\n      return this;\n    };\n\n    /**\n     * registerHelper\n     * ==============\n     * Registers a helper function to be used as a callback function.\n     *\n     * @param {String} id The id of the function.\n     * @param {Function} id The callback function.\n     */\n    this.registerHelper = function (id, fn) {\n      if (typeof id === 'string' && typeof fn === 'function') {\n        helpers[id] = fn;\n      }\n    };\n\n    this.unregisterHelper = function (id) {\n      helpers[id] = null;\n    };\n\n    this.invokeHelper = function (id) {\n      var args = [],\n          i,\n          len;\n\n      for (i = 1, len = arguments.length; i < len; ++i) {\n        args.push(arguments[i]);\n      }\n      if (helpers[id]) {\n        helpers[id].call(null, args);\n      }\n    };\n\n    /**\n     * setCookieName\n     *\n     * Sets the cookie name (or sessionStorage name, if supported) used for multi-page\n     * tour persistence.\n     *\n     * @param {String} name The cookie name\n     * @returns {Object} Hopscotch\n     */\n    this.setCookieName = function (name) {\n      opt.cookieName = name;\n      return this;\n    };\n\n    /**\n     * resetDefaultOptions\n     *\n     * Resets all configuration options to default.\n     *\n     * @returns {Object} Hopscotch\n     */\n    this.resetDefaultOptions = function () {\n      opt = {};\n      return this;\n    };\n\n    /**\n     * resetDefaultI18N\n     *\n     * Resets all i18n.\n     *\n     * @returns {Object} Hopscotch\n     */\n    this.resetDefaultI18N = function () {\n      customI18N = {};\n      return this;\n    };\n\n    /**\n     * hasState\n     *\n     * Returns state from a previous tour run, if it exists.\n     *\n     * @returns {String} State of previous tour run, or empty string if none exists.\n     */\n    this.getState = function () {\n      return utils.getState(getOption('cookieName'));\n    };\n\n    /**\n     * _configure\n     *\n     * @see this.configure\n     * @private\n     * @param options\n     * @param {Boolean} isTourOptions Should be set to true when setting options from a tour definition.\n     */\n    _configure = function _configure(options, isTourOptions) {\n      var bubble,\n          events = ['next', 'prev', 'start', 'end', 'show', 'error', 'close'],\n          eventPropName,\n          callbackProp,\n          i,\n          len;\n\n      if (!opt) {\n        this.resetDefaultOptions();\n      }\n\n      utils.extend(opt, options);\n\n      if (options) {\n        utils.extend(customI18N, options.i18n);\n      }\n\n      for (i = 0, len = events.length; i < len; ++i) {\n        // At this point, options[eventPropName] may have changed from an array\n        // to a function.\n        eventPropName = 'on' + events[i].charAt(0).toUpperCase() + events[i].substring(1);\n        if (options[eventPropName]) {\n          this.listen(events[i], options[eventPropName], isTourOptions);\n        }\n      }\n\n      bubble = getBubble(true);\n\n      return this;\n    };\n\n    /**\n     * configure\n     *\n     * <pre>\n     * VALID OPTIONS INCLUDE...\n     *\n     * - bubbleWidth:     Number   - Default bubble width. Defaults to 280.\n     * - bubblePadding:   Number   - DEPRECATED. Default bubble padding. Defaults to 15.\n     * - smoothScroll:    Boolean  - should the page scroll smoothly to the next\n     *                               step? Defaults to TRUE.\n     * - scrollDuration:  Number   - Duration of page scroll. Only relevant when\n     *                               smoothScroll is set to true. Defaults to\n     *                               1000ms.\n     * - scrollTopMargin: NUMBER   - When the page scrolls, how much space should there\n     *                               be between the bubble/targetElement and the top\n     *                               of the viewport? Defaults to 200.\n     * - showCloseButton: Boolean  - should the tour bubble show a close (X) button?\n     *                               Defaults to TRUE.\n     * - showPrevButton:  Boolean  - should the bubble have the Previous button?\n     *                               Defaults to FALSE.\n     * - showNextButton:  Boolean  - should the bubble have the Next button?\n     *                               Defaults to TRUE.\n     * - arrowWidth:      Number   - Default arrow width. (space between the bubble\n     *                               and the targetEl) Used for bubble position\n     *                               calculation. Only use this option if you are\n     *                               using your own custom CSS. Defaults to 20.\n     * - skipIfNoElement  Boolean  - If a specified target element is not found,\n     *                               should we skip to the next step? Defaults to\n     *                               TRUE.\n     * - onNext:          Function - A callback to be invoked after every click on\n     *                               a \"Next\" button.\n     * - isRtl:           Boolean  - Set to true when instantiating in a right-to-left\n     *                               language environment, or if mirrored positioning is\n     *                               needed.\n     *                               Defaults to FALSE.\n     *\n     * - i18n:            Object   - For i18n purposes. Allows you to change the\n     *                               text of button labels and step numbers.\n     * - i18n.stepNums:   Array\\<String\\> - Provide a list of strings to be shown as\n     *                               the step number, based on index of array. Unicode\n     *                               characters are supported. (e.g., ['&#x4e00;',\n     *                               '&#x4e8c;', '&#x4e09;']) If there are more steps\n     *                               than provided numbers, Arabic numerals\n     *                               ('4', '5', '6', etc.) will be used as default.\n     * // =========\n     * // CALLBACKS\n     * // =========\n     * - onNext:          Function - Invoked after every click on a \"Next\" button.\n     * - onPrev:          Function - Invoked after every click on a \"Prev\" button.\n     * - onStart:         Function - Invoked when the tour is started.\n     * - onEnd:           Function - Invoked when the tour ends.\n     * - onClose:         Function - Invoked when the user closes the tour before finishing.\n     * - onError:         Function - Invoked when the specified target element doesn't exist on the page.\n     *\n     * // ====\n     * // I18N\n     * // ====\n     * i18n:              OBJECT      - For i18n purposes. Allows you to change the text\n     *                                  of button labels and step numbers.\n     * i18n.nextBtn:      STRING      - Label for next button\n     * i18n.prevBtn:      STRING      - Label for prev button\n     * i18n.doneBtn:      STRING      - Label for done button\n     * i18n.skipBtn:      STRING      - Label for skip button\n     * i18n.closeTooltip: STRING      - Text for close button tooltip\n     * i18n.stepNums:   ARRAY<STRING> - Provide a list of strings to be shown as\n     *                                  the step number, based on index of array. Unicode\n     *                                  characters are supported. (e.g., ['&#x4e00;',\n     *                                  '&#x4e8c;', '&#x4e09;']) If there are more steps\n     *                                  than provided numbers, Arabic numerals\n     *                                  ('4', '5', '6', etc.) will be used as default.\n     * </pre>\n     *\n     * @example hopscotch.configure({ scrollDuration: 1000, scrollTopMargin: 150 });\n     * @example\n     * hopscotch.configure({\n     *   scrollTopMargin: 150,\n     *   onStart: function() {\n     *     alert(\"Have fun!\");\n     *   },\n     *   i18n: {\n     *     nextBtn: 'Forward',\n     *     prevBtn: 'Previous'\n     *     closeTooltip: 'Quit'\n     *   }\n     * });\n     *\n     * @param {Object} options A hash of configuration options.\n     * @returns {Object} Hopscotch\n     */\n    this.configure = function (options) {\n      return _configure.call(this, options, false);\n    };\n\n    /**\n     * Set the template that should be used for rendering Hopscotch bubbles.\n     * If a string, it's assumed your template is available in the\n     * hopscotch.templates namespace.\n     *\n     * @param {String|Function(obj)} The template to use for rendering.\n     * @returns {Object} The Hopscotch object (for chaining).\n     */\n    this.setRenderer = function (render) {\n      var typeOfRender = typeof render === 'undefined' ? 'undefined' : _typeof(render);\n\n      if (typeOfRender === 'string') {\n        templateToUse = render;\n        customRenderer = undefined;\n      } else if (typeOfRender === 'function') {\n        customRenderer = render;\n      }\n      return this;\n    };\n\n    /**\n     * Sets the escaping method to be used by JST templates.\n     *\n     * @param {Function} - The escape method to use.\n     * @returns {Object} The Hopscotch object (for chaining).\n     */\n    this.setEscaper = function (esc) {\n      if (typeof esc === 'function') {\n        customEscape = esc;\n      }\n      return this;\n    };\n\n    init.call(this, initOptions);\n  };\n\n  winHopscotch = new Hopscotch();\n\n  // Template includes, placed inside a closure to ensure we don't\n  // end up declaring our shim globally.\n  (function () {\n    var _ = {};\n    /*\n     * Adapted from the Underscore.js framework. Check it out at\n     * https://github.com/jashkenas/underscore\n     */\n    _.escape = function (str) {\n      if (customEscape) {\n        return customEscape(str);\n      }\n\n      if (str == null) return '';\n      return ('' + str).replace(new RegExp('[&<>\"\\']', 'g'), function (match) {\n        if (match == '&') {\n          return '&amp;';\n        }\n        if (match == '<') {\n          return '&lt;';\n        }\n        if (match == '>') {\n          return '&gt;';\n        }\n        if (match == '\"') {\n          return '&quot;';\n        }\n        if (match == \"'\") {\n          return '&#x27;';\n        }\n      });\n    };\n\n    this[\"templates\"] = this[\"templates\"] || {};\n\n    this[\"templates\"][\"bubble_default\"] = function (data) {\n      var __t,\n          __p = '',\n          __e = _.escape,\n          __j = Array.prototype.join;\n      function print() {\n        __p += __j.call(arguments, '');\n      }\n\n      function optEscape(str, unsafe) {\n        if (unsafe) {\n          return _.escape(str);\n        }\n        return str;\n      }\n      ;\n      __p += '\\n';\n\n      var i18n = data.i18n;\n      var buttons = data.buttons;\n      var step = data.step;\n      var tour = data.tour;\n      ;\n      __p += '\\n<div class=\"hopscotch-bubble-container\" style=\"width: ' + ((__t = step.width) == null ? '' : __t) + 'px; padding: ' + ((__t = step.padding) == null ? '' : __t) + 'px;\">\\n  ';\n      if (tour.isTour) {\n        ;\n        __p += '<span class=\"hopscotch-bubble-number\">' + ((__t = i18n.stepNum) == null ? '' : __t) + '</span>';\n      };\n      __p += '\\n  <div class=\"hopscotch-bubble-content\">\\n    ';\n      if (step.title !== '') {\n        ;\n        __p += '<h3 class=\"hopscotch-title\">' + ((__t = optEscape(step.title, tour.unsafe)) == null ? '' : __t) + '</h3>';\n      };\n      __p += '\\n    ';\n      if (step.content !== '') {\n        ;\n        __p += '<div class=\"hopscotch-content\">' + ((__t = optEscape(step.content, tour.unsafe)) == null ? '' : __t) + '</div>';\n      };\n      __p += '\\n  </div>\\n  <div class=\"hopscotch-actions\">\\n    ';\n      if (buttons.showPrev) {\n        ;\n        __p += '<button class=\"hopscotch-nav-button prev hopscotch-prev\">' + ((__t = i18n.prevBtn) == null ? '' : __t) + '</button>';\n      };\n      __p += '\\n    ';\n      if (buttons.showCTA) {\n        ;\n        __p += '<button class=\"hopscotch-nav-button next hopscotch-cta\">' + ((__t = buttons.ctaLabel) == null ? '' : __t) + '</button>';\n      };\n      __p += '\\n    ';\n      if (buttons.showNext) {\n        ;\n        __p += '<button class=\"hopscotch-nav-button next hopscotch-next\">' + ((__t = i18n.nextBtn) == null ? '' : __t) + '</button>';\n      };\n      __p += '\\n  </div>\\n  ';\n      if (buttons.showClose) {\n        ;\n        __p += '<button class=\"hopscotch-bubble-close hopscotch-close\">' + ((__t = i18n.closeTooltip) == null ? '' : __t) + '</button>';\n      };\n      __p += '\\n</div>\\n<div class=\"hopscotch-bubble-arrow-container hopscotch-arrow\">\\n  <div class=\"hopscotch-bubble-arrow-border\"></div>\\n  <div class=\"hopscotch-bubble-arrow\"></div>\\n</div>\\n';\n      return __p;\n    };\n  }).call(winHopscotch);\n\n  var winHopscotch$1 = winHopscotch;\n\n  return winHopscotch$1;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvcGtncy9ob3BzY290Y2gvZGlzdC9qcy9ob3BzY290Y2guanM/NzBhNSJdLCJuYW1lcyI6WyJnbG9iYWwiLCJmYWN0b3J5IiwiZXhwb3J0cyIsIm1vZHVsZSIsImhvcHNjb3RjaCIsIl90eXBlb2YiLCJTeW1ib2wiLCJpdGVyYXRvciIsIm9iaiIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiSG9wc2NvdGNoIiwiSG9wc2NvdGNoQnViYmxlIiwiSG9wc2NvdGNoQ2FsbG91dE1hbmFnZXIiLCJIb3BzY290Y2hJMThOIiwiY3VzdG9tSTE4TiIsImN1c3RvbVJlbmRlcmVyIiwiY3VzdG9tRXNjYXBlIiwidGVtcGxhdGVUb1VzZSIsIlNpenpsZSIsIndpbmRvdyIsInV0aWxzIiwiY2FsbGJhY2tzIiwiaGVscGVycyIsIndpbkxvYWRIYW5kbGVyIiwiZGVmYXVsdE9wdHMiLCJ3aW5Ib3BzY290Y2giLCJ1bmRlZmluZWRTdHIiLCJ3YWl0aW5nVG9TdGFydCIsImhhc0pxdWVyeSIsImpRdWVyeSIsImhhc1Nlc3Npb25TdG9yYWdlIiwiaXNTdG9yYWdlV3JpdGFibGUiLCJ2YWxpZElkUmVnRXgiLCJydGxNYXRjaGVzIiwibGVmdCIsInJpZ2h0Iiwic2Vzc2lvblN0b3JhZ2UiLCJzZXRJdGVtIiwicmVtb3ZlSXRlbSIsImVyciIsInNtb290aFNjcm9sbCIsInNjcm9sbER1cmF0aW9uIiwic2Nyb2xsVG9wTWFyZ2luIiwic2hvd0Nsb3NlQnV0dG9uIiwic2hvd1ByZXZCdXR0b24iLCJzaG93TmV4dEJ1dHRvbiIsImJ1YmJsZVdpZHRoIiwiYnViYmxlUGFkZGluZyIsImFycm93V2lkdGgiLCJza2lwSWZOb0VsZW1lbnQiLCJpc1J0bCIsImNvb2tpZU5hbWUiLCJBcnJheSIsImlzQXJyYXkiLCJPYmplY3QiLCJ0b1N0cmluZyIsImNhbGwiLCJzdGFydFRvdXIiLCJhZGRDbGFzcyIsImRvbUVsIiwiY2xhc3NUb0FkZCIsImRvbUNsYXNzZXMiLCJjbGFzc1RvQWRkQXJyIiwic2V0Q2xhc3MiLCJpIiwibGVuIiwiY2xhc3NOYW1lIiwic3BsaXQiLCJsZW5ndGgiLCJpbmRleE9mIiwicmVwbGFjZSIsInJlbW92ZUNsYXNzIiwiY2xhc3NUb1JlbW92ZSIsImNsYXNzVG9SZW1vdmVBcnIiLCJjdXJyQ2xhc3MiLCJoYXNDbGFzcyIsImNsYXNzVG9DaGVjayIsImNsYXNzZXMiLCJnZXRQaXhlbFZhbHVlIiwidmFsIiwidmFsVHlwZSIsInBhcnNlSW50IiwidmFsT3JEZWZhdWx0IiwidmFsRGVmYXVsdCIsImludm9rZUNhbGxiYWNrQXJyYXlIZWxwZXIiLCJhcnIiLCJmbiIsImFwcGx5Iiwic2xpY2UiLCJpbnZva2VDYWxsYmFja0FycmF5IiwiaW52b2tlQ2FsbGJhY2siLCJjYiIsImludm9rZUV2ZW50Q2FsbGJhY2tzIiwiZXZ0VHlwZSIsInN0ZXBDYiIsImNiQXJyIiwiY2FsbGJhY2siLCJnZXRTY3JvbGxUb3AiLCJzY3JvbGxUb3AiLCJwYWdlWU9mZnNldCIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwiZ2V0U2Nyb2xsTGVmdCIsInNjcm9sbExlZnQiLCJwYWdlWE9mZnNldCIsImdldFdpbmRvd0hlaWdodCIsImlubmVySGVpZ2h0IiwiY2xpZW50SGVpZ2h0IiwiYWRkRXZ0TGlzdGVuZXIiLCJlbCIsImV2dE5hbWUiLCJhZGRFdmVudExpc3RlbmVyIiwiYXR0YWNoRXZlbnQiLCJyZW1vdmVFdnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJkZXRhY2hFdmVudCIsImRvY3VtZW50SXNSZWFkeSIsInJlYWR5U3RhdGUiLCJldnRQcmV2ZW50RGVmYXVsdCIsImV2dCIsInByZXZlbnREZWZhdWx0IiwiZXZlbnQiLCJyZXR1cm5WYWx1ZSIsImV4dGVuZCIsIm9iajEiLCJvYmoyIiwicHJvcCIsImhhc093blByb3BlcnR5IiwiZ2V0U3RlcFRhcmdldEhlbHBlciIsInRhcmdldCIsInJlc3VsdCIsImdldEVsZW1lbnRCeUlkIiwicXVlcnlTZWxlY3RvciIsInRlc3QiLCJzdWJzdHJpbmciLCJnZXRTdGVwVGFyZ2V0Iiwic3RlcCIsInF1ZXJpZWRUYXJnZXQiLCJnZXRJMThOU3RyaW5nIiwia2V5Iiwic2V0U3RhdGUiLCJuYW1lIiwidmFsdWUiLCJkYXlzIiwiZXhwaXJlcyIsImRhdGUiLCJEYXRlIiwic2V0VGltZSIsImdldFRpbWUiLCJ0b0dNVFN0cmluZyIsImNvb2tpZSIsImdldFN0YXRlIiwibmFtZUVRIiwiY2EiLCJjIiwic3RhdGUiLCJnZXRJdGVtIiwiY2hhckF0IiwiY2xlYXJTdGF0ZSIsIm5vcm1hbGl6ZVBsYWNlbWVudCIsInBsYWNlbWVudCIsIm9yaWVudGF0aW9uIiwiZmxpcFBsYWNlbWVudCIsIl9pc0ZsaXBwZWQiLCJwcm9wcyIsInhPZmZzZXQiLCJuZXh0IiwicHJldiIsInN0YXJ0IiwiZW5kIiwic2hvdyIsImVycm9yIiwiY2xvc2UiLCJzdGVwTnVtcyIsIm5leHRCdG4iLCJwcmV2QnRuIiwiZG9uZUJ0biIsInNraXBCdG4iLCJjbG9zZVRvb2x0aXAiLCJvcHQiLCJpbml0IiwiaXNTaG93aW5nIiwiY3VyclN0ZXAiLCJ1bmRlZmluZWQiLCJzZXRQb3NpdGlvbiIsImJ1YmJsZUJvdW5kaW5nSGVpZ2h0IiwiYnViYmxlQm91bmRpbmdXaWR0aCIsImJvdW5kaW5nUmVjdCIsInRvcCIsImFycm93T2Zmc2V0IiwidmVydGljYWxMZWZ0UG9zaXRpb24iLCJ0YXJnZXRFbCIsImVsZW1lbnQiLCJhcnJvd0VsIiwiYXJyb3dQb3MiLCJvZmZzZXRXaWR0aCIsIm9mZnNldEhlaWdodCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImJvdHRvbSIsIkVycm9yIiwic3R5bGUiLCJNYXRoIiwiZmxvb3IiLCJ5T2Zmc2V0IiwiZml4ZWRFbGVtZW50IiwicG9zaXRpb24iLCJyZW5kZXIiLCJpZHgiLCJ0b3VyU3BlY2lmaWNSZW5kZXJlciIsImN1c3RvbVRvdXJEYXRhIiwidW5zYWZlIiwiY3VyclRvdXIiLCJ0b3RhbFN0ZXBzIiwidG90YWxTdGVwc0kxOG4iLCJuZXh0QnRuVGV4dCIsImlzTGFzdCIsIm9wdHMiLCJpc1RvdXJCdWJibGUiLCJnZXRDdXJyVG91ciIsImN1c3RvbURhdGEiLCJzdGVwcyIsIl9nZXRTdGVwSTE4bk51bSIsIl9nZXRTdGVwTnVtIiwic2hvd1NraXAiLCJpMThuIiwic3RlcE51bSIsIm51bVN0ZXBzIiwiYnV0dG9ucyIsInNob3dQcmV2Iiwic2hvd05leHQiLCJzaG93Q1RBIiwic2hvd0NUQUJ1dHRvbiIsImN0YUxhYmVsIiwic2hvd0Nsb3NlIiwibnVtIiwidGl0bGUiLCJjb250ZW50IiwicGFkZGluZyIsIndpZHRoIiwidG91ciIsImlzVG91ciIsImlubmVySFRNTCIsInRlbXBsYXRlcyIsImNoaWxkcmVuIiwibnVtQ2hpbGRyZW4iLCJub2RlIiwiekluZGV4IiwiemluZGV4IiwiX3NldEFycm93IiwiaGlkZSIsInNraXBwZWRTdGVwc0NvdW50Iiwic3RlcElkeCIsInNraXBwZWRTdGVwcyIsImdldFNraXBwZWRTdGVwc0luZGV4ZXMiLCJzdGVwTnVtSTE4TiIsIl9nZXRBcnJvd0RpcmVjdGlvbiIsInNlbGYiLCJmYWRlQ2xhc3MiLCJmYWRlRHVyIiwic2V0VGltZW91dCIsInJlbW92ZSIsImRlc3Ryb3kiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJjbGlja0NiIiwiX2hhbmRsZUJ1YmJsZUNsaWNrIiwiYWN0aW9uIiwidGFyZ2V0RWxlbWVudCIsInNyY0VsZW1lbnQiLCJmaW5kTWF0Y2hSZWN1ciIsImN1cnJlbnRUYXJnZXQiLCJwYXJlbnRFbGVtZW50IiwiZ2V0Q2FsbG91dE1hbmFnZXIiLCJyZW1vdmVDYWxsb3V0IiwiaWQiLCJvbkNUQSIsIm5leHRTdGVwIiwicHJldlN0ZXAiLCJjdXJyU3RlcE51bSIsImdldEN1cnJTdGVwTnVtIiwiZG9FbmRDYWxsYmFjayIsImVuZFRvdXIiLCJvbkNsb3NlIiwiaW5pdE9wdCIsImNyZWF0ZUVsZW1lbnQiLCJyZXNpemVDb29sZG93biIsIm9uV2luUmVzaXplIiwiX2FwcGVuZFRvQm9keTIiLCJzaG93TnVtYmVyIiwiYm9keSIsImFwcGVuZENoaWxkIiwiYXBwZW5kVG9Cb2R5IiwiX2FwcGVuZFRvQm9keSIsImNhbGxvdXRzIiwiY2FsbG91dE9wdHMiLCJjcmVhdGVDYWxsb3V0IiwiY2FsbG91dCIsIm9uU2hvdyIsImdldENhbGxvdXQiLCJyZW1vdmVBbGxDYWxsb3V0cyIsImNhbGxvdXRJZCIsInJlZnJlc2hDYWxsb3V0UG9zaXRpb25zIiwiaW5pdE9wdGlvbnMiLCJidWJibGUiLCJjYWxsb3V0TWdyIiwiY29va2llVG91cklkIiwiY29va2llVG91clN0ZXAiLCJjb29raWVTa2lwcGVkU3RlcHMiLCJfY29uZmlndXJlIiwiZ2V0QnViYmxlIiwic2V0T3B0aW9ucyIsImdldE9wdGlvbiIsImRlc3Ryb3lCdWJibGUiLCJnZXRDdXJyU3RlcCIsInRhcmdldENsaWNrTmV4dEZuIiwiYWRqdXN0V2luZG93U2Nyb2xsIiwiYnViYmxlRWwiLCJidWJibGVUb3AiLCJidWJibGVCb3R0b20iLCJ0YXJnZXRCb3VuZHMiLCJ0YXJnZXRFbFRvcCIsInRhcmdldEVsQm90dG9tIiwidGFyZ2V0VG9wIiwidGFyZ2V0Qm90dG9tIiwid2luZG93VG9wIiwid2luZG93Qm90dG9tIiwic2Nyb2xsVG9WYWwiLCJzY3JvbGxFbCIsInl1aUFuaW0iLCJ5dWlFYXNlIiwiZGlyZWN0aW9uIiwic2Nyb2xsSW5jciIsInNjcm9sbFRpbWVvdXQiLCJfc2Nyb2xsVGltZW91dEZuIiwic2Nyb2xsVG8iLCJZQUhPTyIsImVudiIsInVhIiwidXRpbCIsIlNjcm9sbCIsIndlYmtpdCIsIkVhc2luZyIsImVhc2VPdXQiLCJzY3JvbGwiLCJ0byIsIm9uQ29tcGxldGUiLCJzdWJzY3JpYmUiLCJhbmltYXRlIiwiYWJzIiwic2Nyb2xsVGltZW91dEZuIiwic2Nyb2xsVGFyZ2V0IiwiZ29Ub1N0ZXBXaXRoVGFyZ2V0IiwiZ29Ub1N0ZXBGbiIsImRlbGF5IiwiY2hhbmdlU3RlcCIsImRvQ2FsbGJhY2tzIiwib3JpZ1N0ZXAiLCJ3YXNNdWx0aVBhZ2UiLCJjaGFuZ2VTdGVwQ2IiLCJuZXh0T25UYXJnZXRDbGljayIsIm11bHRpcGFnZSIsImRvU2hvd0ZvbGxvd2luZ1N0ZXAiLCJvbk5leHQiLCJvblByZXYiLCJzZXRTdGF0ZUhlbHBlciIsInNob3dTdGVwIiwibG9hZFRvdXIiLCJ0bXBPcHQiLCJ0b3VyU3RhdGUiLCJ0b3VyU3RhdGVWYWx1ZXMiLCJmaW5kU3RhcnRpbmdTdGVwIiwic3RhcnRTdGVwTnVtIiwic2F2ZWRTa2lwcGVkU3RlcHMiLCJzaG93U3RlcEhlbHBlciIsInNob3dCdWJibGUiLCJhZGp1c3RTY3JvbGwiLCJjb29raWVWYWwiLCJza2lwZWRTdGVwSW5kZXhlcyIsImpvaW4iLCJjb25maWd1cmUiLCJpc0FjdGl2ZSIsInByZXZTdGVwTnVtIiwiY3VycmVudFN0ZXAiLCJyZW1vdmVDYWxsYmFja3MiLCJyZXNldERlZmF1bHRPcHRpb25zIiwiZ2V0Q3VyclRhcmdldCIsInNraXBwZWRTdGVwc0lkeEFycmF5Iiwic3RlcElkcyIsInB1c2giLCJyZWZyZXNoQnViYmxlUG9zaXRpb24iLCJsaXN0ZW4iLCJpc1RvdXJDYiIsImZyb21Ub3VyIiwidW5saXN0ZW4iLCJldnRDYWxsYmFja3MiLCJzcGxpY2UiLCJ0b3VyT25seSIsInJlZ2lzdGVySGVscGVyIiwidW5yZWdpc3RlckhlbHBlciIsImludm9rZUhlbHBlciIsImFyZ3MiLCJhcmd1bWVudHMiLCJzZXRDb29raWVOYW1lIiwicmVzZXREZWZhdWx0STE4TiIsIm9wdGlvbnMiLCJpc1RvdXJPcHRpb25zIiwiZXZlbnRzIiwiZXZlbnRQcm9wTmFtZSIsImNhbGxiYWNrUHJvcCIsInRvVXBwZXJDYXNlIiwic2V0UmVuZGVyZXIiLCJ0eXBlT2ZSZW5kZXIiLCJzZXRFc2NhcGVyIiwiZXNjIiwiXyIsImVzY2FwZSIsInN0ciIsIlJlZ0V4cCIsIm1hdGNoIiwiZGF0YSIsIl9fdCIsIl9fcCIsIl9fZSIsIl9faiIsInByaW50Iiwib3B0RXNjYXBlIiwi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QyxJQUVQLFdBRkE7QUFHRSxPQUFDO0FBQ0hDLGFBQU8sZ0JBQVA7QUFDQyxVQUFHbE0sUUFBUU0sU0FBWCxFQUFxQjtBQUFFO0FBQ3hCNEwsZUFBTyw2REFDTixDQUFDRCxNQUFRcE0sS0FBSzlDLFlBQWQsS0FBaUMsSUFBakMsR0FBd0MsRUFBeEMsR0FBNkNrUCxHQUR2QyxJQUVQLFdBRkE7QUFHRSxPQUFDO0FBQ0hDLGFBQU8sdUxBQVA7QUFDQSxhQUFPQSxHQUFQO0FBQ0MsS0FuRUQ7QUFvRUcsR0F6RkQsRUF5Rkc3VyxJQXpGSCxDQXlGUS9CLFlBekZSOztBQTJGQSxNQUFJaVosaUJBQWlCalosWUFBckI7O0FBRUEsU0FBT2laLGNBQVA7QUFFRCxDQTk3RUEsQ0FBRCIsImZpbGUiOiIxMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKiEgaG9wc2NvdGNoIC0gdjAuMy4xXG4qXG4qIENvcHlyaWdodCAyMDE3IExpbmtlZEluIENvcnAuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgKGdsb2JhbC5ob3BzY290Y2ggPSBmYWN0b3J5KCkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgfSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgfTtcblxuICAvKiBnbG9iYWwgZG9jdW1lbnQgKi9cblxuICB2YXIgSG9wc2NvdGNoO1xuICB2YXIgSG9wc2NvdGNoQnViYmxlO1xuICB2YXIgSG9wc2NvdGNoQ2FsbG91dE1hbmFnZXI7XG4gIHZhciBIb3BzY290Y2hJMThOO1xuICB2YXIgY3VzdG9tSTE4TjtcbiAgdmFyIGN1c3RvbVJlbmRlcmVyO1xuICB2YXIgY3VzdG9tRXNjYXBlO1xuICB2YXIgdGVtcGxhdGVUb1VzZSA9ICdidWJibGVfZGVmYXVsdCc7XG4gIHZhciBTaXp6bGUgPSB3aW5kb3cuU2l6emxlIHx8IG51bGw7XG4gIHZhciB1dGlscztcbiAgdmFyIGNhbGxiYWNrcztcbiAgdmFyIGhlbHBlcnM7XG4gIHZhciB3aW5Mb2FkSGFuZGxlcjtcbiAgdmFyIGRlZmF1bHRPcHRzO1xuICB2YXIgd2luSG9wc2NvdGNoO1xuICB2YXIgdW5kZWZpbmVkU3RyID0gJ3VuZGVmaW5lZCc7XG4gIHZhciB3YWl0aW5nVG9TdGFydCA9IGZhbHNlO1xuICB2YXIgaGFzSnF1ZXJ5ID0gKHR5cGVvZiBqUXVlcnkgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGpRdWVyeSkpICE9PSB1bmRlZmluZWRTdHI7XG4gIHZhciBoYXNTZXNzaW9uU3RvcmFnZSA9IGZhbHNlO1xuICB2YXIgaXNTdG9yYWdlV3JpdGFibGUgPSBmYWxzZTtcbiAgdmFyIHZhbGlkSWRSZWdFeCA9IC9eW2EtekEtWl0rW2EtekEtWjAtOV8tXSokLztcbiAgdmFyIHJ0bE1hdGNoZXMgPSB7XG4gICAgbGVmdDogJ3JpZ2h0JyxcbiAgICByaWdodDogJ2xlZnQnXG4gIH07XG5cbiAgLy8gSWYgY29va2llcyBhcmUgZGlzYWJsZWQsIGFjY2Vzc2luZyBzZXNzaW9uU3RvcmFnZSBjYW4gdGhyb3cgYW4gZXJyb3IuXG4gIC8vIHNlc3Npb25TdG9yYWdlIGNvdWxkIGFsc28gdGhyb3cgYW4gZXJyb3IgaW4gU2FmYXJpIG9uIHdyaXRlIChldmVuIHRob3VnaCBpdCBleGlzdHMpLlxuICAvLyBTbywgd2UnbGwgdHJ5IHdyaXRpbmcgdG8gc2Vzc2lvblN0b3JhZ2UgdG8gdmVyaWZ5IGl0J3MgYXZhaWxhYmxlLlxuICB0cnkge1xuICAgIGlmIChfdHlwZW9mKHdpbmRvdy5zZXNzaW9uU3RvcmFnZSkgIT09IHVuZGVmaW5lZFN0cikge1xuICAgICAgaGFzU2Vzc2lvblN0b3JhZ2UgPSB0cnVlO1xuICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbSgnaG9wc2NvdGNoLnRlc3Quc3RvcmFnZScsICdvaycpO1xuICAgICAgc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbSgnaG9wc2NvdGNoLnRlc3Quc3RvcmFnZScpO1xuICAgICAgaXNTdG9yYWdlV3JpdGFibGUgPSB0cnVlO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7fVxuXG4gIGRlZmF1bHRPcHRzID0ge1xuICAgIHNtb290aFNjcm9sbDogdHJ1ZSxcbiAgICBzY3JvbGxEdXJhdGlvbjogMTAwMCxcbiAgICBzY3JvbGxUb3BNYXJnaW46IDIwMCxcbiAgICBzaG93Q2xvc2VCdXR0b246IHRydWUsXG4gICAgc2hvd1ByZXZCdXR0b246IGZhbHNlLFxuICAgIHNob3dOZXh0QnV0dG9uOiB0cnVlLFxuICAgIGJ1YmJsZVdpZHRoOiAyODAsXG4gICAgYnViYmxlUGFkZGluZzogMTUsXG4gICAgYXJyb3dXaWR0aDogMjAsXG4gICAgc2tpcElmTm9FbGVtZW50OiB0cnVlLFxuICAgIGlzUnRsOiBmYWxzZSxcbiAgICBjb29raWVOYW1lOiAnaG9wc2NvdGNoLnRvdXIuc3RhdGUnXG4gIH07XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KSB7XG4gICAgQXJyYXkuaXNBcnJheSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIHRoZSBwYWdlIGlzIGRvbmUgbG9hZGluZy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHdpbkxvYWRIYW5kbGVyID0gZnVuY3Rpb24gd2luTG9hZEhhbmRsZXIoKSB7XG4gICAgaWYgKHdhaXRpbmdUb1N0YXJ0KSB7XG4gICAgICB3aW5Ib3BzY290Y2guc3RhcnRUb3VyKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiB1dGlsc1xuICAgKiA9PT09PVxuICAgKiBBIHNldCBvZiB1dGlsaXR5IGZ1bmN0aW9ucywgbW9zdGx5IGZvciBzdGFuZGFyZGl6aW5nIHRvIG1hbmlwdWxhdGVcbiAgICogYW5kIGV4dHJhY3QgaW5mb3JtYXRpb24gZnJvbSB0aGUgRE9NLiBCYXNpY2FsbHkgdGhlc2UgYXJlIHRoaW5ncyBJXG4gICAqIHdvdWxkIG5vcm1hbGx5IHVzZSBqUXVlcnkgZm9yLCBidXQgSSBkb24ndCB3YW50IHRvIHJlcXVpcmUgaXQgZm9yXG4gICAqIHRoaXMgZnJhbWV3b3JrLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdXRpbHMgPSB7XG4gICAgLyoqXG4gICAgICogYWRkQ2xhc3NcbiAgICAgKiA9PT09PT09PVxuICAgICAqIEFkZHMgb25lIG9yIG1vcmUgY2xhc3NlcyB0byBhIERPTSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBhZGRDbGFzczogZnVuY3Rpb24gYWRkQ2xhc3MoZG9tRWwsIGNsYXNzVG9BZGQpIHtcbiAgICAgIHZhciBkb21DbGFzc2VzLCBjbGFzc1RvQWRkQXJyLCBzZXRDbGFzcywgaSwgbGVuO1xuXG4gICAgICBpZiAoIWRvbUVsLmNsYXNzTmFtZSkge1xuICAgICAgICBkb21FbC5jbGFzc05hbWUgPSBjbGFzc1RvQWRkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xhc3NUb0FkZEFyciA9IGNsYXNzVG9BZGQuc3BsaXQoL1xccysvKTtcbiAgICAgICAgZG9tQ2xhc3NlcyA9ICcgJyArIGRvbUVsLmNsYXNzTmFtZSArICcgJztcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gY2xhc3NUb0FkZEFyci5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgIGlmIChkb21DbGFzc2VzLmluZGV4T2YoJyAnICsgY2xhc3NUb0FkZEFycltpXSArICcgJykgPCAwKSB7XG4gICAgICAgICAgICBkb21DbGFzc2VzICs9IGNsYXNzVG9BZGRBcnJbaV0gKyAnICc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRvbUVsLmNsYXNzTmFtZSA9IGRvbUNsYXNzZXMucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZW1vdmVDbGFzc1xuICAgICAqID09PT09PT09PT09XG4gICAgICogUmVtb3ZlIG9uZSBvciBtb3JlIGNsYXNzZXMgZnJvbSBhIERPTSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICByZW1vdmVDbGFzczogZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZG9tRWwsIGNsYXNzVG9SZW1vdmUpIHtcbiAgICAgIHZhciBkb21DbGFzc2VzLCBjbGFzc1RvUmVtb3ZlQXJyLCBjdXJyQ2xhc3MsIGksIGxlbjtcblxuICAgICAgY2xhc3NUb1JlbW92ZUFyciA9IGNsYXNzVG9SZW1vdmUuc3BsaXQoL1xccysvKTtcbiAgICAgIGRvbUNsYXNzZXMgPSAnICcgKyBkb21FbC5jbGFzc05hbWUgKyAnICc7XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBjbGFzc1RvUmVtb3ZlQXJyLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIGRvbUNsYXNzZXMgPSBkb21DbGFzc2VzLnJlcGxhY2UoJyAnICsgY2xhc3NUb1JlbW92ZUFycltpXSArICcgJywgJyAnKTtcbiAgICAgIH1cbiAgICAgIGRvbUVsLmNsYXNzTmFtZSA9IGRvbUNsYXNzZXMucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBoYXNDbGFzc1xuICAgICAqID09PT09PT09XG4gICAgICogRGV0ZXJtaW5lIGlmIGEgZ2l2ZW4gRE9NIGVsZW1lbnQgaGFzIGEgY2xhc3MuXG4gICAgICovXG4gICAgaGFzQ2xhc3M6IGZ1bmN0aW9uIGhhc0NsYXNzKGRvbUVsLCBjbGFzc1RvQ2hlY2spIHtcbiAgICAgIHZhciBjbGFzc2VzO1xuXG4gICAgICBpZiAoIWRvbUVsLmNsYXNzTmFtZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjbGFzc2VzID0gJyAnICsgZG9tRWwuY2xhc3NOYW1lICsgJyAnO1xuICAgICAgcmV0dXJuIGNsYXNzZXMuaW5kZXhPZignICcgKyBjbGFzc1RvQ2hlY2sgKyAnICcpICE9PSAtMTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXRQaXhlbFZhbHVlOiBmdW5jdGlvbiBnZXRQaXhlbFZhbHVlKHZhbCkge1xuICAgICAgdmFyIHZhbFR5cGUgPSB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWwpO1xuICAgICAgaWYgKHZhbFR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgICB9XG4gICAgICBpZiAodmFsVHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHZhbCwgMTApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluc3BpcmVkIGJ5IFB5dGhvbi4uLiByZXR1cm5zIHZhbCBpZiBpdCdzIGRlZmluZWQsIG90aGVyd2lzZSByZXR1cm5zIHRoZSBkZWZhdWx0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB2YWxPckRlZmF1bHQ6IGZ1bmN0aW9uIHZhbE9yRGVmYXVsdCh2YWwsIHZhbERlZmF1bHQpIHtcbiAgICAgIHJldHVybiAodHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsKSkgIT09IHVuZGVmaW5lZFN0ciA/IHZhbCA6IHZhbERlZmF1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgYSBzaW5nbGUgY2FsbGJhY2sgcmVwcmVzZW50ZWQgYnkgYW4gYXJyYXkuXG4gICAgICogRXhhbXBsZSBpbnB1dDogW1wibXlfZm5cIiwgXCJhcmcxXCIsIDIsIFwiYXJnM1wiXVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgaW52b2tlQ2FsbGJhY2tBcnJheUhlbHBlcjogZnVuY3Rpb24gaW52b2tlQ2FsbGJhY2tBcnJheUhlbHBlcihhcnIpIHtcbiAgICAgIC8vIExvZ2ljIGZvciBhIHNpbmdsZSBjYWxsYmFja1xuICAgICAgdmFyIGZuO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgICAgICBmbiA9IGhlbHBlcnNbYXJyWzBdXTtcbiAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcnIuc2xpY2UoMSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgb25lIG9yIG1vcmUgY2FsbGJhY2tzLiBBcnJheSBzaG91bGQgaGF2ZSBhdCBtb3N0IG9uZSBsZXZlbCBvZiBuZXN0aW5nLlxuICAgICAqIEV4YW1wbGUgaW5wdXQ6XG4gICAgICogW1wibXlfZm5cIiwgXCJhcmcxXCIsIDIsIFwiYXJnM1wiXVxuICAgICAqIFtbXCJteV9mbl8xXCIsIFwiYXJnMVwiLCBcImFyZzJcIl0sIFtcIm15X2ZuXzJcIiwgXCJhcmcyLTFcIiwgXCJhcmcyLTJcIl1dXG4gICAgICogW1tcIm15X2ZuXzFcIiwgXCJhcmcxXCIsIFwiYXJnMlwiXSwgZnVuY3Rpb24oKSB7IC4uLiB9XVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgaW52b2tlQ2FsbGJhY2tBcnJheTogZnVuY3Rpb24gaW52b2tlQ2FsbGJhY2tBcnJheShhcnIpIHtcbiAgICAgIHZhciBpLCBsZW47XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhcnJbMF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgLy8gQXNzdW1lIHRoZXJlIGFyZSBubyBuZXN0ZWQgYXJyYXlzLiBUaGlzIGlzIHRoZSBvbmUgYW5kIG9ubHkgY2FsbGJhY2suXG4gICAgICAgICAgcmV0dXJuIHV0aWxzLmludm9rZUNhbGxiYWNrQXJyYXlIZWxwZXIoYXJyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBhc3N1bWUgYW4gYXJyYXlcbiAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBhcnIubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIHV0aWxzLmludm9rZUNhbGxiYWNrKGFycltpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBmdW5jdGlvbiBmb3IgaW52b2tpbmcgYSBjYWxsYmFjaywgd2hldGhlciBkZWZpbmVkIGFzIGEgZnVuY3Rpb24gbGl0ZXJhbFxuICAgICAqIG9yIGFuIGFycmF5IHRoYXQgcmVmZXJlbmNlcyBhIHJlZ2lzdGVyZWQgaGVscGVyIGZ1bmN0aW9uLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgaW52b2tlQ2FsbGJhY2s6IGZ1bmN0aW9uIGludm9rZUNhbGxiYWNrKGNiKSB7XG4gICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBjYigpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gJ3N0cmluZycgJiYgaGVscGVyc1tjYl0pIHtcbiAgICAgICAgLy8gbmFtZSBvZiBhIGhlbHBlclxuICAgICAgICByZXR1cm4gaGVscGVyc1tjYl0oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGFzc3VtaW5nIGFycmF5XG4gICAgICAgIHJldHVybiB1dGlscy5pbnZva2VDYWxsYmFja0FycmF5KGNiKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSWYgc3RlcENiICh0aGUgc3RlcC1zcGVjaWZpYyBoZWxwZXIgY2FsbGJhY2spIGlzIHBhc3NlZCBpbiwgdGhlbiBpbnZva2VcbiAgICAgKiBpdCBmaXJzdC4gVGhlbiBpbnZva2UgdG91ci13aWRlIGhlbHBlci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgaW52b2tlRXZlbnRDYWxsYmFja3M6IGZ1bmN0aW9uIGludm9rZUV2ZW50Q2FsbGJhY2tzKGV2dFR5cGUsIHN0ZXBDYikge1xuICAgICAgdmFyIGNiQXJyID0gY2FsbGJhY2tzW2V2dFR5cGVdLFxuICAgICAgICAgIGNhbGxiYWNrLFxuICAgICAgICAgIGZuLFxuICAgICAgICAgIGksXG4gICAgICAgICAgbGVuO1xuXG4gICAgICBpZiAoc3RlcENiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludm9rZUNhbGxiYWNrKHN0ZXBDYik7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGNiQXJyLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIHRoaXMuaW52b2tlQ2FsbGJhY2soY2JBcnJbaV0uY2IpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdldFNjcm9sbFRvcDogZnVuY3Rpb24gZ2V0U2Nyb2xsVG9wKCkge1xuICAgICAgdmFyIHNjcm9sbFRvcDtcbiAgICAgIGlmIChfdHlwZW9mKHdpbmRvdy5wYWdlWU9mZnNldCkgIT09IHVuZGVmaW5lZFN0cikge1xuICAgICAgICBzY3JvbGxUb3AgPSB3aW5kb3cucGFnZVlPZmZzZXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBNb3N0IGxpa2VseSBJRSA8PTgsIHdoaWNoIGRvZXNuJ3Qgc3VwcG9ydCBwYWdlWU9mZnNldFxuICAgICAgICBzY3JvbGxUb3AgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNjcm9sbFRvcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXRTY3JvbGxMZWZ0OiBmdW5jdGlvbiBnZXRTY3JvbGxMZWZ0KCkge1xuICAgICAgdmFyIHNjcm9sbExlZnQ7XG4gICAgICBpZiAoX3R5cGVvZih3aW5kb3cucGFnZVhPZmZzZXQpICE9PSB1bmRlZmluZWRTdHIpIHtcbiAgICAgICAgc2Nyb2xsTGVmdCA9IHdpbmRvdy5wYWdlWE9mZnNldDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE1vc3QgbGlrZWx5IElFIDw9OCwgd2hpY2ggZG9lc24ndCBzdXBwb3J0IHBhZ2VYT2Zmc2V0XG4gICAgICAgIHNjcm9sbExlZnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY3JvbGxMZWZ0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdldFdpbmRvd0hlaWdodDogZnVuY3Rpb24gZ2V0V2luZG93SGVpZ2h0KCkge1xuICAgICAgcmV0dXJuIHdpbmRvdy5pbm5lckhlaWdodCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGFkZEV2dExpc3RlbmVyOiBmdW5jdGlvbiBhZGRFdnRMaXN0ZW5lcihlbCwgZXZ0TmFtZSwgZm4pIHtcbiAgICAgIGlmIChlbCkge1xuICAgICAgICByZXR1cm4gZWwuYWRkRXZlbnRMaXN0ZW5lciA/IGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZ0TmFtZSwgZm4sIGZhbHNlKSA6IGVsLmF0dGFjaEV2ZW50KCdvbicgKyBldnROYW1lLCBmbik7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcmVtb3ZlRXZ0TGlzdGVuZXI6IGZ1bmN0aW9uIHJlbW92ZUV2dExpc3RlbmVyKGVsLCBldnROYW1lLCBmbikge1xuICAgICAgaWYgKGVsKSB7XG4gICAgICAgIHJldHVybiBlbC5yZW1vdmVFdmVudExpc3RlbmVyID8gZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnROYW1lLCBmbiwgZmFsc2UpIDogZWwuZGV0YWNoRXZlbnQoJ29uJyArIGV2dE5hbWUsIGZuKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZG9jdW1lbnRJc1JlYWR5OiBmdW5jdGlvbiBkb2N1bWVudElzUmVhZHkoKSB7XG4gICAgICByZXR1cm4gZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBldnRQcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gZXZ0UHJldmVudERlZmF1bHQoZXZ0KSB7XG4gICAgICBpZiAoZXZ0LnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfSBlbHNlIGlmIChldmVudCkge1xuICAgICAgICBldmVudC5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGV4dGVuZDogZnVuY3Rpb24gZXh0ZW5kKG9iajEsIG9iajIpIHtcbiAgICAgIHZhciBwcm9wO1xuICAgICAgZm9yIChwcm9wIGluIG9iajIpIHtcbiAgICAgICAgaWYgKG9iajIuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICBvYmoxW3Byb3BdID0gb2JqMltwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IGEgc2luZ2xlIHRhcmdldCBET00gZWxlbWVudC4gV2Ugd2lsbCB0cnkgdG9cbiAgICAgKiBsb2NhdGUgdGhlIERPTSBlbGVtZW50IHRocm91Z2ggc2V2ZXJhbCB3YXlzLCBpbiB0aGUgZm9sbG93aW5nIG9yZGVyOlxuICAgICAqXG4gICAgICogMSkgUGFzc2luZyB0aGUgc3RyaW5nIGludG8gZG9jdW1lbnQucXVlcnlTZWxlY3RvclxuICAgICAqIDIpIFBhc3NpbmcgdGhlIHN0cmluZyB0byBqUXVlcnksIGlmIGl0IGV4aXN0c1xuICAgICAqIDMpIFBhc3NpbmcgdGhlIHN0cmluZyB0byBTaXp6bGUsIGlmIGl0IGV4aXN0c1xuICAgICAqIDQpIENhbGxpbmcgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQgaWYgaXQgaXMgYSBwbGFpbiBpZFxuICAgICAqXG4gICAgICogRGVmYXVsdCBjYXNlIGlzIHRvIGFzc3VtZSB0aGUgc3RyaW5nIGlzIGEgcGxhaW4gaWQgYW5kIGNhbGxcbiAgICAgKiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCBvbiBpdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZ2V0U3RlcFRhcmdldEhlbHBlcjogZnVuY3Rpb24gZ2V0U3RlcFRhcmdldEhlbHBlcih0YXJnZXQpIHtcbiAgICAgIHZhciByZXN1bHQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0YXJnZXQpO1xuXG4gICAgICAvL0JhY2t3YXJkcyBjb21wYXRpYmlsaXR5OiBhc3N1bWUgdGhlIHN0cmluZyBpcyBhbiBpZFxuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgaWYgKGhhc0pxdWVyeSkge1xuICAgICAgICByZXN1bHQgPSBqUXVlcnkodGFyZ2V0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5sZW5ndGggPyByZXN1bHRbMF0gOiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKFNpenpsZSkge1xuICAgICAgICByZXN1bHQgPSBuZXcgU2l6emxlKHRhcmdldCk7XG4gICAgICAgIHJldHVybiByZXN1bHQubGVuZ3RoID8gcmVzdWx0WzBdIDogbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgfVxuICAgICAgLy8gUmVnZXggdGVzdCBmb3IgaWQuIEZvbGxvd2luZyB0aGUgSFRNTCA0IHNwZWMgZm9yIHZhbGlkIGlkIGZvcm1hdHMuXG4gICAgICAvLyAoaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDQvdHlwZXMuaHRtbCN0eXBlLWlkKVxuICAgICAgaWYgKC9eI1thLXpBLVpdW1xcdy1fOi5dKiQvLnRlc3QodGFyZ2V0KSkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGFyZ2V0LnN1YnN0cmluZygxKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIHN0ZXAsIHJldHVybnMgdGhlIHRhcmdldCBET00gZWxlbWVudCBhc3NvY2lhdGVkIHdpdGggaXQuIEl0IGlzXG4gICAgICogcmVjb21tZW5kZWQgdG8gb25seSBhc3NpZ24gb25lIHRhcmdldCBwZXIgc3RlcC4gSG93ZXZlciwgdGhlcmUgYXJlXG4gICAgICogc29tZSB1c2UgY2FzZXMgd2hpY2ggcmVxdWlyZSBtdWx0aXBsZSBzdGVwIHRhcmdldHMgdG8gYmUgc3VwcGxpZWQuIEluXG4gICAgICogdGhpcyBldmVudCwgd2Ugd2lsbCB1c2UgdGhlIGZpcnN0IHRhcmdldCBpbiB0aGUgYXJyYXkgdGhhdCB3ZSBjYW5cbiAgICAgKiBsb2NhdGUgb24gdGhlIHBhZ2UuIFNlZSB0aGUgY29tbWVudHMgZm9yIGdldFN0ZXBUYXJnZXRIZWxwZXIgZm9yIG1vcmVcbiAgICAgKiBpbmZvcm1hdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZ2V0U3RlcFRhcmdldDogZnVuY3Rpb24gZ2V0U3RlcFRhcmdldChzdGVwKSB7XG4gICAgICB2YXIgcXVlcmllZFRhcmdldDtcblxuICAgICAgaWYgKCFzdGVwIHx8ICFzdGVwLnRhcmdldCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBzdGVwLnRhcmdldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy9KdXN0IG9uZSB0YXJnZXQgdG8gdGVzdC4gQ2hlY2sgYW5kIHJldHVybiBpdHMgcmVzdWx0cy5cbiAgICAgICAgcmV0dXJuIHV0aWxzLmdldFN0ZXBUYXJnZXRIZWxwZXIoc3RlcC50YXJnZXQpO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHN0ZXAudGFyZ2V0KSkge1xuICAgICAgICAvLyBNdWx0aXBsZSBpdGVtcyB0byBjaGVjay4gQ2hlY2sgZWFjaCBhbmQgcmV0dXJuIHRoZSBmaXJzdCBzdWNjZXNzLlxuICAgICAgICAvLyBBc3N1bWluZyB0aGV5IGFyZSBhbGwgc3RyaW5ncy5cbiAgICAgICAgdmFyIGksIGxlbjtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBzdGVwLnRhcmdldC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlmICh0eXBlb2Ygc3RlcC50YXJnZXRbaV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBxdWVyaWVkVGFyZ2V0ID0gdXRpbHMuZ2V0U3RlcFRhcmdldEhlbHBlcihzdGVwLnRhcmdldFtpXSk7XG5cbiAgICAgICAgICAgIGlmIChxdWVyaWVkVGFyZ2V0KSB7XG4gICAgICAgICAgICAgIHJldHVybiBxdWVyaWVkVGFyZ2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gQXNzdW1lIHRoYXQgdGhlIHN0ZXAudGFyZ2V0IGlzIGEgRE9NIGVsZW1lbnRcbiAgICAgIHJldHVybiBzdGVwLnRhcmdldDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2UgbWV0aG9kIGZvciBnZXR0aW5nIGFuIGkxOG4gc3RyaW5nLiBSZXR1cm5zIGN1c3RvbSBpMThuIHZhbHVlXG4gICAgICogb3IgdGhlIGRlZmF1bHQgaTE4biB2YWx1ZSBpZiBubyBjdXN0b20gdmFsdWUgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXRJMThOU3RyaW5nOiBmdW5jdGlvbiBnZXRJMThOU3RyaW5nKGtleSkge1xuICAgICAgcmV0dXJuIGN1c3RvbUkxOE5ba2V5XSB8fCBIb3BzY290Y2hJMThOW2tleV07XG4gICAgfSxcblxuICAgIC8vIFRvdXIgc2Vzc2lvbiBwZXJzaXN0ZW5jZSBmb3IgbXVsdGktcGFnZSB0b3Vycy4gVXNlcyBIVE1MNSBzZXNzaW9uU3RvcmFnZSBpZiBhdmFpbGFibGUsIHRoZW5cbiAgICAvLyBmYWxscyBiYWNrIHRvIHVzaW5nIGNvb2tpZXMuXG4gICAgLy9cbiAgICAvLyBUaGUgZm9sbG93aW5nIGNvb2tpZS1yZWxhdGVkIGxvZ2ljIGlzIGJvcnJvd2VkIGZyb206XG4gICAgLy8gaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9qcy9jb29raWVzLmh0bWxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgc2V0U3RhdGU6IGZ1bmN0aW9uIHNldFN0YXRlKG5hbWUsIHZhbHVlLCBkYXlzKSB7XG4gICAgICB2YXIgZXhwaXJlcyA9ICcnLFxuICAgICAgICAgIGRhdGU7XG5cbiAgICAgIGlmIChoYXNTZXNzaW9uU3RvcmFnZSAmJiBpc1N0b3JhZ2VXcml0YWJsZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0obmFtZSwgdmFsdWUpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBpc1N0b3JhZ2VXcml0YWJsZSA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuc2V0U3RhdGUobmFtZSwgdmFsdWUsIGRheXMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaGFzU2Vzc2lvblN0b3JhZ2UpIHtcbiAgICAgICAgICAvL0NsZWFyIG91dCBleGlzdGluZyBzZXNzaW9uU3RvcmFnZSBrZXkgc28gdGhlIG5ldyB2YWx1ZSB3ZSBzZXQgdG8gY29va2llIGdldHMgcmVhZC5cbiAgICAgICAgICAvLyhJZiB3ZSdyZSBoZXJlLCB3ZSd2ZSBydW4gaW50byBhbiBlcnJvciB3aGlsZSB0cnlpbmcgdG8gd3JpdGUgdG8gc2Vzc2lvblN0b3JhZ2UpLlxuICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0obmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRheXMpIHtcbiAgICAgICAgICBkYXRlID0gbmV3IERhdGUoKTtcbiAgICAgICAgICBkYXRlLnNldFRpbWUoZGF0ZS5nZXRUaW1lKCkgKyBkYXlzICogMjQgKiA2MCAqIDYwICogMTAwMCk7XG4gICAgICAgICAgZXhwaXJlcyA9ICc7IGV4cGlyZXM9JyArIGRhdGUudG9HTVRTdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBkb2N1bWVudC5jb29raWUgPSBuYW1lICsgJz0nICsgdmFsdWUgKyBleHBpcmVzICsgJzsgcGF0aD0vJztcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXRTdGF0ZTogZnVuY3Rpb24gZ2V0U3RhdGUobmFtZSkge1xuICAgICAgdmFyIG5hbWVFUSA9IG5hbWUgKyAnPScsXG4gICAgICAgICAgY2EgPSBkb2N1bWVudC5jb29raWUuc3BsaXQoJzsnKSxcbiAgICAgICAgICBpLFxuICAgICAgICAgIGMsXG4gICAgICAgICAgc3RhdGU7XG5cbiAgICAgIC8vcmV0dXJuIHZhbHVlIGZyb20gc2Vzc2lvbiBzdG9yYWdlIGlmIHdlIGhhdmUgaXRcbiAgICAgIGlmIChoYXNTZXNzaW9uU3RvcmFnZSkge1xuICAgICAgICBzdGF0ZSA9IHNlc3Npb25TdG9yYWdlLmdldEl0ZW0obmFtZSk7XG4gICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvL2Vsc2UsIHRyeSBjb29raWVzXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2EubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYyA9IGNhW2ldO1xuICAgICAgICB3aGlsZSAoYy5jaGFyQXQoMCkgPT09ICcgJykge1xuICAgICAgICAgIGMgPSBjLnN1YnN0cmluZygxLCBjLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMuaW5kZXhPZihuYW1lRVEpID09PSAwKSB7XG4gICAgICAgICAgc3RhdGUgPSBjLnN1YnN0cmluZyhuYW1lRVEubGVuZ3RoLCBjLmxlbmd0aCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNsZWFyU3RhdGU6IGZ1bmN0aW9uIGNsZWFyU3RhdGUobmFtZSkge1xuICAgICAgaWYgKGhhc1Nlc3Npb25TdG9yYWdlKSB7XG4gICAgICAgIHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0obmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNldFN0YXRlKG5hbWUsICcnLCAtMSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9yaWdpbmFsbHkgY2FsbGVkIGl0IG9yaWVudGF0aW9uLCBidXQgcGxhY2VtZW50IGlzIG1vcmUgaW50dWl0aXZlLlxuICAgICAqIEFsbG93aW5nIGJvdGggZm9yIG5vdyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBub3JtYWxpemVQbGFjZW1lbnQ6IGZ1bmN0aW9uIG5vcm1hbGl6ZVBsYWNlbWVudChzdGVwKSB7XG4gICAgICBpZiAoIXN0ZXAucGxhY2VtZW50ICYmIHN0ZXAub3JpZW50YXRpb24pIHtcbiAgICAgICAgc3RlcC5wbGFjZW1lbnQgPSBzdGVwLm9yaWVudGF0aW9uO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJZiBzdGVwIGlzIHJpZ2h0LXRvLWxlZnQgZW5hYmxlZCwgZmxpcCB0aGUgcGxhY2VtZW50IGFuZCB4T2Zmc2V0LCBidXQgb25seSBvbmNlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZmxpcFBsYWNlbWVudDogZnVuY3Rpb24gZmxpcFBsYWNlbWVudChzdGVwKSB7XG4gICAgICBpZiAoc3RlcC5pc1J0bCAmJiAhc3RlcC5faXNGbGlwcGVkKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IFsnb3JpZW50YXRpb24nLCAncGxhY2VtZW50J10sXG4gICAgICAgICAgICBwcm9wLFxuICAgICAgICAgICAgaTtcbiAgICAgICAgaWYgKHN0ZXAueE9mZnNldCkge1xuICAgICAgICAgIHN0ZXAueE9mZnNldCA9IC0xICogdGhpcy5nZXRQaXhlbFZhbHVlKHN0ZXAueE9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpIGluIHByb3BzKSB7XG4gICAgICAgICAgcHJvcCA9IHByb3BzW2ldO1xuICAgICAgICAgIGlmIChzdGVwLmhhc093blByb3BlcnR5KHByb3ApICYmIHJ0bE1hdGNoZXMuaGFzT3duUHJvcGVydHkoc3RlcFtwcm9wXSkpIHtcbiAgICAgICAgICAgIHN0ZXBbcHJvcF0gPSBydGxNYXRjaGVzW3N0ZXBbcHJvcF1dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGVwLl9pc0ZsaXBwZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB1dGlscy5hZGRFdnRMaXN0ZW5lcih3aW5kb3csICdsb2FkJywgd2luTG9hZEhhbmRsZXIpO1xuXG4gIGNhbGxiYWNrcyA9IHtcbiAgICBuZXh0OiBbXSxcbiAgICBwcmV2OiBbXSxcbiAgICBzdGFydDogW10sXG4gICAgZW5kOiBbXSxcbiAgICBzaG93OiBbXSxcbiAgICBlcnJvcjogW10sXG4gICAgY2xvc2U6IFtdXG4gIH07XG5cbiAgLyoqXG4gICAqIGhlbHBlcnNcbiAgICogPT09PT09PVxuICAgKiBBIG1hcCBvZiBmdW5jdGlvbnMgdG8gYmUgdXNlZCBhcyBjYWxsYmFjayBsaXN0ZW5lcnMuIEZ1bmN0aW9ucyBhcmVcbiAgICogYWRkZWQgdG8gYW5kIHJlbW92ZWQgZnJvbSB0aGUgbWFwIHVzaW5nIHRoZSBmdW5jdGlvbnNcbiAgICogSG9wc2NvdGNoLnJlZ2lzdGVySGVscGVyKCkgYW5kIEhvcHNjb3RjaC51bnJlZ2lzdGVySGVscGVyKCkuXG4gICAqL1xuICBoZWxwZXJzID0ge307XG5cbiAgSG9wc2NvdGNoSTE4TiA9IHtcbiAgICBzdGVwTnVtczogbnVsbCxcbiAgICBuZXh0QnRuOiAnTmV4dCcsXG4gICAgcHJldkJ0bjogJ0JhY2snLFxuICAgIGRvbmVCdG46ICdEb25lJyxcbiAgICBza2lwQnRuOiAnU2tpcCcsXG4gICAgY2xvc2VUb29sdGlwOiAnQ2xvc2UnXG4gIH07XG5cbiAgY3VzdG9tSTE4TiA9IHt9OyAvLyBEZXZlbG9wZXIncyBjdXN0b20gaTE4biBzdHJpbmdzIGdvZXMgaGVyZS5cblxuICAvKipcbiAgICogSG9wc2NvdGNoQnViYmxlXG4gICAqXG4gICAqIEBjbGFzcyBUaGUgSG9wc2NvdGNoQnViYmxlIGNsYXNzIHJlcHJlc2VudHMgdGhlIHZpZXcgb2YgYSBidWJibGUuIFRoaXMgY2xhc3MgaXMgYWxzbyB1c2VkIGZvciBIb3BzY290Y2ggY2FsbG91dHMuXG4gICAqL1xuICBIb3BzY290Y2hCdWJibGUgPSBmdW5jdGlvbiBIb3BzY290Y2hCdWJibGUob3B0KSB7XG4gICAgdGhpcy5pbml0KG9wdCk7XG4gIH07XG5cbiAgSG9wc2NvdGNoQnViYmxlLnByb3RvdHlwZSA9IHtcbiAgICBpc1Nob3dpbmc6IGZhbHNlLFxuXG4gICAgY3VyclN0ZXA6IHVuZGVmaW5lZCxcblxuICAgIC8qKlxuICAgICAqIHNldFBvc2l0aW9uXG4gICAgICpcbiAgICAgKiBTZXRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgYnViYmxlIHVzaW5nIHRoZSBib3VuZGluZyByZWN0YW5nbGUgb2YgdGhlXG4gICAgICogdGFyZ2V0IGVsZW1lbnQgYW5kIHRoZSBvcmllbnRhdGlvbiBhbmQgb2Zmc2V0IGluZm9ybWF0aW9uIHNwZWNpZmllZCBieVxuICAgICAqIHRoZSBKU09OLlxuICAgICAqL1xuICAgIHNldFBvc2l0aW9uOiBmdW5jdGlvbiBzZXRQb3NpdGlvbihzdGVwKSB7XG4gICAgICB2YXIgYnViYmxlQm91bmRpbmdIZWlnaHQsXG4gICAgICAgICAgYnViYmxlQm91bmRpbmdXaWR0aCxcbiAgICAgICAgICBib3VuZGluZ1JlY3QsXG4gICAgICAgICAgdG9wLFxuICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgYXJyb3dPZmZzZXQsXG4gICAgICAgICAgdmVydGljYWxMZWZ0UG9zaXRpb24sXG4gICAgICAgICAgdGFyZ2V0RWwgPSB1dGlscy5nZXRTdGVwVGFyZ2V0KHN0ZXApLFxuICAgICAgICAgIGVsID0gdGhpcy5lbGVtZW50LFxuICAgICAgICAgIGFycm93RWwgPSB0aGlzLmFycm93RWwsXG4gICAgICAgICAgYXJyb3dQb3MgPSBzdGVwLmlzUnRsID8gJ3JpZ2h0JyA6ICdsZWZ0JztcblxuICAgICAgdXRpbHMuZmxpcFBsYWNlbWVudChzdGVwKTtcbiAgICAgIHV0aWxzLm5vcm1hbGl6ZVBsYWNlbWVudChzdGVwKTtcblxuICAgICAgYnViYmxlQm91bmRpbmdXaWR0aCA9IGVsLm9mZnNldFdpZHRoO1xuICAgICAgYnViYmxlQm91bmRpbmdIZWlnaHQgPSBlbC5vZmZzZXRIZWlnaHQ7XG4gICAgICB1dGlscy5yZW1vdmVDbGFzcyhlbCwgJ2ZhZGUtaW4tZG93biBmYWRlLWluLXVwIGZhZGUtaW4tbGVmdCBmYWRlLWluLXJpZ2h0Jyk7XG5cbiAgICAgIC8vIFNFVCBQT1NJVElPTlxuICAgICAgYm91bmRpbmdSZWN0ID0gdGFyZ2V0RWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgIHZlcnRpY2FsTGVmdFBvc2l0aW9uID0gc3RlcC5pc1J0bCA/IGJvdW5kaW5nUmVjdC5yaWdodCAtIGJ1YmJsZUJvdW5kaW5nV2lkdGggOiBib3VuZGluZ1JlY3QubGVmdDtcblxuICAgICAgaWYgKHN0ZXAucGxhY2VtZW50ID09PSAndG9wJykge1xuICAgICAgICB0b3AgPSBib3VuZGluZ1JlY3QudG9wIC0gYnViYmxlQm91bmRpbmdIZWlnaHQgLSB0aGlzLm9wdC5hcnJvd1dpZHRoO1xuICAgICAgICBsZWZ0ID0gdmVydGljYWxMZWZ0UG9zaXRpb247XG4gICAgICB9IGVsc2UgaWYgKHN0ZXAucGxhY2VtZW50ID09PSAnYm90dG9tJykge1xuICAgICAgICB0b3AgPSBib3VuZGluZ1JlY3QuYm90dG9tICsgdGhpcy5vcHQuYXJyb3dXaWR0aDtcbiAgICAgICAgbGVmdCA9IHZlcnRpY2FsTGVmdFBvc2l0aW9uO1xuICAgICAgfSBlbHNlIGlmIChzdGVwLnBsYWNlbWVudCA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIHRvcCA9IGJvdW5kaW5nUmVjdC50b3A7XG4gICAgICAgIGxlZnQgPSBib3VuZGluZ1JlY3QubGVmdCAtIGJ1YmJsZUJvdW5kaW5nV2lkdGggLSB0aGlzLm9wdC5hcnJvd1dpZHRoO1xuICAgICAgfSBlbHNlIGlmIChzdGVwLnBsYWNlbWVudCA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICB0b3AgPSBib3VuZGluZ1JlY3QudG9wO1xuICAgICAgICBsZWZ0ID0gYm91bmRpbmdSZWN0LnJpZ2h0ICsgdGhpcy5vcHQuYXJyb3dXaWR0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQnViYmxlIHBsYWNlbWVudCBmYWlsZWQgYmVjYXVzZSBzdGVwLnBsYWNlbWVudCBpcyBpbnZhbGlkIG9yIHVuZGVmaW5lZCEnKTtcbiAgICAgIH1cblxuICAgICAgLy8gU0VUIChPUiBSRVNFVCkgQVJST1cgT0ZGU0VUU1xuICAgICAgaWYgKHN0ZXAuYXJyb3dPZmZzZXQgIT09ICdjZW50ZXInKSB7XG4gICAgICAgIGFycm93T2Zmc2V0ID0gdXRpbHMuZ2V0UGl4ZWxWYWx1ZShzdGVwLmFycm93T2Zmc2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFycm93T2Zmc2V0ID0gc3RlcC5hcnJvd09mZnNldDtcbiAgICAgIH1cbiAgICAgIGlmICghYXJyb3dPZmZzZXQpIHtcbiAgICAgICAgYXJyb3dFbC5zdHlsZS50b3AgPSAnJztcbiAgICAgICAgYXJyb3dFbC5zdHlsZVthcnJvd1Bvc10gPSAnJztcbiAgICAgIH0gZWxzZSBpZiAoc3RlcC5wbGFjZW1lbnQgPT09ICd0b3AnIHx8IHN0ZXAucGxhY2VtZW50ID09PSAnYm90dG9tJykge1xuICAgICAgICBhcnJvd0VsLnN0eWxlLnRvcCA9ICcnO1xuICAgICAgICBpZiAoYXJyb3dPZmZzZXQgPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgYXJyb3dFbC5zdHlsZVthcnJvd1Bvc10gPSBNYXRoLmZsb29yKGJ1YmJsZUJvdW5kaW5nV2lkdGggLyAyIC0gYXJyb3dFbC5vZmZzZXRXaWR0aCAvIDIpICsgJ3B4JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBOdW1lcmljIHBpeGVsIHZhbHVlXG4gICAgICAgICAgYXJyb3dFbC5zdHlsZVthcnJvd1Bvc10gPSBhcnJvd09mZnNldCArICdweCc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc3RlcC5wbGFjZW1lbnQgPT09ICdsZWZ0JyB8fCBzdGVwLnBsYWNlbWVudCA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICBhcnJvd0VsLnN0eWxlW2Fycm93UG9zXSA9ICcnO1xuICAgICAgICBpZiAoYXJyb3dPZmZzZXQgPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgYXJyb3dFbC5zdHlsZS50b3AgPSBNYXRoLmZsb29yKGJ1YmJsZUJvdW5kaW5nSGVpZ2h0IC8gMiAtIGFycm93RWwub2Zmc2V0SGVpZ2h0IC8gMikgKyAncHgnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE51bWVyaWMgcGl4ZWwgdmFsdWVcbiAgICAgICAgICBhcnJvd0VsLnN0eWxlLnRvcCA9IGFycm93T2Zmc2V0ICsgJ3B4JztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBIT1JJWk9OVEFMIE9GRlNFVFxuICAgICAgaWYgKHN0ZXAueE9mZnNldCA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgbGVmdCA9IGJvdW5kaW5nUmVjdC5sZWZ0ICsgdGFyZ2V0RWwub2Zmc2V0V2lkdGggLyAyIC0gYnViYmxlQm91bmRpbmdXaWR0aCAvIDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZWZ0ICs9IHV0aWxzLmdldFBpeGVsVmFsdWUoc3RlcC54T2Zmc2V0KTtcbiAgICAgIH1cbiAgICAgIC8vIFZFUlRJQ0FMIE9GRlNFVFxuICAgICAgaWYgKHN0ZXAueU9mZnNldCA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgdG9wID0gYm91bmRpbmdSZWN0LnRvcCArIHRhcmdldEVsLm9mZnNldEhlaWdodCAvIDIgLSBidWJibGVCb3VuZGluZ0hlaWdodCAvIDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0b3AgKz0gdXRpbHMuZ2V0UGl4ZWxWYWx1ZShzdGVwLnlPZmZzZXQpO1xuICAgICAgfVxuXG4gICAgICAvLyBBREpVU1QgVE9QIEZPUiBTQ1JPTEwgUE9TSVRJT05cbiAgICAgIGlmICghc3RlcC5maXhlZEVsZW1lbnQpIHtcbiAgICAgICAgdG9wICs9IHV0aWxzLmdldFNjcm9sbFRvcCgpO1xuICAgICAgICBsZWZ0ICs9IHV0aWxzLmdldFNjcm9sbExlZnQoKTtcbiAgICAgIH1cblxuICAgICAgLy8gQUNDT1VOVCBGT1IgRklYRUQgUE9TSVRJT04gRUxFTUVOVFNcbiAgICAgIGVsLnN0eWxlLnBvc2l0aW9uID0gc3RlcC5maXhlZEVsZW1lbnQgPyAnZml4ZWQnIDogJ2Fic29sdXRlJztcblxuICAgICAgZWwuc3R5bGUudG9wID0gdG9wICsgJ3B4JztcbiAgICAgIGVsLnN0eWxlLmxlZnQgPSBsZWZ0ICsgJ3B4JztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgYnViYmxlIGFjY29yZGluZyB0byB0aGUgc3RlcCBKU09OLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0ZXAgSW5mb3JtYXRpb24gZGVmaW5pbmcgaG93IHRoZSBidWJibGUgc2hvdWxkIGxvb2suXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGlkeCBUaGUgaW5kZXggb2YgdGhlIHN0ZXAgaW4gdGhlIHRvdXIuIE5vdCB1c2VkIGZvciBjYWxsb3V0cy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBGdW5jdGlvbiB0byBiZSBpbnZva2VkIGFmdGVyIHJlbmRlcmluZyBpcyBmaW5pc2hlZC5cbiAgICAgKi9cbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihzdGVwLCBpZHgsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgZWwgPSB0aGlzLmVsZW1lbnQsXG4gICAgICAgICAgdG91clNwZWNpZmljUmVuZGVyZXIsXG4gICAgICAgICAgY3VzdG9tVG91ckRhdGEsXG4gICAgICAgICAgdW5zYWZlLFxuICAgICAgICAgIGN1cnJUb3VyLFxuICAgICAgICAgIHRvdGFsU3RlcHMsXG4gICAgICAgICAgdG90YWxTdGVwc0kxOG4sXG4gICAgICAgICAgbmV4dEJ0blRleHQsXG4gICAgICAgICAgaXNMYXN0LFxuICAgICAgICAgIGksXG4gICAgICAgICAgb3B0cztcblxuICAgICAgLy8gQ2FjaGUgY3VycmVudCBzdGVwIGluZm9ybWF0aW9uLlxuICAgICAgaWYgKHN0ZXApIHtcbiAgICAgICAgdGhpcy5jdXJyU3RlcCA9IHN0ZXA7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuY3VyclN0ZXApIHtcbiAgICAgICAgc3RlcCA9IHRoaXMuY3VyclN0ZXA7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGN1cnJlbnQgdG91ciBmb3IgdG90YWwgbnVtYmVyIG9mIHN0ZXBzIGFuZCBjdXN0b20gcmVuZGVyIGRhdGFcbiAgICAgIGlmICh0aGlzLm9wdC5pc1RvdXJCdWJibGUpIHtcbiAgICAgICAgY3VyclRvdXIgPSB3aW5Ib3BzY290Y2guZ2V0Q3VyclRvdXIoKTtcbiAgICAgICAgaWYgKGN1cnJUb3VyKSB7XG4gICAgICAgICAgY3VzdG9tVG91ckRhdGEgPSBjdXJyVG91ci5jdXN0b21EYXRhO1xuICAgICAgICAgIHRvdXJTcGVjaWZpY1JlbmRlcmVyID0gY3VyclRvdXIuY3VzdG9tUmVuZGVyZXI7XG4gICAgICAgICAgc3RlcC5pc1J0bCA9IHN0ZXAuaGFzT3duUHJvcGVydHkoJ2lzUnRsJykgPyBzdGVwLmlzUnRsIDogY3VyclRvdXIuaGFzT3duUHJvcGVydHkoJ2lzUnRsJykgPyBjdXJyVG91ci5pc1J0bCA6IHRoaXMub3B0LmlzUnRsO1xuICAgICAgICAgIHVuc2FmZSA9IGN1cnJUb3VyLnVuc2FmZTtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjdXJyVG91ci5zdGVwcykpIHtcbiAgICAgICAgICAgIHRvdGFsU3RlcHMgPSBjdXJyVG91ci5zdGVwcy5sZW5ndGg7XG4gICAgICAgICAgICB0b3RhbFN0ZXBzSTE4biA9IHRoaXMuX2dldFN0ZXBJMThuTnVtKHRoaXMuX2dldFN0ZXBOdW0odG90YWxTdGVwcyAtIDEpKTtcbiAgICAgICAgICAgIGlzTGFzdCA9IHRoaXMuX2dldFN0ZXBOdW0oaWR4KSA9PT0gdGhpcy5fZ2V0U3RlcE51bSh0b3RhbFN0ZXBzIC0gMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXN0b21Ub3VyRGF0YSA9IHN0ZXAuY3VzdG9tRGF0YTtcbiAgICAgICAgdG91clNwZWNpZmljUmVuZGVyZXIgPSBzdGVwLmN1c3RvbVJlbmRlcmVyO1xuICAgICAgICB1bnNhZmUgPSBzdGVwLnVuc2FmZTtcbiAgICAgICAgc3RlcC5pc1J0bCA9IHN0ZXAuaGFzT3duUHJvcGVydHkoJ2lzUnRsJykgPyBzdGVwLmlzUnRsIDogdGhpcy5vcHQuaXNSdGw7XG4gICAgICB9XG5cbiAgICAgIC8vIERldGVybWluZSBsYWJlbCBmb3IgbmV4dCBidXR0b25cbiAgICAgIGlmIChpc0xhc3QpIHtcbiAgICAgICAgbmV4dEJ0blRleHQgPSB1dGlscy5nZXRJMThOU3RyaW5nKCdkb25lQnRuJyk7XG4gICAgICB9IGVsc2UgaWYgKHN0ZXAuc2hvd1NraXApIHtcbiAgICAgICAgbmV4dEJ0blRleHQgPSB1dGlscy5nZXRJMThOU3RyaW5nKCdza2lwQnRuJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0QnRuVGV4dCA9IHV0aWxzLmdldEkxOE5TdHJpbmcoJ25leHRCdG4nKTtcbiAgICAgIH1cblxuICAgICAgdXRpbHMuZmxpcFBsYWNlbWVudChzdGVwKTtcbiAgICAgIHV0aWxzLm5vcm1hbGl6ZVBsYWNlbWVudChzdGVwKTtcblxuICAgICAgdGhpcy5wbGFjZW1lbnQgPSBzdGVwLnBsYWNlbWVudDtcblxuICAgICAgLy8gU2V0dXAgdGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB3ZSB3YW50IHRvIHBhc3MgYWxvbmcgdG8gdGhlIHRlbXBsYXRlXG4gICAgICBvcHRzID0ge1xuICAgICAgICBpMThuOiB7XG4gICAgICAgICAgcHJldkJ0bjogdXRpbHMuZ2V0STE4TlN0cmluZygncHJldkJ0bicpLFxuICAgICAgICAgIG5leHRCdG46IG5leHRCdG5UZXh0LFxuICAgICAgICAgIGNsb3NlVG9vbHRpcDogdXRpbHMuZ2V0STE4TlN0cmluZygnY2xvc2VUb29sdGlwJyksXG4gICAgICAgICAgc3RlcE51bTogdGhpcy5fZ2V0U3RlcEkxOG5OdW0odGhpcy5fZ2V0U3RlcE51bShpZHgpKSxcbiAgICAgICAgICBudW1TdGVwczogdG90YWxTdGVwc0kxOG5cbiAgICAgICAgfSxcbiAgICAgICAgYnV0dG9uczoge1xuICAgICAgICAgIHNob3dQcmV2OiB1dGlscy52YWxPckRlZmF1bHQoc3RlcC5zaG93UHJldkJ1dHRvbiwgdGhpcy5vcHQuc2hvd1ByZXZCdXR0b24pICYmIHRoaXMuX2dldFN0ZXBOdW0oaWR4KSA+IDAsXG4gICAgICAgICAgc2hvd05leHQ6IHV0aWxzLnZhbE9yRGVmYXVsdChzdGVwLnNob3dOZXh0QnV0dG9uLCB0aGlzLm9wdC5zaG93TmV4dEJ1dHRvbiksXG4gICAgICAgICAgc2hvd0NUQTogdXRpbHMudmFsT3JEZWZhdWx0KHN0ZXAuc2hvd0NUQUJ1dHRvbiAmJiBzdGVwLmN0YUxhYmVsLCBmYWxzZSksXG4gICAgICAgICAgY3RhTGFiZWw6IHN0ZXAuY3RhTGFiZWwsXG4gICAgICAgICAgc2hvd0Nsb3NlOiB1dGlscy52YWxPckRlZmF1bHQodGhpcy5vcHQuc2hvd0Nsb3NlQnV0dG9uLCB0cnVlKVxuICAgICAgICB9LFxuICAgICAgICBzdGVwOiB7XG4gICAgICAgICAgbnVtOiBpZHgsXG4gICAgICAgICAgaXNMYXN0OiB1dGlscy52YWxPckRlZmF1bHQoaXNMYXN0LCBmYWxzZSksXG4gICAgICAgICAgdGl0bGU6IHN0ZXAudGl0bGUgfHwgJycsXG4gICAgICAgICAgY29udGVudDogc3RlcC5jb250ZW50IHx8ICcnLFxuICAgICAgICAgIGlzUnRsOiBzdGVwLmlzUnRsLFxuICAgICAgICAgIHBsYWNlbWVudDogc3RlcC5wbGFjZW1lbnQsXG4gICAgICAgICAgcGFkZGluZzogdXRpbHMudmFsT3JEZWZhdWx0KHN0ZXAucGFkZGluZywgdGhpcy5vcHQuYnViYmxlUGFkZGluZyksXG4gICAgICAgICAgd2lkdGg6IHV0aWxzLmdldFBpeGVsVmFsdWUoc3RlcC53aWR0aCkgfHwgdGhpcy5vcHQuYnViYmxlV2lkdGgsXG4gICAgICAgICAgY3VzdG9tRGF0YTogc3RlcC5jdXN0b21EYXRhIHx8IHt9XG4gICAgICAgIH0sXG4gICAgICAgIHRvdXI6IHtcbiAgICAgICAgICBpc1RvdXI6IHRoaXMub3B0LmlzVG91ckJ1YmJsZSxcbiAgICAgICAgICBudW1TdGVwczogdG90YWxTdGVwcyxcbiAgICAgICAgICB1bnNhZmU6IHV0aWxzLnZhbE9yRGVmYXVsdCh1bnNhZmUsIGZhbHNlKSxcbiAgICAgICAgICBjdXN0b21EYXRhOiBjdXN0b21Ub3VyRGF0YSB8fCB7fVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBSZW5kZXIgdGhlIGJ1YmJsZSdzIGNvbnRlbnQuXG4gICAgICAvLyBVc2UgdG91ciByZW5kZXJlciBpZiBhdmFpbGFibGUsIHRoZW4gdGhlIGdsb2JhbCBjdXN0b21SZW5kZXJlciBpZiBkZWZpbmVkLlxuICAgICAgaWYgKHR5cGVvZiB0b3VyU3BlY2lmaWNSZW5kZXJlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBlbC5pbm5lckhUTUwgPSB0b3VyU3BlY2lmaWNSZW5kZXJlcihvcHRzKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRvdXJTcGVjaWZpY1JlbmRlcmVyID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoIXdpbkhvcHNjb3RjaC50ZW1wbGF0ZXMgfHwgdHlwZW9mIHdpbkhvcHNjb3RjaC50ZW1wbGF0ZXNbdG91clNwZWNpZmljUmVuZGVyZXJdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCdWJibGUgcmVuZGVyaW5nIGZhaWxlZCAtIHRlbXBsYXRlIFwiJyArIHRvdXJTcGVjaWZpY1JlbmRlcmVyICsgJ1wiIGlzIG5vdCBhIGZ1bmN0aW9uLicpO1xuICAgICAgICB9XG4gICAgICAgIGVsLmlubmVySFRNTCA9IHdpbkhvcHNjb3RjaC50ZW1wbGF0ZXNbdG91clNwZWNpZmljUmVuZGVyZXJdKG9wdHMpO1xuICAgICAgfSBlbHNlIGlmIChjdXN0b21SZW5kZXJlcikge1xuICAgICAgICBlbC5pbm5lckhUTUwgPSBjdXN0b21SZW5kZXJlcihvcHRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghd2luSG9wc2NvdGNoLnRlbXBsYXRlcyB8fCB0eXBlb2Ygd2luSG9wc2NvdGNoLnRlbXBsYXRlc1t0ZW1wbGF0ZVRvVXNlXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQnViYmxlIHJlbmRlcmluZyBmYWlsZWQgLSB0ZW1wbGF0ZSBcIicgKyB0ZW1wbGF0ZVRvVXNlICsgJ1wiIGlzIG5vdCBhIGZ1bmN0aW9uLicpO1xuICAgICAgICB9XG4gICAgICAgIGVsLmlubmVySFRNTCA9IHdpbkhvcHNjb3RjaC50ZW1wbGF0ZXNbdGVtcGxhdGVUb1VzZV0ob3B0cyk7XG4gICAgICB9XG5cbiAgICAgIC8vIEZpbmQgYXJyb3cgYW1vbmcgbmV3IGNoaWxkIGVsZW1lbnRzLlxuICAgICAgdmFyIGNoaWxkcmVuID0gZWwuY2hpbGRyZW47XG4gICAgICB2YXIgbnVtQ2hpbGRyZW4gPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgICB2YXIgbm9kZTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1DaGlsZHJlbjsgaSsrKSB7XG4gICAgICAgIG5vZGUgPSBjaGlsZHJlbltpXTtcblxuICAgICAgICBpZiAodXRpbHMuaGFzQ2xhc3Mobm9kZSwgJ2hvcHNjb3RjaC1hcnJvdycpKSB7XG4gICAgICAgICAgdGhpcy5hcnJvd0VsID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBTZXQgei1pbmRleCBhbmQgYXJyb3cgcGxhY2VtZW50XG4gICAgICBlbC5zdHlsZS56SW5kZXggPSB0eXBlb2Ygc3RlcC56aW5kZXggPT09ICdudW1iZXInID8gc3RlcC56aW5kZXggOiAnJztcbiAgICAgIHRoaXMuX3NldEFycm93KHN0ZXAucGxhY2VtZW50KTtcblxuICAgICAgLy8gU2V0IGJ1YmJsZSBwb3NpdGlvbmluZ1xuICAgICAgLy8gTWFrZSBzdXJlIHdlJ3JlIHVzaW5nIHZpc2liaWxpdHk6aGlkZGVuIGluc3RlYWQgb2YgZGlzcGxheTpub25lIGZvciBoZWlnaHQvd2lkdGggY2FsY3VsYXRpb25zLlxuICAgICAgdGhpcy5oaWRlKGZhbHNlKTtcbiAgICAgIHRoaXMuc2V0UG9zaXRpb24oc3RlcCk7XG5cbiAgICAgIC8vIG9ubHkgd2FudCB0byBhZGp1c3Qgd2luZG93IHNjcm9sbCBmb3Igbm9uLWZpeGVkIGVsZW1lbnRzXG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2soIXN0ZXAuZml4ZWRFbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgc3RlcCBudW1iZXIgY29uc2lkZXJpbmcgc3RlcHMgdGhhdCB3ZXJlIHNraXBwZWQgYmVjYXVzZSB0aGVpciB0YXJnZXQgd2Fzbid0IGZvdW5kXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRTdGVwTnVtOiBmdW5jdGlvbiBfZ2V0U3RlcE51bShpZHgpIHtcbiAgICAgIHZhciBza2lwcGVkU3RlcHNDb3VudCA9IDAsXG4gICAgICAgICAgc3RlcElkeCxcbiAgICAgICAgICBza2lwcGVkU3RlcHMgPSB3aW5Ib3BzY290Y2guZ2V0U2tpcHBlZFN0ZXBzSW5kZXhlcygpLFxuICAgICAgICAgIGksXG4gICAgICAgICAgbGVuID0gc2tpcHBlZFN0ZXBzLmxlbmd0aDtcbiAgICAgIC8vY291bnQgbnVtYmVyIG9mIHN0ZXBzIHNraXBwZWQgYmVmb3JlIGN1cnJlbnQgc3RlcFxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHN0ZXBJZHggPSBza2lwcGVkU3RlcHNbaV07XG4gICAgICAgIGlmIChzdGVwSWR4IDwgaWR4KSB7XG4gICAgICAgICAgc2tpcHBlZFN0ZXBzQ291bnQrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGlkeCAtIHNraXBwZWRTdGVwc0NvdW50O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBJMThOIHN0ZXAgbnVtYmVyIGZvciB0aGUgY3VycmVudCBzdGVwLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0U3RlcEkxOG5OdW06IGZ1bmN0aW9uIF9nZXRTdGVwSTE4bk51bShpZHgpIHtcbiAgICAgIHZhciBzdGVwTnVtSTE4TiA9IHV0aWxzLmdldEkxOE5TdHJpbmcoJ3N0ZXBOdW1zJyk7XG4gICAgICBpZiAoc3RlcE51bUkxOE4gJiYgaWR4IDwgc3RlcE51bUkxOE4ubGVuZ3RoKSB7XG4gICAgICAgIGlkeCA9IHN0ZXBOdW1JMThOW2lkeF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZHggPSBpZHggKyAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlkeDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB3aGljaCBzaWRlIHRoZSBhcnJvdyBpcyBvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldEFycm93OiBmdW5jdGlvbiBfc2V0QXJyb3cocGxhY2VtZW50KSB7XG4gICAgICB1dGlscy5yZW1vdmVDbGFzcyh0aGlzLmFycm93RWwsICdkb3duIHVwIHJpZ2h0IGxlZnQnKTtcblxuICAgICAgLy8gV2hhdGV2ZXIgdGhlIG9yaWVudGF0aW9uIGlzLCB3ZSB3YW50IHRvIGFycm93IHRvIGFwcGVhclxuICAgICAgLy8gXCJvcHBvc2l0ZVwiIG9mIHRoZSBvcmllbnRhdGlvbi4gRS5nLiwgYSB0b3Agb3JpZW50YXRpb25cbiAgICAgIC8vIHJlcXVpcmVzIGEgYm90dG9tIGFycm93LlxuICAgICAgaWYgKHBsYWNlbWVudCA9PT0gJ3RvcCcpIHtcbiAgICAgICAgdXRpbHMuYWRkQ2xhc3ModGhpcy5hcnJvd0VsLCAnZG93bicpO1xuICAgICAgfSBlbHNlIGlmIChwbGFjZW1lbnQgPT09ICdib3R0b20nKSB7XG4gICAgICAgIHV0aWxzLmFkZENsYXNzKHRoaXMuYXJyb3dFbCwgJ3VwJyk7XG4gICAgICB9IGVsc2UgaWYgKHBsYWNlbWVudCA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIHV0aWxzLmFkZENsYXNzKHRoaXMuYXJyb3dFbCwgJ3JpZ2h0Jyk7XG4gICAgICB9IGVsc2UgaWYgKHBsYWNlbWVudCA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICB1dGlscy5hZGRDbGFzcyh0aGlzLmFycm93RWwsICdsZWZ0Jyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldEFycm93RGlyZWN0aW9uOiBmdW5jdGlvbiBfZ2V0QXJyb3dEaXJlY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5wbGFjZW1lbnQgPT09ICd0b3AnKSB7XG4gICAgICAgIHJldHVybiAnZG93bic7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5wbGFjZW1lbnQgPT09ICdib3R0b20nKSB7XG4gICAgICAgIHJldHVybiAndXAnO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucGxhY2VtZW50ID09PSAnbGVmdCcpIHtcbiAgICAgICAgcmV0dXJuICdyaWdodCc7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5wbGFjZW1lbnQgPT09ICdyaWdodCcpIHtcbiAgICAgICAgcmV0dXJuICdsZWZ0JztcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc2hvdzogZnVuY3Rpb24gc2hvdygpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICBmYWRlQ2xhc3MgPSAnZmFkZS1pbi0nICsgdGhpcy5fZ2V0QXJyb3dEaXJlY3Rpb24oKSxcbiAgICAgICAgICBmYWRlRHVyID0gMTAwMDtcblxuICAgICAgdXRpbHMucmVtb3ZlQ2xhc3ModGhpcy5lbGVtZW50LCAnaGlkZScpO1xuICAgICAgdXRpbHMuYWRkQ2xhc3ModGhpcy5lbGVtZW50LCBmYWRlQ2xhc3MpO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHV0aWxzLnJlbW92ZUNsYXNzKHNlbGYuZWxlbWVudCwgJ2ludmlzaWJsZScpO1xuICAgICAgfSwgNTApO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHV0aWxzLnJlbW92ZUNsYXNzKHNlbGYuZWxlbWVudCwgZmFkZUNsYXNzKTtcbiAgICAgIH0sIGZhZGVEdXIpO1xuICAgICAgdGhpcy5pc1Nob3dpbmcgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGhpZGU6IGZ1bmN0aW9uIGhpZGUocmVtb3ZlKSB7XG4gICAgICB2YXIgZWwgPSB0aGlzLmVsZW1lbnQ7XG5cbiAgICAgIHJlbW92ZSA9IHV0aWxzLnZhbE9yRGVmYXVsdChyZW1vdmUsIHRydWUpO1xuICAgICAgZWwuc3R5bGUudG9wID0gJyc7XG4gICAgICBlbC5zdHlsZS5sZWZ0ID0gJyc7XG5cbiAgICAgIC8vIGRpc3BsYXk6IG5vbmVcbiAgICAgIGlmIChyZW1vdmUpIHtcbiAgICAgICAgdXRpbHMuYWRkQ2xhc3MoZWwsICdoaWRlJyk7XG4gICAgICAgIHV0aWxzLnJlbW92ZUNsYXNzKGVsLCAnaW52aXNpYmxlJyk7XG4gICAgICB9XG4gICAgICAvLyBvcGFjaXR5OiAwXG4gICAgICBlbHNlIHtcbiAgICAgICAgICB1dGlscy5yZW1vdmVDbGFzcyhlbCwgJ2hpZGUnKTtcbiAgICAgICAgICB1dGlscy5hZGRDbGFzcyhlbCwgJ2ludmlzaWJsZScpO1xuICAgICAgICB9XG4gICAgICB1dGlscy5yZW1vdmVDbGFzcyhlbCwgJ2FuaW1hdGUgZmFkZS1pbi11cCBmYWRlLWluLWRvd24gZmFkZS1pbi1yaWdodCBmYWRlLWluLWxlZnQnKTtcbiAgICAgIHRoaXMuaXNTaG93aW5nID0gZmFsc2U7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHZhciBlbCA9IHRoaXMuZWxlbWVudDtcblxuICAgICAgaWYgKGVsKSB7XG4gICAgICAgIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgfVxuICAgICAgdXRpbHMucmVtb3ZlRXZ0TGlzdGVuZXIoZWwsICdjbGljaycsIHRoaXMuY2xpY2tDYik7XG4gICAgfSxcblxuICAgIF9oYW5kbGVCdWJibGVDbGljazogZnVuY3Rpb24gX2hhbmRsZUJ1YmJsZUNsaWNrKGV2dCkge1xuICAgICAgdmFyIGFjdGlvbjtcblxuICAgICAgLy8gT3ZlcnJpZGUgZXZ0IGZvciBJRTggYXMgSUU4IGRvZXNuJ3QgcGFzcyBldmVudCBidXQgYmluZHMgaXQgdG8gd2luZG93XG4gICAgICBldnQgPSBldnQgfHwgd2luZG93LmV2ZW50OyAvLyBnZXQgd2luZG93LmV2ZW50IGlmIGFyZ3VtZW50IGlzIGZhbHN5IChpbiBJRSlcblxuICAgICAgLy8gZ2V0IHNyY0VsZW1lbnQgaWYgdGFyZ2V0IGlzIGZhbHN5IChJRSlcbiAgICAgIHZhciB0YXJnZXRFbGVtZW50ID0gZXZ0LnRhcmdldCB8fCBldnQuc3JjRWxlbWVudDtcblxuICAgICAgLy9SZWN1cnNpdmVseSBsb29rIHVwIHRoZSBwYXJlbnQgdHJlZSB1bnRpbCB3ZSBmaW5kIGEgbWF0Y2hcbiAgICAgIC8vd2l0aCBvbmUgb2YgdGhlIGNsYXNzZXMgd2UncmUgbG9va2luZyBmb3IsIG9yIHRoZSB0cmlnZ2VyaW5nIGVsZW1lbnQuXG4gICAgICBmdW5jdGlvbiBmaW5kTWF0Y2hSZWN1cihlbCkge1xuICAgICAgICAvKiBXZSdyZSBnb2luZyB0byBtYWtlIHRoZSBhc3N1bXB0aW9uIHRoYXQgd2UncmUgbm90IGJpbmRpbmdcbiAgICAgICAgICAqIG11bHRpcGxlIGV2ZW50IGNsYXNzZXMgdG8gdGhlIHNhbWUgZWxlbWVudC5cbiAgICAgICAgICAqIChuZXh0ICsgcHJldmlvdXMgPSB3YWl0Li4uIGVyci4uLiB3aGF0PylcbiAgICAgICAgICAqXG4gICAgICAgICAgKiBJbiB0aGUgb2RkIGV2ZW50IHdlIGVuZCB1cCB3aXRoIGFuIGVsZW1lbnQgd2l0aCBtdWx0aXBsZVxuICAgICAgICAgICogcG9zc2libGUgbWF0Y2hlcywgdGhlIGZvbGxvd2luZyBwcmlvcml0eSBvcmRlciBpcyBhcHBsaWVkOlxuICAgICAgICAgICogaG9wc2NvdGNoLWN0YSwgaG9wc2NvdGNoLW5leHQsIGhvcHNjb3RjaC1wcmV2LCBob3BzY290Y2gtY2xvc2VcbiAgICAgICAgICAqL1xuICAgICAgICBpZiAoZWwgPT09IGV2dC5jdXJyZW50VGFyZ2V0KSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHV0aWxzLmhhc0NsYXNzKGVsLCAnaG9wc2NvdGNoLWN0YScpKSB7XG4gICAgICAgICAgcmV0dXJuICdjdGEnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1dGlscy5oYXNDbGFzcyhlbCwgJ2hvcHNjb3RjaC1uZXh0JykpIHtcbiAgICAgICAgICByZXR1cm4gJ25leHQnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1dGlscy5oYXNDbGFzcyhlbCwgJ2hvcHNjb3RjaC1wcmV2JykpIHtcbiAgICAgICAgICByZXR1cm4gJ3ByZXYnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1dGlscy5oYXNDbGFzcyhlbCwgJ2hvcHNjb3RjaC1jbG9zZScpKSB7XG4gICAgICAgICAgcmV0dXJuICdjbG9zZSc7XG4gICAgICAgIH1cbiAgICAgICAgLyplbHNlKi9yZXR1cm4gZmluZE1hdGNoUmVjdXIoZWwucGFyZW50RWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIGFjdGlvbiA9IGZpbmRNYXRjaFJlY3VyKHRhcmdldEVsZW1lbnQpO1xuXG4gICAgICAvL05vdyB0aGF0IHdlIGtub3cgd2hhdCBhY3Rpb24gd2Ugc2hvdWxkIHRha2UsIGxldCdzIHRha2UgaXQuXG4gICAgICBpZiAoYWN0aW9uID09PSAnY3RhJykge1xuICAgICAgICBpZiAoIXRoaXMub3B0LmlzVG91ckJ1YmJsZSkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgYSBjYWxsb3V0LiBDbG9zZSB0aGUgY2FsbG91dCB3aGVuIENUQSBpcyBjbGlja2VkLlxuICAgICAgICAgIHdpbkhvcHNjb3RjaC5nZXRDYWxsb3V0TWFuYWdlcigpLnJlbW92ZUNhbGxvdXQodGhpcy5jdXJyU3RlcC5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2FsbCBvbkNUQSBjYWxsYmFjayBpZiBvbmUgaXMgcHJvdmlkZWRcbiAgICAgICAgaWYgKHRoaXMuY3VyclN0ZXAub25DVEEpIHtcbiAgICAgICAgICB1dGlscy5pbnZva2VDYWxsYmFjayh0aGlzLmN1cnJTdGVwLm9uQ1RBKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhY3Rpb24gPT09ICduZXh0Jykge1xuICAgICAgICB3aW5Ib3BzY290Y2gubmV4dFN0ZXAodHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGFjdGlvbiA9PT0gJ3ByZXYnKSB7XG4gICAgICAgIHdpbkhvcHNjb3RjaC5wcmV2U3RlcCh0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoYWN0aW9uID09PSAnY2xvc2UnKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdC5pc1RvdXJCdWJibGUpIHtcbiAgICAgICAgICB2YXIgY3VyclN0ZXBOdW0gPSB3aW5Ib3BzY290Y2guZ2V0Q3VyclN0ZXBOdW0oKSxcbiAgICAgICAgICAgICAgY3VyclRvdXIgPSB3aW5Ib3BzY290Y2guZ2V0Q3VyclRvdXIoKSxcbiAgICAgICAgICAgICAgZG9FbmRDYWxsYmFjayA9IGN1cnJTdGVwTnVtID09PSBjdXJyVG91ci5zdGVwcy5sZW5ndGggLSAxO1xuXG4gICAgICAgICAgdXRpbHMuaW52b2tlRXZlbnRDYWxsYmFja3MoJ2Nsb3NlJyk7XG5cbiAgICAgICAgICB3aW5Ib3BzY290Y2guZW5kVG91cih0cnVlLCBkb0VuZENhbGxiYWNrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGhpcy5vcHQub25DbG9zZSkge1xuICAgICAgICAgICAgdXRpbHMuaW52b2tlQ2FsbGJhY2sodGhpcy5vcHQub25DbG9zZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLm9wdC5pZCAmJiAhdGhpcy5vcHQuaXNUb3VyQnViYmxlKSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgdmlhIHRoZSBIb3BzY290Y2hDYWxsb3V0TWFuYWdlci5cbiAgICAgICAgICAgIC8vIHJlbW92ZUNhbGxvdXQoKSBjYWxscyBIb3BzY290Y2hCdWJibGUuZGVzdHJveSBpbnRlcm5hbGx5LlxuICAgICAgICAgICAgd2luSG9wc2NvdGNoLmdldENhbGxvdXRNYW5hZ2VyKCkucmVtb3ZlQ2FsbG91dCh0aGlzLm9wdC5pZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHV0aWxzLmV2dFByZXZlbnREZWZhdWx0KGV2dCk7XG4gICAgICB9XG4gICAgICAvL090aGVyd2lzZSwgZG8gbm90aGluZy4gV2UgZGlkbid0IGNsaWNrIG9uIGFueXRoaW5nIHJlbGV2YW50LlxuICAgIH0sXG5cbiAgICBpbml0OiBmdW5jdGlvbiBpbml0KGluaXRPcHQpIHtcbiAgICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgICAgIHNlbGYgPSB0aGlzLFxuICAgICAgICAgIHJlc2l6ZUNvb2xkb3duID0gZmFsc2UsXG4gICAgICAgICAgLy8gZm9yIHVwZGF0aW5nIGFmdGVyIHdpbmRvdyByZXNpemVcbiAgICAgIG9uV2luUmVzaXplLFxuICAgICAgICAgIF9hcHBlbmRUb0JvZHkyLFxuICAgICAgICAgIGNoaWxkcmVuLFxuICAgICAgICAgIG51bUNoaWxkcmVuLFxuICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgaSxcbiAgICAgICAgICBjdXJyVG91cixcbiAgICAgICAgICBvcHQ7XG5cbiAgICAgIC8vUmVnaXN0ZXIgRE9NIGVsZW1lbnQgZm9yIHRoaXMgYnViYmxlLlxuICAgICAgdGhpcy5lbGVtZW50ID0gZWw7XG5cbiAgICAgIC8vTWVyZ2UgYnViYmxlIG9wdGlvbnMgd2l0aCBkZWZhdWx0cy5cbiAgICAgIG9wdCA9IHtcbiAgICAgICAgc2hvd1ByZXZCdXR0b246IGRlZmF1bHRPcHRzLnNob3dQcmV2QnV0dG9uLFxuICAgICAgICBzaG93TmV4dEJ1dHRvbjogZGVmYXVsdE9wdHMuc2hvd05leHRCdXR0b24sXG4gICAgICAgIGJ1YmJsZVdpZHRoOiBkZWZhdWx0T3B0cy5idWJibGVXaWR0aCxcbiAgICAgICAgYnViYmxlUGFkZGluZzogZGVmYXVsdE9wdHMuYnViYmxlUGFkZGluZyxcbiAgICAgICAgYXJyb3dXaWR0aDogZGVmYXVsdE9wdHMuYXJyb3dXaWR0aCxcbiAgICAgICAgaXNSdGw6IGRlZmF1bHRPcHRzLmlzUnRsLFxuICAgICAgICBzaG93TnVtYmVyOiB0cnVlLFxuICAgICAgICBpc1RvdXJCdWJibGU6IHRydWVcbiAgICAgIH07XG4gICAgICBpbml0T3B0ID0gKHR5cGVvZiBpbml0T3B0ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihpbml0T3B0KSkgPT09IHVuZGVmaW5lZFN0ciA/IHt9IDogaW5pdE9wdDtcbiAgICAgIHV0aWxzLmV4dGVuZChvcHQsIGluaXRPcHQpO1xuICAgICAgdGhpcy5vcHQgPSBvcHQ7XG5cbiAgICAgIC8vQXBwbHkgY2xhc3NlcyB0byBidWJibGUuIEFkZCBcImFuaW1hdGVkXCIgZm9yIGZhZGUgY3NzIGFuaW1hdGlvblxuICAgICAgZWwuY2xhc3NOYW1lID0gJ2hvcHNjb3RjaC1idWJibGUgYW5pbWF0ZWQnO1xuICAgICAgaWYgKCFvcHQuaXNUb3VyQnViYmxlKSB7XG4gICAgICAgIHV0aWxzLmFkZENsYXNzKGVsLCAnaG9wc2NvdGNoLWNhbGxvdXQgbm8tbnVtYmVyJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyVG91ciA9IHdpbkhvcHNjb3RjaC5nZXRDdXJyVG91cigpO1xuICAgICAgICBpZiAoY3VyclRvdXIpIHtcbiAgICAgICAgICB1dGlscy5hZGRDbGFzcyhlbCwgJ3RvdXItJyArIGN1cnJUb3VyLmlkKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIE5vdCBwcmV0dHksIGJ1dCBJRTggZG9lc24ndCBzdXBwb3J0IEZ1bmN0aW9uLmJpbmQoKSwgc28gSSdtXG4gICAgICAgKiByZWx5aW5nIG9uIGNsb3N1cmVzIHRvIGtlZXAgYSBoYW5kbGUgb2YgXCJ0aGlzXCIuXG4gICAgICAgKiBSZXNldCBwb3NpdGlvbiBvZiBidWJibGUgd2hlbiB3aW5kb3cgaXMgcmVzaXplZFxuICAgICAgICpcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cbiAgICAgIG9uV2luUmVzaXplID0gZnVuY3Rpb24gb25XaW5SZXNpemUoKSB7XG4gICAgICAgIGlmIChyZXNpemVDb29sZG93biB8fCAhc2VsZi5pc1Nob3dpbmcpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXNpemVDb29sZG93biA9IHRydWU7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHNlbGYuc2V0UG9zaXRpb24oc2VsZi5jdXJyU3RlcCk7XG4gICAgICAgICAgcmVzaXplQ29vbGRvd24gPSBmYWxzZTtcbiAgICAgICAgfSwgMTAwKTtcbiAgICAgIH07XG5cbiAgICAgIC8vQWRkIGxpc3RlbmVyIHRvIHJlc2V0IGJ1YmJsZSBwb3NpdGlvbiBvbiB3aW5kb3cgcmVzaXplXG4gICAgICB1dGlscy5hZGRFdnRMaXN0ZW5lcih3aW5kb3csICdyZXNpemUnLCBvbldpblJlc2l6ZSk7XG5cbiAgICAgIC8vQ3JlYXRlIG91ciBjbGljayBjYWxsYmFjayBoYW5kbGVyIGFuZCBrZWVwIGFcbiAgICAgIC8vcmVmZXJlbmNlIHRvIGl0IGZvciBsYXRlci5cbiAgICAgIHRoaXMuY2xpY2tDYiA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgc2VsZi5faGFuZGxlQnViYmxlQ2xpY2soZXZ0KTtcbiAgICAgIH07XG4gICAgICB1dGlscy5hZGRFdnRMaXN0ZW5lcihlbCwgJ2NsaWNrJywgdGhpcy5jbGlja0NiKTtcblxuICAgICAgLy9IaWRlIHRoZSBidWJibGUgYnkgZGVmYXVsdFxuICAgICAgdGhpcy5oaWRlKCk7XG5cbiAgICAgIC8vRmluYWxseSwgYXBwZW5kIG91ciBuZXcgYnViYmxlIHRvIGJvZHkgb25jZSB0aGUgRE9NIGlzIHJlYWR5LlxuICAgICAgaWYgKHV0aWxzLmRvY3VtZW50SXNSZWFkeSgpKSB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTW96LCB3ZWJraXQsIE9wZXJhXG4gICAgICAgIGlmIChkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgX2FwcGVuZFRvQm9keTIgPSBmdW5jdGlvbiBhcHBlbmRUb0JvZHkoKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgX2FwcGVuZFRvQm9keTIpO1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBfYXBwZW5kVG9Cb2R5Mik7XG5cbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgX2FwcGVuZFRvQm9keTIsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJRVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF9hcHBlbmRUb0JvZHkyID0gZnVuY3Rpb24gX2FwcGVuZFRvQm9keSgpIHtcbiAgICAgICAgICAgICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5kZXRhY2hFdmVudCgnb25yZWFkeXN0YXRlY2hhbmdlJywgX2FwcGVuZFRvQm9keTIpO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5kZXRhY2hFdmVudCgnb25sb2FkJywgX2FwcGVuZFRvQm9keTIpO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBkb2N1bWVudC5hdHRhY2hFdmVudCgnb25yZWFkeXN0YXRlY2hhbmdlJywgX2FwcGVuZFRvQm9keTIpO1xuICAgICAgICAgIH1cbiAgICAgICAgdXRpbHMuYWRkRXZ0TGlzdGVuZXIod2luZG93LCAnbG9hZCcsIF9hcHBlbmRUb0JvZHkyKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEhvcHNjb3RjaENhbGxvdXRNYW5hZ2VyXG4gICAqXG4gICAqIEBjbGFzcyBNYW5hZ2VzIHRoZSBjcmVhdGlvbiBhbmQgZGVzdHJ1Y3Rpb24gb2Ygc2luZ2xlIGNhbGxvdXRzLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIEhvcHNjb3RjaENhbGxvdXRNYW5hZ2VyID0gZnVuY3Rpb24gSG9wc2NvdGNoQ2FsbG91dE1hbmFnZXIoKSB7XG4gICAgdmFyIGNhbGxvdXRzID0ge30sXG4gICAgICAgIGNhbGxvdXRPcHRzID0ge307XG5cbiAgICAvKipcbiAgICAgKiBjcmVhdGVDYWxsb3V0XG4gICAgICpcbiAgICAgKiBDcmVhdGVzIGEgc3RhbmRhbG9uZSBjYWxsb3V0LiBUaGlzIGNhbGxvdXQgaGFzIHRoZSBzYW1lIEFQSVxuICAgICAqIGFzIGEgSG9wc2NvdGNoIHRvdXIgYnViYmxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdCBUaGUgb3B0aW9ucyBmb3IgdGhlIGNhbGxvdXQuIEZvciB0aGUgbW9zdFxuICAgICAqIHBhcnQsIHRoZXNlIGFyZSB0aGUgc2FtZSBvcHRpb25zIGFzIHlvdSB3b3VsZCBmaW5kIGluIGEgdG91clxuICAgICAqIHN0ZXAuXG4gICAgICovXG4gICAgdGhpcy5jcmVhdGVDYWxsb3V0ID0gZnVuY3Rpb24gKG9wdCkge1xuICAgICAgdmFyIGNhbGxvdXQ7XG5cbiAgICAgIGlmIChvcHQuaWQpIHtcbiAgICAgICAgaWYgKCF2YWxpZElkUmVnRXgudGVzdChvcHQuaWQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYWxsb3V0IElEIGlzIHVzaW5nIGFuIGludmFsaWQgZm9ybWF0LiBVc2UgYWxwaGFudW1lcmljLCB1bmRlcnNjb3JlcywgYW5kL29yIGh5cGhlbnMgb25seS4gRmlyc3QgY2hhcmFjdGVyIG11c3QgYmUgYSBsZXR0ZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbGxvdXRzW29wdC5pZF0pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxvdXQgYnkgdGhhdCBpZCBhbHJlYWR5IGV4aXN0cy4gUGxlYXNlIGNob29zZSBhIHVuaXF1ZSBpZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXV0aWxzLmdldFN0ZXBUYXJnZXQob3B0KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBzcGVjaWZ5IGV4aXN0aW5nIHRhcmdldCBlbGVtZW50IHZpYSBcXCd0YXJnZXRcXCcgb3B0aW9uLicpO1xuICAgICAgICB9XG4gICAgICAgIG9wdC5zaG93TmV4dEJ1dHRvbiA9IG9wdC5zaG93UHJldkJ1dHRvbiA9IGZhbHNlO1xuICAgICAgICBvcHQuaXNUb3VyQnViYmxlID0gZmFsc2U7XG4gICAgICAgIGNhbGxvdXQgPSBuZXcgSG9wc2NvdGNoQnViYmxlKG9wdCk7XG4gICAgICAgIGNhbGxvdXRzW29wdC5pZF0gPSBjYWxsb3V0O1xuICAgICAgICBjYWxsb3V0T3B0c1tvcHQuaWRdID0gb3B0O1xuICAgICAgICBjYWxsb3V0LnJlbmRlcihvcHQsIG51bGwsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjYWxsb3V0LnNob3coKTtcbiAgICAgICAgICBpZiAob3B0Lm9uU2hvdykge1xuICAgICAgICAgICAgdXRpbHMuaW52b2tlQ2FsbGJhY2sob3B0Lm9uU2hvdyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBzcGVjaWZ5IGEgY2FsbG91dCBpZC4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYWxsb3V0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBnZXRDYWxsb3V0XG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGEgY2FsbG91dCBieSBpdHMgaWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWQgVGhlIGlkIG9mIHRoZSBjYWxsb3V0IHRvIGZldGNoLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IEhvcHNjb3RjaEJ1YmJsZVxuICAgICAqL1xuICAgIHRoaXMuZ2V0Q2FsbG91dCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgcmV0dXJuIGNhbGxvdXRzW2lkXTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogcmVtb3ZlQWxsQ2FsbG91dHNcbiAgICAgKlxuICAgICAqIFJlbW92ZXMgYWxsIGV4aXN0aW5nIGNhbGxvdXRzLlxuICAgICAqL1xuICAgIHRoaXMucmVtb3ZlQWxsQ2FsbG91dHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY2FsbG91dElkO1xuXG4gICAgICBmb3IgKGNhbGxvdXRJZCBpbiBjYWxsb3V0cykge1xuICAgICAgICBpZiAoY2FsbG91dHMuaGFzT3duUHJvcGVydHkoY2FsbG91dElkKSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlQ2FsbG91dChjYWxsb3V0SWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHJlbW92ZUNhbGxvdXRcbiAgICAgKlxuICAgICAqIFJlbW92ZXMgYW4gZXhpc3RpbmcgY2FsbG91dCBieSBpZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZCBUaGUgaWQgb2YgdGhlIGNhbGxvdXQgdG8gcmVtb3ZlLlxuICAgICAqL1xuICAgIHRoaXMucmVtb3ZlQ2FsbG91dCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgdmFyIGNhbGxvdXQgPSBjYWxsb3V0c1tpZF07XG5cbiAgICAgIGNhbGxvdXRzW2lkXSA9IG51bGw7XG4gICAgICBjYWxsb3V0T3B0c1tpZF0gPSBudWxsO1xuICAgICAgaWYgKCFjYWxsb3V0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY2FsbG91dC5kZXN0cm95KCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHJlZnJlc2hDYWxsb3V0UG9zaXRpb25zXG4gICAgICpcbiAgICAgKiBSZWZyZXNoIHRoZSBwb3NpdGlvbnMgZm9yIGFsbCBjYWxsb3V0cyBrbm93biBieSB0aGVcbiAgICAgKiBjYWxsb3V0IG1hbmFnZXIuIFR5cGljYWxseSB5b3UnbGwgdXNlXG4gICAgICogaG9wc2NvdGNoLnJlZnJlc2hCdWJibGVQb3NpdGlvbigpIHRvIHJlZnJlc2ggQUxMXG4gICAgICogYnViYmxlcyBpbnN0ZWFkIG9mIGNhbGxpbmcgdGhpcyBkaXJlY3RseS5cbiAgICAgKi9cbiAgICB0aGlzLnJlZnJlc2hDYWxsb3V0UG9zaXRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNhbGxvdXRJZCwgY2FsbG91dCwgb3B0cztcblxuICAgICAgZm9yIChjYWxsb3V0SWQgaW4gY2FsbG91dHMpIHtcbiAgICAgICAgaWYgKGNhbGxvdXRzLmhhc093blByb3BlcnR5KGNhbGxvdXRJZCkgJiYgY2FsbG91dE9wdHMuaGFzT3duUHJvcGVydHkoY2FsbG91dElkKSkge1xuICAgICAgICAgIGNhbGxvdXQgPSBjYWxsb3V0c1tjYWxsb3V0SWRdO1xuICAgICAgICAgIG9wdHMgPSBjYWxsb3V0T3B0c1tjYWxsb3V0SWRdO1xuICAgICAgICAgIGlmIChjYWxsb3V0ICYmIG9wdHMpIHtcbiAgICAgICAgICAgIGNhbGxvdXQuc2V0UG9zaXRpb24ob3B0cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogSG9wc2NvdGNoXG4gICAqXG4gICAqIEBjbGFzcyBDcmVhdGVzIHRoZSBIb3BzY290Y2ggb2JqZWN0LiBVc2VkIHRvIG1hbmFnZSB0b3VyIHByb2dyZXNzIGFuZCBjb25maWd1cmF0aW9ucy5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbml0T3B0aW9ucyBPcHRpb25zIHRvIGJlIHBhc3NlZCB0byBgY29uZmlndXJlKClgLlxuICAgKi9cbiAgSG9wc2NvdGNoID0gZnVuY3Rpb24gSG9wc2NvdGNoKGluaXRPcHRpb25zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAvLyBmb3IgdGFyZ2V0Q2xpY2tOZXh0Rm5cbiAgICBidWJibGUsXG4gICAgICAgIGNhbGxvdXRNZ3IsXG4gICAgICAgIG9wdCxcbiAgICAgICAgY3VyclRvdXIsXG4gICAgICAgIGN1cnJTdGVwTnVtLFxuICAgICAgICBza2lwcGVkU3RlcHMgPSB7fSxcbiAgICAgICAgY29va2llVG91cklkLFxuICAgICAgICBjb29raWVUb3VyU3RlcCxcbiAgICAgICAgY29va2llU2tpcHBlZFN0ZXBzID0gW10sXG4gICAgICAgIF9jb25maWd1cmUsXG5cblxuICAgIC8qKlxuICAgICAqIGdldEJ1YmJsZVxuICAgICAqXG4gICAgICogU2luZ2xldG9uIGFjY2Vzc29yIGZ1bmN0aW9uIGZvciByZXRyaWV2aW5nIG9yIGNyZWF0aW5nIGJ1YmJsZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSBzZXRPcHRpb25zIHtCb29sZWFufSB3aGVuIHRydWUsIHRyYW5zZmVycyBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdGhlIGJ1YmJsZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IEhvcHNjb3RjaEJ1YmJsZVxuICAgICAqL1xuICAgIGdldEJ1YmJsZSA9IGZ1bmN0aW9uIGdldEJ1YmJsZShzZXRPcHRpb25zKSB7XG4gICAgICBpZiAoIWJ1YmJsZSB8fCAhYnViYmxlLmVsZW1lbnQgfHwgIWJ1YmJsZS5lbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgYnViYmxlID0gbmV3IEhvcHNjb3RjaEJ1YmJsZShvcHQpO1xuICAgICAgfVxuICAgICAgaWYgKHNldE9wdGlvbnMpIHtcbiAgICAgICAgdXRpbHMuZXh0ZW5kKGJ1YmJsZS5vcHQsIHtcbiAgICAgICAgICBidWJibGVQYWRkaW5nOiBnZXRPcHRpb24oJ2J1YmJsZVBhZGRpbmcnKSxcbiAgICAgICAgICBidWJibGVXaWR0aDogZ2V0T3B0aW9uKCdidWJibGVXaWR0aCcpLFxuICAgICAgICAgIHNob3dOZXh0QnV0dG9uOiBnZXRPcHRpb24oJ3Nob3dOZXh0QnV0dG9uJyksXG4gICAgICAgICAgc2hvd1ByZXZCdXR0b246IGdldE9wdGlvbignc2hvd1ByZXZCdXR0b24nKSxcbiAgICAgICAgICBzaG93Q2xvc2VCdXR0b246IGdldE9wdGlvbignc2hvd0Nsb3NlQnV0dG9uJyksXG4gICAgICAgICAgYXJyb3dXaWR0aDogZ2V0T3B0aW9uKCdhcnJvd1dpZHRoJyksXG4gICAgICAgICAgaXNSdGw6IGdldE9wdGlvbignaXNSdGwnKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWJibGU7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogRGVzdHJveSB0aGUgYnViYmxlIGN1cnJlbnRseSBhc3NvY2lhdGVkIHdpdGggSG9wc2NvdGNoLlxuICAgICAqIFRoaXMgaXMgZG9uZSB3aGVuIHdlIGVuZCB0aGUgY3VycmVudCB0b3VyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBkZXN0cm95QnViYmxlID0gZnVuY3Rpb24gZGVzdHJveUJ1YmJsZSgpIHtcbiAgICAgIGlmIChidWJibGUpIHtcbiAgICAgICAgYnViYmxlLmRlc3Ryb3koKTtcbiAgICAgICAgYnViYmxlID0gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgZm9yIGdldHRpbmcgYW4gb3B0aW9uLiBSZXR1cm5zIGN1c3RvbSBjb25maWcgb3B0aW9uXG4gICAgICogb3IgdGhlIGRlZmF1bHQgY29uZmlnIG9wdGlvbiBpZiBubyBjdXN0b20gdmFsdWUgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gbmFtZSB7U3RyaW5nfSBjb25maWcgb3B0aW9uIG5hbWVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBjb25maWcgb3B0aW9uIHZhbHVlXG4gICAgICovXG4gICAgZ2V0T3B0aW9uID0gZnVuY3Rpb24gZ2V0T3B0aW9uKG5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gZGVmYXVsdE9wdHNbbmFtZV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdXRpbHMudmFsT3JEZWZhdWx0KG9wdFtuYW1lXSwgZGVmYXVsdE9wdHNbbmFtZV0pO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIGdldEN1cnJTdGVwXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHRoZSBzdGVwIG9iamVjdCBjb3JyZXNwb25kaW5nIHRvIHRoZSBjdXJyZW50IHZhbHVlIG9mIGN1cnJTdGVwTnVtXG4gICAgICovXG4gICAgZ2V0Q3VyclN0ZXAgPSBmdW5jdGlvbiBnZXRDdXJyU3RlcCgpIHtcbiAgICAgIHZhciBzdGVwO1xuXG4gICAgICBpZiAoIWN1cnJUb3VyIHx8IGN1cnJTdGVwTnVtIDwgMCB8fCBjdXJyU3RlcE51bSA+PSBjdXJyVG91ci5zdGVwcy5sZW5ndGgpIHtcbiAgICAgICAgc3RlcCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGVwID0gY3VyclRvdXIuc3RlcHNbY3VyclN0ZXBOdW1dO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RlcDtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGZvciBuZXh0T25UYXJnZXRDbGlja1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0YXJnZXRDbGlja05leHRGbiA9IGZ1bmN0aW9uIHRhcmdldENsaWNrTmV4dEZuKCkge1xuICAgICAgc2VsZi5uZXh0U3RlcCgpO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIGFkanVzdFdpbmRvd1Njcm9sbFxuICAgICAqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBidWJibGUgb3IgdGFyZ2V0IGVsZW1lbnQgaXMgcGFydGlhbGx5IG9yIGNvbXBsZXRlbHlcbiAgICAgKiBvdXRzaWRlIG9mIHRoZSB2aWV3cG9ydC4gSWYgaXQgaXMsIGFkanVzdCB0aGUgd2luZG93IHNjcm9sbCBwb3NpdGlvblxuICAgICAqIHRvIGJyaW5nIGl0IGJhY2sgaW50byB0aGUgdmlld3BvcnQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrIHRvIGludm9rZSBhZnRlciBkb25lIHNjcm9sbGluZy5cbiAgICAgKi9cbiAgICBhZGp1c3RXaW5kb3dTY3JvbGwgPSBmdW5jdGlvbiBhZGp1c3RXaW5kb3dTY3JvbGwoY2IpIHtcbiAgICAgIHZhciBidWJibGUgPSBnZXRCdWJibGUoKSxcblxuXG4gICAgICAvLyBDYWxjdWxhdGUgdGhlIGJ1YmJsZSBlbGVtZW50IHRvcCBhbmQgYm90dG9tIHBvc2l0aW9uXG4gICAgICBidWJibGVFbCA9IGJ1YmJsZS5lbGVtZW50LFxuICAgICAgICAgIGJ1YmJsZVRvcCA9IHV0aWxzLmdldFBpeGVsVmFsdWUoYnViYmxlRWwuc3R5bGUudG9wKSxcbiAgICAgICAgICBidWJibGVCb3R0b20gPSBidWJibGVUb3AgKyB1dGlscy5nZXRQaXhlbFZhbHVlKGJ1YmJsZUVsLm9mZnNldEhlaWdodCksXG5cblxuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSB0YXJnZXQgZWxlbWVudCB0b3AgYW5kIGJvdHRvbSBwb3NpdGlvblxuICAgICAgdGFyZ2V0RWwgPSB1dGlscy5nZXRTdGVwVGFyZ2V0KGdldEN1cnJTdGVwKCkpLFxuICAgICAgICAgIHRhcmdldEJvdW5kcyA9IHRhcmdldEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgIHRhcmdldEVsVG9wID0gdGFyZ2V0Qm91bmRzLnRvcCArIHV0aWxzLmdldFNjcm9sbFRvcCgpLFxuICAgICAgICAgIHRhcmdldEVsQm90dG9tID0gdGFyZ2V0Qm91bmRzLmJvdHRvbSArIHV0aWxzLmdldFNjcm9sbFRvcCgpLFxuXG5cbiAgICAgIC8vIFRoZSBoaWdoZXIgb2YgdGhlIHR3bzogYnViYmxlIG9yIHRhcmdldFxuICAgICAgdGFyZ2V0VG9wID0gYnViYmxlVG9wIDwgdGFyZ2V0RWxUb3AgPyBidWJibGVUb3AgOiB0YXJnZXRFbFRvcCxcblxuICAgICAgLy8gVGhlIGxvd2VyIG9mIHRoZSB0d286IGJ1YmJsZSBvciB0YXJnZXRcbiAgICAgIHRhcmdldEJvdHRvbSA9IGJ1YmJsZUJvdHRvbSA+IHRhcmdldEVsQm90dG9tID8gYnViYmxlQm90dG9tIDogdGFyZ2V0RWxCb3R0b20sXG5cblxuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBjdXJyZW50IHZpZXdwb3J0IHRvcCBhbmQgYm90dG9tXG4gICAgICB3aW5kb3dUb3AgPSB1dGlscy5nZXRTY3JvbGxUb3AoKSxcbiAgICAgICAgICB3aW5kb3dCb3R0b20gPSB3aW5kb3dUb3AgKyB1dGlscy5nZXRXaW5kb3dIZWlnaHQoKSxcblxuXG4gICAgICAvLyBUaGlzIGlzIG91ciBmaW5hbCB0YXJnZXQgc2Nyb2xsIHZhbHVlLlxuICAgICAgc2Nyb2xsVG9WYWwgPSB0YXJnZXRUb3AgLSBnZXRPcHRpb24oJ3Njcm9sbFRvcE1hcmdpbicpLFxuICAgICAgICAgIHNjcm9sbEVsLFxuICAgICAgICAgIHl1aUFuaW0sXG4gICAgICAgICAgeXVpRWFzZSxcbiAgICAgICAgICBkaXJlY3Rpb24sXG4gICAgICAgICAgc2Nyb2xsSW5jcixcbiAgICAgICAgICBzY3JvbGxUaW1lb3V0LFxuICAgICAgICAgIF9zY3JvbGxUaW1lb3V0Rm47XG5cbiAgICAgIC8vIFRhcmdldCBhbmQgYnViYmxlIGFyZSBib3RoIHZpc2libGUgaW4gdmlld3BvcnRcbiAgICAgIGlmICh0YXJnZXRUb3AgPj0gd2luZG93VG9wICYmICh0YXJnZXRUb3AgPD0gd2luZG93VG9wICsgZ2V0T3B0aW9uKCdzY3JvbGxUb3BNYXJnaW4nKSB8fCB0YXJnZXRCb3R0b20gPD0gd2luZG93Qm90dG9tKSkge1xuICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICBjYigpO1xuICAgICAgICB9IC8vIEhvcHNjb3RjaEJ1YmJsZS5zaG93XG4gICAgICB9XG5cbiAgICAgIC8vIEFicnVwdCBzY3JvbGwgdG8gc2Nyb2xsIHRhcmdldFxuICAgICAgZWxzZSBpZiAoIWdldE9wdGlvbignc21vb3RoU2Nyb2xsJykpIHtcbiAgICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgc2Nyb2xsVG9WYWwpO1xuXG4gICAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgICBjYigpO1xuICAgICAgICAgIH0gLy8gSG9wc2NvdGNoQnViYmxlLnNob3dcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNtb290aCBzY3JvbGwgdG8gc2Nyb2xsIHRhcmdldFxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFVzZSBZVUkgaWYgaXQgZXhpc3RzXG4gICAgICAgICAgICBpZiAoKHR5cGVvZiBZQUhPTyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoWUFIT08pKSAhPT0gdW5kZWZpbmVkU3RyICYmIF90eXBlb2YoWUFIT08uZW52KSAhPT0gdW5kZWZpbmVkU3RyICYmIF90eXBlb2YoWUFIT08uZW52LnVhKSAhPT0gdW5kZWZpbmVkU3RyICYmIF90eXBlb2YoWUFIT08udXRpbCkgIT09IHVuZGVmaW5lZFN0ciAmJiBfdHlwZW9mKFlBSE9PLnV0aWwuU2Nyb2xsKSAhPT0gdW5kZWZpbmVkU3RyKSB7XG4gICAgICAgICAgICAgIHNjcm9sbEVsID0gWUFIT08uZW52LnVhLndlYmtpdCA/IGRvY3VtZW50LmJvZHkgOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgICAgICAgIHl1aUVhc2UgPSBZQUhPTy51dGlsLkVhc2luZyA/IFlBSE9PLnV0aWwuRWFzaW5nLmVhc2VPdXQgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIHl1aUFuaW0gPSBuZXcgWUFIT08udXRpbC5TY3JvbGwoc2Nyb2xsRWwsIHtcbiAgICAgICAgICAgICAgICBzY3JvbGw6IHsgdG86IFswLCBzY3JvbGxUb1ZhbF0gfVxuICAgICAgICAgICAgICB9LCBnZXRPcHRpb24oJ3Njcm9sbER1cmF0aW9uJykgLyAxMDAwLCB5dWlFYXNlKTtcbiAgICAgICAgICAgICAgeXVpQW5pbS5vbkNvbXBsZXRlLnN1YnNjcmliZShjYik7XG4gICAgICAgICAgICAgIHl1aUFuaW0uYW5pbWF0ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVc2UgalF1ZXJ5IGlmIGl0IGV4aXN0c1xuICAgICAgICAgICAgZWxzZSBpZiAoaGFzSnF1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5KCdib2R5LCBodG1sJykuYW5pbWF0ZSh7IHNjcm9sbFRvcDogc2Nyb2xsVG9WYWwgfSwgZ2V0T3B0aW9uKCdzY3JvbGxEdXJhdGlvbicpLCBjYik7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBVc2UgbXkgY3J1bW15IHNldEludGVydmFsIHNjcm9sbCBzb2x1dGlvbiBpZiB3ZSdyZSB1c2luZyBwbGFpbiwgdmFuaWxsYSBKYXZhc2NyaXB0LlxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlmIChzY3JvbGxUb1ZhbCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsVG9WYWwgPSAwO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAvLyA0OCAqIDEwID09IDQ4MG1zIHNjcm9sbCBkdXJhdGlvblxuICAgICAgICAgICAgICAgICAgLy8gbWFrZSBpdCBzbGlnaHRseSBsZXNzIHRoYW4gQ1NTIHRyYW5zaXRpb24gZHVyYXRpb24gYmVjYXVzZSBvZlxuICAgICAgICAgICAgICAgICAgLy8gc2V0SW50ZXJ2YWwgb3ZlcmhlYWQuXG4gICAgICAgICAgICAgICAgICAvLyBUbyBpbmNyZWFzZSBvciBkZWNyZWFzZSBkdXJhdGlvbiwgY2hhbmdlIHRoZSBkaXZpc29yIG9mIHNjcm9sbEluY3IuXG4gICAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSB3aW5kb3dUb3AgPiB0YXJnZXRUb3AgPyAtMSA6IDE7IC8vIC0xIG1lYW5zIHNjcm9sbGluZyB1cCwgMSBtZWFucyBkb3duXG4gICAgICAgICAgICAgICAgICBzY3JvbGxJbmNyID0gTWF0aC5hYnMod2luZG93VG9wIC0gc2Nyb2xsVG9WYWwpIC8gKGdldE9wdGlvbignc2Nyb2xsRHVyYXRpb24nKSAvIDEwKTtcbiAgICAgICAgICAgICAgICAgIF9zY3JvbGxUaW1lb3V0Rm4gPSBmdW5jdGlvbiBzY3JvbGxUaW1lb3V0Rm4oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxUb3AgPSB1dGlscy5nZXRTY3JvbGxUb3AoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbFRhcmdldCA9IHNjcm9sbFRvcCArIGRpcmVjdGlvbiAqIHNjcm9sbEluY3I7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA+IDAgJiYgc2Nyb2xsVGFyZ2V0ID49IHNjcm9sbFRvVmFsIHx8IGRpcmVjdGlvbiA8IDAgJiYgc2Nyb2xsVGFyZ2V0IDw9IHNjcm9sbFRvVmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gT3ZlcnNob3Qgb3VyIHRhcmdldC4gSnVzdCBtYW51YWxseSBzZXQgdG8gZXF1YWwgdGhlIHRhcmdldFxuICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCBjbGVhciB0aGUgaW50ZXJ2YWxcbiAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxUYXJnZXQgPSBzY3JvbGxUb1ZhbDtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgICAgICAgICAgICAgfSAvLyBIb3BzY290Y2hCdWJibGUuc2hvd1xuICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCBzY3JvbGxUYXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCBzY3JvbGxUYXJnZXQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh1dGlscy5nZXRTY3JvbGxUb3AoKSA9PT0gc2Nyb2xsVG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gQ291bGRuJ3Qgc2Nyb2xsIGFueSBmdXJ0aGVyLlxuICAgICAgICAgICAgICAgICAgICAgIGlmIChjYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgICAgICAgICAgICAgICB9IC8vIEhvcHNjb3RjaEJ1YmJsZS5zaG93XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCB0aGlzIHBvaW50LCB0aGF0IG1lYW5zIHRoZXJlJ3Mgc3RpbGwgbW9yZSB0byBzY3JvbGwuXG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoX3Njcm9sbFRpbWVvdXRGbiwgMTApO1xuICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgX3Njcm9sbFRpbWVvdXRGbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogZ29Ub1N0ZXBXaXRoVGFyZ2V0XG4gICAgICpcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gaW5jcmVtZW50IHRoZSBzdGVwIG51bWJlciB1bnRpbCBhIHN0ZXAgaXMgZm91bmQgd2hlcmVcbiAgICAgKiB0aGUgc3RlcCB0YXJnZXQgZXhpc3RzIG9yIHVudGlsIHdlIHJlYWNoIHRoZSBlbmQvYmVnaW5uaW5nIG9mIHRoZSB0b3VyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGlyZWN0aW9uIEVpdGhlciAxIGZvciBpbmNyZW1lbnRpbmcgb3IgLTEgZm9yIGRlY3JlbWVudGluZ1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBpbnZva2VkIHdoZW4gdGhlIHN0ZXAgaGFzIGJlZW4gZm91bmRcbiAgICAgKi9cbiAgICBnb1RvU3RlcFdpdGhUYXJnZXQgPSBmdW5jdGlvbiBnb1RvU3RlcFdpdGhUYXJnZXQoZGlyZWN0aW9uLCBjYikge1xuICAgICAgdmFyIHRhcmdldCwgc3RlcCwgZ29Ub1N0ZXBGbjtcblxuICAgICAgaWYgKGN1cnJTdGVwTnVtICsgZGlyZWN0aW9uID49IDAgJiYgY3VyclN0ZXBOdW0gKyBkaXJlY3Rpb24gPCBjdXJyVG91ci5zdGVwcy5sZW5ndGgpIHtcblxuICAgICAgICBjdXJyU3RlcE51bSArPSBkaXJlY3Rpb247XG4gICAgICAgIHN0ZXAgPSBnZXRDdXJyU3RlcCgpO1xuXG4gICAgICAgIGdvVG9TdGVwRm4gPSBmdW5jdGlvbiBnb1RvU3RlcEZuKCkge1xuICAgICAgICAgIHRhcmdldCA9IHV0aWxzLmdldFN0ZXBUYXJnZXQoc3RlcCk7XG5cbiAgICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgICAvL3RoaXMgc3RlcCB3YXMgcHJldmlvdXNseSBza2lwcGVkLCBidXQgbm93IGl0cyB0YXJnZXQgZXhpc3RzLFxuICAgICAgICAgICAgLy9yZW1vdmUgdGhpcyBzdGVwIGZyb20gc2tpcHBlZCBzdGVwcyBzZXRcbiAgICAgICAgICAgIGlmIChza2lwcGVkU3RlcHNbY3VyclN0ZXBOdW1dKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBza2lwcGVkU3RlcHNbY3VyclN0ZXBOdW1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2UncmUgZG9uZSEgUmV0dXJuIHRoZSBzdGVwIG51bWJlciB2aWEgdGhlIGNhbGxiYWNrLlxuICAgICAgICAgICAgY2IoY3VyclN0ZXBOdW0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvL21hcmsgdGhpcyBzdGVwIGFzIHNraXBwZWQsIHNpbmNlIGl0cyB0YXJnZXQgd2Fzbid0IGZvdW5kXG4gICAgICAgICAgICBza2lwcGVkU3RlcHNbY3VyclN0ZXBOdW1dID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIEhhdmVuJ3QgZm91bmQgYSB2YWxpZCB0YXJnZXQgeWV0LiBSZWN1cnNpdmVseSBjYWxsXG4gICAgICAgICAgICAvLyBnb1RvU3RlcFdpdGhUYXJnZXQuXG4gICAgICAgICAgICB1dGlscy5pbnZva2VFdmVudENhbGxiYWNrcygnZXJyb3InKTtcbiAgICAgICAgICAgIGdvVG9TdGVwV2l0aFRhcmdldChkaXJlY3Rpb24sIGNiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHN0ZXAuZGVsYXkpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGdvVG9TdGVwRm4sIHN0ZXAuZGVsYXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdvVG9TdGVwRm4oKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2IoLTEpOyAvLyBzaWduYWwgdGhhdCB3ZSBkaWRuJ3QgZmluZCBhbnkgc3RlcCB3aXRoIGEgdmFsaWQgdGFyZ2V0XG4gICAgICB9XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogY2hhbmdlU3RlcFxuICAgICAqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRvIGNoYW5nZSBzdGVwIGJ5IGdvaW5nIGZvcndhcmRzIG9yIGJhY2t3YXJkcyAxLlxuICAgICAqIG5leHRTdGVwIGFuZCBwcmV2U3RlcCBhcmUgcHVibGljbHkgYWNjZXNzaWJsZSB3cmFwcGVycyBmb3IgdGhpcyBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBkb0NhbGxiYWNrcyBGbGFnIGZvciBpbnZva2luZyBvbk5leHQgb3Igb25QcmV2IGNhbGxiYWNrc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkaXJlY3Rpb24gRWl0aGVyIDEgZm9yIFwibmV4dFwiIG9yIC0xIGZvciBcInByZXZcIlxuICAgICAqL1xuICAgIGNoYW5nZVN0ZXAgPSBmdW5jdGlvbiBjaGFuZ2VTdGVwKGRvQ2FsbGJhY2tzLCBkaXJlY3Rpb24pIHtcbiAgICAgIHZhciBidWJibGUgPSBnZXRCdWJibGUoKSxcbiAgICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgICBzdGVwLFxuICAgICAgICAgIG9yaWdTdGVwLFxuICAgICAgICAgIHdhc011bHRpUGFnZSxcbiAgICAgICAgICBjaGFuZ2VTdGVwQ2I7XG5cbiAgICAgIGJ1YmJsZS5oaWRlKCk7XG5cbiAgICAgIGRvQ2FsbGJhY2tzID0gdXRpbHMudmFsT3JEZWZhdWx0KGRvQ2FsbGJhY2tzLCB0cnVlKTtcblxuICAgICAgc3RlcCA9IGdldEN1cnJTdGVwKCk7XG5cbiAgICAgIGlmIChzdGVwLm5leHRPblRhcmdldENsaWNrKSB7XG4gICAgICAgIC8vIERldGFjaCB0aGUgbGlzdGVuZXIgd2hlbiB0b3VyIGlzIG1vdmluZyB0byBhIGRpZmZlcmVudCBzdGVwXG4gICAgICAgIHV0aWxzLnJlbW92ZUV2dExpc3RlbmVyKHV0aWxzLmdldFN0ZXBUYXJnZXQoc3RlcCksICdjbGljaycsIHRhcmdldENsaWNrTmV4dEZuKTtcbiAgICAgIH1cblxuICAgICAgb3JpZ1N0ZXAgPSBzdGVwO1xuICAgICAgaWYgKGRpcmVjdGlvbiA+IDApIHtcbiAgICAgICAgd2FzTXVsdGlQYWdlID0gb3JpZ1N0ZXAubXVsdGlwYWdlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FzTXVsdGlQYWdlID0gY3VyclN0ZXBOdW0gPiAwICYmIGN1cnJUb3VyLnN0ZXBzW2N1cnJTdGVwTnVtIC0gMV0ubXVsdGlwYWdlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbGxiYWNrIGZvciBnb1RvU3RlcFdpdGhUYXJnZXRcbiAgICAgICAqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG4gICAgICBjaGFuZ2VTdGVwQ2IgPSBmdW5jdGlvbiBjaGFuZ2VTdGVwQ2Ioc3RlcE51bSkge1xuICAgICAgICB2YXIgZG9TaG93Rm9sbG93aW5nU3RlcDtcblxuICAgICAgICBpZiAoc3RlcE51bSA9PT0gLTEpIHtcbiAgICAgICAgICAvLyBXYXNuJ3QgYWJsZSB0byBmaW5kIGEgc3RlcCB3aXRoIGFuIGV4aXN0aW5nIGVsZW1lbnQuIEVuZCB0b3VyLlxuICAgICAgICAgIHJldHVybiB0aGlzLmVuZFRvdXIodHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZG9DYWxsYmFja3MpIHtcbiAgICAgICAgICBpZiAoZGlyZWN0aW9uID4gMCkge1xuICAgICAgICAgICAgZG9TaG93Rm9sbG93aW5nU3RlcCA9IHV0aWxzLmludm9rZUV2ZW50Q2FsbGJhY2tzKCduZXh0Jywgb3JpZ1N0ZXAub25OZXh0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG9TaG93Rm9sbG93aW5nU3RlcCA9IHV0aWxzLmludm9rZUV2ZW50Q2FsbGJhY2tzKCdwcmV2Jywgb3JpZ1N0ZXAub25QcmV2KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgc3RhdGUgb2YgdGhlIHRvdXIgaXMgdXBkYXRlZCBpbiBhIGNhbGxiYWNrLCBhc3N1bWUgdGhlIGNsaWVudFxuICAgICAgICAvLyBkb2Vzbid0IHdhbnQgdG8gZ28gdG8gbmV4dCBzdGVwIHNpbmNlIHRoZXkgc3BlY2lmaWNhbGx5IHVwZGF0ZWQuXG4gICAgICAgIGlmIChzdGVwTnVtICE9PSBjdXJyU3RlcE51bSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3YXNNdWx0aVBhZ2UpIHtcbiAgICAgICAgICAvLyBVcGRhdGUgc3RhdGUgZm9yIHRoZSBuZXh0IHBhZ2VcbiAgICAgICAgICBzZXRTdGF0ZUhlbHBlcigpO1xuXG4gICAgICAgICAgLy8gTmV4dCBzdGVwIGlzIG9uIGEgZGlmZmVyZW50IHBhZ2UsIHNvIG5vIG5lZWQgdG8gYXR0ZW1wdCB0byByZW5kZXIgaXQuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZG9TaG93Rm9sbG93aW5nU3RlcCA9IHV0aWxzLnZhbE9yRGVmYXVsdChkb1Nob3dGb2xsb3dpbmdTdGVwLCB0cnVlKTtcblxuICAgICAgICAvLyBJZiB0aGUgb25OZXh0L29uUHJldiBjYWxsYmFjayByZXR1cm5lZCBmYWxzZSwgaGFsdCB0aGUgdG91ciBhbmRcbiAgICAgICAgLy8gZG9uJ3Qgc2hvdyB0aGUgbmV4dCBzdGVwLlxuICAgICAgICBpZiAoZG9TaG93Rm9sbG93aW5nU3RlcCkge1xuICAgICAgICAgIHRoaXMuc2hvd1N0ZXAoc3RlcE51bSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSGFsdCB0b3VyIChidXQgZG9uJ3QgY2xlYXIgc3RhdGUpXG4gICAgICAgICAgdGhpcy5lbmRUb3VyKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaWYgKCF3YXNNdWx0aVBhZ2UgJiYgZ2V0T3B0aW9uKCdza2lwSWZOb0VsZW1lbnQnKSkge1xuICAgICAgICBnb1RvU3RlcFdpdGhUYXJnZXQoZGlyZWN0aW9uLCBmdW5jdGlvbiAoc3RlcE51bSkge1xuICAgICAgICAgIGNoYW5nZVN0ZXBDYi5jYWxsKHNlbGYsIHN0ZXBOdW0pO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoY3VyclN0ZXBOdW0gKyBkaXJlY3Rpb24gPj0gMCAmJiBjdXJyU3RlcE51bSArIGRpcmVjdGlvbiA8IGN1cnJUb3VyLnN0ZXBzLmxlbmd0aCkge1xuICAgICAgICAvLyBvbmx5IHRyeSBpbmNyZW1lbnRpbmcgb25jZSwgYW5kIGludm9rZSBlcnJvciBjYWxsYmFjayBpZiBubyB0YXJnZXQgaXMgZm91bmRcbiAgICAgICAgY3VyclN0ZXBOdW0gKz0gZGlyZWN0aW9uO1xuICAgICAgICBzdGVwID0gZ2V0Q3VyclN0ZXAoKTtcbiAgICAgICAgaWYgKCF1dGlscy5nZXRTdGVwVGFyZ2V0KHN0ZXApICYmICF3YXNNdWx0aVBhZ2UpIHtcbiAgICAgICAgICB1dGlscy5pbnZva2VFdmVudENhbGxiYWNrcygnZXJyb3InKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5lbmRUb3VyKHRydWUsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBjaGFuZ2VTdGVwQ2IuY2FsbCh0aGlzLCBjdXJyU3RlcE51bSk7XG4gICAgICB9IGVsc2UgaWYgKGN1cnJTdGVwTnVtICsgZGlyZWN0aW9uID09PSBjdXJyVG91ci5zdGVwcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kVG91cigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBsb2FkVG91clxuICAgICAqXG4gICAgICogTG9hZHMsIGJ1dCBkb2VzIG5vdCBkaXNwbGF5LCB0b3VyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gdG91ciBUaGUgdG91ciBKU09OIG9iamVjdFxuICAgICAqL1xuICAgIGxvYWRUb3VyID0gZnVuY3Rpb24gbG9hZFRvdXIodG91cikge1xuICAgICAgdmFyIHRtcE9wdCA9IHt9LFxuICAgICAgICAgIHByb3AsXG4gICAgICAgICAgdG91clN0YXRlLFxuICAgICAgICAgIHRvdXJTdGF0ZVZhbHVlcztcblxuICAgICAgLy8gU2V0IHRvdXItc3BlY2lmaWMgY29uZmlndXJhdGlvbnNcbiAgICAgIGZvciAocHJvcCBpbiB0b3VyKSB7XG4gICAgICAgIGlmICh0b3VyLmhhc093blByb3BlcnR5KHByb3ApICYmIHByb3AgIT09ICdpZCcgJiYgcHJvcCAhPT0gJ3N0ZXBzJykge1xuICAgICAgICAgIHRtcE9wdFtwcm9wXSA9IHRvdXJbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy90aGlzLnJlc2V0RGVmYXVsdE9wdGlvbnMoKTsgLy8gcmVzZXQgYWxsIG9wdGlvbnMgc28gdGhlcmUgYXJlIG5vIHN1cnByaXNlc1xuICAgICAgLy8gVE9ETyBjaGVjayBudW1iZXIgb2YgY29uZmlnIHByb3BlcnRpZXMgb2YgdG91clxuICAgICAgX2NvbmZpZ3VyZS5jYWxsKHRoaXMsIHRtcE9wdCwgdHJ1ZSk7XG5cbiAgICAgIC8vIEdldCBleGlzdGluZyB0b3VyIHN0YXRlLCBpZiBpdCBleGlzdHMuXG4gICAgICB0b3VyU3RhdGUgPSB1dGlscy5nZXRTdGF0ZShnZXRPcHRpb24oJ2Nvb2tpZU5hbWUnKSk7XG4gICAgICBpZiAodG91clN0YXRlKSB7XG4gICAgICAgIHRvdXJTdGF0ZVZhbHVlcyA9IHRvdXJTdGF0ZS5zcGxpdCgnOicpO1xuICAgICAgICBjb29raWVUb3VySWQgPSB0b3VyU3RhdGVWYWx1ZXNbMF07IC8vIHNlbGVjdGluZyB0b3VyIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBmcmFtZXdvcmsuXG4gICAgICAgIGNvb2tpZVRvdXJTdGVwID0gdG91clN0YXRlVmFsdWVzWzFdO1xuXG4gICAgICAgIGlmICh0b3VyU3RhdGVWYWx1ZXMubGVuZ3RoID4gMikge1xuICAgICAgICAgIGNvb2tpZVNraXBwZWRTdGVwcyA9IHRvdXJTdGF0ZVZhbHVlc1syXS5zcGxpdCgnLCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29va2llVG91clN0ZXAgPSBwYXJzZUludChjb29raWVUb3VyU3RlcCwgMTApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIHRoZSBmaXJzdCBzdGVwIHRvIHNob3cgZm9yIGEgdG91ci4gKFdoYXQgaXMgdGhlIGZpcnN0IHN0ZXAgd2l0aCBhXG4gICAgICogdGFyZ2V0IG9uIHRoZSBwYWdlPylcbiAgICAgKi9cbiAgICBmaW5kU3RhcnRpbmdTdGVwID0gZnVuY3Rpb24gZmluZFN0YXJ0aW5nU3RlcChzdGFydFN0ZXBOdW0sIHNhdmVkU2tpcHBlZFN0ZXBzLCBjYikge1xuICAgICAgdmFyIHN0ZXAsIHRhcmdldDtcblxuICAgICAgY3VyclN0ZXBOdW0gPSBzdGFydFN0ZXBOdW0gfHwgMDtcbiAgICAgIHNraXBwZWRTdGVwcyA9IHNhdmVkU2tpcHBlZFN0ZXBzIHx8IHt9O1xuICAgICAgc3RlcCA9IGdldEN1cnJTdGVwKCk7XG4gICAgICB0YXJnZXQgPSB1dGlscy5nZXRTdGVwVGFyZ2V0KHN0ZXApO1xuXG4gICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgIC8vIEZpcnN0IHN0ZXAgaGFkIGFuIGV4aXN0aW5nIHRhcmdldC5cbiAgICAgICAgY2IoY3VyclN0ZXBOdW0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgIC8vIFByZXZpb3VzIHRhcmdldCBkb2Vzbid0IGV4aXN0IGVpdGhlci4gVGhlIHVzZXIgbWF5IGhhdmUganVzdFxuICAgICAgICAvLyBjbGlja2VkIG9uIGEgbGluayB0aGF0IHdhc24ndCBwYXJ0IG9mIHRoZSB0b3VyLiBBbm90aGVyIHBvc3NpYmlsaXR5IGlzIHRoYXRcbiAgICAgICAgLy8gdGhlIHVzZXIgY2xpY2tlZCBvbiB0aGUgY29ycmVjdCBsaW5rLCBidXQgdGhlIHRhcmdldCBpcyBqdXN0IG1pc3NpbmcgZm9yXG4gICAgICAgIC8vIHdoYXRldmVyIHJlYXNvbi4gSW4gZWl0aGVyIGNhc2UsIHdlIHNob3VsZCBqdXN0IGFkdmFuY2UgdW50aWwgd2UgZmluZCBhIHN0ZXBcbiAgICAgICAgLy8gdGhhdCBoYXMgYSB0YXJnZXQgb24gdGhlIHBhZ2Ugb3IgZW5kIHRoZSB0b3VyIGlmIHdlIGNhbid0IGZpbmQgc3VjaCBhIHN0ZXAuXG4gICAgICAgIHV0aWxzLmludm9rZUV2ZW50Q2FsbGJhY2tzKCdlcnJvcicpO1xuXG4gICAgICAgIC8vdGhpcyBzdGVwIHdhcyBza2lwcGVkLCBzaW5jZSBpdHMgdGFyZ2V0IGRvZXMgbm90IGV4aXN0XG4gICAgICAgIHNraXBwZWRTdGVwc1tjdXJyU3RlcE51bV0gPSB0cnVlO1xuXG4gICAgICAgIGlmIChnZXRPcHRpb24oJ3NraXBJZk5vRWxlbWVudCcpKSB7XG4gICAgICAgICAgZ29Ub1N0ZXBXaXRoVGFyZ2V0KDEsIGNiKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VyclN0ZXBOdW0gPSAtMTtcbiAgICAgICAgICBjYihjdXJyU3RlcE51bSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgICAgICBzaG93U3RlcEhlbHBlciA9IGZ1bmN0aW9uIHNob3dTdGVwSGVscGVyKHN0ZXBOdW0pIHtcbiAgICAgIHZhciBzdGVwID0gY3VyclRvdXIuc3RlcHNbc3RlcE51bV0sXG4gICAgICAgICAgYnViYmxlID0gZ2V0QnViYmxlKCksXG4gICAgICAgICAgdGFyZ2V0RWwgPSB1dGlscy5nZXRTdGVwVGFyZ2V0KHN0ZXApO1xuXG4gICAgICBmdW5jdGlvbiBzaG93QnViYmxlKCkge1xuICAgICAgICBidWJibGUuc2hvdygpO1xuICAgICAgICB1dGlscy5pbnZva2VFdmVudENhbGxiYWNrcygnc2hvdycsIHN0ZXAub25TaG93KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGN1cnJTdGVwTnVtICE9PSBzdGVwTnVtICYmIGdldEN1cnJTdGVwKCkubmV4dE9uVGFyZ2V0Q2xpY2spIHtcbiAgICAgICAgLy8gRGV0YWNoIHRoZSBsaXN0ZW5lciB3aGVuIHRvdXIgaXMgbW92aW5nIHRvIGEgZGlmZmVyZW50IHN0ZXBcbiAgICAgICAgdXRpbHMucmVtb3ZlRXZ0TGlzdGVuZXIodXRpbHMuZ2V0U3RlcFRhcmdldChnZXRDdXJyU3RlcCgpKSwgJ2NsaWNrJywgdGFyZ2V0Q2xpY2tOZXh0Rm4pO1xuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgYnViYmxlIGZvciBjdXJyZW50IHN0ZXBcbiAgICAgIGN1cnJTdGVwTnVtID0gc3RlcE51bTtcblxuICAgICAgYnViYmxlLmhpZGUoZmFsc2UpO1xuXG4gICAgICBidWJibGUucmVuZGVyKHN0ZXAsIHN0ZXBOdW0sIGZ1bmN0aW9uIChhZGp1c3RTY3JvbGwpIHtcbiAgICAgICAgLy8gd2hlbiBkb25lIGFkanVzdGluZyB3aW5kb3cgc2Nyb2xsLCBjYWxsIHNob3dCdWJibGUgaGVscGVyIGZuXG4gICAgICAgIGlmIChhZGp1c3RTY3JvbGwpIHtcbiAgICAgICAgICBhZGp1c3RXaW5kb3dTY3JvbGwoc2hvd0J1YmJsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2hvd0J1YmJsZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgd2Ugd2FudCB0byBhZHZhbmNlIHRvIG5leHQgc3RlcCB3aGVuIHVzZXIgY2xpY2tzIG9uIHRhcmdldC5cbiAgICAgICAgaWYgKHN0ZXAubmV4dE9uVGFyZ2V0Q2xpY2spIHtcbiAgICAgICAgICB1dGlscy5hZGRFdnRMaXN0ZW5lcih0YXJnZXRFbCwgJ2NsaWNrJywgdGFyZ2V0Q2xpY2tOZXh0Rm4pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgc2V0U3RhdGVIZWxwZXIoKTtcbiAgICB9LFxuICAgICAgICBzZXRTdGF0ZUhlbHBlciA9IGZ1bmN0aW9uIHNldFN0YXRlSGVscGVyKCkge1xuICAgICAgdmFyIGNvb2tpZVZhbCA9IGN1cnJUb3VyLmlkICsgJzonICsgY3VyclN0ZXBOdW0sXG4gICAgICAgICAgc2tpcGVkU3RlcEluZGV4ZXMgPSB3aW5Ib3BzY290Y2guZ2V0U2tpcHBlZFN0ZXBzSW5kZXhlcygpO1xuXG4gICAgICBpZiAoc2tpcGVkU3RlcEluZGV4ZXMgJiYgc2tpcGVkU3RlcEluZGV4ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb29raWVWYWwgKz0gJzonICsgc2tpcGVkU3RlcEluZGV4ZXMuam9pbignLCcpO1xuICAgICAgfVxuXG4gICAgICB1dGlscy5zZXRTdGF0ZShnZXRPcHRpb24oJ2Nvb2tpZU5hbWUnKSwgY29va2llVmFsLCAxKTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBpbml0XG4gICAgICpcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgSG9wc2NvdGNoIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgaW5pdCA9IGZ1bmN0aW9uIGluaXQoaW5pdE9wdGlvbnMpIHtcbiAgICAgIGlmIChpbml0T3B0aW9ucykge1xuICAgICAgICAvL2luaXRPcHRpb25zLmNvb2tpZU5hbWUgPSBpbml0T3B0aW9ucy5jb29raWVOYW1lIHx8ICdob3BzY290Y2gudG91ci5zdGF0ZSc7XG4gICAgICAgIHRoaXMuY29uZmlndXJlKGluaXRPcHRpb25zKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogZ2V0Q2FsbG91dE1hbmFnZXJcbiAgICAgKlxuICAgICAqIEdldHMgdGhlIGNhbGxvdXQgbWFuYWdlci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IEhvcHNjb3RjaENhbGxvdXRNYW5hZ2VyXG4gICAgICpcbiAgICAgKi9cbiAgICB0aGlzLmdldENhbGxvdXRNYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCh0eXBlb2YgY2FsbG91dE1nciA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoY2FsbG91dE1ncikpID09PSB1bmRlZmluZWRTdHIpIHtcbiAgICAgICAgY2FsbG91dE1nciA9IG5ldyBIb3BzY290Y2hDYWxsb3V0TWFuYWdlcigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2FsbG91dE1ncjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogc3RhcnRUb3VyXG4gICAgICpcbiAgICAgKiBCZWdpbnMgdGhlIHRvdXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdG91ciBUaGUgdG91ciBKU09OIG9iamVjdFxuICAgICAqIEBzdGVwTnVtIHtOdW1iZXJ9IHN0ZXBOdW0gX19PcHRpb25hbF9fIFRoZSBzdGVwIG51bWJlciB0byBzdGFydCBmcm9tXG4gICAgICogQHJldHVybnMge09iamVjdH0gSG9wc2NvdGNoXG4gICAgICpcbiAgICAgKi9cbiAgICB0aGlzLnN0YXJ0VG91ciA9IGZ1bmN0aW9uICh0b3VyLCBzdGVwTnVtKSB7XG4gICAgICB2YXIgYnViYmxlLFxuICAgICAgICAgIGN1cnJTdGVwTnVtLFxuICAgICAgICAgIHNraXBwZWRTdGVwcyA9IHt9LFxuICAgICAgICAgIHNlbGYgPSB0aGlzO1xuXG4gICAgICAvLyBsb2FkVG91ciBpZiB3ZSBhcmUgY2FsbGluZyBzdGFydFRvdXIgZGlyZWN0bHkuIChXaGVuIHdlIGNhbGwgc3RhcnRUb3VyXG4gICAgICAvLyBmcm9tIHdpbmRvdyBvbkxvYWQgaGFuZGxlciwgd2UnbGwgdXNlIGN1cnJUb3VyKVxuICAgICAgaWYgKCFjdXJyVG91cikge1xuXG4gICAgICAgIC8vIFNhbml0eSBjaGVjayEgSXMgdGhlcmUgYSB0b3VyP1xuICAgICAgICBpZiAoIXRvdXIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvdXIgZGF0YSBpcyByZXF1aXJlZCBmb3Igc3RhcnRUb3VyLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgdmFsaWRpdHkgb2YgdG91ciBJRC4gSWYgaW52YWxpZCwgdGhyb3cgYW4gZXJyb3IuXG4gICAgICAgIGlmICghdG91ci5pZCB8fCAhdmFsaWRJZFJlZ0V4LnRlc3QodG91ci5pZCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvdXIgSUQgaXMgdXNpbmcgYW4gaW52YWxpZCBmb3JtYXQuIFVzZSBhbHBoYW51bWVyaWMsIHVuZGVyc2NvcmVzLCBhbmQvb3IgaHlwaGVucyBvbmx5LiBGaXJzdCBjaGFyYWN0ZXIgbXVzdCBiZSBhIGxldHRlci4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJUb3VyID0gdG91cjtcbiAgICAgICAgbG9hZFRvdXIuY2FsbCh0aGlzLCB0b3VyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCh0eXBlb2Ygc3RlcE51bSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yoc3RlcE51bSkpICE9PSB1bmRlZmluZWRTdHIpIHtcbiAgICAgICAgaWYgKHN0ZXBOdW0gPj0gY3VyclRvdXIuc3RlcHMubGVuZ3RoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTcGVjaWZpZWQgc3RlcCBudW1iZXIgb3V0IG9mIGJvdW5kcy4nKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyU3RlcE51bSA9IHN0ZXBOdW07XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGRvY3VtZW50IGlzbid0IHJlYWR5LCB3YWl0IGZvciBpdCB0byBmaW5pc2ggbG9hZGluZy5cbiAgICAgIC8vIChzbyB0aGF0IHdlIGNhbiBjYWxjdWxhdGUgcG9zaXRpb25pbmcgYWNjdXJhdGVseSlcbiAgICAgIGlmICghdXRpbHMuZG9jdW1lbnRJc1JlYWR5KCkpIHtcbiAgICAgICAgd2FpdGluZ1RvU3RhcnQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBjdXJyU3RlcE51bSA9PT0gXCJ1bmRlZmluZWRcIiAmJiBjdXJyVG91ci5pZCA9PT0gY29va2llVG91cklkICYmICh0eXBlb2YgY29va2llVG91clN0ZXAgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGNvb2tpZVRvdXJTdGVwKSkgIT09IHVuZGVmaW5lZFN0cikge1xuICAgICAgICBjdXJyU3RlcE51bSA9IGNvb2tpZVRvdXJTdGVwO1xuICAgICAgICBpZiAoY29va2llU2tpcHBlZFN0ZXBzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY29va2llU2tpcHBlZFN0ZXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBza2lwcGVkU3RlcHNbY29va2llU2tpcHBlZFN0ZXBzW2ldXSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFjdXJyU3RlcE51bSkge1xuICAgICAgICBjdXJyU3RlcE51bSA9IDA7XG4gICAgICB9XG5cbiAgICAgIC8vIEZpbmQgdGhlIGN1cnJlbnQgc3RlcCB3ZSBzaG91bGQgYmVnaW4gdGhlIHRvdXIgb24sIGFuZCB0aGVuIGFjdHVhbGx5IHN0YXJ0IHRoZSB0b3VyLlxuICAgICAgZmluZFN0YXJ0aW5nU3RlcChjdXJyU3RlcE51bSwgc2tpcHBlZFN0ZXBzLCBmdW5jdGlvbiAoc3RlcE51bSkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gc3RlcE51bSAhPT0gLTEgJiYgdXRpbHMuZ2V0U3RlcFRhcmdldChjdXJyVG91ci5zdGVwc1tzdGVwTnVtXSk7XG5cbiAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAvLyBTaG91bGQgd2UgdHJpZ2dlciBvbkVuZCBjYWxsYmFjaz8gTGV0J3MgZXJyIG9uIHRoZSBzaWRlIG9mIGNhdXRpb25cbiAgICAgICAgICAvLyBhbmQgbm90IHRyaWdnZXIgaXQuIERvbid0IHdhbnQgd2VpcmQgc3R1ZmYgaGFwcGVuaW5nIG9uIGEgcGFnZSB0aGF0XG4gICAgICAgICAgLy8gd2Fzbid0IG1lYW50IGZvciB0aGUgdG91ci4gVXAgdG8gdGhlIGRldmVsb3BlciB0byBmaXggdGhlaXIgdG91ci5cbiAgICAgICAgICBzZWxmLmVuZFRvdXIoZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB1dGlscy5pbnZva2VFdmVudENhbGxiYWNrcygnc3RhcnQnKTtcblxuICAgICAgICBidWJibGUgPSBnZXRCdWJibGUoKTtcbiAgICAgICAgLy8gVE9ETzogZG8gd2Ugc3RpbGwgbmVlZCB0aGlzIGNhbGwgdG8gLmhpZGUoKT8gTm8gbG9uZ2VyIHVzaW5nIG9wdC5hbmltYXRlLi4uXG4gICAgICAgIC8vIExlYXZpbmcgaXQgaW4gZm9yIG5vdyB0byBwbGF5IGl0IHNhZmVcbiAgICAgICAgYnViYmxlLmhpZGUoZmFsc2UpOyAvLyBtYWtlIGludmlzaWJsZSBmb3IgYm91bmRpbmdSZWN0IGNhbGN1bGF0aW9ucyB3aGVuIG9wdC5hbmltYXRlID09IHRydWVcblxuICAgICAgICBzZWxmLmlzQWN0aXZlID0gdHJ1ZTtcblxuICAgICAgICBpZiAoIXV0aWxzLmdldFN0ZXBUYXJnZXQoZ2V0Q3VyclN0ZXAoKSkpIHtcbiAgICAgICAgICAvLyBGaXJzdCBzdGVwIGVsZW1lbnQgZG9lc24ndCBleGlzdFxuICAgICAgICAgIHV0aWxzLmludm9rZUV2ZW50Q2FsbGJhY2tzKCdlcnJvcicpO1xuICAgICAgICAgIGlmIChnZXRPcHRpb24oJ3NraXBJZk5vRWxlbWVudCcpKSB7XG4gICAgICAgICAgICBzZWxmLm5leHRTdGVwKGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VsZi5zaG93U3RlcChzdGVwTnVtKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBzaG93U3RlcFxuICAgICAqXG4gICAgICogU2tpcHMgdG8gYSBzcGVjaWZpYyBzdGVwIGFuZCByZW5kZXJzIHRoZSBjb3JyZXNwb25kaW5nIGJ1YmJsZS5cbiAgICAgKlxuICAgICAqIEBzdGVwTnVtIHtOdW1iZXJ9IHN0ZXBOdW0gVGhlIHN0ZXAgbnVtYmVyIHRvIHNob3dcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBIb3BzY290Y2hcbiAgICAgKi9cbiAgICB0aGlzLnNob3dTdGVwID0gZnVuY3Rpb24gKHN0ZXBOdW0pIHtcbiAgICAgIHZhciBzdGVwID0gY3VyclRvdXIuc3RlcHNbc3RlcE51bV0sXG4gICAgICAgICAgcHJldlN0ZXBOdW0gPSBjdXJyU3RlcE51bTtcbiAgICAgIGlmICghdXRpbHMuZ2V0U3RlcFRhcmdldChzdGVwKSkge1xuICAgICAgICBjdXJyU3RlcE51bSA9IHN0ZXBOdW07XG4gICAgICAgIHV0aWxzLmludm9rZUV2ZW50Q2FsbGJhY2tzKCdlcnJvcicpO1xuICAgICAgICBjdXJyU3RlcE51bSA9IHByZXZTdGVwTnVtO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGVwLmRlbGF5KSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHNob3dTdGVwSGVscGVyKHN0ZXBOdW0pO1xuICAgICAgICB9LCBzdGVwLmRlbGF5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNob3dTdGVwSGVscGVyKHN0ZXBOdW0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHByZXZTdGVwXG4gICAgICpcbiAgICAgKiBKdW1wIHRvIHRoZSBwcmV2aW91cyBzdGVwLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBkb0NhbGxiYWNrcyBGbGFnIGZvciBpbnZva2luZyBvblByZXYgY2FsbGJhY2suIERlZmF1bHRzIHRvIHRydWUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gSG9wc2NvdGNoXG4gICAgICovXG4gICAgdGhpcy5wcmV2U3RlcCA9IGZ1bmN0aW9uIChkb0NhbGxiYWNrcykge1xuICAgICAgY2hhbmdlU3RlcC5jYWxsKHRoaXMsIGRvQ2FsbGJhY2tzLCAtMSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogbmV4dFN0ZXBcbiAgICAgKlxuICAgICAqIEp1bXAgdG8gdGhlIG5leHQgc3RlcC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZG9DYWxsYmFja3MgRmxhZyBmb3IgaW52b2tpbmcgb25OZXh0IGNhbGxiYWNrLiBEZWZhdWx0cyB0byB0cnVlLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IEhvcHNjb3RjaFxuICAgICAqL1xuICAgIHRoaXMubmV4dFN0ZXAgPSBmdW5jdGlvbiAoZG9DYWxsYmFja3MpIHtcbiAgICAgIGNoYW5nZVN0ZXAuY2FsbCh0aGlzLCBkb0NhbGxiYWNrcywgMSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogZW5kVG91clxuICAgICAqXG4gICAgICogQ2FuY2VscyBvdXQgb2YgYW4gYWN0aXZlIHRvdXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNsZWFyU3RhdGUgRmxhZyBmb3IgY2xlYXJpbmcgc3RhdGUuIERlZmF1bHRzIHRvIHRydWUuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBkb0NhbGxiYWNrcyBGbGFnIGZvciBpbnZva2luZyAnb25FbmQnIGNhbGxiYWNrcy4gRGVmYXVsdHMgdG8gdHJ1ZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBIb3BzY290Y2hcbiAgICAgKi9cbiAgICB0aGlzLmVuZFRvdXIgPSBmdW5jdGlvbiAoY2xlYXJTdGF0ZSwgZG9DYWxsYmFja3MpIHtcbiAgICAgIHZhciBidWJibGUgPSBnZXRCdWJibGUoKSxcbiAgICAgICAgICBjdXJyZW50U3RlcDtcblxuICAgICAgY2xlYXJTdGF0ZSA9IHV0aWxzLnZhbE9yRGVmYXVsdChjbGVhclN0YXRlLCB0cnVlKTtcbiAgICAgIGRvQ2FsbGJhY2tzID0gdXRpbHMudmFsT3JEZWZhdWx0KGRvQ2FsbGJhY2tzLCB0cnVlKTtcblxuICAgICAgLy9yZW1vdmUgZXZlbnQgbGlzdGVuZXIgaWYgY3VycmVudCBzdGVwIGhhZCBpdCBhZGRlZFxuICAgICAgaWYgKGN1cnJUb3VyKSB7XG4gICAgICAgIGN1cnJlbnRTdGVwID0gZ2V0Q3VyclN0ZXAoKTtcbiAgICAgICAgaWYgKGN1cnJlbnRTdGVwICYmIGN1cnJlbnRTdGVwLm5leHRPblRhcmdldENsaWNrKSB7XG4gICAgICAgICAgdXRpbHMucmVtb3ZlRXZ0TGlzdGVuZXIodXRpbHMuZ2V0U3RlcFRhcmdldChjdXJyZW50U3RlcCksICdjbGljaycsIHRhcmdldENsaWNrTmV4dEZuKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjdXJyU3RlcE51bSA9IDA7XG4gICAgICBjb29raWVUb3VyU3RlcCA9IHVuZGVmaW5lZDtcblxuICAgICAgYnViYmxlLmhpZGUoKTtcbiAgICAgIGlmIChjbGVhclN0YXRlKSB7XG4gICAgICAgIHV0aWxzLmNsZWFyU3RhdGUoZ2V0T3B0aW9uKCdjb29raWVOYW1lJykpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaXNBY3RpdmUpIHtcbiAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChjdXJyVG91ciAmJiBkb0NhbGxiYWNrcykge1xuICAgICAgICAgIHV0aWxzLmludm9rZUV2ZW50Q2FsbGJhY2tzKCdlbmQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnJlbW92ZUNhbGxiYWNrcyhudWxsLCB0cnVlKTtcbiAgICAgIHRoaXMucmVzZXREZWZhdWx0T3B0aW9ucygpO1xuICAgICAgZGVzdHJveUJ1YmJsZSgpO1xuXG4gICAgICBjdXJyVG91ciA9IG51bGw7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBnZXRDdXJyVG91clxuICAgICAqXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY3VycmVudGx5IGxvYWRlZCB0b3VyLlxuICAgICAqL1xuICAgIHRoaXMuZ2V0Q3VyclRvdXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gY3VyclRvdXI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGdldEN1cnJUYXJnZXRcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGN1cnJlbnRseSB2aXNpYmxlIHRhcmdldC5cbiAgICAgKi9cbiAgICB0aGlzLmdldEN1cnJUYXJnZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdXRpbHMuZ2V0U3RlcFRhcmdldChnZXRDdXJyU3RlcCgpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogZ2V0Q3VyclN0ZXBOdW1cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIGN1cnJlbnQgemVyby1iYXNlZCBzdGVwIG51bWJlci5cbiAgICAgKi9cbiAgICB0aGlzLmdldEN1cnJTdGVwTnVtID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGN1cnJTdGVwTnVtO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBnZXRTa2lwcGVkU3RlcHNJbmRleGVzXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgb2Ygc2tpcHBlZCBzdGVwIGluZGV4ZXNcbiAgICAgKi9cbiAgICB0aGlzLmdldFNraXBwZWRTdGVwc0luZGV4ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc2tpcHBlZFN0ZXBzSWR4QXJyYXkgPSBbXSxcbiAgICAgICAgICBzdGVwSWRzO1xuXG4gICAgICBmb3IgKHN0ZXBJZHMgaW4gc2tpcHBlZFN0ZXBzKSB7XG4gICAgICAgIHNraXBwZWRTdGVwc0lkeEFycmF5LnB1c2goc3RlcElkcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBza2lwcGVkU3RlcHNJZHhBcnJheTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogcmVmcmVzaEJ1YmJsZVBvc2l0aW9uXG4gICAgICpcbiAgICAgKiBUZWxsIGhvcHNjb3RjaCB0aGF0IHRoZSBwb3NpdGlvbiBvZiB0aGUgY3VycmVudCB0b3VyIGVsZW1lbnQgY2hhbmdlZFxuICAgICAqIGFuZCB0aGUgYnViYmxlIHRoZXJlZm9yZSBuZWVkcyB0byBiZSByZWRyYXduLiBBbHNvIHJlZnJlc2hlcyBwb3NpdGlvblxuICAgICAqIG9mIGFsbCBIb3BzY290Y2ggQ2FsbG91dHMgb24gdGhlIHBhZ2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBIb3BzY290Y2hcbiAgICAgKi9cbiAgICB0aGlzLnJlZnJlc2hCdWJibGVQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjdXJyU3RlcCA9IGdldEN1cnJTdGVwKCk7XG4gICAgICBpZiAoY3VyclN0ZXApIHtcbiAgICAgICAgZ2V0QnViYmxlKCkuc2V0UG9zaXRpb24oY3VyclN0ZXApO1xuICAgICAgfVxuICAgICAgdGhpcy5nZXRDYWxsb3V0TWFuYWdlcigpLnJlZnJlc2hDYWxsb3V0UG9zaXRpb25zKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogbGlzdGVuXG4gICAgICpcbiAgICAgKiBBZGRzIGEgY2FsbGJhY2sgZm9yIG9uZSBvZiB0aGUgZXZlbnQgdHlwZXMuIFZhbGlkIGV2ZW50IHR5cGVzIGFyZTpcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlIFwic3RhcnRcIiwgXCJlbmRcIiwgXCJuZXh0XCIsIFwicHJldlwiLCBcInNob3dcIiwgXCJjbG9zZVwiLCBvciBcImVycm9yXCJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBUaGUgY2FsbGJhY2sgdG8gYWRkLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNUb3VyQ2IgRmxhZyBpbmRpY2F0aW5nIGNhbGxiYWNrIGlzIGZyb20gYSB0b3VyIGRlZmluaXRpb24uXG4gICAgICogICAgRm9yIGludGVybmFsIHVzZSBvbmx5IVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IEhvcHNjb3RjaFxuICAgICAqL1xuICAgIHRoaXMubGlzdGVuID0gZnVuY3Rpb24gKGV2dFR5cGUsIGNiLCBpc1RvdXJDYikge1xuICAgICAgaWYgKGV2dFR5cGUpIHtcbiAgICAgICAgY2FsbGJhY2tzW2V2dFR5cGVdLnB1c2goeyBjYjogY2IsIGZyb21Ub3VyOiBpc1RvdXJDYiB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiB1bmxpc3RlblxuICAgICAqXG4gICAgICogUmVtb3ZlcyBhIGNhbGxiYWNrIGZvciBvbmUgb2YgdGhlIGV2ZW50IHR5cGVzLCBlLmcuICdzdGFydCcsICduZXh0JywgZXRjLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2dFR5cGUgXCJzdGFydFwiLCBcImVuZFwiLCBcIm5leHRcIiwgXCJwcmV2XCIsIFwic2hvd1wiLCBcImNsb3NlXCIsIG9yIFwiZXJyb3JcIlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIFRoZSBjYWxsYmFjayB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gSG9wc2NvdGNoXG4gICAgICovXG4gICAgdGhpcy51bmxpc3RlbiA9IGZ1bmN0aW9uIChldnRUeXBlLCBjYikge1xuICAgICAgdmFyIGV2dENhbGxiYWNrcyA9IGNhbGxiYWNrc1tldnRUeXBlXSxcbiAgICAgICAgICBpLFxuICAgICAgICAgIGxlbjtcblxuICAgICAgZm9yIChpID0gMCwgbGVuID0gZXZ0Q2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIGlmIChldnRDYWxsYmFja3NbaV0uY2IgPT09IGNiKSB7XG4gICAgICAgICAgZXZ0Q2FsbGJhY2tzLnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHJlbW92ZUNhbGxiYWNrc1xuICAgICAqXG4gICAgICogUmVtb3ZlIGNhbGxiYWNrcyBmb3IgaG9wc2NvdGNoIGV2ZW50cy4gSWYgdG91ck9ubHkgaXMgc2V0IHRvIHRydWUsIG9ubHlcbiAgICAgKiByZW1vdmVzIGNhbGxiYWNrcyBzcGVjaWZpZWQgYnkgYSB0b3VyIChjYWxsYmFja3Mgc2V0IGJ5IGV4dGVybmFsIGNhbGxzXG4gICAgICogdG8gaG9wc2NvdGNoLmNvbmZpZ3VyZSBvciBob3BzY290Y2gubGlzdGVuIHdpbGwgbm90IGJlIHJlbW92ZWQpLiBJZlxuICAgICAqIGV2dE5hbWUgaXMgbnVsbCBvciB1bmRlZmluZWQsIGNhbGxiYWNrcyBmb3IgYWxsIGV2ZW50cyB3aWxsIGJlIHJlbW92ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0TmFtZSBPcHRpb25hbCBFdmVudCBuYW1lIGZvciB3aGljaCB3ZSBzaG91bGQgcmVtb3ZlIGNhbGxiYWNrc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdG91ck9ubHkgT3B0aW9uYWwgZmxhZyB0byBpbmRpY2F0ZSB3ZSBzaG91bGQgb25seSByZW1vdmUgY2FsbGJhY2tzIGFkZGVkXG4gICAgICogICAgYnkgYSB0b3VyLiBEZWZhdWx0cyB0byBmYWxzZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBIb3BzY290Y2hcbiAgICAgKi9cbiAgICB0aGlzLnJlbW92ZUNhbGxiYWNrcyA9IGZ1bmN0aW9uIChldnROYW1lLCB0b3VyT25seSkge1xuICAgICAgdmFyIGNiQXJyLCBpLCBsZW4sIGV2dDtcblxuICAgICAgLy8gSWYgZXZ0TmFtZSBpcyBudWxsIG9yIHVuZGVmaW5lZCwgcmVtb3ZlIGNhbGxiYWNrcyBmb3IgYWxsIGV2ZW50cy5cbiAgICAgIGZvciAoZXZ0IGluIGNhbGxiYWNrcykge1xuICAgICAgICBpZiAoIWV2dE5hbWUgfHwgZXZ0TmFtZSA9PT0gZXZ0KSB7XG4gICAgICAgICAgaWYgKHRvdXJPbmx5KSB7XG4gICAgICAgICAgICBjYkFyciA9IGNhbGxiYWNrc1tldnRdO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gY2JBcnIubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgaWYgKGNiQXJyW2ldLmZyb21Ub3VyKSB7XG4gICAgICAgICAgICAgICAgY2JBcnIuc3BsaWNlKGktLSwgMSk7XG4gICAgICAgICAgICAgICAgLS1sZW47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2tzW2V2dF0gPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiByZWdpc3RlckhlbHBlclxuICAgICAqID09PT09PT09PT09PT09XG4gICAgICogUmVnaXN0ZXJzIGEgaGVscGVyIGZ1bmN0aW9uIHRvIGJlIHVzZWQgYXMgYSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZCBUaGUgaWQgb2YgdGhlIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGlkIFRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICB0aGlzLnJlZ2lzdGVySGVscGVyID0gZnVuY3Rpb24gKGlkLCBmbikge1xuICAgICAgaWYgKHR5cGVvZiBpZCA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGhlbHBlcnNbaWRdID0gZm47XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMudW5yZWdpc3RlckhlbHBlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgaGVscGVyc1tpZF0gPSBudWxsO1xuICAgIH07XG5cbiAgICB0aGlzLmludm9rZUhlbHBlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgICBpLFxuICAgICAgICAgIGxlbjtcblxuICAgICAgZm9yIChpID0gMSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgICAgfVxuICAgICAgaWYgKGhlbHBlcnNbaWRdKSB7XG4gICAgICAgIGhlbHBlcnNbaWRdLmNhbGwobnVsbCwgYXJncyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHNldENvb2tpZU5hbWVcbiAgICAgKlxuICAgICAqIFNldHMgdGhlIGNvb2tpZSBuYW1lIChvciBzZXNzaW9uU3RvcmFnZSBuYW1lLCBpZiBzdXBwb3J0ZWQpIHVzZWQgZm9yIG11bHRpLXBhZ2VcbiAgICAgKiB0b3VyIHBlcnNpc3RlbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIGNvb2tpZSBuYW1lXG4gICAgICogQHJldHVybnMge09iamVjdH0gSG9wc2NvdGNoXG4gICAgICovXG4gICAgdGhpcy5zZXRDb29raWVOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIG9wdC5jb29raWVOYW1lID0gbmFtZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiByZXNldERlZmF1bHRPcHRpb25zXG4gICAgICpcbiAgICAgKiBSZXNldHMgYWxsIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byBkZWZhdWx0LlxuICAgICAqXG4gICAgICogQHJldHVybnMge09iamVjdH0gSG9wc2NvdGNoXG4gICAgICovXG4gICAgdGhpcy5yZXNldERlZmF1bHRPcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgb3B0ID0ge307XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogcmVzZXREZWZhdWx0STE4TlxuICAgICAqXG4gICAgICogUmVzZXRzIGFsbCBpMThuLlxuICAgICAqXG4gICAgICogQHJldHVybnMge09iamVjdH0gSG9wc2NvdGNoXG4gICAgICovXG4gICAgdGhpcy5yZXNldERlZmF1bHRJMThOID0gZnVuY3Rpb24gKCkge1xuICAgICAgY3VzdG9tSTE4TiA9IHt9O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGhhc1N0YXRlXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIHN0YXRlIGZyb20gYSBwcmV2aW91cyB0b3VyIHJ1biwgaWYgaXQgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1N0cmluZ30gU3RhdGUgb2YgcHJldmlvdXMgdG91ciBydW4sIG9yIGVtcHR5IHN0cmluZyBpZiBub25lIGV4aXN0cy5cbiAgICAgKi9cbiAgICB0aGlzLmdldFN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHV0aWxzLmdldFN0YXRlKGdldE9wdGlvbignY29va2llTmFtZScpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogX2NvbmZpZ3VyZVxuICAgICAqXG4gICAgICogQHNlZSB0aGlzLmNvbmZpZ3VyZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzVG91ck9wdGlvbnMgU2hvdWxkIGJlIHNldCB0byB0cnVlIHdoZW4gc2V0dGluZyBvcHRpb25zIGZyb20gYSB0b3VyIGRlZmluaXRpb24uXG4gICAgICovXG4gICAgX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uIF9jb25maWd1cmUob3B0aW9ucywgaXNUb3VyT3B0aW9ucykge1xuICAgICAgdmFyIGJ1YmJsZSxcbiAgICAgICAgICBldmVudHMgPSBbJ25leHQnLCAncHJldicsICdzdGFydCcsICdlbmQnLCAnc2hvdycsICdlcnJvcicsICdjbG9zZSddLFxuICAgICAgICAgIGV2ZW50UHJvcE5hbWUsXG4gICAgICAgICAgY2FsbGJhY2tQcm9wLFxuICAgICAgICAgIGksXG4gICAgICAgICAgbGVuO1xuXG4gICAgICBpZiAoIW9wdCkge1xuICAgICAgICB0aGlzLnJlc2V0RGVmYXVsdE9wdGlvbnMoKTtcbiAgICAgIH1cblxuICAgICAgdXRpbHMuZXh0ZW5kKG9wdCwgb3B0aW9ucyk7XG5cbiAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIHV0aWxzLmV4dGVuZChjdXN0b21JMThOLCBvcHRpb25zLmkxOG4pO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBldmVudHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgLy8gQXQgdGhpcyBwb2ludCwgb3B0aW9uc1tldmVudFByb3BOYW1lXSBtYXkgaGF2ZSBjaGFuZ2VkIGZyb20gYW4gYXJyYXlcbiAgICAgICAgLy8gdG8gYSBmdW5jdGlvbi5cbiAgICAgICAgZXZlbnRQcm9wTmFtZSA9ICdvbicgKyBldmVudHNbaV0uY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBldmVudHNbaV0uc3Vic3RyaW5nKDEpO1xuICAgICAgICBpZiAob3B0aW9uc1tldmVudFByb3BOYW1lXSkge1xuICAgICAgICAgIHRoaXMubGlzdGVuKGV2ZW50c1tpXSwgb3B0aW9uc1tldmVudFByb3BOYW1lXSwgaXNUb3VyT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYnViYmxlID0gZ2V0QnViYmxlKHRydWUpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogY29uZmlndXJlXG4gICAgICpcbiAgICAgKiA8cHJlPlxuICAgICAqIFZBTElEIE9QVElPTlMgSU5DTFVERS4uLlxuICAgICAqXG4gICAgICogLSBidWJibGVXaWR0aDogICAgIE51bWJlciAgIC0gRGVmYXVsdCBidWJibGUgd2lkdGguIERlZmF1bHRzIHRvIDI4MC5cbiAgICAgKiAtIGJ1YmJsZVBhZGRpbmc6ICAgTnVtYmVyICAgLSBERVBSRUNBVEVELiBEZWZhdWx0IGJ1YmJsZSBwYWRkaW5nLiBEZWZhdWx0cyB0byAxNS5cbiAgICAgKiAtIHNtb290aFNjcm9sbDogICAgQm9vbGVhbiAgLSBzaG91bGQgdGhlIHBhZ2Ugc2Nyb2xsIHNtb290aGx5IHRvIHRoZSBuZXh0XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RlcD8gRGVmYXVsdHMgdG8gVFJVRS5cbiAgICAgKiAtIHNjcm9sbER1cmF0aW9uOiAgTnVtYmVyICAgLSBEdXJhdGlvbiBvZiBwYWdlIHNjcm9sbC4gT25seSByZWxldmFudCB3aGVuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc21vb3RoU2Nyb2xsIGlzIHNldCB0byB0cnVlLiBEZWZhdWx0cyB0b1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEwMDBtcy5cbiAgICAgKiAtIHNjcm9sbFRvcE1hcmdpbjogTlVNQkVSICAgLSBXaGVuIHRoZSBwYWdlIHNjcm9sbHMsIGhvdyBtdWNoIHNwYWNlIHNob3VsZCB0aGVyZVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlIGJldHdlZW4gdGhlIGJ1YmJsZS90YXJnZXRFbGVtZW50IGFuZCB0aGUgdG9wXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2YgdGhlIHZpZXdwb3J0PyBEZWZhdWx0cyB0byAyMDAuXG4gICAgICogLSBzaG93Q2xvc2VCdXR0b246IEJvb2xlYW4gIC0gc2hvdWxkIHRoZSB0b3VyIGJ1YmJsZSBzaG93IGEgY2xvc2UgKFgpIGJ1dHRvbj9cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0cyB0byBUUlVFLlxuICAgICAqIC0gc2hvd1ByZXZCdXR0b246ICBCb29sZWFuICAtIHNob3VsZCB0aGUgYnViYmxlIGhhdmUgdGhlIFByZXZpb3VzIGJ1dHRvbj9cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0cyB0byBGQUxTRS5cbiAgICAgKiAtIHNob3dOZXh0QnV0dG9uOiAgQm9vbGVhbiAgLSBzaG91bGQgdGhlIGJ1YmJsZSBoYXZlIHRoZSBOZXh0IGJ1dHRvbj9cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0cyB0byBUUlVFLlxuICAgICAqIC0gYXJyb3dXaWR0aDogICAgICBOdW1iZXIgICAtIERlZmF1bHQgYXJyb3cgd2lkdGguIChzcGFjZSBiZXR3ZWVuIHRoZSBidWJibGVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgdGhlIHRhcmdldEVsKSBVc2VkIGZvciBidWJibGUgcG9zaXRpb25cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxjdWxhdGlvbi4gT25seSB1c2UgdGhpcyBvcHRpb24gaWYgeW91IGFyZVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzaW5nIHlvdXIgb3duIGN1c3RvbSBDU1MuIERlZmF1bHRzIHRvIDIwLlxuICAgICAqIC0gc2tpcElmTm9FbGVtZW50ICBCb29sZWFuICAtIElmIGEgc3BlY2lmaWVkIHRhcmdldCBlbGVtZW50IGlzIG5vdCBmb3VuZCxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG91bGQgd2Ugc2tpcCB0byB0aGUgbmV4dCBzdGVwPyBEZWZhdWx0cyB0b1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRSVUUuXG4gICAgICogLSBvbk5leHQ6ICAgICAgICAgIEZ1bmN0aW9uIC0gQSBjYWxsYmFjayB0byBiZSBpbnZva2VkIGFmdGVyIGV2ZXJ5IGNsaWNrIG9uXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSBcIk5leHRcIiBidXR0b24uXG4gICAgICogLSBpc1J0bDogICAgICAgICAgIEJvb2xlYW4gIC0gU2V0IHRvIHRydWUgd2hlbiBpbnN0YW50aWF0aW5nIGluIGEgcmlnaHQtdG8tbGVmdFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhbmd1YWdlIGVudmlyb25tZW50LCBvciBpZiBtaXJyb3JlZCBwb3NpdGlvbmluZyBpc1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5lZWRlZC5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0cyB0byBGQUxTRS5cbiAgICAgKlxuICAgICAqIC0gaTE4bjogICAgICAgICAgICBPYmplY3QgICAtIEZvciBpMThuIHB1cnBvc2VzLiBBbGxvd3MgeW91IHRvIGNoYW5nZSB0aGVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0IG9mIGJ1dHRvbiBsYWJlbHMgYW5kIHN0ZXAgbnVtYmVycy5cbiAgICAgKiAtIGkxOG4uc3RlcE51bXM6ICAgQXJyYXlcXDxTdHJpbmdcXD4gLSBQcm92aWRlIGEgbGlzdCBvZiBzdHJpbmdzIHRvIGJlIHNob3duIGFzXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIHN0ZXAgbnVtYmVyLCBiYXNlZCBvbiBpbmRleCBvZiBhcnJheS4gVW5pY29kZVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJhY3RlcnMgYXJlIHN1cHBvcnRlZC4gKGUuZy4sIFsnJiN4NGUwMDsnLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcmI3g0ZThjOycsICcmI3g0ZTA5OyddKSBJZiB0aGVyZSBhcmUgbW9yZSBzdGVwc1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYW4gcHJvdmlkZWQgbnVtYmVycywgQXJhYmljIG51bWVyYWxzXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCc0JywgJzUnLCAnNicsIGV0Yy4pIHdpbGwgYmUgdXNlZCBhcyBkZWZhdWx0LlxuICAgICAqIC8vID09PT09PT09PVxuICAgICAqIC8vIENBTExCQUNLU1xuICAgICAqIC8vID09PT09PT09PVxuICAgICAqIC0gb25OZXh0OiAgICAgICAgICBGdW5jdGlvbiAtIEludm9rZWQgYWZ0ZXIgZXZlcnkgY2xpY2sgb24gYSBcIk5leHRcIiBidXR0b24uXG4gICAgICogLSBvblByZXY6ICAgICAgICAgIEZ1bmN0aW9uIC0gSW52b2tlZCBhZnRlciBldmVyeSBjbGljayBvbiBhIFwiUHJldlwiIGJ1dHRvbi5cbiAgICAgKiAtIG9uU3RhcnQ6ICAgICAgICAgRnVuY3Rpb24gLSBJbnZva2VkIHdoZW4gdGhlIHRvdXIgaXMgc3RhcnRlZC5cbiAgICAgKiAtIG9uRW5kOiAgICAgICAgICAgRnVuY3Rpb24gLSBJbnZva2VkIHdoZW4gdGhlIHRvdXIgZW5kcy5cbiAgICAgKiAtIG9uQ2xvc2U6ICAgICAgICAgRnVuY3Rpb24gLSBJbnZva2VkIHdoZW4gdGhlIHVzZXIgY2xvc2VzIHRoZSB0b3VyIGJlZm9yZSBmaW5pc2hpbmcuXG4gICAgICogLSBvbkVycm9yOiAgICAgICAgIEZ1bmN0aW9uIC0gSW52b2tlZCB3aGVuIHRoZSBzcGVjaWZpZWQgdGFyZ2V0IGVsZW1lbnQgZG9lc24ndCBleGlzdCBvbiB0aGUgcGFnZS5cbiAgICAgKlxuICAgICAqIC8vID09PT1cbiAgICAgKiAvLyBJMThOXG4gICAgICogLy8gPT09PVxuICAgICAqIGkxOG46ICAgICAgICAgICAgICBPQkpFQ1QgICAgICAtIEZvciBpMThuIHB1cnBvc2VzLiBBbGxvd3MgeW91IHRvIGNoYW5nZSB0aGUgdGV4dFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mIGJ1dHRvbiBsYWJlbHMgYW5kIHN0ZXAgbnVtYmVycy5cbiAgICAgKiBpMThuLm5leHRCdG46ICAgICAgU1RSSU5HICAgICAgLSBMYWJlbCBmb3IgbmV4dCBidXR0b25cbiAgICAgKiBpMThuLnByZXZCdG46ICAgICAgU1RSSU5HICAgICAgLSBMYWJlbCBmb3IgcHJldiBidXR0b25cbiAgICAgKiBpMThuLmRvbmVCdG46ICAgICAgU1RSSU5HICAgICAgLSBMYWJlbCBmb3IgZG9uZSBidXR0b25cbiAgICAgKiBpMThuLnNraXBCdG46ICAgICAgU1RSSU5HICAgICAgLSBMYWJlbCBmb3Igc2tpcCBidXR0b25cbiAgICAgKiBpMThuLmNsb3NlVG9vbHRpcDogU1RSSU5HICAgICAgLSBUZXh0IGZvciBjbG9zZSBidXR0b24gdG9vbHRpcFxuICAgICAqIGkxOG4uc3RlcE51bXM6ICAgQVJSQVk8U1RSSU5HPiAtIFByb3ZpZGUgYSBsaXN0IG9mIHN0cmluZ3MgdG8gYmUgc2hvd24gYXNcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgc3RlcCBudW1iZXIsIGJhc2VkIG9uIGluZGV4IG9mIGFycmF5LiBVbmljb2RlXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhcmFjdGVycyBhcmUgc3VwcG9ydGVkLiAoZS5nLiwgWycmI3g0ZTAwOycsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyYjeDRlOGM7JywgJyYjeDRlMDk7J10pIElmIHRoZXJlIGFyZSBtb3JlIHN0ZXBzXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhbiBwcm92aWRlZCBudW1iZXJzLCBBcmFiaWMgbnVtZXJhbHNcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoJzQnLCAnNScsICc2JywgZXRjLikgd2lsbCBiZSB1c2VkIGFzIGRlZmF1bHQuXG4gICAgICogPC9wcmU+XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSBob3BzY290Y2guY29uZmlndXJlKHsgc2Nyb2xsRHVyYXRpb246IDEwMDAsIHNjcm9sbFRvcE1hcmdpbjogMTUwIH0pO1xuICAgICAqIEBleGFtcGxlXG4gICAgICogaG9wc2NvdGNoLmNvbmZpZ3VyZSh7XG4gICAgICogICBzY3JvbGxUb3BNYXJnaW46IDE1MCxcbiAgICAgKiAgIG9uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAqICAgICBhbGVydChcIkhhdmUgZnVuIVwiKTtcbiAgICAgKiAgIH0sXG4gICAgICogICBpMThuOiB7XG4gICAgICogICAgIG5leHRCdG46ICdGb3J3YXJkJyxcbiAgICAgKiAgICAgcHJldkJ0bjogJ1ByZXZpb3VzJ1xuICAgICAqICAgICBjbG9zZVRvb2x0aXA6ICdRdWl0J1xuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQSBoYXNoIG9mIGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBIb3BzY290Y2hcbiAgICAgKi9cbiAgICB0aGlzLmNvbmZpZ3VyZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICByZXR1cm4gX2NvbmZpZ3VyZS5jYWxsKHRoaXMsIG9wdGlvbnMsIGZhbHNlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB0ZW1wbGF0ZSB0aGF0IHNob3VsZCBiZSB1c2VkIGZvciByZW5kZXJpbmcgSG9wc2NvdGNoIGJ1YmJsZXMuXG4gICAgICogSWYgYSBzdHJpbmcsIGl0J3MgYXNzdW1lZCB5b3VyIHRlbXBsYXRlIGlzIGF2YWlsYWJsZSBpbiB0aGVcbiAgICAgKiBob3BzY290Y2gudGVtcGxhdGVzIG5hbWVzcGFjZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9uKG9iail9IFRoZSB0ZW1wbGF0ZSB0byB1c2UgZm9yIHJlbmRlcmluZy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgSG9wc2NvdGNoIG9iamVjdCAoZm9yIGNoYWluaW5nKS5cbiAgICAgKi9cbiAgICB0aGlzLnNldFJlbmRlcmVyID0gZnVuY3Rpb24gKHJlbmRlcikge1xuICAgICAgdmFyIHR5cGVPZlJlbmRlciA9IHR5cGVvZiByZW5kZXIgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHJlbmRlcik7XG5cbiAgICAgIGlmICh0eXBlT2ZSZW5kZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRlbXBsYXRlVG9Vc2UgPSByZW5kZXI7XG4gICAgICAgIGN1c3RvbVJlbmRlcmVyID0gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIGlmICh0eXBlT2ZSZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY3VzdG9tUmVuZGVyZXIgPSByZW5kZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZXNjYXBpbmcgbWV0aG9kIHRvIGJlIHVzZWQgYnkgSlNUIHRlbXBsYXRlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IC0gVGhlIGVzY2FwZSBtZXRob2QgdG8gdXNlLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBIb3BzY290Y2ggb2JqZWN0IChmb3IgY2hhaW5pbmcpLlxuICAgICAqL1xuICAgIHRoaXMuc2V0RXNjYXBlciA9IGZ1bmN0aW9uIChlc2MpIHtcbiAgICAgIGlmICh0eXBlb2YgZXNjID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGN1c3RvbUVzY2FwZSA9IGVzYztcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBpbml0LmNhbGwodGhpcywgaW5pdE9wdGlvbnMpO1xuICB9O1xuXG4gIHdpbkhvcHNjb3RjaCA9IG5ldyBIb3BzY290Y2goKTtcblxuICAvLyBUZW1wbGF0ZSBpbmNsdWRlcywgcGxhY2VkIGluc2lkZSBhIGNsb3N1cmUgdG8gZW5zdXJlIHdlIGRvbid0XG4gIC8vIGVuZCB1cCBkZWNsYXJpbmcgb3VyIHNoaW0gZ2xvYmFsbHkuXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF8gPSB7fTtcbi8qXG4gKiBBZGFwdGVkIGZyb20gdGhlIFVuZGVyc2NvcmUuanMgZnJhbWV3b3JrLiBDaGVjayBpdCBvdXQgYXRcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9qYXNoa2VuYXMvdW5kZXJzY29yZVxuICovXG5fLmVzY2FwZSA9IGZ1bmN0aW9uKHN0cil7XG4gIGlmKGN1c3RvbUVzY2FwZSl7IHJldHVybiBjdXN0b21Fc2NhcGUoc3RyKTsgfVxuICBcbiAgaWYoc3RyID09IG51bGwpIHJldHVybiAnJztcbiAgcmV0dXJuICgnJyArIHN0cikucmVwbGFjZShuZXcgUmVnRXhwKCdbJjw+XCJcXCddJywgJ2cnKSwgZnVuY3Rpb24obWF0Y2gpe1xuICAgIGlmKG1hdGNoID09ICcmJyl7IHJldHVybiAnJmFtcDsnIH1cbiAgICBpZihtYXRjaCA9PSAnPCcpeyByZXR1cm4gJyZsdDsnIH1cbiAgICBpZihtYXRjaCA9PSAnPicpeyByZXR1cm4gJyZndDsnIH1cbiAgICBpZihtYXRjaCA9PSAnXCInKXsgcmV0dXJuICcmcXVvdDsnIH1cbiAgICBpZihtYXRjaCA9PSBcIidcIil7IHJldHVybiAnJiN4Mjc7JyB9XG4gIH0pO1xufVxuXG4gICAgdGhpc1tcInRlbXBsYXRlc1wiXSA9IHRoaXNbXCJ0ZW1wbGF0ZXNcIl0gfHwge307XG5cbnRoaXNbXCJ0ZW1wbGF0ZXNcIl1bXCJidWJibGVfZGVmYXVsdFwiXSA9IGZ1bmN0aW9uKGRhdGEpIHtcbnZhciBfX3QsIF9fcCA9ICcnLCBfX2UgPSBfLmVzY2FwZSwgX19qID0gQXJyYXkucHJvdG90eXBlLmpvaW47XG5mdW5jdGlvbiBwcmludCgpIHsgX19wICs9IF9fai5jYWxsKGFyZ3VtZW50cywgJycpIH1cblxuXG4gIGZ1bmN0aW9uIG9wdEVzY2FwZShzdHIsIHVuc2FmZSl7XG4gICAgaWYodW5zYWZlKXtcbiAgICAgIHJldHVybiBfLmVzY2FwZShzdHIpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xuICB9XG47XG5fX3AgKz0gJ1xcbic7XG5cbnZhciBpMThuID0gZGF0YS5pMThuO1xudmFyIGJ1dHRvbnMgPSBkYXRhLmJ1dHRvbnM7XG52YXIgc3RlcCA9IGRhdGEuc3RlcDtcbnZhciB0b3VyID0gZGF0YS50b3VyO1xuO1xuX19wICs9ICdcXG48ZGl2IGNsYXNzPVwiaG9wc2NvdGNoLWJ1YmJsZS1jb250YWluZXJcIiBzdHlsZT1cIndpZHRoOiAnICtcbigoX190ID0gKCBzdGVwLndpZHRoICkpID09IG51bGwgPyAnJyA6IF9fdCkgK1xuJ3B4OyBwYWRkaW5nOiAnICtcbigoX190ID0gKCBzdGVwLnBhZGRpbmcgKSkgPT0gbnVsbCA/ICcnIDogX190KSArXG4ncHg7XCI+XFxuICAnO1xuIGlmKHRvdXIuaXNUb3VyKXsgO1xuX19wICs9ICc8c3BhbiBjbGFzcz1cImhvcHNjb3RjaC1idWJibGUtbnVtYmVyXCI+JyArXG4oKF9fdCA9ICggaTE4bi5zdGVwTnVtICkpID09IG51bGwgPyAnJyA6IF9fdCkgK1xuJzwvc3Bhbj4nO1xuIH0gO1xuX19wICs9ICdcXG4gIDxkaXYgY2xhc3M9XCJob3BzY290Y2gtYnViYmxlLWNvbnRlbnRcIj5cXG4gICAgJztcbiBpZihzdGVwLnRpdGxlICE9PSAnJyl7IDtcbl9fcCArPSAnPGgzIGNsYXNzPVwiaG9wc2NvdGNoLXRpdGxlXCI+JyArXG4oKF9fdCA9ICggb3B0RXNjYXBlKHN0ZXAudGl0bGUsIHRvdXIudW5zYWZlKSApKSA9PSBudWxsID8gJycgOiBfX3QpICtcbic8L2gzPic7XG4gfSA7XG5fX3AgKz0gJ1xcbiAgICAnO1xuIGlmKHN0ZXAuY29udGVudCAgIT09ICcnKXsgO1xuX19wICs9ICc8ZGl2IGNsYXNzPVwiaG9wc2NvdGNoLWNvbnRlbnRcIj4nICtcbigoX190ID0gKCBvcHRFc2NhcGUoc3RlcC5jb250ZW50LCB0b3VyLnVuc2FmZSkgKSkgPT0gbnVsbCA/ICcnIDogX190KSArXG4nPC9kaXY+JztcbiB9IDtcbl9fcCArPSAnXFxuICA8L2Rpdj5cXG4gIDxkaXYgY2xhc3M9XCJob3BzY290Y2gtYWN0aW9uc1wiPlxcbiAgICAnO1xuIGlmKGJ1dHRvbnMuc2hvd1ByZXYpeyA7XG5fX3AgKz0gJzxidXR0b24gY2xhc3M9XCJob3BzY290Y2gtbmF2LWJ1dHRvbiBwcmV2IGhvcHNjb3RjaC1wcmV2XCI+JyArXG4oKF9fdCA9ICggaTE4bi5wcmV2QnRuICkpID09IG51bGwgPyAnJyA6IF9fdCkgK1xuJzwvYnV0dG9uPic7XG4gfSA7XG5fX3AgKz0gJ1xcbiAgICAnO1xuIGlmKGJ1dHRvbnMuc2hvd0NUQSl7IDtcbl9fcCArPSAnPGJ1dHRvbiBjbGFzcz1cImhvcHNjb3RjaC1uYXYtYnV0dG9uIG5leHQgaG9wc2NvdGNoLWN0YVwiPicgK1xuKChfX3QgPSAoIGJ1dHRvbnMuY3RhTGFiZWwgKSkgPT0gbnVsbCA/ICcnIDogX190KSArXG4nPC9idXR0b24+JztcbiB9IDtcbl9fcCArPSAnXFxuICAgICc7XG4gaWYoYnV0dG9ucy5zaG93TmV4dCl7IDtcbl9fcCArPSAnPGJ1dHRvbiBjbGFzcz1cImhvcHNjb3RjaC1uYXYtYnV0dG9uIG5leHQgaG9wc2NvdGNoLW5leHRcIj4nICtcbigoX190ID0gKCBpMThuLm5leHRCdG4gKSkgPT0gbnVsbCA/ICcnIDogX190KSArXG4nPC9idXR0b24+JztcbiB9IDtcbl9fcCArPSAnXFxuICA8L2Rpdj5cXG4gICc7XG4gaWYoYnV0dG9ucy5zaG93Q2xvc2UpeyA7XG5fX3AgKz0gJzxidXR0b24gY2xhc3M9XCJob3BzY290Y2gtYnViYmxlLWNsb3NlIGhvcHNjb3RjaC1jbG9zZVwiPicgK1xuKChfX3QgPSAoIGkxOG4uY2xvc2VUb29sdGlwICkpID09IG51bGwgPyAnJyA6IF9fdCkgK1xuJzwvYnV0dG9uPic7XG4gfSA7XG5fX3AgKz0gJ1xcbjwvZGl2PlxcbjxkaXYgY2xhc3M9XCJob3BzY290Y2gtYnViYmxlLWFycm93LWNvbnRhaW5lciBob3BzY290Y2gtYXJyb3dcIj5cXG4gIDxkaXYgY2xhc3M9XCJob3BzY290Y2gtYnViYmxlLWFycm93LWJvcmRlclwiPjwvZGl2PlxcbiAgPGRpdiBjbGFzcz1cImhvcHNjb3RjaC1idWJibGUtYXJyb3dcIj48L2Rpdj5cXG48L2Rpdj5cXG4nO1xucmV0dXJuIF9fcFxufTtcbiAgfSkuY2FsbCh3aW5Ib3BzY290Y2gpO1xuXG4gIHZhciB3aW5Ib3BzY290Y2gkMSA9IHdpbkhvcHNjb3RjaDtcblxuICByZXR1cm4gd2luSG9wc2NvdGNoJDE7XG5cbn0pKSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9hc3NldHMvcGtncy9ob3BzY290Y2gvZGlzdC9qcy9ob3BzY290Y2guanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///13\n")},function(module,exports){eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2Nlc3MvYnJvd3Nlci5qcz84MmU0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVUiLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Byb2Nlc3MvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///14\n")},function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    "use strict";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== "function") {\n        callback = new Function("" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."\n        // So if we\'re currently running a task, we\'ll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // "too much recursion" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can\'t be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage("", "*");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = "setImmediate$" + Math.random() + "$";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === "string" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener("message", onGlobalMessage, false);\n        } else {\n            global.attachEvent("onmessage", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, "*");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it\'s been called.\n            var script = doc.createElement("script");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don\'t get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === "[object process]") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && "onreadystatechange" in doc.createElement("script")) {\n        // For IE 6–8\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4), __webpack_require__(14)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanM/NGE4MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMsc0JBQXNCLEVBQUU7QUFDbEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiMTUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgdW5kZWZpbmVkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZiAoZ2xvYmFsLnNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5leHRIYW5kbGUgPSAxOyAvLyBTcGVjIHNheXMgZ3JlYXRlciB0aGFuIHplcm9cbiAgICB2YXIgdGFza3NCeUhhbmRsZSA9IHt9O1xuICAgIHZhciBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICB2YXIgZG9jID0gZ2xvYmFsLmRvY3VtZW50O1xuICAgIHZhciByZWdpc3RlckltbWVkaWF0ZTtcblxuICAgIGZ1bmN0aW9uIHNldEltbWVkaWF0ZShjYWxsYmFjaykge1xuICAgICAgLy8gQ2FsbGJhY2sgY2FuIGVpdGhlciBiZSBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBuZXcgRnVuY3Rpb24oXCJcIiArIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIC8vIENvcHkgZnVuY3Rpb24gYXJndW1lbnRzXG4gICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2kgKyAxXTtcbiAgICAgIH1cbiAgICAgIC8vIFN0b3JlIGFuZCByZWdpc3RlciB0aGUgdGFza1xuICAgICAgdmFyIHRhc2sgPSB7IGNhbGxiYWNrOiBjYWxsYmFjaywgYXJnczogYXJncyB9O1xuICAgICAgdGFza3NCeUhhbmRsZVtuZXh0SGFuZGxlXSA9IHRhc2s7XG4gICAgICByZWdpc3RlckltbWVkaWF0ZShuZXh0SGFuZGxlKTtcbiAgICAgIHJldHVybiBuZXh0SGFuZGxlKys7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaGFuZGxlKSB7XG4gICAgICAgIGRlbGV0ZSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuKHRhc2spIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gdGFzay5jYWxsYmFjaztcbiAgICAgICAgdmFyIGFyZ3MgPSB0YXNrLmFyZ3M7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuSWZQcmVzZW50KGhhbmRsZSkge1xuICAgICAgICAvLyBGcm9tIHRoZSBzcGVjOiBcIldhaXQgdW50aWwgYW55IGludm9jYXRpb25zIG9mIHRoaXMgYWxnb3JpdGhtIHN0YXJ0ZWQgYmVmb3JlIHRoaXMgb25lIGhhdmUgY29tcGxldGVkLlwiXG4gICAgICAgIC8vIFNvIGlmIHdlJ3JlIGN1cnJlbnRseSBydW5uaW5nIGEgdGFzaywgd2UnbGwgbmVlZCB0byBkZWxheSB0aGlzIGludm9jYXRpb24uXG4gICAgICAgIGlmIChjdXJyZW50bHlSdW5uaW5nQVRhc2spIHtcbiAgICAgICAgICAgIC8vIERlbGF5IGJ5IGRvaW5nIGEgc2V0VGltZW91dC4gc2V0SW1tZWRpYXRlIHdhcyB0cmllZCBpbnN0ZWFkLCBidXQgaW4gRmlyZWZveCA3IGl0IGdlbmVyYXRlZCBhXG4gICAgICAgICAgICAvLyBcInRvbyBtdWNoIHJlY3Vyc2lvblwiIGVycm9yLlxuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGFzayA9IHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICAgICAgICAgIGlmICh0YXNrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBydW4odGFzayk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbW1lZGlhdGUoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHsgcnVuSWZQcmVzZW50KGhhbmRsZSk7IH0pO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhblVzZVBvc3RNZXNzYWdlKCkge1xuICAgICAgICAvLyBUaGUgdGVzdCBhZ2FpbnN0IGBpbXBvcnRTY3JpcHRzYCBwcmV2ZW50cyB0aGlzIGltcGxlbWVudGF0aW9uIGZyb20gYmVpbmcgaW5zdGFsbGVkIGluc2lkZSBhIHdlYiB3b3JrZXIsXG4gICAgICAgIC8vIHdoZXJlIGBnbG9iYWwucG9zdE1lc3NhZ2VgIG1lYW5zIHNvbWV0aGluZyBjb21wbGV0ZWx5IGRpZmZlcmVudCBhbmQgY2FuJ3QgYmUgdXNlZCBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgICBpZiAoZ2xvYmFsLnBvc3RNZXNzYWdlICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cykge1xuICAgICAgICAgICAgdmFyIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG9sZE9uTWVzc2FnZSA9IGdsb2JhbC5vbm1lc3NhZ2U7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShcIlwiLCBcIipcIik7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gb2xkT25NZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgLy8gSW5zdGFsbHMgYW4gZXZlbnQgaGFuZGxlciBvbiBgZ2xvYmFsYCBmb3IgdGhlIGBtZXNzYWdlYCBldmVudDogc2VlXG4gICAgICAgIC8vICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vRE9NL3dpbmRvdy5wb3N0TWVzc2FnZVxuICAgICAgICAvLyAqIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL2NvbW1zLmh0bWwjY3Jvc3NEb2N1bWVudE1lc3NhZ2VzXG5cbiAgICAgICAgdmFyIG1lc3NhZ2VQcmVmaXggPSBcInNldEltbWVkaWF0ZSRcIiArIE1hdGgucmFuZG9tKCkgKyBcIiRcIjtcbiAgICAgICAgdmFyIG9uR2xvYmFsTWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlID09PSBnbG9iYWwgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZXZlbnQuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEuaW5kZXhPZihtZXNzYWdlUHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudCgrZXZlbnQuZGF0YS5zbGljZShtZXNzYWdlUHJlZml4Lmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFsLmF0dGFjaEV2ZW50KFwib25tZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKG1lc3NhZ2VQcmVmaXggKyBoYW5kbGUsIFwiKlwiKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZShoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBodG1sID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIDxzY3JpcHQ+IGVsZW1lbnQ7IGl0cyByZWFkeXN0YXRlY2hhbmdlIGV2ZW50IHdpbGwgYmUgZmlyZWQgYXN5bmNocm9ub3VzbHkgb25jZSBpdCBpcyBpbnNlcnRlZFxuICAgICAgICAgICAgLy8gaW50byB0aGUgZG9jdW1lbnQuIERvIHNvLCB0aHVzIHF1ZXVpbmcgdXAgdGhlIHRhc2suIFJlbWVtYmVyIHRvIGNsZWFuIHVwIG9uY2UgaXQncyBiZWVuIGNhbGxlZC5cbiAgICAgICAgICAgIHZhciBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaHRtbC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgICAgIHNjcmlwdCA9IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaHRtbC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBJZiBzdXBwb3J0ZWQsIHdlIHNob3VsZCBhdHRhY2ggdG8gdGhlIHByb3RvdHlwZSBvZiBnbG9iYWwsIHNpbmNlIHRoYXQgaXMgd2hlcmUgc2V0VGltZW91dCBldCBhbC4gbGl2ZS5cbiAgICB2YXIgYXR0YWNoVG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGdsb2JhbCk7XG4gICAgYXR0YWNoVG8gPSBhdHRhY2hUbyAmJiBhdHRhY2hUby5zZXRUaW1lb3V0ID8gYXR0YWNoVG8gOiBnbG9iYWw7XG5cbiAgICAvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IGUuZy4gYnJvd3NlcmlmeSBlbnZpcm9ubWVudHMuXG4gICAgaWYgKHt9LnRvU3RyaW5nLmNhbGwoZ2xvYmFsLnByb2Nlc3MpID09PSBcIltvYmplY3QgcHJvY2Vzc11cIikge1xuICAgICAgICAvLyBGb3IgTm9kZS5qcyBiZWZvcmUgMC45XG4gICAgICAgIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGNhblVzZVBvc3RNZXNzYWdlKCkpIHtcbiAgICAgICAgLy8gRm9yIG5vbi1JRTEwIG1vZGVybiBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChnbG9iYWwuTWVzc2FnZUNoYW5uZWwpIHtcbiAgICAgICAgLy8gRm9yIHdlYiB3b3JrZXJzLCB3aGVyZSBzdXBwb3J0ZWRcbiAgICAgICAgaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZG9jICYmIFwib25yZWFkeXN0YXRlY2hhbmdlXCIgaW4gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIikpIHtcbiAgICAgICAgLy8gRm9yIElFIDbigJM4XG4gICAgICAgIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBvbGRlciBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCk7XG4gICAgfVxuXG4gICAgYXR0YWNoVG8uc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlO1xuICAgIGF0dGFjaFRvLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG59KHR5cGVvZiBzZWxmID09PSBcInVuZGVmaW5lZFwiID8gdHlwZW9mIGdsb2JhbCA9PT0gXCJ1bmRlZmluZWRcIiA/IHRoaXMgOiBnbG9iYWwgOiBzZWxmKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///15\n')},function(module,exports,__webpack_require__){eval("var apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(15);\nexports.setImmediate = setImmediate;\nexports.clearImmediate = clearImmediate;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3RpbWVycy1icm93c2VyaWZ5L21haW4uanM/YjA4OCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjE2LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkge1xuICBpZiAodGltZW91dCkge1xuICAgIHRpbWVvdXQuY2xvc2UoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbCh3aW5kb3csIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBzZXRpbW1lZGlhdGUgYXR0YWNoZXMgaXRzZWxmIHRvIHRoZSBnbG9iYWwgb2JqZWN0XG5yZXF1aXJlKFwic2V0aW1tZWRpYXRlXCIpO1xuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qc1xuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///16\n")}]);