!function(Q){function I(B){if(F[B])return F[B].exports;var C=F[B]={i:B,l:!1,exports:{}};return Q[B].call(C.exports,C,C.exports,I),C.l=!0,C.exports}var F={};I.m=Q,I.c=F,I.i=function(Q){return Q},I.d=function(Q,F,B){I.o(Q,F)||Object.defineProperty(Q,F,{configurable:!1,enumerable:!0,get:B})},I.n=function(Q){var F=Q&&Q.__esModule?function(){return Q.default}:function(){return Q};return I.d(F,"a",F),F},I.o=function(Q,I){return Object.prototype.hasOwnProperty.call(Q,I)},I.p="",I(I.s=28)}([function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(setImmediate, global) {;(function() {\n"use strict"\nfunction Vnode(tag, key, attrs0, children, text, dom) {\n\treturn {tag: tag, key: key, attrs: attrs0, children: children, text: text, dom: dom, domSize: undefined, state: undefined, _state: undefined, events: undefined, instance: undefined, skip: false}\n}\nVnode.normalize = function(node) {\n\tif (Array.isArray(node)) return Vnode("[", undefined, undefined, Vnode.normalizeChildren(node), undefined, undefined)\n\tif (node != null && typeof node !== "object") return Vnode("#", undefined, undefined, node === false ? "" : node, undefined, undefined)\n\treturn node\n}\nVnode.normalizeChildren = function normalizeChildren(children) {\n\tfor (var i = 0; i < children.length; i++) {\n\t\tchildren[i] = Vnode.normalize(children[i])\n\t}\n\treturn children\n}\nvar selectorParser = /(?:(^|#|\\.)([^#\\.\\[\\]]+))|(\\[(.+?)(?:\\s*=\\s*("|\'|)((?:\\\\["\'\\]]|.)*?)\\5)?\\])/g\nvar selectorCache = {}\nvar hasOwn = {}.hasOwnProperty\nfunction compileSelector(selector) {\n\tvar match, tag = "div", classes = [], attrs = {}\n\twhile (match = selectorParser.exec(selector)) {\n\t\tvar type = match[1], value = match[2]\n\t\tif (type === "" && value !== "") tag = value\n\t\telse if (type === "#") attrs.id = value\n\t\telse if (type === ".") classes.push(value)\n\t\telse if (match[3][0] === "[") {\n\t\t\tvar attrValue = match[6]\n\t\t\tif (attrValue) attrValue = attrValue.replace(/\\\\(["\'])/g, "$1").replace(/\\\\\\\\/g, "\\\\")\n\t\t\tif (match[4] === "class") classes.push(attrValue)\n\t\t\telse attrs[match[4]] = attrValue === "" ? attrValue : attrValue || true\n\t\t}\n\t}\n\tif (classes.length > 0) attrs.className = classes.join(" ")\n\treturn selectorCache[selector] = {tag: tag, attrs: attrs}\n}\nfunction execSelector(state, attrs, children) {\n\tvar hasAttrs = false, childList, text\n\tvar className = attrs.className || attrs.class\n\tfor (var key in state.attrs) {\n\t\tif (hasOwn.call(state.attrs, key)) {\n\t\t\tattrs[key] = state.attrs[key]\n\t\t}\n\t}\n\tif (className !== undefined) {\n\t\tif (attrs.class !== undefined) {\n\t\t\tattrs.class = undefined\n\t\t\tattrs.className = className\n\t\t}\n\t\tif (state.attrs.className != null) {\n\t\t\tattrs.className = state.attrs.className + " " + className\n\t\t}\n\t}\n\tfor (var key in attrs) {\n\t\tif (hasOwn.call(attrs, key) && key !== "key") {\n\t\t\thasAttrs = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif (Array.isArray(children) && children.length === 1 && children[0] != null && children[0].tag === "#") {\n\t\ttext = children[0].children\n\t} else {\n\t\tchildList = children\n\t}\n\treturn Vnode(state.tag, attrs.key, hasAttrs ? attrs : undefined, childList, text)\n}\nfunction hyperscript(selector) {\n\t// Because sloppy mode sucks\n\tvar attrs = arguments[1], start = 2, children\n\tif (selector == null || typeof selector !== "string" && typeof selector !== "function" && typeof selector.view !== "function") {\n\t\tthrow Error("The selector must be either a string or a component.");\n\t}\n\tif (typeof selector === "string") {\n\t\tvar cached = selectorCache[selector] || compileSelector(selector)\n\t}\n\tif (attrs == null) {\n\t\tattrs = {}\n\t} else if (typeof attrs !== "object" || attrs.tag != null || Array.isArray(attrs)) {\n\t\tattrs = {}\n\t\tstart = 1\n\t}\n\tif (arguments.length === start + 1) {\n\t\tchildren = arguments[start]\n\t\tif (!Array.isArray(children)) children = [children]\n\t} else {\n\t\tchildren = []\n\t\twhile (start < arguments.length) children.push(arguments[start++])\n\t}\n\tvar normalized = Vnode.normalizeChildren(children)\n\tif (typeof selector === "string") {\n\t\treturn execSelector(cached, attrs, normalized)\n\t} else {\n\t\treturn Vnode(selector, attrs.key, attrs, normalized)\n\t}\n}\nhyperscript.trust = function(html) {\n\tif (html == null) html = ""\n\treturn Vnode("<", undefined, undefined, html, undefined, undefined)\n}\nhyperscript.fragment = function(attrs1, children) {\n\treturn Vnode("[", attrs1.key, attrs1, Vnode.normalizeChildren(children), undefined, undefined)\n}\nvar m = hyperscript\n/** @constructor */\nvar PromisePolyfill = function(executor) {\n\tif (!(this instanceof PromisePolyfill)) throw new Error("Promise must be called with `new`")\n\tif (typeof executor !== "function") throw new TypeError("executor must be a function")\n\tvar self = this, resolvers = [], rejectors = [], resolveCurrent = handler(resolvers, true), rejectCurrent = handler(rejectors, false)\n\tvar instance = self._instance = {resolvers: resolvers, rejectors: rejectors}\n\tvar callAsync = typeof setImmediate === "function" ? setImmediate : setTimeout\n\tfunction handler(list, shouldAbsorb) {\n\t\treturn function execute(value) {\n\t\t\tvar then\n\t\t\ttry {\n\t\t\t\tif (shouldAbsorb && value != null && (typeof value === "object" || typeof value === "function") && typeof (then = value.then) === "function") {\n\t\t\t\t\tif (value === self) throw new TypeError("Promise can\'t be resolved w/ itself")\n\t\t\t\t\texecuteOnce(then.bind(value))\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcallAsync(function() {\n\t\t\t\t\t\tif (!shouldAbsorb && list.length === 0) console.error("Possible unhandled promise rejection:", value)\n\t\t\t\t\t\tfor (var i = 0; i < list.length; i++) list[i](value)\n\t\t\t\t\t\tresolvers.length = 0, rejectors.length = 0\n\t\t\t\t\t\tinstance.state = shouldAbsorb\n\t\t\t\t\t\tinstance.retry = function() {execute(value)}\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (e) {\n\t\t\t\trejectCurrent(e)\n\t\t\t}\n\t\t}\n\t}\n\tfunction executeOnce(then) {\n\t\tvar runs = 0\n\t\tfunction run(fn) {\n\t\t\treturn function(value) {\n\t\t\t\tif (runs++ > 0) return\n\t\t\t\tfn(value)\n\t\t\t}\n\t\t}\n\t\tvar onerror = run(rejectCurrent)\n\t\ttry {then(run(resolveCurrent), onerror)} catch (e) {onerror(e)}\n\t}\n\texecuteOnce(executor)\n}\nPromisePolyfill.prototype.then = function(onFulfilled, onRejection) {\n\tvar self = this, instance = self._instance\n\tfunction handle(callback, list, next, state) {\n\t\tlist.push(function(value) {\n\t\t\tif (typeof callback !== "function") next(value)\n\t\t\telse try {resolveNext(callback(value))} catch (e) {if (rejectNext) rejectNext(e)}\n\t\t})\n\t\tif (typeof instance.retry === "function" && state === instance.state) instance.retry()\n\t}\n\tvar resolveNext, rejectNext\n\tvar promise = new PromisePolyfill(function(resolve, reject) {resolveNext = resolve, rejectNext = reject})\n\thandle(onFulfilled, instance.resolvers, resolveNext, true), handle(onRejection, instance.rejectors, rejectNext, false)\n\treturn promise\n}\nPromisePolyfill.prototype.catch = function(onRejection) {\n\treturn this.then(null, onRejection)\n}\nPromisePolyfill.resolve = function(value) {\n\tif (value instanceof PromisePolyfill) return value\n\treturn new PromisePolyfill(function(resolve) {resolve(value)})\n}\nPromisePolyfill.reject = function(value) {\n\treturn new PromisePolyfill(function(resolve, reject) {reject(value)})\n}\nPromisePolyfill.all = function(list) {\n\treturn new PromisePolyfill(function(resolve, reject) {\n\t\tvar total = list.length, count = 0, values = []\n\t\tif (list.length === 0) resolve([])\n\t\telse for (var i = 0; i < list.length; i++) {\n\t\t\t(function(i) {\n\t\t\t\tfunction consume(value) {\n\t\t\t\t\tcount++\n\t\t\t\t\tvalues[i] = value\n\t\t\t\t\tif (count === total) resolve(values)\n\t\t\t\t}\n\t\t\t\tif (list[i] != null && (typeof list[i] === "object" || typeof list[i] === "function") && typeof list[i].then === "function") {\n\t\t\t\t\tlist[i].then(consume, reject)\n\t\t\t\t}\n\t\t\t\telse consume(list[i])\n\t\t\t})(i)\n\t\t}\n\t})\n}\nPromisePolyfill.race = function(list) {\n\treturn new PromisePolyfill(function(resolve, reject) {\n\t\tfor (var i = 0; i < list.length; i++) {\n\t\t\tlist[i].then(resolve, reject)\n\t\t}\n\t})\n}\nif (typeof window !== "undefined") {\n\tif (typeof window.Promise === "undefined") window.Promise = PromisePolyfill\n\tvar PromisePolyfill = window.Promise\n} else if (typeof global !== "undefined") {\n\tif (typeof global.Promise === "undefined") global.Promise = PromisePolyfill\n\tvar PromisePolyfill = global.Promise\n} else {\n}\nvar buildQueryString = function(object) {\n\tif (Object.prototype.toString.call(object) !== "[object Object]") return ""\n\tvar args = []\n\tfor (var key0 in object) {\n\t\tdestructure(key0, object[key0])\n\t}\n\treturn args.join("&")\n\tfunction destructure(key0, value) {\n\t\tif (Array.isArray(value)) {\n\t\t\tfor (var i = 0; i < value.length; i++) {\n\t\t\t\tdestructure(key0 + "[" + i + "]", value[i])\n\t\t\t}\n\t\t}\n\t\telse if (Object.prototype.toString.call(value) === "[object Object]") {\n\t\t\tfor (var i in value) {\n\t\t\t\tdestructure(key0 + "[" + i + "]", value[i])\n\t\t\t}\n\t\t}\n\t\telse args.push(encodeURIComponent(key0) + (value != null && value !== "" ? "=" + encodeURIComponent(value) : ""))\n\t}\n}\nvar FILE_PROTOCOL_REGEX = new RegExp("^file://", "i")\nvar _8 = function($window, Promise) {\n\tvar callbackCount = 0\n\tvar oncompletion\n\tfunction setCompletionCallback(callback) {oncompletion = callback}\n\tfunction finalizer() {\n\t\tvar count = 0\n\t\tfunction complete() {if (--count === 0 && typeof oncompletion === "function") oncompletion()}\n\t\treturn function finalize(promise0) {\n\t\t\tvar then0 = promise0.then\n\t\t\tpromise0.then = function() {\n\t\t\t\tcount++\n\t\t\t\tvar next = then0.apply(promise0, arguments)\n\t\t\t\tnext.then(complete, function(e) {\n\t\t\t\t\tcomplete()\n\t\t\t\t\tif (count === 0) throw e\n\t\t\t\t})\n\t\t\t\treturn finalize(next)\n\t\t\t}\n\t\t\treturn promise0\n\t\t}\n\t}\n\tfunction normalize(args, extra) {\n\t\tif (typeof args === "string") {\n\t\t\tvar url = args\n\t\t\targs = extra || {}\n\t\t\tif (args.url == null) args.url = url\n\t\t}\n\t\treturn args\n\t}\n\tfunction request(args, extra) {\n\t\tvar finalize = finalizer()\n\t\targs = normalize(args, extra)\n\t\tvar promise0 = new Promise(function(resolve, reject) {\n\t\t\tif (args.method == null) args.method = "GET"\n\t\t\targs.method = args.method.toUpperCase()\n\t\t\tvar useBody = (args.method === "GET" || args.method === "TRACE") ? false : (typeof args.useBody === "boolean" ? args.useBody : true)\n\t\t\tif (typeof args.serialize !== "function") args.serialize = typeof FormData !== "undefined" && args.data instanceof FormData ? function(value) {return value} : JSON.stringify\n\t\t\tif (typeof args.deserialize !== "function") args.deserialize = deserialize\n\t\t\tif (typeof args.extract !== "function") args.extract = extract\n\t\t\targs.url = interpolate(args.url, args.data)\n\t\t\tif (useBody) args.data = args.serialize(args.data)\n\t\t\telse args.url = assemble(args.url, args.data)\n\t\t\tvar xhr = new $window.XMLHttpRequest(),\n\t\t\t\taborted = false,\n\t\t\t\t_abort = xhr.abort\n\t\t\txhr.abort = function abort() {\n\t\t\t\taborted = true\n\t\t\t\t_abort.call(xhr)\n\t\t\t}\n\t\t\txhr.open(args.method, args.url, typeof args.async === "boolean" ? args.async : true, typeof args.user === "string" ? args.user : undefined, typeof args.password === "string" ? args.password : undefined)\n\t\t\tif (args.serialize === JSON.stringify && useBody) {\n\t\t\t\txhr.setRequestHeader("Content-Type", "application/json; charset=utf-8")\n\t\t\t}\n\t\t\tif (args.deserialize === deserialize) {\n\t\t\t\txhr.setRequestHeader("Accept", "application/json, text/*")\n\t\t\t}\n\t\t\tif (args.withCredentials) xhr.withCredentials = args.withCredentials\n\t\t\tfor (var key in args.headers) if ({}.hasOwnProperty.call(args.headers, key)) {\n\t\t\t\txhr.setRequestHeader(key, args.headers[key])\n\t\t\t}\n\t\t\tif (typeof args.config === "function") xhr = args.config(xhr, args) || xhr\n\t\t\txhr.onreadystatechange = function() {\n\t\t\t\t// Don\'t throw errors on xhr.abort().\n\t\t\t\tif(aborted) return\n\t\t\t\tif (xhr.readyState === 4) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvar response = (args.extract !== extract) ? args.extract(xhr, args) : args.deserialize(args.extract(xhr, args))\n\t\t\t\t\t\tif ((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304 || FILE_PROTOCOL_REGEX.test(args.url)) {\n\t\t\t\t\t\t\tresolve(cast(args.type, response))\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tvar error = new Error(xhr.responseText)\n\t\t\t\t\t\t\tfor (var key in response) error[key] = response[key]\n\t\t\t\t\t\t\treject(error)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (e) {\n\t\t\t\t\t\treject(e)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (useBody && (args.data != null)) xhr.send(args.data)\n\t\t\telse xhr.send()\n\t\t})\n\t\treturn args.background === true ? promise0 : finalize(promise0)\n\t}\n\tfunction jsonp(args, extra) {\n\t\tvar finalize = finalizer()\n\t\targs = normalize(args, extra)\n\t\tvar promise0 = new Promise(function(resolve, reject) {\n\t\t\tvar callbackName = args.callbackName || "_mithril_" + Math.round(Math.random() * 1e16) + "_" + callbackCount++\n\t\t\tvar script = $window.document.createElement("script")\n\t\t\t$window[callbackName] = function(data) {\n\t\t\t\tscript.parentNode.removeChild(script)\n\t\t\t\tresolve(cast(args.type, data))\n\t\t\t\tdelete $window[callbackName]\n\t\t\t}\n\t\t\tscript.onerror = function() {\n\t\t\t\tscript.parentNode.removeChild(script)\n\t\t\t\treject(new Error("JSONP request failed"))\n\t\t\t\tdelete $window[callbackName]\n\t\t\t}\n\t\t\tif (args.data == null) args.data = {}\n\t\t\targs.url = interpolate(args.url, args.data)\n\t\t\targs.data[args.callbackKey || "callback"] = callbackName\n\t\t\tscript.src = assemble(args.url, args.data)\n\t\t\t$window.document.documentElement.appendChild(script)\n\t\t})\n\t\treturn args.background === true? promise0 : finalize(promise0)\n\t}\n\tfunction interpolate(url, data) {\n\t\tif (data == null) return url\n\t\tvar tokens = url.match(/:[^\\/]+/gi) || []\n\t\tfor (var i = 0; i < tokens.length; i++) {\n\t\t\tvar key = tokens[i].slice(1)\n\t\t\tif (data[key] != null) {\n\t\t\t\turl = url.replace(tokens[i], data[key])\n\t\t\t}\n\t\t}\n\t\treturn url\n\t}\n\tfunction assemble(url, data) {\n\t\tvar querystring = buildQueryString(data)\n\t\tif (querystring !== "") {\n\t\t\tvar prefix = url.indexOf("?") < 0 ? "?" : "&"\n\t\t\turl += prefix + querystring\n\t\t}\n\t\treturn url\n\t}\n\tfunction deserialize(data) {\n\t\ttry {return data !== "" ? JSON.parse(data) : null}\n\t\tcatch (e) {throw new Error(data)}\n\t}\n\tfunction extract(xhr) {return xhr.responseText}\n\tfunction cast(type0, data) {\n\t\tif (typeof type0 === "function") {\n\t\t\tif (Array.isArray(data)) {\n\t\t\t\tfor (var i = 0; i < data.length; i++) {\n\t\t\t\t\tdata[i] = new type0(data[i])\n\t\t\t\t}\n\t\t\t}\n\t\t\telse return new type0(data)\n\t\t}\n\t\treturn data\n\t}\n\treturn {request: request, jsonp: jsonp, setCompletionCallback: setCompletionCallback}\n}\nvar requestService = _8(window, PromisePolyfill)\nvar coreRenderer = function($window) {\n\tvar $doc = $window.document\n\tvar $emptyFragment = $doc.createDocumentFragment()\n\tvar nameSpace = {\n\t\tsvg: "http://www.w3.org/2000/svg",\n\t\tmath: "http://www.w3.org/1998/Math/MathML"\n\t}\n\tvar onevent\n\tfunction setEventCallback(callback) {return onevent = callback}\n\tfunction getNameSpace(vnode) {\n\t\treturn vnode.attrs && vnode.attrs.xmlns || nameSpace[vnode.tag]\n\t}\n\t//create\n\tfunction createNodes(parent, vnodes, start, end, hooks, nextSibling, ns) {\n\t\tfor (var i = start; i < end; i++) {\n\t\t\tvar vnode = vnodes[i]\n\t\t\tif (vnode != null) {\n\t\t\t\tcreateNode(parent, vnode, hooks, ns, nextSibling)\n\t\t\t}\n\t\t}\n\t}\n\tfunction createNode(parent, vnode, hooks, ns, nextSibling) {\n\t\tvar tag = vnode.tag\n\t\tif (typeof tag === "string") {\n\t\t\tvnode.state = {}\n\t\t\tif (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks)\n\t\t\tswitch (tag) {\n\t\t\t\tcase "#": return createText(parent, vnode, nextSibling)\n\t\t\t\tcase "<": return createHTML(parent, vnode, nextSibling)\n\t\t\t\tcase "[": return createFragment(parent, vnode, hooks, ns, nextSibling)\n\t\t\t\tdefault: return createElement(parent, vnode, hooks, ns, nextSibling)\n\t\t\t}\n\t\t}\n\t\telse return createComponent(parent, vnode, hooks, ns, nextSibling)\n\t}\n\tfunction createText(parent, vnode, nextSibling) {\n\t\tvnode.dom = $doc.createTextNode(vnode.children)\n\t\tinsertNode(parent, vnode.dom, nextSibling)\n\t\treturn vnode.dom\n\t}\n\tfunction createHTML(parent, vnode, nextSibling) {\n\t\tvar match1 = vnode.children.match(/^\\s*?<(\\w+)/im) || []\n\t\tvar parent1 = {caption: "table", thead: "table", tbody: "table", tfoot: "table", tr: "tbody", th: "tr", td: "tr", colgroup: "table", col: "colgroup"}[match1[1]] || "div"\n\t\tvar temp = $doc.createElement(parent1)\n\t\ttemp.innerHTML = vnode.children\n\t\tvnode.dom = temp.firstChild\n\t\tvnode.domSize = temp.childNodes.length\n\t\tvar fragment = $doc.createDocumentFragment()\n\t\tvar child\n\t\twhile (child = temp.firstChild) {\n\t\t\tfragment.appendChild(child)\n\t\t}\n\t\tinsertNode(parent, fragment, nextSibling)\n\t\treturn fragment\n\t}\n\tfunction createFragment(parent, vnode, hooks, ns, nextSibling) {\n\t\tvar fragment = $doc.createDocumentFragment()\n\t\tif (vnode.children != null) {\n\t\t\tvar children = vnode.children\n\t\t\tcreateNodes(fragment, children, 0, children.length, hooks, null, ns)\n\t\t}\n\t\tvnode.dom = fragment.firstChild\n\t\tvnode.domSize = fragment.childNodes.length\n\t\tinsertNode(parent, fragment, nextSibling)\n\t\treturn fragment\n\t}\n\tfunction createElement(parent, vnode, hooks, ns, nextSibling) {\n\t\tvar tag = vnode.tag\n\t\tvar attrs2 = vnode.attrs\n\t\tvar is = attrs2 && attrs2.is\n\t\tns = getNameSpace(vnode) || ns\n\t\tvar element = ns ?\n\t\t\tis ? $doc.createElementNS(ns, tag, {is: is}) : $doc.createElementNS(ns, tag) :\n\t\t\tis ? $doc.createElement(tag, {is: is}) : $doc.createElement(tag)\n\t\tvnode.dom = element\n\t\tif (attrs2 != null) {\n\t\t\tsetAttrs(vnode, attrs2, ns)\n\t\t}\n\t\tinsertNode(parent, element, nextSibling)\n\t\tif (vnode.attrs != null && vnode.attrs.contenteditable != null) {\n\t\t\tsetContentEditable(vnode)\n\t\t}\n\t\telse {\n\t\t\tif (vnode.text != null) {\n\t\t\t\tif (vnode.text !== "") element.textContent = vnode.text\n\t\t\t\telse vnode.children = [Vnode("#", undefined, undefined, vnode.text, undefined, undefined)]\n\t\t\t}\n\t\t\tif (vnode.children != null) {\n\t\t\t\tvar children = vnode.children\n\t\t\t\tcreateNodes(element, children, 0, children.length, hooks, null, ns)\n\t\t\t\tsetLateAttrs(vnode)\n\t\t\t}\n\t\t}\n\t\treturn element\n\t}\n\tfunction initComponent(vnode, hooks) {\n\t\tvar sentinel\n\t\tif (typeof vnode.tag.view === "function") {\n\t\t\tvnode.state = Object.create(vnode.tag)\n\t\t\tsentinel = vnode.state.view\n\t\t\tif (sentinel.$$reentrantLock$$ != null) return $emptyFragment\n\t\t\tsentinel.$$reentrantLock$$ = true\n\t\t} else {\n\t\t\tvnode.state = void 0\n\t\t\tsentinel = vnode.tag\n\t\t\tif (sentinel.$$reentrantLock$$ != null) return $emptyFragment\n\t\t\tsentinel.$$reentrantLock$$ = true\n\t\t\tvnode.state = (vnode.tag.prototype != null && typeof vnode.tag.prototype.view === "function") ? new vnode.tag(vnode) : vnode.tag(vnode)\n\t\t}\n\t\tvnode._state = vnode.state\n\t\tif (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks)\n\t\tinitLifecycle(vnode._state, vnode, hooks)\n\t\tvnode.instance = Vnode.normalize(vnode._state.view.call(vnode.state, vnode))\n\t\tif (vnode.instance === vnode) throw Error("A view cannot return the vnode it received as argument")\n\t\tsentinel.$$reentrantLock$$ = null\n\t}\n\tfunction createComponent(parent, vnode, hooks, ns, nextSibling) {\n\t\tinitComponent(vnode, hooks)\n\t\tif (vnode.instance != null) {\n\t\t\tvar element = createNode(parent, vnode.instance, hooks, ns, nextSibling)\n\t\t\tvnode.dom = vnode.instance.dom\n\t\t\tvnode.domSize = vnode.dom != null ? vnode.instance.domSize : 0\n\t\t\tinsertNode(parent, element, nextSibling)\n\t\t\treturn element\n\t\t}\n\t\telse {\n\t\t\tvnode.domSize = 0\n\t\t\treturn $emptyFragment\n\t\t}\n\t}\n\t//update\n\tfunction updateNodes(parent, old, vnodes, recycling, hooks, nextSibling, ns) {\n\t\tif (old === vnodes || old == null && vnodes == null) return\n\t\telse if (old == null) createNodes(parent, vnodes, 0, vnodes.length, hooks, nextSibling, ns)\n\t\telse if (vnodes == null) removeNodes(old, 0, old.length, vnodes)\n\t\telse {\n\t\t\tif (old.length === vnodes.length) {\n\t\t\t\tvar isUnkeyed = false\n\t\t\t\tfor (var i = 0; i < vnodes.length; i++) {\n\t\t\t\t\tif (vnodes[i] != null && old[i] != null) {\n\t\t\t\t\t\tisUnkeyed = vnodes[i].key == null && old[i].key == null\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (isUnkeyed) {\n\t\t\t\t\tfor (var i = 0; i < old.length; i++) {\n\t\t\t\t\t\tif (old[i] === vnodes[i]) continue\n\t\t\t\t\t\telse if (old[i] == null && vnodes[i] != null) createNode(parent, vnodes[i], hooks, ns, getNextSibling(old, i + 1, nextSibling))\n\t\t\t\t\t\telse if (vnodes[i] == null) removeNodes(old, i, i + 1, vnodes)\n\t\t\t\t\t\telse updateNode(parent, old[i], vnodes[i], hooks, getNextSibling(old, i + 1, nextSibling), recycling, ns)\n\t\t\t\t\t}\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\trecycling = recycling || isRecyclable(old, vnodes)\n\t\t\tif (recycling) {\n\t\t\t\tvar pool = old.pool\n\t\t\t\told = old.concat(old.pool)\n\t\t\t}\n\t\t\tvar oldStart = 0, start = 0, oldEnd = old.length - 1, end = vnodes.length - 1, map\n\t\t\twhile (oldEnd >= oldStart && end >= start) {\n\t\t\t\tvar o = old[oldStart], v = vnodes[start]\n\t\t\t\tif (o === v && !recycling) oldStart++, start++\n\t\t\t\telse if (o == null) oldStart++\n\t\t\t\telse if (v == null) start++\n\t\t\t\telse if (o.key === v.key) {\n\t\t\t\t\tvar shouldRecycle = (pool != null && oldStart >= old.length - pool.length) || ((pool == null) && recycling)\n\t\t\t\t\toldStart++, start++\n\t\t\t\t\tupdateNode(parent, o, v, hooks, getNextSibling(old, oldStart, nextSibling), shouldRecycle, ns)\n\t\t\t\t\tif (recycling && o.tag === v.tag) insertNode(parent, toFragment(o), nextSibling)\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tvar o = old[oldEnd]\n\t\t\t\t\tif (o === v && !recycling) oldEnd--, start++\n\t\t\t\t\telse if (o == null) oldEnd--\n\t\t\t\t\telse if (v == null) start++\n\t\t\t\t\telse if (o.key === v.key) {\n\t\t\t\t\t\tvar shouldRecycle = (pool != null && oldEnd >= old.length - pool.length) || ((pool == null) && recycling)\n\t\t\t\t\t\tupdateNode(parent, o, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), shouldRecycle, ns)\n\t\t\t\t\t\tif (recycling || start < end) insertNode(parent, toFragment(o), getNextSibling(old, oldStart, nextSibling))\n\t\t\t\t\t\toldEnd--, start++\n\t\t\t\t\t}\n\t\t\t\t\telse break\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (oldEnd >= oldStart && end >= start) {\n\t\t\t\tvar o = old[oldEnd], v = vnodes[end]\n\t\t\t\tif (o === v && !recycling) oldEnd--, end--\n\t\t\t\telse if (o == null) oldEnd--\n\t\t\t\telse if (v == null) end--\n\t\t\t\telse if (o.key === v.key) {\n\t\t\t\t\tvar shouldRecycle = (pool != null && oldEnd >= old.length - pool.length) || ((pool == null) && recycling)\n\t\t\t\t\tupdateNode(parent, o, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), shouldRecycle, ns)\n\t\t\t\t\tif (recycling && o.tag === v.tag) insertNode(parent, toFragment(o), nextSibling)\n\t\t\t\t\tif (o.dom != null) nextSibling = o.dom\n\t\t\t\t\toldEnd--, end--\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (!map) map = getKeyMap(old, oldEnd)\n\t\t\t\t\tif (v != null) {\n\t\t\t\t\t\tvar oldIndex = map[v.key]\n\t\t\t\t\t\tif (oldIndex != null) {\n\t\t\t\t\t\t\tvar movable = old[oldIndex]\n\t\t\t\t\t\t\tvar shouldRecycle = (pool != null && oldIndex >= old.length - pool.length) || ((pool == null) && recycling)\n\t\t\t\t\t\t\tupdateNode(parent, movable, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), recycling, ns)\n\t\t\t\t\t\t\tinsertNode(parent, toFragment(movable), nextSibling)\n\t\t\t\t\t\t\told[oldIndex].skip = true\n\t\t\t\t\t\t\tif (movable.dom != null) nextSibling = movable.dom\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tvar dom = createNode(parent, v, hooks, ns, nextSibling)\n\t\t\t\t\t\t\tnextSibling = dom\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tend--\n\t\t\t\t}\n\t\t\t\tif (end < start) break\n\t\t\t}\n\t\t\tcreateNodes(parent, vnodes, start, end + 1, hooks, nextSibling, ns)\n\t\t\tremoveNodes(old, oldStart, oldEnd + 1, vnodes)\n\t\t}\n\t}\n\tfunction updateNode(parent, old, vnode, hooks, nextSibling, recycling, ns) {\n\t\tvar oldTag = old.tag, tag = vnode.tag\n\t\tif (oldTag === tag) {\n\t\t\tvnode.state = old.state\n\t\t\tvnode._state = old._state\n\t\t\tvnode.events = old.events\n\t\t\tif (!recycling && shouldNotUpdate(vnode, old)) return\n\t\t\tif (typeof oldTag === "string") {\n\t\t\t\tif (vnode.attrs != null) {\n\t\t\t\t\tif (recycling) {\n\t\t\t\t\t\tvnode.state = {}\n\t\t\t\t\t\tinitLifecycle(vnode.attrs, vnode, hooks)\n\t\t\t\t\t}\n\t\t\t\t\telse updateLifecycle(vnode.attrs, vnode, hooks)\n\t\t\t\t}\n\t\t\t\tswitch (oldTag) {\n\t\t\t\t\tcase "#": updateText(old, vnode); break\n\t\t\t\t\tcase "<": updateHTML(parent, old, vnode, nextSibling); break\n\t\t\t\t\tcase "[": updateFragment(parent, old, vnode, recycling, hooks, nextSibling, ns); break\n\t\t\t\t\tdefault: updateElement(old, vnode, recycling, hooks, ns)\n\t\t\t\t}\n\t\t\t}\n\t\t\telse updateComponent(parent, old, vnode, hooks, nextSibling, recycling, ns)\n\t\t}\n\t\telse {\n\t\t\tremoveNode(old, null)\n\t\t\tcreateNode(parent, vnode, hooks, ns, nextSibling)\n\t\t}\n\t}\n\tfunction updateText(old, vnode) {\n\t\tif (old.children.toString() !== vnode.children.toString()) {\n\t\t\told.dom.nodeValue = vnode.children\n\t\t}\n\t\tvnode.dom = old.dom\n\t}\n\tfunction updateHTML(parent, old, vnode, nextSibling) {\n\t\tif (old.children !== vnode.children) {\n\t\t\ttoFragment(old)\n\t\t\tcreateHTML(parent, vnode, nextSibling)\n\t\t}\n\t\telse vnode.dom = old.dom, vnode.domSize = old.domSize\n\t}\n\tfunction updateFragment(parent, old, vnode, recycling, hooks, nextSibling, ns) {\n\t\tupdateNodes(parent, old.children, vnode.children, recycling, hooks, nextSibling, ns)\n\t\tvar domSize = 0, children = vnode.children\n\t\tvnode.dom = null\n\t\tif (children != null) {\n\t\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\t\tvar child = children[i]\n\t\t\t\tif (child != null && child.dom != null) {\n\t\t\t\t\tif (vnode.dom == null) vnode.dom = child.dom\n\t\t\t\t\tdomSize += child.domSize || 1\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (domSize !== 1) vnode.domSize = domSize\n\t\t}\n\t}\n\tfunction updateElement(old, vnode, recycling, hooks, ns) {\n\t\tvar element = vnode.dom = old.dom\n\t\tns = getNameSpace(vnode) || ns\n\t\tif (vnode.tag === "textarea") {\n\t\t\tif (vnode.attrs == null) vnode.attrs = {}\n\t\t\tif (vnode.text != null) {\n\t\t\t\tvnode.attrs.value = vnode.text //FIXME handle0 multiple children\n\t\t\t\tvnode.text = undefined\n\t\t\t}\n\t\t}\n\t\tupdateAttrs(vnode, old.attrs, vnode.attrs, ns)\n\t\tif (vnode.attrs != null && vnode.attrs.contenteditable != null) {\n\t\t\tsetContentEditable(vnode)\n\t\t}\n\t\telse if (old.text != null && vnode.text != null && vnode.text !== "") {\n\t\t\tif (old.text.toString() !== vnode.text.toString()) old.dom.firstChild.nodeValue = vnode.text\n\t\t}\n\t\telse {\n\t\t\tif (old.text != null) old.children = [Vnode("#", undefined, undefined, old.text, undefined, old.dom.firstChild)]\n\t\t\tif (vnode.text != null) vnode.children = [Vnode("#", undefined, undefined, vnode.text, undefined, undefined)]\n\t\t\tupdateNodes(element, old.children, vnode.children, recycling, hooks, null, ns)\n\t\t}\n\t}\n\tfunction updateComponent(parent, old, vnode, hooks, nextSibling, recycling, ns) {\n\t\tif (recycling) {\n\t\t\tinitComponent(vnode, hooks)\n\t\t} else {\n\t\t\tvnode.instance = Vnode.normalize(vnode._state.view.call(vnode.state, vnode))\n\t\t\tif (vnode.instance === vnode) throw Error("A view cannot return the vnode it received as argument")\n\t\t\tif (vnode.attrs != null) updateLifecycle(vnode.attrs, vnode, hooks)\n\t\t\tupdateLifecycle(vnode._state, vnode, hooks)\n\t\t}\n\t\tif (vnode.instance != null) {\n\t\t\tif (old.instance == null) createNode(parent, vnode.instance, hooks, ns, nextSibling)\n\t\t\telse updateNode(parent, old.instance, vnode.instance, hooks, nextSibling, recycling, ns)\n\t\t\tvnode.dom = vnode.instance.dom\n\t\t\tvnode.domSize = vnode.instance.domSize\n\t\t}\n\t\telse if (old.instance != null) {\n\t\t\tremoveNode(old.instance, null)\n\t\t\tvnode.dom = undefined\n\t\t\tvnode.domSize = 0\n\t\t}\n\t\telse {\n\t\t\tvnode.dom = old.dom\n\t\t\tvnode.domSize = old.domSize\n\t\t}\n\t}\n\tfunction isRecyclable(old, vnodes) {\n\t\tif (old.pool != null && Math.abs(old.pool.length - vnodes.length) <= Math.abs(old.length - vnodes.length)) {\n\t\t\tvar oldChildrenLength = old[0] && old[0].children && old[0].children.length || 0\n\t\t\tvar poolChildrenLength = old.pool[0] && old.pool[0].children && old.pool[0].children.length || 0\n\t\t\tvar vnodesChildrenLength = vnodes[0] && vnodes[0].children && vnodes[0].children.length || 0\n\t\t\tif (Math.abs(poolChildrenLength - vnodesChildrenLength) <= Math.abs(oldChildrenLength - vnodesChildrenLength)) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\tfunction getKeyMap(vnodes, end) {\n\t\tvar map = {}, i = 0\n\t\tfor (var i = 0; i < end; i++) {\n\t\t\tvar vnode = vnodes[i]\n\t\t\tif (vnode != null) {\n\t\t\t\tvar key2 = vnode.key\n\t\t\t\tif (key2 != null) map[key2] = i\n\t\t\t}\n\t\t}\n\t\treturn map\n\t}\n\tfunction toFragment(vnode) {\n\t\tvar count0 = vnode.domSize\n\t\tif (count0 != null || vnode.dom == null) {\n\t\t\tvar fragment = $doc.createDocumentFragment()\n\t\t\tif (count0 > 0) {\n\t\t\t\tvar dom = vnode.dom\n\t\t\t\twhile (--count0) fragment.appendChild(dom.nextSibling)\n\t\t\t\tfragment.insertBefore(dom, fragment.firstChild)\n\t\t\t}\n\t\t\treturn fragment\n\t\t}\n\t\telse return vnode.dom\n\t}\n\tfunction getNextSibling(vnodes, i, nextSibling) {\n\t\tfor (; i < vnodes.length; i++) {\n\t\t\tif (vnodes[i] != null && vnodes[i].dom != null) return vnodes[i].dom\n\t\t}\n\t\treturn nextSibling\n\t}\n\tfunction insertNode(parent, dom, nextSibling) {\n\t\tif (nextSibling && nextSibling.parentNode) parent.insertBefore(dom, nextSibling)\n\t\telse parent.appendChild(dom)\n\t}\n\tfunction setContentEditable(vnode) {\n\t\tvar children = vnode.children\n\t\tif (children != null && children.length === 1 && children[0].tag === "<") {\n\t\t\tvar content = children[0].children\n\t\t\tif (vnode.dom.innerHTML !== content) vnode.dom.innerHTML = content\n\t\t}\n\t\telse if (vnode.text != null || children != null && children.length !== 0) throw new Error("Child node of a contenteditable must be trusted")\n\t}\n\t//remove\n\tfunction removeNodes(vnodes, start, end, context) {\n\t\tfor (var i = start; i < end; i++) {\n\t\t\tvar vnode = vnodes[i]\n\t\t\tif (vnode != null) {\n\t\t\t\tif (vnode.skip) vnode.skip = false\n\t\t\t\telse removeNode(vnode, context)\n\t\t\t}\n\t\t}\n\t}\n\tfunction removeNode(vnode, context) {\n\t\tvar expected = 1, called = 0\n\t\tif (vnode.attrs && typeof vnode.attrs.onbeforeremove === "function") {\n\t\t\tvar result = vnode.attrs.onbeforeremove.call(vnode.state, vnode)\n\t\t\tif (result != null && typeof result.then === "function") {\n\t\t\t\texpected++\n\t\t\t\tresult.then(continuation, continuation)\n\t\t\t}\n\t\t}\n\t\tif (typeof vnode.tag !== "string" && typeof vnode._state.onbeforeremove === "function") {\n\t\t\tvar result = vnode._state.onbeforeremove.call(vnode.state, vnode)\n\t\t\tif (result != null && typeof result.then === "function") {\n\t\t\t\texpected++\n\t\t\t\tresult.then(continuation, continuation)\n\t\t\t}\n\t\t}\n\t\tcontinuation()\n\t\tfunction continuation() {\n\t\t\tif (++called === expected) {\n\t\t\t\tonremove(vnode)\n\t\t\t\tif (vnode.dom) {\n\t\t\t\t\tvar count0 = vnode.domSize || 1\n\t\t\t\t\tif (count0 > 1) {\n\t\t\t\t\t\tvar dom = vnode.dom\n\t\t\t\t\t\twhile (--count0) {\n\t\t\t\t\t\t\tremoveNodeFromDOM(dom.nextSibling)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tremoveNodeFromDOM(vnode.dom)\n\t\t\t\t\tif (context != null && vnode.domSize == null && !hasIntegrationMethods(vnode.attrs) && typeof vnode.tag === "string") { //TODO test custom elements\n\t\t\t\t\t\tif (!context.pool) context.pool = [vnode]\n\t\t\t\t\t\telse context.pool.push(vnode)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfunction removeNodeFromDOM(node) {\n\t\tvar parent = node.parentNode\n\t\tif (parent != null) parent.removeChild(node)\n\t}\n\tfunction onremove(vnode) {\n\t\tif (vnode.attrs && typeof vnode.attrs.onremove === "function") vnode.attrs.onremove.call(vnode.state, vnode)\n\t\tif (typeof vnode.tag !== "string" && typeof vnode._state.onremove === "function") vnode._state.onremove.call(vnode.state, vnode)\n\t\tif (vnode.instance != null) onremove(vnode.instance)\n\t\telse {\n\t\t\tvar children = vnode.children\n\t\t\tif (Array.isArray(children)) {\n\t\t\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\t\t\tvar child = children[i]\n\t\t\t\t\tif (child != null) onremove(child)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//attrs2\n\tfunction setAttrs(vnode, attrs2, ns) {\n\t\tfor (var key2 in attrs2) {\n\t\t\tsetAttr(vnode, key2, null, attrs2[key2], ns)\n\t\t}\n\t}\n\tfunction setAttr(vnode, key2, old, value, ns) {\n\t\tvar element = vnode.dom\n\t\tif (key2 === "key" || key2 === "is" || (old === value && !isFormAttribute(vnode, key2)) && typeof value !== "object" || typeof value === "undefined" || isLifecycleMethod(key2)) return\n\t\tvar nsLastIndex = key2.indexOf(":")\n\t\tif (nsLastIndex > -1 && key2.substr(0, nsLastIndex) === "xlink") {\n\t\t\telement.setAttributeNS("http://www.w3.org/1999/xlink", key2.slice(nsLastIndex + 1), value)\n\t\t}\n\t\telse if (key2[0] === "o" && key2[1] === "n" && typeof value === "function") updateEvent(vnode, key2, value)\n\t\telse if (key2 === "style") updateStyle(element, old, value)\n\t\telse if (key2 in element && !isAttribute(key2) && ns === undefined && !isCustomElement(vnode)) {\n\t\t\tif (key2 === "value") {\n\t\t\t\tvar normalized0 = "" + value // eslint-disable-line no-implicit-coercion\n\t\t\t\t//setting input[value] to same value by typing on focused element moves cursor to end in Chrome\n\t\t\t\tif ((vnode.tag === "input" || vnode.tag === "textarea") && vnode.dom.value === normalized0 && vnode.dom === $doc.activeElement) return\n\t\t\t\t//setting select[value] to same value while having select open blinks select dropdown in Chrome\n\t\t\t\tif (vnode.tag === "select") {\n\t\t\t\t\tif (value === null) {\n\t\t\t\t\t\tif (vnode.dom.selectedIndex === -1 && vnode.dom === $doc.activeElement) return\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (old !== null && vnode.dom.value === normalized0 && vnode.dom === $doc.activeElement) return\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//setting option[value] to same value while having select open blinks select dropdown in Chrome\n\t\t\t\tif (vnode.tag === "option" && old != null && vnode.dom.value === normalized0) return\n\t\t\t}\n\t\t\t// If you assign an input type1 that is not supported by IE 11 with an assignment expression, an error0 will occur.\n\t\t\tif (vnode.tag === "input" && key2 === "type") {\n\t\t\t\telement.setAttribute(key2, value)\n\t\t\t\treturn\n\t\t\t}\n\t\t\telement[key2] = value\n\t\t}\n\t\telse {\n\t\t\tif (typeof value === "boolean") {\n\t\t\t\tif (value) element.setAttribute(key2, "")\n\t\t\t\telse element.removeAttribute(key2)\n\t\t\t}\n\t\t\telse element.setAttribute(key2 === "className" ? "class" : key2, value)\n\t\t}\n\t}\n\tfunction setLateAttrs(vnode) {\n\t\tvar attrs2 = vnode.attrs\n\t\tif (vnode.tag === "select" && attrs2 != null) {\n\t\t\tif ("value" in attrs2) setAttr(vnode, "value", null, attrs2.value, undefined)\n\t\t\tif ("selectedIndex" in attrs2) setAttr(vnode, "selectedIndex", null, attrs2.selectedIndex, undefined)\n\t\t}\n\t}\n\tfunction updateAttrs(vnode, old, attrs2, ns) {\n\t\tif (attrs2 != null) {\n\t\t\tfor (var key2 in attrs2) {\n\t\t\t\tsetAttr(vnode, key2, old && old[key2], attrs2[key2], ns)\n\t\t\t}\n\t\t}\n\t\tif (old != null) {\n\t\t\tfor (var key2 in old) {\n\t\t\t\tif (attrs2 == null || !(key2 in attrs2)) {\n\t\t\t\t\tif (key2 === "className") key2 = "class"\n\t\t\t\t\tif (key2[0] === "o" && key2[1] === "n" && !isLifecycleMethod(key2)) updateEvent(vnode, key2, undefined)\n\t\t\t\t\telse if (key2 !== "key") vnode.dom.removeAttribute(key2)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfunction isFormAttribute(vnode, attr) {\n\t\treturn attr === "value" || attr === "checked" || attr === "selectedIndex" || attr === "selected" && vnode.dom === $doc.activeElement\n\t}\n\tfunction isLifecycleMethod(attr) {\n\t\treturn attr === "oninit" || attr === "oncreate" || attr === "onupdate" || attr === "onremove" || attr === "onbeforeremove" || attr === "onbeforeupdate"\n\t}\n\tfunction isAttribute(attr) {\n\t\treturn attr === "href" || attr === "list" || attr === "form" || attr === "width" || attr === "height"// || attr === "type"\n\t}\n\tfunction isCustomElement(vnode){\n\t\treturn vnode.attrs.is || vnode.tag.indexOf("-") > -1\n\t}\n\tfunction hasIntegrationMethods(source) {\n\t\treturn source != null && (source.oncreate || source.onupdate || source.onbeforeremove || source.onremove)\n\t}\n\t//style\n\tfunction updateStyle(element, old, style) {\n\t\tif (old === style) element.style.cssText = "", old = null\n\t\tif (style == null) element.style.cssText = ""\n\t\telse if (typeof style === "string") element.style.cssText = style\n\t\telse {\n\t\t\tif (typeof old === "string") element.style.cssText = ""\n\t\t\tfor (var key2 in style) {\n\t\t\t\telement.style[key2] = style[key2]\n\t\t\t}\n\t\t\tif (old != null && typeof old !== "string") {\n\t\t\t\tfor (var key2 in old) {\n\t\t\t\t\tif (!(key2 in style)) element.style[key2] = ""\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//event\n\tfunction updateEvent(vnode, key2, value) {\n\t\tvar element = vnode.dom\n\t\tvar callback = typeof onevent !== "function" ? value : function(e) {\n\t\t\tvar result = value.call(element, e)\n\t\t\tonevent.call(element, e)\n\t\t\treturn result\n\t\t}\n\t\tif (key2 in element) element[key2] = typeof value === "function" ? callback : null\n\t\telse {\n\t\t\tvar eventName = key2.slice(2)\n\t\t\tif (vnode.events === undefined) vnode.events = {}\n\t\t\tif (vnode.events[key2] === callback) return\n\t\t\tif (vnode.events[key2] != null) element.removeEventListener(eventName, vnode.events[key2], false)\n\t\t\tif (typeof value === "function") {\n\t\t\t\tvnode.events[key2] = callback\n\t\t\t\telement.addEventListener(eventName, vnode.events[key2], false)\n\t\t\t}\n\t\t}\n\t}\n\t//lifecycle\n\tfunction initLifecycle(source, vnode, hooks) {\n\t\tif (typeof source.oninit === "function") source.oninit.call(vnode.state, vnode)\n\t\tif (typeof source.oncreate === "function") hooks.push(source.oncreate.bind(vnode.state, vnode))\n\t}\n\tfunction updateLifecycle(source, vnode, hooks) {\n\t\tif (typeof source.onupdate === "function") hooks.push(source.onupdate.bind(vnode.state, vnode))\n\t}\n\tfunction shouldNotUpdate(vnode, old) {\n\t\tvar forceVnodeUpdate, forceComponentUpdate\n\t\tif (vnode.attrs != null && typeof vnode.attrs.onbeforeupdate === "function") forceVnodeUpdate = vnode.attrs.onbeforeupdate.call(vnode.state, vnode, old)\n\t\tif (typeof vnode.tag !== "string" && typeof vnode._state.onbeforeupdate === "function") forceComponentUpdate = vnode._state.onbeforeupdate.call(vnode.state, vnode, old)\n\t\tif (!(forceVnodeUpdate === undefined && forceComponentUpdate === undefined) && !forceVnodeUpdate && !forceComponentUpdate) {\n\t\t\tvnode.dom = old.dom\n\t\t\tvnode.domSize = old.domSize\n\t\t\tvnode.instance = old.instance\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\tfunction render(dom, vnodes) {\n\t\tif (!dom) throw new Error("Ensure the DOM element being passed to m.route/m.mount/m.render is not undefined.")\n\t\tvar hooks = []\n\t\tvar active = $doc.activeElement\n\t\tvar namespace = dom.namespaceURI\n\t\t// First time0 rendering into a node clears it out\n\t\tif (dom.vnodes == null) dom.textContent = ""\n\t\tif (!Array.isArray(vnodes)) vnodes = [vnodes]\n\t\tupdateNodes(dom, dom.vnodes, Vnode.normalizeChildren(vnodes), false, hooks, null, namespace === "http://www.w3.org/1999/xhtml" ? undefined : namespace)\n\t\tdom.vnodes = vnodes\n\t\tfor (var i = 0; i < hooks.length; i++) hooks[i]()\n\t\tif ($doc.activeElement !== active) active.focus()\n\t}\n\treturn {render: render, setEventCallback: setEventCallback}\n}\nfunction throttle(callback) {\n\t//60fps translates to 16.6ms, round it down since setTimeout requires int\n\tvar time = 16\n\tvar last = 0, pending = null\n\tvar timeout = typeof requestAnimationFrame === "function" ? requestAnimationFrame : setTimeout\n\treturn function() {\n\t\tvar now = Date.now()\n\t\tif (last === 0 || now - last >= time) {\n\t\t\tlast = now\n\t\t\tcallback()\n\t\t}\n\t\telse if (pending === null) {\n\t\t\tpending = timeout(function() {\n\t\t\t\tpending = null\n\t\t\t\tcallback()\n\t\t\t\tlast = Date.now()\n\t\t\t}, time - (now - last))\n\t\t}\n\t}\n}\nvar _11 = function($window) {\n\tvar renderService = coreRenderer($window)\n\trenderService.setEventCallback(function(e) {\n\t\tif (e.redraw === false) e.redraw = undefined\n\t\telse redraw()\n\t})\n\tvar callbacks = []\n\tfunction subscribe(key1, callback) {\n\t\tunsubscribe(key1)\n\t\tcallbacks.push(key1, throttle(callback))\n\t}\n\tfunction unsubscribe(key1) {\n\t\tvar index = callbacks.indexOf(key1)\n\t\tif (index > -1) callbacks.splice(index, 2)\n\t}\n\tfunction redraw() {\n\t\tfor (var i = 1; i < callbacks.length; i += 2) {\n\t\t\tcallbacks[i]()\n\t\t}\n\t}\n\treturn {subscribe: subscribe, unsubscribe: unsubscribe, redraw: redraw, render: renderService.render}\n}\nvar redrawService = _11(window)\nrequestService.setCompletionCallback(redrawService.redraw)\nvar _16 = function(redrawService0) {\n\treturn function(root, component) {\n\t\tif (component === null) {\n\t\t\tredrawService0.render(root, [])\n\t\t\tredrawService0.unsubscribe(root)\n\t\t\treturn\n\t\t}\n\t\t\n\t\tif (component.view == null && typeof component !== "function") throw new Error("m.mount(element, component) expects a component, not a vnode")\n\t\t\n\t\tvar run0 = function() {\n\t\t\tredrawService0.render(root, Vnode(component))\n\t\t}\n\t\tredrawService0.subscribe(root, run0)\n\t\tredrawService0.redraw()\n\t}\n}\nm.mount = _16(redrawService)\nvar Promise = PromisePolyfill\nvar parseQueryString = function(string) {\n\tif (string === "" || string == null) return {}\n\tif (string.charAt(0) === "?") string = string.slice(1)\n\tvar entries = string.split("&"), data0 = {}, counters = {}\n\tfor (var i = 0; i < entries.length; i++) {\n\t\tvar entry = entries[i].split("=")\n\t\tvar key5 = decodeURIComponent(entry[0])\n\t\tvar value = entry.length === 2 ? decodeURIComponent(entry[1]) : ""\n\t\tif (value === "true") value = true\n\t\telse if (value === "false") value = false\n\t\tvar levels = key5.split(/\\]\\[?|\\[/)\n\t\tvar cursor = data0\n\t\tif (key5.indexOf("[") > -1) levels.pop()\n\t\tfor (var j = 0; j < levels.length; j++) {\n\t\t\tvar level = levels[j], nextLevel = levels[j + 1]\n\t\t\tvar isNumber = nextLevel == "" || !isNaN(parseInt(nextLevel, 10))\n\t\t\tvar isValue = j === levels.length - 1\n\t\t\tif (level === "") {\n\t\t\t\tvar key5 = levels.slice(0, j).join()\n\t\t\t\tif (counters[key5] == null) counters[key5] = 0\n\t\t\t\tlevel = counters[key5]++\n\t\t\t}\n\t\t\tif (cursor[level] == null) {\n\t\t\t\tcursor[level] = isValue ? value : isNumber ? [] : {}\n\t\t\t}\n\t\t\tcursor = cursor[level]\n\t\t}\n\t}\n\treturn data0\n}\nvar coreRouter = function($window) {\n\tvar supportsPushState = typeof $window.history.pushState === "function"\n\tvar callAsync0 = typeof setImmediate === "function" ? setImmediate : setTimeout\n\tfunction normalize1(fragment0) {\n\t\tvar data = $window.location[fragment0].replace(/(?:%[a-f89][a-f0-9])+/gim, decodeURIComponent)\n\t\tif (fragment0 === "pathname" && data[0] !== "/") data = "/" + data\n\t\treturn data\n\t}\n\tvar asyncId\n\tfunction debounceAsync(callback0) {\n\t\treturn function() {\n\t\t\tif (asyncId != null) return\n\t\t\tasyncId = callAsync0(function() {\n\t\t\t\tasyncId = null\n\t\t\t\tcallback0()\n\t\t\t})\n\t\t}\n\t}\n\tfunction parsePath(path, queryData, hashData) {\n\t\tvar queryIndex = path.indexOf("?")\n\t\tvar hashIndex = path.indexOf("#")\n\t\tvar pathEnd = queryIndex > -1 ? queryIndex : hashIndex > -1 ? hashIndex : path.length\n\t\tif (queryIndex > -1) {\n\t\t\tvar queryEnd = hashIndex > -1 ? hashIndex : path.length\n\t\t\tvar queryParams = parseQueryString(path.slice(queryIndex + 1, queryEnd))\n\t\t\tfor (var key4 in queryParams) queryData[key4] = queryParams[key4]\n\t\t}\n\t\tif (hashIndex > -1) {\n\t\t\tvar hashParams = parseQueryString(path.slice(hashIndex + 1))\n\t\t\tfor (var key4 in hashParams) hashData[key4] = hashParams[key4]\n\t\t}\n\t\treturn path.slice(0, pathEnd)\n\t}\n\tvar router = {prefix: "#!"}\n\trouter.getPath = function() {\n\t\tvar type2 = router.prefix.charAt(0)\n\t\tswitch (type2) {\n\t\t\tcase "#": return normalize1("hash").slice(router.prefix.length)\n\t\t\tcase "?": return normalize1("search").slice(router.prefix.length) + normalize1("hash")\n\t\t\tdefault: return normalize1("pathname").slice(router.prefix.length) + normalize1("search") + normalize1("hash")\n\t\t}\n\t}\n\trouter.setPath = function(path, data, options) {\n\t\tvar queryData = {}, hashData = {}\n\t\tpath = parsePath(path, queryData, hashData)\n\t\tif (data != null) {\n\t\t\tfor (var key4 in data) queryData[key4] = data[key4]\n\t\t\tpath = path.replace(/:([^\\/]+)/g, function(match2, token) {\n\t\t\t\tdelete queryData[token]\n\t\t\t\treturn data[token]\n\t\t\t})\n\t\t}\n\t\tvar query = buildQueryString(queryData)\n\t\tif (query) path += "?" + query\n\t\tvar hash = buildQueryString(hashData)\n\t\tif (hash) path += "#" + hash\n\t\tif (supportsPushState) {\n\t\t\tvar state = options ? options.state : null\n\t\t\tvar title = options ? options.title : null\n\t\t\t$window.onpopstate()\n\t\t\tif (options && options.replace) $window.history.replaceState(state, title, router.prefix + path)\n\t\t\telse $window.history.pushState(state, title, router.prefix + path)\n\t\t}\n\t\telse $window.location.href = router.prefix + path\n\t}\n\trouter.defineRoutes = function(routes, resolve, reject) {\n\t\tfunction resolveRoute() {\n\t\t\tvar path = router.getPath()\n\t\t\tvar params = {}\n\t\t\tvar pathname = parsePath(path, params, params)\n\t\t\tvar state = $window.history.state\n\t\t\tif (state != null) {\n\t\t\t\tfor (var k in state) params[k] = state[k]\n\t\t\t}\n\t\t\tfor (var route0 in routes) {\n\t\t\t\tvar matcher = new RegExp("^" + route0.replace(/:[^\\/]+?\\.{3}/g, "(.*?)").replace(/:[^\\/]+/g, "([^\\\\/]+)") + "\\/?$")\n\t\t\t\tif (matcher.test(pathname)) {\n\t\t\t\t\tpathname.replace(matcher, function() {\n\t\t\t\t\t\tvar keys = route0.match(/:[^\\/]+/g) || []\n\t\t\t\t\t\tvar values = [].slice.call(arguments, 1, -2)\n\t\t\t\t\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\t\t\t\t\tparams[keys[i].replace(/:|\\./g, "")] = decodeURIComponent(values[i])\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresolve(routes[route0], params, path, route0)\n\t\t\t\t\t})\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\treject(path, params)\n\t\t}\n\t\tif (supportsPushState) $window.onpopstate = debounceAsync(resolveRoute)\n\t\telse if (router.prefix.charAt(0) === "#") $window.onhashchange = resolveRoute\n\t\tresolveRoute()\n\t}\n\treturn router\n}\nvar _20 = function($window, redrawService0) {\n\tvar routeService = coreRouter($window)\n\tvar identity = function(v) {return v}\n\tvar render1, component, attrs3, currentPath, lastUpdate\n\tvar route = function(root, defaultRoute, routes) {\n\t\tif (root == null) throw new Error("Ensure the DOM element that was passed to `m.route` is not undefined")\n\t\tvar run1 = function() {\n\t\t\tif (render1 != null) redrawService0.render(root, render1(Vnode(component, attrs3.key, attrs3)))\n\t\t}\n\t\tvar bail = function(path) {\n\t\t\tif (path !== defaultRoute) routeService.setPath(defaultRoute, null, {replace: true})\n\t\t\telse throw new Error("Could not resolve default route " + defaultRoute)\n\t\t}\n\t\trouteService.defineRoutes(routes, function(payload, params, path) {\n\t\t\tvar update = lastUpdate = function(routeResolver, comp) {\n\t\t\t\tif (update !== lastUpdate) return\n\t\t\t\tcomponent = comp != null && (typeof comp.view === "function" || typeof comp === "function")? comp : "div"\n\t\t\t\tattrs3 = params, currentPath = path, lastUpdate = null\n\t\t\t\trender1 = (routeResolver.render || identity).bind(routeResolver)\n\t\t\t\trun1()\n\t\t\t}\n\t\t\tif (payload.view || typeof payload === "function") update({}, payload)\n\t\t\telse {\n\t\t\t\tif (payload.onmatch) {\n\t\t\t\t\tPromise.resolve(payload.onmatch(params, path)).then(function(resolved) {\n\t\t\t\t\t\tupdate(payload, resolved)\n\t\t\t\t\t}, bail)\n\t\t\t\t}\n\t\t\t\telse update(payload, "div")\n\t\t\t}\n\t\t}, bail)\n\t\tredrawService0.subscribe(root, run1)\n\t}\n\troute.set = function(path, data, options) {\n\t\tif (lastUpdate != null) {\n\t\t\toptions = options || {}\n\t\t\toptions.replace = true\n\t\t}\n\t\tlastUpdate = null\n\t\trouteService.setPath(path, data, options)\n\t}\n\troute.get = function() {return currentPath}\n\troute.prefix = function(prefix0) {routeService.prefix = prefix0}\n\troute.link = function(vnode1) {\n\t\tvnode1.dom.setAttribute("href", routeService.prefix + vnode1.attrs.href)\n\t\tvnode1.dom.onclick = function(e) {\n\t\t\tif (e.ctrlKey || e.metaKey || e.shiftKey || e.which === 2) return\n\t\t\te.preventDefault()\n\t\t\te.redraw = false\n\t\t\tvar href = this.getAttribute("href")\n\t\t\tif (href.indexOf(routeService.prefix) === 0) href = href.slice(routeService.prefix.length)\n\t\t\troute.set(href, undefined, undefined)\n\t\t}\n\t}\n\troute.param = function(key3) {\n\t\tif(typeof attrs3 !== "undefined" && typeof key3 !== "undefined") return attrs3[key3]\n\t\treturn attrs3\n\t}\n\treturn route\n}\nm.route = _20(window, redrawService)\nm.withAttr = function(attrName, callback1, context) {\n\treturn function(e) {\n\t\tcallback1.call(context || this, attrName in e.currentTarget ? e.currentTarget[attrName] : e.currentTarget.getAttribute(attrName))\n\t}\n}\nvar _28 = coreRenderer(window)\nm.render = _28.render\nm.redraw = redrawService.redraw\nm.request = requestService.request\nm.jsonp = requestService.jsonp\nm.parseQueryString = parseQueryString\nm.buildQueryString = buildQueryString\nm.version = "1.1.3"\nm.vnode = Vnode\nif (true) module["exports"] = m\nelse window.m = m\n}());\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(35).setImmediate, __webpack_require__(13)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21pdGhyaWwvbWl0aHJpbC5qcz9iZDQyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLDZEQUFDO0FBQ0Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLG1DQUFtQyxZQUFZO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDZCQUE2QixZQUFZO0FBQ3RELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsMkNBQTJDO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsZUFBZTtBQUM5RDtBQUNBO0FBQ0EsdURBQXVELGNBQWM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtKQUFrSixhQUFhO0FBQy9KO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLGFBQWE7QUFDYjtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsc0lBQXNJO0FBQ3ZKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QyxpQ0FBaUMsT0FBTztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsMkRBQTJEO0FBQzNELHFGQUFxRjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG1CQUFtQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0SEFBNEg7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QyxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsRUFBRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLGNBQWM7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsSSIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiOyhmdW5jdGlvbigpIHtcblwidXNlIHN0cmljdFwiXG5mdW5jdGlvbiBWbm9kZSh0YWcsIGtleSwgYXR0cnMwLCBjaGlsZHJlbiwgdGV4dCwgZG9tKSB7XG5cdHJldHVybiB7dGFnOiB0YWcsIGtleToga2V5LCBhdHRyczogYXR0cnMwLCBjaGlsZHJlbjogY2hpbGRyZW4sIHRleHQ6IHRleHQsIGRvbTogZG9tLCBkb21TaXplOiB1bmRlZmluZWQsIHN0YXRlOiB1bmRlZmluZWQsIF9zdGF0ZTogdW5kZWZpbmVkLCBldmVudHM6IHVuZGVmaW5lZCwgaW5zdGFuY2U6IHVuZGVmaW5lZCwgc2tpcDogZmFsc2V9XG59XG5Wbm9kZS5ub3JtYWxpemUgPSBmdW5jdGlvbihub2RlKSB7XG5cdGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSByZXR1cm4gVm5vZGUoXCJbXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBWbm9kZS5ub3JtYWxpemVDaGlsZHJlbihub2RlKSwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG5cdGlmIChub2RlICE9IG51bGwgJiYgdHlwZW9mIG5vZGUgIT09IFwib2JqZWN0XCIpIHJldHVybiBWbm9kZShcIiNcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG5vZGUgPT09IGZhbHNlID8gXCJcIiA6IG5vZGUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKVxuXHRyZXR1cm4gbm9kZVxufVxuVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4gPSBmdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbikge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0Y2hpbGRyZW5baV0gPSBWbm9kZS5ub3JtYWxpemUoY2hpbGRyZW5baV0pXG5cdH1cblx0cmV0dXJuIGNoaWxkcmVuXG59XG52YXIgc2VsZWN0b3JQYXJzZXIgPSAvKD86KF58I3xcXC4pKFteI1xcLlxcW1xcXV0rKSl8KFxcWyguKz8pKD86XFxzKj1cXHMqKFwifCd8KSgoPzpcXFxcW1wiJ1xcXV18LikqPylcXDUpP1xcXSkvZ1xudmFyIHNlbGVjdG9yQ2FjaGUgPSB7fVxudmFyIGhhc093biA9IHt9Lmhhc093blByb3BlcnR5XG5mdW5jdGlvbiBjb21waWxlU2VsZWN0b3Ioc2VsZWN0b3IpIHtcblx0dmFyIG1hdGNoLCB0YWcgPSBcImRpdlwiLCBjbGFzc2VzID0gW10sIGF0dHJzID0ge31cblx0d2hpbGUgKG1hdGNoID0gc2VsZWN0b3JQYXJzZXIuZXhlYyhzZWxlY3RvcikpIHtcblx0XHR2YXIgdHlwZSA9IG1hdGNoWzFdLCB2YWx1ZSA9IG1hdGNoWzJdXG5cdFx0aWYgKHR5cGUgPT09IFwiXCIgJiYgdmFsdWUgIT09IFwiXCIpIHRhZyA9IHZhbHVlXG5cdFx0ZWxzZSBpZiAodHlwZSA9PT0gXCIjXCIpIGF0dHJzLmlkID0gdmFsdWVcblx0XHRlbHNlIGlmICh0eXBlID09PSBcIi5cIikgY2xhc3Nlcy5wdXNoKHZhbHVlKVxuXHRcdGVsc2UgaWYgKG1hdGNoWzNdWzBdID09PSBcIltcIikge1xuXHRcdFx0dmFyIGF0dHJWYWx1ZSA9IG1hdGNoWzZdXG5cdFx0XHRpZiAoYXR0clZhbHVlKSBhdHRyVmFsdWUgPSBhdHRyVmFsdWUucmVwbGFjZSgvXFxcXChbXCInXSkvZywgXCIkMVwiKS5yZXBsYWNlKC9cXFxcXFxcXC9nLCBcIlxcXFxcIilcblx0XHRcdGlmIChtYXRjaFs0XSA9PT0gXCJjbGFzc1wiKSBjbGFzc2VzLnB1c2goYXR0clZhbHVlKVxuXHRcdFx0ZWxzZSBhdHRyc1ttYXRjaFs0XV0gPSBhdHRyVmFsdWUgPT09IFwiXCIgPyBhdHRyVmFsdWUgOiBhdHRyVmFsdWUgfHwgdHJ1ZVxuXHRcdH1cblx0fVxuXHRpZiAoY2xhc3Nlcy5sZW5ndGggPiAwKSBhdHRycy5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oXCIgXCIpXG5cdHJldHVybiBzZWxlY3RvckNhY2hlW3NlbGVjdG9yXSA9IHt0YWc6IHRhZywgYXR0cnM6IGF0dHJzfVxufVxuZnVuY3Rpb24gZXhlY1NlbGVjdG9yKHN0YXRlLCBhdHRycywgY2hpbGRyZW4pIHtcblx0dmFyIGhhc0F0dHJzID0gZmFsc2UsIGNoaWxkTGlzdCwgdGV4dFxuXHR2YXIgY2xhc3NOYW1lID0gYXR0cnMuY2xhc3NOYW1lIHx8IGF0dHJzLmNsYXNzXG5cdGZvciAodmFyIGtleSBpbiBzdGF0ZS5hdHRycykge1xuXHRcdGlmIChoYXNPd24uY2FsbChzdGF0ZS5hdHRycywga2V5KSkge1xuXHRcdFx0YXR0cnNba2V5XSA9IHN0YXRlLmF0dHJzW2tleV1cblx0XHR9XG5cdH1cblx0aWYgKGNsYXNzTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0aWYgKGF0dHJzLmNsYXNzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGF0dHJzLmNsYXNzID0gdW5kZWZpbmVkXG5cdFx0XHRhdHRycy5jbGFzc05hbWUgPSBjbGFzc05hbWVcblx0XHR9XG5cdFx0aWYgKHN0YXRlLmF0dHJzLmNsYXNzTmFtZSAhPSBudWxsKSB7XG5cdFx0XHRhdHRycy5jbGFzc05hbWUgPSBzdGF0ZS5hdHRycy5jbGFzc05hbWUgKyBcIiBcIiArIGNsYXNzTmFtZVxuXHRcdH1cblx0fVxuXHRmb3IgKHZhciBrZXkgaW4gYXR0cnMpIHtcblx0XHRpZiAoaGFzT3duLmNhbGwoYXR0cnMsIGtleSkgJiYga2V5ICE9PSBcImtleVwiKSB7XG5cdFx0XHRoYXNBdHRycyA9IHRydWVcblx0XHRcdGJyZWFrXG5cdFx0fVxuXHR9XG5cdGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJiBjaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgY2hpbGRyZW5bMF0gIT0gbnVsbCAmJiBjaGlsZHJlblswXS50YWcgPT09IFwiI1wiKSB7XG5cdFx0dGV4dCA9IGNoaWxkcmVuWzBdLmNoaWxkcmVuXG5cdH0gZWxzZSB7XG5cdFx0Y2hpbGRMaXN0ID0gY2hpbGRyZW5cblx0fVxuXHRyZXR1cm4gVm5vZGUoc3RhdGUudGFnLCBhdHRycy5rZXksIGhhc0F0dHJzID8gYXR0cnMgOiB1bmRlZmluZWQsIGNoaWxkTGlzdCwgdGV4dClcbn1cbmZ1bmN0aW9uIGh5cGVyc2NyaXB0KHNlbGVjdG9yKSB7XG5cdC8vIEJlY2F1c2Ugc2xvcHB5IG1vZGUgc3Vja3Ncblx0dmFyIGF0dHJzID0gYXJndW1lbnRzWzFdLCBzdGFydCA9IDIsIGNoaWxkcmVuXG5cdGlmIChzZWxlY3RvciA9PSBudWxsIHx8IHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygc2VsZWN0b3IgIT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygc2VsZWN0b3IudmlldyAhPT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0dGhyb3cgRXJyb3IoXCJUaGUgc2VsZWN0b3IgbXVzdCBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgYSBjb21wb25lbnQuXCIpO1xuXHR9XG5cdGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIpIHtcblx0XHR2YXIgY2FjaGVkID0gc2VsZWN0b3JDYWNoZVtzZWxlY3Rvcl0gfHwgY29tcGlsZVNlbGVjdG9yKHNlbGVjdG9yKVxuXHR9XG5cdGlmIChhdHRycyA9PSBudWxsKSB7XG5cdFx0YXR0cnMgPSB7fVxuXHR9IGVsc2UgaWYgKHR5cGVvZiBhdHRycyAhPT0gXCJvYmplY3RcIiB8fCBhdHRycy50YWcgIT0gbnVsbCB8fCBBcnJheS5pc0FycmF5KGF0dHJzKSkge1xuXHRcdGF0dHJzID0ge31cblx0XHRzdGFydCA9IDFcblx0fVxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gc3RhcnQgKyAxKSB7XG5cdFx0Y2hpbGRyZW4gPSBhcmd1bWVudHNbc3RhcnRdXG5cdFx0aWYgKCFBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkgY2hpbGRyZW4gPSBbY2hpbGRyZW5dXG5cdH0gZWxzZSB7XG5cdFx0Y2hpbGRyZW4gPSBbXVxuXHRcdHdoaWxlIChzdGFydCA8IGFyZ3VtZW50cy5sZW5ndGgpIGNoaWxkcmVuLnB1c2goYXJndW1lbnRzW3N0YXJ0KytdKVxuXHR9XG5cdHZhciBub3JtYWxpemVkID0gVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pXG5cdGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIpIHtcblx0XHRyZXR1cm4gZXhlY1NlbGVjdG9yKGNhY2hlZCwgYXR0cnMsIG5vcm1hbGl6ZWQpXG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIFZub2RlKHNlbGVjdG9yLCBhdHRycy5rZXksIGF0dHJzLCBub3JtYWxpemVkKVxuXHR9XG59XG5oeXBlcnNjcmlwdC50cnVzdCA9IGZ1bmN0aW9uKGh0bWwpIHtcblx0aWYgKGh0bWwgPT0gbnVsbCkgaHRtbCA9IFwiXCJcblx0cmV0dXJuIFZub2RlKFwiPFwiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaHRtbCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG59XG5oeXBlcnNjcmlwdC5mcmFnbWVudCA9IGZ1bmN0aW9uKGF0dHJzMSwgY2hpbGRyZW4pIHtcblx0cmV0dXJuIFZub2RlKFwiW1wiLCBhdHRyczEua2V5LCBhdHRyczEsIFZub2RlLm5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKSwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXG59XG52YXIgbSA9IGh5cGVyc2NyaXB0XG4vKiogQGNvbnN0cnVjdG9yICovXG52YXIgUHJvbWlzZVBvbHlmaWxsID0gZnVuY3Rpb24oZXhlY3V0b3IpIHtcblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIFByb21pc2VQb2x5ZmlsbCkpIHRocm93IG5ldyBFcnJvcihcIlByb21pc2UgbXVzdCBiZSBjYWxsZWQgd2l0aCBgbmV3YFwiKVxuXHRpZiAodHlwZW9mIGV4ZWN1dG9yICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJleGVjdXRvciBtdXN0IGJlIGEgZnVuY3Rpb25cIilcblx0dmFyIHNlbGYgPSB0aGlzLCByZXNvbHZlcnMgPSBbXSwgcmVqZWN0b3JzID0gW10sIHJlc29sdmVDdXJyZW50ID0gaGFuZGxlcihyZXNvbHZlcnMsIHRydWUpLCByZWplY3RDdXJyZW50ID0gaGFuZGxlcihyZWplY3RvcnMsIGZhbHNlKVxuXHR2YXIgaW5zdGFuY2UgPSBzZWxmLl9pbnN0YW5jZSA9IHtyZXNvbHZlcnM6IHJlc29sdmVycywgcmVqZWN0b3JzOiByZWplY3RvcnN9XG5cdHZhciBjYWxsQXN5bmMgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBzZXRJbW1lZGlhdGUgOiBzZXRUaW1lb3V0XG5cdGZ1bmN0aW9uIGhhbmRsZXIobGlzdCwgc2hvdWxkQWJzb3JiKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGV4ZWN1dGUodmFsdWUpIHtcblx0XHRcdHZhciB0aGVuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAoc2hvdWxkQWJzb3JiICYmIHZhbHVlICE9IG51bGwgJiYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikgJiYgdHlwZW9mICh0aGVuID0gdmFsdWUudGhlbikgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdGlmICh2YWx1ZSA9PT0gc2VsZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByb21pc2UgY2FuJ3QgYmUgcmVzb2x2ZWQgdy8gaXRzZWxmXCIpXG5cdFx0XHRcdFx0ZXhlY3V0ZU9uY2UodGhlbi5iaW5kKHZhbHVlKSlcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRjYWxsQXN5bmMoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRpZiAoIXNob3VsZEFic29yYiAmJiBsaXN0Lmxlbmd0aCA9PT0gMCkgY29uc29sZS5lcnJvcihcIlBvc3NpYmxlIHVuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbjpcIiwgdmFsdWUpXG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIGxpc3RbaV0odmFsdWUpXG5cdFx0XHRcdFx0XHRyZXNvbHZlcnMubGVuZ3RoID0gMCwgcmVqZWN0b3JzLmxlbmd0aCA9IDBcblx0XHRcdFx0XHRcdGluc3RhbmNlLnN0YXRlID0gc2hvdWxkQWJzb3JiXG5cdFx0XHRcdFx0XHRpbnN0YW5jZS5yZXRyeSA9IGZ1bmN0aW9uKCkge2V4ZWN1dGUodmFsdWUpfVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGNhdGNoIChlKSB7XG5cdFx0XHRcdHJlamVjdEN1cnJlbnQoZSlcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gZXhlY3V0ZU9uY2UodGhlbikge1xuXHRcdHZhciBydW5zID0gMFxuXHRcdGZ1bmN0aW9uIHJ1bihmbikge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdGlmIChydW5zKysgPiAwKSByZXR1cm5cblx0XHRcdFx0Zm4odmFsdWUpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHZhciBvbmVycm9yID0gcnVuKHJlamVjdEN1cnJlbnQpXG5cdFx0dHJ5IHt0aGVuKHJ1bihyZXNvbHZlQ3VycmVudCksIG9uZXJyb3IpfSBjYXRjaCAoZSkge29uZXJyb3IoZSl9XG5cdH1cblx0ZXhlY3V0ZU9uY2UoZXhlY3V0b3IpXG59XG5Qcm9taXNlUG9seWZpbGwucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbihvbkZ1bGZpbGxlZCwgb25SZWplY3Rpb24pIHtcblx0dmFyIHNlbGYgPSB0aGlzLCBpbnN0YW5jZSA9IHNlbGYuX2luc3RhbmNlXG5cdGZ1bmN0aW9uIGhhbmRsZShjYWxsYmFjaywgbGlzdCwgbmV4dCwgc3RhdGUpIHtcblx0XHRsaXN0LnB1c2goZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikgbmV4dCh2YWx1ZSlcblx0XHRcdGVsc2UgdHJ5IHtyZXNvbHZlTmV4dChjYWxsYmFjayh2YWx1ZSkpfSBjYXRjaCAoZSkge2lmIChyZWplY3ROZXh0KSByZWplY3ROZXh0KGUpfVxuXHRcdH0pXG5cdFx0aWYgKHR5cGVvZiBpbnN0YW5jZS5yZXRyeSA9PT0gXCJmdW5jdGlvblwiICYmIHN0YXRlID09PSBpbnN0YW5jZS5zdGF0ZSkgaW5zdGFuY2UucmV0cnkoKVxuXHR9XG5cdHZhciByZXNvbHZlTmV4dCwgcmVqZWN0TmV4dFxuXHR2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlUG9seWZpbGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7cmVzb2x2ZU5leHQgPSByZXNvbHZlLCByZWplY3ROZXh0ID0gcmVqZWN0fSlcblx0aGFuZGxlKG9uRnVsZmlsbGVkLCBpbnN0YW5jZS5yZXNvbHZlcnMsIHJlc29sdmVOZXh0LCB0cnVlKSwgaGFuZGxlKG9uUmVqZWN0aW9uLCBpbnN0YW5jZS5yZWplY3RvcnMsIHJlamVjdE5leHQsIGZhbHNlKVxuXHRyZXR1cm4gcHJvbWlzZVxufVxuUHJvbWlzZVBvbHlmaWxsLnByb3RvdHlwZS5jYXRjaCA9IGZ1bmN0aW9uKG9uUmVqZWN0aW9uKSB7XG5cdHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3Rpb24pXG59XG5Qcm9taXNlUG9seWZpbGwucmVzb2x2ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2VQb2x5ZmlsbCkgcmV0dXJuIHZhbHVlXG5cdHJldHVybiBuZXcgUHJvbWlzZVBvbHlmaWxsKGZ1bmN0aW9uKHJlc29sdmUpIHtyZXNvbHZlKHZhbHVlKX0pXG59XG5Qcm9taXNlUG9seWZpbGwucmVqZWN0ID0gZnVuY3Rpb24odmFsdWUpIHtcblx0cmV0dXJuIG5ldyBQcm9taXNlUG9seWZpbGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7cmVqZWN0KHZhbHVlKX0pXG59XG5Qcm9taXNlUG9seWZpbGwuYWxsID0gZnVuY3Rpb24obGlzdCkge1xuXHRyZXR1cm4gbmV3IFByb21pc2VQb2x5ZmlsbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHR2YXIgdG90YWwgPSBsaXN0Lmxlbmd0aCwgY291bnQgPSAwLCB2YWx1ZXMgPSBbXVxuXHRcdGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkgcmVzb2x2ZShbXSlcblx0XHRlbHNlIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdFx0KGZ1bmN0aW9uKGkpIHtcblx0XHRcdFx0ZnVuY3Rpb24gY29uc3VtZSh2YWx1ZSkge1xuXHRcdFx0XHRcdGNvdW50Kytcblx0XHRcdFx0XHR2YWx1ZXNbaV0gPSB2YWx1ZVxuXHRcdFx0XHRcdGlmIChjb3VudCA9PT0gdG90YWwpIHJlc29sdmUodmFsdWVzKVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChsaXN0W2ldICE9IG51bGwgJiYgKHR5cGVvZiBsaXN0W2ldID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBsaXN0W2ldID09PSBcImZ1bmN0aW9uXCIpICYmIHR5cGVvZiBsaXN0W2ldLnRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdGxpc3RbaV0udGhlbihjb25zdW1lLCByZWplY3QpXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBjb25zdW1lKGxpc3RbaV0pXG5cdFx0XHR9KShpKVxuXHRcdH1cblx0fSlcbn1cblByb21pc2VQb2x5ZmlsbC5yYWNlID0gZnVuY3Rpb24obGlzdCkge1xuXHRyZXR1cm4gbmV3IFByb21pc2VQb2x5ZmlsbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHRcdGxpc3RbaV0udGhlbihyZXNvbHZlLCByZWplY3QpXG5cdFx0fVxuXHR9KVxufVxuaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcblx0aWYgKHR5cGVvZiB3aW5kb3cuUHJvbWlzZSA9PT0gXCJ1bmRlZmluZWRcIikgd2luZG93LlByb21pc2UgPSBQcm9taXNlUG9seWZpbGxcblx0dmFyIFByb21pc2VQb2x5ZmlsbCA9IHdpbmRvdy5Qcm9taXNlXG59IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcblx0aWYgKHR5cGVvZiBnbG9iYWwuUHJvbWlzZSA9PT0gXCJ1bmRlZmluZWRcIikgZ2xvYmFsLlByb21pc2UgPSBQcm9taXNlUG9seWZpbGxcblx0dmFyIFByb21pc2VQb2x5ZmlsbCA9IGdsb2JhbC5Qcm9taXNlXG59IGVsc2Uge1xufVxudmFyIGJ1aWxkUXVlcnlTdHJpbmcgPSBmdW5jdGlvbihvYmplY3QpIHtcblx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpICE9PSBcIltvYmplY3QgT2JqZWN0XVwiKSByZXR1cm4gXCJcIlxuXHR2YXIgYXJncyA9IFtdXG5cdGZvciAodmFyIGtleTAgaW4gb2JqZWN0KSB7XG5cdFx0ZGVzdHJ1Y3R1cmUoa2V5MCwgb2JqZWN0W2tleTBdKVxuXHR9XG5cdHJldHVybiBhcmdzLmpvaW4oXCImXCIpXG5cdGZ1bmN0aW9uIGRlc3RydWN0dXJlKGtleTAsIHZhbHVlKSB7XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGRlc3RydWN0dXJlKGtleTAgKyBcIltcIiArIGkgKyBcIl1cIiwgdmFsdWVbaV0pXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09IFwiW29iamVjdCBPYmplY3RdXCIpIHtcblx0XHRcdGZvciAodmFyIGkgaW4gdmFsdWUpIHtcblx0XHRcdFx0ZGVzdHJ1Y3R1cmUoa2V5MCArIFwiW1wiICsgaSArIFwiXVwiLCB2YWx1ZVtpXSlcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBhcmdzLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleTApICsgKHZhbHVlICE9IG51bGwgJiYgdmFsdWUgIT09IFwiXCIgPyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkgOiBcIlwiKSlcblx0fVxufVxudmFyIEZJTEVfUFJPVE9DT0xfUkVHRVggPSBuZXcgUmVnRXhwKFwiXmZpbGU6Ly9cIiwgXCJpXCIpXG52YXIgXzggPSBmdW5jdGlvbigkd2luZG93LCBQcm9taXNlKSB7XG5cdHZhciBjYWxsYmFja0NvdW50ID0gMFxuXHR2YXIgb25jb21wbGV0aW9uXG5cdGZ1bmN0aW9uIHNldENvbXBsZXRpb25DYWxsYmFjayhjYWxsYmFjaykge29uY29tcGxldGlvbiA9IGNhbGxiYWNrfVxuXHRmdW5jdGlvbiBmaW5hbGl6ZXIoKSB7XG5cdFx0dmFyIGNvdW50ID0gMFxuXHRcdGZ1bmN0aW9uIGNvbXBsZXRlKCkge2lmICgtLWNvdW50ID09PSAwICYmIHR5cGVvZiBvbmNvbXBsZXRpb24gPT09IFwiZnVuY3Rpb25cIikgb25jb21wbGV0aW9uKCl9XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGZpbmFsaXplKHByb21pc2UwKSB7XG5cdFx0XHR2YXIgdGhlbjAgPSBwcm9taXNlMC50aGVuXG5cdFx0XHRwcm9taXNlMC50aGVuID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNvdW50Kytcblx0XHRcdFx0dmFyIG5leHQgPSB0aGVuMC5hcHBseShwcm9taXNlMCwgYXJndW1lbnRzKVxuXHRcdFx0XHRuZXh0LnRoZW4oY29tcGxldGUsIGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0XHRjb21wbGV0ZSgpXG5cdFx0XHRcdFx0aWYgKGNvdW50ID09PSAwKSB0aHJvdyBlXG5cdFx0XHRcdH0pXG5cdFx0XHRcdHJldHVybiBmaW5hbGl6ZShuZXh0KVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHByb21pc2UwXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIG5vcm1hbGl6ZShhcmdzLCBleHRyYSkge1xuXHRcdGlmICh0eXBlb2YgYXJncyA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0dmFyIHVybCA9IGFyZ3Ncblx0XHRcdGFyZ3MgPSBleHRyYSB8fCB7fVxuXHRcdFx0aWYgKGFyZ3MudXJsID09IG51bGwpIGFyZ3MudXJsID0gdXJsXG5cdFx0fVxuXHRcdHJldHVybiBhcmdzXG5cdH1cblx0ZnVuY3Rpb24gcmVxdWVzdChhcmdzLCBleHRyYSkge1xuXHRcdHZhciBmaW5hbGl6ZSA9IGZpbmFsaXplcigpXG5cdFx0YXJncyA9IG5vcm1hbGl6ZShhcmdzLCBleHRyYSlcblx0XHR2YXIgcHJvbWlzZTAgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcblx0XHRcdGlmIChhcmdzLm1ldGhvZCA9PSBudWxsKSBhcmdzLm1ldGhvZCA9IFwiR0VUXCJcblx0XHRcdGFyZ3MubWV0aG9kID0gYXJncy5tZXRob2QudG9VcHBlckNhc2UoKVxuXHRcdFx0dmFyIHVzZUJvZHkgPSAoYXJncy5tZXRob2QgPT09IFwiR0VUXCIgfHwgYXJncy5tZXRob2QgPT09IFwiVFJBQ0VcIikgPyBmYWxzZSA6ICh0eXBlb2YgYXJncy51c2VCb2R5ID09PSBcImJvb2xlYW5cIiA/IGFyZ3MudXNlQm9keSA6IHRydWUpXG5cdFx0XHRpZiAodHlwZW9mIGFyZ3Muc2VyaWFsaXplICE9PSBcImZ1bmN0aW9uXCIpIGFyZ3Muc2VyaWFsaXplID0gdHlwZW9mIEZvcm1EYXRhICE9PSBcInVuZGVmaW5lZFwiICYmIGFyZ3MuZGF0YSBpbnN0YW5jZW9mIEZvcm1EYXRhID8gZnVuY3Rpb24odmFsdWUpIHtyZXR1cm4gdmFsdWV9IDogSlNPTi5zdHJpbmdpZnlcblx0XHRcdGlmICh0eXBlb2YgYXJncy5kZXNlcmlhbGl6ZSAhPT0gXCJmdW5jdGlvblwiKSBhcmdzLmRlc2VyaWFsaXplID0gZGVzZXJpYWxpemVcblx0XHRcdGlmICh0eXBlb2YgYXJncy5leHRyYWN0ICE9PSBcImZ1bmN0aW9uXCIpIGFyZ3MuZXh0cmFjdCA9IGV4dHJhY3Rcblx0XHRcdGFyZ3MudXJsID0gaW50ZXJwb2xhdGUoYXJncy51cmwsIGFyZ3MuZGF0YSlcblx0XHRcdGlmICh1c2VCb2R5KSBhcmdzLmRhdGEgPSBhcmdzLnNlcmlhbGl6ZShhcmdzLmRhdGEpXG5cdFx0XHRlbHNlIGFyZ3MudXJsID0gYXNzZW1ibGUoYXJncy51cmwsIGFyZ3MuZGF0YSlcblx0XHRcdHZhciB4aHIgPSBuZXcgJHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpLFxuXHRcdFx0XHRhYm9ydGVkID0gZmFsc2UsXG5cdFx0XHRcdF9hYm9ydCA9IHhoci5hYm9ydFxuXHRcdFx0eGhyLmFib3J0ID0gZnVuY3Rpb24gYWJvcnQoKSB7XG5cdFx0XHRcdGFib3J0ZWQgPSB0cnVlXG5cdFx0XHRcdF9hYm9ydC5jYWxsKHhocilcblx0XHRcdH1cblx0XHRcdHhoci5vcGVuKGFyZ3MubWV0aG9kLCBhcmdzLnVybCwgdHlwZW9mIGFyZ3MuYXN5bmMgPT09IFwiYm9vbGVhblwiID8gYXJncy5hc3luYyA6IHRydWUsIHR5cGVvZiBhcmdzLnVzZXIgPT09IFwic3RyaW5nXCIgPyBhcmdzLnVzZXIgOiB1bmRlZmluZWQsIHR5cGVvZiBhcmdzLnBhc3N3b3JkID09PSBcInN0cmluZ1wiID8gYXJncy5wYXNzd29yZCA6IHVuZGVmaW5lZClcblx0XHRcdGlmIChhcmdzLnNlcmlhbGl6ZSA9PT0gSlNPTi5zdHJpbmdpZnkgJiYgdXNlQm9keSkge1xuXHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiLCBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIilcblx0XHRcdH1cblx0XHRcdGlmIChhcmdzLmRlc2VyaWFsaXplID09PSBkZXNlcmlhbGl6ZSkge1xuXHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkFjY2VwdFwiLCBcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvKlwiKVxuXHRcdFx0fVxuXHRcdFx0aWYgKGFyZ3Mud2l0aENyZWRlbnRpYWxzKSB4aHIud2l0aENyZWRlbnRpYWxzID0gYXJncy53aXRoQ3JlZGVudGlhbHNcblx0XHRcdGZvciAodmFyIGtleSBpbiBhcmdzLmhlYWRlcnMpIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFyZ3MuaGVhZGVycywga2V5KSkge1xuXHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIGFyZ3MuaGVhZGVyc1trZXldKVxuXHRcdFx0fVxuXHRcdFx0aWYgKHR5cGVvZiBhcmdzLmNvbmZpZyA9PT0gXCJmdW5jdGlvblwiKSB4aHIgPSBhcmdzLmNvbmZpZyh4aHIsIGFyZ3MpIHx8IHhoclxuXHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBEb24ndCB0aHJvdyBlcnJvcnMgb24geGhyLmFib3J0KCkuXG5cdFx0XHRcdGlmKGFib3J0ZWQpIHJldHVyblxuXHRcdFx0XHRpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0dmFyIHJlc3BvbnNlID0gKGFyZ3MuZXh0cmFjdCAhPT0gZXh0cmFjdCkgPyBhcmdzLmV4dHJhY3QoeGhyLCBhcmdzKSA6IGFyZ3MuZGVzZXJpYWxpemUoYXJncy5leHRyYWN0KHhociwgYXJncykpXG5cdFx0XHRcdFx0XHRpZiAoKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDApIHx8IHhoci5zdGF0dXMgPT09IDMwNCB8fCBGSUxFX1BST1RPQ09MX1JFR0VYLnRlc3QoYXJncy51cmwpKSB7XG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoY2FzdChhcmdzLnR5cGUsIHJlc3BvbnNlKSlcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR2YXIgZXJyb3IgPSBuZXcgRXJyb3IoeGhyLnJlc3BvbnNlVGV4dClcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIga2V5IGluIHJlc3BvbnNlKSBlcnJvcltrZXldID0gcmVzcG9uc2Vba2V5XVxuXHRcdFx0XHRcdFx0XHRyZWplY3QoZXJyb3IpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0XHRyZWplY3QoZSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICh1c2VCb2R5ICYmIChhcmdzLmRhdGEgIT0gbnVsbCkpIHhoci5zZW5kKGFyZ3MuZGF0YSlcblx0XHRcdGVsc2UgeGhyLnNlbmQoKVxuXHRcdH0pXG5cdFx0cmV0dXJuIGFyZ3MuYmFja2dyb3VuZCA9PT0gdHJ1ZSA/IHByb21pc2UwIDogZmluYWxpemUocHJvbWlzZTApXG5cdH1cblx0ZnVuY3Rpb24ganNvbnAoYXJncywgZXh0cmEpIHtcblx0XHR2YXIgZmluYWxpemUgPSBmaW5hbGl6ZXIoKVxuXHRcdGFyZ3MgPSBub3JtYWxpemUoYXJncywgZXh0cmEpXG5cdFx0dmFyIHByb21pc2UwID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0XHR2YXIgY2FsbGJhY2tOYW1lID0gYXJncy5jYWxsYmFja05hbWUgfHwgXCJfbWl0aHJpbF9cIiArIE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDFlMTYpICsgXCJfXCIgKyBjYWxsYmFja0NvdW50Kytcblx0XHRcdHZhciBzY3JpcHQgPSAkd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIilcblx0XHRcdCR3aW5kb3dbY2FsbGJhY2tOYW1lXSA9IGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdFx0c2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KVxuXHRcdFx0XHRyZXNvbHZlKGNhc3QoYXJncy50eXBlLCBkYXRhKSlcblx0XHRcdFx0ZGVsZXRlICR3aW5kb3dbY2FsbGJhY2tOYW1lXVxuXHRcdFx0fVxuXHRcdFx0c2NyaXB0Lm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KVxuXHRcdFx0XHRyZWplY3QobmV3IEVycm9yKFwiSlNPTlAgcmVxdWVzdCBmYWlsZWRcIikpXG5cdFx0XHRcdGRlbGV0ZSAkd2luZG93W2NhbGxiYWNrTmFtZV1cblx0XHRcdH1cblx0XHRcdGlmIChhcmdzLmRhdGEgPT0gbnVsbCkgYXJncy5kYXRhID0ge31cblx0XHRcdGFyZ3MudXJsID0gaW50ZXJwb2xhdGUoYXJncy51cmwsIGFyZ3MuZGF0YSlcblx0XHRcdGFyZ3MuZGF0YVthcmdzLmNhbGxiYWNrS2V5IHx8IFwiY2FsbGJhY2tcIl0gPSBjYWxsYmFja05hbWVcblx0XHRcdHNjcmlwdC5zcmMgPSBhc3NlbWJsZShhcmdzLnVybCwgYXJncy5kYXRhKVxuXHRcdFx0JHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoc2NyaXB0KVxuXHRcdH0pXG5cdFx0cmV0dXJuIGFyZ3MuYmFja2dyb3VuZCA9PT0gdHJ1ZT8gcHJvbWlzZTAgOiBmaW5hbGl6ZShwcm9taXNlMClcblx0fVxuXHRmdW5jdGlvbiBpbnRlcnBvbGF0ZSh1cmwsIGRhdGEpIHtcblx0XHRpZiAoZGF0YSA9PSBudWxsKSByZXR1cm4gdXJsXG5cdFx0dmFyIHRva2VucyA9IHVybC5tYXRjaCgvOlteXFwvXSsvZ2kpIHx8IFtdXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBrZXkgPSB0b2tlbnNbaV0uc2xpY2UoMSlcblx0XHRcdGlmIChkYXRhW2tleV0gIT0gbnVsbCkge1xuXHRcdFx0XHR1cmwgPSB1cmwucmVwbGFjZSh0b2tlbnNbaV0sIGRhdGFba2V5XSlcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHVybFxuXHR9XG5cdGZ1bmN0aW9uIGFzc2VtYmxlKHVybCwgZGF0YSkge1xuXHRcdHZhciBxdWVyeXN0cmluZyA9IGJ1aWxkUXVlcnlTdHJpbmcoZGF0YSlcblx0XHRpZiAocXVlcnlzdHJpbmcgIT09IFwiXCIpIHtcblx0XHRcdHZhciBwcmVmaXggPSB1cmwuaW5kZXhPZihcIj9cIikgPCAwID8gXCI/XCIgOiBcIiZcIlxuXHRcdFx0dXJsICs9IHByZWZpeCArIHF1ZXJ5c3RyaW5nXG5cdFx0fVxuXHRcdHJldHVybiB1cmxcblx0fVxuXHRmdW5jdGlvbiBkZXNlcmlhbGl6ZShkYXRhKSB7XG5cdFx0dHJ5IHtyZXR1cm4gZGF0YSAhPT0gXCJcIiA/IEpTT04ucGFyc2UoZGF0YSkgOiBudWxsfVxuXHRcdGNhdGNoIChlKSB7dGhyb3cgbmV3IEVycm9yKGRhdGEpfVxuXHR9XG5cdGZ1bmN0aW9uIGV4dHJhY3QoeGhyKSB7cmV0dXJuIHhoci5yZXNwb25zZVRleHR9XG5cdGZ1bmN0aW9uIGNhc3QodHlwZTAsIGRhdGEpIHtcblx0XHRpZiAodHlwZW9mIHR5cGUwID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGRhdGFbaV0gPSBuZXcgdHlwZTAoZGF0YVtpXSlcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSByZXR1cm4gbmV3IHR5cGUwKGRhdGEpXG5cdFx0fVxuXHRcdHJldHVybiBkYXRhXG5cdH1cblx0cmV0dXJuIHtyZXF1ZXN0OiByZXF1ZXN0LCBqc29ucDoganNvbnAsIHNldENvbXBsZXRpb25DYWxsYmFjazogc2V0Q29tcGxldGlvbkNhbGxiYWNrfVxufVxudmFyIHJlcXVlc3RTZXJ2aWNlID0gXzgod2luZG93LCBQcm9taXNlUG9seWZpbGwpXG52YXIgY29yZVJlbmRlcmVyID0gZnVuY3Rpb24oJHdpbmRvdykge1xuXHR2YXIgJGRvYyA9ICR3aW5kb3cuZG9jdW1lbnRcblx0dmFyICRlbXB0eUZyYWdtZW50ID0gJGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcblx0dmFyIG5hbWVTcGFjZSA9IHtcblx0XHRzdmc6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcblx0XHRtYXRoOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIlxuXHR9XG5cdHZhciBvbmV2ZW50XG5cdGZ1bmN0aW9uIHNldEV2ZW50Q2FsbGJhY2soY2FsbGJhY2spIHtyZXR1cm4gb25ldmVudCA9IGNhbGxiYWNrfVxuXHRmdW5jdGlvbiBnZXROYW1lU3BhY2Uodm5vZGUpIHtcblx0XHRyZXR1cm4gdm5vZGUuYXR0cnMgJiYgdm5vZGUuYXR0cnMueG1sbnMgfHwgbmFtZVNwYWNlW3Zub2RlLnRhZ11cblx0fVxuXHQvL2NyZWF0ZVxuXHRmdW5jdGlvbiBjcmVhdGVOb2RlcyhwYXJlbnQsIHZub2Rlcywgc3RhcnQsIGVuZCwgaG9va3MsIG5leHRTaWJsaW5nLCBucykge1xuXHRcdGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG5cdFx0XHR2YXIgdm5vZGUgPSB2bm9kZXNbaV1cblx0XHRcdGlmICh2bm9kZSAhPSBudWxsKSB7XG5cdFx0XHRcdGNyZWF0ZU5vZGUocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlTm9kZShwYXJlbnQsIHZub2RlLCBob29rcywgbnMsIG5leHRTaWJsaW5nKSB7XG5cdFx0dmFyIHRhZyA9IHZub2RlLnRhZ1xuXHRcdGlmICh0eXBlb2YgdGFnID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHR2bm9kZS5zdGF0ZSA9IHt9XG5cdFx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCkgaW5pdExpZmVjeWNsZSh2bm9kZS5hdHRycywgdm5vZGUsIGhvb2tzKVxuXHRcdFx0c3dpdGNoICh0YWcpIHtcblx0XHRcdFx0Y2FzZSBcIiNcIjogcmV0dXJuIGNyZWF0ZVRleHQocGFyZW50LCB2bm9kZSwgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdGNhc2UgXCI8XCI6IHJldHVybiBjcmVhdGVIVE1MKHBhcmVudCwgdm5vZGUsIG5leHRTaWJsaW5nKVxuXHRcdFx0XHRjYXNlIFwiW1wiOiByZXR1cm4gY3JlYXRlRnJhZ21lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdFx0ZGVmYXVsdDogcmV0dXJuIGNyZWF0ZUVsZW1lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSByZXR1cm4gY3JlYXRlQ29tcG9uZW50KHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlVGV4dChwYXJlbnQsIHZub2RlLCBuZXh0U2libGluZykge1xuXHRcdHZub2RlLmRvbSA9ICRkb2MuY3JlYXRlVGV4dE5vZGUodm5vZGUuY2hpbGRyZW4pXG5cdFx0aW5zZXJ0Tm9kZShwYXJlbnQsIHZub2RlLmRvbSwgbmV4dFNpYmxpbmcpXG5cdFx0cmV0dXJuIHZub2RlLmRvbVxuXHR9XG5cdGZ1bmN0aW9uIGNyZWF0ZUhUTUwocGFyZW50LCB2bm9kZSwgbmV4dFNpYmxpbmcpIHtcblx0XHR2YXIgbWF0Y2gxID0gdm5vZGUuY2hpbGRyZW4ubWF0Y2goL15cXHMqPzwoXFx3KykvaW0pIHx8IFtdXG5cdFx0dmFyIHBhcmVudDEgPSB7Y2FwdGlvbjogXCJ0YWJsZVwiLCB0aGVhZDogXCJ0YWJsZVwiLCB0Ym9keTogXCJ0YWJsZVwiLCB0Zm9vdDogXCJ0YWJsZVwiLCB0cjogXCJ0Ym9keVwiLCB0aDogXCJ0clwiLCB0ZDogXCJ0clwiLCBjb2xncm91cDogXCJ0YWJsZVwiLCBjb2w6IFwiY29sZ3JvdXBcIn1bbWF0Y2gxWzFdXSB8fCBcImRpdlwiXG5cdFx0dmFyIHRlbXAgPSAkZG9jLmNyZWF0ZUVsZW1lbnQocGFyZW50MSlcblx0XHR0ZW1wLmlubmVySFRNTCA9IHZub2RlLmNoaWxkcmVuXG5cdFx0dm5vZGUuZG9tID0gdGVtcC5maXJzdENoaWxkXG5cdFx0dm5vZGUuZG9tU2l6ZSA9IHRlbXAuY2hpbGROb2Rlcy5sZW5ndGhcblx0XHR2YXIgZnJhZ21lbnQgPSAkZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuXHRcdHZhciBjaGlsZFxuXHRcdHdoaWxlIChjaGlsZCA9IHRlbXAuZmlyc3RDaGlsZCkge1xuXHRcdFx0ZnJhZ21lbnQuYXBwZW5kQ2hpbGQoY2hpbGQpXG5cdFx0fVxuXHRcdGluc2VydE5vZGUocGFyZW50LCBmcmFnbWVudCwgbmV4dFNpYmxpbmcpXG5cdFx0cmV0dXJuIGZyYWdtZW50XG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlRnJhZ21lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZykge1xuXHRcdHZhciBmcmFnbWVudCA9ICRkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG5cdFx0aWYgKHZub2RlLmNoaWxkcmVuICE9IG51bGwpIHtcblx0XHRcdHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuXG5cdFx0XHRjcmVhdGVOb2RlcyhmcmFnbWVudCwgY2hpbGRyZW4sIDAsIGNoaWxkcmVuLmxlbmd0aCwgaG9va3MsIG51bGwsIG5zKVxuXHRcdH1cblx0XHR2bm9kZS5kb20gPSBmcmFnbWVudC5maXJzdENoaWxkXG5cdFx0dm5vZGUuZG9tU2l6ZSA9IGZyYWdtZW50LmNoaWxkTm9kZXMubGVuZ3RoXG5cdFx0aW5zZXJ0Tm9kZShwYXJlbnQsIGZyYWdtZW50LCBuZXh0U2libGluZylcblx0XHRyZXR1cm4gZnJhZ21lbnRcblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVFbGVtZW50KHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpIHtcblx0XHR2YXIgdGFnID0gdm5vZGUudGFnXG5cdFx0dmFyIGF0dHJzMiA9IHZub2RlLmF0dHJzXG5cdFx0dmFyIGlzID0gYXR0cnMyICYmIGF0dHJzMi5pc1xuXHRcdG5zID0gZ2V0TmFtZVNwYWNlKHZub2RlKSB8fCBuc1xuXHRcdHZhciBlbGVtZW50ID0gbnMgP1xuXHRcdFx0aXMgPyAkZG9jLmNyZWF0ZUVsZW1lbnROUyhucywgdGFnLCB7aXM6IGlzfSkgOiAkZG9jLmNyZWF0ZUVsZW1lbnROUyhucywgdGFnKSA6XG5cdFx0XHRpcyA/ICRkb2MuY3JlYXRlRWxlbWVudCh0YWcsIHtpczogaXN9KSA6ICRkb2MuY3JlYXRlRWxlbWVudCh0YWcpXG5cdFx0dm5vZGUuZG9tID0gZWxlbWVudFxuXHRcdGlmIChhdHRyczIgIT0gbnVsbCkge1xuXHRcdFx0c2V0QXR0cnModm5vZGUsIGF0dHJzMiwgbnMpXG5cdFx0fVxuXHRcdGluc2VydE5vZGUocGFyZW50LCBlbGVtZW50LCBuZXh0U2libGluZylcblx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCAmJiB2bm9kZS5hdHRycy5jb250ZW50ZWRpdGFibGUgIT0gbnVsbCkge1xuXHRcdFx0c2V0Q29udGVudEVkaXRhYmxlKHZub2RlKVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGlmICh2bm9kZS50ZXh0ICE9IG51bGwpIHtcblx0XHRcdFx0aWYgKHZub2RlLnRleHQgIT09IFwiXCIpIGVsZW1lbnQudGV4dENvbnRlbnQgPSB2bm9kZS50ZXh0XG5cdFx0XHRcdGVsc2Ugdm5vZGUuY2hpbGRyZW4gPSBbVm5vZGUoXCIjXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB2bm9kZS50ZXh0LCB1bmRlZmluZWQsIHVuZGVmaW5lZCldXG5cdFx0XHR9XG5cdFx0XHRpZiAodm5vZGUuY2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0XHR2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlblxuXHRcdFx0XHRjcmVhdGVOb2RlcyhlbGVtZW50LCBjaGlsZHJlbiwgMCwgY2hpbGRyZW4ubGVuZ3RoLCBob29rcywgbnVsbCwgbnMpXG5cdFx0XHRcdHNldExhdGVBdHRycyh2bm9kZSlcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGVsZW1lbnRcblx0fVxuXHRmdW5jdGlvbiBpbml0Q29tcG9uZW50KHZub2RlLCBob29rcykge1xuXHRcdHZhciBzZW50aW5lbFxuXHRcdGlmICh0eXBlb2Ygdm5vZGUudGFnLnZpZXcgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0dm5vZGUuc3RhdGUgPSBPYmplY3QuY3JlYXRlKHZub2RlLnRhZylcblx0XHRcdHNlbnRpbmVsID0gdm5vZGUuc3RhdGUudmlld1xuXHRcdFx0aWYgKHNlbnRpbmVsLiQkcmVlbnRyYW50TG9jayQkICE9IG51bGwpIHJldHVybiAkZW1wdHlGcmFnbWVudFxuXHRcdFx0c2VudGluZWwuJCRyZWVudHJhbnRMb2NrJCQgPSB0cnVlXG5cdFx0fSBlbHNlIHtcblx0XHRcdHZub2RlLnN0YXRlID0gdm9pZCAwXG5cdFx0XHRzZW50aW5lbCA9IHZub2RlLnRhZ1xuXHRcdFx0aWYgKHNlbnRpbmVsLiQkcmVlbnRyYW50TG9jayQkICE9IG51bGwpIHJldHVybiAkZW1wdHlGcmFnbWVudFxuXHRcdFx0c2VudGluZWwuJCRyZWVudHJhbnRMb2NrJCQgPSB0cnVlXG5cdFx0XHR2bm9kZS5zdGF0ZSA9ICh2bm9kZS50YWcucHJvdG90eXBlICE9IG51bGwgJiYgdHlwZW9mIHZub2RlLnRhZy5wcm90b3R5cGUudmlldyA9PT0gXCJmdW5jdGlvblwiKSA/IG5ldyB2bm9kZS50YWcodm5vZGUpIDogdm5vZGUudGFnKHZub2RlKVxuXHRcdH1cblx0XHR2bm9kZS5fc3RhdGUgPSB2bm9kZS5zdGF0ZVxuXHRcdGlmICh2bm9kZS5hdHRycyAhPSBudWxsKSBpbml0TGlmZWN5Y2xlKHZub2RlLmF0dHJzLCB2bm9kZSwgaG9va3MpXG5cdFx0aW5pdExpZmVjeWNsZSh2bm9kZS5fc3RhdGUsIHZub2RlLCBob29rcylcblx0XHR2bm9kZS5pbnN0YW5jZSA9IFZub2RlLm5vcm1hbGl6ZSh2bm9kZS5fc3RhdGUudmlldy5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSkpXG5cdFx0aWYgKHZub2RlLmluc3RhbmNlID09PSB2bm9kZSkgdGhyb3cgRXJyb3IoXCJBIHZpZXcgY2Fubm90IHJldHVybiB0aGUgdm5vZGUgaXQgcmVjZWl2ZWQgYXMgYXJndW1lbnRcIilcblx0XHRzZW50aW5lbC4kJHJlZW50cmFudExvY2skJCA9IG51bGxcblx0fVxuXHRmdW5jdGlvbiBjcmVhdGVDb21wb25lbnQocGFyZW50LCB2bm9kZSwgaG9va3MsIG5zLCBuZXh0U2libGluZykge1xuXHRcdGluaXRDb21wb25lbnQodm5vZGUsIGhvb2tzKVxuXHRcdGlmICh2bm9kZS5pbnN0YW5jZSAhPSBudWxsKSB7XG5cdFx0XHR2YXIgZWxlbWVudCA9IGNyZWF0ZU5vZGUocGFyZW50LCB2bm9kZS5pbnN0YW5jZSwgaG9va3MsIG5zLCBuZXh0U2libGluZylcblx0XHRcdHZub2RlLmRvbSA9IHZub2RlLmluc3RhbmNlLmRvbVxuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IHZub2RlLmRvbSAhPSBudWxsID8gdm5vZGUuaW5zdGFuY2UuZG9tU2l6ZSA6IDBcblx0XHRcdGluc2VydE5vZGUocGFyZW50LCBlbGVtZW50LCBuZXh0U2libGluZylcblx0XHRcdHJldHVybiBlbGVtZW50XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IDBcblx0XHRcdHJldHVybiAkZW1wdHlGcmFnbWVudFxuXHRcdH1cblx0fVxuXHQvL3VwZGF0ZVxuXHRmdW5jdGlvbiB1cGRhdGVOb2RlcyhwYXJlbnQsIG9sZCwgdm5vZGVzLCByZWN5Y2xpbmcsIGhvb2tzLCBuZXh0U2libGluZywgbnMpIHtcblx0XHRpZiAob2xkID09PSB2bm9kZXMgfHwgb2xkID09IG51bGwgJiYgdm5vZGVzID09IG51bGwpIHJldHVyblxuXHRcdGVsc2UgaWYgKG9sZCA9PSBudWxsKSBjcmVhdGVOb2RlcyhwYXJlbnQsIHZub2RlcywgMCwgdm5vZGVzLmxlbmd0aCwgaG9va3MsIG5leHRTaWJsaW5nLCBucylcblx0XHRlbHNlIGlmICh2bm9kZXMgPT0gbnVsbCkgcmVtb3ZlTm9kZXMob2xkLCAwLCBvbGQubGVuZ3RoLCB2bm9kZXMpXG5cdFx0ZWxzZSB7XG5cdFx0XHRpZiAob2xkLmxlbmd0aCA9PT0gdm5vZGVzLmxlbmd0aCkge1xuXHRcdFx0XHR2YXIgaXNVbmtleWVkID0gZmFsc2Vcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB2bm9kZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRpZiAodm5vZGVzW2ldICE9IG51bGwgJiYgb2xkW2ldICE9IG51bGwpIHtcblx0XHRcdFx0XHRcdGlzVW5rZXllZCA9IHZub2Rlc1tpXS5rZXkgPT0gbnVsbCAmJiBvbGRbaV0ua2V5ID09IG51bGxcblx0XHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChpc1Vua2V5ZWQpIHtcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG9sZC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0aWYgKG9sZFtpXSA9PT0gdm5vZGVzW2ldKSBjb250aW51ZVxuXHRcdFx0XHRcdFx0ZWxzZSBpZiAob2xkW2ldID09IG51bGwgJiYgdm5vZGVzW2ldICE9IG51bGwpIGNyZWF0ZU5vZGUocGFyZW50LCB2bm9kZXNbaV0sIGhvb2tzLCBucywgZ2V0TmV4dFNpYmxpbmcob2xkLCBpICsgMSwgbmV4dFNpYmxpbmcpKVxuXHRcdFx0XHRcdFx0ZWxzZSBpZiAodm5vZGVzW2ldID09IG51bGwpIHJlbW92ZU5vZGVzKG9sZCwgaSwgaSArIDEsIHZub2Rlcylcblx0XHRcdFx0XHRcdGVsc2UgdXBkYXRlTm9kZShwYXJlbnQsIG9sZFtpXSwgdm5vZGVzW2ldLCBob29rcywgZ2V0TmV4dFNpYmxpbmcob2xkLCBpICsgMSwgbmV4dFNpYmxpbmcpLCByZWN5Y2xpbmcsIG5zKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmVjeWNsaW5nID0gcmVjeWNsaW5nIHx8IGlzUmVjeWNsYWJsZShvbGQsIHZub2Rlcylcblx0XHRcdGlmIChyZWN5Y2xpbmcpIHtcblx0XHRcdFx0dmFyIHBvb2wgPSBvbGQucG9vbFxuXHRcdFx0XHRvbGQgPSBvbGQuY29uY2F0KG9sZC5wb29sKVxuXHRcdFx0fVxuXHRcdFx0dmFyIG9sZFN0YXJ0ID0gMCwgc3RhcnQgPSAwLCBvbGRFbmQgPSBvbGQubGVuZ3RoIC0gMSwgZW5kID0gdm5vZGVzLmxlbmd0aCAtIDEsIG1hcFxuXHRcdFx0d2hpbGUgKG9sZEVuZCA+PSBvbGRTdGFydCAmJiBlbmQgPj0gc3RhcnQpIHtcblx0XHRcdFx0dmFyIG8gPSBvbGRbb2xkU3RhcnRdLCB2ID0gdm5vZGVzW3N0YXJ0XVxuXHRcdFx0XHRpZiAobyA9PT0gdiAmJiAhcmVjeWNsaW5nKSBvbGRTdGFydCsrLCBzdGFydCsrXG5cdFx0XHRcdGVsc2UgaWYgKG8gPT0gbnVsbCkgb2xkU3RhcnQrK1xuXHRcdFx0XHRlbHNlIGlmICh2ID09IG51bGwpIHN0YXJ0Kytcblx0XHRcdFx0ZWxzZSBpZiAoby5rZXkgPT09IHYua2V5KSB7XG5cdFx0XHRcdFx0dmFyIHNob3VsZFJlY3ljbGUgPSAocG9vbCAhPSBudWxsICYmIG9sZFN0YXJ0ID49IG9sZC5sZW5ndGggLSBwb29sLmxlbmd0aCkgfHwgKChwb29sID09IG51bGwpICYmIHJlY3ljbGluZylcblx0XHRcdFx0XHRvbGRTdGFydCsrLCBzdGFydCsrXG5cdFx0XHRcdFx0dXBkYXRlTm9kZShwYXJlbnQsIG8sIHYsIGhvb2tzLCBnZXROZXh0U2libGluZyhvbGQsIG9sZFN0YXJ0LCBuZXh0U2libGluZyksIHNob3VsZFJlY3ljbGUsIG5zKVxuXHRcdFx0XHRcdGlmIChyZWN5Y2xpbmcgJiYgby50YWcgPT09IHYudGFnKSBpbnNlcnROb2RlKHBhcmVudCwgdG9GcmFnbWVudChvKSwgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0dmFyIG8gPSBvbGRbb2xkRW5kXVxuXHRcdFx0XHRcdGlmIChvID09PSB2ICYmICFyZWN5Y2xpbmcpIG9sZEVuZC0tLCBzdGFydCsrXG5cdFx0XHRcdFx0ZWxzZSBpZiAobyA9PSBudWxsKSBvbGRFbmQtLVxuXHRcdFx0XHRcdGVsc2UgaWYgKHYgPT0gbnVsbCkgc3RhcnQrK1xuXHRcdFx0XHRcdGVsc2UgaWYgKG8ua2V5ID09PSB2LmtleSkge1xuXHRcdFx0XHRcdFx0dmFyIHNob3VsZFJlY3ljbGUgPSAocG9vbCAhPSBudWxsICYmIG9sZEVuZCA+PSBvbGQubGVuZ3RoIC0gcG9vbC5sZW5ndGgpIHx8ICgocG9vbCA9PSBudWxsKSAmJiByZWN5Y2xpbmcpXG5cdFx0XHRcdFx0XHR1cGRhdGVOb2RlKHBhcmVudCwgbywgdiwgaG9va3MsIGdldE5leHRTaWJsaW5nKG9sZCwgb2xkRW5kICsgMSwgbmV4dFNpYmxpbmcpLCBzaG91bGRSZWN5Y2xlLCBucylcblx0XHRcdFx0XHRcdGlmIChyZWN5Y2xpbmcgfHwgc3RhcnQgPCBlbmQpIGluc2VydE5vZGUocGFyZW50LCB0b0ZyYWdtZW50KG8pLCBnZXROZXh0U2libGluZyhvbGQsIG9sZFN0YXJ0LCBuZXh0U2libGluZykpXG5cdFx0XHRcdFx0XHRvbGRFbmQtLSwgc3RhcnQrK1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIGJyZWFrXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHdoaWxlIChvbGRFbmQgPj0gb2xkU3RhcnQgJiYgZW5kID49IHN0YXJ0KSB7XG5cdFx0XHRcdHZhciBvID0gb2xkW29sZEVuZF0sIHYgPSB2bm9kZXNbZW5kXVxuXHRcdFx0XHRpZiAobyA9PT0gdiAmJiAhcmVjeWNsaW5nKSBvbGRFbmQtLSwgZW5kLS1cblx0XHRcdFx0ZWxzZSBpZiAobyA9PSBudWxsKSBvbGRFbmQtLVxuXHRcdFx0XHRlbHNlIGlmICh2ID09IG51bGwpIGVuZC0tXG5cdFx0XHRcdGVsc2UgaWYgKG8ua2V5ID09PSB2LmtleSkge1xuXHRcdFx0XHRcdHZhciBzaG91bGRSZWN5Y2xlID0gKHBvb2wgIT0gbnVsbCAmJiBvbGRFbmQgPj0gb2xkLmxlbmd0aCAtIHBvb2wubGVuZ3RoKSB8fCAoKHBvb2wgPT0gbnVsbCkgJiYgcmVjeWNsaW5nKVxuXHRcdFx0XHRcdHVwZGF0ZU5vZGUocGFyZW50LCBvLCB2LCBob29rcywgZ2V0TmV4dFNpYmxpbmcob2xkLCBvbGRFbmQgKyAxLCBuZXh0U2libGluZyksIHNob3VsZFJlY3ljbGUsIG5zKVxuXHRcdFx0XHRcdGlmIChyZWN5Y2xpbmcgJiYgby50YWcgPT09IHYudGFnKSBpbnNlcnROb2RlKHBhcmVudCwgdG9GcmFnbWVudChvKSwgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdFx0aWYgKG8uZG9tICE9IG51bGwpIG5leHRTaWJsaW5nID0gby5kb21cblx0XHRcdFx0XHRvbGRFbmQtLSwgZW5kLS1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRpZiAoIW1hcCkgbWFwID0gZ2V0S2V5TWFwKG9sZCwgb2xkRW5kKVxuXHRcdFx0XHRcdGlmICh2ICE9IG51bGwpIHtcblx0XHRcdFx0XHRcdHZhciBvbGRJbmRleCA9IG1hcFt2LmtleV1cblx0XHRcdFx0XHRcdGlmIChvbGRJbmRleCAhPSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBtb3ZhYmxlID0gb2xkW29sZEluZGV4XVxuXHRcdFx0XHRcdFx0XHR2YXIgc2hvdWxkUmVjeWNsZSA9IChwb29sICE9IG51bGwgJiYgb2xkSW5kZXggPj0gb2xkLmxlbmd0aCAtIHBvb2wubGVuZ3RoKSB8fCAoKHBvb2wgPT0gbnVsbCkgJiYgcmVjeWNsaW5nKVxuXHRcdFx0XHRcdFx0XHR1cGRhdGVOb2RlKHBhcmVudCwgbW92YWJsZSwgdiwgaG9va3MsIGdldE5leHRTaWJsaW5nKG9sZCwgb2xkRW5kICsgMSwgbmV4dFNpYmxpbmcpLCByZWN5Y2xpbmcsIG5zKVxuXHRcdFx0XHRcdFx0XHRpbnNlcnROb2RlKHBhcmVudCwgdG9GcmFnbWVudChtb3ZhYmxlKSwgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdFx0XHRcdG9sZFtvbGRJbmRleF0uc2tpcCA9IHRydWVcblx0XHRcdFx0XHRcdFx0aWYgKG1vdmFibGUuZG9tICE9IG51bGwpIG5leHRTaWJsaW5nID0gbW92YWJsZS5kb21cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR2YXIgZG9tID0gY3JlYXRlTm9kZShwYXJlbnQsIHYsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0XHRcdFx0XHRcdG5leHRTaWJsaW5nID0gZG9tXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVuZC0tXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGVuZCA8IHN0YXJ0KSBicmVha1xuXHRcdFx0fVxuXHRcdFx0Y3JlYXRlTm9kZXMocGFyZW50LCB2bm9kZXMsIHN0YXJ0LCBlbmQgKyAxLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKVxuXHRcdFx0cmVtb3ZlTm9kZXMob2xkLCBvbGRTdGFydCwgb2xkRW5kICsgMSwgdm5vZGVzKVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVOb2RlKHBhcmVudCwgb2xkLCB2bm9kZSwgaG9va3MsIG5leHRTaWJsaW5nLCByZWN5Y2xpbmcsIG5zKSB7XG5cdFx0dmFyIG9sZFRhZyA9IG9sZC50YWcsIHRhZyA9IHZub2RlLnRhZ1xuXHRcdGlmIChvbGRUYWcgPT09IHRhZykge1xuXHRcdFx0dm5vZGUuc3RhdGUgPSBvbGQuc3RhdGVcblx0XHRcdHZub2RlLl9zdGF0ZSA9IG9sZC5fc3RhdGVcblx0XHRcdHZub2RlLmV2ZW50cyA9IG9sZC5ldmVudHNcblx0XHRcdGlmICghcmVjeWNsaW5nICYmIHNob3VsZE5vdFVwZGF0ZSh2bm9kZSwgb2xkKSkgcmV0dXJuXG5cdFx0XHRpZiAodHlwZW9mIG9sZFRhZyA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCkge1xuXHRcdFx0XHRcdGlmIChyZWN5Y2xpbmcpIHtcblx0XHRcdFx0XHRcdHZub2RlLnN0YXRlID0ge31cblx0XHRcdFx0XHRcdGluaXRMaWZlY3ljbGUodm5vZGUuYXR0cnMsIHZub2RlLCBob29rcylcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB1cGRhdGVMaWZlY3ljbGUodm5vZGUuYXR0cnMsIHZub2RlLCBob29rcylcblx0XHRcdFx0fVxuXHRcdFx0XHRzd2l0Y2ggKG9sZFRhZykge1xuXHRcdFx0XHRcdGNhc2UgXCIjXCI6IHVwZGF0ZVRleHQob2xkLCB2bm9kZSk7IGJyZWFrXG5cdFx0XHRcdFx0Y2FzZSBcIjxcIjogdXBkYXRlSFRNTChwYXJlbnQsIG9sZCwgdm5vZGUsIG5leHRTaWJsaW5nKTsgYnJlYWtcblx0XHRcdFx0XHRjYXNlIFwiW1wiOiB1cGRhdGVGcmFnbWVudChwYXJlbnQsIG9sZCwgdm5vZGUsIHJlY3ljbGluZywgaG9va3MsIG5leHRTaWJsaW5nLCBucyk7IGJyZWFrXG5cdFx0XHRcdFx0ZGVmYXVsdDogdXBkYXRlRWxlbWVudChvbGQsIHZub2RlLCByZWN5Y2xpbmcsIGhvb2tzLCBucylcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSB1cGRhdGVDb21wb25lbnQocGFyZW50LCBvbGQsIHZub2RlLCBob29rcywgbmV4dFNpYmxpbmcsIHJlY3ljbGluZywgbnMpXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0cmVtb3ZlTm9kZShvbGQsIG51bGwpXG5cdFx0XHRjcmVhdGVOb2RlKHBhcmVudCwgdm5vZGUsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZVRleHQob2xkLCB2bm9kZSkge1xuXHRcdGlmIChvbGQuY2hpbGRyZW4udG9TdHJpbmcoKSAhPT0gdm5vZGUuY2hpbGRyZW4udG9TdHJpbmcoKSkge1xuXHRcdFx0b2xkLmRvbS5ub2RlVmFsdWUgPSB2bm9kZS5jaGlsZHJlblxuXHRcdH1cblx0XHR2bm9kZS5kb20gPSBvbGQuZG9tXG5cdH1cblx0ZnVuY3Rpb24gdXBkYXRlSFRNTChwYXJlbnQsIG9sZCwgdm5vZGUsIG5leHRTaWJsaW5nKSB7XG5cdFx0aWYgKG9sZC5jaGlsZHJlbiAhPT0gdm5vZGUuY2hpbGRyZW4pIHtcblx0XHRcdHRvRnJhZ21lbnQob2xkKVxuXHRcdFx0Y3JlYXRlSFRNTChwYXJlbnQsIHZub2RlLCBuZXh0U2libGluZylcblx0XHR9XG5cdFx0ZWxzZSB2bm9kZS5kb20gPSBvbGQuZG9tLCB2bm9kZS5kb21TaXplID0gb2xkLmRvbVNpemVcblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVGcmFnbWVudChwYXJlbnQsIG9sZCwgdm5vZGUsIHJlY3ljbGluZywgaG9va3MsIG5leHRTaWJsaW5nLCBucykge1xuXHRcdHVwZGF0ZU5vZGVzKHBhcmVudCwgb2xkLmNoaWxkcmVuLCB2bm9kZS5jaGlsZHJlbiwgcmVjeWNsaW5nLCBob29rcywgbmV4dFNpYmxpbmcsIG5zKVxuXHRcdHZhciBkb21TaXplID0gMCwgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlblxuXHRcdHZub2RlLmRvbSA9IG51bGxcblx0XHRpZiAoY2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgY2hpbGQgPSBjaGlsZHJlbltpXVxuXHRcdFx0XHRpZiAoY2hpbGQgIT0gbnVsbCAmJiBjaGlsZC5kb20gIT0gbnVsbCkge1xuXHRcdFx0XHRcdGlmICh2bm9kZS5kb20gPT0gbnVsbCkgdm5vZGUuZG9tID0gY2hpbGQuZG9tXG5cdFx0XHRcdFx0ZG9tU2l6ZSArPSBjaGlsZC5kb21TaXplIHx8IDFcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGRvbVNpemUgIT09IDEpIHZub2RlLmRvbVNpemUgPSBkb21TaXplXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUVsZW1lbnQob2xkLCB2bm9kZSwgcmVjeWNsaW5nLCBob29rcywgbnMpIHtcblx0XHR2YXIgZWxlbWVudCA9IHZub2RlLmRvbSA9IG9sZC5kb21cblx0XHRucyA9IGdldE5hbWVTcGFjZSh2bm9kZSkgfHwgbnNcblx0XHRpZiAodm5vZGUudGFnID09PSBcInRleHRhcmVhXCIpIHtcblx0XHRcdGlmICh2bm9kZS5hdHRycyA9PSBudWxsKSB2bm9kZS5hdHRycyA9IHt9XG5cdFx0XHRpZiAodm5vZGUudGV4dCAhPSBudWxsKSB7XG5cdFx0XHRcdHZub2RlLmF0dHJzLnZhbHVlID0gdm5vZGUudGV4dCAvL0ZJWE1FIGhhbmRsZTAgbXVsdGlwbGUgY2hpbGRyZW5cblx0XHRcdFx0dm5vZGUudGV4dCA9IHVuZGVmaW5lZFxuXHRcdFx0fVxuXHRcdH1cblx0XHR1cGRhdGVBdHRycyh2bm9kZSwgb2xkLmF0dHJzLCB2bm9kZS5hdHRycywgbnMpXG5cdFx0aWYgKHZub2RlLmF0dHJzICE9IG51bGwgJiYgdm5vZGUuYXR0cnMuY29udGVudGVkaXRhYmxlICE9IG51bGwpIHtcblx0XHRcdHNldENvbnRlbnRFZGl0YWJsZSh2bm9kZSlcblx0XHR9XG5cdFx0ZWxzZSBpZiAob2xkLnRleHQgIT0gbnVsbCAmJiB2bm9kZS50ZXh0ICE9IG51bGwgJiYgdm5vZGUudGV4dCAhPT0gXCJcIikge1xuXHRcdFx0aWYgKG9sZC50ZXh0LnRvU3RyaW5nKCkgIT09IHZub2RlLnRleHQudG9TdHJpbmcoKSkgb2xkLmRvbS5maXJzdENoaWxkLm5vZGVWYWx1ZSA9IHZub2RlLnRleHRcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRpZiAob2xkLnRleHQgIT0gbnVsbCkgb2xkLmNoaWxkcmVuID0gW1Zub2RlKFwiI1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgb2xkLnRleHQsIHVuZGVmaW5lZCwgb2xkLmRvbS5maXJzdENoaWxkKV1cblx0XHRcdGlmICh2bm9kZS50ZXh0ICE9IG51bGwpIHZub2RlLmNoaWxkcmVuID0gW1Zub2RlKFwiI1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdm5vZGUudGV4dCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpXVxuXHRcdFx0dXBkYXRlTm9kZXMoZWxlbWVudCwgb2xkLmNoaWxkcmVuLCB2bm9kZS5jaGlsZHJlbiwgcmVjeWNsaW5nLCBob29rcywgbnVsbCwgbnMpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUNvbXBvbmVudChwYXJlbnQsIG9sZCwgdm5vZGUsIGhvb2tzLCBuZXh0U2libGluZywgcmVjeWNsaW5nLCBucykge1xuXHRcdGlmIChyZWN5Y2xpbmcpIHtcblx0XHRcdGluaXRDb21wb25lbnQodm5vZGUsIGhvb2tzKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2bm9kZS5pbnN0YW5jZSA9IFZub2RlLm5vcm1hbGl6ZSh2bm9kZS5fc3RhdGUudmlldy5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSkpXG5cdFx0XHRpZiAodm5vZGUuaW5zdGFuY2UgPT09IHZub2RlKSB0aHJvdyBFcnJvcihcIkEgdmlldyBjYW5ub3QgcmV0dXJuIHRoZSB2bm9kZSBpdCByZWNlaXZlZCBhcyBhcmd1bWVudFwiKVxuXHRcdFx0aWYgKHZub2RlLmF0dHJzICE9IG51bGwpIHVwZGF0ZUxpZmVjeWNsZSh2bm9kZS5hdHRycywgdm5vZGUsIGhvb2tzKVxuXHRcdFx0dXBkYXRlTGlmZWN5Y2xlKHZub2RlLl9zdGF0ZSwgdm5vZGUsIGhvb2tzKVxuXHRcdH1cblx0XHRpZiAodm5vZGUuaW5zdGFuY2UgIT0gbnVsbCkge1xuXHRcdFx0aWYgKG9sZC5pbnN0YW5jZSA9PSBudWxsKSBjcmVhdGVOb2RlKHBhcmVudCwgdm5vZGUuaW5zdGFuY2UsIGhvb2tzLCBucywgbmV4dFNpYmxpbmcpXG5cdFx0XHRlbHNlIHVwZGF0ZU5vZGUocGFyZW50LCBvbGQuaW5zdGFuY2UsIHZub2RlLmluc3RhbmNlLCBob29rcywgbmV4dFNpYmxpbmcsIHJlY3ljbGluZywgbnMpXG5cdFx0XHR2bm9kZS5kb20gPSB2bm9kZS5pbnN0YW5jZS5kb21cblx0XHRcdHZub2RlLmRvbVNpemUgPSB2bm9kZS5pbnN0YW5jZS5kb21TaXplXG5cdFx0fVxuXHRcdGVsc2UgaWYgKG9sZC5pbnN0YW5jZSAhPSBudWxsKSB7XG5cdFx0XHRyZW1vdmVOb2RlKG9sZC5pbnN0YW5jZSwgbnVsbClcblx0XHRcdHZub2RlLmRvbSA9IHVuZGVmaW5lZFxuXHRcdFx0dm5vZGUuZG9tU2l6ZSA9IDBcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHR2bm9kZS5kb20gPSBvbGQuZG9tXG5cdFx0XHR2bm9kZS5kb21TaXplID0gb2xkLmRvbVNpemVcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gaXNSZWN5Y2xhYmxlKG9sZCwgdm5vZGVzKSB7XG5cdFx0aWYgKG9sZC5wb29sICE9IG51bGwgJiYgTWF0aC5hYnMob2xkLnBvb2wubGVuZ3RoIC0gdm5vZGVzLmxlbmd0aCkgPD0gTWF0aC5hYnMob2xkLmxlbmd0aCAtIHZub2Rlcy5sZW5ndGgpKSB7XG5cdFx0XHR2YXIgb2xkQ2hpbGRyZW5MZW5ndGggPSBvbGRbMF0gJiYgb2xkWzBdLmNoaWxkcmVuICYmIG9sZFswXS5jaGlsZHJlbi5sZW5ndGggfHwgMFxuXHRcdFx0dmFyIHBvb2xDaGlsZHJlbkxlbmd0aCA9IG9sZC5wb29sWzBdICYmIG9sZC5wb29sWzBdLmNoaWxkcmVuICYmIG9sZC5wb29sWzBdLmNoaWxkcmVuLmxlbmd0aCB8fCAwXG5cdFx0XHR2YXIgdm5vZGVzQ2hpbGRyZW5MZW5ndGggPSB2bm9kZXNbMF0gJiYgdm5vZGVzWzBdLmNoaWxkcmVuICYmIHZub2Rlc1swXS5jaGlsZHJlbi5sZW5ndGggfHwgMFxuXHRcdFx0aWYgKE1hdGguYWJzKHBvb2xDaGlsZHJlbkxlbmd0aCAtIHZub2Rlc0NoaWxkcmVuTGVuZ3RoKSA8PSBNYXRoLmFicyhvbGRDaGlsZHJlbkxlbmd0aCAtIHZub2Rlc0NoaWxkcmVuTGVuZ3RoKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2Vcblx0fVxuXHRmdW5jdGlvbiBnZXRLZXlNYXAodm5vZGVzLCBlbmQpIHtcblx0XHR2YXIgbWFwID0ge30sIGkgPSAwXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBlbmQ7IGkrKykge1xuXHRcdFx0dmFyIHZub2RlID0gdm5vZGVzW2ldXG5cdFx0XHRpZiAodm5vZGUgIT0gbnVsbCkge1xuXHRcdFx0XHR2YXIga2V5MiA9IHZub2RlLmtleVxuXHRcdFx0XHRpZiAoa2V5MiAhPSBudWxsKSBtYXBba2V5Ml0gPSBpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBtYXBcblx0fVxuXHRmdW5jdGlvbiB0b0ZyYWdtZW50KHZub2RlKSB7XG5cdFx0dmFyIGNvdW50MCA9IHZub2RlLmRvbVNpemVcblx0XHRpZiAoY291bnQwICE9IG51bGwgfHwgdm5vZGUuZG9tID09IG51bGwpIHtcblx0XHRcdHZhciBmcmFnbWVudCA9ICRkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG5cdFx0XHRpZiAoY291bnQwID4gMCkge1xuXHRcdFx0XHR2YXIgZG9tID0gdm5vZGUuZG9tXG5cdFx0XHRcdHdoaWxlICgtLWNvdW50MCkgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZG9tLm5leHRTaWJsaW5nKVxuXHRcdFx0XHRmcmFnbWVudC5pbnNlcnRCZWZvcmUoZG9tLCBmcmFnbWVudC5maXJzdENoaWxkKVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZyYWdtZW50XG5cdFx0fVxuXHRcdGVsc2UgcmV0dXJuIHZub2RlLmRvbVxuXHR9XG5cdGZ1bmN0aW9uIGdldE5leHRTaWJsaW5nKHZub2RlcywgaSwgbmV4dFNpYmxpbmcpIHtcblx0XHRmb3IgKDsgaSA8IHZub2Rlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKHZub2Rlc1tpXSAhPSBudWxsICYmIHZub2Rlc1tpXS5kb20gIT0gbnVsbCkgcmV0dXJuIHZub2Rlc1tpXS5kb21cblx0XHR9XG5cdFx0cmV0dXJuIG5leHRTaWJsaW5nXG5cdH1cblx0ZnVuY3Rpb24gaW5zZXJ0Tm9kZShwYXJlbnQsIGRvbSwgbmV4dFNpYmxpbmcpIHtcblx0XHRpZiAobmV4dFNpYmxpbmcgJiYgbmV4dFNpYmxpbmcucGFyZW50Tm9kZSkgcGFyZW50Lmluc2VydEJlZm9yZShkb20sIG5leHRTaWJsaW5nKVxuXHRcdGVsc2UgcGFyZW50LmFwcGVuZENoaWxkKGRvbSlcblx0fVxuXHRmdW5jdGlvbiBzZXRDb250ZW50RWRpdGFibGUodm5vZGUpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlblxuXHRcdGlmIChjaGlsZHJlbiAhPSBudWxsICYmIGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBjaGlsZHJlblswXS50YWcgPT09IFwiPFwiKSB7XG5cdFx0XHR2YXIgY29udGVudCA9IGNoaWxkcmVuWzBdLmNoaWxkcmVuXG5cdFx0XHRpZiAodm5vZGUuZG9tLmlubmVySFRNTCAhPT0gY29udGVudCkgdm5vZGUuZG9tLmlubmVySFRNTCA9IGNvbnRlbnRcblx0XHR9XG5cdFx0ZWxzZSBpZiAodm5vZGUudGV4dCAhPSBudWxsIHx8IGNoaWxkcmVuICE9IG51bGwgJiYgY2hpbGRyZW4ubGVuZ3RoICE9PSAwKSB0aHJvdyBuZXcgRXJyb3IoXCJDaGlsZCBub2RlIG9mIGEgY29udGVudGVkaXRhYmxlIG11c3QgYmUgdHJ1c3RlZFwiKVxuXHR9XG5cdC8vcmVtb3ZlXG5cdGZ1bmN0aW9uIHJlbW92ZU5vZGVzKHZub2Rlcywgc3RhcnQsIGVuZCwgY29udGV4dCkge1xuXHRcdGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG5cdFx0XHR2YXIgdm5vZGUgPSB2bm9kZXNbaV1cblx0XHRcdGlmICh2bm9kZSAhPSBudWxsKSB7XG5cdFx0XHRcdGlmICh2bm9kZS5za2lwKSB2bm9kZS5za2lwID0gZmFsc2Vcblx0XHRcdFx0ZWxzZSByZW1vdmVOb2RlKHZub2RlLCBjb250ZXh0KVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiByZW1vdmVOb2RlKHZub2RlLCBjb250ZXh0KSB7XG5cdFx0dmFyIGV4cGVjdGVkID0gMSwgY2FsbGVkID0gMFxuXHRcdGlmICh2bm9kZS5hdHRycyAmJiB0eXBlb2Ygdm5vZGUuYXR0cnMub25iZWZvcmVyZW1vdmUgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0dmFyIHJlc3VsdCA9IHZub2RlLmF0dHJzLm9uYmVmb3JlcmVtb3ZlLmNhbGwodm5vZGUuc3RhdGUsIHZub2RlKVxuXHRcdFx0aWYgKHJlc3VsdCAhPSBudWxsICYmIHR5cGVvZiByZXN1bHQudGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdGV4cGVjdGVkKytcblx0XHRcdFx0cmVzdWx0LnRoZW4oY29udGludWF0aW9uLCBjb250aW51YXRpb24pXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICh0eXBlb2Ygdm5vZGUudGFnICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiB2bm9kZS5fc3RhdGUub25iZWZvcmVyZW1vdmUgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0dmFyIHJlc3VsdCA9IHZub2RlLl9zdGF0ZS5vbmJlZm9yZXJlbW92ZS5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSlcblx0XHRcdGlmIChyZXN1bHQgIT0gbnVsbCAmJiB0eXBlb2YgcmVzdWx0LnRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRleHBlY3RlZCsrXG5cdFx0XHRcdHJlc3VsdC50aGVuKGNvbnRpbnVhdGlvbiwgY29udGludWF0aW9uKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRjb250aW51YXRpb24oKVxuXHRcdGZ1bmN0aW9uIGNvbnRpbnVhdGlvbigpIHtcblx0XHRcdGlmICgrK2NhbGxlZCA9PT0gZXhwZWN0ZWQpIHtcblx0XHRcdFx0b25yZW1vdmUodm5vZGUpXG5cdFx0XHRcdGlmICh2bm9kZS5kb20pIHtcblx0XHRcdFx0XHR2YXIgY291bnQwID0gdm5vZGUuZG9tU2l6ZSB8fCAxXG5cdFx0XHRcdFx0aWYgKGNvdW50MCA+IDEpIHtcblx0XHRcdFx0XHRcdHZhciBkb20gPSB2bm9kZS5kb21cblx0XHRcdFx0XHRcdHdoaWxlICgtLWNvdW50MCkge1xuXHRcdFx0XHRcdFx0XHRyZW1vdmVOb2RlRnJvbURPTShkb20ubmV4dFNpYmxpbmcpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJlbW92ZU5vZGVGcm9tRE9NKHZub2RlLmRvbSlcblx0XHRcdFx0XHRpZiAoY29udGV4dCAhPSBudWxsICYmIHZub2RlLmRvbVNpemUgPT0gbnVsbCAmJiAhaGFzSW50ZWdyYXRpb25NZXRob2RzKHZub2RlLmF0dHJzKSAmJiB0eXBlb2Ygdm5vZGUudGFnID09PSBcInN0cmluZ1wiKSB7IC8vVE9ETyB0ZXN0IGN1c3RvbSBlbGVtZW50c1xuXHRcdFx0XHRcdFx0aWYgKCFjb250ZXh0LnBvb2wpIGNvbnRleHQucG9vbCA9IFt2bm9kZV1cblx0XHRcdFx0XHRcdGVsc2UgY29udGV4dC5wb29sLnB1c2godm5vZGUpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHJlbW92ZU5vZGVGcm9tRE9NKG5vZGUpIHtcblx0XHR2YXIgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlXG5cdFx0aWYgKHBhcmVudCAhPSBudWxsKSBwYXJlbnQucmVtb3ZlQ2hpbGQobm9kZSlcblx0fVxuXHRmdW5jdGlvbiBvbnJlbW92ZSh2bm9kZSkge1xuXHRcdGlmICh2bm9kZS5hdHRycyAmJiB0eXBlb2Ygdm5vZGUuYXR0cnMub25yZW1vdmUgPT09IFwiZnVuY3Rpb25cIikgdm5vZGUuYXR0cnMub25yZW1vdmUuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpXG5cdFx0aWYgKHR5cGVvZiB2bm9kZS50YWcgIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHZub2RlLl9zdGF0ZS5vbnJlbW92ZSA9PT0gXCJmdW5jdGlvblwiKSB2bm9kZS5fc3RhdGUub25yZW1vdmUuY2FsbCh2bm9kZS5zdGF0ZSwgdm5vZGUpXG5cdFx0aWYgKHZub2RlLmluc3RhbmNlICE9IG51bGwpIG9ucmVtb3ZlKHZub2RlLmluc3RhbmNlKVxuXHRcdGVsc2Uge1xuXHRcdFx0dmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW5cblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0dmFyIGNoaWxkID0gY2hpbGRyZW5baV1cblx0XHRcdFx0XHRpZiAoY2hpbGQgIT0gbnVsbCkgb25yZW1vdmUoY2hpbGQpXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0Ly9hdHRyczJcblx0ZnVuY3Rpb24gc2V0QXR0cnModm5vZGUsIGF0dHJzMiwgbnMpIHtcblx0XHRmb3IgKHZhciBrZXkyIGluIGF0dHJzMikge1xuXHRcdFx0c2V0QXR0cih2bm9kZSwga2V5MiwgbnVsbCwgYXR0cnMyW2tleTJdLCBucylcblx0XHR9XG5cdH1cblx0ZnVuY3Rpb24gc2V0QXR0cih2bm9kZSwga2V5Miwgb2xkLCB2YWx1ZSwgbnMpIHtcblx0XHR2YXIgZWxlbWVudCA9IHZub2RlLmRvbVxuXHRcdGlmIChrZXkyID09PSBcImtleVwiIHx8IGtleTIgPT09IFwiaXNcIiB8fCAob2xkID09PSB2YWx1ZSAmJiAhaXNGb3JtQXR0cmlidXRlKHZub2RlLCBrZXkyKSkgJiYgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIiB8fCBpc0xpZmVjeWNsZU1ldGhvZChrZXkyKSkgcmV0dXJuXG5cdFx0dmFyIG5zTGFzdEluZGV4ID0ga2V5Mi5pbmRleE9mKFwiOlwiKVxuXHRcdGlmIChuc0xhc3RJbmRleCA+IC0xICYmIGtleTIuc3Vic3RyKDAsIG5zTGFzdEluZGV4KSA9PT0gXCJ4bGlua1wiKSB7XG5cdFx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZU5TKFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLCBrZXkyLnNsaWNlKG5zTGFzdEluZGV4ICsgMSksIHZhbHVlKVxuXHRcdH1cblx0XHRlbHNlIGlmIChrZXkyWzBdID09PSBcIm9cIiAmJiBrZXkyWzFdID09PSBcIm5cIiAmJiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikgdXBkYXRlRXZlbnQodm5vZGUsIGtleTIsIHZhbHVlKVxuXHRcdGVsc2UgaWYgKGtleTIgPT09IFwic3R5bGVcIikgdXBkYXRlU3R5bGUoZWxlbWVudCwgb2xkLCB2YWx1ZSlcblx0XHRlbHNlIGlmIChrZXkyIGluIGVsZW1lbnQgJiYgIWlzQXR0cmlidXRlKGtleTIpICYmIG5zID09PSB1bmRlZmluZWQgJiYgIWlzQ3VzdG9tRWxlbWVudCh2bm9kZSkpIHtcblx0XHRcdGlmIChrZXkyID09PSBcInZhbHVlXCIpIHtcblx0XHRcdFx0dmFyIG5vcm1hbGl6ZWQwID0gXCJcIiArIHZhbHVlIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8taW1wbGljaXQtY29lcmNpb25cblx0XHRcdFx0Ly9zZXR0aW5nIGlucHV0W3ZhbHVlXSB0byBzYW1lIHZhbHVlIGJ5IHR5cGluZyBvbiBmb2N1c2VkIGVsZW1lbnQgbW92ZXMgY3Vyc29yIHRvIGVuZCBpbiBDaHJvbWVcblx0XHRcdFx0aWYgKCh2bm9kZS50YWcgPT09IFwiaW5wdXRcIiB8fCB2bm9kZS50YWcgPT09IFwidGV4dGFyZWFcIikgJiYgdm5vZGUuZG9tLnZhbHVlID09PSBub3JtYWxpemVkMCAmJiB2bm9kZS5kb20gPT09ICRkb2MuYWN0aXZlRWxlbWVudCkgcmV0dXJuXG5cdFx0XHRcdC8vc2V0dGluZyBzZWxlY3RbdmFsdWVdIHRvIHNhbWUgdmFsdWUgd2hpbGUgaGF2aW5nIHNlbGVjdCBvcGVuIGJsaW5rcyBzZWxlY3QgZHJvcGRvd24gaW4gQ2hyb21lXG5cdFx0XHRcdGlmICh2bm9kZS50YWcgPT09IFwic2VsZWN0XCIpIHtcblx0XHRcdFx0XHRpZiAodmFsdWUgPT09IG51bGwpIHtcblx0XHRcdFx0XHRcdGlmICh2bm9kZS5kb20uc2VsZWN0ZWRJbmRleCA9PT0gLTEgJiYgdm5vZGUuZG9tID09PSAkZG9jLmFjdGl2ZUVsZW1lbnQpIHJldHVyblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpZiAob2xkICE9PSBudWxsICYmIHZub2RlLmRvbS52YWx1ZSA9PT0gbm9ybWFsaXplZDAgJiYgdm5vZGUuZG9tID09PSAkZG9jLmFjdGl2ZUVsZW1lbnQpIHJldHVyblxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHQvL3NldHRpbmcgb3B0aW9uW3ZhbHVlXSB0byBzYW1lIHZhbHVlIHdoaWxlIGhhdmluZyBzZWxlY3Qgb3BlbiBibGlua3Mgc2VsZWN0IGRyb3Bkb3duIGluIENocm9tZVxuXHRcdFx0XHRpZiAodm5vZGUudGFnID09PSBcIm9wdGlvblwiICYmIG9sZCAhPSBudWxsICYmIHZub2RlLmRvbS52YWx1ZSA9PT0gbm9ybWFsaXplZDApIHJldHVyblxuXHRcdFx0fVxuXHRcdFx0Ly8gSWYgeW91IGFzc2lnbiBhbiBpbnB1dCB0eXBlMSB0aGF0IGlzIG5vdCBzdXBwb3J0ZWQgYnkgSUUgMTEgd2l0aCBhbiBhc3NpZ25tZW50IGV4cHJlc3Npb24sIGFuIGVycm9yMCB3aWxsIG9jY3VyLlxuXHRcdFx0aWYgKHZub2RlLnRhZyA9PT0gXCJpbnB1dFwiICYmIGtleTIgPT09IFwidHlwZVwiKSB7XG5cdFx0XHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleTIsIHZhbHVlKVxuXHRcdFx0XHRyZXR1cm5cblx0XHRcdH1cblx0XHRcdGVsZW1lbnRba2V5Ml0gPSB2YWx1ZVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiKSB7XG5cdFx0XHRcdGlmICh2YWx1ZSkgZWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5MiwgXCJcIilcblx0XHRcdFx0ZWxzZSBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShrZXkyKVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSBlbGVtZW50LnNldEF0dHJpYnV0ZShrZXkyID09PSBcImNsYXNzTmFtZVwiID8gXCJjbGFzc1wiIDoga2V5MiwgdmFsdWUpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHNldExhdGVBdHRycyh2bm9kZSkge1xuXHRcdHZhciBhdHRyczIgPSB2bm9kZS5hdHRyc1xuXHRcdGlmICh2bm9kZS50YWcgPT09IFwic2VsZWN0XCIgJiYgYXR0cnMyICE9IG51bGwpIHtcblx0XHRcdGlmIChcInZhbHVlXCIgaW4gYXR0cnMyKSBzZXRBdHRyKHZub2RlLCBcInZhbHVlXCIsIG51bGwsIGF0dHJzMi52YWx1ZSwgdW5kZWZpbmVkKVxuXHRcdFx0aWYgKFwic2VsZWN0ZWRJbmRleFwiIGluIGF0dHJzMikgc2V0QXR0cih2bm9kZSwgXCJzZWxlY3RlZEluZGV4XCIsIG51bGwsIGF0dHJzMi5zZWxlY3RlZEluZGV4LCB1bmRlZmluZWQpXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHVwZGF0ZUF0dHJzKHZub2RlLCBvbGQsIGF0dHJzMiwgbnMpIHtcblx0XHRpZiAoYXR0cnMyICE9IG51bGwpIHtcblx0XHRcdGZvciAodmFyIGtleTIgaW4gYXR0cnMyKSB7XG5cdFx0XHRcdHNldEF0dHIodm5vZGUsIGtleTIsIG9sZCAmJiBvbGRba2V5Ml0sIGF0dHJzMltrZXkyXSwgbnMpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChvbGQgIT0gbnVsbCkge1xuXHRcdFx0Zm9yICh2YXIga2V5MiBpbiBvbGQpIHtcblx0XHRcdFx0aWYgKGF0dHJzMiA9PSBudWxsIHx8ICEoa2V5MiBpbiBhdHRyczIpKSB7XG5cdFx0XHRcdFx0aWYgKGtleTIgPT09IFwiY2xhc3NOYW1lXCIpIGtleTIgPSBcImNsYXNzXCJcblx0XHRcdFx0XHRpZiAoa2V5MlswXSA9PT0gXCJvXCIgJiYga2V5MlsxXSA9PT0gXCJuXCIgJiYgIWlzTGlmZWN5Y2xlTWV0aG9kKGtleTIpKSB1cGRhdGVFdmVudCh2bm9kZSwga2V5MiwgdW5kZWZpbmVkKVxuXHRcdFx0XHRcdGVsc2UgaWYgKGtleTIgIT09IFwia2V5XCIpIHZub2RlLmRvbS5yZW1vdmVBdHRyaWJ1dGUoa2V5Milcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBpc0Zvcm1BdHRyaWJ1dGUodm5vZGUsIGF0dHIpIHtcblx0XHRyZXR1cm4gYXR0ciA9PT0gXCJ2YWx1ZVwiIHx8IGF0dHIgPT09IFwiY2hlY2tlZFwiIHx8IGF0dHIgPT09IFwic2VsZWN0ZWRJbmRleFwiIHx8IGF0dHIgPT09IFwic2VsZWN0ZWRcIiAmJiB2bm9kZS5kb20gPT09ICRkb2MuYWN0aXZlRWxlbWVudFxuXHR9XG5cdGZ1bmN0aW9uIGlzTGlmZWN5Y2xlTWV0aG9kKGF0dHIpIHtcblx0XHRyZXR1cm4gYXR0ciA9PT0gXCJvbmluaXRcIiB8fCBhdHRyID09PSBcIm9uY3JlYXRlXCIgfHwgYXR0ciA9PT0gXCJvbnVwZGF0ZVwiIHx8IGF0dHIgPT09IFwib25yZW1vdmVcIiB8fCBhdHRyID09PSBcIm9uYmVmb3JlcmVtb3ZlXCIgfHwgYXR0ciA9PT0gXCJvbmJlZm9yZXVwZGF0ZVwiXG5cdH1cblx0ZnVuY3Rpb24gaXNBdHRyaWJ1dGUoYXR0cikge1xuXHRcdHJldHVybiBhdHRyID09PSBcImhyZWZcIiB8fCBhdHRyID09PSBcImxpc3RcIiB8fCBhdHRyID09PSBcImZvcm1cIiB8fCBhdHRyID09PSBcIndpZHRoXCIgfHwgYXR0ciA9PT0gXCJoZWlnaHRcIi8vIHx8IGF0dHIgPT09IFwidHlwZVwiXG5cdH1cblx0ZnVuY3Rpb24gaXNDdXN0b21FbGVtZW50KHZub2RlKXtcblx0XHRyZXR1cm4gdm5vZGUuYXR0cnMuaXMgfHwgdm5vZGUudGFnLmluZGV4T2YoXCItXCIpID4gLTFcblx0fVxuXHRmdW5jdGlvbiBoYXNJbnRlZ3JhdGlvbk1ldGhvZHMoc291cmNlKSB7XG5cdFx0cmV0dXJuIHNvdXJjZSAhPSBudWxsICYmIChzb3VyY2Uub25jcmVhdGUgfHwgc291cmNlLm9udXBkYXRlIHx8IHNvdXJjZS5vbmJlZm9yZXJlbW92ZSB8fCBzb3VyY2Uub25yZW1vdmUpXG5cdH1cblx0Ly9zdHlsZVxuXHRmdW5jdGlvbiB1cGRhdGVTdHlsZShlbGVtZW50LCBvbGQsIHN0eWxlKSB7XG5cdFx0aWYgKG9sZCA9PT0gc3R5bGUpIGVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IFwiXCIsIG9sZCA9IG51bGxcblx0XHRpZiAoc3R5bGUgPT0gbnVsbCkgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gXCJcIlxuXHRcdGVsc2UgaWYgKHR5cGVvZiBzdHlsZSA9PT0gXCJzdHJpbmdcIikgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gc3R5bGVcblx0XHRlbHNlIHtcblx0XHRcdGlmICh0eXBlb2Ygb2xkID09PSBcInN0cmluZ1wiKSBlbGVtZW50LnN0eWxlLmNzc1RleHQgPSBcIlwiXG5cdFx0XHRmb3IgKHZhciBrZXkyIGluIHN0eWxlKSB7XG5cdFx0XHRcdGVsZW1lbnQuc3R5bGVba2V5Ml0gPSBzdHlsZVtrZXkyXVxuXHRcdFx0fVxuXHRcdFx0aWYgKG9sZCAhPSBudWxsICYmIHR5cGVvZiBvbGQgIT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0Zm9yICh2YXIga2V5MiBpbiBvbGQpIHtcblx0XHRcdFx0XHRpZiAoIShrZXkyIGluIHN0eWxlKSkgZWxlbWVudC5zdHlsZVtrZXkyXSA9IFwiXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHQvL2V2ZW50XG5cdGZ1bmN0aW9uIHVwZGF0ZUV2ZW50KHZub2RlLCBrZXkyLCB2YWx1ZSkge1xuXHRcdHZhciBlbGVtZW50ID0gdm5vZGUuZG9tXG5cdFx0dmFyIGNhbGxiYWNrID0gdHlwZW9mIG9uZXZlbnQgIT09IFwiZnVuY3Rpb25cIiA/IHZhbHVlIDogZnVuY3Rpb24oZSkge1xuXHRcdFx0dmFyIHJlc3VsdCA9IHZhbHVlLmNhbGwoZWxlbWVudCwgZSlcblx0XHRcdG9uZXZlbnQuY2FsbChlbGVtZW50LCBlKVxuXHRcdFx0cmV0dXJuIHJlc3VsdFxuXHRcdH1cblx0XHRpZiAoa2V5MiBpbiBlbGVtZW50KSBlbGVtZW50W2tleTJdID0gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBjYWxsYmFjayA6IG51bGxcblx0XHRlbHNlIHtcblx0XHRcdHZhciBldmVudE5hbWUgPSBrZXkyLnNsaWNlKDIpXG5cdFx0XHRpZiAodm5vZGUuZXZlbnRzID09PSB1bmRlZmluZWQpIHZub2RlLmV2ZW50cyA9IHt9XG5cdFx0XHRpZiAodm5vZGUuZXZlbnRzW2tleTJdID09PSBjYWxsYmFjaykgcmV0dXJuXG5cdFx0XHRpZiAodm5vZGUuZXZlbnRzW2tleTJdICE9IG51bGwpIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIHZub2RlLmV2ZW50c1trZXkyXSwgZmFsc2UpXG5cdFx0XHRpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0dm5vZGUuZXZlbnRzW2tleTJdID0gY2FsbGJhY2tcblx0XHRcdFx0ZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgdm5vZGUuZXZlbnRzW2tleTJdLCBmYWxzZSlcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0Ly9saWZlY3ljbGVcblx0ZnVuY3Rpb24gaW5pdExpZmVjeWNsZShzb3VyY2UsIHZub2RlLCBob29rcykge1xuXHRcdGlmICh0eXBlb2Ygc291cmNlLm9uaW5pdCA9PT0gXCJmdW5jdGlvblwiKSBzb3VyY2Uub25pbml0LmNhbGwodm5vZGUuc3RhdGUsIHZub2RlKVxuXHRcdGlmICh0eXBlb2Ygc291cmNlLm9uY3JlYXRlID09PSBcImZ1bmN0aW9uXCIpIGhvb2tzLnB1c2goc291cmNlLm9uY3JlYXRlLmJpbmQodm5vZGUuc3RhdGUsIHZub2RlKSlcblx0fVxuXHRmdW5jdGlvbiB1cGRhdGVMaWZlY3ljbGUoc291cmNlLCB2bm9kZSwgaG9va3MpIHtcblx0XHRpZiAodHlwZW9mIHNvdXJjZS5vbnVwZGF0ZSA9PT0gXCJmdW5jdGlvblwiKSBob29rcy5wdXNoKHNvdXJjZS5vbnVwZGF0ZS5iaW5kKHZub2RlLnN0YXRlLCB2bm9kZSkpXG5cdH1cblx0ZnVuY3Rpb24gc2hvdWxkTm90VXBkYXRlKHZub2RlLCBvbGQpIHtcblx0XHR2YXIgZm9yY2VWbm9kZVVwZGF0ZSwgZm9yY2VDb21wb25lbnRVcGRhdGVcblx0XHRpZiAodm5vZGUuYXR0cnMgIT0gbnVsbCAmJiB0eXBlb2Ygdm5vZGUuYXR0cnMub25iZWZvcmV1cGRhdGUgPT09IFwiZnVuY3Rpb25cIikgZm9yY2VWbm9kZVVwZGF0ZSA9IHZub2RlLmF0dHJzLm9uYmVmb3JldXBkYXRlLmNhbGwodm5vZGUuc3RhdGUsIHZub2RlLCBvbGQpXG5cdFx0aWYgKHR5cGVvZiB2bm9kZS50YWcgIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHZub2RlLl9zdGF0ZS5vbmJlZm9yZXVwZGF0ZSA9PT0gXCJmdW5jdGlvblwiKSBmb3JjZUNvbXBvbmVudFVwZGF0ZSA9IHZub2RlLl9zdGF0ZS5vbmJlZm9yZXVwZGF0ZS5jYWxsKHZub2RlLnN0YXRlLCB2bm9kZSwgb2xkKVxuXHRcdGlmICghKGZvcmNlVm5vZGVVcGRhdGUgPT09IHVuZGVmaW5lZCAmJiBmb3JjZUNvbXBvbmVudFVwZGF0ZSA9PT0gdW5kZWZpbmVkKSAmJiAhZm9yY2VWbm9kZVVwZGF0ZSAmJiAhZm9yY2VDb21wb25lbnRVcGRhdGUpIHtcblx0XHRcdHZub2RlLmRvbSA9IG9sZC5kb21cblx0XHRcdHZub2RlLmRvbVNpemUgPSBvbGQuZG9tU2l6ZVxuXHRcdFx0dm5vZGUuaW5zdGFuY2UgPSBvbGQuaW5zdGFuY2Vcblx0XHRcdHJldHVybiB0cnVlXG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZVxuXHR9XG5cdGZ1bmN0aW9uIHJlbmRlcihkb20sIHZub2Rlcykge1xuXHRcdGlmICghZG9tKSB0aHJvdyBuZXcgRXJyb3IoXCJFbnN1cmUgdGhlIERPTSBlbGVtZW50IGJlaW5nIHBhc3NlZCB0byBtLnJvdXRlL20ubW91bnQvbS5yZW5kZXIgaXMgbm90IHVuZGVmaW5lZC5cIilcblx0XHR2YXIgaG9va3MgPSBbXVxuXHRcdHZhciBhY3RpdmUgPSAkZG9jLmFjdGl2ZUVsZW1lbnRcblx0XHR2YXIgbmFtZXNwYWNlID0gZG9tLm5hbWVzcGFjZVVSSVxuXHRcdC8vIEZpcnN0IHRpbWUwIHJlbmRlcmluZyBpbnRvIGEgbm9kZSBjbGVhcnMgaXQgb3V0XG5cdFx0aWYgKGRvbS52bm9kZXMgPT0gbnVsbCkgZG9tLnRleHRDb250ZW50ID0gXCJcIlxuXHRcdGlmICghQXJyYXkuaXNBcnJheSh2bm9kZXMpKSB2bm9kZXMgPSBbdm5vZGVzXVxuXHRcdHVwZGF0ZU5vZGVzKGRvbSwgZG9tLnZub2RlcywgVm5vZGUubm9ybWFsaXplQ2hpbGRyZW4odm5vZGVzKSwgZmFsc2UsIGhvb2tzLCBudWxsLCBuYW1lc3BhY2UgPT09IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiID8gdW5kZWZpbmVkIDogbmFtZXNwYWNlKVxuXHRcdGRvbS52bm9kZXMgPSB2bm9kZXNcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSBob29rc1tpXSgpXG5cdFx0aWYgKCRkb2MuYWN0aXZlRWxlbWVudCAhPT0gYWN0aXZlKSBhY3RpdmUuZm9jdXMoKVxuXHR9XG5cdHJldHVybiB7cmVuZGVyOiByZW5kZXIsIHNldEV2ZW50Q2FsbGJhY2s6IHNldEV2ZW50Q2FsbGJhY2t9XG59XG5mdW5jdGlvbiB0aHJvdHRsZShjYWxsYmFjaykge1xuXHQvLzYwZnBzIHRyYW5zbGF0ZXMgdG8gMTYuNm1zLCByb3VuZCBpdCBkb3duIHNpbmNlIHNldFRpbWVvdXQgcmVxdWlyZXMgaW50XG5cdHZhciB0aW1lID0gMTZcblx0dmFyIGxhc3QgPSAwLCBwZW5kaW5nID0gbnVsbFxuXHR2YXIgdGltZW91dCA9IHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09IFwiZnVuY3Rpb25cIiA/IHJlcXVlc3RBbmltYXRpb25GcmFtZSA6IHNldFRpbWVvdXRcblx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBub3cgPSBEYXRlLm5vdygpXG5cdFx0aWYgKGxhc3QgPT09IDAgfHwgbm93IC0gbGFzdCA+PSB0aW1lKSB7XG5cdFx0XHRsYXN0ID0gbm93XG5cdFx0XHRjYWxsYmFjaygpXG5cdFx0fVxuXHRcdGVsc2UgaWYgKHBlbmRpbmcgPT09IG51bGwpIHtcblx0XHRcdHBlbmRpbmcgPSB0aW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRwZW5kaW5nID0gbnVsbFxuXHRcdFx0XHRjYWxsYmFjaygpXG5cdFx0XHRcdGxhc3QgPSBEYXRlLm5vdygpXG5cdFx0XHR9LCB0aW1lIC0gKG5vdyAtIGxhc3QpKVxuXHRcdH1cblx0fVxufVxudmFyIF8xMSA9IGZ1bmN0aW9uKCR3aW5kb3cpIHtcblx0dmFyIHJlbmRlclNlcnZpY2UgPSBjb3JlUmVuZGVyZXIoJHdpbmRvdylcblx0cmVuZGVyU2VydmljZS5zZXRFdmVudENhbGxiYWNrKGZ1bmN0aW9uKGUpIHtcblx0XHRpZiAoZS5yZWRyYXcgPT09IGZhbHNlKSBlLnJlZHJhdyA9IHVuZGVmaW5lZFxuXHRcdGVsc2UgcmVkcmF3KClcblx0fSlcblx0dmFyIGNhbGxiYWNrcyA9IFtdXG5cdGZ1bmN0aW9uIHN1YnNjcmliZShrZXkxLCBjYWxsYmFjaykge1xuXHRcdHVuc3Vic2NyaWJlKGtleTEpXG5cdFx0Y2FsbGJhY2tzLnB1c2goa2V5MSwgdGhyb3R0bGUoY2FsbGJhY2spKVxuXHR9XG5cdGZ1bmN0aW9uIHVuc3Vic2NyaWJlKGtleTEpIHtcblx0XHR2YXIgaW5kZXggPSBjYWxsYmFja3MuaW5kZXhPZihrZXkxKVxuXHRcdGlmIChpbmRleCA+IC0xKSBjYWxsYmFja3Muc3BsaWNlKGluZGV4LCAyKVxuXHR9XG5cdGZ1bmN0aW9uIHJlZHJhdygpIHtcblx0XHRmb3IgKHZhciBpID0gMTsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkgKz0gMikge1xuXHRcdFx0Y2FsbGJhY2tzW2ldKClcblx0XHR9XG5cdH1cblx0cmV0dXJuIHtzdWJzY3JpYmU6IHN1YnNjcmliZSwgdW5zdWJzY3JpYmU6IHVuc3Vic2NyaWJlLCByZWRyYXc6IHJlZHJhdywgcmVuZGVyOiByZW5kZXJTZXJ2aWNlLnJlbmRlcn1cbn1cbnZhciByZWRyYXdTZXJ2aWNlID0gXzExKHdpbmRvdylcbnJlcXVlc3RTZXJ2aWNlLnNldENvbXBsZXRpb25DYWxsYmFjayhyZWRyYXdTZXJ2aWNlLnJlZHJhdylcbnZhciBfMTYgPSBmdW5jdGlvbihyZWRyYXdTZXJ2aWNlMCkge1xuXHRyZXR1cm4gZnVuY3Rpb24ocm9vdCwgY29tcG9uZW50KSB7XG5cdFx0aWYgKGNvbXBvbmVudCA9PT0gbnVsbCkge1xuXHRcdFx0cmVkcmF3U2VydmljZTAucmVuZGVyKHJvb3QsIFtdKVxuXHRcdFx0cmVkcmF3U2VydmljZTAudW5zdWJzY3JpYmUocm9vdClcblx0XHRcdHJldHVyblxuXHRcdH1cblx0XHRcblx0XHRpZiAoY29tcG9uZW50LnZpZXcgPT0gbnVsbCAmJiB0eXBlb2YgY29tcG9uZW50ICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcihcIm0ubW91bnQoZWxlbWVudCwgY29tcG9uZW50KSBleHBlY3RzIGEgY29tcG9uZW50LCBub3QgYSB2bm9kZVwiKVxuXHRcdFxuXHRcdHZhciBydW4wID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZWRyYXdTZXJ2aWNlMC5yZW5kZXIocm9vdCwgVm5vZGUoY29tcG9uZW50KSlcblx0XHR9XG5cdFx0cmVkcmF3U2VydmljZTAuc3Vic2NyaWJlKHJvb3QsIHJ1bjApXG5cdFx0cmVkcmF3U2VydmljZTAucmVkcmF3KClcblx0fVxufVxubS5tb3VudCA9IF8xNihyZWRyYXdTZXJ2aWNlKVxudmFyIFByb21pc2UgPSBQcm9taXNlUG9seWZpbGxcbnZhciBwYXJzZVF1ZXJ5U3RyaW5nID0gZnVuY3Rpb24oc3RyaW5nKSB7XG5cdGlmIChzdHJpbmcgPT09IFwiXCIgfHwgc3RyaW5nID09IG51bGwpIHJldHVybiB7fVxuXHRpZiAoc3RyaW5nLmNoYXJBdCgwKSA9PT0gXCI/XCIpIHN0cmluZyA9IHN0cmluZy5zbGljZSgxKVxuXHR2YXIgZW50cmllcyA9IHN0cmluZy5zcGxpdChcIiZcIiksIGRhdGEwID0ge30sIGNvdW50ZXJzID0ge31cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGVudHJ5ID0gZW50cmllc1tpXS5zcGxpdChcIj1cIilcblx0XHR2YXIga2V5NSA9IGRlY29kZVVSSUNvbXBvbmVudChlbnRyeVswXSlcblx0XHR2YXIgdmFsdWUgPSBlbnRyeS5sZW5ndGggPT09IDIgPyBkZWNvZGVVUklDb21wb25lbnQoZW50cnlbMV0pIDogXCJcIlxuXHRcdGlmICh2YWx1ZSA9PT0gXCJ0cnVlXCIpIHZhbHVlID0gdHJ1ZVxuXHRcdGVsc2UgaWYgKHZhbHVlID09PSBcImZhbHNlXCIpIHZhbHVlID0gZmFsc2Vcblx0XHR2YXIgbGV2ZWxzID0ga2V5NS5zcGxpdCgvXFxdXFxbP3xcXFsvKVxuXHRcdHZhciBjdXJzb3IgPSBkYXRhMFxuXHRcdGlmIChrZXk1LmluZGV4T2YoXCJbXCIpID4gLTEpIGxldmVscy5wb3AoKVxuXHRcdGZvciAodmFyIGogPSAwOyBqIDwgbGV2ZWxzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHR2YXIgbGV2ZWwgPSBsZXZlbHNbal0sIG5leHRMZXZlbCA9IGxldmVsc1tqICsgMV1cblx0XHRcdHZhciBpc051bWJlciA9IG5leHRMZXZlbCA9PSBcIlwiIHx8ICFpc05hTihwYXJzZUludChuZXh0TGV2ZWwsIDEwKSlcblx0XHRcdHZhciBpc1ZhbHVlID0gaiA9PT0gbGV2ZWxzLmxlbmd0aCAtIDFcblx0XHRcdGlmIChsZXZlbCA9PT0gXCJcIikge1xuXHRcdFx0XHR2YXIga2V5NSA9IGxldmVscy5zbGljZSgwLCBqKS5qb2luKClcblx0XHRcdFx0aWYgKGNvdW50ZXJzW2tleTVdID09IG51bGwpIGNvdW50ZXJzW2tleTVdID0gMFxuXHRcdFx0XHRsZXZlbCA9IGNvdW50ZXJzW2tleTVdKytcblx0XHRcdH1cblx0XHRcdGlmIChjdXJzb3JbbGV2ZWxdID09IG51bGwpIHtcblx0XHRcdFx0Y3Vyc29yW2xldmVsXSA9IGlzVmFsdWUgPyB2YWx1ZSA6IGlzTnVtYmVyID8gW10gOiB7fVxuXHRcdFx0fVxuXHRcdFx0Y3Vyc29yID0gY3Vyc29yW2xldmVsXVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gZGF0YTBcbn1cbnZhciBjb3JlUm91dGVyID0gZnVuY3Rpb24oJHdpbmRvdykge1xuXHR2YXIgc3VwcG9ydHNQdXNoU3RhdGUgPSB0eXBlb2YgJHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSA9PT0gXCJmdW5jdGlvblwiXG5cdHZhciBjYWxsQXN5bmMwID0gdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiID8gc2V0SW1tZWRpYXRlIDogc2V0VGltZW91dFxuXHRmdW5jdGlvbiBub3JtYWxpemUxKGZyYWdtZW50MCkge1xuXHRcdHZhciBkYXRhID0gJHdpbmRvdy5sb2NhdGlvbltmcmFnbWVudDBdLnJlcGxhY2UoLyg/OiVbYS1mODldW2EtZjAtOV0pKy9naW0sIGRlY29kZVVSSUNvbXBvbmVudClcblx0XHRpZiAoZnJhZ21lbnQwID09PSBcInBhdGhuYW1lXCIgJiYgZGF0YVswXSAhPT0gXCIvXCIpIGRhdGEgPSBcIi9cIiArIGRhdGFcblx0XHRyZXR1cm4gZGF0YVxuXHR9XG5cdHZhciBhc3luY0lkXG5cdGZ1bmN0aW9uIGRlYm91bmNlQXN5bmMoY2FsbGJhY2swKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKGFzeW5jSWQgIT0gbnVsbCkgcmV0dXJuXG5cdFx0XHRhc3luY0lkID0gY2FsbEFzeW5jMChmdW5jdGlvbigpIHtcblx0XHRcdFx0YXN5bmNJZCA9IG51bGxcblx0XHRcdFx0Y2FsbGJhY2swKClcblx0XHRcdH0pXG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIHBhcnNlUGF0aChwYXRoLCBxdWVyeURhdGEsIGhhc2hEYXRhKSB7XG5cdFx0dmFyIHF1ZXJ5SW5kZXggPSBwYXRoLmluZGV4T2YoXCI/XCIpXG5cdFx0dmFyIGhhc2hJbmRleCA9IHBhdGguaW5kZXhPZihcIiNcIilcblx0XHR2YXIgcGF0aEVuZCA9IHF1ZXJ5SW5kZXggPiAtMSA/IHF1ZXJ5SW5kZXggOiBoYXNoSW5kZXggPiAtMSA/IGhhc2hJbmRleCA6IHBhdGgubGVuZ3RoXG5cdFx0aWYgKHF1ZXJ5SW5kZXggPiAtMSkge1xuXHRcdFx0dmFyIHF1ZXJ5RW5kID0gaGFzaEluZGV4ID4gLTEgPyBoYXNoSW5kZXggOiBwYXRoLmxlbmd0aFxuXHRcdFx0dmFyIHF1ZXJ5UGFyYW1zID0gcGFyc2VRdWVyeVN0cmluZyhwYXRoLnNsaWNlKHF1ZXJ5SW5kZXggKyAxLCBxdWVyeUVuZCkpXG5cdFx0XHRmb3IgKHZhciBrZXk0IGluIHF1ZXJ5UGFyYW1zKSBxdWVyeURhdGFba2V5NF0gPSBxdWVyeVBhcmFtc1trZXk0XVxuXHRcdH1cblx0XHRpZiAoaGFzaEluZGV4ID4gLTEpIHtcblx0XHRcdHZhciBoYXNoUGFyYW1zID0gcGFyc2VRdWVyeVN0cmluZyhwYXRoLnNsaWNlKGhhc2hJbmRleCArIDEpKVxuXHRcdFx0Zm9yICh2YXIga2V5NCBpbiBoYXNoUGFyYW1zKSBoYXNoRGF0YVtrZXk0XSA9IGhhc2hQYXJhbXNba2V5NF1cblx0XHR9XG5cdFx0cmV0dXJuIHBhdGguc2xpY2UoMCwgcGF0aEVuZClcblx0fVxuXHR2YXIgcm91dGVyID0ge3ByZWZpeDogXCIjIVwifVxuXHRyb3V0ZXIuZ2V0UGF0aCA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0eXBlMiA9IHJvdXRlci5wcmVmaXguY2hhckF0KDApXG5cdFx0c3dpdGNoICh0eXBlMikge1xuXHRcdFx0Y2FzZSBcIiNcIjogcmV0dXJuIG5vcm1hbGl6ZTEoXCJoYXNoXCIpLnNsaWNlKHJvdXRlci5wcmVmaXgubGVuZ3RoKVxuXHRcdFx0Y2FzZSBcIj9cIjogcmV0dXJuIG5vcm1hbGl6ZTEoXCJzZWFyY2hcIikuc2xpY2Uocm91dGVyLnByZWZpeC5sZW5ndGgpICsgbm9ybWFsaXplMShcImhhc2hcIilcblx0XHRcdGRlZmF1bHQ6IHJldHVybiBub3JtYWxpemUxKFwicGF0aG5hbWVcIikuc2xpY2Uocm91dGVyLnByZWZpeC5sZW5ndGgpICsgbm9ybWFsaXplMShcInNlYXJjaFwiKSArIG5vcm1hbGl6ZTEoXCJoYXNoXCIpXG5cdFx0fVxuXHR9XG5cdHJvdXRlci5zZXRQYXRoID0gZnVuY3Rpb24ocGF0aCwgZGF0YSwgb3B0aW9ucykge1xuXHRcdHZhciBxdWVyeURhdGEgPSB7fSwgaGFzaERhdGEgPSB7fVxuXHRcdHBhdGggPSBwYXJzZVBhdGgocGF0aCwgcXVlcnlEYXRhLCBoYXNoRGF0YSlcblx0XHRpZiAoZGF0YSAhPSBudWxsKSB7XG5cdFx0XHRmb3IgKHZhciBrZXk0IGluIGRhdGEpIHF1ZXJ5RGF0YVtrZXk0XSA9IGRhdGFba2V5NF1cblx0XHRcdHBhdGggPSBwYXRoLnJlcGxhY2UoLzooW15cXC9dKykvZywgZnVuY3Rpb24obWF0Y2gyLCB0b2tlbikge1xuXHRcdFx0XHRkZWxldGUgcXVlcnlEYXRhW3Rva2VuXVxuXHRcdFx0XHRyZXR1cm4gZGF0YVt0b2tlbl1cblx0XHRcdH0pXG5cdFx0fVxuXHRcdHZhciBxdWVyeSA9IGJ1aWxkUXVlcnlTdHJpbmcocXVlcnlEYXRhKVxuXHRcdGlmIChxdWVyeSkgcGF0aCArPSBcIj9cIiArIHF1ZXJ5XG5cdFx0dmFyIGhhc2ggPSBidWlsZFF1ZXJ5U3RyaW5nKGhhc2hEYXRhKVxuXHRcdGlmIChoYXNoKSBwYXRoICs9IFwiI1wiICsgaGFzaFxuXHRcdGlmIChzdXBwb3J0c1B1c2hTdGF0ZSkge1xuXHRcdFx0dmFyIHN0YXRlID0gb3B0aW9ucyA/IG9wdGlvbnMuc3RhdGUgOiBudWxsXG5cdFx0XHR2YXIgdGl0bGUgPSBvcHRpb25zID8gb3B0aW9ucy50aXRsZSA6IG51bGxcblx0XHRcdCR3aW5kb3cub25wb3BzdGF0ZSgpXG5cdFx0XHRpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlcGxhY2UpICR3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoc3RhdGUsIHRpdGxlLCByb3V0ZXIucHJlZml4ICsgcGF0aClcblx0XHRcdGVsc2UgJHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZShzdGF0ZSwgdGl0bGUsIHJvdXRlci5wcmVmaXggKyBwYXRoKVxuXHRcdH1cblx0XHRlbHNlICR3aW5kb3cubG9jYXRpb24uaHJlZiA9IHJvdXRlci5wcmVmaXggKyBwYXRoXG5cdH1cblx0cm91dGVyLmRlZmluZVJvdXRlcyA9IGZ1bmN0aW9uKHJvdXRlcywgcmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0ZnVuY3Rpb24gcmVzb2x2ZVJvdXRlKCkge1xuXHRcdFx0dmFyIHBhdGggPSByb3V0ZXIuZ2V0UGF0aCgpXG5cdFx0XHR2YXIgcGFyYW1zID0ge31cblx0XHRcdHZhciBwYXRobmFtZSA9IHBhcnNlUGF0aChwYXRoLCBwYXJhbXMsIHBhcmFtcylcblx0XHRcdHZhciBzdGF0ZSA9ICR3aW5kb3cuaGlzdG9yeS5zdGF0ZVxuXHRcdFx0aWYgKHN0YXRlICE9IG51bGwpIHtcblx0XHRcdFx0Zm9yICh2YXIgayBpbiBzdGF0ZSkgcGFyYW1zW2tdID0gc3RhdGVba11cblx0XHRcdH1cblx0XHRcdGZvciAodmFyIHJvdXRlMCBpbiByb3V0ZXMpIHtcblx0XHRcdFx0dmFyIG1hdGNoZXIgPSBuZXcgUmVnRXhwKFwiXlwiICsgcm91dGUwLnJlcGxhY2UoLzpbXlxcL10rP1xcLnszfS9nLCBcIiguKj8pXCIpLnJlcGxhY2UoLzpbXlxcL10rL2csIFwiKFteXFxcXC9dKylcIikgKyBcIlxcLz8kXCIpXG5cdFx0XHRcdGlmIChtYXRjaGVyLnRlc3QocGF0aG5hbWUpKSB7XG5cdFx0XHRcdFx0cGF0aG5hbWUucmVwbGFjZShtYXRjaGVyLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHZhciBrZXlzID0gcm91dGUwLm1hdGNoKC86W15cXC9dKy9nKSB8fCBbXVxuXHRcdFx0XHRcdFx0dmFyIHZhbHVlcyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxLCAtMilcblx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRwYXJhbXNba2V5c1tpXS5yZXBsYWNlKC86fFxcLi9nLCBcIlwiKV0gPSBkZWNvZGVVUklDb21wb25lbnQodmFsdWVzW2ldKVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmVzb2x2ZShyb3V0ZXNbcm91dGUwXSwgcGFyYW1zLCBwYXRoLCByb3V0ZTApXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmVqZWN0KHBhdGgsIHBhcmFtcylcblx0XHR9XG5cdFx0aWYgKHN1cHBvcnRzUHVzaFN0YXRlKSAkd2luZG93Lm9ucG9wc3RhdGUgPSBkZWJvdW5jZUFzeW5jKHJlc29sdmVSb3V0ZSlcblx0XHRlbHNlIGlmIChyb3V0ZXIucHJlZml4LmNoYXJBdCgwKSA9PT0gXCIjXCIpICR3aW5kb3cub25oYXNoY2hhbmdlID0gcmVzb2x2ZVJvdXRlXG5cdFx0cmVzb2x2ZVJvdXRlKClcblx0fVxuXHRyZXR1cm4gcm91dGVyXG59XG52YXIgXzIwID0gZnVuY3Rpb24oJHdpbmRvdywgcmVkcmF3U2VydmljZTApIHtcblx0dmFyIHJvdXRlU2VydmljZSA9IGNvcmVSb3V0ZXIoJHdpbmRvdylcblx0dmFyIGlkZW50aXR5ID0gZnVuY3Rpb24odikge3JldHVybiB2fVxuXHR2YXIgcmVuZGVyMSwgY29tcG9uZW50LCBhdHRyczMsIGN1cnJlbnRQYXRoLCBsYXN0VXBkYXRlXG5cdHZhciByb3V0ZSA9IGZ1bmN0aW9uKHJvb3QsIGRlZmF1bHRSb3V0ZSwgcm91dGVzKSB7XG5cdFx0aWYgKHJvb3QgPT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKFwiRW5zdXJlIHRoZSBET00gZWxlbWVudCB0aGF0IHdhcyBwYXNzZWQgdG8gYG0ucm91dGVgIGlzIG5vdCB1bmRlZmluZWRcIilcblx0XHR2YXIgcnVuMSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKHJlbmRlcjEgIT0gbnVsbCkgcmVkcmF3U2VydmljZTAucmVuZGVyKHJvb3QsIHJlbmRlcjEoVm5vZGUoY29tcG9uZW50LCBhdHRyczMua2V5LCBhdHRyczMpKSlcblx0XHR9XG5cdFx0dmFyIGJhaWwgPSBmdW5jdGlvbihwYXRoKSB7XG5cdFx0XHRpZiAocGF0aCAhPT0gZGVmYXVsdFJvdXRlKSByb3V0ZVNlcnZpY2Uuc2V0UGF0aChkZWZhdWx0Um91dGUsIG51bGwsIHtyZXBsYWNlOiB0cnVlfSlcblx0XHRcdGVsc2UgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IHJlc29sdmUgZGVmYXVsdCByb3V0ZSBcIiArIGRlZmF1bHRSb3V0ZSlcblx0XHR9XG5cdFx0cm91dGVTZXJ2aWNlLmRlZmluZVJvdXRlcyhyb3V0ZXMsIGZ1bmN0aW9uKHBheWxvYWQsIHBhcmFtcywgcGF0aCkge1xuXHRcdFx0dmFyIHVwZGF0ZSA9IGxhc3RVcGRhdGUgPSBmdW5jdGlvbihyb3V0ZVJlc29sdmVyLCBjb21wKSB7XG5cdFx0XHRcdGlmICh1cGRhdGUgIT09IGxhc3RVcGRhdGUpIHJldHVyblxuXHRcdFx0XHRjb21wb25lbnQgPSBjb21wICE9IG51bGwgJiYgKHR5cGVvZiBjb21wLnZpZXcgPT09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgY29tcCA9PT0gXCJmdW5jdGlvblwiKT8gY29tcCA6IFwiZGl2XCJcblx0XHRcdFx0YXR0cnMzID0gcGFyYW1zLCBjdXJyZW50UGF0aCA9IHBhdGgsIGxhc3RVcGRhdGUgPSBudWxsXG5cdFx0XHRcdHJlbmRlcjEgPSAocm91dGVSZXNvbHZlci5yZW5kZXIgfHwgaWRlbnRpdHkpLmJpbmQocm91dGVSZXNvbHZlcilcblx0XHRcdFx0cnVuMSgpXG5cdFx0XHR9XG5cdFx0XHRpZiAocGF5bG9hZC52aWV3IHx8IHR5cGVvZiBwYXlsb2FkID09PSBcImZ1bmN0aW9uXCIpIHVwZGF0ZSh7fSwgcGF5bG9hZClcblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRpZiAocGF5bG9hZC5vbm1hdGNoKSB7XG5cdFx0XHRcdFx0UHJvbWlzZS5yZXNvbHZlKHBheWxvYWQub25tYXRjaChwYXJhbXMsIHBhdGgpKS50aGVuKGZ1bmN0aW9uKHJlc29sdmVkKSB7XG5cdFx0XHRcdFx0XHR1cGRhdGUocGF5bG9hZCwgcmVzb2x2ZWQpXG5cdFx0XHRcdFx0fSwgYmFpbClcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHVwZGF0ZShwYXlsb2FkLCBcImRpdlwiKVxuXHRcdFx0fVxuXHRcdH0sIGJhaWwpXG5cdFx0cmVkcmF3U2VydmljZTAuc3Vic2NyaWJlKHJvb3QsIHJ1bjEpXG5cdH1cblx0cm91dGUuc2V0ID0gZnVuY3Rpb24ocGF0aCwgZGF0YSwgb3B0aW9ucykge1xuXHRcdGlmIChsYXN0VXBkYXRlICE9IG51bGwpIHtcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cdFx0XHRvcHRpb25zLnJlcGxhY2UgPSB0cnVlXG5cdFx0fVxuXHRcdGxhc3RVcGRhdGUgPSBudWxsXG5cdFx0cm91dGVTZXJ2aWNlLnNldFBhdGgocGF0aCwgZGF0YSwgb3B0aW9ucylcblx0fVxuXHRyb3V0ZS5nZXQgPSBmdW5jdGlvbigpIHtyZXR1cm4gY3VycmVudFBhdGh9XG5cdHJvdXRlLnByZWZpeCA9IGZ1bmN0aW9uKHByZWZpeDApIHtyb3V0ZVNlcnZpY2UucHJlZml4ID0gcHJlZml4MH1cblx0cm91dGUubGluayA9IGZ1bmN0aW9uKHZub2RlMSkge1xuXHRcdHZub2RlMS5kb20uc2V0QXR0cmlidXRlKFwiaHJlZlwiLCByb3V0ZVNlcnZpY2UucHJlZml4ICsgdm5vZGUxLmF0dHJzLmhyZWYpXG5cdFx0dm5vZGUxLmRvbS5vbmNsaWNrID0gZnVuY3Rpb24oZSkge1xuXHRcdFx0aWYgKGUuY3RybEtleSB8fCBlLm1ldGFLZXkgfHwgZS5zaGlmdEtleSB8fCBlLndoaWNoID09PSAyKSByZXR1cm5cblx0XHRcdGUucHJldmVudERlZmF1bHQoKVxuXHRcdFx0ZS5yZWRyYXcgPSBmYWxzZVxuXHRcdFx0dmFyIGhyZWYgPSB0aGlzLmdldEF0dHJpYnV0ZShcImhyZWZcIilcblx0XHRcdGlmIChocmVmLmluZGV4T2Yocm91dGVTZXJ2aWNlLnByZWZpeCkgPT09IDApIGhyZWYgPSBocmVmLnNsaWNlKHJvdXRlU2VydmljZS5wcmVmaXgubGVuZ3RoKVxuXHRcdFx0cm91dGUuc2V0KGhyZWYsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKVxuXHRcdH1cblx0fVxuXHRyb3V0ZS5wYXJhbSA9IGZ1bmN0aW9uKGtleTMpIHtcblx0XHRpZih0eXBlb2YgYXR0cnMzICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBrZXkzICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gYXR0cnMzW2tleTNdXG5cdFx0cmV0dXJuIGF0dHJzM1xuXHR9XG5cdHJldHVybiByb3V0ZVxufVxubS5yb3V0ZSA9IF8yMCh3aW5kb3csIHJlZHJhd1NlcnZpY2UpXG5tLndpdGhBdHRyID0gZnVuY3Rpb24oYXR0ck5hbWUsIGNhbGxiYWNrMSwgY29udGV4dCkge1xuXHRyZXR1cm4gZnVuY3Rpb24oZSkge1xuXHRcdGNhbGxiYWNrMS5jYWxsKGNvbnRleHQgfHwgdGhpcywgYXR0ck5hbWUgaW4gZS5jdXJyZW50VGFyZ2V0ID8gZS5jdXJyZW50VGFyZ2V0W2F0dHJOYW1lXSA6IGUuY3VycmVudFRhcmdldC5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpKVxuXHR9XG59XG52YXIgXzI4ID0gY29yZVJlbmRlcmVyKHdpbmRvdylcbm0ucmVuZGVyID0gXzI4LnJlbmRlclxubS5yZWRyYXcgPSByZWRyYXdTZXJ2aWNlLnJlZHJhd1xubS5yZXF1ZXN0ID0gcmVxdWVzdFNlcnZpY2UucmVxdWVzdFxubS5qc29ucCA9IHJlcXVlc3RTZXJ2aWNlLmpzb25wXG5tLnBhcnNlUXVlcnlTdHJpbmcgPSBwYXJzZVF1ZXJ5U3RyaW5nXG5tLmJ1aWxkUXVlcnlTdHJpbmcgPSBidWlsZFF1ZXJ5U3RyaW5nXG5tLnZlcnNpb24gPSBcIjEuMS4zXCJcbm0udm5vZGUgPSBWbm9kZVxuaWYgKHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIpIG1vZHVsZVtcImV4cG9ydHNcIl0gPSBtXG5lbHNlIHdpbmRvdy5tID0gbVxufSgpKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbWl0aHJpbC9taXRocmlsLmpzXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n')},function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.setPanelOpen = setPanelOpen;\nexports.togglePanelOpen = togglePanelOpen;\nexports.setPanelCallback = setPanelCallback;\nexports.setPanelOcclusion = setPanelOcclusion;\nexports.scrollBarChanged = scrollBarChanged;\nexports.mergeAttributes = mergeAttributes;\n// Global configuration\n\nvar aboutText = exports.aboutText = 'TwoRavens v0.1 \"Dallas\" -- The Norse god Odin had two talking ravens as advisors, who would fly out into the world and report back all they observed. In the Norse, their names were \"Thought\" and \"Memory\". In our coming release, our thought-raven automatically advises on statistical model selection, while our memory-raven accumulates previous statistical models from Dataverse, to provide cummulative guidance and meta-analysis.';\n\nvar panelMargin = exports.panelMargin = 10; // in pixels\nvar heightHeader = exports.heightHeader = 62;\nvar heightFooter = exports.heightFooter = 40;\n\nvar menuColor = exports.menuColor = '#f9f9f9';\nvar borderColor = exports.borderColor = '1px solid #adadad';\n\n// initial color scale used to establish the initial colors of nodes\n// allNodes.push() below establishes a field for the master node array allNodes called \"nodeCol\" and assigns a color from this scale to that field\n// everything there after should refer to the nodeCol and not the color scale, this enables us to update colors and pass the variable type to R based on its coloring\nvar colors = exports.colors = d3.scale.category20();\nvar csColor = exports.csColor = '#419641';\nvar dvColor = exports.dvColor = '#28a4c9';\nvar gr1Color = exports.gr1Color = '#14bdcc'; // initially was #24a4c9', but that is dvColor, and we track some properties by color assuming them unique\nvar gr1Opacity = exports.gr1Opacity = [0, 1];\nvar gr2Color = exports.gr2Color = '#ffcccc';\nvar gr2Opacity = exports.gr2Opacity = [0, 1];\n\nvar grayColor = exports.grayColor = '#c0c0c0';\nvar nomColor = exports.nomColor = '#ff6600';\nvar varColor = exports.varColor = '#f0f8ff'; // d3.rgb(\"aliceblue\");\nvar taggedColor = exports.taggedColor = '#f5f5f5'; // d3.rgb(\"whitesmoke\");\nvar timeColor = exports.timeColor = '#2d6ca2';\n\nvar d3Color = exports.d3Color = '#1f77b4'; // d3's default blue\nvar selVarColor = exports.selVarColor = '#fa8072'; // d3.rgb(\"salmon\");\n\n// Global features\n\n// stores all functions to be called on window resize\nvar onResize = exports.onResize = [];\nvar callOnResize = exports.callOnResize = function callOnResize(resize) {\n    return onResize.push(resize);\n};\nwindow.onresize = function () {\n    return onResize.map(function (resize) {\n        return resize();\n    });\n};\n\nvar panelOpen = exports.panelOpen = {\n    'left': true,\n    'right': true\n};\n\n// If you invoke from outside a mithril context, run m.redraw() to trigger the visual update\nfunction setPanelOpen(side) {\n    var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    panelOpen[side] = state;\n    panelCallback[side](state);\n}\n\nfunction togglePanelOpen(side) {\n    panelOpen[side] = !panelOpen[side];\n    panelCallback[side](panelOpen[side]);\n}\n\n// Optionally trigger callback after setting panel state (but before redraw)\nvar panelCallback = exports.panelCallback = {\n    'left': Function,\n    'right': Function\n};\nfunction setPanelCallback(side, callback) {\n    panelCallback[side] = callback;\n}\n\n// Number of pixels occluded by the panels. Left at zero if panels are hovering\nvar panelOcclusion = exports.panelOcclusion = {\n    'left': 0,\n    'right': 0\n};\nfunction setPanelOcclusion(side, state) {\n    panelOcclusion[side] = state;\n}\n\nvar scrollbarWidth = exports.scrollbarWidth = getScrollbarWidth();\nvar canvasScroll = exports.canvasScroll = {\n    vertical: false,\n    horizontal: false\n};\n\n// If scroll bar has been added or removed from canvas, update state and return true.\nfunction scrollBarChanged() {\n    var canvas = document.getElementById('canvas');\n    if (canvas === null) return false;\n\n    var newState = {\n        vertical: canvas.scrollHeight > canvas.clientHeight,\n        horizontal: canvas.scrollWidth > canvas.clientWidth\n    };\n\n    if (newState['vertical'] !== canvasScroll['vertical'] || newState['horizontal'] !== canvasScroll['horizontal']) {\n        exports.canvasScroll = canvasScroll = newState;\n        return true;\n    } else return false;\n}\n\n// Merge arrays and objects up to one layer deep\nfunction mergeAttributes(target) {\n    for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        sources[_key - 1] = arguments[_key];\n    }\n\n    if (!sources.length) return target;\n    var source = sources.shift();\n\n    for (var key in source) {\n        if (Array.isArray(source[key]) && Array.isArray(target[key])) target[key].concat(source[key]);else if (_typeof(target[key]) === 'object' && _typeof(source[key]) === 'object') Object.assign(target[key], source[key]);else target[key] = source[key];\n    }\n    return mergeAttributes.apply(undefined, [target].concat(sources));\n}\n\n// https://stackoverflow.com/a/13382873\nfunction getScrollbarWidth() {\n    var outer = document.createElement(\"div\");\n    outer.style.visibility = \"hidden\";\n    outer.style.width = \"100px\";\n    outer.style.msOverflowStyle = \"scrollbar\"; // needed for WinJS apps\n\n    document.body.appendChild(outer);\n\n    var widthNoScroll = outer.offsetWidth;\n    // force scrollbars\n    outer.style.overflow = \"scroll\";\n\n    // add innerdiv\n    var inner = document.createElement(\"div\");\n    inner.style.width = \"100%\";\n    outer.appendChild(inner);\n\n    var widthWithScroll = inner.offsetWidth;\n\n    // remove divs\n    outer.parentNode.removeChild(outer);\n\n    return widthNoScroll - widthWithScroll;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvY29tbW9uL2FwcC9jb21tb24uanM/OGQzMiJdLCJuYW1lcyI6WyJzZXRQYW5lbE9wZW4iLCJ0b2dnbGVQYW5lbE9wZW4iLCJzZXRQYW5lbENhbGxiYWNrIiwic2V0UGFuZWxPY2NsdXNpb24iLCJzY3JvbGxCYXJDaGFuZ2VkIiwibWVyZ2VBdHRyaWJ1dGVzIiwiYWJvdXRUZXh0IiwicGFuZWxNYXJnaW4iLCJoZWlnaHRIZWFkZXIiLCJoZWlnaHRGb290ZXIiLCJtZW51Q29sb3IiLCJib3JkZXJDb2xvciIsImNvbG9ycyIsImQzIiwic2NhbGUiLCJjYXRlZ29yeTIwIiwiY3NDb2xvciIsImR2Q29sb3IiLCJncjFDb2xvciIsImdyMU9wYWNpdHkiLCJncjJDb2xvciIsImdyMk9wYWNpdHkiLCJncmF5Q29sb3IiLCJub21Db2xvciIsInZhckNvbG9yIiwidGFnZ2VkQ29sb3IiLCJ0aW1lQ29sb3IiLCJkM0NvbG9yIiwic2VsVmFyQ29sb3IiLCJvblJlc2l6ZSIsImNhbGxPblJlc2l6ZSIsInJlc2l6ZSIsInB1c2giLCJ3aW5kb3ciLCJvbnJlc2l6ZSIsIm1hcCIsInBhbmVsT3BlbiIsInNpZGUiLCJzdGF0ZSIsInBhbmVsQ2FsbGJhY2siLCJGdW5jdGlvbiIsImNhbGxiYWNrIiwicGFuZWxPY2NsdXNpb24iLCJzY3JvbGxiYXJXaWR0aCIsImdldFNjcm9sbGJhcldpZHRoIiwiY2FudmFzU2Nyb2xsIiwidmVydGljYWwiLCJob3Jpem9udGFsIiwiY2FudmFzIiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsIm5ld1N0YXRlIiwic2Nyb2xsSGVpZ2h0IiwiY2xpZW50SGVpZ2h0Iiwic2Nyb2xsV2lkdGgiLCJjbGllbnRXaWR0aCIsInRhcmdldCIsInNvdXJjZXMiLCJsZW5ndGgiLCJzb3VyY2UiLCJzaGlmdCIsImtleSIsIkFycmF5IiwiaXNBcnJheSIsImNvbmNhdCIsIk9iamVjdCIsImFzc2lnbiIsIm91dGVyIiwiY3JlYXRlRWxlbWVudCIsInN0eWxlIiwidmlzaWJpbGl0eSIsIndpZHRoIiwibXNPdmVyZmxvd1N0eWxlIiwiYm9keSIsImFwcGVuZENoaWxkIiwid2lkdGhOb1Njcm9sbCIsIm9mZnNldFdpZHRoIiwib3ZlcmZsb3ciLCJpbm5lciIsIndpZHRoV2l0aFNjcm9sbCIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7UUE0Q2dCQSxZLEdBQUFBLFk7UUFLQUMsZSxHQUFBQSxlO1FBVUFDLGdCLEdBQUFBLGdCO1FBT0FDLGlCLEdBQUFBLGlCO1FBU0FDLGdCLEdBQUFBLGdCO1FBZ0JBQyxlLEdBQUFBLGU7QUEzRmhCOztBQUVPLElBQUlDLGdDQUFZLCthQUFoQjs7QUFFQSxJQUFJQyxvQ0FBYyxFQUFsQixDLENBQXVCO0FBQ3ZCLElBQUlDLHNDQUFlLEVBQW5CO0FBQ0EsSUFBSUMsc0NBQWUsRUFBbkI7O0FBRUEsSUFBSUMsZ0NBQVksU0FBaEI7QUFDQSxJQUFJQyxvQ0FBYyxtQkFBbEI7O0FBRVA7QUFDQTtBQUNBO0FBQ08sSUFBSUMsMEJBQVNDLEdBQUdDLEtBQUgsQ0FBU0MsVUFBVCxFQUFiO0FBQ0EsSUFBSUMsNEJBQVUsU0FBZDtBQUNBLElBQUlDLDRCQUFVLFNBQWQ7QUFDQSxJQUFJQyw4QkFBVyxTQUFmLEMsQ0FBMkI7QUFDM0IsSUFBSUMsa0NBQWEsQ0FBQyxDQUFELEVBQUcsQ0FBSCxDQUFqQjtBQUNBLElBQUlDLDhCQUFXLFNBQWY7QUFDQSxJQUFJQyxrQ0FBYSxDQUFDLENBQUQsRUFBRyxDQUFILENBQWpCOztBQUVBLElBQUlDLGdDQUFZLFNBQWhCO0FBQ0EsSUFBSUMsOEJBQVcsU0FBZjtBQUNBLElBQUlDLDhCQUFXLFNBQWYsQyxDQUEwQjtBQUMxQixJQUFJQyxvQ0FBYyxTQUFsQixDLENBQTZCO0FBQzdCLElBQUlDLGdDQUFZLFNBQWhCOztBQUVBLElBQUlDLDRCQUFVLFNBQWQsQyxDQUF5QjtBQUN6QixJQUFJQyxvQ0FBYyxTQUFsQixDLENBQTZCOztB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QUEyQkYsT0FBT0UsR0FBUCxDQUEzQixFQURDLEtBR0FMLE9BQU9LLEdBQVAsSUFBY0YsT0FBT0UsR0FBUCxDQUFkO0FBQ1I7QUFDRCxXQUFPeEQsa0NBQWdCbUQsTUFBaEIsU0FBMkJDLE9BQTNCLEVBQVA7QUFDSDs7QUFFRDtBQUNBLFNBQVNiLGlCQUFULEdBQTZCO0FBQ3pCLFFBQUl1QixRQUFRbEIsU0FBU21CLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBWjtBQUNBRCxVQUFNRSxLQUFOLENBQVlDLFVBQVosR0FBeUIsUUFBekI7QUFDQUgsVUFBTUUsS0FBTixDQUFZRSxLQUFaLEdBQW9CLE9BQXBCO0FBQ0FKLFVBQU1FLEtBQU4sQ0FBWUcsZUFBWixHQUE4QixXQUE5QixDQUp5QixDQUlrQjs7QUFFM0N2QixhQUFTd0IsSUFBVCxDQUFjQyxXQUFkLENBQTBCUCxLQUExQjs7QUFFQSxRQUFJUSxnQkFBZ0JSLE1BQU1TLFdBQTFCO0FBQ0E7QUFDQVQsVUFBTUUsS0FBTixDQUFZUSxRQUFaLEdBQXVCLFFBQXZCOztBQUVBO0FBQ0EsUUFBSUMsUUFBUTdCLFNBQVNtQixhQUFULENBQXVCLEtBQXZCLENBQVo7QUFDQVUsVUFBTVQsS0FBTixDQUFZRSxLQUFaLEdBQW9CLE1BQXBCO0FBQ0FKLFVBQU1PLFdBQU4sQ0FBa0JJLEtBQWxCOztBQUVBLFFBQUlDLGtCQUFrQkQsTUFBTUYsV0FBNUI7O0FBRUE7QUFDQVQsVUFBTWEsVUFBTixDQUFpQkMsV0FBakIsQ0FBNkJkLEtBQTdCOztBQUVBLFdBQU9RLGdCQUFnQkksZUFBdkI7QUFDSCIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gR2xvYmFsIGNvbmZpZ3VyYXRpb25cblxuZXhwb3J0IGxldCBhYm91dFRleHQgPSAnVHdvUmF2ZW5zIHYwLjEgXCJEYWxsYXNcIiAtLSBUaGUgTm9yc2UgZ29kIE9kaW4gaGFkIHR3byB0YWxraW5nIHJhdmVucyBhcyBhZHZpc29ycywgd2hvIHdvdWxkIGZseSBvdXQgaW50byB0aGUgd29ybGQgYW5kIHJlcG9ydCBiYWNrIGFsbCB0aGV5IG9ic2VydmVkLiBJbiB0aGUgTm9yc2UsIHRoZWlyIG5hbWVzIHdlcmUgXCJUaG91Z2h0XCIgYW5kIFwiTWVtb3J5XCIuIEluIG91ciBjb21pbmcgcmVsZWFzZSwgb3VyIHRob3VnaHQtcmF2ZW4gYXV0b21hdGljYWxseSBhZHZpc2VzIG9uIHN0YXRpc3RpY2FsIG1vZGVsIHNlbGVjdGlvbiwgd2hpbGUgb3VyIG1lbW9yeS1yYXZlbiBhY2N1bXVsYXRlcyBwcmV2aW91cyBzdGF0aXN0aWNhbCBtb2RlbHMgZnJvbSBEYXRhdmVyc2UsIHRvIHByb3ZpZGUgY3VtbXVsYXRpdmUgZ3VpZGFuY2UgYW5kIG1ldGEtYW5hbHlzaXMuJztcblxuZXhwb3J0IGxldCBwYW5lbE1hcmdpbiA9IDEwOyAgLy8gaW4gcGl4ZWxzXG5leHBvcnQgbGV0IGhlaWdodEhlYWRlciA9IDYyO1xuZXhwb3J0IGxldCBoZWlnaHRGb290ZXIgPSA0MDtcblxuZXhwb3J0IGxldCBtZW51Q29sb3IgPSAnI2Y5ZjlmOSc7XG5leHBvcnQgbGV0IGJvcmRlckNvbG9yID0gJzFweCBzb2xpZCAjYWRhZGFkJztcblxuLy8gaW5pdGlhbCBjb2xvciBzY2FsZSB1c2VkIHRvIGVzdGFibGlzaCB0aGUgaW5pdGlhbCBjb2xvcnMgb2Ygbm9kZXNcbi8vIGFsbE5vZGVzLnB1c2goKSBiZWxvdyBlc3RhYmxpc2hlcyBhIGZpZWxkIGZvciB0aGUgbWFzdGVyIG5vZGUgYXJyYXkgYWxsTm9kZXMgY2FsbGVkIFwibm9kZUNvbFwiIGFuZCBhc3NpZ25zIGEgY29sb3IgZnJvbSB0aGlzIHNjYWxlIHRvIHRoYXQgZmllbGRcbi8vIGV2ZXJ5dGhpbmcgdGhlcmUgYWZ0ZXIgc2hvdWxkIHJlZmVyIHRvIHRoZSBub2RlQ29sIGFuZCBub3QgdGhlIGNvbG9yIHNjYWxlLCB0aGlzIGVuYWJsZXMgdXMgdG8gdXBkYXRlIGNvbG9ycyBhbmQgcGFzcyB0aGUgdmFyaWFibGUgdHlwZSB0byBSIGJhc2VkIG9uIGl0cyBjb2xvcmluZ1xuZXhwb3J0IGxldCBjb2xvcnMgPSBkMy5zY2FsZS5jYXRlZ29yeTIwKCk7XG5leHBvcnQgbGV0IGNzQ29sb3IgPSAnIzQxOTY0MSc7XG5leHBvcnQgbGV0IGR2Q29sb3IgPSAnIzI4YTRjOSc7XG5leHBvcnQgbGV0IGdyMUNvbG9yID0gJyMxNGJkY2MnOyAgLy8gaW5pdGlhbGx5IHdhcyAjMjRhNGM5JywgYnV0IHRoYXQgaXMgZHZDb2xvciwgYW5kIHdlIHRyYWNrIHNvbWUgcHJvcGVydGllcyBieSBjb2xvciBhc3N1bWluZyB0aGVtIHVuaXF1ZVxuZXhwb3J0IGxldCBncjFPcGFjaXR5ID0gWzAsMV07XG5leHBvcnQgbGV0IGdyMkNvbG9yID0gJyNmZmNjY2MnO1xuZXhwb3J0IGxldCBncjJPcGFjaXR5ID0gWzAsMV07XG5cbmV4cG9ydCBsZXQgZ3JheUNvbG9yID0gJyNjMGMwYzAnO1xuZXhwb3J0IGxldCBub21Db2xvciA9ICcjZmY2NjAwJztcbmV4cG9ydCBsZXQgdmFyQ29sb3IgPSAnI2YwZjhmZic7IC8vIGQzLnJnYihcImFsaWNlYmx1ZVwiKTtcbmV4cG9ydCBsZXQgdGFnZ2VkQ29sb3IgPSAnI2Y1ZjVmNSc7IC8vIGQzLnJnYihcIndoaXRlc21va2VcIik7XG5leHBvcnQgbGV0IHRpbWVDb2xvciA9ICcjMmQ2Y2EyJztcblxuZXhwb3J0IGxldCBkM0NvbG9yID0gJyMxZjc3YjQnOyAvLyBkMydzIGRlZmF1bHQgYmx1ZVxuZXhwb3J0IGxldCBzZWxWYXJDb2xvciA9ICcjZmE4MDcyJzsgLy8gZDMucmdiKFwic2FsbW9uXCIpO1xuXG4vLyBHbG9iYWwgZmVhdHVyZXNcblxuLy8gc3RvcmVzIGFsbCBmdW5jdGlvbnMgdG8gYmUgY2FsbGVkIG9uIHdpbmRvdyByZXNpemVcbmV4cG9ydCBsZXQgb25SZXNpemUgPSBbXTtcbmV4cG9ydCBsZXQgY2FsbE9uUmVzaXplID0gKHJlc2l6ZSkgPT4gb25SZXNpemUucHVzaChyZXNpemUpO1xud2luZG93Lm9ucmVzaXplID0gKCkgPT4gb25SZXNpemUubWFwKChyZXNpemUpID0+IHJlc2l6ZSgpKTtcblxuZXhwb3J0IGxldCBwYW5lbE9wZW4gPSB7XG4gICAgJ2xlZnQnOiB0cnVlLFxuICAgICdyaWdodCc6IHRydWVcbn07XG5cbi8vIElmIHlvdSBpbnZva2UgZnJvbSBvdXRzaWRlIGEgbWl0aHJpbCBjb250ZXh0LCBydW4gbS5yZWRyYXcoKSB0byB0cmlnZ2VyIHRoZSB2aXN1YWwgdXBkYXRlXG5leHBvcnQgZnVuY3Rpb24gc2V0UGFuZWxPcGVuKHNpZGUsIHN0YXRlPXRydWUpIHtcbiAgICBwYW5lbE9wZW5bc2lkZV0gPSBzdGF0ZTtcbiAgICBwYW5lbENhbGxiYWNrW3NpZGVdKHN0YXRlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvZ2dsZVBhbmVsT3BlbihzaWRlKSB7XG4gICAgcGFuZWxPcGVuW3NpZGVdID0gIXBhbmVsT3BlbltzaWRlXTtcbiAgICBwYW5lbENhbGxiYWNrW3NpZGVdKHBhbmVsT3BlbltzaWRlXSlcbn1cblxuLy8gT3B0aW9uYWxseSB0cmlnZ2VyIGNhbGxiYWNrIGFmdGVyIHNldHRpbmcgcGFuZWwgc3RhdGUgKGJ1dCBiZWZvcmUgcmVkcmF3KVxuZXhwb3J0IGxldCBwYW5lbENhbGxiYWNrID0ge1xuICAgICdsZWZ0JzogRnVuY3Rpb24sXG4gICAgJ3JpZ2h0JzogRnVuY3Rpb25cbn07XG5leHBvcnQgZnVuY3Rpb24gc2V0UGFuZWxDYWxsYmFjayhzaWRlLCBjYWxsYmFjaykge3BhbmVsQ2FsbGJhY2tbc2lkZV0gPSBjYWxsYmFja31cblxuLy8gTnVtYmVyIG9mIHBpeGVscyBvY2NsdWRlZCBieSB0aGUgcGFuZWxzLiBMZWZ0IGF0IHplcm8gaWYgcGFuZWxzIGFyZSBob3ZlcmluZ1xuZXhwb3J0IGxldCBwYW5lbE9jY2x1c2lvbiA9IHtcbiAgICAnbGVmdCc6IDAsXG4gICAgJ3JpZ2h0JzogMFxufTtcbmV4cG9ydCBmdW5jdGlvbiBzZXRQYW5lbE9jY2x1c2lvbihzaWRlLCBzdGF0ZSkge3BhbmVsT2NjbHVzaW9uW3NpZGVdID0gc3RhdGV9XG5cbmV4cG9ydCBjb25zdCBzY3JvbGxiYXJXaWR0aCA9IGdldFNjcm9sbGJhcldpZHRoKCk7XG5leHBvcnQgbGV0IGNhbnZhc1Njcm9sbCA9IHtcbiAgICB2ZXJ0aWNhbDogZmFsc2UsXG4gICAgaG9yaXpvbnRhbDogZmFsc2Vcbn07XG5cbi8vIElmIHNjcm9sbCBiYXIgaGFzIGJlZW4gYWRkZWQgb3IgcmVtb3ZlZCBmcm9tIGNhbnZhcywgdXBkYXRlIHN0YXRlIGFuZCByZXR1cm4gdHJ1ZS5cbmV4cG9ydCBmdW5jdGlvbiBzY3JvbGxCYXJDaGFuZ2VkKCkge1xuICAgIGxldCBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2FudmFzJyk7XG4gICAgaWYgKGNhbnZhcyA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgbGV0IG5ld1N0YXRlID0ge1xuICAgICAgICB2ZXJ0aWNhbDogY2FudmFzLnNjcm9sbEhlaWdodCA+IGNhbnZhcy5jbGllbnRIZWlnaHQsXG4gICAgICAgIGhvcml6b250YWw6IGNhbnZhcy5zY3JvbGxXaWR0aCA+IGNhbnZhcy5jbGllbnRXaWR0aFxuICAgIH07XG5cbiAgICBpZiAobmV3U3RhdGVbJ3ZlcnRpY2FsJ10gIT09IGNhbnZhc1Njcm9sbFsndmVydGljYWwnXSB8fCBuZXdTdGF0ZVsnaG9yaXpvbnRhbCddICE9PSBjYW52YXNTY3JvbGxbJ2hvcml6b250YWwnXSkge1xuICAgICAgICBjYW52YXNTY3JvbGwgPSBuZXdTdGF0ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHJldHVybiBmYWxzZTtcbn1cblxuLy8gTWVyZ2UgYXJyYXlzIGFuZCBvYmplY3RzIHVwIHRvIG9uZSBsYXllciBkZWVwXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VBdHRyaWJ1dGVzKHRhcmdldCwgLi4uc291cmNlcykge1xuICAgIGlmICghc291cmNlcy5sZW5ndGgpIHJldHVybiB0YXJnZXQ7XG4gICAgY29uc3Qgc291cmNlID0gc291cmNlcy5zaGlmdCgpO1xuXG4gICAgZm9yIChjb25zdCBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZVtrZXldKSAmJiBBcnJheS5pc0FycmF5KHRhcmdldFtrZXldKSlcbiAgICAgICAgICAgIHRhcmdldFtrZXldLmNvbmNhdChzb3VyY2Vba2V5XSk7XG5cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHRhcmdldFtrZXldID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygc291cmNlW2tleV0gPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0YXJnZXRba2V5XSwgc291cmNlW2tleV0pO1xuXG4gICAgICAgIGVsc2UgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlQXR0cmlidXRlcyh0YXJnZXQsIC4uLnNvdXJjZXMpO1xufVxuXG4vLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTMzODI4NzNcbmZ1bmN0aW9uIGdldFNjcm9sbGJhcldpZHRoKCkge1xuICAgIGxldCBvdXRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgb3V0ZXIuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gICAgb3V0ZXIuc3R5bGUud2lkdGggPSBcIjEwMHB4XCI7XG4gICAgb3V0ZXIuc3R5bGUubXNPdmVyZmxvd1N0eWxlID0gXCJzY3JvbGxiYXJcIjsgLy8gbmVlZGVkIGZvciBXaW5KUyBhcHBzXG5cbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG91dGVyKTtcblxuICAgIGxldCB3aWR0aE5vU2Nyb2xsID0gb3V0ZXIub2Zmc2V0V2lkdGg7XG4gICAgLy8gZm9yY2Ugc2Nyb2xsYmFyc1xuICAgIG91dGVyLnN0eWxlLm92ZXJmbG93ID0gXCJzY3JvbGxcIjtcblxuICAgIC8vIGFkZCBpbm5lcmRpdlxuICAgIGxldCBpbm5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgaW5uZXIuc3R5bGUud2lkdGggPSBcIjEwMCVcIjtcbiAgICBvdXRlci5hcHBlbmRDaGlsZChpbm5lcik7XG5cbiAgICBsZXQgd2lkdGhXaXRoU2Nyb2xsID0gaW5uZXIub2Zmc2V0V2lkdGg7XG5cbiAgICAvLyByZW1vdmUgZGl2c1xuICAgIG91dGVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQob3V0ZXIpO1xuXG4gICAgcmV0dXJuIHdpZHRoTm9TY3JvbGwgLSB3aWR0aFdpdGhTY3JvbGw7XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYXNzZXRzL2NvbW1vbi9hcHAvY29tbW9uLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1\n")},function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\nexports.setCheckedDiscoveryProblem = exports.checkedDiscoveryProblems = exports.setSelectedProblem = exports.selectedProblem = exports.probtable = exports.hexToRgba = exports.popoverContent = exports.summary = exports.setLeftTab = exports.pipelineTable = exports.pipelineHeader = exports.setSelectedPipeline = exports.selectedPipeline = exports.lockDescription = exports.searchVariables = exports.matchedVariables = exports.lockTour = exports.mytour3 = exports.mytour = exports.step = exports.restart = exports.reset = exports.byId = exports.arc4 = exports.arc3 = exports.arc2 = exports.arc1 = exports.arc0 = exports.discoveryLadda = exports.estimateLadda = exports.height = exports.width = exports.setD3mProblemDescription = exports.d3mProblemDescription = exports.d3mMetrics = exports.d3mTaskSubtype = exports.d3mTaskType = exports.domainIdentifier = exports.configurations = exports.callHistory = exports.links = exports.nodes = exports.allResults = exports.allNodes = exports.valueKey = exports.modelCount = exports.disco = exports.zparams = exports.logArray = exports.allPipelineInfo = exports.swandive = exports.locktoggle = exports.forcetoggle = exports.myspace = exports.RADIUS = exports.transformList = exports.panelWidth = exports.setRightTabExplore = exports.setRightTab = exports.exploreRightPanelWidths = exports.modelRightPanelWidths = exports.modelLeftPanelWidths = exports.rightTabExplore = exports.rightTab = exports.summaryHold = exports.subset = exports.leftTabHidden = exports.leftTab = exports.timeColor = exports.varColor = exports.nomColor = exports.gr2Color = exports.gr1Color = exports.dvColor = exports.csColor = exports.k = exports.cdb = exports.currentMode = exports.univariate_finished = exports.task2_finished = exports.task1_finished = exports.marginLeftCarousel = exports.marginTopCarousel = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();\n\nvar _arguments = arguments;\nexports.set_mode = set_mode;\nexports.main = main;\nexports.setup_svg = setup_svg;\nexports.layout = layout;\nexports.findNodeIndex = findNodeIndex;\nexports.findNode = findNode;\nexports.clickVar = clickVar;\nexports.getVariableData = getVariableData;\nexports.forceSwitch = forceSwitch;\nexports.helpmaterials = helpmaterials;\nexports.zPop = zPop;\nexports.downloadIncomplete = downloadIncomplete;\nexports.estimate = estimate;\nexports.ta2stuff = ta2stuff;\nexports.makeRequest = makeRequest;\nexports.legend = legend;\nexports.erase = erase;\nexports.panelPlots = panelPlots;\nexports.borderState = borderState;\nexports.subsetSelect = subsetSelect;\nexports.fakeClick = fakeClick;\nexports.endsession = endsession;\nexports.deletepipelines = deletepipelines;\nexports.cancelpipelines = cancelpipelines;\nexports.listpipelines = listpipelines;\nexports.executepipeline = executepipeline;\nexports.setPebbleRadius = setPebbleRadius;\nexports.resultsplotinit = resultsplotinit;\nexports.genconfdata = genconfdata;\nexports.confusionmatrix = confusionmatrix;\nexports.bivariatePlot = bivariatePlot;\nexports.setxTable = setxTable;\nexports.exportpipeline = exportpipeline;\nexports.deletepipeline = deletepipeline;\nexports.ta3_search_message = ta3_search_message;\nexports.test_msg_ta3_search = test_msg_ta3_search;\nexports.end_ta3_search = end_ta3_search;\nexports.record_user_metadata = record_user_metadata;\nexports.showPredPlot = showPredPlot;\nexports.showGenPreds = showGenPreds;\nexports.discovery = discovery;\nexports.submitDiscProb = submitDiscProb;\nexports.saveDisc = saveDisc;\n\nvar _hopscotch = __webpack_require__(12);\n\nvar _hopscotch2 = _interopRequireDefault(_hopscotch);\n\nvar _mithril = __webpack_require__(0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _common = __webpack_require__(1);\n\nvar common = _interopRequireWildcard(_common);\n\nvar _Modal = __webpack_require__(10);\n\nvar _plots = __webpack_require__(4);\n\nvar _utils = __webpack_require__(3);\n\nvar _Search = __webpack_require__(5);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// hostname default - the app will use it to obtain the variable metadata\n// (ddi) and pre-processed data info if the file id is supplied as an\n// argument (for ex., gui.html?dfId=17), but hostname isn\'t.\n// Edit it to suit your installation.\n// (NOTE that if the file id isn\'t supplied, the app will default to the\n// local files specified below!)\n// NEW: it is also possible now to supply complete urls for the ddi and\n// the tab-delimited data file; the parameters are ddiurl and dataurl.\n// These new parameters are optional. If they are not supplied, the app\n// will go the old route - will try to cook standard dataverse urls\n// for both the data and metadata, if the file id is supplied; or the\n// local files if nothing is supplied.\n\n//-------------------------------------------------\n// NOTE: global variables are now set in the index.html file.\n//    Developers, see /template/index.html\n//-------------------------------------------------\n\nvar marginTopCarousel = exports.marginTopCarousel = 0;\nvar marginLeftCarousel = exports.marginLeftCarousel = 0;\n\nwindow.onresize = function () {\n    if (_mithril2.default.route.get() === \'/data\') {\n        return;\n    }\n\n    var carousel = (0, _utils.elem)(\'#innercarousel\');\n    var container = (0, _utils.elem)(\'#m0\');\n    var whitespace = (0, _utils.elem)(\'#whitespace0\');\n\n    exports.marginTopCarousel = marginTopCarousel = (carousel.offsetHeight - whitespace.getAttribute("height") - 16) / 2;\n    exports.marginLeftCarousel = marginLeftCarousel = (carousel.offsetWidth - whitespace.getAttribute("width")) / 2;\n\n    container.style.marginTop = marginTopCarousel + \'px\';\n    container.style.marginLeft = marginLeftCarousel + \'px\';\n    container.style.height = \'calc(100% + \' + Math.abs(marginTopCarousel) + \'px)\';\n};\n\nvar peekBatchSize = 100;\nvar peekSkip = 0;\nvar peekData = [];\n\nvar peekAllDataReceived = false;\nvar peekIsGetting = false;\n\nfunction onStorageEvent(e) {\n    if (e.key !== \'peekMore\' || peekIsGetting) return;\n\n    if (localStorage.getItem(\'peekMore\') === \'true\' && !peekAllDataReceived) {\n        localStorage.setItem(\'peekMore\', \'false\');\n        peekIsGetting = true;\n        updatePeek();\n    }\n}\n\nwindow.addEventListener(\'storage\', onStorageEvent);\n\nfunction updatePeek() {\n    _mithril2.default.request(\'rook-custom/rook-files/\' + configurations.name + \'/data/trainData.tsv\', {\n        deserialize: function deserialize(x) {\n            return x.split(\'\\n\').map(function (y) {\n                return y.split(\'\\t\');\n            });\n        }\n    }).then(function (data) {\n        // simulate only loading some of the data... by just deleting all the other data\n        var headers = data[0].map(function (x) {\n            return x.replace(/"/g, \'\');\n        });\n        var newData = data.slice(peekSkip + 1, peekSkip + 1 + peekBatchSize);\n\n        // stop blocking new requests\n        peekIsGetting = false;\n\n        // start blocking new requests until peekReset() is called\n        if (newData.length === 0) peekAllDataReceived = true;\n\n        peekData = peekData.concat(newData);\n        peekSkip += newData.length;\n\n        localStorage.setItem(\'peekTableHeaders\', JSON.stringify(headers));\n        localStorage.setItem(\'peekTableData\', JSON.stringify(peekData));\n    });\n}\n\nfunction resetPeek() {\n    peekSkip = 0;\n    peekData = [];\n\n    peekAllDataReceived = false;\n    peekIsGetting = false;\n\n    // provoke a redraw from the peek menu\n    localStorage.removeItem(\'peekTableData\');\n}\n\nresetPeek();\n\nvar task1_finished = exports.task1_finished = false;\nvar task2_finished = exports.task2_finished = false;\nvar univariate_finished = exports.univariate_finished = false;\n\nvar currentMode = exports.currentMode = \'model\';\nvar is_explore_mode = false;\nvar is_results_mode = false;\n\nfunction set_mode(mode) {\n    if (!mode) mode = \'model\';\n    mode = mode.toLowerCase();\n\n    if (currentMode !== mode) {\n        updateRightPanelWidth();\n        updateLeftPanelWidth();\n\n        exports.currentMode = currentMode = mode;\n        _mithril2.default.route.set(\'/\' + mode.toLowerCase());\n    }\n\n    is_explore_mode = mode === \'explore\';\n    is_results_mode = mode === \'results\';\n}\n\n// for debugging - if not in PRODUCTION, prints args\nvar cdb = exports.cdb = function cdb(_) {\n    var _console;\n\n    return PRODUCTION || (_console = console).log.apply(_console, _arguments);\n};\n\nvar k = exports.k = 4; // strength parameter for group attraction/repulsion\nvar tutorial_mode = localStorage.getItem(\'tutorial_mode\') !== \'false\';\n\n// initial color scale used to establish the initial colors of nodes\n// allNodes.push() below establishes a field for the master node array allNodes called "nodeCol" and assigns a color from this scale to that field\n// everything there after should refer to the nodeCol and not the color scale, this enables us to update colors and pass the variable type to R based on its coloring\nvar colors = d3.scale.category20();\nvar csColor = exports.csColor = \'#419641\';\nvar dvColor = exports.dvColor = \'#28a4c9\';\nvar gr1Color = exports.gr1Color = \'#14bdcc\'; // initially was #24a4c9\', but that is dvColor, and we track some properties by color assuming them unique\nvar gr1Opacity = [0, 1];\nvar gr2Color = exports.gr2Color = \'#ffcccc\';\nvar gr2Opacity = [0, 1];\n\nvar grayColor = \'#c0c0c0\';\nvar nomColor = exports.nomColor = \'#ff6600\';\nvar varColor = exports.varColor = \'#f0f8ff\'; // d3.rgb("aliceblue");\nvar taggedColor = \'#f5f5f5\'; // d3.rgb("whitesmoke");\nvar timeColor = exports.timeColor = \'#2d6ca2\';\n\nvar leftTab = exports.leftTab = \'Variables\'; // current tab in left panel\nvar leftTabHidden = exports.leftTabHidden = \'Variables\'; // stores the tab user was in before summary hover\nvar subset = exports.subset = false;\nvar summaryHold = exports.summaryHold = false;\n\nvar rightTab = exports.rightTab = \'Task Type\'; // current tab in right panel\nvar rightTabExplore = exports.rightTabExplore = \'Univariate\';\n\nvar modelLeftPanelWidths = exports.modelLeftPanelWidths = {\n    \'Variables\': \'300px\',\n    \'Discovery\': \'auto\',\n    \'Summary\': \'300px\'\n};\n\nvar modelRightPanelWidths = exports.modelRightPanelWidths = {\n    \'Models\': \'300px\',\n    \'Task Type\': \'300px\',\n    \'Subtype\': \'300px\',\n    \'Metrics\': \'300px\',\n    //     \'Set Covar.\': \'900px\',\n    \'Results\': \'900px\'\n};\n\nvar exploreRightPanelWidths = exports.exploreRightPanelWidths = {\n    \'Univariate\': \'700px\',\n    \'Bivariate\': \'75%\'\n};\n\nvar setRightTab = exports.setRightTab = function setRightTab(tab) {\n    exports.rightTab = rightTab = tab;updateRightPanelWidth();\n};\nvar setRightTabExplore = exports.setRightTabExplore = function setRightTabExplore(tab) {\n    exports.rightTabExplore = rightTabExplore = tab;updateRightPanelWidth();\n};\n\n// panelWidth is meant to be read only\nvar panelWidth = exports.panelWidth = {\n    \'left\': \'0\',\n    \'right\': \'0\'\n};\n\nvar updateRightPanelWidth = function updateRightPanelWidth() {\n    if (common.panelOpen[\'right\']) {\n        var tempWidth = {\n            \'model\': modelRightPanelWidths[rightTab],\n            \'explore\': exploreRightPanelWidths[rightTabExplore]\n        }[currentMode];\n\n        panelWidth[\'right\'] = \'calc(\' + common.panelMargin * 2 + \'px + \' + tempWidth + \')\';\n    } else panelWidth[\'right\'] = \'calc(\' + common.panelMargin * 2 + \'px + 16px)\';\n};\nvar updateLeftPanelWidth = function updateLeftPanelWidth() {\n    if (common.panelOpen[\'left\']) panelWidth[\'left\'] = \'calc(\' + common.panelMargin * 2 + \'px + \' + modelLeftPanelWidths[leftTab] + \')\';else panelWidth[\'left\'] = \'calc(\' + common.panelMargin * 2 + \'px + 16px)\';\n};\n\nupdateRightPanelWidth();\nupdateLeftPanelWidth();\n\ncommon.setPanelCallback(\'right\', updateRightPanelWidth);\ncommon.setPanelCallback(\'left\', updateLeftPanelWidth);\n\n// transformation toolbar options\nvar t = void 0,\n    typeTransform = void 0;\nvar transformList = exports.transformList = \'log(d) exp(d) d^2 sqrt(d) interact(d,e)\'.split(\' \');\nvar transformVar = \'\';\n\n// var list for each space contain variables in original data\n// plus trans in that space\nvar trans = [];\nvar preprocess = {}; // hold pre-processed data\nvar spaces = [];\n\n// layout function constants\nvar layoutAdd = "add";\nvar layoutMove = "move";\n\n// radius of circle\nvar RADIUS = exports.RADIUS = 40;\n\n// cx, cy, r values for indicator lights\nvar ind1 = [(RADIUS + 30) * Math.cos(1.3), -1 * (RADIUS + 30) * Math.sin(1.3), 5];\nvar ind2 = [(RADIUS + 30) * Math.cos(1.1), -1 * (RADIUS + 30) * Math.sin(1.1), 5];\n\n// space index\nvar myspace = exports.myspace = 0;\n\nvar forcetoggle = exports.forcetoggle = ["true"];\nvar locktoggle = exports.locktoggle = true;\nvar priv = true;\n\n// swandive is our graceful fail for d3m\n// swandive set to true if task is in failset\nvar swandive = exports.swandive = false;\nvar failset = ["TIME_SERIES_FORECASTING", "GRAPH_MATCHING", "LINK_PREDICTION", "timeSeriesForecasting", "graphMatching", "linkPrediction"];\n\n// object that contains all information about the returned pipelines\nvar allPipelineInfo = exports.allPipelineInfo = {};\n\nvar logArray = exports.logArray = [];\nvar zparams = exports.zparams = {\n    zdata: [],\n    zedges: [],\n    ztime: [],\n    znom: [],\n    zcross: [],\n    zmodel: "",\n    zvars: [],\n    zdv: [],\n    zgroup1: [],\n    zgroup2: [], // hard coding to two groups for present experiments, but will eventually make zgroup array of arrays, with zgroup.length the number of groups\n    zdataurl: "",\n    zd3mdata: "", //these take the place of zdataurl for d3m, because data is in two placees. eventually will generalize\n    zd3mtarget: "",\n    zsubset: [],\n    zsetx: [],\n    zmodelcount: 0,\n    zplot: [],\n    zsessionid: "",\n    zdatacite: \'...\',\n    zcrosstab: [],\n    zusername: \'\'\n};\n\nvar disco = exports.disco = [];\n\nvar modelCount = exports.modelCount = 0;\nvar valueKey = exports.valueKey = [];\nvar allNodes = exports.allNodes = [];\nvar allResults = exports.allResults = [];\nvar nodes = exports.nodes = [];\nvar links = exports.links = [];\nvar mods = {};\nvar estimated = false;\nvar rightClickLast = false;\nvar selInteract = false;\nvar callHistory = exports.callHistory = []; // transform and subset calls\nvar mytarget = \'\';\n\nvar configurations = exports.configurations = {};\nvar datadocument = {};\n\nvar domainIdentifier = exports.domainIdentifier = null; // available throughout apps js; used for saving workspace\n\n// eventually read this from the schema with real descriptions\n// metrics, tasks, and subtasks as specified in D3M schemas\n// MEAN SQUARED ERROR IS SET TO SAME AS RMSE. MSE is in schema but not proto\nvar d3mTaskType = exports.d3mTaskType = {\n    taskTypeUndefined: ["description", "TASK_TYPE_UNDEFINED", 0],\n    classification: ["description", "CLASSIFICATION", 1],\n    regression: ["description", "REGRESSION", 2],\n    clustering: ["description", "CLUSTERING", 3],\n    linkPrediction: ["description", "LINK_PREDICTION", 4],\n    vertexNomination: ["description", "VERTEX_NOMINATION", 5],\n    communityDetection: ["description", "COMMUNITY_DETECTION", 6],\n    graphClustering: ["description", "GRAPH_CLUSTERING", 7],\n    graphMatching: ["description", "GRAPH_MATCHING", 8],\n    timeSeriesForecasting: ["description", "TIME_SERIES_FORECASTING", 9],\n    collaborativeFiltering: ["description", "COLLABORATIVE_FILTERING", 10]\n};\n\nvar d3mTaskSubtype = exports.d3mTaskSubtype = {\n    taskSubtypeUndefined: ["description", "TASK_SUBTYPE_UNDEFINED", 0],\n    subtypeNone: ["description", "NONE", 1],\n    binary: ["description", "BINARY", 2],\n    multiClass: ["description", "MULTICLASS", 3],\n    multiLabel: ["description", "MULTILABEL", 4],\n    univariate: ["description", "UNIVARIATE", 5],\n    multivariate: ["description", "MULTIVARIATE", 6],\n    overlapping: ["description", "OVERLAPPING", 7],\n    nonOverlapping: ["description", "NONOVERLAPPING", 8]\n};\n/*export let d3mOutputType = {\n    outputUndefined:["description","OUTPUT_TYPE_UNDEFINED ", 0],\n    predictionsFile:["description","PREDICTIONS_FILE",1],\n    scoresFile:["description","SCORES_FILE",2]\n}; */\nvar d3mMetrics = exports.d3mMetrics = {\n    metricUndefined: ["description", "METRIC_UNDEFINED", 0],\n    executionTime: ["description", "EXECUTION_TIME", 1],\n    accuracy: ["description", "ACCURACY", 2],\n    f1: ["description", "F1", 3],\n    f1Micro: ["description", "F1_MICRO", 4],\n    f1Macro: ["description", "F1_MACRO", 5],\n    rocAuc: ["description", "ROC_AUC", 6],\n    rocAucMicro: ["description", "ROC_AUC_MICRO", 7],\n    rocAucMacro: ["description", "ROC_AUC_MACRO", 8],\n    meanSquaredError: ["description", "MEAN_SQUARED_ERROR", 9],\n    rootMeanSquaredError: ["description", "ROOT_MEAN_SQUARED_ERROR", 10],\n    rootMeanSquaredErrorAvg: ["description", "ROOT_MEAN_SQUARED_ERROR_AVG", 11],\n    meanAbsoluteError: ["description", "MEAN_ABSOLUTE_ERROR", 12],\n    rSquared: ["description", "R_SQUARED", 13],\n    normalizedMutualInformation: ["description", "NORMALIZED_MUTUAL_INFORMATION", 14],\n    jaccardSimilarityScore: ["description", "JACCARD_SIMILARITY_SCORE", 15]\n};\n\nvar d3mProblemDescription = exports.d3mProblemDescription = {\n    taskType: "taskTypeUndefined",\n    taskSubtype: "taskSubtypeUndefined",\n    //   outputType: [3,"DEFAULT"],\n    metric: "metricUndefined",\n    taskDescription: ""\n};\n\n/*\n * call to django to update the problem definition in the problem document\n * rpc SetProblemDoc(SetProblemDocRequest) returns (Response) {}\n */\nvar setD3mProblemDescription = exports.setD3mProblemDescription = function setD3mProblemDescription(key, value) {\n    if (!locktoggle) {\n        d3mProblemDescription[key] = value;\n\n        var lookup = {\n            \'taskType\': d3mTaskType,\n            \'taskSubtype\': d3mTaskSubtype,\n            // \'outputType\': d3mOutputType,\n            \'metric\': d3mMetrics\n        }[key];\n\n        if (lookup === undefined) return;\n        makeRequest(D3M_SVC_URL + "/SetProblemDoc", { replaceProblemSchemaField: _defineProperty({}, key, lookup[d3mProblemDescription[key]][1]), context: apiSession(zparams.zsessionid) });\n    } else _hopscotch2.default.startTour(lockTour);\n};\n\nvar svg = void 0,\n    div = void 0,\n    selectLadda = void 0;\nvar width = exports.width = void 0,\n    height = exports.height = void 0,\n    estimateLadda = exports.estimateLadda = void 0,\n    discoveryLadda = exports.discoveryLadda = void 0;\n\n// arcs for denoting pebble characteristics\nvar arc = function arc(start, end) {\n    return function (radius) {\n        return d3.svg.arc().innerRadius(radius + 5).outerRadius(radius + 20).startAngle(start).endAngle(end);\n    };\n};\nvar _ref = [arc(0, 3.2), arc(0, 1), arc(1.1, 2.2), arc(2.3, 3.3), arc(4.3, 5.3)];\nvar arc0 = _ref[0],\n    arc1 = _ref[1],\n    arc2 = _ref[2],\n    arc3 = _ref[3],\n    arc4 = _ref[4];\nexports.arc0 = arc0;\nexports.arc1 = arc1;\nexports.arc2 = arc2;\nexports.arc3 = arc3;\nexports.arc4 = arc4;\n\nvar arcInd = function arcInd(arclimits) {\n    return function (radius) {\n        return d3.svg.arc().innerRadius(radius + 22).outerRadius(radius + 37).startAngle(arclimits[0]).endAngle(arclimits[1]);\n    };\n};\n\nvar arcInd1Limits = [0, 0.3],\n    arcInd2Limits = [0.35, 0.65];\nvar _ref2 = [arcInd(arcInd1Limits), arcInd(arcInd2Limits)],\n    arcInd1 = _ref2[0],\n    arcInd2 = _ref2[1];\n\n// milliseconds to wait before showing/hiding the pebble handles\n\nvar hoverTimeout = 150;\nvar hoverPebble = void 0;\nvar selectedPebble = void 0;\n\nvar byId = exports.byId = function byId(id) {\n    return document.getElementById(id);\n};\n// export let byId = id => {console.log(id); return document.getElementById(id);}\n\nfunction trigger(id, event) {\n    var evt = document.createEvent(\'HTMLEvents\');\n    evt.initEvent(event, true, false);\n    byId(id).dispatchEvent(evt);\n}\n\n/**\n   page reload linked to btnReset\n*/\nvar reset = exports.reset = async function reloadPage() {\n    var res = await makeRequest(D3M_SVC_URL + \'/endsession\', apiSession(zparams.zsessionid));\n    byId("btnModel").click();\n    location.reload();\n};\nvar _restart = void 0;\n\nexports.restart = _restart;\nvar dataurl = \'\';\n\nvar step = exports.step = function step(target, placement, title, content) {\n    return {\n        target: target,\n        placement: placement,\n        title: title,\n        content: content,\n        showCTAButton: true,\n        ctaLabel: \'Disable these messages\',\n        onCTA: function onCTA() {\n            localStorage.setItem(\'tutorial_mode\', \'false\');\n            _hopscotch2.default.endTour(true);\n        }\n    };\n};\n\nvar mytour = exports.mytour = {\n    id: "dataset_launch",\n    i18n: { doneBtn: \'Ok\' },\n    showCloseButton: true,\n    scrollDuration: 300,\n    steps: [step("dataName", "bottom", "Welcome to TwoRavens Solver", \'<p>This tool can guide you to solve an empirical problem in the dataset above.</p>\\n                      <p>These messages will teach you the steps to take to find and submit a solution.</p>\'), step("btnReset", "bottom", "Restart Any Problem Here", \'<p>You can always start a problem over by using this reset button.</p>\'), step("btnDiscovery", "right", "Start Task 1", \'<p>This Problem Discovery button allows you to start Task 1 - Problem Discovery.</p>\\n                     <p>Generally, as a tip, the Green button is the next button you need to press to move the current task forward.</p>\\n                     <p>Click this button to see a list of problems that have been discovered in the dataset.</p>\\n                     <p>You can mark which ones you agree may be interesting, and then submit the table as an answer.</p>\'),\n    //step("btnSelect", "right", "Complete Task 1",\n    //     `<p>This submission button marks Task 1 - Problem Discovery, as complete.</p>\n    //     <p>Click this button to save the check marked problems in the table below as potentially interesting or relevant.</p>\n    //     <p>Generally, as a tip, the Green button is the next button you need to press to move the current task forward.</p>`),\n    step("btnEstimate", "left", "Solve Task 2", \'<p>This generally is the important step to follow for Task 2 - Build a Model.</p>\\n                      <p>Generally, as a tip, the Green button is the next button you need to press to move the current task forward, and this button will be Green when Task 1 is completed and Task 2 started.</p>\\n                      <p>Click this Solve button to tell the tool to find a solution to the problem, using the variables presented in the center panel.</p>\'), step(mytarget + \'biggroup\', "left", "Target Variable", \'This is the variable, \' + mytarget + \', we are trying to predict.\\n                      This center panel graphically represents the problem currently being attempted.\'), step("gr1hull", "right", "Explanation Set", "This set of variables can potentially predict the target."), step("displacement", "right", "Variable List", \'<p>Click on any variable name here if you wish to remove it from the problem solution.</p>\\n                      <p>You likely do not need to adjust the problem representation in the center panel.</p>\'), step("btnEndSession", "bottom", "Finish Problem", "If the solution reported back seems acceptable, then finish this problem by clicking this End Session button.")]\n};\n\nvar mytour3 = exports.mytour3 = {\n    id: "dataset_launch",\n    i18n: { doneBtn: \'Ok\' },\n    showCloseButton: true,\n    scrollDuration: 300,\n    steps: [step("btnSelect", "right", "Complete Task 1", \'<p>This submission button marks Task 1 - Problem Discovery, as complete.</p>\\n                     <p>Click this button to save the check marked problems in the table below as potentially interesting or relevant.</p>\\n                     <p>Generally, as a tip, the Green button is the next button you need to press to move the current task forward.</p>\')]\n};\n\n// appears when a user attempts to edit when the toggle is set\nvar lockTour = exports.lockTour = {\n    id: "lock_toggle",\n    i18n: { doneBtn: \'Ok\' },\n    showCloseButton: true,\n    scrollDuration: 300,\n    steps: [step("btnLock", "left", "Locked Mode", \'<p>Click the lock button to enable editing.</p>\')]\n};\n\n/**\n  called by main\n  Loads all external data in the following order (logic is not included):\n  1. Retrieve the configuration information\n  2. Set \'configurations\'\n  3. Read the problem schema and set \'d3mProblemDescription\'\n  4. Read the data document and set \'datadocument\'\n  5. Read in zelig models (not for d3m)\n  6. Read in zeligchoice models (not for d3m)\n  7. Start the user session\n  8. Read preprocess data or (if necessary) run preprocess\n  9. Build allNodes[] using preprocessed information\n  10. Add datadocument information to allNodes (when in IS_D3M_DOMAIN)\n  11. Call layout() and start up\n*/\nasync function load(hold, lablArray, d3mRootPath, d3mDataName, d3mPreprocess, d3mData, d3mPS, d3mDS, pURL) {\n    if (!IS_D3M_DOMAIN) {\n        return;\n    }\n\n    // 1. Retrieve the configuration information\n    var res = await _mithril2.default.request({\n        method: "POST",\n        url: "/config/d3m-config/json/latest"\n    });\n    console.log(res);\n    // 2. Set \'configurations\'\n    exports.configurations = configurations = JSON.parse(JSON.stringify(res)); // this is just copying res\n    d3mRootPath = configurations.training_data_root.replace(/\\/data/, \'\');\n    d3mDataName = configurations.name;\n\n    // scopes at app.js level; used for saving workspace\n    exports.domainIdentifier = domainIdentifier = { name: configurations.name,\n        source_url: configurations.config_url,\n        description: \'D3M config file\' };\n    //id: configurations.id};\n\n    d3mPS = "/config/d3m-config/get-problem-schema/json";\n    d3mDS = "/config/d3m-config/get-dataset-schema/json";\n    console.log("Configurations: ", configurations);\n    d3mPreprocess = pURL = \'rook-custom/rook-files/\' + d3mDataName + \'/preprocess/preprocess.json\';\n    console.log(d3mPreprocess);\n\n    // 3. Read the problem schema and set \'d3mProblemDescription\'\n    // ...and make a call to start the session with TA2. if we get this far, data are guaranteed to exist for the frontend\n\n    res = await _mithril2.default.request("/config/d3m-config/get-problem-data-file-info");\n    // The result of this call is similar to below:\n    // example:\n    /*  {\n             "success":true,\n             "data":{\n                "learningData.csv":{\n                   "exists":true,\n                   "size":11654,\n                   "path":"/inputs/dataset_TRAIN/tables/learningData.csv"\n                },\n                "learningData.csv.gz":{\n                   "exists":false,\n                   "size":-1,\n                   "path":"/inputs/dataset_TRAIN/tables/learningData.csv.gz"\n                }\n             }\n          }\n    */\n\n    // Loop through the response above and\n    // pick the first "path" where "exists" is true\n    //\n    // Note: if data files have "exists" as false, stay as default which is null\n    //\n    var set_d3m_data_path = function set_d3m_data_path(field, val) {\n        return res.data[field].exists ? res.data[field].path : res.data[field + \'.gz\'].exists ? res.data[field + \'.gz\'].path : val;\n    };\n\n    zparams.zd3mdata = d3mData = set_d3m_data_path(\'learningData.csv\', d3mData);\n    zparams.zd3mtarget = set_d3m_data_path(\'learningData.csv\', d3mData);\n\n    // If this is the D3M domain; d3mData MUST be set to an actual value\n    //\n    if (IS_D3M_DOMAIN && d3mData == null) {\n        var d3m_path_err = \'NO VALID d3mData path!! \' + JSON.stringify(res);\n        console.log(d3m_path_err);\n        alert(\'debug (be more graceful): \' + d3m_path_err);\n    }\n\n    // hardcoding this, once get-problem-data-file-info is revised this hardcode can go away and use the previous two LOC\n    //  zparams.zd3mdata = d3mData = d3mRootPath+"/dataset_TRAIN/tables/learningData.csv";\n    //  zparams.zd3mtarget = d3mRootPath+"/dataset_TRAIN/tables/learningData.csv";\n\n    res = await _mithril2.default.request(d3mPS);\n    console.log("prob schema data: ", res);\n\n    mytarget = res.inputs.data[0].targets[0].colName; // easier way to access target name?\n    if (typeof res.about.taskType !== \'undefined\') {\n        d3mProblemDescription.taskType = res.about.taskType;\n    }\n    if (typeof res.about.taskSubType !== \'undefined\') {\n        d3mProblemDescription.taskSubtype = res.about.taskSubType;\n    }\n    if (typeof res.inputs.performanceMetrics[0].metric !== \'undefined\') {\n        d3mProblemDescription.metric = res.inputs.performanceMetrics[0].metric;\n    }\n    if (typeof res.descriptionFile !== \'undefined\') {\n        d3mProblemDescription.taskDescription = res.descriptionFile;\n    }\n    //   d3mProblemDescription.outputType = res.expectedOutputs.predictionsFile;\n\n    // making it case insensitive because the case seems to disagree all too often\n    if (failset.includes(d3mProblemDescription.taskType.toUpperCase())) {\n        if (IS_D3M_DOMAIN) {\n            console.log(\'D3M WARNING: failset  task type found\');\n        }\n        exports.swandive = swandive = true;\n    }\n\n    // 4. Read the data document and set \'datadocument\'\n    datadocument = await _mithril2.default.request(d3mDS);\n\n    // if no columns in the datadocument, go to swandive\n    // 4a. Set datadocument columns!\n    var datadocument_columns = void 0;\n    var col_idx = void 0;\n    for (col_idx = 0; col_idx < datadocument.dataResources.length; col_idx++) {\n        if (datadocument.dataResources[col_idx].columns) {\n            datadocument_columns = datadocument.dataResources[col_idx].columns;\n            console.log(\'columns found in datadocument.dataResources[\' + col_idx + \'].columns\');\n            break;\n        }\n    }\n    if (typeof datadocument_columns === "undefined") {\n        console.log(\'D3M WARNING: datadocument.dataResources[x].columns is undefined.\');\n        exports.swandive = swandive = true;\n    }\n\n    if (IS_D3M_DOMAIN) {\n        var datasetName = datadocument.about.datasetID; //.datasetName;             // Was use "datasetName" field in dataset document, but is commonly "null"\n        zparams.zdata = datasetName.charAt(0).toUpperCase() + datasetName.slice(1); // Make sure to capitalize;\n        var cite = "No citation provided";\n        if (typeof datadocument.about.citation !== \'undefined\') {\n            cite = datadocument.about.citation;\n        }\n        //console.log(cite);\n        //let newcite = cite.match(/{\\s*[\\w\\.]+\\s*}/g).map(function(x) { return x.match(/[\\w\\.]+/)[0]; });\n        //console.log(newcite);\n        /*\n        // clean citation\n        zparams.zdatacite = cite\n        .replace(/\\&/g, "and")\n        .replace(/\\;/g, ",")\n        .replace(/\\%/g, "-");\n        // fill in citation in header\n        elem(\'#cite div.panel-body\').textNode = zparams.zdatacite;\n        */\n    } else {\n        // Note: presently xml is no longer being read from Dataverse metadata anywhere\n        var temp = xml.documentElement.getElementsByTagName("fileName");\n        zparams.zdata = temp[0].childNodes[0].nodeValue;\n        var _cite = xml.documentElement.getElementsByTagName("biblCit");\n        // clean citation so POST is valid json\n        zparams.zdatacite = _cite[0].childNodes[0].nodeValue.replace(/\\&/g, "and").replace(/\\;/g, ",").replace(/\\%/g, "-");\n        // fill in citation in header\n        byId(\'cite\').children[0].textContent = zparams.zdatacite;\n    }\n    // drop file extension\n    var dataname = IS_D3M_DOMAIN ? zparams.zdata : zparams.zdata.replace(/\\.(.*)/, \'\');\n    d3.select("#dataName").html(dataname);\n    // put dataset name, from meta-data, into page title\n    d3.select("title").html("TwoRavens " + dataname);\n    localStorage.setItem(\'peekHeader\', "TwoRavens " + dataname);\n\n    // if swandive, we have to set valueKey here so that left panel can populate.\n    if (swandive) {\n        alert(\'Exceptional data detected.  Please check the logs for "D3M WARNING"\');\n        //    let mydataRes = datadocument.dataResources;\n        //  for (let i = 0; i < mydataRes.length; i++) {\n        //       valueKey.push(mydataRes[i].resFormat[0]);\n        //  }\n        // end session if neither trainData nor trainTargets?\n        // valueKey.length === 0 && alert("no trainData or trainTargest in data description file. valueKey length is 0");\n        // perhaps allow users to unlock and select things?\n        byId(\'btnLock\').classList.add(\'noshow\');\n        byId(\'btnForce\').classList.add(\'noshow\');\n        byId(\'btnEraser\').classList.add(\'noshow\');\n        byId(\'btnSubset\').classList.add(\'noshow\');\n        byId(\'main\').style.backgroundColor = \'grey\';\n        byId(\'whitespace\').style.backgroundColor = \'grey\';\n    }\n    console.log("data schema data: ", datadocument);\n\n    // 5. Read in zelig models (not for d3m)\n    // 6. Read in zeligchoice models (not for d3m)\n    if (!IS_D3M_DOMAIN) {\n        var _arr = [\'zelig5models\', \'zelig5choicemodels\'];\n\n        var _loop = async function _loop() {\n            var field = _arr[_i];\n            try {\n                res = await _mithril2.default.request(\'data/\' + field + \'.json\');\n                cdb(field + \' json: \', res);\n                res[field].filter(function (key) {\n                    return res[field].hasOwnProperty(key);\n                }).forEach(function (key) {\n                    return mods[key.name[0]] = key.description[0];\n                });\n            } catch (_) {\n                console.log("can\'t load " + field);\n            }\n        };\n\n        for (var _i = 0; _i < _arr.length; _i++) {\n            await _loop();\n        }\n    }\n    // 7. Start the user session\n    // rpc StartSession(SessionRequest) returns (SessionResponse) {}\n    res = await makeRequest(D3M_SVC_URL + \'/startsession\', { user_agent: \'some agent\', version: \'some version\' });\n    if (res) {\n        if (res.responseInfo.status.code != "OK") {\n            var user_err_msg = "Failed to StartSession with TA2! status code: " + res.responseInfo.status.code;\n            (0, _Modal.setModal)(user_err_msg, "Error Connecting to TA2", true, "Reset", false, location.reload);\n            //  end_ta3_search(false, user_err_msg);\n            return;\n        } else {\n            zparams.zsessionid = res.context.sessionId;\n        }\n    }\n\n    // hopscotch tutorial\n    if (tutorial_mode) {\n        console.log(\'Starting Hopscotch Tour\');\n        _hopscotch2.default.startTour(mytour);\n    }\n\n    // 8. read preprocess data or (if necessary) run preprocess\n    // NOTE: preprocess.json is now guaranteed to exist...\n    var read = function read(res) {\n        priv = res.dataset.private || priv;\n        Object.keys(res.variables).forEach(function (k) {\n            return preprocess[k] = res.variables[k];\n        });\n        return res;\n    };\n    try {\n        console.log(\'attempt to read preprocess file (which may not exist): \' + pURL);\n        res = read((await _mithril2.default.request(pURL)));\n    } catch (_) {\n        console.log("Ok, preprocess not found, try to RUN THE PREPROCESSAPP");\n        var url = ROOK_SVC_URL + \'preprocessapp\';\n        var json_input;\n        if (IS_D3M_DOMAIN) {\n            // For D3M inputs, change the preprocess input data\n            //\n            json_input = { data: d3mData, datastub: d3mDataName };\n        } else {\n            json_input = { data: dataloc, target: targetloc, datastub: datastub };\n        }\n\n        console.log(\'json_input: \', json_input);\n        console.log(\'url: \', url);\n        var data = new FormData();\n        try {\n            res = read((await _mithril2.default.request({ method: \'POST\', url: url, data: json_input })));\n        } catch (_) {\n            console.log(\'preprocess failed\');\n            alert(\'preprocess failed. ending user session.\');\n            endsession();\n        }\n    }\n\n    console.log("is this preprocess?");\n    console.log(res);\n    console.log(preprocess);\n\n    // 9. Build allNodes[] using preprocessed information\n    var vars = Object.keys(preprocess);\n    // temporary values for hold that correspond to histogram bins\n    hold = [.6, .2, .9, .8, .1, .3, .4];\n    for (var i = 0; i < vars.length; i++) {\n        // valueKey[i] = vars[i].attributes.name.nodeValue;\n        // lablArray[i] = varsXML[i].getElementsByTagName("labl").length == 0 ?\n        // "no label" :\n        // varsXML[i].getElementsByTagName("labl")[0].childNodes[0].nodeValue;\n        // let datasetcount = d3.layout.histogram()\n        //     .bins(barnumber).frequency(false)\n        //     ([0, 0, 0, 0, 0]);\n        valueKey[i] = vars[i];\n        lablArray[i] = "no label";\n        // contains all the preprocessed data we have for the variable, as well as UI data pertinent to that variable,\n        // such as setx values (if the user has selected them) and pebble coordinates\n        var obj = {\n            id: i,\n            reflexive: false,\n            name: valueKey[i],\n            labl: lablArray[i],\n            data: [5, 15, 20, 0, 5, 15, 20],\n            count: hold,\n            nodeCol: colors(i),\n            baseCol: colors(i),\n            strokeColor: _plots.selVarColor,\n            strokeWidth: "1",\n            subsetplot: false,\n            subsetrange: ["", ""],\n            setxplot: false,\n            setxvals: ["", ""],\n            grayout: false,\n            group1: false,\n            group2: false,\n            forefront: false\n        };\n        jQuery.extend(true, obj, preprocess[valueKey[i]]);\n        allNodes.push(obj);\n    }\n\n    // 10. Add datadocument information to allNodes (when in IS_D3M_DOMAIN)\n    if (!swandive) {\n        var datavars = datadocument_columns;\n        datavars.forEach(function (v, i) {\n            var myi = findNodeIndex(v.colName);\n            allNodes[myi] = Object.assign(allNodes[myi], { d3mDescription: v });\n        });\n        console.log(allNodes);\n    }\n\n    // 10b. Call problem discovery\n    // Requires that `res` built in 8. above still exists.  Should make this better.\n    if (!swandive) {\n        exports.disco = disco = discovery(res);\n\n        // Kick off discovery button as green for user guidance\n        byId("btnDiscovery").classList.remove("btn-default");\n        byId("btnDiscovery").classList.add("btn-success"); // Would be better to attach this as a class at creation, but don\'t see where it is created\n\n        console.log(disco);\n    }\n\n    // 11. Call layout() and start up\n    layout(false, true);\n    IS_D3M_DOMAIN ? zPop() : dataDownload();\n}\n\n/**\n   called on app start\n   @param {string} fileid\n   @param {string} hostname\n   @param {string} ddiurl\n   @param {string} dataurl\n   @param {string} apikey\n*/\nfunction main(fileid, hostname, ddiurl, dataurl, apikey) {\n    if (PRODUCTION && fileid === \'\') {\n        var msg = \'Error: No fileid has been provided.\';\n        alert(msg);\n        throw new Error(msg);\n    }\n\n    var dataverseurl = hostname ? \'https://\' + hostname : PRODUCTION ? DATAVERSE_URL : \'http://localhost:8080\';\n    // if file id supplied, assume we are dealing with dataverse and cook a standard dataverse data access url\n    // with the fileid supplied and the hostname we have supplied or configured\n    dataurl = fileid && !dataurl ? dataverseurl + \'/api/access/datafile/\' + fileid + \'?key=\' + apikey : dataurl;\n    cdb(\'--dataurl: \' + dataurl);\n    cdb(\'--dataverseurl: \' + dataverseurl);\n\n    var tempWidth = d3.select(\'#main.left\').style(\'width\');\n    exports.width = width = tempWidth.substring(0, tempWidth.length - 2);\n    exports.height = height = window.innerHeight - 120; // hard code header, footer, and bottom margin\n\n    exports.estimateLadda = estimateLadda = Ladda.create(byId("btnEstimate"));\n    exports.discoveryLadda = discoveryLadda = Ladda.create(byId("btnSubmitDisc"));\n    svg = d3.select("#whitespace");\n\n    // indicators for showing membership above arcs\n    // let indicator = (degree) => d3.svg.circle()\n    //     .cx( RADIUS )//(RADIUS+35) * Math.sin(degree))\n    //     .cy( RADIUS )//(RADIUS+35) * Math.cos(degree))\n    //     .r(3);\n    // ind1 = indicator(1);\n    // ind2 = indicator(1.2);\n\n    // from .csv\n    var hold = [],\n        lablArray = [];\n\n    // assume locations are consistent based on d3m directory structure\n\n    var d3mRootPath = \'\';\n    var d3mDataName = \'\';\n    var d3mData = null;\n    var d3mPreprocess = \'\';\n    var d3mPS = \'\';\n    var d3mDS = \'\';\n\n    // default to Fearon Laitin\n    var data = \'data/\' + (false ? \'PUMS5small\' : \'fearonLaitin\');\n    var metadataurl = ddiurl || (fileid ? dataverseurl + \'/api/meta/datafile/\' + fileid : data + \'.xml\');\n    // read pre-processed metadata and data\n    var pURL = dataurl ? dataurl + \'&format=prep\' : data + \'.json\';\n\n    if (IS_D3M_DOMAIN) {\n        pURL = d3mPreprocess;\n    } else if (!PRODUCTION) {\n        zparams.zdataurl = \'data/fearonLaitin.tsv\';\n    }\n    load(hold, lablArray, d3mRootPath, d3mDataName, d3mPreprocess, d3mData, d3mPS, d3mDS, pURL);\n}\n\nvar $fill = function $fill(obj, op, d1, d2) {\n    return d3.select(obj).transition().attr(\'fill-opacity\', op).attr(\'display\', op ? \'\' : \'none\').delay(d1).duration(d2);\n};\nvar fill = function fill(d, id, op, d1, d2) {\n    return $fill(\'#\' + id + d.id, op, d1, d2);\n};\nvar fillThis = function fillThis(self, op, d1, d2) {\n    return $fill(self, op, d1, d2);\n};\n\n/**\n   deletes the item at index from array.\n   if object is provided, deletes first instance of object from array.\n   @param {Object[]} arr - array\n   @param {number} idx - index\n   @param {Object} [obj] - object\n*/\nfunction del(arr, idx, obj) {\n    idx = obj ? arr.indexOf(obj) : idx;\n    idx > -1 && arr.splice(idx, 1);\n}\n\n/** needs doc */\nfunction zparamsReset(text) {\n    \'zdv zcross ztime znom\'.split(\' \').forEach(function (x) {\n        return del(zparams[x], -1, text);\n    });\n}\n\nfunction setup_svg(svg) {\n    svg.append("svg:defs").append("svg:marker").attr("id", "group1-arrow").attr(\'viewBox\', \'0 -5 15 15\').attr("refX", 2.5).attr("refY", 0).attr("markerWidth", 3).attr("markerHeight", 3).attr("orient", "auto").append("path").attr(\'d\', \'M0,-5L10,0L0,5\').style("fill", gr1Color);\n    svg.append("svg:defs").append("svg:marker").attr("id", "group2-arrow").attr(\'viewBox\', \'0 -5 15 15\').attr("refX", 2.5).attr("refY", 0).attr("markerWidth", 3).attr("markerHeight", 3).attr("orient", "auto").append("path").attr(\'d\', \'M0,-5L10,0L0,5\').style("fill", gr2Color);\n    // define arrow markers for graph links\n    svg.append(\'svg:defs\').append(\'svg:marker\').attr(\'id\', \'end-arrow\').attr(\'viewBox\', \'0 -5 10 10\').attr(\'refX\', 6).attr(\'markerWidth\', 3).attr(\'markerHeight\', 3).attr(\'orient\', \'auto\').append(\'svg:path\').attr(\'d\', \'M0,-5L10,0L0,5\').style(\'fill\', \'#000\');\n    svg.append(\'svg:defs\').append(\'svg:marker\').attr(\'id\', \'start-arrow\').attr(\'viewBox\', \'0 -5 10 10\').attr(\'refX\', 4).attr(\'markerWidth\', 3).attr(\'markerHeight\', 3).attr(\'orient\', \'auto\').append(\'svg:path\').attr(\'d\', \'M10,-5L0,0L10,5\').style(\'fill\', \'#000\');\n\n    var line = svg.append("line").style(\'fill\', \'none\').style(\'stroke\', gr1Color).style(\'stroke-width\', 5).attr("marker-end", "url(#group1-arrow)");\n    var line2 = svg.append("line").style(\'fill\', \'none\').style(\'stroke\', gr2Color).style(\'stroke-width\', 5).attr("marker-end", "url(#group2-arrow)");\n    var visbackground = svg.append("svg").attr("width", width).attr("height", height);\n    visbackground.append("path") // note lines, are behind group hulls of which there is a white and colored semi transparent layer\n    .attr("id", \'gr1background\').style("fill", \'#ffffff\').style("stroke", \'#ffffff\').style("stroke-width", 2.5 * RADIUS).style(\'stroke-linejoin\', \'round\').style("opacity", 1);\n    var vis2background = svg.append("svg").attr("width", width).attr("height", height);\n    vis2background.append("path").attr("id", \'gr1background\').style("fill", \'#ffffff\').style("stroke", \'#ffffff\').style("stroke-width", 2.5 * RADIUS).style(\'stroke-linejoin\', \'round\').style("opacity", 1);\n    var vis = svg.append("svg").attr("width", width).attr("height", height);\n    vis.append("path").attr("id", \'gr1hull\').style("fill", gr1Color).style("stroke", gr1Color).style("stroke-width", 2.5 * RADIUS).style(\'stroke-linejoin\', \'round\');\n    var vis2 = svg.append("svg").attr("width", width).attr("height", height);\n    vis2.append("path").style("fill", gr2Color).style("stroke", gr2Color).style("stroke-width", 2.5 * RADIUS).style(\'stroke-linejoin\', \'round\');\n    // line displayed when dragging new nodes\n    var drag_line = svg.append(\'svg:path\').attr(\'class\', \'link dragline hidden\').attr(\'d\', \'M0,0L0,0\');\n    // handles to link and node element groups\n    var path = svg.append(\'svg:g\').selectAll(\'path\'),\n        circle = svg.append(\'svg:g\').selectAll(\'g\');\n    return [line, line2, visbackground, vis2background, vis, vis2, drag_line, path, circle];\n}\n\n/** needs doc */\nfunction layout(v, v2) {\n    var myValues = [];\n    exports.nodes = nodes = [];\n    exports.links = links = [];\n\n    var _setup_svg = setup_svg(svg),\n        _setup_svg2 = _slicedToArray(_setup_svg, 9),\n        line = _setup_svg2[0],\n        line2 = _setup_svg2[1],\n        visbackground = _setup_svg2[2],\n        vis2background = _setup_svg2[3],\n        vis = _setup_svg2[4],\n        vis2 = _setup_svg2[5],\n        drag_line = _setup_svg2[6],\n        path = _setup_svg2[7],\n        circle = _setup_svg2[8];\n\n    if (v == layoutAdd || v == layoutMove) {\n        for (var j = 0; j < zparams.zvars.length; j++) {\n            var ii = findNodeIndex(zparams.zvars[j]);\n            if (allNodes[ii].grayout) continue;\n            nodes.push(allNodes[ii]);\n            var selectMe = zparams.zvars[j].replace(/\\W/g, "_");\n            selectMe = "#".concat(selectMe);\n            d3.select(selectMe).style(\'background-color\', function () {\n                return hexToRgba(nodes[j].strokeColor);\n            });\n        }\n\n        for (var j = 0; j < zparams.zedges.length; j++) {\n            var mysrc = nodeIndex(zparams.zedges[j][0]);\n            var mytgt = nodeIndex(zparams.zedges[j][1]);\n            links.push({\n                source: nodes[mysrc],\n                target: nodes[mytgt],\n                left: false,\n                right: true\n            });\n        }\n    } else {\n        if (IS_D3M_DOMAIN) {\n            //nodes = [findNode(mytarget)];               // Only add dependent variable on startup\n            exports.nodes = nodes = allNodes.slice(1, allNodes.length); // Add all but first variable on startup (assumes 0 position is d3m index variable)\n            for (var _j = 0; _j < nodes.length; _j++) {\n                //populate zvars array\n                if (nodes[_j].name != mytarget) {\n                    nodes[_j].group1 = true;\n                    zparams.zgroup1.push(nodes[_j].name); // write all names (except d3m index and the dependent variable) to zgroup1 array\n                };\n            };\n        } else if (allNodes.length > 2) {\n            exports.nodes = nodes = [allNodes[0], allNodes[1], allNodes[2]];\n            exports.links = links = [{\n                source: nodes[1],\n                target: nodes[0],\n                left: false,\n                right: true\n            }, {\n                source: nodes[0],\n                target: nodes[2],\n                left: false,\n                right: true\n            }];\n        } else if (allNodes.length === 2) {\n            exports.nodes = nodes = [allNodes[0], allNodes[1]];\n            exports.links = links = [{\n                source: nodes[1],\n                target: nodes[0],\n                left: false,\n                right: true\n            }];\n        } else if (allNodes.length === 1) {\n            exports.nodes = nodes = [allNodes[0]];\n        } else {\n            alert("There are zero variables in the metadata.");\n            return;\n        }\n    }\n\n    panelPlots(); // after nodes is populated, add subset and (if !IS_D3M_DOMAIN) setx panels\n\n    var force = d3.layout.force().nodes(nodes).links(links).size([width, height]).linkDistance(150).charge(-800).on(\'tick\', tick);\n\n    // mouse event vars\n    var selected_node = null,\n        selected_link = null,\n        mousedown_link = null,\n        mousedown_node = null,\n        mouseup_node = null;\n\n    function resetMouseVars() {\n        mousedown_node = null;\n        mouseup_node = null;\n        mousedown_link = null;\n    }\n\n    // update force layout (called automatically each iteration)\n    function tick() {\n        function findcoords(findnames, allnames, coords, lengthen) {\n            var fcoords = new Array(findnames.length); // found coordinates\n            var addlocation = 0;\n            if (findnames.length > 0) {\n                for (var j = 0; j < findnames.length; j++) {\n                    addlocation = allnames.indexOf(findnames[j]);\n                    fcoords[j] = coords[addlocation];\n                };\n            };\n\n            if (lengthen) {\n                // d3.geom.hull returns null for two points, and fails if three points are in a line,\n                // so this puts a couple points slightly off the line for two points, or around a singleton.\n                if (fcoords.length == 2) {\n                    var deltax = fcoords[0][0] - fcoords[1][0];\n                    var deltay = fcoords[0][1] - fcoords[1][1];\n                    fcoords.push([(fcoords[0][0] + fcoords[1][0]) / 2 + deltay / 20, (fcoords[0][1] + fcoords[1][1]) / 2 + deltax / 20]);\n                    fcoords.push([(fcoords[0][0] + fcoords[1][0]) / 2 - deltay / 20, (fcoords[0][1] + fcoords[1][1]) / 2 - deltax / 20]);\n                }\n                if (fcoords.length == 1) {\n                    var delta = RADIUS * 0.2;\n                    fcoords.push([fcoords[0][0] + delta, fcoords[0][1]]);\n                    fcoords.push([fcoords[0][0] - delta, fcoords[0][1]]);\n                    fcoords.push([fcoords[0][0], fcoords[0][1] + delta]);\n                    fcoords.push([fcoords[0][0], fcoords[0][1] - delta]);\n                }\n            }\n            return fcoords;\n        };\n\n        // d3.geom.hull returns null for two points, and fails if three points are in a line,\n        // so this puts a couple points slightly off the line for two points, or around a singleton.\n        function lengthencoords(coords) {\n            if (coords.length == 2) {\n                var deltax = coords[0][0] - coords[1][0];\n                var deltay = coords[0][1] - coords[1][1];\n                coords.push([(coords[0][0] + coords[1][0]) / 2 + deltay / 20, (coords[0][1] + coords[1][1]) / 2 + deltax / 20]);\n                coords.push([(coords[0][0] + coords[1][0]) / 2 - deltay / 20, (coords[0][1] + coords[1][1]) / 2 - deltax / 20]);\n            }\n            if (coords.length == 1) {\n                var delta = RADIUS * 0.2;\n                coords.push([coords[0][0] + delta, coords[0][1]]);\n                coords.push([coords[0][0] - delta, coords[0][1]]);\n                coords.push([coords[0][0], coords[0][1] + delta]);\n                coords.push([coords[0][0], coords[0][1] - delta]);\n            }\n            return coords;\n        };\n\n        var coords = nodes.map(function (d) {\n            return [d.x, d.y];\n        });\n        var gr1coords = findcoords(zparams.zgroup1, zparams.zvars, coords, true);\n        var gr2coords = findcoords(zparams.zgroup2, zparams.zvars, coords, true);\n        var depcoords = findcoords(zparams.zdv, zparams.zvars, coords, false);\n\n        // draw convex hull around independent variables, if three or more coordinates given\n        // note, d3.geom.hull returns null if shorter coordinate set than 3,\n        // so findcoords() function has option to lengthen the coordinates returned to bypass this\n        if (gr1coords.length > 2) {\n            line.style("opacity", 1);\n            visbackground.style("opacity", 1);\n            vis.style("opacity", 0.3);\n            var myhull = d3.geom.hull(gr1coords);\n\n            vis.selectAll("path").data([myhull]) // returns null if less than three coordinates\n            .attr("d", function (d) {\n                return "M" + d.join("L") + "Z";\n            });\n            visbackground.selectAll("path").data([myhull]) // returns null if less than three coordinates\n            .attr("d", function (d) {\n                return "M" + d.join("L") + "Z";\n            });\n\n            //var p = d3.geom.polygon(indcoords).centroid();  // Seems to go strange sometimes\n            var p = jamescentroid(gr1coords);\n\n            if (depcoords.length > 0) {\n                var q = depcoords[0]; // Note, only using first dep var currently\n                //var r = findboundary(p,q,gr1coords);        // An approach to find the exact boundary, not presently working\n                var ldeltaX = q[0] - p[0],\n                    ldeltaY = q[1] - p[1],\n                    ldist = Math.sqrt(ldeltaX * ldeltaX + ldeltaY * ldeltaY),\n                    lnormX = 0,\n                    lnormY = 0,\n                    lsourcePadding = RADIUS + 7,\n                    ltargetPadding = RADIUS + 10;\n\n                if (ldist > 0) {\n                    lnormX = ldeltaX / ldist;\n                    lnormY = ldeltaY / ldist;\n                };\n\n                line.attr("x1", p[0] + lsourcePadding * lnormX) // or r[0] if findboundary works\n                .attr("y1", p[1] + lsourcePadding * lnormY) // or r[1] if findboundary works\n                .attr("x2", q[0] - ltargetPadding * lnormX).attr("y2", q[1] - ltargetPadding * lnormY);\n            };\n\n            // group members attract each other, repulse non-group members\n            nodes.forEach(function (n) {\n                var sign = n.group1 ? 1 : -1; //was: Math.sign( zparams.zgroup1.indexOf(n.name) +0.5 );  // 1 if n in group, -1 if n not in group;\n                var ldeltaX = p[0] - n.x,\n                    ldeltaY = p[1] - n.y,\n                    ldist = Math.sqrt(ldeltaX * ldeltaX + ldeltaY * ldeltaY);\n                lnormX = 0, lnormY = 0;\n\n                if (ldist > 0) {\n                    lnormX = ldeltaX / ldist;\n                    lnormY = ldeltaY / ldist;\n                };\n\n                n.x += Math.min(lnormX, ldeltaX / 100) * k * sign * force.alpha();\n                n.y += Math.min(lnormY, ldeltaY / 100) * k * sign * force.alpha();\n            });\n        } else {\n            visbackground.style("opacity", 0);\n            vis.style("opacity", 0);\n            line.style("opacity", 0);\n        };\n\n        if (gr2coords.length > 2) {\n            line2.style("opacity", 1);\n            vis2background.style("opacity", 1);\n            vis2.style("opacity", 0.3);\n            var myhull = d3.geom.hull(gr2coords);\n            vis2.selectAll("path").data([myhull]) // returns null if less than three coordinates\n            .attr("d", function (d) {\n                return "M" + d.join("L") + "Z";\n            });\n            vis2background.selectAll("path").data([myhull]) // returns null if less than three coordinates\n            .attr("d", function (d) {\n                return "M" + d.join("L") + "Z";\n            });\n\n            //var p = d3.geom.polygon(indcoords).centroid();  // Seems to go strange sometimes\n            var p = jamescentroid(gr2coords);\n\n            if (depcoords.length > 0) {\n                var q = depcoords[0]; // Note, only using first dep var currently\n                var ldeltaX = q[0] - p[0],\n                    ldeltaY = q[1] - p[1],\n                    ldist = Math.sqrt(ldeltaX * ldeltaX + ldeltaY * ldeltaY),\n                    lnormX = ldeltaX / ldist,\n                    lnormY = ldeltaY / ldist,\n                    lsourcePadding = RADIUS + 7,\n                    ltargetPadding = RADIUS + 10;\n\n                line2.attr("x1", p[0] + lsourcePadding * lnormX).attr("y1", p[1] + lsourcePadding * lnormY).attr("x2", q[0] - ltargetPadding * lnormX).attr("y2", q[1] - ltargetPadding * lnormY);\n            };\n\n            // group members attract each other, repulse non-group members\n            nodes.forEach(function (n) {\n                var sign = n.group2 ? 1 : -1; // was: Math.sign( zparams.zgroup2.indexOf(n.name) +0.5 );  // 1 if n in group, -1 if n not in group;\n                var ldeltaX = p[0] - n.x,\n                    ldeltaY = p[1] - n.y,\n                    ldist = Math.sqrt(ldeltaX * ldeltaX + ldeltaY * ldeltaY),\n                    lnormX = 0,\n                    lnormY = 0;\n\n                if (ldist > 0) {\n                    lnormX = ldeltaX / ldist;\n                    lnormY = ldeltaY / ldist;\n                };\n\n                n.x += Math.min(lnormX, ldeltaX / 100) * k * sign * force.alpha();\n                n.y += Math.min(lnormY, ldeltaY / 100) * k * sign * force.alpha();\n            });\n        } else {\n            vis2background.style("opacity", 0);\n            vis2.style("opacity", 0);\n            line2.style("opacity", 0);\n        };\n\n        // draw directed edges with proper padding from node centers\n        path.attr(\'d\', function (d) {\n            var deltaX = d.target.x - d.source.x,\n                deltaY = d.target.y - d.source.y,\n                dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY),\n                normX = deltaX / dist,\n                normY = deltaY / dist,\n                sourcePadding = d.left ? RADIUS + 5 : RADIUS,\n                targetPadding = d.right ? RADIUS + 5 : RADIUS,\n                sourceX = d.source.x + sourcePadding * normX,\n                sourceY = d.source.y + sourcePadding * normY,\n                targetX = d.target.x - targetPadding * normX,\n                targetY = d.target.y - targetPadding * normY;\n            return \'M\' + sourceX + \',\' + sourceY + \'L\' + targetX + \',\' + targetY;\n        });\n\n        circle.attr(\'transform\', function (d) {\n            return \'translate(\' + d.x + \',\' + d.y + \')\';\n        });\n\n        circle.selectAll(\'circle\') // Shrink/expand pebbles that join/leave groups\n        .transition().duration(100).attr(\'r\', function (d) {\n            return setPebbleRadius(d);\n        });\n    }\n\n    // this is to detect a click in the whitespace, but not on a pebble\n    var outsideClick = false;\n\n    // update graph (called when needed)\n    exports.restart = _restart = function restart($links) {\n        if (is_results_mode) {\n            return;\n        }\n\n        exports.links = links = $links || links;\n        // nodes.id is pegged to allNodes, i.e. the order in which variables are read in\n        // nodes.index is floating and depends on updates to nodes.  a variables index changes when new variables are added.\n        circle.call(force.drag);\n        if (forcetoggle[0] == "true") {\n            force.gravity(0.1);\n            force.charge(function (d) {\n                return setPebbleCharge(d);\n            });\n            force.start();\n            force.linkStrength(1);\n            exports.k = k = 4; // strength parameter for group attraction/repulsion\n            if (zparams.zgroup1.length > 0 & zparams.zgroup2.length > 0) {\n                // scale down by number of active groups\n                exports.k = k = 2.5;\n            }\n        } else {\n            force.gravity(0);\n            force.charge(0);\n            force.linkStrength(0);\n            exports.k = k = 0;\n        }\n        force.resume();\n\n        // path (link) group\n        path = path.data(links);\n\n        var marker = function marker(side) {\n            return function (x) {\n                var kind = side === \'left\' ? \'start\' : \'end\';\n                return is_explore_mode ? \'url(#circle)\' : x[side] ? \'url(#\' + kind + \'-arrow)\' : \'\';\n            };\n        };\n\n        // update existing links\n        // VJD: dashed links between pebbles are "selected". this is disabled for now\n        path.classed(\'selected\', function (x) {\n            return null;\n        }).style(\'marker-start\', marker(\'left\')).style(\'marker-end\', marker(\'right\'));\n\n        // add new links\n        path.enter().append(\'svg:path\').attr(\'class\', \'link\').classed(\'selected\', function (x) {\n            return null;\n        }).style(\'marker-start\', marker(\'left\')).style(\'marker-end\', marker(\'right\')).on(\'mousedown\', function (d) {\n            // do we ever need to select a link? make it delete..\n            var obj = JSON.stringify(d);\n            for (var j = 0; j < links.length; j++) {\n                if (obj === JSON.stringify(links[j])) del(links, j);\n            }\n        });\n\n        // remove old links\n        path.exit().remove();\n\n        // circle (node) group\n        circle = circle.data(nodes, function (x) {\n            return x.id;\n        });\n\n        // update existing nodes (reflexive & selected visual states)\n        // d3.rgb is the function adjusting the color here\n        circle.selectAll(\'circle\').classed(\'reflexive\', function (x) {\n            return x.reflexive;\n        }).style(\'fill\', function (x) {\n            return d3.rgb(x.nodeCol);\n        }).style(\'stroke\', function (x) {\n            return d3.rgb(x.strokeColor);\n        }).style(\'stroke-width\', function (x) {\n            return x.strokeWidth;\n        });\n        // add new nodes\n        var g = circle.enter().append(\'svg:g\').attr(\'id\', function (x) {\n            return x.name + \'biggroup\';\n        });\n\n        // add plot\n        g.each(function (d) {\n            d3.select(this);\n            if (d.plottype == \'continuous\') (0, _plots.densityNode)(d, this, setPebbleRadius(d));else if (d.plottype == \'bar\') (0, _plots.barsNode)(d, this, setPebbleRadius(d));\n        });\n\n        var append = function append(str, attr) {\n            return function (x) {\n                return str + x[attr || \'id\'];\n            };\n        };\n\n        var redrawPebbles = function redrawPebbles() {\n            g[0].forEach(function (pebble) {\n                // nullity check for when reintroducing variable from variable list\n                if (pebble === null) return;\n\n                var data = pebble.__data__;\n                var radius = setPebbleRadius(data);\n\n                if (data.plottype == \'continuous\') (0, _plots.densityNode)(data, pebble, setPebbleRadius(data));else if (data.plottype == \'bar\') (0, _plots.barsNode)(data, pebble, setPebbleRadius(data));\n\n                d3.select(pebble.querySelector("[id^=\'pebbleLabel\']")).style(\'font-size\', radius * .175 + 7 + \'px\'); // proportional scaling would be 14 / 40, but I added y-intercept at 7\n                d3.select(pebble.querySelector("[id^=\'dvArc\']")).attr("d", arc3(radius));\n                d3.select(pebble.querySelector("[id^=\'nomArc\']")).attr("d", arc4(radius));\n                d3.select(pebble.querySelector("[id^=\'grArc\']")).attr("d", arc1(radius));\n                d3.select(pebble.querySelector("[id^=\'gr1indicator\']")).attr("d", arcInd1(radius));\n                d3.select(pebble.querySelector("[id^=\'gr2indicator\']")).attr("d", arcInd2(radius));\n            });\n        };\n\n        g.append("path").each(function (d) {\n            var radius = setPebbleRadius(d);\n            d3.select(this).attr("id", append(\'dvArc\')).attr("d", arc3(radius)).style("fill", dvColor).attr("fill-opacity", 0).on(\'mouseover\', function (d) {\n                var _this = this;\n\n                d.forefront = true;\n                if (hoverPebble === d.name) {\n                    setTimeout(function () {\n                        if (!d.forefront) return;\n                        hoverPebble = d.name;\n                        fillThis(_this, .3, 0, 100);\n                        fill(d, \'dvText\', .9, 0, 100);\n                    }, hoverTimeout);\n                }\n            }).on(\'mouseout\', function (d) {\n                var _this2 = this;\n\n                d.forefront = false;\n                setTimeout(function () {\n                    fillThis(_this2, 0, 100, 500);\n                    fill(d, \'dvText\', 0, 100, 500);\n                }, hoverTimeout);\n            }).on(\'click\', function (d) {\n                setColors(d, dvColor);\n                legend(dvColor);\n                d.group1 = d.group2 = false;\n                selectedPebble = d.name;\n                redrawPebbles();\n                _restart();\n            });\n        });\n\n        g.append("text").attr("id", append(\'dvText\')).attr("x", 6).attr("dy", 11.5).attr("fill-opacity", 0).append("textPath").attr("xlink:href", append(\'#dvArc\')).text("Dep Var");\n\n        g.append("path").each(function (d) {\n            var radius = setPebbleRadius(d);\n            d3.select(this).attr("id", append(\'nomArc\')).attr("d", arc4(radius)).style("fill", nomColor).attr("fill-opacity", 0).on(\'mouseover\', function (d) {\n                var _this3 = this;\n\n                if (d.defaultNumchar == "character") return;\n                d.forefront = true;\n                if (hoverPebble === d.name) {\n                    setTimeout(function () {\n                        if (!d.forefront) return;\n                        hoverPebble = d.name;\n                        fillThis(_this3, .3, 0, 100);\n                        fill(d, "nomText", .9, 0, 100);\n                    }, hoverTimeout);\n                }\n            }).on(\'mouseout\', function (d) {\n                var _this4 = this;\n\n                if (d.defaultNumchar == "character") return;\n                d.forefront = false;\n                setTimeout(function () {\n                    fillThis(_this4, 0, 100, 500);\n                    fill(d, "nomText", 0, 100, 500);\n                }, hoverTimeout);\n            }).on(\'click\', function (d) {\n                if (d.defaultNumchar == "character") return;\n                setColors(d, nomColor);\n                legend(nomColor);\n                selectedPebble = d.name;\n                redrawPebbles();\n                _restart();\n            });\n        });\n\n        g.append("text").attr("id", append("nomText")).attr("x", 6).attr("dy", 11.5).attr("fill-opacity", 0).append("textPath").attr("xlink:href", append("#nomArc")).text("Nominal");\n\n        g.append("path").each(function (d) {\n            var radius = setPebbleRadius(d);\n            d3.select(this).attr("id", append(\'grArc\')).attr("d", arc1(radius)).style("fill", gr1Color).attr("fill-opacity", 0).on(\'mouseover\', function (d) {\n                var _this5 = this;\n\n                fill(d, "gr1indicator", .3, 0, 100);\n                fill(d, "gr2indicator", .3, 0, 100);\n                d.forefront = true;\n                if (hoverPebble === d.name) {\n                    setTimeout(function () {\n                        if (!d.forefront) return;\n                        hoverPebble = d.name;\n                        fillThis(_this5, .3, 0, 100);\n                        fill(d, \'grText\', .9, 0, 100);\n                    }, hoverTimeout);\n                }\n            }).on(\'mouseout\', function (d) {\n                var _this6 = this;\n\n                d.forefront = false;\n                setTimeout(function () {\n                    fill(d, "gr1indicator", 0, 100, 500);\n                    fill(d, "gr2indicator", 0, 100, 500);\n                    fillThis(_this6, 0, 100, 500);\n                    fill(d, \'grText\', 0, 100, 500);\n                }, hoverTimeout);\n            }).on(\'click\', function (d) {\n                //d.group1 = !d.group1;      // This might be easier, but currently set in setColors()\n                setColors(d, gr1Color);\n                legend(gr1Color);\n                selectedPebble = d.name;\n                redrawPebbles();\n                _restart();\n            });\n        });\n\n        g.append("path").each(function (d) {\n            var radius = setPebbleRadius(d);\n            d3.select(this).attr("id", append(\'gr1indicator\')).attr("d", arcInd1(radius)).style("fill", gr1Color) // something like: zparams.zgroup1.indexOf(node.name) > -1  ?  #FFFFFF : gr1Color)\n            .attr("fill-opacity", 0).on(\'mouseover\', function (d) {\n                var _this7 = this;\n\n                d.forefront = true;\n                if (hoverPebble === d.name) {\n                    setTimeout(function () {\n                        if (!d.forefront) return;\n                        hoverPebble = d.name;\n                        fillThis(_this7, .3, 0, 100);\n                        fill(d, "grArc", .1, 0, 100);\n                        fill(d, \'grText\', .9, 0, 100);\n                    }, hoverTimeout);\n                }\n            }).on(\'mouseout\', function (d) {\n                var _this8 = this;\n\n                d.forefront = false;\n                setTimeout(function () {\n                    fillThis(_this8, 0, 100, 500);\n                    fill(d, "grArc", 0, 100, 500);\n                    fill(d, \'grText\', 0, 100, 500);\n                }, hoverTimeout);\n            }).on(\'click\', function (d) {\n                //d.group1 = !d.group1;      // This might be easier, but currently set in setColors()\n                setColors(d, gr1Color);\n                legend(gr1Color);\n                selectedPebble = d.name;\n                redrawPebbles();\n                _restart();\n            });\n        });\n\n        g.append("path").each(function (d) {\n            var radius = setPebbleRadius(d);\n            d3.select(this).attr("id", append(\'gr2indicator\')).attr("d", arcInd2(radius)).style("fill", gr2Color) // something like: zparams.zgroup1.indexOf(node.name) > -1  ?  #FFFFFF : gr1Color)\n            .attr("fill-opacity", 0).on(\'mouseover\', function (d) {\n                var _this9 = this;\n\n                d.forefront = true;\n                if (hoverPebble === d.name) {\n                    setTimeout(function () {\n                        if (!d.forefront) return;\n                        hoverPebble = d.name;\n                        fillThis(_this9, .3, 0, 100);\n                        fill(d, "grArc", .1, 0, 100);\n                        fill(d, \'grText\', .9, 0, 100);\n                    }, hoverTimeout);\n                }\n            }).on(\'mouseout\', function (d) {\n                var _this10 = this;\n\n                d.forefront = false;\n                setTimeout(function () {\n                    fillThis(_this10, 0, 100, 500);\n                    fill(d, "grArc", 0, 100, 500);\n                    fill(d, \'grText\', 0, 100, 500);\n                }, hoverTimeout);\n            }).on(\'click\', function (d) {\n                //d.group2 = !d.group2;      // This might be easier, but currently set in setColors()\n                setColors(d, gr2Color);\n                legend(gr2Color);\n                selectedPebble = d.name;\n                redrawPebbles();\n                _restart();\n            });\n        });\n\n        g.append("text").attr("id", append(\'grText\')).attr("x", 6).attr("dy", 11.5).attr("fill-opacity", 0).append("textPath").attr("xlink:href", append(\'#grArc\')).text("Groups");\n\n        g.append(\'svg:circle\').attr(\'class\', \'node\').attr(\'r\', function (d) {\n            return setPebbleRadius(d);\n        }).style(\'pointer-events\', \'inherit\').style(\'fill\', function (d) {\n            return d.nodeCol;\n        }).style(\'opacity\', "0.5").style(\'stroke\', function (d) {\n            return d3.rgb(d.strokeColor).toString();\n        }).classed(\'reflexive\', function (d) {\n            return d.reflexive;\n        })\n        // TODO should this be used?\n        .on(\'dblclick\', function (_) {\n            d3.event.stopPropagation(); // stop click from bubbling\n            exports.summaryHold = summaryHold = true;\n        }).on(\'click\', function (d) {\n            selectedPebble = d.name;\n            outsideClick = false;\n            redrawPebbles();\n        }).on(\'contextmenu\', function (d) {\n            // right click on node\n            d3.event.preventDefault();\n            d3.event.stopPropagation();\n\n            rightClickLast = true;\n            mousedown_node = d;\n            selected_node = mousedown_node === selected_node ? null : mousedown_node;\n            selected_link = null;\n\n            // reposition drag line\n            drag_line.style(\'marker-end\', is_explore_mode ? \'url(#end-marker)\' : \'url(#end-arrow)\').classed(\'hidden\', false).attr(\'d\', \'M\' + mousedown_node.x + \',\' + mousedown_node.y + \'L\' + mousedown_node.x + \',\' + mousedown_node.y);\n\n            svg.on(\'mousemove\', mousemove);\n            _restart();\n        }).on(\'mouseup\', function (d) {\n            d3.event.stopPropagation();\n\n            if (rightClickLast) {\n                rightClickLast = false;\n                return;\n            }\n            if (!mousedown_node) return;\n\n            // needed by FF\n            drag_line.classed(\'hidden\', true).style(\'marker-end\', \'\');\n\n            // check for drag-to-self\n            mouseup_node = d;\n            if (mouseup_node === mousedown_node) {\n                resetMouseVars();\n                return;\n            }\n\n            // unenlarge target node\n            d3.select(this).attr(\'transform\', \'\');\n\n            // add link to graph (update if exists)\n            // NB: links are strictly source < target; arrows separately specified by booleans\n            var source, target, direction;\n            if (mousedown_node.id < mouseup_node.id) {\n                source = mousedown_node;\n                target = mouseup_node;\n                direction = \'right\';\n            } else {\n                source = mouseup_node;\n                target = mousedown_node;\n                direction = \'left\';\n            }\n\n            var link = links.filter(function (x) {\n                return x.source == source && x.target == target;\n            })[0];\n            if (link) {\n                link[direction] = true;\n            } else {\n                link = {\n                    source: source,\n                    target: target,\n                    left: false,\n                    right: false\n                };\n                link[direction] = true;\n                links.push(link);\n            }\n\n            // select new link\n            selected_link = link;\n            selected_node = null;\n            svg.on(\'mousemove\', null);\n\n            resetMouseVars();\n            _restart();\n        });\n\n        // show node names\n        g.append(\'svg:text\').attr(\'id\', append(\'pebbleLabel\')).attr(\'x\', 0).attr(\'y\', 15).attr(\'class\', \'id\').text(function (d) {\n            return d.name;\n        });\n\n        // show summary stats on mouseover\n        // SVG doesn\'t support text wrapping, use html instead\n        g.selectAll("circle.node").on("mouseover", function (d) {\n\n            d.forefront = true;\n\n            setTimeout(function () {\n                if (leftTab !== \'Summary\') exports.leftTabHidden = leftTabHidden = leftTab;\n                setLeftTab(\'Summary\');\n                varSummary(d);\n\n                byId(\'transformations\').setAttribute(\'style\', \'display:block\');\n                byId("transSel").selectedIndex = d.id;\n                transformVar = valueKey[d.id];\n\n                _mithril2.default.redraw();\n\n                if (!d.forefront) return;\n                hoverPebble = d.name;\n\n                fill(d, "dvArc", .1, 0, 100);\n                fill(d, "dvText", .5, 0, 100);\n                fill(d, "grArc", .1, 0, 100);\n                fill(d, "grText", .5, 0, 100);\n\n                //fill(d, "gr1indicator", .1, 0, 100);\n                //fill(d, "gr1indicatorText", .1, 0, 100);\n                //fill(d, "gr2indicator", .1, 0, 100);\n                //fill(d, "gr2indicatorText", .1, 0, 100);\n\n                if (d.defaultNumchar == "numeric") {\n                    fill(d, "nomArc", .1, 0, 100);\n                    fill(d, "nomText", .5, 0, 100);\n                }\n                fill(d, "csArc", .1, 0, 100);\n                fill(d, "csText", .5, 0, 100);\n                fill(d, "timeArc", .1, 0, 100);\n                fill(d, "timeText", .5, 0, 100);\n            }, hoverTimeout);\n        }).on(\'mouseout\', function (d) {\n            d.forefront = false;\n            setTimeout(function () {\n                hoverPebble = undefined;\n\n                if (selectedPebble) varSummary(allNodes.filter(function (node) {\n                    return node.name === selectedPebble;\n                })[0]);else setLeftTab(leftTabHidden);\n                \'csArc csText timeArc timeText dvArc dvText nomArc nomText grArc grText\'.split(\' \').map(function (x) {\n                    return fill(d, x, 0, 100, 500);\n                });\n                _mithril2.default.redraw();\n            }, hoverTimeout);\n        });\n\n        // the transformation variable list is silently updated as pebbles are added/removed\n        d3.select("#transSel").selectAll(\'li\').remove();\n\n        d3.select("#transSel").selectAll(\'li\').data(nodes.map(function (x) {\n            return x.name;\n        })) // set to variables in model space as they\'re added\n        .enter().append("li").text(function (d) {\n            return d;\n        });\n\n        if (!IS_D3M_DOMAIN) {\n            document.querySelectorAll(\'#transSel li\').forEach(function (x) {\n                return x.onclick(function (evt) {\n                    // if \'interaction\' is the selected function, don\'t show the function list again\n                    var tInput = byId(\'tInput\');\n                    if (selInteract) {\n                        var n = tInput.value.concat(this.textContent);\n                        tInput.value = n;\n                        evt.stopPropagation();\n                        var _t = transParse(n = n);\n                        if (!_t) return;\n                        (0, _utils.fadeOut)(this.parentNode, 100);\n                        transform(n = _t.slice(0, _t.length - 1), _t = _t[_t.length - 1], typeTransform = false);\n                        return;\n                    }\n\n                    tInput.value = this.textContent;\n                    (0, _utils.fadeOut)(this.parentNode, 100);\n                    (0, _utils.fadeOut)(\'#transList\', 100);\n                    evt.stopPropagation();\n                });\n            });\n        };\n\n        // remove old nodes\n        circle.exit().remove();\n        force.start();\n\n        // save workspaces\n        // console.log(\'ok ws\');\n        record_user_metadata();\n    };\n\n    function mousedown(d) {\n        selectedPebble = undefined;\n        // prevent I-bar on drag\n        d3.event.preventDefault();\n        // because :active only works in WebKit?\n        svg.classed(\'active\', true);\n        if (d3.event.ctrlKey || mousedown_node || mousedown_link) return;\n        outsideClick = true;\n        _restart();\n    }\n\n    function mousemove(d) {\n        if (!mousedown_node) return;\n        // update drag line\n        drag_line.attr(\'d\', \'M\' + mousedown_node.x + \',\' + mousedown_node.y + \'L\' + d3.mouse(this)[0] + \',\' + d3.mouse(this)[1]);\n    }\n\n    function mouseup(d) {\n        if (mousedown_node) {\n            drag_line.classed(\'hidden\', true).style(\'marker-end\', \'\');\n        }\n        if (outsideClick) {\n            outsideClick = false;\n            if (leftTabHidden) {\n                setLeftTab(leftTabHidden);\n                exports.leftTabHidden = leftTabHidden = undefined;\n                _mithril2.default.redraw();\n            }\n        }\n        // because :active only works in WebKit?\n        svg.classed(\'active\', false);\n        // clear mouse event vars\n        resetMouseVars();\n    }\n\n    // app starts here\n    svg.attr(\'id\', function () {\n        return "whitespace".concat(myspace);\n    }).attr(\'height\', height).attr(\'width\', width).on(\'mousedown\', function () {\n        mousedown(this);\n    }).on(\'mouseup\', function () {\n        mouseup(this);\n    });\n\n    d3.select(window).on(\'click\', function () {\n        // all clicks will bubble here unless event.stopPropagation()\n        (0, _utils.fadeOut)(\'#transList\', 100);\n        (0, _utils.fadeOut)(\'#transSel\', 100);\n    });\n\n    _restart(); // initializes force.layout()\n    fakeClick();\n\n    if (v2 & IS_D3M_DOMAIN) {\n        var click_ev = document.createEvent("MouseEvents");\n        // initialize the event\n        click_ev.initEvent("click", true /* bubble */, true /* cancelable */);\n        // trigger the event\n        var clickID = "dvArc" + findNodeIndex(mytarget);\n        byId(clickID).dispatchEvent(click_ev);\n\n        // The dispatched click sets the leftpanel. This switches the panel back on page load\n        selectedPebble = undefined;\n        mouseup();\n    }\n}\n\n/** needs doc */\nfunction find($nodes, name) {\n    for (var i in $nodes) {\n        if ($nodes[i].name == name) return $nodes[i].id;\n    }\n}\n\n/**\n returns id\n */\nfunction findNodeIndex(name, whole) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n        for (var _iterator = allNodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var node = _step.value;\n\n            if (node.name === name) return whole ? node : node.id;\n        }\n    } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n            }\n        } finally {\n            if (_didIteratorError) {\n                throw _iteratorError;\n            }\n        }\n    }\n}\n\n/** needs doc */\nfunction nodeIndex(nodeName) {\n    for (var i in nodes) {\n        if (nodes[i].name === nodeName) return i;\n    }\n}\n\n/** needs doc */\nfunction findNode(name) {\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n        for (var _iterator2 = allNodes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var n = _step2.value;\n\n            if (n.name === name) return n;\n        }\n    } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                _iterator2.return();\n            }\n        } finally {\n            if (_didIteratorError2) {\n                throw _iteratorError2;\n            }\n        }\n    }\n}\n\n/** needs doc */\nfunction updateNode(id) {\n    var node = findNode(id);\n    if (node.grayout) return false;\n\n    var name = node.name;\n    var names = function names() {\n        return nodes.map(function (n) {\n            return n.name;\n        });\n    };\n    if (names().includes(name)) {\n        del(nodes, node.index);\n        links.filter(function (l) {\n            return l.source === node || l.target === node;\n        }).forEach(function (l) {\n            return del(links, -1, l);\n        });\n        zparamsReset(name);\n\n        // remove node name from group lists\n        node.group1 && del(zparams.zgroup1, -1, name);\n        node.group2 && del(zparams.zgroup2, -1, name);\n        node.group1 = node.group2 = false;\n\n        // node reset - perhaps this will become a hard reset back to all original allNode values?\n        node.nodeCol = node.baseCol;\n        node.strokeColor = _plots.selVarColor;\n        node.strokeWidth = \'1\';\n\n        borderState();\n    } else {\n        nodes.push(node);\n    }\n    zparams.zvars = names();\n    return true;\n}\n\n/**\n every time a variable in leftpanel is clicked, nodes updates and background color changes\n */\nfunction clickVar(elem) {\n    if (updateNode(elem)) {\n        // panelPlots(); is this necessary?\n        _restart();\n    }\n}\n\n// Used for left panel variable search\nvar matchedVariables = exports.matchedVariables = [];\nvar searchVariables = exports.searchVariables = function searchVariables(val) {\n    matchedVariables.length = 0;\n\n    var others = [],\n        match = function match(n, key) {\n        return n[key].toLowerCase().includes(val.toLowerCase());\n    };\n\n    allNodes.forEach(function (n) {\n        return match(n, \'name\') || match(n, \'labl\') ? matchedVariables.push(n.name) : others.push(n.name);\n    });\n    exports.valueKey = valueKey = matchedVariables.concat(others);\n\n    // Just because having every variable bordered all the time is not pleasant\n    if (val === \'\') matchedVariables.length = 0;\n};\n\n/**\n Retrieve the variable list from the preprocess data.\n This helps handle the new format and (temporarily)\n the older format in PRODUCTION (rp 8.14.2017)\n "new" response:\n {\n "dataset" : {...}\n "variables" : {\n "var1" : {...},\n (etc)\n }\n }\n "old" response:\n {\n "var1" : {...},\n (etc)\n }\n */\nfunction getVariableData(json) {\n    return json.hasOwnProperty(\'variables\') ? json.variables : json;\n}\n\n/**\n called by force button\n */\nfunction forceSwitch() {\n    exports.forcetoggle = forcetoggle = [forcetoggle[0] == \'true\' ? \'false\' : \'true\'];\n    if (forcetoggle[0] === "false") {\n        byId(\'btnForce\').setAttribute("class", "btn active");\n    } else {\n        byId(\'btnForce\').setAttribute("class", "btn btn-default");\n        fakeClick();\n    }\n}\n\n/** needs doc */\nfunction helpmaterials(type) {\n    if (type == "video") {\n        var win = window.open("http://2ra.vn/demos/d3mintegrationdemo.mp4", \'_blank\');\n        win.focus();\n    } else {\n        var win = window.open("http://2ra.vn/papers/tworavens-d3mguide.pdf", \'_blank\');\n        win.focus();\n    }\n    console.log(type);\n}\n\n/** needs doc */\nvar lockDescription = exports.lockDescription = function lockDescription(state) {\n    return exports.locktoggle = locktoggle = state;\n};\n\n/** needs doc */\nfunction zPop() {\n    if (dataurl) zparams.zdataurl = dataurl;\n    zparams.zmodelcount = modelCount;\n    zparams.zedges = [];\n    zparams.zvars = [];\n    zparams.znature = [];\n    for (var j = 0; j < nodes.length; j++) {\n        //populate zvars array\n        zparams.zvars.push(nodes[j].name);\n        zparams.znature.push(nodes[j].nature);\n        var temp = nodes[j].id;\n        zparams.zsetx[j] = allNodes[temp].setxvals;\n        zparams.zsubset[j] = allNodes[temp].subsetrange;\n    }\n    for (var _j2 = 0; _j2 < links.length; _j2++) {\n        //populate zedges array\n        //correct the source target ordering for Zelig\n        var srctgt = links[_j2].left == false ? [links[_j2].source.name, links[_j2].target.name] : [links[_j2].target.name, links[_j2].source.name];\n        zparams.zedges.push(srctgt);\n    }\n}\n\n// when selected, the key/value [mode]: [pipelineID] is set.\nvar selectedPipeline = exports.selectedPipeline = {};\nvar setSelectedPipeline = exports.setSelectedPipeline = function setSelectedPipeline(result) {\n    selectedPipeline[currentMode] = result;\n    if (currentMode === \'model\') {\n        // the \'find\' function would have been nice here-- es6 only. Find pipeline with UID, then pass pipeline_id\n        var pipeline = pipelineTable.filter(function (row) {\n            return row[0] == result;\n        })[0];\n        resultsplotinit(pipeline[1]);\n    }\n};\n\nvar pipelineHeader = exports.pipelineHeader = [\'Hidden_UID\', \'PipelineID\', \'Metric\', \'Score\'];\nvar pipelineTable = exports.pipelineTable = void 0;\n\nfunction onPipelineCreate(PipelineCreateResult, rookpipe) {\n    // rpc GetExecutePipelineResults(PipelineExecuteResultsRequest) returns (stream PipelineExecuteResult) {}\n    estimateLadda.stop(); // stop spinner\n    console.log(PipelineCreateResult);\n\n    // change status of buttons for estimating problem and marking problem as finished\n    byId("btnEstimate").classList.remove("btn-success");\n    byId("btnEstimate").classList.add("btn-default");\n    byId("btnEndSession").classList.remove("btn-default");\n    byId("btnEndSession").classList.add("btn-success");\n\n    var context = apiSession(zparams.zsessionid);\n    for (var i = 0; i < PipelineCreateResult.length; i++) {\n        if (PipelineCreateResult[i].pipelineId in allPipelineInfo) {\n            allPipelineInfo[PipelineCreateResult[i].pipelineId] = Object.assign(allPipelineInfo[PipelineCreateResult[i].pipelineId], PipelineCreateResult[i]);\n        } else {\n            allPipelineInfo[PipelineCreateResult[i].pipelineId] = PipelineCreateResult[i];\n        }\n    }\n    console.log(allPipelineInfo);\n    // to get all pipeline ids: Object.keys(allPipelineInfo)\n\n    exports.pipelineTable = pipelineTable = [];\n    for (var key in allPipelineInfo) {\n        console.log(key);\n        console.log(allPipelineInfo[key]);\n\n        if (key == "rookpipe") {\n            // happens when multiple CreatePipelines calls have been made\n            continue;\n        }\n        // this will NOT report the pipeline to user if pipeline has failed, if pipeline is still running, or if it has not completed\n        if (allPipelineInfo[key].responseInfo.status.details == "Pipeline Failed") {\n            continue;\n        }\n        if (allPipelineInfo[key].progressInfo == "RUNNING") {\n            continue;\n        }\n\n        var myid = "";\n        var mymetric = "";\n        var myval = "";\n        console.log(key);\n        console.log(allPipelineInfo[key].progressInfo);\n        var myscores = [];\n        if (allPipelineInfo[key].progressInfo == "COMPLETED") {\n            myscores = allPipelineInfo[key].pipelineInfo.scores;\n            for (var i = 0; i < myscores.length; i++) {\n                //if(i==0) {myid=key;}\n                //   else myid="";\n                myid = key;\n                mymetric = myscores[i].metric;\n                myval = +myscores[i].value.toFixed(3);\n                pipelineTable.push([pipelineTable.length, myid, mymetric, myval]);\n            }\n        } else {\n            // if progressInfo is not "COMPLETED"\n            continue;\n        }\n    }\n\n    console.table(pipelineTable, [1, 2, 3]);\n\n    if (IS_D3M_DOMAIN) {\n        byId("btnSetx").click(); // Was "btnResults" - changing to simplify user experience for testing.\n    };\n\n    //adding rookpipe to allPipelineInfo\n    allPipelineInfo.rookpipe = rookpipe; // This is setting rookpipe for the entire table, but when there are multiple CreatePipelines calls, this is only recording latest values\n\n    // this initializes the results windows using the first pipeline ID\n    if (!swandive) {\n        resultsplotinit(pipelineTable[0][1]);\n    }\n    // VJD: these two functions are built and (I believe) functioning as intended. These exercise two core API calls that are currently unnecessary\n    //exportpipeline(pipelineTable[1][1]);\n    //listpipelines();\n\n    // VJD: this is a third core API call that is currently unnecessary\n    //let pipelineid = PipelineCreateResult.pipelineid;\n    // getexecutepipelineresults is the third to be called\n    //  makeRequest(D3M_SVC_URL + \'/getexecutepipelineresults\', {context, pipeline_ids: Object.keys(allPipelineInfo)});\n}\n\nfunction CreatePipelineData(predictors, depvar, aux) {\n    var context = apiSession(zparams.zsessionid);\n    var uriCsv = zparams.zd3mdata;\n    var uriJson = uriCsv.substring(0, uriCsv.lastIndexOf("/tables")) + "/datasetDoc.json";\n    var targetFeatures = [{ \'resource_id\': "0", \'feature_name\': depvar[0] }];\n    var predictFeatures = [];\n    for (var i = 0; i < predictors.length; i++) {\n        predictFeatures[i] = { \'resource_id\': "0", \'feature_name\': predictors[i] };\n    }\n    if (typeof aux === "undefined") {\n        //default behavior for creating pipeline data\n        return {\n            context: context,\n            dataset_uri: uriJson, // uriCsv is also valid, but not currently accepted by ISI TA2\n            task: d3mTaskType[d3mProblemDescription.taskType][1],\n            taskSubtype: d3mTaskSubtype[d3mProblemDescription.taskSubtype][1],\n            taskDescription: d3mProblemDescription.taskDescription,\n            output: "OUTPUT_TYPE_UNDEFINED", // valid values will come in future API\n            metrics: [d3mMetrics[d3mProblemDescription.metric][1]],\n            targetFeatures: targetFeatures,\n            /* Example:\n              "targetFeatures": [\n              {\n                  "resource_id": "0",\n                  "feature_name": "At_bats"\n              }\n              ],\n            */\n            predictFeatures: predictFeatures,\n            /* Example:\n              "predictReatures": [\n              {\n                "resource_id": "0",\n                "feature_name": "RBIs"\n              }\n              ],\n            */\n            maxPipelines: 5 //user to specify this eventually?\n        };\n    } else {\n        //creating pipeline data for problem discovery using aux inputs\n        return {\n            context: context,\n            dataset_uri: uriJson, // uriCsv is also valid, but not currently accepted by ISI TA2\n            task: aux.task,\n            taskSubtype: "TASK_SUBTYPE_UNDEFINED",\n            taskDescription: aux.description,\n            output: "OUTPUT_TYPE_UNDEFINED",\n            metrics: [aux.metrics],\n            targetFeatures: targetFeatures,\n            predictFeatures: predictFeatures,\n            maxPipelines: 1\n        };\n    }\n}\n\nfunction downloadIncomplete() {\n    if (PRODUCTION && zparams.zsessionid === \'\') {\n        alert(\'Warning: Data download is not complete. Try again soon.\');\n        return true;\n    }\n    return false;\n}\n\n/**\n    called by clicking \'Solve This Problem\' in model mode\n*/\nasync function estimate(btn) {\n    if (!IS_D3M_DOMAIN) {\n        if (downloadIncomplete()) {\n            return;\n        }\n\n        zPop();\n        // write links to file & run R CMD\n        // package the output as JSON\n        // add call history and package the zparams object as JSON\n        zparams.callHistory = callHistory;\n        zparams.allVars = valueKey.slice(10, 25); // because the URL is too long...\n\n        /* UNUSED\n        var selectorurlcall = ROOK_SVC_URL + "selectorapp";\n        function selectorSuccess(btn, json) {\n            d3.select("#ticker")\n                .text("Suggested variables and percent improvement on RMSE: " + json.vars);\n            cdb("selectorSuccess: ", json);\n        }\n        function selectorFail(btn) {\n            alert("Selector Fail");\n        }\n        */\n\n        estimateLadda.start(); // start spinner\n        var json = await makeRequest(ROOK_SVC_URL + \'zeligapp\', zparams);\n        if (!json) {\n            estimated = true;\n        } else {\n            var modCol = function modCol() {\n                d3.select("#modelView").selectAll("p").style(\'background-color\', hexToRgba(varColor));\n            };\n\n            allResults.push(json);\n            if (!estimated) byId("tabResults").removeChild(byId("resultsHolder"));\n\n            estimated = true;\n            d3.select("#tabResults").style("display", "block");\n            d3.select("#resultsView").style("display", "block");\n            d3.select("#modelView").style("display", "block");\n\n            // programmatic click on Results button\n            trigger("btnSetx", "click"); // Was "btnResults" - changing to simplify user experience for testing.\n\n            var model = "Model".concat(exports.modelCount = modelCount = modelCount + 1);\n\n            modCol();\n\n            d3.select("#modelView").insert("p", ":first-child") // top stack for results\n            .attr("id", model).text(model).style(\'background-color\', hexToRgba(_plots.selVarColor)).on("click", function () {\n                var a = this.style.backgroundColor.replace(/\\s*/g, "");\n                var b = hexToRgba(_plots.selVarColor).replace(/\\s*/g, "");\n                if (a.substr(0, 17) == b.substr(0, 17)) return; // escape function if displayed model is clicked\n                modCol();\n                d3.select(this).style(\'background-color\', hexToRgba(_plots.selVarColor));\n                viz(this.id);\n            });\n\n            var rCall = [json.call];\n            showLog(\'estimate\', rCall);\n\n            viz(model);\n        }\n    } else if (swandive) {\n        // IS_D3M_DOMAIN and swandive is true\n        zPop();\n        zparams.callHistory = callHistory;\n\n        var myvki = valueKey.indexOf(mytarget);\n        if (myvki != -1) {\n            del(valueKey, myvki);\n        }\n\n        estimateLadda.start(); // start spinner\n        var res = await makeRequest(D3M_SVC_URL + \'/CreatePipelines\', CreatePipelineData(valueKey, mytarget));\n        res && onPipelineCreate(res);\n    } else {\n        // we are in IS_D3M_DOMAIN no swandive\n        // rpc CreatePipelines(PipelineCreateRequest) returns (stream PipelineCreateResult) {}\n        zPop();\n        zparams.callHistory = callHistory;\n\n        // pipelineapp is a rook application that returns the dependent variable, the DV values, and the predictors. can think of it was a way to translate the potentially complex grammar from the UI\n\n        estimateLadda.start(); // start spinner\n\n        // 1. Some diagnostic tests to add special characters to the pipelineapp call:\n        //zparams.zgroup1.unshift("blah+");\n        //zparams.zgroup1.unshift("Alice-was_beg!n^ing t* get/ ve#y tired of s(tt)ng by her si$\\+er on th= bank & of having nothing to do:");\n\n        // 2. Note how they go out in call:\n        //console.log("zparams zgroup1");\n        //console.log(zparams.zgroup1);      // Notice zgroup1 is being sent with correct characters\n\n        var rookpipe = await makeRequest(ROOK_SVC_URL + \'pipelineapp\', zparams);\n\n        // 3. And check they come back correctly formed:\n        //console.log("pipeline app return (rookpipe)");\n        //console.log(rookpipe);\n\n        if (!rookpipe) {\n            estimated = true;\n        } else {\n\n            setxTable(rookpipe.predictors);\n            //     let dvvals = res.dvvalues;\n            //    let dvvar = res.depvar[0];\n            var _res = await makeRequest(D3M_SVC_URL + \'/CreatePipelines\', CreatePipelineData(rookpipe.predictors, rookpipe.depvar));\n            //   res = await makeRequest(ROOK_SVC_URL + \'createpipeline\', zparams);\n            _res && onPipelineCreate(_res, rookpipe);\n        }\n    }\n    exports.task2_finished = task2_finished = true;\n}\n\n/** needs doc */\nfunction ta2stuff() {\n    console.log(d3mProblemDescription);\n}\n\n/** needs doc */\nasync function dataDownload() {\n    zPop();\n    // write links to file & run R CMD\n\n    // package the output as JSON\n    // add call history and package the zparams object as JSON\n    var res = await makeRequest(ROOK_SVC_URL + \'dataapp\', zparams);\n    if (!res) {\n        return;\n    }\n\n    zparams.zsessionid = res.sessionid[0];\n    // set link URL\n    byId("logID").href = \'\' + (PRODUCTION ? ROOK_SVC_URL + \'log_dir/log_\' : \'rook/log_\') + zparams.zsessionid + \'.txt\';\n}\n\n/** needs doc */\nfunction viz(mym) {\n    mym = +mym.substr(5, 5) - 1;\n\n    var removeKids = function removeKids(parent) {\n        while (parent.firstChild) {\n            parent.removeChild(parent.firstChild);\n        }\n    };\n    removeKids(byId("resultsView"));\n\n    var json = allResults[mym];\n\n    // pipe in figures to right panel\n    var filelist = new Array();\n    for (var i in json.images) {\n        var zfig = document.createElement("img");\n        zfig.setAttribute("src", json.images[i]);\n        zfig.setAttribute(\'width\', 200);\n        zfig.setAttribute(\'height\', 200);\n        byId("resultsView").appendChild(zfig);\n    }\n\n    // write the results table\n    var resultsArray = [];\n    for (var key in json.sumInfo) {\n        if (key == \'colnames\') continue;\n        resultsArray.push(json.sumInfo[key]);\n    }\n\n    var table = d3.select("#resultsView").append("p").append("table");\n\n    var thead = table.append("thead");\n    thead.append("tr").selectAll("th").data(json.sumInfo.colnames).enter().append("th").text(function (d) {\n        return d;\n    });\n\n    var tbody = table.append("tbody");\n    tbody.selectAll("tr").data(resultsArray).enter().append("tr").selectAll("td").data(function (d) {\n        return d;\n    }).enter().append("td").text(function (d) {\n        var myNum = Number(d);\n        if (isNaN(myNum)) return d;\n        return myNum.toPrecision(3);\n    }).on("mouseover", function () {\n        d3.select(this).style("background-color", "aliceblue");\n    }) // for no discernable reason\n    .on("mouseout", function () {\n        d3.select(this).style("background-color", "#F9F9F9");\n    }); //(but maybe we\'ll think of one)\n\n    d3.select("#resultsView").append("p").html(function () {\n        return "<b>Formula: </b>".concat(json.call[0]);\n    });\n\n    _mithril2.default.redraw();\n}\n\n/**\n   parses the transformation input.\n   variable names are often nested inside one another, e.g., ethwar, war, wars, and so this is handled\n*/\nfunction transParse(n) {\n    var out2 = [];\n    var t2 = n;\n    var k2 = 0;\n    var subMe2 = "_transvar".concat(k2);\n    var indexed = [];\n\n    // out2 is all matched variables, indexed is an array, each element is an object that contains the matched variables starting index and finishing index.  e.g., n="wars+2", out2=[war, wars], indexed=[{0,2},{0,3}]\n    for (var i in valueKey) {\n        var m2 = n.match(valueKey[i]);\n        if (m2 != null) out2.push(m2[0]);\n\n        var re = new RegExp(valueKey[i], "g");\n        var s = n.search(re);\n        if (s != -1) indexed.push({ from: s, to: s + valueKey[i].length });\n    }\n\n    // nested loop not good, but indexed is not likely to be very large.\n    // if a variable is nested, it is removed from out2\n    // notice, loop is backwards so that index changes don\'t affect the splice\n    cdb("indexed ", indexed);\n    for (var i = indexed.length - 1; i > -1; i--) {\n        for (var j = indexed.length - 1; j > -1; j--) {\n            if (i === j) continue;\n            if (indexed[i].from >= indexed[j].from & indexed[i].to <= indexed[j].to) {\n                cdb(i, " is nested in ", j);\n                del(out2, i);\n            }\n        }\n    }\n\n    for (var i in out2) {\n        t2 = t2.replace(out2[i], subMe2); //something that\'ll never be a variable name\n        k2 = k2 + 1;\n        subMe2 = "_transvar".concat(k2);\n    }\n\n    if (out2.length > 0) {\n        out2.push(t2);\n        cdb("new out ", out2);\n        return out2;\n    } else {\n        alert("No variable name found. Perhaps check your spelling?");\n        return null;\n    }\n}\n\n/**\n   n = name of column/node\n   t = selected transformation\n*/\nasync function transform(n, t, typeTransform) {\n    if (downloadIncomplete()) {\n        return;\n    }\n\n    if (!typeTransform) t = t.replace("+", "_plus_"); // can\'t send the plus operator\n\n    cdb(\'name of col: \' + n);\n    cdb(\'transformation: \' + t);\n\n    var btn = byId(\'btnEstimate\');\n\n    // find the node by name\n    var myn = findNodeIndex(n[0], true);\n\n    if (typeof myn === "undefined") {\n        myn = findNodeIndex(n, true);\n    }\n\n    var outtypes = {\n        varnamesTypes: n,\n        interval: myn.interval,\n        numchar: myn.numchar,\n        nature: myn.nature,\n        binary: myn.binary\n    };\n\n    cdb(myn);\n    // if typeTransform but we already have the metadata\n    if (typeTransform) {\n        if (myn.nature == "nominal" & typeof myn.plotvalues !== "undefined") {\n            myn.plottype = "bar";\n            (0, _plots.barsNode)(myn);\n            panelPlots();\n            return;\n        } else if (myn.nature != "nominal" & typeof myn.plotx !== "undefined") {\n            myn.plottype = "continuous";\n            (0, _plots.densityNode)(myn);\n            panelPlots();\n            return;\n        }\n    }\n\n    estimateLadda.start(); // start spinner\n    var json = await makeRequest(ROOK_SVC_URL + \'transformapp\', { zdataurl: dataurl,\n        zvars: myn.name,\n        zsessionid: zparams.zsessionid,\n        transform: t,\n        callHistory: callHistory,\n        typeTransform: typeTransform,\n        typeStuff: outtypes });\n    if (!json) {\n        return;\n    }\n\n    // Is this a typeTransform?\n    if (json.typeTransform[0]) {\n        // Yes. We\'re updating an existing node\n        d3.json(json.url, function (err, data) {\n            if (err) return console.warn(err);\n            var node = void 0;\n            for (var key in data) {\n                node = findNodeIndex(key, true);\n                if (!node) continue;\n                jQuery.extend(true, node, data[key]);\n                node.plottype === "continuous" ? (0, _plots.densityNode)(node) : node.plottype === "bar" ? (0, _plots.barsNode)(node) : null;\n            }\n            fakeClick();\n            panelPlots();\n            node && cdb(node);\n        });\n    } else {\n        /* No, we have a new node here--e.g. the transformed column\n           example response: {\n           "call":["t_year_2"],\n           "url":["data/preprocessSubset_BACCBC78-7DD9-4482-B31D-6EB01C3A0C95.txt"],\n           "trans":["year","_transvar0^2"],\n           "typeTransform":[false]\n           }\n        */\n        callHistory.push({\n            func: "transform",\n            zvars: n,\n            transform: t\n        });\n\n        var subseted = false;\n        var rCall = [];\n\n        rCall[0] = json.call;\n        var newVar = rCall[0][0];\n\n        trans.push(newVar);\n\n        // Read the preprocess file containing values\n        // for the transformed variable\n        //\n        d3.json(json.url, function (error, json) {\n            if (error) return console.warn(error);\n\n            var jsondata = getVariableData(json);\n\n            for (var key in jsondata) {\n                var myIndex = findNodeIndex(key);\n                if (typeof myIndex !== "undefined") {\n                    alert("Invalid transformation: this variable name already exists.");\n                    return;\n                }\n                // add transformed variable to the current space\n                var i = allNodes.length; // get new index\n                var obj1 = {\n                    id: i,\n                    reflexive: false,\n                    name: key,\n                    labl: "transformlabel",\n                    data: [5, 15, 20, 0, 5, 15, 20],\n                    count: [.6, .2, .9, .8, .1, .3, .4],\n                    nodeCol: colors(i),\n                    baseCol: colors(i),\n                    strokeColor: _plots.selVarColor,\n                    strokeWidth: "1",\n                    subsetplot: false,\n                    subsetrange: ["", ""],\n                    setxplot: false,\n                    setxvals: ["", ""],\n                    grayout: false,\n                    defaultInterval: jsondata[key].interval,\n                    defaultNumchar: jsondata[key].numchar,\n                    defaultNature: jsondata[key].nature,\n                    defaultBinary: jsondata[key].binary\n                };\n\n                jQuery.extend(true, obj1, jsondata[key]);\n                allNodes.push(obj1);\n\n                valueKey.push(newVar);\n                nodes.push(allNodes[i]);\n                fakeClick();\n                panelPlots();\n\n                if (allNodes[i].plottype === "continuous") {\n                    (0, _plots.densityNode)(allNodes[i]);\n                } else if (allNodes[i].plottype === "bar") {\n                    (0, _plots.barsNode)(allNodes[i]);\n                }\n\n                _mithril2.default.redraw();\n            }\n        });\n\n        showLog(\'transform\', rCall);\n    }\n}\n\nasync function makeRequest(url, data) {\n    console.log(\'url:\', url);\n    console.log(\'POST:\', data);\n    var res = void 0;\n    try {\n        res = await _mithril2.default.request(url, { method: \'POST\', data: data });\n        console.log(\'response:\', res);\n        if (Object.keys(res)[0] === \'warning\') {\n            alert(\'Warning: \' + res.warning);\n            end_ta3_search(false, res.warning);\n        }\n    } catch (err) {\n        end_ta3_search(false, err);\n        cdb(err);\n        alert(\'Error: call to \' + url + \' failed\');\n    }\n\n    /*\n     // call end_ta3_search if status != OK\n     // status may be in different places for different calls though, and this is not worth doing at the moment\n     let myreg = /d3m-service/g;\n     let isd3mcall = myreg.test(url);\n     if(isd3mcall) {\n         let mystatus = res.responseInfo.status.code.toUpperCase();\n         if(mystatus != "OK") {\n             end_ta3_search(false, "grpc response status not ok");\n         }\n     }\n     */\n\n    if (!IS_D3M_DOMAIN) {\n        estimateLadda.stop(); // estimateLadda is being stopped in onPipelineCreate in D3M\n    };\n    return res;\n}\n\n/** needs doc */\nfunction legend() {\n    borderState();\n    _mithril2.default.redraw();\n}\n\n/**\n   programmatically deselect every selected variable\n*/\nfunction erase() {\n    setLeftTab(\'Variables\');\n\n    valueKey.forEach(function (element) {\n        if (zparams.zdv.concat(zparams.znom, zparams.zvars).includes(element)) // names start with varList now\n            clickVar(element);\n    });\n}\n\n/** needs doc */\nvar setLeftTab = exports.setLeftTab = function setLeftTab(tab) {\n    exports.leftTab = leftTab = tab;\n    updateLeftPanelWidth();\n\n    if (tab === "Discovery") {\n        probtable.length = 0;\n        for (var i = 0; i < disco.length; i++) {\n            var mypredictors = disco[i].predictors.join();\n            probtable.push([i, disco[i].target, mypredictors, disco[i].task, disco[i].metric]);\n        }\n\n        document.getElementById("discoveryInput").value = disco[0].description;\n    }\n};\n\nvar summary = exports.summary = { data: [] };\n\n/** needs doc */\nfunction varSummary(d) {\n    var t1 = \'Mean:, Median:, Most Freq:, Occurrences:, Median Freq:, Occurrences:, Least Freq:, Occurrences:, Std Dev:, Minimum:, Maximum:, Invalid:, Valid:, Uniques:, Herfindahl\'.split(\', \');\n\n    d3.select(\'#tabSummary\').selectAll(\'svg\').remove();\n\n    if (!d.plottype) return;\n    d.plottype == \'continuous\' ? (0, _plots.density)(d, \'Summary\', priv) : d.plottype == "bar" ? (0, _plots.bars)(d, \'Summary\', priv) : d3.select("#tabSummary") // no graph to draw, but still need to remove previous graph\n    .selectAll("svg").remove();\n\n    var rint = d3.format(\'r\');\n    var str = function str(x, p) {\n        return (+x).toPrecision(p || 4).toString();\n    };\n    var t2 = priv && d.meanCI ? [str(d.mean, 2) + \' (\' + str(d.meanCI.lowerBound, 2) + \' - \' + str(d.meanCI.upperBound, 2) + \')\', str(d.median), d.mode, rint(d.freqmode), d.mid, rint(d.freqmid), d.fewest, rint(d.freqfewest), str(d.sd), str(d.min), str(d.max), rint(d.invalid), rint(d.valid), rint(d.uniques), str(d.herfindahl)] : [str(d.mean), str(d.median), d.mode, rint(d.freqmode), d.mid, rint(d.freqmid), d.fewest, rint(d.freqfewest), str(d.sd), str(d.min), str(d.max), rint(d.invalid), rint(d.valid), rint(d.uniques), str(d.herfindahl)];\n\n    summary.data = [];\n    t1.forEach(function (e, i) {\n        return !t2[i].includes(\'NaN\') && t2[i] != \'NA\' && t2[i] != \'\' && summary.data.push([e, t2[i]]);\n    });\n\n    summary.name = d.name;\n    summary.labl = d.labl;\n}\n\nvar popoverContent = exports.popoverContent = function popoverContent(d) {\n    if (swandive) return;\n    var text = \'<table class="table table-sm table-striped" style="margin:-10px;"><tbody>\';\n    var _ref3 = [d3.format(\'r\'), function (val, int) {\n        return (+val).toPrecision(int).toString();\n    }],\n        rint = _ref3[0],\n        prec = _ref3[1];\n\n    var div = function div(field, name, val) {\n        if (field != \'NA\') text += \'<tr><th>\' + name + \'</th><td><p class="text-left" style="height:10px;">\' + (val || field) + \'</p></td></tr>\';\n    };\n    d.labl != \'\' && div(d.labl, \'Label\');\n    div(d.mean, \'Mean\', priv && d.meanCI ? prec(d.mean, 2) + \' (\' + prec(d.meanCI.lowerBound, 2) + \' - \' + prec(d.meanCI.upperBound, 2) + \')\' : prec(d.mean, 4));\n    div(d.median, \'Median\', prec(d.median, 4));\n    div(d.mode, \'Most Freq\');\n    div(d.freqmode, \'Occurrences\', rint(d.freqmode));\n    div(d.mid, \'Median Freq\');\n    div(d.freqmid, \'Occurrences\', rint(d.freqmid));\n    div(d.fewest, \'Least Freq\');\n    div(d.freqfewest, \'Occurrences\', rint(d.freqfewest));\n    div(d.sd, \'Stand Dev\', prec(d.sd, 4));\n    div(d.max, \'Maximum\', prec(d.max, 4));\n    div(d.min, \'Minimum\', prec(d.min, 4));\n    div(d.invalid, \'Invalid\', rint(d.invalid));\n    div(d.valid, \'Valid\', rint(d.valid));\n    div(d.uniques, \'Uniques\', rint(d.uniques));\n    div(d.herfindahl, \'Herfindahl\', prec(d.herfindahl, 4));\n    return text + \'</tbody></table>\';\n};\n\n/** needs doc */\nfunction panelPlots() {\n\n    if (IS_D3M_DOMAIN) {}\n    //byId(\'btnSubset\').classList.add(\'noshow\');\n\n    // build arrays from nodes in main\n    var vars = [];\n    var ids = [];\n    nodes.forEach(function (n) {\n        vars.push(n.name.replace(/\\(|\\)/g, \'\'));\n        ids.push(n.id);\n    });\n\n    //remove all plots, could be smarter here\n    d3.select(\'#setxLeft\').selectAll(\'svg\').remove();\n    for (var i = 0; i < vars.length; i++) {\n        if (allNodes[ids[i]].valid == 0) // this was a silent error... very frustrating...\n            continue;\n        var node = allNodes[ids[i]];\n        node.setxplot = false;\n        node.subsetplot = false;\n        if (node.plottype === "continuous" & node.setxplot == false) {\n            node.setxplot = true;\n            (0, _plots.density)(node, div = "setxLeft", priv);\n            node.subsetplot = true;\n            (0, _plots.density)(node, div = "Summary", priv);\n        } else if (node.plottype === "bar" & node.setxplot == false) {\n            node.setxplot = true;\n            (0, _plots.bars)(node, div = "setxLeft", priv);\n            node.subsetplot = true;\n            (0, _plots.barsSubset)(node);\n        }\n    }\n\n    d3.select("#setxLeft").selectAll("svg").each(function () {\n        d3.select(this);\n        var regstr = /(.+)_setxLeft_(\\d+)/;\n        var myname = regstr.exec(this.id);\n        var nodeid = myname[2];\n        myname = myname[1];\n        if (!vars.includes(myname)) {\n            allNodes[nodeid].setxplot = false;\n            var temp = "#".concat(myname, "_setxLeft_", nodeid);\n            d3.select(temp).remove();\n            allNodes[nodeid].subsetplot = false;\n            temp = "#".concat(myname, "_tab2_", nodeid);\n            d3.select(temp).remove();\n        }\n    });\n\n    // just removing all the subset plots here, because using this button for problem discover\n    d3.select(\'#tabDiscovery\').selectAll(\'svg\').remove();\n}\n\n/**\n   converts color codes\n*/\nvar hexToRgba = exports.hexToRgba = function hexToRgba(hex) {\n    var int = parseInt(hex.replace(\'#\', \'\'), 16);\n    return \'rgba(\' + [int >> 16 & 255, int >> 8 & 255, int & 255, \'0.5\'].join(\',\') + \')\';\n};\n\n/**\n   takes node and color and updates zparams\n*/\nfunction setColors(n, c) {\n    if (n.strokeWidth == \'1\') {\n        if (c == gr1Color) {\n            var tempindex = zparams.zgroup1.indexOf(n.name);\n            if (tempindex > -1) {\n                n.group1 = false;\n                del(zparams.zgroup1, tempindex);\n            } else {\n                n.group1 = true;\n                zparams.zgroup1.push(n.name);\n            };\n        } else if (c == gr2Color) {\n            var tempindex = zparams.zgroup2.indexOf(n.name);\n            if (tempindex > -1) {\n                n.group2 = false;\n                del(zparams.zgroup2, tempindex);\n            } else {\n                n.group2 = true;\n                zparams.zgroup2.push(n.name);\n            };\n        } else {\n            // adding time, cs, dv, nom to node with no stroke\n            n.strokeWidth = \'4\';\n            n.strokeColor = c;\n            n.nodeCol = taggedColor;\n            var push = function push(_ref4) {\n                var _ref5 = _slicedToArray(_ref4, 2),\n                    color = _ref5[0],\n                    key = _ref5[1];\n\n                if (color != c) return;\n                zparams[key] = Array.isArray(zparams[key]) ? zparams[key] : [];\n                zparams[key].push(n.name);\n                if (key == \'znom\') {\n                    findNodeIndex(n.name, true).nature = "nominal";\n                    transform(n.name, t = null, typeTransform = true);\n                }\n                if (key == \'zdv\') {\n                    // remove group memberships from dv\'s\n                    if (n.group1) {\n                        n.group1 = false;\n                        del(zparams.zgroup1, -1, n.name);\n                    };\n                    if (n.group2) {\n                        n.group2 = false;\n                        del(zparams.zgroup2, -1, n.name);\n                    };\n                }\n            };\n            [[dvColor, \'zdv\'], [csColor, \'zcross\'], [timeColor, \'ztime\'], [nomColor, \'znom\']].forEach(push);\n        }\n    } else if (n.strokeWidth == \'4\') {\n        if (c == n.strokeColor) {\n            // deselecting time, cs, dv, nom\n            n.strokeWidth = \'1\';\n            n.strokeColor = _plots.selVarColor;\n            n.nodeCol = colors(n.id);\n            zparamsReset(n.name);\n            if (nomColor == c && zparams.znom.includes(n.name)) {\n                findNodeIndex(n.name, true).nature = findNodeIndex(n.name, true).defaultNature;\n                transform(n.name, t = null, typeTransform = true);\n            }\n        } else {\n            // deselecting time, cs, dv, nom AND changing it to time, cs, dv, nom\n            zparamsReset(n.name);\n            if (nomColor == n.strokeColor && zparams.znom.includes(n.name)) {\n                findNodeIndex(n.name, true).nature = findNodeIndex(n.name, true).defaultNature;\n                transform(n.name, t = null, typeTransform = true);\n            }\n            n.strokeColor = c;\n            if (dvColor == c) {\n                var dvname = n.name;\n                zparams.zdv.push(dvname);\n                if (n.group1) {\n                    // remove group memberships from dv\'s\n                    ngroup1 = false;\n                    del(zparams.zgroup1, -1, dvname);\n                };\n                if (n.group2) {\n                    ngroup2 = false;\n                    del(zparams.zgroup2, -1, dvname);\n                };\n            } else if (csColor == c) zparams.zcross.push(n.name);else if (timeColor == c) zparams.ztime.push(n.name);else if (nomColor == c) {\n                zparams.znom.push(n.name);\n                findNodeIndex(n.name, true).nature = "nominal";\n                transform(n.name, t = null, typeTransform = true);\n            }\n        }\n    }\n}\n\n/** needs doc */\nfunction borderState() {\n    var set = function set(id, param, attrs) {\n        var el = byId(id);\n        zparams[param].length > 0 ? Object.entries(attrs).forEach(function (_ref6) {\n            var _ref7 = _slicedToArray(_ref6, 2),\n                x = _ref7[0],\n                y = _ref7[1];\n\n            return el.querySelector(\'.rectColor svg circle\').setAttribute(x, y);\n        }) : el.style[\'border-color\'] = \'#ccc\';\n    };\n    set(\'dvButton\', \'zdv\', { stroke: dvColor });\n    set(\'csButton\', \'zcross\', { stroke: csColor });\n    set(\'timeButton\', \'ztime\', { stroke: timeColor });\n    set(\'nomButton\', \'znom\', { stroke: nomColor });\n    set(\'gr1Button\', \'zgroup1\', { stroke: gr1Color, fill: gr1Color, \'fill-opacity\': 0.6, \'stroke-opacity\': 0 });\n    set(\'gr2Button\', \'zgroup2\', { stroke: gr2Color, fill: gr2Color, \'fill-opacity\': 0.6, \'stroke-opacity\': 0 });\n}\n\n/** needs doc */\nfunction subsetSelect(btn) {\n    if (dataurl) {\n        zparams.zdataurl = dataurl;\n    }\n    if (downloadIncomplete()) {\n        return;\n    }\n\n    zparams.zvars = [];\n    zparams.zplot = [];\n    var subsetEmpty = true;\n    // is this the same as zPop()?\n    for (var j = 0; j < nodes.length; j++) {\n        // populate zvars and zsubset arrays\n        zparams.zvars.push(nodes[j].name);\n        var temp = nodes[j].id;\n        zparams.zsubset[j] = allNodes[temp].subsetrange;\n        if (zparams.zsubset[j].length > 0) {\n            if (zparams.zsubset[j][0] != "") zparams.zsubset[j][0] = Number(zparams.zsubset[j][0]);\n            if (zparams.zsubset[j][1] != "") zparams.zsubset[j][1] = Number(zparams.zsubset[j][1]);\n        }\n        zparams.zplot.push(allNodes[temp].plottype);\n        if (zparams.zsubset[j][1] != "") subsetEmpty = false; // only need to check one\n    }\n\n    if (subsetEmpty == true) {\n        alert("Warning: No new subset selected.");\n        return;\n    }\n\n    var outtypes = [];\n    for (var j = 0; j < allNodes.length; j++) {\n        outtypes.push({\n            varnamesTypes: allNodes[j].name,\n            nature: allNodes[j].nature,\n            numchar: allNodes[j].numchar,\n            binary: allNodes[j].binary,\n            interval: allNodes[j].interval\n        });\n    }\n\n    var json = makeRequest(ROOK_SVC_URL + \'subsetSelect\', { zdataurl: zparams.zdataurl,\n        zvars: zparams.zvars,\n        zsubset: zparams.zsubset,\n        zsessionid: zparams.zsessionid,\n        zplot: zparams.zplot,\n        callHistory: callHistory,\n        typeStuff: outtypes });\n    if (!json) {\n        return;\n    }\n\n    trigger("btnVariables", "click"); // programmatic clicks\n    trigger("btnModels", "click");\n\n    var grayOuts = [];\n    var rCall = [];\n    rCall[0] = json.call;\n\n    // store contents of the pre-subset space\n    zPop();\n    var myNodes = jQuery.extend(true, [], allNodes);\n    var myParams = jQuery.extend(true, {}, zparams);\n    var myTrans = jQuery.extend(true, [], trans);\n    var myForce = jQuery.extend(true, [], forcetoggle);\n    var myPreprocess = jQuery.extend(true, {}, preprocess);\n    var myLog = jQuery.extend(true, [], logArray);\n    var myHistory = jQuery.extend(true, [], callHistory);\n\n    spaces[myspace] = {\n        "allNodes": myNodes,\n        "zparams": myParams,\n        "trans": myTrans,\n        "force": myForce,\n        "preprocess": myPreprocess,\n        "logArray": myLog,\n        "callHistory": myHistory\n    };\n\n    // remove pre-subset svg\n    var selectMe = "#m".concat(myspace);\n    d3.select(selectMe).attr(\'class\', \'item\');\n    selectMe = "#whitespace".concat(myspace);\n    d3.select(selectMe).remove();\n\n    exports.myspace = myspace = spaces.length;\n    callHistory.push({\n        func: "subset",\n        zvars: jQuery.extend(true, [], zparams.zvars),\n        zsubset: jQuery.extend(true, [], zparams.zsubset),\n        zplot: jQuery.extend(true, [], zparams.zplot)\n    });\n\n    // this is to be used to gray out and remove listeners for variables that have been subsetted out of the data\n    function varOut(v) {\n        // if in nodes, remove gray out in left panel\n        // make unclickable in left panel\n        for (var i = 0; i < v.length; i++) {\n            var selectMe = v[i].replace(/\\W/g, "_");\n            byId(selectMe).style.color = hexToRgba(grayColor);\n            selectMe = "p#".concat(selectMe);\n            d3.select(selectMe).on("click", null);\n        }\n    }\n\n    showLog(\'subset\', rCall);\n\n    d3.select("#innercarousel").append(\'div\').attr(\'class\', \'item active\').attr(\'id\', function () {\n        return "m".concat(myspace.toString());\n    }).append(\'svg\').attr(\'id\', \'whitespace\');\n    svg = d3.select("#whitespace");\n\n    d3.json(json.url, function (error, json) {\n        if (error) {\n            return console.warn(error);\n        }\n        var jsondata = getVariableData(json);\n\n        for (var key in jsondata) {\n            var myIndex = findNodeIndex(key);\n\n            allNodes[myIndex].plotx = undefined;\n            allNodes[myIndex].ploty = undefined;\n            allNodes[myIndex].plotvalues = undefined;\n            allNodes[myIndex].plottype = "";\n\n            jQuery.extend(true, allNodes[myIndex], jsondata[key]);\n            allNodes[myIndex].subsetplot = false;\n            allNodes[myIndex].subsetrange = ["", ""];\n            allNodes[myIndex].setxplot = false;\n            allNodes[myIndex].setxvals = ["", ""];\n\n            if (allNodes[myIndex].valid == 0) {\n                grayOuts.push(allNodes[myIndex].name);\n                allNodes[myIndex].grayout = true;\n            }\n        }\n        rePlot();\n        layout(layoutAdd);\n    });\n\n    varOut(grayOuts);\n}\n\n/**\n   removes all the children svgs inside subset and setx divs\n*/\nfunction rePlot() {\n    d3.select(\'#tab2\').selectAll(\'svg\').remove();\n    d3.select(\'#setx\').selectAll(\'svg\').remove();\n    allNodes.forEach(function (n) {\n        return n.setxplot = n.subsetplot = false;\n    });\n}\n\n// acts as if the user clicked in whitespace. useful when restart() is outside of scope\nfunction fakeClick() {\n    var el = byId(\'whitespace\' + myspace);\n    var evt = document.createEvent("MouseEvents");\n    evt.initMouseEvent("mousedown", true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);\n    el.dispatchEvent(evt);\n    d3.select(el).classed(\'active\', false);\n}\n\n/**\n   EndSession(SessionContext) returns (Response) {}\n*/\nasync function endsession() {\n    var table = document.getElementById("setxRight").getElementsByTagName(\'table\')[0];\n    if (typeof table === \'undefined\') {\n        alert("No pipelines exist. Cannot mark problem as complete.");\n        return;\n    }\n\n    var tableposition = selectedPipeline[\'model\'] + 1; // no pipeline selected become NaN\n    if (isNaN(tableposition)) {\n        tableposition = 1;\n    }\n    var selected = table.rows[tableposition].cells[0].innerHTML; // was "none"; as default\n\n    // calling exportpipeline\n    var end = await exportpipeline(selected);\n\n    // makeRequest(D3M_SVC_URL + \'/endsession\', apiSession(zparams.zsessionid));\n    var res = await makeRequest(D3M_SVC_URL + \'/endsession\', apiSession(zparams.zsessionid));\n    var mystatus = res.status.code.toUpperCase();\n    if (mystatus == "OK") {\n        end_ta3_search(true, "Problem marked as complete.");\n        (0, _Modal.setModal)("Your selected pipeline has been submitted.", "Task Complete", true, false, false, location.reload);\n    }\n}\n\n/**\n    rpc DeletePipelines(PipelineDeleteRequest) returns (PipelineListResult) {}\n    pipes is an array of pipeline IDs\n*/\nfunction deletepipelines(pipes) {\n    var res = makeRequest(D3M_SVC_URL + \'/DeletePipelines\', { context: apiSession(zparams.zsessionid), deletePipelineIds: pipes });\n    if (!res) {\n        return;\n    }\n}\n\n/**\n    rpc DeletePipelines(PipelineDeleteRequest) returns (PipelineListResult) {}\n    pipes is an array of pipeline IDs\n*/\nfunction cancelpipelines(pipes) {\n    var res = makeRequest(D3M_SVC_URL + \'/CancelPipelines\', { context: apiSession(zparams.zsessionid), cancelPipelineIds: pipes });\n    if (!res) {\n        return;\n    }\n}\n\n/**\n   rpc ListPipelines(PipelineListRequest) returns (PipelineListResult) {}\n   pipes is an array of pipeline IDs\n*/\nasync function listpipelines() {\n    var res = await makeRequest(D3M_SVC_URL + \'/listpipelines\', { context: apiSession(zparams.zsessionid) });\n    if (!res) {\n        return [];\n    }\n    var pipes = res.pipelineIds;\n    return pipes;\n}\n\n/**\n   rpc ExecutePipeline(PipelineExecuteRequest) returns (stream PipelineExecuteResult) {}\n*/\nasync function executepipeline() {\n    var context = apiSession(zparams.zsessionid);\n    var tablerow = document.querySelector(\'#setxRight tr.item-select\');\n    if (tablerow == null) {\n        alert("Please select a pipeline to execute on.");return;\n    }\n    var pipelineId = tablerow.firstChild.innerText;\n\n    zPop();\n    zparams.callHistory = callHistory;\n\n    var data = [];\n\n    //this will just set zparams.zsetx to the mean, which is default for setx plots\n    //note that if setxplot is modified, it will NOT == "" because zparams.zsetx is modified when the setx plot slider is moved for the first time\n    for (var i = 0; i < zparams.zvars.length; i++) {\n        var mydata = [];\n        mydata[0] = zparams.zvars[i];\n        var mymean = allNodes[findNodeIndex(zparams.zvars[i])].mean;\n        if (zparams.zsetx[i][0] == "") {\n            mydata[1] = mymean;\n        } else if (zparams.zsetx[i][0] != mymean) {\n            mydata[1] = zparams.zsetx[i][0];\n        }\n        if (zparams.zsetx[i][1] == "") {\n            mydata[2] = allNodes[findNodeIndex(zparams.zvars[i])].mean;\n        } else if (zparams.zsetx[i][1] != mymean) {\n            mydata[2] = zparams.zsetx[i][1];\n        }\n        data.push(mydata);\n    }\n\n    var temp = { context: context, pipelineId: pipelineId, data: data };\n    temp = JSON.stringify(temp);\n    console.log(temp);\n    var res = await makeRequest(D3M_SVC_URL + \'/ExecutePipeline\', { context: context, pipelineId: pipelineId, data: data });\n    // I think we want to do this here, but will wait for ISI image to test against\n    // if(res.progressInfo=="COMPLETED") {\n    res && addPredictions(res);\n    // }\n}\n\nfunction addPredictions(res) {\n    function tabulate(data, columns) {\n        var table = d3.select(\'#setxLeftBottomRightBottom\').append(\'table\');\n        var thead = table.append(\'thead\');\n        var tbody = table.append(\'tbody\');\n\n        // append the header row\n        thead.append(\'tr\').selectAll(\'th\').data(columns).enter().append(\'th\').text(function (column) {\n            return column;\n        });\n\n        // create a row for each object in the data\n        var rows = tbody.selectAll(\'tr\').data(data).enter().append(\'tr\');\n\n        // create a cell in each row for each column\n        var cells = rows.selectAll(\'td\').data(function (row) {\n            return columns.map(function (column) {\n                return { column: column, value: row[column] };\n            });\n        }).enter().append(\'td\').text(function (d) {\n            return d.value;\n        }).attr(\'id\', function (d, i) {\n            var rowname = this.parentElement.firstChild.innerText;\n            return rowname + d.column;\n        });\n\n        return table;\n    }\n\n    // this is what ISI should look like, and the test server eventually, so just remove the following line when it\'s up\n    res = res.grpcResp[0];\n\n    console.log(res);\n    var allPreds = res.resultData.data;\n    var predvals = [];\n\n    for (var i = 0; i < allPreds.length; i++) {\n        predvals.push(allPreds[i]["preds"]);\n    }\n\n    var mydata = [];\n    mydata.push({ " ": "Pred 1", "E(Y|X1)": predvals[0], "E(Y|X2)": predvals[1] });\n\n    // render the table(s)\n    tabulate(mydata, [\' \', \'E(Y|X1)\', \'E(Y|X2)\']); // 2 column table\n}\n\n/**\n   find something centerish to the vertices of a convex hull\n   (specifically, the center of the bounding box)\n*/\nfunction jamescentroid(coord) {\n    var minx = coord[0][0],\n        maxx = coord[0][0],\n        miny = coord[0][1],\n        maxy = coord[0][1];\n    for (var j = 1; j < coord.length; j++) {\n        if (coord[j][0] < minx) minx = coord[j][0];\n        if (coord[j][1] < miny) miny = coord[j][1];\n        if (coord[j][0] > maxx) maxx = coord[j][0];\n        if (coord[j][1] > maxy) maxy = coord[j][1];\n    };\n    return [(minx + maxx) / 2, (miny + maxy) / 2];\n};\n\n/**\n   Define each pebble radius.\n   Presently, most pebbles are scaled to radius set by global RADIUS.\n   Members of groups are scaled down if group gets large.\n*/\nfunction setPebbleRadius(d) {\n    if (d.group1 || d.group2) {\n        // if a member of a group, need to calculate radius size\n        var uppersize = 7;\n        var ng1 = d.group1 ? zparams.zgroup1.length : 1; // size of group1, if a member of group 1\n        var ng2 = d.group2 ? zparams.zgroup2.length : 1; // size of group2, if a member of group 2\n        var maxng = Math.max(ng1, ng2); // size of the largest group variable is member of\n        var node_radius = maxng > uppersize ? RADIUS * Math.sqrt(uppersize / maxng) : RADIUS; // keep total area of pebbles bounded to pi * RADIUS^2 * uppersize, thus shrinking radius for pebbles in larger groups\n\n        // make the selected node a bit bigger\n        if (d.name === selectedPebble) return Math.min(node_radius * 1.5, RADIUS);\n        return node_radius;\n    } else {\n        return RADIUS; // nongroup members get the common global radius\n    }\n};\n\n/**\n   Define each pebble charge.\n*/\nfunction setPebbleCharge(d) {\n    if (d.group1 || d.group2) {\n        if (d.forefront) {\n            // pebbles packed in groups repel others on mouseover\n            return -1000;\n        }\n        var uppersize = 7;\n        var ng1 = d.group1 ? zparams.zgroup1.length : 1; // size of group1, if a member of group 1\n        var ng2 = d.group2 ? zparams.zgroup2.length : 1; // size of group2, if a member of group 2\n        var maxng = Math.max(ng1, ng2); // size of the largest group variable is member of\n        return maxng > uppersize ? -400 * (uppersize / maxng) : -400; // decrease charge as pebbles become smaller, so they can pack together\n    } else {\n        return -800;\n    }\n}\n\n/** needs doc */\nfunction resultsplotinit(pid) {\n    console.log(pid);\n    pid = allPipelineInfo[pid];\n    var mydv = allPipelineInfo.rookpipe.depvar[0]; // When there are multiple CreatePipelines calls, then this only has values from latest value\n    var dvvalues = allPipelineInfo.rookpipe.dvvalues; // When there are multiple CreatePipelines calls, then this only has values from latest value\n    // let predfile = pid.pipelineInfo.predictResultData.file_1;\n\n    if (pid.pipelineInfo.predictResultData.success == false) return;\n\n    var allPreds = pid.pipelineInfo.predictResultData.data;\n    console.log(Object.keys(allPreds[1]));\n    var predvals = [];\n\n    var mydvI = Object.keys(allPreds[1]).indexOf(mydv);\n    if (mydvI > -1) {\n        for (var i = 0; i < allPreds.length; i++) {\n            predvals.push(allPreds[i][mydv]);\n        }\n    } else if (Object.keys(allPreds[1]).indexOf("preds") > -1) {\n        for (var _i2 = 0; _i2 < allPreds.length; _i2++) {\n            predvals.push(allPreds[_i2]["preds"]);\n        }\n    } else {\n        alert("DV does not match. No Results window.");\n        return;\n    }\n\n    // only do this for classification tasks\n    if (d3mTaskType[d3mProblemDescription.taskType][1] == "CLASSIFICATION") {\n        genconfdata(dvvalues, predvals);\n    } else {\n        var xdata = "Actual";\n        var ydata = "Predicted";\n        bivariatePlot(dvvalues, predvals, xdata, ydata);\n    }\n\n    // add the list of predictors into setxLeftTopLeft\n    d3.select("#setxLeftTopLeft").selectAll("p").data(allPipelineInfo.rookpipe.predictors) // When there are multiple CreatePipelines calls, then this only has values from latest value\n    .enter().append("p").text(function (d) {\n        return d;\n    }).attr(\'id\', function (d) {\n        return "sx_" + d;\n    }).attr(\'class\', "item-default").on("click", function () {\n        if (this.className == "item-select") {\n            return;\n        } else {\n            d3.select("#setxLeftTopLeft").select("p.item-select").attr(\'class\', \'item-default\');\n            d3.select(this).attr(\'class\', "item-select");\n            singlePlot(this.id.slice(3)); // drops that sx_\n        }\n    });\n}\n\n/** needs doc */\nfunction genconfdata(dvvalues, predvals) {\n\n    // dvvalues are generally numeric\n    dvvalues = dvvalues.map(String);\n\n    // predvals are generally strings\n    predvals = predvals.map(String);\n\n    var mycounts = [];\n    var mypairs = [];\n\n    // combine actuals and predicted, and get all unique elements\n    var myuniques = dvvalues.concat(predvals);\n    myuniques = [].concat(_toConsumableArray(new Set(myuniques))); //equivalent to: myuniques = Array.from(new Set(myuniques));\n    //was:\n    //  function onlyUnique(value, index, self) {\n    //    return self.indexOf(value) === index;\n    //  }\n    //  myuniques = myuniques.filter(onlyUnique);\n    myuniques = myuniques.sort();\n\n    // create two arrays: mycounts initialized to 0, mypairs have elements set to all possible pairs of uniques\n    // looked into solutions other than nested fors, but Internet suggest performance is just fine this way\n    for (var i = 0; i < myuniques.length; i++) {\n        var tempcount = [];\n        var temppair = [];\n        for (var j = 0; j < myuniques.length; j++) {\n            mycounts.push(0);\n            mypairs.push(myuniques[i] + \',\' + myuniques[j]);\n        }\n    }\n\n    // line up actuals and predicted, and increment mycounts at index where mypair has a match for the \'actual,predicted\'\n    for (var _i3 = 0; _i3 < dvvalues.length; _i3++) {\n        var _temppair = dvvalues[_i3] + \',\' + predvals[_i3];\n        var myindex = mypairs.indexOf(_temppair);\n        mycounts[myindex] += 1;\n    }\n\n    var confdata = [],\n        size = myuniques.length;\n    // another loop... this builds the array of arrays from the flat array mycounts for input to confusionsmatrix function\n    while (mycounts.length > 0) {\n        confdata.push(mycounts.splice(0, size));\n    }confusionmatrix(confdata, myuniques);\n}\n\n/** needs doc */\nfunction confusionmatrix(matrixdata, classes) {\n\n    d3.select("#setxLeftPlot").html("");\n    d3.select("#setxLeftPlot").select("svg").remove();\n\n    // adapted from this block: https://bl.ocks.org/arpitnarechania/dbf03d8ef7fffa446379d59db6354bac\n    var mainwidth = byId(\'main\').clientWidth;\n    var mainheight = byId(\'main\').clientHeight;\n\n    var longest = classes.reduce(function (a, b) {\n        return a.length > b.length ? a : b;\n    });\n    //console.log(longest);\n    var leftmarginguess = Math.max(longest.length * 8, 25); // More correct answer is to make a span, put string inside span, then use jquery to get pixel width of span.\n\n\n    var condiv = document.createElement(\'div\');\n    condiv.id = "confusioncontainer";\n    condiv.style.display = "inline-block";\n    condiv.style.width = +(mainwidth * .385) + \'px\'; // Need to not be hard coded\n    condiv.style.marginLeft = \'20px\';\n    condiv.style.height = +mainheight + \'px\'; // Need to not be hard coded\n    condiv.style.float = "left";\n    byId(\'setxLeftPlot\').appendChild(condiv);\n\n    var legdiv = document.createElement(\'div\');\n    legdiv.id = "confusionlegend";\n    legdiv.style.width = +(mainwidth * .05) + \'px\'; // Need to not be hard coded\n    legdiv.style.marginLeft = \'5px\'; // Margin between confusion matrix container and legend container\n    legdiv.style.height = +mainheight + \'px\'; // Need to not be hard coded\n    legdiv.style.display = "inline-block";\n    byId(\'setxLeftPlot\').appendChild(legdiv);\n\n    var margin = { top: 30, right: 35, bottom: 0, left: leftmarginguess }; // Left margin needs not to be hardcoded, but responsive to maximum label length\n\n\n    function Matrix(options) {\n        var width = options.width,\n            height = options.height,\n            data = options.data,\n            container = options.container,\n            labelsData = options.labels,\n            startColor = options.start_color,\n            endColor = options.end_color,\n            xOffset = options.x_offset;\n\n        var widthLegend = options.widthLegend;\n\n        if (!data) {\n            throw new Error(\'Please pass data\');\n        }\n\n        if (!Array.isArray(data) || !data.length || !Array.isArray(data[0])) {\n            throw new Error(\'It should be a 2-D array\');\n        }\n\n        var maxValue = d3.max(data, function (layer) {\n            return d3.max(layer, function (d) {\n                return d;\n            });\n        });\n        var minValue = d3.min(data, function (layer) {\n            return d3.min(layer, function (d) {\n                return d;\n            });\n        });\n\n        var numrows = data.length;\n        var numcols = data[0].length;\n\n        var svg = d3.select(container).append("svg").attr("width", width + margin.left + margin.right).attr("height", height + margin.top + margin.bottom).append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");\n\n        var background = svg.append("rect").style("stroke", "black").style("stroke-width", "2px").attr("width", width).attr("height", height);\n\n        var x = d3.scale.ordinal().domain(d3.range(numcols)).rangeBands([0, width]);\n\n        var y = d3.scale.ordinal().domain(d3.range(numrows)).rangeBands([0, height]);\n\n        var colorMap = d3.scale.linear().domain([minValue, maxValue]).range([startColor, endColor]);\n\n        var row = svg.selectAll(".row").data(data).enter().append("g").attr("class", "row").attr("transform", function (d, i) {\n            return "translate(0," + y(i) + ")";\n        });\n\n        var cell = row.selectAll(".cell").data(function (d) {\n            return d;\n        }).enter().append("g").attr("class", "cell").attr("transform", function (d, i) {\n            return "translate(" + x(i) + ", 0)";\n        });\n\n        cell.append(\'rect\').attr("width", x.rangeBand()).attr("height", y.rangeBand()).style("stroke-width", 0);\n\n        if (numcols < 20) {\n            cell.append("text").attr("dy", ".32em").attr("x", x.rangeBand() / 2).attr("y", y.rangeBand() / 2).attr("text-anchor", "middle").style("fill", function (d, i) {\n                return d >= maxValue / 2 ? \'white\' : \'black\';\n            }).text(function (d, i) {\n                return d;\n            });\n        };\n\n        row.selectAll(".cell").data(function (d, i) {\n            return data[i];\n        }).style("fill", colorMap);\n\n        // this portion of the code isn\'t as robust to sizing. column labels not rendering in the right place\n        var labels = svg.append(\'g\').attr(\'class\', "labels");\n\n        var columnLabels = labels.selectAll(".column-label").data(labelsData).enter().append("g").attr("class", "column-label").attr("transform", function (d, i) {\n            // let temp = "translate(" + x(i) + "," + (height+20) + ")"; // this in particular looks to be the cause\n            //  console.log(temp);\n            return "translate(" + x(i) + "," + (height + xOffset) + ")";\n        });\n\n        columnLabels.append("line").style("stroke", "black").style("stroke-width", "1px").attr("x1", x.rangeBand() / 2).attr("x2", x.rangeBand() / 2).attr("y1", 5 - xOffset).attr("y2", -xOffset);\n\n        console.log(x.rangeBand);\n\n        columnLabels.append("text").attr("x", x.rangeBand() / 2).attr("y", -10)\n        //.attr("dy", "0.5em")\n        .attr("text-anchor", "start").attr("transform", "rotate(60," + x.rangeBand() / 2 + ",-10)").text(function (d, i) {\n            return d;\n        });\n\n        var rowLabels = labels.selectAll(".row-label").data(labelsData).enter().append("g").attr("class", "row-label").attr("transform", function (d, i) {\n            return "translate(" + 0 + "," + y(i) + ")";\n        });\n\n        rowLabels.append("line").style("stroke", "black").style("stroke-width", "1px").attr("x1", 0).attr("x2", -5).attr("y1", y.rangeBand() / 2).attr("y2", y.rangeBand() / 2);\n\n        rowLabels.append("text").attr("x", -8).attr("y", y.rangeBand() / 2).attr("dy", ".32em").attr("text-anchor", "end").text(function (d, i) {\n            return d;\n        });\n\n        var key = d3.select("#confusionlegend").append("svg").attr("width", widthLegend).attr("height", height + margin.top + margin.bottom);\n\n        var legend = key.append("defs").append("svg:linearGradient").attr("id", "gradient").attr("x1", "100%").attr("y1", "0%").attr("x2", "100%").attr("y2", "100%").attr("spreadMethod", "pad");\n\n        legend.append("stop").attr("offset", "0%").attr("stop-color", endColor).attr("stop-opacity", 1);\n\n        legend.append("stop").attr("offset", "100%").attr("stop-color", startColor).attr("stop-opacity", 1);\n\n        key.append("rect").attr("width", widthLegend / 2 - 10).attr("height", height).style("fill", "url(#gradient)").attr("transform", "translate(0," + margin.top + ")");\n\n        svg.append("text").attr("transform", "translate(" + width / 2 + " ," + (0 - 10) + ")").style("text-anchor", "middle").text("Predicted Class");\n\n        svg.append("text").attr("transform", "rotate(-90)").attr("y", width + 15).attr("x", 0 - height / 2)\n        //.attr("dy", "1em")\n        .style("text-anchor", "middle").text("Actual Class");\n\n        // this y is for the legend\n        y = d3.scale.linear().range([height, 0]).domain([minValue, maxValue]);\n\n        var yAxis = d3.svg.axis().scale(y).orient("right");\n\n        key.append("g").attr("class", "y axis").attr("transform", "translate(25," + margin.top + ")") // first number is separation between legend scale and legend key\n        .call(yAxis);\n    }\n\n    // The table generation function. Used for the table of performance measures, not the confusion matrix\n    function tabulate(data, columns) {\n        var table = d3.select("#setxLeftPlot").append("table").attr("style", "margin-left: " + margin.left + "px"),\n            thead = table.append("thead"),\n            tbody = table.append("tbody");\n\n        // append the header row\n        thead.append("tr").selectAll("th").data(columns).enter().append("th").text(function (column) {\n            return column;\n        });\n\n        // create a row for each object in the data\n        var rows = tbody.selectAll("tr").data(data).enter().append("tr");\n\n        // create a cell in each row for each column\n        var cells = rows.selectAll("td").data(function (row) {\n            return columns.map(function (column) {\n                return { column: column, value: row[column] };\n            });\n        }).enter().append("td").attr("style", "font-family: Courier") // sets the font style\n        .html(function (d) {\n            return d.value;\n        });\n\n        return table;\n    }\n\n    // this code is all for producing a table with performance measures\n    //var confusionMatrix = [[169, 10],[7, 46]];\n    var tp = matrixdata[0][0];\n    var fn = matrixdata[0][1];\n    var fp = matrixdata[1][0];\n    var tn = matrixdata[1][1];\n\n    var p = tp + fn;\n    var n = fp + tn;\n\n    var accuracy = (tp + tn) / (p + n);\n    var f1 = 2 * tp / (2 * tp + fp + fn);\n    var precision = tp / (tp + fp);\n    var recall = tp / (tp + fn);\n\n    accuracy = Math.round(accuracy * 100) / 100;\n    f1 = Math.round(f1 * 100) / 100;\n    precision = Math.round(precision * 100) / 100;\n    recall = Math.round(recall * 100) / 100;\n\n    var computedData = [];\n    computedData.push({ "F1": f1, "PRECISION": precision, "RECALL": recall, "ACCURACY": accuracy });\n\n    Matrix({\n        container: \'#confusioncontainer\',\n        data: matrixdata,\n        labels: classes,\n        start_color: \'#ffffff\',\n        end_color: \'#e67e22\',\n        width: mainwidth * .33 + 25 - leftmarginguess, // Width of confusion matrix table: Need to not be hard coded\n        height: mainheight * .6, // Need to not be hard coded\n        widthLegend: mainwidth * .04,\n        x_offset: 30\n    });\n\n    // not rendering this table for right now, left all the code in place though. maybe we use it eventually\n    // var table = tabulate(computedData, ["F1", "PRECISION","RECALL","ACCURACY"]);\n}\n\n/**\n   scatterplot function to go to plots.js to be reused\n*/\nfunction bivariatePlot(x_Axis, y_Axis, x_Axis_name, y_Axis_name) {\n    d3.select("#setxLeftPlot").html("");\n    d3.select("#setxLeftPlot").select("svg").remove();\n\n    x_Axis = x_Axis.map(Number);\n    y_Axis = y_Axis.map(Number);\n\n    console.log(x_Axis);\n    console.log(y_Axis);\n\n    var mainwidth = byId(\'main\').clientWidth;\n    var mainheight = byId(\'main\').clientHeight;\n\n    // scatter plot\n    var data_plot = [];\n    var nanCount = 0;\n    for (var i = 0; i < x_Axis.length; i++) {\n        if (isNaN(x_Axis[i]) || isNaN(y_Axis[i])) {\n            nanCount++;\n        } else {\n            var newNumber1 = x_Axis[i];\n            var newNumber2 = y_Axis[i];\n            data_plot.push({ xaxis: newNumber1, yaxis: newNumber2, score: Math.random() * 100 });\n        }\n    }\n\n    var margin = { top: 35, right: 35, bottom: 35, left: 35 },\n        width = mainwidth * .25 - margin.left - margin.right,\n        height = mainwidth * .25 - margin.top - margin.bottom;\n    var padding = 100;\n\n    var min_x = d3.min(data_plot, function (d, i) {\n        return data_plot[i].xaxis;\n    });\n    var max_x = d3.max(data_plot, function (d, i) {\n        return data_plot[i].xaxis;\n    });\n    var avg_x = (max_x - min_x) / 10;\n    var min_y = d3.min(data_plot, function (d, i) {\n        return data_plot[i].yaxis;\n    });\n    var max_y = d3.max(data_plot, function (d, i) {\n        return data_plot[i].yaxis;\n    });\n    var avg_y = (max_y - min_y) / 10;\n\n    var xScale = d3.scale.linear().domain([min_x - avg_x, max_x + avg_x]).range([0, width]);\n\n    var yScale = d3.scale.linear().domain([min_y - avg_y, max_y + avg_y]).range([height, 0]);\n\n    var xAxis = d3.svg.axis().scale(xScale).orient(\'bottom\').tickSize(-height);\n\n    var yAxis = d3.svg.axis().scale(yScale).orient(\'left\').ticks(5).tickSize(-width);\n\n    var zoom = d3.behavior.zoom().x(xScale).y(yScale).scaleExtent([1, 10]).on("zoom", zoomed);\n\n    var chart_scatter = d3.select(\'#setxLeftPlot\').append(\'svg:svg\').attr(\'width\', width + margin.right + margin.left).attr(\'height\', height + margin.top + margin.bottom);\n    // .call(zoom); dropping this for now, until the line zooms properly\n\n    var main1 = chart_scatter.append(\'g\').attr(\'transform\', \'translate(\' + margin.left + \',\' + margin.top + \')\').attr(\'width\', width + margin.right + margin.left).attr(\'height\', height + margin.top + margin.bottom).attr(\'class\', \'main\');\n\n    var gX = main1.append(\'g\').attr(\'transform\', \'translate(0,\' + height + \')\').attr(\'class\', \'x axis\').call(xAxis);\n\n    var gY = main1.append(\'g\').attr(\'transform\', \'translate(0,0)\').attr(\'class\', \'y axis\').call(yAxis);\n\n    var clip = main1.append("defs").append("svg:clipPath").attr("id", "clip").append("svg:rect").attr("id", "clip-rect").attr("x", "0").attr("y", "0").attr(\'width\', width).attr(\'height\', height);\n\n    main1.append("g").attr("clip-path", "url(#clip)").selectAll("circle").data(data_plot).enter().append("circle").attr("cx", function (d, i) {\n        return xScale(data_plot[i].xaxis);\n    }).attr("cy", function (d, i) {\n        return yScale(data_plot[i].yaxis);\n    }).attr("r", 2).style("fill", "#B71C1C");\n\n    chart_scatter.append("text").attr("text-anchor", "middle") // this makes it easy to centre the text as the transform is applied to the anchor\n    .attr("transform", "translate(" + padding / 5 + "," + height / 2 + ")rotate(-90)") // text is drawn off the screen top left, move down and out and rotate\n    .text(y_Axis_name).style("fill", "#424242").style("text-indent", "20px").style("font-size", "12px").style("font-weight", "bold");\n\n    chart_scatter.append("text").attr("text-anchor", "middle") // this makes it easy to centre the text as the transform is applied to the anchor\n    .attr("transform", "translate(" + width / 2 + "," + (height + padding / 2) + ")") // centre below axis\n    .text(x_Axis_name).style("fill", "#424242").style("text-indent", "20px").style("font-size", "12px").style("font-weight", "bold");\n\n    main1.append("line").attr("x1", xScale(min_x)).attr("y1", yScale(min_x)).attr("x2", xScale(max_x)).attr("y2", yScale(max_x)).attr("stroke-width", 2).attr("stroke", "black");\n\n    function zoomed() {\n        var panX = d3.event.translate[0];\n        var panY = d3.event.translate[1];\n        var scale = d3.event.scale;\n\n        panX = panX > 10 ? 10 : panX;\n        var maxX = -(scale - 1) * width - 10;\n        panX = panX < maxX ? maxX : panX;\n\n        panY = panY > 10 ? 10 : panY;\n        var maxY = -(scale - 1) * height - 10;\n        panY = panY < maxY ? maxY : panY;\n\n        zoom.translate([panX, panY]);\n\n        main1.select(".x.axis").call(xAxis);\n        main1.select(".y.axis").call(yAxis);\n        main1.selectAll("circle").attr("cx", function (d, i) {\n            console.log("circle x ", xScale(5));\n            return xScale(data_plot[i].xaxis);\n        }).attr("cy", function (d, i) {\n            return yScale(data_plot[i].yaxis);\n        }).attr("r", 2.5).style("fill", "#B71C1C");\n\n        // below doesn\'t work, so I\'m just dropping the zoom\n        main1.select("line").attr("x1", function (d, i) {\n            return xScale(min_x);\n        }).attr("y1", function (d, i) {\n            return xScale(min_x);\n        }).attr("x2", function (d, i) {\n            return xScale(max_x);\n        }).attr("y2", function (d, i) {\n            return yScale(max_x);\n        }).attr("stroke-width", 2).attr("stroke", "black");\n    }\n    //  d3.select("#NAcount").text("There are " + nanCount + " number of NA values in the relation.");\n}\n\n/** needs doc */\nfunction setxTable(features) {\n    function tabulate(data, columns) {\n        var table = d3.select(\'#setxLeftBottomLeft\').append(\'table\');\n        var thead = table.append(\'thead\');\n        var tbody = table.append(\'tbody\');\n\n        // append the header row\n        thead.append(\'tr\').selectAll(\'th\').data(columns).enter().append(\'th\').text(function (column) {\n            return column;\n        });\n\n        // create a row for each object in the data\n        var rows = tbody.selectAll(\'tr\').data(data).enter().append(\'tr\');\n\n        // create a cell in each row for each column\n        var cells = rows.selectAll(\'td\').data(function (row) {\n            return columns.map(function (column) {\n                return { column: column, value: row[column] };\n            });\n        }).enter().append(\'td\').text(function (d) {\n            return d.value;\n        }).attr(\'id\', function (d, i) {\n            var rowname = this.parentElement.firstChild.innerText;\n            return rowname + d.column;\n        });\n\n        return table;\n    }\n\n    var mydata = [];\n    for (var i = 0; i < features.length; i++) {\n        var myi = findNodeIndex(features[i]); //i+1;                                // This was set as (i+1), but should be allnodes position, not features position\n\n        if (allNodes[myi].valid == 0) {\n            var xval = 0;\n            var x1val = 0;\n            mydata.push({ "Variables": features[i], "From": xval, "To": x1val });\n            continue;\n        }\n\n        var mysvg = features[i] + "_setxLeft_" + myi;\n\n        try {\n            //console.log(mysvg);\n            //console.log(byId(mysvg).querySelector(\'.xval\'));\n            var _xval = byId(mysvg).querySelector(\'.xval\').innerHTML;\n            var _x1val = byId(mysvg).querySelector(\'.x1val\').innerHTML;\n            //console.log(xval);\n            //console.log(x1val);\n            _xval = _xval.split("x: ").pop();\n            _x1val = _x1val.split("x1: ").pop();\n            mydata.push({ "Variables": features[i], "From": _xval, "To": _x1val });\n        } catch (error) {\n            continue;\n        }\n    }\n\n    // render the table(s)\n    tabulate(mydata, [\'Variables\', \'From\', \'To\']); // 2 column table\n}\n\n/**\n  rpc ExportPipeline(PipelineExportRequest) returns (Response) {}\n*/\n\nasync function exportpipeline(pipelineId) {\n    var temp = { pipelineId: pipelineId, context: apiSession(zparams.zsessionid), pipelineExecUri: \'<<EXECUTABLE_URI>>\' };\n\n    var res = await makeRequest(D3M_SVC_URL + \'/exportpipeline\', { pipelineId: pipelineId, context: apiSession(zparams.zsessionid), pipelineExecUri: \'<<EXECUTABLE_URI>>\' });\n\n    // we need standardized status messages...\n    var mystatus = res.status;\n    if (typeof mystatus !== \'undefined\') {\n        if (mystatus.code == "FAILED_PRECONDITION") {\n            console.log("TA2 has not written the executable."); // was alert(), but testing on NIST infrastructure suggests these are getting written but triggering alert.\n        } else {\n            console.log(\'Executable for \' + pipelineId + \' has been written\');\n        }\n    }\n    return res;\n}\n\n/** needs doc */\nfunction deletepipeline() {\n    console.log("DELETE CALLED");\n}\n\n/**\n   D3M API HELPERS\n   because these get built in various places, pulling them out for easy manipulation\n*/\nfunction apiFeature(vars, uri) {\n    var out = [];\n    for (var i = 0; i < vars.length; i++) {\n        out.push({ featureId: vars[i], dataUri: uri });\n    }\n    return out;\n}\n\n/** needs doc */\nfunction apiFeatureShortPath(vars, uri) {\n    var out = [];\n    var shortUri = uri.substring(0, uri.lastIndexOf("/"));\n    for (var i = 0; i < vars.length; i++) {\n        out.push({ featureId: vars[i], dataUri: shortUri });\n    }\n    return out;\n}\n\n/**\n   silly but perhaps useful if in the future SessionContext requires more things (as suggest by core)\n*/\nfunction apiSession(context) {\n    return { session_id: context };\n}\n\n/**\n *  Send a status message to the TA3 console\n */\nfunction ta3_search_message(user_msg) {\n    /*\n    let ta3_search_message = {\'message\': user_msg}\n     const end_search_url = \'ta3-search/send-reviewer-message\';\n     try {\n        let res = m.request(end_search_url,\n                            {method: \'POST\', data: ta3_search_message});\n        console.log(\'ta3_search_message succeeded:\' + res);\n    } catch (err) {\n        console.log(\'ta3_search_message failed: \' + err);\n    }\n    */\n}\n\nfunction test_msg_ta3_search() {}\n//end_ta3_search(true, \'it worked!\');\n//end_ta3_search(false, \'it failed!\');\n//ta3_search_message(\'just sending a message!\');\n\n\n/**\n *  End the TA3 search.  This sends a message\n *  to the ta3_search console as well as message\n *  for the console to exit with a:\n *  - return code 0 for success\n *  - return code -1 for failure\n *\n *  > is_success - boolean\n *  > user_msg - string sent to the console\n */\nfunction end_ta3_search(is_success, user_msg) {}\n\n// 6/21/2018 - removed from eval\n/*\nlet end_search_msg = {\'is_success\': is_success,\n                      \'message\': user_msg}\n const end_search_url = \'ta3-search/end-search\';\n try {\n    let res = m.request(end_search_url,\n                        {method: \'POST\', data: end_search_msg});\n    console.log(\'end_ta3_search succeeded:\' + res);\n} catch (err) {\n    console.log(\'end_ta3_search failed: \' + err);\n}\n*/\n\n\n/**\n *  record user metadata\n */\nvar recorder_cnt = 0;\nvar save_workspace_url = \'/workspaces/record-user-workspace\';\n\nfunction record_user_metadata() {\n\n    // turning off for now\n    return;\n\n    // (1) Set domain identifier: differs for D3M, Dataverse, etc\n    //\n    var domain_identifier = \'unknown!\';\n    if (IS_D3M_DOMAIN) {\n        // domain specific identifier\n        domain_identifier = domainIdentifier;\n    } /*else if (IS_DATAVERSE_DOMAIN){\n       domain_identifier = \'TODO: DV IDENTIFIER\';\n      }else if (IS_EVENTDATA_DOMAIN){\n       domain_identifier = \'TODO: EVENTDATA IDENTIFIER\';\n      }*/\n\n    if (zparams == null) {\n        console.log(\'No workspace recording. zparams not defined\');\n        return;\n    }\n    if (allNodes == null) {\n        console.log(\'No workspace recording. zparams not defined\');\n        return;\n    }\n\n    // (2) Format workspace data\n    //\n    var workspace_data = { \'app_domain\': APP_DOMAIN,\n        \'domain_identifier\': domain_identifier,\n        \'allnodes\': allNodes,\n        \'zparams\': zparams\n\n        //console.log(\'workspace_data: \' + workspace_data);\n\n        // (3) Save workspace data\n        //\n    };try {\n        var res = _mithril2.default.request(save_workspace_url, { method: \'POST\', data: workspace_data });\n        recorder_cnt++;\n        console.log(\'Session recorded: (cnt: \' + recorder_cnt + \') \' + res);\n    } catch (err) {\n        console.log(\'record_user_metadata failed: \' + err);\n    }\n}\n\nfunction showPredPlot(btn) {\n    if (document.getElementById("setxLeftGen").style.display == "none") return;\n    document.getElementById("setxLeftPlot").style.display = "block";\n    document.getElementById("setxLeftGen").style.display = "none";\n}\n\nfunction showGenPreds(btn) {\n    if (document.getElementById("setxLeftPlot").style.display == "none") return;\n    document.getElementById("setxLeftPlot").style.display = "none";\n    document.getElementById("setxLeftGen").style.display = "block";\n}\n\nfunction singlePlot(pred) {\n    d3.select(\'#setxLeftTopRight\').selectAll(\'svg\').remove();\n    var i = findNodeIndex(pred);\n    var node = allNodes[i];\n    node.setxplot = false;\n    node.subsetplot = false;\n    if (node.plottype === "continuous" & node.setxplot == false) {\n        node.setxplot = true;\n        (0, _plots.density)(node, div = "setxLeftTopRight", priv);\n    } else if (node.plottype === "bar" & node.setxplot == false) {\n        node.setxplot = true;\n        (0, _plots.bars)(node, div = "setxLeftTopRight", priv);\n    }\n}\n\nfunction discovery(preprocess_file) {\n\n    // console.log("entering disco");\n    var extract = preprocess_file.dataset.discovery;\n    // console.log(extract);\n    var disco = [];\n    var names = [];\n    var vars = Object.keys(preprocess);\n    for (var i = 0; i < extract.length; i++) {\n        names[i] = "Problem" + (i + 1);\n        var current_target = extract[i]["target"];\n        var j = findNodeIndex(current_target);\n        var node = allNodes[j];\n        var current_predictors = extract[i]["predictors"];\n        var current_task = node.plottype === "bar" ? \'classification\' : \'regression\';\n        var current_rating = 3;\n        var current_description = current_target + " is predicted by " + current_predictors.join(" and ");\n        var current_metric = node.plottype === "bar" ? \'f1Macro\' : \'meanSquaredError\';\n        var current_disco = { target: current_target, predictors: current_predictors, task: current_task, rating: current_rating, description: current_description, metric: current_metric };\n        //jQuery.extend(true, current_disco, names);\n        disco[i] = current_disco;\n    };\n    /* Problem Array of the Form:\n        [1: {target:"Home_runs",\n            predictors:["Walks","RBIs"],\n            task:"regression",\n            rating:5,\n            description: "Home_runs is predicted by Walks and RBIs",\n            metric: "meanSquaredError"\n        },2:{...}]\n    */\n    return disco;\n}\n\n// This stores discovery problems\nvar probtable = exports.probtable = [];\n\nvar selectedProblem = exports.selectedProblem = void 0;\nvar setSelectedProblem = exports.setSelectedProblem = function setSelectedProblem(problem) {\n    return exports.selectedProblem = selectedProblem = problem;\n};\n\nvar checkedDiscoveryProblems = exports.checkedDiscoveryProblems = new Set();\nvar setCheckedDiscoveryProblem = exports.setCheckedDiscoveryProblem = function setCheckedDiscoveryProblem(status, problem) {\n    if (problem !== undefined) status ? checkedDiscoveryProblems.add(problem) : checkedDiscoveryProblems.delete(problem);else exports.checkedDiscoveryProblems = checkedDiscoveryProblems = status ? new Set(probtable.map(function (problem) {\n        return problem[0];\n    })) : new Set();\n};\n\nasync function submitDiscProb() {\n    discoveryLadda.start();\n    for (var i = 0; i < disco.length; i++) {\n        if (!checkedDiscoveryProblems.has(i)) continue;\n        //createpipeline call\n        console.log(disco);\n        var aux = { "task": d3mTaskType[disco[i].task][1], "metrics": d3mMetrics[disco[i].metric][1], "description": disco[i].description };\n        console.log(aux);\n        // VJD: this is the code to ask TA2 for a single pipeline, to check viability. However, TA2s might not actually handle \'maxpipelines\', making this take a very long time to run. Bypassing this for now\n        //  let res = await makeRequest(D3M_SVC_URL + \'/CreatePipelines\', CreatePipelineData(disco[i].predictors, [disco[i].target], aux)); // creating a single pipeline for a discovered problem, to check viability\n        //  if(res) { // have to check if the response went through ok, this just checks if res exists\n        var res = await makeRequest(D3M_SVC_URL + \'/write-user-problem\', CreatePipelineData(disco[i].predictors, [disco[i].target], aux));\n        //  }\n    }\n\n    discoveryLadda.stop();\n    // change status of buttons for estimating problem and marking problem as finished\n    byId("btnDiscovery").classList.remove("btn-success");\n    byId("btnDiscovery").classList.add("btn-default");\n    byId("btnSubmitDisc").classList.remove("btn-success");\n    byId("btnSubmitDisc").classList.add("btn-default");\n    exports.task1_finished = task1_finished = true;\n    if (!task2_finished) {\n        byId("btnEstimate").classList.remove("btn-default");\n        byId("btnEstimate").classList.add("btn-success");\n    };\n    trigger("btnVariables", \'click\');\n}\n\nfunction saveDisc(btn) {\n    var table = document.getElementById("discoveryTable");\n    var newtext = document.getElementById("discoveryInput").value;\n    for (var i = 1, row; row = table.rows[i]; i++) {\n        //skipping the header\n        if (row.className === \'item-select\') {\n            disco[i - 1].description = newtext;\n        }\n    }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvYXBwL2FwcC5qcz9mNTEyIl0sIm5hbWVzIjpbInNldF9tb2RlIiwibWFpbiIsInNldHVwX3N2ZyIsImxheW91dCIsImZpbmROb2RlSW5kZXgiLCJmaW5kTm9kZSIsImNsaWNrVmFyIiwiZ2V0VmFyaWFibGVEYXRhIiwiZm9yY2VTd2l0Y2giLCJoZWxwbWF0ZXJpYWxzIiwielBvcCIsImRvd25sb2FkSW5jb21wbGV0ZSIsImVzdGltYXRlIiwidGEyc3R1ZmYiLCJtYWtlUmVxdWVzdCIsImxlZ2VuZCIsImVyYXNlIiwicGFuZWxQbG90cyIsImJvcmRlclN0YXRlIiwic3Vic2V0U2VsZWN0IiwiZmFrZUNsaWNrIiwiZW5kc2Vzc2lvbiIsImRlbGV0ZXBpcGVsaW5lcyIsImNhbmNlbHBpcGVsaW5lcyIsImxpc3RwaXBlbGluZXMiLCJleGVjdXRlcGlwZWxpbmUiLCJzZXRQZWJibGVSYWRpdXMiLCJyZXN1bHRzcGxvdGluaXQiLCJnZW5jb25mZGF0YSIsImNvbmZ1c2lvbm1hdHJpeCIsImJpdmFyaWF0ZVBsb3QiLCJzZXR4VGFibGUiLCJleHBvcnRwaXBlbGluZSIsImRlbGV0ZXBpcGVsaW5lIiwidGEzX3NlYXJjaF9tZXNzYWdlIiwidGVzdF9tc2dfdGEzX3NlYXJjaCIsImVuZF90YTNfc2VhcmNoIiwicmVjb3JkX3VzZXJfbWV0YWRhdGEiLCJzaG93UHJlZFBsb3QiLCJzaG93R2VuUHJlZHMiLCJkaXNjb3ZlcnkiLCJzdWJtaXREaXNjUHJvYiIsInNhdmVEaXNjIiwiY29tbW9uIiwibWFyZ2luVG9wQ2Fyb3VzZWwiLCJtYXJnaW5MZWZ0Q2Fyb3VzZWwiLCJ3aW5kb3ciLCJvbnJlc2l6ZSIsInJvdXRlIiwiZ2V0IiwiY2Fyb3VzZWwiLCJjb250YWluZXIiLCJ3aGl0ZXNwYWNlIiwib2Zmc2V0SGVpZ2h0IiwiZ2V0QXR0cmlidXRlIiwib2Zmc2V0V2lkdGgiLCJzdHlsZSIsIm1hcmdpblRvcCIsIm1hcmdpbkxlZnQiLCJoZWlnaHQiLCJNYXRoIiwiYWJzIiwicGVla0JhdGNoU2l6ZSIsInBlZWtTa2lwIiwicGVla0RhdGEiLCJwZWVrQWxsRGF0YVJlY2VpdmVkIiwicGVla0lzR2V0dGluZyIsIm9uU3RvcmFnZUV2ZW50IiwiZSIsImtleSIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJzZXRJdGVtIiwidXBkYXRlUGVlayIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZXF1ZXN0IiwiY29uZmlndXJhdGlvbnMiLCJuYW1lIiwiZGVzZXJpYWxpemUiLCJ4Iiwic3BsaXQiLCJtYXAiLCJ5IiwidGhlbiIsImhlYWRlcnMiLCJkYXRhIiwicmVwbGFjZSIsIm5ld0RhdGEiLCJzbGljZSIsImxlbmd0aCIsImNvbmNhdCIsIkpTT04iLCJzdHJpbmdpZnkiLCJyZXNldFBlZWsiLCJyZW1vdmVJdGVtIiwidGFzazFfZmluaXNoZWQiLCJ0YXNrMl9maW5pc2hlZCIsInVuaXZhcmlhdGVfZmluaXNoZWQiLCJjdXJyZW50TW9kZSIsImlzX2V4cGxvcmVfbW9kZSIsImlzX3Jlc3VsdHNfbW9kZSIsIm1vZGUiLCJ0b0xvd2VyQ2FzZSIsInVwZGF0ZVJpZ2h0UGFuZWxXaWR0aCIsInVwZGF0ZUxlZnRQYW5lbFdpZHRoIiwic2V0IiwiY2RiIiwiUFJPRFVDVElPTiIsImxvZyIsImsiLCJ0dXRvcmlhbF9tb2RlIiwiY29sb3JzIiwiZDMiLCJzY2FsZSIsImNhdGVnb3J5MjAiLCJjc0NvbG9yIiwiZHZDb2xvciIsImdyMUNvbG9yIiwiZ3IxT3BhY2l0eSIsImdyMkNvbG9yIiwiZ3IyT3BhY2l0eSIsImdyYXlDb2xvciIsIm5vbUNvbG9yIiwidmFyQ29sb3IiLCJ0YWdnZWRDb2xvciIsInRpbWVDb2xvciIsImxlZnRUYWIiLCJsZWZ0VGFiSGlkZGVuIiwic3Vic2V0Iiwic3VtbWFyeUhvbGQiLCJyaWdodFRhYiIsInJpZ2h0VGFiRXhwbG9yZSIsIm1vZGVsTGVmdFBhbmVsV2lkdGhzIiwibW9kZWxSaWdodFBhbmVsV2lkdGhzIiwiZXhwbG9yZVJpZ2h0UGFuZWxXaWR0aHMiLCJzZXRSaWdodFRhYiIsInRhYiIsInNldFJpZ2h0VGFiRXhwbG9yZSIsInBhbmVsV2lkdGgiLCJwYW5lbE9wZW4iLCJ0ZW1wV2lkdGgiLCJwYW5lbE1hcmdpbiIsInNldFBhbmVsQ2FsbGJhY2siLCJ0IiwidHlwZVRyYW5zZm9ybSIsInRyYW5zZm9ybUxpc3QiLCJ0cmFuc2Zvcm1WYXIiLCJ0cmFucyIsInByZXByb2Nlc3MiLCJzcGFjZXMiLCJsYXlvdXRBZGQiLCJsYXlvdXRNb3ZlIiwiUkFESVVTIiwiaW5kMSIsImNvcyIsInNpbiIsImluZDIiLCJteXNwYWNlIiwiZm9yY2V0b2dnbGUiLCJsb2NrdG9nZ2xlIiwicHJpdiIsInN3YW5kaXZlIiwiZmFpbHNldCIsImFsbFBpcGVsaW5lSW5mbyIsImxvZ0FycmF5IiwienBhcmFtcyIsInpkYXRhIiwiemVkZ2VzIiwienRpbWUiLCJ6bm9tIiwiemNyb3NzIiwiem1vZGVsIiwienZhcnMiLCJ6ZHYiLCJ6Z3JvdXAxIiwiemdyb3VwMiIsInpkYXRhdXJsIiwiemQzbWRhdGEiLCJ6ZDNtdGFyZ2V0IiwienN1YnNldCIsInpzZXR4Iiwiem1vZGVsY291bnQiLCJ6cGxvdCIsInpzZXNzaW9uaWQiLCJ6ZGF0YWNpdGUiLCJ6Y3Jvc3N0YWIiLCJ6dXNlcm5hbWUiLCJkaXNjbyIsIm1vZGVsQ291bnQiLCJ2YWx1ZUtleSIsImFsbE5vZGVzIiwiYWxsUmVzdWx0cyIsIm5vZGVzIiwibGlua3MiLCJtb2RzIiwiZXN0aW1hdGVkIiwicmlnaHRDbGlja0xhc3QiLCJzZWxJbnRlcmFjdCIsImNhbGxIaXN0b3J5IiwibXl0YXJnZXQiLCJkYXRhZG9jdW1lbnQiLCJkb21haW5JZGVudGlmaWVyIiwiZDNtVGFza1R5cGUiLCJ0YXNrVHlwZVVuZGVmaW5lZCIsImNsYXNzaWZpY2F0aW9uIiwicmVncmVzc2lvbiIsImNsdXN0ZXJpbmciLCJsaW5rUHJlZGljdGlvbiIsInZlcnRleE5vbWluYXRpb24iLCJjb21tdW5pdHlEZXRlY3Rpb24iLCJncmFwaENsdXN0ZXJpbmciLCJncmFwaE1hdGNoaW5nIiwidGltZVNlcmllc0ZvcmVjYXN0aW5nIiwiY29sbGFib3JhdGl2ZUZpbHRlcmluZyIsImQzbVRhc2tTdWJ0eXBlIiwidGFza1N1YnR5cGVVbmRlZmluZWQiLCJzdWJ0eXBlTm9uZSIsImJpbmFyeSIsIm11bHRpQ2xhc3MiLCJtdWx0aUxhYmVsIiwidW5pdmFyaWF0ZSIsIm11bHRpdmFyaWF0ZSIsIm92ZXJsYXBwaW5nIiwibm9uT3ZlcmxhcHBpbmciLCJkM21NZXRyaWNzIiwibWV0cmljVW5kZWZpbmVkIiwiZXhlY3V0aW9uVGltZSIsImFjY3VyYWN5IiwiZjEiLCJmMU1pY3JvIiwiZjFNYWNybyIsInJvY0F1YyIsInJvY0F1Y01pY3JvIiwicm9jQXVjTWFjcm8iLCJtZWFuU3F1YXJlZEVycm9yIiwicm9vdE1lYW5TcXVhcmVkRXJyb3IiLCJyb290TWVhblNxdWFyZWRFcnJvckF2ZyIsIm1lYW5BYnNvbHV0ZUVycm9yIiwiclNxdWFyZWQiLCJub3JtYWxpemVkTXV0dWFsSW5mb3JtYXRpb24iLCJqYWNjYXJkU2ltaWxhcml0eVNjb3JlIiwiZDNtUHJvYmxlbURlc2NyaXB0aW9uIiwidGFza1R5cGUiLCJ0YXNrU3VidHlwZSIsIm1ldHJpYyIsInRhc2tEZXNjcmlwdGlvbiIsInNldEQzbVByb2JsZW1EZXNjcmlwdGlvbiIsInZhbHVlIiwibG9va3VwIiwidW5kZWZpbmVkIiwiRDNNX1NWQ19VUkwiLCJyZXBsYWNlUHJvYmxlbVNjaGVtYUZpZWxkIiwiY29udGV4dCIsImFwaVNlc3Npb24iLCJzdGFydFRvdXIiLCJsb2NrVG91ciIsInN2ZyIsImRpdiIsInNlbGVjdExhZGRhIiwid2lkdGgiLCJlc3RpbWF0ZUxhZGRhIiwiZGlzY292ZXJ5TGFkZGEiLCJhcmMiLCJzdGFydCIsImVuZCIsInJhZGl1cyIsImlubmVyUmFkaXVzIiwib3V0ZXJSYWRpdXMiLCJzdGFydEFuZ2xlIiwiZW5kQW5nbGUiLCJhcmMwIiwiYXJjMSIsImFyYzIiLCJhcmMzIiwiYXJjNCIsImFyY0luZCIsImFyY2xpbWl0cyIsImFyY0luZDFMaW1pdHMiLCJhcmNJbmQyTGltaXRzIiwiYXJjSW5kMSIsImFyY0luZDIiLCJob3ZlclRpbWVvdXQiLCJob3ZlclBlYmJsZSIsInNlbGVjdGVkUGViYmxlIiwiYnlJZCIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJpZCIsInRyaWdnZXIiLCJldmVudCIsImV2dCIsImNyZWF0ZUV2ZW50IiwiaW5pdEV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsInJlc2V0IiwicmVsb2FkUGFnZSIsInJlcyIsImNsaWNrIiwibG9jYXRpb24iLCJyZWxvYWQiLCJyZXN0YXJ0IiwiZGF0YXVybCIsInN0ZXAiLCJ0YXJnZXQiLCJwbGFjZW1lbnQiLCJ0aXRsZSIsImNvbnRlbnQiLCJzaG93Q1RBQnV0dG9uIiwiY3RhTGFiZWwiLCJvbkNUQSIsImVuZFRvdXIiLCJteXRvdXIiLCJpMThuIiwiZG9uZUJ0biIsInNob3dDbG9zZUJ1dHRvbiIsInNjcm9sbER1cmF0aW9uIiwic3RlcHMiLCJteXRvdXIzIiwibG9hZCIsImhvbGQiLCJsYWJsQXJyYXkiLCJkM21Sb290UGF0aCIsImQzbURhdGFOYW1lIiwiZDNtUHJlcHJvY2VzcyIsImQzbURhdGEiLCJkM21QUyIsImQzbURTIiwicFVSTCIsIklTX0QzTV9ET01BSU4iLCJtZXRob2QiLCJ1cmwiLCJjb25zb2xlIiwicGFyc2UiLCJ0cmFpbmluZ19kYXRhX3Jvb3QiLCJzb3VyY2VfdXJsIiwiY29uZmlnX3VybCIsImRlc2NyaXB0aW9uIiwic2V0X2QzbV9kYXRhX3BhdGgiLCJmaWVsZCIsInZhbCIsImV4aXN0cyIsInBhdGgiLCJkM21fcGF0aF9lcnIiLCJhbGVydCIsImlucHV0cyIsInRhcmdldHMiLCJjb2xOYW1lIiwiYWJvdXQiLCJ0YXNrU3ViVHlwZSIsInBlcmZvcm1hbmNlTWV0cmljcyIsImRlc2NyaXB0aW9uRmlsZSIsImluY2x1ZGVzIiwidG9VcHBlckNhc2UiLCJkYXRhZG9jdW1lbnRfY29sdW1ucyIsImNvbF9pZHgiLCJkYXRhUmVzb3VyY2VzIiwiY29sdW1ucyIsImRhdGFzZXROYW1lIiwiZGF0YXNldElEIiwiY2hhckF0IiwiY2l0ZSIsImNpdGF0aW9uIiwidGVtcCIsInhtbCIsImRvY3VtZW50RWxlbWVudCIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwiY2hpbGROb2RlcyIsIm5vZGVWYWx1ZSIsImNoaWxkcmVuIiwidGV4dENvbnRlbnQiLCJkYXRhbmFtZSIsInNlbGVjdCIsImh0bWwiLCJjbGFzc0xpc3QiLCJhZGQiLCJiYWNrZ3JvdW5kQ29sb3IiLCJmaWx0ZXIiLCJoYXNPd25Qcm9wZXJ0eSIsImZvckVhY2giLCJfIiwidXNlcl9hZ2VudCIsInZlcnNpb24iLCJyZXNwb25zZUluZm8iLCJzdGF0dXMiLCJjb2RlIiwidXNlcl9lcnJfbXNnIiwic2Vzc2lvbklkIiwicmVhZCIsImRhdGFzZXQiLCJwcml2YXRlIiwiT2JqZWN0Iiwia2V5cyIsInZhcmlhYmxlcyIsIlJPT0tfU1ZDX1VSTCIsImpzb25faW5wdXQiLCJkYXRhc3R1YiIsImRhdGFsb2MiLCJ0YXJnZXRsb2MiLCJGb3JtRGF0YSIsInZhcnMiLCJpIiwib2JqIiwicmVmbGV4aXZlIiwibGFibCIsImNvdW50Iiwibm9kZUNvbCIsImJhc2VDb2wiLCJzdHJva2VDb2xvciIsInN0cm9rZVdpZHRoIiwic3Vic2V0cGxvdCIsInN1YnNldHJhbmdlIiwic2V0eHBsb3QiLCJzZXR4dmFscyIsImdyYXlvdXQiLCJncm91cDEiLCJncm91cDIiLCJmb3JlZnJvbnQiLCJqUXVlcnkiLCJleHRlbmQiLCJwdXNoIiwiZGF0YXZhcnMiLCJ2IiwibXlpIiwiYXNzaWduIiwiZDNtRGVzY3JpcHRpb24iLCJyZW1vdmUiLCJkYXRhRG93bmxvYWQiLCJmaWxlaWQiLCJob3N0bmFtZSIsImRkaXVybCIsImFwaWtleSIsIm1zZyIsIkVycm9yIiwiZGF0YXZlcnNldXJsIiwiREFUQVZFUlNFX1VSTCIsInN1YnN0cmluZyIsImlubmVySGVpZ2h0IiwiTGFkZGEiLCJjcmVhdGUiLCJtZXRhZGF0YXVybCIsIiRmaWxsIiwib3AiLCJkMSIsImQyIiwidHJhbnNpdGlvbiIsImF0dHIiLCJkZWxheSIsImR1cmF0aW9uIiwiZmlsbCIsImQiLCJmaWxsVGhpcyIsInNlbGYiLCJkZWwiLCJhcnIiLCJpZHgiLCJpbmRleE9mIiwic3BsaWNlIiwienBhcmFtc1Jlc2V0IiwidGV4dCIsImFwcGVuZCIsImxpbmUiLCJsaW5lMiIsInZpc2JhY2tncm91bmQiLCJ2aXMyYmFja2dyb3VuZCIsInZpcyIsInZpczIiLCJkcmFnX2xpbmUiLCJzZWxlY3RBbGwiLCJjaXJjbGUiLCJ2MiIsIm15VmFsdWVzIiwiaiIsImlpIiwic2VsZWN0TWUiLCJoZXhUb1JnYmEiLCJteXNyYyIsIm5vZGVJbmRleCIsIm15dGd0Iiwic291cmNlIiwibGVmdCIsInJpZ2h0IiwiZm9yY2UiLCJzaXplIiwibGlua0Rpc3RhbmNlIiwiY2hhcmdlIiwib24iLCJ0aWNrIiwic2VsZWN0ZWRfbm9kZSIsInNlbGVjdGVkX2xpbmsiLCJtb3VzZWRvd25fbGluayIsIm1vdXNlZG93bl9ub2RlIiwibW91c2V1cF9ub2RlIiwicmVzZXRNb3VzZVZhcnMiLCJmaW5kY29vcmRzIiwiZmluZG5hbWVzIiwiYWxsbmFtZXMiLCJjb29yZHMiLCJsZW5ndGhlbiIsImZjb29yZHMiLCJBcnJheSIsImFkZGxvY2F0aW9uIiwiZGVsdGF4IiwiZGVsdGF5IiwiZGVsdGEiLCJsZW5ndGhlbmNvb3JkcyIsImdyMWNvb3JkcyIsImdyMmNvb3JkcyIsImRlcGNvb3JkcyIsIm15aHVsbCIsImdlb20iLCJodWxsIiwiam9pbiIsInAiLCJqYW1lc2NlbnRyb2lkIiwicSIsImxkZWx0YVgiLCJsZGVsdGFZIiwibGRpc3QiLCJzcXJ0IiwibG5vcm1YIiwibG5vcm1ZIiwibHNvdXJjZVBhZGRpbmciLCJsdGFyZ2V0UGFkZGluZyIsInNpZ24iLCJuIiwibWluIiwiYWxwaGEiLCJkZWx0YVgiLCJkZWx0YVkiLCJkaXN0Iiwibm9ybVgiLCJub3JtWSIsInNvdXJjZVBhZGRpbmciLCJ0YXJnZXRQYWRkaW5nIiwic291cmNlWCIsInNvdXJjZVkiLCJ0YXJnZXRYIiwidGFyZ2V0WSIsIm91dHNpZGVDbGljayIsIiRsaW5rcyIsImNhbGwiLCJkcmFnIiwiZ3Jhdml0eSIsInNldFBlYmJsZUNoYXJnZSIsImxpbmtTdHJlbmd0aCIsInJlc3VtZSIsIm1hcmtlciIsImtpbmQiLCJzaWRlIiwiY2xhc3NlZCIsImVudGVyIiwiZXhpdCIsInJnYiIsImciLCJlYWNoIiwicGxvdHR5cGUiLCJzdHIiLCJyZWRyYXdQZWJibGVzIiwicGViYmxlIiwiX19kYXRhX18iLCJxdWVyeVNlbGVjdG9yIiwic2V0VGltZW91dCIsInNldENvbG9ycyIsImRlZmF1bHROdW1jaGFyIiwidG9TdHJpbmciLCJzdG9wUHJvcGFnYXRpb24iLCJwcmV2ZW50RGVmYXVsdCIsIm1vdXNlbW92ZSIsImRpcmVjdGlvbiIsImxpbmsiLCJzZXRMZWZ0VGFiIiwidmFyU3VtbWFyeSIsInNldEF0dHJpYnV0ZSIsInNlbGVjdGVkSW5kZXgiLCJyZWRyYXciLCJub2RlIiwicXVlcnlTZWxlY3RvckFsbCIsIm9uY2xpY2siLCJ0SW5wdXQiLCJ0cmFuc1BhcnNlIiwicGFyZW50Tm9kZSIsInRyYW5zZm9ybSIsIm1vdXNlZG93biIsImN0cmxLZXkiLCJtb3VzZSIsIm1vdXNldXAiLCJjbGlja19ldiIsImNsaWNrSUQiLCJmaW5kIiwiJG5vZGVzIiwid2hvbGUiLCJub2RlTmFtZSIsInVwZGF0ZU5vZGUiLCJuYW1lcyIsImluZGV4IiwibCIsImVsZW0iLCJtYXRjaGVkVmFyaWFibGVzIiwic2VhcmNoVmFyaWFibGVzIiwib3RoZXJzIiwibWF0Y2giLCJqc29uIiwidHlwZSIsIndpbiIsIm9wZW4iLCJmb2N1cyIsImxvY2tEZXNjcmlwdGlvbiIsInN0YXRlIiwiem5hdHVyZSIsIm5hdHVyZSIsInNyY3RndCIsInNlbGVjdGVkUGlwZWxpbmUiLCJzZXRTZWxlY3RlZFBpcGVsaW5lIiwicmVzdWx0IiwicGlwZWxpbmUiLCJwaXBlbGluZVRhYmxlIiwicm93IiwicGlwZWxpbmVIZWFkZXIiLCJvblBpcGVsaW5lQ3JlYXRlIiwiUGlwZWxpbmVDcmVhdGVSZXN1bHQiLCJyb29rcGlwZSIsInN0b3AiLCJwaXBlbGluZUlkIiwiZGV0YWlscyIsInByb2dyZXNzSW5mbyIsIm15aWQiLCJteW1ldHJpYyIsIm15dmFsIiwibXlzY29yZXMiLCJwaXBlbGluZUluZm8iLCJzY29yZXMiLCJ0b0ZpeGVkIiwidGFibGUiLCJDcmVhdGVQaXBlbGluZURhdGEiLCJwcmVkaWN0b3JzIiwiZGVwdmFyIiwiYXV4IiwidXJpQ3N2IiwidXJpSnNvbiIsImxhc3RJbmRleE9mIiwidGFyZ2V0RmVhdHVyZXMiLCJwcmVkaWN0RmVhdHVyZXMiLCJkYXRhc2V0X3VyaSIsInRhc2siLCJvdXRwdXQiLCJtZXRyaWNzIiwibWF4UGlwZWxpbmVzIiwiYnRuIiwiYWxsVmFycyIsIm1vZENvbCIsInJlbW92ZUNoaWxkIiwibW9kZWwiLCJpbnNlcnQiLCJhIiwiYiIsInN1YnN0ciIsInZpeiIsInJDYWxsIiwic2hvd0xvZyIsIm15dmtpIiwic2Vzc2lvbmlkIiwiaHJlZiIsIm15bSIsInJlbW92ZUtpZHMiLCJwYXJlbnQiLCJmaXJzdENoaWxkIiwiZmlsZWxpc3QiLCJpbWFnZXMiLCJ6ZmlnIiwiY3JlYXRlRWxlbWVudCIsImFwcGVuZENoaWxkIiwicmVzdWx0c0FycmF5Iiwic3VtSW5mbyIsInRoZWFkIiwiY29sbmFtZXMiLCJ0Ym9keSIsIm15TnVtIiwiTnVtYmVyIiwiaXNOYU4iLCJ0b1ByZWNpc2lvbiIsIm91dDIiLCJ0MiIsImsyIiwic3ViTWUyIiwiaW5kZXhlZCIsIm0yIiwicmUiLCJSZWdFeHAiLCJzIiwic2VhcmNoIiwiZnJvbSIsInRvIiwibXluIiwib3V0dHlwZXMiLCJ2YXJuYW1lc1R5cGVzIiwiaW50ZXJ2YWwiLCJudW1jaGFyIiwicGxvdHZhbHVlcyIsInBsb3R4IiwidHlwZVN0dWZmIiwiZXJyIiwid2FybiIsImZ1bmMiLCJzdWJzZXRlZCIsIm5ld1ZhciIsImVycm9yIiwianNvbmRhdGEiLCJteUluZGV4Iiwib2JqMSIsImRlZmF1bHRJbnRlcnZhbCIsImRlZmF1bHROYXR1cmUiLCJkZWZhdWx0QmluYXJ5Iiwid2FybmluZyIsImVsZW1lbnQiLCJwcm9idGFibGUiLCJteXByZWRpY3RvcnMiLCJzdW1tYXJ5IiwidDEiLCJyaW50IiwiZm9ybWF0IiwibWVhbkNJIiwibWVhbiIsImxvd2VyQm91bmQiLCJ1cHBlckJvdW5kIiwibWVkaWFuIiwiZnJlcW1vZGUiLCJtaWQiLCJmcmVxbWlkIiwiZmV3ZXN0IiwiZnJlcWZld2VzdCIsInNkIiwibWF4IiwiaW52YWxpZCIsInZhbGlkIiwidW5pcXVlcyIsImhlcmZpbmRhaGwiLCJwb3BvdmVyQ29udGVudCIsImludCIsInByZWMiLCJpZHMiLCJyZWdzdHIiLCJteW5hbWUiLCJleGVjIiwibm9kZWlkIiwicGFyc2VJbnQiLCJoZXgiLCJjIiwidGVtcGluZGV4IiwiY29sb3IiLCJpc0FycmF5IiwiZHZuYW1lIiwibmdyb3VwMSIsIm5ncm91cDIiLCJwYXJhbSIsImF0dHJzIiwiZWwiLCJlbnRyaWVzIiwic3Ryb2tlIiwic3Vic2V0RW1wdHkiLCJncmF5T3V0cyIsIm15Tm9kZXMiLCJteVBhcmFtcyIsIm15VHJhbnMiLCJteUZvcmNlIiwibXlQcmVwcm9jZXNzIiwibXlMb2ciLCJteUhpc3RvcnkiLCJ2YXJPdXQiLCJwbG90eSIsInJlUGxvdCIsImluaXRNb3VzZUV2ZW50IiwidGFibGVwb3NpdGlvbiIsInNlbGVjdGVkIiwicm93cyIsImNlbGxzIiwiaW5uZXJIVE1MIiwibXlzdGF0dXMiLCJwaXBlcyIsImRlbGV0ZVBpcGVsaW5lSWRzIiwiY2FuY2VsUGlwZWxpbmVJZHMiLCJwaXBlbGluZUlkcyIsInRhYmxlcm93IiwiaW5uZXJUZXh0IiwibXlkYXRhIiwibXltZWFuIiwiYWRkUHJlZGljdGlvbnMiLCJ0YWJ1bGF0ZSIsImNvbHVtbiIsInJvd25hbWUiLCJwYXJlbnRFbGVtZW50IiwiZ3JwY1Jlc3AiLCJhbGxQcmVkcyIsInJlc3VsdERhdGEiLCJwcmVkdmFscyIsImNvb3JkIiwibWlueCIsIm1heHgiLCJtaW55IiwibWF4eSIsInVwcGVyc2l6ZSIsIm5nMSIsIm5nMiIsIm1heG5nIiwibm9kZV9yYWRpdXMiLCJwaWQiLCJteWR2IiwiZHZ2YWx1ZXMiLCJwcmVkaWN0UmVzdWx0RGF0YSIsInN1Y2Nlc3MiLCJteWR2SSIsInhkYXRhIiwieWRhdGEiLCJjbGFzc05hbWUiLCJzaW5nbGVQbG90IiwiU3RyaW5nIiwibXljb3VudHMiLCJteXBhaXJzIiwibXl1bmlxdWVzIiwiU2V0Iiwic29ydCIsInRlbXBjb3VudCIsInRlbXBwYWlyIiwibXlpbmRleCIsImNvbmZkYXRhIiwibWF0cml4ZGF0YSIsImNsYXNzZXMiLCJtYWlud2lkdGgiLCJjbGllbnRXaWR0aCIsIm1haW5oZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJsb25nZXN0IiwicmVkdWNlIiwibGVmdG1hcmdpbmd1ZXNzIiwiY29uZGl2IiwiZGlzcGxheSIsImZsb2F0IiwibGVnZGl2IiwibWFyZ2luIiwidG9wIiwiYm90dG9tIiwiTWF0cml4Iiwib3B0aW9ucyIsImxhYmVsc0RhdGEiLCJsYWJlbHMiLCJzdGFydENvbG9yIiwic3RhcnRfY29sb3IiLCJlbmRDb2xvciIsImVuZF9jb2xvciIsInhPZmZzZXQiLCJ4X29mZnNldCIsIndpZHRoTGVnZW5kIiwibWF4VmFsdWUiLCJsYXllciIsIm1pblZhbHVlIiwibnVtcm93cyIsIm51bWNvbHMiLCJiYWNrZ3JvdW5kIiwib3JkaW5hbCIsImRvbWFpbiIsInJhbmdlIiwicmFuZ2VCYW5kcyIsImNvbG9yTWFwIiwibGluZWFyIiwiY2VsbCIsInJhbmdlQmFuZCIsImNvbHVtbkxhYmVscyIsInJvd0xhYmVscyIsInlBeGlzIiwiYXhpcyIsIm9yaWVudCIsInRwIiwiZm4iLCJmcCIsInRuIiwicHJlY2lzaW9uIiwicmVjYWxsIiwicm91bmQiLCJjb21wdXRlZERhdGEiLCJ4X0F4aXMiLCJ5X0F4aXMiLCJ4X0F4aXNfbmFtZSIsInlfQXhpc19uYW1lIiwiZGF0YV9wbG90IiwibmFuQ291bnQiLCJuZXdOdW1iZXIxIiwibmV3TnVtYmVyMiIsInhheGlzIiwieWF4aXMiLCJzY29yZSIsInJhbmRvbSIsInBhZGRpbmciLCJtaW5feCIsIm1heF94IiwiYXZnX3giLCJtaW5feSIsIm1heF95IiwiYXZnX3kiLCJ4U2NhbGUiLCJ5U2NhbGUiLCJ4QXhpcyIsInRpY2tTaXplIiwidGlja3MiLCJ6b29tIiwiYmVoYXZpb3IiLCJzY2FsZUV4dGVudCIsInpvb21lZCIsImNoYXJ0X3NjYXR0ZXIiLCJtYWluMSIsImdYIiwiZ1kiLCJjbGlwIiwicGFuWCIsInRyYW5zbGF0ZSIsInBhblkiLCJtYXhYIiwibWF4WSIsImZlYXR1cmVzIiwieHZhbCIsIngxdmFsIiwibXlzdmciLCJwb3AiLCJwaXBlbGluZUV4ZWNVcmkiLCJhcGlGZWF0dXJlIiwidXJpIiwib3V0IiwiZmVhdHVyZUlkIiwiZGF0YVVyaSIsImFwaUZlYXR1cmVTaG9ydFBhdGgiLCJzaG9ydFVyaSIsInNlc3Npb25faWQiLCJ1c2VyX21zZyIsImlzX3N1Y2Nlc3MiLCJyZWNvcmRlcl9jbnQiLCJzYXZlX3dvcmtzcGFjZV91cmwiLCJkb21haW5faWRlbnRpZmllciIsIndvcmtzcGFjZV9kYXRhIiwiQVBQX0RPTUFJTiIsInByZWQiLCJwcmVwcm9jZXNzX2ZpbGUiLCJleHRyYWN0IiwiY3VycmVudF90YXJnZXQiLCJjdXJyZW50X3ByZWRpY3RvcnMiLCJjdXJyZW50X3Rhc2siLCJjdXJyZW50X3JhdGluZyIsImN1cnJlbnRfZGVzY3JpcHRpb24iLCJjdXJyZW50X21ldHJpYyIsImN1cnJlbnRfZGlzY28iLCJyYXRpbmciLCJzZWxlY3RlZFByb2JsZW0iLCJzZXRTZWxlY3RlZFByb2JsZW0iLCJwcm9ibGVtIiwiY2hlY2tlZERpc2NvdmVyeVByb2JsZW1zIiwic2V0Q2hlY2tlZERpc2NvdmVyeVByb2JsZW0iLCJkZWxldGUiLCJoYXMiLCJuZXd0ZXh0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7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LENBQStCb0QsTUFBL0IsQ0FBc0MsYUFBdEM7QUFDQTdJLFNBQUssY0FBTCxFQUFxQnlGLFNBQXJCLENBQStCQyxHQUEvQixDQUFtQyxhQUFuQztBQUNBMUYsU0FBSyxlQUFMLEVBQXNCeUYsU0FBdEIsQ0FBZ0NvRCxNQUFoQyxDQUF1QyxhQUF2QztBQUNBN0ksU0FBSyxlQUFMLEVBQXNCeUYsU0FBdEIsQ0FBZ0NDLEdBQWhDLENBQW9DLGFBQXBDO0FBQ0EsWUExbElPdlIsY0EwbElQLG9CQUFpQixJQUFqQjtBQUNBLFFBQUcsQ0FBRUMsY0FBTCxFQUFxQjtBQUNqQjRMLGFBQUssYUFBTCxFQUFvQnlGLFNBQXBCLENBQThCb0QsTUFBOUIsQ0FBcUMsYUFBckM7QUFDQTdJLGFBQUssYUFBTCxFQUFvQnlGLFNBQXBCLENBQThCQyxHQUE5QixDQUFrQyxhQUFsQztBQUNIO0FBQ0R0RixZQUFRLGNBQVIsRUFBd0IsT0FBeEI7QUFDSDs7QUFFTSxTQUFTdFAsUUFBVCxDQUFrQjZsQixHQUFsQixFQUF1QjtBQUMxQixRQUFJZixRQUFRM1YsU0FBU0MsY0FBVCxDQUF3QixnQkFBeEIsQ0FBWjtBQUNBLFFBQUk2cEIsVUFBVTlwQixTQUFTQyxjQUFULENBQXdCLGdCQUF4QixFQUEwQ3ZDLEtBQXhEO0FBQ0EsU0FBSyxJQUFJeUosSUFBSSxDQUFSLEVBQVd3TixHQUFoQixFQUFxQkEsTUFBTWdCLE1BQU02SSxJQUFOLENBQVdyWCxDQUFYLENBQTNCLEVBQTBDQSxHQUExQyxFQUErQztBQUFFO0FBQzdDLFlBQUl3TixJQUFJb00sU0FBSixLQUFrQixhQUF0QixFQUFxQztBQUNqQ2puQixrQkFBTXFOLElBQUUsQ0FBUixFQUFXaEUsV0FBWCxHQUF5QjJtQixPQUF6QjtBQUNIO0FBQ0o7QUFDSiIsImZpbGUiOiIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGhvcHNjb3RjaCBmcm9tICdob3BzY290Y2gnO1xuaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCc7XG5cbmltcG9ydCB7aGVpZ2h0SGVhZGVyfSBmcm9tIFwiLi4vY29tbW9uL2FwcC9jb21tb25cIjtcbmltcG9ydCAqIGFzIGNvbW1vbiBmcm9tIFwiLi4vY29tbW9uL2FwcC9jb21tb25cIjtcbmltcG9ydCB7c2V0TW9kYWx9IGZyb20gJy4uL2NvbW1vbi9hcHAvdmlld3MvTW9kYWwnO1xuXG5pbXBvcnQge2JhcnMsIGJhcnNOb2RlLCBiYXJzU3Vic2V0LCBkZW5zaXR5LCBkZW5zaXR5Tm9kZSwgc2VsVmFyQ29sb3J9IGZyb20gJy4vcGxvdHMuanMnO1xuaW1wb3J0IHtlbGVtLCBmYWRlT3V0fSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7c2VhcmNoSW5kZXh9IGZyb20gXCIuL3ZpZXdzL1NlYXJjaFwiO1xuXG4vLyBob3N0bmFtZSBkZWZhdWx0IC0gdGhlIGFwcCB3aWxsIHVzZSBpdCB0byBvYnRhaW4gdGhlIHZhcmlhYmxlIG1ldGFkYXRhXG4vLyAoZGRpKSBhbmQgcHJlLXByb2Nlc3NlZCBkYXRhIGluZm8gaWYgdGhlIGZpbGUgaWQgaXMgc3VwcGxpZWQgYXMgYW5cbi8vIGFyZ3VtZW50IChmb3IgZXguLCBndWkuaHRtbD9kZklkPTE3KSwgYnV0IGhvc3RuYW1lIGlzbid0LlxuLy8gRWRpdCBpdCB0byBzdWl0IHlvdXIgaW5zdGFsbGF0aW9uLlxuLy8gKE5PVEUgdGhhdCBpZiB0aGUgZmlsZSBpZCBpc24ndCBzdXBwbGllZCwgdGhlIGFwcCB3aWxsIGRlZmF1bHQgdG8gdGhlXG4vLyBsb2NhbCBmaWxlcyBzcGVjaWZpZWQgYmVsb3chKVxuLy8gTkVXOiBpdCBpcyBhbHNvIHBvc3NpYmxlIG5vdyB0byBzdXBwbHkgY29tcGxldGUgdXJscyBmb3IgdGhlIGRkaSBhbmRcbi8vIHRoZSB0YWItZGVsaW1pdGVkIGRhdGEgZmlsZTsgdGhlIHBhcmFtZXRlcnMgYXJlIGRkaXVybCBhbmQgZGF0YXVybC5cbi8vIFRoZXNlIG5ldyBwYXJhbWV0ZXJzIGFyZSBvcHRpb25hbC4gSWYgdGhleSBhcmUgbm90IHN1cHBsaWVkLCB0aGUgYXBwXG4vLyB3aWxsIGdvIHRoZSBvbGQgcm91dGUgLSB3aWxsIHRyeSB0byBjb29rIHN0YW5kYXJkIGRhdGF2ZXJzZSB1cmxzXG4vLyBmb3IgYm90aCB0aGUgZGF0YSBhbmQgbWV0YWRhdGEsIGlmIHRoZSBmaWxlIGlkIGlzIHN1cHBsaWVkOyBvciB0aGVcbi8vIGxvY2FsIGZpbGVzIGlmIG5vdGhpbmcgaXMgc3VwcGxpZWQuXG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gTk9URTogZ2xvYmFsIHZhcmlhYmxlcyBhcmUgbm93IHNldCBpbiB0aGUgaW5kZXguaHRtbCBmaWxlLlxuLy8gICAgRGV2ZWxvcGVycywgc2VlIC90ZW1wbGF0ZS9pbmRleC5odG1sXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGxldCBtYXJnaW5Ub3BDYXJvdXNlbCA9IDA7XG5leHBvcnQgbGV0IG1hcmdpbkxlZnRDYXJvdXNlbCA9IDA7XG5cbndpbmRvdy5vbnJlc2l6ZSA9ICgpID0+IHtcbiAgICBpZiAobS5yb3V0ZS5nZXQoKSA9PT0gJy9kYXRhJykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IGNhcm91c2VsID0gZWxlbSgnI2lubmVyY2Fyb3VzZWwnKTtcbiAgICBsZXQgY29udGFpbmVyID0gZWxlbSgnI20wJyk7XG4gICAgbGV0IHdoaXRlc3BhY2UgPSBlbGVtKCcjd2hpdGVzcGFjZTAnKTtcblxuICAgIG1hcmdpblRvcENhcm91c2VsID0gKGNhcm91c2VsLm9mZnNldEhlaWdodCAtIHdoaXRlc3BhY2UuZ2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIpIC0gMTYpIC8gMjtcbiAgICBtYXJnaW5MZWZ0Q2Fyb3VzZWwgPSAoY2Fyb3VzZWwub2Zmc2V0V2lkdGggLSB3aGl0ZXNwYWNlLmdldEF0dHJpYnV0ZShcIndpZHRoXCIpKSAvIDI7XG5cbiAgICBjb250YWluZXIuc3R5bGUubWFyZ2luVG9wID0gbWFyZ2luVG9wQ2Fyb3VzZWwgKyAncHgnO1xuICAgIGNvbnRhaW5lci5zdHlsZS5tYXJnaW5MZWZ0ID0gbWFyZ2luTGVmdENhcm91c2VsICsgJ3B4JztcbiAgICBjb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gYGNhbGMoMTAwJSArICR7TWF0aC5hYnMobWFyZ2luVG9wQ2Fyb3VzZWwpfXB4KWA7XG59O1xuXG5sZXQgcGVla0JhdGNoU2l6ZSA9IDEwMDtcbmxldCBwZWVrU2tpcCA9IDA7XG5sZXQgcGVla0RhdGEgPSBbXTtcblxubGV0IHBlZWtBbGxEYXRhUmVjZWl2ZWQgPSBmYWxzZTtcbmxldCBwZWVrSXNHZXR0aW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIG9uU3RvcmFnZUV2ZW50KGUpIHtcbiAgICBpZiAoZS5rZXkgIT09ICdwZWVrTW9yZScgfHwgcGVla0lzR2V0dGluZykgcmV0dXJuO1xuXG4gICAgaWYgKGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdwZWVrTW9yZScpID09PSAndHJ1ZScgJiYgIXBlZWtBbGxEYXRhUmVjZWl2ZWQpIHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3BlZWtNb3JlJywgJ2ZhbHNlJyk7XG4gICAgICAgIHBlZWtJc0dldHRpbmcgPSB0cnVlO1xuICAgICAgICB1cGRhdGVQZWVrKCk7XG4gICAgfVxufVxuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc3RvcmFnZScsIG9uU3RvcmFnZUV2ZW50KTtcblxuZnVuY3Rpb24gdXBkYXRlUGVlaygpIHtcbiAgICBtLnJlcXVlc3QoYHJvb2stY3VzdG9tL3Jvb2stZmlsZXMvJHtjb25maWd1cmF0aW9ucy5uYW1lfS9kYXRhL3RyYWluRGF0YS50c3ZgLCB7XG4gICAgICAgIGRlc2VyaWFsaXplOiB4ID0+IHguc3BsaXQoJ1xcbicpLm1hcCh5ID0+IHkuc3BsaXQoJ1xcdCcpKVxuICAgIH0pLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgIC8vIHNpbXVsYXRlIG9ubHkgbG9hZGluZyBzb21lIG9mIHRoZSBkYXRhLi4uIGJ5IGp1c3QgZGVsZXRpbmcgYWxsIHRoZSBvdGhlciBkYXRhXG4gICAgICAgIGxldCBoZWFkZXJzID0gZGF0YVswXS5tYXAoeCA9PiB4LnJlcGxhY2UoL1wiL2csICcnKSk7XG4gICAgICAgIGxldCBuZXdEYXRhID0gZGF0YS5zbGljZShwZWVrU2tpcCArIDEsIHBlZWtTa2lwICsgMSArIHBlZWtCYXRjaFNpemUpO1xuXG4gICAgICAgIC8vIHN0b3AgYmxvY2tpbmcgbmV3IHJlcXVlc3RzXG4gICAgICAgIHBlZWtJc0dldHRpbmcgPSBmYWxzZTtcblxuICAgICAgICAvLyBzdGFydCBibG9ja2luZyBuZXcgcmVxdWVzdHMgdW50aWwgcGVla1Jlc2V0KCkgaXMgY2FsbGVkXG4gICAgICAgIGlmIChuZXdEYXRhLmxlbmd0aCA9PT0gMCkgcGVla0FsbERhdGFSZWNlaXZlZCA9IHRydWU7XG5cbiAgICAgICAgcGVla0RhdGEgPSBwZWVrRGF0YS5jb25jYXQobmV3RGF0YSk7XG4gICAgICAgIHBlZWtTa2lwICs9IG5ld0RhdGEubGVuZ3RoO1xuXG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdwZWVrVGFibGVIZWFkZXJzJywgSlNPTi5zdHJpbmdpZnkoaGVhZGVycykpO1xuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgncGVla1RhYmxlRGF0YScsIEpTT04uc3RyaW5naWZ5KHBlZWtEYXRhKSk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlc2V0UGVlaygpIHtcbiAgICBwZWVrU2tpcCA9IDA7XG4gICAgcGVla0RhdGEgPSBbXTtcblxuICAgIHBlZWtBbGxEYXRhUmVjZWl2ZWQgPSBmYWxzZTtcbiAgICBwZWVrSXNHZXR0aW5nID0gZmFsc2U7XG5cbiAgICAvLyBwcm92b2tlIGEgcmVkcmF3IGZyb20gdGhlIHBlZWsgbWVudVxuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdwZWVrVGFibGVEYXRhJyk7XG59XG5cbnJlc2V0UGVlaygpO1xuXG5leHBvcnQgbGV0IHRhc2sxX2ZpbmlzaGVkID0gZmFsc2U7XG5leHBvcnQgbGV0IHRhc2syX2ZpbmlzaGVkID0gZmFsc2U7XG5leHBvcnQgbGV0IHVuaXZhcmlhdGVfZmluaXNoZWQgPSBmYWxzZTtcblxuZXhwb3J0IGxldCBjdXJyZW50TW9kZSA9ICdtb2RlbCc7XG5sZXQgaXNfZXhwbG9yZV9tb2RlID0gZmFsc2U7XG5sZXQgaXNfcmVzdWx0c19tb2RlID0gZmFsc2U7XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRfbW9kZShtb2RlKSB7XG4gICAgaWYgKCFtb2RlKSBtb2RlID0gJ21vZGVsJztcbiAgICBtb2RlID0gbW9kZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgaWYgKGN1cnJlbnRNb2RlICE9PSBtb2RlKSB7XG4gICAgICAgIHVwZGF0ZVJpZ2h0UGFuZWxXaWR0aCgpO1xuICAgICAgICB1cGRhdGVMZWZ0UGFuZWxXaWR0aCgpO1xuXG4gICAgICAgIGN1cnJlbnRNb2RlID0gbW9kZTtcbiAgICAgICAgbS5yb3V0ZS5zZXQoJy8nICsgbW9kZS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG5cbiAgICBpc19leHBsb3JlX21vZGUgPSBtb2RlID09PSAnZXhwbG9yZSc7XG4gICAgaXNfcmVzdWx0c19tb2RlID0gbW9kZSA9PT0gJ3Jlc3VsdHMnO1xufVxuXG4vLyBmb3IgZGVidWdnaW5nIC0gaWYgbm90IGluIFBST0RVQ1RJT04sIHByaW50cyBhcmdzXG5leHBvcnQgbGV0IGNkYiA9IF8gPT4gUFJPRFVDVElPTiB8fCBjb25zb2xlLmxvZyguLi5hcmd1bWVudHMpO1xuXG5leHBvcnQgbGV0IGsgPSA0OyAvLyBzdHJlbmd0aCBwYXJhbWV0ZXIgZm9yIGdyb3VwIGF0dHJhY3Rpb24vcmVwdWxzaW9uXG5sZXQgdHV0b3JpYWxfbW9kZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd0dXRvcmlhbF9tb2RlJykgIT09ICdmYWxzZSc7XG5cbi8vIGluaXRpYWwgY29sb3Igc2NhbGUgdXNlZCB0byBlc3RhYmxpc2ggdGhlIGluaXRpYWwgY29sb3JzIG9mIG5vZGVzXG4vLyBhbGxOb2Rlcy5wdXNoKCkgYmVsb3cgZXN0YWJsaXNoZXMgYSBmaWVsZCBmb3IgdGhlIG1hc3RlciBub2RlIGFycmF5IGFsbE5vZGVzIGNhbGxlZCBcIm5vZGVDb2xcIiBhbmQgYXNzaWducyBhIGNvbG9yIGZyb20gdGhpcyBzY2FsZSB0byB0aGF0IGZpZWxkXG4vLyBldmVyeXRoaW5nIHRoZXJlIGFmdGVyIHNob3VsZCByZWZlciB0byB0aGUgbm9kZUNvbCBhbmQgbm90IHRoZSBjb2xvciBzY2FsZSwgdGhpcyBlbmFibGVzIHVzIHRvIHVwZGF0ZSBjb2xvcnMgYW5kIHBhc3MgdGhlIHZhcmlhYmxlIHR5cGUgdG8gUiBiYXNlZCBvbiBpdHMgY29sb3JpbmdcbmxldCBjb2xvcnMgPSBkMy5zY2FsZS5jYXRlZ29yeTIwKCk7XG5leHBvcnQgbGV0IGNzQ29sb3IgPSAnIzQxOTY0MSc7XG5leHBvcnQgbGV0IGR2Q29sb3IgPSAnIzI4YTRjOSc7XG5leHBvcnQgbGV0IGdyMUNvbG9yID0gJyMxNGJkY2MnOyAgLy8gaW5pdGlhbGx5IHdhcyAjMjRhNGM5JywgYnV0IHRoYXQgaXMgZHZDb2xvciwgYW5kIHdlIHRyYWNrIHNvbWUgcHJvcGVydGllcyBieSBjb2xvciBhc3N1bWluZyB0aGVtIHVuaXF1ZVxubGV0IGdyMU9wYWNpdHkgPSBbMCwxXTtcbmV4cG9ydCBsZXQgZ3IyQ29sb3IgPSAnI2ZmY2NjYyc7XG5sZXQgZ3IyT3BhY2l0eSA9IFswLDFdO1xuXG5sZXQgZ3JheUNvbG9yID0gJyNjMGMwYzAnO1xuZXhwb3J0IGxldCBub21Db2xvciA9ICcjZmY2NjAwJztcbmV4cG9ydCBsZXQgdmFyQ29sb3IgPSAnI2YwZjhmZic7IC8vIGQzLnJnYihcImFsaWNlYmx1ZVwiKTtcbmxldCB0YWdnZWRDb2xvciA9ICcjZjVmNWY1JzsgLy8gZDMucmdiKFwid2hpdGVzbW9rZVwiKTtcbmV4cG9ydCBsZXQgdGltZUNvbG9yID0gJyMyZDZjYTInO1xuXG5leHBvcnQgbGV0IGxlZnRUYWIgPSAnVmFyaWFibGVzJzsgLy8gY3VycmVudCB0YWIgaW4gbGVmdCBwYW5lbFxuZXhwb3J0IGxldCBsZWZ0VGFiSGlkZGVuID0gJ1ZhcmlhYmxlcyc7IC8vIHN0b3JlcyB0aGUgdGFiIHVzZXIgd2FzIGluIGJlZm9yZSBzdW1tYXJ5IGhvdmVyXG5leHBvcnQgbGV0IHN1YnNldCA9IGZhbHNlO1xuZXhwb3J0IGxldCBzdW1tYXJ5SG9sZCA9IGZhbHNlO1xuXG5leHBvcnQgbGV0IHJpZ2h0VGFiID0gJ1Rhc2sgVHlwZSc7IC8vIGN1cnJlbnQgdGFiIGluIHJpZ2h0IHBhbmVsXG5leHBvcnQgbGV0IHJpZ2h0VGFiRXhwbG9yZSA9ICdVbml2YXJpYXRlJztcblxuZXhwb3J0IGxldCBtb2RlbExlZnRQYW5lbFdpZHRocyA9IHtcbiAgICAnVmFyaWFibGVzJzogJzMwMHB4JyxcbiAgICAnRGlzY292ZXJ5JzogJ2F1dG8nLFxuICAgICdTdW1tYXJ5JzogJzMwMHB4J1xufTtcblxuZXhwb3J0IGxldCBtb2RlbFJpZ2h0UGFuZWxXaWR0aHMgPSB7XG4gICAgJ01vZGVscyc6ICczMDBweCcsXG4gICAgJ1Rhc2sgVHlwZSc6ICczMDBweCcsXG4gICAgJ1N1YnR5cGUnOiAnMzAwcHgnLFxuICAgICdNZXRyaWNzJzogJzMwMHB4JyxcbiAgICAvLyAgICAgJ1NldCBDb3Zhci4nOiAnOTAwcHgnLFxuICAgICdSZXN1bHRzJzogJzkwMHB4J1xufTtcblxuZXhwb3J0IGxldCBleHBsb3JlUmlnaHRQYW5lbFdpZHRocyA9IHtcbiAgICAnVW5pdmFyaWF0ZSc6ICc3MDBweCcsXG4gICAgJ0JpdmFyaWF0ZSc6ICc3NSUnXG59O1xuXG5leHBvcnQgbGV0IHNldFJpZ2h0VGFiID0gKHRhYikgPT4geyByaWdodFRhYiA9IHRhYjsgdXBkYXRlUmlnaHRQYW5lbFdpZHRoKCkgfTtcbmV4cG9ydCBsZXQgc2V0UmlnaHRUYWJFeHBsb3JlID0gKHRhYikgPT4geyByaWdodFRhYkV4cGxvcmUgPSB0YWI7IHVwZGF0ZVJpZ2h0UGFuZWxXaWR0aCgpIH07XG5cbi8vIHBhbmVsV2lkdGggaXMgbWVhbnQgdG8gYmUgcmVhZCBvbmx5XG5leHBvcnQgbGV0IHBhbmVsV2lkdGggPSB7XG4gICAgJ2xlZnQnOiAnMCcsXG4gICAgJ3JpZ2h0JzogJzAnXG59O1xuXG5sZXQgdXBkYXRlUmlnaHRQYW5lbFdpZHRoID0gKCkgPT4ge1xuICAgIGlmIChjb21tb24ucGFuZWxPcGVuWydyaWdodCddKSB7XG4gICAgICAgIGxldCB0ZW1wV2lkdGggPSB7XG4gICAgICAgICAgICAnbW9kZWwnOiBtb2RlbFJpZ2h0UGFuZWxXaWR0aHNbcmlnaHRUYWJdLFxuICAgICAgICAgICAgJ2V4cGxvcmUnOiBleHBsb3JlUmlnaHRQYW5lbFdpZHRoc1tyaWdodFRhYkV4cGxvcmVdXG4gICAgICAgIH1bY3VycmVudE1vZGVdO1xuXG4gICAgICAgIHBhbmVsV2lkdGhbJ3JpZ2h0J10gPSBgY2FsYygke2NvbW1vbi5wYW5lbE1hcmdpbiAqIDJ9cHggKyAke3RlbXBXaWR0aH0pYDtcbiAgICB9XG4gICAgZWxzZSBwYW5lbFdpZHRoWydyaWdodCddID0gYGNhbGMoJHtjb21tb24ucGFuZWxNYXJnaW4gKiAyfXB4ICsgMTZweClgO1xufTtcbmxldCB1cGRhdGVMZWZ0UGFuZWxXaWR0aCA9ICgpID0+IHtcbiAgICBpZiAoY29tbW9uLnBhbmVsT3BlblsnbGVmdCddKVxuICAgICAgICBwYW5lbFdpZHRoWydsZWZ0J10gPSBgY2FsYygke2NvbW1vbi5wYW5lbE1hcmdpbiAqIDJ9cHggKyAke21vZGVsTGVmdFBhbmVsV2lkdGhzW2xlZnRUYWJdfSlgO1xuICAgIGVsc2UgcGFuZWxXaWR0aFsnbGVmdCddID0gYGNhbGMoJHtjb21tb24ucGFuZWxNYXJnaW4gKiAyfXB4ICsgMTZweClgO1xufTtcblxudXBkYXRlUmlnaHRQYW5lbFdpZHRoKCk7XG51cGRhdGVMZWZ0UGFuZWxXaWR0aCgpO1xuXG5jb21tb24uc2V0UGFuZWxDYWxsYmFjaygncmlnaHQnLCB1cGRhdGVSaWdodFBhbmVsV2lkdGgpO1xuY29tbW9uLnNldFBhbmVsQ2FsbGJhY2soJ2xlZnQnLCB1cGRhdGVMZWZ0UGFuZWxXaWR0aCk7XG5cbi8vIHRyYW5zZm9ybWF0aW9uIHRvb2xiYXIgb3B0aW9uc1xubGV0IHQsIHR5cGVUcmFuc2Zvcm07XG5leHBvcnQgbGV0IHRyYW5zZm9ybUxpc3QgPSAnbG9nKGQpIGV4cChkKSBkXjIgc3FydChkKSBpbnRlcmFjdChkLGUpJy5zcGxpdCgnICcpO1xubGV0IHRyYW5zZm9ybVZhciA9ICcnO1xuXG4vLyB2YXIgbGlzdCBmb3IgZWFjaCBzcGFjZSBjb250YWluIHZhcmlhYmxlcyBpbiBvcmlnaW5hbCBkYXRhXG4vLyBwbHVzIHRyYW5zIGluIHRoYXQgc3BhY2VcbmxldCB0cmFucyA9IFtdO1xubGV0IHByZXByb2Nlc3MgPSB7fTsgLy8gaG9sZCBwcmUtcHJvY2Vzc2VkIGRhdGFcbmxldCBzcGFjZXMgPSBbXTtcblxuLy8gbGF5b3V0IGZ1bmN0aW9uIGNvbnN0YW50c1xuY29uc3QgbGF5b3V0QWRkID0gXCJhZGRcIjtcbmNvbnN0IGxheW91dE1vdmUgPSBcIm1vdmVcIjtcblxuLy8gcmFkaXVzIG9mIGNpcmNsZVxuZXhwb3J0IGNvbnN0IFJBRElVUyA9IDQwO1xuXG4vLyBjeCwgY3ksIHIgdmFsdWVzIGZvciBpbmRpY2F0b3IgbGlnaHRzXG5sZXQgaW5kMSA9IFsoUkFESVVTKzMwKSAqIE1hdGguY29zKDEuMyksIC0xKihSQURJVVMrMzApICogTWF0aC5zaW4oMS4zKSwgNV07XG5sZXQgaW5kMiA9IFsoUkFESVVTKzMwKSAqIE1hdGguY29zKDEuMSksIC0xKihSQURJVVMrMzApICogTWF0aC5zaW4oMS4xKSwgNV07XG5cbi8vIHNwYWNlIGluZGV4XG5leHBvcnQgbGV0IG15c3BhY2UgPSAwO1xuXG5leHBvcnQgbGV0IGZvcmNldG9nZ2xlID0gW1widHJ1ZVwiXTtcbmV4cG9ydCBsZXQgbG9ja3RvZ2dsZSA9IHRydWU7XG5sZXQgcHJpdiA9IHRydWU7XG5cbi8vIHN3YW5kaXZlIGlzIG91ciBncmFjZWZ1bCBmYWlsIGZvciBkM21cbi8vIHN3YW5kaXZlIHNldCB0byB0cnVlIGlmIHRhc2sgaXMgaW4gZmFpbHNldFxuZXhwb3J0IGxldCBzd2FuZGl2ZSA9IGZhbHNlO1xubGV0IGZhaWxzZXQgPSBbXCJUSU1FX1NFUklFU19GT1JFQ0FTVElOR1wiLFwiR1JBUEhfTUFUQ0hJTkdcIixcIkxJTktfUFJFRElDVElPTlwiLFwidGltZVNlcmllc0ZvcmVjYXN0aW5nXCIsXCJncmFwaE1hdGNoaW5nXCIsXCJsaW5rUHJlZGljdGlvblwiXTtcblxuLy8gb2JqZWN0IHRoYXQgY29udGFpbnMgYWxsIGluZm9ybWF0aW9uIGFib3V0IHRoZSByZXR1cm5lZCBwaXBlbGluZXNcbmV4cG9ydCBsZXQgYWxsUGlwZWxpbmVJbmZvID0ge307XG5cbmV4cG9ydCBsZXQgbG9nQXJyYXkgPSBbXTtcbmV4cG9ydCBsZXQgenBhcmFtcyA9IHtcbiAgICB6ZGF0YTogW10sXG4gICAgemVkZ2VzOiBbXSxcbiAgICB6dGltZTogW10sXG4gICAgem5vbTogW10sXG4gICAgemNyb3NzOiBbXSxcbiAgICB6bW9kZWw6IFwiXCIsXG4gICAgenZhcnM6IFtdLFxuICAgIHpkdjogW10sXG4gICAgemdyb3VwMTogW10sXG4gICAgemdyb3VwMjogW10sIC8vIGhhcmQgY29kaW5nIHRvIHR3byBncm91cHMgZm9yIHByZXNlbnQgZXhwZXJpbWVudHMsIGJ1dCB3aWxsIGV2ZW50dWFsbHkgbWFrZSB6Z3JvdXAgYXJyYXkgb2YgYXJyYXlzLCB3aXRoIHpncm91cC5sZW5ndGggdGhlIG51bWJlciBvZiBncm91cHNcbiAgICB6ZGF0YXVybDogXCJcIixcbiAgICB6ZDNtZGF0YTogXCJcIiwgLy90aGVzZSB0YWtlIHRoZSBwbGFjZSBvZiB6ZGF0YXVybCBmb3IgZDNtLCBiZWNhdXNlIGRhdGEgaXMgaW4gdHdvIHBsYWNlZXMuIGV2ZW50dWFsbHkgd2lsbCBnZW5lcmFsaXplXG4gICAgemQzbXRhcmdldDogXCJcIixcbiAgICB6c3Vic2V0OiBbXSxcbiAgICB6c2V0eDogW10sXG4gICAgem1vZGVsY291bnQ6IDAsXG4gICAgenBsb3Q6IFtdLFxuICAgIHpzZXNzaW9uaWQ6IFwiXCIsXG4gICAgemRhdGFjaXRlOiAnLi4uJyxcbiAgICB6Y3Jvc3N0YWI6IFtdLFxuICAgIHp1c2VybmFtZTogJydcbn07XG5cbmV4cG9ydCBsZXQgZGlzY28gPSBbXTtcblxuZXhwb3J0IGxldCBtb2RlbENvdW50ID0gMDtcbmV4cG9ydCBsZXQgdmFsdWVLZXkgPSBbXTtcbmV4cG9ydCBsZXQgYWxsTm9kZXMgPSBbXTtcbmV4cG9ydCBsZXQgYWxsUmVzdWx0cyA9IFtdO1xuZXhwb3J0IGxldCBub2RlcyA9IFtdO1xuZXhwb3J0IGxldCBsaW5rcyA9IFtdO1xubGV0IG1vZHMgPSB7fTtcbmxldCBlc3RpbWF0ZWQgPSBmYWxzZTtcbmxldCByaWdodENsaWNrTGFzdCA9IGZhbHNlO1xubGV0IHNlbEludGVyYWN0ID0gZmFsc2U7XG5leHBvcnQgbGV0IGNhbGxIaXN0b3J5ID0gW107IC8vIHRyYW5zZm9ybSBhbmQgc3Vic2V0IGNhbGxzXG5sZXQgbXl0YXJnZXQgPSAnJztcblxuZXhwb3J0IGxldCBjb25maWd1cmF0aW9ucyA9IHt9O1xubGV0IGRhdGFkb2N1bWVudCA9IHt9O1xuXG5leHBvcnQgbGV0IGRvbWFpbklkZW50aWZpZXIgPSBudWxsOyAvLyBhdmFpbGFibGUgdGhyb3VnaG91dCBhcHBzIGpzOyB1c2VkIGZvciBzYXZpbmcgd29ya3NwYWNlXG5cbi8vIGV2ZW50dWFsbHkgcmVhZCB0aGlzIGZyb20gdGhlIHNjaGVtYSB3aXRoIHJlYWwgZGVzY3JpcHRpb25zXG4vLyBtZXRyaWNzLCB0YXNrcywgYW5kIHN1YnRhc2tzIGFzIHNwZWNpZmllZCBpbiBEM00gc2NoZW1hc1xuLy8gTUVBTiBTUVVBUkVEIEVSUk9SIElTIFNFVCBUTyBTQU1FIEFTIFJNU0UuIE1TRSBpcyBpbiBzY2hlbWEgYnV0IG5vdCBwcm90b1xuZXhwb3J0IGxldCBkM21UYXNrVHlwZSA9IHtcbiAgICB0YXNrVHlwZVVuZGVmaW5lZDogW1wiZGVzY3JpcHRpb25cIiwgXCJUQVNLX1RZUEVfVU5ERUZJTkVEXCIsIDBdLFxuICAgIGNsYXNzaWZpY2F0aW9uOiBbXCJkZXNjcmlwdGlvblwiLCBcIkNMQVNTSUZJQ0FUSU9OXCIgLCAxXSxcbiAgICByZWdyZXNzaW9uOiBbXCJkZXNjcmlwdGlvblwiLCBcIlJFR1JFU1NJT05cIiAsIDJdLFxuICAgIGNsdXN0ZXJpbmc6IFtcImRlc2NyaXB0aW9uXCIsIFwiQ0xVU1RFUklOR1wiLCAzXSxcbiAgICBsaW5rUHJlZGljdGlvbjogW1wiZGVzY3JpcHRpb25cIiwgXCJMSU5LX1BSRURJQ1RJT05cIiAsIDRdLFxuICAgIHZlcnRleE5vbWluYXRpb246IFtcImRlc2NyaXB0aW9uXCIsIFwiVkVSVEVYX05PTUlOQVRJT05cIiAsIDVdLFxuICAgIGNvbW11bml0eURldGVjdGlvbjogW1wiZGVzY3JpcHRpb25cIiwgXCJDT01NVU5JVFlfREVURUNUSU9OXCIgLCA2XSxcbiAgICBncmFwaENsdXN0ZXJpbmc6IFtcImRlc2NyaXB0aW9uXCIsIFwiR1JBUEhfQ0xVU1RFUklOR1wiICwgN10sXG4gICAgZ3JhcGhNYXRjaGluZzogW1wiZGVzY3JpcHRpb25cIiwgXCJHUkFQSF9NQVRDSElOR1wiICwgOF0sXG4gICAgdGltZVNlcmllc0ZvcmVjYXN0aW5nOiBbXCJkZXNjcmlwdGlvblwiLCBcIlRJTUVfU0VSSUVTX0ZPUkVDQVNUSU5HXCIgLCA5XSxcbiAgICBjb2xsYWJvcmF0aXZlRmlsdGVyaW5nOiBbXCJkZXNjcmlwdGlvblwiLCBcIkNPTExBQk9SQVRJVkVfRklMVEVSSU5HXCIgLCAxMF1cbn07XG5cbmV4cG9ydCBsZXQgZDNtVGFza1N1YnR5cGUgPSB7XG4gICAgdGFza1N1YnR5cGVVbmRlZmluZWQ6W1wiZGVzY3JpcHRpb25cIiwgXCJUQVNLX1NVQlRZUEVfVU5ERUZJTkVEXCIsIDBdLFxuICAgIHN1YnR5cGVOb25lOltcImRlc2NyaXB0aW9uXCIsXCJOT05FXCIsMV0sXG4gICAgYmluYXJ5OltcImRlc2NyaXB0aW9uXCIsIFwiQklOQVJZXCIgLCAyXSxcbiAgICBtdWx0aUNsYXNzOltcImRlc2NyaXB0aW9uXCIsIFwiTVVMVElDTEFTU1wiICwgM10sXG4gICAgbXVsdGlMYWJlbDpbXCJkZXNjcmlwdGlvblwiLCBcIk1VTFRJTEFCRUxcIiAsIDRdLFxuICAgIHVuaXZhcmlhdGU6W1wiZGVzY3JpcHRpb25cIiwgXCJVTklWQVJJQVRFXCIgLCA1XSxcbiAgICBtdWx0aXZhcmlhdGU6W1wiZGVzY3JpcHRpb25cIiwgXCJNVUxUSVZBUklBVEVcIiAsIDZdLFxuICAgIG92ZXJsYXBwaW5nOltcImRlc2NyaXB0aW9uXCIsIFwiT1ZFUkxBUFBJTkdcIiAsIDddLFxuICAgIG5vbk92ZXJsYXBwaW5nOltcImRlc2NyaXB0aW9uXCIsIFwiTk9OT1ZFUkxBUFBJTkdcIiAsIDhdXG59O1xuLypleHBvcnQgbGV0IGQzbU91dHB1dFR5cGUgPSB7XG4gICAgb3V0cHV0VW5kZWZpbmVkOltcImRlc2NyaXB0aW9uXCIsXCJPVVRQVVRfVFlQRV9VTkRFRklORUQgXCIsIDBdLFxuICAgIHByZWRpY3Rpb25zRmlsZTpbXCJkZXNjcmlwdGlvblwiLFwiUFJFRElDVElPTlNfRklMRVwiLDFdLFxuICAgIHNjb3Jlc0ZpbGU6W1wiZGVzY3JpcHRpb25cIixcIlNDT1JFU19GSUxFXCIsMl1cbn07ICovXG5leHBvcnQgbGV0IGQzbU1ldHJpY3MgPSB7XG4gICAgbWV0cmljVW5kZWZpbmVkOltcImRlc2NyaXB0aW9uXCIsIFwiTUVUUklDX1VOREVGSU5FRFwiICwgMF0sXG4gICAgZXhlY3V0aW9uVGltZTpbXCJkZXNjcmlwdGlvblwiLCBcIkVYRUNVVElPTl9USU1FXCIsIDFdLFxuICAgIGFjY3VyYWN5IDogW1wiZGVzY3JpcHRpb25cIiwgXCJBQ0NVUkFDWVwiICwgMl0sXG4gICAgZjE6W1wiZGVzY3JpcHRpb25cIiwgXCJGMVwiICwgM10sXG4gICAgZjFNaWNybzpbXCJkZXNjcmlwdGlvblwiLCBcIkYxX01JQ1JPXCIgLCA0XSxcbiAgICBmMU1hY3JvOltcImRlc2NyaXB0aW9uXCIsIFwiRjFfTUFDUk9cIiAsIDVdLFxuICAgIHJvY0F1YzpbXCJkZXNjcmlwdGlvblwiLCBcIlJPQ19BVUNcIiAsIDZdLFxuICAgIHJvY0F1Y01pY3JvOltcImRlc2NyaXB0aW9uXCIsIFwiUk9DX0FVQ19NSUNST1wiICwgN10sXG4gICAgcm9jQXVjTWFjcm86W1wiZGVzY3JpcHRpb25cIiwgXCJST0NfQVVDX01BQ1JPXCIgLCA4XSxcbiAgICBtZWFuU3F1YXJlZEVycm9yOltcImRlc2NyaXB0aW9uXCIsIFwiTUVBTl9TUVVBUkVEX0VSUk9SXCIsIDldLFxuICAgIHJvb3RNZWFuU3F1YXJlZEVycm9yOltcImRlc2NyaXB0aW9uXCIsIFwiUk9PVF9NRUFOX1NRVUFSRURfRVJST1JcIiAsIDEwXSxcbiAgICByb290TWVhblNxdWFyZWRFcnJvckF2ZzpbXCJkZXNjcmlwdGlvblwiLCBcIlJPT1RfTUVBTl9TUVVBUkVEX0VSUk9SX0FWR1wiICwgMTFdLFxuICAgIG1lYW5BYnNvbHV0ZUVycm9yOltcImRlc2NyaXB0aW9uXCIsIFwiTUVBTl9BQlNPTFVURV9FUlJPUlwiICwgMTJdLFxuICAgIHJTcXVhcmVkOltcImRlc2NyaXB0aW9uXCIsIFwiUl9TUVVBUkVEXCIgLCAxM10sXG4gICAgbm9ybWFsaXplZE11dHVhbEluZm9ybWF0aW9uOltcImRlc2NyaXB0aW9uXCIsIFwiTk9STUFMSVpFRF9NVVRVQUxfSU5GT1JNQVRJT05cIiAsIDE0XSxcbiAgICBqYWNjYXJkU2ltaWxhcml0eVNjb3JlOltcImRlc2NyaXB0aW9uXCIsIFwiSkFDQ0FSRF9TSU1JTEFSSVRZX1NDT1JFXCIgLCAxNV1cbn07XG5cbmV4cG9ydCBsZXQgZDNtUHJvYmxlbURlc2NyaXB0aW9uID0ge1xuICAgIHRhc2tUeXBlOiBcInRhc2tUeXBlVW5kZWZpbmVkXCIsXG4gICAgdGFza1N1YnR5cGU6IFwidGFza1N1YnR5cGVVbmRlZmluZWRcIixcbiAvLyAgIG91dHB1dFR5cGU6IFszLFwiREVGQVVMVFwiXSxcbiAgICBtZXRyaWM6IFwibWV0cmljVW5kZWZpbmVkXCIsXG4gICAgdGFza0Rlc2NyaXB0aW9uOiBcIlwiXG59O1xuXG4vKlxuICogY2FsbCB0byBkamFuZ28gdG8gdXBkYXRlIHRoZSBwcm9ibGVtIGRlZmluaXRpb24gaW4gdGhlIHByb2JsZW0gZG9jdW1lbnRcbiAqIHJwYyBTZXRQcm9ibGVtRG9jKFNldFByb2JsZW1Eb2NSZXF1ZXN0KSByZXR1cm5zIChSZXNwb25zZSkge31cbiAqL1xuZXhwb3J0IGxldCBzZXREM21Qcm9ibGVtRGVzY3JpcHRpb24gPSAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgIGlmICghbG9ja3RvZ2dsZSkge1xuICAgICAgICBkM21Qcm9ibGVtRGVzY3JpcHRpb25ba2V5XSA9IHZhbHVlO1xuXG4gICAgICAgIGxldCBsb29rdXAgPSB7XG4gICAgICAgICAgICAndGFza1R5cGUnOiBkM21UYXNrVHlwZSxcbiAgICAgICAgICAgICd0YXNrU3VidHlwZSc6IGQzbVRhc2tTdWJ0eXBlLFxuICAgICAgICAgICAgLy8gJ291dHB1dFR5cGUnOiBkM21PdXRwdXRUeXBlLFxuICAgICAgICAgICAgJ21ldHJpYyc6IGQzbU1ldHJpY3NcbiAgICAgICAgfVtrZXldO1xuXG4gICAgICAgIGlmIChsb29rdXAgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgICAgICBtYWtlUmVxdWVzdChcbiAgICAgICAgICAgIEQzTV9TVkNfVVJMICsgXCIvU2V0UHJvYmxlbURvY1wiLFxuICAgICAgICAgICAge3JlcGxhY2VQcm9ibGVtU2NoZW1hRmllbGQ6IHtba2V5XTogbG9va3VwW2QzbVByb2JsZW1EZXNjcmlwdGlvbltrZXldXVsxXX0sIGNvbnRleHQ6IGFwaVNlc3Npb24oenBhcmFtcy56c2Vzc2lvbmlkKX0pO1xuICAgIH1cbiAgICBlbHNlIGhvcHNjb3RjaC5zdGFydFRvdXIobG9ja1RvdXIpO1xufVxuXG5sZXQgc3ZnLCBkaXYsIHNlbGVjdExhZGRhO1xuZXhwb3J0IGxldCB3aWR0aCwgaGVpZ2h0LCBlc3RpbWF0ZUxhZGRhLCBkaXNjb3ZlcnlMYWRkYTtcblxuLy8gYXJjcyBmb3IgZGVub3RpbmcgcGViYmxlIGNoYXJhY3RlcmlzdGljc1xuY29uc3QgYXJjID0gKHN0YXJ0LCBlbmQpID0+IChyYWRpdXMpID0+IGQzLnN2Zy5hcmMoKVxuICAgIC5pbm5lclJhZGl1cyhyYWRpdXMgKyA1KVxuICAgIC5vdXRlclJhZGl1cyhyYWRpdXMgKyAyMClcbiAgICAuc3RhcnRBbmdsZShzdGFydClcbiAgICAuZW5kQW5nbGUoZW5kKTtcbmV4cG9ydCBjb25zdCBbYXJjMCwgYXJjMSwgYXJjMiwgYXJjMywgYXJjNF0gPSBbYXJjKDAsIDMuMiksIGFyYygwLCAxKSwgYXJjKDEuMSwgMi4yKSwgYXJjKDIuMywgMy4zKSwgYXJjKDQuMywgNS4zKV07XG5jb25zdCBhcmNJbmQgPSAoYXJjbGltaXRzKSA9PiAocmFkaXVzKSA9PiBkMy5zdmcuYXJjKClcbiAgICAuaW5uZXJSYWRpdXMocmFkaXVzICsgMjIpXG4gICAgLm91dGVyUmFkaXVzKHJhZGl1cyArIDM3KVxuICAgIC5zdGFydEFuZ2xlKGFyY2xpbWl0c1swXSlcbiAgICAuZW5kQW5nbGUoYXJjbGltaXRzWzFdKTtcblxuY29uc3QgW2FyY0luZDFMaW1pdHMsIGFyY0luZDJMaW1pdHNdID0gW1swLCAwLjNdLCBbMC4zNSwgMC42NV1dO1xuY29uc3QgW2FyY0luZDEsIGFyY0luZDJdID0gW2FyY0luZChhcmNJbmQxTGltaXRzKSwgYXJjSW5kKGFyY0luZDJMaW1pdHMpXTtcblxuLy8gbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmVmb3JlIHNob3dpbmcvaGlkaW5nIHRoZSBwZWJibGUgaGFuZGxlc1xubGV0IGhvdmVyVGltZW91dCA9IDE1MDtcbmxldCBob3ZlclBlYmJsZTtcbmxldCBzZWxlY3RlZFBlYmJsZTtcblxuZXhwb3J0IGxldCBieUlkID0gaWQgPT4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuLy8gZXhwb3J0IGxldCBieUlkID0gaWQgPT4ge2NvbnNvbGUubG9nKGlkKTsgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTt9XG5cbmZ1bmN0aW9uIHRyaWdnZXIoaWQsIGV2ZW50KSB7XG4gICAgbGV0IGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJyk7XG4gICAgZXZ0LmluaXRFdmVudChldmVudCwgdHJ1ZSwgZmFsc2UpO1xuICAgIGJ5SWQoaWQpLmRpc3BhdGNoRXZlbnQoZXZ0KTtcbn1cblxuLyoqXG4gICBwYWdlIHJlbG9hZCBsaW5rZWQgdG8gYnRuUmVzZXRcbiovXG5leHBvcnQgY29uc3QgcmVzZXQgPSBhc3luYyBmdW5jdGlvbiByZWxvYWRQYWdlKCkge1xuICAgIGxldCByZXMgPSBhd2FpdCBtYWtlUmVxdWVzdChEM01fU1ZDX1VSTCArICcvZW5kc2Vzc2lvbicsIGFwaVNlc3Npb24oenBhcmFtcy56c2Vzc2lvbmlkKSk7XG4gICAgYnlJZChcImJ0bk1vZGVsXCIpLmNsaWNrKCk7XG4gICAgbG9jYXRpb24ucmVsb2FkKCk7XG59O1xuZXhwb3J0IGxldCByZXN0YXJ0O1xuXG5sZXQgZGF0YXVybCA9ICcnO1xuXG5leHBvcnQgbGV0IHN0ZXAgPSAodGFyZ2V0LCBwbGFjZW1lbnQsIHRpdGxlLCBjb250ZW50KSA9PiAoe1xuICAgIHRhcmdldCxcbiAgICBwbGFjZW1lbnQsXG4gICAgdGl0bGUsXG4gICAgY29udGVudCxcbiAgICBzaG93Q1RBQnV0dG9uOiB0cnVlLFxuICAgIGN0YUxhYmVsOiAnRGlzYWJsZSB0aGVzZSBtZXNzYWdlcycsXG4gICAgb25DVEE6ICgpID0+IHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3R1dG9yaWFsX21vZGUnLCAnZmFsc2UnKTtcbiAgICAgICAgaG9wc2NvdGNoLmVuZFRvdXIodHJ1ZSk7XG4gICAgfVxufSk7XG5cbmV4cG9ydCBsZXQgbXl0b3VyID0ge1xuICAgIGlkOiBcImRhdGFzZXRfbGF1bmNoXCIsXG4gICAgaTE4bjoge2RvbmVCdG46J09rJ30sXG4gICAgc2hvd0Nsb3NlQnV0dG9uOiB0cnVlLFxuICAgIHNjcm9sbER1cmF0aW9uOiAzMDAsXG4gICAgc3RlcHM6IFtcbiAgICAgICAgc3RlcChcImRhdGFOYW1lXCIsIFwiYm90dG9tXCIsIFwiV2VsY29tZSB0byBUd29SYXZlbnMgU29sdmVyXCIsXG4gICAgICAgICAgICAgYDxwPlRoaXMgdG9vbCBjYW4gZ3VpZGUgeW91IHRvIHNvbHZlIGFuIGVtcGlyaWNhbCBwcm9ibGVtIGluIHRoZSBkYXRhc2V0IGFib3ZlLjwvcD5cbiAgICAgICAgICAgICAgICAgICAgICA8cD5UaGVzZSBtZXNzYWdlcyB3aWxsIHRlYWNoIHlvdSB0aGUgc3RlcHMgdG8gdGFrZSB0byBmaW5kIGFuZCBzdWJtaXQgYSBzb2x1dGlvbi48L3A+YCksXG4gICAgICAgIHN0ZXAoXCJidG5SZXNldFwiLCBcImJvdHRvbVwiLCBcIlJlc3RhcnQgQW55IFByb2JsZW0gSGVyZVwiLFxuICAgICAgICAgICAgICc8cD5Zb3UgY2FuIGFsd2F5cyBzdGFydCBhIHByb2JsZW0gb3ZlciBieSB1c2luZyB0aGlzIHJlc2V0IGJ1dHRvbi48L3A+JyksXG4gICAgICAgIHN0ZXAoXCJidG5EaXNjb3ZlcnlcIiwgXCJyaWdodFwiLCBcIlN0YXJ0IFRhc2sgMVwiLFxuICAgICAgICAgICAgIGA8cD5UaGlzIFByb2JsZW0gRGlzY292ZXJ5IGJ1dHRvbiBhbGxvd3MgeW91IHRvIHN0YXJ0IFRhc2sgMSAtIFByb2JsZW0gRGlzY292ZXJ5LjwvcD5cbiAgICAgICAgICAgICAgICAgICAgIDxwPkdlbmVyYWxseSwgYXMgYSB0aXAsIHRoZSBHcmVlbiBidXR0b24gaXMgdGhlIG5leHQgYnV0dG9uIHlvdSBuZWVkIHRvIHByZXNzIHRvIG1vdmUgdGhlIGN1cnJlbnQgdGFzayBmb3J3YXJkLjwvcD5cbiAgICAgICAgICAgICAgICAgICAgIDxwPkNsaWNrIHRoaXMgYnV0dG9uIHRvIHNlZSBhIGxpc3Qgb2YgcHJvYmxlbXMgdGhhdCBoYXZlIGJlZW4gZGlzY292ZXJlZCBpbiB0aGUgZGF0YXNldC48L3A+XG4gICAgICAgICAgICAgICAgICAgICA8cD5Zb3UgY2FuIG1hcmsgd2hpY2ggb25lcyB5b3UgYWdyZWUgbWF5IGJlIGludGVyZXN0aW5nLCBhbmQgdGhlbiBzdWJtaXQgdGhlIHRhYmxlIGFzIGFuIGFuc3dlci48L3A+YCksXG4gICAgICAgIC8vc3RlcChcImJ0blNlbGVjdFwiLCBcInJpZ2h0XCIsIFwiQ29tcGxldGUgVGFzayAxXCIsXG4gICAgICAgIC8vICAgICBgPHA+VGhpcyBzdWJtaXNzaW9uIGJ1dHRvbiBtYXJrcyBUYXNrIDEgLSBQcm9ibGVtIERpc2NvdmVyeSwgYXMgY29tcGxldGUuPC9wPlxuICAgICAgICAvLyAgICAgPHA+Q2xpY2sgdGhpcyBidXR0b24gdG8gc2F2ZSB0aGUgY2hlY2sgbWFya2VkIHByb2JsZW1zIGluIHRoZSB0YWJsZSBiZWxvdyBhcyBwb3RlbnRpYWxseSBpbnRlcmVzdGluZyBvciByZWxldmFudC48L3A+XG4gICAgICAgIC8vICAgICA8cD5HZW5lcmFsbHksIGFzIGEgdGlwLCB0aGUgR3JlZW4gYnV0dG9uIGlzIHRoZSBuZXh0IGJ1dHRvbiB5b3UgbmVlZCB0byBwcmVzcyB0byBtb3ZlIHRoZSBjdXJyZW50IHRhc2sgZm9yd2FyZC48L3A+YCksXG4gICAgICAgIHN0ZXAoXCJidG5Fc3RpbWF0ZVwiLCBcImxlZnRcIiwgXCJTb2x2ZSBUYXNrIDJcIixcbiAgICAgICAgICAgICBgPHA+VGhpcyBnZW5lcmFsbHkgaXMgdGhlIGltcG9ydGFudCBzdGVwIHRvIGZvbGxvdyBmb3IgVGFzayAyIC0gQnVpbGQgYSBNb2RlbC48L3A+XG4gICAgICAgICAgICAgICAgICAgICAgPHA+R2VuZXJhbGx5LCBhcyBhIHRpcCwgdGhlIEdyZWVuIGJ1dHRvbiBpcyB0aGUgbmV4dCBidXR0b24geW91IG5lZWQgdG8gcHJlc3MgdG8gbW92ZSB0aGUgY3VycmVudCB0YXNrIGZvcndhcmQsIGFuZCB0aGlzIGJ1dHRvbiB3aWxsIGJlIEdyZWVuIHdoZW4gVGFzayAxIGlzIGNvbXBsZXRlZCBhbmQgVGFzayAyIHN0YXJ0ZWQuPC9wPlxuICAgICAgICAgICAgICAgICAgICAgIDxwPkNsaWNrIHRoaXMgU29sdmUgYnV0dG9uIHRvIHRlbGwgdGhlIHRvb2wgdG8gZmluZCBhIHNvbHV0aW9uIHRvIHRoZSBwcm9ibGVtLCB1c2luZyB0aGUgdmFyaWFibGVzIHByZXNlbnRlZCBpbiB0aGUgY2VudGVyIHBhbmVsLjwvcD5gKSxcbiAgICAgICAgc3RlcChteXRhcmdldCArICdiaWdncm91cCcsIFwibGVmdFwiLCBcIlRhcmdldCBWYXJpYWJsZVwiLFxuICAgICAgICAgICAgIGBUaGlzIGlzIHRoZSB2YXJpYWJsZSwgJHtteXRhcmdldH0sIHdlIGFyZSB0cnlpbmcgdG8gcHJlZGljdC5cbiAgICAgICAgICAgICAgICAgICAgICBUaGlzIGNlbnRlciBwYW5lbCBncmFwaGljYWxseSByZXByZXNlbnRzIHRoZSBwcm9ibGVtIGN1cnJlbnRseSBiZWluZyBhdHRlbXB0ZWQuYCksXG4gICAgICAgIHN0ZXAoXCJncjFodWxsXCIsIFwicmlnaHRcIiwgXCJFeHBsYW5hdGlvbiBTZXRcIiwgXCJUaGlzIHNldCBvZiB2YXJpYWJsZXMgY2FuIHBvdGVudGlhbGx5IHByZWRpY3QgdGhlIHRhcmdldC5cIiksXG4gICAgICAgIHN0ZXAoXCJkaXNwbGFjZW1lbnRcIiwgXCJyaWdodFwiLCBcIlZhcmlhYmxlIExpc3RcIixcbiAgICAgICAgICAgICBgPHA+Q2xpY2sgb24gYW55IHZhcmlhYmxlIG5hbWUgaGVyZSBpZiB5b3Ugd2lzaCB0byByZW1vdmUgaXQgZnJvbSB0aGUgcHJvYmxlbSBzb2x1dGlvbi48L3A+XG4gICAgICAgICAgICAgICAgICAgICAgPHA+WW91IGxpa2VseSBkbyBub3QgbmVlZCB0byBhZGp1c3QgdGhlIHByb2JsZW0gcmVwcmVzZW50YXRpb24gaW4gdGhlIGNlbnRlciBwYW5lbC48L3A+YCksXG4gICAgICAgIHN0ZXAoXCJidG5FbmRTZXNzaW9uXCIsIFwiYm90dG9tXCIsIFwiRmluaXNoIFByb2JsZW1cIixcbiAgICAgICAgICAgICBcIklmIHRoZSBzb2x1dGlvbiByZXBvcnRlZCBiYWNrIHNlZW1zIGFjY2VwdGFibGUsIHRoZW4gZmluaXNoIHRoaXMgcHJvYmxlbSBieSBjbGlja2luZyB0aGlzIEVuZCBTZXNzaW9uIGJ1dHRvbi5cIiksXG4gICAgXVxufTtcblxuXG5leHBvcnQgbGV0IG15dG91cjMgPSB7XG4gICAgaWQ6IFwiZGF0YXNldF9sYXVuY2hcIixcbiAgICBpMThuOiB7ZG9uZUJ0bjonT2snfSxcbiAgICBzaG93Q2xvc2VCdXR0b246IHRydWUsXG4gICAgc2Nyb2xsRHVyYXRpb246IDMwMCxcbiAgICBzdGVwczogW1xuICAgICAgICBzdGVwKFwiYnRuU2VsZWN0XCIsIFwicmlnaHRcIiwgXCJDb21wbGV0ZSBUYXNrIDFcIixcbiAgICAgICAgICAgICBgPHA+VGhpcyBzdWJtaXNzaW9uIGJ1dHRvbiBtYXJrcyBUYXNrIDEgLSBQcm9ibGVtIERpc2NvdmVyeSwgYXMgY29tcGxldGUuPC9wPlxuICAgICAgICAgICAgICAgICAgICAgPHA+Q2xpY2sgdGhpcyBidXR0b24gdG8gc2F2ZSB0aGUgY2hlY2sgbWFya2VkIHByb2JsZW1zIGluIHRoZSB0YWJsZSBiZWxvdyBhcyBwb3RlbnRpYWxseSBpbnRlcmVzdGluZyBvciByZWxldmFudC48L3A+XG4gICAgICAgICAgICAgICAgICAgICA8cD5HZW5lcmFsbHksIGFzIGEgdGlwLCB0aGUgR3JlZW4gYnV0dG9uIGlzIHRoZSBuZXh0IGJ1dHRvbiB5b3UgbmVlZCB0byBwcmVzcyB0byBtb3ZlIHRoZSBjdXJyZW50IHRhc2sgZm9yd2FyZC48L3A+YCksXG4gICAgXVxufTtcblxuLy8gYXBwZWFycyB3aGVuIGEgdXNlciBhdHRlbXB0cyB0byBlZGl0IHdoZW4gdGhlIHRvZ2dsZSBpcyBzZXRcbmV4cG9ydCBsZXQgbG9ja1RvdXIgPSB7XG4gICAgaWQ6IFwibG9ja190b2dnbGVcIixcbiAgICBpMThuOiB7ZG9uZUJ0bjonT2snfSxcbiAgICBzaG93Q2xvc2VCdXR0b246IHRydWUsXG4gICAgc2Nyb2xsRHVyYXRpb246IDMwMCxcbiAgICBzdGVwczogW1xuICAgICAgICBzdGVwKFwiYnRuTG9ja1wiLCBcImxlZnRcIiwgXCJMb2NrZWQgTW9kZVwiLCBgPHA+Q2xpY2sgdGhlIGxvY2sgYnV0dG9uIHRvIGVuYWJsZSBlZGl0aW5nLjwvcD5gKVxuICAgIF1cbn07XG5cbi8qKlxuICBjYWxsZWQgYnkgbWFpblxuICBMb2FkcyBhbGwgZXh0ZXJuYWwgZGF0YSBpbiB0aGUgZm9sbG93aW5nIG9yZGVyIChsb2dpYyBpcyBub3QgaW5jbHVkZWQpOlxuICAxLiBSZXRyaWV2ZSB0aGUgY29uZmlndXJhdGlvbiBpbmZvcm1hdGlvblxuICAyLiBTZXQgJ2NvbmZpZ3VyYXRpb25zJ1xuICAzLiBSZWFkIHRoZSBwcm9ibGVtIHNjaGVtYSBhbmQgc2V0ICdkM21Qcm9ibGVtRGVzY3JpcHRpb24nXG4gIDQuIFJlYWQgdGhlIGRhdGEgZG9jdW1lbnQgYW5kIHNldCAnZGF0YWRvY3VtZW50J1xuICA1LiBSZWFkIGluIHplbGlnIG1vZGVscyAobm90IGZvciBkM20pXG4gIDYuIFJlYWQgaW4gemVsaWdjaG9pY2UgbW9kZWxzIChub3QgZm9yIGQzbSlcbiAgNy4gU3RhcnQgdGhlIHVzZXIgc2Vzc2lvblxuICA4LiBSZWFkIHByZXByb2Nlc3MgZGF0YSBvciAoaWYgbmVjZXNzYXJ5KSBydW4gcHJlcHJvY2Vzc1xuICA5LiBCdWlsZCBhbGxOb2Rlc1tdIHVzaW5nIHByZXByb2Nlc3NlZCBpbmZvcm1hdGlvblxuICAxMC4gQWRkIGRhdGFkb2N1bWVudCBpbmZvcm1hdGlvbiB0byBhbGxOb2RlcyAod2hlbiBpbiBJU19EM01fRE9NQUlOKVxuICAxMS4gQ2FsbCBsYXlvdXQoKSBhbmQgc3RhcnQgdXBcbiovXG5hc3luYyBmdW5jdGlvbiBsb2FkKGhvbGQsIGxhYmxBcnJheSwgZDNtUm9vdFBhdGgsIGQzbURhdGFOYW1lLCBkM21QcmVwcm9jZXNzLCBkM21EYXRhLCBkM21QUywgZDNtRFMsIHBVUkwpIHtcbiAgICBpZiAoIUlTX0QzTV9ET01BSU4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIDEuIFJldHJpZXZlIHRoZSBjb25maWd1cmF0aW9uIGluZm9ybWF0aW9uXG4gICAgbGV0IHJlcyA9IGF3YWl0IG0ucmVxdWVzdCh7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIHVybDogXCIvY29uZmlnL2QzbS1jb25maWcvanNvbi9sYXRlc3RcIlxuICAgIH0pO1xuICAgIGNvbnNvbGUubG9nKHJlcyk7XG4gICAgLy8gMi4gU2V0ICdjb25maWd1cmF0aW9ucydcbiAgICBjb25maWd1cmF0aW9ucyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocmVzKSk7IC8vIHRoaXMgaXMganVzdCBjb3B5aW5nIHJlc1xuICAgIGQzbVJvb3RQYXRoID0gY29uZmlndXJhdGlvbnMudHJhaW5pbmdfZGF0YV9yb290LnJlcGxhY2UoL1xcL2RhdGEvLCcnKTtcbiAgICBkM21EYXRhTmFtZSA9IGNvbmZpZ3VyYXRpb25zLm5hbWU7XG5cbiAgICAvLyBzY29wZXMgYXQgYXBwLmpzIGxldmVsOyB1c2VkIGZvciBzYXZpbmcgd29ya3NwYWNlXG4gICAgZG9tYWluSWRlbnRpZmllciA9IHtuYW1lOiBjb25maWd1cmF0aW9ucy5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlX3VybDogY29uZmlndXJhdGlvbnMuY29uZmlnX3VybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnRDNNIGNvbmZpZyBmaWxlJ307XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2lkOiBjb25maWd1cmF0aW9ucy5pZH07XG5cbiAgICBkM21QUyA9IFwiL2NvbmZpZy9kM20tY29uZmlnL2dldC1wcm9ibGVtLXNjaGVtYS9qc29uXCI7XG4gICAgZDNtRFMgPSBcIi9jb25maWcvZDNtLWNvbmZpZy9nZXQtZGF0YXNldC1zY2hlbWEvanNvblwiO1xuICAgIGNvbnNvbGUubG9nKFwiQ29uZmlndXJhdGlvbnM6IFwiLCBjb25maWd1cmF0aW9ucyk7XG4gICAgZDNtUHJlcHJvY2VzcyA9IHBVUkwgPSBgcm9vay1jdXN0b20vcm9vay1maWxlcy8ke2QzbURhdGFOYW1lfS9wcmVwcm9jZXNzL3ByZXByb2Nlc3MuanNvbmA7XG4gICAgY29uc29sZS5sb2coZDNtUHJlcHJvY2Vzcyk7XG5cbiAgICAvLyAzLiBSZWFkIHRoZSBwcm9ibGVtIHNjaGVtYSBhbmQgc2V0ICdkM21Qcm9ibGVtRGVzY3JpcHRpb24nXG4gICAgLy8gLi4uYW5kIG1ha2UgYSBjYWxsIHRvIHN0YXJ0IHRoZSBzZXNzaW9uIHdpdGggVEEyLiBpZiB3ZSBnZXQgdGhpcyBmYXIsIGRhdGEgYXJlIGd1YXJhbnRlZWQgdG8gZXhpc3QgZm9yIHRoZSBmcm9udGVuZFxuXG4gICAgcmVzID0gYXdhaXQgbS5yZXF1ZXN0KFwiL2NvbmZpZy9kM20tY29uZmlnL2dldC1wcm9ibGVtLWRhdGEtZmlsZS1pbmZvXCIpO1xuICAgIC8vIFRoZSByZXN1bHQgb2YgdGhpcyBjYWxsIGlzIHNpbWlsYXIgdG8gYmVsb3c6XG4gICAgLy8gZXhhbXBsZTpcbiAgICAvKiAge1xuICAgICAgICAgICAgIFwic3VjY2Vzc1wiOnRydWUsXG4gICAgICAgICAgICAgXCJkYXRhXCI6e1xuICAgICAgICAgICAgICAgIFwibGVhcm5pbmdEYXRhLmNzdlwiOntcbiAgICAgICAgICAgICAgICAgICBcImV4aXN0c1wiOnRydWUsXG4gICAgICAgICAgICAgICAgICAgXCJzaXplXCI6MTE2NTQsXG4gICAgICAgICAgICAgICAgICAgXCJwYXRoXCI6XCIvaW5wdXRzL2RhdGFzZXRfVFJBSU4vdGFibGVzL2xlYXJuaW5nRGF0YS5jc3ZcIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJsZWFybmluZ0RhdGEuY3N2Lmd6XCI6e1xuICAgICAgICAgICAgICAgICAgIFwiZXhpc3RzXCI6ZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgXCJzaXplXCI6LTEsXG4gICAgICAgICAgICAgICAgICAgXCJwYXRoXCI6XCIvaW5wdXRzL2RhdGFzZXRfVFJBSU4vdGFibGVzL2xlYXJuaW5nRGF0YS5jc3YuZ3pcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICovXG5cbiAgICAvLyBMb29wIHRocm91Z2ggdGhlIHJlc3BvbnNlIGFib3ZlIGFuZFxuICAgIC8vIHBpY2sgdGhlIGZpcnN0IFwicGF0aFwiIHdoZXJlIFwiZXhpc3RzXCIgaXMgdHJ1ZVxuICAgIC8vXG4gICAgLy8gTm90ZTogaWYgZGF0YSBmaWxlcyBoYXZlIFwiZXhpc3RzXCIgYXMgZmFsc2UsIHN0YXkgYXMgZGVmYXVsdCB3aGljaCBpcyBudWxsXG4gICAgLy9cbiAgICBsZXQgc2V0X2QzbV9kYXRhX3BhdGggPSAoZmllbGQsIHZhbCkgPT4gcmVzLmRhdGFbZmllbGRdLmV4aXN0cyA/IHJlcy5kYXRhW2ZpZWxkXS5wYXRoIDpcbiAgICAgICAgcmVzLmRhdGFbZmllbGQgKyAnLmd6J10uZXhpc3RzID8gcmVzLmRhdGFbZmllbGQgKyAnLmd6J10ucGF0aCA6XG4gICAgICAgIHZhbDtcblxuICAgIHpwYXJhbXMuemQzbWRhdGEgPSBkM21EYXRhID0gc2V0X2QzbV9kYXRhX3BhdGgoJ2xlYXJuaW5nRGF0YS5jc3YnLCBkM21EYXRhKTtcbiAgICB6cGFyYW1zLnpkM210YXJnZXQgPSBzZXRfZDNtX2RhdGFfcGF0aCgnbGVhcm5pbmdEYXRhLmNzdicsIGQzbURhdGEpO1xuXG4gICAgLy8gSWYgdGhpcyBpcyB0aGUgRDNNIGRvbWFpbjsgZDNtRGF0YSBNVVNUIGJlIHNldCB0byBhbiBhY3R1YWwgdmFsdWVcbiAgICAvL1xuICAgIGlmICgoSVNfRDNNX0RPTUFJTikmJihkM21EYXRhID09IG51bGwpKXtcbiAgICAgICAgY29uc3QgZDNtX3BhdGhfZXJyID0gJ05PIFZBTElEIGQzbURhdGEgcGF0aCEhICcgKyBKU09OLnN0cmluZ2lmeShyZXMpXG4gICAgICAgIGNvbnNvbGUubG9nKGQzbV9wYXRoX2Vycik7XG4gICAgICAgIGFsZXJ0KCdkZWJ1ZyAoYmUgbW9yZSBncmFjZWZ1bCk6ICcgKyBkM21fcGF0aF9lcnIpO1xuICAgIH1cblxuICAgIC8vIGhhcmRjb2RpbmcgdGhpcywgb25jZSBnZXQtcHJvYmxlbS1kYXRhLWZpbGUtaW5mbyBpcyByZXZpc2VkIHRoaXMgaGFyZGNvZGUgY2FuIGdvIGF3YXkgYW5kIHVzZSB0aGUgcHJldmlvdXMgdHdvIExPQ1xuICAvLyAgenBhcmFtcy56ZDNtZGF0YSA9IGQzbURhdGEgPSBkM21Sb290UGF0aCtcIi9kYXRhc2V0X1RSQUlOL3RhYmxlcy9sZWFybmluZ0RhdGEuY3N2XCI7XG4gIC8vICB6cGFyYW1zLnpkM210YXJnZXQgPSBkM21Sb290UGF0aCtcIi9kYXRhc2V0X1RSQUlOL3RhYmxlcy9sZWFybmluZ0RhdGEuY3N2XCI7XG5cbiAgICByZXMgPSBhd2FpdCBtLnJlcXVlc3QoZDNtUFMpO1xuICAgIGNvbnNvbGUubG9nKFwicHJvYiBzY2hlbWEgZGF0YTogXCIsIHJlcyk7XG5cbiAgICBteXRhcmdldCA9IHJlcy5pbnB1dHMuZGF0YVswXS50YXJnZXRzWzBdLmNvbE5hbWU7IC8vIGVhc2llciB3YXkgdG8gYWNjZXNzIHRhcmdldCBuYW1lP1xuICAgIGlmICh0eXBlb2YgcmVzLmFib3V0LnRhc2tUeXBlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBkM21Qcm9ibGVtRGVzY3JpcHRpb24udGFza1R5cGU9cmVzLmFib3V0LnRhc2tUeXBlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHJlcy5hYm91dC50YXNrU3ViVHlwZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZDNtUHJvYmxlbURlc2NyaXB0aW9uLnRhc2tTdWJ0eXBlPXJlcy5hYm91dC50YXNrU3ViVHlwZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiByZXMuaW5wdXRzLnBlcmZvcm1hbmNlTWV0cmljc1swXS5tZXRyaWMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGQzbVByb2JsZW1EZXNjcmlwdGlvbi5tZXRyaWMgPSByZXMuaW5wdXRzLnBlcmZvcm1hbmNlTWV0cmljc1swXS5tZXRyaWM7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcmVzLmRlc2NyaXB0aW9uRmlsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZDNtUHJvYmxlbURlc2NyaXB0aW9uLnRhc2tEZXNjcmlwdGlvbiA9IHJlcy5kZXNjcmlwdGlvbkZpbGU7XG4gICAgfVxuIC8vICAgZDNtUHJvYmxlbURlc2NyaXB0aW9uLm91dHB1dFR5cGUgPSByZXMuZXhwZWN0ZWRPdXRwdXRzLnByZWRpY3Rpb25zRmlsZTtcblxuICAgIC8vIG1ha2luZyBpdCBjYXNlIGluc2Vuc2l0aXZlIGJlY2F1c2UgdGhlIGNhc2Ugc2VlbXMgdG8gZGlzYWdyZWUgYWxsIHRvbyBvZnRlblxuICAgIGlmIChmYWlsc2V0LmluY2x1ZGVzKGQzbVByb2JsZW1EZXNjcmlwdGlvbi50YXNrVHlwZS50b1VwcGVyQ2FzZSgpKSkge1xuICAgICAgICBpZihJU19EM01fRE9NQUlOKXtcbiAgICAgICAgICBjb25zb2xlLmxvZygnRDNNIFdBUk5JTkc6IGZhaWxzZXQgIHRhc2sgdHlwZSBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIHN3YW5kaXZlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyA0LiBSZWFkIHRoZSBkYXRhIGRvY3VtZW50IGFuZCBzZXQgJ2RhdGFkb2N1bWVudCdcbiAgICBkYXRhZG9jdW1lbnQgPSBhd2FpdCBtLnJlcXVlc3QoZDNtRFMpO1xuXG4gICAgLy8gaWYgbm8gY29sdW1ucyBpbiB0aGUgZGF0YWRvY3VtZW50LCBnbyB0byBzd2FuZGl2ZVxuICAgIC8vIDRhLiBTZXQgZGF0YWRvY3VtZW50IGNvbHVtbnMhXG4gICAgbGV0IGRhdGFkb2N1bWVudF9jb2x1bW5zO1xuICAgIGxldCBjb2xfaWR4O1xuICAgIGZvciAoY29sX2lkeCA9IDA7IGNvbF9pZHggPCBkYXRhZG9jdW1lbnQuZGF0YVJlc291cmNlcy5sZW5ndGg7IGNvbF9pZHgrKykge1xuICAgICAgICBpZihkYXRhZG9jdW1lbnQuZGF0YVJlc291cmNlc1tjb2xfaWR4XS5jb2x1bW5zKSB7XG4gICAgICAgICAgICBkYXRhZG9jdW1lbnRfY29sdW1ucyA9IGRhdGFkb2N1bWVudC5kYXRhUmVzb3VyY2VzW2NvbF9pZHhdLmNvbHVtbnM7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnY29sdW1ucyBmb3VuZCBpbiBkYXRhZG9jdW1lbnQuZGF0YVJlc291cmNlc1snICsgY29sX2lkeCArICddLmNvbHVtbnMnKTtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkYXRhZG9jdW1lbnRfY29sdW1ucyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBjb25zb2xlLmxvZygnRDNNIFdBUk5JTkc6IGRhdGFkb2N1bWVudC5kYXRhUmVzb3VyY2VzW3hdLmNvbHVtbnMgaXMgdW5kZWZpbmVkLicpO1xuICAgICAgICBzd2FuZGl2ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKElTX0QzTV9ET01BSU4pIHtcbiAgICAgICAgbGV0IGRhdGFzZXROYW1lID0gZGF0YWRvY3VtZW50LmFib3V0LmRhdGFzZXRJRDsgICAvLy5kYXRhc2V0TmFtZTsgICAgICAgICAgICAgLy8gV2FzIHVzZSBcImRhdGFzZXROYW1lXCIgZmllbGQgaW4gZGF0YXNldCBkb2N1bWVudCwgYnV0IGlzIGNvbW1vbmx5IFwibnVsbFwiXG4gICAgICAgIHpwYXJhbXMuemRhdGEgPSBkYXRhc2V0TmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGRhdGFzZXROYW1lLnNsaWNlKDEpOyAvLyBNYWtlIHN1cmUgdG8gY2FwaXRhbGl6ZTtcbiAgICAgICAgbGV0IGNpdGUgPSBcIk5vIGNpdGF0aW9uIHByb3ZpZGVkXCI7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YWRvY3VtZW50LmFib3V0LmNpdGF0aW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgY2l0ZSA9IGRhdGFkb2N1bWVudC5hYm91dC5jaXRhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICAvL2NvbnNvbGUubG9nKGNpdGUpO1xuICAgICAgICAvL2xldCBuZXdjaXRlID0gY2l0ZS5tYXRjaCgve1xccypbXFx3XFwuXStcXHMqfS9nKS5tYXAoZnVuY3Rpb24oeCkgeyByZXR1cm4geC5tYXRjaCgvW1xcd1xcLl0rLylbMF07IH0pO1xuICAgICAgICAvL2NvbnNvbGUubG9nKG5ld2NpdGUpO1xuICAgICAgICAvKlxuICAgICAgICAvLyBjbGVhbiBjaXRhdGlvblxuICAgICAgICB6cGFyYW1zLnpkYXRhY2l0ZSA9IGNpdGVcbiAgICAgICAgLnJlcGxhY2UoL1xcJi9nLCBcImFuZFwiKVxuICAgICAgICAucmVwbGFjZSgvXFw7L2csIFwiLFwiKVxuICAgICAgICAucmVwbGFjZSgvXFwlL2csIFwiLVwiKTtcbiAgICAgICAgLy8gZmlsbCBpbiBjaXRhdGlvbiBpbiBoZWFkZXJcbiAgICAgICAgZWxlbSgnI2NpdGUgZGl2LnBhbmVsLWJvZHknKS50ZXh0Tm9kZSA9IHpwYXJhbXMuemRhdGFjaXRlO1xuICAgICAgICAqL1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm90ZTogcHJlc2VudGx5IHhtbCBpcyBubyBsb25nZXIgYmVpbmcgcmVhZCBmcm9tIERhdGF2ZXJzZSBtZXRhZGF0YSBhbnl3aGVyZVxuICAgICAgICBsZXQgdGVtcCA9IHhtbC5kb2N1bWVudEVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJmaWxlTmFtZVwiKTtcbiAgICAgICAgenBhcmFtcy56ZGF0YSA9IHRlbXBbMF0uY2hpbGROb2Rlc1swXS5ub2RlVmFsdWU7XG4gICAgICAgIGxldCBjaXRlID0geG1sLmRvY3VtZW50RWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImJpYmxDaXRcIik7XG4gICAgICAgIC8vIGNsZWFuIGNpdGF0aW9uIHNvIFBPU1QgaXMgdmFsaWQganNvblxuICAgICAgICB6cGFyYW1zLnpkYXRhY2l0ZSA9IGNpdGVbMF0uY2hpbGROb2Rlc1swXS5ub2RlVmFsdWVcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXCYvZywgXCJhbmRcIilcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXDsvZywgXCIsXCIpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFwlL2csIFwiLVwiKTtcbiAgICAgICAgLy8gZmlsbCBpbiBjaXRhdGlvbiBpbiBoZWFkZXJcbiAgICAgICAgYnlJZCgnY2l0ZScpLmNoaWxkcmVuWzBdLnRleHRDb250ZW50ID0genBhcmFtcy56ZGF0YWNpdGU7XG4gICAgfVxuICAgIC8vIGRyb3AgZmlsZSBleHRlbnNpb25cbiAgICBsZXQgZGF0YW5hbWUgPSBJU19EM01fRE9NQUlOID8genBhcmFtcy56ZGF0YSA6IHpwYXJhbXMuemRhdGEucmVwbGFjZSgvXFwuKC4qKS8sICcnKTtcbiAgICBkMy5zZWxlY3QoXCIjZGF0YU5hbWVcIikuaHRtbChkYXRhbmFtZSk7XG4gICAgLy8gcHV0IGRhdGFzZXQgbmFtZSwgZnJvbSBtZXRhLWRhdGEsIGludG8gcGFnZSB0aXRsZVxuICAgIGQzLnNlbGVjdChcInRpdGxlXCIpLmh0bWwoXCJUd29SYXZlbnMgXCIgKyBkYXRhbmFtZSk7XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3BlZWtIZWFkZXInLCBcIlR3b1JhdmVucyBcIiArIGRhdGFuYW1lKTtcblxuICAgIC8vIGlmIHN3YW5kaXZlLCB3ZSBoYXZlIHRvIHNldCB2YWx1ZUtleSBoZXJlIHNvIHRoYXQgbGVmdCBwYW5lbCBjYW4gcG9wdWxhdGUuXG4gICAgaWYgKHN3YW5kaXZlKSB7XG4gICAgICAgIGFsZXJ0KCdFeGNlcHRpb25hbCBkYXRhIGRldGVjdGVkLiAgUGxlYXNlIGNoZWNrIHRoZSBsb2dzIGZvciBcIkQzTSBXQVJOSU5HXCInKTtcbiAgICAgICAgLy8gICAgbGV0IG15ZGF0YVJlcyA9IGRhdGFkb2N1bWVudC5kYXRhUmVzb3VyY2VzO1xuICAgICAgICAvLyAgZm9yIChsZXQgaSA9IDA7IGkgPCBteWRhdGFSZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gICAgICAgdmFsdWVLZXkucHVzaChteWRhdGFSZXNbaV0ucmVzRm9ybWF0WzBdKTtcbiAgICAgICAgLy8gIH1cbiAgICAgICAgLy8gZW5kIHNlc3Npb24gaWYgbmVpdGhlciB0cmFpbkRhdGEgbm9yIHRyYWluVGFyZ2V0cz9cbiAgICAgICAgLy8gdmFsdWVLZXkubGVuZ3RoID09PSAwICYmIGFsZXJ0KFwibm8gdHJhaW5EYXRhIG9yIHRyYWluVGFyZ2VzdCBpbiBkYXRhIGRlc2NyaXB0aW9uIGZpbGUuIHZhbHVlS2V5IGxlbmd0aCBpcyAwXCIpO1xuICAgICAgICAvLyBwZXJoYXBzIGFsbG93IHVzZXJzIHRvIHVubG9jayBhbmQgc2VsZWN0IHRoaW5ncz9cbiAgICAgICAgYnlJZCgnYnRuTG9jaycpLmNsYXNzTGlzdC5hZGQoJ25vc2hvdycpO1xuICAgICAgICBieUlkKCdidG5Gb3JjZScpLmNsYXNzTGlzdC5hZGQoJ25vc2hvdycpO1xuICAgICAgICBieUlkKCdidG5FcmFzZXInKS5jbGFzc0xpc3QuYWRkKCdub3Nob3cnKTtcbiAgICAgICAgYnlJZCgnYnRuU3Vic2V0JykuY2xhc3NMaXN0LmFkZCgnbm9zaG93Jyk7XG4gICAgICAgIGJ5SWQoJ21haW4nKS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnZ3JleSc7XG4gICAgICAgIGJ5SWQoJ3doaXRlc3BhY2UnKS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnZ3JleSc7XG4gICAgfVxuICAgIGNvbnNvbGUubG9nKFwiZGF0YSBzY2hlbWEgZGF0YTogXCIsIGRhdGFkb2N1bWVudCk7XG5cbiAgICAvLyA1LiBSZWFkIGluIHplbGlnIG1vZGVscyAobm90IGZvciBkM20pXG4gICAgLy8gNi4gUmVhZCBpbiB6ZWxpZ2Nob2ljZSBtb2RlbHMgKG5vdCBmb3IgZDNtKVxuICAgIGlmICghSVNfRDNNX0RPTUFJTil7XG4gICAgICBmb3IgKGxldCBmaWVsZCBvZiBbJ3plbGlnNW1vZGVscycsICd6ZWxpZzVjaG9pY2Vtb2RlbHMnXSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJlcyA9IGF3YWl0IG0ucmVxdWVzdChgZGF0YS8ke2ZpZWxkfS5qc29uYCk7XG4gICAgICAgICAgICAgIGNkYihmaWVsZCArICcganNvbjogJywgcmVzKTtcbiAgICAgICAgICAgICAgcmVzW2ZpZWxkXVxuICAgICAgICAgICAgICAgICAgLmZpbHRlcihrZXkgPT4gcmVzW2ZpZWxkXS5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgICAgICAgLmZvckVhY2goa2V5ID0+IG1vZHNba2V5Lm5hbWVbMF1dID0ga2V5LmRlc2NyaXB0aW9uWzBdKTtcbiAgICAgICAgICB9IGNhdGNoKF8pIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJjYW4ndCBsb2FkIFwiICsgZmllbGQpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gNy4gU3RhcnQgdGhlIHVzZXIgc2Vzc2lvblxuICAgIC8vIHJwYyBTdGFydFNlc3Npb24oU2Vzc2lvblJlcXVlc3QpIHJldHVybnMgKFNlc3Npb25SZXNwb25zZSkge31cbiAgICByZXMgPSBhd2FpdCBtYWtlUmVxdWVzdChEM01fU1ZDX1VSTCArICcvc3RhcnRzZXNzaW9uJywge3VzZXJfYWdlbnQ6ICdzb21lIGFnZW50JywgdmVyc2lvbjogJ3NvbWUgdmVyc2lvbid9KTtcbiAgICBpZiAocmVzKSB7XG4gICAgICBpZiAocmVzLnJlc3BvbnNlSW5mby5zdGF0dXMuY29kZSAhPSBcIk9LXCIpe1xuICAgICAgICBjb25zdCB1c2VyX2Vycl9tc2cgPSBcIkZhaWxlZCB0byBTdGFydFNlc3Npb24gd2l0aCBUQTIhIHN0YXR1cyBjb2RlOiBcIiArIHJlcy5yZXNwb25zZUluZm8uc3RhdHVzLmNvZGU7XG4gICAgICAgIHNldE1vZGFsKHVzZXJfZXJyX21zZywgXCJFcnJvciBDb25uZWN0aW5nIHRvIFRBMlwiLCB0cnVlLCBcIlJlc2V0XCIsIGZhbHNlLCBsb2NhdGlvbi5yZWxvYWQpO1xuICAgICAgICAgIC8vICBlbmRfdGEzX3NlYXJjaChmYWxzZSwgdXNlcl9lcnJfbXNnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHpwYXJhbXMuenNlc3Npb25pZCA9IHJlcy5jb250ZXh0LnNlc3Npb25JZDtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbiAgICAvLyBob3BzY290Y2ggdHV0b3JpYWxcbiAgICBpZiAodHV0b3JpYWxfbW9kZSkge1xuICAgICAgICBjb25zb2xlLmxvZygnU3RhcnRpbmcgSG9wc2NvdGNoIFRvdXInKTtcbiAgICAgICAgaG9wc2NvdGNoLnN0YXJ0VG91cihteXRvdXIpO1xuICAgIH1cblxuICAgIC8vIDguIHJlYWQgcHJlcHJvY2VzcyBkYXRhIG9yIChpZiBuZWNlc3NhcnkpIHJ1biBwcmVwcm9jZXNzXG4gICAgLy8gTk9URTogcHJlcHJvY2Vzcy5qc29uIGlzIG5vdyBndWFyYW50ZWVkIHRvIGV4aXN0Li4uXG4gICAgbGV0IHJlYWQgPSByZXMgPT4ge1xuICAgICAgICBwcml2ID0gcmVzLmRhdGFzZXQucHJpdmF0ZSB8fCBwcml2O1xuICAgICAgICBPYmplY3Qua2V5cyhyZXMudmFyaWFibGVzKS5mb3JFYWNoKGsgPT4gcHJlcHJvY2Vzc1trXSA9IHJlcy52YXJpYWJsZXNba10pO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS5sb2coJ2F0dGVtcHQgdG8gcmVhZCBwcmVwcm9jZXNzIGZpbGUgKHdoaWNoIG1heSBub3QgZXhpc3QpOiAnICsgcFVSTCk7XG4gICAgICAgIHJlcyA9IHJlYWQoYXdhaXQgbS5yZXF1ZXN0KHBVUkwpKTtcbiAgICB9IGNhdGNoKF8pIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJPaywgcHJlcHJvY2VzcyBub3QgZm91bmQsIHRyeSB0byBSVU4gVEhFIFBSRVBST0NFU1NBUFBcIik7XG4gICAgICAgIGxldCB1cmwgPSBST09LX1NWQ19VUkwgKyAncHJlcHJvY2Vzc2FwcCc7XG4gICAgICAgIHZhciBqc29uX2lucHV0O1xuICAgICAgICBpZiAoSVNfRDNNX0RPTUFJTil7XG4gICAgICAgICAgLy8gRm9yIEQzTSBpbnB1dHMsIGNoYW5nZSB0aGUgcHJlcHJvY2VzcyBpbnB1dCBkYXRhXG4gICAgICAgICAgLy9cbiAgICAgICAgICBqc29uX2lucHV0ID0ge2RhdGE6IGQzbURhdGEsIGRhdGFzdHViOiBkM21EYXRhTmFtZX07XG4gICAgICAgIH1lbHNle1xuICAgICAgICAganNvbl9pbnB1dCA9IHtkYXRhOiBkYXRhbG9jLCB0YXJnZXQ6IHRhcmdldGxvYywgZGF0YXN0dWI6IGRhdGFzdHVifTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUubG9nKCdqc29uX2lucHV0OiAnLCBqc29uX2lucHV0KTtcbiAgICAgICAgY29uc29sZS5sb2coJ3VybDogJywgdXJsKTtcbiAgICAgICAgbGV0IGRhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlcyA9IHJlYWQoYXdhaXQgbS5yZXF1ZXN0KHttZXRob2Q6ICdQT1NUJywgdXJsOiB1cmwsIGRhdGE6IGpzb25faW5wdXR9KSk7XG4gICAgICAgIH0gY2F0Y2goXykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ3ByZXByb2Nlc3MgZmFpbGVkJyk7XG4gICAgICAgICAgICBhbGVydCgncHJlcHJvY2VzcyBmYWlsZWQuIGVuZGluZyB1c2VyIHNlc3Npb24uJyk7XG4gICAgICAgICAgICBlbmRzZXNzaW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZyhcImlzIHRoaXMgcHJlcHJvY2Vzcz9cIilcbiAgICBjb25zb2xlLmxvZyhyZXMpO1xuICAgIGNvbnNvbGUubG9nKHByZXByb2Nlc3MpO1xuXG4gICAgLy8gOS4gQnVpbGQgYWxsTm9kZXNbXSB1c2luZyBwcmVwcm9jZXNzZWQgaW5mb3JtYXRpb25cbiAgICBsZXQgdmFycyA9IE9iamVjdC5rZXlzKHByZXByb2Nlc3MpO1xuICAgIC8vIHRlbXBvcmFyeSB2YWx1ZXMgZm9yIGhvbGQgdGhhdCBjb3JyZXNwb25kIHRvIGhpc3RvZ3JhbSBiaW5zXG4gICAgaG9sZCA9IFsuNiwgLjIsIC45LCAuOCwgLjEsIC4zLCAuNF07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIHZhbHVlS2V5W2ldID0gdmFyc1tpXS5hdHRyaWJ1dGVzLm5hbWUubm9kZVZhbHVlO1xuICAgICAgICAvLyBsYWJsQXJyYXlbaV0gPSB2YXJzWE1MW2ldLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwibGFibFwiKS5sZW5ndGggPT0gMCA/XG4gICAgICAgIC8vIFwibm8gbGFiZWxcIiA6XG4gICAgICAgIC8vIHZhcnNYTUxbaV0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJsYWJsXCIpWzBdLmNoaWxkTm9kZXNbMF0ubm9kZVZhbHVlO1xuICAgICAgICAvLyBsZXQgZGF0YXNldGNvdW50ID0gZDMubGF5b3V0Lmhpc3RvZ3JhbSgpXG4gICAgICAgIC8vICAgICAuYmlucyhiYXJudW1iZXIpLmZyZXF1ZW5jeShmYWxzZSlcbiAgICAgICAgLy8gICAgIChbMCwgMCwgMCwgMCwgMF0pO1xuICAgICAgICB2YWx1ZUtleVtpXSA9IHZhcnNbaV07XG4gICAgICAgIGxhYmxBcnJheVtpXSA9IFwibm8gbGFiZWxcIjtcbiAgICAgICAgLy8gY29udGFpbnMgYWxsIHRoZSBwcmVwcm9jZXNzZWQgZGF0YSB3ZSBoYXZlIGZvciB0aGUgdmFyaWFibGUsIGFzIHdlbGwgYXMgVUkgZGF0YSBwZXJ0aW5lbnQgdG8gdGhhdCB2YXJpYWJsZSxcbiAgICAgICAgLy8gc3VjaCBhcyBzZXR4IHZhbHVlcyAoaWYgdGhlIHVzZXIgaGFzIHNlbGVjdGVkIHRoZW0pIGFuZCBwZWJibGUgY29vcmRpbmF0ZXNcbiAgICAgICAgbGV0IG9iaiA9IHtcbiAgICAgICAgICAgIGlkOiBpLFxuICAgICAgICAgICAgcmVmbGV4aXZlOiBmYWxzZSxcbiAgICAgICAgICAgIG5hbWU6IHZhbHVlS2V5W2ldLFxuICAgICAgICAgICAgbGFibDogbGFibEFycmF5W2ldLFxuICAgICAgICAgICAgZGF0YTogWzUsIDE1LCAyMCwgMCwgNSwgMTUsIDIwXSxcbiAgICAgICAgICAgIGNvdW50OiBob2xkLFxuICAgICAgICAgICAgbm9kZUNvbDogY29sb3JzKGkpLFxuICAgICAgICAgICAgYmFzZUNvbDogY29sb3JzKGkpLFxuICAgICAgICAgICAgc3Ryb2tlQ29sb3I6IHNlbFZhckNvbG9yLFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IFwiMVwiLFxuICAgICAgICAgICAgc3Vic2V0cGxvdDogZmFsc2UsXG4gICAgICAgICAgICBzdWJzZXRyYW5nZTogW1wiXCIsIFwiXCJdLFxuICAgICAgICAgICAgc2V0eHBsb3Q6IGZhbHNlLFxuICAgICAgICAgICAgc2V0eHZhbHM6IFtcIlwiLCBcIlwiXSxcbiAgICAgICAgICAgIGdyYXlvdXQ6IGZhbHNlLFxuICAgICAgICAgICAgZ3JvdXAxOiBmYWxzZSxcbiAgICAgICAgICAgIGdyb3VwMjogZmFsc2UsXG4gICAgICAgICAgICBmb3JlZnJvbnQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIGpRdWVyeS5leHRlbmQodHJ1ZSwgb2JqLCBwcmVwcm9jZXNzW3ZhbHVlS2V5W2ldXSk7XG4gICAgICAgIGFsbE5vZGVzLnB1c2gob2JqKTtcbiAgICB9XG5cbiAgICAvLyAxMC4gQWRkIGRhdGFkb2N1bWVudCBpbmZvcm1hdGlvbiB0byBhbGxOb2RlcyAod2hlbiBpbiBJU19EM01fRE9NQUlOKVxuICAgIGlmKCFzd2FuZGl2ZSkge1xuICAgICAgICBsZXQgZGF0YXZhcnMgPSBkYXRhZG9jdW1lbnRfY29sdW1ucztcbiAgICAgICAgZGF0YXZhcnMuZm9yRWFjaCgodiwgaSkgPT4ge1xuICAgICAgICAgICAgbGV0IG15aSA9IGZpbmROb2RlSW5kZXgodi5jb2xOYW1lKTtcbiAgICAgICAgICAgIGFsbE5vZGVzW215aV0gPSBPYmplY3QuYXNzaWduKGFsbE5vZGVzW215aV0sIHtkM21EZXNjcmlwdGlvbjogdn0pO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc29sZS5sb2coYWxsTm9kZXMpO1xuICAgIH1cblxuICAgIC8vIDEwYi4gQ2FsbCBwcm9ibGVtIGRpc2NvdmVyeVxuICAgIC8vIFJlcXVpcmVzIHRoYXQgYHJlc2AgYnVpbHQgaW4gOC4gYWJvdmUgc3RpbGwgZXhpc3RzLiAgU2hvdWxkIG1ha2UgdGhpcyBiZXR0ZXIuXG4gICAgaWYoIXN3YW5kaXZlKSB7XG4gICAgICAgIGRpc2NvID0gZGlzY292ZXJ5KHJlcyk7XG5cbiAgICAgICAgLy8gS2ljayBvZmYgZGlzY292ZXJ5IGJ1dHRvbiBhcyBncmVlbiBmb3IgdXNlciBndWlkYW5jZVxuICAgICAgICBieUlkKFwiYnRuRGlzY292ZXJ5XCIpLmNsYXNzTGlzdC5yZW1vdmUoXCJidG4tZGVmYXVsdFwiKTtcbiAgICAgICAgYnlJZChcImJ0bkRpc2NvdmVyeVwiKS5jbGFzc0xpc3QuYWRkKFwiYnRuLXN1Y2Nlc3NcIik7IC8vIFdvdWxkIGJlIGJldHRlciB0byBhdHRhY2ggdGhpcyBhcyBhIGNsYXNzIGF0IGNyZWF0aW9uLCBidXQgZG9uJ3Qgc2VlIHdoZXJlIGl0IGlzIGNyZWF0ZWRcblxuICAgICAgICBjb25zb2xlLmxvZyhkaXNjbyk7XG4gICAgfVxuXG4gICAgLy8gMTEuIENhbGwgbGF5b3V0KCkgYW5kIHN0YXJ0IHVwXG4gICAgbGF5b3V0KGZhbHNlLCB0cnVlKTtcbiAgICBJU19EM01fRE9NQUlOID8gelBvcCgpIDogZGF0YURvd25sb2FkKCk7XG59XG5cbi8qKlxuICAgY2FsbGVkIG9uIGFwcCBzdGFydFxuICAgQHBhcmFtIHtzdHJpbmd9IGZpbGVpZFxuICAgQHBhcmFtIHtzdHJpbmd9IGhvc3RuYW1lXG4gICBAcGFyYW0ge3N0cmluZ30gZGRpdXJsXG4gICBAcGFyYW0ge3N0cmluZ30gZGF0YXVybFxuICAgQHBhcmFtIHtzdHJpbmd9IGFwaWtleVxuKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWluKGZpbGVpZCwgaG9zdG5hbWUsIGRkaXVybCwgZGF0YXVybCwgYXBpa2V5KSB7XG4gICAgaWYgKFBST0RVQ1RJT04gJiYgZmlsZWlkID09PSAnJykge1xuICAgICAgICBsZXQgbXNnID0gJ0Vycm9yOiBObyBmaWxlaWQgaGFzIGJlZW4gcHJvdmlkZWQuJztcbiAgICAgICAgYWxlcnQobXNnKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxuXG4gICAgbGV0IGRhdGF2ZXJzZXVybCA9IGhvc3RuYW1lID8gJ2h0dHBzOi8vJyArIGhvc3RuYW1lIDpcbiAgICAgICAgUFJPRFVDVElPTiA/IERBVEFWRVJTRV9VUkwgOlxuICAgICAgICAnaHR0cDovL2xvY2FsaG9zdDo4MDgwJztcbiAgICAvLyBpZiBmaWxlIGlkIHN1cHBsaWVkLCBhc3N1bWUgd2UgYXJlIGRlYWxpbmcgd2l0aCBkYXRhdmVyc2UgYW5kIGNvb2sgYSBzdGFuZGFyZCBkYXRhdmVyc2UgZGF0YSBhY2Nlc3MgdXJsXG4gICAgLy8gd2l0aCB0aGUgZmlsZWlkIHN1cHBsaWVkIGFuZCB0aGUgaG9zdG5hbWUgd2UgaGF2ZSBzdXBwbGllZCBvciBjb25maWd1cmVkXG4gICAgZGF0YXVybCA9IGZpbGVpZCAmJiAhZGF0YXVybCA/IGAke2RhdGF2ZXJzZXVybH0vYXBpL2FjY2Vzcy9kYXRhZmlsZS8ke2ZpbGVpZH0/a2V5PSR7YXBpa2V5fWAgOiBkYXRhdXJsO1xuICAgIGNkYignLS1kYXRhdXJsOiAnICsgZGF0YXVybCk7XG4gICAgY2RiKCctLWRhdGF2ZXJzZXVybDogJyArIGRhdGF2ZXJzZXVybCk7XG5cbiAgICBsZXQgdGVtcFdpZHRoID0gZDMuc2VsZWN0KCcjbWFpbi5sZWZ0Jykuc3R5bGUoJ3dpZHRoJyk7XG4gICAgd2lkdGggPSB0ZW1wV2lkdGguc3Vic3RyaW5nKDAsIHRlbXBXaWR0aC5sZW5ndGggLSAyKTtcbiAgICBoZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLSAxMjA7IC8vIGhhcmQgY29kZSBoZWFkZXIsIGZvb3RlciwgYW5kIGJvdHRvbSBtYXJnaW5cblxuICAgIGVzdGltYXRlTGFkZGEgPSBMYWRkYS5jcmVhdGUoYnlJZChcImJ0bkVzdGltYXRlXCIpKTtcbiAgICBkaXNjb3ZlcnlMYWRkYSA9IExhZGRhLmNyZWF0ZShieUlkKFwiYnRuU3VibWl0RGlzY1wiKSk7XG4gICAgc3ZnID0gZDMuc2VsZWN0KFwiI3doaXRlc3BhY2VcIik7XG5cbiAgICAvLyBpbmRpY2F0b3JzIGZvciBzaG93aW5nIG1lbWJlcnNoaXAgYWJvdmUgYXJjc1xuICAgIC8vIGxldCBpbmRpY2F0b3IgPSAoZGVncmVlKSA9PiBkMy5zdmcuY2lyY2xlKClcbiAgICAvLyAgICAgLmN4KCBSQURJVVMgKS8vKFJBRElVUyszNSkgKiBNYXRoLnNpbihkZWdyZWUpKVxuICAgIC8vICAgICAuY3koIFJBRElVUyApLy8oUkFESVVTKzM1KSAqIE1hdGguY29zKGRlZ3JlZSkpXG4gICAgLy8gICAgIC5yKDMpO1xuICAgIC8vIGluZDEgPSBpbmRpY2F0b3IoMSk7XG4gICAgLy8gaW5kMiA9IGluZGljYXRvcigxLjIpO1xuXG4gICAgLy8gZnJvbSAuY3N2XG4gICAgbGV0IFtob2xkLCBsYWJsQXJyYXldID0gW1tdLCBbXV07XG5cbiAgICAvLyBhc3N1bWUgbG9jYXRpb25zIGFyZSBjb25zaXN0ZW50IGJhc2VkIG9uIGQzbSBkaXJlY3Rvcnkgc3RydWN0dXJlXG4gICAgbGV0IGQzbVJvb3RQYXRoID0gJyc7XG4gICAgbGV0IGQzbURhdGFOYW1lID0gJyc7XG4gICAgbGV0IGQzbURhdGEgPSBudWxsO1xuICAgIGxldCBkM21QcmVwcm9jZXNzID0gJyc7XG4gICAgbGV0IGQzbVBTID0gJyc7XG4gICAgbGV0IGQzbURTID0gJyc7XG5cbiAgICAvLyBkZWZhdWx0IHRvIEZlYXJvbiBMYWl0aW5cbiAgICBsZXQgZGF0YSA9ICdkYXRhLycgKyAoZmFsc2UgPyAnUFVNUzVzbWFsbCcgOiAnZmVhcm9uTGFpdGluJyk7XG4gICAgbGV0IG1ldGFkYXRhdXJsID0gZGRpdXJsIHx8IChmaWxlaWQgPyBgJHtkYXRhdmVyc2V1cmx9L2FwaS9tZXRhL2RhdGFmaWxlLyR7ZmlsZWlkfWAgOiBkYXRhICsgJy54bWwnKTtcbiAgICAvLyByZWFkIHByZS1wcm9jZXNzZWQgbWV0YWRhdGEgYW5kIGRhdGFcbiAgICBsZXQgcFVSTCA9IGRhdGF1cmwgPyBgJHtkYXRhdXJsfSZmb3JtYXQ9cHJlcGAgOiBkYXRhICsgJy5qc29uJztcblxuICAgIGlmIChJU19EM01fRE9NQUlOKSB7XG4gICAgICAgIHBVUkwgPSBkM21QcmVwcm9jZXNzO1xuICAgIH0gZWxzZSBpZiAoIVBST0RVQ1RJT04pIHtcbiAgICAgICAgenBhcmFtcy56ZGF0YXVybCA9ICdkYXRhL2ZlYXJvbkxhaXRpbi50c3YnO1xuICAgIH1cbiAgICBsb2FkKGhvbGQsIGxhYmxBcnJheSwgZDNtUm9vdFBhdGgsIGQzbURhdGFOYW1lLCBkM21QcmVwcm9jZXNzLCBkM21EYXRhLCBkM21QUywgZDNtRFMsIHBVUkwpO1xufVxuXG5sZXQgJGZpbGwgPSAob2JqLCBvcCwgZDEsIGQyKSA9PiBkMy5zZWxlY3Qob2JqKS50cmFuc2l0aW9uKClcbiAgICAuYXR0cignZmlsbC1vcGFjaXR5Jywgb3ApLmF0dHIoJ2Rpc3BsYXknLCBvcCA/ICcnIDogJ25vbmUnKVxuICAgIC5kZWxheShkMSlcbiAgICAuZHVyYXRpb24oZDIpO1xubGV0IGZpbGwgPSAoZCwgaWQsIG9wLCBkMSwgZDIpID0+ICRmaWxsKCcjJyArIGlkICsgZC5pZCwgb3AsIGQxLCBkMik7XG5sZXQgZmlsbFRoaXMgPSAoc2VsZiwgb3AsIGQxLCBkMikgPT4gJGZpbGwoc2VsZiwgb3AsIGQxLCBkMik7XG5cbi8qKlxuICAgZGVsZXRlcyB0aGUgaXRlbSBhdCBpbmRleCBmcm9tIGFycmF5LlxuICAgaWYgb2JqZWN0IGlzIHByb3ZpZGVkLCBkZWxldGVzIGZpcnN0IGluc3RhbmNlIG9mIG9iamVjdCBmcm9tIGFycmF5LlxuICAgQHBhcmFtIHtPYmplY3RbXX0gYXJyIC0gYXJyYXlcbiAgIEBwYXJhbSB7bnVtYmVyfSBpZHggLSBpbmRleFxuICAgQHBhcmFtIHtPYmplY3R9IFtvYmpdIC0gb2JqZWN0XG4qL1xuZnVuY3Rpb24gZGVsKGFyciwgaWR4LCBvYmopIHtcbiAgICBpZHggPSBvYmogPyBhcnIuaW5kZXhPZihvYmopIDogaWR4O1xuICAgIGlkeCA+IC0xICYmIGFyci5zcGxpY2UoaWR4LCAxKTtcbn1cblxuLyoqIG5lZWRzIGRvYyAqL1xuZnVuY3Rpb24genBhcmFtc1Jlc2V0KHRleHQpIHtcbiAgICAnemR2IHpjcm9zcyB6dGltZSB6bm9tJy5zcGxpdCgnICcpLmZvckVhY2goeCA9PiBkZWwoenBhcmFtc1t4XSwgLTEsIHRleHQpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldHVwX3N2ZyhzdmcpIHtcbiAgICBzdmcuYXBwZW5kKFwic3ZnOmRlZnNcIikuYXBwZW5kKFwic3ZnOm1hcmtlclwiKVxuICAgICAgICAuYXR0cihcImlkXCIsIFwiZ3JvdXAxLWFycm93XCIpXG4gICAgICAgIC5hdHRyKCd2aWV3Qm94JywgJzAgLTUgMTUgMTUnKVxuICAgICAgICAuYXR0cihcInJlZlhcIiwgMi41KVxuICAgICAgICAuYXR0cihcInJlZllcIiwgMClcbiAgICAgICAgLmF0dHIoXCJtYXJrZXJXaWR0aFwiLCAzKVxuICAgICAgICAuYXR0cihcIm1hcmtlckhlaWdodFwiLCAzKVxuICAgICAgICAuYXR0cihcIm9yaWVudFwiLCBcImF1dG9cIilcbiAgICAgICAgLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgLmF0dHIoJ2QnLCAnTTAsLTVMMTAsMEwwLDUnKVxuICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGdyMUNvbG9yKTtcbiAgICBzdmcuYXBwZW5kKFwic3ZnOmRlZnNcIikuYXBwZW5kKFwic3ZnOm1hcmtlclwiKVxuICAgICAgICAuYXR0cihcImlkXCIsIFwiZ3JvdXAyLWFycm93XCIpXG4gICAgICAgIC5hdHRyKCd2aWV3Qm94JywgJzAgLTUgMTUgMTUnKVxuICAgICAgICAuYXR0cihcInJlZlhcIiwgMi41KVxuICAgICAgICAuYXR0cihcInJlZllcIiwgMClcbiAgICAgICAgLmF0dHIoXCJtYXJrZXJXaWR0aFwiLCAzKVxuICAgICAgICAuYXR0cihcIm1hcmtlckhlaWdodFwiLCAzKVxuICAgICAgICAuYXR0cihcIm9yaWVudFwiLCBcImF1dG9cIilcbiAgICAgICAgLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgLmF0dHIoJ2QnLCAnTTAsLTVMMTAsMEwwLDUnKVxuICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGdyMkNvbG9yKTtcbiAgICAvLyBkZWZpbmUgYXJyb3cgbWFya2VycyBmb3IgZ3JhcGggbGlua3NcbiAgICBzdmcuYXBwZW5kKCdzdmc6ZGVmcycpLmFwcGVuZCgnc3ZnOm1hcmtlcicpXG4gICAgICAgIC5hdHRyKCdpZCcsICdlbmQtYXJyb3cnKVxuICAgICAgICAuYXR0cigndmlld0JveCcsICcwIC01IDEwIDEwJylcbiAgICAgICAgLmF0dHIoJ3JlZlgnLCA2KVxuICAgICAgICAuYXR0cignbWFya2VyV2lkdGgnLCAzKVxuICAgICAgICAuYXR0cignbWFya2VySGVpZ2h0JywgMylcbiAgICAgICAgLmF0dHIoJ29yaWVudCcsICdhdXRvJylcbiAgICAgICAgLmFwcGVuZCgnc3ZnOnBhdGgnKVxuICAgICAgICAuYXR0cignZCcsICdNMCwtNUwxMCwwTDAsNScpXG4gICAgICAgIC5zdHlsZSgnZmlsbCcsICcjMDAwJyk7XG4gICAgc3ZnLmFwcGVuZCgnc3ZnOmRlZnMnKS5hcHBlbmQoJ3N2ZzptYXJrZXInKVxuICAgICAgICAuYXR0cignaWQnLCAnc3RhcnQtYXJyb3cnKVxuICAgICAgICAuYXR0cigndmlld0JveCcsICcwIC01IDEwIDEwJylcbiAgICAgICAgLmF0dHIoJ3JlZlgnLCA0KVxuICAgICAgICAuYXR0cignbWFya2VyV2lkdGgnLCAzKVxuICAgICAgICAuYXR0cignbWFya2VySGVpZ2h0JywgMylcbiAgICAgICAgLmF0dHIoJ29yaWVudCcsICdhdXRvJylcbiAgICAgICAgLmFwcGVuZCgnc3ZnOnBhdGgnKVxuICAgICAgICAuYXR0cignZCcsICdNMTAsLTVMMCwwTDEwLDUnKVxuICAgICAgICAuc3R5bGUoJ2ZpbGwnLCAnIzAwMCcpO1xuXG4gICAgdmFyIGxpbmUgPSBzdmcuYXBwZW5kKFwibGluZVwiKVxuICAgICAgICAuc3R5bGUoJ2ZpbGwnLCAnbm9uZScpXG4gICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgZ3IxQ29sb3IpXG4gICAgICAgIC5zdHlsZSgnc3Ryb2tlLXdpZHRoJywgNSlcbiAgICAgICAgLmF0dHIoXCJtYXJrZXItZW5kXCIsIFwidXJsKCNncm91cDEtYXJyb3cpXCIpO1xuICAgIHZhciBsaW5lMiA9IHN2Zy5hcHBlbmQoXCJsaW5lXCIpXG4gICAgICAgIC5zdHlsZSgnZmlsbCcsICdub25lJylcbiAgICAgICAgLnN0eWxlKCdzdHJva2UnLCBncjJDb2xvcilcbiAgICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLCA1KVxuICAgICAgICAuYXR0cihcIm1hcmtlci1lbmRcIiwgXCJ1cmwoI2dyb3VwMi1hcnJvdylcIik7XG4gICAgdmFyIHZpc2JhY2tncm91bmQgPSBzdmcuYXBwZW5kKFwic3ZnXCIpXG4gICAgICAgIC5hdHRyKFwid2lkdGhcIiwgd2lkdGgpXG4gICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGhlaWdodCk7XG4gICAgdmlzYmFja2dyb3VuZC5hcHBlbmQoXCJwYXRoXCIpIC8vIG5vdGUgbGluZXMsIGFyZSBiZWhpbmQgZ3JvdXAgaHVsbHMgb2Ygd2hpY2ggdGhlcmUgaXMgYSB3aGl0ZSBhbmQgY29sb3JlZCBzZW1pIHRyYW5zcGFyZW50IGxheWVyXG4gICAgICAgIC5hdHRyKFwiaWRcIiwgJ2dyMWJhY2tncm91bmQnKVxuICAgICAgICAuc3R5bGUoXCJmaWxsXCIsICcjZmZmZmZmJylcbiAgICAgICAgLnN0eWxlKFwic3Ryb2tlXCIsICcjZmZmZmZmJylcbiAgICAgICAgLnN0eWxlKFwic3Ryb2tlLXdpZHRoXCIsIDIuNSpSQURJVVMpXG4gICAgICAgIC5zdHlsZSgnc3Ryb2tlLWxpbmVqb2luJywncm91bmQnKVxuICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDEpO1xuICAgIHZhciB2aXMyYmFja2dyb3VuZCA9IHN2Zy5hcHBlbmQoXCJzdmdcIilcbiAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCB3aWR0aClcbiAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgaGVpZ2h0KTtcbiAgICB2aXMyYmFja2dyb3VuZC5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgIC5hdHRyKFwiaWRcIiwgJ2dyMWJhY2tncm91bmQnKVxuICAgICAgICAuc3R5bGUoXCJmaWxsXCIsICcjZmZmZmZmJylcbiAgICAgICAgLnN0eWxlKFwic3Ryb2tlXCIsICcjZmZmZmZmJylcbiAgICAgICAgLnN0eWxlKFwic3Ryb2tlLXdpZHRoXCIsIDIuNSpSQURJVVMpXG4gICAgICAgIC5zdHlsZSgnc3Ryb2tlLWxpbmVqb2luJywncm91bmQnKVxuICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIDEpO1xuICAgIHZhciB2aXMgPSBzdmcuYXBwZW5kKFwic3ZnXCIpXG4gICAgICAgIC5hdHRyKFwid2lkdGhcIiwgd2lkdGgpXG4gICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGhlaWdodCk7XG4gICAgdmlzLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgLmF0dHIoXCJpZFwiLCAnZ3IxaHVsbCcpXG4gICAgICAgIC5zdHlsZShcImZpbGxcIiwgZ3IxQ29sb3IpXG4gICAgICAgIC5zdHlsZShcInN0cm9rZVwiLCBncjFDb2xvcilcbiAgICAgICAgLnN0eWxlKFwic3Ryb2tlLXdpZHRoXCIsIDIuNSpSQURJVVMpXG4gICAgICAgIC5zdHlsZSgnc3Ryb2tlLWxpbmVqb2luJywncm91bmQnKTtcbiAgICB2YXIgdmlzMiA9IHN2Zy5hcHBlbmQoXCJzdmdcIilcbiAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCB3aWR0aClcbiAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgaGVpZ2h0KTtcbiAgICB2aXMyLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBncjJDb2xvcilcbiAgICAgICAgLnN0eWxlKFwic3Ryb2tlXCIsIGdyMkNvbG9yKVxuICAgICAgICAuc3R5bGUoXCJzdHJva2Utd2lkdGhcIiwgMi41KlJBRElVUylcbiAgICAgICAgLnN0eWxlKCdzdHJva2UtbGluZWpvaW4nLCdyb3VuZCcpO1xuICAgIC8vIGxpbmUgZGlzcGxheWVkIHdoZW4gZHJhZ2dpbmcgbmV3IG5vZGVzXG4gICAgdmFyIGRyYWdfbGluZSA9IHN2Zy5hcHBlbmQoJ3N2ZzpwYXRoJylcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2xpbmsgZHJhZ2xpbmUgaGlkZGVuJylcbiAgICAgICAgLmF0dHIoJ2QnLCAnTTAsMEwwLDAnKTtcbiAgICAvLyBoYW5kbGVzIHRvIGxpbmsgYW5kIG5vZGUgZWxlbWVudCBncm91cHNcbiAgICB2YXIgcGF0aCA9IHN2Zy5hcHBlbmQoJ3N2ZzpnJykuc2VsZWN0QWxsKCdwYXRoJyksXG4gICAgICAgIGNpcmNsZSA9IHN2Zy5hcHBlbmQoJ3N2ZzpnJykuc2VsZWN0QWxsKCdnJyk7XG4gICAgcmV0dXJuIFtsaW5lLCBsaW5lMiwgdmlzYmFja2dyb3VuZCwgdmlzMmJhY2tncm91bmQsIHZpcywgdmlzMiwgZHJhZ19saW5lLCBwYXRoLCBjaXJjbGVdO1xufVxuXG4vKiogbmVlZHMgZG9jICovXG5leHBvcnQgZnVuY3Rpb24gbGF5b3V0KHYsIHYyKSB7XG4gICAgdmFyIG15VmFsdWVzID0gW107XG4gICAgbm9kZXMgPSBbXTtcbiAgICBsaW5rcyA9IFtdO1xuXG4gICAgdmFyIFtsaW5lLCBsaW5lMiwgdmlzYmFja2dyb3VuZCwgdmlzMmJhY2tncm91bmQsIHZpcywgdmlzMiwgZHJhZ19saW5lLCBwYXRoLCBjaXJjbGVdID0gc2V0dXBfc3ZnKHN2Zyk7XG5cbiAgICBpZiAodiA9PSBsYXlvdXRBZGQgfHwgdiA9PSBsYXlvdXRNb3ZlKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgenBhcmFtcy56dmFycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIGlpID0gZmluZE5vZGVJbmRleCh6cGFyYW1zLnp2YXJzW2pdKTtcbiAgICAgICAgICAgIGlmIChhbGxOb2Rlc1tpaV0uZ3JheW91dClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIG5vZGVzLnB1c2goYWxsTm9kZXNbaWldKTtcbiAgICAgICAgICAgIHZhciBzZWxlY3RNZSA9IHpwYXJhbXMuenZhcnNbal0ucmVwbGFjZSgvXFxXL2csIFwiX1wiKTtcbiAgICAgICAgICAgIHNlbGVjdE1lID0gXCIjXCIuY29uY2F0KHNlbGVjdE1lKTtcbiAgICAgICAgICAgIGQzLnNlbGVjdChzZWxlY3RNZSkuc3R5bGUoJ2JhY2tncm91bmQtY29sb3InLCAoKSA9PiBoZXhUb1JnYmEobm9kZXNbal0uc3Ryb2tlQ29sb3IpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgenBhcmFtcy56ZWRnZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBteXNyYyA9IG5vZGVJbmRleCh6cGFyYW1zLnplZGdlc1tqXVswXSk7XG4gICAgICAgICAgICB2YXIgbXl0Z3QgPSBub2RlSW5kZXgoenBhcmFtcy56ZWRnZXNbal1bMV0pO1xuICAgICAgICAgICAgbGlua3MucHVzaCh7XG4gICAgICAgICAgICAgICAgc291cmNlOiBub2Rlc1tteXNyY10sXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBub2Rlc1tteXRndF0sXG4gICAgICAgICAgICAgICAgbGVmdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYoSVNfRDNNX0RPTUFJTikge1xuICAgICAgICAgICAgLy9ub2RlcyA9IFtmaW5kTm9kZShteXRhcmdldCldOyAgICAgICAgICAgICAgIC8vIE9ubHkgYWRkIGRlcGVuZGVudCB2YXJpYWJsZSBvbiBzdGFydHVwXG4gICAgICAgICAgICBub2RlcyA9IGFsbE5vZGVzLnNsaWNlKDEsYWxsTm9kZXMubGVuZ3RoKTsgICAgLy8gQWRkIGFsbCBidXQgZmlyc3QgdmFyaWFibGUgb24gc3RhcnR1cCAoYXNzdW1lcyAwIHBvc2l0aW9uIGlzIGQzbSBpbmRleCB2YXJpYWJsZSlcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbm9kZXMubGVuZ3RoOyBqKyspIHsgLy9wb3B1bGF0ZSB6dmFycyBhcnJheVxuICAgICAgICAgICAgICAgIGlmIChub2Rlc1tqXS5uYW1lICE9IG15dGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzW2pdLmdyb3VwMSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHpwYXJhbXMuemdyb3VwMS5wdXNoKG5vZGVzW2pdLm5hbWUpOyAgLy8gd3JpdGUgYWxsIG5hbWVzIChleGNlcHQgZDNtIGluZGV4IGFuZCB0aGUgZGVwZW5kZW50IHZhcmlhYmxlKSB0byB6Z3JvdXAxIGFycmF5XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoYWxsTm9kZXMubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgbm9kZXMgPSBbYWxsTm9kZXNbMF0sIGFsbE5vZGVzWzFdLCBhbGxOb2Rlc1syXV07XG4gICAgICAgICAgICBsaW5rcyA9IFt7XG4gICAgICAgICAgICAgICAgc291cmNlOiBub2Rlc1sxXSxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IG5vZGVzWzBdLFxuICAgICAgICAgICAgICAgIGxlZnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiB0cnVlXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgc291cmNlOiBub2Rlc1swXSxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IG5vZGVzWzJdLFxuICAgICAgICAgICAgICAgIGxlZnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiB0cnVlXG4gICAgICAgICAgICB9XTtcbiAgICAgICAgfSBlbHNlIGlmIChhbGxOb2Rlcy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIG5vZGVzID0gW2FsbE5vZGVzWzBdLCBhbGxOb2Rlc1sxXV07XG4gICAgICAgICAgICBsaW5rcyA9IFt7XG4gICAgICAgICAgICAgICAgc291cmNlOiBub2Rlc1sxXSxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IG5vZGVzWzBdLFxuICAgICAgICAgICAgICAgIGxlZnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiB0cnVlXG4gICAgICAgICAgICB9XTtcbiAgICAgICAgfSBlbHNlIGlmIChhbGxOb2Rlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIG5vZGVzID0gW2FsbE5vZGVzWzBdXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFsZXJ0KFwiVGhlcmUgYXJlIHplcm8gdmFyaWFibGVzIGluIHRoZSBtZXRhZGF0YS5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwYW5lbFBsb3RzKCk7IC8vIGFmdGVyIG5vZGVzIGlzIHBvcHVsYXRlZCwgYWRkIHN1YnNldCBhbmQgKGlmICFJU19EM01fRE9NQUlOKSBzZXR4IHBhbmVsc1xuXG4gICAgdmFyIGZvcmNlID0gZDMubGF5b3V0LmZvcmNlKClcbiAgICAgICAgLm5vZGVzKG5vZGVzKVxuICAgICAgICAubGlua3MobGlua3MpXG4gICAgICAgIC5zaXplKFt3aWR0aCwgaGVpZ2h0XSlcbiAgICAgICAgLmxpbmtEaXN0YW5jZSgxNTApXG4gICAgICAgIC5jaGFyZ2UoLTgwMClcbiAgICAgICAgLm9uKCd0aWNrJywgdGljayk7XG5cbiAgICAvLyBtb3VzZSBldmVudCB2YXJzXG4gICAgdmFyIHNlbGVjdGVkX25vZGUgPSBudWxsLFxuICAgICAgICBzZWxlY3RlZF9saW5rID0gbnVsbCxcbiAgICAgICAgbW91c2Vkb3duX2xpbmsgPSBudWxsLFxuICAgICAgICBtb3VzZWRvd25fbm9kZSA9IG51bGwsXG4gICAgICAgIG1vdXNldXBfbm9kZSA9IG51bGw7XG5cbiAgICBmdW5jdGlvbiByZXNldE1vdXNlVmFycygpIHtcbiAgICAgICAgbW91c2Vkb3duX25vZGUgPSBudWxsO1xuICAgICAgICBtb3VzZXVwX25vZGUgPSBudWxsO1xuICAgICAgICBtb3VzZWRvd25fbGluayA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIGZvcmNlIGxheW91dCAoY2FsbGVkIGF1dG9tYXRpY2FsbHkgZWFjaCBpdGVyYXRpb24pXG4gICAgZnVuY3Rpb24gdGljaygpIHtcbiAgICAgICAgZnVuY3Rpb24gZmluZGNvb3JkcyhmaW5kbmFtZXMsYWxsbmFtZXMsY29vcmRzLGxlbmd0aGVuKXtcbiAgICAgICAgICAgIHZhciBmY29vcmRzID0gbmV3IEFycmF5KGZpbmRuYW1lcy5sZW5ndGgpOyAgIC8vIGZvdW5kIGNvb3JkaW5hdGVzXG4gICAgICAgICAgICB2YXIgYWRkbG9jYXRpb24gPSAwO1xuICAgICAgICAgICAgaWYoZmluZG5hbWVzLmxlbmd0aD4wKXtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGZpbmRuYW1lcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBhZGRsb2NhdGlvbiA9IGFsbG5hbWVzLmluZGV4T2YoZmluZG5hbWVzW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgZmNvb3Jkc1tqXSA9IGNvb3Jkc1thZGRsb2NhdGlvbl07XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmKGxlbmd0aGVuKXtcbiAgICAgICAgICAgICAgICAvLyBkMy5nZW9tLmh1bGwgcmV0dXJucyBudWxsIGZvciB0d28gcG9pbnRzLCBhbmQgZmFpbHMgaWYgdGhyZWUgcG9pbnRzIGFyZSBpbiBhIGxpbmUsXG4gICAgICAgICAgICAgICAgLy8gc28gdGhpcyBwdXRzIGEgY291cGxlIHBvaW50cyBzbGlnaHRseSBvZmYgdGhlIGxpbmUgZm9yIHR3byBwb2ludHMsIG9yIGFyb3VuZCBhIHNpbmdsZXRvbi5cbiAgICAgICAgICAgICAgICBpZiAoZmNvb3Jkcy5sZW5ndGggPT0gMil7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWx0YXggPSBmY29vcmRzWzBdWzBdLSBmY29vcmRzWzFdWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVsdGF5ID0gZmNvb3Jkc1swXVsxXS0gZmNvb3Jkc1sxXVsxXTtcbiAgICAgICAgICAgICAgICAgICAgZmNvb3Jkcy5wdXNoKFsoZmNvb3Jkc1swXVswXSArIGZjb29yZHNbMV1bMF0pLzIgKyBkZWx0YXkvMjAsIChmY29vcmRzWzBdWzFdKyBmY29vcmRzWzFdWzFdKS8yICsgZGVsdGF4LzIwXSk7XG4gICAgICAgICAgICAgICAgICAgIGZjb29yZHMucHVzaChbKGZjb29yZHNbMF1bMF0gKyBmY29vcmRzWzFdWzBdKS8yIC0gZGVsdGF5LzIwLCAoZmNvb3Jkc1swXVsxXSsgZmNvb3Jkc1sxXVsxXSkvMiAtIGRlbHRheC8yMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZmNvb3Jkcy5sZW5ndGggPT0gMSl7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWx0YSA9IFJBRElVUyAqIDAuMjtcbiAgICAgICAgICAgICAgICAgICAgZmNvb3Jkcy5wdXNoKFtmY29vcmRzWzBdWzBdICsgZGVsdGEsIGZjb29yZHNbMF1bMV1dKTtcbiAgICAgICAgICAgICAgICAgICAgZmNvb3Jkcy5wdXNoKFtmY29vcmRzWzBdWzBdIC0gZGVsdGEsIGZjb29yZHNbMF1bMV1dKTtcbiAgICAgICAgICAgICAgICAgICAgZmNvb3Jkcy5wdXNoKFtmY29vcmRzWzBdWzBdLCBmY29vcmRzWzBdWzFdICsgZGVsdGFdKTtcbiAgICAgICAgICAgICAgICAgICAgZmNvb3Jkcy5wdXNoKFtmY29vcmRzWzBdWzBdLCBmY29vcmRzWzBdWzFdIC0gZGVsdGFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKGZjb29yZHMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGQzLmdlb20uaHVsbCByZXR1cm5zIG51bGwgZm9yIHR3byBwb2ludHMsIGFuZCBmYWlscyBpZiB0aHJlZSBwb2ludHMgYXJlIGluIGEgbGluZSxcbiAgICAgICAgLy8gc28gdGhpcyBwdXRzIGEgY291cGxlIHBvaW50cyBzbGlnaHRseSBvZmYgdGhlIGxpbmUgZm9yIHR3byBwb2ludHMsIG9yIGFyb3VuZCBhIHNpbmdsZXRvbi5cbiAgICAgICAgZnVuY3Rpb24gbGVuZ3RoZW5jb29yZHMoY29vcmRzKXtcbiAgICAgICAgICAgIGlmIChjb29yZHMubGVuZ3RoID09IDIpe1xuICAgICAgICAgICAgICAgIHZhciBkZWx0YXggPSBjb29yZHNbMF1bMF0tIGNvb3Jkc1sxXVswXTtcbiAgICAgICAgICAgICAgICB2YXIgZGVsdGF5ID0gY29vcmRzWzBdWzFdLSBjb29yZHNbMV1bMV07XG4gICAgICAgICAgICAgICAgY29vcmRzLnB1c2goWyhjb29yZHNbMF1bMF0gKyBjb29yZHNbMV1bMF0pLzIgKyBkZWx0YXkvMjAsIChjb29yZHNbMF1bMV0rIGNvb3Jkc1sxXVsxXSkvMiArIGRlbHRheC8yMF0pO1xuICAgICAgICAgICAgICAgIGNvb3Jkcy5wdXNoKFsoY29vcmRzWzBdWzBdICsgY29vcmRzWzFdWzBdKS8yIC0gZGVsdGF5LzIwLCAoY29vcmRzWzBdWzFdKyBjb29yZHNbMV1bMV0pLzIgLSBkZWx0YXgvMjBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb29yZHMubGVuZ3RoID09IDEpe1xuICAgICAgICAgICAgICAgIHZhciBkZWx0YSA9IFJBRElVUyAqIDAuMjtcbiAgICAgICAgICAgICAgICBjb29yZHMucHVzaChbY29vcmRzWzBdWzBdICsgZGVsdGEsIGNvb3Jkc1swXVsxXV0pO1xuICAgICAgICAgICAgICAgIGNvb3Jkcy5wdXNoKFtjb29yZHNbMF1bMF0gLSBkZWx0YSwgY29vcmRzWzBdWzFdXSk7XG4gICAgICAgICAgICAgICAgY29vcmRzLnB1c2goW2Nvb3Jkc1swXVswXSwgY29vcmRzWzBdWzFdICsgZGVsdGFdKTtcbiAgICAgICAgICAgICAgICBjb29yZHMucHVzaChbY29vcmRzWzBdWzBdLCBjb29yZHNbMF1bMV0gLSBkZWx0YV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChjb29yZHMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBjb29yZHMgPSBub2Rlcy5tYXAoZnVuY3Rpb24oZCkgeyAgcmV0dXJuIFsgZC54LCBkLnldOyB9KTtcbiAgICAgICAgdmFyIGdyMWNvb3JkcyA9IGZpbmRjb29yZHMoenBhcmFtcy56Z3JvdXAxLCB6cGFyYW1zLnp2YXJzLCBjb29yZHMsIHRydWUpO1xuICAgICAgICB2YXIgZ3IyY29vcmRzID0gZmluZGNvb3Jkcyh6cGFyYW1zLnpncm91cDIsIHpwYXJhbXMuenZhcnMsIGNvb3JkcywgdHJ1ZSk7XG4gICAgICAgIHZhciBkZXBjb29yZHMgPSBmaW5kY29vcmRzKHpwYXJhbXMuemR2LCB6cGFyYW1zLnp2YXJzLCBjb29yZHMsIGZhbHNlKTtcblxuICAgICAgICAvLyBkcmF3IGNvbnZleCBodWxsIGFyb3VuZCBpbmRlcGVuZGVudCB2YXJpYWJsZXMsIGlmIHRocmVlIG9yIG1vcmUgY29vcmRpbmF0ZXMgZ2l2ZW5cbiAgICAgICAgLy8gbm90ZSwgZDMuZ2VvbS5odWxsIHJldHVybnMgbnVsbCBpZiBzaG9ydGVyIGNvb3JkaW5hdGUgc2V0IHRoYW4gMyxcbiAgICAgICAgLy8gc28gZmluZGNvb3JkcygpIGZ1bmN0aW9uIGhhcyBvcHRpb24gdG8gbGVuZ3RoZW4gdGhlIGNvb3JkaW5hdGVzIHJldHVybmVkIHRvIGJ5cGFzcyB0aGlzXG4gICAgICAgIGlmKGdyMWNvb3Jkcy5sZW5ndGggPiAyKXtcbiAgICAgICAgICAgIGxpbmUuc3R5bGUoXCJvcGFjaXR5XCIsIDEpO1xuICAgICAgICAgICAgdmlzYmFja2dyb3VuZC5zdHlsZShcIm9wYWNpdHlcIiwgMSk7XG4gICAgICAgICAgICB2aXMuc3R5bGUoXCJvcGFjaXR5XCIsIDAuMyk7XG4gICAgICAgICAgICB2YXIgbXlodWxsID0gZDMuZ2VvbS5odWxsKGdyMWNvb3Jkcyk7XG5cbiAgICAgICAgICAgIHZpcy5zZWxlY3RBbGwoXCJwYXRoXCIpXG4gICAgICAgICAgICAgICAgLmRhdGEoW215aHVsbF0pICAgLy8gcmV0dXJucyBudWxsIGlmIGxlc3MgdGhhbiB0aHJlZSBjb29yZGluYXRlc1xuICAgICAgICAgICAgICAgIC5hdHRyKFwiZFwiLCBmdW5jdGlvbihkKSB7IHJldHVybiBcIk1cIiArIGQuam9pbihcIkxcIikgKyBcIlpcIjsgfSk7XG4gICAgICAgICAgICB2aXNiYWNrZ3JvdW5kLnNlbGVjdEFsbChcInBhdGhcIilcbiAgICAgICAgICAgICAgICAuZGF0YShbbXlodWxsXSkgICAvLyByZXR1cm5zIG51bGwgaWYgbGVzcyB0aGFuIHRocmVlIGNvb3JkaW5hdGVzXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJkXCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIFwiTVwiICsgZC5qb2luKFwiTFwiKSArIFwiWlwiOyB9KTtcblxuICAgICAgICAgICAgLy92YXIgcCA9IGQzLmdlb20ucG9seWdvbihpbmRjb29yZHMpLmNlbnRyb2lkKCk7ICAvLyBTZWVtcyB0byBnbyBzdHJhbmdlIHNvbWV0aW1lc1xuICAgICAgICAgICAgdmFyIHAgPSBqYW1lc2NlbnRyb2lkKGdyMWNvb3Jkcyk7XG5cbiAgICAgICAgICAgIGlmKGRlcGNvb3Jkcy5sZW5ndGg+MCl7XG4gICAgICAgICAgICAgICAgdmFyIHEgPSBkZXBjb29yZHNbMF07ICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdGUsIG9ubHkgdXNpbmcgZmlyc3QgZGVwIHZhciBjdXJyZW50bHlcbiAgICAgICAgICAgICAgICAvL3ZhciByID0gZmluZGJvdW5kYXJ5KHAscSxncjFjb29yZHMpOyAgICAgICAgLy8gQW4gYXBwcm9hY2ggdG8gZmluZCB0aGUgZXhhY3QgYm91bmRhcnksIG5vdCBwcmVzZW50bHkgd29ya2luZ1xuICAgICAgICAgICAgICAgIHZhciBsZGVsdGFYID0gcVswXSAtIHBbMF0sXG4gICAgICAgICAgICAgICAgICAgIGxkZWx0YVkgPSBxWzFdIC0gcFsxXSxcbiAgICAgICAgICAgICAgICAgICAgbGRpc3QgPSBNYXRoLnNxcnQobGRlbHRhWCAqIGxkZWx0YVggKyBsZGVsdGFZICogbGRlbHRhWSksXG4gICAgICAgICAgICAgICAgICAgIGxub3JtWCA9IDAsXG4gICAgICAgICAgICAgICAgICAgIGxub3JtWSA9IDAsXG4gICAgICAgICAgICAgICAgICAgIGxzb3VyY2VQYWRkaW5nID0gUkFESVVTICsgNyxcbiAgICAgICAgICAgICAgICAgICAgbHRhcmdldFBhZGRpbmcgPSBSQURJVVMgKyAxMDtcblxuICAgICAgICAgICAgICAgIGlmIChsZGlzdCA+IDApe1xuICAgICAgICAgICAgICAgICAgICBsbm9ybVggPSBsZGVsdGFYIC8gbGRpc3Q7XG4gICAgICAgICAgICAgICAgICAgIGxub3JtWSA9IGxkZWx0YVkgLyBsZGlzdDtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgbGluZS5hdHRyKFwieDFcIiwgcFswXSArIChsc291cmNlUGFkZGluZyAqIGxub3JtWCkpICAgLy8gb3IgclswXSBpZiBmaW5kYm91bmRhcnkgd29ya3NcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ5MVwiLCBwWzFdICsgKGxzb3VyY2VQYWRkaW5nICogbG5vcm1ZKSkgICAvLyBvciByWzFdIGlmIGZpbmRib3VuZGFyeSB3b3Jrc1xuICAgICAgICAgICAgICAgICAgICAuYXR0cihcIngyXCIsIHFbMF0tIChsdGFyZ2V0UGFkZGluZyAqIGxub3JtWCkpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieTJcIiwgcVsxXS0gKGx0YXJnZXRQYWRkaW5nICogbG5vcm1ZKSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBncm91cCBtZW1iZXJzIGF0dHJhY3QgZWFjaCBvdGhlciwgcmVwdWxzZSBub24tZ3JvdXAgbWVtYmVyc1xuICAgICAgICAgICAgbm9kZXMuZm9yRWFjaChuID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgc2lnbiA9IChuLmdyb3VwMSkgPyAxIDogLTE7ICAgIC8vd2FzOiBNYXRoLnNpZ24oIHpwYXJhbXMuemdyb3VwMS5pbmRleE9mKG4ubmFtZSkgKzAuNSApOyAgLy8gMSBpZiBuIGluIGdyb3VwLCAtMSBpZiBuIG5vdCBpbiBncm91cDtcbiAgICAgICAgICAgICAgICB2YXIgbGRlbHRhWCA9IHBbMF0gLSBuLngsXG4gICAgICAgICAgICAgICAgICAgIGxkZWx0YVkgPSBwWzFdIC0gbi55LFxuICAgICAgICAgICAgICAgICAgICBsZGlzdCA9IE1hdGguc3FydChsZGVsdGFYICogbGRlbHRhWCArIGxkZWx0YVkgKiBsZGVsdGFZKTtcbiAgICAgICAgICAgICAgICAgICAgbG5vcm1YID0gMCxcbiAgICAgICAgICAgICAgICAgICAgbG5vcm1ZID0gMDtcblxuICAgICAgICAgICAgICAgIGlmIChsZGlzdCA+IDApe1xuICAgICAgICAgICAgICAgICAgICBsbm9ybVggPSBsZGVsdGFYIC8gbGRpc3Q7XG4gICAgICAgICAgICAgICAgICAgIGxub3JtWSA9IGxkZWx0YVkgLyBsZGlzdDtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgbi54ICs9IE1hdGgubWluKGxub3JtWCAsIGxkZWx0YVgvMTAwICkgKiBrICogc2lnbiAgICogZm9yY2UuYWxwaGEoKTtcbiAgICAgICAgICAgICAgICBuLnkgKz0gTWF0aC5taW4obG5vcm1ZICwgbGRlbHRhWS8xMDAgKSAqIGsgKiBzaWduICAgKiBmb3JjZS5hbHBoYSgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZpc2JhY2tncm91bmQuc3R5bGUoXCJvcGFjaXR5XCIsIDApO1xuICAgICAgICAgICAgdmlzLnN0eWxlKFwib3BhY2l0eVwiLCAwKTtcbiAgICAgICAgICAgIGxpbmUuc3R5bGUoXCJvcGFjaXR5XCIsIDApO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmKGdyMmNvb3Jkcy5sZW5ndGggPiAyKXtcbiAgICAgICAgICAgIGxpbmUyLnN0eWxlKFwib3BhY2l0eVwiLCAxKTtcbiAgICAgICAgICAgIHZpczJiYWNrZ3JvdW5kLnN0eWxlKFwib3BhY2l0eVwiLCAxKTtcbiAgICAgICAgICAgIHZpczIuc3R5bGUoXCJvcGFjaXR5XCIsIDAuMyk7XG4gICAgICAgICAgICB2YXIgbXlodWxsID0gZDMuZ2VvbS5odWxsKGdyMmNvb3Jkcyk7XG4gICAgICAgICAgICB2aXMyLnNlbGVjdEFsbChcInBhdGhcIilcbiAgICAgICAgICAgICAgICAuZGF0YShbbXlodWxsXSkgICAvLyByZXR1cm5zIG51bGwgaWYgbGVzcyB0aGFuIHRocmVlIGNvb3JkaW5hdGVzXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJkXCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIFwiTVwiICsgZC5qb2luKFwiTFwiKSArIFwiWlwiOyB9KTtcbiAgICAgICAgICAgIHZpczJiYWNrZ3JvdW5kLnNlbGVjdEFsbChcInBhdGhcIilcbiAgICAgICAgICAgICAgICAuZGF0YShbbXlodWxsXSkgICAvLyByZXR1cm5zIG51bGwgaWYgbGVzcyB0aGFuIHRocmVlIGNvb3JkaW5hdGVzXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJkXCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIFwiTVwiICsgZC5qb2luKFwiTFwiKSArIFwiWlwiOyB9KTtcblxuICAgICAgICAgICAgLy92YXIgcCA9IGQzLmdlb20ucG9seWdvbihpbmRjb29yZHMpLmNlbnRyb2lkKCk7ICAvLyBTZWVtcyB0byBnbyBzdHJhbmdlIHNvbWV0aW1lc1xuICAgICAgICAgICAgdmFyIHAgPSBqYW1lc2NlbnRyb2lkKGdyMmNvb3Jkcyk7XG5cbiAgICAgICAgICAgIGlmKGRlcGNvb3Jkcy5sZW5ndGg+MCl7XG4gICAgICAgICAgICAgICAgdmFyIHEgPSBkZXBjb29yZHNbMF07ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3RlLCBvbmx5IHVzaW5nIGZpcnN0IGRlcCB2YXIgY3VycmVudGx5XG4gICAgICAgICAgICAgICAgdmFyIGxkZWx0YVggPSBxWzBdIC0gcFswXSxcbiAgICAgICAgICAgICAgICAgICAgbGRlbHRhWSA9IHFbMV0gLSBwWzFdLFxuICAgICAgICAgICAgICAgICAgICBsZGlzdCA9IE1hdGguc3FydChsZGVsdGFYICogbGRlbHRhWCArIGxkZWx0YVkgKiBsZGVsdGFZKSxcbiAgICAgICAgICAgICAgICAgICAgbG5vcm1YID0gbGRlbHRhWCAvIGxkaXN0LFxuICAgICAgICAgICAgICAgICAgICBsbm9ybVkgPSBsZGVsdGFZIC8gbGRpc3QsXG4gICAgICAgICAgICAgICAgICAgIGxzb3VyY2VQYWRkaW5nID0gUkFESVVTICsgNyxcbiAgICAgICAgICAgICAgICAgICAgbHRhcmdldFBhZGRpbmcgPSBSQURJVVMgKyAxMDtcblxuICAgICAgICAgICAgICAgIGxpbmUyLmF0dHIoXCJ4MVwiLCBwWzBdICsgKGxzb3VyY2VQYWRkaW5nICogbG5vcm1YKSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ5MVwiLCBwWzFdICsgKGxzb3VyY2VQYWRkaW5nICogbG5vcm1ZKSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ4MlwiLCBxWzBdLSAobHRhcmdldFBhZGRpbmcgKiBsbm9ybVgpKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcInkyXCIsIHFbMV0tIChsdGFyZ2V0UGFkZGluZyAqIGxub3JtWSkpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gZ3JvdXAgbWVtYmVycyBhdHRyYWN0IGVhY2ggb3RoZXIsIHJlcHVsc2Ugbm9uLWdyb3VwIG1lbWJlcnNcbiAgICAgICAgICAgIG5vZGVzLmZvckVhY2gobiA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIHNpZ24gPSAobi5ncm91cDIpID8gMSA6IC0xOyAgLy8gd2FzOiBNYXRoLnNpZ24oIHpwYXJhbXMuemdyb3VwMi5pbmRleE9mKG4ubmFtZSkgKzAuNSApOyAgLy8gMSBpZiBuIGluIGdyb3VwLCAtMSBpZiBuIG5vdCBpbiBncm91cDtcbiAgICAgICAgICAgICAgICB2YXIgbGRlbHRhWCA9IHBbMF0gLSBuLngsXG4gICAgICAgICAgICAgICAgICAgIGxkZWx0YVkgPSBwWzFdIC0gbi55LFxuICAgICAgICAgICAgICAgICAgICBsZGlzdCA9IE1hdGguc3FydChsZGVsdGFYICogbGRlbHRhWCArIGxkZWx0YVkgKiBsZGVsdGFZKSxcbiAgICAgICAgICAgICAgICAgICAgbG5vcm1YID0gMCxcbiAgICAgICAgICAgICAgICAgICAgbG5vcm1ZID0gMDtcblxuICAgICAgICAgICAgICAgIGlmIChsZGlzdCA+IDApe1xuICAgICAgICAgICAgICAgICAgICBsbm9ybVggPSBsZGVsdGFYIC8gbGRpc3Q7XG4gICAgICAgICAgICAgICAgICAgIGxub3JtWSA9IGxkZWx0YVkgLyBsZGlzdDtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgbi54ICs9IE1hdGgubWluKGxub3JtWCAsIGxkZWx0YVgvMTAwICkgKiBrICogc2lnbiAgICogZm9yY2UuYWxwaGEoKTtcbiAgICAgICAgICAgICAgICBuLnkgKz0gTWF0aC5taW4obG5vcm1ZICwgbGRlbHRhWS8xMDAgKSAqIGsgKiBzaWduICAgKiBmb3JjZS5hbHBoYSgpO1xuICAgICAgICAgICAgfSk7XG5cblxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHZpczJiYWNrZ3JvdW5kLnN0eWxlKFwib3BhY2l0eVwiLCAwKTtcbiAgICAgICAgICAgIHZpczIuc3R5bGUoXCJvcGFjaXR5XCIsIDApO1xuICAgICAgICAgICAgbGluZTIuc3R5bGUoXCJvcGFjaXR5XCIsIDApO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGRyYXcgZGlyZWN0ZWQgZWRnZXMgd2l0aCBwcm9wZXIgcGFkZGluZyBmcm9tIG5vZGUgY2VudGVyc1xuICAgICAgICBwYXRoLmF0dHIoJ2QnLCBkID0+IHtcbiAgICAgICAgICAgIHZhciBkZWx0YVggPSBkLnRhcmdldC54IC0gZC5zb3VyY2UueCxcbiAgICAgICAgICAgICAgICBkZWx0YVkgPSBkLnRhcmdldC55IC0gZC5zb3VyY2UueSxcbiAgICAgICAgICAgICAgICBkaXN0ID0gTWF0aC5zcXJ0KGRlbHRhWCAqIGRlbHRhWCArIGRlbHRhWSAqIGRlbHRhWSksXG4gICAgICAgICAgICAgICAgbm9ybVggPSBkZWx0YVggLyBkaXN0LFxuICAgICAgICAgICAgICAgIG5vcm1ZID0gZGVsdGFZIC8gZGlzdCxcbiAgICAgICAgICAgICAgICBzb3VyY2VQYWRkaW5nID0gZC5sZWZ0ID8gUkFESVVTICsgNSA6IFJBRElVUyxcbiAgICAgICAgICAgICAgICB0YXJnZXRQYWRkaW5nID0gZC5yaWdodCA/IFJBRElVUyArIDUgOiBSQURJVVMsXG4gICAgICAgICAgICAgICAgc291cmNlWCA9IGQuc291cmNlLnggKyAoc291cmNlUGFkZGluZyAqIG5vcm1YKSxcbiAgICAgICAgICAgICAgICBzb3VyY2VZID0gZC5zb3VyY2UueSArIChzb3VyY2VQYWRkaW5nICogbm9ybVkpLFxuICAgICAgICAgICAgICAgIHRhcmdldFggPSBkLnRhcmdldC54IC0gKHRhcmdldFBhZGRpbmcgKiBub3JtWCksXG4gICAgICAgICAgICAgICAgdGFyZ2V0WSA9IGQudGFyZ2V0LnkgLSAodGFyZ2V0UGFkZGluZyAqIG5vcm1ZKTtcbiAgICAgICAgICAgIHJldHVybiBgTSR7c291cmNlWH0sJHtzb3VyY2VZfUwke3RhcmdldFh9LCR7dGFyZ2V0WX1gO1xuICAgICAgICB9KTtcblxuICAgICAgICBjaXJjbGUuYXR0cigndHJhbnNmb3JtJywgZCA9PiAndHJhbnNsYXRlKCcgKyBkLnggKyAnLCcgKyBkLnkgKyAnKScpO1xuXG4gICAgICAgIGNpcmNsZS5zZWxlY3RBbGwoJ2NpcmNsZScpICAgICAgICAgICAvLyBTaHJpbmsvZXhwYW5kIHBlYmJsZXMgdGhhdCBqb2luL2xlYXZlIGdyb3Vwc1xuICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgLmR1cmF0aW9uKDEwMClcbiAgICAgICAgICAgIC5hdHRyKCdyJywgZCA9PiBzZXRQZWJibGVSYWRpdXMoZCkpO1xuICAgIH1cblxuICAgIC8vIHRoaXMgaXMgdG8gZGV0ZWN0IGEgY2xpY2sgaW4gdGhlIHdoaXRlc3BhY2UsIGJ1dCBub3Qgb24gYSBwZWJibGVcbiAgICBsZXQgb3V0c2lkZUNsaWNrID0gZmFsc2U7XG5cbiAgICAvLyB1cGRhdGUgZ3JhcGggKGNhbGxlZCB3aGVuIG5lZWRlZClcbiAgICByZXN0YXJ0ID0gZnVuY3Rpb24oJGxpbmtzKSB7XG4gICAgICAgIGlmIChpc19yZXN1bHRzX21vZGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxpbmtzID0gJGxpbmtzIHx8IGxpbmtzO1xuICAgICAgICAvLyBub2Rlcy5pZCBpcyBwZWdnZWQgdG8gYWxsTm9kZXMsIGkuZS4gdGhlIG9yZGVyIGluIHdoaWNoIHZhcmlhYmxlcyBhcmUgcmVhZCBpblxuICAgICAgICAvLyBub2Rlcy5pbmRleCBpcyBmbG9hdGluZyBhbmQgZGVwZW5kcyBvbiB1cGRhdGVzIHRvIG5vZGVzLiAgYSB2YXJpYWJsZXMgaW5kZXggY2hhbmdlcyB3aGVuIG5ldyB2YXJpYWJsZXMgYXJlIGFkZGVkLlxuICAgICAgICBjaXJjbGUuY2FsbChmb3JjZS5kcmFnKTtcbiAgICAgICAgaWYgKGZvcmNldG9nZ2xlWzBdID09IFwidHJ1ZVwiKSB7XG4gICAgICAgICAgICBmb3JjZS5ncmF2aXR5KDAuMSk7XG4gICAgICAgICAgICBmb3JjZS5jaGFyZ2UoZCA9PiBzZXRQZWJibGVDaGFyZ2UoZCkpO1xuICAgICAgICAgICAgZm9yY2Uuc3RhcnQoKTtcbiAgICAgICAgICAgIGZvcmNlLmxpbmtTdHJlbmd0aCgxKTtcbiAgICAgICAgICAgIGsgPSA0OyAvLyBzdHJlbmd0aCBwYXJhbWV0ZXIgZm9yIGdyb3VwIGF0dHJhY3Rpb24vcmVwdWxzaW9uXG4gICAgICAgICAgICBpZiAoKHpwYXJhbXMuemdyb3VwMS5sZW5ndGggPiAwKSAmICh6cGFyYW1zLnpncm91cDIubGVuZ3RoID4gMCApKSB7IC8vIHNjYWxlIGRvd24gYnkgbnVtYmVyIG9mIGFjdGl2ZSBncm91cHNcbiAgICAgICAgICAgICAgICBrID0gMi41O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yY2UuZ3Jhdml0eSgwKTtcbiAgICAgICAgICAgIGZvcmNlLmNoYXJnZSgwKTtcbiAgICAgICAgICAgIGZvcmNlLmxpbmtTdHJlbmd0aCgwKTtcbiAgICAgICAgICAgIGsgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGZvcmNlLnJlc3VtZSgpO1xuXG4gICAgICAgIC8vIHBhdGggKGxpbmspIGdyb3VwXG4gICAgICAgIHBhdGggPSBwYXRoLmRhdGEobGlua3MpO1xuXG4gICAgICAgIGxldCBtYXJrZXIgPSBzaWRlID0+IHggPT4ge1xuICAgICAgICAgICAgbGV0IGtpbmQgPSBzaWRlID09PSAnbGVmdCcgPyAnc3RhcnQnIDogJ2VuZCc7XG4gICAgICAgICAgICByZXR1cm4gaXNfZXhwbG9yZV9tb2RlID8gJ3VybCgjY2lyY2xlKScgOlxuICAgICAgICAgICAgICAgIHhbc2lkZV0gPyBgdXJsKCMke2tpbmR9LWFycm93KWAgOlxuICAgICAgICAgICAgICAgICAgICAnJztcbiAgICAgICAgfTtcblxuICAgICAgICAvLyB1cGRhdGUgZXhpc3RpbmcgbGlua3NcbiAgICAgICAgLy8gVkpEOiBkYXNoZWQgbGlua3MgYmV0d2VlbiBwZWJibGVzIGFyZSBcInNlbGVjdGVkXCIuIHRoaXMgaXMgZGlzYWJsZWQgZm9yIG5vd1xuICAgICAgICBwYXRoLmNsYXNzZWQoJ3NlbGVjdGVkJywgeCA9PiBudWxsKVxuICAgICAgICAgICAgLnN0eWxlKCdtYXJrZXItc3RhcnQnLCBtYXJrZXIoJ2xlZnQnKSlcbiAgICAgICAgICAgIC5zdHlsZSgnbWFya2VyLWVuZCcsIG1hcmtlcigncmlnaHQnKSk7XG5cbiAgICAgICAgLy8gYWRkIG5ldyBsaW5rc1xuICAgICAgICBwYXRoLmVudGVyKCkuYXBwZW5kKCdzdmc6cGF0aCcpXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbGluaycpXG4gICAgICAgICAgICAuY2xhc3NlZCgnc2VsZWN0ZWQnLCB4ID0+IG51bGwpXG4gICAgICAgICAgICAuc3R5bGUoJ21hcmtlci1zdGFydCcsIG1hcmtlcignbGVmdCcpKVxuICAgICAgICAgICAgLnN0eWxlKCdtYXJrZXItZW5kJywgbWFya2VyKCdyaWdodCcpKVxuICAgICAgICAgICAgLm9uKCdtb3VzZWRvd24nLCBmdW5jdGlvbihkKSB7IC8vIGRvIHdlIGV2ZXIgbmVlZCB0byBzZWxlY3QgYSBsaW5rPyBtYWtlIGl0IGRlbGV0ZS4uXG4gICAgICAgICAgICAgICAgdmFyIG9iaiA9IEpTT04uc3RyaW5naWZ5KGQpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGlua3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9iaiA9PT0gSlNPTi5zdHJpbmdpZnkobGlua3Nbal0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsKGxpbmtzLCBqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAvLyByZW1vdmUgb2xkIGxpbmtzXG4gICAgICAgIHBhdGguZXhpdCgpLnJlbW92ZSgpO1xuXG4gICAgICAgIC8vIGNpcmNsZSAobm9kZSkgZ3JvdXBcbiAgICAgICAgY2lyY2xlID0gY2lyY2xlLmRhdGEobm9kZXMsIHggPT4geC5pZCk7XG5cbiAgICAgICAgLy8gdXBkYXRlIGV4aXN0aW5nIG5vZGVzIChyZWZsZXhpdmUgJiBzZWxlY3RlZCB2aXN1YWwgc3RhdGVzKVxuICAgICAgICAvLyBkMy5yZ2IgaXMgdGhlIGZ1bmN0aW9uIGFkanVzdGluZyB0aGUgY29sb3IgaGVyZVxuICAgICAgICBjaXJjbGUuc2VsZWN0QWxsKCdjaXJjbGUnKVxuICAgICAgICAgICAgLmNsYXNzZWQoJ3JlZmxleGl2ZScsIHggPT4geC5yZWZsZXhpdmUpXG4gICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCB4ID0+IGQzLnJnYih4Lm5vZGVDb2wpKVxuICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCB4ID0+IGQzLnJnYih4LnN0cm9rZUNvbG9yKSlcbiAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlLXdpZHRoJywgeCA9PiB4LnN0cm9rZVdpZHRoKTtcbiAgICAgICAgLy8gYWRkIG5ldyBub2Rlc1xuICAgICAgICBsZXQgZyA9IGNpcmNsZS5lbnRlcigpXG4gICAgICAgICAgICAuYXBwZW5kKCdzdmc6ZycpXG4gICAgICAgICAgICAuYXR0cignaWQnLCB4ID0+IHgubmFtZSArICdiaWdncm91cCcpO1xuXG4gICAgICAgIC8vIGFkZCBwbG90XG4gICAgICAgIGcuZWFjaChmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICBkMy5zZWxlY3QodGhpcyk7XG4gICAgICAgICAgICBpZiAoZC5wbG90dHlwZSA9PSAnY29udGludW91cycpIGRlbnNpdHlOb2RlKGQsIHRoaXMsIHNldFBlYmJsZVJhZGl1cyhkKSk7XG4gICAgICAgICAgICBlbHNlIGlmIChkLnBsb3R0eXBlID09ICdiYXInKSBiYXJzTm9kZShkLCB0aGlzLCBzZXRQZWJibGVSYWRpdXMoZCkpO1xuICAgICAgICB9KTtcblxuICAgICAgICBsZXQgYXBwZW5kID0gKHN0ciwgYXR0cikgPT4geCA9PiBzdHIgKyB4W2F0dHIgfHwgJ2lkJ107XG5cbiAgICAgICAgbGV0IHJlZHJhd1BlYmJsZXMgPSAoKSA9PiB7XG4gICAgICAgICAgICBnWzBdLmZvckVhY2goKHBlYmJsZSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIG51bGxpdHkgY2hlY2sgZm9yIHdoZW4gcmVpbnRyb2R1Y2luZyB2YXJpYWJsZSBmcm9tIHZhcmlhYmxlIGxpc3RcbiAgICAgICAgICAgICAgICBpZiAocGViYmxlID09PSBudWxsKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICBsZXQgZGF0YSA9IHBlYmJsZS5fX2RhdGFfXztcbiAgICAgICAgICAgICAgICBsZXQgcmFkaXVzID0gc2V0UGViYmxlUmFkaXVzKGRhdGEpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEucGxvdHR5cGUgPT0gJ2NvbnRpbnVvdXMnKSBkZW5zaXR5Tm9kZShkYXRhLCBwZWJibGUsIHNldFBlYmJsZVJhZGl1cyhkYXRhKSk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZGF0YS5wbG90dHlwZSA9PSAnYmFyJykgYmFyc05vZGUoZGF0YSwgcGViYmxlLCBzZXRQZWJibGVSYWRpdXMoZGF0YSkpO1xuXG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KHBlYmJsZS5xdWVyeVNlbGVjdG9yKFwiW2lkXj0ncGViYmxlTGFiZWwnXVwiKSkuc3R5bGUoJ2ZvbnQtc2l6ZScsIHJhZGl1cyAqIC4xNzUgKyA3ICsgJ3B4JykgIC8vIHByb3BvcnRpb25hbCBzY2FsaW5nIHdvdWxkIGJlIDE0IC8gNDAsIGJ1dCBJIGFkZGVkIHktaW50ZXJjZXB0IGF0IDdcbiAgICAgICAgICAgICAgICBkMy5zZWxlY3QocGViYmxlLnF1ZXJ5U2VsZWN0b3IoXCJbaWRePSdkdkFyYyddXCIpKS5hdHRyKFwiZFwiLCBhcmMzKHJhZGl1cykpXG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KHBlYmJsZS5xdWVyeVNlbGVjdG9yKFwiW2lkXj0nbm9tQXJjJ11cIikpLmF0dHIoXCJkXCIsIGFyYzQocmFkaXVzKSlcbiAgICAgICAgICAgICAgICBkMy5zZWxlY3QocGViYmxlLnF1ZXJ5U2VsZWN0b3IoXCJbaWRePSdnckFyYyddXCIpKS5hdHRyKFwiZFwiLCBhcmMxKHJhZGl1cykpXG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KHBlYmJsZS5xdWVyeVNlbGVjdG9yKFwiW2lkXj0nZ3IxaW5kaWNhdG9yJ11cIikpLmF0dHIoXCJkXCIsIGFyY0luZDEocmFkaXVzKSlcbiAgICAgICAgICAgICAgICBkMy5zZWxlY3QocGViYmxlLnF1ZXJ5U2VsZWN0b3IoXCJbaWRePSdncjJpbmRpY2F0b3InXVwiKSkuYXR0cihcImRcIiwgYXJjSW5kMihyYWRpdXMpKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGcuYXBwZW5kKFwicGF0aFwiKS5lYWNoKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIGxldCByYWRpdXMgPSBzZXRQZWJibGVSYWRpdXMoZCk7XG4gICAgICAgICAgICBkMy5zZWxlY3QodGhpcylcbiAgICAgICAgICAgICAgICAuYXR0cihcImlkXCIsIGFwcGVuZCgnZHZBcmMnKSlcbiAgICAgICAgICAgICAgICAuYXR0cihcImRcIiwgYXJjMyhyYWRpdXMpKVxuICAgICAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgZHZDb2xvcilcbiAgICAgICAgICAgICAgICAuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAwKVxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgICBkLmZvcmVmcm9udCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChob3ZlclBlYmJsZSA9PT0gZC5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWQuZm9yZWZyb250KSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG92ZXJQZWJibGUgPSBkLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbFRoaXModGhpcywgLjMsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbChkLCAnZHZUZXh0JywgLjksIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBob3ZlclRpbWVvdXQpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgICAgIGQuZm9yZWZyb250ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbFRoaXModGhpcywgMCwgMTAwLCA1MDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbChkLCAnZHZUZXh0JywgMCwgMTAwLCA1MDApO1xuICAgICAgICAgICAgICAgICAgICB9LCBob3ZlclRpbWVvdXQpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAub24oJ2NsaWNrJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgICBzZXRDb2xvcnMoZCwgZHZDb2xvcik7XG4gICAgICAgICAgICAgICAgICAgIGxlZ2VuZChkdkNvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgZC5ncm91cDEgPSBkLmdyb3VwMiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZFBlYmJsZSA9IGQubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgcmVkcmF3UGViYmxlcygpO1xuICAgICAgICAgICAgICAgICAgICByZXN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pXG5cbiAgICAgICAgZy5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsIGFwcGVuZCgnZHZUZXh0JykpXG4gICAgICAgICAgICAuYXR0cihcInhcIiwgNilcbiAgICAgICAgICAgIC5hdHRyKFwiZHlcIiwgMTEuNSlcbiAgICAgICAgICAgIC5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAuYXBwZW5kKFwidGV4dFBhdGhcIilcbiAgICAgICAgICAgIC5hdHRyKFwieGxpbms6aHJlZlwiLCBhcHBlbmQoJyNkdkFyYycpKVxuICAgICAgICAgICAgLnRleHQoXCJEZXAgVmFyXCIpO1xuXG4gICAgICAgIGcuYXBwZW5kKFwicGF0aFwiKS5lYWNoKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIGxldCByYWRpdXMgPSBzZXRQZWJibGVSYWRpdXMoZCk7XG4gICAgICAgICAgICBkMy5zZWxlY3QodGhpcylcbiAgICAgICAgICAgICAgICAuYXR0cihcImlkXCIsIGFwcGVuZCgnbm9tQXJjJykpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJkXCIsIGFyYzQocmFkaXVzKSlcbiAgICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIG5vbUNvbG9yKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZC5kZWZhdWx0TnVtY2hhciA9PSBcImNoYXJhY3RlclwiKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGQuZm9yZWZyb250ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhvdmVyUGViYmxlID09PSBkLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZC5mb3JlZnJvbnQpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3ZlclBlYmJsZSA9IGQubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsVGhpcyh0aGlzLCAuMywgMCwgMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsKGQsIFwibm9tVGV4dFwiLCAuOSwgMCwgMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGhvdmVyVGltZW91dClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkLmRlZmF1bHROdW1jaGFyID09IFwiY2hhcmFjdGVyXCIpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgZC5mb3JlZnJvbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsVGhpcyh0aGlzLCAwLCAxMDAsIDUwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsKGQsIFwibm9tVGV4dFwiLCAwLCAxMDAsIDUwMCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIGhvdmVyVGltZW91dClcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5vbignY2xpY2snLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZC5kZWZhdWx0TnVtY2hhciA9PSBcImNoYXJhY3RlclwiKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIHNldENvbG9ycyhkLCBub21Db2xvcik7XG4gICAgICAgICAgICAgICAgICAgIGxlZ2VuZChub21Db2xvcik7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkUGViYmxlID0gZC5uYW1lO1xuICAgICAgICAgICAgICAgICAgICByZWRyYXdQZWJibGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3RhcnQoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZy5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsIGFwcGVuZChcIm5vbVRleHRcIikpXG4gICAgICAgICAgICAuYXR0cihcInhcIiwgNilcbiAgICAgICAgICAgIC5hdHRyKFwiZHlcIiwgMTEuNSlcbiAgICAgICAgICAgIC5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAuYXBwZW5kKFwidGV4dFBhdGhcIilcbiAgICAgICAgICAgIC5hdHRyKFwieGxpbms6aHJlZlwiLCBhcHBlbmQoXCIjbm9tQXJjXCIpKVxuICAgICAgICAgICAgLnRleHQoXCJOb21pbmFsXCIpO1xuXG4gICAgICAgIGcuYXBwZW5kKFwicGF0aFwiKS5lYWNoKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIGxldCByYWRpdXMgPSBzZXRQZWJibGVSYWRpdXMoZCk7XG4gICAgICAgICAgICBkMy5zZWxlY3QodGhpcylcbiAgICAgICAgICAgICAgICAuYXR0cihcImlkXCIsIGFwcGVuZCgnZ3JBcmMnKSlcbiAgICAgICAgICAgICAgICAuYXR0cihcImRcIiwgYXJjMShyYWRpdXMpKVxuICAgICAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgZ3IxQ29sb3IpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGwoZCwgXCJncjFpbmRpY2F0b3JcIiwgLjMsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgICAgIGZpbGwoZCwgXCJncjJpbmRpY2F0b3JcIiwgLjMsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgICAgIGQuZm9yZWZyb250ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhvdmVyUGViYmxlID09PSBkLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZC5mb3JlZnJvbnQpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3ZlclBlYmJsZSA9IGQubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsVGhpcyh0aGlzLCAuMywgMCwgMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsKGQsICdnclRleHQnLCAuOSwgMCwgMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGhvdmVyVGltZW91dClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgICAgIGQuZm9yZWZyb250ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbChkLCBcImdyMWluZGljYXRvclwiLCAwLCAxMDAsIDUwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsKGQsIFwiZ3IyaW5kaWNhdG9yXCIsIDAsIDEwMCwgNTAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGxUaGlzKHRoaXMsIDAsIDEwMCwgNTAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGwoZCwgJ2dyVGV4dCcsIDAsIDEwMCwgNTAwKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgaG92ZXJUaW1lb3V0KVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm9uKCdjbGljaycsIGQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvL2QuZ3JvdXAxID0gIWQuZ3JvdXAxOyAgICAgIC8vIFRoaXMgbWlnaHQgYmUgZWFzaWVyLCBidXQgY3VycmVudGx5IHNldCBpbiBzZXRDb2xvcnMoKVxuICAgICAgICAgICAgICAgICAgICBzZXRDb2xvcnMoZCwgZ3IxQ29sb3IpO1xuICAgICAgICAgICAgICAgICAgICBsZWdlbmQoZ3IxQ29sb3IpO1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZFBlYmJsZSA9IGQubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgcmVkcmF3UGViYmxlcygpO1xuICAgICAgICAgICAgICAgICAgICByZXN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGcuYXBwZW5kKFwicGF0aFwiKS5lYWNoKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIGxldCByYWRpdXMgPSBzZXRQZWJibGVSYWRpdXMoZCk7XG4gICAgICAgICAgICBkMy5zZWxlY3QodGhpcylcbiAgICAgICAgICAgICAgICAuYXR0cihcImlkXCIsIGFwcGVuZCgnZ3IxaW5kaWNhdG9yJykpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJkXCIsIGFyY0luZDEocmFkaXVzKSlcbiAgICAgICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGdyMUNvbG9yKSAgLy8gc29tZXRoaW5nIGxpa2U6IHpwYXJhbXMuemdyb3VwMS5pbmRleE9mKG5vZGUubmFtZSkgPiAtMSAgPyAgI0ZGRkZGRiA6IGdyMUNvbG9yKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIDApXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgICAgICBkLmZvcmVmcm9udCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChob3ZlclBlYmJsZSA9PT0gZC5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWQuZm9yZWZyb250KSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG92ZXJQZWJibGUgPSBkLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbFRoaXModGhpcywgLjMsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbChkLCBcImdyQXJjXCIsIC4xLCAwLCAxMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGwoZCwgJ2dyVGV4dCcsIC45LCAwLCAxMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgaG92ZXJUaW1lb3V0KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgZC5mb3JlZnJvbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsVGhpcyh0aGlzLCAwLCAxMDAsIDUwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsKGQsIFwiZ3JBcmNcIiwgMCwgMTAwLCA1MDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbChkLCAnZ3JUZXh0JywgMCwgMTAwLCA1MDApO1xuICAgICAgICAgICAgICAgICAgICB9LCBob3ZlclRpbWVvdXQpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAub24oJ2NsaWNrJywgZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vZC5ncm91cDEgPSAhZC5ncm91cDE7ICAgICAgLy8gVGhpcyBtaWdodCBiZSBlYXNpZXIsIGJ1dCBjdXJyZW50bHkgc2V0IGluIHNldENvbG9ycygpXG4gICAgICAgICAgICAgICAgICAgIHNldENvbG9ycyhkLCBncjFDb2xvcik7XG4gICAgICAgICAgICAgICAgICAgIGxlZ2VuZChncjFDb2xvcik7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkUGViYmxlID0gZC5uYW1lO1xuICAgICAgICAgICAgICAgICAgICByZWRyYXdQZWJibGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3RhcnQoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZy5hcHBlbmQoXCJwYXRoXCIpLmVhY2goZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgbGV0IHJhZGl1cyA9IHNldFBlYmJsZVJhZGl1cyhkKTtcbiAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgYXBwZW5kKCdncjJpbmRpY2F0b3InKSlcbiAgICAgICAgICAgICAgICAuYXR0cihcImRcIiwgYXJjSW5kMihyYWRpdXMpKVxuICAgICAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgZ3IyQ29sb3IpICAvLyBzb21ldGhpbmcgbGlrZTogenBhcmFtcy56Z3JvdXAxLmluZGV4T2Yobm9kZS5uYW1lKSA+IC0xICA/ICAjRkZGRkZGIDogZ3IxQ29sb3IpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgICAgIGQuZm9yZWZyb250ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhvdmVyUGViYmxlID09PSBkLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZC5mb3JlZnJvbnQpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3ZlclBlYmJsZSA9IGQubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsVGhpcyh0aGlzLCAuMywgMCwgMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsKGQsIFwiZ3JBcmNcIiwgLjEsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbChkLCAnZ3JUZXh0JywgLjksIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBob3ZlclRpbWVvdXQpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgICAgICBkLmZvcmVmcm9udCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGxUaGlzKHRoaXMsIDAsIDEwMCwgNTAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGwoZCwgXCJnckFyY1wiLCAwLCAxMDAsIDUwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsKGQsICdnclRleHQnLCAwLCAxMDAsIDUwMCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIGhvdmVyVGltZW91dClcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5vbignY2xpY2snLCBkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy9kLmdyb3VwMiA9ICFkLmdyb3VwMjsgICAgICAvLyBUaGlzIG1pZ2h0IGJlIGVhc2llciwgYnV0IGN1cnJlbnRseSBzZXQgaW4gc2V0Q29sb3JzKClcbiAgICAgICAgICAgICAgICAgICAgc2V0Q29sb3JzKGQsIGdyMkNvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgbGVnZW5kKGdyMkNvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRQZWJibGUgPSBkLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHJlZHJhd1BlYmJsZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdGFydCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgYXBwZW5kKCdnclRleHQnKSlcbiAgICAgICAgICAgIC5hdHRyKFwieFwiLCA2KVxuICAgICAgICAgICAgLmF0dHIoXCJkeVwiLCAxMS41KVxuICAgICAgICAgICAgLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgMClcbiAgICAgICAgICAgIC5hcHBlbmQoXCJ0ZXh0UGF0aFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ4bGluazpocmVmXCIsIGFwcGVuZCgnI2dyQXJjJykpXG4gICAgICAgICAgICAudGV4dChcIkdyb3Vwc1wiKTtcblxuICAgICAgICBnLmFwcGVuZCgnc3ZnOmNpcmNsZScpXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbm9kZScpXG4gICAgICAgICAgICAuYXR0cigncicsIGQgPT4gc2V0UGViYmxlUmFkaXVzKGQpKVxuICAgICAgICAgICAgLnN0eWxlKCdwb2ludGVyLWV2ZW50cycsICdpbmhlcml0JylcbiAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIGQgPT4gZC5ub2RlQ29sKVxuICAgICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgXCIwLjVcIilcbiAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgZCA9PiBkMy5yZ2IoZC5zdHJva2VDb2xvcikudG9TdHJpbmcoKSlcbiAgICAgICAgICAgIC5jbGFzc2VkKCdyZWZsZXhpdmUnLCBkID0+IGQucmVmbGV4aXZlKVxuICAgICAgICAgICAgLy8gVE9ETyBzaG91bGQgdGhpcyBiZSB1c2VkP1xuICAgICAgICAgICAgLm9uKCdkYmxjbGljaycsIGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgICAgICAgICBkMy5ldmVudC5zdG9wUHJvcGFnYXRpb24oKTsgLy8gc3RvcCBjbGljayBmcm9tIGJ1YmJsaW5nXG4gICAgICAgICAgICAgICAgc3VtbWFyeUhvbGQgPSB0cnVlO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignY2xpY2snLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRQZWJibGUgPSBkLm5hbWU7XG4gICAgICAgICAgICAgICAgb3V0c2lkZUNsaWNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmVkcmF3UGViYmxlcygpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignY29udGV4dG1lbnUnLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgLy8gcmlnaHQgY2xpY2sgb24gbm9kZVxuICAgICAgICAgICAgICAgIGQzLmV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZDMuZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgICAgICAgICByaWdodENsaWNrTGFzdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgbW91c2Vkb3duX25vZGUgPSBkO1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkX25vZGUgPSBtb3VzZWRvd25fbm9kZSA9PT0gc2VsZWN0ZWRfbm9kZSA/IG51bGwgOiBtb3VzZWRvd25fbm9kZTtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZF9saW5rID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIC8vIHJlcG9zaXRpb24gZHJhZyBsaW5lXG4gICAgICAgICAgICAgICAgZHJhZ19saW5lXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnbWFya2VyLWVuZCcsIGlzX2V4cGxvcmVfbW9kZT8gJ3VybCgjZW5kLW1hcmtlciknIDogJ3VybCgjZW5kLWFycm93KScpXG4gICAgICAgICAgICAgICAgICAgIC5jbGFzc2VkKCdoaWRkZW4nLCBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCAnTScgKyBtb3VzZWRvd25fbm9kZS54ICsgJywnICsgbW91c2Vkb3duX25vZGUueSArICdMJyArIG1vdXNlZG93bl9ub2RlLnggKyAnLCcgKyBtb3VzZWRvd25fbm9kZS55KTtcblxuICAgICAgICAgICAgICAgIHN2Zy5vbignbW91c2Vtb3ZlJywgbW91c2Vtb3ZlKTtcbiAgICAgICAgICAgICAgICByZXN0YXJ0KCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdtb3VzZXVwJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIGQzLmV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJpZ2h0Q2xpY2tMYXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0Q2xpY2tMYXN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFtb3VzZWRvd25fbm9kZSkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgLy8gbmVlZGVkIGJ5IEZGXG4gICAgICAgICAgICAgICAgZHJhZ19saW5lXG4gICAgICAgICAgICAgICAgICAgIC5jbGFzc2VkKCdoaWRkZW4nLCB0cnVlKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ21hcmtlci1lbmQnLCAnJyk7XG5cbiAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgZHJhZy10by1zZWxmXG4gICAgICAgICAgICAgICAgbW91c2V1cF9ub2RlID0gZDtcbiAgICAgICAgICAgICAgICBpZiAobW91c2V1cF9ub2RlID09PSBtb3VzZWRvd25fbm9kZSkge1xuICAgICAgICAgICAgICAgICAgICByZXNldE1vdXNlVmFycygpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gdW5lbmxhcmdlIHRhcmdldCBub2RlXG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmF0dHIoJ3RyYW5zZm9ybScsICcnKTtcblxuICAgICAgICAgICAgICAgIC8vIGFkZCBsaW5rIHRvIGdyYXBoICh1cGRhdGUgaWYgZXhpc3RzKVxuICAgICAgICAgICAgICAgIC8vIE5COiBsaW5rcyBhcmUgc3RyaWN0bHkgc291cmNlIDwgdGFyZ2V0OyBhcnJvd3Mgc2VwYXJhdGVseSBzcGVjaWZpZWQgYnkgYm9vbGVhbnNcbiAgICAgICAgICAgICAgICB2YXIgc291cmNlLCB0YXJnZXQsIGRpcmVjdGlvbjtcbiAgICAgICAgICAgICAgICBpZiAobW91c2Vkb3duX25vZGUuaWQgPCBtb3VzZXVwX25vZGUuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlID0gbW91c2Vkb3duX25vZGU7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IG1vdXNldXBfbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gJ3JpZ2h0JztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2UgPSBtb3VzZXVwX25vZGU7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IG1vdXNlZG93bl9ub2RlO1xuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSAnbGVmdCc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IGxpbmsgPSBsaW5rcy5maWx0ZXIoeCA9PiB4LnNvdXJjZSA9PSBzb3VyY2UgJiYgeC50YXJnZXQgPT0gdGFyZ2V0KVswXTtcbiAgICAgICAgICAgICAgICBpZiAobGluaykge1xuICAgICAgICAgICAgICAgICAgICBsaW5rW2RpcmVjdGlvbl0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmsgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodDogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgbGlua1tkaXJlY3Rpb25dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbGlua3MucHVzaChsaW5rKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBzZWxlY3QgbmV3IGxpbmtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZF9saW5rID0gbGluaztcbiAgICAgICAgICAgICAgICBzZWxlY3RlZF9ub2RlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBzdmcub24oJ21vdXNlbW92ZScsIG51bGwpO1xuXG4gICAgICAgICAgICAgICAgcmVzZXRNb3VzZVZhcnMoKTtcbiAgICAgICAgICAgICAgICByZXN0YXJ0KCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAvLyBzaG93IG5vZGUgbmFtZXNcbiAgICAgICAgZy5hcHBlbmQoJ3N2Zzp0ZXh0JylcbiAgICAgICAgICAgIC5hdHRyKCdpZCcsIGFwcGVuZCgncGViYmxlTGFiZWwnKSlcbiAgICAgICAgICAgIC5hdHRyKCd4JywgMClcbiAgICAgICAgICAgIC5hdHRyKCd5JywgMTUpXG4gICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnaWQnKVxuICAgICAgICAgICAgLnRleHQoZCA9PiBkLm5hbWUpO1xuXG4gICAgICAgIC8vIHNob3cgc3VtbWFyeSBzdGF0cyBvbiBtb3VzZW92ZXJcbiAgICAgICAgLy8gU1ZHIGRvZXNuJ3Qgc3VwcG9ydCB0ZXh0IHdyYXBwaW5nLCB1c2UgaHRtbCBpbnN0ZWFkXG4gICAgICAgIGcuc2VsZWN0QWxsKFwiY2lyY2xlLm5vZGVcIilcbiAgICAgICAgICAgIC5vbihcIm1vdXNlb3ZlclwiLCBkID0+IHtcblxuICAgICAgICAgICAgICAgIGQuZm9yZWZyb250ID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdFRhYiAhPT0gJ1N1bW1hcnknKSBsZWZ0VGFiSGlkZGVuID0gbGVmdFRhYjtcbiAgICAgICAgICAgICAgICAgICAgc2V0TGVmdFRhYignU3VtbWFyeScpO1xuICAgICAgICAgICAgICAgICAgICB2YXJTdW1tYXJ5KGQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGJ5SWQoJ3RyYW5zZm9ybWF0aW9ucycpLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnZGlzcGxheTpibG9jaycpO1xuICAgICAgICAgICAgICAgICAgICBieUlkKFwidHJhbnNTZWxcIikuc2VsZWN0ZWRJbmRleCA9IGQuaWQ7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybVZhciA9IHZhbHVlS2V5W2QuaWRdO1xuXG4gICAgICAgICAgICAgICAgICAgIG0ucmVkcmF3KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkLmZvcmVmcm9udCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBob3ZlclBlYmJsZSA9IGQubmFtZTtcblxuICAgICAgICAgICAgICAgICAgICBmaWxsKGQsIFwiZHZBcmNcIiwgLjEsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgICAgIGZpbGwoZCwgXCJkdlRleHRcIiwgLjUsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgICAgIGZpbGwoZCwgXCJnckFyY1wiLCAuMSwgMCwgMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgZmlsbChkLCBcImdyVGV4dFwiLCAuNSwgMCwgMTAwKTtcblxuICAgICAgICAgICAgICAgICAgICAvL2ZpbGwoZCwgXCJncjFpbmRpY2F0b3JcIiwgLjEsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgICAgIC8vZmlsbChkLCBcImdyMWluZGljYXRvclRleHRcIiwgLjEsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgICAgIC8vZmlsbChkLCBcImdyMmluZGljYXRvclwiLCAuMSwgMCwgMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgLy9maWxsKGQsIFwiZ3IyaW5kaWNhdG9yVGV4dFwiLCAuMSwgMCwgMTAwKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZC5kZWZhdWx0TnVtY2hhciA9PSBcIm51bWVyaWNcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbChkLCBcIm5vbUFyY1wiLCAuMSwgMCwgMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGwoZCwgXCJub21UZXh0XCIsIC41LCAwLCAxMDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbGwoZCwgXCJjc0FyY1wiLCAuMSwgMCwgMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgZmlsbChkLCBcImNzVGV4dFwiLCAuNSwgMCwgMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgZmlsbChkLCBcInRpbWVBcmNcIiwgLjEsIDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgICAgIGZpbGwoZCwgXCJ0aW1lVGV4dFwiLCAuNSwgMCwgMTAwKTtcbiAgICAgICAgICAgICAgICB9LCBob3ZlclRpbWVvdXQpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGQgPT4ge1xuICAgICAgICAgICAgICAgIGQuZm9yZWZyb250ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGhvdmVyUGViYmxlID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZFBlYmJsZSkgdmFyU3VtbWFyeShhbGxOb2Rlcy5maWx0ZXIoKG5vZGUpID0+IG5vZGUubmFtZSA9PT0gc2VsZWN0ZWRQZWJibGUpWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBzZXRMZWZ0VGFiKGxlZnRUYWJIaWRkZW4pO1xuICAgICAgICAgICAgICAgICAgICAnY3NBcmMgY3NUZXh0IHRpbWVBcmMgdGltZVRleHQgZHZBcmMgZHZUZXh0IG5vbUFyYyBub21UZXh0IGdyQXJjIGdyVGV4dCcuc3BsaXQoJyAnKS5tYXAoeCA9PiBmaWxsKGQsIHgsIDAsIDEwMCwgNTAwKSk7XG4gICAgICAgICAgICAgICAgICAgIG0ucmVkcmF3KCk7XG4gICAgICAgICAgICAgICAgfSwgaG92ZXJUaW1lb3V0KVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gdGhlIHRyYW5zZm9ybWF0aW9uIHZhcmlhYmxlIGxpc3QgaXMgc2lsZW50bHkgdXBkYXRlZCBhcyBwZWJibGVzIGFyZSBhZGRlZC9yZW1vdmVkXG4gICAgICAgIGQzLnNlbGVjdChcIiN0cmFuc1NlbFwiKVxuICAgICAgICAgICAgLnNlbGVjdEFsbCgnbGknKVxuICAgICAgICAgICAgLnJlbW92ZSgpO1xuXG4gICAgICAgIGQzLnNlbGVjdChcIiN0cmFuc1NlbFwiKVxuICAgICAgICAgICAgLnNlbGVjdEFsbCgnbGknKVxuICAgICAgICAgICAgLmRhdGEobm9kZXMubWFwKHggPT4geC5uYW1lKSkgLy8gc2V0IHRvIHZhcmlhYmxlcyBpbiBtb2RlbCBzcGFjZSBhcyB0aGV5J3JlIGFkZGVkXG4gICAgICAgICAgICAuZW50ZXIoKVxuICAgICAgICAgICAgLmFwcGVuZChcImxpXCIpXG4gICAgICAgICAgICAudGV4dChkID0+IGQpO1xuXG4gICAgICAgIGlmKCFJU19EM01fRE9NQUlOKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcjdHJhbnNTZWwgbGknKS5mb3JFYWNoKHggPT4geC5vbmNsaWNrKGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgICAgICAgIC8vIGlmICdpbnRlcmFjdGlvbicgaXMgdGhlIHNlbGVjdGVkIGZ1bmN0aW9uLCBkb24ndCBzaG93IHRoZSBmdW5jdGlvbiBsaXN0IGFnYWluXG4gICAgICAgICAgICAgICAgbGV0IHRJbnB1dCA9IGJ5SWQoJ3RJbnB1dCcpO1xuICAgICAgICAgICAgICAgIGlmIChzZWxJbnRlcmFjdCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbiA9IHRJbnB1dC52YWx1ZS5jb25jYXQodGhpcy50ZXh0Q29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgIHRJbnB1dC52YWx1ZSA9IG47XG4gICAgICAgICAgICAgICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHQgPSB0cmFuc1BhcnNlKG4gPSBuKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0KSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGZhZGVPdXQodGhpcy5wYXJlbnROb2RlLCAxMDApO1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm0obiA9IHQuc2xpY2UoMCwgdC5sZW5ndGggLSAxKSwgdCA9IHRbdC5sZW5ndGggLSAxXSwgdHlwZVRyYW5zZm9ybSA9IGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRJbnB1dC52YWx1ZSA9IHRoaXMudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgZmFkZU91dCh0aGlzLnBhcmVudE5vZGUsIDEwMCk7XG4gICAgICAgICAgICAgICAgZmFkZU91dCgnI3RyYW5zTGlzdCcsIDEwMCk7XG4gICAgICAgICAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHJlbW92ZSBvbGQgbm9kZXNcbiAgICAgICAgY2lyY2xlLmV4aXQoKS5yZW1vdmUoKTtcbiAgICAgICAgZm9yY2Uuc3RhcnQoKTtcblxuICAgICAgICAvLyBzYXZlIHdvcmtzcGFjZXNcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ29rIHdzJyk7XG4gICAgICAgIHJlY29yZF91c2VyX21ldGFkYXRhKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW91c2Vkb3duKGQpIHtcbiAgICAgICAgc2VsZWN0ZWRQZWJibGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8vIHByZXZlbnQgSS1iYXIgb24gZHJhZ1xuICAgICAgICBkMy5ldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAvLyBiZWNhdXNlIDphY3RpdmUgb25seSB3b3JrcyBpbiBXZWJLaXQ/XG4gICAgICAgIHN2Zy5jbGFzc2VkKCdhY3RpdmUnLCB0cnVlKTtcbiAgICAgICAgaWYgKGQzLmV2ZW50LmN0cmxLZXkgfHwgbW91c2Vkb3duX25vZGUgfHwgbW91c2Vkb3duX2xpbmspIHJldHVybjtcbiAgICAgICAgb3V0c2lkZUNsaWNrID0gdHJ1ZTtcbiAgICAgICAgcmVzdGFydCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vdXNlbW92ZShkKSB7XG4gICAgICAgIGlmICghbW91c2Vkb3duX25vZGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIHVwZGF0ZSBkcmFnIGxpbmVcbiAgICAgICAgZHJhZ19saW5lLmF0dHIoJ2QnLCAnTScgKyBtb3VzZWRvd25fbm9kZS54ICsgJywnICsgbW91c2Vkb3duX25vZGUueSArICdMJyArIGQzLm1vdXNlKHRoaXMpWzBdICsgJywnICsgZDMubW91c2UodGhpcylbMV0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vdXNldXAoZCkge1xuICAgICAgICBpZiAobW91c2Vkb3duX25vZGUpIHtcbiAgICAgICAgICAgIGRyYWdfbGluZVxuICAgICAgICAgICAgICAgIC5jbGFzc2VkKCdoaWRkZW4nLCB0cnVlKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnbWFya2VyLWVuZCcsICcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3V0c2lkZUNsaWNrKSB7XG4gICAgICAgICAgICBvdXRzaWRlQ2xpY2sgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChsZWZ0VGFiSGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgc2V0TGVmdFRhYihsZWZ0VGFiSGlkZGVuKTtcbiAgICAgICAgICAgICAgICBsZWZ0VGFiSGlkZGVuID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIG0ucmVkcmF3KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gYmVjYXVzZSA6YWN0aXZlIG9ubHkgd29ya3MgaW4gV2ViS2l0P1xuICAgICAgICBzdmcuY2xhc3NlZCgnYWN0aXZlJywgZmFsc2UpO1xuICAgICAgICAvLyBjbGVhciBtb3VzZSBldmVudCB2YXJzXG4gICAgICAgIHJlc2V0TW91c2VWYXJzKCk7XG4gICAgfVxuXG4gICAgLy8gYXBwIHN0YXJ0cyBoZXJlXG4gICAgc3ZnLmF0dHIoJ2lkJywgKCkgPT4gXCJ3aGl0ZXNwYWNlXCIuY29uY2F0KG15c3BhY2UpKVxuICAgICAgICAuYXR0cignaGVpZ2h0JywgaGVpZ2h0KVxuICAgICAgICAuYXR0cignd2lkdGgnLCB3aWR0aClcbiAgICAgICAgLm9uKCdtb3VzZWRvd24nLCBmdW5jdGlvbigpIHttb3VzZWRvd24odGhpcyk7fSlcbiAgICAgICAgLm9uKCdtb3VzZXVwJywgZnVuY3Rpb24oKSB7bW91c2V1cCh0aGlzKTt9KTtcblxuICAgIGQzLnNlbGVjdCh3aW5kb3cpXG4gICAgICAgIC5vbignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgICAvLyBhbGwgY2xpY2tzIHdpbGwgYnViYmxlIGhlcmUgdW5sZXNzIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICAgICAgICBmYWRlT3V0KCcjdHJhbnNMaXN0JywgMTAwKTtcbiAgICAgICAgICAgIGZhZGVPdXQoJyN0cmFuc1NlbCcsIDEwMCk7XG4gICAgICAgIH0pO1xuXG4gICAgcmVzdGFydCgpOyAvLyBpbml0aWFsaXplcyBmb3JjZS5sYXlvdXQoKVxuICAgIGZha2VDbGljaygpO1xuXG4gICAgaWYodjIgJiBJU19EM01fRE9NQUlOKSB7XG4gICAgICAgIHZhciBjbGlja19ldiA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiTW91c2VFdmVudHNcIik7XG4gICAgICAgIC8vIGluaXRpYWxpemUgdGhlIGV2ZW50XG4gICAgICAgIGNsaWNrX2V2LmluaXRFdmVudChcImNsaWNrXCIsIHRydWUgLyogYnViYmxlICovLCB0cnVlIC8qIGNhbmNlbGFibGUgKi8pO1xuICAgICAgICAvLyB0cmlnZ2VyIHRoZSBldmVudFxuICAgICAgICBsZXQgY2xpY2tJRCA9IFwiZHZBcmNcIitmaW5kTm9kZUluZGV4KG15dGFyZ2V0KTtcbiAgICAgICAgYnlJZChjbGlja0lEKS5kaXNwYXRjaEV2ZW50KGNsaWNrX2V2KTtcblxuICAgICAgICAvLyBUaGUgZGlzcGF0Y2hlZCBjbGljayBzZXRzIHRoZSBsZWZ0cGFuZWwuIFRoaXMgc3dpdGNoZXMgdGhlIHBhbmVsIGJhY2sgb24gcGFnZSBsb2FkXG4gICAgICAgIHNlbGVjdGVkUGViYmxlID0gdW5kZWZpbmVkO1xuICAgICAgICBtb3VzZXVwKCk7XG4gICAgfVxufVxuXG4vKiogbmVlZHMgZG9jICovXG5mdW5jdGlvbiBmaW5kKCRub2RlcywgbmFtZSkge1xuICAgIGZvciAobGV0IGkgaW4gJG5vZGVzKVxuICAgICAgICBpZiAoJG5vZGVzW2ldLm5hbWUgPT0gbmFtZSkgcmV0dXJuICRub2Rlc1tpXS5pZDtcbn1cblxuLyoqXG4gcmV0dXJucyBpZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZE5vZGVJbmRleChuYW1lLCB3aG9sZSkge1xuICAgIGZvciAobGV0IG5vZGUgb2YgYWxsTm9kZXMpXG4gICAgICAgIGlmIChub2RlLm5hbWUgPT09IG5hbWUpIHJldHVybiB3aG9sZSA/IG5vZGUgOiBub2RlLmlkO1xufVxuXG4vKiogbmVlZHMgZG9jICovXG5mdW5jdGlvbiBub2RlSW5kZXgobm9kZU5hbWUpIHtcbiAgICBmb3IgKGxldCBpIGluIG5vZGVzKVxuICAgICAgICBpZiAobm9kZXNbaV0ubmFtZSA9PT0gbm9kZU5hbWUpIHJldHVybiBpO1xufVxuXG4vKiogbmVlZHMgZG9jICovXG5leHBvcnQgZnVuY3Rpb24gZmluZE5vZGUobmFtZSkge1xuICAgIGZvciAobGV0IG4gb2YgYWxsTm9kZXMpXG4gICAgICAgIGlmIChuLm5hbWUgPT09IG5hbWUpXG4gICAgICAgICAgICByZXR1cm4gbjtcbn1cblxuLyoqIG5lZWRzIGRvYyAqL1xuZnVuY3Rpb24gdXBkYXRlTm9kZShpZCkge1xuICAgIGxldCBub2RlID0gZmluZE5vZGUoaWQpO1xuICAgIGlmIChub2RlLmdyYXlvdXQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIGxldCBuYW1lID0gbm9kZS5uYW1lO1xuICAgIGxldCBuYW1lcyA9ICgpID0+IG5vZGVzLm1hcChuID0+IG4ubmFtZSk7XG4gICAgaWYgKG5hbWVzKCkuaW5jbHVkZXMobmFtZSkpIHtcbiAgICAgICAgZGVsKG5vZGVzLCBub2RlLmluZGV4KTtcbiAgICAgICAgbGlua3NcbiAgICAgICAgICAgIC5maWx0ZXIobCA9PiBsLnNvdXJjZSA9PT0gbm9kZSB8fCBsLnRhcmdldCA9PT0gbm9kZSlcbiAgICAgICAgICAgIC5mb3JFYWNoKGwgPT4gZGVsKGxpbmtzLCAtMSwgbCkpO1xuICAgICAgICB6cGFyYW1zUmVzZXQobmFtZSk7XG5cbiAgICAgICAgLy8gcmVtb3ZlIG5vZGUgbmFtZSBmcm9tIGdyb3VwIGxpc3RzXG4gICAgICAgIG5vZGUuZ3JvdXAxICYmIGRlbCh6cGFyYW1zLnpncm91cDEsIC0xLCBuYW1lKTtcbiAgICAgICAgbm9kZS5ncm91cDIgJiYgZGVsKHpwYXJhbXMuemdyb3VwMiwgLTEsIG5hbWUpO1xuICAgICAgICBub2RlLmdyb3VwMSA9IG5vZGUuZ3JvdXAyID0gZmFsc2U7XG5cbiAgICAgICAgLy8gbm9kZSByZXNldCAtIHBlcmhhcHMgdGhpcyB3aWxsIGJlY29tZSBhIGhhcmQgcmVzZXQgYmFjayB0byBhbGwgb3JpZ2luYWwgYWxsTm9kZSB2YWx1ZXM/XG4gICAgICAgIG5vZGUubm9kZUNvbCA9IG5vZGUuYmFzZUNvbDtcbiAgICAgICAgbm9kZS5zdHJva2VDb2xvciA9IHNlbFZhckNvbG9yO1xuICAgICAgICBub2RlLnN0cm9rZVdpZHRoID0gJzEnO1xuXG4gICAgICAgIGJvcmRlclN0YXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZXMucHVzaChub2RlKTtcbiAgICB9XG4gICAgenBhcmFtcy56dmFycyA9IG5hbWVzKCk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuIGV2ZXJ5IHRpbWUgYSB2YXJpYWJsZSBpbiBsZWZ0cGFuZWwgaXMgY2xpY2tlZCwgbm9kZXMgdXBkYXRlcyBhbmQgYmFja2dyb3VuZCBjb2xvciBjaGFuZ2VzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGlja1ZhcihlbGVtKSB7XG4gICAgaWYgKHVwZGF0ZU5vZGUoZWxlbSkpIHtcbiAgICAgICAgLy8gcGFuZWxQbG90cygpOyBpcyB0aGlzIG5lY2Vzc2FyeT9cbiAgICAgICAgcmVzdGFydCgpO1xuICAgIH1cbn1cblxuLy8gVXNlZCBmb3IgbGVmdCBwYW5lbCB2YXJpYWJsZSBzZWFyY2hcbmV4cG9ydCBsZXQgbWF0Y2hlZFZhcmlhYmxlcyA9IFtdO1xuZXhwb3J0IGxldCBzZWFyY2hWYXJpYWJsZXMgPSB2YWwgPT4ge1xuICAgIG1hdGNoZWRWYXJpYWJsZXMubGVuZ3RoID0gMDtcbiAgICBsZXQgW290aGVycywgbWF0Y2hdID0gW1tdLCAobiwga2V5KSA9PiBuW2tleV0udG9Mb3dlckNhc2UoKS5pbmNsdWRlcyh2YWwudG9Mb3dlckNhc2UoKSldO1xuICAgIGFsbE5vZGVzLmZvckVhY2gobiA9PiBtYXRjaChuLCAnbmFtZScpIHx8IG1hdGNoKG4sICdsYWJsJykgPyBtYXRjaGVkVmFyaWFibGVzLnB1c2gobi5uYW1lKSA6IG90aGVycy5wdXNoKG4ubmFtZSkpO1xuICAgIHZhbHVlS2V5ID0gbWF0Y2hlZFZhcmlhYmxlcy5jb25jYXQob3RoZXJzKTtcblxuICAgIC8vIEp1c3QgYmVjYXVzZSBoYXZpbmcgZXZlcnkgdmFyaWFibGUgYm9yZGVyZWQgYWxsIHRoZSB0aW1lIGlzIG5vdCBwbGVhc2FudFxuICAgIGlmICh2YWwgPT09ICcnKSBtYXRjaGVkVmFyaWFibGVzLmxlbmd0aCA9IDA7XG59O1xuXG4vKipcbiBSZXRyaWV2ZSB0aGUgdmFyaWFibGUgbGlzdCBmcm9tIHRoZSBwcmVwcm9jZXNzIGRhdGEuXG4gVGhpcyBoZWxwcyBoYW5kbGUgdGhlIG5ldyBmb3JtYXQgYW5kICh0ZW1wb3JhcmlseSlcbiB0aGUgb2xkZXIgZm9ybWF0IGluIFBST0RVQ1RJT04gKHJwIDguMTQuMjAxNylcbiBcIm5ld1wiIHJlc3BvbnNlOlxuIHtcbiBcImRhdGFzZXRcIiA6IHsuLi59XG4gXCJ2YXJpYWJsZXNcIiA6IHtcbiBcInZhcjFcIiA6IHsuLi59LFxuIChldGMpXG4gfVxuIH1cbiBcIm9sZFwiIHJlc3BvbnNlOlxuIHtcbiBcInZhcjFcIiA6IHsuLi59LFxuIChldGMpXG4gfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VmFyaWFibGVEYXRhKGpzb24pIHtcbiAgICByZXR1cm4ganNvbi5oYXNPd25Qcm9wZXJ0eSgndmFyaWFibGVzJykgPyBqc29uLnZhcmlhYmxlcyA6IGpzb247XG59XG5cbi8qKlxuIGNhbGxlZCBieSBmb3JjZSBidXR0b25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcmNlU3dpdGNoKCkge1xuICAgIGZvcmNldG9nZ2xlID0gW2ZvcmNldG9nZ2xlWzBdID09ICd0cnVlJyA/ICdmYWxzZScgOiAndHJ1ZSddO1xuICAgIGlmIChmb3JjZXRvZ2dsZVswXSA9PT0gXCJmYWxzZVwiKSB7XG4gICAgICAgIGJ5SWQoJ2J0bkZvcmNlJykuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJidG4gYWN0aXZlXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGJ5SWQoJ2J0bkZvcmNlJykuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJidG4gYnRuLWRlZmF1bHRcIik7XG4gICAgICAgIGZha2VDbGljaygpO1xuICAgIH1cbn1cblxuLyoqIG5lZWRzIGRvYyAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhlbHBtYXRlcmlhbHModHlwZSkge1xuICAgIGlmKHR5cGU9PVwidmlkZW9cIil7XG4gICAgICAgIHZhciB3aW4gPSB3aW5kb3cub3BlbihcImh0dHA6Ly8ycmEudm4vZGVtb3MvZDNtaW50ZWdyYXRpb25kZW1vLm1wNFwiLCAnX2JsYW5rJyk7XG4gICAgICAgIHdpbi5mb2N1cygpO1xuICAgIH1lbHNle1xuICAgICAgICB2YXIgd2luID0gd2luZG93Lm9wZW4oXCJodHRwOi8vMnJhLnZuL3BhcGVycy90d29yYXZlbnMtZDNtZ3VpZGUucGRmXCIsICdfYmxhbmsnKTtcbiAgICAgICAgd2luLmZvY3VzKCk7XG4gICAgfVxuICAgIGNvbnNvbGUubG9nKHR5cGUpO1xufVxuXG4vKiogbmVlZHMgZG9jICovXG5leHBvcnQgbGV0IGxvY2tEZXNjcmlwdGlvbiA9IChzdGF0ZSkgPT4gbG9ja3RvZ2dsZSA9IHN0YXRlO1xuXG4vKiogbmVlZHMgZG9jICovXG5leHBvcnQgZnVuY3Rpb24gelBvcCgpIHtcbiAgICBpZiAoZGF0YXVybCkgenBhcmFtcy56ZGF0YXVybCA9IGRhdGF1cmw7XG4gICAgenBhcmFtcy56bW9kZWxjb3VudCA9IG1vZGVsQ291bnQ7XG4gICAgenBhcmFtcy56ZWRnZXMgPSBbXTtcbiAgICB6cGFyYW1zLnp2YXJzID0gW107XG4gICAgenBhcmFtcy56bmF0dXJlID0gW107XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBub2Rlcy5sZW5ndGg7IGorKykgeyAvL3BvcHVsYXRlIHp2YXJzIGFycmF5XG4gICAgICAgIHpwYXJhbXMuenZhcnMucHVzaChub2Rlc1tqXS5uYW1lKTtcbiAgICAgICAgenBhcmFtcy56bmF0dXJlLnB1c2gobm9kZXNbal0ubmF0dXJlKTtcbiAgICAgICAgbGV0IHRlbXAgPSBub2Rlc1tqXS5pZDtcbiAgICAgICAgenBhcmFtcy56c2V0eFtqXSA9IGFsbE5vZGVzW3RlbXBdLnNldHh2YWxzO1xuICAgICAgICB6cGFyYW1zLnpzdWJzZXRbal0gPSBhbGxOb2Rlc1t0ZW1wXS5zdWJzZXRyYW5nZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBsaW5rcy5sZW5ndGg7IGorKykgeyAvL3BvcHVsYXRlIHplZGdlcyBhcnJheVxuICAgICAgICAvL2NvcnJlY3QgdGhlIHNvdXJjZSB0YXJnZXQgb3JkZXJpbmcgZm9yIFplbGlnXG4gICAgICAgIGxldCBzcmN0Z3QgPSBsaW5rc1tqXS5sZWZ0ID09IGZhbHNlID9cbiAgICAgICAgICAgIFtsaW5rc1tqXS5zb3VyY2UubmFtZSwgbGlua3Nbal0udGFyZ2V0Lm5hbWVdIDpcbiAgICAgICAgICAgIFtsaW5rc1tqXS50YXJnZXQubmFtZSwgbGlua3Nbal0uc291cmNlLm5hbWVdO1xuICAgICAgICB6cGFyYW1zLnplZGdlcy5wdXNoKHNyY3RndCk7XG4gICAgfVxufVxuXG4vLyB3aGVuIHNlbGVjdGVkLCB0aGUga2V5L3ZhbHVlIFttb2RlXTogW3BpcGVsaW5lSURdIGlzIHNldC5cbmV4cG9ydCBsZXQgc2VsZWN0ZWRQaXBlbGluZSA9IHt9O1xuZXhwb3J0IGxldCBzZXRTZWxlY3RlZFBpcGVsaW5lID0gKHJlc3VsdCkgPT4ge1xuICAgIHNlbGVjdGVkUGlwZWxpbmVbY3VycmVudE1vZGVdID0gcmVzdWx0O1xuICAgIGlmIChjdXJyZW50TW9kZSA9PT0gJ21vZGVsJykge1xuICAgICAgICAvLyB0aGUgJ2ZpbmQnIGZ1bmN0aW9uIHdvdWxkIGhhdmUgYmVlbiBuaWNlIGhlcmUtLSBlczYgb25seS4gRmluZCBwaXBlbGluZSB3aXRoIFVJRCwgdGhlbiBwYXNzIHBpcGVsaW5lX2lkXG4gICAgICAgIGxldCBwaXBlbGluZSA9IHBpcGVsaW5lVGFibGUuZmlsdGVyKChyb3cpID0+IHJvd1swXSA9PSByZXN1bHQpWzBdO1xuICAgICAgICByZXN1bHRzcGxvdGluaXQocGlwZWxpbmVbMV0pO1xuICAgIH1cbn1cblxuZXhwb3J0IGxldCBwaXBlbGluZUhlYWRlciA9IFsnSGlkZGVuX1VJRCcsICdQaXBlbGluZUlEJywgJ01ldHJpYycsICdTY29yZSddO1xuZXhwb3J0IGxldCBwaXBlbGluZVRhYmxlO1xuXG5mdW5jdGlvbiBvblBpcGVsaW5lQ3JlYXRlKFBpcGVsaW5lQ3JlYXRlUmVzdWx0LCByb29rcGlwZSkge1xuICAgIC8vIHJwYyBHZXRFeGVjdXRlUGlwZWxpbmVSZXN1bHRzKFBpcGVsaW5lRXhlY3V0ZVJlc3VsdHNSZXF1ZXN0KSByZXR1cm5zIChzdHJlYW0gUGlwZWxpbmVFeGVjdXRlUmVzdWx0KSB7fVxuICAgIGVzdGltYXRlTGFkZGEuc3RvcCgpOyAvLyBzdG9wIHNwaW5uZXJcbiAgICBjb25zb2xlLmxvZyhQaXBlbGluZUNyZWF0ZVJlc3VsdCk7XG5cbiAgICAvLyBjaGFuZ2Ugc3RhdHVzIG9mIGJ1dHRvbnMgZm9yIGVzdGltYXRpbmcgcHJvYmxlbSBhbmQgbWFya2luZyBwcm9ibGVtIGFzIGZpbmlzaGVkXG4gICAgYnlJZChcImJ0bkVzdGltYXRlXCIpLmNsYXNzTGlzdC5yZW1vdmUoXCJidG4tc3VjY2Vzc1wiKTtcbiAgICBieUlkKFwiYnRuRXN0aW1hdGVcIikuY2xhc3NMaXN0LmFkZChcImJ0bi1kZWZhdWx0XCIpO1xuICAgIGJ5SWQoXCJidG5FbmRTZXNzaW9uXCIpLmNsYXNzTGlzdC5yZW1vdmUoXCJidG4tZGVmYXVsdFwiKTtcbiAgICBieUlkKFwiYnRuRW5kU2Vzc2lvblwiKS5jbGFzc0xpc3QuYWRkKFwiYnRuLXN1Y2Nlc3NcIik7XG5cbiAgICBsZXQgY29udGV4dCA9IGFwaVNlc3Npb24oenBhcmFtcy56c2Vzc2lvbmlkKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaTxQaXBlbGluZUNyZWF0ZVJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZihQaXBlbGluZUNyZWF0ZVJlc3VsdFtpXS5waXBlbGluZUlkIGluIGFsbFBpcGVsaW5lSW5mbykge1xuICAgICAgICAgICAgYWxsUGlwZWxpbmVJbmZvW1BpcGVsaW5lQ3JlYXRlUmVzdWx0W2ldLnBpcGVsaW5lSWRdPU9iamVjdC5hc3NpZ24oYWxsUGlwZWxpbmVJbmZvW1BpcGVsaW5lQ3JlYXRlUmVzdWx0W2ldLnBpcGVsaW5lSWRdLFBpcGVsaW5lQ3JlYXRlUmVzdWx0W2ldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFsbFBpcGVsaW5lSW5mb1tQaXBlbGluZUNyZWF0ZVJlc3VsdFtpXS5waXBlbGluZUlkXT1QaXBlbGluZUNyZWF0ZVJlc3VsdFtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zb2xlLmxvZyhhbGxQaXBlbGluZUluZm8pO1xuICAgIC8vIHRvIGdldCBhbGwgcGlwZWxpbmUgaWRzOiBPYmplY3Qua2V5cyhhbGxQaXBlbGluZUluZm8pXG5cbiAgICBwaXBlbGluZVRhYmxlID0gW107XG4gICAgZm9yKHZhciBrZXkgaW4gYWxsUGlwZWxpbmVJbmZvKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICAgIGNvbnNvbGUubG9nKGFsbFBpcGVsaW5lSW5mb1trZXldKTtcblxuICAgICAgICBpZihrZXkgPT0gXCJyb29rcGlwZVwiKXsgICAvLyBoYXBwZW5zIHdoZW4gbXVsdGlwbGUgQ3JlYXRlUGlwZWxpbmVzIGNhbGxzIGhhdmUgYmVlbiBtYWRlXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGlzIHdpbGwgTk9UIHJlcG9ydCB0aGUgcGlwZWxpbmUgdG8gdXNlciBpZiBwaXBlbGluZSBoYXMgZmFpbGVkLCBpZiBwaXBlbGluZSBpcyBzdGlsbCBydW5uaW5nLCBvciBpZiBpdCBoYXMgbm90IGNvbXBsZXRlZFxuICAgICAgICBpZihhbGxQaXBlbGluZUluZm9ba2V5XS5yZXNwb25zZUluZm8uc3RhdHVzLmRldGFpbHMgPT0gXCJQaXBlbGluZSBGYWlsZWRcIikgIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmKGFsbFBpcGVsaW5lSW5mb1trZXldLnByb2dyZXNzSW5mbyA9PSBcIlJVTk5JTkdcIikgIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG15aWQgPSBcIlwiO1xuICAgICAgICBsZXQgbXltZXRyaWMgPSBcIlwiO1xuICAgICAgICBsZXQgbXl2YWwgPSBcIlwiO1xuICAgICAgICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAgICBjb25zb2xlLmxvZyhhbGxQaXBlbGluZUluZm9ba2V5XS5wcm9ncmVzc0luZm8pO1xuICAgICAgICBsZXQgbXlzY29yZXMgPSBbXTtcbiAgICAgICAgaWYoYWxsUGlwZWxpbmVJbmZvW2tleV0ucHJvZ3Jlc3NJbmZvID09IFwiQ09NUExFVEVEXCIpe1xuICAgICAgICAgICAgbXlzY29yZXMgPSBhbGxQaXBlbGluZUluZm9ba2V5XS5waXBlbGluZUluZm8uc2NvcmVzO1xuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG15c2NvcmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy9pZihpPT0wKSB7bXlpZD1rZXk7fVxuICAgICAgICAgICAgICAgIC8vICAgZWxzZSBteWlkPVwiXCI7XG4gICAgICAgICAgICAgICAgbXlpZD1rZXk7XG4gICAgICAgICAgICAgICAgbXltZXRyaWM9bXlzY29yZXNbaV0ubWV0cmljO1xuICAgICAgICAgICAgICAgIG15dmFsPStteXNjb3Jlc1tpXS52YWx1ZS50b0ZpeGVkKDMpO1xuICAgICAgICAgICAgICAgIHBpcGVsaW5lVGFibGUucHVzaChbcGlwZWxpbmVUYWJsZS5sZW5ndGgsIG15aWQsIG15bWV0cmljLCBteXZhbF0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7IC8vIGlmIHByb2dyZXNzSW5mbyBpcyBub3QgXCJDT01QTEVURURcIlxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zb2xlLnRhYmxlKHBpcGVsaW5lVGFibGUsIFsxLCAyLCAzXSk7XG5cbiAgICBpZiAoSVNfRDNNX0RPTUFJTil7XG4gICAgICAgIGJ5SWQoXCJidG5TZXR4XCIpLmNsaWNrKCk7ICAgLy8gV2FzIFwiYnRuUmVzdWx0c1wiIC0gY2hhbmdpbmcgdG8gc2ltcGxpZnkgdXNlciBleHBlcmllbmNlIGZvciB0ZXN0aW5nLlxuICAgIH07XG5cbiAgICAvL2FkZGluZyByb29rcGlwZSB0byBhbGxQaXBlbGluZUluZm9cbiAgICBhbGxQaXBlbGluZUluZm8ucm9va3BpcGU9cm9va3BpcGU7ICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgc2V0dGluZyByb29rcGlwZSBmb3IgdGhlIGVudGlyZSB0YWJsZSwgYnV0IHdoZW4gdGhlcmUgYXJlIG11bHRpcGxlIENyZWF0ZVBpcGVsaW5lcyBjYWxscywgdGhpcyBpcyBvbmx5IHJlY29yZGluZyBsYXRlc3QgdmFsdWVzXG5cbiAgICAvLyB0aGlzIGluaXRpYWxpemVzIHRoZSByZXN1bHRzIHdpbmRvd3MgdXNpbmcgdGhlIGZpcnN0IHBpcGVsaW5lIElEXG4gICAgaWYoIXN3YW5kaXZlKSB7XG4gICAgICAgIHJlc3VsdHNwbG90aW5pdChwaXBlbGluZVRhYmxlWzBdWzFdKTtcbiAgICB9XG4gICAgLy8gVkpEOiB0aGVzZSB0d28gZnVuY3Rpb25zIGFyZSBidWlsdCBhbmQgKEkgYmVsaWV2ZSkgZnVuY3Rpb25pbmcgYXMgaW50ZW5kZWQuIFRoZXNlIGV4ZXJjaXNlIHR3byBjb3JlIEFQSSBjYWxscyB0aGF0IGFyZSBjdXJyZW50bHkgdW5uZWNlc3NhcnlcbiAgICAvL2V4cG9ydHBpcGVsaW5lKHBpcGVsaW5lVGFibGVbMV1bMV0pO1xuICAgIC8vbGlzdHBpcGVsaW5lcygpO1xuXG4gICAgLy8gVkpEOiB0aGlzIGlzIGEgdGhpcmQgY29yZSBBUEkgY2FsbCB0aGF0IGlzIGN1cnJlbnRseSB1bm5lY2Vzc2FyeVxuICAgIC8vbGV0IHBpcGVsaW5laWQgPSBQaXBlbGluZUNyZWF0ZVJlc3VsdC5waXBlbGluZWlkO1xuICAgIC8vIGdldGV4ZWN1dGVwaXBlbGluZXJlc3VsdHMgaXMgdGhlIHRoaXJkIHRvIGJlIGNhbGxlZFxuICAvLyAgbWFrZVJlcXVlc3QoRDNNX1NWQ19VUkwgKyAnL2dldGV4ZWN1dGVwaXBlbGluZXJlc3VsdHMnLCB7Y29udGV4dCwgcGlwZWxpbmVfaWRzOiBPYmplY3Qua2V5cyhhbGxQaXBlbGluZUluZm8pfSk7XG59XG5cbmZ1bmN0aW9uIENyZWF0ZVBpcGVsaW5lRGF0YShwcmVkaWN0b3JzLCBkZXB2YXIsIGF1eCkge1xuICAgIGxldCBjb250ZXh0ID0gYXBpU2Vzc2lvbih6cGFyYW1zLnpzZXNzaW9uaWQpO1xuICAgIGxldCB1cmlDc3YgPSB6cGFyYW1zLnpkM21kYXRhO1xuICAgIGxldCB1cmlKc29uID0gdXJpQ3N2LnN1YnN0cmluZygwLCB1cmlDc3YubGFzdEluZGV4T2YoXCIvdGFibGVzXCIpKSArIFwiL2RhdGFzZXREb2MuanNvblwiO1xuICAgIGxldCB0YXJnZXRGZWF0dXJlcyA9IFt7ICdyZXNvdXJjZV9pZCc6IFwiMFwiLCAnZmVhdHVyZV9uYW1lJzogZGVwdmFyWzBdIH1dO1xuICAgIGxldCBwcmVkaWN0RmVhdHVyZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByZWRpY3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcHJlZGljdEZlYXR1cmVzW2ldID0geyAncmVzb3VyY2VfaWQnOiBcIjBcIiwgJ2ZlYXR1cmVfbmFtZSc6IHByZWRpY3RvcnNbaV0gfTtcbiAgICB9XG4gICAgaWYodHlwZW9mIGF1eD09PVwidW5kZWZpbmVkXCIpIHsgLy9kZWZhdWx0IGJlaGF2aW9yIGZvciBjcmVhdGluZyBwaXBlbGluZSBkYXRhXG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgZGF0YXNldF91cmk6IHVyaUpzb24sICAgLy8gdXJpQ3N2IGlzIGFsc28gdmFsaWQsIGJ1dCBub3QgY3VycmVudGx5IGFjY2VwdGVkIGJ5IElTSSBUQTJcbiAgICAgICAgdGFzazogZDNtVGFza1R5cGVbZDNtUHJvYmxlbURlc2NyaXB0aW9uLnRhc2tUeXBlXVsxXSxcbiAgICAgICAgdGFza1N1YnR5cGU6IGQzbVRhc2tTdWJ0eXBlW2QzbVByb2JsZW1EZXNjcmlwdGlvbi50YXNrU3VidHlwZV1bMV0sXG4gICAgICAgIHRhc2tEZXNjcmlwdGlvbjogZDNtUHJvYmxlbURlc2NyaXB0aW9uLnRhc2tEZXNjcmlwdGlvbixcbiAgICAgICAgb3V0cHV0OiBcIk9VVFBVVF9UWVBFX1VOREVGSU5FRFwiLCAgLy8gdmFsaWQgdmFsdWVzIHdpbGwgY29tZSBpbiBmdXR1cmUgQVBJXG4gICAgICAgIG1ldHJpY3M6IFtkM21NZXRyaWNzW2QzbVByb2JsZW1EZXNjcmlwdGlvbi5tZXRyaWNdWzFdXSxcbiAgICAgICAgdGFyZ2V0RmVhdHVyZXMsXG4gICAgICAgIC8qIEV4YW1wbGU6XG4gICAgICAgICAgXCJ0YXJnZXRGZWF0dXJlc1wiOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgICBcInJlc291cmNlX2lkXCI6IFwiMFwiLFxuICAgICAgICAgICAgICBcImZlYXR1cmVfbmFtZVwiOiBcIkF0X2JhdHNcIlxuICAgICAgICAgIH1cbiAgICAgICAgICBdLFxuICAgICAgICAqL1xuICAgICAgICBwcmVkaWN0RmVhdHVyZXMsXG4gICAgICAgIC8qIEV4YW1wbGU6XG4gICAgICAgICAgXCJwcmVkaWN0UmVhdHVyZXNcIjogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIFwicmVzb3VyY2VfaWRcIjogXCIwXCIsXG4gICAgICAgICAgICBcImZlYXR1cmVfbmFtZVwiOiBcIlJCSXNcIlxuICAgICAgICAgIH1cbiAgICAgICAgICBdLFxuICAgICAgICAqL1xuICAgICAgICBtYXhQaXBlbGluZXM6IDUgLy91c2VyIHRvIHNwZWNpZnkgdGhpcyBldmVudHVhbGx5P1xuICAgIH07fVxuICAgIGVsc2UgeyAvL2NyZWF0aW5nIHBpcGVsaW5lIGRhdGEgZm9yIHByb2JsZW0gZGlzY292ZXJ5IHVzaW5nIGF1eCBpbnB1dHNcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgZGF0YXNldF91cmk6IHVyaUpzb24sICAgLy8gdXJpQ3N2IGlzIGFsc28gdmFsaWQsIGJ1dCBub3QgY3VycmVudGx5IGFjY2VwdGVkIGJ5IElTSSBUQTJcbiAgICAgICAgdGFzazogYXV4LnRhc2ssXG4gICAgICAgIHRhc2tTdWJ0eXBlOiBcIlRBU0tfU1VCVFlQRV9VTkRFRklORURcIixcbiAgICAgICAgdGFza0Rlc2NyaXB0aW9uOiBhdXguZGVzY3JpcHRpb24sXG4gICAgICAgIG91dHB1dDogXCJPVVRQVVRfVFlQRV9VTkRFRklORURcIixcbiAgICAgICAgbWV0cmljczogW2F1eC5tZXRyaWNzXSxcbiAgICAgICAgdGFyZ2V0RmVhdHVyZXMsXG4gICAgICAgIHByZWRpY3RGZWF0dXJlcyxcbiAgICAgICAgbWF4UGlwZWxpbmVzOiAxXG4gICAgICAgIH07XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZG93bmxvYWRJbmNvbXBsZXRlKCkge1xuICAgIGlmIChQUk9EVUNUSU9OICYmIHpwYXJhbXMuenNlc3Npb25pZCA9PT0gJycpIHtcbiAgICAgICAgYWxlcnQoJ1dhcm5pbmc6IERhdGEgZG93bmxvYWQgaXMgbm90IGNvbXBsZXRlLiBUcnkgYWdhaW4gc29vbi4nKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gICAgY2FsbGVkIGJ5IGNsaWNraW5nICdTb2x2ZSBUaGlzIFByb2JsZW0nIGluIG1vZGVsIG1vZGVcbiovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZXN0aW1hdGUoYnRuKSB7XG4gICAgaWYgKCFJU19EM01fRE9NQUlOKXtcbiAgICAgICAgaWYgKGRvd25sb2FkSW5jb21wbGV0ZSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB6UG9wKCk7XG4gICAgICAgIC8vIHdyaXRlIGxpbmtzIHRvIGZpbGUgJiBydW4gUiBDTURcbiAgICAgICAgLy8gcGFja2FnZSB0aGUgb3V0cHV0IGFzIEpTT05cbiAgICAgICAgLy8gYWRkIGNhbGwgaGlzdG9yeSBhbmQgcGFja2FnZSB0aGUgenBhcmFtcyBvYmplY3QgYXMgSlNPTlxuICAgICAgICB6cGFyYW1zLmNhbGxIaXN0b3J5ID0gY2FsbEhpc3Rvcnk7XG4gICAgICAgIHpwYXJhbXMuYWxsVmFycyA9IHZhbHVlS2V5LnNsaWNlKDEwLCAyNSk7IC8vIGJlY2F1c2UgdGhlIFVSTCBpcyB0b28gbG9uZy4uLlxuXG4gICAgICAgIC8qIFVOVVNFRFxuICAgICAgICB2YXIgc2VsZWN0b3J1cmxjYWxsID0gUk9PS19TVkNfVVJMICsgXCJzZWxlY3RvcmFwcFwiO1xuICAgICAgICBmdW5jdGlvbiBzZWxlY3RvclN1Y2Nlc3MoYnRuLCBqc29uKSB7XG4gICAgICAgICAgICBkMy5zZWxlY3QoXCIjdGlja2VyXCIpXG4gICAgICAgICAgICAgICAgLnRleHQoXCJTdWdnZXN0ZWQgdmFyaWFibGVzIGFuZCBwZXJjZW50IGltcHJvdmVtZW50IG9uIFJNU0U6IFwiICsganNvbi52YXJzKTtcbiAgICAgICAgICAgIGNkYihcInNlbGVjdG9yU3VjY2VzczogXCIsIGpzb24pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNlbGVjdG9yRmFpbChidG4pIHtcbiAgICAgICAgICAgIGFsZXJ0KFwiU2VsZWN0b3IgRmFpbFwiKTtcbiAgICAgICAgfVxuICAgICAgICAqL1xuXG4gICAgICAgIGVzdGltYXRlTGFkZGEuc3RhcnQoKTsgLy8gc3RhcnQgc3Bpbm5lclxuICAgICAgICBsZXQganNvbiA9IGF3YWl0IG1ha2VSZXF1ZXN0KFJPT0tfU1ZDX1VSTCArICd6ZWxpZ2FwcCcsIHpwYXJhbXMpO1xuICAgICAgICBpZiAoIWpzb24pIHtcbiAgICAgICAgICAgIGVzdGltYXRlZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbGxSZXN1bHRzLnB1c2goanNvbik7XG4gICAgICAgICAgICBpZiAoIWVzdGltYXRlZCkgYnlJZChcInRhYlJlc3VsdHNcIikucmVtb3ZlQ2hpbGQoYnlJZChcInJlc3VsdHNIb2xkZXJcIikpO1xuXG4gICAgICAgICAgICBlc3RpbWF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgZDMuc2VsZWN0KFwiI3RhYlJlc3VsdHNcIilcbiAgICAgICAgICAgICAgICAuc3R5bGUoXCJkaXNwbGF5XCIsIFwiYmxvY2tcIik7XG4gICAgICAgICAgICBkMy5zZWxlY3QoXCIjcmVzdWx0c1ZpZXdcIilcbiAgICAgICAgICAgICAgICAuc3R5bGUoXCJkaXNwbGF5XCIsIFwiYmxvY2tcIik7XG4gICAgICAgICAgICBkMy5zZWxlY3QoXCIjbW9kZWxWaWV3XCIpXG4gICAgICAgICAgICAgICAgLnN0eWxlKFwiZGlzcGxheVwiLCBcImJsb2NrXCIpO1xuXG4gICAgICAgICAgICAvLyBwcm9ncmFtbWF0aWMgY2xpY2sgb24gUmVzdWx0cyBidXR0b25cbiAgICAgICAgICAgIHRyaWdnZXIoXCJidG5TZXR4XCIsIFwiY2xpY2tcIik7IC8vIFdhcyBcImJ0blJlc3VsdHNcIiAtIGNoYW5naW5nIHRvIHNpbXBsaWZ5IHVzZXIgZXhwZXJpZW5jZSBmb3IgdGVzdGluZy5cblxuICAgICAgICAgICAgbGV0IG1vZGVsID0gXCJNb2RlbFwiLmNvbmNhdChtb2RlbENvdW50ID0gbW9kZWxDb3VudCArIDEpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBtb2RDb2woKSB7XG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KFwiI21vZGVsVmlld1wiKVxuICAgICAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKFwicFwiKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ2JhY2tncm91bmQtY29sb3InLCBoZXhUb1JnYmEodmFyQ29sb3IpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1vZENvbCgpO1xuXG4gICAgICAgICAgICBkMy5zZWxlY3QoXCIjbW9kZWxWaWV3XCIpXG4gICAgICAgICAgICAgICAgLmluc2VydChcInBcIiwgXCI6Zmlyc3QtY2hpbGRcIikgLy8gdG9wIHN0YWNrIGZvciByZXN1bHRzXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBtb2RlbClcbiAgICAgICAgICAgICAgICAudGV4dChtb2RlbClcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2JhY2tncm91bmQtY29sb3InLCBoZXhUb1JnYmEoc2VsVmFyQ29sb3IpKVxuICAgICAgICAgICAgICAgIC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IHRoaXMuc3R5bGUuYmFja2dyb3VuZENvbG9yLnJlcGxhY2UoL1xccyovZywgXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiID0gaGV4VG9SZ2JhKHNlbFZhckNvbG9yKS5yZXBsYWNlKC9cXHMqL2csIFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYS5zdWJzdHIoMCwgMTcpID09IGIuc3Vic3RyKDAsIDE3KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gZXNjYXBlIGZ1bmN0aW9uIGlmIGRpc3BsYXllZCBtb2RlbCBpcyBjbGlja2VkXG4gICAgICAgICAgICAgICAgICAgIG1vZENvbCgpO1xuICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnYmFja2dyb3VuZC1jb2xvcicsIGhleFRvUmdiYShzZWxWYXJDb2xvcikpO1xuICAgICAgICAgICAgICAgICAgICB2aXoodGhpcy5pZCk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGxldCByQ2FsbCA9IFtqc29uLmNhbGxdO1xuICAgICAgICAgICAgc2hvd0xvZygnZXN0aW1hdGUnLCByQ2FsbCk7XG5cbiAgICAgICAgICAgIHZpeihtb2RlbCk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHN3YW5kaXZlKSB7IC8vIElTX0QzTV9ET01BSU4gYW5kIHN3YW5kaXZlIGlzIHRydWVcbiAgICAgICAgelBvcCgpO1xuICAgICAgICB6cGFyYW1zLmNhbGxIaXN0b3J5ID0gY2FsbEhpc3Rvcnk7XG5cbiAgICAgICAgbGV0IG15dmtpID0gdmFsdWVLZXkuaW5kZXhPZihteXRhcmdldCk7XG4gICAgICAgIGlmKG15dmtpICE9IC0xKSB7XG4gICAgICAgICAgICBkZWwodmFsdWVLZXksIG15dmtpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVzdGltYXRlTGFkZGEuc3RhcnQoKTsgLy8gc3RhcnQgc3Bpbm5lclxuICAgICAgICBsZXQgcmVzID0gYXdhaXQgbWFrZVJlcXVlc3QoRDNNX1NWQ19VUkwgKyAnL0NyZWF0ZVBpcGVsaW5lcycsIENyZWF0ZVBpcGVsaW5lRGF0YSh2YWx1ZUtleSwgbXl0YXJnZXQpKTtcbiAgICAgICAgcmVzICYmIG9uUGlwZWxpbmVDcmVhdGUocmVzKTtcbiAgICB9IGVsc2UgeyAvLyB3ZSBhcmUgaW4gSVNfRDNNX0RPTUFJTiBubyBzd2FuZGl2ZVxuICAgICAgICAvLyBycGMgQ3JlYXRlUGlwZWxpbmVzKFBpcGVsaW5lQ3JlYXRlUmVxdWVzdCkgcmV0dXJucyAoc3RyZWFtIFBpcGVsaW5lQ3JlYXRlUmVzdWx0KSB7fVxuICAgICAgICB6UG9wKCk7XG4gICAgICAgIHpwYXJhbXMuY2FsbEhpc3RvcnkgPSBjYWxsSGlzdG9yeTtcblxuICAgICAgICAvLyBwaXBlbGluZWFwcCBpcyBhIHJvb2sgYXBwbGljYXRpb24gdGhhdCByZXR1cm5zIHRoZSBkZXBlbmRlbnQgdmFyaWFibGUsIHRoZSBEViB2YWx1ZXMsIGFuZCB0aGUgcHJlZGljdG9ycy4gY2FuIHRoaW5rIG9mIGl0IHdhcyBhIHdheSB0byB0cmFuc2xhdGUgdGhlIHBvdGVudGlhbGx5IGNvbXBsZXggZ3JhbW1hciBmcm9tIHRoZSBVSVxuXG4gICAgICAgIGVzdGltYXRlTGFkZGEuc3RhcnQoKTsgLy8gc3RhcnQgc3Bpbm5lclxuXG4gICAgICAgIC8vIDEuIFNvbWUgZGlhZ25vc3RpYyB0ZXN0cyB0byBhZGQgc3BlY2lhbCBjaGFyYWN0ZXJzIHRvIHRoZSBwaXBlbGluZWFwcCBjYWxsOlxuICAgICAgICAvL3pwYXJhbXMuemdyb3VwMS51bnNoaWZ0KFwiYmxhaCtcIik7XG4gICAgICAgIC8venBhcmFtcy56Z3JvdXAxLnVuc2hpZnQoXCJBbGljZS13YXNfYmVnIW5eaW5nIHQqIGdldC8gdmUjeSB0aXJlZCBvZiBzKHR0KW5nIGJ5IGhlciBzaSRcXCtlciBvbiB0aD0gYmFuayAmIG9mIGhhdmluZyBub3RoaW5nIHRvIGRvOlwiKTtcblxuICAgICAgICAvLyAyLiBOb3RlIGhvdyB0aGV5IGdvIG91dCBpbiBjYWxsOlxuICAgICAgICAvL2NvbnNvbGUubG9nKFwienBhcmFtcyB6Z3JvdXAxXCIpO1xuICAgICAgICAvL2NvbnNvbGUubG9nKHpwYXJhbXMuemdyb3VwMSk7ICAgICAgLy8gTm90aWNlIHpncm91cDEgaXMgYmVpbmcgc2VudCB3aXRoIGNvcnJlY3QgY2hhcmFjdGVyc1xuXG4gICAgICAgIGxldCByb29rcGlwZSA9IGF3YWl0IG1ha2VSZXF1ZXN0KFJPT0tfU1ZDX1VSTCArICdwaXBlbGluZWFwcCcsIHpwYXJhbXMpO1xuXG4gICAgICAgIC8vIDMuIEFuZCBjaGVjayB0aGV5IGNvbWUgYmFjayBjb3JyZWN0bHkgZm9ybWVkOlxuICAgICAgICAvL2NvbnNvbGUubG9nKFwicGlwZWxpbmUgYXBwIHJldHVybiAocm9va3BpcGUpXCIpO1xuICAgICAgICAvL2NvbnNvbGUubG9nKHJvb2twaXBlKTtcblxuICAgICAgICBpZiAoIXJvb2twaXBlKSB7XG4gICAgICAgICAgICBlc3RpbWF0ZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBzZXR4VGFibGUocm9va3BpcGUucHJlZGljdG9ycyk7XG4gICAgICAgLy8gICAgIGxldCBkdnZhbHMgPSByZXMuZHZ2YWx1ZXM7XG4gICAgICAgIC8vICAgIGxldCBkdnZhciA9IHJlcy5kZXB2YXJbMF07XG4gICAgICAgICAgbGV0IHJlcyA9IGF3YWl0IG1ha2VSZXF1ZXN0KEQzTV9TVkNfVVJMICsgJy9DcmVhdGVQaXBlbGluZXMnLCBDcmVhdGVQaXBlbGluZURhdGEocm9va3BpcGUucHJlZGljdG9ycywgcm9va3BpcGUuZGVwdmFyKSk7XG4gICAgICAgICAvLyAgIHJlcyA9IGF3YWl0IG1ha2VSZXF1ZXN0KFJPT0tfU1ZDX1VSTCArICdjcmVhdGVwaXBlbGluZScsIHpwYXJhbXMpO1xuICAgICAgICAgICAgcmVzICYmIG9uUGlwZWxpbmVDcmVhdGUocmVzLCByb29rcGlwZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGFzazJfZmluaXNoZWQgPSB0cnVlO1xufVxuXG4vKiogbmVlZHMgZG9jICovXG5leHBvcnQgZnVuY3Rpb24gdGEyc3R1ZmYoKSB7XG4gICAgY29uc29sZS5sb2coZDNtUHJvYmxlbURlc2NyaXB0aW9uKTtcbn1cblxuLyoqIG5lZWRzIGRvYyAqL1xuYXN5bmMgZnVuY3Rpb24gZGF0YURvd25sb2FkKCkge1xuICAgIHpQb3AoKTtcbiAgICAvLyB3cml0ZSBsaW5rcyB0byBmaWxlICYgcnVuIFIgQ01EXG5cbiAgICAvLyBwYWNrYWdlIHRoZSBvdXRwdXQgYXMgSlNPTlxuICAgIC8vIGFkZCBjYWxsIGhpc3RvcnkgYW5kIHBhY2thZ2UgdGhlIHpwYXJhbXMgb2JqZWN0IGFzIEpTT05cbiAgICBsZXQgcmVzID0gYXdhaXQgbWFrZVJlcXVlc3QoUk9PS19TVkNfVVJMICsgJ2RhdGFhcHAnLCB6cGFyYW1zKTtcbiAgICBpZiAoIXJlcykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgenBhcmFtcy56c2Vzc2lvbmlkID0gcmVzLnNlc3Npb25pZFswXTtcbiAgICAvLyBzZXQgbGluayBVUkxcbiAgICBieUlkKFwibG9nSURcIikuaHJlZiA9IGAke1BST0RVQ1RJT04gPyBST09LX1NWQ19VUkwgKyAnbG9nX2Rpci9sb2dfJyA6ICdyb29rL2xvZ18nIH0ke3pwYXJhbXMuenNlc3Npb25pZH0udHh0YDtcbn1cblxuLyoqIG5lZWRzIGRvYyAqL1xuZnVuY3Rpb24gdml6KG15bSkge1xuICAgIG15bSA9ICtteW0uc3Vic3RyKDUsIDUpIC0gMTtcblxuICAgIGxldCByZW1vdmVLaWRzID0gcGFyZW50ID0+IHtcbiAgICAgICAgd2hpbGUgKHBhcmVudC5maXJzdENoaWxkKVxuICAgICAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKHBhcmVudC5maXJzdENoaWxkKTtcbiAgICB9O1xuICAgIHJlbW92ZUtpZHMoYnlJZChcInJlc3VsdHNWaWV3XCIpKTtcblxuICAgIGxldCBqc29uID0gYWxsUmVzdWx0c1tteW1dO1xuXG4gICAgLy8gcGlwZSBpbiBmaWd1cmVzIHRvIHJpZ2h0IHBhbmVsXG4gICAgdmFyIGZpbGVsaXN0ID0gbmV3IEFycmF5O1xuICAgIGZvciAodmFyIGkgaW4ganNvbi5pbWFnZXMpIHtcbiAgICAgICAgdmFyIHpmaWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgICAgICB6ZmlnLnNldEF0dHJpYnV0ZShcInNyY1wiLCBqc29uLmltYWdlc1tpXSk7XG4gICAgICAgIHpmaWcuc2V0QXR0cmlidXRlKCd3aWR0aCcsIDIwMCk7XG4gICAgICAgIHpmaWcuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAyMDApO1xuICAgICAgICBieUlkKFwicmVzdWx0c1ZpZXdcIikuYXBwZW5kQ2hpbGQoemZpZyk7XG4gICAgfVxuXG4gICAgLy8gd3JpdGUgdGhlIHJlc3VsdHMgdGFibGVcbiAgICB2YXIgcmVzdWx0c0FycmF5ID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIGpzb24uc3VtSW5mbykge1xuICAgICAgICBpZiAoa2V5ID09ICdjb2xuYW1lcycpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgcmVzdWx0c0FycmF5LnB1c2goanNvbi5zdW1JbmZvW2tleV0pO1xuICAgIH1cblxuICAgIHZhciB0YWJsZSA9IGQzLnNlbGVjdChcIiNyZXN1bHRzVmlld1wiKVxuICAgICAgICAuYXBwZW5kKFwicFwiKVxuICAgICAgICAuYXBwZW5kKFwidGFibGVcIik7XG5cbiAgICB2YXIgdGhlYWQgPSB0YWJsZS5hcHBlbmQoXCJ0aGVhZFwiKTtcbiAgICB0aGVhZC5hcHBlbmQoXCJ0clwiKVxuICAgICAgICAuc2VsZWN0QWxsKFwidGhcIilcbiAgICAgICAgLmRhdGEoanNvbi5zdW1JbmZvLmNvbG5hbWVzKVxuICAgICAgICAuZW50ZXIoKVxuICAgICAgICAuYXBwZW5kKFwidGhcIilcbiAgICAgICAgLnRleHQoZCA9PiBkKTtcblxuICAgIHZhciB0Ym9keSA9IHRhYmxlLmFwcGVuZChcInRib2R5XCIpO1xuICAgIHRib2R5LnNlbGVjdEFsbChcInRyXCIpXG4gICAgICAgIC5kYXRhKHJlc3VsdHNBcnJheSlcbiAgICAgICAgLmVudGVyKCkuYXBwZW5kKFwidHJcIilcbiAgICAgICAgLnNlbGVjdEFsbChcInRkXCIpXG4gICAgICAgIC5kYXRhKGQgPT4gZClcbiAgICAgICAgLmVudGVyKCkuYXBwZW5kKFwidGRcIilcbiAgICAgICAgLnRleHQoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgdmFyIG15TnVtID0gTnVtYmVyKGQpO1xuICAgICAgICAgICAgaWYgKGlzTmFOKG15TnVtKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgICAgIHJldHVybiBteU51bS50b1ByZWNpc2lvbigzKTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnN0eWxlKFwiYmFja2dyb3VuZC1jb2xvclwiLCBcImFsaWNlYmx1ZVwiKTtcbiAgICAgICAgfSkgLy8gZm9yIG5vIGRpc2Nlcm5hYmxlIHJlYXNvblxuICAgICAgICAub24oXCJtb3VzZW91dFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5zdHlsZShcImJhY2tncm91bmQtY29sb3JcIiwgXCIjRjlGOUY5XCIpO1xuICAgICAgICB9KTsgLy8oYnV0IG1heWJlIHdlJ2xsIHRoaW5rIG9mIG9uZSlcblxuICAgIGQzLnNlbGVjdChcIiNyZXN1bHRzVmlld1wiKVxuICAgICAgICAuYXBwZW5kKFwicFwiKVxuICAgICAgICAuaHRtbCgoKSA9PiBcIjxiPkZvcm11bGE6IDwvYj5cIi5jb25jYXQoanNvbi5jYWxsWzBdKSk7XG5cbiAgICBtLnJlZHJhdygpO1xufVxuXG4vKipcbiAgIHBhcnNlcyB0aGUgdHJhbnNmb3JtYXRpb24gaW5wdXQuXG4gICB2YXJpYWJsZSBuYW1lcyBhcmUgb2Z0ZW4gbmVzdGVkIGluc2lkZSBvbmUgYW5vdGhlciwgZS5nLiwgZXRod2FyLCB3YXIsIHdhcnMsIGFuZCBzbyB0aGlzIGlzIGhhbmRsZWRcbiovXG5mdW5jdGlvbiB0cmFuc1BhcnNlKG4pIHtcbiAgICB2YXIgb3V0MiA9IFtdO1xuICAgIHZhciB0MiA9IG47XG4gICAgdmFyIGsyID0gMDtcbiAgICB2YXIgc3ViTWUyID0gXCJfdHJhbnN2YXJcIi5jb25jYXQoazIpO1xuICAgIHZhciBpbmRleGVkID0gW107XG5cbiAgICAvLyBvdXQyIGlzIGFsbCBtYXRjaGVkIHZhcmlhYmxlcywgaW5kZXhlZCBpcyBhbiBhcnJheSwgZWFjaCBlbGVtZW50IGlzIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBtYXRjaGVkIHZhcmlhYmxlcyBzdGFydGluZyBpbmRleCBhbmQgZmluaXNoaW5nIGluZGV4LiAgZS5nLiwgbj1cIndhcnMrMlwiLCBvdXQyPVt3YXIsIHdhcnNdLCBpbmRleGVkPVt7MCwyfSx7MCwzfV1cbiAgICBmb3IgKHZhciBpIGluIHZhbHVlS2V5KSB7XG4gICAgICAgIHZhciBtMiA9IG4ubWF0Y2godmFsdWVLZXlbaV0pO1xuICAgICAgICBpZiAobTIgIT0gbnVsbClcbiAgICAgICAgICAgIG91dDIucHVzaChtMlswXSk7XG5cbiAgICAgICAgdmFyIHJlID0gbmV3IFJlZ0V4cCh2YWx1ZUtleVtpXSwgXCJnXCIpO1xuICAgICAgICB2YXIgcyA9IG4uc2VhcmNoKHJlKTtcbiAgICAgICAgaWYgKHMgIT0gLTEpXG4gICAgICAgICAgICBpbmRleGVkLnB1c2goe2Zyb206IHMsIHRvOiBzICsgdmFsdWVLZXlbaV0ubGVuZ3RofSk7XG4gICAgfVxuXG4gICAgLy8gbmVzdGVkIGxvb3Agbm90IGdvb2QsIGJ1dCBpbmRleGVkIGlzIG5vdCBsaWtlbHkgdG8gYmUgdmVyeSBsYXJnZS5cbiAgICAvLyBpZiBhIHZhcmlhYmxlIGlzIG5lc3RlZCwgaXQgaXMgcmVtb3ZlZCBmcm9tIG91dDJcbiAgICAvLyBub3RpY2UsIGxvb3AgaXMgYmFja3dhcmRzIHNvIHRoYXQgaW5kZXggY2hhbmdlcyBkb24ndCBhZmZlY3QgdGhlIHNwbGljZVxuICAgIGNkYihcImluZGV4ZWQgXCIsIGluZGV4ZWQpO1xuICAgIGZvciAodmFyIGkgPSBpbmRleGVkLmxlbmd0aCAtIDE7IGkgPiAtMTsgaS0tKSB7XG4gICAgICAgIGZvciAodmFyIGogPSBpbmRleGVkLmxlbmd0aCAtIDE7IGogPiAtMTsgai0tKSB7XG4gICAgICAgICAgICBpZiAoaSA9PT0gailcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICgoaW5kZXhlZFtpXS5mcm9tID49IGluZGV4ZWRbal0uZnJvbSkgJiAoaW5kZXhlZFtpXS50byA8PSBpbmRleGVkW2pdLnRvKSkge1xuICAgICAgICAgICAgICAgIGNkYihpLCBcIiBpcyBuZXN0ZWQgaW4gXCIsIGopO1xuICAgICAgICAgICAgICAgIGRlbChvdXQyLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGkgaW4gb3V0Mikge1xuICAgICAgICB0MiA9IHQyLnJlcGxhY2Uob3V0MltpXSwgc3ViTWUyKTsgLy9zb21ldGhpbmcgdGhhdCdsbCBuZXZlciBiZSBhIHZhcmlhYmxlIG5hbWVcbiAgICAgICAgazIgPSBrMiArIDE7XG4gICAgICAgIHN1Yk1lMiA9IFwiX3RyYW5zdmFyXCIuY29uY2F0KGsyKTtcbiAgICB9XG5cbiAgICBpZiAob3V0Mi5sZW5ndGggPiAwKSB7XG4gICAgICAgIG91dDIucHVzaCh0Mik7XG4gICAgICAgIGNkYihcIm5ldyBvdXQgXCIsIG91dDIpO1xuICAgICAgICByZXR1cm4gKG91dDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGFsZXJ0KFwiTm8gdmFyaWFibGUgbmFtZSBmb3VuZC4gUGVyaGFwcyBjaGVjayB5b3VyIHNwZWxsaW5nP1wiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuXG4vKipcbiAgIG4gPSBuYW1lIG9mIGNvbHVtbi9ub2RlXG4gICB0ID0gc2VsZWN0ZWQgdHJhbnNmb3JtYXRpb25cbiovXG5hc3luYyBmdW5jdGlvbiB0cmFuc2Zvcm0obiwgdCwgdHlwZVRyYW5zZm9ybSkge1xuICAgIGlmIChkb3dubG9hZEluY29tcGxldGUoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCF0eXBlVHJhbnNmb3JtKVxuICAgICAgICB0ID0gdC5yZXBsYWNlKFwiK1wiLCBcIl9wbHVzX1wiKTsgLy8gY2FuJ3Qgc2VuZCB0aGUgcGx1cyBvcGVyYXRvclxuXG4gICAgY2RiKCduYW1lIG9mIGNvbDogJyArIG4pO1xuICAgIGNkYigndHJhbnNmb3JtYXRpb246ICcgKyB0KTtcblxuICAgIHZhciBidG4gPSBieUlkKCdidG5Fc3RpbWF0ZScpO1xuXG4gICAgLy8gZmluZCB0aGUgbm9kZSBieSBuYW1lXG4gICAgdmFyIG15biA9IGZpbmROb2RlSW5kZXgoblswXSwgdHJ1ZSk7XG5cbiAgICBpZiAodHlwZW9mIG15biA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBteW4gPSBmaW5kTm9kZUluZGV4KG4sIHRydWUpO1xuICAgIH1cblxuICAgIHZhciBvdXR0eXBlcyA9IHtcbiAgICAgICAgdmFybmFtZXNUeXBlczogbixcbiAgICAgICAgaW50ZXJ2YWw6IG15bi5pbnRlcnZhbCxcbiAgICAgICAgbnVtY2hhcjogbXluLm51bWNoYXIsXG4gICAgICAgIG5hdHVyZTogbXluLm5hdHVyZSxcbiAgICAgICAgYmluYXJ5OiBteW4uYmluYXJ5XG4gICAgfTtcblxuICAgIGNkYihteW4pO1xuICAgIC8vIGlmIHR5cGVUcmFuc2Zvcm0gYnV0IHdlIGFscmVhZHkgaGF2ZSB0aGUgbWV0YWRhdGFcbiAgICBpZiAodHlwZVRyYW5zZm9ybSkge1xuICAgICAgICBpZiAobXluLm5hdHVyZSA9PSBcIm5vbWluYWxcIiAmIHR5cGVvZiBteW4ucGxvdHZhbHVlcyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgbXluLnBsb3R0eXBlID0gXCJiYXJcIjtcbiAgICAgICAgICAgIGJhcnNOb2RlKG15bik7XG4gICAgICAgICAgICBwYW5lbFBsb3RzKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAobXluLm5hdHVyZSAhPSBcIm5vbWluYWxcIiAmIHR5cGVvZiBteW4ucGxvdHggIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIG15bi5wbG90dHlwZSA9IFwiY29udGludW91c1wiO1xuICAgICAgICAgICAgZGVuc2l0eU5vZGUobXluKTtcbiAgICAgICAgICAgIHBhbmVsUGxvdHMoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGVzdGltYXRlTGFkZGEuc3RhcnQoKTsgLy8gc3RhcnQgc3Bpbm5lclxuICAgIGxldCBqc29uID0gYXdhaXQgbWFrZVJlcXVlc3QoXG4gICAgICAgIFJPT0tfU1ZDX1VSTCArICd0cmFuc2Zvcm1hcHAnLFxuICAgICAgICB7emRhdGF1cmw6IGRhdGF1cmwsXG4gICAgICAgICB6dmFyczogbXluLm5hbWUsXG4gICAgICAgICB6c2Vzc2lvbmlkOiB6cGFyYW1zLnpzZXNzaW9uaWQsXG4gICAgICAgICB0cmFuc2Zvcm06IHQsXG4gICAgICAgICBjYWxsSGlzdG9yeTogY2FsbEhpc3RvcnksXG4gICAgICAgICB0eXBlVHJhbnNmb3JtOiB0eXBlVHJhbnNmb3JtLFxuICAgICAgICAgdHlwZVN0dWZmOiBvdXR0eXBlc30pO1xuICAgIGlmICghanNvbikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSXMgdGhpcyBhIHR5cGVUcmFuc2Zvcm0/XG4gICAgaWYgKGpzb24udHlwZVRyYW5zZm9ybVswXSkge1xuICAgICAgICAvLyBZZXMuIFdlJ3JlIHVwZGF0aW5nIGFuIGV4aXN0aW5nIG5vZGVcbiAgICAgICAgZDMuanNvbihqc29uLnVybCwgKGVyciwgZGF0YSkgPT4ge1xuICAgICAgICAgICAgaWYgKGVycilcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKGVycik7XG4gICAgICAgICAgICBsZXQgbm9kZTtcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IGZpbmROb2RlSW5kZXgoa2V5LCB0cnVlKTtcblx0XHQgICAgICAgICAgICBpZiAoIW5vZGUpXG5cdFx0ICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGpRdWVyeS5leHRlbmQodHJ1ZSwgbm9kZSwgZGF0YVtrZXldKTtcbiAgICAgICAgICAgICAgICBub2RlLnBsb3R0eXBlID09PSBcImNvbnRpbnVvdXNcIiA/IGRlbnNpdHlOb2RlKG5vZGUpIDpcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5wbG90dHlwZSA9PT0gXCJiYXJcIiA/IGJhcnNOb2RlKG5vZGUpIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZha2VDbGljaygpO1xuICAgICAgICAgICAgcGFuZWxQbG90cygpO1xuICAgICAgICAgICAgbm9kZSAmJiBjZGIobm9kZSk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIE5vLCB3ZSBoYXZlIGEgbmV3IG5vZGUgaGVyZS0tZS5nLiB0aGUgdHJhbnNmb3JtZWQgY29sdW1uXG4gICAgICAgICAgIGV4YW1wbGUgcmVzcG9uc2U6IHtcbiAgICAgICAgICAgXCJjYWxsXCI6W1widF95ZWFyXzJcIl0sXG4gICAgICAgICAgIFwidXJsXCI6W1wiZGF0YS9wcmVwcm9jZXNzU3Vic2V0X0JBQ0NCQzc4LTdERDktNDQ4Mi1CMzFELTZFQjAxQzNBMEM5NS50eHRcIl0sXG4gICAgICAgICAgIFwidHJhbnNcIjpbXCJ5ZWFyXCIsXCJfdHJhbnN2YXIwXjJcIl0sXG4gICAgICAgICAgIFwidHlwZVRyYW5zZm9ybVwiOltmYWxzZV1cbiAgICAgICAgICAgfVxuICAgICAgICAqL1xuICAgICAgICBjYWxsSGlzdG9yeS5wdXNoKHtcbiAgICAgICAgICAgIGZ1bmM6IFwidHJhbnNmb3JtXCIsXG4gICAgICAgICAgICB6dmFyczogbixcbiAgICAgICAgICAgIHRyYW5zZm9ybTogdFxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgc3Vic2V0ZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIHJDYWxsID0gW107XG5cbiAgICAgICAgckNhbGxbMF0gPSBqc29uLmNhbGw7XG4gICAgICAgIHZhciBuZXdWYXIgPSByQ2FsbFswXVswXTtcblxuICAgICAgICB0cmFucy5wdXNoKG5ld1Zhcik7XG5cbiAgICAgICAgLy8gUmVhZCB0aGUgcHJlcHJvY2VzcyBmaWxlIGNvbnRhaW5pbmcgdmFsdWVzXG4gICAgICAgIC8vIGZvciB0aGUgdHJhbnNmb3JtZWQgdmFyaWFibGVcbiAgICAgICAgLy9cbiAgICAgICAgZDMuanNvbihqc29uLnVybCwgZnVuY3Rpb24oZXJyb3IsIGpzb24pIHtcbiAgICAgICAgICAgIGlmIChlcnJvcikgcmV0dXJuIGNvbnNvbGUud2FybihlcnJvcik7XG5cbiAgICAgICAgICAgIHZhciBqc29uZGF0YSA9IGdldFZhcmlhYmxlRGF0YShqc29uKTtcblxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGpzb25kYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIG15SW5kZXggPSBmaW5kTm9kZUluZGV4KGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBteUluZGV4ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGFsZXJ0KFwiSW52YWxpZCB0cmFuc2Zvcm1hdGlvbjogdGhpcyB2YXJpYWJsZSBuYW1lIGFscmVhZHkgZXhpc3RzLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBhZGQgdHJhbnNmb3JtZWQgdmFyaWFibGUgdG8gdGhlIGN1cnJlbnQgc3BhY2VcbiAgICAgICAgICAgICAgICB2YXIgaSA9IGFsbE5vZGVzLmxlbmd0aDsgIC8vIGdldCBuZXcgaW5kZXhcbiAgICAgICAgICAgICAgICB2YXIgb2JqMSA9IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGksXG4gICAgICAgICAgICAgICAgICAgIHJlZmxleGl2ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgbGFibDogXCJ0cmFuc2Zvcm1sYWJlbFwiLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBbNSwgMTUsIDIwLCAwLCA1LCAxNSwgMjBdLFxuICAgICAgICAgICAgICAgICAgICBjb3VudDogWy42LCAuMiwgLjksIC44LCAuMSwgLjMsIC40XSxcbiAgICAgICAgICAgICAgICAgICAgbm9kZUNvbDogY29sb3JzKGkpLFxuICAgICAgICAgICAgICAgICAgICBiYXNlQ29sOiBjb2xvcnMoaSksXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZUNvbG9yOiBzZWxWYXJDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IFwiMVwiLFxuICAgICAgICAgICAgICAgICAgICBzdWJzZXRwbG90OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgc3Vic2V0cmFuZ2U6IFtcIlwiLCBcIlwiXSxcbiAgICAgICAgICAgICAgICAgICAgc2V0eHBsb3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBzZXR4dmFsczogW1wiXCIsIFwiXCJdLFxuICAgICAgICAgICAgICAgICAgICBncmF5b3V0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdEludGVydmFsOiBqc29uZGF0YVtrZXldLmludGVydmFsLFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0TnVtY2hhcjoganNvbmRhdGFba2V5XS5udW1jaGFyLFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0TmF0dXJlOiBqc29uZGF0YVtrZXldLm5hdHVyZSxcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdEJpbmFyeToganNvbmRhdGFba2V5XS5iaW5hcnlcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgalF1ZXJ5LmV4dGVuZCh0cnVlLCBvYmoxLCBqc29uZGF0YVtrZXldKTtcbiAgICAgICAgICAgICAgICBhbGxOb2Rlcy5wdXNoKG9iajEpO1xuXG4gICAgICAgICAgICAgICAgdmFsdWVLZXkucHVzaChuZXdWYXIpO1xuICAgICAgICAgICAgICAgIG5vZGVzLnB1c2goYWxsTm9kZXNbaV0pO1xuICAgICAgICAgICAgICAgIGZha2VDbGljaygpO1xuICAgICAgICAgICAgICAgIHBhbmVsUGxvdHMoKTtcblxuICAgICAgICAgICAgICAgIGlmIChhbGxOb2Rlc1tpXS5wbG90dHlwZSA9PT0gXCJjb250aW51b3VzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVuc2l0eU5vZGUoYWxsTm9kZXNbaV0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYWxsTm9kZXNbaV0ucGxvdHR5cGUgPT09IFwiYmFyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgYmFyc05vZGUoYWxsTm9kZXNbaV0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG0ucmVkcmF3KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNob3dMb2coJ3RyYW5zZm9ybScsIHJDYWxsKTtcbiAgICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBtYWtlUmVxdWVzdCh1cmwsIGRhdGEpIHtcbiAgICBjb25zb2xlLmxvZygndXJsOicsIHVybCk7XG4gICAgY29uc29sZS5sb2coJ1BPU1Q6JywgZGF0YSk7XG4gICAgbGV0IHJlcztcbiAgICB0cnkge1xuICAgICAgICByZXMgPSBhd2FpdCBtLnJlcXVlc3QodXJsLCB7bWV0aG9kOiAnUE9TVCcsIGRhdGE6IGRhdGF9KTtcbiAgICAgICAgY29uc29sZS5sb2coJ3Jlc3BvbnNlOicsIHJlcyk7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhyZXMpWzBdID09PSAnd2FybmluZycpIHtcbiAgICAgICAgICAgIGFsZXJ0KCdXYXJuaW5nOiAnICsgcmVzLndhcm5pbmcpO1xuICAgICAgICAgICAgZW5kX3RhM19zZWFyY2goZmFsc2UsIHJlcy53YXJuaW5nKTtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgIGVuZF90YTNfc2VhcmNoKGZhbHNlLCBlcnIpO1xuICAgICAgICBjZGIoZXJyKTtcbiAgICAgICAgYWxlcnQoYEVycm9yOiBjYWxsIHRvICR7dXJsfSBmYWlsZWRgKTtcbiAgICB9XG5cbiAgIC8qXG4gICAgLy8gY2FsbCBlbmRfdGEzX3NlYXJjaCBpZiBzdGF0dXMgIT0gT0tcbiAgICAvLyBzdGF0dXMgbWF5IGJlIGluIGRpZmZlcmVudCBwbGFjZXMgZm9yIGRpZmZlcmVudCBjYWxscyB0aG91Z2gsIGFuZCB0aGlzIGlzIG5vdCB3b3J0aCBkb2luZyBhdCB0aGUgbW9tZW50XG4gICAgbGV0IG15cmVnID0gL2QzbS1zZXJ2aWNlL2c7XG4gICAgbGV0IGlzZDNtY2FsbCA9IG15cmVnLnRlc3QodXJsKTtcbiAgICBpZihpc2QzbWNhbGwpIHtcbiAgICAgICAgbGV0IG15c3RhdHVzID0gcmVzLnJlc3BvbnNlSW5mby5zdGF0dXMuY29kZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBpZihteXN0YXR1cyAhPSBcIk9LXCIpIHtcbiAgICAgICAgICAgIGVuZF90YTNfc2VhcmNoKGZhbHNlLCBcImdycGMgcmVzcG9uc2Ugc3RhdHVzIG5vdCBva1wiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAqL1xuXG4gICAgaWYgKCFJU19EM01fRE9NQUlOKXtcbiAgICAgICAgZXN0aW1hdGVMYWRkYS5zdG9wKCk7ICAgIC8vIGVzdGltYXRlTGFkZGEgaXMgYmVpbmcgc3RvcHBlZCBpbiBvblBpcGVsaW5lQ3JlYXRlIGluIEQzTVxuICAgIH07XG4gICAgcmV0dXJuIHJlcztcbn1cblxuLyoqIG5lZWRzIGRvYyAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxlZ2VuZCgpIHtcbiAgICBib3JkZXJTdGF0ZSgpO1xuICAgIG0ucmVkcmF3KCk7XG59XG5cbi8qKlxuICAgcHJvZ3JhbW1hdGljYWxseSBkZXNlbGVjdCBldmVyeSBzZWxlY3RlZCB2YXJpYWJsZVxuKi9cbmV4cG9ydCBmdW5jdGlvbiBlcmFzZSgpIHtcbiAgICBzZXRMZWZ0VGFiKCdWYXJpYWJsZXMnKTtcblxuICAgIHZhbHVlS2V5LmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCl7XG4gICAgICBpZiAoenBhcmFtcy56ZHYuY29uY2F0KHpwYXJhbXMuem5vbSwgenBhcmFtcy56dmFycykuaW5jbHVkZXMoZWxlbWVudCkpICAgLy8gbmFtZXMgc3RhcnQgd2l0aCB2YXJMaXN0IG5vd1xuICAgICAgICBjbGlja1ZhcihlbGVtZW50KTtcbiAgICB9KTtcbn1cblxuLyoqIG5lZWRzIGRvYyAqL1xuZXhwb3J0IGxldCBzZXRMZWZ0VGFiID0gKHRhYikgPT4ge1xuICAgIGxlZnRUYWIgPSB0YWI7XG4gICAgdXBkYXRlTGVmdFBhbmVsV2lkdGgoKTtcblxuICAgIGlmICh0YWIgPT09IFwiRGlzY292ZXJ5XCIpe1xuICAgICAgICBwcm9idGFibGUubGVuZ3RoID0gMDtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGRpc2NvLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbXlwcmVkaWN0b3JzID0gZGlzY29baV0ucHJlZGljdG9ycy5qb2luKCk7XG4gICAgICAgICAgICBwcm9idGFibGUucHVzaChbaSwgZGlzY29baV0udGFyZ2V0LCBteXByZWRpY3RvcnMsIGRpc2NvW2ldLnRhc2ssIGRpc2NvW2ldLm1ldHJpY10pO1xuICAgICAgICB9XG5cbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJkaXNjb3ZlcnlJbnB1dFwiKS52YWx1ZT1kaXNjb1swXS5kZXNjcmlwdGlvbjtcbiAgICB9XG59O1xuXG5leHBvcnQgbGV0IHN1bW1hcnkgPSB7ZGF0YTogW119O1xuXG4vKiogbmVlZHMgZG9jICovXG5mdW5jdGlvbiB2YXJTdW1tYXJ5KGQpIHtcbiAgICBsZXQgdDEgPSAnTWVhbjosIE1lZGlhbjosIE1vc3QgRnJlcTosIE9jY3VycmVuY2VzOiwgTWVkaWFuIEZyZXE6LCBPY2N1cnJlbmNlczosIExlYXN0IEZyZXE6LCBPY2N1cnJlbmNlczosIFN0ZCBEZXY6LCBNaW5pbXVtOiwgTWF4aW11bTosIEludmFsaWQ6LCBWYWxpZDosIFVuaXF1ZXM6LCBIZXJmaW5kYWhsJy5zcGxpdCgnLCAnKTtcblxuICAgIGQzLnNlbGVjdCgnI3RhYlN1bW1hcnknKVxuICAgICAgICAuc2VsZWN0QWxsKCdzdmcnKVxuICAgICAgICAucmVtb3ZlKCk7XG5cbiAgICBpZiAoIWQucGxvdHR5cGUpXG4gICAgICAgIHJldHVybjtcbiAgICBkLnBsb3R0eXBlID09ICdjb250aW51b3VzJyA/IGRlbnNpdHkoZCwgJ1N1bW1hcnknLCBwcml2KSA6XG4gICAgICAgIGQucGxvdHR5cGUgPT0gXCJiYXJcIiA/IGJhcnMoZCwgJ1N1bW1hcnknLCBwcml2KSA6XG4gICAgICAgIGQzLnNlbGVjdChcIiN0YWJTdW1tYXJ5XCIpIC8vIG5vIGdyYXBoIHRvIGRyYXcsIGJ1dCBzdGlsbCBuZWVkIHRvIHJlbW92ZSBwcmV2aW91cyBncmFwaFxuICAgICAgICAuc2VsZWN0QWxsKFwic3ZnXCIpXG4gICAgICAgIC5yZW1vdmUoKTtcblxuICAgIGxldCByaW50ID0gZDMuZm9ybWF0KCdyJyk7XG4gICAgbGV0IHN0ciA9ICh4LCBwKSA9PiAoK3gpLnRvUHJlY2lzaW9uKHAgfHwgNCkudG9TdHJpbmcoKTtcbiAgICBsZXQgdDIgPSBwcml2ICYmIGQubWVhbkNJID9cbiAgICAgICAgW3N0cihkLm1lYW4sIDIpICsgJyAoJyArIHN0cihkLm1lYW5DSS5sb3dlckJvdW5kLCAyKSArICcgLSAnICsgc3RyKGQubWVhbkNJLnVwcGVyQm91bmQsIDIpICsgJyknLFxuICAgICAgICAgc3RyKGQubWVkaWFuKSwgZC5tb2RlLCByaW50KGQuZnJlcW1vZGUpLCBkLm1pZCwgcmludChkLmZyZXFtaWQpLCBkLmZld2VzdCwgcmludChkLmZyZXFmZXdlc3QpLFxuICAgICAgICAgc3RyKGQuc2QpLCBzdHIoZC5taW4pLCBzdHIoZC5tYXgpLCByaW50KGQuaW52YWxpZCksIHJpbnQoZC52YWxpZCksIHJpbnQoZC51bmlxdWVzKSwgc3RyKGQuaGVyZmluZGFobCldIDpcbiAgICAgICAgW3N0cihkLm1lYW4pLCBzdHIoZC5tZWRpYW4pLCBkLm1vZGUsIHJpbnQoZC5mcmVxbW9kZSksIGQubWlkLCByaW50KGQuZnJlcW1pZCksIGQuZmV3ZXN0LCByaW50KGQuZnJlcWZld2VzdCksXG4gICAgICAgICBzdHIoZC5zZCksIHN0cihkLm1pbiksIHN0cihkLm1heCksIHJpbnQoZC5pbnZhbGlkKSwgcmludChkLnZhbGlkKSwgcmludChkLnVuaXF1ZXMpLCBzdHIoZC5oZXJmaW5kYWhsKV07XG5cbiAgICBzdW1tYXJ5LmRhdGEgPSBbXTtcbiAgICB0MS5mb3JFYWNoKChlLCBpKSA9PiAhdDJbaV0uaW5jbHVkZXMoJ05hTicpICYmIHQyW2ldICE9ICdOQScgJiYgdDJbaV0gIT0gJycgJiYgc3VtbWFyeS5kYXRhLnB1c2goW2UsIHQyW2ldXSkpO1xuXG4gICAgc3VtbWFyeS5uYW1lID0gZC5uYW1lO1xuICAgIHN1bW1hcnkubGFibCA9IGQubGFibDtcblxufVxuXG5leHBvcnQgbGV0IHBvcG92ZXJDb250ZW50ID0gZCA9PiB7XG4gICAgaWYoc3dhbmRpdmUpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgdGV4dCA9ICc8dGFibGUgY2xhc3M9XCJ0YWJsZSB0YWJsZS1zbSB0YWJsZS1zdHJpcGVkXCIgc3R5bGU9XCJtYXJnaW46LTEwcHg7XCI+PHRib2R5Pic7XG4gICAgbGV0IFtyaW50LCBwcmVjXSA9IFtkMy5mb3JtYXQoJ3InKSwgKHZhbCwgaW50KSA9PiAoK3ZhbCkudG9QcmVjaXNpb24oaW50KS50b1N0cmluZygpXTtcbiAgICBsZXQgZGl2ID0gKGZpZWxkLCBuYW1lLCB2YWwpID0+IHtcbiAgICAgICAgaWYgKGZpZWxkICE9ICdOQScpIHRleHQgKz0gYDx0cj48dGg+JHtuYW1lfTwvdGg+PHRkPjxwIGNsYXNzPVwidGV4dC1sZWZ0XCIgc3R5bGU9XCJoZWlnaHQ6MTBweDtcIj4ke3ZhbCB8fCBmaWVsZH08L3A+PC90ZD48L3RyPmA7XG4gICAgfTtcbiAgICBkLmxhYmwgIT0gJycgJiYgZGl2KGQubGFibCwgJ0xhYmVsJyk7XG4gICAgZGl2KGQubWVhbiwgJ01lYW4nLCBwcml2ICYmIGQubWVhbkNJID9cbiAgICAgICAgYCR7cHJlYyhkLm1lYW4sIDIpfSAoJHtwcmVjKGQubWVhbkNJLmxvd2VyQm91bmQsIDIpfSAtICR7cHJlYyhkLm1lYW5DSS51cHBlckJvdW5kLCAyKX0pYCA6XG4gICAgICAgIHByZWMoZC5tZWFuLCA0KSk7XG4gICAgZGl2KGQubWVkaWFuLCAnTWVkaWFuJywgcHJlYyhkLm1lZGlhbiwgNCkpO1xuICAgIGRpdihkLm1vZGUsICdNb3N0IEZyZXEnKTtcbiAgICBkaXYoZC5mcmVxbW9kZSwgJ09jY3VycmVuY2VzJywgIHJpbnQoZC5mcmVxbW9kZSkpO1xuICAgIGRpdihkLm1pZCwgJ01lZGlhbiBGcmVxJyk7XG4gICAgZGl2KGQuZnJlcW1pZCwgJ09jY3VycmVuY2VzJywgcmludChkLmZyZXFtaWQpKTtcbiAgICBkaXYoZC5mZXdlc3QsICdMZWFzdCBGcmVxJyk7XG4gICAgZGl2KGQuZnJlcWZld2VzdCwgJ09jY3VycmVuY2VzJywgcmludChkLmZyZXFmZXdlc3QpKTtcbiAgICBkaXYoZC5zZCwgJ1N0YW5kIERldicsIHByZWMoZC5zZCwgNCkpO1xuICAgIGRpdihkLm1heCwgJ01heGltdW0nLCBwcmVjKGQubWF4LCA0KSk7XG4gICAgZGl2KGQubWluLCAnTWluaW11bScsIHByZWMoZC5taW4sIDQpKTtcbiAgICBkaXYoZC5pbnZhbGlkLCAnSW52YWxpZCcsIHJpbnQoZC5pbnZhbGlkKSk7XG4gICAgZGl2KGQudmFsaWQsICdWYWxpZCcsIHJpbnQoZC52YWxpZCkpO1xuICAgIGRpdihkLnVuaXF1ZXMsICdVbmlxdWVzJywgcmludChkLnVuaXF1ZXMpKTtcbiAgICBkaXYoZC5oZXJmaW5kYWhsLCAnSGVyZmluZGFobCcsIHByZWMoZC5oZXJmaW5kYWhsLCA0KSk7XG4gICAgcmV0dXJuIHRleHQgKyAnPC90Ym9keT48L3RhYmxlPic7XG59XG5cbi8qKiBuZWVkcyBkb2MgKi9cbmV4cG9ydCBmdW5jdGlvbiBwYW5lbFBsb3RzKCkge1xuXG4gICAgaWYoSVNfRDNNX0RPTUFJTikge1xuICAgICAgICAvL2J5SWQoJ2J0blN1YnNldCcpLmNsYXNzTGlzdC5hZGQoJ25vc2hvdycpO1xuICAgIH1cbiAgICAvLyBidWlsZCBhcnJheXMgZnJvbSBub2RlcyBpbiBtYWluXG4gICAgbGV0IHZhcnMgPSBbXTtcbiAgICBsZXQgaWRzID0gW107XG4gICAgbm9kZXMuZm9yRWFjaChuID0+IHtcbiAgICAgICAgdmFycy5wdXNoKG4ubmFtZS5yZXBsYWNlKC9cXCh8XFwpL2csICcnKSk7XG4gICAgICAgIGlkcy5wdXNoKG4uaWQpO1xuICAgIH0pO1xuXG4gICAgLy9yZW1vdmUgYWxsIHBsb3RzLCBjb3VsZCBiZSBzbWFydGVyIGhlcmVcbiAgICBkMy5zZWxlY3QoJyNzZXR4TGVmdCcpLnNlbGVjdEFsbCgnc3ZnJykucmVtb3ZlKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmKGFsbE5vZGVzW2lkc1tpXV0udmFsaWQ9PTApIC8vIHRoaXMgd2FzIGEgc2lsZW50IGVycm9yLi4uIHZlcnkgZnJ1c3RyYXRpbmcuLi5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBsZXQgbm9kZSA9IGFsbE5vZGVzW2lkc1tpXV07XG4gICAgICAgIG5vZGUuc2V0eHBsb3QgPSBmYWxzZTtcbiAgICAgICAgbm9kZS5zdWJzZXRwbG90ID0gZmFsc2U7XG4gICAgICAgIGlmIChub2RlLnBsb3R0eXBlID09PSBcImNvbnRpbnVvdXNcIiAmIG5vZGUuc2V0eHBsb3QgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG5vZGUuc2V0eHBsb3QgPSB0cnVlO1xuICAgICAgICAgICAgZGVuc2l0eShub2RlLCBkaXYgPSBcInNldHhMZWZ0XCIsIHByaXYpO1xuICAgICAgICAgICAgbm9kZS5zdWJzZXRwbG90ID0gdHJ1ZTtcbiAgICAgICAgICAgIGRlbnNpdHkobm9kZSwgZGl2ID0gXCJTdW1tYXJ5XCIsIHByaXYpO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGUucGxvdHR5cGUgPT09IFwiYmFyXCIgJiBub2RlLnNldHhwbG90ID09IGZhbHNlKSB7XG4gICAgICAgICAgICBub2RlLnNldHhwbG90ID0gdHJ1ZTtcbiAgICAgICAgICAgIGJhcnMobm9kZSwgZGl2ID0gXCJzZXR4TGVmdFwiLCBwcml2KTtcbiAgICAgICAgICAgIG5vZGUuc3Vic2V0cGxvdCA9IHRydWU7XG4gICAgICAgICAgICBiYXJzU3Vic2V0KG5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgICAgIGQzLnNlbGVjdChcIiNzZXR4TGVmdFwiKS5zZWxlY3RBbGwoXCJzdmdcIilcbiAgICAgICAgLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpO1xuICAgICAgICAgICAgdmFyIHJlZ3N0ciA9IC8oLispX3NldHhMZWZ0XyhcXGQrKS87XG4gICAgICAgICAgICB2YXIgbXluYW1lID0gcmVnc3RyLmV4ZWModGhpcy5pZCk7XG4gICAgICAgICAgICB2YXIgbm9kZWlkID0gbXluYW1lWzJdO1xuICAgICAgICAgICAgbXluYW1lID0gbXluYW1lWzFdO1xuICAgICAgICAgICAgaWYgKCF2YXJzLmluY2x1ZGVzKG15bmFtZSkpIHtcbiAgICAgICAgICAgICAgICBhbGxOb2Rlc1tub2RlaWRdLnNldHhwbG90ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbGV0IHRlbXAgPSBcIiNcIi5jb25jYXQobXluYW1lLCBcIl9zZXR4TGVmdF9cIiwgbm9kZWlkKTtcbiAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGVtcClcbiAgICAgICAgICAgICAgICAgICAgLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIGFsbE5vZGVzW25vZGVpZF0uc3Vic2V0cGxvdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRlbXAgPSBcIiNcIi5jb25jYXQobXluYW1lLCBcIl90YWIyX1wiLCBub2RlaWQpO1xuICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0ZW1wKVxuICAgICAgICAgICAgICAgICAgICAucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgLy8ganVzdCByZW1vdmluZyBhbGwgdGhlIHN1YnNldCBwbG90cyBoZXJlLCBiZWNhdXNlIHVzaW5nIHRoaXMgYnV0dG9uIGZvciBwcm9ibGVtIGRpc2NvdmVyXG4gICAgZDMuc2VsZWN0KCcjdGFiRGlzY292ZXJ5Jykuc2VsZWN0QWxsKCdzdmcnKS5yZW1vdmUoKTtcbn1cblxuLyoqXG4gICBjb252ZXJ0cyBjb2xvciBjb2Rlc1xuKi9cbmV4cG9ydCBsZXQgaGV4VG9SZ2JhID0gaGV4ID0+IHtcbiAgICBsZXQgaW50ID0gcGFyc2VJbnQoaGV4LnJlcGxhY2UoJyMnLCAnJyksIDE2KTtcbiAgICByZXR1cm4gYHJnYmEoJHtbKGludCA+PiAxNikgJiAyNTUsIChpbnQgPj4gOCkgJiAyNTUsIGludCAmIDI1NSwgJzAuNSddLmpvaW4oJywnKX0pYDtcbn07XG5cbi8qKlxuICAgdGFrZXMgbm9kZSBhbmQgY29sb3IgYW5kIHVwZGF0ZXMgenBhcmFtc1xuKi9cbmZ1bmN0aW9uIHNldENvbG9ycyhuLCBjKSB7XG4gICAgaWYgKG4uc3Ryb2tlV2lkdGggPT0gJzEnKSB7XG4gICAgICAgIGlmIChjID09IGdyMUNvbG9yKXtcbiAgICAgICAgICAgIHZhciB0ZW1waW5kZXggPSB6cGFyYW1zLnpncm91cDEuaW5kZXhPZihuLm5hbWUpO1xuICAgICAgICAgICAgaWYgKHRlbXBpbmRleCA+IC0xKXtcbiAgICAgICAgICAgICAgICBuLmdyb3VwMSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGRlbCh6cGFyYW1zLnpncm91cDEsIHRlbXBpbmRleCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG4uZ3JvdXAxID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB6cGFyYW1zLnpncm91cDEucHVzaChuLm5hbWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChjID09IGdyMkNvbG9yKXtcbiAgICAgICAgICAgIHZhciB0ZW1waW5kZXggPSB6cGFyYW1zLnpncm91cDIuaW5kZXhPZihuLm5hbWUpO1xuICAgICAgICAgICAgaWYgKHRlbXBpbmRleCA+IC0xKXtcbiAgICAgICAgICAgICAgICBuLmdyb3VwMiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGRlbCh6cGFyYW1zLnpncm91cDIsIHRlbXBpbmRleCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG4uZ3JvdXAyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB6cGFyYW1zLnpncm91cDIucHVzaChuLm5hbWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYWRkaW5nIHRpbWUsIGNzLCBkdiwgbm9tIHRvIG5vZGUgd2l0aCBubyBzdHJva2VcbiAgICAgICAgbi5zdHJva2VXaWR0aCA9ICc0JztcbiAgICAgICAgbi5zdHJva2VDb2xvciA9IGM7XG4gICAgICAgIG4ubm9kZUNvbCA9IHRhZ2dlZENvbG9yO1xuICAgICAgICBsZXQgcHVzaCA9IChbY29sb3IsIGtleV0pID0+IHtcbiAgICAgICAgICAgIGlmIChjb2xvciAhPSBjKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHpwYXJhbXNba2V5XSA9IEFycmF5LmlzQXJyYXkoenBhcmFtc1trZXldKSA/IHpwYXJhbXNba2V5XSA6IFtdO1xuICAgICAgICAgICAgenBhcmFtc1trZXldLnB1c2gobi5uYW1lKTtcbiAgICAgICAgICAgIGlmIChrZXkgPT0gJ3pub20nKSB7XG4gICAgICAgICAgICAgICAgZmluZE5vZGVJbmRleChuLm5hbWUsIHRydWUpLm5hdHVyZSA9IFwibm9taW5hbFwiO1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybShuLm5hbWUsIHQgPSBudWxsLCB0eXBlVHJhbnNmb3JtID0gdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoa2V5ID09ICd6ZHYnKXsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGdyb3VwIG1lbWJlcnNoaXBzIGZyb20gZHYnc1xuICAgICAgICAgICAgICAgIGlmKG4uZ3JvdXAxKXtcbiAgICAgICAgICAgICAgICAgICAgbi5ncm91cDEgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZGVsKHpwYXJhbXMuemdyb3VwMSwgLTEsIG4ubmFtZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZihuLmdyb3VwMil7XG4gICAgICAgICAgICAgICAgICAgIG4uZ3JvdXAyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGRlbCh6cGFyYW1zLnpncm91cDIsIC0xLCBuLm5hbWUpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFtbZHZDb2xvciwgJ3pkdiddLCBbY3NDb2xvciwgJ3pjcm9zcyddLCBbdGltZUNvbG9yLCAnenRpbWUnXSwgW25vbUNvbG9yLCAnem5vbSddXS5mb3JFYWNoKHB1c2gpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChuLnN0cm9rZVdpZHRoID09ICc0Jykge1xuICAgICAgICBpZiAoYyA9PSBuLnN0cm9rZUNvbG9yKSB7IC8vIGRlc2VsZWN0aW5nIHRpbWUsIGNzLCBkdiwgbm9tXG4gICAgICAgICAgICBuLnN0cm9rZVdpZHRoID0gJzEnO1xuICAgICAgICAgICAgbi5zdHJva2VDb2xvciA9IHNlbFZhckNvbG9yO1xuICAgICAgICAgICAgbi5ub2RlQ29sID0gY29sb3JzKG4uaWQpO1xuICAgICAgICAgICAgenBhcmFtc1Jlc2V0KG4ubmFtZSk7XG4gICAgICAgICAgICBpZiAobm9tQ29sb3IgPT0gYyAmJiB6cGFyYW1zLnpub20uaW5jbHVkZXMobi5uYW1lKSkge1xuICAgICAgICAgICAgICAgIGZpbmROb2RlSW5kZXgobi5uYW1lLCB0cnVlKS5uYXR1cmUgPSBmaW5kTm9kZUluZGV4KG4ubmFtZSwgdHJ1ZSkuZGVmYXVsdE5hdHVyZTtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm0obi5uYW1lLCB0ID0gbnVsbCwgdHlwZVRyYW5zZm9ybSA9IHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgeyAvLyBkZXNlbGVjdGluZyB0aW1lLCBjcywgZHYsIG5vbSBBTkQgY2hhbmdpbmcgaXQgdG8gdGltZSwgY3MsIGR2LCBub21cbiAgICAgICAgICAgIHpwYXJhbXNSZXNldChuLm5hbWUpO1xuICAgICAgICAgICAgaWYgKG5vbUNvbG9yID09IG4uc3Ryb2tlQ29sb3IgJiYgenBhcmFtcy56bm9tLmluY2x1ZGVzKG4ubmFtZSkpIHtcbiAgICAgICAgICAgICAgICBmaW5kTm9kZUluZGV4KG4ubmFtZSwgdHJ1ZSkubmF0dXJlID0gZmluZE5vZGVJbmRleChuLm5hbWUsIHRydWUpLmRlZmF1bHROYXR1cmU7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtKG4ubmFtZSwgdCA9IG51bGwsIHR5cGVUcmFuc2Zvcm0gPSB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG4uc3Ryb2tlQ29sb3IgPSBjO1xuICAgICAgICAgICAgaWYgKGR2Q29sb3IgPT0gYyl7XG4gICAgICAgICAgICAgICAgdmFyIGR2bmFtZSA9IG4ubmFtZTtcbiAgICAgICAgICAgICAgICB6cGFyYW1zLnpkdi5wdXNoKGR2bmFtZSk7XG4gICAgICAgICAgICAgICAgaWYobi5ncm91cDEpeyAvLyByZW1vdmUgZ3JvdXAgbWVtYmVyc2hpcHMgZnJvbSBkdidzXG4gICAgICAgICAgICAgICAgICAgIG5ncm91cDEgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZGVsKHpwYXJhbXMuemdyb3VwMSwgLTEsIGR2bmFtZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZihuLmdyb3VwMil7XG4gICAgICAgICAgICAgICAgICAgIG5ncm91cDIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZGVsKHpwYXJhbXMuemdyb3VwMiwgLTEsIGR2bmFtZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNzQ29sb3IgPT0gYykgenBhcmFtcy56Y3Jvc3MucHVzaChuLm5hbWUpO1xuICAgICAgICAgICAgZWxzZSBpZiAodGltZUNvbG9yID09IGMpIHpwYXJhbXMuenRpbWUucHVzaChuLm5hbWUpO1xuICAgICAgICAgICAgZWxzZSBpZiAobm9tQ29sb3IgPT0gYykge1xuICAgICAgICAgICAgICAgIHpwYXJhbXMuem5vbS5wdXNoKG4ubmFtZSk7XG4gICAgICAgICAgICAgICAgZmluZE5vZGVJbmRleChuLm5hbWUsIHRydWUpLm5hdHVyZSA9IFwibm9taW5hbFwiO1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybShuLm5hbWUsIHQgPSBudWxsLCB0eXBlVHJhbnNmb3JtID0gdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKiBuZWVkcyBkb2MgKi9cbmV4cG9ydCBmdW5jdGlvbiBib3JkZXJTdGF0ZSgpIHtcbiAgICBsZXQgc2V0ID0gKGlkLCBwYXJhbSwgYXR0cnMpID0+IHtcbiAgICAgICAgbGV0IGVsID0gYnlJZChpZCk7XG4gICAgICAgIHpwYXJhbXNbcGFyYW1dLmxlbmd0aCA+IDAgP1xuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMoYXR0cnMpLmZvckVhY2goKFt4LCB5XSkgPT4gZWwucXVlcnlTZWxlY3RvcignLnJlY3RDb2xvciBzdmcgY2lyY2xlJykuc2V0QXR0cmlidXRlKHgsIHkpKSA6XG4gICAgICAgICAgICBlbC5zdHlsZVsnYm9yZGVyLWNvbG9yJ10gPSAnI2NjYyc7XG4gICAgfTtcbiAgICBzZXQoJ2R2QnV0dG9uJywgJ3pkdicsIHtzdHJva2U6IGR2Q29sb3J9KTtcbiAgICBzZXQoJ2NzQnV0dG9uJywnemNyb3NzJywge3N0cm9rZTogY3NDb2xvcn0pO1xuICAgIHNldCgndGltZUJ1dHRvbicsJ3p0aW1lJywge3N0cm9rZTogdGltZUNvbG9yfSk7XG4gICAgc2V0KCdub21CdXR0b24nLCd6bm9tJywge3N0cm9rZTogbm9tQ29sb3J9KTtcbiAgICBzZXQoJ2dyMUJ1dHRvbicsJ3pncm91cDEnLCB7c3Ryb2tlOiBncjFDb2xvciwgZmlsbDogZ3IxQ29sb3IsICdmaWxsLW9wYWNpdHknOiAwLjYsICdzdHJva2Utb3BhY2l0eSc6IDB9KTtcbiAgICBzZXQoJ2dyMkJ1dHRvbicsJ3pncm91cDInLCB7c3Ryb2tlOiBncjJDb2xvciwgZmlsbDogZ3IyQ29sb3IsICdmaWxsLW9wYWNpdHknOiAwLjYsICdzdHJva2Utb3BhY2l0eSc6IDB9KTtcbn1cblxuLyoqIG5lZWRzIGRvYyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN1YnNldFNlbGVjdChidG4pIHtcbiAgICBpZiAoZGF0YXVybCkge1xuICAgICAgICB6cGFyYW1zLnpkYXRhdXJsID0gZGF0YXVybDtcbiAgICB9XG4gICAgaWYgKGRvd25sb2FkSW5jb21wbGV0ZSgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB6cGFyYW1zLnp2YXJzID0gW107XG4gICAgenBhcmFtcy56cGxvdCA9IFtdO1xuICAgIHZhciBzdWJzZXRFbXB0eSA9IHRydWU7XG4gICAgLy8gaXMgdGhpcyB0aGUgc2FtZSBhcyB6UG9wKCk/XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBub2Rlcy5sZW5ndGg7IGorKykgeyAvLyBwb3B1bGF0ZSB6dmFycyBhbmQgenN1YnNldCBhcnJheXNcbiAgICAgICAgenBhcmFtcy56dmFycy5wdXNoKG5vZGVzW2pdLm5hbWUpO1xuICAgICAgICB2YXIgdGVtcCA9IG5vZGVzW2pdLmlkO1xuICAgICAgICB6cGFyYW1zLnpzdWJzZXRbal0gPSBhbGxOb2Rlc1t0ZW1wXS5zdWJzZXRyYW5nZTtcbiAgICAgICAgaWYgKHpwYXJhbXMuenN1YnNldFtqXS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpZiAoenBhcmFtcy56c3Vic2V0W2pdWzBdICE9IFwiXCIpXG4gICAgICAgICAgICAgICAgenBhcmFtcy56c3Vic2V0W2pdWzBdID0gTnVtYmVyKHpwYXJhbXMuenN1YnNldFtqXVswXSk7XG4gICAgICAgICAgICBpZiAoenBhcmFtcy56c3Vic2V0W2pdWzFdICE9IFwiXCIpXG4gICAgICAgICAgICAgICAgenBhcmFtcy56c3Vic2V0W2pdWzFdID0gTnVtYmVyKHpwYXJhbXMuenN1YnNldFtqXVsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgenBhcmFtcy56cGxvdC5wdXNoKGFsbE5vZGVzW3RlbXBdLnBsb3R0eXBlKTtcbiAgICAgICAgaWYgKHpwYXJhbXMuenN1YnNldFtqXVsxXSAhPSBcIlwiKVxuICAgICAgICAgICAgc3Vic2V0RW1wdHkgPSBmYWxzZTsgLy8gb25seSBuZWVkIHRvIGNoZWNrIG9uZVxuICAgIH1cblxuICAgIGlmIChzdWJzZXRFbXB0eSA9PSB0cnVlKSB7XG4gICAgICAgIGFsZXJ0KFwiV2FybmluZzogTm8gbmV3IHN1YnNldCBzZWxlY3RlZC5cIik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgb3V0dHlwZXMgPSBbXTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGFsbE5vZGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIG91dHR5cGVzLnB1c2goe1xuICAgICAgICAgICAgdmFybmFtZXNUeXBlczogYWxsTm9kZXNbal0ubmFtZSxcbiAgICAgICAgICAgIG5hdHVyZTogYWxsTm9kZXNbal0ubmF0dXJlLFxuICAgICAgICAgICAgbnVtY2hhcjogYWxsTm9kZXNbal0ubnVtY2hhcixcbiAgICAgICAgICAgIGJpbmFyeTogYWxsTm9kZXNbal0uYmluYXJ5LFxuICAgICAgICAgICAgaW50ZXJ2YWw6IGFsbE5vZGVzW2pdLmludGVydmFsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGxldCBqc29uID0gbWFrZVJlcXVlc3QoXG4gICAgICAgIFJPT0tfU1ZDX1VSTCArICdzdWJzZXRTZWxlY3QnLFxuICAgICAgICB7emRhdGF1cmw6IHpwYXJhbXMuemRhdGF1cmwsXG4gICAgICAgICB6dmFyczogenBhcmFtcy56dmFycyxcbiAgICAgICAgIHpzdWJzZXQ6IHpwYXJhbXMuenN1YnNldCxcbiAgICAgICAgIHpzZXNzaW9uaWQ6IHpwYXJhbXMuenNlc3Npb25pZCxcbiAgICAgICAgIHpwbG90OiB6cGFyYW1zLnpwbG90LFxuICAgICAgICAgY2FsbEhpc3Rvcnk6IGNhbGxIaXN0b3J5LFxuICAgICAgICAgdHlwZVN0dWZmOiBvdXR0eXBlc30pO1xuICAgIGlmICghanNvbikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJpZ2dlcihcImJ0blZhcmlhYmxlc1wiLCBcImNsaWNrXCIpOyAvLyBwcm9ncmFtbWF0aWMgY2xpY2tzXG4gICAgdHJpZ2dlcihcImJ0bk1vZGVsc1wiLCBcImNsaWNrXCIpO1xuXG4gICAgdmFyIGdyYXlPdXRzID0gW107XG4gICAgdmFyIHJDYWxsID0gW107XG4gICAgckNhbGxbMF0gPSBqc29uLmNhbGw7XG5cbiAgICAvLyBzdG9yZSBjb250ZW50cyBvZiB0aGUgcHJlLXN1YnNldCBzcGFjZVxuICAgIHpQb3AoKTtcbiAgICB2YXIgbXlOb2RlcyA9IGpRdWVyeS5leHRlbmQodHJ1ZSwgW10sIGFsbE5vZGVzKTtcbiAgICB2YXIgbXlQYXJhbXMgPSBqUXVlcnkuZXh0ZW5kKHRydWUsIHt9LCB6cGFyYW1zKTtcbiAgICB2YXIgbXlUcmFucyA9IGpRdWVyeS5leHRlbmQodHJ1ZSwgW10sIHRyYW5zKTtcbiAgICB2YXIgbXlGb3JjZSA9IGpRdWVyeS5leHRlbmQodHJ1ZSwgW10sIGZvcmNldG9nZ2xlKTtcbiAgICB2YXIgbXlQcmVwcm9jZXNzID0galF1ZXJ5LmV4dGVuZCh0cnVlLCB7fSwgcHJlcHJvY2Vzcyk7XG4gICAgdmFyIG15TG9nID0galF1ZXJ5LmV4dGVuZCh0cnVlLCBbXSwgbG9nQXJyYXkpO1xuICAgIHZhciBteUhpc3RvcnkgPSBqUXVlcnkuZXh0ZW5kKHRydWUsIFtdLCBjYWxsSGlzdG9yeSk7XG5cbiAgICBzcGFjZXNbbXlzcGFjZV0gPSB7XG4gICAgICAgIFwiYWxsTm9kZXNcIjogbXlOb2RlcyxcbiAgICAgICAgXCJ6cGFyYW1zXCI6IG15UGFyYW1zLFxuICAgICAgICBcInRyYW5zXCI6IG15VHJhbnMsXG4gICAgICAgIFwiZm9yY2VcIjogbXlGb3JjZSxcbiAgICAgICAgXCJwcmVwcm9jZXNzXCI6IG15UHJlcHJvY2VzcyxcbiAgICAgICAgXCJsb2dBcnJheVwiOiBteUxvZyxcbiAgICAgICAgXCJjYWxsSGlzdG9yeVwiOiBteUhpc3RvcnlcbiAgICB9O1xuXG4gICAgLy8gcmVtb3ZlIHByZS1zdWJzZXQgc3ZnXG4gICAgdmFyIHNlbGVjdE1lID0gXCIjbVwiLmNvbmNhdChteXNwYWNlKTtcbiAgICBkMy5zZWxlY3Qoc2VsZWN0TWUpLmF0dHIoJ2NsYXNzJywgJ2l0ZW0nKTtcbiAgICBzZWxlY3RNZSA9IFwiI3doaXRlc3BhY2VcIi5jb25jYXQobXlzcGFjZSk7XG4gICAgZDMuc2VsZWN0KHNlbGVjdE1lKS5yZW1vdmUoKTtcblxuICAgIG15c3BhY2UgPSBzcGFjZXMubGVuZ3RoO1xuICAgIGNhbGxIaXN0b3J5LnB1c2goe1xuICAgICAgICBmdW5jOiBcInN1YnNldFwiLFxuICAgICAgICB6dmFyczogalF1ZXJ5LmV4dGVuZCh0cnVlLCBbXSwgenBhcmFtcy56dmFycyksXG4gICAgICAgIHpzdWJzZXQ6IGpRdWVyeS5leHRlbmQodHJ1ZSwgW10sIHpwYXJhbXMuenN1YnNldCksXG4gICAgICAgIHpwbG90OiBqUXVlcnkuZXh0ZW5kKHRydWUsIFtdLCB6cGFyYW1zLnpwbG90KVxuICAgIH0pO1xuXG4gICAgLy8gdGhpcyBpcyB0byBiZSB1c2VkIHRvIGdyYXkgb3V0IGFuZCByZW1vdmUgbGlzdGVuZXJzIGZvciB2YXJpYWJsZXMgdGhhdCBoYXZlIGJlZW4gc3Vic2V0dGVkIG91dCBvZiB0aGUgZGF0YVxuICAgIGZ1bmN0aW9uIHZhck91dCh2KSB7XG4gICAgICAgIC8vIGlmIGluIG5vZGVzLCByZW1vdmUgZ3JheSBvdXQgaW4gbGVmdCBwYW5lbFxuICAgICAgICAvLyBtYWtlIHVuY2xpY2thYmxlIGluIGxlZnQgcGFuZWxcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0TWUgPSB2W2ldLnJlcGxhY2UoL1xcVy9nLCBcIl9cIik7XG4gICAgICAgICAgICBieUlkKHNlbGVjdE1lKS5zdHlsZS5jb2xvciA9IGhleFRvUmdiYShncmF5Q29sb3IpO1xuICAgICAgICAgICAgc2VsZWN0TWUgPSBcInAjXCIuY29uY2F0KHNlbGVjdE1lKTtcbiAgICAgICAgICAgIGQzLnNlbGVjdChzZWxlY3RNZSlcbiAgICAgICAgICAgICAgICAub24oXCJjbGlja1wiLCBudWxsKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNob3dMb2coJ3N1YnNldCcsIHJDYWxsKTtcblxuICAgIGQzLnNlbGVjdChcIiNpbm5lcmNhcm91c2VsXCIpXG4gICAgICAgIC5hcHBlbmQoJ2RpdicpXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdpdGVtIGFjdGl2ZScpXG4gICAgICAgIC5hdHRyKCdpZCcsICgpID0+IFwibVwiLmNvbmNhdChteXNwYWNlLnRvU3RyaW5nKCkpKVxuICAgICAgICAuYXBwZW5kKCdzdmcnKVxuICAgICAgICAuYXR0cignaWQnLCAnd2hpdGVzcGFjZScpO1xuICAgIHN2ZyA9IGQzLnNlbGVjdChcIiN3aGl0ZXNwYWNlXCIpO1xuXG4gICAgZDMuanNvbihqc29uLnVybCwgZnVuY3Rpb24oZXJyb3IsIGpzb24pIHtcbiAgICAgICAgaWYgKGVycm9yKXtcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBqc29uZGF0YSA9IGdldFZhcmlhYmxlRGF0YShqc29uKTtcblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4ganNvbmRhdGEpIHtcbiAgICAgICAgICAgIHZhciBteUluZGV4ID0gZmluZE5vZGVJbmRleChrZXkpO1xuXG4gICAgICAgICAgICBhbGxOb2Rlc1tteUluZGV4XS5wbG90eCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGFsbE5vZGVzW215SW5kZXhdLnBsb3R5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgYWxsTm9kZXNbbXlJbmRleF0ucGxvdHZhbHVlcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGFsbE5vZGVzW215SW5kZXhdLnBsb3R0eXBlID0gXCJcIjtcblxuICAgICAgICAgICAgalF1ZXJ5LmV4dGVuZCh0cnVlLCBhbGxOb2Rlc1tteUluZGV4XSwganNvbmRhdGFba2V5XSk7XG4gICAgICAgICAgICBhbGxOb2Rlc1tteUluZGV4XS5zdWJzZXRwbG90ID0gZmFsc2U7XG4gICAgICAgICAgICBhbGxOb2Rlc1tteUluZGV4XS5zdWJzZXRyYW5nZSA9IFtcIlwiLCBcIlwiXTtcbiAgICAgICAgICAgIGFsbE5vZGVzW215SW5kZXhdLnNldHhwbG90ID0gZmFsc2U7XG4gICAgICAgICAgICBhbGxOb2Rlc1tteUluZGV4XS5zZXR4dmFscyA9IFtcIlwiLCBcIlwiXTtcblxuICAgICAgICAgICAgaWYgKGFsbE5vZGVzW215SW5kZXhdLnZhbGlkID09IDApIHtcbiAgICAgICAgICAgICAgICBncmF5T3V0cy5wdXNoKGFsbE5vZGVzW215SW5kZXhdLm5hbWUpO1xuICAgICAgICAgICAgICAgIGFsbE5vZGVzW215SW5kZXhdLmdyYXlvdXQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlUGxvdCgpO1xuICAgICAgICBsYXlvdXQobGF5b3V0QWRkKTtcbiAgICB9KTtcblxuICAgIHZhck91dChncmF5T3V0cyk7XG59XG5cbi8qKlxuICAgcmVtb3ZlcyBhbGwgdGhlIGNoaWxkcmVuIHN2Z3MgaW5zaWRlIHN1YnNldCBhbmQgc2V0eCBkaXZzXG4qL1xuZnVuY3Rpb24gcmVQbG90KCkge1xuICAgIGQzLnNlbGVjdCgnI3RhYjInKVxuICAgICAgICAuc2VsZWN0QWxsKCdzdmcnKVxuICAgICAgICAucmVtb3ZlKCk7XG4gICAgZDMuc2VsZWN0KCcjc2V0eCcpXG4gICAgICAgIC5zZWxlY3RBbGwoJ3N2ZycpXG4gICAgICAgIC5yZW1vdmUoKTtcbiAgICBhbGxOb2Rlcy5mb3JFYWNoKG4gPT4gbi5zZXR4cGxvdCA9IG4uc3Vic2V0cGxvdCA9IGZhbHNlKTtcbn1cblxuLy8gYWN0cyBhcyBpZiB0aGUgdXNlciBjbGlja2VkIGluIHdoaXRlc3BhY2UuIHVzZWZ1bCB3aGVuIHJlc3RhcnQoKSBpcyBvdXRzaWRlIG9mIHNjb3BlXG5leHBvcnQgZnVuY3Rpb24gZmFrZUNsaWNrKCkge1xuICAgIGxldCBlbCA9IGJ5SWQoYHdoaXRlc3BhY2Uke215c3BhY2V9YCk7XG4gICAgbGV0IGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiTW91c2VFdmVudHNcIik7XG4gICAgZXZ0LmluaXRNb3VzZUV2ZW50KFwibW91c2Vkb3duXCIsIHRydWUsIHRydWUsIHdpbmRvdywgMCwgMCwgMCwgMCwgMCwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGwpO1xuICAgIGVsLmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgICBkMy5zZWxlY3QoZWwpXG4gICAgICAgIC5jbGFzc2VkKCdhY3RpdmUnLCBmYWxzZSk7XG59XG5cbi8qKlxuICAgRW5kU2Vzc2lvbihTZXNzaW9uQ29udGV4dCkgcmV0dXJucyAoUmVzcG9uc2UpIHt9XG4qL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGVuZHNlc3Npb24oKSB7XG4gICAgbGV0IHRhYmxlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzZXR4UmlnaHRcIikuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3RhYmxlJylbMF07XG4gICAgaWYodHlwZW9mIHRhYmxlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBhbGVydChcIk5vIHBpcGVsaW5lcyBleGlzdC4gQ2Fubm90IG1hcmsgcHJvYmxlbSBhcyBjb21wbGV0ZS5cIik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgdGFibGVwb3NpdGlvbiA9IHNlbGVjdGVkUGlwZWxpbmVbJ21vZGVsJ10gKyAxOyAgLy8gbm8gcGlwZWxpbmUgc2VsZWN0ZWQgYmVjb21lIE5hTlxuICAgIGlmKGlzTmFOKHRhYmxlcG9zaXRpb24pKXtcbiAgICAgICAgdGFibGVwb3NpdGlvbiA9IDE7XG4gICAgfVxuICAgIGxldCBzZWxlY3RlZCA9IHRhYmxlLnJvd3NbdGFibGVwb3NpdGlvbl0uY2VsbHNbMF0uaW5uZXJIVE1MOyAgLy8gd2FzIFwibm9uZVwiOyBhcyBkZWZhdWx0XG5cbiAgICAvLyBjYWxsaW5nIGV4cG9ydHBpcGVsaW5lXG4gICAgbGV0IGVuZCA9IGF3YWl0IGV4cG9ydHBpcGVsaW5lKHNlbGVjdGVkKTtcblxuICAgLy8gbWFrZVJlcXVlc3QoRDNNX1NWQ19VUkwgKyAnL2VuZHNlc3Npb24nLCBhcGlTZXNzaW9uKHpwYXJhbXMuenNlc3Npb25pZCkpO1xuICAgIGxldCByZXMgPSBhd2FpdCBtYWtlUmVxdWVzdChEM01fU1ZDX1VSTCArICcvZW5kc2Vzc2lvbicsIGFwaVNlc3Npb24oenBhcmFtcy56c2Vzc2lvbmlkKSk7XG4gICAgbGV0IG15c3RhdHVzID0gcmVzLnN0YXR1cy5jb2RlLnRvVXBwZXJDYXNlKCk7XG4gICAgaWYobXlzdGF0dXMgPT0gXCJPS1wiKSB7XG4gICAgICAgIGVuZF90YTNfc2VhcmNoKHRydWUsIFwiUHJvYmxlbSBtYXJrZWQgYXMgY29tcGxldGUuXCIpO1xuICAgICAgICBzZXRNb2RhbChcIllvdXIgc2VsZWN0ZWQgcGlwZWxpbmUgaGFzIGJlZW4gc3VibWl0dGVkLlwiLCBcIlRhc2sgQ29tcGxldGVcIiwgdHJ1ZSwgZmFsc2UsIGZhbHNlLCBsb2NhdGlvbi5yZWxvYWQpO1xuICAgIH1cbn1cblxuLyoqXG4gICAgcnBjIERlbGV0ZVBpcGVsaW5lcyhQaXBlbGluZURlbGV0ZVJlcXVlc3QpIHJldHVybnMgKFBpcGVsaW5lTGlzdFJlc3VsdCkge31cbiAgICBwaXBlcyBpcyBhbiBhcnJheSBvZiBwaXBlbGluZSBJRHNcbiovXG5leHBvcnQgZnVuY3Rpb24gZGVsZXRlcGlwZWxpbmVzKHBpcGVzKSB7XG4gICAgbGV0IHJlcyA9IG1ha2VSZXF1ZXN0KEQzTV9TVkNfVVJMICsgJy9EZWxldGVQaXBlbGluZXMnLCB7Y29udGV4dDogYXBpU2Vzc2lvbih6cGFyYW1zLnpzZXNzaW9uaWQpLCBkZWxldGVQaXBlbGluZUlkczogcGlwZXN9KTtcbiAgICBpZiAoIXJlcykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxufVxuXG4vKipcbiAgICBycGMgRGVsZXRlUGlwZWxpbmVzKFBpcGVsaW5lRGVsZXRlUmVxdWVzdCkgcmV0dXJucyAoUGlwZWxpbmVMaXN0UmVzdWx0KSB7fVxuICAgIHBpcGVzIGlzIGFuIGFycmF5IG9mIHBpcGVsaW5lIElEc1xuKi9cbmV4cG9ydCBmdW5jdGlvbiBjYW5jZWxwaXBlbGluZXMocGlwZXMpIHtcbiAgICBsZXQgcmVzID0gbWFrZVJlcXVlc3QoRDNNX1NWQ19VUkwgKyAnL0NhbmNlbFBpcGVsaW5lcycsIHtjb250ZXh0OiBhcGlTZXNzaW9uKHpwYXJhbXMuenNlc3Npb25pZCksIGNhbmNlbFBpcGVsaW5lSWRzOiBwaXBlc30pO1xuICAgIGlmICghcmVzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG59XG5cbi8qKlxuICAgcnBjIExpc3RQaXBlbGluZXMoUGlwZWxpbmVMaXN0UmVxdWVzdCkgcmV0dXJucyAoUGlwZWxpbmVMaXN0UmVzdWx0KSB7fVxuICAgcGlwZXMgaXMgYW4gYXJyYXkgb2YgcGlwZWxpbmUgSURzXG4qL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGxpc3RwaXBlbGluZXMoKSB7XG4gICAgbGV0IHJlcyA9IGF3YWl0IG1ha2VSZXF1ZXN0KEQzTV9TVkNfVVJMICsgJy9saXN0cGlwZWxpbmVzJywge2NvbnRleHQ6IGFwaVNlc3Npb24oenBhcmFtcy56c2Vzc2lvbmlkKX0pO1xuICAgIGlmICghcmVzKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgbGV0IHBpcGVzID0gcmVzLnBpcGVsaW5lSWRzO1xuICAgIHJldHVybiBwaXBlcztcbn1cblxuLyoqXG4gICBycGMgRXhlY3V0ZVBpcGVsaW5lKFBpcGVsaW5lRXhlY3V0ZVJlcXVlc3QpIHJldHVybnMgKHN0cmVhbSBQaXBlbGluZUV4ZWN1dGVSZXN1bHQpIHt9XG4qL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGV4ZWN1dGVwaXBlbGluZSgpIHtcbiAgICBsZXQgY29udGV4dCA9IGFwaVNlc3Npb24oenBhcmFtcy56c2Vzc2lvbmlkKTtcbiAgICBsZXQgdGFibGVyb3cgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjc2V0eFJpZ2h0IHRyLml0ZW0tc2VsZWN0Jyk7XG4gICAgaWYodGFibGVyb3cgPT0gbnVsbCkge2FsZXJ0KFwiUGxlYXNlIHNlbGVjdCBhIHBpcGVsaW5lIHRvIGV4ZWN1dGUgb24uXCIpOyByZXR1cm47fVxuICAgIGxldCBwaXBlbGluZUlkPXRhYmxlcm93LmZpcnN0Q2hpbGQuaW5uZXJUZXh0O1xuXG4gICAgelBvcCgpO1xuICAgIHpwYXJhbXMuY2FsbEhpc3RvcnkgPSBjYWxsSGlzdG9yeTtcblxuICAgIGxldCBkYXRhID0gW107XG5cbiAgICAvL3RoaXMgd2lsbCBqdXN0IHNldCB6cGFyYW1zLnpzZXR4IHRvIHRoZSBtZWFuLCB3aGljaCBpcyBkZWZhdWx0IGZvciBzZXR4IHBsb3RzXG4gICAgLy9ub3RlIHRoYXQgaWYgc2V0eHBsb3QgaXMgbW9kaWZpZWQsIGl0IHdpbGwgTk9UID09IFwiXCIgYmVjYXVzZSB6cGFyYW1zLnpzZXR4IGlzIG1vZGlmaWVkIHdoZW4gdGhlIHNldHggcGxvdCBzbGlkZXIgaXMgbW92ZWQgZm9yIHRoZSBmaXJzdCB0aW1lXG4gICAgZm9yKGxldCBpID0wOyBpPHpwYXJhbXMuenZhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG15ZGF0YSA9IFtdO1xuICAgICAgICBteWRhdGFbMF0gPSB6cGFyYW1zLnp2YXJzW2ldO1xuICAgICAgICBsZXQgbXltZWFuID0gYWxsTm9kZXNbZmluZE5vZGVJbmRleCh6cGFyYW1zLnp2YXJzW2ldKV0ubWVhbjtcbiAgICAgICAgaWYoenBhcmFtcy56c2V0eFtpXVswXT09XCJcIikge1xuICAgICAgICAgICAgbXlkYXRhWzFdPW15bWVhbjtcbiAgICAgICAgfSBlbHNlIGlmKHpwYXJhbXMuenNldHhbaV1bMF0hPW15bWVhbil7XG4gICAgICAgICAgICBteWRhdGFbMV09enBhcmFtcy56c2V0eFtpXVswXTtcbiAgICAgICAgfVxuICAgICAgICBpZih6cGFyYW1zLnpzZXR4W2ldWzFdPT1cIlwiKSB7XG4gICAgICAgICAgICBteWRhdGFbMl09YWxsTm9kZXNbZmluZE5vZGVJbmRleCh6cGFyYW1zLnp2YXJzW2ldKV0ubWVhbjtcbiAgICAgICAgfSBlbHNlIGlmKHpwYXJhbXMuenNldHhbaV1bMV0hPW15bWVhbil7XG4gICAgICAgICAgICBteWRhdGFbMl09enBhcmFtcy56c2V0eFtpXVsxXTtcbiAgICAgICAgfVxuICAgICAgICBkYXRhLnB1c2gobXlkYXRhKTtcbiAgICB9XG5cbiAgICBsZXQgdGVtcCA9IHtjb250ZXh0LCBwaXBlbGluZUlkLCBkYXRhfTtcbiAgICB0ZW1wID0gSlNPTi5zdHJpbmdpZnkodGVtcCk7XG4gICAgY29uc29sZS5sb2codGVtcCk7XG4gICAgbGV0IHJlcyA9IGF3YWl0IG1ha2VSZXF1ZXN0KEQzTV9TVkNfVVJMICsgJy9FeGVjdXRlUGlwZWxpbmUnLCB7Y29udGV4dCwgcGlwZWxpbmVJZCwgZGF0YX0pO1xuICAgIC8vIEkgdGhpbmsgd2Ugd2FudCB0byBkbyB0aGlzIGhlcmUsIGJ1dCB3aWxsIHdhaXQgZm9yIElTSSBpbWFnZSB0byB0ZXN0IGFnYWluc3RcbiAgIC8vIGlmKHJlcy5wcm9ncmVzc0luZm89PVwiQ09NUExFVEVEXCIpIHtcbiAgICAgICAgcmVzICYmIGFkZFByZWRpY3Rpb25zKHJlcyk7XG4gICAvLyB9XG59XG5cbmZ1bmN0aW9uIGFkZFByZWRpY3Rpb25zKHJlcykge1xuICAgIGZ1bmN0aW9uIHRhYnVsYXRlKGRhdGEsIGNvbHVtbnMpIHtcbiAgICAgICAgdmFyIHRhYmxlID0gZDMuc2VsZWN0KCcjc2V0eExlZnRCb3R0b21SaWdodEJvdHRvbScpLmFwcGVuZCgndGFibGUnKTtcbiAgICAgICAgdmFyIHRoZWFkID0gdGFibGUuYXBwZW5kKCd0aGVhZCcpO1xuICAgICAgICB2YXIgICAgdGJvZHkgPSB0YWJsZS5hcHBlbmQoJ3Rib2R5Jyk7XG5cbiAgICAgICAgLy8gYXBwZW5kIHRoZSBoZWFkZXIgcm93XG4gICAgICAgIHRoZWFkLmFwcGVuZCgndHInKVxuICAgICAgICAuc2VsZWN0QWxsKCd0aCcpXG4gICAgICAgIC5kYXRhKGNvbHVtbnMpLmVudGVyKClcbiAgICAgICAgLmFwcGVuZCgndGgnKVxuICAgICAgICAudGV4dChmdW5jdGlvbiAoY29sdW1uKSB7IHJldHVybiBjb2x1bW47IH0pO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBhIHJvdyBmb3IgZWFjaCBvYmplY3QgaW4gdGhlIGRhdGFcbiAgICAgICAgdmFyIHJvd3MgPSB0Ym9keS5zZWxlY3RBbGwoJ3RyJylcbiAgICAgICAgLmRhdGEoZGF0YSlcbiAgICAgICAgLmVudGVyKClcbiAgICAgICAgLmFwcGVuZCgndHInKTtcblxuICAgICAgICAvLyBjcmVhdGUgYSBjZWxsIGluIGVhY2ggcm93IGZvciBlYWNoIGNvbHVtblxuICAgICAgICB2YXIgY2VsbHMgPSByb3dzLnNlbGVjdEFsbCgndGQnKVxuICAgICAgICAgICAgLmRhdGEoZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2x1bW5zLm1hcChmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7Y29sdW1uOiBjb2x1bW4sIHZhbHVlOiByb3dbY29sdW1uXX07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmVudGVyKClcbiAgICAgICAgICAgIC5hcHBlbmQoJ3RkJylcbiAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLnZhbHVlOyB9KVxuICAgICAgICAgICAgLmF0dHIoJ2lkJyxmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICBsZXQgcm93bmFtZSA9IHRoaXMucGFyZW50RWxlbWVudC5maXJzdENoaWxkLmlubmVyVGV4dDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcm93bmFtZSArIGQuY29sdW1uO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRhYmxlO1xuICAgIH1cblxuICAgIC8vIHRoaXMgaXMgd2hhdCBJU0kgc2hvdWxkIGxvb2sgbGlrZSwgYW5kIHRoZSB0ZXN0IHNlcnZlciBldmVudHVhbGx5LCBzbyBqdXN0IHJlbW92ZSB0aGUgZm9sbG93aW5nIGxpbmUgd2hlbiBpdCdzIHVwXG4gICAgcmVzID0gcmVzLmdycGNSZXNwWzBdO1xuXG4gICAgY29uc29sZS5sb2cocmVzKTtcbiAgICBsZXQgYWxsUHJlZHMgPSByZXMucmVzdWx0RGF0YS5kYXRhO1xuICAgIGxldCBwcmVkdmFscyA9IFtdO1xuXG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGFsbFByZWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHByZWR2YWxzLnB1c2goYWxsUHJlZHNbaV1bXCJwcmVkc1wiXSk7XG4gICAgfVxuXG4gICAgbGV0IG15ZGF0YSA9IFtdO1xuICAgIG15ZGF0YS5wdXNoKHtcIiBcIjpcIlByZWQgMVwiLFwiRShZfFgxKVwiOnByZWR2YWxzWzBdLCBcIkUoWXxYMilcIjpwcmVkdmFsc1sxXX0pO1xuXG4gICAgLy8gcmVuZGVyIHRoZSB0YWJsZShzKVxuICAgIHRhYnVsYXRlKG15ZGF0YSwgWycgJywgJ0UoWXxYMSknLCAnRShZfFgyKSddKTsgLy8gMiBjb2x1bW4gdGFibGVcblxufVxuXG4vKipcbiAgIGZpbmQgc29tZXRoaW5nIGNlbnRlcmlzaCB0byB0aGUgdmVydGljZXMgb2YgYSBjb252ZXggaHVsbFxuICAgKHNwZWNpZmljYWxseSwgdGhlIGNlbnRlciBvZiB0aGUgYm91bmRpbmcgYm94KVxuKi9cbmZ1bmN0aW9uIGphbWVzY2VudHJvaWQoY29vcmQpIHtcbiAgICB2YXIgbWlueCA9IGNvb3JkWzBdWzBdLFxuICAgICAgICBtYXh4ID0gY29vcmRbMF1bMF0sXG4gICAgICAgIG1pbnkgPSBjb29yZFswXVsxXSxcbiAgICAgICAgbWF4eSA9IGNvb3JkWzBdWzFdO1xuICAgIGZvcih2YXIgaiA9IDE7IGo8Y29vcmQubGVuZ3RoOyBqKyspe1xuICAgICAgICBpZiAoY29vcmRbal1bMF0gPCBtaW54KSBtaW54ID0gY29vcmRbal1bMF07XG4gICAgICAgIGlmIChjb29yZFtqXVsxXSA8IG1pbnkpIG1pbnkgPSBjb29yZFtqXVsxXTtcbiAgICAgICAgaWYgKGNvb3JkW2pdWzBdID4gbWF4eCkgbWF4eCA9IGNvb3JkW2pdWzBdO1xuICAgICAgICBpZiAoY29vcmRbal1bMV0gPiBtYXh5KSBtYXh5ID0gY29vcmRbal1bMV07XG4gICAgfTtcbiAgICAgICAgcmV0dXJuWyhtaW54ICsgbWF4eCkvMiwgKG1pbnkgKyBtYXh5KS8yXTtcbn07XG5cbi8qKlxuICAgRGVmaW5lIGVhY2ggcGViYmxlIHJhZGl1cy5cbiAgIFByZXNlbnRseSwgbW9zdCBwZWJibGVzIGFyZSBzY2FsZWQgdG8gcmFkaXVzIHNldCBieSBnbG9iYWwgUkFESVVTLlxuICAgTWVtYmVycyBvZiBncm91cHMgYXJlIHNjYWxlZCBkb3duIGlmIGdyb3VwIGdldHMgbGFyZ2UuXG4qL1xuZXhwb3J0IGZ1bmN0aW9uIHNldFBlYmJsZVJhZGl1cyhkKXtcbiAgICBpZiAoZC5ncm91cDEgfHwgZC5ncm91cDIpIHsgLy8gaWYgYSBtZW1iZXIgb2YgYSBncm91cCwgbmVlZCB0byBjYWxjdWxhdGUgcmFkaXVzIHNpemVcbiAgICAgICAgdmFyIHVwcGVyc2l6ZSA9IDc7XG4gICAgICAgIHZhciBuZzEgPSAoZC5ncm91cDEpID8genBhcmFtcy56Z3JvdXAxLmxlbmd0aCA6IDE7IC8vIHNpemUgb2YgZ3JvdXAxLCBpZiBhIG1lbWJlciBvZiBncm91cCAxXG4gICAgICAgIHZhciBuZzIgPSAoZC5ncm91cDIpID8genBhcmFtcy56Z3JvdXAyLmxlbmd0aCA6IDE7IC8vIHNpemUgb2YgZ3JvdXAyLCBpZiBhIG1lbWJlciBvZiBncm91cCAyXG4gICAgICAgIHZhciBtYXhuZyA9IE1hdGgubWF4KG5nMSwgbmcyKTsgLy8gc2l6ZSBvZiB0aGUgbGFyZ2VzdCBncm91cCB2YXJpYWJsZSBpcyBtZW1iZXIgb2ZcbiAgICAgICAgbGV0IG5vZGVfcmFkaXVzID0gKG1heG5nPnVwcGVyc2l6ZSkgPyBSQURJVVMqTWF0aC5zcXJ0KHVwcGVyc2l6ZS9tYXhuZykgOiBSQURJVVM7IC8vIGtlZXAgdG90YWwgYXJlYSBvZiBwZWJibGVzIGJvdW5kZWQgdG8gcGkgKiBSQURJVVNeMiAqIHVwcGVyc2l6ZSwgdGh1cyBzaHJpbmtpbmcgcmFkaXVzIGZvciBwZWJibGVzIGluIGxhcmdlciBncm91cHNcblxuICAgICAgICAvLyBtYWtlIHRoZSBzZWxlY3RlZCBub2RlIGEgYml0IGJpZ2dlclxuICAgICAgICBpZiAoZC5uYW1lID09PSBzZWxlY3RlZFBlYmJsZSkgcmV0dXJuIE1hdGgubWluKG5vZGVfcmFkaXVzICogMS41LCBSQURJVVMpO1xuICAgICAgICByZXR1cm4gbm9kZV9yYWRpdXNcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUkFESVVTOyAvLyBub25ncm91cCBtZW1iZXJzIGdldCB0aGUgY29tbW9uIGdsb2JhbCByYWRpdXNcbiAgICB9XG59O1xuXG4vKipcbiAgIERlZmluZSBlYWNoIHBlYmJsZSBjaGFyZ2UuXG4qL1xuZnVuY3Rpb24gc2V0UGViYmxlQ2hhcmdlKGQpe1xuICAgIGlmKGQuZ3JvdXAxIHx8IGQuZ3JvdXAyKXtcbiAgICAgICAgaWYoZC5mb3JlZnJvbnQpey8vIHBlYmJsZXMgcGFja2VkIGluIGdyb3VwcyByZXBlbCBvdGhlcnMgb24gbW91c2VvdmVyXG4gICAgICAgICAgICByZXR1cm4gLTEwMDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHVwcGVyc2l6ZSA9IDc7XG4gICAgICAgIHZhciBuZzEgPSAoZC5ncm91cDEpID8genBhcmFtcy56Z3JvdXAxLmxlbmd0aCA6IDE7ICAgICAgLy8gc2l6ZSBvZiBncm91cDEsIGlmIGEgbWVtYmVyIG9mIGdyb3VwIDFcbiAgICAgICAgdmFyIG5nMiA9IChkLmdyb3VwMikgPyB6cGFyYW1zLnpncm91cDIubGVuZ3RoIDogMTsgICAgICAvLyBzaXplIG9mIGdyb3VwMiwgaWYgYSBtZW1iZXIgb2YgZ3JvdXAgMlxuICAgICAgICB2YXIgbWF4bmcgPSBNYXRoLm1heChuZzEsbmcyKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzaXplIG9mIHRoZSBsYXJnZXN0IGdyb3VwIHZhcmlhYmxlIGlzIG1lbWJlciBvZlxuICAgICAgICByZXR1cm4gKG1heG5nPnVwcGVyc2l6ZSkgPyAtNDAwKih1cHBlcnNpemUvbWF4bmcpIDogLTQwMDsgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkZWNyZWFzZSBjaGFyZ2UgYXMgcGViYmxlcyBiZWNvbWUgc21hbGxlciwgc28gdGhleSBjYW4gcGFjayB0b2dldGhlclxuICAgIH1lbHNle1xuICAgICAgICByZXR1cm4gLTgwMDtcbiAgICB9XG59XG5cbi8qKiBuZWVkcyBkb2MgKi9cbmV4cG9ydCBmdW5jdGlvbiByZXN1bHRzcGxvdGluaXQocGlkKSB7XG4gICAgY29uc29sZS5sb2cocGlkKTtcbiAgICBwaWQgPSBhbGxQaXBlbGluZUluZm9bcGlkXTtcbiAgICBsZXQgbXlkdiA9IGFsbFBpcGVsaW5lSW5mby5yb29rcGlwZS5kZXB2YXJbMF07ICAgICAgICAgLy8gV2hlbiB0aGVyZSBhcmUgbXVsdGlwbGUgQ3JlYXRlUGlwZWxpbmVzIGNhbGxzLCB0aGVuIHRoaXMgb25seSBoYXMgdmFsdWVzIGZyb20gbGF0ZXN0IHZhbHVlXG4gICAgbGV0IGR2dmFsdWVzID0gYWxsUGlwZWxpbmVJbmZvLnJvb2twaXBlLmR2dmFsdWVzOyAgICAgICAvLyBXaGVuIHRoZXJlIGFyZSBtdWx0aXBsZSBDcmVhdGVQaXBlbGluZXMgY2FsbHMsIHRoZW4gdGhpcyBvbmx5IGhhcyB2YWx1ZXMgZnJvbSBsYXRlc3QgdmFsdWVcbiAgICAvLyBsZXQgcHJlZGZpbGUgPSBwaWQucGlwZWxpbmVJbmZvLnByZWRpY3RSZXN1bHREYXRhLmZpbGVfMTtcblxuICAgIGlmIChwaWQucGlwZWxpbmVJbmZvLnByZWRpY3RSZXN1bHREYXRhLnN1Y2Nlc3MgPT0gZmFsc2UpIHJldHVybjtcblxuICAgIGxldCBhbGxQcmVkcyA9IHBpZC5waXBlbGluZUluZm8ucHJlZGljdFJlc3VsdERhdGEuZGF0YTtcbiAgICBjb25zb2xlLmxvZyhPYmplY3Qua2V5cyhhbGxQcmVkc1sxXSkpO1xuICAgIGxldCBwcmVkdmFscyA9IFtdO1xuXG4gICAgbGV0IG15ZHZJID0gT2JqZWN0LmtleXMoYWxsUHJlZHNbMV0pLmluZGV4T2YobXlkdik7XG4gICAgaWYgKG15ZHZJID4gLTEpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbGxQcmVkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcHJlZHZhbHMucHVzaChhbGxQcmVkc1tpXVtteWR2XSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKE9iamVjdC5rZXlzKGFsbFByZWRzWzFdKS5pbmRleE9mKFwicHJlZHNcIikgPiAtMSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFsbFByZWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwcmVkdmFscy5wdXNoKGFsbFByZWRzW2ldW1wicHJlZHNcIl0pO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYWxlcnQoXCJEViBkb2VzIG5vdCBtYXRjaC4gTm8gUmVzdWx0cyB3aW5kb3cuXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gb25seSBkbyB0aGlzIGZvciBjbGFzc2lmaWNhdGlvbiB0YXNrc1xuICAgIGlmKGQzbVRhc2tUeXBlW2QzbVByb2JsZW1EZXNjcmlwdGlvbi50YXNrVHlwZV1bMV0gPT0gXCJDTEFTU0lGSUNBVElPTlwiKSB7XG4gICAgICAgIGdlbmNvbmZkYXRhKGR2dmFsdWVzLCBwcmVkdmFscyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHhkYXRhID0gXCJBY3R1YWxcIjtcbiAgICAgICAgbGV0IHlkYXRhID0gXCJQcmVkaWN0ZWRcIjtcbiAgICAgICAgYml2YXJpYXRlUGxvdChkdnZhbHVlcywgcHJlZHZhbHMsIHhkYXRhLCB5ZGF0YSk7XG4gICAgfVxuXG4gICAgLy8gYWRkIHRoZSBsaXN0IG9mIHByZWRpY3RvcnMgaW50byBzZXR4TGVmdFRvcExlZnRcbiAgICBkMy5zZWxlY3QoXCIjc2V0eExlZnRUb3BMZWZ0XCIpLnNlbGVjdEFsbChcInBcIilcbiAgICAgICAgLmRhdGEoYWxsUGlwZWxpbmVJbmZvLnJvb2twaXBlLnByZWRpY3RvcnMpICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZXJlIGFyZSBtdWx0aXBsZSBDcmVhdGVQaXBlbGluZXMgY2FsbHMsIHRoZW4gdGhpcyBvbmx5IGhhcyB2YWx1ZXMgZnJvbSBsYXRlc3QgdmFsdWVcbiAgICAgICAgLmVudGVyKClcbiAgICAgICAgLmFwcGVuZChcInBcIilcbiAgICAgICAgLnRleHQoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQ7IH0pXG4gICAgICAgIC5hdHRyKCdpZCcsZnVuY3Rpb24oZCkgeyByZXR1cm4gXCJzeF9cIitkOyB9KVxuICAgICAgICAuYXR0cignY2xhc3MnLFwiaXRlbS1kZWZhdWx0XCIpXG4gICAgICAgIC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZih0aGlzLmNsYXNzTmFtZT09XCJpdGVtLXNlbGVjdFwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkMy5zZWxlY3QoXCIjc2V0eExlZnRUb3BMZWZ0XCIpLnNlbGVjdChcInAuaXRlbS1zZWxlY3RcIilcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdpdGVtLWRlZmF1bHQnKTtcbiAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5hdHRyKCdjbGFzcycsXCJpdGVtLXNlbGVjdFwiKTtcbiAgICAgICAgICAgIHNpbmdsZVBsb3QodGhpcy5pZC5zbGljZSgzKSk7IC8vIGRyb3BzIHRoYXQgc3hfXG4gICAgICAgIH1cbiAgICAgICAgfSk7XG59XG5cbi8qKiBuZWVkcyBkb2MgKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5jb25mZGF0YSAoZHZ2YWx1ZXMsIHByZWR2YWxzKSB7XG5cbiAgICAvLyBkdnZhbHVlcyBhcmUgZ2VuZXJhbGx5IG51bWVyaWNcbiAgICBkdnZhbHVlcyA9IGR2dmFsdWVzLm1hcChTdHJpbmcpO1xuXG4gICAgLy8gcHJlZHZhbHMgYXJlIGdlbmVyYWxseSBzdHJpbmdzXG4gICAgcHJlZHZhbHMgPSBwcmVkdmFscy5tYXAoU3RyaW5nKTtcblxuICAgIGxldCBteWNvdW50cyA9IFtdO1xuICAgIGxldCBteXBhaXJzID0gW107XG5cbiAgICAvLyBjb21iaW5lIGFjdHVhbHMgYW5kIHByZWRpY3RlZCwgYW5kIGdldCBhbGwgdW5pcXVlIGVsZW1lbnRzXG4gICAgbGV0IG15dW5pcXVlcyA9IGR2dmFsdWVzLmNvbmNhdChwcmVkdmFscyk7XG4gICAgbXl1bmlxdWVzPSBbLi4ubmV3IFNldChteXVuaXF1ZXMpXTsgICAgICAgICAgICAgICAgIC8vZXF1aXZhbGVudCB0bzogbXl1bmlxdWVzID0gQXJyYXkuZnJvbShuZXcgU2V0KG15dW5pcXVlcykpO1xuICAgIC8vd2FzOlxuICAgIC8vICBmdW5jdGlvbiBvbmx5VW5pcXVlKHZhbHVlLCBpbmRleCwgc2VsZikge1xuICAgIC8vICAgIHJldHVybiBzZWxmLmluZGV4T2YodmFsdWUpID09PSBpbmRleDtcbiAgICAvLyAgfVxuICAgIC8vICBteXVuaXF1ZXMgPSBteXVuaXF1ZXMuZmlsdGVyKG9ubHlVbmlxdWUpO1xuICAgIG15dW5pcXVlcyA9IG15dW5pcXVlcy5zb3J0KCk7XG5cbiAgICAvLyBjcmVhdGUgdHdvIGFycmF5czogbXljb3VudHMgaW5pdGlhbGl6ZWQgdG8gMCwgbXlwYWlycyBoYXZlIGVsZW1lbnRzIHNldCB0byBhbGwgcG9zc2libGUgcGFpcnMgb2YgdW5pcXVlc1xuICAgIC8vIGxvb2tlZCBpbnRvIHNvbHV0aW9ucyBvdGhlciB0aGFuIG5lc3RlZCBmb3JzLCBidXQgSW50ZXJuZXQgc3VnZ2VzdCBwZXJmb3JtYW5jZSBpcyBqdXN0IGZpbmUgdGhpcyB3YXlcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgbXl1bmlxdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCB0ZW1wY291bnQgPSBbXTtcbiAgICAgICAgbGV0IHRlbXBwYWlyID0gW107XG4gICAgICAgIGZvcihsZXQgaiA9IDA7IGogPCBteXVuaXF1ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIG15Y291bnRzLnB1c2goMCk7XG4gICAgICAgICAgICBteXBhaXJzLnB1c2gobXl1bmlxdWVzW2ldKycsJytteXVuaXF1ZXNbal0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gbGluZSB1cCBhY3R1YWxzIGFuZCBwcmVkaWN0ZWQsIGFuZCBpbmNyZW1lbnQgbXljb3VudHMgYXQgaW5kZXggd2hlcmUgbXlwYWlyIGhhcyBhIG1hdGNoIGZvciB0aGUgJ2FjdHVhbCxwcmVkaWN0ZWQnXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkdnZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgdGVtcHBhaXIgPSBkdnZhbHVlc1tpXSsnLCcrcHJlZHZhbHNbaV07XG4gICAgICAgIGxldCBteWluZGV4ID0gbXlwYWlycy5pbmRleE9mKHRlbXBwYWlyKTtcbiAgICAgICAgbXljb3VudHNbbXlpbmRleF0gKz0gMTtcbiAgICB9XG5cbiAgICBsZXQgY29uZmRhdGEgPSBbXSwgc2l6ZSA9IG15dW5pcXVlcy5sZW5ndGg7XG4gICAgLy8gYW5vdGhlciBsb29wLi4uIHRoaXMgYnVpbGRzIHRoZSBhcnJheSBvZiBhcnJheXMgZnJvbSB0aGUgZmxhdCBhcnJheSBteWNvdW50cyBmb3IgaW5wdXQgdG8gY29uZnVzaW9uc21hdHJpeCBmdW5jdGlvblxuICAgIHdoaWxlIChteWNvdW50cy5sZW5ndGggPiAwKVxuICAgICAgICBjb25mZGF0YS5wdXNoKG15Y291bnRzLnNwbGljZSgwLCBzaXplKSk7XG5cbiAgICBjb25mdXNpb25tYXRyaXgoY29uZmRhdGEsIG15dW5pcXVlcyk7XG59XG5cbi8qKiBuZWVkcyBkb2MgKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25mdXNpb25tYXRyaXgobWF0cml4ZGF0YSwgY2xhc3Nlcykge1xuXG4gICAgZDMuc2VsZWN0KFwiI3NldHhMZWZ0UGxvdFwiKS5odG1sKFwiXCIpO1xuICAgIGQzLnNlbGVjdChcIiNzZXR4TGVmdFBsb3RcIikuc2VsZWN0KFwic3ZnXCIpLnJlbW92ZSgpO1xuXG4gICAgLy8gYWRhcHRlZCBmcm9tIHRoaXMgYmxvY2s6IGh0dHBzOi8vYmwub2Nrcy5vcmcvYXJwaXRuYXJlY2hhbmlhL2RiZjAzZDhlZjdmZmZhNDQ2Mzc5ZDU5ZGI2MzU0YmFjXG4gICAgbGV0IG1haW53aWR0aCA9IGJ5SWQoJ21haW4nKS5jbGllbnRXaWR0aDtcbiAgICBsZXQgbWFpbmhlaWdodCA9IGJ5SWQoJ21haW4nKS5jbGllbnRIZWlnaHQ7XG5cblxuICAgIGxldCBsb25nZXN0ID0gY2xhc3Nlcy5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEubGVuZ3RoID4gYi5sZW5ndGggPyBhIDogYjsgfSk7XG4gICAgLy9jb25zb2xlLmxvZyhsb25nZXN0KTtcbiAgICBsZXQgbGVmdG1hcmdpbmd1ZXNzID0gTWF0aC5tYXgobG9uZ2VzdC5sZW5ndGggKiA4LCAyNSk7ICAvLyBNb3JlIGNvcnJlY3QgYW5zd2VyIGlzIHRvIG1ha2UgYSBzcGFuLCBwdXQgc3RyaW5nIGluc2lkZSBzcGFuLCB0aGVuIHVzZSBqcXVlcnkgdG8gZ2V0IHBpeGVsIHdpZHRoIG9mIHNwYW4uXG5cblxuICAgIGxldCBjb25kaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb25kaXYuaWQ9XCJjb25mdXNpb25jb250YWluZXJcIjtcbiAgICBjb25kaXYuc3R5bGUuZGlzcGxheT1cImlubGluZS1ibG9ja1wiO1xuICAgIGNvbmRpdi5zdHlsZS53aWR0aD0rKG1haW53aWR0aCouMzg1KSsncHgnOyAgIC8vIE5lZWQgdG8gbm90IGJlIGhhcmQgY29kZWRcbiAgICBjb25kaXYuc3R5bGUubWFyZ2luTGVmdD0nMjBweCc7XG4gICAgY29uZGl2LnN0eWxlLmhlaWdodD0rKG1haW5oZWlnaHQpKydweCc7ICAgICAgLy8gTmVlZCB0byBub3QgYmUgaGFyZCBjb2RlZFxuICAgIGNvbmRpdi5zdHlsZS5mbG9hdD1cImxlZnRcIjtcbiAgICBieUlkKCdzZXR4TGVmdFBsb3QnKS5hcHBlbmRDaGlsZChjb25kaXYpO1xuXG4gICAgbGV0IGxlZ2RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGxlZ2Rpdi5pZD1cImNvbmZ1c2lvbmxlZ2VuZFwiO1xuICAgIGxlZ2Rpdi5zdHlsZS53aWR0aD0rKG1haW53aWR0aCouMDUpKydweCc7ICAgIC8vIE5lZWQgdG8gbm90IGJlIGhhcmQgY29kZWRcbiAgICBsZWdkaXYuc3R5bGUubWFyZ2luTGVmdD0nNXB4JzsgICAgICAgICAgICAgICAvLyBNYXJnaW4gYmV0d2VlbiBjb25mdXNpb24gbWF0cml4IGNvbnRhaW5lciBhbmQgbGVnZW5kIGNvbnRhaW5lclxuICAgIGxlZ2Rpdi5zdHlsZS5oZWlnaHQ9KyhtYWluaGVpZ2h0KSsncHgnOyAgICAgIC8vIE5lZWQgdG8gbm90IGJlIGhhcmQgY29kZWRcbiAgICBsZWdkaXYuc3R5bGUuZGlzcGxheT1cImlubGluZS1ibG9ja1wiO1xuICAgIGJ5SWQoJ3NldHhMZWZ0UGxvdCcpLmFwcGVuZENoaWxkKGxlZ2Rpdik7XG5cbiAgICB2YXIgbWFyZ2luID0ge3RvcDogMzAsIHJpZ2h0OiAzNSwgYm90dG9tOiAwLCBsZWZ0OiBsZWZ0bWFyZ2luZ3Vlc3N9OyAgICAvLyBMZWZ0IG1hcmdpbiBuZWVkcyBub3QgdG8gYmUgaGFyZGNvZGVkLCBidXQgcmVzcG9uc2l2ZSB0byBtYXhpbXVtIGxhYmVsIGxlbmd0aFxuXG5cbiAgICBmdW5jdGlvbiBNYXRyaXgob3B0aW9ucykge1xuICAgICAgICBsZXQgd2lkdGggPSBvcHRpb25zLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBvcHRpb25zLmhlaWdodCxcbiAgICAgICAgZGF0YSA9IG9wdGlvbnMuZGF0YSxcbiAgICAgICAgY29udGFpbmVyID0gb3B0aW9ucy5jb250YWluZXIsXG4gICAgICAgIGxhYmVsc0RhdGEgPSBvcHRpb25zLmxhYmVscyxcbiAgICAgICAgc3RhcnRDb2xvciA9IG9wdGlvbnMuc3RhcnRfY29sb3IsXG4gICAgICAgIGVuZENvbG9yID0gb3B0aW9ucy5lbmRfY29sb3IsXG4gICAgICAgIHhPZmZzZXQgPSBvcHRpb25zLnhfb2Zmc2V0O1xuXG4gICAgICAgIGxldCB3aWR0aExlZ2VuZCA9IG9wdGlvbnMud2lkdGhMZWdlbmQ7XG5cbiAgICAgICAgaWYoIWRhdGEpe1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgcGFzcyBkYXRhJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZighQXJyYXkuaXNBcnJheShkYXRhKSB8fCAhZGF0YS5sZW5ndGggfHwgIUFycmF5LmlzQXJyYXkoZGF0YVswXSkpe1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJdCBzaG91bGQgYmUgYSAyLUQgYXJyYXknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBtYXhWYWx1ZSA9IGQzLm1heChkYXRhLCBmdW5jdGlvbihsYXllcikgeyByZXR1cm4gZDMubWF4KGxheWVyLCBmdW5jdGlvbihkKSB7IHJldHVybiBkOyB9KTsgfSk7XG4gICAgICAgIGxldCBtaW5WYWx1ZSA9IGQzLm1pbihkYXRhLCBmdW5jdGlvbihsYXllcikgeyByZXR1cm4gZDMubWluKGxheWVyLCBmdW5jdGlvbihkKSB7IHJldHVybiBkOyB9KTsgfSk7XG5cbiAgICAgICAgbGV0IG51bXJvd3MgPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgbGV0IG51bWNvbHMgPSBkYXRhWzBdLmxlbmd0aDtcblxuICAgICAgICBsZXQgc3ZnID0gZDMuc2VsZWN0KGNvbnRhaW5lcikuYXBwZW5kKFwic3ZnXCIpXG4gICAgICAgIC5hdHRyKFwid2lkdGhcIiwgd2lkdGggKyBtYXJnaW4ubGVmdCArIG1hcmdpbi5yaWdodClcbiAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgaGVpZ2h0ICsgbWFyZ2luLnRvcCArIG1hcmdpbi5ib3R0b20pXG4gICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgbWFyZ2luLmxlZnQgKyBcIixcIiArIG1hcmdpbi50b3AgKyBcIilcIik7XG5cbiAgICAgICAgbGV0IGJhY2tncm91bmQgPSBzdmcuYXBwZW5kKFwicmVjdFwiKVxuICAgICAgICAuc3R5bGUoXCJzdHJva2VcIiwgXCJibGFja1wiKVxuICAgICAgICAuc3R5bGUoXCJzdHJva2Utd2lkdGhcIiwgXCIycHhcIilcbiAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCB3aWR0aClcbiAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgaGVpZ2h0KTtcblxuICAgICAgICBsZXQgeCA9IGQzLnNjYWxlLm9yZGluYWwoKVxuICAgICAgICAuZG9tYWluKGQzLnJhbmdlKG51bWNvbHMpKVxuICAgICAgICAucmFuZ2VCYW5kcyhbMCwgd2lkdGhdKTtcblxuICAgICAgICBsZXQgeSA9IGQzLnNjYWxlLm9yZGluYWwoKVxuICAgICAgICAuZG9tYWluKGQzLnJhbmdlKG51bXJvd3MpKVxuICAgICAgICAucmFuZ2VCYW5kcyhbMCwgaGVpZ2h0XSk7XG5cbiAgICAgICAgbGV0IGNvbG9yTWFwID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLmRvbWFpbihbbWluVmFsdWUsbWF4VmFsdWVdKVxuICAgICAgICAucmFuZ2UoW3N0YXJ0Q29sb3IsIGVuZENvbG9yXSk7XG5cbiAgICAgICAgbGV0IHJvdyA9IHN2Zy5zZWxlY3RBbGwoXCIucm93XCIpXG4gICAgICAgIC5kYXRhKGRhdGEpXG4gICAgICAgIC5lbnRlcigpLmFwcGVuZChcImdcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInJvd1wiKVxuICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBmdW5jdGlvbihkLCBpKSB7IHJldHVybiBcInRyYW5zbGF0ZSgwLFwiICsgeShpKSArIFwiKVwiOyB9KTtcblxuICAgICAgICBsZXQgY2VsbCA9IHJvdy5zZWxlY3RBbGwoXCIuY2VsbFwiKVxuICAgICAgICAuZGF0YShmdW5jdGlvbihkKSB7IHJldHVybiBkOyB9KVxuICAgICAgICAuZW50ZXIoKS5hcHBlbmQoXCJnXCIpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJjZWxsXCIpXG4gICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uKGQsIGkpIHsgcmV0dXJuIFwidHJhbnNsYXRlKFwiICsgeChpKSArIFwiLCAwKVwiOyB9KTtcblxuICAgICAgICBjZWxsLmFwcGVuZCgncmVjdCcpXG4gICAgICAgIC5hdHRyKFwid2lkdGhcIiwgeC5yYW5nZUJhbmQoKSlcbiAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgeS5yYW5nZUJhbmQoKSlcbiAgICAgICAgLnN0eWxlKFwic3Ryb2tlLXdpZHRoXCIsIDApO1xuXG4gICAgICAgIGlmKG51bWNvbHMgPCAyMCl7XG4gICAgICAgICAgY2VsbC5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgICAgLmF0dHIoXCJkeVwiLCBcIi4zMmVtXCIpXG4gICAgICAgICAgLmF0dHIoXCJ4XCIsIHgucmFuZ2VCYW5kKCkgLyAyKVxuICAgICAgICAgIC5hdHRyKFwieVwiLCB5LnJhbmdlQmFuZCgpIC8gMilcbiAgICAgICAgICAuYXR0cihcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpXG4gICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBmdW5jdGlvbihkLCBpKSB7IHJldHVybiBkID49IG1heFZhbHVlLzIgPyAnd2hpdGUnIDogJ2JsYWNrJzsgfSlcbiAgICAgICAgICAudGV4dChmdW5jdGlvbihkLCBpKSB7IHJldHVybiBkOyB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICByb3cuc2VsZWN0QWxsKFwiLmNlbGxcIilcbiAgICAgICAgLmRhdGEoZnVuY3Rpb24oZCwgaSkgeyByZXR1cm4gZGF0YVtpXTsgfSlcbiAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBjb2xvck1hcCk7XG5cbiAgICAgICAgLy8gdGhpcyBwb3J0aW9uIG9mIHRoZSBjb2RlIGlzbid0IGFzIHJvYnVzdCB0byBzaXppbmcuIGNvbHVtbiBsYWJlbHMgbm90IHJlbmRlcmluZyBpbiB0aGUgcmlnaHQgcGxhY2VcbiAgICAgICAgbGV0IGxhYmVscyA9IHN2Zy5hcHBlbmQoJ2cnKVxuICAgICAgICAuYXR0cignY2xhc3MnLCBcImxhYmVsc1wiKTtcblxuICAgICAgICBsZXQgY29sdW1uTGFiZWxzID0gbGFiZWxzLnNlbGVjdEFsbChcIi5jb2x1bW4tbGFiZWxcIilcbiAgICAgICAgLmRhdGEobGFiZWxzRGF0YSlcbiAgICAgICAgLmVudGVyKCkuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiY29sdW1uLWxhYmVsXCIpXG4gICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgICAvLyBsZXQgdGVtcCA9IFwidHJhbnNsYXRlKFwiICsgeChpKSArIFwiLFwiICsgKGhlaWdodCsyMCkgKyBcIilcIjsgLy8gdGhpcyBpbiBwYXJ0aWN1bGFyIGxvb2tzIHRvIGJlIHRoZSBjYXVzZVxuICAgICAgICAgICAgLy8gIGNvbnNvbGUubG9nKHRlbXApO1xuICAgICAgICAgICAgICByZXR1cm4gXCJ0cmFuc2xhdGUoXCIgKyB4KGkpICsgXCIsXCIgKyAoaGVpZ2h0ICsgeE9mZnNldCkgKyBcIilcIjsgfSk7XG5cbiAgICAgICAgY29sdW1uTGFiZWxzLmFwcGVuZChcImxpbmVcIilcbiAgICAgICAgLnN0eWxlKFwic3Ryb2tlXCIsIFwiYmxhY2tcIilcbiAgICAgICAgLnN0eWxlKFwic3Ryb2tlLXdpZHRoXCIsIFwiMXB4XCIpXG4gICAgICAgIC5hdHRyKFwieDFcIiwgeC5yYW5nZUJhbmQoKSAvIDIpXG4gICAgICAgIC5hdHRyKFwieDJcIiwgeC5yYW5nZUJhbmQoKSAvIDIpXG4gICAgICAgIC5hdHRyKFwieTFcIiwgNSAteE9mZnNldClcbiAgICAgICAgLmF0dHIoXCJ5MlwiLCAteE9mZnNldCk7XG5cbiAgICAgICAgY29uc29sZS5sb2coeC5yYW5nZUJhbmQpO1xuXG4gICAgICAgIGNvbHVtbkxhYmVscy5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgIC5hdHRyKFwieFwiLCB4LnJhbmdlQmFuZCgpLzIpXG4gICAgICAgIC5hdHRyKFwieVwiLCAtMTApXG4gICAgICAgIC8vLmF0dHIoXCJkeVwiLCBcIjAuNWVtXCIpXG4gICAgICAgIC5hdHRyKFwidGV4dC1hbmNob3JcIiwgXCJzdGFydFwiKVxuICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInJvdGF0ZSg2MCxcIiArIHgucmFuZ2VCYW5kKCkvMiArIFwiLC0xMClcIilcbiAgICAgICAgLnRleHQoZnVuY3Rpb24oZCwgaSkgeyByZXR1cm4gZDsgfSk7XG5cbiAgICAgICAgbGV0IHJvd0xhYmVscyA9IGxhYmVscy5zZWxlY3RBbGwoXCIucm93LWxhYmVsXCIpXG4gICAgICAgIC5kYXRhKGxhYmVsc0RhdGEpXG4gICAgICAgIC5lbnRlcigpLmFwcGVuZChcImdcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInJvdy1sYWJlbFwiKVxuICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBmdW5jdGlvbihkLCBpKSB7IHJldHVybiBcInRyYW5zbGF0ZShcIiArIDAgKyBcIixcIiArIHkoaSkgKyBcIilcIjsgfSk7XG5cbiAgICAgICAgcm93TGFiZWxzLmFwcGVuZChcImxpbmVcIilcbiAgICAgICAgLnN0eWxlKFwic3Ryb2tlXCIsIFwiYmxhY2tcIilcbiAgICAgICAgLnN0eWxlKFwic3Ryb2tlLXdpZHRoXCIsIFwiMXB4XCIpXG4gICAgICAgIC5hdHRyKFwieDFcIiwgMClcbiAgICAgICAgLmF0dHIoXCJ4MlwiLCAtNSlcbiAgICAgICAgLmF0dHIoXCJ5MVwiLCB5LnJhbmdlQmFuZCgpIC8gMilcbiAgICAgICAgLmF0dHIoXCJ5MlwiLCB5LnJhbmdlQmFuZCgpIC8gMik7XG5cbiAgICAgICAgcm93TGFiZWxzLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgLmF0dHIoXCJ4XCIsIC04KVxuICAgICAgICAuYXR0cihcInlcIiwgeS5yYW5nZUJhbmQoKSAvIDIpXG4gICAgICAgIC5hdHRyKFwiZHlcIiwgXCIuMzJlbVwiKVxuICAgICAgICAuYXR0cihcInRleHQtYW5jaG9yXCIsIFwiZW5kXCIpXG4gICAgICAgIC50ZXh0KGZ1bmN0aW9uKGQsIGkpIHsgcmV0dXJuIGQ7IH0pO1xuXG4gICAgICAgIGxldCBrZXkgPSBkMy5zZWxlY3QoXCIjY29uZnVzaW9ubGVnZW5kXCIpXG4gICAgICAgIC5hcHBlbmQoXCJzdmdcIilcbiAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCB3aWR0aExlZ2VuZClcbiAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgaGVpZ2h0ICsgbWFyZ2luLnRvcCArIG1hcmdpbi5ib3R0b20pO1xuXG4gICAgICAgIGxldCBsZWdlbmQgPSBrZXlcbiAgICAgICAgLmFwcGVuZChcImRlZnNcIilcbiAgICAgICAgLmFwcGVuZChcInN2ZzpsaW5lYXJHcmFkaWVudFwiKVxuICAgICAgICAuYXR0cihcImlkXCIsIFwiZ3JhZGllbnRcIilcbiAgICAgICAgLmF0dHIoXCJ4MVwiLCBcIjEwMCVcIilcbiAgICAgICAgLmF0dHIoXCJ5MVwiLCBcIjAlXCIpXG4gICAgICAgIC5hdHRyKFwieDJcIiwgXCIxMDAlXCIpXG4gICAgICAgIC5hdHRyKFwieTJcIiwgXCIxMDAlXCIpXG4gICAgICAgIC5hdHRyKFwic3ByZWFkTWV0aG9kXCIsIFwicGFkXCIpO1xuXG4gICAgICAgIGxlZ2VuZFxuICAgICAgICAuYXBwZW5kKFwic3RvcFwiKVxuICAgICAgICAuYXR0cihcIm9mZnNldFwiLCBcIjAlXCIpXG4gICAgICAgIC5hdHRyKFwic3RvcC1jb2xvclwiLCBlbmRDb2xvcilcbiAgICAgICAgLmF0dHIoXCJzdG9wLW9wYWNpdHlcIiwgMSk7XG5cbiAgICAgICAgbGVnZW5kXG4gICAgICAgIC5hcHBlbmQoXCJzdG9wXCIpXG4gICAgICAgIC5hdHRyKFwib2Zmc2V0XCIsIFwiMTAwJVwiKVxuICAgICAgICAuYXR0cihcInN0b3AtY29sb3JcIiwgc3RhcnRDb2xvcilcbiAgICAgICAgLmF0dHIoXCJzdG9wLW9wYWNpdHlcIiwgMSk7XG5cbiAgICAgICAga2V5LmFwcGVuZChcInJlY3RcIilcbiAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCB3aWR0aExlZ2VuZC8yLTEwKVxuICAgICAgICAuYXR0cihcImhlaWdodFwiLCBoZWlnaHQpXG4gICAgICAgIC5zdHlsZShcImZpbGxcIiwgXCJ1cmwoI2dyYWRpZW50KVwiKVxuICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLFwiICsgbWFyZ2luLnRvcCArIFwiKVwiKTtcblxuICAgICAgICBzdmcuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArICh3aWR0aCAvIDIpICsgXCIgLFwiICsgKDAgLSAxMCkgKyBcIilcIilcbiAgICAgICAgLnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIilcbiAgICAgICAgLnRleHQoXCJQcmVkaWN0ZWQgQ2xhc3NcIik7XG5cbiAgICAgICAgc3ZnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJyb3RhdGUoLTkwKVwiKVxuICAgICAgICAuYXR0cihcInlcIiwgKHdpZHRoICsgMTUpIClcbiAgICAgICAgLmF0dHIoXCJ4XCIsMCAtIChoZWlnaHQgLyAyKSlcbiAgICAgICAgLy8uYXR0cihcImR5XCIsIFwiMWVtXCIpXG4gICAgICAgIC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpXG4gICAgICAgIC50ZXh0KFwiQWN0dWFsIENsYXNzXCIpO1xuXG4gICAgICAgIC8vIHRoaXMgeSBpcyBmb3IgdGhlIGxlZ2VuZFxuICAgICAgICB5ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLnJhbmdlKFtoZWlnaHQsIDBdKVxuICAgICAgICAuZG9tYWluKFttaW5WYWx1ZSwgbWF4VmFsdWVdKTtcblxuICAgICAgICBsZXQgeUF4aXMgPSBkMy5zdmcuYXhpcygpXG4gICAgICAgIC5zY2FsZSh5KVxuICAgICAgICAub3JpZW50KFwicmlnaHRcIik7XG5cbiAgICAgICAga2V5XG4gICAgICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInkgYXhpc1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMjUsXCIgKyBtYXJnaW4udG9wICsgXCIpXCIpICAgIC8vIGZpcnN0IG51bWJlciBpcyBzZXBhcmF0aW9uIGJldHdlZW4gbGVnZW5kIHNjYWxlIGFuZCBsZWdlbmQga2V5XG4gICAgICAgICAgICAuY2FsbCh5QXhpcyk7XG4gICAgfVxuXG4gICAgLy8gVGhlIHRhYmxlIGdlbmVyYXRpb24gZnVuY3Rpb24uIFVzZWQgZm9yIHRoZSB0YWJsZSBvZiBwZXJmb3JtYW5jZSBtZWFzdXJlcywgbm90IHRoZSBjb25mdXNpb24gbWF0cml4XG4gICAgZnVuY3Rpb24gdGFidWxhdGUoZGF0YSwgY29sdW1ucykge1xuICAgICAgICB2YXIgdGFibGUgPSBkMy5zZWxlY3QoXCIjc2V0eExlZnRQbG90XCIpLmFwcGVuZChcInRhYmxlXCIpXG4gICAgICAgIC5hdHRyKFwic3R5bGVcIiwgXCJtYXJnaW4tbGVmdDogXCIgKyBtYXJnaW4ubGVmdCArXCJweFwiKSxcbiAgICAgICAgdGhlYWQgPSB0YWJsZS5hcHBlbmQoXCJ0aGVhZFwiKSxcbiAgICAgICAgdGJvZHkgPSB0YWJsZS5hcHBlbmQoXCJ0Ym9keVwiKTtcblxuICAgICAgICAvLyBhcHBlbmQgdGhlIGhlYWRlciByb3dcbiAgICAgICAgdGhlYWQuYXBwZW5kKFwidHJcIilcbiAgICAgICAgLnNlbGVjdEFsbChcInRoXCIpXG4gICAgICAgIC5kYXRhKGNvbHVtbnMpXG4gICAgICAgIC5lbnRlcigpXG4gICAgICAgIC5hcHBlbmQoXCJ0aFwiKVxuICAgICAgICAudGV4dChmdW5jdGlvbihjb2x1bW4pIHsgcmV0dXJuIGNvbHVtbjsgfSk7XG5cbiAgICAgICAgLy8gY3JlYXRlIGEgcm93IGZvciBlYWNoIG9iamVjdCBpbiB0aGUgZGF0YVxuICAgICAgICB2YXIgcm93cyA9IHRib2R5LnNlbGVjdEFsbChcInRyXCIpXG4gICAgICAgIC5kYXRhKGRhdGEpXG4gICAgICAgIC5lbnRlcigpXG4gICAgICAgIC5hcHBlbmQoXCJ0clwiKTtcblxuICAgICAgICAvLyBjcmVhdGUgYSBjZWxsIGluIGVhY2ggcm93IGZvciBlYWNoIGNvbHVtblxuICAgICAgICB2YXIgY2VsbHMgPSByb3dzLnNlbGVjdEFsbChcInRkXCIpXG4gICAgICAgIC5kYXRhKGZ1bmN0aW9uKHJvdykge1xuICAgICAgICAgICAgICByZXR1cm4gY29sdW1ucy5tYXAoZnVuY3Rpb24oY29sdW1uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge2NvbHVtbjogY29sdW1uLCB2YWx1ZTogcm93W2NvbHVtbl19O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgIC5lbnRlcigpXG4gICAgICAgIC5hcHBlbmQoXCJ0ZFwiKVxuICAgICAgICAuYXR0cihcInN0eWxlXCIsIFwiZm9udC1mYW1pbHk6IENvdXJpZXJcIikgLy8gc2V0cyB0aGUgZm9udCBzdHlsZVxuICAgICAgICAuaHRtbChmdW5jdGlvbihkKSB7IHJldHVybiBkLnZhbHVlOyB9KTtcblxuICAgICAgICByZXR1cm4gdGFibGU7XG4gICAgfVxuXG4gICAgLy8gdGhpcyBjb2RlIGlzIGFsbCBmb3IgcHJvZHVjaW5nIGEgdGFibGUgd2l0aCBwZXJmb3JtYW5jZSBtZWFzdXJlc1xuICAgIC8vdmFyIGNvbmZ1c2lvbk1hdHJpeCA9IFtbMTY5LCAxMF0sWzcsIDQ2XV07XG4gICAgdmFyIHRwID0gbWF0cml4ZGF0YVswXVswXTtcbiAgICB2YXIgZm4gPSBtYXRyaXhkYXRhWzBdWzFdO1xuICAgIHZhciBmcCA9IG1hdHJpeGRhdGFbMV1bMF07XG4gICAgdmFyIHRuID0gbWF0cml4ZGF0YVsxXVsxXTtcblxuICAgIHZhciBwID0gdHAgKyBmbjtcbiAgICB2YXIgbiA9IGZwICsgdG47XG5cbiAgICB2YXIgYWNjdXJhY3kgPSAodHArdG4pLyhwK24pO1xuICAgIHZhciBmMSA9IDIqdHAvKDIqdHArZnArZm4pO1xuICAgIHZhciBwcmVjaXNpb24gPSB0cC8odHArZnApO1xuICAgIHZhciByZWNhbGwgPSB0cC8odHArZm4pO1xuXG4gICAgYWNjdXJhY3kgPSBNYXRoLnJvdW5kKGFjY3VyYWN5ICogMTAwKSAvIDEwMDtcbiAgICBmMSA9IE1hdGgucm91bmQoZjEgKiAxMDApIC8gMTAwO1xuICAgIHByZWNpc2lvbiA9IE1hdGgucm91bmQocHJlY2lzaW9uICogMTAwKSAvIDEwMDtcbiAgICByZWNhbGwgPSBNYXRoLnJvdW5kKHJlY2FsbCAqIDEwMCkgLyAxMDA7XG5cbiAgICB2YXIgY29tcHV0ZWREYXRhID0gW107XG4gICAgY29tcHV0ZWREYXRhLnB1c2goe1wiRjFcIjpmMSwgXCJQUkVDSVNJT05cIjpwcmVjaXNpb24sXCJSRUNBTExcIjpyZWNhbGwsXCJBQ0NVUkFDWVwiOmFjY3VyYWN5fSk7XG5cbiAgICBNYXRyaXgoe1xuICAgICAgICAgICBjb250YWluZXIgOiAnI2NvbmZ1c2lvbmNvbnRhaW5lcicsXG4gICAgICAgICAgIGRhdGEgICAgICA6IG1hdHJpeGRhdGEsXG4gICAgICAgICAgIGxhYmVscyAgICA6IGNsYXNzZXMsXG4gICAgICAgICAgIHN0YXJ0X2NvbG9yIDogJyNmZmZmZmYnLFxuICAgICAgICAgICBlbmRfY29sb3IgOiAnI2U2N2UyMicsXG4gICAgICAgICAgIHdpZHRoIDogbWFpbndpZHRoICogLjMzICsgMjUgLSBsZWZ0bWFyZ2luZ3Vlc3MsICAgICAgLy8gV2lkdGggb2YgY29uZnVzaW9uIG1hdHJpeCB0YWJsZTogTmVlZCB0byBub3QgYmUgaGFyZCBjb2RlZFxuICAgICAgICAgICBoZWlnaHQgOiBtYWluaGVpZ2h0ICogLjYsICAgIC8vIE5lZWQgdG8gbm90IGJlIGhhcmQgY29kZWRcbiAgICAgICAgICAgd2lkdGhMZWdlbmQgOiBtYWlud2lkdGgqLjA0LFxuICAgICAgICAgICB4X29mZnNldCA6IDMwXG4gICAgICAgICAgIH0pO1xuXG4gICAgLy8gbm90IHJlbmRlcmluZyB0aGlzIHRhYmxlIGZvciByaWdodCBub3csIGxlZnQgYWxsIHRoZSBjb2RlIGluIHBsYWNlIHRob3VnaC4gbWF5YmUgd2UgdXNlIGl0IGV2ZW50dWFsbHlcbiAgICAvLyB2YXIgdGFibGUgPSB0YWJ1bGF0ZShjb21wdXRlZERhdGEsIFtcIkYxXCIsIFwiUFJFQ0lTSU9OXCIsXCJSRUNBTExcIixcIkFDQ1VSQUNZXCJdKTtcbn1cblxuLyoqXG4gICBzY2F0dGVycGxvdCBmdW5jdGlvbiB0byBnbyB0byBwbG90cy5qcyB0byBiZSByZXVzZWRcbiovXG5leHBvcnQgZnVuY3Rpb24gYml2YXJpYXRlUGxvdCh4X0F4aXMsIHlfQXhpcywgeF9BeGlzX25hbWUsIHlfQXhpc19uYW1lKSB7XG4gICAgZDMuc2VsZWN0KFwiI3NldHhMZWZ0UGxvdFwiKS5odG1sKFwiXCIpO1xuICAgIGQzLnNlbGVjdChcIiNzZXR4TGVmdFBsb3RcIikuc2VsZWN0KFwic3ZnXCIpLnJlbW92ZSgpO1xuXG4gICAgeF9BeGlzPXhfQXhpcy5tYXAoTnVtYmVyKTtcbiAgICB5X0F4aXM9eV9BeGlzLm1hcChOdW1iZXIpO1xuXG4gICAgY29uc29sZS5sb2coeF9BeGlzKTtcbiAgICBjb25zb2xlLmxvZyh5X0F4aXMpO1xuXG4gICAgbGV0IG1haW53aWR0aCA9IGJ5SWQoJ21haW4nKS5jbGllbnRXaWR0aDtcbiAgICBsZXQgbWFpbmhlaWdodCA9IGJ5SWQoJ21haW4nKS5jbGllbnRIZWlnaHQ7XG5cbiAgICAvLyBzY2F0dGVyIHBsb3RcbiAgICBsZXQgZGF0YV9wbG90ID0gW107XG4gICAgdmFyIG5hbkNvdW50ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhfQXhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaXNOYU4oeF9BeGlzW2ldKSB8fCBpc05hTih5X0F4aXNbaV0pKSB7XG4gICAgICAgICAgICBuYW5Db3VudCsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG5ld051bWJlcjEgPSB4X0F4aXNbaV07XG4gICAgICAgICAgICB2YXIgbmV3TnVtYmVyMiA9IHlfQXhpc1tpXTtcbiAgICAgICAgICAgIGRhdGFfcGxvdC5wdXNoKHt4YXhpczogbmV3TnVtYmVyMSwgeWF4aXM6IG5ld051bWJlcjIsIHNjb3JlOiBNYXRoLnJhbmRvbSgpICogMTAwfSk7XG5cbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgdmFyIG1hcmdpbiA9IHt0b3A6IDM1LCByaWdodDogMzUsIGJvdHRvbTogMzUsIGxlZnQ6IDM1fVxuICAgICwgd2lkdGggPSBtYWlud2lkdGgqLjI1LSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodFxuICAgICwgaGVpZ2h0ID0gbWFpbndpZHRoKi4yNSAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xuICAgIHZhciBwYWRkaW5nID0gMTAwO1xuXG4gICAgdmFyIG1pbl94ID0gZDMubWluKGRhdGFfcGxvdCwgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFfcGxvdFtpXS54YXhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgdmFyIG1heF94ID0gZDMubWF4KGRhdGFfcGxvdCwgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFfcGxvdFtpXS54YXhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgdmFyIGF2Z194ID0gKG1heF94IC0gbWluX3gpIC8gMTA7XG4gICAgdmFyIG1pbl95ID0gZDMubWluKGRhdGFfcGxvdCwgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFfcGxvdFtpXS55YXhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgdmFyIG1heF95ID0gZDMubWF4KGRhdGFfcGxvdCwgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFfcGxvdFtpXS55YXhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgdmFyIGF2Z195ID0gKG1heF95IC0gbWluX3kpIC8gMTA7XG5cbiAgICB2YXIgeFNjYWxlID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAuZG9tYWluKFttaW5feCAtIGF2Z194LCBtYXhfeCArIGF2Z194XSlcbiAgICAucmFuZ2UoWzAsIHdpZHRoXSk7XG5cbiAgICB2YXIgeVNjYWxlID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAuZG9tYWluKFttaW5feSAtIGF2Z195LCBtYXhfeSArIGF2Z195XSlcbiAgICAucmFuZ2UoW2hlaWdodCwgMF0pO1xuXG4gICAgdmFyIHhBeGlzID0gZDMuc3ZnLmF4aXMoKVxuICAgIC5zY2FsZSh4U2NhbGUpXG4gICAgLm9yaWVudCgnYm90dG9tJylcbiAgICAudGlja1NpemUoLWhlaWdodCk7XG5cbiAgICB2YXIgeUF4aXMgPSBkMy5zdmcuYXhpcygpXG4gICAgLnNjYWxlKHlTY2FsZSlcbiAgICAub3JpZW50KCdsZWZ0JylcbiAgICAudGlja3MoNSlcbiAgICAudGlja1NpemUoLXdpZHRoKTtcblxuICAgIHZhciB6b29tID0gZDMuYmVoYXZpb3Iuem9vbSgpXG4gICAgLngoeFNjYWxlKVxuICAgIC55KHlTY2FsZSlcbiAgICAuc2NhbGVFeHRlbnQoWzEsIDEwXSlcbiAgICAub24oXCJ6b29tXCIsIHpvb21lZCk7XG5cbiAgICB2YXIgY2hhcnRfc2NhdHRlciA9IGQzLnNlbGVjdCgnI3NldHhMZWZ0UGxvdCcpXG4gICAgLmFwcGVuZCgnc3ZnOnN2ZycpXG4gICAgLmF0dHIoJ3dpZHRoJywgd2lkdGggKyBtYXJnaW4ucmlnaHQgKyBtYXJnaW4ubGVmdClcbiAgICAuYXR0cignaGVpZ2h0JywgaGVpZ2h0ICsgbWFyZ2luLnRvcCArIG1hcmdpbi5ib3R0b20pO1xuICAgIC8vIC5jYWxsKHpvb20pOyBkcm9wcGluZyB0aGlzIGZvciBub3csIHVudGlsIHRoZSBsaW5lIHpvb21zIHByb3Blcmx5XG5cbiAgICB2YXIgbWFpbjEgPSBjaGFydF9zY2F0dGVyLmFwcGVuZCgnZycpXG4gICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIG1hcmdpbi5sZWZ0ICsgJywnICsgbWFyZ2luLnRvcCArICcpJylcbiAgICAuYXR0cignd2lkdGgnLCB3aWR0aCsgbWFyZ2luLnJpZ2h0ICsgbWFyZ2luLmxlZnQpXG4gICAgLmF0dHIoJ2hlaWdodCcsIGhlaWdodCArIG1hcmdpbi50b3AgKyBtYXJnaW4uYm90dG9tKVxuICAgIC5hdHRyKCdjbGFzcycsICdtYWluJyk7XG5cbiAgICBsZXQgZ1ggPSBtYWluMS5hcHBlbmQoJ2cnKVxuICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsJyArIGhlaWdodCArICcpJylcbiAgICAuYXR0cignY2xhc3MnLCAneCBheGlzJylcbiAgICAuY2FsbCh4QXhpcyk7XG5cbiAgICBsZXQgZ1kgPSBtYWluMS5hcHBlbmQoJ2cnKVxuICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsMCknKVxuICAgIC5hdHRyKCdjbGFzcycsICd5IGF4aXMnKVxuICAgIC5jYWxsKHlBeGlzKTtcblxuICAgIHZhciBjbGlwID0gbWFpbjEuYXBwZW5kKFwiZGVmc1wiKS5hcHBlbmQoXCJzdmc6Y2xpcFBhdGhcIilcbiAgICAuYXR0cihcImlkXCIsIFwiY2xpcFwiKVxuICAgIC5hcHBlbmQoXCJzdmc6cmVjdFwiKVxuICAgIC5hdHRyKFwiaWRcIiwgXCJjbGlwLXJlY3RcIilcbiAgICAuYXR0cihcInhcIiwgXCIwXCIpXG4gICAgLmF0dHIoXCJ5XCIsIFwiMFwiKVxuICAgIC5hdHRyKCd3aWR0aCcsIHdpZHRoKVxuICAgIC5hdHRyKCdoZWlnaHQnLCBoZWlnaHQpO1xuXG4gICAgbWFpbjEuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xpcC1wYXRoXCIsIFwidXJsKCNjbGlwKVwiKVxuICAgIC5zZWxlY3RBbGwoXCJjaXJjbGVcIilcbiAgICAuZGF0YShkYXRhX3Bsb3QpXG4gICAgLmVudGVyKClcbiAgICAuYXBwZW5kKFwiY2lyY2xlXCIpXG4gICAgLmF0dHIoXCJjeFwiLCAoZCwgaSkgPT4geFNjYWxlKGRhdGFfcGxvdFtpXS54YXhpcykpXG4gICAgLmF0dHIoXCJjeVwiLCAoZCwgaSkgPT4geVNjYWxlKGRhdGFfcGxvdFtpXS55YXhpcykpXG4gICAgLmF0dHIoXCJyXCIsIDIpXG4gICAgLnN0eWxlKFwiZmlsbFwiLCBcIiNCNzFDMUNcIik7XG5cblxuICAgIGNoYXJ0X3NjYXR0ZXIuYXBwZW5kKFwidGV4dFwiKVxuICAgIC5hdHRyKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIikgIC8vIHRoaXMgbWFrZXMgaXQgZWFzeSB0byBjZW50cmUgdGhlIHRleHQgYXMgdGhlIHRyYW5zZm9ybSBpcyBhcHBsaWVkIHRvIHRoZSBhbmNob3JcbiAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIHBhZGRpbmcgLyA1ICsgXCIsXCIgKyAoaGVpZ2h0IC8gMikgKyBcIilyb3RhdGUoLTkwKVwiKSAgLy8gdGV4dCBpcyBkcmF3biBvZmYgdGhlIHNjcmVlbiB0b3AgbGVmdCwgbW92ZSBkb3duIGFuZCBvdXQgYW5kIHJvdGF0ZVxuICAgIC50ZXh0KHlfQXhpc19uYW1lKVxuICAgIC5zdHlsZShcImZpbGxcIiwgXCIjNDI0MjQyXCIpXG4gICAgLnN0eWxlKFwidGV4dC1pbmRlbnRcIixcIjIwcHhcIilcbiAgICAuc3R5bGUoXCJmb250LXNpemVcIixcIjEycHhcIilcbiAgICAuc3R5bGUoXCJmb250LXdlaWdodFwiLFwiYm9sZFwiKTtcblxuICAgIGNoYXJ0X3NjYXR0ZXIuYXBwZW5kKFwidGV4dFwiKVxuICAgIC5hdHRyKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIikgIC8vIHRoaXMgbWFrZXMgaXQgZWFzeSB0byBjZW50cmUgdGhlIHRleHQgYXMgdGhlIHRyYW5zZm9ybSBpcyBhcHBsaWVkIHRvIHRoZSBhbmNob3JcbiAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArICh3aWR0aCAvIDIpICsgXCIsXCIgKyAoaGVpZ2h0ICsgKHBhZGRpbmcgLyAyKSkgKyBcIilcIikgIC8vIGNlbnRyZSBiZWxvdyBheGlzXG4gICAgLnRleHQoeF9BeGlzX25hbWUpXG4gICAgLnN0eWxlKFwiZmlsbFwiLCBcIiM0MjQyNDJcIilcbiAgICAuc3R5bGUoXCJ0ZXh0LWluZGVudFwiLFwiMjBweFwiKVxuICAgIC5zdHlsZShcImZvbnQtc2l6ZVwiLFwiMTJweFwiKVxuICAgIC5zdHlsZShcImZvbnQtd2VpZ2h0XCIsXCJib2xkXCIpO1xuXG5cbiAgICBtYWluMS5hcHBlbmQoXCJsaW5lXCIpXG4gICAgLmF0dHIoXCJ4MVwiLCB4U2NhbGUobWluX3gpKVxuICAgIC5hdHRyKFwieTFcIiwgeVNjYWxlKG1pbl94KSlcbiAgICAuYXR0cihcIngyXCIsIHhTY2FsZShtYXhfeCkpXG4gICAgLmF0dHIoXCJ5MlwiLCB5U2NhbGUobWF4X3gpKVxuICAgIC5hdHRyKFwic3Ryb2tlLXdpZHRoXCIsIDIpXG4gICAgLmF0dHIoXCJzdHJva2VcIiwgXCJibGFja1wiKTtcblxuICAgIGZ1bmN0aW9uIHpvb21lZCgpIHtcbiAgICAgICAgdmFyIHBhblggPSBkMy5ldmVudC50cmFuc2xhdGVbMF07XG4gICAgICAgIHZhciBwYW5ZID0gZDMuZXZlbnQudHJhbnNsYXRlWzFdO1xuICAgICAgICB2YXIgc2NhbGUgPSBkMy5ldmVudC5zY2FsZTtcblxuICAgICAgICBwYW5YID0gcGFuWCA+IDEwID8gMTAgOiBwYW5YO1xuICAgICAgICB2YXIgbWF4WCA9IC0oc2NhbGUgLSAxKSAqIHdpZHRoIC0gMTA7XG4gICAgICAgIHBhblggPSBwYW5YIDwgbWF4WCA/IG1heFggOiBwYW5YO1xuXG4gICAgICAgIHBhblkgPSBwYW5ZID4gMTAgPyAxMCA6IHBhblk7XG4gICAgICAgIHZhciBtYXhZID0gLShzY2FsZSAtIDEpICogaGVpZ2h0IC0gMTA7XG4gICAgICAgIHBhblkgPSBwYW5ZIDwgbWF4WSA/IG1heFkgOiBwYW5ZO1xuXG4gICAgICAgIHpvb20udHJhbnNsYXRlKFtwYW5YLCBwYW5ZXSk7XG5cblxuICAgICAgICBtYWluMS5zZWxlY3QoXCIueC5heGlzXCIpLmNhbGwoeEF4aXMpO1xuICAgICAgICBtYWluMS5zZWxlY3QoXCIueS5heGlzXCIpLmNhbGwoeUF4aXMpO1xuICAgICAgICBtYWluMS5zZWxlY3RBbGwoXCJjaXJjbGVcIilcbiAgICAgICAgLmF0dHIoXCJjeFwiLCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImNpcmNsZSB4IFwiLHhTY2FsZSg1KSk7XG4gICAgICAgICAgICAgIHJldHVybiB4U2NhbGUoZGF0YV9wbG90W2ldLnhheGlzKTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoXCJjeVwiLCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgICByZXR1cm4geVNjYWxlKGRhdGFfcGxvdFtpXS55YXhpcyk7XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgIC5hdHRyKFwiclwiLCAyLjUpXG4gICAgICAgIC5zdHlsZShcImZpbGxcIiwgXCIjQjcxQzFDXCIpO1xuXG4gICAgICAgLy8gYmVsb3cgZG9lc24ndCB3b3JrLCBzbyBJJ20ganVzdCBkcm9wcGluZyB0aGUgem9vbVxuICAgICAgICBtYWluMS5zZWxlY3QoXCJsaW5lXCIpXG4gICAgICAgIC5hdHRyKFwieDFcIiwgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgICByZXR1cm4geFNjYWxlKG1pbl94KTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoXCJ5MVwiLCBmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB4U2NhbGUobWluX3gpO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAuYXR0cihcIngyXCIsIGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHhTY2FsZShtYXhfeCk7XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgIC5hdHRyKFwieTJcIiwgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgICByZXR1cm4geVNjYWxlKG1heF94KTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoXCJzdHJva2Utd2lkdGhcIiwgMilcbiAgICAgICAgLmF0dHIoXCJzdHJva2VcIiwgXCJibGFja1wiKTtcbiAgICB9XG4gICAgLy8gIGQzLnNlbGVjdChcIiNOQWNvdW50XCIpLnRleHQoXCJUaGVyZSBhcmUgXCIgKyBuYW5Db3VudCArIFwiIG51bWJlciBvZiBOQSB2YWx1ZXMgaW4gdGhlIHJlbGF0aW9uLlwiKTtcbn1cblxuLyoqIG5lZWRzIGRvYyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldHhUYWJsZShmZWF0dXJlcykge1xuICAgIGZ1bmN0aW9uIHRhYnVsYXRlKGRhdGEsIGNvbHVtbnMpIHtcbiAgICAgICAgdmFyIHRhYmxlID0gZDMuc2VsZWN0KCcjc2V0eExlZnRCb3R0b21MZWZ0JykuYXBwZW5kKCd0YWJsZScpO1xuICAgICAgICB2YXIgdGhlYWQgPSB0YWJsZS5hcHBlbmQoJ3RoZWFkJyk7XG4gICAgICAgIHZhclx0dGJvZHkgPSB0YWJsZS5hcHBlbmQoJ3Rib2R5Jyk7XG5cbiAgICAgICAgLy8gYXBwZW5kIHRoZSBoZWFkZXIgcm93XG4gICAgICAgIHRoZWFkLmFwcGVuZCgndHInKVxuICAgICAgICAuc2VsZWN0QWxsKCd0aCcpXG4gICAgICAgIC5kYXRhKGNvbHVtbnMpLmVudGVyKClcbiAgICAgICAgLmFwcGVuZCgndGgnKVxuICAgICAgICAudGV4dChmdW5jdGlvbiAoY29sdW1uKSB7IHJldHVybiBjb2x1bW47IH0pO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBhIHJvdyBmb3IgZWFjaCBvYmplY3QgaW4gdGhlIGRhdGFcbiAgICAgICAgdmFyIHJvd3MgPSB0Ym9keS5zZWxlY3RBbGwoJ3RyJylcbiAgICAgICAgLmRhdGEoZGF0YSlcbiAgICAgICAgLmVudGVyKClcbiAgICAgICAgLmFwcGVuZCgndHInKTtcblxuICAgICAgICAvLyBjcmVhdGUgYSBjZWxsIGluIGVhY2ggcm93IGZvciBlYWNoIGNvbHVtblxuICAgICAgICB2YXIgY2VsbHMgPSByb3dzLnNlbGVjdEFsbCgndGQnKVxuICAgICAgICAgICAgLmRhdGEoZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2x1bW5zLm1hcChmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7Y29sdW1uOiBjb2x1bW4sIHZhbHVlOiByb3dbY29sdW1uXX07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmVudGVyKClcbiAgICAgICAgICAgIC5hcHBlbmQoJ3RkJylcbiAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLnZhbHVlOyB9KVxuICAgICAgICAgICAgLmF0dHIoJ2lkJyxmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICBsZXQgcm93bmFtZSA9IHRoaXMucGFyZW50RWxlbWVudC5maXJzdENoaWxkLmlubmVyVGV4dDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcm93bmFtZSArIGQuY29sdW1uO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRhYmxlO1xuICAgIH1cblxuICAgIGxldCBteWRhdGEgPSBbXTtcbiAgICBmb3IobGV0IGkgPSAwOyBpPGZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBteWkgPSBmaW5kTm9kZUluZGV4KGZlYXR1cmVzW2ldKTsgLy9pKzE7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHdhcyBzZXQgYXMgKGkrMSksIGJ1dCBzaG91bGQgYmUgYWxsbm9kZXMgcG9zaXRpb24sIG5vdCBmZWF0dXJlcyBwb3NpdGlvblxuXG4gICAgICAgIGlmKGFsbE5vZGVzW215aV0udmFsaWQ9PTApIHtcbiAgICAgICAgICAgIGxldCB4dmFsPTA7XG4gICAgICAgICAgICBsZXQgeDF2YWw9MDtcbiAgICAgICAgICAgIG15ZGF0YS5wdXNoKHtcIlZhcmlhYmxlc1wiOmZlYXR1cmVzW2ldLFwiRnJvbVwiOnh2YWwsIFwiVG9cIjp4MXZhbH0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbXlzdmcgPSBmZWF0dXJlc1tpXStcIl9zZXR4TGVmdF9cIitteWk7XG5cbiAgICAgICAgdHJ5XG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2cobXlzdmcpO1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhieUlkKG15c3ZnKS5xdWVyeVNlbGVjdG9yKCcueHZhbCcpKTtcbiAgICAgICAgICAgIGxldCB4dmFsID0gYnlJZChteXN2ZykucXVlcnlTZWxlY3RvcignLnh2YWwnKS5pbm5lckhUTUw7XG4gICAgICAgICAgICBsZXQgeDF2YWwgPSBieUlkKG15c3ZnKS5xdWVyeVNlbGVjdG9yKCcueDF2YWwnKS5pbm5lckhUTUw7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKHh2YWwpO1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyh4MXZhbCk7XG4gICAgICAgICAgICB4dmFsID0geHZhbC5zcGxpdChcIng6IFwiKS5wb3AoKTtcbiAgICAgICAgICAgIHgxdmFsID0geDF2YWwuc3BsaXQoXCJ4MTogXCIpLnBvcCgpO1xuICAgICAgICAgICAgbXlkYXRhLnB1c2goe1wiVmFyaWFibGVzXCI6ZmVhdHVyZXNbaV0sXCJGcm9tXCI6eHZhbCwgXCJUb1wiOngxdmFsfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2goZXJyb3IpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmVuZGVyIHRoZSB0YWJsZShzKVxuICAgIHRhYnVsYXRlKG15ZGF0YSwgWydWYXJpYWJsZXMnLCAnRnJvbScsICdUbyddKTsgLy8gMiBjb2x1bW4gdGFibGVcbn1cblxuLyoqXG4gIHJwYyBFeHBvcnRQaXBlbGluZShQaXBlbGluZUV4cG9ydFJlcXVlc3QpIHJldHVybnMgKFJlc3BvbnNlKSB7fVxuKi9cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGV4cG9ydHBpcGVsaW5lKHBpcGVsaW5lSWQpIHtcbiAgICBsZXQgdGVtcCA9IHtwaXBlbGluZUlkLCBjb250ZXh0OiBhcGlTZXNzaW9uKHpwYXJhbXMuenNlc3Npb25pZCksIHBpcGVsaW5lRXhlY1VyaTogJzw8RVhFQ1VUQUJMRV9VUkk+Pid9O1xuXG4gICAgbGV0IHJlcyA9IGF3YWl0IG1ha2VSZXF1ZXN0KFxuICAgICAgICBEM01fU1ZDX1VSTCArICcvZXhwb3J0cGlwZWxpbmUnLFxuICAgICAgICB7cGlwZWxpbmVJZCwgY29udGV4dDogYXBpU2Vzc2lvbih6cGFyYW1zLnpzZXNzaW9uaWQpLCBwaXBlbGluZUV4ZWNVcmk6ICc8PEVYRUNVVEFCTEVfVVJJPj4nfSk7XG5cbiAgICAvLyB3ZSBuZWVkIHN0YW5kYXJkaXplZCBzdGF0dXMgbWVzc2FnZXMuLi5cbiAgICBsZXQgbXlzdGF0dXMgPSByZXMuc3RhdHVzO1xuICAgIGlmICh0eXBlb2YgbXlzdGF0dXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYobXlzdGF0dXMuY29kZT09XCJGQUlMRURfUFJFQ09ORElUSU9OXCIpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJUQTIgaGFzIG5vdCB3cml0dGVuIHRoZSBleGVjdXRhYmxlLlwiKTsgICAgLy8gd2FzIGFsZXJ0KCksIGJ1dCB0ZXN0aW5nIG9uIE5JU1QgaW5mcmFzdHJ1Y3R1cmUgc3VnZ2VzdHMgdGhlc2UgYXJlIGdldHRpbmcgd3JpdHRlbiBidXQgdHJpZ2dlcmluZyBhbGVydC5cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBFeGVjdXRhYmxlIGZvciAke3BpcGVsaW5lSWR9IGhhcyBiZWVuIHdyaXR0ZW5gKTtcbiAgICB9fVxuICAgIHJldHVybiByZXM7XG59XG5cbi8qKiBuZWVkcyBkb2MgKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWxldGVwaXBlbGluZSgpIHtcbiAgICBjb25zb2xlLmxvZyhcIkRFTEVURSBDQUxMRURcIik7XG59XG5cbi8qKlxuICAgRDNNIEFQSSBIRUxQRVJTXG4gICBiZWNhdXNlIHRoZXNlIGdldCBidWlsdCBpbiB2YXJpb3VzIHBsYWNlcywgcHVsbGluZyB0aGVtIG91dCBmb3IgZWFzeSBtYW5pcHVsYXRpb25cbiovXG5mdW5jdGlvbiBhcGlGZWF0dXJlICh2YXJzLCB1cmkpIHtcbiAgICBsZXQgb3V0ID0gW107XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IHZhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgb3V0LnB1c2goe2ZlYXR1cmVJZDp2YXJzW2ldLGRhdGFVcmk6dXJpfSk7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKiBuZWVkcyBkb2MgKi9cbmZ1bmN0aW9uIGFwaUZlYXR1cmVTaG9ydFBhdGggKHZhcnMsIHVyaSkge1xuICAgIGxldCBvdXQgPSBbXTtcbiAgICBsZXQgc2hvcnRVcmkgPSB1cmkuc3Vic3RyaW5nKDAsIHVyaS5sYXN0SW5kZXhPZihcIi9cIikpO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCB2YXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG91dC5wdXNoKHtmZWF0dXJlSWQ6dmFyc1tpXSxkYXRhVXJpOnNob3J0VXJpfSk7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICAgc2lsbHkgYnV0IHBlcmhhcHMgdXNlZnVsIGlmIGluIHRoZSBmdXR1cmUgU2Vzc2lvbkNvbnRleHQgcmVxdWlyZXMgbW9yZSB0aGluZ3MgKGFzIHN1Z2dlc3QgYnkgY29yZSlcbiovXG5mdW5jdGlvbiBhcGlTZXNzaW9uKGNvbnRleHQpIHtcbiAgICByZXR1cm4ge3Nlc3Npb25faWQ6IGNvbnRleHR9O1xufVxuXG5cbi8qKlxuICogIFNlbmQgYSBzdGF0dXMgbWVzc2FnZSB0byB0aGUgVEEzIGNvbnNvbGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRhM19zZWFyY2hfbWVzc2FnZSh1c2VyX21zZyl7XG4gIC8qXG4gIGxldCB0YTNfc2VhcmNoX21lc3NhZ2UgPSB7J21lc3NhZ2UnOiB1c2VyX21zZ31cblxuICBjb25zdCBlbmRfc2VhcmNoX3VybCA9ICd0YTMtc2VhcmNoL3NlbmQtcmV2aWV3ZXItbWVzc2FnZSc7XG5cbiAgdHJ5IHtcbiAgICAgIGxldCByZXMgPSBtLnJlcXVlc3QoZW5kX3NlYXJjaF91cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHttZXRob2Q6ICdQT1NUJywgZGF0YTogdGEzX3NlYXJjaF9tZXNzYWdlfSk7XG4gICAgICBjb25zb2xlLmxvZygndGEzX3NlYXJjaF9tZXNzYWdlIHN1Y2NlZWRlZDonICsgcmVzKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmxvZygndGEzX3NlYXJjaF9tZXNzYWdlIGZhaWxlZDogJyArIGVycik7XG4gIH1cbiAgKi9cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRlc3RfbXNnX3RhM19zZWFyY2goKXtcbiAgLy9lbmRfdGEzX3NlYXJjaCh0cnVlLCAnaXQgd29ya2VkIScpO1xuICAvL2VuZF90YTNfc2VhcmNoKGZhbHNlLCAnaXQgZmFpbGVkIScpO1xuICAvL3RhM19zZWFyY2hfbWVzc2FnZSgnanVzdCBzZW5kaW5nIGEgbWVzc2FnZSEnKTtcbn1cblxuLyoqXG4gKiAgRW5kIHRoZSBUQTMgc2VhcmNoLiAgVGhpcyBzZW5kcyBhIG1lc3NhZ2VcbiAqICB0byB0aGUgdGEzX3NlYXJjaCBjb25zb2xlIGFzIHdlbGwgYXMgbWVzc2FnZVxuICogIGZvciB0aGUgY29uc29sZSB0byBleGl0IHdpdGggYTpcbiAqICAtIHJldHVybiBjb2RlIDAgZm9yIHN1Y2Nlc3NcbiAqICAtIHJldHVybiBjb2RlIC0xIGZvciBmYWlsdXJlXG4gKlxuICogID4gaXNfc3VjY2VzcyAtIGJvb2xlYW5cbiAqICA+IHVzZXJfbXNnIC0gc3RyaW5nIHNlbnQgdG8gdGhlIGNvbnNvbGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuZF90YTNfc2VhcmNoKGlzX3N1Y2Nlc3MsIHVzZXJfbXNnKXtcblxuICAvLyA2LzIxLzIwMTggLSByZW1vdmVkIGZyb20gZXZhbFxuICAvKlxuICBsZXQgZW5kX3NlYXJjaF9tc2cgPSB7J2lzX3N1Y2Nlc3MnOiBpc19zdWNjZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21lc3NhZ2UnOiB1c2VyX21zZ31cblxuICBjb25zdCBlbmRfc2VhcmNoX3VybCA9ICd0YTMtc2VhcmNoL2VuZC1zZWFyY2gnO1xuXG4gIHRyeSB7XG4gICAgICBsZXQgcmVzID0gbS5yZXF1ZXN0KGVuZF9zZWFyY2hfdXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB7bWV0aG9kOiAnUE9TVCcsIGRhdGE6IGVuZF9zZWFyY2hfbXNnfSk7XG4gICAgICBjb25zb2xlLmxvZygnZW5kX3RhM19zZWFyY2ggc3VjY2VlZGVkOicgKyByZXMpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdlbmRfdGEzX3NlYXJjaCBmYWlsZWQ6ICcgKyBlcnIpO1xuICB9XG4gICovXG59XG5cbi8qKlxuICogIHJlY29yZCB1c2VyIG1ldGFkYXRhXG4gKi9cbmxldCByZWNvcmRlcl9jbnQgPSAwO1xuY29uc3Qgc2F2ZV93b3Jrc3BhY2VfdXJsID0gJy93b3Jrc3BhY2VzL3JlY29yZC11c2VyLXdvcmtzcGFjZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiByZWNvcmRfdXNlcl9tZXRhZGF0YSgpe1xuXG4gIC8vIHR1cm5pbmcgb2ZmIGZvciBub3dcbiAgcmV0dXJuO1xuXG4gIC8vICgxKSBTZXQgZG9tYWluIGlkZW50aWZpZXI6IGRpZmZlcnMgZm9yIEQzTSwgRGF0YXZlcnNlLCBldGNcbiAgLy9cbiAgdmFyIGRvbWFpbl9pZGVudGlmaWVyID0gJ3Vua25vd24hJztcbiAgaWYgKElTX0QzTV9ET01BSU4peyAvLyBkb21haW4gc3BlY2lmaWMgaWRlbnRpZmllclxuICAgIGRvbWFpbl9pZGVudGlmaWVyID0gZG9tYWluSWRlbnRpZmllcjtcbiAgfS8qZWxzZSBpZiAoSVNfREFUQVZFUlNFX0RPTUFJTil7XG4gICAgZG9tYWluX2lkZW50aWZpZXIgPSAnVE9ETzogRFYgSURFTlRJRklFUic7XG4gIH1lbHNlIGlmIChJU19FVkVOVERBVEFfRE9NQUlOKXtcbiAgICBkb21haW5faWRlbnRpZmllciA9ICdUT0RPOiBFVkVOVERBVEEgSURFTlRJRklFUic7XG4gIH0qL1xuXG4gIGlmICh6cGFyYW1zID09IG51bGwpe1xuICAgIGNvbnNvbGUubG9nKCdObyB3b3Jrc3BhY2UgcmVjb3JkaW5nLiB6cGFyYW1zIG5vdCBkZWZpbmVkJyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChhbGxOb2RlcyA9PSBudWxsKXtcbiAgICBjb25zb2xlLmxvZygnTm8gd29ya3NwYWNlIHJlY29yZGluZy4genBhcmFtcyBub3QgZGVmaW5lZCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vICgyKSBGb3JtYXQgd29ya3NwYWNlIGRhdGFcbiAgLy9cbiAgbGV0IHdvcmtzcGFjZV9kYXRhID0geydhcHBfZG9tYWluJzogQVBQX0RPTUFJTixcbiAgICAgICAgICAgICAgICAgICAgICAgICdkb21haW5faWRlbnRpZmllcic6IGRvbWFpbl9pZGVudGlmaWVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2FsbG5vZGVzJzogYWxsTm9kZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAnenBhcmFtcyc6IHpwYXJhbXN9XG5cbiAgICAgICAgLy9jb25zb2xlLmxvZygnd29ya3NwYWNlX2RhdGE6ICcgKyB3b3Jrc3BhY2VfZGF0YSk7XG5cbiAgICAgIC8vICgzKSBTYXZlIHdvcmtzcGFjZSBkYXRhXG4gICAgICAvL1xuICAgICAgdHJ5IHtcbiAgICAgICAgICBsZXQgcmVzID0gbS5yZXF1ZXN0KHNhdmVfd29ya3NwYWNlX3VybCwge21ldGhvZDogJ1BPU1QnLCBkYXRhOiB3b3Jrc3BhY2VfZGF0YX0pO1xuICAgICAgICAgIHJlY29yZGVyX2NudCsrO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdTZXNzaW9uIHJlY29yZGVkOiAoY250OiAnICsgcmVjb3JkZXJfY250ICsgJykgJyArIHJlcyk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygncmVjb3JkX3VzZXJfbWV0YWRhdGEgZmFpbGVkOiAnICsgZXJyKTtcbiAgICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNob3dQcmVkUGxvdCAoYnRuKSB7XG4gICAgaWYoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzZXR4TGVmdEdlblwiKS5zdHlsZS5kaXNwbGF5PT1cIm5vbmVcIilcbiAgICAgICAgcmV0dXJuO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2V0eExlZnRQbG90XCIpLnN0eWxlLmRpc3BsYXk9XCJibG9ja1wiO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2V0eExlZnRHZW5cIikuc3R5bGUuZGlzcGxheT1cIm5vbmVcIjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNob3dHZW5QcmVkcyAoYnRuKSB7XG4gICAgaWYoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzZXR4TGVmdFBsb3RcIikuc3R5bGUuZGlzcGxheT09XCJub25lXCIpXG4gICAgICAgIHJldHVybjtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNldHhMZWZ0UGxvdFwiKS5zdHlsZS5kaXNwbGF5PVwibm9uZVwiO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2V0eExlZnRHZW5cIikuc3R5bGUuZGlzcGxheT1cImJsb2NrXCI7XG59XG5cbmZ1bmN0aW9uIHNpbmdsZVBsb3QocHJlZCkge1xuICAgIGQzLnNlbGVjdCgnI3NldHhMZWZ0VG9wUmlnaHQnKS5zZWxlY3RBbGwoJ3N2ZycpLnJlbW92ZSgpO1xuICAgIGxldCBpID0gZmluZE5vZGVJbmRleChwcmVkKTtcbiAgICBsZXQgbm9kZSA9IGFsbE5vZGVzW2ldO1xuICAgIG5vZGUuc2V0eHBsb3QgPSBmYWxzZTtcbiAgICAgICAgbm9kZS5zdWJzZXRwbG90ID0gZmFsc2U7XG4gICAgICAgIGlmIChub2RlLnBsb3R0eXBlID09PSBcImNvbnRpbnVvdXNcIiAmIG5vZGUuc2V0eHBsb3QgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG5vZGUuc2V0eHBsb3QgPSB0cnVlO1xuICAgICAgICAgICAgZGVuc2l0eShub2RlLCBkaXYgPSBcInNldHhMZWZ0VG9wUmlnaHRcIiwgcHJpdik7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS5wbG90dHlwZSA9PT0gXCJiYXJcIiAmIG5vZGUuc2V0eHBsb3QgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG5vZGUuc2V0eHBsb3QgPSB0cnVlO1xuICAgICAgICAgICAgYmFycyhub2RlLCBkaXYgPSBcInNldHhMZWZ0VG9wUmlnaHRcIiwgcHJpdik7XG4gICAgICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpc2NvdmVyeShwcmVwcm9jZXNzX2ZpbGUpIHtcblxuICAgIC8vIGNvbnNvbGUubG9nKFwiZW50ZXJpbmcgZGlzY29cIik7XG4gICAgbGV0IGV4dHJhY3QgPSBwcmVwcm9jZXNzX2ZpbGUuZGF0YXNldC5kaXNjb3Zlcnk7XG4gICAgLy8gY29uc29sZS5sb2coZXh0cmFjdCk7XG4gICAgbGV0IGRpc2NvID0gW107XG4gICAgbGV0IG5hbWVzID0gW107XG4gICAgbGV0IHZhcnMgPSBPYmplY3Qua2V5cyhwcmVwcm9jZXNzKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV4dHJhY3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbmFtZXNbaV0gPSBcIlByb2JsZW1cIiArIChpICsgMSk7XG4gICAgICAgIGxldCBjdXJyZW50X3RhcmdldCA9IGV4dHJhY3RbaV1bXCJ0YXJnZXRcIl07XG4gICAgICAgIGxldCBqID0gZmluZE5vZGVJbmRleChjdXJyZW50X3RhcmdldCk7XG4gICAgICAgIGxldCBub2RlID0gYWxsTm9kZXNbal07XG4gICAgICAgIGxldCBjdXJyZW50X3ByZWRpY3RvcnMgPSBleHRyYWN0W2ldW1wicHJlZGljdG9yc1wiXTtcbiAgICAgICAgbGV0IGN1cnJlbnRfdGFzayA9IG5vZGUucGxvdHR5cGUgPT09IFwiYmFyXCIgPyAnY2xhc3NpZmljYXRpb24nIDogJ3JlZ3Jlc3Npb24nO1xuICAgICAgICBsZXQgY3VycmVudF9yYXRpbmcgPSAzO1xuICAgICAgICBsZXQgY3VycmVudF9kZXNjcmlwdGlvbiA9IGN1cnJlbnRfdGFyZ2V0ICsgXCIgaXMgcHJlZGljdGVkIGJ5IFwiICsgY3VycmVudF9wcmVkaWN0b3JzLmpvaW4oXCIgYW5kIFwiKTtcbiAgICAgICAgbGV0IGN1cnJlbnRfbWV0cmljID0gbm9kZS5wbG90dHlwZSA9PT0gXCJiYXJcIiA/ICdmMU1hY3JvJyA6ICdtZWFuU3F1YXJlZEVycm9yJztcbiAgICAgICAgbGV0IGN1cnJlbnRfZGlzY28gPSB7dGFyZ2V0OiBjdXJyZW50X3RhcmdldCwgcHJlZGljdG9yczogY3VycmVudF9wcmVkaWN0b3JzLCB0YXNrOiBjdXJyZW50X3Rhc2ssIHJhdGluZzogY3VycmVudF9yYXRpbmcsIGRlc2NyaXB0aW9uOiBjdXJyZW50X2Rlc2NyaXB0aW9uLCBtZXRyaWM6IGN1cnJlbnRfbWV0cmljfTtcbiAgICAgICAgLy9qUXVlcnkuZXh0ZW5kKHRydWUsIGN1cnJlbnRfZGlzY28sIG5hbWVzKTtcbiAgICAgICAgZGlzY29baV0gPSBjdXJyZW50X2Rpc2NvO1xuICAgIH07XG4gICAgLyogUHJvYmxlbSBBcnJheSBvZiB0aGUgRm9ybTpcbiAgICAgICAgWzE6IHt0YXJnZXQ6XCJIb21lX3J1bnNcIixcbiAgICAgICAgICAgIHByZWRpY3RvcnM6W1wiV2Fsa3NcIixcIlJCSXNcIl0sXG4gICAgICAgICAgICB0YXNrOlwicmVncmVzc2lvblwiLFxuICAgICAgICAgICAgcmF0aW5nOjUsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJIb21lX3J1bnMgaXMgcHJlZGljdGVkIGJ5IFdhbGtzIGFuZCBSQklzXCIsXG4gICAgICAgICAgICBtZXRyaWM6IFwibWVhblNxdWFyZWRFcnJvclwiXG4gICAgICAgIH0sMjp7Li4ufV1cbiAgICAqL1xuICAgIHJldHVybiBkaXNjbztcbn1cblxuLy8gVGhpcyBzdG9yZXMgZGlzY292ZXJ5IHByb2JsZW1zXG5leHBvcnQgbGV0IHByb2J0YWJsZSA9IFtdO1xuXG5leHBvcnQgbGV0IHNlbGVjdGVkUHJvYmxlbTtcbmV4cG9ydCBsZXQgc2V0U2VsZWN0ZWRQcm9ibGVtID0gKHByb2JsZW0pID0+IHNlbGVjdGVkUHJvYmxlbSA9IHByb2JsZW07XG5cbmV4cG9ydCBsZXQgY2hlY2tlZERpc2NvdmVyeVByb2JsZW1zID0gbmV3IFNldCgpO1xuZXhwb3J0IGxldCBzZXRDaGVja2VkRGlzY292ZXJ5UHJvYmxlbSA9IChzdGF0dXMsIHByb2JsZW0pID0+IHtcbiAgICBpZiAocHJvYmxlbSAhPT0gdW5kZWZpbmVkKSBzdGF0dXMgPyBjaGVja2VkRGlzY292ZXJ5UHJvYmxlbXMuYWRkKHByb2JsZW0pIDogY2hlY2tlZERpc2NvdmVyeVByb2JsZW1zLmRlbGV0ZShwcm9ibGVtKTtcbiAgICBlbHNlIGNoZWNrZWREaXNjb3ZlcnlQcm9ibGVtcyA9IHN0YXR1cyA/IG5ldyBTZXQocHJvYnRhYmxlLm1hcCgocHJvYmxlbSkgPT4gcHJvYmxlbVswXSkpIDogbmV3IFNldCgpO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc3VibWl0RGlzY1Byb2IoKSB7XG4gICAgZGlzY292ZXJ5TGFkZGEuc3RhcnQoKTtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgZGlzY28ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYoIWNoZWNrZWREaXNjb3ZlcnlQcm9ibGVtcy5oYXMoaSkpIGNvbnRpbnVlO1xuICAgICAgICAvL2NyZWF0ZXBpcGVsaW5lIGNhbGxcbiAgICAgICAgY29uc29sZS5sb2coZGlzY28pO1xuICAgICAgICBsZXQgYXV4ID0ge1widGFza1wiOmQzbVRhc2tUeXBlW2Rpc2NvW2ldLnRhc2tdWzFdLCBcIm1ldHJpY3NcIjpkM21NZXRyaWNzW2Rpc2NvW2ldLm1ldHJpY11bMV0sIFwiZGVzY3JpcHRpb25cIjpkaXNjb1tpXS5kZXNjcmlwdGlvbn07XG4gICAgICAgIGNvbnNvbGUubG9nKGF1eCk7XG4gICAgICAgIC8vIFZKRDogdGhpcyBpcyB0aGUgY29kZSB0byBhc2sgVEEyIGZvciBhIHNpbmdsZSBwaXBlbGluZSwgdG8gY2hlY2sgdmlhYmlsaXR5LiBIb3dldmVyLCBUQTJzIG1pZ2h0IG5vdCBhY3R1YWxseSBoYW5kbGUgJ21heHBpcGVsaW5lcycsIG1ha2luZyB0aGlzIHRha2UgYSB2ZXJ5IGxvbmcgdGltZSB0byBydW4uIEJ5cGFzc2luZyB0aGlzIGZvciBub3dcbiAgICAgIC8vICBsZXQgcmVzID0gYXdhaXQgbWFrZVJlcXVlc3QoRDNNX1NWQ19VUkwgKyAnL0NyZWF0ZVBpcGVsaW5lcycsIENyZWF0ZVBpcGVsaW5lRGF0YShkaXNjb1tpXS5wcmVkaWN0b3JzLCBbZGlzY29baV0udGFyZ2V0XSwgYXV4KSk7IC8vIGNyZWF0aW5nIGEgc2luZ2xlIHBpcGVsaW5lIGZvciBhIGRpc2NvdmVyZWQgcHJvYmxlbSwgdG8gY2hlY2sgdmlhYmlsaXR5XG4gICAgICAvLyAgaWYocmVzKSB7IC8vIGhhdmUgdG8gY2hlY2sgaWYgdGhlIHJlc3BvbnNlIHdlbnQgdGhyb3VnaCBvaywgdGhpcyBqdXN0IGNoZWNrcyBpZiByZXMgZXhpc3RzXG4gICAgICAgICAgICBsZXQgcmVzID0gYXdhaXQgbWFrZVJlcXVlc3QoRDNNX1NWQ19VUkwgKyAnL3dyaXRlLXVzZXItcHJvYmxlbScsIENyZWF0ZVBpcGVsaW5lRGF0YShkaXNjb1tpXS5wcmVkaWN0b3JzLCBbZGlzY29baV0udGFyZ2V0XSwgYXV4KSk7XG4gICAgICAvLyAgfVxuICAgIH1cblxuICAgIGRpc2NvdmVyeUxhZGRhLnN0b3AoKTtcbiAgICAvLyBjaGFuZ2Ugc3RhdHVzIG9mIGJ1dHRvbnMgZm9yIGVzdGltYXRpbmcgcHJvYmxlbSBhbmQgbWFya2luZyBwcm9ibGVtIGFzIGZpbmlzaGVkXG4gICAgYnlJZChcImJ0bkRpc2NvdmVyeVwiKS5jbGFzc0xpc3QucmVtb3ZlKFwiYnRuLXN1Y2Nlc3NcIik7XG4gICAgYnlJZChcImJ0bkRpc2NvdmVyeVwiKS5jbGFzc0xpc3QuYWRkKFwiYnRuLWRlZmF1bHRcIik7XG4gICAgYnlJZChcImJ0blN1Ym1pdERpc2NcIikuY2xhc3NMaXN0LnJlbW92ZShcImJ0bi1zdWNjZXNzXCIpO1xuICAgIGJ5SWQoXCJidG5TdWJtaXREaXNjXCIpLmNsYXNzTGlzdC5hZGQoXCJidG4tZGVmYXVsdFwiKTtcbiAgICB0YXNrMV9maW5pc2hlZCA9IHRydWU7XG4gICAgaWYoISh0YXNrMl9maW5pc2hlZCkpe1xuICAgICAgICBieUlkKFwiYnRuRXN0aW1hdGVcIikuY2xhc3NMaXN0LnJlbW92ZShcImJ0bi1kZWZhdWx0XCIpO1xuICAgICAgICBieUlkKFwiYnRuRXN0aW1hdGVcIikuY2xhc3NMaXN0LmFkZChcImJ0bi1zdWNjZXNzXCIpO1xuICAgIH07XG4gICAgdHJpZ2dlcihcImJ0blZhcmlhYmxlc1wiLCAnY2xpY2snKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNhdmVEaXNjKGJ0bikge1xuICAgIGxldCB0YWJsZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZGlzY292ZXJ5VGFibGVcIik7XG4gICAgbGV0IG5ld3RleHQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImRpc2NvdmVyeUlucHV0XCIpLnZhbHVlO1xuICAgIGZvciAobGV0IGkgPSAxLCByb3c7IHJvdyA9IHRhYmxlLnJvd3NbaV07IGkrKykgeyAvL3NraXBwaW5nIHRoZSBoZWFkZXJcbiAgICAgICAgaWYgKHJvdy5jbGFzc05hbWUgPT09ICdpdGVtLXNlbGVjdCcpIHtcbiAgICAgICAgICAgIGRpc2NvW2ktMV0uZGVzY3JpcHRpb24gPSBuZXd0ZXh0O1xuICAgICAgICB9XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYXNzZXRzL2FwcC9hcHAuanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2\n')},function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();\n\nexports.elem = elem;\nexports.fadeIn = fadeIn;\nexports.fadeOut = fadeOut;\nexports.fadeTo = fadeTo;\nexports.remove = remove;\nexports.setAttrs = setAttrs;\nexports.trigger = trigger;\nfunction elem(selectors) {\n    return document.querySelector(selectors);\n}\n\nfunction fadeIn(selectors) {\n    return $(selectors).fadeIn();\n}\n\nfunction fadeOut(selectors, duration) {\n    return $(selectors).fadeOut(duration);\n}\n\nfunction fadeTo(selectors, duration, complete) {\n    return $(selectors).fadeTo(duration, complete);\n}\n\nfunction remove(selectors) {\n    var el = elem(selectors);\n    el.parentNode.removeChild(el);\n}\n\nfunction setAttrs(selectors, attrs) {\n    var el = elem(selectors);\n    Object.entries(attrs).forEach(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            x = _ref2[0],\n            y = _ref2[1];\n\n        return el.setAttribute(x, y);\n    });\n};\n\nfunction trigger(selectors, event) {\n    var evt = document.createEvent(\'HTMLEvents\');\n    evt.initEvent(event, true, false);\n    elem(selectors).dispatchEvent(evt);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvYXBwL3V0aWxzLmpzPzAwMDciXSwibmFtZXMiOlsiZWxlbSIsImZhZGVJbiIsImZhZGVPdXQiLCJmYWRlVG8iLCJyZW1vdmUiLCJzZXRBdHRycyIsInRyaWdnZXIiLCJzZWxlY3RvcnMiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCIkIiwiZHVyYXRpb24iLCJjb21wbGV0ZSIsImVsIiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiYXR0cnMiLCJPYmplY3QiLCJlbnRyaWVzIiwiZm9yRWFjaCIsIngiLCJ5Iiwic2V0QXR0cmlidXRlIiwiZXZlbnQiLCJldnQiLCJjcmVhdGVFdmVudCIsImluaXRFdmVudCIsImRpc3BhdGNoRXZlbnQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O1FBQWdCQSxJLEdBQUFBLEk7UUFJQUMsTSxHQUFBQSxNO1FBSUFDLE8sR0FBQUEsTztRQUlBQyxNLEdBQUFBLE07UUFJQUMsTSxHQUFBQSxNO1FBS0FDLFEsR0FBQUEsUTtRQUtBQyxPLEdBQUFBLE87QUExQlQsU0FBU04sSUFBVCxDQUFjTyxTQUFkLEVBQXlCO0FBQzVCLFdBQU9DLFNBQVNDLGFBQVQsQ0FBdUJGLFNBQXZCLENBQVA7QUFDSDs7QUFFTSxTQUFTTixNQUFULENBQWdCTSxTQUFoQixFQUEyQjtBQUM5QixXQUFPRyxFQUFFSCxTQUFGLEVBQWFOLE1BQWIsRUFBUDtBQUNIOztBQUVNLFNBQVNDLE9BQVQsQ0FBaUJLLFNBQWpCLEVBQTRCSSxRQUE1QixFQUFzQztBQUN6QyxXQUFPRCxFQUFFSCxTQUFGLEVBQWFMLE9BQWIsQ0FBcUJTLFFBQXJCLENBQVA7QUFDSDs7QUFFTSxTQUFTUixNQUFULENBQWdCSSxTQUFoQixFQUEyQkksUUFBM0IsRUFBcUNDLFFBQXJDLEVBQStDO0FBQ2xELFdBQU9GLEVBQUVILFNBQUYsRUFBYUosTUFBYixDQUFvQlEsUUFBcEIsRUFBOEJDLFFBQTlCLENBQVA7QUFDSDs7QUFFTSxTQUFTUixNQUFULENBQWdCRyxTQUFoQixFQUEyQjtBQUM5QixRQUFJTSxLQUFLYixLQUFLTyxTQUFMLENBQVQ7QUFDQU0sT0FBR0MsVUFBSCxDQUFjQyxXQUFkLENBQTBCRixFQUExQjtBQUNIOztBQUVNLFNBQVNSLFFBQVQsQ0FBa0JFLFNBQWxCLEVBQTZCUyxLQUE3QixFQUFvQztBQUN2QyxRQUFJSCxLQUFLYixLQUFLTyxTQUFMLENBQVQ7QUFDQVUsV0FBT0MsT0FBUCxDQUFlRixLQUFmLEVBQXNCRyxPQUF0QixDQUE4QjtBQUFBO0FBQUEsWUFBRUMsQ0FBRjtBQUFBLFlBQUtDLENBQUw7O0FBQUEsZUFBWVIsR0FBR1MsWUFBSCxDQUFnQkYsQ0FBaEIsRUFBbUJDLENBQW5CLENBQVo7QUFBQSxLQUE5QjtBQUNIOztBQUVNLFNBQVNmLE9BQVQsQ0FBaUJDLFNBQWpCLEVBQTRCZ0IsS0FBNUIsRUFBbUM7QUFDdEMsUUFBSUMsTUFBTWhCLFNBQVNpQixXQUFULENBQXFCLFlBQXJCLENBQVY7QUFDQUQsUUFBSUUsU0FBSixDQUFjSCxLQUFkLEVBQXFCLElBQXJCLEVBQTJCLEtBQTNCO0FBQ0F2QixTQUFLTyxTQUFMLEVBQWdCb0IsYUFBaEIsQ0FBOEJILEdBQTlCO0FBQ0giLCJmaWxlIjoiMy5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBlbGVtKHNlbGVjdG9ycykge1xuICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9ycyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmYWRlSW4oc2VsZWN0b3JzKSB7XG4gICAgcmV0dXJuICQoc2VsZWN0b3JzKS5mYWRlSW4oKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZhZGVPdXQoc2VsZWN0b3JzLCBkdXJhdGlvbikge1xuICAgIHJldHVybiAkKHNlbGVjdG9ycykuZmFkZU91dChkdXJhdGlvbik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmYWRlVG8oc2VsZWN0b3JzLCBkdXJhdGlvbiwgY29tcGxldGUpIHtcbiAgICByZXR1cm4gJChzZWxlY3RvcnMpLmZhZGVUbyhkdXJhdGlvbiwgY29tcGxldGUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlKHNlbGVjdG9ycykge1xuICAgIGxldCBlbCA9IGVsZW0oc2VsZWN0b3JzKTtcbiAgICBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldEF0dHJzKHNlbGVjdG9ycywgYXR0cnMpIHtcbiAgICBsZXQgZWwgPSBlbGVtKHNlbGVjdG9ycyk7XG4gICAgT2JqZWN0LmVudHJpZXMoYXR0cnMpLmZvckVhY2goKFt4LCB5XSkgPT4gZWwuc2V0QXR0cmlidXRlKHgsIHkpKTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmlnZ2VyKHNlbGVjdG9ycywgZXZlbnQpIHtcbiAgICBsZXQgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0hUTUxFdmVudHMnKTtcbiAgICBldnQuaW5pdEV2ZW50KGV2ZW50LCB0cnVlLCBmYWxzZSk7XG4gICAgZWxlbShzZWxlY3RvcnMpLmRpc3BhdGNoRXZlbnQoZXZ0KTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Fzc2V0cy9hcHAvdXRpbHMuanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3\n')},function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\nexports.selVarColor = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();\n\nexports.density = density;\nexports.bars = bars;\nexports.barsSubset = barsSubset;\nexports.densityNode = densityNode;\nexports.barsNode = barsNode;\n\nvar _utils = __webpack_require__(3);\n\nvar d3Color = \'#1f77b4\'; // d3\'s default blue\nvar selVarColor = exports.selVarColor = \'#fa8072\'; // d3.rgb("salmon");\n\n// function to use d3 to graph density plots with preprocessed data\nfunction density(node, div, priv) {\n    div = { setxLeft: \'#setxLeft\', setxLeftTopRight: \'#setxLeftTopRight\', Summary: \'#tabSummary\' }[div];\n\n    if (!div) return alert("Error: incorrect div selected for plots: " + div);\n\n    var _ref = [node.plotx, node.ploty],\n        xVals = _ref[0],\n        yVals = _ref[1];\n\n    if (priv && node.plotCI) {\n        var _map = [\'upperBound\', \'lowerBound\'].map(function (bound) {\n            return xVals.map(function (x, i) {\n                return { x: +x, y: +node.plotCI[bound][i] };\n            });\n        }),\n            _map2 = _slicedToArray(_map, 2),\n            _upperError = _map2[0],\n            _lowerError = _map2[1];\n\n        console.log(\'upperError\\n\', _upperError);\n    }\n\n    var tempWidth = d3.select(div).style("width");\n    var width = tempWidth.substring(0, tempWidth.length - 2);\n    var tw = document.getElementById(\'main\').offsetWidth;\n    var tempHeight = d3.select(div).style("height");\n    var height = tempHeight.substring(0, tempHeight.length - 2);\n    var margin = {\n        top: 20, //20,\n        right: 20,\n        bottom: 53, //53,\n        left: 10\n    };\n\n    // Need to fix automatic width and height settings for leftpanel (#tabSubset, #tabSummary)\n    if (div == "#tabSummary") {\n        //[242, 250];             // These should not be hard coded\n        // width = 0.7 * (width - margin.left - margin.right),\n        // height = 0.3 * (height - margin.top - margin.bottom);\n        width = 242;\n        height = 150;\n    } else if (div == "#setxLeft" || div == "#setxLeftTopRight") {\n        width = tw * .185 - margin.left - margin.right; //rightpanel.expand is 40 percent, setxLeft to 50 percent, toggle bar is 16px, padding, it\'s all about .185\n        height = width * .6; //height to width is .6\n    } else {\n        width = 0.35 * (width - margin.left - margin.right), height = 0.25 * (height - margin.top - margin.bottom);\n    };\n\n    var x = d3.scale.linear().domain([d3.min(xVals), d3.max(xVals)]).range([0, width]);\n    var invx = d3.scale.linear().range([d3.min(xVals), d3.max(xVals)]).domain([0, width]);\n    var y = d3.scale.linear().domain([d3.min(yVals), d3.max(yVals)]).range([height, 0]);\n    var xAxis = d3.svg.axis().scale(x).ticks(5).orient("bottom");\n    var yAxis = d3.svg.axis().scale(y).orient("left");\n    var brush = d3.svg.brush().x(x).extent(node.subsetrange).on("brush", brushed);\n    var brush2 = d3.svg.brush().x(x).on("brush", brushed2);\n    var area = d3.svg.area().interpolate("monotone").x(function (d) {\n        return x(d.x);\n    }).y0(height).y1(function (d) {\n        return y(d.y);\n    });\n    var line = d3.svg.line().x(function (d) {\n        return x(d.x);\n    }).y(function (d) {\n        return y(d.y);\n    }).interpolate("monotone");\n\n    // cumbersome to treat "tabSummary" differently, but works for now\n    // tabSummary, has an issue, that unless width height hardcoded, they grow with each additional graph.\n    if (div == "#tabSummary") {\n        var plotsvg = d3.select(div).selectAll("svg").remove();\n        plotsvg = d3.select(div).append("svg").attr("id", function () {\n            return node.name.toString().concat(div.substr(1));\n        }).style("width", 300) // set height to the height of #main.left\n        .style("height", 200).append("g").attr("transform", \'translate(\' + margin.left + \',\' + margin.top + \')\');\n    } else {\n        var plotsvg = d3.select(div).append("svg").attr("id", function () {\n            return node.name.toString().replace(/\\(|\\)/g, "").concat("_", div.substr(1), "_", node.id);\n        }).style("width", width + margin.left + margin.right) //setting height to the height of #main.left\n        .style("height", height + margin.top + margin.bottom).append("g").attr("transform", \'translate(\' + margin.left + \',\' + margin.top + \')\');\n    };\n    plotsvg.append("path").datum(xVals.map(function (x, i) {\n        return { x: +x, y: +node.ploty[i] };\n    })).attr("class", "area").attr("d", area);\n\n    //add upper bound\n    priv && node.plotCI && plotsvg.append("path").attr("class", "upperError").datum(upperError).attr("d", area);\n\n    //add lower bound\n    priv && node.plotCI && plotsvg.append("path").attr("class", "lowerError").datum(lowerError).attr("d", area);\n\n    plotsvg.append("g").attr("class", "x axis").attr("transform", "translate(0," + height + ")").call(xAxis);\n\n    plotsvg.append("text").attr("x", width / 2).attr("y", 0 - margin.top / 2).attr("text-anchor", "middle").style("font-size", "12px").text(node.name);\n\n    // add brush if subset\n    // this tab doesn\'t exist anymore - Shoeboxam\n    if (div == "#tabSubset") {\n        plotsvg.append("text").attr("id", "range").attr("x", 25).attr("y", height + 40).text(function () {\n            return "Range: ".concat(d3.min(xVals).toPrecision(4), " to ", d3.max(xVals).toPrecision(4));\n        });\n        plotsvg.append("g").attr("class", "x brush").call(brush).selectAll("rect").attr("height", height);\n    }\n\n    // add z lines and sliders setx\n    if (div == "#setxLeft" || div == "#setxLeftTopRight") {\n        plotsvg.append("text").attr("id", "range") // this is bad practice, id is not unique\n        .attr(\'class\', \'xval\').attr("x", 25).attr("y", height + 40).text(function () {\n            return "x: ".concat((+node.mean).toPrecision(4));\n        });\n\n        plotsvg.append("text").attr("id", "range2") // this is bad practice, id is not unique\n        .attr(\'class\', \'x1val\').attr("x", 25).attr("y", height + 50).text(function (_) {\n            var returnval = "x1: ".concat((+node.mean).toPrecision(4));\n            return returnval;\n        });\n\n        // create tick marks at all zscores in the bounds of the data\n        var lineFunction = d3.svg.line().x(function (d) {\n            return d.x;\n        }).y(function (d) {\n            return d.y;\n        }).interpolate("linear");\n\n        var colSeq = ["#A2CD5A", "orange", "red"]; // will cycle through color sequence, and then repeat last color\n        var lineData = new Array();\n\n        var zLower = -1 * (d3.min(xVals) - node.mean) / node.sd; // zscore of lower bound\n        var zUpper = (d3.max(xVals) - node.mean) / node.sd; // zscore of upper bound\n\n        for (var i = 0; i < zUpper; i++) {\n            lineData = [{\n                "x": x(+node.mean + i * node.sd),\n                "y": height * .7\n            }, {\n                "x": x(+node.mean + i * node.sd),\n                "y": height * .9\n            }];\n            plotsvg.append("path").attr("d", lineFunction([lineData[0], lineData[1]])).attr("stroke", colSeq[d3.min([i, colSeq.length - 1])]).attr("stroke-width", 1.5).attr("fill", "none");\n        }\n\n        for (var i = 1; i < zLower; i++) {\n            lineData = [{\n                "x": x(+node.mean - i * node.sd),\n                "y": height * .7\n            }, {\n                "x": x(+node.mean - i * node.sd),\n                "y": height * .9\n            }];\n            plotsvg.append("path").attr("d", lineFunction([lineData[0], lineData[1]])).attr("stroke", colSeq[d3.min([i, colSeq.length - 1])]).attr("stroke-width", 1.5).attr("fill", "none");\n        }\n\n        // initialize slider components\n        var slideBox = plotsvg.append("g").attr("class", "x axis").attr("transform", "translate(0," + height * .8 + ")").call(d3.svg.axis().scale(x).ticks(0).orient("bottom"));\n        var slider = plotsvg.append("g").attr("class", "slider").call(brush);\n        var handle = slider.append("polygon").attr("class", "handle").attr("transform", "translate(0," + height * .7 + ")").attr("points", function (_) {\n            var s = 6;\n            var xnm = node.setxvals[0] == \'\' ? x(node.mean) : x(node.setxvals[0]);\n            return xnm - s + "," + -s + " " + (xnm + s) + "," + -s + " " + xnm + "," + s * 1.3;\n        });\n        var slider2 = plotsvg.append("g").attr("class", "slider").call(brush2);\n        var handle2 = slider2.append("polygon").attr("class", "handle").attr("transform", "translate(0," + height * .9 + ")").attr("points", function (_) {\n            var s = 6;\n            var xnm = node.setxvals[1] == \'\' ? x(node.mean) : x(node.setxvals[1]);\n            return xnm - s + "," + s + " " + (xnm + s) + "," + s + " " + xnm + "," + -s * 1.3;\n        });\n    }\n\n    // brushing functions\n    function brushed() {\n        if (div == "#tabSummary") {\n            plotsvg.select("text#range").text(function () {\n                return brush.empty() ? "Range: ".concat(d3.min(xVals).toPrecision(4), " to ", d3.max(xVals).toPrecision(4)) : "Range: ".concat(brush.extent()[0].toPrecision(4), " to ", brush.extent()[1].toPrecision(4));\n            });\n            node.subsetrange = brush.extent()[0].toPrecision(4) != brush.extent()[1].toPrecision(4) ? [brush.extent()[0].toPrecision(4), brush.extent()[1].toPrecision(4)] : ["", ""];\n        } else if (div == "#setxLeft" || div == "#setxLeftTopRight") {\n            var value = brush.extent()[0];\n            var s = 6;\n            if (d3.event.sourceEvent) {\n                value = x.invert(d3.mouse(this)[0]);\n                brush.extent([value, value]);\n            }\n\n            // set x position of slider center\n            var xpos = x(value);\n            if (value > d3.max(xVals)) {\n                // dragged past max\n                xpos = x(d3.max(xVals));\n            } else if (value < d3.min(xVals)) {\n                // dragged past min\n                xpos = x(d3.min(xVals));\n            } else {\n                var m = +node.mean;\n                var sd = +node.sd;\n                var zScore = (value - m) / sd; // z-score\n                var zRound = Math.round(zScore); // nearest integer z-score\n                if (.1 > Math.abs(zRound - zScore)) // snap to integer z-score\n                    xpos = x(m + zRound * sd);\n            }\n\n            // create slider symbol and text\n            handle.attr("points", function (_) {\n                return xpos - s + "," + -s + " " + (xpos + s) + "," + -s + " " + xpos + "," + s * 1.3;\n            });\n            plotsvg.select("text#range").text(function (_) {\n                var returnval = "x: ".concat(invx(xpos).toPrecision(4));\n                var xval = invx(xpos).toPrecision(4);\n                var mycell = node.name + "From"; // hardcoded here\n                if (document.getElementById(mycell)) {\n                    document.getElementById(mycell).innerText = xval;\n                }\n                return returnval;\n            });\n            node.setxvals[0] = invx(xpos).toPrecision(4);\n        }\n    }\n\n    // certainly a more clever way to do this, but for now it\'s basically copied with brush and handle changes to brush2 and handle2 and #range to #range2 and setxvals[0] to setxvals[1]\n    function brushed2() {\n        var value = brush2.extent()[0];\n        var s = 6; // scaling for triangle shape\n\n        if (d3.event.sourceEvent) {\n            value = x.invert(d3.mouse(this)[0]);\n            brush2.extent([value, value]);\n        }\n\n        // set x position of slider center\n        var xpos = x(value);\n        if (value > d3.max(xVals)) {\n            // dragged past max\n            xpos = x(d3.max(xVals));\n        } else if (value < d3.min(xVals)) {\n            // dragged past min\n            xpos = x(d3.min(xVals));\n        } else {\n            var m = +node.mean;\n            var sd = +node.sd;\n            var zScore = (value - m) / sd; // z-score\n            var zRound = Math.round(zScore); // nearest integer z-score\n            if (.1 > Math.abs(zRound - zScore)) // snap to integer z-score\n                xpos = x(m + zRound * sd);\n        }\n\n        // create slider symbol and text\n        handle2.attr("points", function (_) {\n            return xpos - s + "," + s + " " + (xpos + s) + "," + s + " " + xpos + "," + -s * 1.3;\n        });\n        plotsvg.select("text#range2").text(function (_) {\n            var returnval = "x1: ".concat(invx(xpos).toPrecision(4));\n            var x1val = invx(xpos).toPrecision(4);\n            var mycell = node.name + "To"; // hardcoded here\n            if (document.getElementById(mycell)) {\n                document.getElementById(mycell).innerText = x1val;\n            }\n            return returnval;\n        });\n        node.setxvals[1] = invx(xpos).toPrecision(4);\n    }\n}\n\nfunction bars(node, div, priv) {\n    // Histogram spacing\n    var barPadding = .015; // Space between bars\n    var topScale = 1.2; // Multiplicative factor to assign space at top within graph - currently removed from implementation\n    var plotXaxis = true;\n\n    // Data\n    var keys = Object.keys(node.plotvalues);\n    var yVals = new Array();\n    var ciUpperVals = new Array();\n    var ciLowerVals = new Array();\n    var ciSize;\n\n    var xVals = new Array();\n    var yValKey = new Array();\n\n    if (node.nature == "nominal") {\n        var xi = 0;\n        for (var i = 0; i < keys.length; i++) {\n            if (node.plotvalues[keys[i]] == 0) continue;\n            yVals[xi] = node.plotvalues[keys[i]];\n            xVals[xi] = xi;\n            if (priv) {\n                if (node.plotvaluesCI) {\n                    ciLowerVals[xi] = node.plotValuesCI.lowerBound[keys[i]];\n                    ciUpperVals[xi] = node.plotValuesCI.upperBound[keys[i]];\n                }\n                ciSize = ciUpperVals[xi] - ciLowerVals[xi];\n            };\n\n            yValKey.push({\n                y: yVals[xi],\n                x: keys[i]\n            });\n            xi = xi + 1;\n        }\n        yValKey.sort(function (a, b) {\n            return b.y - a.y;\n        }); // array of objects, each object has y, the same as yVals, and x, the category\n        yVals.sort(function (a, b) {\n            return b - a;\n        }); // array of y values, the height of the bars\n        ciUpperVals.sort(function (a, b) {\n            return b.y - a.y;\n        }); // ?\n        ciLowerVals.sort(function (a, b) {\n            return b.y - a.y;\n        }); // ?\n    } else {\n        for (var i = 0; i < keys.length; i++) {\n            // console.log("plotvalues in bars");\n            yVals[i] = node.plotvalues[keys[i]];\n            xVals[i] = Number(keys[i]);\n            if (priv) {\n                if (node.plotvaluesCI) {\n                    ciLowerVals[i] = node.plotvaluesCI.lowerBound[keys[i]];\n                    ciUpperVals[i] = node.plotvaluesCI.upperBound[keys[i]];\n                }\n                ciSize = ciUpperVals[i] - ciLowerVals[i];\n            }\n        }\n    }\n\n    if (yVals.length > 15 & node.numchar == "numeric" || yVals.length > 5 & node.numchar == "character") plotXaxis = false;\n    var maxY = d3.max(yVals); // in the future, set maxY to the value of the maximum confidence limit\n    if (priv && node.plotvaluesCI) maxY = d3.max(ciUpperVals);\n    var minX = d3.min(xVals);\n    var maxX = d3.max(xVals);\n\n    var mydiv = void 0;\n    if (div == "setxLeft") mydiv = "#setxLeft";else if (div == "Summary") mydiv = "#tabSummary";else if (div == "setxLeftTopRight") mydiv = "#setxLeftTopRight";else return alert("Error: incorrect div selected for plots");\n\n    var tempWidth = d3.select(mydiv).style("width");\n    var width = tempWidth.substring(0, tempWidth.length - 2);\n    var tempHeight = d3.select(mydiv).style("height");\n    var height = tempHeight.substring(0, tempHeight.length - 2);\n\n    var margin = {\n        top: 20,\n        right: 20,\n        bottom: 53,\n        left: 10\n    };\n    var tw = document.getElementById(\'main\').offsetWidth;\n\n    // Need to fix automatic width and height settings for leftpanel (#tabSubset, #tabSummary)\n    if (mydiv == "#tabSummary") {\n        //[242, 250];       // These should not be hard coded\n        // width = 0.7 * (width - margin.left - margin.right);\n        // height = 0.3 * (height - margin.top - margin.bottom);\n        width = 242;\n        height = 150;\n    } else if (mydiv == "#setxLeft" || mydiv == "#setxLeftTopRight") {\n        //width = 200;\n        //height = 120;\n        width = tw * .185 - margin.left - margin.right; //rightpanel.expand is 40 percent, setxLeft to 50 percent, toggle bar is 16px, padding, it\'s all about .185\n        height = width * .6; //height to width is .6\n    } else {\n        width = 0.35 * (width - margin.left - margin.right);\n        height = 0.25 * (height - margin.top - margin.bottom);\n    };\n\n    if (priv && node.stabilityBin) {\n        var x = d3.scale.linear().domain([minX - 0.5, maxX + 1.5]).range([0, width]);\n    } else {\n        var x = d3.scale.linear().domain([minX - 0.5, maxX + 0.5]).range([0, width]);\n    }\n\n    var invx = d3.scale.linear().range([minX - 0.5, maxX + 0.5]).domain([0, width]);\n\n    var y = d3.scale.linear().domain([0, maxY]).range([0, height]);\n\n    var xAxis = d3.svg.axis().scale(x).ticks(yVals.length).orient("bottom");\n\n    var yAxis = d3.svg.axis().scale(y).orient("left");\n\n    var brush = d3.svg.brush().x(x).extent(function () {\n        return node.subsetrange.length == 1 ? [node.subsetrange[0], node.subsetrange[0]] : node.subsetrange;\n    }).on("brush", brushed);\n\n    var brush2 = d3.svg.brush().x(x).on("brush", brushed2);\n\n    // Create SVG element\n    // cumbersome to treat "tabSummary" differently, but works for now\n    // tabSummary, has an issue, that unless width height hardcoded, they grow with each additional graph.\n    if (mydiv == "#tabSummary") {\n        var plotsvg = d3.select(mydiv).selectAll("svg").remove();\n\n        var plotsvg = d3.select(mydiv).append("svg").attr("id", function () {\n            return node.name.toString().concat(mydiv.substr(1));\n        }).style("width", 300) //setting height to the height of #main.left\n        .style("height", 200).append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");\n    } else {\n        var plotsvg = d3.select(mydiv).append("svg").attr("id", function () {\n            var myname = node.name.toString();\n            myname = myname.replace(/\\(|\\)/g, "");\n            return myname.concat("_", mydiv.substr(1), "_", node.id);\n        }).style("width", width + margin.left + margin.right) //setting height to the height of #main.left\n        .style("height", height + margin.top + margin.bottom).append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");\n    };\n\n    var rectWidth = x(minX + 0.5 - 2 * barPadding); //the "width" is the coordinate of the end of the first bar\n\n    plotsvg.selectAll("rect").data(yVals).enter().append("rect").attr("x", function (d, i) {\n        return x(xVals[i] - 0.5 + barPadding);\n    }).attr("y", function (d) {\n        return y(maxY - d);\n    }).attr("width", rectWidth).attr("height", y).attr("fill", "#1f77b4");\n\n    // draw error bars, threshold line and extra bin\n    if (priv) {\n        if (yVals.length <= 20) {\n            plotsvg.selectAll("line").data(ciUpperVals).enter().append("line").style("stroke", "black").attr("x1", function (d, i) {\n                return x(xVals[i] - 0.5 + barPadding) + rectWidth / 2;\n            }).attr("y1", function (d) {\n                return y(maxY - d);\n            }).attr("x2", function (d, i) {\n                return x(xVals[i] - 0.5 + barPadding) + rectWidth / 2;\n            }).attr("y2", function (d) {\n                var y2 = y(maxY - d + ciSize);\n                return y2 >= y(maxY) ? y(maxY) : y2;\n            });\n\n            //draw top ticks on error bars\n            //need to fix the height of the graphs - the tops of error bars are getting cut off\n            plotsvg.selectAll(".topTick").data(ciUpperVals).enter().append("line").attr("class", "topTick").style("stroke", "black").attr("x1", function (d, i) {\n                if (yVals.length > 20) {\n                    return x(xVals[i] - 0.5 + barPadding); //make tick bigger to increase visibility\n                } else {\n                    return x(xVals[i] - 0.5 + barPadding) + 0.4 * rectWidth;\n                }\n            }).attr("y1", function (d) {\n                return y(maxY - d);\n            }).attr("x2", function (d, i) {\n                if (yVals.length > 20) {\n                    return x(xVals[i] - 0.5 + barPadding) + rectWidth; //make tick bigger to increase visibility\n                } else {\n                    return x(xVals[i] - 0.5 + barPadding) + 0.6 * rectWidth;\n                }\n            }).attr("y2", function (d) {\n                return y(maxY - d);\n            });\n\n            // draw bottom ticks of error bars\n            plotsvg.selectAll(".bottomTick").data(ciLowerVals).enter().append("line").attr("class", "bottomTick").style("stroke", "black").attr("x1", function (d, i) {\n                if (yVals.length > 20) {\n                    return x(xVals[i] - 0.5 + barPadding);\n                } else {\n                    return x(xVals[i] - 0.5 + barPadding) + 0.4 * rectWidth;\n                }\n            }).attr("y1", function (d) {\n                return y(maxY - d);\n            }).attr("x2", function (d, i) {\n                if (yVals.length > 20) {\n                    return x(xVals[i] - 0.5 + barPadding) + rectWidth;\n                } else {\n                    return x(xVals[i] - 0.5 + barPadding) + 0.6 * rectWidth;\n                }\n            }).attr("y2", function (d) {\n                return y(maxY - d);\n            });\n        } else {\n            plotsvg.selectAll(".denseError").data(yVals).enter().append("rect").attr("class", "denseError").attr("x", function (d, i) {\n                return x(xVals[i] - 0.5 + barPadding);\n            }).attr("y", function (d) {\n                return y(maxY - d) - .1 * y(d);\n            }).attr("width", rectWidth).attr("height", function (d) {\n                return y(maxY - d) + .1 * y(d) - (y(maxY - d) - .1 * y(d));\n            }).attr("fill", "silver");\n        }\n\n        //if statement for stability histograms\n        //extra stability bin\n        if (node.stabilityBin) {\n            plotsvg.append("rect").attr("x", x(maxX + 0.5 - barPadding)).attr("y", y(maxY) - node.stabilityBin).attr("width", rectWidth).attr("height", node.stabilityBin).attr("fill", "silver");\n        }\n\n        //threshold line\n        if (node.threshold) {\n            plotsvg.append("line").style("stroke", "black").attr("x1", x(minX - 0.5 + barPadding)).attr("y1", y(maxY) - node.threshold).attr("x2", function () {\n                console.log("stabilityBin");\n                console.log(node.stabilityBin);\n                if (node.stabilityBin) {\n                    return x(maxX + 0.5 - barPadding) + rectWidth;\n                } else {\n                    return x(maxX + 0.5 - barPadding);\n                }\n            }).attr("y2", y(maxY) - node.threshold);\n        }\n    }\n\n    if (plotXaxis) {\n        plotsvg.append("g").attr("class", "x axis").attr("transform", "translate(0," + height + ")").call(xAxis);\n    }\n\n    plotsvg.append("text").attr("x", width / 2).attr("y", 0 - margin.top / 2).attr("text-anchor", "middle").style("font-size", "12px").text(node.name);\n\n    if (mydiv == "#setxLeft" || mydiv == "#setxLeftTopRight") {\n        plotsvg.append("text").attr("id", "range") // bad practice, not unique\n        .attr(\'class\', \'xval\').attr("x", 25).attr("y", height + 40).text(function () {\n            if (node.nature === "nominal") {\n                var t = Math.round(yValKey.length / 2) - 1;\n                var mycell = node.name + "From"; // hardcoded here\n                if (document.getElementById(mycell)) {\n                    document.getElementById(mycell).innerText = yValKey[t].x;\n                }\n                return "x: " + yValKey[t].x;\n            } else {\n                var _mycell = node.name + "From"; // hardcoded here\n                if (document.getElementById(_mycell)) {\n                    document.getElementById(_mycell).innerText = (+node.mean).toPrecision(4).toString();\n                }\n                return "x: ".concat((+node.mean).toPrecision(4).toString());\n            }\n        });\n\n        plotsvg.append("text").attr("id", "range2") //bad practice, not unique\n        .attr(\'class\', \'x1val\').attr("x", 25).attr("y", height + 50).text(function () {\n            if (node.nature === "nominal") {\n                var t = Math.round(yValKey.length / 2) - 1;\n                return "x1: " + yValKey[t].x;\n            } else {\n                return "x1: ".concat((+node.mean).toPrecision(4).toString());\n            }\n        });\n\n        // create tick marks at all zscores in the bounds of the data\n        var lineFunction = d3.svg.line().x(function (d) {\n            return d.x;\n        }).y(function (d) {\n            return d.y;\n        }).interpolate("linear");\n\n        var colSeq = ["#A2CD5A", "orange", "red"]; // will cycle through color sequence, and then repeat last color\n        var lineData = new Array();\n\n        var zLower = -1 * (minX - node.mean) / node.sd; // zscore of lower bound\n        var zUpper = (maxX - node.mean) / node.sd; // zscore of upper bound\n\n        for (var i = 0; i < zUpper; i++) {\n            lineData = [{\n                "x": x(+node.mean + i * node.sd),\n                "y": height * .7\n            }, {\n                "x": x(+node.mean + i * node.sd),\n                "y": height * .9\n            }];\n            plotsvg.append("path").attr("d", lineFunction([lineData[0], lineData[1]])).attr("stroke", colSeq[d3.min([i, colSeq.length - 1])]).attr("stroke-width", 1.5).attr("fill", "none");\n        }\n\n        for (var i = 1; i < zLower; i++) {\n            lineData = [{\n                "x": x(+node.mean - i * node.sd),\n                "y": height * .7\n            }, {\n                "x": x(+node.mean - i * node.sd),\n                "y": height * .9\n            }];\n            plotsvg.append("path").attr("d", lineFunction([lineData[0], lineData[1]])).attr("stroke", colSeq[d3.min([i, colSeq.length - 1])]).attr("stroke-width", 1.5).attr("fill", "none");\n        }\n\n        for (var i = d3.min(xVals); i <= d3.max(xVals); i++) {\n            lineData = [{\n                "x": x(i),\n                "y": height * .75\n            }, {\n                "x": x(i),\n                "y": height * .85\n            }];\n            plotsvg.append("path").attr("d", lineFunction([lineData[0], lineData[1]])).attr("stroke", "black").attr("stroke-width", 1).attr("fill", "none");\n        }\n\n        // initialize slider components\n        var slideBox = plotsvg.append("g").attr("class", "x axis").attr("transform", "translate(0," + height * .8 + ")").call(d3.svg.axis().scale(x).ticks(0).orient("bottom"));\n\n        var slider = plotsvg.append("g").attr("class", "slider").call(brush);\n        var slider2 = plotsvg.append("g").attr("class", "slider").call(brush2);\n\n        var points = function points(i) {\n            return function (d) {\n                var xnm = void 0,\n                    s = 6;\n                if (node.setxvals[i] == \'\') {\n                    // if nominal, use the median frequency as the position for the setx slider\n                    xnm = node.nature == \'nominal\' ? x(Math.round(xVals.length / 2) - 1) : x(node.mean);\n                } else {\n                    xnm = x(node.setxvals[i]);\n                };\n                return xnm - s + \',\' + -s + \' \' + (xnm + s) + \',\' + -s + \' \' + xnm + \',\' + s * 1.3;\n            };\n        };\n        var handle = slider.append("polygon").attr("class", "handle").attr("transform", "translate(0," + height * .7 + ")").attr("points", points(0));\n        var handle2 = slider2.append("polygon").attr("class", "handle").attr("transform", "translate(0," + height * .9 + ")").attr("points", points(1));\n    }\n\n    function twoSF(x) {\n        var tsf = d3.format(".2r"); // format to two significant figures after the decimal place\n        return tsf(x).replace(/0+$/, "").replace(/\\.$/, ""); // trim trailing zeros after a period, and any orphaned period\n    }\n\n    // brushing functions\n    function brushed() {\n        var value = brush.extent()[0];\n        var s = 6;\n\n        if (d3.event.sourceEvent) {\n            value = x.invert(d3.mouse(this)[0]);\n            brush.extent([value, value]);\n        }\n\n        // set x position of slider center\n        var xpos = x(value);\n        if (value > maxX) {\n            // dragged past max\n            xpos = x(maxX);\n        } else if (value < minX) {\n            // dragged past min\n            xpos = x(minX);\n        } else {\n            var m = +node.mean;\n            var sd = +node.sd;\n            var zScore = (value - m) / sd; // z-score\n            var zRound = Math.round(zScore); // nearest integer z-score\n            if (.1 > Math.abs(Math.round(value) - value)) {\n                // snap to integer\n                xpos = x(Math.round(value));\n            } else if (.1 > Math.abs(zRound - zScore)) {\n                // snap to integer z-score\n                xpos = x(m + zRound * sd);\n            }\n        }\n\n        // create slider symbol and text\n        handle.attr("points", function (d) {\n            return xpos - s + "," + -s + " " + (xpos + s) + "," + -s + " " + xpos + "," + s * 1.3;\n        });\n        plotsvg.select("text#range").text(function () {\n            if (node.nature === "nominal") {\n                var mycell = node.name + "From"; // hardcoded here\n                if (document.getElementById(mycell)) {\n                    document.getElementById(mycell).innerText = yValKey[Math.round(invx(xpos))].x;\n                }\n                return "x: " + yValKey[Math.round(invx(xpos))].x;\n            } else {\n                var _mycell2 = node.name + "From"; // hardcoded here\n                if (document.getElementById(_mycell2)) {\n                    document.getElementById(_mycell2).innerText = +invx(xpos).toPrecision(4).toString();\n                }\n                return "x: ".concat(+invx(xpos).toPrecision(4).toString());\n            }\n        });\n        node.setxvals[0] = +invx(xpos).toPrecision(4);\n    }\n\n    // certainly a more clever way to do this, but for now it\'s basically copied with brush and handle changes to brush2 and handle2 and #range to #range2 and setxvals[0] to setxvals[1]\n    function brushed2() {\n        var value = brush2.extent()[0];\n        var s = 6; // scaling for triangle shape\n\n        if (d3.event.sourceEvent) {\n            value = x.invert(d3.mouse(this)[0]);\n            brush2.extent([value, value]);\n        }\n\n        // set x position of slider center\n        var xpos = x(value);\n        if (value > maxX) {\n            // dragged past max\n            xpos = x(maxX);\n        } else if (value < minX) {\n            // dragged past min\n            xpos = x(minX);\n        } else {\n            var m = +node.mean;\n            var sd = +node.sd;\n            var zScore = (value - m) / sd; // z-score\n            var zRound = Math.round(zScore); // nearest integer z-score\n            if (.1 > Math.abs(Math.round(value) - value)) {\n                // snap to integer\n                xpos = x(Math.round(value));\n            } else if (.1 > Math.abs(zRound - zScore)) {\n                // snap to integer z-score\n                xpos = x(m + zRound * sd);\n            }\n        }\n\n        // create slider symbol and text\n        handle2.attr("points", function (d) {\n            return xpos - s + "," + s + " " + (xpos + s) + "," + s + " " + xpos + "," + -s * 1.3;\n        });\n        plotsvg.select("text#range2").text(function () {\n            if (node.nature === "nominal") {\n                var mycell = node.name + "To"; // hardcoded here\n                if (document.getElementById(mycell)) {\n                    document.getElementById(mycell).innerText = yValKey[Math.round(invx(xpos))].x;\n                }\n                return "x1: " + yValKey[Math.round(invx(xpos))].x;\n            } else {\n                var _mycell3 = node.name + "To"; // hardcoded here\n                if (document.getElementById(_mycell3)) {\n                    document.getElementById(_mycell3).innerText = +invx(xpos).toPrecision(4).toString();\n                }\n                return "x1: ".concat(+invx(xpos).toPrecision(4).toString());\n            }\n        });\n        node.setxvals[1] = +invx(xpos).toPrecision(4);\n    }\n}\n\n// draws barplots in subset tab\nfunction barsSubset(node) {\n    // if untouched, set node.subsetrange to an empty array, meaning all values selected by default\n    if (node.subsetrange[0] == "" & node.subsetrange[1] == "") {\n        node.subsetrange = [];\n    }\n\n    // Histogram spacing\n    var barPadding = .015; // Space between bars\n    var topScale = 1.2; // Multiplicative factor to assign space at top within graph - currently removed from implementation\n    var plotXaxis = true;\n\n    // Variable name\n    var myname = node.name.toString();\n    myname = myname.replace(/\\(|\\)/g, "");\n\n    // Data\n    var keys = Object.keys(node.plotvalues);\n    var yVals = new Array();\n    var xVals = new Array();\n    var yValKey = new Array();\n\n    var xi = 0;\n    for (var i = 0; i < keys.length; i++) {\n        if (node.plotvalues[keys[i]] == 0) continue;\n        yVals[xi] = node.plotvalues[keys[i]];\n        xVals[xi] = xi;\n        yValKey.push({\n            y: yVals[xi],\n            x: keys[i]\n        });\n        xi = xi + 1;\n    }\n    if (node.nature === "nominal") {\n        // if nominal, orders bars left to right, highest frequency to lowest\n        yValKey.sort(function (a, b) {\n            return b.y - a.y;\n        }); // array of objects, each object has y, the same as yVals, and x, the category\n        yVals.sort(function (a, b) {\n            return b - a;\n        }); // array of y values, the height of the bars\n    }\n\n    plotXaxis = false;\n\n    var maxY = d3.max(yVals);\n    var minX = d3.min(xVals);\n    var maxX = d3.max(xVals);\n    var gname = ["subsetyes", "subsetno"];\n\n    var yVals2 = [];\n    var yVals1 = [];\n    for (i = 0; i < yVals.length; i++) {\n        yVals1.push({\n            y0: maxY - yVals[i],\n            y1: yVals[i],\n            col: d3Color\n        });\n        yVals2.push({\n            y0: 0,\n            y1: maxY - yVals[i],\n            col: "transparent"\n        });\n    }\n    var freqs = [yVals1, yVals2];\n\n    // y0 is the starting point\n    // y1 is the length of the bar\n\n    var mydiv = "#tabSubset";\n    var width = 200;\n    var height = 120;\n    var margin = {\n        top: 20,\n        right: 20,\n        bottom: 53,\n        left: 50\n    };\n\n    var x = d3.scale.linear().domain([minX - 0.5, maxX + 0.5]).range([0, width]);\n\n    var invx = d3.scale.linear().range([minX - 0.5, maxX + 0.5]).domain([0, width]);\n\n    var y = d3.scale.linear().domain([0, maxY]).range([0, height]);\n\n    var xAxis = d3.svg.axis().scale(x).ticks(yVals.length).orient("bottom");\n\n    var yAxis = d3.svg.axis().scale(y).orient("left");\n\n    //Create SVG element\n    var plotsvg = d3.select(mydiv).append("svg").attr("id", function () {\n        return myname.concat("_", mydiv.substr(1), "_", node.id);\n    }).style("width", width + margin.left + margin.right) //setting height to the height of #main.left\n    .style("height", height + margin.top + margin.bottom).append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");\n\n    var freq = plotsvg.selectAll("g.freq").data(freqs).enter().append("g").attr("class", "freq").attr("name", function (d, i) {\n        return myname.concat(gname[i]);\n    });\n\n    var rect = freq.selectAll("rect").data(Object).enter().append("rect").attr("class", "bar").attr("name", function (d, i) {\n        return xVals[i];\n    }).attr("x", function (d, i) {\n        return x(xVals[i] - 0.5 + barPadding);\n    }).attr("y", function (d) {\n        return y(d.y0);\n    }).attr("width", x(minX + 0.5 - 2 * barPadding)) // the "width" is the coordinate of the end of the first bar\n    .attr("height", function (d) {\n        return y(d.y1);\n    }).style("fill", function (d, i) {\n        if (node.subsetrange.length > 0 & d.col === d3Color & $.inArray(xVals[i].toString(), node.subsetrange) > -1) {\n            return selVarColor;\n        } else {\n            return d.col;\n        }\n    }).on("click", function () {\n        var selectMe = this;\n        var selectName = this.getAttribute("name");\n        if (this.parentNode.getAttribute("name") == myname.concat("subsetno")) {\n            selectMe = (0, _utils.elem)(\'[name="\' + myname + \'subsetyes"] > [name="\' + selectName + \'"]\');\n        }\n        d3.select(selectMe).style("fill", function (d, i) {\n            var myCol = "";\n            if (this.style.fill === selVarColor) {\n                var myindex = node.subsetrange.indexOf(this.getAttribute("name"));\n                node.subsetrange.splice(myindex, 1);\n                myCol = d3Color;\n            } else {\n                node.subsetrange.push(this.getAttribute("name"));\n                myCol = selVarColor;\n            }\n            return myCol;\n        });\n        plotsvg.select("text#selectrange").text(function () {\n            if (node.subsetrange.length == 0) {\n                return "Selected: all values";\n            } else {\n                var a = node.subsetrange;\n                var selecteds = new Array();\n                a.forEach(function (val) {\n                    selecteds.push(yValKey[val].x);\n                });\n                return "Selected: " + selecteds;\n            }\n        });\n    }).on("mouseover", function () {\n        var i = this.getAttribute("name");\n        plotsvg.select("text#mymouseover").text(function () {\n            return yValKey[i].x + ": " + yValKey[i].y;\n        });\n    }).on("mouseout", function () {\n        var i = this.getAttribute("name");\n        plotsvg.select("text#mymouseover").text(function () {\n            return "Value: Frequency";\n        });\n    });\n\n    if (plotXaxis) {\n        plotsvg.append("g").attr("class", "x axis").attr("transform", "translate(0," + height + ")").call(xAxis);\n    } else {\n        plotsvg.append("text").attr("id", "mymouseover").attr("x", 25).attr("y", height + 20).text(function () {\n            return "Value: Frequency";\n        });\n    }\n\n    plotsvg.append("text").attr("x", width / 2).attr("y", 0 - margin.top / 2).attr("text-anchor", "middle").style("font-size", "12px").text(myname);\n\n    plotsvg.append("text").attr("id", "selectrange").attr("x", 25).attr("y", height + 40).text(function () {\n        if (node.subsetrange.length == 0) return "Selected: all values";\n        var selecteds = new Array();\n        node.subsetrange.forEach(function (val) {\n            return selecteds.push(yValKey[val].x);\n        });\n        return "Selected: " + selecteds;\n    });\n}\n\nfunction densityNode(node, obj, radius) {\n    var myname = node.name.toString().concat("nodeplot");\n\n    d3.select(obj).selectAll("svg").remove();\n\n    var yVals = node.ploty;\n    var xVals = node.plotx;\n    // array of objects\n    var data2 = node.plotx.map(function (x, i) {\n        return { x: +x, y: +node.ploty[i] };\n    });\n\n    // default radius 40\n\n    // width 60\n    // height 30\n    // top 20\n    // l/r 10\n\n    var width = radius * 1.5;\n    var height = radius * 0.75;\n    var margin = {\n        top: 50 - radius * .75,\n        right: (80 - width) / 2,\n        bottom: 53,\n        left: (80 - width) / 2\n    };\n\n    var x = d3.scale.linear().domain([d3.min(xVals), d3.max(xVals)]).range([0, width]);\n\n    var y = d3.scale.linear().domain([d3.min(yVals), d3.max(yVals)]).range([height, 0]);\n\n    var area = d3.svg.area().interpolate("monotone").x(function (d) {\n        return x(d.x);\n    }).y0(height).y1(function (d) {\n        return y(d.y);\n    });\n\n    var plotsvg = d3.select(obj).insert("svg", ":first-child").attr("x", -40) // NOTE: Not sure exactly why these numbers work, but these hardcoded values seem to position the plot inside g correctly.  this shouldn\'t be hardcoded in the future\n    .attr("y", -45).attr("id", function () {\n        return myname;\n    }).style("width", width).style("height", height).append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");\n\n    plotsvg.append("path").datum(data2).attr("class", "area").attr("d", area);\n}\n\nfunction barsNode(node, obj, radius) {\n    var myname = node.name.toString().concat("nodeplot");\n\n    d3.select(obj).selectAll("svg").remove();\n\n    // Histogram spacing\n    var barPadding = .015; // Space between bars\n    var topScale = 1.2; // Multiplicative factor to assign space at top within graph - currently removed from implementation\n\n    // Data\n    var keys = Object.keys(node.plotvalues);\n    var yVals = new Array();\n    var xVals = new Array();\n    var yValKey = new Array();\n\n    if (node.nature === "nominal") {\n        var xi = 0;\n        for (var i = 0; i < keys.length; i++) {\n            if (node.plotvalues[keys[i]] == 0) continue;\n            yVals[xi] = node.plotvalues[keys[i]];\n            xVals[xi] = xi;\n            yValKey.push({ y: yVals[xi], x: keys[i] });\n            xi = xi + 1;\n        }\n        yValKey.sort(function (a, b) {\n            return b.y - a.y;\n        }); // array of objects, each object has y, the same as yVals, and x, the category\n        yVals.sort(function (a, b) {\n            return b - a;\n        }); // array of y values, the height of the bars\n    } else {\n        for (var i = 0; i < keys.length; i++) {\n            yVals[i] = node.plotvalues[keys[i]];\n            xVals[i] = Number(keys[i]);\n        }\n    }\n\n    var maxY = d3.max(yVals);\n    var minX = d3.min(xVals);\n    var maxX = d3.max(xVals);\n\n    var width = radius * 1.5;\n    var height = radius * 0.75;\n    var margin = {\n        top: 50 - radius * .75,\n        right: (80 - width) / 2,\n        bottom: 53,\n        left: (80 - width) / 2\n    };\n\n    var x = d3.scale.linear().domain([minX - 0.5, maxX + 0.5]).range([0, width]);\n\n    var invx = d3.scale.linear().range([minX - 0.5, maxX + 0.5]).domain([0, width]);\n\n    var y = d3.scale.linear().domain([0, maxY]).range([0, height]);\n\n    //Create SVG element\n    var plotsvg = d3.select(obj).insert("svg", ":first-child").attr("x", -40).attr("y", -45).attr("id", function () {\n        return myname;\n    }).style("width", width) // set height to the height of #main.left\n    .style("height", height).append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");\n\n    plotsvg.selectAll("rect").data(yVals).enter().append("rect").attr("x", function (d, i) {\n        return x(xVals[i] - 0.5 + barPadding);\n    }).attr("y", function (d) {\n        return y(maxY - d);\n    }).attr("width", x(minX + 0.5 - 2 * barPadding)) // the "width" is the coordinate of the end of the first bar\n    .attr("height", y).attr("fill", "#1f77b4");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvYXBwL3Bsb3RzLmpzP2JmMWYiXSwibmFtZXMiOlsiZGVuc2l0eSIsImJhcnMiLCJiYXJzU3Vic2V0IiwiZGVuc2l0eU5vZGUiLCJiYXJzTm9kZSIsImQzQ29sb3IiLCJzZWxWYXJDb2xvciIsIm5vZGUiLCJkaXYiLCJwcml2Iiwic2V0eExlZnQiLCJzZXR4TGVmdFRvcFJpZ2h0IiwiU3VtbWFyeSIsImFsZXJ0IiwicGxvdHgiLCJwbG90eSIsInhWYWxzIiwieVZhbHMiLCJwbG90Q0kiLCJtYXAiLCJ4IiwiaSIsInkiLCJib3VuZCIsInVwcGVyRXJyb3IiLCJsb3dlckVycm9yIiwiY29uc29sZSIsImxvZyIsInRlbXBXaWR0aCIsImQzIiwic2VsZWN0Iiwic3R5bGUiLCJ3aWR0aCIsInN1YnN0cmluZyIsImxlbmd0aCIsInR3IiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsIm9mZnNldFdpZHRoIiwidGVtcEhlaWdodCIsImhlaWdodCIsIm1hcmdpbiIsInRvcCIsInJpZ2h0IiwiYm90dG9tIiwibGVmdCIsInNjYWxlIiwibGluZWFyIiwiZG9tYWluIiwibWluIiwibWF4IiwicmFuZ2UiLCJpbnZ4IiwieEF4aXMiLCJzdmciLCJheGlzIiwidGlja3MiLCJvcmllbnQiLCJ5QXhpcyIsImJydXNoIiwiZXh0ZW50Iiwic3Vic2V0cmFuZ2UiLCJvbiIsImJydXNoZWQiLCJicnVzaDIiLCJicnVzaGVkMiIsImFyZWEiLCJpbnRlcnBvbGF0ZSIsImQiLCJ5MCIsInkxIiwibGluZSIsInBsb3RzdmciLCJzZWxlY3RBbGwiLCJyZW1vdmUiLCJhcHBlbmQiLCJhdHRyIiwibmFtZSIsInRvU3RyaW5nIiwiY29uY2F0Iiwic3Vic3RyIiwicmVwbGFjZSIsImlkIiwiZGF0dW0iLCJjYWxsIiwidGV4dCIsInRvUHJlY2lzaW9uIiwibWVhbiIsInJldHVybnZhbCIsImxpbmVGdW5jdGlvbiIsImNvbFNlcSIsImxpbmVEYXRhIiwiQXJyYXkiLCJ6TG93ZXIiLCJzZCIsInpVcHBlciIsInNsaWRlQm94Iiwic2xpZGVyIiwiaGFuZGxlIiwicyIsInhubSIsInNldHh2YWxzIiwic2xpZGVyMiIsImhhbmRsZTIiLCJlbXB0eSIsInZhbHVlIiwiZXZlbnQiLCJzb3VyY2VFdmVudCIsImludmVydCIsIm1vdXNlIiwieHBvcyIsIm0iLCJ6U2NvcmUiLCJ6Um91bmQiLCJNYXRoIiwicm91bmQiLCJhYnMiLCJ4dmFsIiwibXljZWxsIiwiaW5uZXJUZXh0IiwieDF2YWwiLCJiYXJQYWRkaW5nIiwidG9wU2NhbGUiLCJwbG90WGF4aXMiLCJrZXlzIiwiT2JqZWN0IiwicGxvdHZhbHVlcyIsImNpVXBwZXJWYWxzIiwiY2lMb3dlclZhbHMiLCJjaVNpemUiLCJ5VmFsS2V5IiwibmF0dXJlIiwieGkiLCJwbG90dmFsdWVzQ0kiLCJwbG90VmFsdWVzQ0kiLCJsb3dlckJvdW5kIiwidXBwZXJCb3VuZCIsInB1c2giLCJzb3J0IiwiYSIsImIiLCJOdW1iZXIiLCJudW1jaGFyIiwibWF4WSIsIm1pblgiLCJtYXhYIiwibXlkaXYiLCJzdGFiaWxpdHlCaW4iLCJteW5hbWUiLCJyZWN0V2lkdGgiLCJkYXRhIiwiZW50ZXIiLCJ5MiIsInRocmVzaG9sZCIsInQiLCJwb2ludHMiLCJ0d29TRiIsInRzZiIsImZvcm1hdCIsImduYW1lIiwieVZhbHMyIiwieVZhbHMxIiwiY29sIiwiZnJlcXMiLCJmcmVxIiwicmVjdCIsIiQiLCJpbkFycmF5Iiwic2VsZWN0TWUiLCJzZWxlY3ROYW1lIiwiZ2V0QXR0cmlidXRlIiwicGFyZW50Tm9kZSIsIm15Q29sIiwiZmlsbCIsIm15aW5kZXgiLCJpbmRleE9mIiwic3BsaWNlIiwic2VsZWN0ZWRzIiwiZm9yRWFjaCIsInZhbCIsIm9iaiIsInJhZGl1cyIsImRhdGEyIiwiaW5zZXJ0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7UUFNZ0JBLE8sR0FBQUEsTztRQW1VQUMsSSxHQUFBQSxJO1FBaWlCQUMsVSxHQUFBQSxVO1FBNk5BQyxX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LElBUkwsQ0FRVSxNQVJWLEVBUWtCLFNBUmxCO0FBU0giLCJmaWxlIjoiNC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7ZWxlbX0gZnJvbSAnLi91dGlscyc7XG5cbmxldCBkM0NvbG9yID0gJyMxZjc3YjQnOyAvLyBkMydzIGRlZmF1bHQgYmx1ZVxuZXhwb3J0IGxldCBzZWxWYXJDb2xvciA9ICcjZmE4MDcyJzsgLy8gZDMucmdiKFwic2FsbW9uXCIpO1xuXG4vLyBmdW5jdGlvbiB0byB1c2UgZDMgdG8gZ3JhcGggZGVuc2l0eSBwbG90cyB3aXRoIHByZXByb2Nlc3NlZCBkYXRhXG5leHBvcnQgZnVuY3Rpb24gZGVuc2l0eShub2RlLCBkaXYsIHByaXYpIHtcbiAgICBkaXYgPSB7c2V0eExlZnQ6ICcjc2V0eExlZnQnLCBzZXR4TGVmdFRvcFJpZ2h0OiAnI3NldHhMZWZ0VG9wUmlnaHQnLCBTdW1tYXJ5OiAnI3RhYlN1bW1hcnknfVtkaXZdO1xuXG4gICAgaWYgKCFkaXYpIHJldHVybiBhbGVydChcIkVycm9yOiBpbmNvcnJlY3QgZGl2IHNlbGVjdGVkIGZvciBwbG90czogXCIgKyBkaXYpO1xuXG4gICAgbGV0IFt4VmFscywgeVZhbHNdID0gW25vZGUucGxvdHgsIG5vZGUucGxvdHldO1xuICAgIGlmIChwcml2ICYmIG5vZGUucGxvdENJKSB7XG4gICAgICAgIGxldCBbdXBwZXJFcnJvciwgbG93ZXJFcnJvcl0gPSBbJ3VwcGVyQm91bmQnLCAnbG93ZXJCb3VuZCddLm1hcChcbiAgICAgICAgICAgIGJvdW5kID0+IHhWYWxzLm1hcCgoeCwgaSkgPT4gKHt4OiAreCwgeTogK25vZGUucGxvdENJW2JvdW5kXVtpXX0pKSk7XG4gICAgICAgIGNvbnNvbGUubG9nKCd1cHBlckVycm9yXFxuJywgdXBwZXJFcnJvcik7XG4gICAgfVxuXG4gICAgdmFyIHRlbXBXaWR0aCA9IGQzLnNlbGVjdChkaXYpLnN0eWxlKFwid2lkdGhcIik7XG4gICAgdmFyIHdpZHRoID0gdGVtcFdpZHRoLnN1YnN0cmluZygwLCAodGVtcFdpZHRoLmxlbmd0aCAtIDIpKTtcbiAgICBsZXQgdHcgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWFpbicpLm9mZnNldFdpZHRoO1xuICAgIHZhciB0ZW1wSGVpZ2h0ID0gZDMuc2VsZWN0KGRpdikuc3R5bGUoXCJoZWlnaHRcIik7XG4gICAgdmFyIGhlaWdodCA9IHRlbXBIZWlnaHQuc3Vic3RyaW5nKDAsICh0ZW1wSGVpZ2h0Lmxlbmd0aCAtIDIpKTtcbiAgICB2YXIgbWFyZ2luID0ge1xuICAgICAgICB0b3A6IDIwLC8vMjAsXG4gICAgICAgIHJpZ2h0OiAyMCxcbiAgICAgICAgYm90dG9tOiA1MywvLzUzLFxuICAgICAgICBsZWZ0OiAxMFxuICAgIH07XG5cbiAgICAvLyBOZWVkIHRvIGZpeCBhdXRvbWF0aWMgd2lkdGggYW5kIGhlaWdodCBzZXR0aW5ncyBmb3IgbGVmdHBhbmVsICgjdGFiU3Vic2V0LCAjdGFiU3VtbWFyeSlcbiAgICBpZiAoZGl2ID09IFwiI3RhYlN1bW1hcnlcIikge1xuICAgICAgICBbd2lkdGgsIGhlaWdodF0gPSBbMjQyLDE1MF07IC8vWzI0MiwgMjUwXTsgICAgICAgICAgICAgLy8gVGhlc2Ugc2hvdWxkIG5vdCBiZSBoYXJkIGNvZGVkXG4gICAgICAgIC8vIHdpZHRoID0gMC43ICogKHdpZHRoIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQpLFxuICAgICAgICAvLyBoZWlnaHQgPSAwLjMgKiAoaGVpZ2h0IC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b20pO1xuICAgIH0gZWxzZSBpZiAoZGl2ID09IFwiI3NldHhMZWZ0XCIgfHwgZGl2ID09IFwiI3NldHhMZWZ0VG9wUmlnaHRcIikge1xuICAgICAgICB3aWR0aD10dyouMTg1LW1hcmdpbi5sZWZ0LW1hcmdpbi5yaWdodDsgLy9yaWdodHBhbmVsLmV4cGFuZCBpcyA0MCBwZXJjZW50LCBzZXR4TGVmdCB0byA1MCBwZXJjZW50LCB0b2dnbGUgYmFyIGlzIDE2cHgsIHBhZGRpbmcsIGl0J3MgYWxsIGFib3V0IC4xODVcbiAgICAgICAgaGVpZ2h0PXdpZHRoKi42OyAvL2hlaWdodCB0byB3aWR0aCBpcyAuNlxuICAgIH0gZWxzZSB7XG4gICAgICAgIHdpZHRoID0gMC4zNSAqICh3aWR0aCAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0KSxcbiAgICAgICAgaGVpZ2h0ID0gMC4yNSAqIChoZWlnaHQgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbSk7XG4gICAgfTtcblxuXG4gICAgdmFyIHggPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAuZG9tYWluKFtkMy5taW4oeFZhbHMpLCBkMy5tYXgoeFZhbHMpXSlcbiAgICAgICAgLnJhbmdlKFswLCB3aWR0aF0pO1xuICAgIHZhciBpbnZ4ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLnJhbmdlKFtkMy5taW4oeFZhbHMpLCBkMy5tYXgoeFZhbHMpXSlcbiAgICAgICAgLmRvbWFpbihbMCwgd2lkdGhdKTtcbiAgICB2YXIgeSA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgIC5kb21haW4oW2QzLm1pbih5VmFscyksIGQzLm1heCh5VmFscyldKVxuICAgICAgICAucmFuZ2UoW2hlaWdodCwgMF0pO1xuICAgIHZhciB4QXhpcyA9IGQzLnN2Zy5heGlzKClcbiAgICAgICAgLnNjYWxlKHgpXG4gICAgICAgIC50aWNrcyg1KVxuICAgICAgICAub3JpZW50KFwiYm90dG9tXCIpO1xuICAgIHZhciB5QXhpcyA9IGQzLnN2Zy5heGlzKClcbiAgICAgICAgLnNjYWxlKHkpXG4gICAgICAgIC5vcmllbnQoXCJsZWZ0XCIpO1xuICAgIHZhciBicnVzaCA9IGQzLnN2Zy5icnVzaCgpXG4gICAgICAgIC54KHgpXG4gICAgICAgIC5leHRlbnQobm9kZS5zdWJzZXRyYW5nZSlcbiAgICAgICAgLm9uKFwiYnJ1c2hcIiwgYnJ1c2hlZCk7XG4gICAgdmFyIGJydXNoMiA9IGQzLnN2Zy5icnVzaCgpXG4gICAgICAgIC54KHgpXG4gICAgICAgIC5vbihcImJydXNoXCIsIGJydXNoZWQyKTtcbiAgICB2YXIgYXJlYSA9IGQzLnN2Zy5hcmVhKClcbiAgICAgICAgLmludGVycG9sYXRlKFwibW9ub3RvbmVcIilcbiAgICAgICAgLngoZCA9PiB4KGQueCkpXG4gICAgICAgIC55MChoZWlnaHQpXG4gICAgICAgIC55MShkID0+IHkoZC55KSk7XG4gICAgdmFyIGxpbmUgPSBkMy5zdmcubGluZSgpXG4gICAgICAgIC54KGQgPT4geChkLngpKVxuICAgICAgICAueShkID0+IHkoZC55KSlcbiAgICAgICAgLmludGVycG9sYXRlKFwibW9ub3RvbmVcIik7XG5cbiAgICAvLyBjdW1iZXJzb21lIHRvIHRyZWF0IFwidGFiU3VtbWFyeVwiIGRpZmZlcmVudGx5LCBidXQgd29ya3MgZm9yIG5vd1xuICAgIC8vIHRhYlN1bW1hcnksIGhhcyBhbiBpc3N1ZSwgdGhhdCB1bmxlc3Mgd2lkdGggaGVpZ2h0IGhhcmRjb2RlZCwgdGhleSBncm93IHdpdGggZWFjaCBhZGRpdGlvbmFsIGdyYXBoLlxuICAgIGlmIChkaXYgPT0gXCIjdGFiU3VtbWFyeVwiKSB7XG4gICAgICAgIHZhciBwbG90c3ZnID0gZDMuc2VsZWN0KGRpdilcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoXCJzdmdcIilcbiAgICAgICAgICAgIC5yZW1vdmUoKTtcbiAgICAgICAgcGxvdHN2ZyA9IGQzLnNlbGVjdChkaXYpXG4gICAgICAgICAgICAuYXBwZW5kKFwic3ZnXCIpXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsICgpID0+IG5vZGUubmFtZS50b1N0cmluZygpLmNvbmNhdChkaXYuc3Vic3RyKDEpKSlcbiAgICAgICAgICAgIC5zdHlsZShcIndpZHRoXCIsIDMwMCkgLy8gc2V0IGhlaWdodCB0byB0aGUgaGVpZ2h0IG9mICNtYWluLmxlZnRcbiAgICAgICAgICAgIC5zdHlsZShcImhlaWdodFwiLCAyMDApXG4gICAgICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgYHRyYW5zbGF0ZSgke21hcmdpbi5sZWZ0fSwke21hcmdpbi50b3B9KWApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwbG90c3ZnID0gZDMuc2VsZWN0KGRpdilcbiAgICAgICAgICAgIC5hcHBlbmQoXCJzdmdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgKCkgPT4gbm9kZS5uYW1lLnRvU3RyaW5nKClcbiAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXCh8XFwpL2csIFwiXCIpXG4gICAgICAgICAgICAgICAgICAuY29uY2F0KFwiX1wiLCBkaXYuc3Vic3RyKDEpLCBcIl9cIiwgbm9kZS5pZCkpXG4gICAgICAgICAgICAuc3R5bGUoXCJ3aWR0aFwiLCB3aWR0aCArIG1hcmdpbi5sZWZ0ICsgbWFyZ2luLnJpZ2h0KSAvL3NldHRpbmcgaGVpZ2h0IHRvIHRoZSBoZWlnaHQgb2YgI21haW4ubGVmdFxuICAgICAgICAgICAgLnN0eWxlKFwiaGVpZ2h0XCIsIGhlaWdodCArIG1hcmdpbi50b3AgKyBtYXJnaW4uYm90dG9tKVxuICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIGB0cmFuc2xhdGUoJHttYXJnaW4ubGVmdH0sJHttYXJnaW4udG9wfSlgKTtcbiAgICB9O1xuICAgIHBsb3RzdmcuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAuZGF0dW0oeFZhbHMubWFwKCh4LCBpKSA9PiAoe3g6ICt4LCB5OiArbm9kZS5wbG90eVtpXX0pKSlcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImFyZWFcIilcbiAgICAgICAgLmF0dHIoXCJkXCIsIGFyZWEpO1xuXG4gICAgLy9hZGQgdXBwZXIgYm91bmRcbiAgICBwcml2ICYmIG5vZGUucGxvdENJICYmIHBsb3RzdmcuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwidXBwZXJFcnJvclwiKVxuICAgICAgICAuZGF0dW0odXBwZXJFcnJvcilcbiAgICAgICAgLmF0dHIoXCJkXCIsIGFyZWEpO1xuXG4gICAgLy9hZGQgbG93ZXIgYm91bmRcbiAgICBwcml2ICYmIG5vZGUucGxvdENJICYmIHBsb3RzdmcuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwibG93ZXJFcnJvclwiKVxuICAgICAgICAuZGF0dW0obG93ZXJFcnJvcilcbiAgICAgICAgLmF0dHIoXCJkXCIsIGFyZWEpO1xuXG4gICAgcGxvdHN2Zy5hcHBlbmQoXCJnXCIpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJ4IGF4aXNcIilcbiAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCxcIiArIGhlaWdodCArIFwiKVwiKVxuICAgICAgICAuY2FsbCh4QXhpcyk7XG5cbiAgICBwbG90c3ZnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgLmF0dHIoXCJ4XCIsICh3aWR0aCAvIDIpKVxuICAgICAgICAuYXR0cihcInlcIiwgMCAtIChtYXJnaW4udG9wIC8gMikpXG4gICAgICAgIC5hdHRyKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIilcbiAgICAgICAgLnN0eWxlKFwiZm9udC1zaXplXCIsIFwiMTJweFwiKVxuICAgICAgICAudGV4dChub2RlLm5hbWUpO1xuXG4gICAgLy8gYWRkIGJydXNoIGlmIHN1YnNldFxuICAgIC8vIHRoaXMgdGFiIGRvZXNuJ3QgZXhpc3QgYW55bW9yZSAtIFNob2Vib3hhbVxuICAgIGlmIChkaXYgPT0gXCIjdGFiU3Vic2V0XCIpIHtcbiAgICAgICAgcGxvdHN2Zy5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsIFwicmFuZ2VcIilcbiAgICAgICAgICAgIC5hdHRyKFwieFwiLCAyNSlcbiAgICAgICAgICAgIC5hdHRyKFwieVwiLCBoZWlnaHQgKyA0MClcbiAgICAgICAgICAgIC50ZXh0KCgpID0+IFwiUmFuZ2U6IFwiLmNvbmNhdChkMy5taW4oeFZhbHMpLnRvUHJlY2lzaW9uKDQpLCBcIiB0byBcIiwgZDMubWF4KHhWYWxzKS50b1ByZWNpc2lvbig0KSkpO1xuICAgICAgICBwbG90c3ZnLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJ4IGJydXNoXCIpXG4gICAgICAgICAgICAuY2FsbChicnVzaClcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoXCJyZWN0XCIpXG4gICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCBoZWlnaHQpO1xuICAgIH1cblxuICAgIC8vIGFkZCB6IGxpbmVzIGFuZCBzbGlkZXJzIHNldHhcbiAgICBpZiAoZGl2ID09IFwiI3NldHhMZWZ0XCIgfHwgZGl2ID09IFwiI3NldHhMZWZ0VG9wUmlnaHRcIikge1xuICAgICAgICBwbG90c3ZnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgXCJyYW5nZVwiKSAvLyB0aGlzIGlzIGJhZCBwcmFjdGljZSwgaWQgaXMgbm90IHVuaXF1ZVxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywneHZhbCcpXG4gICAgICAgICAgICAuYXR0cihcInhcIiwgMjUpXG4gICAgICAgICAgICAuYXR0cihcInlcIiwgaGVpZ2h0ICsgNDApXG4gICAgICAgICAgICAudGV4dCgoKSA9PiBcIng6IFwiLmNvbmNhdCgoK25vZGUubWVhbikudG9QcmVjaXNpb24oNCkpKTtcblxuICAgICAgICBwbG90c3ZnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgXCJyYW5nZTJcIikgLy8gdGhpcyBpcyBiYWQgcHJhY3RpY2UsIGlkIGlzIG5vdCB1bmlxdWVcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsJ3gxdmFsJylcbiAgICAgICAgICAgIC5hdHRyKFwieFwiLCAyNSlcbiAgICAgICAgICAgIC5hdHRyKFwieVwiLCBoZWlnaHQgKyA1MClcbiAgICAgICAgICAgIC50ZXh0KCBfID0+IHtcbiAgICAgICAgICAgICAgICAgIGxldCByZXR1cm52YWwgPSBcIngxOiBcIi5jb25jYXQoKCtub2RlLm1lYW4pLnRvUHJlY2lzaW9uKDQpKTtcbiAgICAgICAgICAgICAgIHJldHVybiByZXR1cm52YWx9KTtcbiAgICAgICAgXG5cbiAgICAgICAgLy8gY3JlYXRlIHRpY2sgbWFya3MgYXQgYWxsIHpzY29yZXMgaW4gdGhlIGJvdW5kcyBvZiB0aGUgZGF0YVxuICAgICAgICB2YXIgbGluZUZ1bmN0aW9uID0gZDMuc3ZnLmxpbmUoKVxuICAgICAgICAgICAgLngoZCA9PiBkLngpXG4gICAgICAgICAgICAueShkID0+IGQueSlcbiAgICAgICAgICAgIC5pbnRlcnBvbGF0ZShcImxpbmVhclwiKTtcblxuICAgICAgICB2YXIgY29sU2VxID0gW1wiI0EyQ0Q1QVwiLCBcIm9yYW5nZVwiLCBcInJlZFwiXTsgLy8gd2lsbCBjeWNsZSB0aHJvdWdoIGNvbG9yIHNlcXVlbmNlLCBhbmQgdGhlbiByZXBlYXQgbGFzdCBjb2xvclxuICAgICAgICB2YXIgbGluZURhdGEgPSBuZXcgQXJyYXk7XG5cbiAgICAgICAgdmFyIHpMb3dlciA9IC0xICogKGQzLm1pbih4VmFscykgLSBub2RlLm1lYW4pIC8gbm9kZS5zZDsgLy8genNjb3JlIG9mIGxvd2VyIGJvdW5kXG4gICAgICAgIHZhciB6VXBwZXIgPSAoZDMubWF4KHhWYWxzKSAtIG5vZGUubWVhbikgLyBub2RlLnNkOyAvLyB6c2NvcmUgb2YgdXBwZXIgYm91bmRcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHpVcHBlcjsgaSsrKSB7XG4gICAgICAgICAgICBsaW5lRGF0YSA9IFt7XG4gICAgICAgICAgICAgICAgXCJ4XCI6IHgoK25vZGUubWVhbiArIGkgKiBub2RlLnNkKSxcbiAgICAgICAgICAgICAgICBcInlcIjogaGVpZ2h0ICogLjdcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBcInhcIjogeCgrbm9kZS5tZWFuICsgaSAqIG5vZGUuc2QpLFxuICAgICAgICAgICAgICAgIFwieVwiOiBoZWlnaHQgKiAuOVxuICAgICAgICAgICAgfV07XG4gICAgICAgICAgICBwbG90c3ZnLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImRcIiwgbGluZUZ1bmN0aW9uKFtsaW5lRGF0YVswXSwgbGluZURhdGFbMV1dKSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInN0cm9rZVwiLCBjb2xTZXFbZDMubWluKFtpLCBjb2xTZXEubGVuZ3RoIC0gMV0pXSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInN0cm9rZS13aWR0aFwiLCAxLjUpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJmaWxsXCIsIFwibm9uZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgekxvd2VyOyBpKyspIHtcbiAgICAgICAgICAgIGxpbmVEYXRhID0gW3tcbiAgICAgICAgICAgICAgICBcInhcIjogeCgrbm9kZS5tZWFuIC0gaSAqIG5vZGUuc2QpLFxuICAgICAgICAgICAgICAgIFwieVwiOiBoZWlnaHQgKiAuN1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIFwieFwiOiB4KCtub2RlLm1lYW4gLSBpICogbm9kZS5zZCksXG4gICAgICAgICAgICAgICAgXCJ5XCI6IGhlaWdodCAqIC45XG4gICAgICAgICAgICB9XTtcbiAgICAgICAgICAgIHBsb3RzdmcuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiZFwiLCBsaW5lRnVuY3Rpb24oW2xpbmVEYXRhWzBdLCBsaW5lRGF0YVsxXV0pKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwic3Ryb2tlXCIsIGNvbFNlcVtkMy5taW4oW2ksIGNvbFNlcS5sZW5ndGggLSAxXSldKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwic3Ryb2tlLXdpZHRoXCIsIDEuNSlcbiAgICAgICAgICAgICAgICAuYXR0cihcImZpbGxcIiwgXCJub25lXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaW5pdGlhbGl6ZSBzbGlkZXIgY29tcG9uZW50c1xuICAgICAgICB2YXIgc2xpZGVCb3ggPSBwbG90c3ZnLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJ4IGF4aXNcIilcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsXCIgKyBoZWlnaHQgKiAuOCArIFwiKVwiKVxuICAgICAgICAgICAgLmNhbGwoZDMuc3ZnLmF4aXMoKVxuICAgICAgICAgICAgICAgICAgLnNjYWxlKHgpXG4gICAgICAgICAgICAgICAgICAudGlja3MoMClcbiAgICAgICAgICAgICAgICAgIC5vcmllbnQoXCJib3R0b21cIikpO1xuICAgICAgICB2YXIgc2xpZGVyID0gcGxvdHN2Zy5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwic2xpZGVyXCIpXG4gICAgICAgICAgICAuY2FsbChicnVzaCk7XG4gICAgICAgIHZhciBoYW5kbGUgPSBzbGlkZXIuYXBwZW5kKFwicG9seWdvblwiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImhhbmRsZVwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCxcIiArIGhlaWdodCAqIC43ICsgXCIpXCIpXG4gICAgICAgICAgICAuYXR0cihcInBvaW50c1wiLCBfID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgcyA9IDY7XG4gICAgICAgICAgICAgICAgbGV0IHhubSA9IG5vZGUuc2V0eHZhbHNbMF0gPT0gJycgPyB4KG5vZGUubWVhbikgOiB4KG5vZGUuc2V0eHZhbHNbMF0pO1xuICAgICAgICAgICAgICAgIHJldHVybiAoeG5tIC0gcykgKyBcIixcIiArICgtcykgKyBcIiBcIiArICh4bm0gKyBzKSArIFwiLFwiICsgKC1zKSArIFwiIFwiICsgeG5tICsgXCIsXCIgKyAocyAqIDEuMyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgdmFyIHNsaWRlcjIgPSBwbG90c3ZnLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJzbGlkZXJcIilcbiAgICAgICAgICAgIC5jYWxsKGJydXNoMik7XG4gICAgICAgIHZhciBoYW5kbGUyID0gc2xpZGVyMi5hcHBlbmQoXCJwb2x5Z29uXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiaGFuZGxlXCIpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLFwiICsgaGVpZ2h0ICogLjkgKyBcIilcIilcbiAgICAgICAgICAgIC5hdHRyKFwicG9pbnRzXCIsIF8gPT4ge1xuICAgICAgICAgICAgICAgIGxldCBzID0gNjtcbiAgICAgICAgICAgICAgICBsZXQgeG5tID0gbm9kZS5zZXR4dmFsc1sxXSA9PSAnJyA/IHgobm9kZS5tZWFuKSA6IHgobm9kZS5zZXR4dmFsc1sxXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh4bm0gLSBzKSArIFwiLFwiICsgcyArIFwiIFwiICsgKHhubSArIHMpICsgXCIsXCIgKyBzICsgXCIgXCIgKyB4bm0gKyBcIixcIiArICgtcyAqIDEuMyk7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBicnVzaGluZyBmdW5jdGlvbnNcbiAgICBmdW5jdGlvbiBicnVzaGVkKCkge1xuICAgICAgICBpZiAoZGl2ID09IFwiI3RhYlN1bW1hcnlcIikge1xuICAgICAgICAgICAgcGxvdHN2Zy5zZWxlY3QoXCJ0ZXh0I3JhbmdlXCIpXG4gICAgICAgICAgICAgICAgLnRleHQoKCkgPT4gYnJ1c2guZW1wdHkoKSA/XG4gICAgICAgICAgICAgICAgICAgIFwiUmFuZ2U6IFwiLmNvbmNhdChkMy5taW4oeFZhbHMpLnRvUHJlY2lzaW9uKDQpLCBcIiB0byBcIiwgZDMubWF4KHhWYWxzKS50b1ByZWNpc2lvbig0KSkgOlxuICAgICAgICAgICAgICAgICAgICBcIlJhbmdlOiBcIi5jb25jYXQoKGJydXNoLmV4dGVudCgpWzBdKS50b1ByZWNpc2lvbig0KSwgXCIgdG8gXCIsIChicnVzaC5leHRlbnQoKVsxXSkudG9QcmVjaXNpb24oNCkpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG5vZGUuc3Vic2V0cmFuZ2UgPSBicnVzaC5leHRlbnQoKVswXS50b1ByZWNpc2lvbig0KSAhPSBicnVzaC5leHRlbnQoKVsxXS50b1ByZWNpc2lvbig0KSA/XG4gICAgICAgICAgICAgICAgWyhicnVzaC5leHRlbnQoKVswXSkudG9QcmVjaXNpb24oNCksIChicnVzaC5leHRlbnQoKVsxXSkudG9QcmVjaXNpb24oNCldIDpcbiAgICAgICAgICAgICAgICBbXCJcIiwgXCJcIl07XG4gICAgICAgIH0gZWxzZSBpZiAoZGl2ID09IFwiI3NldHhMZWZ0XCIgfHwgZGl2ID09IFwiI3NldHhMZWZ0VG9wUmlnaHRcIikge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gYnJ1c2guZXh0ZW50KClbMF07XG4gICAgICAgICAgICB2YXIgcyA9IDY7XG4gICAgICAgICAgICBpZiAoZDMuZXZlbnQuc291cmNlRXZlbnQpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHguaW52ZXJ0KGQzLm1vdXNlKHRoaXMpWzBdKTtcbiAgICAgICAgICAgICAgICBicnVzaC5leHRlbnQoW3ZhbHVlLCB2YWx1ZV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzZXQgeCBwb3NpdGlvbiBvZiBzbGlkZXIgY2VudGVyXG4gICAgICAgICAgICB2YXIgeHBvcyA9IHgodmFsdWUpO1xuICAgICAgICAgICAgaWYgKHZhbHVlID4gZDMubWF4KHhWYWxzKSkgeyAvLyBkcmFnZ2VkIHBhc3QgbWF4XG4gICAgICAgICAgICAgICAgeHBvcyA9IHgoZDMubWF4KHhWYWxzKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlIDwgZDMubWluKHhWYWxzKSkgeyAvLyBkcmFnZ2VkIHBhc3QgbWluXG4gICAgICAgICAgICAgICAgeHBvcyA9IHgoZDMubWluKHhWYWxzKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBtID0gK25vZGUubWVhbjtcbiAgICAgICAgICAgICAgICB2YXIgc2QgPSArbm9kZS5zZDtcbiAgICAgICAgICAgICAgICB2YXIgelNjb3JlID0gKHZhbHVlIC0gbSkgLyBzZDsgLy8gei1zY29yZVxuICAgICAgICAgICAgICAgIHZhciB6Um91bmQgPSBNYXRoLnJvdW5kKHpTY29yZSk7IC8vIG5lYXJlc3QgaW50ZWdlciB6LXNjb3JlXG4gICAgICAgICAgICAgICAgaWYgKC4xID4gTWF0aC5hYnMoelJvdW5kIC0gelNjb3JlKSkgLy8gc25hcCB0byBpbnRlZ2VyIHotc2NvcmVcbiAgICAgICAgICAgICAgICAgICAgeHBvcyA9IHgobSArICh6Um91bmQgKiBzZCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjcmVhdGUgc2xpZGVyIHN5bWJvbCBhbmQgdGV4dFxuICAgICAgICAgICAgaGFuZGxlLmF0dHIoXCJwb2ludHNcIiwgXyA9PiAoeHBvcyAtIHMpICsgXCIsXCIgKyAoLXMpICsgXCIgXCIgKyAoeHBvcyArIHMpICsgXCIsXCIgKyAoLXMpICsgXCIgXCIgKyB4cG9zICsgXCIsXCIgKyAocyAqIDEuMykpO1xuICAgICAgICAgICAgcGxvdHN2Zy5zZWxlY3QoXCJ0ZXh0I3JhbmdlXCIpXG4gICAgICAgICAgICAudGV4dChfID0+IHtcbiAgICAgICAgICAgICAgICAgIGxldCByZXR1cm52YWwgPSBcIng6IFwiLmNvbmNhdCgoaW52eCh4cG9zKSkudG9QcmVjaXNpb24oNCkpO1xuICAgICAgICAgICAgICAgICAgbGV0IHh2YWwgPSBpbnZ4KHhwb3MpLnRvUHJlY2lzaW9uKDQpO1xuICAgICAgICAgICAgICAgICAgbGV0IG15Y2VsbCA9IG5vZGUubmFtZStcIkZyb21cIjsgLy8gaGFyZGNvZGVkIGhlcmVcbiAgICAgICAgICAgICAgICAgIGlmKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG15Y2VsbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobXljZWxsKS5pbm5lclRleHQ9eHZhbDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm52YWx9KTtcbiAgICAgICAgICAgIG5vZGUuc2V0eHZhbHNbMF0gPSAoaW52eCh4cG9zKSkudG9QcmVjaXNpb24oNCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjZXJ0YWlubHkgYSBtb3JlIGNsZXZlciB3YXkgdG8gZG8gdGhpcywgYnV0IGZvciBub3cgaXQncyBiYXNpY2FsbHkgY29waWVkIHdpdGggYnJ1c2ggYW5kIGhhbmRsZSBjaGFuZ2VzIHRvIGJydXNoMiBhbmQgaGFuZGxlMiBhbmQgI3JhbmdlIHRvICNyYW5nZTIgYW5kIHNldHh2YWxzWzBdIHRvIHNldHh2YWxzWzFdXG4gICAgZnVuY3Rpb24gYnJ1c2hlZDIoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGJydXNoMi5leHRlbnQoKVswXTtcbiAgICAgICAgdmFyIHMgPSA2OyAvLyBzY2FsaW5nIGZvciB0cmlhbmdsZSBzaGFwZVxuXG4gICAgICAgIGlmIChkMy5ldmVudC5zb3VyY2VFdmVudCkge1xuICAgICAgICAgICAgdmFsdWUgPSB4LmludmVydChkMy5tb3VzZSh0aGlzKVswXSk7XG4gICAgICAgICAgICBicnVzaDIuZXh0ZW50KFt2YWx1ZSwgdmFsdWVdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldCB4IHBvc2l0aW9uIG9mIHNsaWRlciBjZW50ZXJcbiAgICAgICAgdmFyIHhwb3MgPSB4KHZhbHVlKTtcbiAgICAgICAgaWYgKHZhbHVlID4gZDMubWF4KHhWYWxzKSkgeyAvLyBkcmFnZ2VkIHBhc3QgbWF4XG4gICAgICAgICAgICB4cG9zID0geChkMy5tYXgoeFZhbHMpKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA8IGQzLm1pbih4VmFscykpIHsgLy8gZHJhZ2dlZCBwYXN0IG1pblxuICAgICAgICAgICAgeHBvcyA9IHgoZDMubWluKHhWYWxzKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbSA9ICtub2RlLm1lYW47XG4gICAgICAgICAgICB2YXIgc2QgPSArbm9kZS5zZDtcbiAgICAgICAgICAgIHZhciB6U2NvcmUgPSAodmFsdWUgLSBtKSAvIHNkOyAvLyB6LXNjb3JlXG4gICAgICAgICAgICB2YXIgelJvdW5kID0gTWF0aC5yb3VuZCh6U2NvcmUpOyAvLyBuZWFyZXN0IGludGVnZXIgei1zY29yZVxuICAgICAgICAgICAgaWYgKC4xID4gTWF0aC5hYnMoelJvdW5kIC0gelNjb3JlKSkgLy8gc25hcCB0byBpbnRlZ2VyIHotc2NvcmVcbiAgICAgICAgICAgICAgICB4cG9zID0geChtICsgKHpSb3VuZCAqIHNkKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjcmVhdGUgc2xpZGVyIHN5bWJvbCBhbmQgdGV4dFxuICAgICAgICBoYW5kbGUyLmF0dHIoXCJwb2ludHNcIiwgXyA9PiAoeHBvcyAtIHMpICsgXCIsXCIgKyBzICsgXCIgXCIgKyAoeHBvcyArIHMpICsgXCIsXCIgKyBzICsgXCIgXCIgKyB4cG9zICsgXCIsXCIgKyAoLXMgKiAxLjMpKTtcbiAgICAgICAgcGxvdHN2Zy5zZWxlY3QoXCJ0ZXh0I3JhbmdlMlwiKVxuICAgICAgICAudGV4dChfID0+IHtcbiAgICAgICAgICAgICAgbGV0IHJldHVybnZhbCA9IFwieDE6IFwiLmNvbmNhdCgoaW52eCh4cG9zKSkudG9QcmVjaXNpb24oNCkpO1xuICAgICAgICAgICAgICBsZXQgeDF2YWwgPSBpbnZ4KHhwb3MpLnRvUHJlY2lzaW9uKDQpO1xuICAgICAgICAgICAgICBsZXQgbXljZWxsID0gbm9kZS5uYW1lK1wiVG9cIjsgLy8gaGFyZGNvZGVkIGhlcmVcbiAgICAgICAgICAgICAgaWYoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobXljZWxsKSkge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG15Y2VsbCkuaW5uZXJUZXh0PXgxdmFsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXR1cm52YWx9KTtcbiAgICAgICAgbm9kZS5zZXR4dmFsc1sxXSA9IChpbnZ4KHhwb3MpKS50b1ByZWNpc2lvbig0KTtcbiAgICAgICAgXG4gICAgICAgIFxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJhcnMobm9kZSwgZGl2LCBwcml2KSB7XG4gICAgLy8gSGlzdG9ncmFtIHNwYWNpbmdcbiAgICB2YXIgYmFyUGFkZGluZyA9IC4wMTU7IC8vIFNwYWNlIGJldHdlZW4gYmFyc1xuICAgIHZhciB0b3BTY2FsZSA9IDEuMjsgLy8gTXVsdGlwbGljYXRpdmUgZmFjdG9yIHRvIGFzc2lnbiBzcGFjZSBhdCB0b3Agd2l0aGluIGdyYXBoIC0gY3VycmVudGx5IHJlbW92ZWQgZnJvbSBpbXBsZW1lbnRhdGlvblxuICAgIHZhciBwbG90WGF4aXMgPSB0cnVlO1xuXG4gICAgLy8gRGF0YVxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMobm9kZS5wbG90dmFsdWVzKTtcbiAgICB2YXIgeVZhbHMgPSBuZXcgQXJyYXk7XG4gICAgdmFyIGNpVXBwZXJWYWxzID0gbmV3IEFycmF5O1xuICAgIHZhciBjaUxvd2VyVmFscyA9IG5ldyBBcnJheTtcbiAgICB2YXIgY2lTaXplO1xuXG4gICAgdmFyIHhWYWxzID0gbmV3IEFycmF5O1xuICAgIHZhciB5VmFsS2V5ID0gbmV3IEFycmF5O1xuXG4gICAgaWYgKG5vZGUubmF0dXJlID09IFwibm9taW5hbFwiKSB7XG4gICAgICAgIHZhciB4aSA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKG5vZGUucGxvdHZhbHVlc1trZXlzW2ldXSA9PSAwKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgeVZhbHNbeGldID0gbm9kZS5wbG90dmFsdWVzW2tleXNbaV1dO1xuICAgICAgICAgICAgeFZhbHNbeGldID0geGk7XG4gICAgICAgICAgICBpZiAocHJpdikge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLnBsb3R2YWx1ZXNDSSkge1xuICAgICAgICAgICAgICAgICAgICBjaUxvd2VyVmFsc1t4aV0gPSBub2RlLnBsb3RWYWx1ZXNDSS5sb3dlckJvdW5kW2tleXNbaV1dO1xuICAgICAgICAgICAgICAgICAgICBjaVVwcGVyVmFsc1t4aV0gPSBub2RlLnBsb3RWYWx1ZXNDSS51cHBlckJvdW5kW2tleXNbaV1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaVNpemUgPSBjaVVwcGVyVmFsc1t4aV0gLSBjaUxvd2VyVmFsc1t4aV07XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB5VmFsS2V5LnB1c2goe1xuICAgICAgICAgICAgICAgIHk6IHlWYWxzW3hpXSxcbiAgICAgICAgICAgICAgICB4OiBrZXlzW2ldXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHhpID0geGkgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHlWYWxLZXkuc29ydCgoYSwgYikgPT4gYi55IC0gYS55KTsgLy8gYXJyYXkgb2Ygb2JqZWN0cywgZWFjaCBvYmplY3QgaGFzIHksIHRoZSBzYW1lIGFzIHlWYWxzLCBhbmQgeCwgdGhlIGNhdGVnb3J5XG4gICAgICAgIHlWYWxzLnNvcnQoKGEsIGIpID0+IGIgLSBhKTsgLy8gYXJyYXkgb2YgeSB2YWx1ZXMsIHRoZSBoZWlnaHQgb2YgdGhlIGJhcnNcbiAgICAgICAgY2lVcHBlclZhbHMuc29ydCgoYSwgYikgPT4gYi55IC0gYS55KTsgLy8gP1xuICAgICAgICBjaUxvd2VyVmFscy5zb3J0KChhLCBiKSA9PiBiLnkgLSBhLnkpOyAvLyA/XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwicGxvdHZhbHVlcyBpbiBiYXJzXCIpO1xuICAgICAgICAgICAgeVZhbHNbaV0gPSBub2RlLnBsb3R2YWx1ZXNba2V5c1tpXV07XG4gICAgICAgICAgICB4VmFsc1tpXSA9IE51bWJlcihrZXlzW2ldKTtcbiAgICAgICAgICAgIGlmIChwcml2KSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUucGxvdHZhbHVlc0NJKSB7XG4gICAgICAgICAgICAgICAgICAgIGNpTG93ZXJWYWxzW2ldID0gbm9kZS5wbG90dmFsdWVzQ0kubG93ZXJCb3VuZFtrZXlzW2ldXTtcbiAgICAgICAgICAgICAgICAgICAgY2lVcHBlclZhbHNbaV0gPSBub2RlLnBsb3R2YWx1ZXNDSS51cHBlckJvdW5kW2tleXNbaV1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaVNpemUgPSBjaVVwcGVyVmFsc1tpXSAtIGNpTG93ZXJWYWxzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCh5VmFscy5sZW5ndGggPiAxNSAmIG5vZGUubnVtY2hhciA9PSBcIm51bWVyaWNcIikgfHwgKHlWYWxzLmxlbmd0aCA+IDUgJiBub2RlLm51bWNoYXIgPT0gXCJjaGFyYWN0ZXJcIikpXG4gICAgICAgIHBsb3RYYXhpcyA9IGZhbHNlO1xuICAgIHZhciBtYXhZID0gZDMubWF4KHlWYWxzKTsgLy8gaW4gdGhlIGZ1dHVyZSwgc2V0IG1heFkgdG8gdGhlIHZhbHVlIG9mIHRoZSBtYXhpbXVtIGNvbmZpZGVuY2UgbGltaXRcbiAgICBpZiAocHJpdiAmJiBub2RlLnBsb3R2YWx1ZXNDSSkgbWF4WSA9IGQzLm1heChjaVVwcGVyVmFscyk7XG4gICAgdmFyIG1pblggPSBkMy5taW4oeFZhbHMpO1xuICAgIHZhciBtYXhYID0gZDMubWF4KHhWYWxzKTtcblxuICAgIGxldCBteWRpdjtcbiAgICBpZiAoZGl2ID09IFwic2V0eExlZnRcIikgbXlkaXYgPSBcIiNzZXR4TGVmdFwiO1xuICAgIGVsc2UgaWYgKGRpdiA9PSBcIlN1bW1hcnlcIikgbXlkaXYgPSBcIiN0YWJTdW1tYXJ5XCI7XG4gICAgZWxzZSBpZiAoZGl2ID09IFwic2V0eExlZnRUb3BSaWdodFwiKSBteWRpdiA9IFwiI3NldHhMZWZ0VG9wUmlnaHRcIjtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiBhbGVydChcIkVycm9yOiBpbmNvcnJlY3QgZGl2IHNlbGVjdGVkIGZvciBwbG90c1wiKTtcblxuICAgIHZhciB0ZW1wV2lkdGggPSBkMy5zZWxlY3QobXlkaXYpLnN0eWxlKFwid2lkdGhcIilcbiAgICB2YXIgd2lkdGggPSB0ZW1wV2lkdGguc3Vic3RyaW5nKDAsICh0ZW1wV2lkdGgubGVuZ3RoIC0gMikpO1xuICAgIHZhciB0ZW1wSGVpZ2h0ID0gZDMuc2VsZWN0KG15ZGl2KS5zdHlsZShcImhlaWdodFwiKVxuICAgIHZhciBoZWlnaHQgPSB0ZW1wSGVpZ2h0LnN1YnN0cmluZygwLCAodGVtcEhlaWdodC5sZW5ndGggLSAyKSk7XG5cbiAgICB2YXIgbWFyZ2luID0ge1xuICAgICAgICB0b3A6IDIwLFxuICAgICAgICByaWdodDogMjAsXG4gICAgICAgIGJvdHRvbTogNTMsXG4gICAgICAgIGxlZnQ6IDEwXG4gICAgfTtcbiAgICBsZXQgdHcgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWFpbicpLm9mZnNldFdpZHRoO1xuXG4gICAgLy8gTmVlZCB0byBmaXggYXV0b21hdGljIHdpZHRoIGFuZCBoZWlnaHQgc2V0dGluZ3MgZm9yIGxlZnRwYW5lbCAoI3RhYlN1YnNldCwgI3RhYlN1bW1hcnkpXG4gICAgaWYgKG15ZGl2ID09IFwiI3RhYlN1bW1hcnlcIikge1xuICAgICAgICBbd2lkdGgsIGhlaWdodF0gPSBbMjQyLDE1MF07IC8vWzI0MiwgMjUwXTsgICAgICAgLy8gVGhlc2Ugc2hvdWxkIG5vdCBiZSBoYXJkIGNvZGVkXG4gICAgICAgIC8vIHdpZHRoID0gMC43ICogKHdpZHRoIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQpO1xuICAgICAgICAvLyBoZWlnaHQgPSAwLjMgKiAoaGVpZ2h0IC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b20pO1xuICAgIH0gZWxzZSBpZiAobXlkaXYgPT0gXCIjc2V0eExlZnRcIiB8fCBteWRpdj09XCIjc2V0eExlZnRUb3BSaWdodFwiKSB7XG4gICAgICAgIC8vd2lkdGggPSAyMDA7XG4gICAgICAgIC8vaGVpZ2h0ID0gMTIwO1xuICAgICAgICB3aWR0aD10dyouMTg1LW1hcmdpbi5sZWZ0LW1hcmdpbi5yaWdodDsgLy9yaWdodHBhbmVsLmV4cGFuZCBpcyA0MCBwZXJjZW50LCBzZXR4TGVmdCB0byA1MCBwZXJjZW50LCB0b2dnbGUgYmFyIGlzIDE2cHgsIHBhZGRpbmcsIGl0J3MgYWxsIGFib3V0IC4xODVcbiAgICAgICAgaGVpZ2h0PXdpZHRoKi42OyAvL2hlaWdodCB0byB3aWR0aCBpcyAuNlxuICAgIH0gZWxzZSB7XG4gICAgICAgIHdpZHRoID0gMC4zNSAqICh3aWR0aCAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0KTtcbiAgICAgICAgaGVpZ2h0ID0gMC4yNSAqIChoZWlnaHQgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbSk7XG4gICAgfTtcblxuICAgIGlmIChwcml2ICYmIG5vZGUuc3RhYmlsaXR5QmluKSB7XG4gICAgICAgIHZhciB4ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgICAgIC5kb21haW4oW21pblggLSAwLjUsIG1heFggKyAxLjVdKVxuICAgICAgICAgICAgLnJhbmdlKFswLCB3aWR0aF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB4ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgICAgIC5kb21haW4oW21pblggLSAwLjUsIG1heFggKyAwLjVdKVxuICAgICAgICAgICAgLnJhbmdlKFswLCB3aWR0aF0pO1xuICAgIH1cblxuICAgIHZhciBpbnZ4ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLnJhbmdlKFttaW5YIC0gMC41LCBtYXhYICsgMC41XSlcbiAgICAgICAgLmRvbWFpbihbMCwgd2lkdGhdKTtcblxuICAgIHZhciB5ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLmRvbWFpbihbMCwgbWF4WV0pXG4gICAgICAgIC5yYW5nZShbMCwgaGVpZ2h0XSk7XG5cbiAgICB2YXIgeEF4aXMgPSBkMy5zdmcuYXhpcygpXG4gICAgICAgIC5zY2FsZSh4KVxuICAgICAgICAudGlja3MoeVZhbHMubGVuZ3RoKVxuICAgICAgICAub3JpZW50KFwiYm90dG9tXCIpO1xuXG4gICAgdmFyIHlBeGlzID0gZDMuc3ZnLmF4aXMoKVxuICAgICAgICAuc2NhbGUoeSlcbiAgICAgICAgLm9yaWVudChcImxlZnRcIik7XG5cbiAgICB2YXIgYnJ1c2ggPSBkMy5zdmcuYnJ1c2goKVxuICAgICAgICAueCh4KVxuICAgICAgICAuZXh0ZW50KCgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBub2RlLnN1YnNldHJhbmdlLmxlbmd0aCA9PSAxID9cbiAgICAgICAgICAgICAgICBbbm9kZS5zdWJzZXRyYW5nZVswXSwgbm9kZS5zdWJzZXRyYW5nZVswXV1cbiAgICAgICAgICAgICAgICA6IG5vZGUuc3Vic2V0cmFuZ2U7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbihcImJydXNoXCIsIGJydXNoZWQpO1xuXG4gICAgdmFyIGJydXNoMiA9IGQzLnN2Zy5icnVzaCgpXG4gICAgICAgIC54KHgpXG4gICAgICAgIC5vbihcImJydXNoXCIsIGJydXNoZWQyKTtcblxuICAgIC8vIENyZWF0ZSBTVkcgZWxlbWVudFxuICAgIC8vIGN1bWJlcnNvbWUgdG8gdHJlYXQgXCJ0YWJTdW1tYXJ5XCIgZGlmZmVyZW50bHksIGJ1dCB3b3JrcyBmb3Igbm93XG4gICAgLy8gdGFiU3VtbWFyeSwgaGFzIGFuIGlzc3VlLCB0aGF0IHVubGVzcyB3aWR0aCBoZWlnaHQgaGFyZGNvZGVkLCB0aGV5IGdyb3cgd2l0aCBlYWNoIGFkZGl0aW9uYWwgZ3JhcGguXG4gICAgaWYgKG15ZGl2ID09IFwiI3RhYlN1bW1hcnlcIikge1xuICAgICAgICB2YXIgcGxvdHN2ZyA9IGQzLnNlbGVjdChteWRpdilcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoXCJzdmdcIilcbiAgICAgICAgICAgIC5yZW1vdmUoKTtcblxuICAgICAgICB2YXIgcGxvdHN2ZyA9IGQzLnNlbGVjdChteWRpdilcbiAgICAgICAgICAgIC5hcHBlbmQoXCJzdmdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgKCkgPT4gbm9kZS5uYW1lLnRvU3RyaW5nKCkuY29uY2F0KG15ZGl2LnN1YnN0cigxKSkpXG4gICAgICAgICAgICAuc3R5bGUoXCJ3aWR0aFwiLCAzMDApIC8vc2V0dGluZyBoZWlnaHQgdG8gdGhlIGhlaWdodCBvZiAjbWFpbi5sZWZ0XG4gICAgICAgICAgICAuc3R5bGUoXCJoZWlnaHRcIiwgMjAwKVxuICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgbWFyZ2luLmxlZnQgKyBcIixcIiArIG1hcmdpbi50b3AgKyBcIilcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHBsb3RzdmcgPSBkMy5zZWxlY3QobXlkaXYpXG4gICAgICAgICAgICAuYXBwZW5kKFwic3ZnXCIpXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBteW5hbWUgPSBub2RlLm5hbWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBteW5hbWUgPSBteW5hbWUucmVwbGFjZSgvXFwofFxcKS9nLCBcIlwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbXluYW1lLmNvbmNhdChcIl9cIiwgbXlkaXYuc3Vic3RyKDEpLCBcIl9cIiwgbm9kZS5pZCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnN0eWxlKFwid2lkdGhcIiwgd2lkdGggKyBtYXJnaW4ubGVmdCArIG1hcmdpbi5yaWdodCkgLy9zZXR0aW5nIGhlaWdodCB0byB0aGUgaGVpZ2h0IG9mICNtYWluLmxlZnRcbiAgICAgICAgICAgIC5zdHlsZShcImhlaWdodFwiLCBoZWlnaHQgKyBtYXJnaW4udG9wICsgbWFyZ2luLmJvdHRvbSlcbiAgICAgICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIG1hcmdpbi5sZWZ0ICsgXCIsXCIgKyBtYXJnaW4udG9wICsgXCIpXCIpO1xuICAgIH07XG5cbiAgICB2YXIgcmVjdFdpZHRoID0geChtaW5YICsgMC41IC0gMiAqIGJhclBhZGRpbmcpOyAvL3RoZSBcIndpZHRoXCIgaXMgdGhlIGNvb3JkaW5hdGUgb2YgdGhlIGVuZCBvZiB0aGUgZmlyc3QgYmFyXG5cbiAgICBwbG90c3ZnLnNlbGVjdEFsbChcInJlY3RcIilcbiAgICAgICAgLmRhdGEoeVZhbHMpXG4gICAgICAgIC5lbnRlcigpXG4gICAgICAgIC5hcHBlbmQoXCJyZWN0XCIpXG4gICAgICAgIC5hdHRyKFwieFwiLCAoZCwgaSkgPT4geCh4VmFsc1tpXSAtIDAuNSArIGJhclBhZGRpbmcpKVxuICAgICAgICAuYXR0cihcInlcIiwgZCA9PiB5KG1heFkgLSBkKSlcbiAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCByZWN0V2lkdGgpXG4gICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIHkpXG4gICAgICAgIC5hdHRyKFwiZmlsbFwiLCBcIiMxZjc3YjRcIik7XG5cbiAgICAvLyBkcmF3IGVycm9yIGJhcnMsIHRocmVzaG9sZCBsaW5lIGFuZCBleHRyYSBiaW5cbiAgICBpZiAocHJpdikge1xuICAgICAgICBpZiAoeVZhbHMubGVuZ3RoIDw9IDIwKSB7XG4gICAgICAgICAgICBwbG90c3ZnLnNlbGVjdEFsbChcImxpbmVcIilcbiAgICAgICAgICAgICAgICAuZGF0YShjaVVwcGVyVmFscylcbiAgICAgICAgICAgICAgICAuZW50ZXIoKVxuICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJsaW5lXCIpXG4gICAgICAgICAgICAgICAgLnN0eWxlKFwic3Ryb2tlXCIsIFwiYmxhY2tcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcIngxXCIsIGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHgoeFZhbHNbaV0gLSAwLjUgKyBiYXJQYWRkaW5nKSArIHJlY3RXaWR0aCAvIDJcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICBcdC5hdHRyKFwieTFcIiwgZCA9PiB5KG1heFkgLSBkKSlcbiAgICAgICAgICAgICAgICAuYXR0cihcIngyXCIsIGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHgoeFZhbHNbaV0gLSAwLjUgKyBiYXJQYWRkaW5nKSArIHJlY3RXaWR0aCAvIDJcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieTJcIiwgZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB5MiA9IHkobWF4WSAtIGQgKyBjaVNpemUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geTIgPj0geShtYXhZKSA/IHkobWF4WSkgOiB5MjtcbiAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vZHJhdyB0b3AgdGlja3Mgb24gZXJyb3IgYmFyc1xuICAgICAgICAgICAgLy9uZWVkIHRvIGZpeCB0aGUgaGVpZ2h0IG9mIHRoZSBncmFwaHMgLSB0aGUgdG9wcyBvZiBlcnJvciBiYXJzIGFyZSBnZXR0aW5nIGN1dCBvZmZcbiAgICAgICAgICAgIHBsb3Rzdmcuc2VsZWN0QWxsKFwiLnRvcFRpY2tcIilcbiAgICAgICAgICAgICAgICAuZGF0YShjaVVwcGVyVmFscylcbiAgICAgICAgICAgICAgICAuZW50ZXIoKVxuICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJsaW5lXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInRvcFRpY2tcIilcbiAgICAgICAgICAgICAgICAuc3R5bGUoXCJzdHJva2VcIiwgXCJibGFja1wiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieDFcIiwgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoeVZhbHMubGVuZ3RoID4gMjApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB4KHhWYWxzW2ldIC0gMC41ICsgYmFyUGFkZGluZykgLy9tYWtlIHRpY2sgYmlnZ2VyIHRvIGluY3JlYXNlIHZpc2liaWxpdHlcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB4KHhWYWxzW2ldIC0gMC41ICsgYmFyUGFkZGluZykgKyAwLjQgKiByZWN0V2lkdGhcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ5MVwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB5KG1heFkgLSBkKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieDJcIiwgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoeVZhbHMubGVuZ3RoID4gMjApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB4KHhWYWxzW2ldIC0gMC41ICsgYmFyUGFkZGluZykgKyByZWN0V2lkdGggLy9tYWtlIHRpY2sgYmlnZ2VyIHRvIGluY3JlYXNlIHZpc2liaWxpdHlcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB4KHhWYWxzW2ldIC0gMC41ICsgYmFyUGFkZGluZykgKyAwLjYgKiByZWN0V2lkdGhcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ5MlwiLCBkID0+IHkobWF4WSAtIGQpKTtcblxuICAgICAgICAgICAgLy8gZHJhdyBib3R0b20gdGlja3Mgb2YgZXJyb3IgYmFyc1xuICAgICAgICAgICAgcGxvdHN2Zy5zZWxlY3RBbGwoXCIuYm90dG9tVGlja1wiKVxuICAgICAgICAgICAgICAgIC5kYXRhKGNpTG93ZXJWYWxzKVxuICAgICAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAgICAgLmFwcGVuZChcImxpbmVcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiYm90dG9tVGlja1wiKVxuICAgICAgICAgICAgICAgIC5zdHlsZShcInN0cm9rZVwiLCBcImJsYWNrXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ4MVwiLCBmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh5VmFscy5sZW5ndGggPiAyMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHgoeFZhbHNbaV0gLSAwLjUgKyBiYXJQYWRkaW5nKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHgoeFZhbHNbaV0gLSAwLjUgKyBiYXJQYWRkaW5nKSArIDAuNCAqIHJlY3RXaWR0aFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInkxXCIsIGQgPT4geShtYXhZIC0gZCkpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ4MlwiLCBmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh5VmFscy5sZW5ndGggPiAyMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHgoeFZhbHNbaV0gLSAwLjUgKyBiYXJQYWRkaW5nKSArIHJlY3RXaWR0aFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHgoeFZhbHNbaV0gLSAwLjUgKyBiYXJQYWRkaW5nKSArIDAuNiAqIHJlY3RXaWR0aFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInkyXCIsIGQgPT4geShtYXhZIC0gZCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGxvdHN2Zy5zZWxlY3RBbGwoXCIuZGVuc2VFcnJvclwiKVxuICAgICAgICAgICAgICAgIC5kYXRhKHlWYWxzKVxuICAgICAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAgICAgLmFwcGVuZChcInJlY3RcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiZGVuc2VFcnJvclwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieFwiLCAoZCwgaSkgPT4geCh4VmFsc1tpXSAtIDAuNSArIGJhclBhZGRpbmcpKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieVwiLCBkID0+IHkobWF4WSAtIGQpIC0gLjEgKiB5KGQpKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgcmVjdFdpZHRoKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGQgPT4gKHkobWF4WSAtIGQpICsgLjEgKiB5KGQpKSAtICh5KG1heFkgLSBkKSAtIC4xICogeShkKSkpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJmaWxsXCIsIFwic2lsdmVyXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9pZiBzdGF0ZW1lbnQgZm9yIHN0YWJpbGl0eSBoaXN0b2dyYW1zXG4gICAgICAgIC8vZXh0cmEgc3RhYmlsaXR5IGJpblxuICAgICAgICBpZiAobm9kZS5zdGFiaWxpdHlCaW4pIHtcbiAgICAgICAgICAgIHBsb3RzdmcuYXBwZW5kKFwicmVjdFwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieFwiLCB4KG1heFggKyAwLjUgLSBiYXJQYWRkaW5nKSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInlcIiwgeShtYXhZKSAtIG5vZGUuc3RhYmlsaXR5QmluKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgcmVjdFdpZHRoKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIG5vZGUuc3RhYmlsaXR5QmluKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiZmlsbFwiLCBcInNpbHZlclwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vdGhyZXNob2xkIGxpbmVcbiAgICAgICAgaWYgKG5vZGUudGhyZXNob2xkKSB7XG4gICAgICAgICAgICBwbG90c3ZnLmFwcGVuZChcImxpbmVcIilcbiAgICAgICAgICAgICAgICAuc3R5bGUoXCJzdHJva2VcIiwgXCJibGFja1wiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieDFcIiwgeChtaW5YIC0gMC41ICsgYmFyUGFkZGluZykpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ5MVwiLCB5KG1heFkpIC0gbm9kZS50aHJlc2hvbGQpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ4MlwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJzdGFiaWxpdHlCaW5cIik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKG5vZGUuc3RhYmlsaXR5QmluKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuc3RhYmlsaXR5QmluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geChtYXhYICsgMC41IC0gYmFyUGFkZGluZykgKyByZWN0V2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geChtYXhYICsgMC41IC0gYmFyUGFkZGluZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieTJcIiwgeShtYXhZKSAtIG5vZGUudGhyZXNob2xkKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBsb3RYYXhpcykge1xuICAgICAgICBwbG90c3ZnLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJ4IGF4aXNcIilcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsXCIgKyBoZWlnaHQgKyBcIilcIilcbiAgICAgICAgICAgIC5jYWxsKHhBeGlzKTtcbiAgICB9XG5cbiAgICBwbG90c3ZnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgLmF0dHIoXCJ4XCIsICh3aWR0aCAvIDIpKVxuICAgICAgICAuYXR0cihcInlcIiwgMCAtIChtYXJnaW4udG9wIC8gMikpXG4gICAgICAgIC5hdHRyKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIilcbiAgICAgICAgLnN0eWxlKFwiZm9udC1zaXplXCIsIFwiMTJweFwiKVxuICAgICAgICAudGV4dChub2RlLm5hbWUpO1xuXG4gICAgaWYgKG15ZGl2ID09IFwiI3NldHhMZWZ0XCIgfHwgbXlkaXY9PVwiI3NldHhMZWZ0VG9wUmlnaHRcIikge1xuICAgICAgICBwbG90c3ZnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgXCJyYW5nZVwiKSAvLyBiYWQgcHJhY3RpY2UsIG5vdCB1bmlxdWVcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsJ3h2YWwnKVxuICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIDI1KVxuICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIGhlaWdodCArIDQwKVxuICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubmF0dXJlID09PSBcIm5vbWluYWxcIikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IE1hdGgucm91bmQoeVZhbEtleS5sZW5ndGggLyAyKSAtIDE7XG4gICAgICAgICAgICAgICAgICAgIGxldCBteWNlbGwgPSBub2RlLm5hbWUrXCJGcm9tXCI7IC8vIGhhcmRjb2RlZCBoZXJlXG4gICAgICAgICAgICAgICAgICAgIGlmKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG15Y2VsbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG15Y2VsbCkuaW5uZXJUZXh0PXlWYWxLZXlbdF0ueDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFwieDogXCIgKyB5VmFsS2V5W3RdLngpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBteWNlbGwgPSBub2RlLm5hbWUrXCJGcm9tXCI7IC8vIGhhcmRjb2RlZCBoZXJlXG4gICAgICAgICAgICAgICAgICAgIGlmKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG15Y2VsbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG15Y2VsbCkuaW5uZXJUZXh0PSgrbm9kZS5tZWFuKS50b1ByZWNpc2lvbig0KS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoXCJ4OiBcIi5jb25jYXQoKCtub2RlLm1lYW4pLnRvUHJlY2lzaW9uKDQpLnRvU3RyaW5nKCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBwbG90c3ZnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgXCJyYW5nZTJcIikgLy9iYWQgcHJhY3RpY2UsIG5vdCB1bmlxdWVcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsJ3gxdmFsJylcbiAgICAgICAgICAgIC5hdHRyKFwieFwiLCAyNSlcbiAgICAgICAgICAgIC5hdHRyKFwieVwiLCBoZWlnaHQgKyA1MClcbiAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLm5hdHVyZSA9PT0gXCJub21pbmFsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBNYXRoLnJvdW5kKHlWYWxLZXkubGVuZ3RoIC8gMikgLSAxO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFwieDE6IFwiICsgeVZhbEtleVt0XS54KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFwieDE6IFwiLmNvbmNhdCgoK25vZGUubWVhbikudG9QcmVjaXNpb24oNCkudG9TdHJpbmcoKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGNyZWF0ZSB0aWNrIG1hcmtzIGF0IGFsbCB6c2NvcmVzIGluIHRoZSBib3VuZHMgb2YgdGhlIGRhdGFcbiAgICAgICAgdmFyIGxpbmVGdW5jdGlvbiA9IGQzLnN2Zy5saW5lKClcbiAgICAgICAgICAgIC54KGQgPT4gZC54KVxuICAgICAgICAgICAgLnkoZCA9PiBkLnkpXG4gICAgICAgICAgICAuaW50ZXJwb2xhdGUoXCJsaW5lYXJcIik7XG5cbiAgICAgICAgdmFyIGNvbFNlcSA9IFtcIiNBMkNENUFcIiwgXCJvcmFuZ2VcIiwgXCJyZWRcIl07IC8vIHdpbGwgY3ljbGUgdGhyb3VnaCBjb2xvciBzZXF1ZW5jZSwgYW5kIHRoZW4gcmVwZWF0IGxhc3QgY29sb3JcbiAgICAgICAgdmFyIGxpbmVEYXRhID0gbmV3IEFycmF5O1xuXG4gICAgICAgIHZhciB6TG93ZXIgPSAtMSAqIChtaW5YIC0gbm9kZS5tZWFuKSAvIG5vZGUuc2Q7IC8vIHpzY29yZSBvZiBsb3dlciBib3VuZFxuICAgICAgICB2YXIgelVwcGVyID0gKG1heFggLSBub2RlLm1lYW4pIC8gbm9kZS5zZDsgLy8genNjb3JlIG9mIHVwcGVyIGJvdW5kXG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB6VXBwZXI7IGkrKykge1xuICAgICAgICAgICAgbGluZURhdGEgPSBbe1xuICAgICAgICAgICAgICAgIFwieFwiOiB4KCtub2RlLm1lYW4gKyBpICogbm9kZS5zZCksXG4gICAgICAgICAgICAgICAgXCJ5XCI6IGhlaWdodCAqIC43XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgXCJ4XCI6IHgoK25vZGUubWVhbiArIGkgKiBub2RlLnNkKSxcbiAgICAgICAgICAgICAgICBcInlcIjogaGVpZ2h0ICogLjlcbiAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgcGxvdHN2Zy5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJkXCIsIGxpbmVGdW5jdGlvbihbbGluZURhdGFbMF0sIGxpbmVEYXRhWzFdXSkpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJzdHJva2VcIiwgY29sU2VxW2QzLm1pbihbaSwgY29sU2VxLmxlbmd0aCAtIDFdKV0pXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJzdHJva2Utd2lkdGhcIiwgMS41KVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiZmlsbFwiLCBcIm5vbmVcIik7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHpMb3dlcjsgaSsrKSB7XG4gICAgICAgICAgICBsaW5lRGF0YSA9IFt7XG4gICAgICAgICAgICAgICAgXCJ4XCI6IHgoK25vZGUubWVhbiAtIGkgKiBub2RlLnNkKSxcbiAgICAgICAgICAgICAgICBcInlcIjogaGVpZ2h0ICogLjdcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBcInhcIjogeCgrbm9kZS5tZWFuIC0gaSAqIG5vZGUuc2QpLFxuICAgICAgICAgICAgICAgIFwieVwiOiBoZWlnaHQgKiAuOVxuICAgICAgICAgICAgfV07XG4gICAgICAgICAgICBwbG90c3ZnLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImRcIiwgbGluZUZ1bmN0aW9uKFtsaW5lRGF0YVswXSwgbGluZURhdGFbMV1dKSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInN0cm9rZVwiLCBjb2xTZXFbZDMubWluKFtpLCBjb2xTZXEubGVuZ3RoIC0gMV0pXSlcbiAgICAgICAgICAgICAgICAuYXR0cihcInN0cm9rZS13aWR0aFwiLCAxLjUpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJmaWxsXCIsIFwibm9uZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSBkMy5taW4oeFZhbHMpOyBpIDw9IGQzLm1heCh4VmFscyk7IGkrKykge1xuICAgICAgICAgICAgbGluZURhdGEgPSBbe1xuICAgICAgICAgICAgICAgIFwieFwiOiB4KGkpLFxuICAgICAgICAgICAgICAgIFwieVwiOiBoZWlnaHQgKiAuNzVcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBcInhcIjogeChpKSxcbiAgICAgICAgICAgICAgICBcInlcIjogaGVpZ2h0ICogLjg1XG4gICAgICAgICAgICB9XTtcbiAgICAgICAgICAgIHBsb3RzdmcuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiZFwiLCBsaW5lRnVuY3Rpb24oW2xpbmVEYXRhWzBdLCBsaW5lRGF0YVsxXV0pKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwic3Ryb2tlXCIsIFwiYmxhY2tcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcInN0cm9rZS13aWR0aFwiLCAxKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiZmlsbFwiLCBcIm5vbmVcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpbml0aWFsaXplIHNsaWRlciBjb21wb25lbnRzXG4gICAgICAgIHZhciBzbGlkZUJveCA9IHBsb3RzdmcuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInggYXhpc1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCxcIiArIGhlaWdodCAqIC44ICsgXCIpXCIpXG4gICAgICAgICAgICAuY2FsbChkMy5zdmcuYXhpcygpXG4gICAgICAgICAgICAgICAgICAuc2NhbGUoeClcbiAgICAgICAgICAgICAgICAgIC50aWNrcygwKVxuICAgICAgICAgICAgICAgICAgLm9yaWVudChcImJvdHRvbVwiKSk7XG5cbiAgICAgICAgdmFyIHNsaWRlciA9IHBsb3RzdmcuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInNsaWRlclwiKVxuICAgICAgICAgICAgLmNhbGwoYnJ1c2gpO1xuICAgICAgICB2YXIgc2xpZGVyMiA9IHBsb3RzdmcuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInNsaWRlclwiKVxuICAgICAgICAgICAgLmNhbGwoYnJ1c2gyKTtcblxuICAgICAgICBsZXQgcG9pbnRzID0gaSA9PiBkID0+IHtcbiAgICAgICAgICAgIGxldCB4bm0sIHMgPSA2O1xuICAgICAgICAgICAgaWYgKG5vZGUuc2V0eHZhbHNbaV0gPT0gJycpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBub21pbmFsLCB1c2UgdGhlIG1lZGlhbiBmcmVxdWVuY3kgYXMgdGhlIHBvc2l0aW9uIGZvciB0aGUgc2V0eCBzbGlkZXJcbiAgICAgICAgICAgICAgICB4bm0gPSBub2RlLm5hdHVyZSA9PSAnbm9taW5hbCcgPyB4KE1hdGgucm91bmQoeFZhbHMubGVuZ3RoIC8gMikgLSAxKSA6IHgobm9kZS5tZWFuKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgeG5tID0geChub2RlLnNldHh2YWxzW2ldKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gYCR7eG5tIC0gc30sJHstc30gJHt4bm0gKyBzfSwkey1zfSAke3hubX0sJHtzICogMS4zfWA7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBoYW5kbGUgPSBzbGlkZXIuYXBwZW5kKFwicG9seWdvblwiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImhhbmRsZVwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCxcIiArIGhlaWdodCAqIC43ICsgXCIpXCIpXG4gICAgICAgICAgICAuYXR0cihcInBvaW50c1wiLCBwb2ludHMoMCkpO1xuICAgICAgICB2YXIgaGFuZGxlMiA9IHNsaWRlcjIuYXBwZW5kKFwicG9seWdvblwiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImhhbmRsZVwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCxcIiArIGhlaWdodCAqIC45ICsgXCIpXCIpXG4gICAgICAgICAgICAuYXR0cihcInBvaW50c1wiLCBwb2ludHMoMSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHR3b1NGKHgpIHtcbiAgICAgICAgdmFyIHRzZiA9IGQzLmZvcm1hdChcIi4yclwiKTsgLy8gZm9ybWF0IHRvIHR3byBzaWduaWZpY2FudCBmaWd1cmVzIGFmdGVyIHRoZSBkZWNpbWFsIHBsYWNlXG4gICAgICAgIHJldHVybiB0c2YoeCkucmVwbGFjZSgvMCskLywgXCJcIikucmVwbGFjZSgvXFwuJC8sIFwiXCIpOyAvLyB0cmltIHRyYWlsaW5nIHplcm9zIGFmdGVyIGEgcGVyaW9kLCBhbmQgYW55IG9ycGhhbmVkIHBlcmlvZFxuICAgIH1cblxuICAgIC8vIGJydXNoaW5nIGZ1bmN0aW9uc1xuICAgIGZ1bmN0aW9uIGJydXNoZWQoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGJydXNoLmV4dGVudCgpWzBdO1xuICAgICAgICB2YXIgcyA9IDY7XG5cbiAgICAgICAgaWYgKGQzLmV2ZW50LnNvdXJjZUV2ZW50KSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHguaW52ZXJ0KGQzLm1vdXNlKHRoaXMpWzBdKTtcbiAgICAgICAgICAgIGJydXNoLmV4dGVudChbdmFsdWUsIHZhbHVlXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgeCBwb3NpdGlvbiBvZiBzbGlkZXIgY2VudGVyXG4gICAgICAgIHZhciB4cG9zID0geCh2YWx1ZSk7XG4gICAgICAgIGlmICh2YWx1ZSA+IG1heFgpIHsgLy8gZHJhZ2dlZCBwYXN0IG1heFxuICAgICAgICAgICAgeHBvcyA9IHgobWF4WCk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPCBtaW5YKSB7IC8vIGRyYWdnZWQgcGFzdCBtaW5cbiAgICAgICAgICAgIHhwb3MgPSB4KG1pblgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG0gPSArbm9kZS5tZWFuO1xuICAgICAgICAgICAgdmFyIHNkID0gK25vZGUuc2Q7XG4gICAgICAgICAgICB2YXIgelNjb3JlID0gKHZhbHVlIC0gbSkgLyBzZDsgLy8gei1zY29yZVxuICAgICAgICAgICAgdmFyIHpSb3VuZCA9IE1hdGgucm91bmQoelNjb3JlKTsgLy8gbmVhcmVzdCBpbnRlZ2VyIHotc2NvcmVcbiAgICAgICAgICAgIGlmICguMSA+IE1hdGguYWJzKE1hdGgucm91bmQodmFsdWUpIC0gdmFsdWUpKSB7IC8vIHNuYXAgdG8gaW50ZWdlclxuICAgICAgICAgICAgICAgIHhwb3MgPSB4KE1hdGgucm91bmQodmFsdWUpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoLjEgPiBNYXRoLmFicyh6Um91bmQgLSB6U2NvcmUpKSB7IC8vIHNuYXAgdG8gaW50ZWdlciB6LXNjb3JlXG4gICAgICAgICAgICAgICAgeHBvcyA9IHgobSArICh6Um91bmQgKiBzZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JlYXRlIHNsaWRlciBzeW1ib2wgYW5kIHRleHRcbiAgICAgICAgaGFuZGxlLmF0dHIoXCJwb2ludHNcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgcmV0dXJuICh4cG9zIC0gcykgKyBcIixcIiArICgtcykgKyBcIiBcIiArICh4cG9zICsgcykgKyBcIixcIiArICgtcykgKyBcIiBcIiArIHhwb3MgKyBcIixcIiArIChzICogMS4zKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHBsb3Rzdmcuc2VsZWN0KFwidGV4dCNyYW5nZVwiKVxuICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubmF0dXJlID09PSBcIm5vbWluYWxcIikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbXljZWxsID0gbm9kZS5uYW1lK1wiRnJvbVwiOyAvLyBoYXJkY29kZWQgaGVyZVxuICAgICAgICAgICAgICAgICAgICBpZihkb2N1bWVudC5nZXRFbGVtZW50QnlJZChteWNlbGwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChteWNlbGwpLmlubmVyVGV4dD15VmFsS2V5W01hdGgucm91bmQoaW52eCh4cG9zKSldLng7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcIng6IFwiICsgeVZhbEtleVtNYXRoLnJvdW5kKGludngoeHBvcykpXS54KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbXljZWxsID0gbm9kZS5uYW1lK1wiRnJvbVwiOyAvLyBoYXJkY29kZWQgaGVyZVxuICAgICAgICAgICAgICAgICAgICBpZihkb2N1bWVudC5nZXRFbGVtZW50QnlJZChteWNlbGwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChteWNlbGwpLmlubmVyVGV4dD0rKGludngoeHBvcykpLnRvUHJlY2lzaW9uKDQpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcIng6IFwiLmNvbmNhdCgrKGludngoeHBvcykpLnRvUHJlY2lzaW9uKDQpLnRvU3RyaW5nKCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgbm9kZS5zZXR4dmFsc1swXSA9ICsoaW52eCh4cG9zKSkudG9QcmVjaXNpb24oNCk7XG4gICAgfVxuXG4gICAgLy8gY2VydGFpbmx5IGEgbW9yZSBjbGV2ZXIgd2F5IHRvIGRvIHRoaXMsIGJ1dCBmb3Igbm93IGl0J3MgYmFzaWNhbGx5IGNvcGllZCB3aXRoIGJydXNoIGFuZCBoYW5kbGUgY2hhbmdlcyB0byBicnVzaDIgYW5kIGhhbmRsZTIgYW5kICNyYW5nZSB0byAjcmFuZ2UyIGFuZCBzZXR4dmFsc1swXSB0byBzZXR4dmFsc1sxXVxuICAgIGZ1bmN0aW9uIGJydXNoZWQyKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBicnVzaDIuZXh0ZW50KClbMF07XG4gICAgICAgIHZhciBzID0gNjsgLy8gc2NhbGluZyBmb3IgdHJpYW5nbGUgc2hhcGVcblxuICAgICAgICBpZiAoZDMuZXZlbnQuc291cmNlRXZlbnQpIHtcbiAgICAgICAgICAgIHZhbHVlID0geC5pbnZlcnQoZDMubW91c2UodGhpcylbMF0pO1xuICAgICAgICAgICAgYnJ1c2gyLmV4dGVudChbdmFsdWUsIHZhbHVlXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgeCBwb3NpdGlvbiBvZiBzbGlkZXIgY2VudGVyXG4gICAgICAgIHZhciB4cG9zID0geCh2YWx1ZSk7XG4gICAgICAgIGlmICh2YWx1ZSA+IG1heFgpIHsgLy8gZHJhZ2dlZCBwYXN0IG1heFxuICAgICAgICAgICAgeHBvcyA9IHgobWF4WCk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPCBtaW5YKSB7IC8vIGRyYWdnZWQgcGFzdCBtaW5cbiAgICAgICAgICAgIHhwb3MgPSB4KG1pblgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG0gPSArbm9kZS5tZWFuO1xuICAgICAgICAgICAgdmFyIHNkID0gK25vZGUuc2Q7XG4gICAgICAgICAgICB2YXIgelNjb3JlID0gKHZhbHVlIC0gbSkgLyBzZDsgLy8gei1zY29yZVxuICAgICAgICAgICAgdmFyIHpSb3VuZCA9IE1hdGgucm91bmQoelNjb3JlKTsgLy8gbmVhcmVzdCBpbnRlZ2VyIHotc2NvcmVcbiAgICAgICAgICAgIGlmICguMSA+IE1hdGguYWJzKE1hdGgucm91bmQodmFsdWUpIC0gdmFsdWUpKSB7IC8vIHNuYXAgdG8gaW50ZWdlclxuICAgICAgICAgICAgICAgIHhwb3MgPSB4KE1hdGgucm91bmQodmFsdWUpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoLjEgPiBNYXRoLmFicyh6Um91bmQgLSB6U2NvcmUpKSB7IC8vIHNuYXAgdG8gaW50ZWdlciB6LXNjb3JlXG4gICAgICAgICAgICAgICAgeHBvcyA9IHgobSArICh6Um91bmQgKiBzZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JlYXRlIHNsaWRlciBzeW1ib2wgYW5kIHRleHRcbiAgICAgICAgaGFuZGxlMi5hdHRyKFwicG9pbnRzXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHJldHVybiAoeHBvcyAtIHMpICsgXCIsXCIgKyBzICsgXCIgXCIgKyAoeHBvcyArIHMpICsgXCIsXCIgKyBzICsgXCIgXCIgKyB4cG9zICsgXCIsXCIgKyAoLXMgKiAxLjMpO1xuICAgICAgICB9KTtcbiAgICAgICAgcGxvdHN2Zy5zZWxlY3QoXCJ0ZXh0I3JhbmdlMlwiKVxuICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubmF0dXJlID09PSBcIm5vbWluYWxcIikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbXljZWxsID0gbm9kZS5uYW1lK1wiVG9cIjsgLy8gaGFyZGNvZGVkIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgaWYoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobXljZWxsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobXljZWxsKS5pbm5lclRleHQ9eVZhbEtleVtNYXRoLnJvdW5kKGludngoeHBvcykpXS54O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoXCJ4MTogXCIgKyB5VmFsS2V5W01hdGgucm91bmQoaW52eCh4cG9zKSldLngpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBteWNlbGwgPSBub2RlLm5hbWUrXCJUb1wiOyAvLyBoYXJkY29kZWQgaGVyZVxuICAgICAgICAgICAgICAgICAgICBpZihkb2N1bWVudC5nZXRFbGVtZW50QnlJZChteWNlbGwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChteWNlbGwpLmlubmVyVGV4dD0rKGludngoeHBvcykpLnRvUHJlY2lzaW9uKDQpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcIngxOiBcIi5jb25jYXQoKyhpbnZ4KHhwb3MpKS50b1ByZWNpc2lvbig0KS50b1N0cmluZygpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIG5vZGUuc2V0eHZhbHNbMV0gPSArKGludngoeHBvcykpLnRvUHJlY2lzaW9uKDQpO1xuICAgIH1cbn1cblxuLy8gZHJhd3MgYmFycGxvdHMgaW4gc3Vic2V0IHRhYlxuZXhwb3J0IGZ1bmN0aW9uIGJhcnNTdWJzZXQobm9kZSkge1xuICAgIC8vIGlmIHVudG91Y2hlZCwgc2V0IG5vZGUuc3Vic2V0cmFuZ2UgdG8gYW4gZW1wdHkgYXJyYXksIG1lYW5pbmcgYWxsIHZhbHVlcyBzZWxlY3RlZCBieSBkZWZhdWx0XG4gICAgaWYgKG5vZGUuc3Vic2V0cmFuZ2VbMF0gPT0gXCJcIiAmIG5vZGUuc3Vic2V0cmFuZ2VbMV0gPT0gXCJcIikge1xuICAgICAgICBub2RlLnN1YnNldHJhbmdlID0gW107XG4gICAgfVxuXG4gICAgLy8gSGlzdG9ncmFtIHNwYWNpbmdcbiAgICB2YXIgYmFyUGFkZGluZyA9IC4wMTU7IC8vIFNwYWNlIGJldHdlZW4gYmFyc1xuICAgIHZhciB0b3BTY2FsZSA9IDEuMjsgLy8gTXVsdGlwbGljYXRpdmUgZmFjdG9yIHRvIGFzc2lnbiBzcGFjZSBhdCB0b3Agd2l0aGluIGdyYXBoIC0gY3VycmVudGx5IHJlbW92ZWQgZnJvbSBpbXBsZW1lbnRhdGlvblxuICAgIHZhciBwbG90WGF4aXMgPSB0cnVlO1xuXG4gICAgLy8gVmFyaWFibGUgbmFtZVxuICAgIHZhciBteW5hbWUgPSBub2RlLm5hbWUudG9TdHJpbmcoKTtcbiAgICBteW5hbWUgPSBteW5hbWUucmVwbGFjZSgvXFwofFxcKS9nLCBcIlwiKTtcblxuICAgIC8vIERhdGFcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG5vZGUucGxvdHZhbHVlcyk7XG4gICAgdmFyIHlWYWxzID0gbmV3IEFycmF5O1xuICAgIHZhciB4VmFscyA9IG5ldyBBcnJheTtcbiAgICB2YXIgeVZhbEtleSA9IG5ldyBBcnJheTtcblxuICAgIHZhciB4aSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChub2RlLnBsb3R2YWx1ZXNba2V5c1tpXV0gPT0gMClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB5VmFsc1t4aV0gPSBub2RlLnBsb3R2YWx1ZXNba2V5c1tpXV07XG4gICAgICAgIHhWYWxzW3hpXSA9IHhpO1xuICAgICAgICB5VmFsS2V5LnB1c2goe1xuICAgICAgICAgICAgeTogeVZhbHNbeGldLFxuICAgICAgICAgICAgeDoga2V5c1tpXVxuICAgICAgICB9KTtcbiAgICAgICAgeGkgPSB4aSArIDE7XG4gICAgfVxuICAgIGlmIChub2RlLm5hdHVyZSA9PT0gXCJub21pbmFsXCIpIHsgLy8gaWYgbm9taW5hbCwgb3JkZXJzIGJhcnMgbGVmdCB0byByaWdodCwgaGlnaGVzdCBmcmVxdWVuY3kgdG8gbG93ZXN0XG4gICAgICAgIHlWYWxLZXkuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYi55IC0gYS55XG4gICAgICAgIH0pOyAvLyBhcnJheSBvZiBvYmplY3RzLCBlYWNoIG9iamVjdCBoYXMgeSwgdGhlIHNhbWUgYXMgeVZhbHMsIGFuZCB4LCB0aGUgY2F0ZWdvcnlcbiAgICAgICAgeVZhbHMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYiAtIGFcbiAgICAgICAgfSk7IC8vIGFycmF5IG9mIHkgdmFsdWVzLCB0aGUgaGVpZ2h0IG9mIHRoZSBiYXJzXG4gICAgfVxuXG4gICAgcGxvdFhheGlzID0gZmFsc2U7XG5cbiAgICB2YXIgbWF4WSA9IGQzLm1heCh5VmFscyk7XG4gICAgdmFyIG1pblggPSBkMy5taW4oeFZhbHMpO1xuICAgIHZhciBtYXhYID0gZDMubWF4KHhWYWxzKTtcbiAgICB2YXIgZ25hbWUgPSBbXCJzdWJzZXR5ZXNcIiwgXCJzdWJzZXRub1wiXTtcblxuICAgIHZhciB5VmFsczIgPSBbXTtcbiAgICB2YXIgeVZhbHMxID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IHlWYWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHlWYWxzMS5wdXNoKHtcbiAgICAgICAgICAgIHkwOiBtYXhZIC0geVZhbHNbaV0sXG4gICAgICAgICAgICB5MTogeVZhbHNbaV0sXG4gICAgICAgICAgICBjb2w6IGQzQ29sb3JcbiAgICAgICAgfSk7XG4gICAgICAgIHlWYWxzMi5wdXNoKHtcbiAgICAgICAgICAgIHkwOiAwLFxuICAgICAgICAgICAgeTE6IG1heFkgLSB5VmFsc1tpXSxcbiAgICAgICAgICAgIGNvbDogXCJ0cmFuc3BhcmVudFwiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgZnJlcXMgPSBbeVZhbHMxLCB5VmFsczJdO1xuXG4gICAgLy8geTAgaXMgdGhlIHN0YXJ0aW5nIHBvaW50XG4gICAgLy8geTEgaXMgdGhlIGxlbmd0aCBvZiB0aGUgYmFyXG5cbiAgICB2YXIgbXlkaXYgPSBcIiN0YWJTdWJzZXRcIjtcbiAgICB2YXIgd2lkdGggPSAyMDA7XG4gICAgdmFyIGhlaWdodCA9IDEyMDtcbiAgICB2YXIgbWFyZ2luID0ge1xuICAgICAgICB0b3A6IDIwLFxuICAgICAgICByaWdodDogMjAsXG4gICAgICAgIGJvdHRvbTogNTMsXG4gICAgICAgIGxlZnQ6IDUwXG4gICAgfTtcblxuICAgIHZhciB4ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLmRvbWFpbihbbWluWCAtIDAuNSwgbWF4WCArIDAuNV0pXG4gICAgICAgIC5yYW5nZShbMCwgd2lkdGhdKTtcblxuICAgIHZhciBpbnZ4ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLnJhbmdlKFttaW5YIC0gMC41LCBtYXhYICsgMC41XSlcbiAgICAgICAgLmRvbWFpbihbMCwgd2lkdGhdKTtcblxuICAgIHZhciB5ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLmRvbWFpbihbMCwgbWF4WV0pXG4gICAgICAgIC5yYW5nZShbMCwgaGVpZ2h0XSk7XG5cbiAgICB2YXIgeEF4aXMgPSBkMy5zdmcuYXhpcygpXG4gICAgICAgIC5zY2FsZSh4KVxuICAgICAgICAudGlja3MoeVZhbHMubGVuZ3RoKVxuICAgICAgICAub3JpZW50KFwiYm90dG9tXCIpO1xuXG4gICAgdmFyIHlBeGlzID0gZDMuc3ZnLmF4aXMoKVxuICAgICAgICAuc2NhbGUoeSlcbiAgICAgICAgLm9yaWVudChcImxlZnRcIik7XG5cbiAgICAvL0NyZWF0ZSBTVkcgZWxlbWVudFxuICAgIHZhciBwbG90c3ZnID0gZDMuc2VsZWN0KG15ZGl2KVxuICAgICAgICAuYXBwZW5kKFwic3ZnXCIpXG4gICAgICAgIC5hdHRyKFwiaWRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gbXluYW1lLmNvbmNhdChcIl9cIiwgbXlkaXYuc3Vic3RyKDEpLCBcIl9cIiwgbm9kZS5pZCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5zdHlsZShcIndpZHRoXCIsIHdpZHRoICsgbWFyZ2luLmxlZnQgKyBtYXJnaW4ucmlnaHQpIC8vc2V0dGluZyBoZWlnaHQgdG8gdGhlIGhlaWdodCBvZiAjbWFpbi5sZWZ0XG4gICAgICAgIC5zdHlsZShcImhlaWdodFwiLCBoZWlnaHQgKyBtYXJnaW4udG9wICsgbWFyZ2luLmJvdHRvbSlcbiAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBtYXJnaW4ubGVmdCArIFwiLFwiICsgbWFyZ2luLnRvcCArIFwiKVwiKTtcblxuICAgIHZhciBmcmVxID0gcGxvdHN2Zy5zZWxlY3RBbGwoXCJnLmZyZXFcIilcbiAgICAgICAgLmRhdGEoZnJlcXMpXG4gICAgICAgIC5lbnRlcigpLmFwcGVuZChcImdcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImZyZXFcIilcbiAgICAgICAgLmF0dHIoXCJuYW1lXCIsIGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiBteW5hbWUuY29uY2F0KGduYW1lW2ldKTtcbiAgICAgICAgfSk7XG5cbiAgICB2YXIgcmVjdCA9IGZyZXEuc2VsZWN0QWxsKFwicmVjdFwiKVxuICAgICAgICAuZGF0YShPYmplY3QpXG4gICAgICAgIC5lbnRlcigpLmFwcGVuZChcInJlY3RcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImJhclwiKVxuICAgICAgICAuYXR0cihcIm5hbWVcIiwgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIHhWYWxzW2ldO1xuICAgICAgICB9KVxuICAgICAgICAuYXR0cihcInhcIiwgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIHgoeFZhbHNbaV0gLSAwLjUgKyBiYXJQYWRkaW5nKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmF0dHIoXCJ5XCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHJldHVybiB5KGQueTApO1xuICAgICAgICB9KVxuICAgICAgICAuYXR0cihcIndpZHRoXCIsIHgobWluWCArIDAuNSAtIDIgKiBiYXJQYWRkaW5nKSkgLy8gdGhlIFwid2lkdGhcIiBpcyB0aGUgY29vcmRpbmF0ZSBvZiB0aGUgZW5kIG9mIHRoZSBmaXJzdCBiYXJcbiAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgcmV0dXJuIHkoZC55MSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5zdHlsZShcImZpbGxcIiwgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgaWYgKG5vZGUuc3Vic2V0cmFuZ2UubGVuZ3RoID4gMCAmIGQuY29sID09PSBkM0NvbG9yICYgJC5pbkFycmF5KHhWYWxzW2ldLnRvU3RyaW5nKCksIG5vZGUuc3Vic2V0cmFuZ2UpID4gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsVmFyQ29sb3I7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBkLmNvbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0TWUgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHNlbGVjdE5hbWUgPSB0aGlzLmdldEF0dHJpYnV0ZShcIm5hbWVcIik7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnROb2RlLmdldEF0dHJpYnV0ZShcIm5hbWVcIikgPT0gbXluYW1lLmNvbmNhdChcInN1YnNldG5vXCIpKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0TWUgPSBlbGVtKGBbbmFtZT1cIiR7bXluYW1lfXN1YnNldHllc1wiXSA+IFtuYW1lPVwiJHtzZWxlY3ROYW1lfVwiXWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZDMuc2VsZWN0KHNlbGVjdE1lKVxuICAgICAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbXlDb2wgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zdHlsZS5maWxsID09PSBzZWxWYXJDb2xvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG15aW5kZXggPSBub2RlLnN1YnNldHJhbmdlLmluZGV4T2YodGhpcy5nZXRBdHRyaWJ1dGUoXCJuYW1lXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc3Vic2V0cmFuZ2Uuc3BsaWNlKG15aW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbXlDb2wgPSBkM0NvbG9yO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5zdWJzZXRyYW5nZS5wdXNoKHRoaXMuZ2V0QXR0cmlidXRlKFwibmFtZVwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBteUNvbCA9IHNlbFZhckNvbG9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBteUNvbDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBsb3Rzdmcuc2VsZWN0KFwidGV4dCNzZWxlY3RyYW5nZVwiKVxuICAgICAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5zdWJzZXRyYW5nZS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcIlNlbGVjdGVkOiBhbGwgdmFsdWVzXCIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBub2RlLnN1YnNldHJhbmdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGVjdGVkcyA9IG5ldyBBcnJheTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGEuZm9yRWFjaChmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZHMucHVzaCh5VmFsS2V5W3ZhbF0ueCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcIlNlbGVjdGVkOiBcIiArIHNlbGVjdGVkcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICB9KVxuICAgICAgICAub24oXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaSA9IHRoaXMuZ2V0QXR0cmlidXRlKFwibmFtZVwiKTtcbiAgICAgICAgICAgIHBsb3Rzdmcuc2VsZWN0KFwidGV4dCNteW1vdXNlb3ZlclwiKVxuICAgICAgICAgICAgICAgIC50ZXh0KCgpID0+IHlWYWxLZXlbaV0ueCArIFwiOiBcIiArIHlWYWxLZXlbaV0ueSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbihcIm1vdXNlb3V0XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGkgPSB0aGlzLmdldEF0dHJpYnV0ZShcIm5hbWVcIik7XG4gICAgICAgICAgICBwbG90c3ZnLnNlbGVjdChcInRleHQjbXltb3VzZW92ZXJcIilcbiAgICAgICAgICAgICAgICAudGV4dCgoKSA9PiBcIlZhbHVlOiBGcmVxdWVuY3lcIik7XG4gICAgICAgIH0pO1xuXG4gICAgaWYgKHBsb3RYYXhpcykge1xuICAgICAgICBwbG90c3ZnLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJ4IGF4aXNcIilcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsXCIgKyBoZWlnaHQgKyBcIilcIilcbiAgICAgICAgICAgIC5jYWxsKHhBeGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBwbG90c3ZnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgXCJteW1vdXNlb3ZlclwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIDI1KVxuICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIGhlaWdodCArIDIwKVxuICAgICAgICAgICAgLnRleHQoKCkgPT4gXCJWYWx1ZTogRnJlcXVlbmN5XCIpO1xuICAgIH1cblxuICAgIHBsb3RzdmcuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAuYXR0cihcInhcIiwgKHdpZHRoIC8gMikpXG4gICAgICAgIC5hdHRyKFwieVwiLCAwIC0gKG1hcmdpbi50b3AgLyAyKSlcbiAgICAgICAgLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKVxuICAgICAgICAuc3R5bGUoXCJmb250LXNpemVcIiwgXCIxMnB4XCIpXG4gICAgICAgIC50ZXh0KG15bmFtZSk7XG5cbiAgICBwbG90c3ZnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgLmF0dHIoXCJpZFwiLCBcInNlbGVjdHJhbmdlXCIpXG4gICAgICAgIC5hdHRyKFwieFwiLCAyNSlcbiAgICAgICAgLmF0dHIoXCJ5XCIsIGhlaWdodCArIDQwKVxuICAgICAgICAudGV4dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAobm9kZS5zdWJzZXRyYW5nZS5sZW5ndGggPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJTZWxlY3RlZDogYWxsIHZhbHVlc1wiO1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkcyA9IG5ldyBBcnJheTtcbiAgICAgICAgICAgIG5vZGUuc3Vic2V0cmFuZ2UuZm9yRWFjaCh2YWwgPT4gIHNlbGVjdGVkcy5wdXNoKHlWYWxLZXlbdmFsXS54KSk7XG4gICAgICAgICAgICByZXR1cm4gXCJTZWxlY3RlZDogXCIgKyBzZWxlY3RlZHM7XG4gICAgICAgIH0pO1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBkZW5zaXR5Tm9kZShub2RlLCBvYmosIHJhZGl1cykge1xuICAgIHZhciBteW5hbWUgPSBub2RlLm5hbWUudG9TdHJpbmcoKS5jb25jYXQoXCJub2RlcGxvdFwiKTtcblxuICAgIGQzLnNlbGVjdChvYmopLnNlbGVjdEFsbChcInN2Z1wiKS5yZW1vdmUoKTtcblxuICAgIHZhciB5VmFscyA9IG5vZGUucGxvdHk7XG4gICAgdmFyIHhWYWxzID0gbm9kZS5wbG90eDtcbiAgICAvLyBhcnJheSBvZiBvYmplY3RzXG4gICAgbGV0IGRhdGEyID0gbm9kZS5wbG90eC5tYXAoKHgsIGkpID0+ICh7eDogK3gsIHk6ICtub2RlLnBsb3R5W2ldfSkpO1xuXG4gICAgLy8gZGVmYXVsdCByYWRpdXMgNDBcblxuICAgIC8vIHdpZHRoIDYwXG4gICAgLy8gaGVpZ2h0IDMwXG4gICAgLy8gdG9wIDIwXG4gICAgLy8gbC9yIDEwXG5cbiAgICB2YXIgd2lkdGggPSByYWRpdXMgKiAxLjU7XG4gICAgdmFyIGhlaWdodCA9IHJhZGl1cyAqIDAuNzU7XG4gICAgdmFyIG1hcmdpbiA9IHtcbiAgICAgICAgdG9wOiA1MCAtIHJhZGl1cyAqIC43NSxcbiAgICAgICAgcmlnaHQ6ICg4MCAtIHdpZHRoKSAvIDIsXG4gICAgICAgIGJvdHRvbTogNTMsXG4gICAgICAgIGxlZnQ6ICg4MCAtIHdpZHRoKSAvIDJcbiAgICB9O1xuXG4gICAgdmFyIHggPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAuZG9tYWluKFtkMy5taW4oeFZhbHMpLCBkMy5tYXgoeFZhbHMpXSlcbiAgICAgICAgLnJhbmdlKFswLCB3aWR0aF0pO1xuXG4gICAgdmFyIHkgPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAuZG9tYWluKFtkMy5taW4oeVZhbHMpLCBkMy5tYXgoeVZhbHMpXSlcbiAgICAgICAgLnJhbmdlKFtoZWlnaHQsIDBdKTtcblxuICAgIHZhciBhcmVhID0gZDMuc3ZnLmFyZWEoKVxuICAgICAgICAuaW50ZXJwb2xhdGUoXCJtb25vdG9uZVwiKVxuICAgICAgICAueChkID0+IHgoZC54KSlcbiAgICAgICAgLnkwKGhlaWdodClcbiAgICAgICAgLnkxKGQgPT4geShkLnkpKTtcblxuICAgIHZhciBwbG90c3ZnID0gZDMuc2VsZWN0KG9iailcbiAgICAgICAgLmluc2VydChcInN2Z1wiLCBcIjpmaXJzdC1jaGlsZFwiKVxuICAgICAgICAuYXR0cihcInhcIiwgLTQwKSAvLyBOT1RFOiBOb3Qgc3VyZSBleGFjdGx5IHdoeSB0aGVzZSBudW1iZXJzIHdvcmssIGJ1dCB0aGVzZSBoYXJkY29kZWQgdmFsdWVzIHNlZW0gdG8gcG9zaXRpb24gdGhlIHBsb3QgaW5zaWRlIGcgY29ycmVjdGx5LiAgdGhpcyBzaG91bGRuJ3QgYmUgaGFyZGNvZGVkIGluIHRoZSBmdXR1cmVcbiAgICAgICAgLmF0dHIoXCJ5XCIsIC00NSlcbiAgICAgICAgLmF0dHIoXCJpZFwiLCAoKSA9PiBteW5hbWUpXG4gICAgICAgIC5zdHlsZShcIndpZHRoXCIsIHdpZHRoKVxuICAgICAgICAuc3R5bGUoXCJoZWlnaHRcIiwgaGVpZ2h0KVxuICAgICAgICAuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIG1hcmdpbi5sZWZ0ICsgXCIsXCIgKyBtYXJnaW4udG9wICsgXCIpXCIpO1xuXG4gICAgcGxvdHN2Zy5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgIC5kYXR1bShkYXRhMilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImFyZWFcIilcbiAgICAgICAgLmF0dHIoXCJkXCIsIGFyZWEpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYmFyc05vZGUobm9kZSwgb2JqLCByYWRpdXMpIHtcbiAgICB2YXIgbXluYW1lID0gbm9kZS5uYW1lLnRvU3RyaW5nKCkuY29uY2F0KFwibm9kZXBsb3RcIik7XG5cbiAgICBkMy5zZWxlY3Qob2JqKS5zZWxlY3RBbGwoXCJzdmdcIikucmVtb3ZlKCk7XG5cbiAgICAvLyBIaXN0b2dyYW0gc3BhY2luZ1xuICAgIHZhciBiYXJQYWRkaW5nID0gLjAxNTsgLy8gU3BhY2UgYmV0d2VlbiBiYXJzXG4gICAgdmFyIHRvcFNjYWxlID0gMS4yOyAvLyBNdWx0aXBsaWNhdGl2ZSBmYWN0b3IgdG8gYXNzaWduIHNwYWNlIGF0IHRvcCB3aXRoaW4gZ3JhcGggLSBjdXJyZW50bHkgcmVtb3ZlZCBmcm9tIGltcGxlbWVudGF0aW9uXG5cbiAgICAvLyBEYXRhXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhub2RlLnBsb3R2YWx1ZXMpO1xuICAgIHZhciB5VmFscyA9IG5ldyBBcnJheTtcbiAgICB2YXIgeFZhbHMgPSBuZXcgQXJyYXk7XG4gICAgdmFyIHlWYWxLZXkgPSBuZXcgQXJyYXk7XG5cbiAgICBpZiAobm9kZS5uYXR1cmUgPT09IFwibm9taW5hbFwiKSB7XG4gICAgICAgIHZhciB4aSA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKG5vZGUucGxvdHZhbHVlc1trZXlzW2ldXSA9PSAwKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgeVZhbHNbeGldID0gbm9kZS5wbG90dmFsdWVzW2tleXNbaV1dO1xuICAgICAgICAgICAgeFZhbHNbeGldID0geGk7XG4gICAgICAgICAgICB5VmFsS2V5LnB1c2goe3k6IHlWYWxzW3hpXSwgeDoga2V5c1tpXX0pO1xuICAgICAgICAgICAgeGkgPSB4aSArIDE7XG4gICAgICAgIH1cbiAgICAgICAgeVZhbEtleS5zb3J0KChhLCBiKSA9PiBiLnkgLSBhLnkpOyAvLyBhcnJheSBvZiBvYmplY3RzLCBlYWNoIG9iamVjdCBoYXMgeSwgdGhlIHNhbWUgYXMgeVZhbHMsIGFuZCB4LCB0aGUgY2F0ZWdvcnlcbiAgICAgICAgeVZhbHMuc29ydCgoYSwgYikgPT4gYiAtIGEpOyAvLyBhcnJheSBvZiB5IHZhbHVlcywgdGhlIGhlaWdodCBvZiB0aGUgYmFyc1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgeVZhbHNbaV0gPSBub2RlLnBsb3R2YWx1ZXNba2V5c1tpXV07XG4gICAgICAgICAgICB4VmFsc1tpXSA9IE51bWJlcihrZXlzW2ldKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBtYXhZID0gZDMubWF4KHlWYWxzKTtcbiAgICB2YXIgbWluWCA9IGQzLm1pbih4VmFscyk7XG4gICAgdmFyIG1heFggPSBkMy5tYXgoeFZhbHMpO1xuXG4gICAgdmFyIHdpZHRoID0gcmFkaXVzICogMS41O1xuICAgIHZhciBoZWlnaHQgPSByYWRpdXMgKiAwLjc1O1xuICAgIHZhciBtYXJnaW4gPSB7XG4gICAgICAgIHRvcDogNTAgLSByYWRpdXMgKiAuNzUsXG4gICAgICAgIHJpZ2h0OiAoODAgLSB3aWR0aCkgLyAyLFxuICAgICAgICBib3R0b206IDUzLFxuICAgICAgICBsZWZ0OiAoODAgLSB3aWR0aCkgLyAyXG4gICAgfTtcblxuICAgIHZhciB4ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLmRvbWFpbihbbWluWCAtIDAuNSwgbWF4WCArIDAuNV0pXG4gICAgICAgIC5yYW5nZShbMCwgd2lkdGhdKTtcblxuICAgIHZhciBpbnZ4ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLnJhbmdlKFttaW5YIC0gMC41LCBtYXhYICsgMC41XSlcbiAgICAgICAgLmRvbWFpbihbMCwgd2lkdGhdKTtcblxuICAgIHZhciB5ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLmRvbWFpbihbMCwgbWF4WV0pXG4gICAgICAgIC5yYW5nZShbMCwgaGVpZ2h0XSk7XG5cbiAgICAvL0NyZWF0ZSBTVkcgZWxlbWVudFxuICAgIHZhciBwbG90c3ZnID0gZDMuc2VsZWN0KG9iailcbiAgICAgICAgLmluc2VydChcInN2Z1wiLCBcIjpmaXJzdC1jaGlsZFwiKVxuICAgICAgICAuYXR0cihcInhcIiwgLTQwKVxuICAgICAgICAuYXR0cihcInlcIiwgLTQ1KVxuICAgICAgICAuYXR0cihcImlkXCIsICgpID0+IG15bmFtZSlcbiAgICAgICAgLnN0eWxlKFwid2lkdGhcIiwgd2lkdGgpIC8vIHNldCBoZWlnaHQgdG8gdGhlIGhlaWdodCBvZiAjbWFpbi5sZWZ0XG4gICAgICAgIC5zdHlsZShcImhlaWdodFwiLCBoZWlnaHQpXG4gICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgbWFyZ2luLmxlZnQgKyBcIixcIiArIG1hcmdpbi50b3AgKyBcIilcIik7XG5cbiAgICBwbG90c3ZnLnNlbGVjdEFsbChcInJlY3RcIilcbiAgICAgICAgLmRhdGEoeVZhbHMpXG4gICAgICAgIC5lbnRlcigpXG4gICAgICAgIC5hcHBlbmQoXCJyZWN0XCIpXG4gICAgICAgIC5hdHRyKFwieFwiLCAoZCwgaSkgPT4gIHgoeFZhbHNbaV0gLSAwLjUgKyBiYXJQYWRkaW5nKSlcbiAgICAgICAgLmF0dHIoXCJ5XCIsIGQgPT4gIHkobWF4WSAtIGQpKVxuICAgICAgICAuYXR0cihcIndpZHRoXCIsIHgobWluWCArIDAuNSAtIDIgKiBiYXJQYWRkaW5nKSkgLy8gdGhlIFwid2lkdGhcIiBpcyB0aGUgY29vcmRpbmF0ZSBvZiB0aGUgZW5kIG9mIHRoZSBmaXJzdCBiYXJcbiAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgeSlcbiAgICAgICAgLmF0dHIoXCJmaWxsXCIsIFwiIzFmNzdiNFwiKTtcbn1cblxuXG5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Fzc2V0cy9hcHAvcGxvdHMuanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4\n')},function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.searchIndex = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mithril = __webpack_require__(0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _app = __webpack_require__(2);\n\nvar app = _interopRequireWildcard(_app);\n\nvar _plots = __webpack_require__(4);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar searchIndex = exports.searchIndex = void 0;\n\nvar search = function search(val) {\n    var all = app.allNodes;\n    if (val === '') {\n        exports.searchIndex = searchIndex = null;\n        return app.valueKey = all.map(function (n) {\n            return n.name;\n        });\n    }\n\n    var matches = [],\n        others = [],\n        match = function match(n, key) {\n        return n[key].toLowerCase().includes(val.toLowerCase());\n    };\n\n    all.forEach(function (n) {\n        return match(n, 'name') || match(n, 'labl') ? matches.push(n) : others.push(n);\n    });\n    exports.searchIndex = searchIndex = matches.length;\n    app.valueKey = matches.concat(others).map(function (n) {\n        return n.name;\n    });\n};\n\nvar Search = function () {\n    function Search() {\n        _classCallCheck(this, Search);\n    }\n\n    _createClass(Search, [{\n        key: 'view',\n        value: function view(vnode) {\n            vnode.attrs.oninput = _mithril2.default.withAttr('value', search);\n            return (0, _mithril2.default)('input#searchvar.form-control[style=margin-bottom: 5px; width: 100%]', vnode.attrs);\n        }\n    }]);\n\n    return Search;\n}();\n\nexports.default = Search;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvYXBwL3ZpZXdzL1NlYXJjaC5qcz8xMzc4Il0sIm5hbWVzIjpbImFwcCIsInNlYXJjaEluZGV4Iiwic2VhcmNoIiwiYWxsIiwiYWxsTm9kZXMiLCJ2YWwiLCJ2YWx1ZUtleSIsIm1hcCIsIm4iLCJuYW1lIiwibWF0Y2hlcyIsIm90aGVycyIsIm1hdGNoIiwia2V5IiwidG9Mb3dlckNhc2UiLCJpbmNsdWRlcyIsImZvckVhY2giLCJwdXNoIiwibGVuZ3RoIiwiY29uY2F0IiwiU2VhcmNoIiwidm5vZGUiLCJhdHRycyIsIm9uaW5wdXQiLCJ3aXRoQXR0ciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7Ozs7QUFFQTs7SUFBWUEsRzs7QUFDWjs7Ozs7Ozs7QUFFTyxJQUFJQywwQ0FBSjs7QUFFUCxJQUFJQyxTQUFTLFNBQVRBLE1BQVMsTUFBTztBQUNoQixRQUFJQyxNQUFNSCxJQUFJSSxRQUFkO0FBQ0EsUUFBSUMsUUFBUSxFQUFaLEVBQWdCO0FBQ1osZ0JBTEdKLFdBS0gsaUJBQWMsSUFBZDtBQUNBLGVBQU9ELElBQUlNLFFBQUosR0FBZUgsSUFBSUksR0FBSixDQUFRO0FBQUEsbUJBQUtDLEVBQUVDLElBQVA7QUFBQSxTQUFSLENBQXRCO0FBQ0g7O0FBTGUsUUFNWEMsT0FOVyxHQU1nQixFQU5oQjtBQUFBLFFBTUZDLE1BTkUsR0FNb0IsRUFOcEI7QUFBQSxRQU1NQyxLQU5OLEdBTXdCLFNBQWxCQSxLQUFrQixDQUFDSixDQUFELEVBQUlLLEdBQUo7QUFBQSxlQUFZTCxFQUFFSyxHQUFGLEVBQU9DLFdBQVAsR0FBcUJDLFFBQXJCLENBQThCVixJQUFJUyxXQUFKLEVBQTlCLENBQVo7QUFBQSxLQU54Qjs7QUFPaEJYLFFBQUlhLE9BQUosQ0FBWTtBQUFBLGVBQUtKLE1BQU1KLENBQU4sRUFBUyxNQUFULEtBQW9CSSxNQUFNSixDQUFOLEVBQVMsTUFBVCxDQUFwQixHQUF1Q0UsUUFBUU8sSUFBUixDQUFhVCxDQUFiLENBQXZDLEdBQXlERyxPQUFPTSxJQUFQLENBQVlULENBQVosQ0FBOUQ7QUFBQSxLQUFaO0FBQ0EsWUFWT1AsV0FVUCxpQkFBY1MsUUFBUVEsTUFBdEI7QUFDQWxCLFFBQUlNLFFBQUosR0FBZUksUUFDVlMsTUFEVSxDQUNIUixNQURHLEVBRVZKLEdBRlUsQ0FFTjtBQUFBLGVBQUtDLEVBQUVDLElBQVA7QUFBQSxLQUZNLENBQWY7QUFHSCxDQVpEOztJQWNNVyxNOzs7Ozs7OzZCQUNHQyxLLEVBQU87QUFDUkEsa0JBQU1DLEtBQU4sQ0FBWUMsT0FBWixHQUFzQixrQkFBRUMsUUFBRixDQUFXLE9BQVgsRUFBb0J0QixNQUFwQixDQUF0QjtBQUNBLG1CQUFPLHVCQUFFLHFFQUFGLEVBQXlFbUIsTUFBTUMsS0FBL0UsQ0FBUDtBQUNIOzs7Ozs7a0JBR1VGLE0iLCJmaWxlIjoiNS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuXG5pbXBvcnQgKiBhcyBhcHAgZnJvbSAnLi4vYXBwJztcbmltcG9ydCB7c2VsVmFyQ29sb3J9IGZyb20gJy4uL3Bsb3RzJztcblxuZXhwb3J0IGxldCBzZWFyY2hJbmRleDtcblxubGV0IHNlYXJjaCA9IHZhbCA9PiB7XG4gICAgbGV0IGFsbCA9IGFwcC5hbGxOb2RlcztcbiAgICBpZiAodmFsID09PSAnJykge1xuICAgICAgICBzZWFyY2hJbmRleCA9IG51bGw7XG4gICAgICAgIHJldHVybiBhcHAudmFsdWVLZXkgPSBhbGwubWFwKG4gPT4gbi5uYW1lKTtcbiAgICB9XG4gICAgbGV0IFttYXRjaGVzLCBvdGhlcnMsIG1hdGNoXSA9IFtbXSwgW10sIChuLCBrZXkpID0+IG5ba2V5XS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHZhbC50b0xvd2VyQ2FzZSgpKV07XG4gICAgYWxsLmZvckVhY2gobiA9PiBtYXRjaChuLCAnbmFtZScpIHx8IG1hdGNoKG4sICdsYWJsJykgPyBtYXRjaGVzLnB1c2gobikgOiBvdGhlcnMucHVzaChuKSk7XG4gICAgc2VhcmNoSW5kZXggPSBtYXRjaGVzLmxlbmd0aDtcbiAgICBhcHAudmFsdWVLZXkgPSBtYXRjaGVzXG4gICAgICAgIC5jb25jYXQob3RoZXJzKVxuICAgICAgICAubWFwKG4gPT4gbi5uYW1lKTtcbn07XG5cbmNsYXNzIFNlYXJjaCB7XG4gICAgdmlldyh2bm9kZSkge1xuICAgICAgICB2bm9kZS5hdHRycy5vbmlucHV0ID0gbS53aXRoQXR0cigndmFsdWUnLCBzZWFyY2gpO1xuICAgICAgICByZXR1cm4gbSgnaW5wdXQjc2VhcmNodmFyLmZvcm0tY29udHJvbFtzdHlsZT1tYXJnaW4tYm90dG9tOiA1cHg7IHdpZHRoOiAxMDAlXScsIHZub2RlLmF0dHJzKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNlYXJjaDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Fzc2V0cy9hcHAvdmlld3MvU2VhcmNoLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.when = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mithril = __webpack_require__(0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _app = __webpack_require__(2);\n\nvar app = _interopRequireWildcard(_app);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar when = exports.when = function when(side, val) {\n    var y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'block';\n    var n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'none';\n\n    return app[side + 'tab'] === val ? y : n;\n};\n\nvar PanelButton = function () {\n    function PanelButton() {\n        _classCallCheck(this, PanelButton);\n    }\n\n    _createClass(PanelButton, [{\n        key: 'view',\n        value: function view(vnode) {\n            var _vnode$attrs = vnode.attrs,\n                id = _vnode$attrs.id,\n                id2 = _vnode$attrs.id2,\n                classes = _vnode$attrs.classes,\n                onclick = _vnode$attrs.onclick,\n                style = _vnode$attrs.style,\n                title = _vnode$attrs.title,\n                is_explore_mode = _vnode$attrs.is_explore_mode;\n\n            var left = id2 ? true : false;\n            id2 = id2 || id;\n            var disabled = is_explore_mode && !app.explored;\n            return (0, _mithril2.default)('button#' + id + '.btn.' + (classes || when(left ? 'left' : 'right', id2, 'active', disabled ? 'btn.disabled' : 'btn-default')) + '[type=button]', {\n                onclick: onclick || function (_) {\n                    return left ? app.probDiscView(id2) : disabled || app.tabRight(id2);\n                },\n                style: style,\n                title: title }, vnode.children);\n        }\n    }]);\n\n    return PanelButton;\n}();\n\nexports.default = PanelButton;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvYXBwL3ZpZXdzL1BhbmVsQnV0dG9uLmpzP2M4NTciXSwibmFtZXMiOlsiYXBwIiwid2hlbiIsInNpZGUiLCJ2YWwiLCJ5IiwibiIsIlBhbmVsQnV0dG9uIiwidm5vZGUiLCJhdHRycyIsImlkIiwiaWQyIiwiY2xhc3NlcyIsIm9uY2xpY2siLCJzdHlsZSIsInRpdGxlIiwiaXNfZXhwbG9yZV9tb2RlIiwibGVmdCIsImRpc2FibGVkIiwiZXhwbG9yZWQiLCJwcm9iRGlzY1ZpZXciLCJ0YWJSaWdodCIsImNoaWxkcmVuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTs7OztBQUVBOztJQUFZQSxHOzs7Ozs7OztBQUVMLElBQUlDLHNCQUFPLFNBQVBBLElBQU8sQ0FBU0MsSUFBVCxFQUFlQyxHQUFmLEVBQXlDO0FBQUEsUUFBckJDLENBQXFCLHVFQUFuQixPQUFtQjtBQUFBLFFBQVZDLENBQVUsdUVBQVIsTUFBUTs7QUFDdkQsV0FBT0wsSUFBSUUsT0FBTyxLQUFYLE1BQXNCQyxHQUF0QixHQUE0QkMsQ0FBNUIsR0FBZ0NDLENBQXZDO0FBQ0gsQ0FGTTs7SUFJREMsVzs7Ozs7Ozs2QkFDR0MsSyxFQUFPO0FBQUEsK0JBQ3lEQSxNQUFNQyxLQUQvRDtBQUFBLGdCQUNIQyxFQURHLGdCQUNIQSxFQURHO0FBQUEsZ0JBQ0NDLEdBREQsZ0JBQ0NBLEdBREQ7QUFBQSxnQkFDTUMsT0FETixnQkFDTUEsT0FETjtBQUFBLGdCQUNlQyxPQURmLGdCQUNlQSxPQURmO0FBQUEsZ0JBQ3dCQyxLQUR4QixnQkFDd0JBLEtBRHhCO0FBQUEsZ0JBQytCQyxLQUQvQixnQkFDK0JBLEtBRC9CO0FBQUEsZ0JBQ3NDQyxlQUR0QyxnQkFDc0NBLGVBRHRDOztBQUVSLGdCQUFJQyxPQUFPTixNQUFNLElBQU4sR0FBYSxLQUF4QjtBQUNBQSxrQkFBTUEsT0FBT0QsRUFBYjtBQUNBLGdCQUFJUSxXQUFXRixtQkFBbUIsQ0FBQ2YsSUFBSWtCLFFBQXZDO0FBQ0EsbUJBQU8sbUNBQ09ULEVBRFAsY0FDaUJFLFdBQVdWLEtBQUtlLE9BQU8sTUFBUCxHQUFnQixPQUFyQixFQUE4Qk4sR0FBOUIsRUFBbUMsUUFBbkMsRUFBNkNPLFdBQVcsY0FBWCxHQUE0QixhQUF6RSxDQUQ1QixxQkFDb0k7QUFDdklMLHlCQUFTQSxXQUFZO0FBQUEsMkJBQUtJLE9BQU9oQixJQUFJbUIsWUFBSixDQUFpQlQsR0FBakIsQ0FBUCxHQUErQk8sWUFBWWpCLElBQUlvQixRQUFKLENBQWFWLEdBQWIsQ0FBaEQ7QUFBQSxpQkFEa0g7QUFFdklHLHVCQUFPQSxLQUZnSTtBQUd2SUMsdUJBQU9BLEtBSGdJLEVBRHBJLEVBS0hQLE1BQU1jLFFBTEgsQ0FBUDtBQU1IOzs7Ozs7a0JBR1VmLFciLCJmaWxlIjoiNi5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuXG5pbXBvcnQgKiBhcyBhcHAgZnJvbSAnLi4vYXBwJztcblxuZXhwb3J0IGxldCB3aGVuID0gZnVuY3Rpb24oc2lkZSwgdmFsLCB5PSdibG9jaycsIG49J25vbmUnKSB7XG4gICAgcmV0dXJuIGFwcFtzaWRlICsgJ3RhYiddID09PSB2YWwgPyB5IDogbjtcbn07XG5cbmNsYXNzIFBhbmVsQnV0dG9uIHtcbiAgICB2aWV3KHZub2RlKSB7XG4gICAgICAgIGxldCB7aWQsIGlkMiwgY2xhc3Nlcywgb25jbGljaywgc3R5bGUsIHRpdGxlLCBpc19leHBsb3JlX21vZGV9ID0gdm5vZGUuYXR0cnM7XG4gICAgICAgIGxldCBsZWZ0ID0gaWQyID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgICBpZDIgPSBpZDIgfHwgaWQ7XG4gICAgICAgIGxldCBkaXNhYmxlZCA9IGlzX2V4cGxvcmVfbW9kZSAmJiAhYXBwLmV4cGxvcmVkO1xuICAgICAgICByZXR1cm4gbShcbiAgICAgICAgICAgIGBidXR0b24jJHtpZH0uYnRuLiR7Y2xhc3NlcyB8fCB3aGVuKGxlZnQgPyAnbGVmdCcgOiAncmlnaHQnLCBpZDIsICdhY3RpdmUnLCBkaXNhYmxlZCA/ICdidG4uZGlzYWJsZWQnIDogJ2J0bi1kZWZhdWx0Jyl9W3R5cGU9YnV0dG9uXWAsIHtcbiAgICAgICAgICAgIG9uY2xpY2s6IG9uY2xpY2sgfHwgKF8gPT4gbGVmdCA/IGFwcC5wcm9iRGlzY1ZpZXcoaWQyKSA6IGRpc2FibGVkIHx8IGFwcC50YWJSaWdodChpZDIpKSxcbiAgICAgICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgICAgIHRpdGxlOiB0aXRsZX0sXG4gICAgICAgICAgICB2bm9kZS5jaGlsZHJlbik7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBQYW5lbEJ1dHRvbjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Fzc2V0cy9hcHAvdmlld3MvUGFuZWxCdXR0b24uanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mithril = __webpack_require__(0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _app = __webpack_require__(2);\n\nvar app = _interopRequireWildcard(_app);\n\nvar _plots = __webpack_require__(4);\n\nvar plots = _interopRequireWildcard(_plots);\n\nvar _Search = __webpack_require__(5);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar PanelList = function () {\n    function PanelList() {\n        _classCallCheck(this, PanelList);\n    }\n\n    _createClass(PanelList, [{\n        key: 'view',\n        value: function view(vnode) {\n            var _vnode$attrs = vnode.attrs,\n                items = _vnode$attrs.items,\n                content = _vnode$attrs.content,\n                title = _vnode$attrs.title,\n                probDesc = _vnode$attrs.probDesc,\n                onclick = _vnode$attrs.onclick;\n\n            return (0, _mithril2.default)('#varList[style=display: block]', items.map(function (v, i) {\n                return (0, _mithril2.default)('p#' + v.replace(/\\W/g, '_'), {\n                    class: probDesc ? app.d3mProblemDescription[probDesc] === v ? 'item-select' : app.locktoggle ? 'item-default item-lineout' : 'item-default' : '',\n                    style: {\n                        'background-color': probDesc ? '' : app.zparams.zdv.includes(v) ? app.hexToRgba(app.dvColor) : app.zparams.znom.includes(v) ? app.hexToRgba(app.nomColor) : app.nodes.map(function (n) {\n                            return n.name;\n                        }).includes(v) ? app.hexToRgba(plots.selVarColor) : app.varColor,\n                        'border-color': '#000000',\n                        'border-style': !probDesc && _Search.searchIndex && i < _Search.searchIndex ? 'solid' : 'none',\n                        'text-align': 'center'\n                    },\n                    onclick: onclick || probDesc || app.clickVar,\n                    onmouseover: function onmouseover() {\n                        $(this).popover('toggle');\n                        if (probDesc) return;\n                        $(\"body div.popover\").addClass(\"variables\");\n                        $(\"body div.popover div.popover-content\").addClass(\"form-horizontal\");\n                    },\n                    onmouseout: \"$(this).popover('toggle');\",\n                    'data-container': 'body',\n                    'data-content': content ? content(v) : app.popoverContent(app.findNodeIndex(v, true)),\n                    'data-html': 'true',\n                    'data-original-title': title + ' for <b>' + v,\n                    'data-placement': probDesc ? 'top' : 'right',\n                    'data-toggle': 'popover',\n                    'data-trigger': 'hover' }, v);\n            }));\n        }\n    }]);\n\n    return PanelList;\n}();\n\nexports.default = PanelList;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvYXBwL3ZpZXdzL1BhbmVsTGlzdC5qcz9mNjE3Il0sIm5hbWVzIjpbImFwcCIsInBsb3RzIiwiUGFuZWxMaXN0Iiwidm5vZGUiLCJhdHRycyIsIml0ZW1zIiwiY29udGVudCIsInRpdGxlIiwicHJvYkRlc2MiLCJvbmNsaWNrIiwibWFwIiwidiIsImkiLCJyZXBsYWNlIiwiY2xhc3MiLCJkM21Qcm9ibGVtRGVzY3JpcHRpb24iLCJsb2NrdG9nZ2xlIiwic3R5bGUiLCJ6cGFyYW1zIiwiemR2IiwiaW5jbHVkZXMiLCJoZXhUb1JnYmEiLCJkdkNvbG9yIiwiem5vbSIsIm5vbUNvbG9yIiwibm9kZXMiLCJuIiwibmFtZSIsInNlbFZhckNvbG9yIiwidmFyQ29sb3IiLCJjbGlja1ZhciIsIm9ubW91c2VvdmVyIiwiJCIsInBvcG92ZXIiLCJhZGRDbGFzcyIsIm9ubW91c2VvdXQiLCJwb3BvdmVyQ29udGVudCIsImZpbmROb2RlSW5kZXgiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7Ozs7QUFFQTs7SUFBWUEsRzs7QUFDWjs7SUFBWUMsSzs7QUFFWjs7Ozs7Ozs7SUFFTUMsUzs7Ozs7Ozs2QkFDR0MsSyxFQUFPO0FBQUEsK0JBQ3lDQSxNQUFNQyxLQUQvQztBQUFBLGdCQUNIQyxLQURHLGdCQUNIQSxLQURHO0FBQUEsZ0JBQ0lDLE9BREosZ0JBQ0lBLE9BREo7QUFBQSxnQkFDYUMsS0FEYixnQkFDYUEsS0FEYjtBQUFBLGdCQUNvQkMsUUFEcEIsZ0JBQ29CQSxRQURwQjtBQUFBLGdCQUM4QkMsT0FEOUIsZ0JBQzhCQSxPQUQ5Qjs7QUFFUixtQkFBTyx1QkFDSCxnQ0FERyxFQUVISixNQUFNSyxHQUFOLENBQVUsVUFBQ0MsQ0FBRCxFQUFJQyxDQUFKO0FBQUEsdUJBQ0EsOEJBQU9ELEVBQUVFLE9BQUYsQ0FBVSxLQUFWLEVBQWlCLEdBQWpCLENBQVAsRUFBZ0M7QUFDNUJDLDJCQUFPTixXQUNGUixJQUFJZSxxQkFBSixDQUEwQlAsUUFBMUIsTUFBd0NHLENBQXhDLEdBQTRDLGFBQTVDLEdBQ0FYLElBQUlnQixVQUFKLEdBQWlCLDJCQUFqQixHQUNBLGNBSEUsR0FHZ0IsRUFKSztBQUs1QkMsMkJBQU87QUFDSCw0Q0FBb0JULFdBQVcsRUFBWCxHQUNoQlIsSUFBSWtCLE9BQUosQ0FBWUMsR0FBWixDQUFnQkMsUUFBaEIsQ0FBeUJULENBQXpCLElBQThCWCxJQUFJcUIsU0FBSixDQUFjckIsSUFBSXNCLE9BQWxCLENBQTlCLEdBQ0F0QixJQUFJa0IsT0FBSixDQUFZSyxJQUFaLENBQWlCSCxRQUFqQixDQUEwQlQsQ0FBMUIsSUFBK0JYLElBQUlxQixTQUFKLENBQWNyQixJQUFJd0IsUUFBbEIsQ0FBL0IsR0FDQXhCLElBQUl5QixLQUFKLENBQVVmLEdBQVYsQ0FBYztBQUFBLG1DQUFLZ0IsRUFBRUMsSUFBUDtBQUFBLHlCQUFkLEVBQTJCUCxRQUEzQixDQUFvQ1QsQ0FBcEMsSUFBeUNYLElBQUlxQixTQUFKLENBQWNwQixNQUFNMkIsV0FBcEIsQ0FBekMsR0FDQTVCLElBQUk2QixRQUxMO0FBTUgsd0NBQWdCLFNBTmI7QUFPSCx3Q0FBZ0IsQ0FBQ3JCLFFBQUQsMkJBQTRCSSx1QkFBNUIsR0FBOEMsT0FBOUMsR0FBd0QsTUFQckU7QUFRSCxzQ0FBYztBQVJYLHFCQUxxQjtBQWU1QkgsNkJBQVNBLFdBQVdELFFBQVgsSUFBdUJSLElBQUk4QixRQWZSO0FBZ0I1QkMsaUNBQWEsdUJBQVc7QUFDcEJDLDBCQUFFLElBQUYsRUFBUUMsT0FBUixDQUFnQixRQUFoQjtBQUNBLDRCQUFJekIsUUFBSixFQUFjO0FBQ2R3QiwwQkFBRSxrQkFBRixFQUNLRSxRQURMLENBQ2MsV0FEZDtBQUVBRiwwQkFBRSxzQ0FBRixFQUNLRSxRQURMLENBQ2MsaUJBRGQ7QUFFSCxxQkF2QjJCO0FBd0I1QkMsZ0NBQVksNEJBeEJnQjtBQXlCNUIsc0NBQWtCLE1BekJVO0FBMEI1QixvQ0FBZ0I3QixVQUFVQSxRQUFRSyxDQUFSLENBQVYsR0FBdUJYLElBQUlvQyxjQUFKLENBQW1CcEMsSUFBSXFDLGFBQUosQ0FBa0IxQixDQUFsQixFQUFxQixJQUFyQixDQUFuQixDQTFCWDtBQTJCNUIsaUNBQWEsTUEzQmU7QUE0QjVCLDJDQUF1QkosUUFBUSxVQUFSLEdBQXFCSSxDQTVCaEI7QUE2QjVCLHNDQUFrQkgsV0FBVyxLQUFYLEdBQW1CLE9BN0JUO0FBOEI1QixtQ0FBZSxTQTlCYTtBQStCNUIsb0NBQWdCLE9BL0JZLEVBQWhDLEVBZ0NFRyxDQWhDRixDQURBO0FBQUEsYUFBVixDQUZHLENBQVA7QUFvQ0g7Ozs7OztrQkFHVVQsUyIsImZpbGUiOiI3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCc7XG5cbmltcG9ydCAqIGFzIGFwcCBmcm9tICcuLi9hcHAnO1xuaW1wb3J0ICogYXMgcGxvdHMgZnJvbSAnLi4vcGxvdHMnO1xuXG5pbXBvcnQge3NlYXJjaEluZGV4fSBmcm9tICcuL1NlYXJjaCc7XG5cbmNsYXNzIFBhbmVsTGlzdCB7XG4gICAgdmlldyh2bm9kZSkge1xuICAgICAgICBsZXQge2l0ZW1zLCBjb250ZW50LCB0aXRsZSwgcHJvYkRlc2MsIG9uY2xpY2t9ID0gdm5vZGUuYXR0cnM7XG4gICAgICAgIHJldHVybiBtKFxuICAgICAgICAgICAgJyN2YXJMaXN0W3N0eWxlPWRpc3BsYXk6IGJsb2NrXScsXG4gICAgICAgICAgICBpdGVtcy5tYXAoKHYsIGkpID0+XG4gICAgICAgICAgICAgICAgICAgICAgbShgcCMke3YucmVwbGFjZSgvXFxXL2csICdfJyl9YCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzczogcHJvYkRlc2MgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGFwcC5kM21Qcm9ibGVtRGVzY3JpcHRpb25bcHJvYkRlc2NdID09PSB2ID8gJ2l0ZW0tc2VsZWN0JyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwLmxvY2t0b2dnbGUgPyAnaXRlbS1kZWZhdWx0IGl0ZW0tbGluZW91dCcgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdpdGVtLWRlZmF1bHQnKSA6ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2JhY2tncm91bmQtY29sb3InOiBwcm9iRGVzYyA/ICcnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHAuenBhcmFtcy56ZHYuaW5jbHVkZXModikgPyBhcHAuaGV4VG9SZ2JhKGFwcC5kdkNvbG9yKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwLnpwYXJhbXMuem5vbS5pbmNsdWRlcyh2KSA/IGFwcC5oZXhUb1JnYmEoYXBwLm5vbUNvbG9yKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwLm5vZGVzLm1hcChuID0+IG4ubmFtZSkuaW5jbHVkZXModikgPyBhcHAuaGV4VG9SZ2JhKHBsb3RzLnNlbFZhckNvbG9yKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwLnZhckNvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2JvcmRlci1jb2xvcic6ICcjMDAwMDAwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdib3JkZXItc3R5bGUnOiAhcHJvYkRlc2MgJiYgc2VhcmNoSW5kZXggJiYgaSA8IHNlYXJjaEluZGV4ID8gJ3NvbGlkJyA6ICdub25lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0ZXh0LWFsaWduJzogJ2NlbnRlcidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb25jbGljazogb25jbGljayB8fCBwcm9iRGVzYyB8fCBhcHAuY2xpY2tWYXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9ubW91c2VvdmVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQodGhpcykucG9wb3ZlcigndG9nZ2xlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvYkRlc2MpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoXCJib2R5IGRpdi5wb3BvdmVyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKFwidmFyaWFibGVzXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJChcImJvZHkgZGl2LnBvcG92ZXIgZGl2LnBvcG92ZXItY29udGVudFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhcImZvcm0taG9yaXpvbnRhbFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb25tb3VzZW91dDogXCIkKHRoaXMpLnBvcG92ZXIoJ3RvZ2dsZScpO1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAnZGF0YS1jb250YWluZXInOiAnYm9keScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhLWNvbnRlbnQnOiBjb250ZW50ID8gY29udGVudCh2KSA6IGFwcC5wb3BvdmVyQ29udGVudChhcHAuZmluZE5vZGVJbmRleCh2LCB0cnVlKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhLWh0bWwnOiAndHJ1ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhLW9yaWdpbmFsLXRpdGxlJzogdGl0bGUgKyAnIGZvciA8Yj4nICsgdixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEtcGxhY2VtZW50JzogcHJvYkRlc2MgPyAndG9wJyA6ICdyaWdodCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhLXRvZ2dsZSc6ICdwb3BvdmVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEtdHJpZ2dlcic6ICdob3Zlcid9LFxuICAgICAgICAgICAgICAgICAgICAgICAgdikpKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBhbmVsTGlzdDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Fzc2V0cy9hcHAvdmlld3MvUGFuZWxMaXN0LmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mithril = __webpack_require__(0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _common = __webpack_require__(1);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// Interface specification\n//\n// ```\n// m(ButtonRadio, {\n//     sections: [\n//             {\n//                 value: 'Button 1',\n//                 title: 'Hover text',\n//                 attrsInterface: {optional object of attributes}\n//             },\n//             ...\n//         ],\n//     defaultSection: string (optional),\n//     activeSection: string (optional),\n//     onclick: (value) => console.log(value + \" was clicked.\")\n//     attrsAll: {optional object of attributes to apply to the bar}\n//     attrsButtons: {optional object of attributes to apply to all buttons}\n//     selectWidth: 20 (optional int),\n//     hoverBonus: 10 (optional int)\n//     })\n// ```\n\n// The selectWidth option forces the selected button to be n percent wide.\n// The other buttons on the bar compensate.\n// If not included, then every button has even spacing.\n\n// The hoverBonus option makes the hovered button n percent larger when hovered.\n// Both hoverBonus and selectWidth may be used together. On both, don't pass a string%, pass the numeric.\n\n// defaultSection sets which element is selected on page load\n// activeSelection forces the selected element. This is for convenience when external events change the selected button\n\nvar ButtonRadio = function () {\n    function ButtonRadio() {\n        _classCallCheck(this, ButtonRadio);\n    }\n\n    _createClass(ButtonRadio, [{\n        key: 'oninit',\n        value: function oninit(vnode) {\n            var _vnode$attrs = vnode.attrs,\n                activeSection = _vnode$attrs.activeSection,\n                defaultSection = _vnode$attrs.defaultSection,\n                sections = _vnode$attrs.sections;\n            // Attempt to set active on initial load based on options\n\n            this.active = activeSection || defaultSection || sections.length !== 0 ? sections[0].value : undefined;\n        }\n    }, {\n        key: 'view',\n        value: function view(vnode) {\n            var _this = this;\n\n            var _vnode$attrs2 = vnode.attrs,\n                id = _vnode$attrs2.id,\n                sections = _vnode$attrs2.sections,\n                _onclick = _vnode$attrs2.onclick,\n                selectWidth = _vnode$attrs2.selectWidth,\n                hoverBonus = _vnode$attrs2.hoverBonus,\n                attrsAll = _vnode$attrs2.attrsAll,\n                attrsButtons = _vnode$attrs2.attrsButtons,\n                activeSection = _vnode$attrs2.activeSection;\n\n            // Sorry about the complexity here. Got stuck with a lot of cases\n\n            var getWidth = function getWidth(value) {\n                // Evenly spaced\n                if (selectWidth === undefined && (hoverBonus === undefined || _this.hovered === undefined)) {\n                    return 100. / sections.length + '%';\n                }\n\n                // Fixed width of selected button\n                if (selectWidth !== undefined && (hoverBonus === undefined || _this.hovered === undefined)) {\n                    if (_this.active === value) return selectWidth + '%';\n                    return 'calc(' + 100. / (sections.length - 1) + '% - ' + selectWidth / (sections.length - 1) + '%)';\n                }\n\n                // Hovering is turned on and a button is hovered\n                if (selectWidth === undefined && hoverBonus !== undefined && _this.hovered !== undefined) {\n                    if (_this.hovered === value) return 100. / sections.length + hoverBonus + '%';\n                    return 100. / sections.length - hoverBonus / (sections.length - 1) + '%';\n                }\n\n                // Fixed width of selected button and button resize on hover\n                if (selectWidth !== undefined && hoverBonus !== undefined && _this.hovered !== undefined) {\n                    if (_this.active === value) return selectWidth + '%';\n                    if (_this.hovered === _this.active) return 'calc(' + 100. / (sections.length - 1) + '% - ' + selectWidth / (sections.length - 1) + '%)';\n                    if (_this.hovered === value) return 'calc(' + (100. / (sections.length - 1) + hoverBonus) + '% - ' + selectWidth / (sections.length - 1) + '%)';\n                    return 'calc(' + (100. - (100. / (sections.length - 1) + hoverBonus)) / (sections.length - 2) + '% - ' + selectWidth / (sections.length - 1) + '%)';\n                }\n            };\n\n            this.active = activeSection || this.active;\n\n            // Button bar\n            return (0, _mithril2.default)('div#' + id + '.btn-group[data-toggle=buttons]', (0, _common.mergeAttributes)({ style: { 'width': '100%' } }, attrsAll), sections.map(function (section) {\n                return (\n                    // Individual buttons\n                    (0, _mithril2.default)('#' + (section.id || 'btn' + section.value) + '.btn.btn-default\\n                    ' + (section.value.toLowerCase() === (activeSection || _this.active).toLowerCase() ? '.active' : ''), (0, _common.mergeAttributes)({\n                        onmouseover: function onmouseover() {\n                            return _this.hovered = section.value;\n                        },\n                        onmouseout: function onmouseout() {\n                            return _this.hovered = undefined;\n                        },\n                        style: { width: getWidth(section.value) },\n                        onclick: function onclick() {\n                            _this.active = section.value;\n                            _onclick(section.value);\n                        }\n                    }, attrsButtons, section.attrsInterface), [(0, _mithril2.default)('input#' + id + section.value, { 'name': id, 'title': section.title, 'type': 'radio' }), section.value])\n                );\n            }));\n        }\n    }]);\n\n    return ButtonRadio;\n}();\n\nexports.default = ButtonRadio;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvY29tbW9uL2FwcC92aWV3cy9CdXR0b25SYWRpby5qcz9iYTVhIl0sIm5hbWVzIjpbIkJ1dHRvblJhZGlvIiwidm5vZGUiLCJhdHRycyIsImFjdGl2ZVNlY3Rpb24iLCJkZWZhdWx0U2VjdGlvbiIsInNlY3Rpb25zIiwiYWN0aXZlIiwibGVuZ3RoIiwidmFsdWUiLCJ1bmRlZmluZWQiLCJpZCIsIm9uY2xpY2siLCJzZWxlY3RXaWR0aCIsImhvdmVyQm9udXMiLCJhdHRyc0FsbCIsImF0dHJzQnV0dG9ucyIsImdldFdpZHRoIiwiaG92ZXJlZCIsInN0eWxlIiwibWFwIiwic2VjdGlvbiIsInRvTG93ZXJDYXNlIiwib25tb3VzZW92ZXIiLCJvbm1vdXNlb3V0Iiwid2lkdGgiLCJhdHRyc0ludGVyZmFjZSIsInRpdGxlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7O0FBQ0E7Ozs7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztJQUVxQkEsVzs7Ozs7OzsrQkFDVkMsSyxFQUFPO0FBQUEsK0JBQ3NDQSxNQUFNQyxLQUQ1QztBQUFBLGdCQUNMQyxhQURLLGdCQUNMQSxhQURLO0FBQUEsZ0JBQ1VDLGNBRFYsZ0JBQ1VBLGNBRFY7QUFBQSxnQkFDMEJDLFFBRDFCLGdCQUMwQkEsUUFEMUI7QUFFVjs7QUFDQSxpQkFBS0MsTUFBTCxHQUFjSCxpQkFBaUJDLGNBQWpCLElBQW1DQyxTQUFTRSxNQUFULEtBQW9CLENBQXZELEdBQTJERixTQUFTLENBQVQsRUFBWUcsS0FBdkUsR0FBK0VDLFNBQTdGO0FBQ0g7Ozs2QkFFSVIsSyxFQUFPO0FBQUE7O0FBQUEsZ0NBQ3NGQSxNQUFNQyxLQUQ1RjtBQUFBLGdCQUNIUSxF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QUErQmUsV0FBL0IsRUFBaEMsR0FBK0UsU0FBL0UsR0FBMkYsRUFEakcsR0FHSSw2QkFBZ0I7QUFDWkMscUNBQWE7QUFBQSxtQ0FBTSxNQUFLTCxPQUFMLEdBQWVHLFFBQVFaLEtBQTdCO0FBQUEseUJBREQ7QUFFWmUsb0NBQVk7QUFBQSxtQ0FBTSxNQUFLTixPQUFMLEdBQWVSLFNBQXJCO0FBQUEseUJBRkE7QUFHWlMsK0JBQU8sRUFBQ00sT0FBT1IsU0FBU0ksUUFBUVosS0FBakIsQ0FBUixFQUhLO0FBSVpHLGlDQUFTLG1CQUFNO0FBQ1gsa0NBQUtMLE1BQUwsR0FBY2MsUUFBUVosS0FBdEI7QUFDQUcscUNBQVFTLFFBQVFaLEtBQWhCO0FBQ0g7QUFQVyxxQkFBaEIsRUFRR08sWUFSSCxFQVFpQkssUUFBUUssY0FSekIsQ0FISixFQVlJLENBQ0ksa0NBQVdmLEVBQVgsR0FBZ0JVLFFBQVFaLEtBQXhCLEVBQWlDLEVBQUMsUUFBUUUsRUFBVCxFQUFhLFNBQVNVLFFBQVFNLEtBQTlCLEVBQXFDLFFBQVEsT0FBN0MsRUFBakMsQ0FESixFQUVJTixRQUFRWixLQUZaLENBWko7QUFGUztBQUFBLGFBQWIsQ0FERyxDQUFQO0FBcUJIOzs7Ozs7a0JBOURnQlIsVyIsImZpbGUiOiI4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCdcbmltcG9ydCB7bWVyZ2VBdHRyaWJ1dGVzfSBmcm9tICcuLi9jb21tb24nXG5cbi8vIEludGVyZmFjZSBzcGVjaWZpY2F0aW9uXG4vL1xuLy8gYGBgXG4vLyBtKEJ1dHRvblJhZGlvLCB7XG4vLyAgICAgc2VjdGlvbnM6IFtcbi8vICAgICAgICAgICAgIHtcbi8vICAgICAgICAgICAgICAgICB2YWx1ZTogJ0J1dHRvbiAxJyxcbi8vICAgICAgICAgICAgICAgICB0aXRsZTogJ0hvdmVyIHRleHQnLFxuLy8gICAgICAgICAgICAgICAgIGF0dHJzSW50ZXJmYWNlOiB7b3B0aW9uYWwgb2JqZWN0IG9mIGF0dHJpYnV0ZXN9XG4vLyAgICAgICAgICAgICB9LFxuLy8gICAgICAgICAgICAgLi4uXG4vLyAgICAgICAgIF0sXG4vLyAgICAgZGVmYXVsdFNlY3Rpb246IHN0cmluZyAob3B0aW9uYWwpLFxuLy8gICAgIGFjdGl2ZVNlY3Rpb246IHN0cmluZyAob3B0aW9uYWwpLFxuLy8gICAgIG9uY2xpY2s6ICh2YWx1ZSkgPT4gY29uc29sZS5sb2codmFsdWUgKyBcIiB3YXMgY2xpY2tlZC5cIilcbi8vICAgICBhdHRyc0FsbDoge29wdGlvbmFsIG9iamVjdCBvZiBhdHRyaWJ1dGVzIHRvIGFwcGx5IHRvIHRoZSBiYXJ9XG4vLyAgICAgYXR0cnNCdXR0b25zOiB7b3B0aW9uYWwgb2JqZWN0IG9mIGF0dHJpYnV0ZXMgdG8gYXBwbHkgdG8gYWxsIGJ1dHRvbnN9XG4vLyAgICAgc2VsZWN0V2lkdGg6IDIwIChvcHRpb25hbCBpbnQpLFxuLy8gICAgIGhvdmVyQm9udXM6IDEwIChvcHRpb25hbCBpbnQpXG4vLyAgICAgfSlcbi8vIGBgYFxuXG4vLyBUaGUgc2VsZWN0V2lkdGggb3B0aW9uIGZvcmNlcyB0aGUgc2VsZWN0ZWQgYnV0dG9uIHRvIGJlIG4gcGVyY2VudCB3aWRlLlxuLy8gVGhlIG90aGVyIGJ1dHRvbnMgb24gdGhlIGJhciBjb21wZW5zYXRlLlxuLy8gSWYgbm90IGluY2x1ZGVkLCB0aGVuIGV2ZXJ5IGJ1dHRvbiBoYXMgZXZlbiBzcGFjaW5nLlxuXG4vLyBUaGUgaG92ZXJCb251cyBvcHRpb24gbWFrZXMgdGhlIGhvdmVyZWQgYnV0dG9uIG4gcGVyY2VudCBsYXJnZXIgd2hlbiBob3ZlcmVkLlxuLy8gQm90aCBob3ZlckJvbnVzIGFuZCBzZWxlY3RXaWR0aCBtYXkgYmUgdXNlZCB0b2dldGhlci4gT24gYm90aCwgZG9uJ3QgcGFzcyBhIHN0cmluZyUsIHBhc3MgdGhlIG51bWVyaWMuXG5cbi8vIGRlZmF1bHRTZWN0aW9uIHNldHMgd2hpY2ggZWxlbWVudCBpcyBzZWxlY3RlZCBvbiBwYWdlIGxvYWRcbi8vIGFjdGl2ZVNlbGVjdGlvbiBmb3JjZXMgdGhlIHNlbGVjdGVkIGVsZW1lbnQuIFRoaXMgaXMgZm9yIGNvbnZlbmllbmNlIHdoZW4gZXh0ZXJuYWwgZXZlbnRzIGNoYW5nZSB0aGUgc2VsZWN0ZWQgYnV0dG9uXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJ1dHRvblJhZGlvIHtcbiAgICBvbmluaXQodm5vZGUpIHtcbiAgICAgICAgbGV0IHthY3RpdmVTZWN0aW9uLCBkZWZhdWx0U2VjdGlvbiwgc2VjdGlvbnN9ID0gdm5vZGUuYXR0cnM7XG4gICAgICAgIC8vIEF0dGVtcHQgdG8gc2V0IGFjdGl2ZSBvbiBpbml0aWFsIGxvYWQgYmFzZWQgb24gb3B0aW9uc1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IGFjdGl2ZVNlY3Rpb24gfHwgZGVmYXVsdFNlY3Rpb24gfHwgc2VjdGlvbnMubGVuZ3RoICE9PSAwID8gc2VjdGlvbnNbMF0udmFsdWUgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdmlldyh2bm9kZSkge1xuICAgICAgICBsZXQge2lkLCBzZWN0aW9ucywgb25jbGljaywgc2VsZWN0V2lkdGgsIGhvdmVyQm9udXMsIGF0dHJzQWxsLCBhdHRyc0J1dHRvbnMsIGFjdGl2ZVNlY3Rpb259ID0gdm5vZGUuYXR0cnM7XG5cbiAgICAgICAgLy8gU29ycnkgYWJvdXQgdGhlIGNvbXBsZXhpdHkgaGVyZS4gR290IHN0dWNrIHdpdGggYSBsb3Qgb2YgY2FzZXNcbiAgICAgICAgbGV0IGdldFdpZHRoID0gKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAvLyBFdmVubHkgc3BhY2VkXG4gICAgICAgICAgICBpZiAoc2VsZWN0V2lkdGggPT09IHVuZGVmaW5lZCAmJiAoaG92ZXJCb251cyA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuaG92ZXJlZCA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxMDAuIC8gc2VjdGlvbnMubGVuZ3RoICsgJyUnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGaXhlZCB3aWR0aCBvZiBzZWxlY3RlZCBidXR0b25cbiAgICAgICAgICAgIGlmIChzZWxlY3RXaWR0aCAhPT0gdW5kZWZpbmVkICYmIChob3ZlckJvbnVzID09PSB1bmRlZmluZWQgfHwgdGhpcy5ob3ZlcmVkID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlID09PSB2YWx1ZSkgcmV0dXJuIHNlbGVjdFdpZHRoICsgJyUnO1xuICAgICAgICAgICAgICAgIHJldHVybiBgY2FsYygkezEwMC4gLyAoc2VjdGlvbnMubGVuZ3RoIC0gMSl9JSAtICR7c2VsZWN0V2lkdGggLyAoc2VjdGlvbnMubGVuZ3RoIC0gMSl9JSlgO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBIb3ZlcmluZyBpcyB0dXJuZWQgb24gYW5kIGEgYnV0dG9uIGlzIGhvdmVyZWRcbiAgICAgICAgICAgIGlmIChzZWxlY3RXaWR0aCA9PT0gdW5kZWZpbmVkICYmIGhvdmVyQm9udXMgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmhvdmVyZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhvdmVyZWQgPT09IHZhbHVlKSByZXR1cm4gMTAwLiAvIHNlY3Rpb25zLmxlbmd0aCArIGhvdmVyQm9udXMgKyAnJSc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDEwMC4gLyBzZWN0aW9ucy5sZW5ndGggLSAoaG92ZXJCb251cyAvIChzZWN0aW9ucy5sZW5ndGggLSAxKSkgKyAnJSc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZpeGVkIHdpZHRoIG9mIHNlbGVjdGVkIGJ1dHRvbiBhbmQgYnV0dG9uIHJlc2l6ZSBvbiBob3ZlclxuICAgICAgICAgICAgaWYgKHNlbGVjdFdpZHRoICE9PSB1bmRlZmluZWQgJiYgaG92ZXJCb251cyAhPT0gdW5kZWZpbmVkICYmIHRoaXMuaG92ZXJlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlID09PSB2YWx1ZSkgcmV0dXJuIHNlbGVjdFdpZHRoICsgJyUnO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhvdmVyZWQgPT09IHRoaXMuYWN0aXZlKSByZXR1cm4gYGNhbGMoJHsxMDAuIC8gKHNlY3Rpb25zLmxlbmd0aCAtIDEpfSUgLSAke3NlbGVjdFdpZHRoIC8gKHNlY3Rpb25zLmxlbmd0aCAtIDEpfSUpYDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ob3ZlcmVkID09PSB2YWx1ZSkgcmV0dXJuIGBjYWxjKCR7MTAwLiAvIChzZWN0aW9ucy5sZW5ndGggLSAxKSArIGhvdmVyQm9udXN9JSAtICR7c2VsZWN0V2lkdGggLyAoc2VjdGlvbnMubGVuZ3RoIC0gMSl9JSlgO1xuICAgICAgICAgICAgICAgIHJldHVybiBgY2FsYygkeygxMDAuIC0gKDEwMC4gLyAoc2VjdGlvbnMubGVuZ3RoIC0gMSkgKyBob3ZlckJvbnVzKSkgLyAoc2VjdGlvbnMubGVuZ3RoIC0gMil9JSAtICR7c2VsZWN0V2lkdGggLyAoc2VjdGlvbnMubGVuZ3RoIC0gMSl9JSlgO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuYWN0aXZlID0gYWN0aXZlU2VjdGlvbiB8fCB0aGlzLmFjdGl2ZTtcblxuICAgICAgICAvLyBCdXR0b24gYmFyXG4gICAgICAgIHJldHVybiBtKGBkaXYjJHtpZH0uYnRuLWdyb3VwW2RhdGEtdG9nZ2xlPWJ1dHRvbnNdYCwgbWVyZ2VBdHRyaWJ1dGVzKHtzdHlsZTogeyd3aWR0aCc6ICcxMDAlJ319LCBhdHRyc0FsbCksXG4gICAgICAgICAgICBzZWN0aW9ucy5tYXAoKHNlY3Rpb24pID0+XG4gICAgICAgICAgICAgICAgLy8gSW5kaXZpZHVhbCBidXR0b25zXG4gICAgICAgICAgICAgICAgbShgIyR7c2VjdGlvbi5pZCB8fCAnYnRuJyArIHNlY3Rpb24udmFsdWV9LmJ0bi5idG4tZGVmYXVsdFxuICAgICAgICAgICAgICAgICAgICAke3NlY3Rpb24udmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gKGFjdGl2ZVNlY3Rpb24gfHwgdGhpcy5hY3RpdmUpLnRvTG93ZXJDYXNlKCkgPyAnLmFjdGl2ZScgOiAnJ31gLFxuXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlQXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbm1vdXNlb3ZlcjogKCkgPT4gdGhpcy5ob3ZlcmVkID0gc2VjdGlvbi52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ubW91c2VvdXQ6ICgpID0+IHRoaXMuaG92ZXJlZCA9IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7d2lkdGg6IGdldFdpZHRoKHNlY3Rpb24udmFsdWUpfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uY2xpY2s6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IHNlY3Rpb24udmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25jbGljayhzZWN0aW9uLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgYXR0cnNCdXR0b25zLCBzZWN0aW9uLmF0dHJzSW50ZXJmYWNlKSxcbiAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgbShgaW5wdXQjJHtpZH0ke3NlY3Rpb24udmFsdWV9YCwgeyduYW1lJzogaWQsICd0aXRsZSc6IHNlY3Rpb24udGl0bGUsICd0eXBlJzogJ3JhZGlvJ30pLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VjdGlvbi52YWx1ZVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgKSlcbiAgICAgICAgKTtcbiAgICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYXNzZXRzL2NvbW1vbi9hcHAvdmlld3MvQnV0dG9uUmFkaW8uanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mithril = __webpack_require__(0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _common = __webpack_require__(1);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Header = function () {\n    function Header() {\n        _classCallCheck(this, Header);\n    }\n\n    _createClass(Header, [{\n        key: 'oninit',\n        value: function oninit() {\n            this.about = false;\n        }\n    }, {\n        key: 'view',\n        value: function view(vnode) {\n            var _this = this;\n\n            return (0, _mithril2.default)(\"nav#navbar.navbar.navbar-default.navbar-fixed-top[role=navigation]\", (0, _common.mergeAttributes)({\n                style: {\n                    background: _common.menuColor,\n                    height: _common.heightHeader\n                }\n            }, vnode.attrs), [(0, _mithril2.default)(\"a.navbar-brand\", (0, _mithril2.default)(\"img[src=/static/images/TwoRavens.png][alt=TwoRavens][width=100][style=margin-left: 1em; margin-top: -0.5em]\", { onmouseover: function onmouseover(_) {\n                    return _this.about = true;\n                }, onmouseout: function onmouseout(_) {\n                    return _this.about = false;\n                } })), (0, _mithril2.default)('#about.panel.panel-default[style=display: ' + (this.about ? 'block' : 'none') + '; left: 140px; position: absolute; width: 500px; z-index: 50]', (0, _mithril2.default)('.panel-body', _common.aboutText)), (0, _mithril2.default)('div', { style: { 'display': 'flex', 'justify-content': 'flex-end', 'align-items': 'center', 'height': '100%' } }, vnode.children)]);\n        }\n    }]);\n\n    return Header;\n}();\n\nexports.default = Header;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvY29tbW9uL2FwcC92aWV3cy9IZWFkZXIuanM/NWE3YiJdLCJuYW1lcyI6WyJIZWFkZXIiLCJhYm91dCIsInZub2RlIiwic3R5bGUiLCJiYWNrZ3JvdW5kIiwiaGVpZ2h0IiwiYXR0cnMiLCJvbm1vdXNlb3ZlciIsIm9ubW91c2VvdXQiLCJjaGlsZHJlbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7OztBQUVBOzs7Ozs7SUFFcUJBLE07Ozs7Ozs7aUNBQ1I7QUFDTCxpQkFBS0MsS0FBTCxHQUFhLEtBQWI7QUFDSDs7OzZCQUVJQyxLLEVBQU87QUFBQTs7QUFDUixtQkFBTyx1QkFBRSxvRUFBRixFQUF3RSw2QkFBZ0I7QUFDM0ZDLHVCQUFPO0FBQ0hDLGlEQURHO0FBRUhDO0FBRkc7QUFEb0YsYUFBaEIsRUFLNUVILE1BQU1JLEtBTHNFLENBQXhFLEVBS1UsQ0FDYix1QkFBRSxnQkFBRixFQUNFLHVCQUFFLDZHQUFGLEVBQ0UsRUFBQ0MsYUFBYTtBQUFBLDJCQUFLLE1BQUtOLEtBQUwsR0FBYSxJQUFsQjtBQUFBLGlCQUFkLEVBQXNDTyxZQUFZO0FBQUEsMkJBQUssTUFBS1AsS0FBTCxHQUFhLEtBQWxCO0FBQUEsaUJBQWxELEVBREYsQ0FERixDQURhLEVBSWIsdUVBQStDLEtBQUtBLEtBQUwsR0FBYSxPQUFiLEdBQXVCLE1BQXRFLHFFQUNFLHVCQUFFLGFBQUYsb0JBREYsQ0FKYSxFQU1iLHVCQUFFLEtBQUYsRUFBUyxFQUFDRSxPQUFPLEVBQUMsV0FBVyxNQUFaLEVBQW9CLG1CQUFtQixVQUF2QyxFQUFtRCxlQUFlLFFBQWxFLEVBQTRFLFVBQVUsTUFBdEYsRUFBUixFQUFULEVBQWlIRCxNQUFNTyxRQUF2SCxDQU5hLENBTFYsQ0FBUDtBQWFIOzs7Ozs7a0JBbkJnQlQsTSIsImZpbGUiOiI5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCc7XG5cbmltcG9ydCB7YWJvdXRUZXh0LCBtZW51Q29sb3IsIGhlaWdodEhlYWRlciwgbWVyZ2VBdHRyaWJ1dGVzfSBmcm9tICcuLi9jb21tb24nO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIZWFkZXIge1xuICAgIG9uaW5pdCgpIHtcbiAgICAgICAgdGhpcy5hYm91dCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZpZXcodm5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG0oXCJuYXYjbmF2YmFyLm5hdmJhci5uYXZiYXItZGVmYXVsdC5uYXZiYXItZml4ZWQtdG9wW3JvbGU9bmF2aWdhdGlvbl1cIiwgbWVyZ2VBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZDogbWVudUNvbG9yLFxuICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0SGVhZGVyXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHZub2RlLmF0dHJzKSwgW1xuICAgICAgICAgICAgbShcImEubmF2YmFyLWJyYW5kXCIsXG4gICAgICAgICAgICAgIG0oXCJpbWdbc3JjPS9zdGF0aWMvaW1hZ2VzL1R3b1JhdmVucy5wbmddW2FsdD1Ud29SYXZlbnNdW3dpZHRoPTEwMF1bc3R5bGU9bWFyZ2luLWxlZnQ6IDFlbTsgbWFyZ2luLXRvcDogLTAuNWVtXVwiLFxuICAgICAgICAgICAgICAgIHtvbm1vdXNlb3ZlcjogXyA9PiB0aGlzLmFib3V0ID0gdHJ1ZSwgb25tb3VzZW91dDogXyA9PiB0aGlzLmFib3V0ID0gZmFsc2V9KSksXG4gICAgICAgICAgICBtKGAjYWJvdXQucGFuZWwucGFuZWwtZGVmYXVsdFtzdHlsZT1kaXNwbGF5OiAke3RoaXMuYWJvdXQgPyAnYmxvY2snIDogJ25vbmUnfTsgbGVmdDogMTQwcHg7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgd2lkdGg6IDUwMHB4OyB6LWluZGV4OiA1MF1gLFxuICAgICAgICAgICAgICBtKCcucGFuZWwtYm9keScsIGFib3V0VGV4dCkpLFxuICAgICAgICAgICAgbSgnZGl2Jywge3N0eWxlOiB7J2Rpc3BsYXknOiAnZmxleCcsICdqdXN0aWZ5LWNvbnRlbnQnOiAnZmxleC1lbmQnLCAnYWxpZ24taXRlbXMnOiAnY2VudGVyJywgJ2hlaWdodCc6ICcxMDAlJ319LCB2bm9kZS5jaGlsZHJlbilcbiAgICAgICAgXSk7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYXNzZXRzL2NvbW1vbi9hcHAvdmlld3MvSGVhZGVyLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9\n")},function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nexports.setModal = setModal;\n\nvar _mithril = __webpack_require__(0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nvar text = "Default modal text";\nvar header = "Default modal header";\nvar btnDisplay = \'block\';\nvar close = false;\nvar func = function func(_) {};\nvar btnText = "Close";\nvar vis = false;\n\n// text and header are text\n// show is boolean\n// btnText is the text to go inside the button (eg "Reset"), but if false then no button appears\n// func is the function to execute when button is clicked\nfunction setModal(text_, header_, show, btnText_, close_, func_) {\n    if (text_) text = text_;\n    if (header_) header = header_;\n    if (btnText_) {\n        btnText = btnText_;\n        close = close_;\n        btnDisplay = \'block\';\n    } else {\n        btnDisplay = \'none\';\n    };\n    if (func_) func = func_;\n    _mithril2.default.redraw();\n    show ? $(\'#modal\').modal({ show: show, backdrop: \'static\', keyboard: false }) : $(\'#modal\').modal("hide");\n}\n\nvar Modal = function () {\n    function Modal() {\n        _classCallCheck(this, Modal);\n    }\n\n    _createClass(Modal, [{\n        key: "view",\n        value: function view(vnode) {\n            return (0, _mithril2.default)(".modal.fade[id=modal][role=dialog]", [(0, _mithril2.default)(".modal-dialog", (0, _mithril2.default)(".modal-content", [(0, _mithril2.default)(".modal-header", (0, _mithril2.default)("h4.modal-title", header)), (0, _mithril2.default)(".modal-body", (0, _mithril2.default)("p", text)), (0, _mithril2.default)(".modal-footer", (0, _mithril2.default)("button.btn.btn-default[type=button]", { style: { display: btnDisplay, float: \'right\' },\n                onclick: function onclick(_) {\n                    if (close) {\n                        close = false;\n                        $(\'#modal\').modal(\'hide\');\n                        return;\n                    }\n                    func();\n                } }, btnText))]))]);\n        }\n    }]);\n\n    return Modal;\n}();\n\nexports.default = Modal;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvY29tbW9uL2FwcC92aWV3cy9Nb2RhbC5qcz8yN2U5Il0sIm5hbWVzIjpbInNldE1vZGFsIiwidGV4dCIsImhlYWRlciIsImJ0bkRpc3BsYXkiLCJjbG9zZSIsImZ1bmMiLCJidG5UZXh0IiwidmlzIiwidGV4dF8iLCJoZWFkZXJfIiwic2hvdyIsImJ0blRleHRfIiwiY2xvc2VfIiwiZnVuY18iLCJyZWRyYXciLCIkIiwibW9kYWwiLCJiYWNrZHJvcCIsImtleWJvYXJkIiwiTW9kYWwiLCJ2bm9kZSIsInN0eWxlIiwiZGlzcGxheSIsImZsb2F0Iiwib25jbGljayJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7UUFjZ0JBLFEsR0FBQUEsUTs7QUFkaEI7Ozs7Ozs7O0FBRUEsSUFBSUMsT0FBTyxvQkFBWDtBQUNBLElBQUlDLFNBQVMsc0JBQWI7QUFDQSxJQUFJQyxhQUFhLE9BQWpCO0FBQ0EsSUFBSUMsUUFBUSxLQUFaO0FBQ0EsSUFBSUMsT0FBTyxpQkFBSyxDQUFFLENBQWxCO0FBQ0EsSUFBSUMsVUFBVSxPQUFkO0FBQ0EsSUFBSUMsTUFBTSxLQUFWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sU0FBU1AsUUFBVCxDQUFrQlEsS0FBbEIsRUFBeUJDLE9BQXpCLEVBQWtDQyxJQUFsQyxFQUF3Q0MsUUFBeEMsRUFBa0RDLE1BQWxELEVBQTBEQyxLQUExRCxFQUFpRTtBQUNwRSxRQUFJTCxLQUFKLEVBQVdQLE9BQU9PLEtBQVA7QUFDWCxRQUFJQyxPQUFKLEVBQWFQLFNBQVNPLE9BQVQ7QUFDYixRQUFJRSxRQUFKLEVBQWM7QUFDVkwsa0JBQVVLLFFBQVY7QUFDQVAsZ0JBQVFRLE1BQVI7QUFDQVQscUJBQWEsT0FBYjtBQUNILEtBSkQsTUFJTztBQUNIQSxxQkFBYSxNQUFiO0FBQ0g7QUFDRCxRQUFJVSxLQUFKLEVBQVdSLE9BQU9RLEtBQVA7QUFDWCxzQkFBRUMsTUFBRjtBQUNBSixXQUFPSyxFQUFFLFFBQUYsRUFBWUMsS0FBWixDQUFrQixFQUFDTixVQUFELEVBQU9PLFVBQVUsUUFBakIsRUFBMkJDLFVBQVUsS0FBckMsRUFBbEIsQ0FBUCxHQUF3RUgsRUFBRSxRQUFGLEVBQVlDLEtBQVosQ0FBa0IsTUFBbEIsQ0FBeEU7QUFDSDs7SUFFb0JHLEs7Ozs7Ozs7NkJBQ1pDLEssRUFBTztBQUNSLG1CQUFPLHVCQUFFLG9DQUFGLEVBQXdDLENBQzNDLHVCQUFFLGVBQUYsRUFDRSx1QkFBRSxnQkFBRixFQUFvQixDQUNoQix1QkFBRSxlQUFGLEVBQ0UsdUJBQUUsZ0JBQUYsRUFBb0JsQixNQUFwQixDQURGLENBRGdCLEVBR2hCLHVCQUFFLGFBQUYsRUFDRSx1QkFBRSxHQUFGLEVBQU9ELElBQVAsQ0FERixDQUhnQixFQUtoQix1QkFBRSxlQUFGLEVBQ0UsdUJBQUUscUNBQUYsRUFDRSxFQUFDb0IsT0FBTyxFQUFDQyxTQUFTbkIsVUFBVixFQUFzQm9CLE9BQU8sT0FBN0IsRUFBUjtBQUNDQyx5QkFBUyxvQkFBSztBQUNWLHdCQUFJcEIsS0FBSixFQUFXO0FBQ1BBLGdDQUFRLEtBQVI7QUFDQVcsMEJBQUUsUUFBRixFQUFZQyxLQUFaLENBQWtCLE1BQWxCO0FBQ0E7QUFDSDtBQUNEWDtBQUNILGlCQVJGLEVBREYsRUFVRUMsT0FWRixDQURGLENBTGdCLENBQXBCLENBREYsQ0FEMkMsQ0FBeEMsQ0FBUDtBQXFCSDs7Ozs7O2tCQXZCZ0JhLEsiLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbSBmcm9tICdtaXRocmlsJztcblxubGV0IHRleHQgPSBcIkRlZmF1bHQgbW9kYWwgdGV4dFwiO1xubGV0IGhlYWRlciA9IFwiRGVmYXVsdCBtb2RhbCBoZWFkZXJcIjtcbmxldCBidG5EaXNwbGF5ID0gJ2Jsb2NrJztcbmxldCBjbG9zZSA9IGZhbHNlO1xubGV0IGZ1bmMgPSBfID0+IHt9O1xubGV0IGJ0blRleHQgPSBcIkNsb3NlXCI7XG5sZXQgdmlzID0gZmFsc2U7XG5cbi8vIHRleHQgYW5kIGhlYWRlciBhcmUgdGV4dFxuLy8gc2hvdyBpcyBib29sZWFuXG4vLyBidG5UZXh0IGlzIHRoZSB0ZXh0IHRvIGdvIGluc2lkZSB0aGUgYnV0dG9uIChlZyBcIlJlc2V0XCIpLCBidXQgaWYgZmFsc2UgdGhlbiBubyBidXR0b24gYXBwZWFyc1xuLy8gZnVuYyBpcyB0aGUgZnVuY3Rpb24gdG8gZXhlY3V0ZSB3aGVuIGJ1dHRvbiBpcyBjbGlja2VkXG5leHBvcnQgZnVuY3Rpb24gc2V0TW9kYWwodGV4dF8sIGhlYWRlcl8sIHNob3csIGJ0blRleHRfLCBjbG9zZV8sIGZ1bmNfKSB7XG4gICAgaWYgKHRleHRfKSB0ZXh0ID0gdGV4dF87XG4gICAgaWYgKGhlYWRlcl8pIGhlYWRlciA9IGhlYWRlcl87XG4gICAgaWYgKGJ0blRleHRfKSB7XG4gICAgICAgIGJ0blRleHQgPSBidG5UZXh0XztcbiAgICAgICAgY2xvc2UgPSBjbG9zZV87XG4gICAgICAgIGJ0bkRpc3BsYXkgPSAnYmxvY2snO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGJ0bkRpc3BsYXkgPSAnbm9uZSc7XG4gICAgfTtcbiAgICBpZiAoZnVuY18pIGZ1bmMgPSBmdW5jXztcbiAgICBtLnJlZHJhdygpO1xuICAgIHNob3cgPyAkKCcjbW9kYWwnKS5tb2RhbCh7c2hvdywgYmFja2Ryb3A6ICdzdGF0aWMnLCBrZXlib2FyZDogZmFsc2V9KSA6ICQoJyNtb2RhbCcpLm1vZGFsKFwiaGlkZVwiKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW9kYWwge1xuICAgIHZpZXcodm5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG0oXCIubW9kYWwuZmFkZVtpZD1tb2RhbF1bcm9sZT1kaWFsb2ddXCIsIFtcbiAgICAgICAgICAgIG0oXCIubW9kYWwtZGlhbG9nXCIsXG4gICAgICAgICAgICAgIG0oXCIubW9kYWwtY29udGVudFwiLCBbXG4gICAgICAgICAgICAgICAgICBtKFwiLm1vZGFsLWhlYWRlclwiLFxuICAgICAgICAgICAgICAgICAgICBtKFwiaDQubW9kYWwtdGl0bGVcIiwgaGVhZGVyKSksXG4gICAgICAgICAgICAgICAgICBtKFwiLm1vZGFsLWJvZHlcIixcbiAgICAgICAgICAgICAgICAgICAgbShcInBcIiwgdGV4dCkpLFxuICAgICAgICAgICAgICAgICAgbShcIi5tb2RhbC1mb290ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgbShcImJ1dHRvbi5idG4uYnRuLWRlZmF1bHRbdHlwZT1idXR0b25dXCIsXG4gICAgICAgICAgICAgICAgICAgICAge3N0eWxlOiB7ZGlzcGxheTogYnRuRGlzcGxheSwgZmxvYXQ6ICdyaWdodCd9LFxuICAgICAgICAgICAgICAgICAgICAgICBvbmNsaWNrOiBfID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbG9zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJCgnI21vZGFsJykubW9kYWwoJ2hpZGUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jKCk7XG4gICAgICAgICAgICAgICAgICAgICAgIH19LFxuICAgICAgICAgICAgICAgICAgICAgIGJ0blRleHQpKVxuICAgICAgICAgICAgICBdKSlcbiAgICAgICAgXSk7XG4gICAgfVxufVxuXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9hc3NldHMvY29tbW9uL2FwcC92aWV3cy9Nb2RhbC5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///10\n')},function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mithril = __webpack_require__(0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _common = __webpack_require__(1);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// Interface specification\n//\n// ```\n// m(Table, {\n//     id: id (String),\n//     headers: ['col1Header', 'col2Header'],\n//     data: [['row1col1', 'row1col2'], ['row2col1', 'row2col2']] or function\n//     activeRow: 'row1col1', (optional)\n//     onclick: (uid, colID) => console.log(uid + \" row was clicked, column number \" + colID + \" was clicked\"), (optional)\n//     showUID: true | false, (optional)\n//\n//     attrsAll: { apply attributes to all divs },(optional)\n//     attrsRows: { apply attributes to each row }, (optional)\n//     attrsCells: { apply attributes to each cell } (optional)\n//     tableTags: [ m('colgroup', ...), m('caption', ...), m('tfoot', ...)]\n//     })\n// ```\n\n// The UID for the table is the key for identifying a certain row.\n// The UID is the first column, and its value is passed in the onclick callback.\n// The first column may be hidden via showUID: false. This does not remove the first header\n\n// Table tags allows passing colgroups, captions, etc. into the table manually. Can be a single element or list\n\nvar Table = function () {\n    function Table() {\n        _classCallCheck(this, Table);\n    }\n\n    _createClass(Table, [{\n        key: 'view',\n        value: function view(vnode) {\n            var _vnode$attrs = vnode.attrs,\n                id = _vnode$attrs.id,\n                data = _vnode$attrs.data,\n                headers = _vnode$attrs.headers,\n                activeRow = _vnode$attrs.activeRow,\n                _onclick = _vnode$attrs.onclick,\n                showUID = _vnode$attrs.showUID,\n                abbreviation = _vnode$attrs.abbreviation;\n            // Interface custom attributes\n\n            var _vnode$attrs2 = vnode.attrs,\n                attrsAll = _vnode$attrs2.attrsAll,\n                attrsRows = _vnode$attrs2.attrsRows,\n                attrsCells = _vnode$attrs2.attrsCells,\n                tableTags = _vnode$attrs2.tableTags;\n\n\n            showUID = showUID !== false; // Default is 'true'\n            if (typeof data === 'function') data = data();\n\n            // if abbreviation is not undefined, and string is too long, then shorten the string and add a tooltop\n            var abbreviate = function abbreviate(item) {\n                if (typeof item === 'string' && item.length > abbreviation) {\n                    return (0, _mithril2.default)('div', { 'data-toggle': 'tooltip', title: item }, item.substring(0, abbreviation - 3).trim() + '...');\n                } else return item;\n            };\n\n            return (0, _mithril2.default)('table.table#' + id, (0, _common.mergeAttributes)({ style: { width: '100%' } }, attrsAll), [tableTags, headers ? (0, _mithril2.default)('tr', { style: { width: '100%', background: _common.menuColor } }, [].concat(_toConsumableArray((showUID ? headers : headers.slice(1)).map(function (header) {\n                return (0, _mithril2.default)('th', abbreviate(header));\n            })))) : undefined].concat(_toConsumableArray(data.map(function (row, i) {\n                return (0, _mithril2.default)('tr', (0, _common.mergeAttributes)(i % 2 === 1 ? { style: { 'background': '#fcfcfc' } } : {}, row[0] === activeRow ? { style: { 'background': _common.selVarColor } } : {}, attrsRows), row.filter(function (item, j) {\n                    return j !== 0 || showUID;\n                }).map(function (item, j) {\n                    return (0, _mithril2.default)('td', (0, _common.mergeAttributes)(_onclick ? { onclick: function onclick() {\n                            return _onclick(row[0], j);\n                        } } : {}, attrsCells), abbreviate(item));\n                }));\n            }))));\n        }\n    }]);\n\n    return Table;\n}();\n\nexports.default = Table;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvY29tbW9uL2FwcC92aWV3cy9UYWJsZS5qcz9hYTQ1Il0sIm5hbWVzIjpbIlRhYmxlIiwidm5vZGUiLCJhdHRycyIsImlkIiwiZGF0YSIsImhlYWRlcnMiLCJhY3RpdmVSb3ciLCJvbmNsaWNrIiwic2hvd1VJRCIsImFiYnJldmlhdGlvbiIsImF0dHJzQWxsIiwiYXR0cnNSb3dzIiwiYXR0cnNDZWxscyIsInRhYmxlVGFncyIsImFiYnJldmlhdGUiLCJpdGVtIiwibGVuZ3RoIiwidGl0bGUiLCJzdWJzdHJpbmciLCJ0cmltIiwic3R5bGUiLCJ3aWR0aCIsImJhY2tncm91bmQiLCJzbGljZSIsIm1hcCIsImhlYWRlciIsInVuZGVmaW5lZCIsInJvdyIsImkiLCJmaWx0ZXIiLCJqIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7O0FBRUE7Ozs7Ozs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0lBRXFCQSxLOzs7Ozs7OzZCQUNaQyxLLEVBQU87QUFBQSwrQkFDNkRBLE1BQU1DLEtBRG5FO0FBQUEsZ0JBQ0hDLEVBREcsZ0JBQ0hBLEVBREc7QUFBQSxnQkFDQ0MsSUFERCxnQkFDQ0EsSUFERDtBQUFBLGdCQUNPQyxPQURQLGdCQUNPQSxPQURQO0FBQUEsZ0JBQ2dCQyxTQURoQixnQkFDZ0JBLFNBRGhCO0FBQUEsZ0JBQzJCQyxRQUQzQixnQkFDMkJBLE9BRDNCO0FBQUEsZ0JBQ29DQyxPQURwQyxnQkFDb0NBLE9BRHBDO0FBQUEsZ0JBQzZDQyxZQUQ3QyxnQkFDNkNBLFlBRDdDO0FBRVI7O0FBRlEsZ0NBRzJDUixNQUFNQyxLQUhqRDtBQUFBLGdCQUdIUSxRQUhHLGlCQUdIQSxRQUhHO0FBQUEsZ0JBR09DLFNBSFAsaUJBR09BLFNBSFA7QUFBQSxnQkFHa0JDLFVBSGxCLGlCQUdrQkEsVUFIbEI7QUFBQSxnQkFHOEJDLFNBSDlCLGlCQUc4QkEsU0FIOUI7OztBQUtSTCxzQkFBVUEsWUFBWSxLQUF0QixDQUxRLENBS3FCO0FBQzdCLGdCQUFJLE9BQU9KLElBQVAsS0FBZ0IsVUFBcEIsRUFBZ0NBLE9BQU9BLE1BQVA7O0FBRWhDO0FBQ0EsZ0JBQUlVLGFBQWEsU0FBYkEsVUFBYSxDQUFDQyxJQUFELEVBQVU7QUFDdkIsb0JBQUksT0FBT0EsSUFBUCxLQUFpQixRQUFqQixJQUE2QkEsS0FBS0MsTUFBTCxHQUFjUCxZQUEvQyxFQUE2RDtBQUN6RCwyQkFBTyx1QkFBRSxLQUFGLEVBQVMsRUFBQyxlQUFlLFNBQWhCLEVBQTJCUSxPQUFPRixJQUFsQyxFQUFULEVBQ0hBLEtBQUtHLFNBQUwsQ0FBZSxDQUFmLEVBQWtCVCxlQUFlLENBQWpDLEVBQW9DVSxJQUFwQyxLQUE2QyxLQUQxQyxDQUFQO0FBRUgsaUJBSEQsTUFJSyxPQUFPSixJQUFQO0FBQ1IsYUFORDs7QUFRQSxtQkFBTyx3Q0FBaUJaLEVBQWpCLEVBQXVCLDZCQUFnQixFQUFDaUIsT0FBTyxFQUFDQyxPQUFPLE1BQVIsRUFBUixFQUFoQixFQUEwQ1gsUUFBMUMsQ0FBdkIsR0FDSEcsU0FERyxFQUVIUixVQUFVLHVCQUFFLElBQUYsRUFBUSxFQUFDZSxPQUFPLEVBQUNDLE9BQU8sTUFBUixFQUFnQkMsNkJBQWhCLEVBQVIsRUFBUiwrQkFDSCxDQUFDZCxVQUFVSCxPQUFWLEdBQW9CQSxRQUFRa0IsS0FBUixDQUFjLENBQWQsQ0FBckIsRUFBdUNDLEdBQXZDLENBQTJDLFVBQUNDLE1BQUQ7QUFBQSx1QkFBWSx1QkFBRSxJQUFGLEVBQVFYLFdBQVdXLE1BQVgsQ0FBUixDQUFaO0FBQUEsYUFBM0MsQ0FERyxHQUFWLEdBRUtDLFNBSkYsNEJBTUF0QixLQUFLb0IsR0FBTCxDQUFTLFVBQUNHLEdBQUQsRUFBTUMsQ0FBTjtBQUFBLHVCQUFZLHVCQUFFLElBQUYsRUFBUSw2QkFDNUJBLElBQUksQ0FBSixLQUFVLENBQVYsR0FBYyxFQUFDUixPQUFPLEVBQUMsY0FBYyxTQUFmLEVBQVIsRUFBZCxHQUFtRCxFQUR2QixFQUU1Qk8sSUFBSSxDQUFKLE1BQVdyQixTQUFYLEdBQXVCLEVBQUNjLE9BQU8sRUFBQyxpQ0FBRCxFQUFSLEVBQXZCLEdBQThELEVBRmxDLEVBRzVCVCxTQUg0QixDQUFSLEVBSXBCZ0IsSUFBSUUsTUFBSixDQUFXLFVBQUNkLElBQUQsRUFBT2UsQ0FBUDtBQUFBLDJCQUFhQSxNQUFNLENBQU4sSUFBV3RCLE9BQXhCO0FBQUEsaUJBQVgsRUFBNENnQixHQUE1QyxDQUFnRCxVQUFDVCxJQUFELEVBQU9lLENBQVA7QUFBQSwyQkFDNUMsdUJBQUUsSUFBRixFQUFRLDZCQUFnQnZCLFdBQVUsRUFBQ0EsU0FBUztBQUFBLG1DQUFNQSxTQUFRb0IsSUFBSSxDQUFKLENBQVIsRUFBZ0JHLENBQWhCLENBQU47QUFBQSx5QkFBVixFQUFWLEdBQWdELEVBQWhFLEVBQW9FbEIsVUFBcEUsQ0FBUixFQUF5RkUsV0FBV0MsSUFBWCxDQUF6RixDQUQ0QztBQUFBLGlCQUFoRCxDQUpvQixDQUFaO0FBQUEsYUFBVCxDQU5BLEdBQVA7QUFlSDs7Ozs7O2tCQWpDZ0JmLEsiLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbSBmcm9tICdtaXRocmlsJztcblxuaW1wb3J0IHtzZWxWYXJDb2xvciwgbWVyZ2VBdHRyaWJ1dGVzLCBtZW51Q29sb3J9IGZyb20gXCIuLi9jb21tb25cIjtcblxuLy8gSW50ZXJmYWNlIHNwZWNpZmljYXRpb25cbi8vXG4vLyBgYGBcbi8vIG0oVGFibGUsIHtcbi8vICAgICBpZDogaWQgKFN0cmluZyksXG4vLyAgICAgaGVhZGVyczogWydjb2wxSGVhZGVyJywgJ2NvbDJIZWFkZXInXSxcbi8vICAgICBkYXRhOiBbWydyb3cxY29sMScsICdyb3cxY29sMiddLCBbJ3JvdzJjb2wxJywgJ3JvdzJjb2wyJ11dIG9yIGZ1bmN0aW9uXG4vLyAgICAgYWN0aXZlUm93OiAncm93MWNvbDEnLCAob3B0aW9uYWwpXG4vLyAgICAgb25jbGljazogKHVpZCwgY29sSUQpID0+IGNvbnNvbGUubG9nKHVpZCArIFwiIHJvdyB3YXMgY2xpY2tlZCwgY29sdW1uIG51bWJlciBcIiArIGNvbElEICsgXCIgd2FzIGNsaWNrZWRcIiksIChvcHRpb25hbClcbi8vICAgICBzaG93VUlEOiB0cnVlIHwgZmFsc2UsIChvcHRpb25hbClcbi8vXG4vLyAgICAgYXR0cnNBbGw6IHsgYXBwbHkgYXR0cmlidXRlcyB0byBhbGwgZGl2cyB9LChvcHRpb25hbClcbi8vICAgICBhdHRyc1Jvd3M6IHsgYXBwbHkgYXR0cmlidXRlcyB0byBlYWNoIHJvdyB9LCAob3B0aW9uYWwpXG4vLyAgICAgYXR0cnNDZWxsczogeyBhcHBseSBhdHRyaWJ1dGVzIHRvIGVhY2ggY2VsbCB9IChvcHRpb25hbClcbi8vICAgICB0YWJsZVRhZ3M6IFsgbSgnY29sZ3JvdXAnLCAuLi4pLCBtKCdjYXB0aW9uJywgLi4uKSwgbSgndGZvb3QnLCAuLi4pXVxuLy8gICAgIH0pXG4vLyBgYGBcblxuLy8gVGhlIFVJRCBmb3IgdGhlIHRhYmxlIGlzIHRoZSBrZXkgZm9yIGlkZW50aWZ5aW5nIGEgY2VydGFpbiByb3cuXG4vLyBUaGUgVUlEIGlzIHRoZSBmaXJzdCBjb2x1bW4sIGFuZCBpdHMgdmFsdWUgaXMgcGFzc2VkIGluIHRoZSBvbmNsaWNrIGNhbGxiYWNrLlxuLy8gVGhlIGZpcnN0IGNvbHVtbiBtYXkgYmUgaGlkZGVuIHZpYSBzaG93VUlEOiBmYWxzZS4gVGhpcyBkb2VzIG5vdCByZW1vdmUgdGhlIGZpcnN0IGhlYWRlclxuXG4vLyBUYWJsZSB0YWdzIGFsbG93cyBwYXNzaW5nIGNvbGdyb3VwcywgY2FwdGlvbnMsIGV0Yy4gaW50byB0aGUgdGFibGUgbWFudWFsbHkuIENhbiBiZSBhIHNpbmdsZSBlbGVtZW50IG9yIGxpc3RcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGFibGUge1xuICAgIHZpZXcodm5vZGUpIHtcbiAgICAgICAgbGV0IHtpZCwgZGF0YSwgaGVhZGVycywgYWN0aXZlUm93LCBvbmNsaWNrLCBzaG93VUlELCBhYmJyZXZpYXRpb259ID0gdm5vZGUuYXR0cnM7XG4gICAgICAgIC8vIEludGVyZmFjZSBjdXN0b20gYXR0cmlidXRlc1xuICAgICAgICBsZXQge2F0dHJzQWxsLCBhdHRyc1Jvd3MsIGF0dHJzQ2VsbHMsIHRhYmxlVGFnc30gPSB2bm9kZS5hdHRycztcblxuICAgICAgICBzaG93VUlEID0gc2hvd1VJRCAhPT0gZmFsc2U7IC8vIERlZmF1bHQgaXMgJ3RydWUnXG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykgZGF0YSA9IGRhdGEoKTtcblxuICAgICAgICAvLyBpZiBhYmJyZXZpYXRpb24gaXMgbm90IHVuZGVmaW5lZCwgYW5kIHN0cmluZyBpcyB0b28gbG9uZywgdGhlbiBzaG9ydGVuIHRoZSBzdHJpbmcgYW5kIGFkZCBhIHRvb2x0b3BcbiAgICAgICAgbGV0IGFiYnJldmlhdGUgPSAoaXRlbSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZihpdGVtKSA9PT0gJ3N0cmluZycgJiYgaXRlbS5sZW5ndGggPiBhYmJyZXZpYXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbSgnZGl2JywgeydkYXRhLXRvZ2dsZSc6ICd0b29sdGlwJywgdGl0bGU6IGl0ZW19LFxuICAgICAgICAgICAgICAgICAgICBpdGVtLnN1YnN0cmluZygwLCBhYmJyZXZpYXRpb24gLSAzKS50cmltKCkgKyAnLi4uJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgcmV0dXJuIGl0ZW07XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG0oYHRhYmxlLnRhYmxlIyR7aWR9YCwgbWVyZ2VBdHRyaWJ1dGVzKHtzdHlsZToge3dpZHRoOiAnMTAwJSd9fSwgYXR0cnNBbGwpLCBbXG4gICAgICAgICAgICB0YWJsZVRhZ3MsXG4gICAgICAgICAgICBoZWFkZXJzID8gbSgndHInLCB7c3R5bGU6IHt3aWR0aDogJzEwMCUnLCBiYWNrZ3JvdW5kOiBtZW51Q29sb3J9fSwgW1xuICAgICAgICAgICAgICAgIC4uLihzaG93VUlEID8gaGVhZGVycyA6IGhlYWRlcnMuc2xpY2UoMSkpLm1hcCgoaGVhZGVyKSA9PiBtKCd0aCcsIGFiYnJldmlhdGUoaGVhZGVyKSkpXG4gICAgICAgICAgICBdKSA6IHVuZGVmaW5lZCxcblxuICAgICAgICAgICAgLi4uZGF0YS5tYXAoKHJvdywgaSkgPT4gbSgndHInLCBtZXJnZUF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgICAgaSAlIDIgPT09IDEgPyB7c3R5bGU6IHsnYmFja2dyb3VuZCc6ICcjZmNmY2ZjJ319IDoge30sXG4gICAgICAgICAgICAgICAgcm93WzBdID09PSBhY3RpdmVSb3cgPyB7c3R5bGU6IHsnYmFja2dyb3VuZCc6IHNlbFZhckNvbG9yfX0gOiB7fSxcbiAgICAgICAgICAgICAgICBhdHRyc1Jvd3MpLFxuICAgICAgICAgICAgICAgIHJvdy5maWx0ZXIoKGl0ZW0sIGopID0+IGogIT09IDAgfHwgc2hvd1VJRCkubWFwKChpdGVtLCBqKSA9PlxuICAgICAgICAgICAgICAgICAgICBtKCd0ZCcsIG1lcmdlQXR0cmlidXRlcyhvbmNsaWNrID8ge29uY2xpY2s6ICgpID0+IG9uY2xpY2socm93WzBdLCBqKX0gOiB7fSwgYXR0cnNDZWxscyksIGFiYnJldmlhdGUoaXRlbSkpKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICldXG4gICAgICAgICk7XG4gICAgfTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Fzc2V0cy9jb21tb24vYXBwL3ZpZXdzL1RhYmxlLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///11\n")},function(module,exports,__webpack_require__){eval('/**! hopscotch - v0.3.1\n*\n* Copyright 2017 LinkedIn Corp. All rights reserved.\n*\n* Licensed under the Apache License, Version 2.0 (the "License");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*     http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an "AS IS" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n!function(a,b){ true?module.exports=b():"function"==typeof define&&define.amd?define(b):a.hopscotch=b()}(this,function(){"use strict";var a,b,c,d,e,f,g,h,i,j,k,l,m,n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(a){return typeof a}:function(a){return a&&"function"==typeof Symbol&&a.constructor===Symbol&&a!==Symbol.prototype?"symbol":typeof a},o="bubble_default",p=window.Sizzle||null,q="undefined",r=!1,s=("undefined"==typeof jQuery?"undefined":n(jQuery))!==q,t=!1,u=!1,v=/^[a-zA-Z]+[a-zA-Z0-9_-]*$/,w={left:"right",right:"left"};try{n(window.sessionStorage)!==q&&(t=!0,sessionStorage.setItem("hopscotch.test.storage","ok"),sessionStorage.removeItem("hopscotch.test.storage"),u=!0)}catch(x){}l={smoothScroll:!0,scrollDuration:1e3,scrollTopMargin:200,showCloseButton:!0,showPrevButton:!1,showNextButton:!0,bubbleWidth:280,bubblePadding:15,arrowWidth:20,skipIfNoElement:!0,isRtl:!1,cookieName:"hopscotch.tour.state"},Array.isArray||(Array.isArray=function(a){return"[object Array]"===Object.prototype.toString.call(a)}),k=function(){r&&m.startTour()},h={addClass:function(a,b){var c,d,e,f;if(a.className){for(d=b.split(/\\s+/),c=" "+a.className+" ",e=0,f=d.length;f>e;++e)c.indexOf(" "+d[e]+" ")<0&&(c+=d[e]+" ");a.className=c.replace(/^\\s+|\\s+$/g,"")}else a.className=b},removeClass:function(a,b){var c,d,e,f;for(d=b.split(/\\s+/),c=" "+a.className+" ",e=0,f=d.length;f>e;++e)c=c.replace(" "+d[e]+" "," ");a.className=c.replace(/^\\s+|\\s+$/g,"")},hasClass:function(a,b){var c;return a.className?(c=" "+a.className+" ",-1!==c.indexOf(" "+b+" ")):!1},getPixelValue:function(a){var b="undefined"==typeof a?"undefined":n(a);return"number"===b?a:"string"===b?parseInt(a,10):0},valOrDefault:function(a,b){return("undefined"==typeof a?"undefined":n(a))!==q?a:b},invokeCallbackArrayHelper:function(a){var b;return Array.isArray(a)&&(b=j[a[0]],"function"==typeof b)?b.apply(this,a.slice(1)):void 0},invokeCallbackArray:function(a){var b,c;if(Array.isArray(a)){if("string"==typeof a[0])return h.invokeCallbackArrayHelper(a);for(b=0,c=a.length;c>b;++b)h.invokeCallback(a[b])}},invokeCallback:function(a){return"function"==typeof a?a():"string"==typeof a&&j[a]?j[a]():h.invokeCallbackArray(a)},invokeEventCallbacks:function(a,b){var c,d,e=i[a];if(b)return this.invokeCallback(b);for(c=0,d=e.length;d>c;++c)this.invokeCallback(e[c].cb)},getScrollTop:function(){var a;return a=n(window.pageYOffset)!==q?window.pageYOffset:document.documentElement.scrollTop},getScrollLeft:function(){var a;return a=n(window.pageXOffset)!==q?window.pageXOffset:document.documentElement.scrollLeft},getWindowHeight:function(){return window.innerHeight||document.documentElement.clientHeight},addEvtListener:function(a,b,c){return a?a.addEventListener?a.addEventListener(b,c,!1):a.attachEvent("on"+b,c):void 0},removeEvtListener:function(a,b,c){return a?a.removeEventListener?a.removeEventListener(b,c,!1):a.detachEvent("on"+b,c):void 0},documentIsReady:function(){return"complete"===document.readyState},evtPreventDefault:function(a){a.preventDefault?a.preventDefault():event&&(event.returnValue=!1)},extend:function(a,b){var c;for(c in b)b.hasOwnProperty(c)&&(a[c]=b[c])},getStepTargetHelper:function(a){var b=document.getElementById(a);if(b)return b;if(s)return b=jQuery(a),b.length?b[0]:null;if(p)return b=new p(a),b.length?b[0]:null;if(document.querySelector)try{return document.querySelector(a)}catch(c){}return/^#[a-zA-Z][\\w-_:.]*$/.test(a)?document.getElementById(a.substring(1)):null},getStepTarget:function(a){var b;if(!a||!a.target)return null;if("string"==typeof a.target)return h.getStepTargetHelper(a.target);if(Array.isArray(a.target)){var c,d;for(c=0,d=a.target.length;d>c;c++)if("string"==typeof a.target[c]&&(b=h.getStepTargetHelper(a.target[c])))return b;return null}return a.target},getI18NString:function(a){return e[a]||d[a]},setState:function(a,b,c){var d,e="";if(t&&u)try{sessionStorage.setItem(a,b)}catch(f){u=!1,this.setState(a,b,c)}else t&&sessionStorage.removeItem(a),c&&(d=new Date,d.setTime(d.getTime()+24*c*60*60*1e3),e="; expires="+d.toGMTString()),document.cookie=a+"="+b+e+"; path=/"},getState:function(a){var b,c,d,e=a+"=",f=document.cookie.split(";");if(t&&(d=sessionStorage.getItem(a)))return d;for(b=0;b<f.length;b++){for(c=f[b];" "===c.charAt(0);)c=c.substring(1,c.length);if(0===c.indexOf(e)){d=c.substring(e.length,c.length);break}}return d},clearState:function(a){t?sessionStorage.removeItem(a):this.setState(a,"",-1)},normalizePlacement:function(a){!a.placement&&a.orientation&&(a.placement=a.orientation)},flipPlacement:function(a){if(a.isRtl&&!a._isFlipped){var b,c,d=["orientation","placement"];a.xOffset&&(a.xOffset=-1*this.getPixelValue(a.xOffset));for(c in d)b=d[c],a.hasOwnProperty(b)&&w.hasOwnProperty(a[b])&&(a[b]=w[a[b]]);a._isFlipped=!0}}},h.addEvtListener(window,"load",k),i={next:[],prev:[],start:[],end:[],show:[],error:[],close:[]},j={},d={stepNums:null,nextBtn:"Next",prevBtn:"Back",doneBtn:"Done",skipBtn:"Skip",closeTooltip:"Close"},e={},b=function(a){this.init(a)},b.prototype={isShowing:!1,currStep:void 0,setPosition:function(a){var b,c,d,e,f,g,i,j=h.getStepTarget(a),k=this.element,l=this.arrowEl,m=a.isRtl?"right":"left";if(h.flipPlacement(a),h.normalizePlacement(a),c=k.offsetWidth,b=k.offsetHeight,h.removeClass(k,"fade-in-down fade-in-up fade-in-left fade-in-right"),d=j.getBoundingClientRect(),i=a.isRtl?d.right-c:d.left,"top"===a.placement)e=d.top-b-this.opt.arrowWidth,f=i;else if("bottom"===a.placement)e=d.bottom+this.opt.arrowWidth,f=i;else if("left"===a.placement)e=d.top,f=d.left-c-this.opt.arrowWidth;else{if("right"!==a.placement)throw new Error("Bubble placement failed because step.placement is invalid or undefined!");e=d.top,f=d.right+this.opt.arrowWidth}g="center"!==a.arrowOffset?h.getPixelValue(a.arrowOffset):a.arrowOffset,g?"top"===a.placement||"bottom"===a.placement?(l.style.top="","center"===g?l.style[m]=Math.floor(c/2-l.offsetWidth/2)+"px":l.style[m]=g+"px"):("left"===a.placement||"right"===a.placement)&&(l.style[m]="","center"===g?l.style.top=Math.floor(b/2-l.offsetHeight/2)+"px":l.style.top=g+"px"):(l.style.top="",l.style[m]=""),"center"===a.xOffset?f=d.left+j.offsetWidth/2-c/2:f+=h.getPixelValue(a.xOffset),"center"===a.yOffset?e=d.top+j.offsetHeight/2-b/2:e+=h.getPixelValue(a.yOffset),a.fixedElement||(e+=h.getScrollTop(),f+=h.getScrollLeft()),k.style.position=a.fixedElement?"fixed":"absolute",k.style.top=e+"px",k.style.left=f+"px"},render:function(a,b,c){var d,e,g,i,j,k,l,n,p,q,r=this.element;if(a?this.currStep=a:this.currStep&&(a=this.currStep),this.opt.isTourBubble?(i=m.getCurrTour(),i&&(e=i.customData,d=i.customRenderer,a.isRtl=a.hasOwnProperty("isRtl")?a.isRtl:i.hasOwnProperty("isRtl")?i.isRtl:this.opt.isRtl,g=i.unsafe,Array.isArray(i.steps)&&(j=i.steps.length,k=this._getStepI18nNum(this._getStepNum(j-1)),n=this._getStepNum(b)===this._getStepNum(j-1)))):(e=a.customData,d=a.customRenderer,g=a.unsafe,a.isRtl=a.hasOwnProperty("isRtl")?a.isRtl:this.opt.isRtl),l=n?h.getI18NString("doneBtn"):a.showSkip?h.getI18NString("skipBtn"):h.getI18NString("nextBtn"),h.flipPlacement(a),h.normalizePlacement(a),this.placement=a.placement,q={i18n:{prevBtn:h.getI18NString("prevBtn"),nextBtn:l,closeTooltip:h.getI18NString("closeTooltip"),stepNum:this._getStepI18nNum(this._getStepNum(b)),numSteps:k},buttons:{showPrev:h.valOrDefault(a.showPrevButton,this.opt.showPrevButton)&&this._getStepNum(b)>0,showNext:h.valOrDefault(a.showNextButton,this.opt.showNextButton),showCTA:h.valOrDefault(a.showCTAButton&&a.ctaLabel,!1),ctaLabel:a.ctaLabel,showClose:h.valOrDefault(this.opt.showCloseButton,!0)},step:{num:b,isLast:h.valOrDefault(n,!1),title:a.title||"",content:a.content||"",isRtl:a.isRtl,placement:a.placement,padding:h.valOrDefault(a.padding,this.opt.bubblePadding),width:h.getPixelValue(a.width)||this.opt.bubbleWidth,customData:a.customData||{}},tour:{isTour:this.opt.isTourBubble,numSteps:j,unsafe:h.valOrDefault(g,!1),customData:e||{}}},"function"==typeof d)r.innerHTML=d(q);else if("string"==typeof d){if(!m.templates||"function"!=typeof m.templates[d])throw new Error(\'Bubble rendering failed - template "\'+d+\'" is not a function.\');r.innerHTML=m.templates[d](q)}else if(f)r.innerHTML=f(q);else{if(!m.templates||"function"!=typeof m.templates[o])throw new Error(\'Bubble rendering failed - template "\'+o+\'" is not a function.\');r.innerHTML=m.templates[o](q)}var s,t=r.children,u=t.length;for(p=0;u>p;p++)s=t[p],h.hasClass(s,"hopscotch-arrow")&&(this.arrowEl=s);return r.style.zIndex="number"==typeof a.zindex?a.zindex:"",this._setArrow(a.placement),this.hide(!1),this.setPosition(a),c&&c(!a.fixedElement),this},_getStepNum:function(a){var b,c,d=0,e=m.getSkippedStepsIndexes(),f=e.length;for(c=0;f>c;c++)b=e[c],a>b&&d++;return a-d},_getStepI18nNum:function(a){var b=h.getI18NString("stepNums");return b&&a<b.length?a=b[a]:a+=1,a},_setArrow:function(a){h.removeClass(this.arrowEl,"down up right left"),"top"===a?h.addClass(this.arrowEl,"down"):"bottom"===a?h.addClass(this.arrowEl,"up"):"left"===a?h.addClass(this.arrowEl,"right"):"right"===a&&h.addClass(this.arrowEl,"left")},_getArrowDirection:function(){return"top"===this.placement?"down":"bottom"===this.placement?"up":"left"===this.placement?"right":"right"===this.placement?"left":void 0},show:function(){var a=this,b="fade-in-"+this._getArrowDirection(),c=1e3;return h.removeClass(this.element,"hide"),h.addClass(this.element,b),setTimeout(function(){h.removeClass(a.element,"invisible")},50),setTimeout(function(){h.removeClass(a.element,b)},c),this.isShowing=!0,this},hide:function(a){var b=this.element;return a=h.valOrDefault(a,!0),b.style.top="",b.style.left="",a?(h.addClass(b,"hide"),h.removeClass(b,"invisible")):(h.removeClass(b,"hide"),h.addClass(b,"invisible")),h.removeClass(b,"animate fade-in-up fade-in-down fade-in-right fade-in-left"),this.isShowing=!1,this},destroy:function(){var a=this.element;a&&a.parentNode.removeChild(a),h.removeEvtListener(a,"click",this.clickCb)},_handleBubbleClick:function(a){function b(c){return c===a.currentTarget?null:h.hasClass(c,"hopscotch-cta")?"cta":h.hasClass(c,"hopscotch-next")?"next":h.hasClass(c,"hopscotch-prev")?"prev":h.hasClass(c,"hopscotch-close")?"close":b(c.parentElement)}var c;a=a||window.event;var d=a.target||a.srcElement;if(c=b(d),"cta"===c)this.opt.isTourBubble||m.getCalloutManager().removeCallout(this.currStep.id),this.currStep.onCTA&&h.invokeCallback(this.currStep.onCTA);else if("next"===c)m.nextStep(!0);else if("prev"===c)m.prevStep(!0);else if("close"===c){if(this.opt.isTourBubble){var e=m.getCurrStepNum(),f=m.getCurrTour(),g=e===f.steps.length-1;h.invokeEventCallbacks("close"),m.endTour(!0,g)}else this.opt.onClose&&h.invokeCallback(this.opt.onClose),this.opt.id&&!this.opt.isTourBubble?m.getCalloutManager().removeCallout(this.opt.id):this.destroy();h.evtPreventDefault(a)}},init:function(a){var b,c,d,e,f=document.createElement("div"),g=this,i=!1;this.element=f,e={showPrevButton:l.showPrevButton,showNextButton:l.showNextButton,bubbleWidth:l.bubbleWidth,bubblePadding:l.bubblePadding,arrowWidth:l.arrowWidth,isRtl:l.isRtl,showNumber:!0,isTourBubble:!0},a=("undefined"==typeof a?"undefined":n(a))===q?{}:a,h.extend(e,a),this.opt=e,f.className="hopscotch-bubble animated",e.isTourBubble?(d=m.getCurrTour(),d&&h.addClass(f,"tour-"+d.id)):h.addClass(f,"hopscotch-callout no-number"),b=function(){!i&&g.isShowing&&(i=!0,setTimeout(function(){g.setPosition(g.currStep),i=!1},100))},h.addEvtListener(window,"resize",b),this.clickCb=function(a){g._handleBubbleClick(a)},h.addEvtListener(f,"click",this.clickCb),this.hide(),h.documentIsReady()?document.body.appendChild(f):(document.addEventListener?(c=function(){document.removeEventListener("DOMContentLoaded",c),window.removeEventListener("load",c),document.body.appendChild(f)},document.addEventListener("DOMContentLoaded",c,!1)):(c=function(){"complete"===document.readyState&&(document.detachEvent("onreadystatechange",c),window.detachEvent("onload",c),document.body.appendChild(f))},document.attachEvent("onreadystatechange",c)),h.addEvtListener(window,"load",c))}},c=function(){var a={},c={};this.createCallout=function(d){var e;if(!d.id)throw new Error("Must specify a callout id.");if(!v.test(d.id))throw new Error("Callout ID is using an invalid format. Use alphanumeric, underscores, and/or hyphens only. First character must be a letter.");if(a[d.id])throw new Error("Callout by that id already exists. Please choose a unique id.");if(!h.getStepTarget(d))throw new Error("Must specify existing target element via \'target\' option.");return d.showNextButton=d.showPrevButton=!1,d.isTourBubble=!1,e=new b(d),a[d.id]=e,c[d.id]=d,e.render(d,null,function(){e.show(),d.onShow&&h.invokeCallback(d.onShow)}),e},this.getCallout=function(b){return a[b]},this.removeAllCallouts=function(){var b;for(b in a)a.hasOwnProperty(b)&&this.removeCallout(b)},this.removeCallout=function(b){var d=a[b];a[b]=null,c[b]=null,d&&d.destroy()},this.refreshCalloutPositions=function(){var b,d,e;for(b in a)a.hasOwnProperty(b)&&c.hasOwnProperty(b)&&(d=a[b],e=c[b],d&&e&&d.setPosition(e))}},a=function(a){var d,k,p,t,u,w,x,y,z=this,A={},B=[],C=function(a){return d&&d.element&&d.element.parentNode||(d=new b(p)),a&&h.extend(d.opt,{bubblePadding:E("bubblePadding"),bubbleWidth:E("bubbleWidth"),showNextButton:E("showNextButton"),showPrevButton:E("showPrevButton"),showCloseButton:E("showCloseButton"),arrowWidth:E("arrowWidth"),isRtl:E("isRtl")}),d},D=function(){d&&(d.destroy(),d=null)},E=function(a){return"undefined"==typeof p?l[a]:h.valOrDefault(p[a],l[a])},F=function(){var a;return a=!t||0>u||u>=t.steps.length?null:t.steps[u]},G=function(){z.nextStep()},H=function(a){var b,c,d,e,f,g,i=C(),j=i.element,k=h.getPixelValue(j.style.top),l=k+h.getPixelValue(j.offsetHeight),m=h.getStepTarget(F()),o=m.getBoundingClientRect(),p=o.top+h.getScrollTop(),r=o.bottom+h.getScrollTop(),t=p>k?k:p,u=l>r?l:r,v=h.getScrollTop(),w=v+h.getWindowHeight(),x=t-E("scrollTopMargin");t>=v&&(t<=v+E("scrollTopMargin")||w>=u)?a&&a():E("smoothScroll")?("undefined"==typeof YAHOO?"undefined":n(YAHOO))!==q&&n(YAHOO.env)!==q&&n(YAHOO.env.ua)!==q&&n(YAHOO.util)!==q&&n(YAHOO.util.Scroll)!==q?(b=YAHOO.env.ua.webkit?document.body:document.documentElement,d=YAHOO.util.Easing?YAHOO.util.Easing.easeOut:void 0,c=new YAHOO.util.Scroll(b,{scroll:{to:[0,x]}},E("scrollDuration")/1e3,d),c.onComplete.subscribe(a),c.animate()):s?jQuery("body, html").animate({scrollTop:x},E("scrollDuration"),a):(0>x&&(x=0),e=v>t?-1:1,f=Math.abs(v-x)/(E("scrollDuration")/10),(g=function(){var b=h.getScrollTop(),c=b+e*f;return e>0&&c>=x||0>e&&x>=c?(c=x,a&&a(),void window.scrollTo(0,c)):(window.scrollTo(0,c),h.getScrollTop()===b?void(a&&a()):void setTimeout(g,10))})()):(window.scrollTo(0,x),a&&a())},I=function P(a,b){var c,d,e;u+a>=0&&u+a<t.steps.length?(u+=a,d=F(),e=function(){c=h.getStepTarget(d),c?(A[u]&&delete A[u],b(u)):(A[u]=!0,h.invokeEventCallbacks("error"),P(a,b))},d.delay?setTimeout(e,d.delay):e()):b(-1)},J=function(a,b){var c,d,e,f,g=C(),i=this;if(g.hide(),a=h.valOrDefault(a,!0),c=F(),c.nextOnTargetClick&&h.removeEvtListener(h.getStepTarget(c),"click",G),d=c,e=b>0?d.multipage:u>0&&t.steps[u-1].multipage,f=function(c){var f;if(-1===c)return this.endTour(!0);if(a&&(f=b>0?h.invokeEventCallbacks("next",d.onNext):h.invokeEventCallbacks("prev",d.onPrev)),c===u){if(e)return void N();f=h.valOrDefault(f,!0),f?this.showStep(c):this.endTour(!1)}},!e&&E("skipIfNoElement"))I(b,function(a){f.call(i,a)});else if(u+b>=0&&u+b<t.steps.length){if(u+=b,c=F(),!h.getStepTarget(c)&&!e)return h.invokeEventCallbacks("error"),this.endTour(!0,!1);f.call(this,u)}else if(u+b===t.steps.length)return this.endTour();return this},K=function(a){var b,c,d,e={};for(b in a)a.hasOwnProperty(b)&&"id"!==b&&"steps"!==b&&(e[b]=a[b]);return y.call(this,e,!0),c=h.getState(E("cookieName")),c&&(d=c.split(":"),w=d[0],x=d[1],d.length>2&&(B=d[2].split(",")),x=parseInt(x,10)),this},L=function(a,b,c){var d,e;if(u=a||0,A=b||{},d=F(),e=h.getStepTarget(d))return void c(u);if(!e){if(h.invokeEventCallbacks("error"),A[u]=!0,E("skipIfNoElement"))return void I(1,c);u=-1,c(u)}},M=function(a){function b(){d.show(),h.invokeEventCallbacks("show",c.onShow)}var c=t.steps[a],d=C(),e=h.getStepTarget(c);u!==a&&F().nextOnTargetClick&&h.removeEvtListener(h.getStepTarget(F()),"click",G),u=a,d.hide(!1),d.render(c,a,function(a){a?H(b):b(),c.nextOnTargetClick&&h.addEvtListener(e,"click",G)}),N()},N=function(){var a=t.id+":"+u,b=m.getSkippedStepsIndexes();b&&b.length>0&&(a+=":"+b.join(",")),h.setState(E("cookieName"),a,1)},O=function(a){a&&this.configure(a)};this.getCalloutManager=function(){return("undefined"==typeof k?"undefined":n(k))===q&&(k=new c),k},this.startTour=function(a,b){var c,d,e={},f=this;if(!t){if(!a)throw new Error("Tour data is required for startTour.");if(!a.id||!v.test(a.id))throw new Error("Tour ID is using an invalid format. Use alphanumeric, underscores, and/or hyphens only. First character must be a letter.");t=a,K.call(this,a)}if(("undefined"==typeof b?"undefined":n(b))!==q){if(b>=t.steps.length)throw new Error("Specified step number out of bounds.");d=b}if(!h.documentIsReady())return r=!0,this;if("undefined"==typeof d&&t.id===w&&("undefined"==typeof x?"undefined":n(x))!==q){if(d=x,B.length>0)for(var g=0,i=B.length;i>g;g++)e[B[g]]=!0}else d||(d=0);return L(d,e,function(a){var b=-1!==a&&h.getStepTarget(t.steps[a]);return b?(h.invokeEventCallbacks("start"),c=C(),c.hide(!1),f.isActive=!0,void(h.getStepTarget(F())?f.showStep(a):(h.invokeEventCallbacks("error"),E("skipIfNoElement")&&f.nextStep(!1)))):void f.endTour(!1,!1)}),this},this.showStep=function(a){var b=t.steps[a],c=u;return h.getStepTarget(b)?(b.delay?setTimeout(function(){M(a)},b.delay):M(a),this):(u=a,h.invokeEventCallbacks("error"),void(u=c))},this.prevStep=function(a){return J.call(this,a,-1),this},this.nextStep=function(a){return J.call(this,a,1),this},this.endTour=function(a,b){var c,d=C();return a=h.valOrDefault(a,!0),b=h.valOrDefault(b,!0),t&&(c=F(),c&&c.nextOnTargetClick&&h.removeEvtListener(h.getStepTarget(c),"click",G)),u=0,x=void 0,d.hide(),a&&h.clearState(E("cookieName")),this.isActive&&(this.isActive=!1,t&&b&&h.invokeEventCallbacks("end")),this.removeCallbacks(null,!0),this.resetDefaultOptions(),D(),t=null,this},this.getCurrTour=function(){return t},this.getCurrTarget=function(){return h.getStepTarget(F())},this.getCurrStepNum=function(){return u},this.getSkippedStepsIndexes=function(){var a,b=[];for(a in A)b.push(a);return b},this.refreshBubblePosition=function(){var a=F();return a&&C().setPosition(a),this.getCalloutManager().refreshCalloutPositions(),this},this.listen=function(a,b,c){return a&&i[a].push({cb:b,fromTour:c}),this},this.unlisten=function(a,b){var c,d,e=i[a];for(c=0,d=e.length;d>c;++c)e[c].cb===b&&e.splice(c,1);return this},this.removeCallbacks=function(a,b){var c,d,e,f;for(f in i)if(!a||a===f)if(b)for(c=i[f],d=0,e=c.length;e>d;++d)c[d].fromTour&&(c.splice(d--,1),--e);else i[f]=[];return this},this.registerHelper=function(a,b){"string"==typeof a&&"function"==typeof b&&(j[a]=b)},this.unregisterHelper=function(a){j[a]=null},this.invokeHelper=function(a){var b,c,d=[];for(b=1,c=arguments.length;c>b;++b)d.push(arguments[b]);j[a]&&j[a].call(null,d)},this.setCookieName=function(a){return p.cookieName=a,this},this.resetDefaultOptions=function(){return p={},this},this.resetDefaultI18N=function(){return e={},this},this.getState=function(){return h.getState(E("cookieName"))},y=function(a,b){var c,d,f,g,i=["next","prev","start","end","show","error","close"];for(p||this.resetDefaultOptions(),h.extend(p,a),a&&h.extend(e,a.i18n),f=0,g=i.length;g>f;++f)d="on"+i[f].charAt(0).toUpperCase()+i[f].substring(1),a[d]&&this.listen(i[f],a[d],b);return c=C(!0),this},this.configure=function(a){return y.call(this,a,!1)},this.setRenderer=function(a){var b="undefined"==typeof a?"undefined":n(a);return"string"===b?(o=a,f=void 0):"function"===b&&(f=a),this},this.setEscaper=function(a){return"function"==typeof a&&(g=a),this},O.call(this,a)},m=new a,function(){var a={};a.escape=function(a){return g?g(a):null==a?"":(""+a).replace(new RegExp("[&<>\\"\']","g"),function(a){return"&"==a?"&amp;":"<"==a?"&lt;":">"==a?"&gt;":\'"\'==a?"&quot;":"\'"==a?"&#x27;":void 0})},this.templates=this.templates||{},this.templates.bubble_default=function(b){function c(b,c){return c?a.escape(b):b}var d,e="";a.escape,Array.prototype.join;e+="\\n";var f=b.i18n,g=b.buttons,h=b.step,i=b.tour;return e+=\'\\n<div class="hopscotch-bubble-container" style="width: \'+(null==(d=h.width)?"":d)+"px; padding: "+(null==(d=h.padding)?"":d)+\'px;">\\n  \',i.isTour&&(e+=\'<span class="hopscotch-bubble-number">\'+(null==(d=f.stepNum)?"":d)+"</span>"),e+=\'\\n  <div class="hopscotch-bubble-content">\\n    \',""!==h.title&&(e+=\'<h3 class="hopscotch-title">\'+(null==(d=c(h.title,i.unsafe))?"":d)+"</h3>"),e+="\\n    ",""!==h.content&&(e+=\'<div class="hopscotch-content">\'+(null==(d=c(h.content,i.unsafe))?"":d)+"</div>"),e+=\'\\n  </div>\\n  <div class="hopscotch-actions">\\n    \',g.showPrev&&(e+=\'<button class="hopscotch-nav-button prev hopscotch-prev">\'+(null==(d=f.prevBtn)?"":d)+"</button>"),e+="\\n    ",g.showCTA&&(e+=\'<button class="hopscotch-nav-button next hopscotch-cta">\'+(null==(d=g.ctaLabel)?"":d)+"</button>"),e+="\\n    ",g.showNext&&(e+=\'<button class="hopscotch-nav-button next hopscotch-next">\'+(null==(d=f.nextBtn)?"":d)+"</button>"),e+="\\n  </div>\\n  ",g.showClose&&(e+=\'<button class="hopscotch-bubble-close hopscotch-close">\'+(null==(d=f.closeTooltip)?"":d)+"</button>"),e+=\'\\n</div>\\n<div class="hopscotch-bubble-arrow-container hopscotch-arrow">\\n  <div class="hopscotch-bubble-arrow-border"></div>\\n  <div class="hopscotch-bubble-arrow"></div>\\n</div>\\n\'}}.call(m);var y=m;return y});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2hvcHNjb3RjaC9kaXN0L2pzL2hvcHNjb3RjaC5taW4uanM/Mzc0OSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUseUZBQXdJLGlCQUFpQixhQUFhLHdHQUF3RyxnQkFBZ0IsYUFBYSxvR0FBb0csaUtBQWlLLDJCQUEyQixJQUFJLG9KQUFvSixVQUFVLEdBQUcsMk5BQTJOLDJDQUEyQywyREFBMkQsZUFBZSxpQkFBaUIsSUFBSSx1QkFBdUIsWUFBWSxnQkFBZ0IsMERBQTBELElBQUksNkNBQTZDLHVDQUF1QyxtQkFBbUIsMkJBQTJCLFlBQVksMERBQTBELElBQUksa0NBQWtDLHVDQUF1Qyx3QkFBd0IsTUFBTSx3RUFBd0UsMkJBQTJCLDZDQUE2QyxtREFBbUQsNEJBQTRCLHVEQUF1RCx1Q0FBdUMsTUFBTSwwRkFBMEYsaUNBQWlDLFFBQVEscUJBQXFCLCtEQUErRCxtQkFBbUIsSUFBSSw0QkFBNEIsNEJBQTRCLHdGQUF3RixvQ0FBb0MsZUFBZSxtQ0FBbUMsbUJBQW1CLElBQUksaUNBQWlDLHlCQUF5QixNQUFNLHlGQUF5RiwwQkFBMEIsTUFBTSwwRkFBMEYsNEJBQTRCLGlFQUFpRSxnQ0FBZ0Msc0ZBQXNGLG1DQUFtQyw0RkFBNEYsNEJBQTRCLHVDQUF1QywrQkFBK0Isa0VBQWtFLHNCQUFzQixNQUFNLDRDQUE0QyxpQ0FBaUMsaUNBQWlDLGNBQWMsMkNBQTJDLDBDQUEwQyw4QkFBOEIsaUNBQWlDLFVBQVUsa0ZBQWtGLDJCQUEyQixNQUFNLDZCQUE2QixvRUFBb0UsNEJBQTRCLFFBQVEsMEJBQTBCLElBQUkscUZBQXFGLFlBQVksZ0JBQWdCLDJCQUEyQixrQkFBa0IsMEJBQTBCLFdBQVcsWUFBWSw0QkFBNEIsU0FBUywwQkFBMEIsOEZBQThGLHdEQUF3RCxTQUFTLHNC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RCxtQ0FBbUMsVUFBVSwrQkFBK0IsYUFBYSwyQkFBMkIsSUFBSSx5QkFBeUIsd0JBQXdCLGdDQUFnQywyQkFBMkIscUNBQXFDLFdBQVcsTUFBTSxrQ0FBa0MsV0FBVyxNQUFNLDBCQUEwQixtQ0FBbUMsaUJBQWlCLG1FQUFtRSxxRkFBcUYsSUFBSSx5RkFBeUYsb0JBQW9CLDRCQUE0Qix5QkFBeUIsOEJBQThCLDZDQUE2Qyw2REFBNkQsNkJBQTZCLHVDQUF1QyxnQkFBZ0Isb0JBQW9CLFNBQVMscUJBQXFCLCtFQUErRSxtQkFBbUIsY0FBYyxjQUFjLGdCQUFnQixnQkFBZ0IsU0FBUyxFQUFFLGtDQUFrQywyQ0FBMkMsZ0JBQWdCLHVCQUF1QixXQUFXLDhCQUE4QixRQUFRLDJDQUEyQyxrR0FBa0csMkNBQTJDLGltQ0FBaW1DLFNBQVMsUUFBUSxTQUFTIiwiZmlsZSI6IjEyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqISBob3BzY290Y2ggLSB2MC4zLjFcbipcbiogQ29weXJpZ2h0IDIwMTcgTGlua2VkSW4gQ29ycC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuIWZ1bmN0aW9uKGEsYil7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9YigpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoYik6YS5ob3BzY290Y2g9YigpfSh0aGlzLGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIGEsYixjLGQsZSxmLGcsaCxpLGosayxsLG0sbj1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24oYSl7cmV0dXJuIHR5cGVvZiBhfTpmdW5jdGlvbihhKXtyZXR1cm4gYSYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZhLmNvbnN0cnVjdG9yPT09U3ltYm9sJiZhIT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiBhfSxvPVwiYnViYmxlX2RlZmF1bHRcIixwPXdpbmRvdy5TaXp6bGV8fG51bGwscT1cInVuZGVmaW5lZFwiLHI9ITEscz0oXCJ1bmRlZmluZWRcIj09dHlwZW9mIGpRdWVyeT9cInVuZGVmaW5lZFwiOm4oalF1ZXJ5KSkhPT1xLHQ9ITEsdT0hMSx2PS9eW2EtekEtWl0rW2EtekEtWjAtOV8tXSokLyx3PXtsZWZ0OlwicmlnaHRcIixyaWdodDpcImxlZnRcIn07dHJ5e24od2luZG93LnNlc3Npb25TdG9yYWdlKSE9PXEmJih0PSEwLHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oXCJob3BzY290Y2gudGVzdC5zdG9yYWdlXCIsXCJva1wiKSxzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKFwiaG9wc2NvdGNoLnRlc3Quc3RvcmFnZVwiKSx1PSEwKX1jYXRjaCh4KXt9bD17c21vb3RoU2Nyb2xsOiEwLHNjcm9sbER1cmF0aW9uOjFlMyxzY3JvbGxUb3BNYXJnaW46MjAwLHNob3dDbG9zZUJ1dHRvbjohMCxzaG93UHJldkJ1dHRvbjohMSxzaG93TmV4dEJ1dHRvbjohMCxidWJibGVXaWR0aDoyODAsYnViYmxlUGFkZGluZzoxNSxhcnJvd1dpZHRoOjIwLHNraXBJZk5vRWxlbWVudDohMCxpc1J0bDohMSxjb29raWVOYW1lOlwiaG9wc2NvdGNoLnRvdXIuc3RhdGVcIn0sQXJyYXkuaXNBcnJheXx8KEFycmF5LmlzQXJyYXk9ZnVuY3Rpb24oYSl7cmV0dXJuXCJbb2JqZWN0IEFycmF5XVwiPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGEpfSksaz1mdW5jdGlvbigpe3ImJm0uc3RhcnRUb3VyKCl9LGg9e2FkZENsYXNzOmZ1bmN0aW9uKGEsYil7dmFyIGMsZCxlLGY7aWYoYS5jbGFzc05hbWUpe2ZvcihkPWIuc3BsaXQoL1xccysvKSxjPVwiIFwiK2EuY2xhc3NOYW1lK1wiIFwiLGU9MCxmPWQubGVuZ3RoO2Y+ZTsrK2UpYy5pbmRleE9mKFwiIFwiK2RbZV0rXCIgXCIpPDAmJihjKz1kW2VdK1wiIFwiKTthLmNsYXNzTmFtZT1jLnJlcGxhY2UoL15cXHMrfFxccyskL2csXCJcIil9ZWxzZSBhLmNsYXNzTmFtZT1ifSxyZW1vdmVDbGFzczpmdW5jdGlvbihhLGIpe3ZhciBjLGQsZSxmO2ZvcihkPWIuc3BsaXQoL1xccysvKSxjPVwiIFwiK2EuY2xhc3NOYW1lK1wiIFwiLGU9MCxmPWQubGVuZ3RoO2Y+ZTsrK2UpYz1jLnJlcGxhY2UoXCIgXCIrZFtlXStcIiBcIixcIiBcIik7YS5jbGFzc05hbWU9Yy5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLFwiXCIpfSxoYXNDbGFzczpmdW5jdGlvbihhLGIpe3ZhciBjO3JldHVybiBhLmNsYXNzTmFtZT8oYz1cIiBcIithLmNsYXNzTmFtZStcIiBcIiwtMSE9PWMuaW5kZXhPZihcIiBcIitiK1wiIFwiKSk6ITF9LGdldFBpeGVsVmFsdWU6ZnVuY3Rpb24oYSl7dmFyIGI9XCJ1bmRlZmluZWRcIj09dHlwZW9mIGE/XCJ1bmRlZmluZWRcIjpuKGEpO3JldHVyblwibnVtYmVyXCI9PT1iP2E6XCJzdHJpbmdcIj09PWI/cGFyc2VJbnQoYSwxMCk6MH0sdmFsT3JEZWZhdWx0OmZ1bmN0aW9uKGEsYil7cmV0dXJuKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBhP1widW5kZWZpbmVkXCI6bihhKSkhPT1xP2E6Yn0saW52b2tlQ2FsbGJhY2tBcnJheUhlbHBlcjpmdW5jdGlvbihhKXt2YXIgYjtyZXR1cm4gQXJyYXkuaXNBcnJheShhKSYmKGI9althWzBdXSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBiKT9iLmFwcGx5KHRoaXMsYS5zbGljZSgxKSk6dm9pZCAwfSxpbnZva2VDYWxsYmFja0FycmF5OmZ1bmN0aW9uKGEpe3ZhciBiLGM7aWYoQXJyYXkuaXNBcnJheShhKSl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGFbMF0pcmV0dXJuIGguaW52b2tlQ2FsbGJhY2tBcnJheUhlbHBlcihhKTtmb3IoYj0wLGM9YS5sZW5ndGg7Yz5iOysrYiloLmludm9rZUNhbGxiYWNrKGFbYl0pfX0saW52b2tlQ2FsbGJhY2s6ZnVuY3Rpb24oYSl7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgYT9hKCk6XCJzdHJpbmdcIj09dHlwZW9mIGEmJmpbYV0/althXSgpOmguaW52b2tlQ2FsbGJhY2tBcnJheShhKX0saW52b2tlRXZlbnRDYWxsYmFja3M6ZnVuY3Rpb24oYSxiKXt2YXIgYyxkLGU9aVthXTtpZihiKXJldHVybiB0aGlzLmludm9rZUNhbGxiYWNrKGIpO2ZvcihjPTAsZD1lLmxlbmd0aDtkPmM7KytjKXRoaXMuaW52b2tlQ2FsbGJhY2soZVtjXS5jYil9LGdldFNjcm9sbFRvcDpmdW5jdGlvbigpe3ZhciBhO3JldHVybiBhPW4od2luZG93LnBhZ2VZT2Zmc2V0KSE9PXE/d2luZG93LnBhZ2VZT2Zmc2V0OmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3B9LGdldFNjcm9sbExlZnQ6ZnVuY3Rpb24oKXt2YXIgYTtyZXR1cm4gYT1uKHdpbmRvdy5wYWdlWE9mZnNldCkhPT1xP3dpbmRvdy5wYWdlWE9mZnNldDpkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdH0sZ2V0V2luZG93SGVpZ2h0OmZ1bmN0aW9uKCl7cmV0dXJuIHdpbmRvdy5pbm5lckhlaWdodHx8ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodH0sYWRkRXZ0TGlzdGVuZXI6ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBhP2EuYWRkRXZlbnRMaXN0ZW5lcj9hLmFkZEV2ZW50TGlzdGVuZXIoYixjLCExKTphLmF0dGFjaEV2ZW50KFwib25cIitiLGMpOnZvaWQgMH0scmVtb3ZlRXZ0TGlzdGVuZXI6ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBhP2EucmVtb3ZlRXZlbnRMaXN0ZW5lcj9hLnJlbW92ZUV2ZW50TGlzdGVuZXIoYixjLCExKTphLmRldGFjaEV2ZW50KFwib25cIitiLGMpOnZvaWQgMH0sZG9jdW1lbnRJc1JlYWR5OmZ1bmN0aW9uKCl7cmV0dXJuXCJjb21wbGV0ZVwiPT09ZG9jdW1lbnQucmVhZHlTdGF0ZX0sZXZ0UHJldmVudERlZmF1bHQ6ZnVuY3Rpb24oYSl7YS5wcmV2ZW50RGVmYXVsdD9hLnByZXZlbnREZWZhdWx0KCk6ZXZlbnQmJihldmVudC5yZXR1cm5WYWx1ZT0hMSl9LGV4dGVuZDpmdW5jdGlvbihhLGIpe3ZhciBjO2ZvcihjIGluIGIpYi5oYXNPd25Qcm9wZXJ0eShjKSYmKGFbY109YltjXSl9LGdldFN0ZXBUYXJnZXRIZWxwZXI6ZnVuY3Rpb24oYSl7dmFyIGI9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYSk7aWYoYilyZXR1cm4gYjtpZihzKXJldHVybiBiPWpRdWVyeShhKSxiLmxlbmd0aD9iWzBdOm51bGw7aWYocClyZXR1cm4gYj1uZXcgcChhKSxiLmxlbmd0aD9iWzBdOm51bGw7aWYoZG9jdW1lbnQucXVlcnlTZWxlY3Rvcil0cnl7cmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYSl9Y2F0Y2goYyl7fXJldHVybi9eI1thLXpBLVpdW1xcdy1fOi5dKiQvLnRlc3QoYSk/ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYS5zdWJzdHJpbmcoMSkpOm51bGx9LGdldFN0ZXBUYXJnZXQ6ZnVuY3Rpb24oYSl7dmFyIGI7aWYoIWF8fCFhLnRhcmdldClyZXR1cm4gbnVsbDtpZihcInN0cmluZ1wiPT10eXBlb2YgYS50YXJnZXQpcmV0dXJuIGguZ2V0U3RlcFRhcmdldEhlbHBlcihhLnRhcmdldCk7aWYoQXJyYXkuaXNBcnJheShhLnRhcmdldCkpe3ZhciBjLGQ7Zm9yKGM9MCxkPWEudGFyZ2V0Lmxlbmd0aDtkPmM7YysrKWlmKFwic3RyaW5nXCI9PXR5cGVvZiBhLnRhcmdldFtjXSYmKGI9aC5nZXRTdGVwVGFyZ2V0SGVscGVyKGEudGFyZ2V0W2NdKSkpcmV0dXJuIGI7cmV0dXJuIG51bGx9cmV0dXJuIGEudGFyZ2V0fSxnZXRJMThOU3RyaW5nOmZ1bmN0aW9uKGEpe3JldHVybiBlW2FdfHxkW2FdfSxzZXRTdGF0ZTpmdW5jdGlvbihhLGIsYyl7dmFyIGQsZT1cIlwiO2lmKHQmJnUpdHJ5e3Nlc3Npb25TdG9yYWdlLnNldEl0ZW0oYSxiKX1jYXRjaChmKXt1PSExLHRoaXMuc2V0U3RhdGUoYSxiLGMpfWVsc2UgdCYmc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShhKSxjJiYoZD1uZXcgRGF0ZSxkLnNldFRpbWUoZC5nZXRUaW1lKCkrMjQqYyo2MCo2MCoxZTMpLGU9XCI7IGV4cGlyZXM9XCIrZC50b0dNVFN0cmluZygpKSxkb2N1bWVudC5jb29raWU9YStcIj1cIitiK2UrXCI7IHBhdGg9L1wifSxnZXRTdGF0ZTpmdW5jdGlvbihhKXt2YXIgYixjLGQsZT1hK1wiPVwiLGY9ZG9jdW1lbnQuY29va2llLnNwbGl0KFwiO1wiKTtpZih0JiYoZD1zZXNzaW9uU3RvcmFnZS5nZXRJdGVtKGEpKSlyZXR1cm4gZDtmb3IoYj0wO2I8Zi5sZW5ndGg7YisrKXtmb3IoYz1mW2JdO1wiIFwiPT09Yy5jaGFyQXQoMCk7KWM9Yy5zdWJzdHJpbmcoMSxjLmxlbmd0aCk7aWYoMD09PWMuaW5kZXhPZihlKSl7ZD1jLnN1YnN0cmluZyhlLmxlbmd0aCxjLmxlbmd0aCk7YnJlYWt9fXJldHVybiBkfSxjbGVhclN0YXRlOmZ1bmN0aW9uKGEpe3Q/c2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShhKTp0aGlzLnNldFN0YXRlKGEsXCJcIiwtMSl9LG5vcm1hbGl6ZVBsYWNlbWVudDpmdW5jdGlvbihhKXshYS5wbGFjZW1lbnQmJmEub3JpZW50YXRpb24mJihhLnBsYWNlbWVudD1hLm9yaWVudGF0aW9uKX0sZmxpcFBsYWNlbWVudDpmdW5jdGlvbihhKXtpZihhLmlzUnRsJiYhYS5faXNGbGlwcGVkKXt2YXIgYixjLGQ9W1wib3JpZW50YXRpb25cIixcInBsYWNlbWVudFwiXTthLnhPZmZzZXQmJihhLnhPZmZzZXQ9LTEqdGhpcy5nZXRQaXhlbFZhbHVlKGEueE9mZnNldCkpO2ZvcihjIGluIGQpYj1kW2NdLGEuaGFzT3duUHJvcGVydHkoYikmJncuaGFzT3duUHJvcGVydHkoYVtiXSkmJihhW2JdPXdbYVtiXV0pO2EuX2lzRmxpcHBlZD0hMH19fSxoLmFkZEV2dExpc3RlbmVyKHdpbmRvdyxcImxvYWRcIixrKSxpPXtuZXh0OltdLHByZXY6W10sc3RhcnQ6W10sZW5kOltdLHNob3c6W10sZXJyb3I6W10sY2xvc2U6W119LGo9e30sZD17c3RlcE51bXM6bnVsbCxuZXh0QnRuOlwiTmV4dFwiLHByZXZCdG46XCJCYWNrXCIsZG9uZUJ0bjpcIkRvbmVcIixza2lwQnRuOlwiU2tpcFwiLGNsb3NlVG9vbHRpcDpcIkNsb3NlXCJ9LGU9e30sYj1mdW5jdGlvbihhKXt0aGlzLmluaXQoYSl9LGIucHJvdG90eXBlPXtpc1Nob3dpbmc6ITEsY3VyclN0ZXA6dm9pZCAwLHNldFBvc2l0aW9uOmZ1bmN0aW9uKGEpe3ZhciBiLGMsZCxlLGYsZyxpLGo9aC5nZXRTdGVwVGFyZ2V0KGEpLGs9dGhpcy5lbGVtZW50LGw9dGhpcy5hcnJvd0VsLG09YS5pc1J0bD9cInJpZ2h0XCI6XCJsZWZ0XCI7aWYoaC5mbGlwUGxhY2VtZW50KGEpLGgubm9ybWFsaXplUGxhY2VtZW50KGEpLGM9ay5vZmZzZXRXaWR0aCxiPWsub2Zmc2V0SGVpZ2h0LGgucmVtb3ZlQ2xhc3MoayxcImZhZGUtaW4tZG93biBmYWRlLWluLXVwIGZhZGUtaW4tbGVmdCBmYWRlLWluLXJpZ2h0XCIpLGQ9ai5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxpPWEuaXNSdGw/ZC5yaWdodC1jOmQubGVmdCxcInRvcFwiPT09YS5wbGFjZW1lbnQpZT1kLnRvcC1iLXRoaXMub3B0LmFycm93V2lkdGgsZj1pO2Vsc2UgaWYoXCJib3R0b21cIj09PWEucGxhY2VtZW50KWU9ZC5ib3R0b20rdGhpcy5vcHQuYXJyb3dXaWR0aCxmPWk7ZWxzZSBpZihcImxlZnRcIj09PWEucGxhY2VtZW50KWU9ZC50b3AsZj1kLmxlZnQtYy10aGlzLm9wdC5hcnJvd1dpZHRoO2Vsc2V7aWYoXCJyaWdodFwiIT09YS5wbGFjZW1lbnQpdGhyb3cgbmV3IEVycm9yKFwiQnViYmxlIHBsYWNlbWVudCBmYWlsZWQgYmVjYXVzZSBzdGVwLnBsYWNlbWVudCBpcyBpbnZhbGlkIG9yIHVuZGVmaW5lZCFcIik7ZT1kLnRvcCxmPWQucmlnaHQrdGhpcy5vcHQuYXJyb3dXaWR0aH1nPVwiY2VudGVyXCIhPT1hLmFycm93T2Zmc2V0P2guZ2V0UGl4ZWxWYWx1ZShhLmFycm93T2Zmc2V0KTphLmFycm93T2Zmc2V0LGc/XCJ0b3BcIj09PWEucGxhY2VtZW50fHxcImJvdHRvbVwiPT09YS5wbGFjZW1lbnQ/KGwuc3R5bGUudG9wPVwiXCIsXCJjZW50ZXJcIj09PWc/bC5zdHlsZVttXT1NYXRoLmZsb29yKGMvMi1sLm9mZnNldFdpZHRoLzIpK1wicHhcIjpsLnN0eWxlW21dPWcrXCJweFwiKTooXCJsZWZ0XCI9PT1hLnBsYWNlbWVudHx8XCJyaWdodFwiPT09YS5wbGFjZW1lbnQpJiYobC5zdHlsZVttXT1cIlwiLFwiY2VudGVyXCI9PT1nP2wuc3R5bGUudG9wPU1hdGguZmxvb3IoYi8yLWwub2Zmc2V0SGVpZ2h0LzIpK1wicHhcIjpsLnN0eWxlLnRvcD1nK1wicHhcIik6KGwuc3R5bGUudG9wPVwiXCIsbC5zdHlsZVttXT1cIlwiKSxcImNlbnRlclwiPT09YS54T2Zmc2V0P2Y9ZC5sZWZ0K2oub2Zmc2V0V2lkdGgvMi1jLzI6Zis9aC5nZXRQaXhlbFZhbHVlKGEueE9mZnNldCksXCJjZW50ZXJcIj09PWEueU9mZnNldD9lPWQudG9wK2oub2Zmc2V0SGVpZ2h0LzItYi8yOmUrPWguZ2V0UGl4ZWxWYWx1ZShhLnlPZmZzZXQpLGEuZml4ZWRFbGVtZW50fHwoZSs9aC5nZXRTY3JvbGxUb3AoKSxmKz1oLmdldFNjcm9sbExlZnQoKSksay5zdHlsZS5wb3NpdGlvbj1hLmZpeGVkRWxlbWVudD9cImZpeGVkXCI6XCJhYnNvbHV0ZVwiLGsuc3R5bGUudG9wPWUrXCJweFwiLGsuc3R5bGUubGVmdD1mK1wicHhcIn0scmVuZGVyOmZ1bmN0aW9uKGEsYixjKXt2YXIgZCxlLGcsaSxqLGssbCxuLHAscSxyPXRoaXMuZWxlbWVudDtpZihhP3RoaXMuY3VyclN0ZXA9YTp0aGlzLmN1cnJTdGVwJiYoYT10aGlzLmN1cnJTdGVwKSx0aGlzLm9wdC5pc1RvdXJCdWJibGU/KGk9bS5nZXRDdXJyVG91cigpLGkmJihlPWkuY3VzdG9tRGF0YSxkPWkuY3VzdG9tUmVuZGVyZXIsYS5pc1J0bD1hLmhhc093blByb3BlcnR5KFwiaXNSdGxcIik/YS5pc1J0bDppLmhhc093blByb3BlcnR5KFwiaXNSdGxcIik/aS5pc1J0bDp0aGlzLm9wdC5pc1J0bCxnPWkudW5zYWZlLEFycmF5LmlzQXJyYXkoaS5zdGVwcykmJihqPWkuc3RlcHMubGVuZ3RoLGs9dGhpcy5fZ2V0U3RlcEkxOG5OdW0odGhpcy5fZ2V0U3RlcE51bShqLTEpKSxuPXRoaXMuX2dldFN0ZXBOdW0oYik9PT10aGlzLl9nZXRTdGVwTnVtKGotMSkpKSk6KGU9YS5jdXN0b21EYXRhLGQ9YS5jdXN0b21SZW5kZXJlcixnPWEudW5zYWZlLGEuaXNSdGw9YS5oYXNPd25Qcm9wZXJ0eShcImlzUnRsXCIpP2EuaXNSdGw6dGhpcy5vcHQuaXNSdGwpLGw9bj9oLmdldEkxOE5TdHJpbmcoXCJkb25lQnRuXCIpOmEuc2hvd1NraXA/aC5nZXRJMThOU3RyaW5nKFwic2tpcEJ0blwiKTpoLmdldEkxOE5TdHJpbmcoXCJuZXh0QnRuXCIpLGguZmxpcFBsYWNlbWVudChhKSxoLm5vcm1hbGl6ZVBsYWNlbWVudChhKSx0aGlzLnBsYWNlbWVudD1hLnBsYWNlbWVudCxxPXtpMThuOntwcmV2QnRuOmguZ2V0STE4TlN0cmluZyhcInByZXZCdG5cIiksbmV4dEJ0bjpsLGNsb3NlVG9vbHRpcDpoLmdldEkxOE5TdHJpbmcoXCJjbG9zZVRvb2x0aXBcIiksc3RlcE51bTp0aGlzLl9nZXRTdGVwSTE4bk51bSh0aGlzLl9nZXRTdGVwTnVtKGIpKSxudW1TdGVwczprfSxidXR0b25zOntzaG93UHJldjpoLnZhbE9yRGVmYXVsdChhLnNob3dQcmV2QnV0dG9uLHRoaXMub3B0LnNob3dQcmV2QnV0dG9uKSYmdGhpcy5fZ2V0U3RlcE51bShiKT4wLHNob3dOZXh0OmgudmFsT3JEZWZhdWx0KGEuc2hvd05leHRCdXR0b24sdGhpcy5vcHQuc2hvd05leHRCdXR0b24pLHNob3dDVEE6aC52YWxPckRlZmF1bHQoYS5zaG93Q1RBQnV0dG9uJiZhLmN0YUxhYmVsLCExKSxjdGFMYWJlbDphLmN0YUxhYmVsLHNob3dDbG9zZTpoLnZhbE9yRGVmYXVsdCh0aGlzLm9wdC5zaG93Q2xvc2VCdXR0b24sITApfSxzdGVwOntudW06Yixpc0xhc3Q6aC52YWxPckRlZmF1bHQobiwhMSksdGl0bGU6YS50aXRsZXx8XCJcIixjb250ZW50OmEuY29udGVudHx8XCJcIixpc1J0bDphLmlzUnRsLHBsYWNlbWVudDphLnBsYWNlbWVudCxwYWRkaW5nOmgudmFsT3JEZWZhdWx0KGEucGFkZGluZyx0aGlzLm9wdC5idWJibGVQYWRkaW5nKSx3aWR0aDpoLmdldFBpeGVsVmFsdWUoYS53aWR0aCl8fHRoaXMub3B0LmJ1YmJsZVdpZHRoLGN1c3RvbURhdGE6YS5jdXN0b21EYXRhfHx7fX0sdG91cjp7aXNUb3VyOnRoaXMub3B0LmlzVG91ckJ1YmJsZSxudW1TdGVwczpqLHVuc2FmZTpoLnZhbE9yRGVmYXVsdChnLCExKSxjdXN0b21EYXRhOmV8fHt9fX0sXCJmdW5jdGlvblwiPT10eXBlb2YgZClyLmlubmVySFRNTD1kKHEpO2Vsc2UgaWYoXCJzdHJpbmdcIj09dHlwZW9mIGQpe2lmKCFtLnRlbXBsYXRlc3x8XCJmdW5jdGlvblwiIT10eXBlb2YgbS50ZW1wbGF0ZXNbZF0pdGhyb3cgbmV3IEVycm9yKCdCdWJibGUgcmVuZGVyaW5nIGZhaWxlZCAtIHRlbXBsYXRlIFwiJytkKydcIiBpcyBub3QgYSBmdW5jdGlvbi4nKTtyLmlubmVySFRNTD1tLnRlbXBsYXRlc1tkXShxKX1lbHNlIGlmKGYpci5pbm5lckhUTUw9ZihxKTtlbHNle2lmKCFtLnRlbXBsYXRlc3x8XCJmdW5jdGlvblwiIT10eXBlb2YgbS50ZW1wbGF0ZXNbb10pdGhyb3cgbmV3IEVycm9yKCdCdWJibGUgcmVuZGVyaW5nIGZhaWxlZCAtIHRlbXBsYXRlIFwiJytvKydcIiBpcyBub3QgYSBmdW5jdGlvbi4nKTtyLmlubmVySFRNTD1tLnRlbXBsYXRlc1tvXShxKX12YXIgcyx0PXIuY2hpbGRyZW4sdT10Lmxlbmd0aDtmb3IocD0wO3U+cDtwKyspcz10W3BdLGguaGFzQ2xhc3MocyxcImhvcHNjb3RjaC1hcnJvd1wiKSYmKHRoaXMuYXJyb3dFbD1zKTtyZXR1cm4gci5zdHlsZS56SW5kZXg9XCJudW1iZXJcIj09dHlwZW9mIGEuemluZGV4P2EuemluZGV4OlwiXCIsdGhpcy5fc2V0QXJyb3coYS5wbGFjZW1lbnQpLHRoaXMuaGlkZSghMSksdGhpcy5zZXRQb3NpdGlvbihhKSxjJiZjKCFhLmZpeGVkRWxlbWVudCksdGhpc30sX2dldFN0ZXBOdW06ZnVuY3Rpb24oYSl7dmFyIGIsYyxkPTAsZT1tLmdldFNraXBwZWRTdGVwc0luZGV4ZXMoKSxmPWUubGVuZ3RoO2ZvcihjPTA7Zj5jO2MrKyliPWVbY10sYT5iJiZkKys7cmV0dXJuIGEtZH0sX2dldFN0ZXBJMThuTnVtOmZ1bmN0aW9uKGEpe3ZhciBiPWguZ2V0STE4TlN0cmluZyhcInN0ZXBOdW1zXCIpO3JldHVybiBiJiZhPGIubGVuZ3RoP2E9YlthXTphKz0xLGF9LF9zZXRBcnJvdzpmdW5jdGlvbihhKXtoLnJlbW92ZUNsYXNzKHRoaXMuYXJyb3dFbCxcImRvd24gdXAgcmlnaHQgbGVmdFwiKSxcInRvcFwiPT09YT9oLmFkZENsYXNzKHRoaXMuYXJyb3dFbCxcImRvd25cIik6XCJib3R0b21cIj09PWE/aC5hZGRDbGFzcyh0aGlzLmFycm93RWwsXCJ1cFwiKTpcImxlZnRcIj09PWE/aC5hZGRDbGFzcyh0aGlzLmFycm93RWwsXCJyaWdodFwiKTpcInJpZ2h0XCI9PT1hJiZoLmFkZENsYXNzKHRoaXMuYXJyb3dFbCxcImxlZnRcIil9LF9nZXRBcnJvd0RpcmVjdGlvbjpmdW5jdGlvbigpe3JldHVyblwidG9wXCI9PT10aGlzLnBsYWNlbWVudD9cImRvd25cIjpcImJvdHRvbVwiPT09dGhpcy5wbGFjZW1lbnQ/XCJ1cFwiOlwibGVmdFwiPT09dGhpcy5wbGFjZW1lbnQ/XCJyaWdodFwiOlwicmlnaHRcIj09PXRoaXMucGxhY2VtZW50P1wibGVmdFwiOnZvaWQgMH0sc2hvdzpmdW5jdGlvbigpe3ZhciBhPXRoaXMsYj1cImZhZGUtaW4tXCIrdGhpcy5fZ2V0QXJyb3dEaXJlY3Rpb24oKSxjPTFlMztyZXR1cm4gaC5yZW1vdmVDbGFzcyh0aGlzLmVsZW1lbnQsXCJoaWRlXCIpLGguYWRkQ2xhc3ModGhpcy5lbGVtZW50LGIpLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtoLnJlbW92ZUNsYXNzKGEuZWxlbWVudCxcImludmlzaWJsZVwiKX0sNTApLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtoLnJlbW92ZUNsYXNzKGEuZWxlbWVudCxiKX0sYyksdGhpcy5pc1Nob3dpbmc9ITAsdGhpc30saGlkZTpmdW5jdGlvbihhKXt2YXIgYj10aGlzLmVsZW1lbnQ7cmV0dXJuIGE9aC52YWxPckRlZmF1bHQoYSwhMCksYi5zdHlsZS50b3A9XCJcIixiLnN0eWxlLmxlZnQ9XCJcIixhPyhoLmFkZENsYXNzKGIsXCJoaWRlXCIpLGgucmVtb3ZlQ2xhc3MoYixcImludmlzaWJsZVwiKSk6KGgucmVtb3ZlQ2xhc3MoYixcImhpZGVcIiksaC5hZGRDbGFzcyhiLFwiaW52aXNpYmxlXCIpKSxoLnJlbW92ZUNsYXNzKGIsXCJhbmltYXRlIGZhZGUtaW4tdXAgZmFkZS1pbi1kb3duIGZhZGUtaW4tcmlnaHQgZmFkZS1pbi1sZWZ0XCIpLHRoaXMuaXNTaG93aW5nPSExLHRoaXN9LGRlc3Ryb3k6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmVsZW1lbnQ7YSYmYS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGEpLGgucmVtb3ZlRXZ0TGlzdGVuZXIoYSxcImNsaWNrXCIsdGhpcy5jbGlja0NiKX0sX2hhbmRsZUJ1YmJsZUNsaWNrOmZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGIoYyl7cmV0dXJuIGM9PT1hLmN1cnJlbnRUYXJnZXQ/bnVsbDpoLmhhc0NsYXNzKGMsXCJob3BzY290Y2gtY3RhXCIpP1wiY3RhXCI6aC5oYXNDbGFzcyhjLFwiaG9wc2NvdGNoLW5leHRcIik/XCJuZXh0XCI6aC5oYXNDbGFzcyhjLFwiaG9wc2NvdGNoLXByZXZcIik/XCJwcmV2XCI6aC5oYXNDbGFzcyhjLFwiaG9wc2NvdGNoLWNsb3NlXCIpP1wiY2xvc2VcIjpiKGMucGFyZW50RWxlbWVudCl9dmFyIGM7YT1hfHx3aW5kb3cuZXZlbnQ7dmFyIGQ9YS50YXJnZXR8fGEuc3JjRWxlbWVudDtpZihjPWIoZCksXCJjdGFcIj09PWMpdGhpcy5vcHQuaXNUb3VyQnViYmxlfHxtLmdldENhbGxvdXRNYW5hZ2VyKCkucmVtb3ZlQ2FsbG91dCh0aGlzLmN1cnJTdGVwLmlkKSx0aGlzLmN1cnJTdGVwLm9uQ1RBJiZoLmludm9rZUNhbGxiYWNrKHRoaXMuY3VyclN0ZXAub25DVEEpO2Vsc2UgaWYoXCJuZXh0XCI9PT1jKW0ubmV4dFN0ZXAoITApO2Vsc2UgaWYoXCJwcmV2XCI9PT1jKW0ucHJldlN0ZXAoITApO2Vsc2UgaWYoXCJjbG9zZVwiPT09Yyl7aWYodGhpcy5vcHQuaXNUb3VyQnViYmxlKXt2YXIgZT1tLmdldEN1cnJTdGVwTnVtKCksZj1tLmdldEN1cnJUb3VyKCksZz1lPT09Zi5zdGVwcy5sZW5ndGgtMTtoLmludm9rZUV2ZW50Q2FsbGJhY2tzKFwiY2xvc2VcIiksbS5lbmRUb3VyKCEwLGcpfWVsc2UgdGhpcy5vcHQub25DbG9zZSYmaC5pbnZva2VDYWxsYmFjayh0aGlzLm9wdC5vbkNsb3NlKSx0aGlzLm9wdC5pZCYmIXRoaXMub3B0LmlzVG91ckJ1YmJsZT9tLmdldENhbGxvdXRNYW5hZ2VyKCkucmVtb3ZlQ2FsbG91dCh0aGlzLm9wdC5pZCk6dGhpcy5kZXN0cm95KCk7aC5ldnRQcmV2ZW50RGVmYXVsdChhKX19LGluaXQ6ZnVuY3Rpb24oYSl7dmFyIGIsYyxkLGUsZj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLGc9dGhpcyxpPSExO3RoaXMuZWxlbWVudD1mLGU9e3Nob3dQcmV2QnV0dG9uOmwuc2hvd1ByZXZCdXR0b24sc2hvd05leHRCdXR0b246bC5zaG93TmV4dEJ1dHRvbixidWJibGVXaWR0aDpsLmJ1YmJsZVdpZHRoLGJ1YmJsZVBhZGRpbmc6bC5idWJibGVQYWRkaW5nLGFycm93V2lkdGg6bC5hcnJvd1dpZHRoLGlzUnRsOmwuaXNSdGwsc2hvd051bWJlcjohMCxpc1RvdXJCdWJibGU6ITB9LGE9KFwidW5kZWZpbmVkXCI9PXR5cGVvZiBhP1widW5kZWZpbmVkXCI6bihhKSk9PT1xP3t9OmEsaC5leHRlbmQoZSxhKSx0aGlzLm9wdD1lLGYuY2xhc3NOYW1lPVwiaG9wc2NvdGNoLWJ1YmJsZSBhbmltYXRlZFwiLGUuaXNUb3VyQnViYmxlPyhkPW0uZ2V0Q3VyclRvdXIoKSxkJiZoLmFkZENsYXNzKGYsXCJ0b3VyLVwiK2QuaWQpKTpoLmFkZENsYXNzKGYsXCJob3BzY290Y2gtY2FsbG91dCBuby1udW1iZXJcIiksYj1mdW5jdGlvbigpeyFpJiZnLmlzU2hvd2luZyYmKGk9ITAsc2V0VGltZW91dChmdW5jdGlvbigpe2cuc2V0UG9zaXRpb24oZy5jdXJyU3RlcCksaT0hMX0sMTAwKSl9LGguYWRkRXZ0TGlzdGVuZXIod2luZG93LFwicmVzaXplXCIsYiksdGhpcy5jbGlja0NiPWZ1bmN0aW9uKGEpe2cuX2hhbmRsZUJ1YmJsZUNsaWNrKGEpfSxoLmFkZEV2dExpc3RlbmVyKGYsXCJjbGlja1wiLHRoaXMuY2xpY2tDYiksdGhpcy5oaWRlKCksaC5kb2N1bWVudElzUmVhZHkoKT9kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGYpOihkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyPyhjPWZ1bmN0aW9uKCl7ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIixjKSx3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRcIixjKSxkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGYpfSxkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLGMsITEpKTooYz1mdW5jdGlvbigpe1wiY29tcGxldGVcIj09PWRvY3VtZW50LnJlYWR5U3RhdGUmJihkb2N1bWVudC5kZXRhY2hFdmVudChcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiLGMpLHdpbmRvdy5kZXRhY2hFdmVudChcIm9ubG9hZFwiLGMpLGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZikpfSxkb2N1bWVudC5hdHRhY2hFdmVudChcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiLGMpKSxoLmFkZEV2dExpc3RlbmVyKHdpbmRvdyxcImxvYWRcIixjKSl9fSxjPWZ1bmN0aW9uKCl7dmFyIGE9e30sYz17fTt0aGlzLmNyZWF0ZUNhbGxvdXQ9ZnVuY3Rpb24oZCl7dmFyIGU7aWYoIWQuaWQpdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBzcGVjaWZ5IGEgY2FsbG91dCBpZC5cIik7aWYoIXYudGVzdChkLmlkKSl0aHJvdyBuZXcgRXJyb3IoXCJDYWxsb3V0IElEIGlzIHVzaW5nIGFuIGludmFsaWQgZm9ybWF0LiBVc2UgYWxwaGFudW1lcmljLCB1bmRlcnNjb3JlcywgYW5kL29yIGh5cGhlbnMgb25seS4gRmlyc3QgY2hhcmFjdGVyIG11c3QgYmUgYSBsZXR0ZXIuXCIpO2lmKGFbZC5pZF0pdGhyb3cgbmV3IEVycm9yKFwiQ2FsbG91dCBieSB0aGF0IGlkIGFscmVhZHkgZXhpc3RzLiBQbGVhc2UgY2hvb3NlIGEgdW5pcXVlIGlkLlwiKTtpZighaC5nZXRTdGVwVGFyZ2V0KGQpKXRocm93IG5ldyBFcnJvcihcIk11c3Qgc3BlY2lmeSBleGlzdGluZyB0YXJnZXQgZWxlbWVudCB2aWEgJ3RhcmdldCcgb3B0aW9uLlwiKTtyZXR1cm4gZC5zaG93TmV4dEJ1dHRvbj1kLnNob3dQcmV2QnV0dG9uPSExLGQuaXNUb3VyQnViYmxlPSExLGU9bmV3IGIoZCksYVtkLmlkXT1lLGNbZC5pZF09ZCxlLnJlbmRlcihkLG51bGwsZnVuY3Rpb24oKXtlLnNob3coKSxkLm9uU2hvdyYmaC5pbnZva2VDYWxsYmFjayhkLm9uU2hvdyl9KSxlfSx0aGlzLmdldENhbGxvdXQ9ZnVuY3Rpb24oYil7cmV0dXJuIGFbYl19LHRoaXMucmVtb3ZlQWxsQ2FsbG91dHM9ZnVuY3Rpb24oKXt2YXIgYjtmb3IoYiBpbiBhKWEuaGFzT3duUHJvcGVydHkoYikmJnRoaXMucmVtb3ZlQ2FsbG91dChiKX0sdGhpcy5yZW1vdmVDYWxsb3V0PWZ1bmN0aW9uKGIpe3ZhciBkPWFbYl07YVtiXT1udWxsLGNbYl09bnVsbCxkJiZkLmRlc3Ryb3koKX0sdGhpcy5yZWZyZXNoQ2FsbG91dFBvc2l0aW9ucz1mdW5jdGlvbigpe3ZhciBiLGQsZTtmb3IoYiBpbiBhKWEuaGFzT3duUHJvcGVydHkoYikmJmMuaGFzT3duUHJvcGVydHkoYikmJihkPWFbYl0sZT1jW2JdLGQmJmUmJmQuc2V0UG9zaXRpb24oZSkpfX0sYT1mdW5jdGlvbihhKXt2YXIgZCxrLHAsdCx1LHcseCx5LHo9dGhpcyxBPXt9LEI9W10sQz1mdW5jdGlvbihhKXtyZXR1cm4gZCYmZC5lbGVtZW50JiZkLmVsZW1lbnQucGFyZW50Tm9kZXx8KGQ9bmV3IGIocCkpLGEmJmguZXh0ZW5kKGQub3B0LHtidWJibGVQYWRkaW5nOkUoXCJidWJibGVQYWRkaW5nXCIpLGJ1YmJsZVdpZHRoOkUoXCJidWJibGVXaWR0aFwiKSxzaG93TmV4dEJ1dHRvbjpFKFwic2hvd05leHRCdXR0b25cIiksc2hvd1ByZXZCdXR0b246RShcInNob3dQcmV2QnV0dG9uXCIpLHNob3dDbG9zZUJ1dHRvbjpFKFwic2hvd0Nsb3NlQnV0dG9uXCIpLGFycm93V2lkdGg6RShcImFycm93V2lkdGhcIiksaXNSdGw6RShcImlzUnRsXCIpfSksZH0sRD1mdW5jdGlvbigpe2QmJihkLmRlc3Ryb3koKSxkPW51bGwpfSxFPWZ1bmN0aW9uKGEpe3JldHVyblwidW5kZWZpbmVkXCI9PXR5cGVvZiBwP2xbYV06aC52YWxPckRlZmF1bHQocFthXSxsW2FdKX0sRj1mdW5jdGlvbigpe3ZhciBhO3JldHVybiBhPSF0fHwwPnV8fHU+PXQuc3RlcHMubGVuZ3RoP251bGw6dC5zdGVwc1t1XX0sRz1mdW5jdGlvbigpe3oubmV4dFN0ZXAoKX0sSD1mdW5jdGlvbihhKXt2YXIgYixjLGQsZSxmLGcsaT1DKCksaj1pLmVsZW1lbnQsaz1oLmdldFBpeGVsVmFsdWUoai5zdHlsZS50b3ApLGw9aytoLmdldFBpeGVsVmFsdWUoai5vZmZzZXRIZWlnaHQpLG09aC5nZXRTdGVwVGFyZ2V0KEYoKSksbz1tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLHA9by50b3AraC5nZXRTY3JvbGxUb3AoKSxyPW8uYm90dG9tK2guZ2V0U2Nyb2xsVG9wKCksdD1wPms/azpwLHU9bD5yP2w6cix2PWguZ2V0U2Nyb2xsVG9wKCksdz12K2guZ2V0V2luZG93SGVpZ2h0KCkseD10LUUoXCJzY3JvbGxUb3BNYXJnaW5cIik7dD49diYmKHQ8PXYrRShcInNjcm9sbFRvcE1hcmdpblwiKXx8dz49dSk/YSYmYSgpOkUoXCJzbW9vdGhTY3JvbGxcIik/KFwidW5kZWZpbmVkXCI9PXR5cGVvZiBZQUhPTz9cInVuZGVmaW5lZFwiOm4oWUFIT08pKSE9PXEmJm4oWUFIT08uZW52KSE9PXEmJm4oWUFIT08uZW52LnVhKSE9PXEmJm4oWUFIT08udXRpbCkhPT1xJiZuKFlBSE9PLnV0aWwuU2Nyb2xsKSE9PXE/KGI9WUFIT08uZW52LnVhLndlYmtpdD9kb2N1bWVudC5ib2R5OmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxkPVlBSE9PLnV0aWwuRWFzaW5nP1lBSE9PLnV0aWwuRWFzaW5nLmVhc2VPdXQ6dm9pZCAwLGM9bmV3IFlBSE9PLnV0aWwuU2Nyb2xsKGIse3Njcm9sbDp7dG86WzAseF19fSxFKFwic2Nyb2xsRHVyYXRpb25cIikvMWUzLGQpLGMub25Db21wbGV0ZS5zdWJzY3JpYmUoYSksYy5hbmltYXRlKCkpOnM/alF1ZXJ5KFwiYm9keSwgaHRtbFwiKS5hbmltYXRlKHtzY3JvbGxUb3A6eH0sRShcInNjcm9sbER1cmF0aW9uXCIpLGEpOigwPngmJih4PTApLGU9dj50Py0xOjEsZj1NYXRoLmFicyh2LXgpLyhFKFwic2Nyb2xsRHVyYXRpb25cIikvMTApLChnPWZ1bmN0aW9uKCl7dmFyIGI9aC5nZXRTY3JvbGxUb3AoKSxjPWIrZSpmO3JldHVybiBlPjAmJmM+PXh8fDA+ZSYmeD49Yz8oYz14LGEmJmEoKSx2b2lkIHdpbmRvdy5zY3JvbGxUbygwLGMpKTood2luZG93LnNjcm9sbFRvKDAsYyksaC5nZXRTY3JvbGxUb3AoKT09PWI/dm9pZChhJiZhKCkpOnZvaWQgc2V0VGltZW91dChnLDEwKSl9KSgpKTood2luZG93LnNjcm9sbFRvKDAseCksYSYmYSgpKX0sST1mdW5jdGlvbiBQKGEsYil7dmFyIGMsZCxlO3UrYT49MCYmdSthPHQuc3RlcHMubGVuZ3RoPyh1Kz1hLGQ9RigpLGU9ZnVuY3Rpb24oKXtjPWguZ2V0U3RlcFRhcmdldChkKSxjPyhBW3VdJiZkZWxldGUgQVt1XSxiKHUpKTooQVt1XT0hMCxoLmludm9rZUV2ZW50Q2FsbGJhY2tzKFwiZXJyb3JcIiksUChhLGIpKX0sZC5kZWxheT9zZXRUaW1lb3V0KGUsZC5kZWxheSk6ZSgpKTpiKC0xKX0sSj1mdW5jdGlvbihhLGIpe3ZhciBjLGQsZSxmLGc9QygpLGk9dGhpcztpZihnLmhpZGUoKSxhPWgudmFsT3JEZWZhdWx0KGEsITApLGM9RigpLGMubmV4dE9uVGFyZ2V0Q2xpY2smJmgucmVtb3ZlRXZ0TGlzdGVuZXIoaC5nZXRTdGVwVGFyZ2V0KGMpLFwiY2xpY2tcIixHKSxkPWMsZT1iPjA/ZC5tdWx0aXBhZ2U6dT4wJiZ0LnN0ZXBzW3UtMV0ubXVsdGlwYWdlLGY9ZnVuY3Rpb24oYyl7dmFyIGY7aWYoLTE9PT1jKXJldHVybiB0aGlzLmVuZFRvdXIoITApO2lmKGEmJihmPWI+MD9oLmludm9rZUV2ZW50Q2FsbGJhY2tzKFwibmV4dFwiLGQub25OZXh0KTpoLmludm9rZUV2ZW50Q2FsbGJhY2tzKFwicHJldlwiLGQub25QcmV2KSksYz09PXUpe2lmKGUpcmV0dXJuIHZvaWQgTigpO2Y9aC52YWxPckRlZmF1bHQoZiwhMCksZj90aGlzLnNob3dTdGVwKGMpOnRoaXMuZW5kVG91cighMSl9fSwhZSYmRShcInNraXBJZk5vRWxlbWVudFwiKSlJKGIsZnVuY3Rpb24oYSl7Zi5jYWxsKGksYSl9KTtlbHNlIGlmKHUrYj49MCYmdStiPHQuc3RlcHMubGVuZ3RoKXtpZih1Kz1iLGM9RigpLCFoLmdldFN0ZXBUYXJnZXQoYykmJiFlKXJldHVybiBoLmludm9rZUV2ZW50Q2FsbGJhY2tzKFwiZXJyb3JcIiksdGhpcy5lbmRUb3VyKCEwLCExKTtmLmNhbGwodGhpcyx1KX1lbHNlIGlmKHUrYj09PXQuc3RlcHMubGVuZ3RoKXJldHVybiB0aGlzLmVuZFRvdXIoKTtyZXR1cm4gdGhpc30sSz1mdW5jdGlvbihhKXt2YXIgYixjLGQsZT17fTtmb3IoYiBpbiBhKWEuaGFzT3duUHJvcGVydHkoYikmJlwiaWRcIiE9PWImJlwic3RlcHNcIiE9PWImJihlW2JdPWFbYl0pO3JldHVybiB5LmNhbGwodGhpcyxlLCEwKSxjPWguZ2V0U3RhdGUoRShcImNvb2tpZU5hbWVcIikpLGMmJihkPWMuc3BsaXQoXCI6XCIpLHc9ZFswXSx4PWRbMV0sZC5sZW5ndGg+MiYmKEI9ZFsyXS5zcGxpdChcIixcIikpLHg9cGFyc2VJbnQoeCwxMCkpLHRoaXN9LEw9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkLGU7aWYodT1hfHwwLEE9Ynx8e30sZD1GKCksZT1oLmdldFN0ZXBUYXJnZXQoZCkpcmV0dXJuIHZvaWQgYyh1KTtpZighZSl7aWYoaC5pbnZva2VFdmVudENhbGxiYWNrcyhcImVycm9yXCIpLEFbdV09ITAsRShcInNraXBJZk5vRWxlbWVudFwiKSlyZXR1cm4gdm9pZCBJKDEsYyk7dT0tMSxjKHUpfX0sTT1mdW5jdGlvbihhKXtmdW5jdGlvbiBiKCl7ZC5zaG93KCksaC5pbnZva2VFdmVudENhbGxiYWNrcyhcInNob3dcIixjLm9uU2hvdyl9dmFyIGM9dC5zdGVwc1thXSxkPUMoKSxlPWguZ2V0U3RlcFRhcmdldChjKTt1IT09YSYmRigpLm5leHRPblRhcmdldENsaWNrJiZoLnJlbW92ZUV2dExpc3RlbmVyKGguZ2V0U3RlcFRhcmdldChGKCkpLFwiY2xpY2tcIixHKSx1PWEsZC5oaWRlKCExKSxkLnJlbmRlcihjLGEsZnVuY3Rpb24oYSl7YT9IKGIpOmIoKSxjLm5leHRPblRhcmdldENsaWNrJiZoLmFkZEV2dExpc3RlbmVyKGUsXCJjbGlja1wiLEcpfSksTigpfSxOPWZ1bmN0aW9uKCl7dmFyIGE9dC5pZCtcIjpcIit1LGI9bS5nZXRTa2lwcGVkU3RlcHNJbmRleGVzKCk7YiYmYi5sZW5ndGg+MCYmKGErPVwiOlwiK2Iuam9pbihcIixcIikpLGguc2V0U3RhdGUoRShcImNvb2tpZU5hbWVcIiksYSwxKX0sTz1mdW5jdGlvbihhKXthJiZ0aGlzLmNvbmZpZ3VyZShhKX07dGhpcy5nZXRDYWxsb3V0TWFuYWdlcj1mdW5jdGlvbigpe3JldHVybihcInVuZGVmaW5lZFwiPT10eXBlb2Ygaz9cInVuZGVmaW5lZFwiOm4oaykpPT09cSYmKGs9bmV3IGMpLGt9LHRoaXMuc3RhcnRUb3VyPWZ1bmN0aW9uKGEsYil7dmFyIGMsZCxlPXt9LGY9dGhpcztpZighdCl7aWYoIWEpdGhyb3cgbmV3IEVycm9yKFwiVG91ciBkYXRhIGlzIHJlcXVpcmVkIGZvciBzdGFydFRvdXIuXCIpO2lmKCFhLmlkfHwhdi50ZXN0KGEuaWQpKXRocm93IG5ldyBFcnJvcihcIlRvdXIgSUQgaXMgdXNpbmcgYW4gaW52YWxpZCBmb3JtYXQuIFVzZSBhbHBoYW51bWVyaWMsIHVuZGVyc2NvcmVzLCBhbmQvb3IgaHlwaGVucyBvbmx5LiBGaXJzdCBjaGFyYWN0ZXIgbXVzdCBiZSBhIGxldHRlci5cIik7dD1hLEsuY2FsbCh0aGlzLGEpfWlmKChcInVuZGVmaW5lZFwiPT10eXBlb2YgYj9cInVuZGVmaW5lZFwiOm4oYikpIT09cSl7aWYoYj49dC5zdGVwcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiU3BlY2lmaWVkIHN0ZXAgbnVtYmVyIG91dCBvZiBib3VuZHMuXCIpO2Q9Yn1pZighaC5kb2N1bWVudElzUmVhZHkoKSlyZXR1cm4gcj0hMCx0aGlzO2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBkJiZ0LmlkPT09dyYmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiB4P1widW5kZWZpbmVkXCI6bih4KSkhPT1xKXtpZihkPXgsQi5sZW5ndGg+MClmb3IodmFyIGc9MCxpPUIubGVuZ3RoO2k+ZztnKyspZVtCW2ddXT0hMH1lbHNlIGR8fChkPTApO3JldHVybiBMKGQsZSxmdW5jdGlvbihhKXt2YXIgYj0tMSE9PWEmJmguZ2V0U3RlcFRhcmdldCh0LnN0ZXBzW2FdKTtyZXR1cm4gYj8oaC5pbnZva2VFdmVudENhbGxiYWNrcyhcInN0YXJ0XCIpLGM9QygpLGMuaGlkZSghMSksZi5pc0FjdGl2ZT0hMCx2b2lkKGguZ2V0U3RlcFRhcmdldChGKCkpP2Yuc2hvd1N0ZXAoYSk6KGguaW52b2tlRXZlbnRDYWxsYmFja3MoXCJlcnJvclwiKSxFKFwic2tpcElmTm9FbGVtZW50XCIpJiZmLm5leHRTdGVwKCExKSkpKTp2b2lkIGYuZW5kVG91cighMSwhMSl9KSx0aGlzfSx0aGlzLnNob3dTdGVwPWZ1bmN0aW9uKGEpe3ZhciBiPXQuc3RlcHNbYV0sYz11O3JldHVybiBoLmdldFN0ZXBUYXJnZXQoYik/KGIuZGVsYXk/c2V0VGltZW91dChmdW5jdGlvbigpe00oYSl9LGIuZGVsYXkpOk0oYSksdGhpcyk6KHU9YSxoLmludm9rZUV2ZW50Q2FsbGJhY2tzKFwiZXJyb3JcIiksdm9pZCh1PWMpKX0sdGhpcy5wcmV2U3RlcD1mdW5jdGlvbihhKXtyZXR1cm4gSi5jYWxsKHRoaXMsYSwtMSksdGhpc30sdGhpcy5uZXh0U3RlcD1mdW5jdGlvbihhKXtyZXR1cm4gSi5jYWxsKHRoaXMsYSwxKSx0aGlzfSx0aGlzLmVuZFRvdXI9ZnVuY3Rpb24oYSxiKXt2YXIgYyxkPUMoKTtyZXR1cm4gYT1oLnZhbE9yRGVmYXVsdChhLCEwKSxiPWgudmFsT3JEZWZhdWx0KGIsITApLHQmJihjPUYoKSxjJiZjLm5leHRPblRhcmdldENsaWNrJiZoLnJlbW92ZUV2dExpc3RlbmVyKGguZ2V0U3RlcFRhcmdldChjKSxcImNsaWNrXCIsRykpLHU9MCx4PXZvaWQgMCxkLmhpZGUoKSxhJiZoLmNsZWFyU3RhdGUoRShcImNvb2tpZU5hbWVcIikpLHRoaXMuaXNBY3RpdmUmJih0aGlzLmlzQWN0aXZlPSExLHQmJmImJmguaW52b2tlRXZlbnRDYWxsYmFja3MoXCJlbmRcIikpLHRoaXMucmVtb3ZlQ2FsbGJhY2tzKG51bGwsITApLHRoaXMucmVzZXREZWZhdWx0T3B0aW9ucygpLEQoKSx0PW51bGwsdGhpc30sdGhpcy5nZXRDdXJyVG91cj1mdW5jdGlvbigpe3JldHVybiB0fSx0aGlzLmdldEN1cnJUYXJnZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gaC5nZXRTdGVwVGFyZ2V0KEYoKSl9LHRoaXMuZ2V0Q3VyclN0ZXBOdW09ZnVuY3Rpb24oKXtyZXR1cm4gdX0sdGhpcy5nZXRTa2lwcGVkU3RlcHNJbmRleGVzPWZ1bmN0aW9uKCl7dmFyIGEsYj1bXTtmb3IoYSBpbiBBKWIucHVzaChhKTtyZXR1cm4gYn0sdGhpcy5yZWZyZXNoQnViYmxlUG9zaXRpb249ZnVuY3Rpb24oKXt2YXIgYT1GKCk7cmV0dXJuIGEmJkMoKS5zZXRQb3NpdGlvbihhKSx0aGlzLmdldENhbGxvdXRNYW5hZ2VyKCkucmVmcmVzaENhbGxvdXRQb3NpdGlvbnMoKSx0aGlzfSx0aGlzLmxpc3Rlbj1mdW5jdGlvbihhLGIsYyl7cmV0dXJuIGEmJmlbYV0ucHVzaCh7Y2I6Yixmcm9tVG91cjpjfSksdGhpc30sdGhpcy51bmxpc3Rlbj1mdW5jdGlvbihhLGIpe3ZhciBjLGQsZT1pW2FdO2ZvcihjPTAsZD1lLmxlbmd0aDtkPmM7KytjKWVbY10uY2I9PT1iJiZlLnNwbGljZShjLDEpO3JldHVybiB0aGlzfSx0aGlzLnJlbW92ZUNhbGxiYWNrcz1mdW5jdGlvbihhLGIpe3ZhciBjLGQsZSxmO2ZvcihmIGluIGkpaWYoIWF8fGE9PT1mKWlmKGIpZm9yKGM9aVtmXSxkPTAsZT1jLmxlbmd0aDtlPmQ7KytkKWNbZF0uZnJvbVRvdXImJihjLnNwbGljZShkLS0sMSksLS1lKTtlbHNlIGlbZl09W107cmV0dXJuIHRoaXN9LHRoaXMucmVnaXN0ZXJIZWxwZXI9ZnVuY3Rpb24oYSxiKXtcInN0cmluZ1wiPT10eXBlb2YgYSYmXCJmdW5jdGlvblwiPT10eXBlb2YgYiYmKGpbYV09Yil9LHRoaXMudW5yZWdpc3RlckhlbHBlcj1mdW5jdGlvbihhKXtqW2FdPW51bGx9LHRoaXMuaW52b2tlSGVscGVyPWZ1bmN0aW9uKGEpe3ZhciBiLGMsZD1bXTtmb3IoYj0xLGM9YXJndW1lbnRzLmxlbmd0aDtjPmI7KytiKWQucHVzaChhcmd1bWVudHNbYl0pO2pbYV0mJmpbYV0uY2FsbChudWxsLGQpfSx0aGlzLnNldENvb2tpZU5hbWU9ZnVuY3Rpb24oYSl7cmV0dXJuIHAuY29va2llTmFtZT1hLHRoaXN9LHRoaXMucmVzZXREZWZhdWx0T3B0aW9ucz1mdW5jdGlvbigpe3JldHVybiBwPXt9LHRoaXN9LHRoaXMucmVzZXREZWZhdWx0STE4Tj1mdW5jdGlvbigpe3JldHVybiBlPXt9LHRoaXN9LHRoaXMuZ2V0U3RhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gaC5nZXRTdGF0ZShFKFwiY29va2llTmFtZVwiKSl9LHk9ZnVuY3Rpb24oYSxiKXt2YXIgYyxkLGYsZyxpPVtcIm5leHRcIixcInByZXZcIixcInN0YXJ0XCIsXCJlbmRcIixcInNob3dcIixcImVycm9yXCIsXCJjbG9zZVwiXTtmb3IocHx8dGhpcy5yZXNldERlZmF1bHRPcHRpb25zKCksaC5leHRlbmQocCxhKSxhJiZoLmV4dGVuZChlLGEuaTE4biksZj0wLGc9aS5sZW5ndGg7Zz5mOysrZilkPVwib25cIitpW2ZdLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK2lbZl0uc3Vic3RyaW5nKDEpLGFbZF0mJnRoaXMubGlzdGVuKGlbZl0sYVtkXSxiKTtyZXR1cm4gYz1DKCEwKSx0aGlzfSx0aGlzLmNvbmZpZ3VyZT1mdW5jdGlvbihhKXtyZXR1cm4geS5jYWxsKHRoaXMsYSwhMSl9LHRoaXMuc2V0UmVuZGVyZXI9ZnVuY3Rpb24oYSl7dmFyIGI9XCJ1bmRlZmluZWRcIj09dHlwZW9mIGE/XCJ1bmRlZmluZWRcIjpuKGEpO3JldHVyblwic3RyaW5nXCI9PT1iPyhvPWEsZj12b2lkIDApOlwiZnVuY3Rpb25cIj09PWImJihmPWEpLHRoaXN9LHRoaXMuc2V0RXNjYXBlcj1mdW5jdGlvbihhKXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBhJiYoZz1hKSx0aGlzfSxPLmNhbGwodGhpcyxhKX0sbT1uZXcgYSxmdW5jdGlvbigpe3ZhciBhPXt9O2EuZXNjYXBlPWZ1bmN0aW9uKGEpe3JldHVybiBnP2coYSk6bnVsbD09YT9cIlwiOihcIlwiK2EpLnJlcGxhY2UobmV3IFJlZ0V4cChcIlsmPD5cXFwiJ11cIixcImdcIiksZnVuY3Rpb24oYSl7cmV0dXJuXCImXCI9PWE/XCImYW1wO1wiOlwiPFwiPT1hP1wiJmx0O1wiOlwiPlwiPT1hP1wiJmd0O1wiOidcIic9PWE/XCImcXVvdDtcIjpcIidcIj09YT9cIiYjeDI3O1wiOnZvaWQgMH0pfSx0aGlzLnRlbXBsYXRlcz10aGlzLnRlbXBsYXRlc3x8e30sdGhpcy50ZW1wbGF0ZXMuYnViYmxlX2RlZmF1bHQ9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhiLGMpe3JldHVybiBjP2EuZXNjYXBlKGIpOmJ9dmFyIGQsZT1cIlwiO2EuZXNjYXBlLEFycmF5LnByb3RvdHlwZS5qb2luO2UrPVwiXFxuXCI7dmFyIGY9Yi5pMThuLGc9Yi5idXR0b25zLGg9Yi5zdGVwLGk9Yi50b3VyO3JldHVybiBlKz0nXFxuPGRpdiBjbGFzcz1cImhvcHNjb3RjaC1idWJibGUtY29udGFpbmVyXCIgc3R5bGU9XCJ3aWR0aDogJysobnVsbD09KGQ9aC53aWR0aCk/XCJcIjpkKStcInB4OyBwYWRkaW5nOiBcIisobnVsbD09KGQ9aC5wYWRkaW5nKT9cIlwiOmQpKydweDtcIj5cXG4gICcsaS5pc1RvdXImJihlKz0nPHNwYW4gY2xhc3M9XCJob3BzY290Y2gtYnViYmxlLW51bWJlclwiPicrKG51bGw9PShkPWYuc3RlcE51bSk/XCJcIjpkKStcIjwvc3Bhbj5cIiksZSs9J1xcbiAgPGRpdiBjbGFzcz1cImhvcHNjb3RjaC1idWJibGUtY29udGVudFwiPlxcbiAgICAnLFwiXCIhPT1oLnRpdGxlJiYoZSs9JzxoMyBjbGFzcz1cImhvcHNjb3RjaC10aXRsZVwiPicrKG51bGw9PShkPWMoaC50aXRsZSxpLnVuc2FmZSkpP1wiXCI6ZCkrXCI8L2gzPlwiKSxlKz1cIlxcbiAgICBcIixcIlwiIT09aC5jb250ZW50JiYoZSs9JzxkaXYgY2xhc3M9XCJob3BzY290Y2gtY29udGVudFwiPicrKG51bGw9PShkPWMoaC5jb250ZW50LGkudW5zYWZlKSk/XCJcIjpkKStcIjwvZGl2PlwiKSxlKz0nXFxuICA8L2Rpdj5cXG4gIDxkaXYgY2xhc3M9XCJob3BzY290Y2gtYWN0aW9uc1wiPlxcbiAgICAnLGcuc2hvd1ByZXYmJihlKz0nPGJ1dHRvbiBjbGFzcz1cImhvcHNjb3RjaC1uYXYtYnV0dG9uIHByZXYgaG9wc2NvdGNoLXByZXZcIj4nKyhudWxsPT0oZD1mLnByZXZCdG4pP1wiXCI6ZCkrXCI8L2J1dHRvbj5cIiksZSs9XCJcXG4gICAgXCIsZy5zaG93Q1RBJiYoZSs9JzxidXR0b24gY2xhc3M9XCJob3BzY290Y2gtbmF2LWJ1dHRvbiBuZXh0IGhvcHNjb3RjaC1jdGFcIj4nKyhudWxsPT0oZD1nLmN0YUxhYmVsKT9cIlwiOmQpK1wiPC9idXR0b24+XCIpLGUrPVwiXFxuICAgIFwiLGcuc2hvd05leHQmJihlKz0nPGJ1dHRvbiBjbGFzcz1cImhvcHNjb3RjaC1uYXYtYnV0dG9uIG5leHQgaG9wc2NvdGNoLW5leHRcIj4nKyhudWxsPT0oZD1mLm5leHRCdG4pP1wiXCI6ZCkrXCI8L2J1dHRvbj5cIiksZSs9XCJcXG4gIDwvZGl2PlxcbiAgXCIsZy5zaG93Q2xvc2UmJihlKz0nPGJ1dHRvbiBjbGFzcz1cImhvcHNjb3RjaC1idWJibGUtY2xvc2UgaG9wc2NvdGNoLWNsb3NlXCI+JysobnVsbD09KGQ9Zi5jbG9zZVRvb2x0aXApP1wiXCI6ZCkrXCI8L2J1dHRvbj5cIiksZSs9J1xcbjwvZGl2PlxcbjxkaXYgY2xhc3M9XCJob3BzY290Y2gtYnViYmxlLWFycm93LWNvbnRhaW5lciBob3BzY290Y2gtYXJyb3dcIj5cXG4gIDxkaXYgY2xhc3M9XCJob3BzY290Y2gtYnViYmxlLWFycm93LWJvcmRlclwiPjwvZGl2PlxcbiAgPGRpdiBjbGFzcz1cImhvcHNjb3RjaC1idWJibGUtYXJyb3dcIj48L2Rpdj5cXG48L2Rpdj5cXG4nfX0uY2FsbChtKTt2YXIgeT1tO3JldHVybiB5fSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2hvcHNjb3RjaC9kaXN0L2pzL2hvcHNjb3RjaC5taW4uanNcbi8vIG1vZHVsZSBpZCA9IDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///12\n')},function(module,exports){eval('var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function("return this")() || (1,eval)("this");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === "object")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it\'s\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzPzM2OTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUMiLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///13\n')},function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\nexports.exploreVar = undefined;\nexports.get_width = get_width;\nexports.linechart = linechart;\nexports.explore = explore;\nexports.callTreeApp = callTreeApp;\n\nvar _mithril = __webpack_require__(0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _app = __webpack_require__(2);\n\nvar app = _interopRequireWildcard(_app);\n\nvar _plots = __webpack_require__(4);\n\nvar plots = _interopRequireWildcard(_plots);\n\nvar _utils = __webpack_require__(3);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar $private = false;\n\nfunction heatmap(x_Axis_name, y_Axis_name) {\n    var heatchart = (0, _utils.elem)(\'#heatchart\');\n    heatchart.style.display = "block";\n    d3.select("#heatchart").select("svg").remove();\n    heatchart.innerHTML = \'\';\n\n    var margin_heat = { top: 30, right: 10, bottom: 60, left: 60 },\n        width_heat = 500 - margin_heat.left - margin_heat.right,\n        height_heat = 300 - margin_heat.top - margin_heat.bottom;\n    var padding = 100;\n\n    var min_x = d3.min(data_plot, function (d, i) {\n        return data_plot[i].xaxis;\n    });\n    var max_x = d3.max(data_plot, function (d, i) {\n        return data_plot[i].xaxis;\n    });\n    var avg_x = (max_x - min_x) / 100;\n    var min_y = d3.min(data_plot, function (d, i) {\n        return data_plot[i].yaxis;\n    });\n    var max_y = d3.max(data_plot, function (d, i) {\n        return data_plot[i].yaxis;\n    });\n    var avg_y = (max_y - min_y) / 100;\n\n    var x = d3.scale.linear().domain([min_x - avg_x, max_x + avg_x]).range([0, width_heat]);\n\n    var y = d3.scale.linear().domain([min_y - avg_y, max_y + avg_y]).range([height_heat, 0]);\n\n    var z = d3.scale.linear().range(["#EF9A9A", "#EF5350"]);\n\n    // This could be inferred from the data if it weren\'t sparse.\n    var xStep = avg_x + 0.1,\n        yStep = avg_y + 0.2;\n    var svg_heat = d3.select("#heatchart").append("svg").attr("width", width_heat + margin_heat.left + margin_heat.right).attr("height", height_heat + margin_heat.top + margin_heat.bottom).append("g").attr("transform", "translate(" + margin_heat.left + "," + margin_heat.top + ")").style("background-color", "#FFEBEE");\n\n    // Compute the scale domains.\n    x.domain(d3.extent(data_plot, function (d, i) {\n        return data_plot[i].xaxis;\n    }));\n    y.domain(d3.extent(data_plot, function (d, i) {\n        return data_plot[i].yaxis;\n    }));\n    z.domain([0, d3.max(data_plot, function (d, i) {\n        return data_plot[i].score;\n    })]);\n\n    // Extend the x- and y-domain to fit the last bucket.\n    // For example, the y-bucket 3200 corresponds to values [3200, 3300].\n    x.domain([x.domain()[0], +x.domain()[1] + xStep]);\n    y.domain([y.domain()[0], y.domain()[1] + yStep]);\n\n    // Display the tiles for each non-zero bucket.\n    // See http://bl.ocks.org/3074470 for an alternative implementation.\n    svg_heat.selectAll(".tile").data(data_plot).enter().append("rect").attr("class", "tile").attr("x", function (d, i) {\n        return x(data_plot[i].xaxis);\n    }).attr("y", function (d, i) {\n        return y(data_plot[i].yaxis + yStep);\n    }).attr("width", 15).attr("height", 15).attr("dx", ".35em").attr("dy", ".35em").style("fill", function (d, i) {\n        return z(data_plot[i].score);\n    });\n\n    svg_heat.append("text").attr("class", "label").attr("x", width_heat + 20).attr("y", 10).attr("dy", ".35em").text("Count");\n\n    // Add an x-axis with label.\n    svg_heat.append("g").attr("class", "x axis").attr("transform", "translate(0," + height_heat + ")").call(d3.svg.axis().scale(x).ticks(5).tickSize(-height_heat).orient("bottom")).append("text").attr("class", "label").attr("x", width_heat).attr("y", -6).attr("text-anchor", "end").text("");\n\n    // Add a y-axis with label.\n    svg_heat.append("g").attr("class", "y axis").call(d3.svg.axis().scale(y).tickSize(-width_heat).orient("left")).append("text").attr("class", "label").attr("y", 6).attr("dy", ".71em").attr("text-anchor", "end").attr("transform", "rotate(-90)").text("");\n\n    svg_heat.append("text").attr("text-anchor", "middle") // this makes it easy to centre the text as the transform is applied to the anchor\n    .attr("transform", "translate(-40," + height_heat / 2 + ")rotate(-90)") // text is drawn off the screen top left, move down and out and rotate\n    .text(y_Axis_name).style("fill", "#424242").style("text-indent", "20px").style("font-size", "12px").style("font-weight", "bold");\n\n    svg_heat.append("text").attr("text-anchor", "middle") // this makes it easy to centre the text as the transform is applied to the anchor\n    .attr("transform", "translate(" + width_heat / 2 + "," + (height_heat + padding / 4) + ")") // centre below axis\n    .text(x_Axis_name).style("fill", "#424242").style("text-indent", "20px").style("font-size", "12px").style("font-weight", "bold");\n}\n\nvar heatxaxis = void 0,\n    heatyaxis = void 0;\nvar data_plot = [];\n\nfunction bivariatePlot(x_Axis, y_Axis, x_Axis_name, y_Axis_name) {\n    heatxaxis = x_Axis_name;\n    heatyaxis = y_Axis_name;\n    app.byId(\'scatterplot\').style.display = \'block\';\n    d3.select("#scatterplot").html("");\n    d3.select("#scatterplot").select("svg").remove();\n\n    // scatter plot\n    data_plot = [];\n    var nanCount = 0;\n    for (var i = 0; i < 1000; i++) {\n        if (isNaN(x_Axis[i]) || isNaN(y_Axis[i])) {\n            nanCount++;\n        } else {\n            var newNumber1 = x_Axis[i];\n            var newNumber2 = y_Axis[i];\n            data_plot.push({ xaxis: newNumber1, yaxis: newNumber2, score: Math.random() * 100 });\n        }\n    }\n\n    // D3 line charts need sorted data\n    data_plot.sort(function (a, b) {\n        return a.xaxis - b.xaxis;\n    });\n\n    var margin = { top: 20, right: 15, bottom: 40, left: 60 },\n        width = 500 - margin.left - margin.right,\n        height = 280 - margin.top - margin.bottom,\n        padding = 100;\n\n    var min_x = d3.min(data_plot, function (_, i) {\n        return data_plot[i].xaxis;\n    });\n    var max_x = d3.max(data_plot, function (_, i) {\n        return data_plot[i].xaxis;\n    });\n    var avg_x = (max_x - min_x) / 10;\n    var min_y = d3.min(data_plot, function (d, i) {\n        return data_plot[i].yaxis;\n    });\n    var max_y = d3.max(data_plot, function (d, i) {\n        return data_plot[i].yaxis;\n    });\n    var avg_y = (max_y - min_y) / 10;\n\n    var xScale = d3.scale.linear().domain([min_x - avg_x, max_x + avg_x]).range([0, width]);\n\n    var yScale = d3.scale.linear().domain([min_y - avg_y, max_y + avg_y]).range([height, 0]);\n\n    var xAxis = d3.svg.axis().scale(xScale).orient(\'bottom\').tickSize(-height);\n\n    var yAxis = d3.svg.axis().scale(yScale).orient(\'left\').ticks(5).tickSize(-width);\n\n    var zoom = d3.behavior.zoom().x(xScale).y(yScale).scaleExtent([1, 10]).on("zoom", zoomed);\n\n    var chart_scatter = d3.select(\'#scatterplot\').append(\'svg:svg\').attr(\'width\', width + margin.right + margin.left).attr(\'height\', height + margin.top + margin.bottom).call(zoom);\n\n    var main1 = chart_scatter.append(\'g\').attr(\'transform\', \'translate(\' + margin.left + \',\' + margin.top + \')\').attr(\'width\', width + margin.right + margin.left).attr(\'height\', height + margin.top + margin.bottom).attr(\'class\', \'main\');\n\n    main1.append(\'g\').attr(\'transform\', \'translate(0,\' + height + \')\').attr(\'class\', \'x axis\').call(xAxis);\n\n    main1.append(\'g\').attr(\'transform\', \'translate(0,0)\').attr(\'class\', \'y axis\').call(yAxis);\n\n    var clip = main1.append("defs").append("svg:clipPath").attr("id", "clip").append("svg:rect").attr("id", "clip-rect").attr("x", "0").attr("y", "0").attr(\'width\', width).attr(\'height\', height);\n\n    main1.append("g").attr("clip-path", "url(#clip)").selectAll("circle").data(data_plot).enter().append("circle").attr("cx", function (_, i) {\n        return xScale(data_plot[i].xaxis);\n    }).attr("cy", function (_, i) {\n        return yScale(data_plot[i].yaxis);\n    }).attr("r", 2).style("fill", "#B71C1C");\n    chart_scatter.append("text").attr("text-anchor", "middle") // this makes it easy to centre the text as the transform is applied to the anchor\n    .attr("transform", "translate(" + padding / 5 + "," + height / 2 + ")rotate(-90)") // text is drawn off the screen top left, move down and out and rotate\n    .text(y_Axis_name).style("fill", "#424242").style("text-indent", "20px").style("font-size", "12px").style("font-weight", "bold");\n\n    chart_scatter.append("text").attr("text-anchor", "middle") // this makes it easy to centre the text as the transform is applied to the anchor\n    .attr("transform", "translate(" + width / 2 + "," + (height + padding / 2) + ")") // centre below axis\n    .text(x_Axis_name).style("fill", "#424242").style("text-indent", "20px").style("font-size", "12px").style("font-weight", "bold");\n\n    function zoomed() {\n        var panX = d3.event.translate[0];\n        var panY = d3.event.translate[1];\n        var scale = d3.event.scale;\n\n        panX = panX > 10 ? 10 : panX;\n        var maxX = -(scale - 1) * width - 10;\n        panX = panX < maxX ? maxX : panX;\n\n        panY = panY > 10 ? 10 : panY;\n        var maxY = -(scale - 1) * height - 10;\n        panY = panY < maxY ? maxY : panY;\n\n        zoom.translate([panX, panY]);\n\n        main1.select(".x.axis").call(xAxis);\n        main1.select(".y.axis").call(yAxis);\n        main1.selectAll("circle").attr("cx", function (_, i) {\n            return xScale(data_plot[i].xaxis);\n        }).attr("cy", function (_, i) {\n            return yScale(data_plot[i].yaxis);\n        }).attr("r", 2.5).style("fill", "#B71C1C");\n    }\n\n    d3.select(\'#NAcount\').style(\'display\', \'block\');\n    d3.select("#NAcount").text("There are " + nanCount + " number of NA values in the relation.");\n}\n\nvar plotnamea = void 0,\n    plotnameb = void 0,\n    varn1 = void 0,\n    varn2 = void 0,\n    varsize1 = void 0,\n    varsize2 = void 0;\n\nvar continuous_n = 0;\nvar bar_n = 0;\n\nfunction get_width(id) {\n    return 50 * (id === \'plotA\' ? continuous_n : bar_n);\n}\n\nfunction crossTabPlots(PlotNameA, PlotNameB, json_obj) {\n    continuous_n = 0;\n    bar_n = 0;\n    plotnamea = PlotNameA;\n    plotnameb = PlotNameB;\n    (0, _utils.trigger)(\'#input1\', \'blur\');\n    (0, _utils.trigger)(\'#input2\', \'blur\');\n    (0, _utils.setAttrs)(\'#input1\', { placeholder: PlotNameA });\n    (0, _utils.setAttrs)(\'#input2\', { placeholder: PlotNameB });\n    var plot_a = \'#plotA\',\n        plot_b = \'#plotB\';\n\n\n    var margin_cross = { top: 30, right: 35, bottom: 40, left: 40 },\n        width_cross = 300 - margin_cross.left - margin_cross.right,\n        height_cross = 160 - margin_cross.top - margin_cross.bottom;\n    var padding_cross = 100;\n\n    d3.select("#input1").on("mouseover", function () {\n        d3.select("#tooltipPlotA").style("visibility", "visible").style("opacity", "1").text(PlotNameA);\n    }).on("mouseout", function () {\n        d3.select("#tooltipPlotA").style("visibility", "hidden").style("opacity", "0");\n    });\n    d3.select("#input2").on("mouseover", function () {\n        d3.select("#tooltipPlotB").style("visibility", "visible").style("opacity", "1").text(PlotNameB);\n    }).on("mouseout", function () {\n        d3.select("#tooltipPlotB").style("visibility", "hidden").style("opacity", "0");\n    });\n\n    var plot_nodes = app.nodes.slice();\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n        for (var _iterator = plot_nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var node = _step.value;\n\n            if (node.name === PlotNameA) {\n                if (node.plottype === "continuous") {\n                    continuous_n++;\n                    density_cross(node);\n                } else if (node.plottype === "bar") {\n                    bar_n++;\n                    bar_cross(node);\n                }\n            } else if (node.name === PlotNameB) {\n                if (node.plottype === "continuous") {\n                    continuous_n++;\n                    density_cross(node);\n                } else if (node.plottype === "bar") {\n                    bar_n++;\n                    bar_cross(node);\n                }\n            }\n        }\n    } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n            }\n        } finally {\n            if (_didIteratorError) {\n                throw _iteratorError;\n            }\n        }\n    }\n\n    var plotA_size = void 0,\n        plotB_size = void 0,\n        plotA_sizem = void 0,\n        plotB_sizem = void 0;\n    var varn1 = void 0,\n        varn2 = void 0,\n        varsize1 = void 0,\n        varsize2 = void 0;\n    var setStatus = function setStatus(id, plot, n, size) {\n        return (0, _utils.elem)(id).innerHTML = plot + \' : \' + n + \' distribution with \' + size + \' divisions\';\n    };\n    (0, _utils.elem)("#Equidistance1").onclick = function () {\n        varn1 = "equidistance";\n        plotA_size = parseInt(d3.select("#input1")[0][0].value);\n        varsize1 = plotA_size;\n        equidistance(PlotNameA, plotA_size);\n        setStatus("#plotA_status", PlotNameA, varn1, varsize1);\n    };\n    (0, _utils.elem)("#Equimass1").onclick = function () {\n        varn1 = "equimass";\n        plotA_sizem = parseInt(d3.select("#input1")[0][0].value);\n        varsize1 = plotA_sizem;\n        equimass(PlotNameA, plotA_sizem);\n        setStatus("#plotA_status", PlotNameA, varn1, varsize1);\n    };\n    (0, _utils.elem)("#Equidistance2").onclick = function () {\n        varn2 = "equidistance";\n        plotB_size = parseInt(d3.select("#input2")[0][0].value);\n        equidistance(PlotNameB, plotB_size);\n        varsize2 = plotB_size;\n        setStatus("#plotB_status", PlotNameB, varn2, varsize2);\n    };\n    (0, _utils.elem)("#Equimass2").onclick = function () {\n        varn2 = "equimass";\n        plotB_sizem = parseInt(d3.select("#input2")[0][0].value);\n        equimass(PlotNameB, plotB_sizem);\n        varsize2 = plotB_sizem;\n        setStatus("#plotB_status", PlotNameB, varn2, varsize2);\n    };\n\n    // this is the function to add  the density plot if any\n    function density_cross(density_env, a, method_name) {\n        // setup the x_cord according to the size given by user\n        var yVals = density_env.ploty;\n        var xVals = density_env.plotx;\n\n        // an array of objects\n        var data2 = [];\n        for (var i = 0; i < density_env.plotx.length; i++) {\n            data2.push({ x: density_env.plotx[i], y: density_env.ploty[i] });\n        }\n        data2.forEach(function (d) {\n            d.x = +d.x;\n            d.y = +d.y;\n        });\n\n        var min_x = d3.min(data2, function (d, i) {\n            return data2[i].x;\n        });\n        var max_x = d3.max(data2, function (d, i) {\n            return data2[i].x;\n        });\n        var avg_x = (max_x - min_x) / 10;\n        var min_y = d3.min(data2, function (d, i) {\n            return data2[i].y;\n        });\n        var max_y = d3.max(data2, function (d, i) {\n            return data2[i].y;\n        });\n        var avg_y = (max_y - min_y) / 10;\n        var x = d3.scale.linear().domain([d3.min(xVals), d3.max(xVals)]).range([0, width_cross]);\n        var invx = d3.scale.linear().range([d3.min(data2.map(function (d) {\n            return d.x;\n        })), d3.max(data2.map(function (d) {\n            return d.x;\n        }))]).domain([0, width_cross]);\n        var y = d3.scale.linear().domain([d3.min(data2.map(function (d) {\n            return d.y;\n        })), d3.max(data2.map(function (d) {\n            return d.y;\n        }))]).range([height_cross, 0]);\n        var xAxis = d3.svg.axis().scale(x).ticks(5).orient("bottom");\n        var yAxis = d3.svg.axis().scale(y).orient("left");\n        var area = d3.svg.area().interpolate("monotone").x(function (d) {\n            return x(d.x);\n        }).y0(height_cross - avg_y).y1(function (d) {\n            return y(d.y);\n        });\n        var line = d3.svg.line().x(function (d) {\n            return x(d.x);\n        }).y(function (d) {\n            return y(d.y);\n        }).interpolate("monotone");\n\n        var plotsvg = d3.select(plot_a).append("svg").attr("id", "plotsvg_id").style("width", width_cross + margin_cross.left + margin_cross.right) //setting height to the height of #main.left\n        .style("height", height_cross + margin_cross.top + margin_cross.bottom).style("margin-left", "20px").append("g").attr("transform", "translate(0," + margin_cross.top + ")");\n        plotsvg.append("path").attr("id", "path1").datum(data2).attr("class", "area").attr("d", area);\n        plotsvg.append("g").attr("class", "x axis").attr("transform", "translate(0," + height_cross + ")").call(xAxis);\n        plotsvg.append("text").attr("x", width_cross / 2).attr("y", margin_cross.top + padding_cross - 10).attr("text-anchor", "middle").text(density_env.name).style("text-indent", "20px").style("font-size", "12px").style("font-weight", "bold");\n\n        if (isNaN(a) || a === 0) {\n            var upper_limit = d3.max(xVals);\n            var lower_limit = d3.min(xVals);\n            var z = 10;\n            var diff = upper_limit - lower_limit;\n            var buffer = diff / z;\n            var x_cord = [];\n            var push_data = lower_limit;\n            for (var i = 0; i < z - 1; i++) {\n                push_data = push_data + buffer;\n                x_cord.push(push_data);\n                plotsvg.append("line").attr("id", "line1").attr("x1", x(x_cord[i])).attr("x2", x(x_cord[i])).attr("y1", y(d3.min(yVals))).attr("y2", y(d3.max(yVals))).style("stroke", "#0D47A1").style("stroke-dasharray", "3");\n            }\n        } else {\n            if (method_name === "equidistance") {\n                var upper_limit = d3.max(xVals);\n                var lower_limit = d3.min(xVals);\n                var diff = upper_limit - lower_limit;\n                var buffer = diff / a;\n                var x_cord = [];\n                var push_data = lower_limit;\n                for (var i = 0; i < a - 1; i++) {\n                    push_data = push_data + buffer;\n                    x_cord.push(push_data);\n                    plotsvg.append("line").attr("id", "line1").attr("x1", x(x_cord[i])).attr("x2", x(x_cord[i])).attr("y1", y(d3.min(yVals))).attr("y2", y(d3.max(yVals))).style("stroke", "#0D47A1").style("stroke-dasharray", "4");\n                }\n            } else if (method_name === "equimass") {\n                // here we use the data from equimassCalculation to draw lines\n                var temp = [];\n                temp = equimassCalculation(density_env, a);\n                for (var i = 1; i < a; i++) {\n                    plotsvg.append("line").attr("id", "line1").attr("x1", x(temp[i])).attr("x2", x(temp[i])).attr("y1", y(d3.min(yVals))).attr("y2", y(d3.max(yVals))).style("stroke", "#0D47A1").style("stroke-dasharray", "4");\n                }\n            }\n        }\n    }\n\n    // this is the function to add the bar plot if any\n    function bar_cross(bar_env, a, method_name) {\n        var barPadding = .015; // Space between bars\n        var topScale = 1.2; // Multiplicative factor to assign space at top within graph - currently removed from implementation\n        var plotXaxis = true;\n\n        // Data\n        var keys = Object.keys(bar_env.plotvalues);\n        var yVals = new Array();\n        var ciUpperVals = new Array();\n        var ciLowerVals = new Array();\n        var ciSize;\n\n        var xVals = new Array();\n        var yValKey = new Array();\n\n        if (bar_env.nature === "nominal") {\n            var xi = 0;\n            for (var i = 0; i < keys.length; i++) {\n                if (bar_env.plotvalues[keys[i]] == 0) {\n                    continue;\n                }\n                yVals[xi] = bar_env.plotvalues[keys[i]];\n                xVals[xi] = xi;\n                if ($private) {\n                    if (bar_env.plotvaluesCI) {\n                        ciLowerVals[xi] = bar_env.plotValuesCI.lowerBound[keys[i]];\n                        ciUpperVals[xi] = bar_env.plotValuesCI.upperBound[keys[i]];\n                    }\n                    ciSize = ciUpperVals[xi] - ciLowerVals[xi];\n                }\n                yValKey.push({ y: yVals[xi], x: keys[i] });\n                xi = xi + 1;\n            }\n            yValKey.sort(function (a, b) {\n                return b.y - a.y;\n            }); // array of objects, each object has y, the same as yVals, and x, the category\n            yVals.sort(function (a, b) {\n                return b - a;\n            }); // array of y values, the height of the bars\n            ciUpperVals.sort(function (a, b) {\n                return b.y - a.y;\n            }); // ?\n            ciLowerVals.sort(function (a, b) {\n                return b.y - a.y;\n            }); // ?\n        } else {\n            for (var i = 0; i < keys.length; i++) {\n                yVals[i] = bar_env.plotvalues[keys[i]];\n                xVals[i] = Number(keys[i]);\n                if ($private) {\n                    if (bar_env.plotvaluesCI) {\n                        ciLowerVals[i] = bar_env.plotvaluesCI.lowerBound[keys[i]];\n                        ciUpperVals[i] = bar_env.plotvaluesCI.upperBound[keys[i]];\n                    }\n                    ciSize = ciUpperVals[i] - ciLowerVals[i];\n                }\n            }\n        }\n\n        if (yVals.length > 15 & bar_env.numchar === "numeric" | yVals.length > 5 & bar_env.numchar === "character") {\n            plotXaxis = false;\n        }\n        var minY = d3.min(yVals);\n        var maxY = d3.max(yVals); // in the future, set maxY to the value of the maximum confidence limit\n        var minX = d3.min(xVals);\n        var maxX = d3.max(xVals);\n        var x_1 = d3.scale.linear().domain([minX - 0.5, maxX + 0.5]).range([0, width_cross]);\n\n        var invx = d3.scale.linear().range([minX - 0.5, maxX + 0.5]).domain([0, width_cross]);\n\n        var y_1 = d3.scale.linear()\n        // .domain([0, maxY])\n        .domain([0, maxY]).range([0, height_cross]);\n\n        var xAxis = d3.svg.axis().scale(x_1).ticks(yVals.length).orient("bottom");\n\n        var yAxis = d3.svg.axis().scale(y_1).orient("left");\n\n        var plotsvg1 = d3.select(plot_b).append("svg").attr("id", "plotsvg1_id").style("width", width_cross + margin_cross.left + margin_cross.right) //setting height to the height of #main.left\n        .style("height", height_cross + margin_cross.top + margin_cross.bottom).style("margin-left", "20px").append("g").attr("transform", "translate(0," + margin_cross.top + ")");\n\n        var rectWidth = x_1(minX + 0.5 - 2 * barPadding); //the "width" is the coordinate of the end of the first bar\n        plotsvg1.selectAll("rect").data(yVals).enter().append("rect").attr("id", "path2").attr("x", function (d, i) {\n            return x_1(xVals[i] - 0.5 + barPadding);\n        }).attr("y", function (d) {\n            return y_1(maxY - d);\n        }).attr("width", rectWidth).attr("height", function (d) {\n            return y_1(d);\n        }).attr("fill", "#fa8072");\n\n        if (plotXaxis) {\n            plotsvg1.append("g").attr("class", "x axis").attr("transform", "translate(0," + height_cross + ")").call(xAxis);\n        }\n\n        plotsvg1.append("text").attr("x", width_cross / 2).attr("y", margin_cross.top + padding_cross - 10).attr("text-anchor", "middle").text(bar_env.name).style("text-indent", "20px").style("font-size", "12px").style("font-weight", "bold");\n\n        if (isNaN(a) || a === 0) {\n            x_cord2 = equimass_bar(bar_env, keys.length);\n            for (var i = 0; i < keys.length - 1; i++) {\n                plotsvg1.append("line").attr("id", "line2").attr("x1", x_1(x_cord2[i])).attr("x2", x_1(x_cord2[i])).attr("y1", y_1(0)).attr("y2", y_1(maxY)).style("stroke", "#212121").style("stroke-dasharray", "4");\n            }\n        } else {\n            if (method_name === "equidistance") {\n                var upper_limit1 = maxX;\n                var lower_limit1 = minX;\n                var diff1 = upper_limit1 - lower_limit1;\n                var buffer1 = diff1 / a;\n                var x_cord1 = [];\n                var push_data1 = lower_limit1;\n                for (var i = 0; i < a - 1; i++) {\n                    push_data1 = push_data1 + buffer1;\n                    x_cord1.push(push_data1);\n                    plotsvg1.append("line").attr("id", "line2").attr("x1", x_1(x_cord1[i])).attr("x2", x_1(x_cord1[i])).attr("y1", y_1(0)).attr("y2", y_1(maxY)).style("stroke", "#0D47A1").style("stroke-dasharray", "4");\n                }\n            } else if (method_name === "equimass") {\n                var x_cord2 = [];\n                x_cord2 = equimass_bar(bar_env, a);\n                for (var i = 0; i < a - 1; i++) {\n                    plotsvg1.append("line").attr("id", "line2").attr("x1", x_1(x_cord2[i])).attr("x2", x_1(x_cord2[i])).attr("y1", y_1(0)).attr("y2", y_1(maxY)).style("stroke", "#0D47A1").style("stroke-dasharray", "4");\n                }\n            }\n        }\n    }\n\n    function equidistance(A, a) {\n        var method_name = "equidistance";\n        // json object to be sent to r server\n        var obj = new Object();\n        obj.plotNameA = A;\n        obj.equidistance = a;\n        var string = JSON.stringify(obj);\n        for (var i = 0; i < plot_nodes.length; i++) {\n            if (plot_nodes[i].name === A) {\n                if (plot_nodes[i].plottype === "continuous") {\n                    (0, _utils.remove)("#plotsvg_id");\n                    density_cross(plot_nodes[i], a, method_name);\n                } else if (plot_nodes[i].plottype === "bar") {\n                    (0, _utils.remove)("#plotsvg1_id");\n                    bar_cross(plot_nodes[i], a, method_name);\n                }\n            } else {\n                console.log("not found");\n            }\n        }\n    }\n    function equimass(A, a) {\n        //equimass function to call the plot function\n        var method_name = "equimass";\n        var obj = new Object();\n        obj.plotNameA = A;\n        obj.equidistance = a;\n        var string = JSON.stringify(obj);\n        for (var i = 0; i < plot_nodes.length; i++) {\n            if (plot_nodes[i].name === A) {\n                if (plot_nodes[i].plottype === "continuous") {\n                    (0, _utils.remove)("#plotsvg_id");\n                    density_cross(plot_nodes[i], a, method_name);\n                } else if (plot_nodes[i].plottype === "bar") {\n                    (0, _utils.remove)("#plotsvg1_id");\n                    bar_cross(plot_nodes[i], a, method_name);\n                }\n            } else {\n                console.log("not found");\n            }\n        }\n    }\n\n    function equimassCalculation(plot_ev, n) {\n        // here we find the coordinates using CDF values\n        //var n =v-1;\n        var arr_y = [];\n        var arr_x = [];\n\n        arr_y = plot_ev.cdfploty; // cdfploty data stored\n        arr_x = plot_ev.cdfplotx; // cdfplotx data stored\n\n        var Upper_limitY = d3.max(arr_y);\n        var Lower_limitY = d3.min(arr_y);\n        var diffy = Upper_limitY - Lower_limitY;\n        var e = diffy / n; // e is the variable to store the average distance between the points in the cdfy in order to divide the cdfy\n\n        var arr_c = []; //array to store the cdfy divided coordinates data\n        var push_data = arr_y[0];\n        for (var i = 0; i < n; i++) {\n            push_data = push_data + e;\n            arr_c.push(push_data);\n        }\n\n        var temp_cdfx = [];\n        var temp = [];\n        var store = [];\n\n        for (var i = 0; i < n; i++) //to get through each arr_c\n        {\n            for (var j = 0; j < 50; j++) // to compare with cdfy or arr_y\n            {\n                if (arr_c[i] === arr_y[j]) {\n                    store.push({ val: i, coor1: j, coor2: j, diff1: 0.34, diff2: 0 }); // for testing purpose\n                }\n            }\n        }\n        for (var i = 0; i < n; i++) {\n            var diff_val1, diff_val2; // here the diff is not actual difference, it is the fraction of the distance from the two points\n            var x1, x2, x3, x4;\n            for (var j = 0; j < 50; j++) {\n                if (arr_y[j] < arr_c[i] && arr_c[i] < arr_y[j + 1]) {\n                    x1 = arr_c[i];\n                    x2 = arr_c[i] - arr_y[j];\n                    x3 = arr_y[j + 1] - arr_c[i];\n                    x4 = arr_y[j + 1] - arr_y[j];\n                    diff_val1 = x2 / x4;\n                    diff_val2 = x3 / x4;\n                    store.push({ val: i, coor1: j, coor2: j + 1, diff1: diff_val1, diff2: diff_val2 });\n                }\n            }\n        }\n\n        for (var i = 0; i < n; i++) {\n            var y1, y2, y3, diffy1, diffy2;\n            y1 = store[i].val;\n            y2 = store[i].coor1;\n            y3 = store[i].coor2;\n            diffy1 = store[i].diff1;\n            diffy2 = store[i].diff2;\n            var x_coor1 = arr_x[y2];\n            var x_coor2 = arr_x[y3];\n            var x_diff = x_coor2 - x_coor1;\n            var distance1 = x_diff * diffy1;\n            var val_x = x_coor1 + distance1;\n            temp.push(val_x);\n        }\n        return temp;\n    }\n\n    function equimass_bar(plot_ev, n) {\n        var keys = Object.keys(plot_ev.plotvalues);\n        var k = keys.length;\n        var temp = [];\n        var count = 0;\n\n        if (k < n) {\n            alert("error enter vaild size");\n        } else {\n            while (k > 0) {\n                temp.push({ pos: count, val: k });\n                count++;\n                k--;\n                if (count >= n) {\n                    count = 0;\n                }\n            }\n\n            var temp2 = new Array(n);\n            for (var i = 0; i < temp2.length; i++) {\n                temp2[i] = 0;\n            }\n            for (var i = 0; i < keys.length; i++) {\n                keys[i] = (keys[i] + 5) / 10; // to get the increase in the actual values by 0.5 according to the xaxis in plot\n            }\n            for (var i = 0; i < n; i++) {\n                for (var j = 0; j < temp.length; j++) {\n                    if (temp[j].pos === i) {\n                        temp2[i] = temp2[i] + 1;\n                    }\n                }\n            }\n\n            var j = 0,\n                k = 0;\n            var temp_final = new Array(n);\n            for (var i = 0; i < keys.length; i++) {\n                temp2[j] = temp2[j] - 1;\n                if (temp2[j] === 0) {\n                    j++;\n                    temp_final[k] = keys[i];\n                    k++;\n                }\n            }\n            return temp_final;\n        }\n    }\n}\n\nfunction linechart(x_Axis_name, y_Axis_name) {\n    document.getElementById(\'linechart\').style.display = "block";\n    d3.select("#lineChart").select("svg").remove();\n    (0, _utils.elem)(\'#linechart\').innerHTML = \'\';\n    var padding = 10;\n    var w_linechart = 480;\n    var h_linechart = 300;\n    var margin_linechart = { top: 20, right: 80, bottom: 30, left: 50 };\n    var width_linechart = w_linechart - margin_linechart.left - margin_linechart.right;\n    var height_linechart = h_linechart - margin_linechart.top - margin_linechart.bottom;\n\n    var svg = d3.select("#linechart").append("svg").attr("id", "chart").attr("width", w_linechart).attr("height", h_linechart);\n    var chart = svg.append("g").classed("display", true).attr("transform", "translate(" + margin_linechart.left + "," + margin_linechart.top + ")");\n    var x = d3.scale.linear().domain(d3.extent(data_plot, function (d) {\n        return d.xaxis;\n    })).range([0, width_linechart]);\n    var y = d3.scale.linear().domain([d3.min(data_plot, function (d) {\n        return d.yaxis;\n    }), d3.max(data_plot, function (d) {\n        return d.yaxis;\n    })]).range([height_linechart, 0]);\n    var xAxis = d3.svg.axis().scale(x).orient("bottom").ticks(5);\n    var yAxis = d3.svg.axis().scale(y).orient("left").ticks(5);\n    var line = d3.svg.line().x(function (d) {\n        return x(d.xaxis);\n    }).y(function (d) {\n        return y(d.yaxis);\n    });\n\n    function plot(params) {\n        this.append("g").classed("x axis", true).attr("transform", "translate(0," + height_linechart + ")").call(params.axis.x);\n        this.append("g").classed("y axis", true).attr("transform", "translate(0,0)").call(params.axis.y);\n        //enter()\n        this.selectAll(".trendline").data([params.data]).enter().append("path").classed("trendline", true);\n        this.selectAll(".point").data(params.data).enter().append("circle").classed("point", true).attr("r", 2);\n        //update\n        this.selectAll(".trendline").attr("d", function (d) {\n            return line(d);\n        });\n        this.selectAll(".point").attr("cx", function (d) {\n            var date = d.xaxis;\n            return x(date);\n        }).attr("cy", function (d) {\n            return y(d.yaxis);\n        }).style("color", "#EF5350");\n        //exit()\n        this.selectAll(".trendline").data([params.data]).exit().remove();\n        this.selectAll(".point").data(params.data).exit().remove();\n    }\n\n    var temp = d3.select("#main.left").style("width");\n    var width = temp.substring(0, temp.length - 2);\n    var height = window.innerHeight - 120;\n    svg.append("text").attr("text-anchor", "middle") // this makes it easy to centre the text as the transform is applied to the anchor\n    .attr("transform", "translate(" + padding + "," + height / 3 + ")rotate(-90)") // text is drawn off the screen top left, move down and out and rotate\n    .text(y_Axis_name).style("fill", "#424242").style("text-indent", "20px").style("font-size", "12px").style("font-weight", "bold");\n    svg.append("text").attr("text-anchor", "middle") // this makes it easy to centre the text as the transform is applied to the anchor\n    .attr("transform", "translate(" + width / 5 + "," + (height - padding - 128) + ")") // centre below axis\n    .text(x_Axis_name).style("fill", "#424242").style("text-indent", "20px").style("font-size", "12px").style("font-weight", "bold");\n\n    plot.call(chart, {\n        data: data_plot,\n        axis: {\n            x: xAxis,\n            y: yAxis\n        }\n    });\n}\n\nfunction viz(m, json_vizexplore, model_name_set) {\n    d3.select("#plotA").html("");\n    d3.select("#plotB").html("");\n    d3.select("#tabular_1").style("display", "block");\n    d3.select("#tabular_2").style("display", "block");\n\n    var get_data = model_name_set.split("-");\n    var model_name1 = get_data[0] + "-" + get_data[1];\n    var model_name2 = get_data[1] + "-" + get_data[0];\n    var mym = +m.substr(5, 5) - 1;\n\n    function removeKids(parent) {\n        while (parent.firstChild) {\n            parent.removeChild(parent.firstChild);\n        }\n    }\n\n    var json = json_vizexplore;\n    // pipe in figures to right panel\n    var filelist = new Array();\n\n    // image added to the div\n    var x_axis = [];\n    var y_axis = [];\n    for (var i in json.plotdata) {\n        for (var j in json.plotdata[i].varname) {\n            if (json.plotdata[i].varname[j] === get_data[0]) {\n                for (var k in json.plotdata[i].data) {\n                    x_axis[k] = json.plotdata[i].data[k];\n                }\n            }\n            if (json.plotdata[i].varname[j] === get_data[1]) {\n                for (var k in json.plotdata[i].data) {\n                    y_axis[k] = json.plotdata[i].data[k];\n                }\n            }\n        }\n    }\n\n    bivariatePlot(x_axis, y_axis, get_data[0], get_data[1]);\n\n    var heatchart = (0, _utils.elem)(\'#heatchart\');\n    var $linechart = (0, _utils.elem)(\'#linechart\');\n    var scatterplot = (0, _utils.elem)(\'#scatterplot\');\n    (0, _utils.elem)(\'#scatterplot_img\').onclick = function () {\n        (0, _utils.fadeOut)(this, "fast");\n        (0, _utils.fadeIn)(this);\n        (0, _utils.fadeTo)(this, "fast", 1.0);\n        heatchart.style.display = "none";\n        $linechart.style.display = "none";\n        bivariatePlot(x_axis, y_axis, get_data[0], get_data[1]);\n    };\n    (0, _utils.elem)(\'#heatmap_img\').onclick = function () {\n        (0, _utils.fadeOut)(this, "fast");\n        (0, _utils.fadeIn)(this);\n        (0, _utils.fadeTo)(this, "fast", 1.0);\n        $linechart.style.display = "none";\n        scatterplot.style.display = "none";\n        heatmap(get_data[0], get_data[1]);\n    };\n    (0, _utils.elem)(\'#linechart_img\').onclick = function () {\n        (0, _utils.fadeOut)(this, "fast");\n        (0, _utils.fadeIn)(this);\n        (0, _utils.fadeTo)(this, "fast", 1.0);\n        heatchart.style.display = "none";\n        scatterplot.style.display = "none";\n        linechart(get_data[0], get_data[1]);\n    };\n\n    var empty = [];\n    crossTabPlots(get_data[0], get_data[1], empty);\n\n    var cork = [];\n    var corp = [];\n    var cors = [];\n    var var1 = [];\n    var var2 = [];\n    var table_obj = [];\n    var colnames = [];\n    var colvar = [];\n    var table_data = [];\n    var rowvar = [];\n    var rownames = [];\n    function crossTab_Table(json) {\n        table_data = [];\n        table_obj = [];\n        var push = function push(i, key) {\n            return json.tabular[i][key].map(function (v) {\n                return v;\n            });\n        };\n        // data for statistics\n        for (var i in json.tabular) {\n            if (i == model_name1 || i == model_name2) {\n                colnames = push(i, \'colnames\');\n                rownames = push(i, \'rownames\');\n                rowvar = push(i, \'rowvar\');\n                colvar = push(i, \'colvar\');\n            }\n        }\n        for (var i in json.tabular) {\n            if (i == model_name1 || i == model_name2) {\n                for (var n in json.tabular[i].data) {\n                    table_data[n] = [];\n                    for (var a = 0; a < colnames.length; a++) {\n                        table_data[n].push(json.tabular[i].data[n][a]);\n                    }\n                }\n            }\n        }\n        for (var p = 0; p < rownames.length; p++) {\n            for (var l = 0; l < colnames.length; l++) {\n                table_obj.push({ rowname: rownames[p], colname: colnames[l], value: table_data[p][l] });\n            }\n        }\n        d3table1(table_obj);\n    }\n\n    // for the statistics\n    for (var key in json.statistical) {\n        if (key == model_name1 || key == model_name2) {\n            for (var a in json.statistical[key].cork) {\n                cork.push(json.statistical[key].cork[a]);\n            }\n        }\n    }\n    for (var key1 in json.statistical) {\n        if (key1 == model_name1 || key1 == model_name2) {\n            for (var b in json.statistical[key1].corp) {\n                corp.push(json.statistical[key1].corp[b]);\n            }\n        }\n    }\n    for (var key in json.statistical) {\n        if (key == model_name1 || key == model_name2) {\n            for (var c in json.statistical[key].cors) {\n                cors.push(json.statistical[key].cors[c]);\n            }\n        }\n    }\n    for (var key in json.statistical) {\n        if (key == model_name1 || key == model_name2) {\n            for (var d in json.statistical[key].var1) {\n                var1.push(json.statistical[key].var1[d]);\n            }\n        }\n    }\n    for (var key4 in json.statistical) {\n        if (key == model_name1 || key == model_name2) {\n            for (var e in json.statistical[key].var2) {\n                var2.push(json.statistical[key].var2[e]);\n            }\n        }\n    }\n    for (var i = 0; i < app.zparams.zvars.length; i++) {\n        var resultsArray = [];\n    }\n    for (var key in json.tabular) {\n        if (key == "colnames") {\n            console.log("colnames found");\n            continue;\n        }\n        var obj = json.tabular[key];\n        resultsArray.push(obj);\n    }\n\n    function d3table1(data) {\n        var width = 120,\n            // width of svg\n        height = 160,\n            // height of svg\n        padding = 22; // space around the chart, not including labels\n\n        d3.select("#tabular_2").html("").append("h5").text("CROSS-TABS ").style("color", "#424242");\n\n        var sv = d3.select("#tabular_2").append("svg").attr("width", "100%").attr("height", "100%").style("overflow", "visible");\n        var fo = sv.append(\'foreignObject\').attr("width", "100%").attr("height", "100%").style("padding", 10).attr("overflow", "visible");\n        var table = fo.append("xhtml:table").attr("class", "table").style("border-collapse", " collapse"),\n            th = table.append("tr").style("border", 1).text("_").style("color", "#fff");\n        for (var i = 0; i < colnames.length; i++) {\n            th.append("td").style("border-bottom", 1).style("text-align", "center").style("background-color", plots.selVarColor).append("b").text(colnames[i]);\n        }\n        for (var k = 0; k < rownames.length; k++) {\n            var pos = 0;\n            var tr = table.append("tr").style("margin-left", 20).style("background-color", "#BDBDBD").style("border", 1).style("text-align", "center").text(rownames[k]);\n            for (var m = 0; m < colnames.length; m++) {\n                for (var z = 0; z < data.length; z++) {\n                    if (rownames[k] === data[z].rowname && colnames[m] === data[z].colname) {\n                        tr.append("td").style("border", 1).style("text-align", "center").style("position", "relative").style("background-color", app.varColor).text(data[z].value);\n                    }\n                }\n            }\n        }\n    }\n\n    crossTab_Table(json);\n\n    var plotAval = varsize1,\n        plotBval = varsize2;\n    if (isNaN(plotAval)) plotAval = 10;\n    if (isNaN(plotBval)) plotBval = 10;\n    var crosstabs = {\n        var1: {\n            name: plotnamea,\n            value: plotAval,\n            buttonType: varn1\n        },\n        var2: {\n            name: plotnameb,\n            value: plotBval,\n            buttonType: varn2\n        }\n    };\n\n    function removeData(key) {\n        for (var key1 in app.zparams) {\n            if (app.zparams.hasOwnProperty(key1) && key === key1 && app.zparams[key1.length] > 0) app.zparams[key1] = [];\n        }\n    }\n\n    var zbreaks = [];\n    var zbreaks_tabular = [];\n    (0, _utils.elem)(\'#SelectionData1\').click(function () {\n        d3.select("#tabular_2").html("");\n        removeData(\'zcrosstab\');\n        app.zparams.zcrosstab.push(crosstabs);\n        explore_crosstab(json);\n        app.estimateLadda.stop();\n        app.explored = true;\n        zbreaks.push(crosstabs);\n        zbreaks_tabular.push(json.tabular);\n        d3.select(\'#breakspace\').append("span").text(\'\\xA0 \\xA0 \\xA0 \\xA0   \').style("margin-top", 0).style("white-space", "pre").style("display", "inline-block").style("float", "left").append("span").append("button") // top stack for results\n        .attr("class", "btn btn-default btn-xs").attr("id", zbreaks.length).text("break " + (zbreaks.length + 1)).on("click", function () {\n            d3.select("#tabular_2").html("");\n            removeData();\n            var id = this.id - 1;\n            app.zparams.zcrosstab.push(zbreaks[id]);\n            explore_crosstab(zbreaks_tabular[id]);\n\n            var inputvalue1, inputvalue2;\n            inputvalue1 = zbreaks[id].var1.value;\n            inputvalue2 = zbreaks[id].var2.value;\n            document.getElementById("input1").value = inputvalue1;\n            document.getElementById("input2").value = inputvalue2;\n\n            var json_obj = zbreaks[id];\n            var varn1, varn2, varsize1, varsize2;\n            if (json_obj.length === 0) {\n                console.log("break not called");\n            } else {\n                varn1 = json_obj.var1.buttonType;\n                varn2 = json_obj.var2.buttonType;\n                varsize1 = json_obj.var1.value;\n                varsize2 = json_obj.var2.value;\n                if (varn1 === "equidistance") {\n                    crossTabPlots.equidistance(get_data[0], varsize1);\n                } else if (varn1 === "equimass") {\n                    crossTabPlots.equimass(get_data[0], varsize1);\n                }\n                if (varn2 === "equidistance") {\n                    crossTabPlots.equidistance(get_data[1], varsize2);\n                } else if (varn2 === "equimass") {\n                    crossTabPlots.equimass(get_data[1], varsize2);\n                }\n            }\n        });\n    });\n\n    async function explore_crosstab(btn) {\n        if (app.downloadIncomplete()) {\n            return;\n        }\n        app.zPop();\n\n        app.estimateLadda.start();\n        // write links to file & run R CMD\n        app.zparams.callHistory = app.callHistory;\n        var json = await app.makeRequest(ROOK_SVC_URL + \'exploreapp\', app.zparams);\n        app.estimateLadda.start();\n        app.explored = false;\n        d3.json("static/result.json", function (err, json) {\n            if (err) {\n                return console.warn(err);\n            }\n            crossTab_Table(json);\n            app.estimateLadda.stop();\n            app.explored = true;\n        });\n    }\n\n    // data for the statistical div\n    var string1 = cork.toString();\n    var string3 = string1.substring(string1.indexOf(":"), string1.length);\n    var string2 = string1.substring(0, string1.indexOf("c"));\n    var string4 = corp.toString();\n    var string6 = string4.substring(string4.indexOf(":"), string4.length);\n    var string5 = string4.substring(0, string4.indexOf("c"));\n    var string7 = cors.toString();\n    var string9 = string7.substring(string7.indexOf(":"), string7.length);\n    var string8 = string7.substring(0, string7.indexOf("c"));\n    var statistical_data = [{ correlation: string2, value: string3 }, { correlation: string5, value: string6 }, { correlation: string8, value: string9 }];\n\n    function d3table(data) {\n        d3.select("#resultsView_statistics").html("").style("background-color", "#fff").append("h5").text("CORRELATION STATISTICS ").style("color", "#424242");\n        var table = d3.select("#resultsView_statistics").append("table").attr("class", "table").style("border-collapse", " collapse"),\n            th = table.append("tr").style("border", 1);\n        for (var i in Object.keys(data[0])) {\n            th.append("td").style("border-bottom", 1).style("text-align", "left").style("background-color", plots.selVarColor).append("b").text(Object.keys(data[0])[i]);\n        }\n        for (var row in data) {\n            var tr = table.append("tr").style("margin-left", 40).style("border", 1).style("text-align", "left");\n            for (var td in data[row]) {\n                tr.append("td").style("border", 1).style("text-align", "left").style("position", "relative").style("background-color", app.varColor).text(data[row][td]);\n            }\n        }\n    }\n    d3table(statistical_data);\n}\n\nfunction model_selection(model_selection_name, count_value, json) {\n\n    if (count_value % 2 == 0 && count_value != 0) {\n        d3.select("#modelView").append("span").text(\'\\xA0 \\xA0 \\xA0 \\xA0   \\xA0 \').style("margin-top", 0).style("white-space", "pre").style("display", "inline-block").style("float", "left").append("span").text("|").style("margin-top", 0).style("white-space", "pre").style("display", "inline-block").style("float", "left").append("span").text(\'\\xA0 \\xA0 \\xA0 \\xA0   \\xA0 \').style("margin-top", 0).style("white-space", "pre").style("display", "inline-block").style("float", "left");\n    }\n    d3.select("#modelView").append("span").text(\' \\xA0\').style("margin-top", 0).style("float", "left").style("display", "inline-block").style("white-space", "pre").style("overflow-y", "hidden").style("overflow-x", "auto").append("button") // top stack for results\n    //      .append("xhtml:button")\n    .attr("class", "btn btn-outline-success").style("padding", "4px").attr("id", model_selection_name).text(model_selection_name).style(\'background-color\', function () {\n        var color1 = "#FFD54F";\n        return count == count1 ? plots.selVarColor : color1;\n    }).style("display", "inline-block").style("white-space", "pre").style("margin-top", 0).style("float", "left").on("click", function () {\n        var a = this.style.backgroundColor.replace(/\\s*/g, "");\n        var b = app.hexToRgba(plots.selVarColor).replace(/\\s*/g, "");\n        if (a.substr(0, 17) === b.substr(0, 17)) {\n            return; //escapes the function early if the displayed model is clicked\n        }\n        viz(this.id, json, model_selection_name);\n        d3.select("#modelView").selectAll("button").style(\'background-color\', "#FFD54F");\n        d3.select(this).style(\'background-color\', plots.selVarColor);\n        _mithril2.default.redraw();\n    });\n}\n\nfunction showLog() {\n    if (app.logArray.length > 0) {\n        app.byId(\'logdiv\').setAttribute("style", "display:block");\n        d3.select("#collapseLog div.panel-body").selectAll("p").data(app.logArray).enter().append("p").text(function (d) {\n            return d;\n        });\n        return;\n    }\n    app.byId(\'logdiv\').setAttribute("style", "display:none");\n}\n\nvar count = 0;\nvar count1 = 0;\n\n/**\n   called by clicking \'Explore\' in explore mode\n*/\nasync function explore() {\n    if (app.downloadIncomplete()) {\n        return;\n    }\n\n    app.zPop();\n    console.log(\'zpop:\', app.zparams);\n\n    // write links to file & run R CMD\n    app.zparams.callHistory = app.callHistory;\n    app.estimateLadda.start(); // start spinner\n    var json = await app.makeRequest(ROOK_SVC_URL + \'exploreapp\', app.zparams);\n    app.estimateLadda.stop();\n    if (!json) {\n        return;\n    }\n\n    app.allResults.push(json);\n    app.explored = true;\n    app.univariate_finished = false;\n\n    d3.select("#modelView").html(\'\');\n    d3.select("#resultsView_statistics").html(\'\');\n\n    d3.select("#modelView").style(\'background-color\', app.hexToRgba(app.varColor)).style("overflow-y", "hidden").style("overflow-x", "auto").append("span").style("white-space", "pre").style("margin-top", 0).style("float", "left").style("position", "relative").style("color", "#757575").text("MODEL SELECTION :  ");\n\n    count = 0;\n    count1 = 0;\n    var model_name = void 0;\n    for (var img in json.images) {\n        if (count === 0) {\n            model_name = img;\n        }\n        model_selection(img, count, json); // for entering all the variables\n        count++;\n    }\n    count1 = count - 1;\n    app.modelCount++;\n\n    var rCall = [];\n    rCall[0] = json.call;\n    app.logArray.push("explore: ".concat(rCall[0]));\n    showLog();\n    viz(model_name, json, model_name);\n    _mithril2.default.redraw();\n}\n\nvar exploreVar = exports.exploreVar = \'\';\nasync function callTreeApp(node_var, app) {\n    exports.exploreVar = exploreVar = node_var;\n    app.zPop();\n    app.zparams.callHistory = app.callHistory;\n\n    app.estimateLadda.start();\n    var res = await app.makeRequest(ROOK_SVC_URL + \'treeapp\', { zparams: app.zparams, dv: node_var });\n    app.estimateLadda.stop();\n    if (res) {\n        app.explored = false;\n        app.univariate_finished = true;\n        _mithril2.default.redraw();\n        univariatePart(res, node_var);\n    }\n}\n\n// Kripanshu : Function to create D3 Tree using the JSON result from call Tree app\nfunction univariatePart(json, var_name) {\n    app.setRightTabExplore(\'Univariate\');\n    document.getElementById("decisionTree").innerHTML = "";\n    d3.select("#decisionTree").style("display", "block").append("p").style("margin-top", "1px").text(var_name);\n\n    // request for r code using nodevar\n    //code for the  decision tree map\n\n    var m = [15, 100, 15, 100],\n        w = 700 - m[1] - m[3],\n        h = 500 - m[0] - m[2],\n        i = 0,\n        rect_width = 60,\n        rect_height = 20,\n        max_link_width = 20,\n        min_link_width = 1.5,\n        char_to_pxl = 6,\n        root;\n\n    var tree = d3.layout.tree().size([h, w]);\n\n    var diagonal = d3.svg.diagonal().projection(function (d) {\n        return [d.x, d.y];\n    });\n\n    // set height of SVG via height of tree, 200px per layer\n    var getHeight = function getHeight(json_data) {\n        return json_data.children ? Math.max.apply(Math, _toConsumableArray(json_data.children.map(function (v) {\n            return getHeight(v);\n        }))) + 1 : 0;\n    };\n\n    var vis = d3.select("#decisionTree").append("svg:svg").attr("width", w + m[1] + m[3]).attr("height", getHeight(json) * 200 + 20).style(\'height\', \'auto\').append("svg:g").attr("transform", "translate(" + m[3] + "," + m[0] + ")");\n\n    // global scale for link width\n    var link_stoke_scale = d3.scale.linear();\n\n    var color_map = d3.scale.category10();\n\n    // stroke style of link - either color or function\n    var stroke_callback = "#ccc";\n    load_dataset(json);\n\n    function load_dataset(json_data) {\n\n        console.log("our data for decision tree", json_data);\n        root = json_data;\n        root.x0 = 0;\n        root.y0 = 0;\n\n        var n_samples = root.samples;\n        var n_labels = root.value.length;\n\n        if (n_labels >= 2) {\n            stroke_callback = mix_colors;\n        } else if (n_labels === 1) {\n            stroke_callback = mean_interpolation(root);\n        }\n\n        link_stoke_scale = d3.scale.linear().domain([0, n_samples]).range([min_link_width, max_link_width]);\n\n        function toggleAll(d) {\n            if (d && d.children) {\n                d.children.forEach(toggleAll);\n                toggle(d);\n            }\n        }\n\n        // Initialize the display to show a few nodes.\n        root.children.forEach(toggleAll);\n\n        update(root);\n    }\n\n    function update(source) {\n        var duration = d3.event && d3.event.altKey ? 5000 : 500;\n\n        // Compute the new tree layout.\n        var nodes = tree.nodes(root).reverse();\n\n        // Normalize for fixed-depth.\n        nodes.forEach(function (d) {\n            d.y = d.depth * 180;\n        });\n\n        // Update the nodes…\n        var node = vis.selectAll("g.node").data(nodes, function (d) {\n            return d.id || (d.id = ++i);\n        });\n\n        // Enter any new nodes at the parent\'s previous position.\n        var nodeEnter = node.enter().append("svg:g").attr("class", "node").attr("transform", function (d) {\n            return "translate(" + source.x0 + "," + source.y0 + ")";\n        }).on("click", function (d) {\n            toggle(d);\n            update(d);\n        });\n\n        nodeEnter.append("svg:rect").attr("x", function (d) {\n            var label = node_label(d);\n            var text_len = label.length * char_to_pxl;\n            var width = d3.max([rect_width, text_len]);\n            return -width / 2;\n        }).attr("width", 1e-6).attr("height", 1e-6).attr("rx", function (d) {\n            return d.type === "split" ? 2 : 0;\n        }).attr("ry", function (d) {\n            return d.type === "split" ? 2 : 0;\n        }).style("stroke", function (d) {\n            return d.type === "split" ? "steelblue" : "olivedrab";\n        }).style("fill", function (d) {\n            return d._children ? "lightsteelblue" : "#fff";\n        });\n\n        nodeEnter.append("svg:text").attr("dy", "12px").attr("text-anchor", "middle").text(node_label).style("fill-opacity", 1e-6);\n\n        // Transition nodes to their new position.\n        var nodeUpdate = node.transition().duration(duration).attr("transform", function (d) {\n            return "translate(" + d.x + "," + d.y + ")";\n        });\n\n        nodeUpdate.select("rect").attr("width", function (d) {\n            var label = node_label(d);\n            var text_len = label.length * char_to_pxl;\n            var width = d3.max([rect_width, text_len]);\n            return width;\n        }).attr("height", rect_height).style("fill", function (d) {\n            return d._children ? "lightsteelblue" : "#fff";\n        });\n\n        nodeUpdate.select("text").style("fill-opacity", 1);\n\n        // Transition exiting nodes to the parent\'s new position.\n        var nodeExit = node.exit().transition().duration(duration).attr("transform", function (d) {\n            return "translate(" + source.x + "," + source.y + ")";\n        }).remove();\n\n        nodeExit.select("rect").attr("width", 1e-6).attr("height", 1e-6);\n\n        nodeExit.select("text").style("fill-opacity", 1e-6);\n\n        // Update the links\n        var link = vis.selectAll("path.link").data(tree.links(nodes), function (d) {\n            return d.target.id;\n        });\n\n        // Enter any new links at the parent\'s previous position.\n        link.enter().insert("svg:path", "g").attr("class", "link").attr("d", function (d) {\n            var o = {\n                x: source.x0,\n                y: source.y0\n            };\n            return diagonal({\n                source: o,\n                target: o\n            });\n        }).transition().duration(duration).attr("d", diagonal).style("stroke-width", function (d) {\n            return link_stoke_scale(d.target.samples);\n        }).style("stroke", stroke_callback);\n\n        // Transition links to their new position.\n        link.transition().duration(duration).attr("d", diagonal).style("stroke-width", function (d) {\n            return link_stoke_scale(d.target.samples);\n        }).style("stroke", stroke_callback);\n\n        // Transition exiting nodes to the parent\'s new position.\n        link.exit().transition().duration(duration).attr("d", function (d) {\n            var o = {\n                x: source.x,\n                y: source.y\n            };\n            return diagonal({\n                source: o,\n                target: o\n            });\n        }).remove();\n\n        // Stash the old positions for transition.\n        nodes.forEach(function (d) {\n            d.x0 = d.x;\n            d.y0 = d.y;\n        });\n    }\n\n    // Toggle children.\n    function toggle(d) {\n        if (d.children) {\n            d._children = d.children;\n            d.children = null;\n        } else {\n            d.children = d._children;\n            d._children = null;\n        }\n    }\n\n    // Node labels\n    function node_label(d) {\n        if (d.type === "leaf") {\n            // leaf\n            var formatter = d3.format(".2f");\n            var vals = [];\n            d.value.forEach(function (v) {\n                vals.push(formatter(v));\n            });\n            return "[" + vals.join(", ") + "]";\n        } else {\n            // split node\n            return d.label;\n        }\n    }\n\n    /**\n     * Mixes colors according to the relative frequency of classes.\n     */\n    function mix_colors(d) {\n        var value = d.target.value;\n        var sum = d3.sum(value);\n        var col = d3.rgb(0, 0, 0);\n        value.forEach(function (val, i) {\n            var label_color = d3.rgb(color_map(i));\n            var mix_coef = val / sum;\n            col.r += mix_coef * label_color.r;\n            col.g += mix_coef * label_color.g;\n            col.b += mix_coef * label_color.b;\n        });\n        return col;\n    }\n\n    /**\n     * A linear interpolator for value[0].\n     *\n     * Useful for link coloring in regression trees.\n     */\n    function mean_interpolation(root) {\n\n        var max = 1e-9,\n            min = 1e9;\n\n        function recurse(node) {\n            if (node.value[0] > max) {\n                max = node.value[0];\n            }\n\n            if (node.value[0] < min) {\n                min = node.value[0];\n            }\n\n            if (node.children) {\n                node.children.forEach(recurse);\n            }\n        }\n\n        recurse(root);\n\n        var scale = d3.scale.linear().domain([min, max]).range(["#2166AC", "#B2182B"]);\n\n        function interpolator(d) {\n            return scale(d.target.value[0]);\n        }\n\n        return interpolator;\n    }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvYXBwL2V4cGxvcmUuanM/NzYxMCJdLCJuYW1lcyI6WyJnZXRfd2lkdGgiLCJsaW5lY2hhcnQiLCJleHBsb3JlIiwiY2FsbFRyZWVBcHAiLCJhcHAiLCJwbG90cyIsIiRwcml2YXRlIiwiaGVhdG1hcCIsInhfQXhpc19uYW1lIiwieV9BeGlzX25hbWUiLCJoZWF0Y2hhcnQiLCJzdHlsZSIsImRpc3BsYXkiLCJkMyIsInNlbGVjdCIsInJlbW92ZSIsImlubmVySFRNTCIsIm1hcmdpbl9oZWF0IiwidG9wIiwicmlnaHQiLCJib3R0b20iLCJsZWZ0Iiwid2lkdGhfaGVhdCIsImhlaWdodF9oZWF0IiwicGFkZGluZyIsIm1pbl94IiwibWluIiwiZGF0YV9wbG90IiwiZCIsImkiLCJ4YXhpcyIsIm1heF94IiwibWF4IiwiYXZnX3giLCJtaW5feSIsInlheGlzIiwibWF4X3kiLCJhdmdfeSIsIngiLCJzY2FsZSIsImxpbmVhciIsImRvbWFpbiIsInJhbmdlIiwieSIsInoiLCJ4U3RlcCIsInlTdGVwIiwic3ZnX2hlYXQiLCJhcHBlbmQiLCJhdHRyIiwiZXh0ZW50Iiwic2NvcmUiLCJzZWxlY3RBbGwiLCJkYXRhIiwiZW50ZXIiLCJ0ZXh0IiwiY2FsbCIsInN2ZyIsImF4aXMiLCJ0aWNrcyIsInRpY2tTaXplIiwib3JpZW50IiwiaGVhdHhheGlzIiwiaGVhdHlheGlzIiwiYml2YXJpYXRlUGxvdCIsInhfQXhpcyIsInlfQXhpcyIsImJ5SWQiLCJodG1sIiwibmFuQ291bnQiLCJpc05hTiIsIm5ld051bWJlcjEiLCJuZXdOdW1iZXIyIiwicHVzaCIsIk1hdGgiLCJyYW5kb20iLCJzb3J0IiwiYSIsImIiLCJtYXJnaW4iLCJ3aWR0aCIsImhlaWdodCIsIl8iLCJ4U2NhbGUiLCJ5U2NhbGUiLCJ4QXhpcyIsInlBeGlzIiwiem9vbSIsImJlaGF2aW9yIiwic2NhbGVFeHRlbnQiLCJvbiIsInpvb21lZCIsImNoYXJ0X3NjYXR0ZXIiLCJtYWluMSIsImNsaXAiLCJwYW5YIiwiZXZlbnQiLCJ0cmFuc2xhdGUiLCJwYW5ZIiwibWF4WCIsIm1heFkiLCJwbG90bmFtZWEiLCJwbG90bmFtZWIiLCJ2YXJuMSIsInZhcm4yIiwidmFyc2l6ZTEiLCJ2YXJzaXplMiIsImNvbnRpbnVvdXNfbiIsImJhcl9uIiwiaWQiLCJjcm9zc1RhYlBsb3RzIiwiUGxvdE5hbWVBIiwiUGxvdE5hbWVCIiwianNvbl9vYmoiLCJwbGFjZWhvbGRlciIsInBsb3RfYSIsInBsb3RfYiIsIm1hcmdpbl9jcm9zcyIsIndpZHRoX2Nyb3NzIiwiaGVpZ2h0X2Nyb3NzIiwicGFkZGluZ19jcm9zcyIsInBsb3Rfbm9kZXMiLCJub2RlcyIsInNsaWNlIiwibm9kZSIsIm5hbWUiLCJwbG90dHlwZSIsImRlbnNpdHlfY3Jvc3MiLCJiYXJfY3Jvc3MiLCJwbG90QV9zaXplIiwicGxvdEJfc2l6ZSIsInBsb3RBX3NpemVtIiwicGxvdEJfc2l6ZW0iLCJzZXRTdGF0dXMiLCJwbG90IiwibiIsInNpemUiLCJvbmNsaWNrIiwicGFyc2VJbnQiLCJ2YWx1ZSIsImVxdWlkaXN0YW5jZSIsImVxdWltYXNzIiwiZGVuc2l0eV9lbnYiLCJtZXRob2RfbmFtZSIsInlWYWxzIiwicGxvdHkiLCJ4VmFscyIsInBsb3R4IiwiZGF0YTIiLCJsZW5ndGgiLCJmb3JFYWNoIiwiaW52eCIsIm1hcCIsImFyZWEiLCJpbnRlcnBvbGF0ZSIsInkwIiwieTEiLCJsaW5lIiwicGxvdHN2ZyIsImRhdHVtIiwidXBwZXJfbGltaXQiLCJsb3dlcl9saW1pdCIsImRpZmYiLCJidWZmZXIiLCJ4X2NvcmQiLCJwdXNoX2RhdGEiLCJ0ZW1wIiwiZXF1aW1hc3NDYWxjdWxhdGlvbiIsImJhcl9lbnYiLCJiYXJQYWRkaW5nIiwidG9wU2NhbGUiLCJwbG90WGF4aXMiLCJrZXlzIiwiT2JqZWN0IiwicGxvdHZhbHVlcyIsIkFycmF5IiwiY2lVcHBlclZhbHMiLCJjaUxvd2VyVmFscyIsImNpU2l6ZSIsInlWYWxLZXkiLCJuYXR1cmUiLCJ4aSIsInBsb3R2YWx1ZXNDSSIsInBsb3RWYWx1ZXNDSSIsImxvd2VyQm91bmQiLCJ1cHBlckJvdW5kIiwiTnVtYmVyIiwibnVtY2hhciIsIm1pblkiLCJtaW5YIiwieF8xIiwieV8xIiwicGxvdHN2ZzEiLCJyZWN0V2lkdGgiLCJ4X2NvcmQyIiwiZXF1aW1hc3NfYmFyIiwidXBwZXJfbGltaXQxIiwibG93ZXJfbGltaXQxIiwiZGlmZjEiLCJidWZmZXIxIiwieF9jb3JkMSIsInB1c2hfZGF0YTEiLCJBIiwib2JqIiwicGxvdE5hbWVBIiwic3RyaW5nIiwiSlNPTiIsInN0cmluZ2lmeSIsImNvbnNvbGUiLCJsb2ciLCJwbG90X2V2IiwiYXJyX3kiLCJhcnJfeCIsImNkZnBsb3R5IiwiY2RmcGxvdHgiLCJVcHBlcl9saW1pdFkiLCJMb3dlcl9saW1pdFkiLCJkaWZmeSIsImUiLCJhcnJfYyIsInRlbXBfY2RmeCIsInN0b3JlIiwiaiIsInZhbCIsImNvb3IxIiwiY29vcjIiLCJkaWZmMiIsImRpZmZfdmFsMSIsImRpZmZfdmFsMiIsIngxIiwieDIiLCJ4MyIsIng0IiwieTIiLCJ5MyIsImRpZmZ5MSIsImRpZmZ5MiIsInhfY29vcjEiLCJ4X2Nvb3IyIiwieF9kaWZmIiwiZGlzdGFuY2UxIiwidmFsX3giLCJrIiwiY291bnQiLCJhbGVydCIsInBvcyIsInRlbXAyIiwidGVtcF9maW5hbCIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJ3X2xpbmVjaGFydCIsImhfbGluZWNoYXJ0IiwibWFyZ2luX2xpbmVjaGFydCIsIndpZHRoX2xpbmVjaGFydCIsImhlaWdodF9saW5lY2hhcnQiLCJjaGFydCIsImNsYXNzZWQiLCJwYXJhbXMiLCJkYXRlIiwiZXhpdCIsInN1YnN0cmluZyIsIndpbmRvdyIsImlubmVySGVpZ2h0Iiwidml6IiwibSIsImpzb25fdml6ZXhwbG9yZSIsIm1vZGVsX25hbWVfc2V0IiwiZ2V0X2RhdGEiLCJzcGxpdCIsIm1vZGVsX25hbWUxIiwibW9kZWxfbmFtZTIiLCJteW0iLCJzdWJzdHIiLCJyZW1vdmVLaWRzIiwicGFyZW50IiwiZmlyc3RDaGlsZCIsInJlbW92ZUNoaWxkIiwianNvbiIsImZpbGVsaXN0IiwieF9heGlzIiwieV9heGlzIiwicGxvdGRhdGEiLCJ2YXJuYW1lIiwiJGxpbmVjaGFydCIsInNjYXR0ZXJwbG90IiwiZW1wdHkiLCJjb3JrIiwiY29ycCIsImNvcnMiLCJ2YXIxIiwidmFyMiIsInRhYmxlX29iaiIsImNvbG5hbWVzIiwiY29sdmFyIiwidGFibGVfZGF0YSIsInJvd3ZhciIsInJvd25hbWVzIiwiY3Jvc3NUYWJfVGFibGUiLCJrZXkiLCJ0YWJ1bGFyIiwidiIsInAiLCJsIiwicm93bmFtZSIsImNvbG5hbWUiLCJkM3RhYmxlMSIsInN0YXRpc3RpY2FsIiwia2V5MSIsImMiLCJrZXk0IiwienBhcmFtcyIsInp2YXJzIiwicmVzdWx0c0FycmF5Iiwic3YiLCJmbyIsInRhYmxlIiwidGgiLCJzZWxWYXJDb2xvciIsInRyIiwidmFyQ29sb3IiLCJwbG90QXZhbCIsInBsb3RCdmFsIiwiY3Jvc3N0YWJzIiwiYnV0dG9uVHlwZSIsInJlbW92ZURhdGEiLCJoYXNPd25Qcm9wZXJ0eSIsInpicmVha3MiLCJ6YnJlYWtzX3RhYnVsYXIiLCJjbGljayIsInpjcm9zc3RhYiIsImV4cGxvcmVfY3Jvc3N0YWIiLCJlc3RpbWF0ZUxhZGRhIiwic3RvcCIsImV4cGxvcmVkIiwiaW5wdXR2YWx1ZTEiLCJpbnB1dHZhbHVlMiIsImJ0biIsImRvd25sb2FkSW5jb21wbGV0ZSIsInpQb3AiLCJzdGFydCIsImNhbGxIaXN0b3J5IiwibWFrZVJlcXVlc3QiLCJST09LX1NWQ19VUkwiLCJlcnIiLCJ3YXJuIiwic3RyaW5nMSIsInRvU3RyaW5nIiwic3RyaW5nMyIsImluZGV4T2YiLCJzdHJpbmcyIiwic3RyaW5nNCIsInN0cmluZzYiLCJzdHJpbmc1Iiwic3RyaW5nNyIsInN0cmluZzkiLCJzdHJpbmc4Iiwic3RhdGlzdGljYWxfZGF0YSIsImNvcnJlbGF0aW9uIiwiZDN0YWJsZSIsInJvdyIsInRkIiwibW9kZWxfc2VsZWN0aW9uIiwibW9kZWxfc2VsZWN0aW9uX25hbWUiLCJjb3VudF92YWx1ZSIsImNvbG9yMSIsImNvdW50MSIsImJhY2tncm91bmRDb2xvciIsInJlcGxhY2UiLCJoZXhUb1JnYmEiLCJyZWRyYXciLCJzaG93TG9nIiwibG9nQXJyYXkiLCJzZXRBdHRyaWJ1dGUiLCJhbGxSZXN1bHRzIiwidW5pdmFyaWF0ZV9maW5pc2hlZCIsIm1vZGVsX25hbWUiLCJpbWciLCJpbWFnZXMiLCJtb2RlbENvdW50IiwickNhbGwiLCJjb25jYXQiLCJleHBsb3JlVmFyIiwibm9kZV92YXIiLCJyZXMiLCJkdiIsInVuaXZhcmlhdGVQYXJ0IiwidmFyX25hbWUiLCJzZXRSaWdodFRhYkV4cGxvcmUiLCJ3IiwiaCIsInJlY3Rfd2lkdGgiLCJyZWN0X2hlaWdodCIsIm1heF9saW5rX3dpZHRoIiwibWluX2xpbmtfd2lkdGgiLCJjaGFyX3RvX3B4bCIsInJvb3QiLCJ0cmVlIiwibGF5b3V0IiwiZGlhZ29uYWwiLCJwcm9qZWN0aW9uIiwiZ2V0SGVpZ2h0IiwianNvbl9kYXRhIiwiY2hpbGRyZW4iLCJ2aXMiLCJsaW5rX3N0b2tlX3NjYWxlIiwiY29sb3JfbWFwIiwiY2F0ZWdvcnkxMCIsInN0cm9rZV9jYWxsYmFjayIsImxvYWRfZGF0YXNldCIsIngwIiwibl9zYW1wbGVzIiwic2FtcGxlcyIsIm5fbGFiZWxzIiwibWl4X2NvbG9ycyIsIm1lYW5faW50ZXJwb2xhdGlvbiIsInRvZ2dsZUFsbCIsInRvZ2dsZSIsInVwZGF0ZSIsInNvdXJjZSIsImR1cmF0aW9uIiwiYWx0S2V5IiwicmV2ZXJzZSIsImRlcHRoIiwibm9kZUVudGVyIiwibGFiZWwiLCJub2RlX2xhYmVsIiwidGV4dF9sZW4iLCJ0eXBlIiwiX2NoaWxkcmVuIiwibm9kZVVwZGF0ZSIsInRyYW5zaXRpb24iLCJub2RlRXhpdCIsImxpbmsiLCJsaW5rcyIsInRhcmdldCIsImluc2VydCIsIm8iLCJmb3JtYXR0ZXIiLCJmb3JtYXQiLCJ2YWxzIiwiam9pbiIsInN1bSIsImNvbCIsInJnYiIsImxhYmVsX2NvbG9yIiwibWl4X2NvZWYiLCJyIiwiZyIsInJlY3Vyc2UiLCJpbnRlcnBvbGF0b3IiXSwibWFwcGluZ3MiOiI7Ozs7OztRQThTZ0JBLFMsR0FBQUEsUztRQTBrQkFDLFMsR0FBQUEsUztRQTJoQk1DLE8sR0FBQUEsTztRQTBEQUMsVyxHQUFBQSxXOztBQTc4Q3RCOzs7O0FBRUE7O0lBQVlDLEc7O0FBQ1o7O0lBQVlDLEs7O0FBQ1o7Ozs7Ozs7O0FBRUEsSUFBTUMsV0FBVyxLQUFqQjs7QUFFQSxTQUFTQyxPQUFULENBQWlCQyxXQUFqQixFQUE4QkMsV0FBOUIsRUFBMkM7QUFDdkMsUUFBSUMsWUFBWSxpQkFBSyxZQUFMLENBQWhCO0FBQ0FBLGNBQVVDLEtBQVYsQ0FBZ0JDLE9BQWhCLEdBQTBCLE9BQTFCO0FBQ0FDLE9BQUdDLE1BQUgsQ0FBVSxZQUFWLEVBQXdCQSxNQUF4QixDQUErQixLQUEvQixFQUFzQ0MsTUFBdEM7QUFDQUwsY0FBVU0sU0FBVixHQUFzQixFQUF0Qjs7QUFFQSxRQUFJQyxjQUFjLEVBQUNDLEtBQUssRUFBTixFQUFVQyxPQUFPLEVBQWpCLEVBQXFCQyxRQUFRLEVBQTdCLEVBQWlDQyxNQUFNLEVBQXZDLEVBQWxCO0FBQUEsUUFDSUMsYUFBYSxNQUFNTCxZQUFZSSxJQUFsQixHQUF5QkosWUFBWUUsS0FEdEQ7QUFBQSxRQUVJSSxjQUFjLE1BQU1OLFlBQVlDLEdBQWxCLEdBQXdCRCxZQUFZRyxNQUZ0RDtBQUdBLFFBQUlJLFVBQVUsR0FBZDs7QUFFQSxRQUFJQyxRQUFRWixHQUFHYSxHQUFILENBQU9DLFNBQVAsRUFBa0IsVUFBVUMsQ0FBVixFQUFhQyxDQUFiLEVBQWdCO0FBQzFDLGVBQU9GLFVBQVVFLENBQVYsRUFBYUMsS0FBcEI7QUFDSCxLQUZXLENBQVo7QUFHQSxRQUFJQyxRQUFRbEIsR0FBR21CLEdBQUgsQ0FBT0wsU0FBUCxFQUFrQixVQUFVQyxDQUFWLEVBQWFDLENBQWIsRUFBZ0I7QUFD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S0FBS2UsS0FBTCxDQUFXLENBQVgsSUFBZ0JqSCxHQUFwQixFQUF5QjtBQUNyQkEsc0JBQU1rRyxLQUFLZSxLQUFMLENBQVcsQ0FBWCxDQUFOO0FBQ0g7O0FBRUQsZ0JBQUlmLEtBQUtzUixRQUFULEVBQW1CO0FBQ2Z0UixxQkFBS3NSLFFBQUwsQ0FBYzVQLE9BQWQsQ0FBc0IwUyxPQUF0QjtBQUNIO0FBQ0o7O0FBRURBLGdCQUFRckQsSUFBUjs7QUFFQSxZQUFJcFcsUUFBUTFCLEdBQUcwQixLQUFILENBQVNDLE1BQVQsR0FBa0JDLE1BQWxCLENBQXlCLENBQUNmLEdBQUQsRUFBTU0sR0FBTixDQUF6QixFQUNQVSxLQURPLENBQ0QsQ0FBQyxTQUFELEVBQVksU0FBWixDQURDLENBQVo7O0FBR0EsaUJBQVN1WixZQUFULENBQXNCcmEsQ0FBdEIsRUFBeUI7QUFDckIsbUJBQU9XLE1BQU1YLEVBQUVzWixNQUFGLENBQVN2UyxLQUFULENBQWUsQ0FBZixDQUFOLENBQVA7QUFDSDs7QUFFRCxlQUFPc1QsWUFBUDtBQUNIO0FBR0oiLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbSBmcm9tICdtaXRocmlsJztcblxuaW1wb3J0ICogYXMgYXBwIGZyb20gJy4vYXBwJztcbmltcG9ydCAqIGFzIHBsb3RzIGZyb20gJy4vcGxvdHMnO1xuaW1wb3J0IHtlbGVtLCBmYWRlSW4sIGZhZGVPdXQsIGZhZGVUbywgcmVtb3ZlLCBzZXRBdHRycywgdHJpZ2dlcn0gZnJvbSAnLi91dGlscyc7XG5cbmNvbnN0ICRwcml2YXRlID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGhlYXRtYXAoeF9BeGlzX25hbWUsIHlfQXhpc19uYW1lKSB7XG4gICAgbGV0IGhlYXRjaGFydCA9IGVsZW0oJyNoZWF0Y2hhcnQnKTtcbiAgICBoZWF0Y2hhcnQuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICBkMy5zZWxlY3QoXCIjaGVhdGNoYXJ0XCIpLnNlbGVjdChcInN2Z1wiKS5yZW1vdmUoKTtcbiAgICBoZWF0Y2hhcnQuaW5uZXJIVE1MID0gJyc7XG5cbiAgICB2YXIgbWFyZ2luX2hlYXQgPSB7dG9wOiAzMCwgcmlnaHQ6IDEwLCBib3R0b206IDYwLCBsZWZ0OiA2MH0sXG4gICAgICAgIHdpZHRoX2hlYXQgPSA1MDAgLSBtYXJnaW5faGVhdC5sZWZ0IC0gbWFyZ2luX2hlYXQucmlnaHQsXG4gICAgICAgIGhlaWdodF9oZWF0ID0gMzAwIC0gbWFyZ2luX2hlYXQudG9wIC0gbWFyZ2luX2hlYXQuYm90dG9tO1xuICAgIHZhciBwYWRkaW5nID0gMTAwO1xuXG4gICAgdmFyIG1pbl94ID0gZDMubWluKGRhdGFfcGxvdCwgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgcmV0dXJuIGRhdGFfcGxvdFtpXS54YXhpcztcbiAgICB9KTtcbiAgICB2YXIgbWF4X3ggPSBkMy5tYXgoZGF0YV9wbG90LCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICByZXR1cm4gZGF0YV9wbG90W2ldLnhheGlzO1xuICAgIH0pO1xuICAgIHZhciBhdmdfeCA9IChtYXhfeCAtIG1pbl94KSAvIDEwMDtcbiAgICB2YXIgbWluX3kgPSBkMy5taW4oZGF0YV9wbG90LCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICByZXR1cm4gZGF0YV9wbG90W2ldLnlheGlzO1xuICAgIH0pO1xuICAgIHZhciBtYXhfeSA9IGQzLm1heChkYXRhX3Bsb3QsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgIHJldHVybiBkYXRhX3Bsb3RbaV0ueWF4aXM7XG4gICAgfSk7XG4gICAgdmFyIGF2Z195ID0gKG1heF95IC0gbWluX3kpIC8gMTAwO1xuXG4gICAgdmFyIHggPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAuZG9tYWluKFttaW5feCAtIGF2Z194LCBtYXhfeCArIGF2Z194XSlcbiAgICAgICAgLnJhbmdlKFswLCB3aWR0aF9oZWF0XSk7XG5cbiAgICB2YXIgeSA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgIC5kb21haW4oW21pbl95IC0gYXZnX3ksIG1heF95ICsgYXZnX3ldKVxuICAgICAgICAucmFuZ2UoW2hlaWdodF9oZWF0LCAwXSk7XG5cbiAgICB2YXIgeiA9IGQzLnNjYWxlLmxpbmVhcigpLnJhbmdlKFtcIiNFRjlBOUFcIiwgXCIjRUY1MzUwXCJdKTtcblxuICAgIC8vIFRoaXMgY291bGQgYmUgaW5mZXJyZWQgZnJvbSB0aGUgZGF0YSBpZiBpdCB3ZXJlbid0IHNwYXJzZS5cbiAgICB2YXIgeFN0ZXAgPSBhdmdfeCsgMC4xLFxuICAgICAgICB5U3RlcCA9IGF2Z195ICsgMC4yO1xuICAgIHZhciBzdmdfaGVhdCA9IGQzLnNlbGVjdChcIiNoZWF0Y2hhcnRcIikuYXBwZW5kKFwic3ZnXCIpXG4gICAgICAgIC5hdHRyKFwid2lkdGhcIiwgd2lkdGhfaGVhdCArIG1hcmdpbl9oZWF0LmxlZnQgKyBtYXJnaW5faGVhdC5yaWdodClcbiAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgaGVpZ2h0X2hlYXQgKyBtYXJnaW5faGVhdC50b3AgKyBtYXJnaW5faGVhdC5ib3R0b20pXG4gICAgICAgIC5hcHBlbmQoXCJnXCIpXG4gICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgbWFyZ2luX2hlYXQubGVmdCArIFwiLFwiICsgbWFyZ2luX2hlYXQudG9wKyBcIilcIilcbiAgICAgICAgLnN0eWxlKFwiYmFja2dyb3VuZC1jb2xvclwiLCBcIiNGRkVCRUVcIik7XG5cblxuICAgIC8vIENvbXB1dGUgdGhlIHNjYWxlIGRvbWFpbnMuXG4gICAgeC5kb21haW4oZDMuZXh0ZW50KGRhdGFfcGxvdCwgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgcmV0dXJuIGRhdGFfcGxvdFtpXS54YXhpcztcbiAgICB9KSk7XG4gICAgeS5kb21haW4oZDMuZXh0ZW50KGRhdGFfcGxvdCwgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgcmV0dXJuIGRhdGFfcGxvdFtpXS55YXhpcztcbiAgICB9KSk7XG4gICAgei5kb21haW4oWzAsIGQzLm1heChkYXRhX3Bsb3QsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgIHJldHVybiBkYXRhX3Bsb3RbaV0uc2NvcmU7XG4gICAgfSldKTtcblxuICAgIC8vIEV4dGVuZCB0aGUgeC0gYW5kIHktZG9tYWluIHRvIGZpdCB0aGUgbGFzdCBidWNrZXQuXG4gICAgLy8gRm9yIGV4YW1wbGUsIHRoZSB5LWJ1Y2tldCAzMjAwIGNvcnJlc3BvbmRzIHRvIHZhbHVlcyBbMzIwMCwgMzMwMF0uXG4gICAgeC5kb21haW4oW3guZG9tYWluKClbMF0sICt4LmRvbWFpbigpWzFdICsgeFN0ZXBdKTtcbiAgICB5LmRvbWFpbihbeS5kb21haW4oKVswXSwgeS5kb21haW4oKVsxXSArIHlTdGVwXSk7XG5cbiAgICAvLyBEaXNwbGF5IHRoZSB0aWxlcyBmb3IgZWFjaCBub24temVybyBidWNrZXQuXG4gICAgLy8gU2VlIGh0dHA6Ly9ibC5vY2tzLm9yZy8zMDc0NDcwIGZvciBhbiBhbHRlcm5hdGl2ZSBpbXBsZW1lbnRhdGlvbi5cbiAgICBzdmdfaGVhdC5zZWxlY3RBbGwoXCIudGlsZVwiKVxuICAgICAgICAuZGF0YShkYXRhX3Bsb3QpXG4gICAgICAgIC5lbnRlcigpLmFwcGVuZChcInJlY3RcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInRpbGVcIilcbiAgICAgICAgLmF0dHIoXCJ4XCIsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4geChkYXRhX3Bsb3RbaV0ueGF4aXMpO1xuICAgICAgICB9KVxuICAgICAgICAuYXR0cihcInlcIiwgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiB5KGRhdGFfcGxvdFtpXS55YXhpcyArIHlTdGVwICk7XG4gICAgICAgIH0pXG4gICAgICAgIC5hdHRyKFwid2lkdGhcIiwgMTUpXG4gICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIDE1KVxuICAgICAgICAuYXR0cihcImR4XCIsIFwiLjM1ZW1cIilcbiAgICAgICAgLmF0dHIoXCJkeVwiLCBcIi4zNWVtXCIpXG4gICAgICAgIC5zdHlsZShcImZpbGxcIiwgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiB6KGRhdGFfcGxvdFtpXS5zY29yZSk7XG4gICAgICAgIH0pO1xuXG5cbiAgICBzdmdfaGVhdC5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJsYWJlbFwiKVxuICAgICAgICAuYXR0cihcInhcIiwgd2lkdGhfaGVhdCArIDIwKVxuICAgICAgICAuYXR0cihcInlcIiwgMTApXG4gICAgICAgIC5hdHRyKFwiZHlcIiwgXCIuMzVlbVwiKVxuICAgICAgICAudGV4dChcIkNvdW50XCIpO1xuXG4gICAgLy8gQWRkIGFuIHgtYXhpcyB3aXRoIGxhYmVsLlxuICAgIHN2Z19oZWF0LmFwcGVuZChcImdcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInggYXhpc1wiKVxuICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLFwiICsgaGVpZ2h0X2hlYXQgKyBcIilcIilcbiAgICAgICAgLmNhbGwoZDMuc3ZnLmF4aXMoKS5zY2FsZSh4KS50aWNrcyg1KS50aWNrU2l6ZSgtaGVpZ2h0X2hlYXQpLm9yaWVudChcImJvdHRvbVwiKSlcbiAgICAgICAgLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImxhYmVsXCIpXG4gICAgICAgIC5hdHRyKFwieFwiLCB3aWR0aF9oZWF0KVxuICAgICAgICAuYXR0cihcInlcIiwgLTYpXG4gICAgICAgIC5hdHRyKFwidGV4dC1hbmNob3JcIiwgXCJlbmRcIilcbiAgICAgICAgLnRleHQoXCJcIik7XG5cbiAgICAvLyBBZGQgYSB5LWF4aXMgd2l0aCBsYWJlbC5cbiAgICBzdmdfaGVhdC5hcHBlbmQoXCJnXCIpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJ5IGF4aXNcIilcbiAgICAgICAgLmNhbGwoZDMuc3ZnLmF4aXMoKS5zY2FsZSh5KS50aWNrU2l6ZSgtd2lkdGhfaGVhdCkub3JpZW50KFwibGVmdFwiKSlcbiAgICAgICAgLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImxhYmVsXCIpXG4gICAgICAgIC5hdHRyKFwieVwiLCA2KVxuICAgICAgICAuYXR0cihcImR5XCIsIFwiLjcxZW1cIilcbiAgICAgICAgLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBcImVuZFwiKVxuICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInJvdGF0ZSgtOTApXCIpXG4gICAgICAgIC50ZXh0KFwiXCIpO1xuXG4gICAgc3ZnX2hlYXQuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAuYXR0cihcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpICAvLyB0aGlzIG1ha2VzIGl0IGVhc3kgdG8gY2VudHJlIHRoZSB0ZXh0IGFzIHRoZSB0cmFuc2Zvcm0gaXMgYXBwbGllZCB0byB0aGUgYW5jaG9yXG4gICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKC00MCxcIiArIChoZWlnaHRfaGVhdCAvIDIpICsgXCIpcm90YXRlKC05MClcIikgIC8vIHRleHQgaXMgZHJhd24gb2ZmIHRoZSBzY3JlZW4gdG9wIGxlZnQsIG1vdmUgZG93biBhbmQgb3V0IGFuZCByb3RhdGVcbiAgICAgICAgLnRleHQoeV9BeGlzX25hbWUpXG4gICAgICAgIC5zdHlsZShcImZpbGxcIiwgXCIjNDI0MjQyXCIpXG4gICAgICAgIC5zdHlsZShcInRleHQtaW5kZW50XCIsXCIyMHB4XCIpXG4gICAgICAgIC5zdHlsZShcImZvbnQtc2l6ZVwiLFwiMTJweFwiKVxuICAgICAgICAuc3R5bGUoXCJmb250LXdlaWdodFwiLFwiYm9sZFwiKTtcblxuICAgIHN2Z19oZWF0LmFwcGVuZChcInRleHRcIilcbiAgICAgICAgLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKSAgLy8gdGhpcyBtYWtlcyBpdCBlYXN5IHRvIGNlbnRyZSB0aGUgdGV4dCBhcyB0aGUgdHJhbnNmb3JtIGlzIGFwcGxpZWQgdG8gdGhlIGFuY2hvclxuICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArICh3aWR0aF9oZWF0IC8gMikgKyBcIixcIiArIChoZWlnaHRfaGVhdCArIHBhZGRpbmcgLyA0KSArIFwiKVwiKSAgLy8gY2VudHJlIGJlbG93IGF4aXNcbiAgICAgICAgLnRleHQoeF9BeGlzX25hbWUpXG4gICAgICAgIC5zdHlsZShcImZpbGxcIiwgXCIjNDI0MjQyXCIpXG4gICAgICAgIC5zdHlsZShcInRleHQtaW5kZW50XCIsXCIyMHB4XCIpXG4gICAgICAgIC5zdHlsZShcImZvbnQtc2l6ZVwiLFwiMTJweFwiKVxuICAgICAgICAuc3R5bGUoXCJmb250LXdlaWdodFwiLFwiYm9sZFwiKTtcbn1cblxubGV0IGhlYXR4YXhpcywgaGVhdHlheGlzO1xubGV0IGRhdGFfcGxvdCA9IFtdO1xuXG5mdW5jdGlvbiBiaXZhcmlhdGVQbG90KHhfQXhpcywgeV9BeGlzLCB4X0F4aXNfbmFtZSwgeV9BeGlzX25hbWUpIHtcbiAgICBoZWF0eGF4aXMgPSB4X0F4aXNfbmFtZTtcbiAgICBoZWF0eWF4aXMgPSB5X0F4aXNfbmFtZTtcbiAgICBhcHAuYnlJZCgnc2NhdHRlcnBsb3QnKS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICBkMy5zZWxlY3QoXCIjc2NhdHRlcnBsb3RcIikuaHRtbChcIlwiKTtcbiAgICBkMy5zZWxlY3QoXCIjc2NhdHRlcnBsb3RcIikuc2VsZWN0KFwic3ZnXCIpLnJlbW92ZSgpO1xuXG4gICAgLy8gc2NhdHRlciBwbG90XG4gICAgZGF0YV9wbG90ID0gW107XG4gICAgbGV0IG5hbkNvdW50ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwMDA7IGkrKykge1xuICAgICAgICBpZiAoaXNOYU4oeF9BeGlzW2ldKSB8fCBpc05hTih5X0F4aXNbaV0pKSB7XG4gICAgICAgICAgICBuYW5Db3VudCsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IG5ld051bWJlcjEgPSB4X0F4aXNbaV07XG4gICAgICAgICAgICBsZXQgbmV3TnVtYmVyMiA9IHlfQXhpc1tpXTtcbiAgICAgICAgICAgIGRhdGFfcGxvdC5wdXNoKHt4YXhpczogbmV3TnVtYmVyMSwgeWF4aXM6IG5ld051bWJlcjIsIHNjb3JlOiBNYXRoLnJhbmRvbSgpICogMTAwfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEMyBsaW5lIGNoYXJ0cyBuZWVkIHNvcnRlZCBkYXRhXG4gICAgZGF0YV9wbG90LnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICByZXR1cm4gYS54YXhpcyAtIGIueGF4aXM7XG4gICAgfSk7XG5cbiAgICBsZXQgbWFyZ2luID0ge3RvcDogMjAsIHJpZ2h0OiAxNSwgYm90dG9tOiA0MCwgbGVmdDogNjB9LFxuICAgICAgICB3aWR0aCA9IDUwMCAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0LFxuICAgICAgICBoZWlnaHQgPSAyODAgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbSxcbiAgICAgICAgcGFkZGluZyA9IDEwMDtcblxuICAgIGxldCBtaW5feCA9IGQzLm1pbihkYXRhX3Bsb3QsIChfLCBpKSA9PiBkYXRhX3Bsb3RbaV0ueGF4aXMpO1xuICAgIGxldCBtYXhfeCA9IGQzLm1heChkYXRhX3Bsb3QsIChfLCBpKSA9PiBkYXRhX3Bsb3RbaV0ueGF4aXMpO1xuICAgIHZhciBhdmdfeCA9IChtYXhfeCAtIG1pbl94KSAvIDEwO1xuICAgIHZhciBtaW5feSA9IGQzLm1pbihkYXRhX3Bsb3QsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgIHJldHVybiBkYXRhX3Bsb3RbaV0ueWF4aXM7XG4gICAgfSk7XG4gICAgdmFyIG1heF95ID0gZDMubWF4KGRhdGFfcGxvdCwgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgcmV0dXJuIGRhdGFfcGxvdFtpXS55YXhpcztcbiAgICB9KTtcbiAgICB2YXIgYXZnX3kgPSAobWF4X3kgLSBtaW5feSkgLyAxMDtcblxuICAgIHZhciB4U2NhbGUgPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAuZG9tYWluKFttaW5feCAtIGF2Z194LCBtYXhfeCArIGF2Z194XSlcbiAgICAgICAgLnJhbmdlKFswLCB3aWR0aF0pO1xuXG4gICAgdmFyIHlTY2FsZSA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgIC5kb21haW4oW21pbl95IC0gYXZnX3ksIG1heF95ICsgYXZnX3ldKVxuICAgICAgICAucmFuZ2UoW2hlaWdodCwgMF0pO1xuXG4gICAgdmFyIHhBeGlzID0gZDMuc3ZnLmF4aXMoKVxuICAgICAgICAuc2NhbGUoeFNjYWxlKVxuICAgICAgICAub3JpZW50KCdib3R0b20nKVxuICAgICAgICAudGlja1NpemUoLWhlaWdodCk7XG5cbiAgICB2YXIgeUF4aXMgPSBkMy5zdmcuYXhpcygpXG4gICAgICAgIC5zY2FsZSh5U2NhbGUpXG4gICAgICAgIC5vcmllbnQoJ2xlZnQnKVxuICAgICAgICAudGlja3MoNSlcbiAgICAgICAgLnRpY2tTaXplKC13aWR0aCk7XG5cbiAgICB2YXIgem9vbSA9IGQzLmJlaGF2aW9yLnpvb20oKVxuICAgICAgICAueCh4U2NhbGUpXG4gICAgICAgIC55KHlTY2FsZSlcbiAgICAgICAgLnNjYWxlRXh0ZW50KFsxLCAxMF0pXG4gICAgICAgIC5vbihcInpvb21cIiwgem9vbWVkKTtcblxuICAgIHZhciBjaGFydF9zY2F0dGVyID0gZDMuc2VsZWN0KCcjc2NhdHRlcnBsb3QnKVxuICAgICAgICAuYXBwZW5kKCdzdmc6c3ZnJylcbiAgICAgICAgLmF0dHIoJ3dpZHRoJywgd2lkdGggKyBtYXJnaW4ucmlnaHQgKyBtYXJnaW4ubGVmdClcbiAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGhlaWdodCArIG1hcmdpbi50b3AgKyBtYXJnaW4uYm90dG9tKVxuICAgICAgICAuY2FsbCh6b29tKTtcblxuICAgIHZhciBtYWluMSA9IGNoYXJ0X3NjYXR0ZXIuYXBwZW5kKCdnJylcbiAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIG1hcmdpbi5sZWZ0ICsgJywnICsgbWFyZ2luLnRvcCArICcpJylcbiAgICAgICAgLmF0dHIoJ3dpZHRoJywgd2lkdGgrIG1hcmdpbi5yaWdodCArIG1hcmdpbi5sZWZ0KVxuICAgICAgICAuYXR0cignaGVpZ2h0JywgaGVpZ2h0ICsgbWFyZ2luLnRvcCArIG1hcmdpbi5ib3R0b20pXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdtYWluJyk7XG5cbiAgICBtYWluMS5hcHBlbmQoJ2cnKVxuICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLCcgKyBoZWlnaHQgKyAnKScpXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICd4IGF4aXMnKVxuICAgICAgICAuY2FsbCh4QXhpcyk7XG5cbiAgICBtYWluMS5hcHBlbmQoJ2cnKVxuICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLDApJylcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3kgYXhpcycpXG4gICAgICAgIC5jYWxsKHlBeGlzKTtcblxuICAgIHZhciBjbGlwID0gbWFpbjEuYXBwZW5kKFwiZGVmc1wiKS5hcHBlbmQoXCJzdmc6Y2xpcFBhdGhcIilcbiAgICAgICAgLmF0dHIoXCJpZFwiLCBcImNsaXBcIilcbiAgICAgICAgLmFwcGVuZChcInN2ZzpyZWN0XCIpXG4gICAgICAgIC5hdHRyKFwiaWRcIiwgXCJjbGlwLXJlY3RcIilcbiAgICAgICAgLmF0dHIoXCJ4XCIsIFwiMFwiKVxuICAgICAgICAuYXR0cihcInlcIiwgXCIwXCIpXG4gICAgICAgIC5hdHRyKCd3aWR0aCcsIHdpZHRoKVxuICAgICAgICAuYXR0cignaGVpZ2h0JywgaGVpZ2h0KTtcblxuICAgIG1haW4xLmFwcGVuZChcImdcIikuYXR0cihcImNsaXAtcGF0aFwiLCBcInVybCgjY2xpcClcIilcbiAgICAgICAgLnNlbGVjdEFsbChcImNpcmNsZVwiKVxuICAgICAgICAuZGF0YShkYXRhX3Bsb3QpXG4gICAgICAgIC5lbnRlcigpXG4gICAgICAgIC5hcHBlbmQoXCJjaXJjbGVcIilcbiAgICAgICAgLmF0dHIoXCJjeFwiLCAoXywgaSkgPT4geFNjYWxlKGRhdGFfcGxvdFtpXS54YXhpcykpXG4gICAgICAgIC5hdHRyKFwiY3lcIiwgKF8sIGkpID0+IHlTY2FsZShkYXRhX3Bsb3RbaV0ueWF4aXMpKVxuICAgICAgICAuYXR0cihcInJcIiwgMilcbiAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBcIiNCNzFDMUNcIik7XG4gICAgY2hhcnRfc2NhdHRlci5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgIC5hdHRyKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIikgIC8vIHRoaXMgbWFrZXMgaXQgZWFzeSB0byBjZW50cmUgdGhlIHRleHQgYXMgdGhlIHRyYW5zZm9ybSBpcyBhcHBsaWVkIHRvIHRoZSBhbmNob3JcbiAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBwYWRkaW5nIC8gNSArIFwiLFwiICsgKGhlaWdodCAvIDIpICsgXCIpcm90YXRlKC05MClcIikgIC8vIHRleHQgaXMgZHJhd24gb2ZmIHRoZSBzY3JlZW4gdG9wIGxlZnQsIG1vdmUgZG93biBhbmQgb3V0IGFuZCByb3RhdGVcbiAgICAgICAgLnRleHQoeV9BeGlzX25hbWUpXG4gICAgICAgIC5zdHlsZShcImZpbGxcIiwgXCIjNDI0MjQyXCIpXG4gICAgICAgIC5zdHlsZShcInRleHQtaW5kZW50XCIsXCIyMHB4XCIpXG4gICAgICAgIC5zdHlsZShcImZvbnQtc2l6ZVwiLFwiMTJweFwiKVxuICAgICAgICAuc3R5bGUoXCJmb250LXdlaWdodFwiLFwiYm9sZFwiKTtcblxuICAgIGNoYXJ0X3NjYXR0ZXIuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAuYXR0cihcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpICAvLyB0aGlzIG1ha2VzIGl0IGVhc3kgdG8gY2VudHJlIHRoZSB0ZXh0IGFzIHRoZSB0cmFuc2Zvcm0gaXMgYXBwbGllZCB0byB0aGUgYW5jaG9yXG4gICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgKHdpZHRoIC8gMikgKyBcIixcIiArIChoZWlnaHQgKyAocGFkZGluZyAvIDIpKSArIFwiKVwiKSAgLy8gY2VudHJlIGJlbG93IGF4aXNcbiAgICAgICAgLnRleHQoeF9BeGlzX25hbWUpXG4gICAgICAgIC5zdHlsZShcImZpbGxcIiwgXCIjNDI0MjQyXCIpXG4gICAgICAgIC5zdHlsZShcInRleHQtaW5kZW50XCIsXCIyMHB4XCIpXG4gICAgICAgIC5zdHlsZShcImZvbnQtc2l6ZVwiLFwiMTJweFwiKVxuICAgICAgICAuc3R5bGUoXCJmb250LXdlaWdodFwiLFwiYm9sZFwiKTtcblxuICAgIGZ1bmN0aW9uIHpvb21lZCgpIHtcbiAgICAgICAgdmFyIHBhblggPSBkMy5ldmVudC50cmFuc2xhdGVbMF07XG4gICAgICAgIHZhciBwYW5ZID0gZDMuZXZlbnQudHJhbnNsYXRlWzFdO1xuICAgICAgICB2YXIgc2NhbGUgPSBkMy5ldmVudC5zY2FsZTtcblxuICAgICAgICBwYW5YID0gcGFuWCA+IDEwID8gMTAgOiBwYW5YO1xuICAgICAgICB2YXIgbWF4WCA9IC0oc2NhbGUgLSAxKSAqIHdpZHRoIC0gMTA7XG4gICAgICAgIHBhblggPSBwYW5YIDwgbWF4WCA/IG1heFggOiBwYW5YO1xuXG4gICAgICAgIHBhblkgPSBwYW5ZID4gMTAgPyAxMCA6IHBhblk7XG4gICAgICAgIHZhciBtYXhZID0gLShzY2FsZSAtIDEpICogaGVpZ2h0IC0gMTA7XG4gICAgICAgIHBhblkgPSBwYW5ZIDwgbWF4WSA/IG1heFkgOiBwYW5ZO1xuXG4gICAgICAgIHpvb20udHJhbnNsYXRlKFtwYW5YLCBwYW5ZXSk7XG5cbiAgICAgICAgbWFpbjEuc2VsZWN0KFwiLnguYXhpc1wiKS5jYWxsKHhBeGlzKTtcbiAgICAgICAgbWFpbjEuc2VsZWN0KFwiLnkuYXhpc1wiKS5jYWxsKHlBeGlzKTtcbiAgICAgICAgbWFpbjEuc2VsZWN0QWxsKFwiY2lyY2xlXCIpXG4gICAgICAgICAgICAuYXR0cihcImN4XCIsIChfLCBpKSA9PiB4U2NhbGUoZGF0YV9wbG90W2ldLnhheGlzKSlcbiAgICAgICAgICAgIC5hdHRyKFwiY3lcIiwgKF8sIGkpID0+IHlTY2FsZShkYXRhX3Bsb3RbaV0ueWF4aXMpKVxuICAgICAgICAgICAgLmF0dHIoXCJyXCIsIDIuNSlcbiAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgXCIjQjcxQzFDXCIpO1xuICAgIH1cblxuICAgIGQzLnNlbGVjdCgnI05BY291bnQnKS5zdHlsZSgnZGlzcGxheScsICdibG9jaycpO1xuICAgIGQzLnNlbGVjdChcIiNOQWNvdW50XCIpLnRleHQoXCJUaGVyZSBhcmUgXCIgKyBuYW5Db3VudCArIFwiIG51bWJlciBvZiBOQSB2YWx1ZXMgaW4gdGhlIHJlbGF0aW9uLlwiKTtcbn1cblxubGV0IHBsb3RuYW1lYSwgcGxvdG5hbWViLCB2YXJuMSwgdmFybjIsIHZhcnNpemUxLCB2YXJzaXplMjtcblxubGV0IGNvbnRpbnVvdXNfbiA9IDA7XG5sZXQgYmFyX24gPSAwO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0X3dpZHRoKGlkKSB7XG4gICAgcmV0dXJuIDUwICogKGlkID09PSAncGxvdEEnID8gY29udGludW91c19uIDogYmFyX24pO1xufVxuXG5mdW5jdGlvbiBjcm9zc1RhYlBsb3RzKFBsb3ROYW1lQSwgUGxvdE5hbWVCLCBqc29uX29iaikge1xuICAgIGNvbnRpbnVvdXNfbiA9IDA7XG4gICAgYmFyX24gPSAwO1xuICAgIHBsb3RuYW1lYSA9IFBsb3ROYW1lQTtcbiAgICBwbG90bmFtZWIgPSBQbG90TmFtZUI7XG4gICAgdHJpZ2dlcignI2lucHV0MScsICdibHVyJyk7XG4gICAgdHJpZ2dlcignI2lucHV0MicsICdibHVyJyk7XG4gICAgc2V0QXR0cnMoJyNpbnB1dDEnLCB7cGxhY2Vob2xkZXI6IFBsb3ROYW1lQX0pO1xuICAgIHNldEF0dHJzKCcjaW5wdXQyJywge3BsYWNlaG9sZGVyOiBQbG90TmFtZUJ9KTtcbiAgICBsZXQgW3Bsb3RfYSwgcGxvdF9iXSA9IFsnI3Bsb3RBJywgJyNwbG90QiddO1xuXG4gICAgdmFyIG1hcmdpbl9jcm9zcyA9IHt0b3A6IDMwLCByaWdodDogMzUsIGJvdHRvbTogNDAsIGxlZnQ6IDQwfSxcbiAgICAgICAgd2lkdGhfY3Jvc3MgPSAzMDAgLSBtYXJnaW5fY3Jvc3MubGVmdCAtIG1hcmdpbl9jcm9zcy5yaWdodCxcbiAgICAgICAgaGVpZ2h0X2Nyb3NzID0gMTYwIC0gbWFyZ2luX2Nyb3NzLnRvcCAtIG1hcmdpbl9jcm9zcy5ib3R0b207XG4gICAgdmFyIHBhZGRpbmdfY3Jvc3MgPSAxMDA7XG5cbiAgICBkMy5zZWxlY3QoXCIjaW5wdXQxXCIpLm9uKFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBkMy5zZWxlY3QoXCIjdG9vbHRpcFBsb3RBXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIFwidmlzaWJsZVwiKVxuICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLFwiMVwiKVxuICAgICAgICAgICAgLnRleHQoUGxvdE5hbWVBKTtcbiAgICB9KVxuICAgICAgICAub24oXCJtb3VzZW91dFwiLGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBkMy5zZWxlY3QoXCIjdG9vbHRpcFBsb3RBXCIpXG4gICAgICAgICAgICAgICAgLnN0eWxlKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKVxuICAgICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIixcIjBcIik7XG4gICAgICAgIH0pO1xuICAgIGQzLnNlbGVjdChcIiNpbnB1dDJcIikub24oXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGQzLnNlbGVjdChcIiN0b29sdGlwUGxvdEJcIilcbiAgICAgICAgICAgIC5zdHlsZShcInZpc2liaWxpdHlcIiwgXCJ2aXNpYmxlXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsXCIxXCIpXG4gICAgICAgICAgICAudGV4dChQbG90TmFtZUIpO1xuICAgIH0pXG4gICAgICAgIC5vbihcIm1vdXNlb3V0XCIsZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGQzLnNlbGVjdChcIiN0b29sdGlwUGxvdEJcIilcbiAgICAgICAgICAgICAgICAuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIFwiaGlkZGVuXCIpXG4gICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLFwiMFwiKTtcbiAgICAgICAgfSk7XG5cbiAgICB2YXIgcGxvdF9ub2RlcyA9IGFwcC5ub2Rlcy5zbGljZSgpO1xuICAgIGZvciAobGV0IG5vZGUgb2YgcGxvdF9ub2Rlcykge1xuICAgICAgICBpZiAobm9kZS5uYW1lID09PSBQbG90TmFtZUEpIHtcbiAgICAgICAgICAgIGlmIChub2RlLnBsb3R0eXBlID09PSBcImNvbnRpbnVvdXNcIikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVvdXNfbisrO1xuICAgICAgICAgICAgICAgIGRlbnNpdHlfY3Jvc3Mobm9kZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUucGxvdHR5cGUgPT09IFwiYmFyXCIpIHtcbiAgICAgICAgICAgICAgICBiYXJfbisrO1xuICAgICAgICAgICAgICAgIGJhcl9jcm9zcyhub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChub2RlLm5hbWUgPT09IFBsb3ROYW1lQikge1xuICAgICAgICAgICAgaWYgKG5vZGUucGxvdHR5cGUgPT09IFwiY29udGludW91c1wiKSB7XG4gICAgICAgICAgICAgICAgY29udGludW91c19uKys7XG4gICAgICAgICAgICAgICAgZGVuc2l0eV9jcm9zcyhub2RlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS5wbG90dHlwZSA9PT0gXCJiYXJcIikge1xuICAgICAgICAgICAgICAgIGJhcl9uKys7XG4gICAgICAgICAgICAgICAgYmFyX2Nyb3NzKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHBsb3RBX3NpemUsIHBsb3RCX3NpemUsIHBsb3RBX3NpemVtLCBwbG90Ql9zaXplbTtcbiAgICBsZXQgdmFybjEsIHZhcm4yLCB2YXJzaXplMSwgdmFyc2l6ZTI7XG4gICAgbGV0IHNldFN0YXR1cyA9IChpZCwgcGxvdCwgbiwgc2l6ZSkgPT4gZWxlbShpZCkuaW5uZXJIVE1MID0gYCR7cGxvdH0gOiAke259IGRpc3RyaWJ1dGlvbiB3aXRoICR7c2l6ZX0gZGl2aXNpb25zYDtcbiAgICBlbGVtKFwiI0VxdWlkaXN0YW5jZTFcIikub25jbGljayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXJuMSA9IFwiZXF1aWRpc3RhbmNlXCI7XG4gICAgICAgIHBsb3RBX3NpemUgPSBwYXJzZUludChkMy5zZWxlY3QoXCIjaW5wdXQxXCIpWzBdWzBdLnZhbHVlKTtcbiAgICAgICAgdmFyc2l6ZTEgPSBwbG90QV9zaXplO1xuICAgICAgICBlcXVpZGlzdGFuY2UoUGxvdE5hbWVBLCBwbG90QV9zaXplKTtcbiAgICAgICAgc2V0U3RhdHVzKFwiI3Bsb3RBX3N0YXR1c1wiLCBQbG90TmFtZUEsIHZhcm4xLCB2YXJzaXplMSk7XG4gICAgfTtcbiAgICBlbGVtKFwiI0VxdWltYXNzMVwiKS5vbmNsaWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhcm4xID0gXCJlcXVpbWFzc1wiO1xuICAgICAgICBwbG90QV9zaXplbSA9IHBhcnNlSW50KGQzLnNlbGVjdChcIiNpbnB1dDFcIilbMF1bMF0udmFsdWUpO1xuICAgICAgICB2YXJzaXplMSA9IHBsb3RBX3NpemVtO1xuICAgICAgICBlcXVpbWFzcyhQbG90TmFtZUEsIHBsb3RBX3NpemVtKTtcbiAgICAgICAgc2V0U3RhdHVzKFwiI3Bsb3RBX3N0YXR1c1wiLCBQbG90TmFtZUEsIHZhcm4xLCB2YXJzaXplMSk7XG4gICAgfTtcbiAgICBlbGVtKFwiI0VxdWlkaXN0YW5jZTJcIikub25jbGljayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXJuMiA9IFwiZXF1aWRpc3RhbmNlXCI7XG4gICAgICAgIHBsb3RCX3NpemUgPSBwYXJzZUludChkMy5zZWxlY3QoXCIjaW5wdXQyXCIpWzBdWzBdLnZhbHVlKTtcbiAgICAgICAgZXF1aWRpc3RhbmNlKFBsb3ROYW1lQiwgcGxvdEJfc2l6ZSk7XG4gICAgICAgIHZhcnNpemUyID0gcGxvdEJfc2l6ZTtcbiAgICAgICAgc2V0U3RhdHVzKFwiI3Bsb3RCX3N0YXR1c1wiLCBQbG90TmFtZUIsIHZhcm4yLCB2YXJzaXplMik7XG4gICAgfTtcbiAgICBlbGVtKFwiI0VxdWltYXNzMlwiKS5vbmNsaWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhcm4yID0gXCJlcXVpbWFzc1wiO1xuICAgICAgICBwbG90Ql9zaXplbSA9IHBhcnNlSW50KGQzLnNlbGVjdChcIiNpbnB1dDJcIilbMF1bMF0udmFsdWUpO1xuICAgICAgICBlcXVpbWFzcyhQbG90TmFtZUIsIHBsb3RCX3NpemVtKTtcbiAgICAgICAgdmFyc2l6ZTIgPSBwbG90Ql9zaXplbTtcbiAgICAgICAgc2V0U3RhdHVzKFwiI3Bsb3RCX3N0YXR1c1wiLCBQbG90TmFtZUIsIHZhcm4yLCB2YXJzaXplMik7XG4gICAgfTtcblxuICAgIC8vIHRoaXMgaXMgdGhlIGZ1bmN0aW9uIHRvIGFkZCAgdGhlIGRlbnNpdHkgcGxvdCBpZiBhbnlcbiAgICBmdW5jdGlvbiBkZW5zaXR5X2Nyb3NzKGRlbnNpdHlfZW52LGEsbWV0aG9kX25hbWUpIHtcbiAgICAgICAgLy8gc2V0dXAgdGhlIHhfY29yZCBhY2NvcmRpbmcgdG8gdGhlIHNpemUgZ2l2ZW4gYnkgdXNlclxuICAgICAgICB2YXIgeVZhbHMgPSBkZW5zaXR5X2Vudi5wbG90eTtcbiAgICAgICAgdmFyIHhWYWxzID0gZGVuc2l0eV9lbnYucGxvdHg7XG5cbiAgICAgICAgLy8gYW4gYXJyYXkgb2Ygb2JqZWN0c1xuICAgICAgICB2YXIgZGF0YTIgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZW5zaXR5X2Vudi5wbG90eC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZGF0YTIucHVzaCh7eDogZGVuc2l0eV9lbnYucGxvdHhbaV0sIHk6IGRlbnNpdHlfZW52LnBsb3R5W2ldfSk7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YTIuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgZC54ID0gK2QueDtcbiAgICAgICAgICAgIGQueSA9ICtkLnk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBtaW5feCA9IGQzLm1pbihkYXRhMiwgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhMltpXS54O1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIG1heF94ID0gZDMubWF4KGRhdGEyLCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGEyW2ldLng7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgYXZnX3ggPSAobWF4X3ggLSBtaW5feCkgLyAxMDtcbiAgICAgICAgdmFyIG1pbl95ID0gZDMubWluKGRhdGEyLCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGEyW2ldLnk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbWF4X3kgPSBkMy5tYXgoZGF0YTIsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTJbaV0ueTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBhdmdfeSA9IChtYXhfeSAtIG1pbl95KSAvIDEwO1xuICAgICAgICB2YXIgeCA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgICAgICAuZG9tYWluKFtkMy5taW4oeFZhbHMpLCBkMy5tYXgoeFZhbHMpXSlcbiAgICAgICAgICAgIC5yYW5nZShbMCwgd2lkdGhfY3Jvc3NdKTtcbiAgICAgICAgdmFyIGludnggPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAgICAgLnJhbmdlKFtkMy5taW4oZGF0YTIubWFwKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGQueDtcbiAgICAgICAgICAgIH0pKSwgZDMubWF4KGRhdGEyLm1hcChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkLng7XG4gICAgICAgICAgICB9KSldKVxuICAgICAgICAgICAgLmRvbWFpbihbMCwgd2lkdGhfY3Jvc3NdKTtcbiAgICAgICAgdmFyIHkgPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAgICAgLmRvbWFpbihbZDMubWluKGRhdGEyLm1hcChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkLnk7XG4gICAgICAgICAgICB9KSksIGQzLm1heChkYXRhMi5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZC55O1xuICAgICAgICAgICAgfSkpXSlcbiAgICAgICAgICAgIC5yYW5nZShbaGVpZ2h0X2Nyb3NzLCAwXSk7XG4gICAgICAgIHZhciB4QXhpcyA9IGQzLnN2Zy5heGlzKClcbiAgICAgICAgICAgIC5zY2FsZSh4KVxuICAgICAgICAgICAgLnRpY2tzKDUpXG4gICAgICAgICAgICAub3JpZW50KFwiYm90dG9tXCIpO1xuICAgICAgICB2YXIgeUF4aXMgPSBkMy5zdmcuYXhpcygpXG4gICAgICAgICAgICAuc2NhbGUoeSlcbiAgICAgICAgICAgIC5vcmllbnQoXCJsZWZ0XCIpO1xuICAgICAgICB2YXIgYXJlYSA9IGQzLnN2Zy5hcmVhKClcbiAgICAgICAgICAgIC5pbnRlcnBvbGF0ZShcIm1vbm90b25lXCIpXG4gICAgICAgICAgICAueChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB4KGQueCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnkwKGhlaWdodF9jcm9zcyAtIGF2Z195KVxuICAgICAgICAgICAgLnkxKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHkoZC55KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB2YXIgbGluZSA9IGQzLnN2Zy5saW5lKClcbiAgICAgICAgICAgIC54KGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHgoZC54KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAueShmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB5KGQueSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmludGVycG9sYXRlKFwibW9ub3RvbmVcIik7XG5cbiAgICAgICAgdmFyIHBsb3RzdmcgPSBkMy5zZWxlY3QocGxvdF9hKVxuICAgICAgICAgICAgLmFwcGVuZChcInN2Z1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBcInBsb3RzdmdfaWRcIilcbiAgICAgICAgICAgIC5zdHlsZShcIndpZHRoXCIsIHdpZHRoX2Nyb3NzICsgbWFyZ2luX2Nyb3NzLmxlZnQgKyBtYXJnaW5fY3Jvc3MucmlnaHQpIC8vc2V0dGluZyBoZWlnaHQgdG8gdGhlIGhlaWdodCBvZiAjbWFpbi5sZWZ0XG4gICAgICAgICAgICAuc3R5bGUoXCJoZWlnaHRcIiwgaGVpZ2h0X2Nyb3NzICsgbWFyZ2luX2Nyb3NzLnRvcCArIG1hcmdpbl9jcm9zcy5ib3R0b20pXG4gICAgICAgICAgICAuc3R5bGUoXCJtYXJnaW4tbGVmdFwiLFwiMjBweFwiKVxuICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsXCIgKyBtYXJnaW5fY3Jvc3MudG9wICsgXCIpXCIpO1xuICAgICAgICBwbG90c3ZnLmFwcGVuZChcInBhdGhcIilcbiAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgXCJwYXRoMVwiKVxuICAgICAgICAgICAgLmRhdHVtKGRhdGEyKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImFyZWFcIilcbiAgICAgICAgICAgIC5hdHRyKFwiZFwiLCBhcmVhKTtcbiAgICAgICAgcGxvdHN2Zy5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwieCBheGlzXCIpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLFwiICsgKGhlaWdodF9jcm9zcyAgKSArIFwiKVwiKVxuICAgICAgICAgICAgLmNhbGwoeEF4aXMpO1xuICAgICAgICBwbG90c3ZnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgIC5hdHRyKFwieFwiLCAod2lkdGhfY3Jvc3MgLyAyKSlcbiAgICAgICAgICAgIC5hdHRyKFwieVwiLCAobWFyZ2luX2Nyb3NzLnRvcCArIHBhZGRpbmdfY3Jvc3MgLTEwKSlcbiAgICAgICAgICAgIC5hdHRyKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIilcbiAgICAgICAgICAgIC50ZXh0KGRlbnNpdHlfZW52Lm5hbWUpXG4gICAgICAgICAgICAuc3R5bGUoXCJ0ZXh0LWluZGVudFwiLFwiMjBweFwiKVxuICAgICAgICAgICAgLnN0eWxlKFwiZm9udC1zaXplXCIsXCIxMnB4XCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJmb250LXdlaWdodFwiLFwiYm9sZFwiKTtcblxuICAgICAgICBpZiAoaXNOYU4oYSkgfHwgYSA9PT0gMCkge1xuICAgICAgICAgICAgdmFyIHVwcGVyX2xpbWl0ID0gZDMubWF4KHhWYWxzKTtcbiAgICAgICAgICAgIHZhciBsb3dlcl9saW1pdCA9IGQzLm1pbih4VmFscyk7XG4gICAgICAgICAgICB2YXIgeiA9IDEwO1xuICAgICAgICAgICAgdmFyIGRpZmYgPSB1cHBlcl9saW1pdCAtIGxvd2VyX2xpbWl0O1xuICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IGRpZmYgLyB6O1xuICAgICAgICAgICAgdmFyIHhfY29yZCA9IFtdO1xuICAgICAgICAgICAgdmFyIHB1c2hfZGF0YSA9IGxvd2VyX2xpbWl0O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB6IC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcHVzaF9kYXRhID0gcHVzaF9kYXRhICsgYnVmZmVyO1xuICAgICAgICAgICAgICAgIHhfY29yZC5wdXNoKHB1c2hfZGF0YSk7XG4gICAgICAgICAgICAgICAgcGxvdHN2Zy5hcHBlbmQoXCJsaW5lXCIpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgXCJsaW5lMVwiKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcIngxXCIsIHgoeF9jb3JkW2ldKSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ4MlwiLCB4KHhfY29yZFtpXSkpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieTFcIiwgeShkMy5taW4oeVZhbHMpKSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ5MlwiLCB5KGQzLm1heCh5VmFscykpKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJzdHJva2VcIiwgXCIjMEQ0N0ExXCIpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZShcInN0cm9rZS1kYXNoYXJyYXlcIiwgXCIzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG1ldGhvZF9uYW1lID09PSBcImVxdWlkaXN0YW5jZVwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHVwcGVyX2xpbWl0ID0gZDMubWF4KHhWYWxzKTtcbiAgICAgICAgICAgICAgICB2YXIgbG93ZXJfbGltaXQgPSBkMy5taW4oeFZhbHMpO1xuICAgICAgICAgICAgICAgIHZhciBkaWZmID0gdXBwZXJfbGltaXQgLSBsb3dlcl9saW1pdDtcbiAgICAgICAgICAgICAgICB2YXIgYnVmZmVyID0gZGlmZiAvIGE7XG4gICAgICAgICAgICAgICAgdmFyIHhfY29yZCA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBwdXNoX2RhdGEgPSBsb3dlcl9saW1pdDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEgLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcHVzaF9kYXRhID0gcHVzaF9kYXRhICsgYnVmZmVyO1xuICAgICAgICAgICAgICAgICAgICB4X2NvcmQucHVzaChwdXNoX2RhdGEpO1xuICAgICAgICAgICAgICAgICAgICBwbG90c3ZnLmFwcGVuZChcImxpbmVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgXCJsaW5lMVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ4MVwiLCB4KHhfY29yZFtpXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcIngyXCIsIHgoeF9jb3JkW2ldKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieTFcIiwgeShkMy5taW4oeVZhbHMpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieTJcIiwgeShkMy5tYXgoeVZhbHMpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcInN0cm9rZVwiLCBcIiMwRDQ3QTFcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcInN0cm9rZS1kYXNoYXJyYXlcIiwgXCI0XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWV0aG9kX25hbWUgPT09IFwiZXF1aW1hc3NcIikge1xuICAgICAgICAgICAgICAgIC8vIGhlcmUgd2UgdXNlIHRoZSBkYXRhIGZyb20gZXF1aW1hc3NDYWxjdWxhdGlvbiB0byBkcmF3IGxpbmVzXG4gICAgICAgICAgICAgICAgdmFyIHRlbXAgPSBbXTtcbiAgICAgICAgICAgICAgICB0ZW1wID0gZXF1aW1hc3NDYWxjdWxhdGlvbihkZW5zaXR5X2VudiwgYSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcGxvdHN2Zy5hcHBlbmQoXCJsaW5lXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImlkXCIsIFwibGluZTFcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieDFcIiwgeCh0ZW1wW2ldKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieDJcIiwgeCh0ZW1wW2ldKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieTFcIiwgeShkMy5taW4oeVZhbHMpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieTJcIiwgeShkMy5tYXgoeVZhbHMpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcInN0cm9rZVwiLCBcIiMwRDQ3QTFcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcInN0cm9rZS1kYXNoYXJyYXlcIiwgXCI0XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHRoaXMgaXMgdGhlIGZ1bmN0aW9uIHRvIGFkZCB0aGUgYmFyIHBsb3QgaWYgYW55XG4gICAgZnVuY3Rpb24gYmFyX2Nyb3NzKGJhcl9lbnYsYSxtZXRob2RfbmFtZSkge1xuICAgICAgICB2YXIgYmFyUGFkZGluZyA9IC4wMTU7ICAvLyBTcGFjZSBiZXR3ZWVuIGJhcnNcbiAgICAgICAgdmFyIHRvcFNjYWxlID0gMS4yOyAgICAgIC8vIE11bHRpcGxpY2F0aXZlIGZhY3RvciB0byBhc3NpZ24gc3BhY2UgYXQgdG9wIHdpdGhpbiBncmFwaCAtIGN1cnJlbnRseSByZW1vdmVkIGZyb20gaW1wbGVtZW50YXRpb25cbiAgICAgICAgdmFyIHBsb3RYYXhpcyA9IHRydWU7XG5cbiAgICAgICAgLy8gRGF0YVxuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGJhcl9lbnYucGxvdHZhbHVlcyk7XG4gICAgICAgIHZhciB5VmFscyA9IG5ldyBBcnJheTtcbiAgICAgICAgdmFyIGNpVXBwZXJWYWxzID0gbmV3IEFycmF5O1xuICAgICAgICB2YXIgY2lMb3dlclZhbHMgPSBuZXcgQXJyYXk7XG4gICAgICAgIHZhciBjaVNpemU7XG5cbiAgICAgICAgdmFyIHhWYWxzID0gbmV3IEFycmF5O1xuICAgICAgICB2YXIgeVZhbEtleSA9IG5ldyBBcnJheTtcblxuICAgICAgICBpZiAoYmFyX2Vudi5uYXR1cmUgPT09IFwibm9taW5hbFwiKSB7XG4gICAgICAgICAgICB2YXIgeGkgPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJhcl9lbnYucGxvdHZhbHVlc1trZXlzW2ldXSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB5VmFsc1t4aV0gPSBiYXJfZW52LnBsb3R2YWx1ZXNba2V5c1tpXV07XG4gICAgICAgICAgICAgICAgeFZhbHNbeGldID0geGk7XG4gICAgICAgICAgICAgICAgaWYgKCRwcml2YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiYXJfZW52LnBsb3R2YWx1ZXNDSSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2lMb3dlclZhbHNbeGldID0gYmFyX2Vudi5wbG90VmFsdWVzQ0kubG93ZXJCb3VuZFtrZXlzW2ldXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNpVXBwZXJWYWxzW3hpXSA9IGJhcl9lbnYucGxvdFZhbHVlc0NJLnVwcGVyQm91bmRba2V5c1tpXV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2lTaXplID0gY2lVcHBlclZhbHNbeGldIC0gY2lMb3dlclZhbHNbeGldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB5VmFsS2V5LnB1c2goe3k6IHlWYWxzW3hpXSwgeDoga2V5c1tpXX0pO1xuICAgICAgICAgICAgICAgIHhpID0geGkgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeVZhbEtleS5zb3J0KChhLCBiKSA9PiBiLnkgLSBhLnkpOyAvLyBhcnJheSBvZiBvYmplY3RzLCBlYWNoIG9iamVjdCBoYXMgeSwgdGhlIHNhbWUgYXMgeVZhbHMsIGFuZCB4LCB0aGUgY2F0ZWdvcnlcbiAgICAgICAgICAgIHlWYWxzLnNvcnQoKGEsIGIpID0+IGIgLSBhKTsgLy8gYXJyYXkgb2YgeSB2YWx1ZXMsIHRoZSBoZWlnaHQgb2YgdGhlIGJhcnNcbiAgICAgICAgICAgIGNpVXBwZXJWYWxzLnNvcnQoKGEsIGIpID0+IGIueSAtIGEueSk7IC8vID9cbiAgICAgICAgICAgIGNpTG93ZXJWYWxzLnNvcnQoKGEsIGIpID0+IGIueSAtIGEueSk7IC8vID9cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHlWYWxzW2ldID0gYmFyX2Vudi5wbG90dmFsdWVzW2tleXNbaV1dO1xuICAgICAgICAgICAgICAgIHhWYWxzW2ldID0gTnVtYmVyKGtleXNbaV0pO1xuICAgICAgICAgICAgICAgIGlmICgkcHJpdmF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmFyX2Vudi5wbG90dmFsdWVzQ0kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNpTG93ZXJWYWxzW2ldID0gYmFyX2Vudi5wbG90dmFsdWVzQ0kubG93ZXJCb3VuZFtrZXlzW2ldXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNpVXBwZXJWYWxzW2ldID0gYmFyX2Vudi5wbG90dmFsdWVzQ0kudXBwZXJCb3VuZFtrZXlzW2ldXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjaVNpemUgPSBjaVVwcGVyVmFsc1tpXSAtIGNpTG93ZXJWYWxzW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgoeVZhbHMubGVuZ3RoID4gMTUgJiBiYXJfZW52Lm51bWNoYXIgPT09IFwibnVtZXJpY1wiKSB8ICh5VmFscy5sZW5ndGggPiA1ICYgYmFyX2Vudi5udW1jaGFyID09PSBcImNoYXJhY3RlclwiKSkge1xuICAgICAgICAgICAgcGxvdFhheGlzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1pblk9ZDMubWluKHlWYWxzKTtcbiAgICAgICAgdmFyICBtYXhZID0gZDMubWF4KHlWYWxzKTsgLy8gaW4gdGhlIGZ1dHVyZSwgc2V0IG1heFkgdG8gdGhlIHZhbHVlIG9mIHRoZSBtYXhpbXVtIGNvbmZpZGVuY2UgbGltaXRcbiAgICAgICAgdmFyICBtaW5YID0gZDMubWluKHhWYWxzKTtcbiAgICAgICAgdmFyICBtYXhYID0gZDMubWF4KHhWYWxzKTtcbiAgICAgICAgdmFyICAgeF8xID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgICAgIC5kb21haW4oW21pblggLSAwLjUsIG1heFggKyAwLjVdKVxuICAgICAgICAgICAgLnJhbmdlKFswLCB3aWR0aF9jcm9zc10pO1xuXG4gICAgICAgIHZhciBpbnZ4ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgICAgIC5yYW5nZShbbWluWCAtIDAuNSwgbWF4WCArIDAuNV0pXG4gICAgICAgICAgICAuZG9tYWluKFswLCB3aWR0aF9jcm9zc10pO1xuXG4gICAgICAgIHZhciAgeV8xID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLy8gLmRvbWFpbihbMCwgbWF4WV0pXG4gICAgICAgICAgICAuZG9tYWluKFswLCBtYXhZXSlcbiAgICAgICAgICAgIC5yYW5nZShbMCwgaGVpZ2h0X2Nyb3NzXSk7XG5cbiAgICAgICAgdmFyIHhBeGlzID0gZDMuc3ZnLmF4aXMoKVxuICAgICAgICAgICAgLnNjYWxlKHhfMSlcbiAgICAgICAgICAgIC50aWNrcyh5VmFscy5sZW5ndGgpXG4gICAgICAgICAgICAub3JpZW50KFwiYm90dG9tXCIpO1xuXG4gICAgICAgIHZhciB5QXhpcyA9IGQzLnN2Zy5heGlzKClcbiAgICAgICAgICAgIC5zY2FsZSh5XzEpXG4gICAgICAgICAgICAub3JpZW50KFwibGVmdFwiKTtcblxuICAgICAgICB2YXIgcGxvdHN2ZzEgPSBkMy5zZWxlY3QocGxvdF9iKVxuICAgICAgICAgICAgLmFwcGVuZChcInN2Z1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJpZFwiLFwicGxvdHN2ZzFfaWRcIilcbiAgICAgICAgICAgIC5zdHlsZShcIndpZHRoXCIsIHdpZHRoX2Nyb3NzICsgbWFyZ2luX2Nyb3NzLmxlZnQgKyBtYXJnaW5fY3Jvc3MucmlnaHQpIC8vc2V0dGluZyBoZWlnaHQgdG8gdGhlIGhlaWdodCBvZiAjbWFpbi5sZWZ0XG4gICAgICAgICAgICAuc3R5bGUoXCJoZWlnaHRcIiwgaGVpZ2h0X2Nyb3NzICsgbWFyZ2luX2Nyb3NzLnRvcCArIG1hcmdpbl9jcm9zcy5ib3R0b20pXG4gICAgICAgICAgICAuc3R5bGUoXCJtYXJnaW4tbGVmdFwiLFwiMjBweFwiKVxuICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsXCIgKyBtYXJnaW5fY3Jvc3MudG9wICsgXCIpXCIpO1xuXG4gICAgICAgIHZhciByZWN0V2lkdGggPSB4XzEobWluWCArIDAuNSAtIDIgKiBiYXJQYWRkaW5nKTsgLy90aGUgXCJ3aWR0aFwiIGlzIHRoZSBjb29yZGluYXRlIG9mIHRoZSBlbmQgb2YgdGhlIGZpcnN0IGJhclxuICAgICAgICBwbG90c3ZnMS5zZWxlY3RBbGwoXCJyZWN0XCIpXG4gICAgICAgICAgICAuZGF0YSh5VmFscylcbiAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAuYXBwZW5kKFwicmVjdFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJpZFwiLFwicGF0aDJcIilcbiAgICAgICAgICAgIC5hdHRyKFwieFwiLCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB4XzEoeFZhbHNbaV0gLSAwLjUgKyBiYXJQYWRkaW5nKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuYXR0cihcInlcIiwgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geV8xKG1heFkgLSBkKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIHJlY3RXaWR0aClcbiAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlfMShkKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuYXR0cihcImZpbGxcIiwgXCIjZmE4MDcyXCIpO1xuXG4gICAgICAgIGlmIChwbG90WGF4aXMpIHtcbiAgICAgICAgICAgIHBsb3RzdmcxLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwieCBheGlzXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCxcIiArIGhlaWdodF9jcm9zcyArIFwiKVwiKVxuICAgICAgICAgICAgICAgIC5jYWxsKHhBeGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBsb3RzdmcxLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgIC5hdHRyKFwieFwiLCAod2lkdGhfY3Jvc3MgLyAyKSlcbiAgICAgICAgICAgIC5hdHRyKFwieVwiLCBtYXJnaW5fY3Jvc3MudG9wICsgcGFkZGluZ19jcm9zcy0xMClcbiAgICAgICAgICAgIC5hdHRyKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIilcbiAgICAgICAgICAgIC50ZXh0KGJhcl9lbnYubmFtZSlcbiAgICAgICAgICAgIC5zdHlsZShcInRleHQtaW5kZW50XCIsXCIyMHB4XCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJmb250LXNpemVcIixcIjEycHhcIilcbiAgICAgICAgICAgIC5zdHlsZShcImZvbnQtd2VpZ2h0XCIsXCJib2xkXCIpO1xuXG4gICAgICAgIGlmKGlzTmFOKGEpfHwgYT09PTApIHtcbiAgICAgICAgICAgIHhfY29yZDIgPSBlcXVpbWFzc19iYXIoYmFyX2Vudiwga2V5cy5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgIHBsb3RzdmcxLmFwcGVuZChcImxpbmVcIilcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBcImxpbmUyXCIpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieDFcIiwgeF8xKHhfY29yZDJbaV0gKSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ4MlwiLCB4XzEoeF9jb3JkMltpXSApKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcInkxXCIsIHlfMSgwKSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ5MlwiLCB5XzEobWF4WSkpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZShcInN0cm9rZVwiLCBcIiMyMTIxMjFcIilcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwic3Ryb2tlLWRhc2hhcnJheVwiLCBcIjRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAobWV0aG9kX25hbWUgPT09IFwiZXF1aWRpc3RhbmNlXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgdXBwZXJfbGltaXQxID0gbWF4WDtcbiAgICAgICAgICAgICAgICB2YXIgbG93ZXJfbGltaXQxID0gbWluWDtcbiAgICAgICAgICAgICAgICB2YXIgZGlmZjEgPSB1cHBlcl9saW1pdDEgLSBsb3dlcl9saW1pdDE7XG4gICAgICAgICAgICAgICAgdmFyIGJ1ZmZlcjEgPSBkaWZmMSAvIGE7XG4gICAgICAgICAgICAgICAgdmFyIHhfY29yZDEgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgcHVzaF9kYXRhMSA9IGxvd2VyX2xpbWl0MTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEgLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcHVzaF9kYXRhMSA9IHB1c2hfZGF0YTEgKyBidWZmZXIxO1xuICAgICAgICAgICAgICAgICAgICB4X2NvcmQxLnB1c2gocHVzaF9kYXRhMSk7XG4gICAgICAgICAgICAgICAgICAgIHBsb3RzdmcxLmFwcGVuZChcImxpbmVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgXCJsaW5lMlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ4MVwiLCB4XzEoeF9jb3JkMVtpXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcIngyXCIsIHhfMSh4X2NvcmQxW2ldKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieTFcIiwgeV8xKDApKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ5MlwiLCB5XzEobWF4WSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJzdHJva2VcIiwgXCIjMEQ0N0ExXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJzdHJva2UtZGFzaGFycmF5XCIsIFwiNFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZF9uYW1lPT09XCJlcXVpbWFzc1wiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHhfY29yZDIgPSBbXTtcbiAgICAgICAgICAgICAgICB4X2NvcmQyID0gZXF1aW1hc3NfYmFyKGJhcl9lbnYsIGEpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYSAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBwbG90c3ZnMS5hcHBlbmQoXCJsaW5lXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImlkXCIsIFwibGluZTJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieDFcIiwgeF8xKHhfY29yZDJbaV0gKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieDJcIiwgeF8xKHhfY29yZDJbaV0gKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieTFcIiwgeV8xKDApKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ5MlwiLCB5XzEobWF4WSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJzdHJva2VcIiwgXCIjMEQ0N0ExXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJzdHJva2UtZGFzaGFycmF5XCIsIFwiNFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlcXVpZGlzdGFuY2UoQSxhKSB7XG4gICAgICAgIHZhciBtZXRob2RfbmFtZT0gXCJlcXVpZGlzdGFuY2VcIjtcbiAgICAgICAgLy8ganNvbiBvYmplY3QgdG8gYmUgc2VudCB0byByIHNlcnZlclxuICAgICAgICB2YXIgb2JqID0gbmV3IE9iamVjdCgpO1xuICAgICAgICBvYmoucGxvdE5hbWVBID0gQTtcbiAgICAgICAgb2JqLmVxdWlkaXN0YW5jZSA9IGE7XG4gICAgICAgIHZhciBzdHJpbmcgPSBKU09OLnN0cmluZ2lmeShvYmopO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBsb3Rfbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChwbG90X25vZGVzW2ldLm5hbWUgPT09IEEpIHtcbiAgICAgICAgICAgICAgICBpZiAocGxvdF9ub2Rlc1tpXS5wbG90dHlwZSA9PT0gXCJjb250aW51b3VzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlKFwiI3Bsb3RzdmdfaWRcIik7XG4gICAgICAgICAgICAgICAgICAgIGRlbnNpdHlfY3Jvc3MocGxvdF9ub2Rlc1tpXSxhLG1ldGhvZF9uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocGxvdF9ub2Rlc1tpXS5wbG90dHlwZSA9PT0gXCJiYXJcIikge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmUoXCIjcGxvdHN2ZzFfaWRcIik7XG4gICAgICAgICAgICAgICAgICAgIGJhcl9jcm9zcyhwbG90X25vZGVzW2ldLGEsbWV0aG9kX25hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJub3QgZm91bmRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZXF1aW1hc3MoQSxhKSB7XG4gICAgICAgIC8vZXF1aW1hc3MgZnVuY3Rpb24gdG8gY2FsbCB0aGUgcGxvdCBmdW5jdGlvblxuICAgICAgICB2YXIgbWV0aG9kX25hbWU9IFwiZXF1aW1hc3NcIjtcbiAgICAgICAgdmFyIG9iaiA9IG5ldyBPYmplY3QoKTtcbiAgICAgICAgb2JqLnBsb3ROYW1lQSA9IEE7XG4gICAgICAgIG9iai5lcXVpZGlzdGFuY2UgPSBhO1xuICAgICAgICB2YXIgc3RyaW5nID0gSlNPTi5zdHJpbmdpZnkob2JqKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbG90X25vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAocGxvdF9ub2Rlc1tpXS5uYW1lID09PSBBKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBsb3Rfbm9kZXNbaV0ucGxvdHR5cGUgPT09IFwiY29udGludW91c1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZShcIiNwbG90c3ZnX2lkXCIpO1xuICAgICAgICAgICAgICAgICAgICBkZW5zaXR5X2Nyb3NzKHBsb3Rfbm9kZXNbaV0sYSxtZXRob2RfbmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBsb3Rfbm9kZXNbaV0ucGxvdHR5cGUgPT09IFwiYmFyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlKFwiI3Bsb3RzdmcxX2lkXCIpO1xuICAgICAgICAgICAgICAgICAgICBiYXJfY3Jvc3MocGxvdF9ub2Rlc1tpXSxhLG1ldGhvZF9uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwibm90IGZvdW5kXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXF1aW1hc3NDYWxjdWxhdGlvbihwbG90X2V2LG4pIHtcbiAgICAgICAgLy8gaGVyZSB3ZSBmaW5kIHRoZSBjb29yZGluYXRlcyB1c2luZyBDREYgdmFsdWVzXG4gICAgICAgIC8vdmFyIG4gPXYtMTtcbiAgICAgICAgdmFyIGFycl95PVtdO1xuICAgICAgICB2YXIgYXJyX3g9W107XG5cbiAgICAgICAgYXJyX3k9cGxvdF9ldi5jZGZwbG90eTsvLyBjZGZwbG90eSBkYXRhIHN0b3JlZFxuICAgICAgICBhcnJfeD1wbG90X2V2LmNkZnBsb3R4Oy8vIGNkZnBsb3R4IGRhdGEgc3RvcmVkXG5cbiAgICAgICAgdmFyIFVwcGVyX2xpbWl0WT0gZDMubWF4KGFycl95KTtcbiAgICAgICAgdmFyIExvd2VyX2xpbWl0WT1kMy5taW4oYXJyX3kpO1xuICAgICAgICB2YXIgZGlmZnk9VXBwZXJfbGltaXRZLUxvd2VyX2xpbWl0WTtcbiAgICAgICAgdmFyIGU9KGRpZmZ5KS9uOyAvLyBlIGlzIHRoZSB2YXJpYWJsZSB0byBzdG9yZSB0aGUgYXZlcmFnZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBwb2ludHMgaW4gdGhlIGNkZnkgaW4gb3JkZXIgdG8gZGl2aWRlIHRoZSBjZGZ5XG5cbiAgICAgICAgdmFyIGFycl9jPVtdOyAvL2FycmF5IHRvIHN0b3JlIHRoZSBjZGZ5IGRpdmlkZWQgY29vcmRpbmF0ZXMgZGF0YVxuICAgICAgICB2YXIgcHVzaF9kYXRhPWFycl95WzBdO1xuICAgICAgICBmb3IodmFyIGk9MDtpPG47aSsrKSB7XG4gICAgICAgICAgICBwdXNoX2RhdGE9cHVzaF9kYXRhK2U7XG4gICAgICAgICAgICBhcnJfYy5wdXNoKHB1c2hfZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGVtcF9jZGZ4PVtdO1xuICAgICAgICB2YXIgdGVtcD1bXTtcbiAgICAgICAgdmFyIHN0b3JlPVtdO1xuXG4gICAgICAgIGZvciAodmFyIGk9MDsgaTxuOyBpKyspLy90byBnZXQgdGhyb3VnaCBlYWNoIGFycl9jXG4gICAgICAgIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgNTA7IGorKykvLyB0byBjb21wYXJlIHdpdGggY2RmeSBvciBhcnJfeVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChhcnJfY1tpXSA9PT0gYXJyX3lbal0pIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmUucHVzaCh7dmFsOiBpLCBjb29yMTogaiwgY29vcjI6IGosIGRpZmYxOiAwLjM0LCBkaWZmMjogMH0pOy8vIGZvciB0ZXN0aW5nIHB1cnBvc2VcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yKHZhciBpPTA7IGk8bjtpKyspIHtcbiAgICAgICAgICAgIHZhciBkaWZmX3ZhbDEsIGRpZmZfdmFsMjsvLyBoZXJlIHRoZSBkaWZmIGlzIG5vdCBhY3R1YWwgZGlmZmVyZW5jZSwgaXQgaXMgdGhlIGZyYWN0aW9uIG9mIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSB0d28gcG9pbnRzXG4gICAgICAgICAgICB2YXIgeDEsIHgyLCB4Myx4NDtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgNTA7IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChhcnJfeVtqXSA8IGFycl9jW2ldICYmIGFycl9jW2ldIDwgYXJyX3lbaiArIDFdKSB7XG4gICAgICAgICAgICAgICAgICAgIHgxID0gYXJyX2NbaV07XG4gICAgICAgICAgICAgICAgICAgIHgyID0gYXJyX2NbaV0tYXJyX3lbal07XG4gICAgICAgICAgICAgICAgICAgIHgzID0gYXJyX3lbaisxXS1hcnJfY1tpXTtcbiAgICAgICAgICAgICAgICAgICAgeDQ9YXJyX3lbaisxXS1hcnJfeVtqXTtcbiAgICAgICAgICAgICAgICAgICAgZGlmZl92YWwxID0geDIvIHg0O1xuICAgICAgICAgICAgICAgICAgICBkaWZmX3ZhbDIgPSB4MyAvIHg0O1xuICAgICAgICAgICAgICAgICAgICBzdG9yZS5wdXNoKHt2YWw6IGksIGNvb3IxOiBqLCBjb29yMjogaiArIDEsIGRpZmYxOiBkaWZmX3ZhbDEsIGRpZmYyOiBkaWZmX3ZhbDJ9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IodmFyIGk9MDsgaTxuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB5MSx5Mix5MyxkaWZmeTEsZGlmZnkyO1xuICAgICAgICAgICAgeTE9c3RvcmVbaV0udmFsO1xuICAgICAgICAgICAgeTI9IHN0b3JlW2ldLmNvb3IxO1xuICAgICAgICAgICAgeTM9IHN0b3JlW2ldLmNvb3IyO1xuICAgICAgICAgICAgZGlmZnkxPXN0b3JlW2ldLmRpZmYxO1xuICAgICAgICAgICAgZGlmZnkyPXN0b3JlW2ldLmRpZmYyO1xuICAgICAgICAgICAgdmFyIHhfY29vcjE9IGFycl94W3kyXTtcbiAgICAgICAgICAgIHZhciB4X2Nvb3IyPWFycl94W3kzXTtcbiAgICAgICAgICAgIHZhciB4X2RpZmY9eF9jb29yMi14X2Nvb3IxO1xuICAgICAgICAgICAgdmFyIGRpc3RhbmNlMT0geF9kaWZmKmRpZmZ5MTtcbiAgICAgICAgICAgIHZhciB2YWxfeD14X2Nvb3IxK2Rpc3RhbmNlMTtcbiAgICAgICAgICAgIHRlbXAucHVzaCh2YWxfeCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRlbXA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXF1aW1hc3NfYmFyKHBsb3RfZXYsbikge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHBsb3RfZXYucGxvdHZhbHVlcyk7XG4gICAgICAgIHZhciBrID0ga2V5cy5sZW5ndGg7XG4gICAgICAgIHZhciB0ZW1wID0gW107XG4gICAgICAgIHZhciBjb3VudCA9IDA7XG5cbiAgICAgICAgaWYgKGsgPCBuKSB7XG4gICAgICAgICAgICBhbGVydChcImVycm9yIGVudGVyIHZhaWxkIHNpemVcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aGlsZSAoayA+IDApIHtcbiAgICAgICAgICAgICAgICB0ZW1wLnB1c2goe3BvczogY291bnQsIHZhbDoga30pO1xuICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICAgICAgay0tO1xuICAgICAgICAgICAgICAgIGlmIChjb3VudCA+PSBuKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0ZW1wMiA9IG5ldyBBcnJheShuKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGVtcDIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0ZW1wMltpXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBrZXlzW2ldID0gKGtleXNbaV0gKyA1KSAvIDEwOy8vIHRvIGdldCB0aGUgaW5jcmVhc2UgaW4gdGhlIGFjdHVhbCB2YWx1ZXMgYnkgMC41IGFjY29yZGluZyB0byB0aGUgeGF4aXMgaW4gcGxvdFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRlbXAubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRlbXBbal0ucG9zID09PSBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wMltpXSA9IHRlbXAyW2ldICsgMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGogPSAwLCBrID0gMDtcbiAgICAgICAgICAgIHZhciB0ZW1wX2ZpbmFsID0gbmV3IEFycmF5KG4pO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGVtcDJbal0gPSB0ZW1wMltqXSAtIDE7XG4gICAgICAgICAgICAgICAgaWYgKHRlbXAyW2pdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgICAgICAgICAgdGVtcF9maW5hbFtrXSA9IGtleXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGsrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGVtcF9maW5hbDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxpbmVjaGFydCh4X0F4aXNfbmFtZSwgeV9BeGlzX25hbWUpIHtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbGluZWNoYXJ0Jykuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICBkMy5zZWxlY3QoXCIjbGluZUNoYXJ0XCIpLnNlbGVjdChcInN2Z1wiKS5yZW1vdmUoKTtcbiAgICBlbGVtKCcjbGluZWNoYXJ0JykuaW5uZXJIVE1MID0gJyc7XG4gICAgbGV0IHBhZGRpbmcgPSAxMDtcbiAgICB2YXIgd19saW5lY2hhcnQgPSA0ODA7XG4gICAgdmFyIGhfbGluZWNoYXJ0ID0gMzAwO1xuICAgIHZhciBtYXJnaW5fbGluZWNoYXJ0ID0ge3RvcDogMjAsIHJpZ2h0OiA4MCwgYm90dG9tOiAzMCwgbGVmdDogNTB9O1xuICAgIHZhciB3aWR0aF9saW5lY2hhcnQgPSB3X2xpbmVjaGFydCAtIG1hcmdpbl9saW5lY2hhcnQubGVmdCAtIG1hcmdpbl9saW5lY2hhcnQucmlnaHQ7XG4gICAgdmFyIGhlaWdodF9saW5lY2hhcnQgPSBoX2xpbmVjaGFydCAtIG1hcmdpbl9saW5lY2hhcnQudG9wIC0gbWFyZ2luX2xpbmVjaGFydC5ib3R0b207XG5cbiAgICB2YXIgc3ZnID0gZDMuc2VsZWN0KFwiI2xpbmVjaGFydFwiKS5hcHBlbmQoXCJzdmdcIilcbiAgICAgICAgLmF0dHIoXCJpZFwiLCBcImNoYXJ0XCIpXG4gICAgICAgIC5hdHRyKFwid2lkdGhcIiwgd19saW5lY2hhcnQpXG4gICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGhfbGluZWNoYXJ0KTtcbiAgICB2YXIgY2hhcnQgPSBzdmcuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAuY2xhc3NlZChcImRpc3BsYXlcIiwgdHJ1ZSlcbiAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBtYXJnaW5fbGluZWNoYXJ0LmxlZnQgKyBcIixcIiArIG1hcmdpbl9saW5lY2hhcnQudG9wICsgXCIpXCIpO1xuICAgIHZhciB4ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLmRvbWFpbihkMy5leHRlbnQoZGF0YV9wbG90LCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuIGQueGF4aXM7XG4gICAgICAgIH0pKVxuICAgICAgICAucmFuZ2UoWzAsIHdpZHRoX2xpbmVjaGFydF0pO1xuICAgIHZhciB5ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLmRvbWFpbihbZDMubWluKGRhdGFfcGxvdCwgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkLnlheGlzO1xuICAgICAgICB9KSwgZDMubWF4KGRhdGFfcGxvdCwgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkLnlheGlzO1xuICAgICAgICB9KV0pXG4gICAgICAgIC5yYW5nZShbaGVpZ2h0X2xpbmVjaGFydCwgMF0pO1xuICAgIHZhciB4QXhpcyA9IGQzLnN2Zy5heGlzKClcbiAgICAgICAgLnNjYWxlKHgpXG4gICAgICAgIC5vcmllbnQoXCJib3R0b21cIilcbiAgICAgICAgLnRpY2tzKDUpO1xuICAgIHZhciB5QXhpcyA9IGQzLnN2Zy5heGlzKClcbiAgICAgICAgLnNjYWxlKHkpXG4gICAgICAgIC5vcmllbnQoXCJsZWZ0XCIpXG4gICAgICAgIC50aWNrcyg1KTtcbiAgICB2YXIgbGluZSA9IGQzLnN2Zy5saW5lKClcbiAgICAgICAgLngoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiB4KGQueGF4aXMpO1xuICAgICAgICB9KVxuICAgICAgICAueShmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuIHkoZC55YXhpcyk7XG4gICAgICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gcGxvdChwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuY2xhc3NlZChcInggYXhpc1wiLCB0cnVlKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCxcIiArIGhlaWdodF9saW5lY2hhcnQgKyBcIilcIilcbiAgICAgICAgICAgIC5jYWxsKHBhcmFtcy5heGlzLngpO1xuICAgICAgICB0aGlzLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5jbGFzc2VkKFwieSBheGlzXCIsIHRydWUpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLDApXCIpXG4gICAgICAgICAgICAuY2FsbChwYXJhbXMuYXhpcy55KTtcbiAgICAgICAgLy9lbnRlcigpXG4gICAgICAgIHRoaXMuc2VsZWN0QWxsKFwiLnRyZW5kbGluZVwiKVxuICAgICAgICAgICAgLmRhdGEoW3BhcmFtcy5kYXRhXSlcbiAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAgICAgLmNsYXNzZWQoXCJ0cmVuZGxpbmVcIiwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuc2VsZWN0QWxsKFwiLnBvaW50XCIpXG4gICAgICAgICAgICAuZGF0YShwYXJhbXMuZGF0YSlcbiAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAuYXBwZW5kKFwiY2lyY2xlXCIpXG4gICAgICAgICAgICAuY2xhc3NlZChcInBvaW50XCIsIHRydWUpXG4gICAgICAgICAgICAuYXR0cihcInJcIiwgMik7XG4gICAgICAgIC8vdXBkYXRlXG4gICAgICAgIHRoaXMuc2VsZWN0QWxsKFwiLnRyZW5kbGluZVwiKVxuICAgICAgICAgICAgLmF0dHIoXCJkXCIsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpbmUoZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZWxlY3RBbGwoXCIucG9pbnRcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY3hcIiwgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0ZSA9IGQueGF4aXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHgoZGF0ZSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmF0dHIoXCJjeVwiLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB5KGQueWF4aXMpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5zdHlsZShcImNvbG9yXCIsIFwiI0VGNTM1MFwiKTtcbiAgICAgICAgLy9leGl0KClcbiAgICAgICAgdGhpcy5zZWxlY3RBbGwoXCIudHJlbmRsaW5lXCIpXG4gICAgICAgICAgICAuZGF0YShbcGFyYW1zLmRhdGFdKVxuICAgICAgICAgICAgLmV4aXQoKVxuICAgICAgICAgICAgLnJlbW92ZSgpO1xuICAgICAgICB0aGlzLnNlbGVjdEFsbChcIi5wb2ludFwiKVxuICAgICAgICAgICAgLmRhdGEocGFyYW1zLmRhdGEpXG4gICAgICAgICAgICAuZXhpdCgpXG4gICAgICAgICAgICAucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgbGV0IHRlbXAgPSBkMy5zZWxlY3QoXCIjbWFpbi5sZWZ0XCIpLnN0eWxlKFwid2lkdGhcIik7XG4gICAgbGV0IHdpZHRoID0gdGVtcC5zdWJzdHJpbmcoMCwgKHRlbXAubGVuZ3RoIC0gMikpO1xuICAgIGxldCBoZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLSAxMjA7XG4gICAgc3ZnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKSAgLy8gdGhpcyBtYWtlcyBpdCBlYXN5IHRvIGNlbnRyZSB0aGUgdGV4dCBhcyB0aGUgdHJhbnNmb3JtIGlzIGFwcGxpZWQgdG8gdGhlIGFuY2hvclxuICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIHBhZGRpbmcgICsgXCIsXCIgKyAoaGVpZ2h0IC8gMykgKyBcIilyb3RhdGUoLTkwKVwiKSAgLy8gdGV4dCBpcyBkcmF3biBvZmYgdGhlIHNjcmVlbiB0b3AgbGVmdCwgbW92ZSBkb3duIGFuZCBvdXQgYW5kIHJvdGF0ZVxuICAgICAgICAudGV4dCh5X0F4aXNfbmFtZSlcbiAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBcIiM0MjQyNDJcIilcbiAgICAgICAgLnN0eWxlKFwidGV4dC1pbmRlbnRcIixcIjIwcHhcIilcbiAgICAgICAgLnN0eWxlKFwiZm9udC1zaXplXCIsXCIxMnB4XCIpXG4gICAgICAgIC5zdHlsZShcImZvbnQtd2VpZ2h0XCIsXCJib2xkXCIpO1xuICAgIHN2Zy5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgIC5hdHRyKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIikgIC8vIHRoaXMgbWFrZXMgaXQgZWFzeSB0byBjZW50cmUgdGhlIHRleHQgYXMgdGhlIHRyYW5zZm9ybSBpcyBhcHBsaWVkIHRvIHRoZSBhbmNob3JcbiAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyAod2lkdGggLyA1KSArIFwiLFwiICsgKGhlaWdodCAtIHBhZGRpbmcgLSAxMjggKSArIFwiKVwiKSAgLy8gY2VudHJlIGJlbG93IGF4aXNcbiAgICAgICAgLnRleHQoeF9BeGlzX25hbWUpXG4gICAgICAgIC5zdHlsZShcImZpbGxcIiwgXCIjNDI0MjQyXCIpXG4gICAgICAgIC5zdHlsZShcInRleHQtaW5kZW50XCIsXCIyMHB4XCIpXG4gICAgICAgIC5zdHlsZShcImZvbnQtc2l6ZVwiLFwiMTJweFwiKVxuICAgICAgICAuc3R5bGUoXCJmb250LXdlaWdodFwiLFwiYm9sZFwiKTtcblxuICAgIHBsb3QuY2FsbChjaGFydCwge1xuICAgICAgICBkYXRhOiBkYXRhX3Bsb3QsXG4gICAgICAgIGF4aXM6IHtcbiAgICAgICAgICAgIHg6IHhBeGlzLFxuICAgICAgICAgICAgeTogeUF4aXNcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiB2aXoobSwganNvbl92aXpleHBsb3JlLCBtb2RlbF9uYW1lX3NldCkge1xuICAgIGQzLnNlbGVjdChcIiNwbG90QVwiKS5odG1sKFwiXCIpO1xuICAgIGQzLnNlbGVjdChcIiNwbG90QlwiKS5odG1sKFwiXCIpO1xuICAgIGQzLnNlbGVjdChcIiN0YWJ1bGFyXzFcIikuc3R5bGUoXCJkaXNwbGF5XCIsIFwiYmxvY2tcIik7XG4gICAgZDMuc2VsZWN0KFwiI3RhYnVsYXJfMlwiKS5zdHlsZShcImRpc3BsYXlcIiwgXCJibG9ja1wiKTtcblxuICAgIGxldCBnZXRfZGF0YSA9IG1vZGVsX25hbWVfc2V0LnNwbGl0KFwiLVwiKTtcbiAgICB2YXIgbW9kZWxfbmFtZTEgPSBnZXRfZGF0YVswXSArIFwiLVwiICsgZ2V0X2RhdGFbMV07XG4gICAgdmFyIG1vZGVsX25hbWUyID0gZ2V0X2RhdGFbMV0gKyBcIi1cIiArIGdldF9kYXRhWzBdO1xuICAgIHZhciBteW0gPSArbS5zdWJzdHIoNSwgNSkgLSAxO1xuXG4gICAgZnVuY3Rpb24gcmVtb3ZlS2lkcyhwYXJlbnQpIHtcbiAgICAgICAgd2hpbGUgKHBhcmVudC5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQocGFyZW50LmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGpzb24gPSBqc29uX3ZpemV4cGxvcmU7XG4gICAgLy8gcGlwZSBpbiBmaWd1cmVzIHRvIHJpZ2h0IHBhbmVsXG4gICAgdmFyIGZpbGVsaXN0ID0gbmV3IEFycmF5O1xuXG4gICAgLy8gaW1hZ2UgYWRkZWQgdG8gdGhlIGRpdlxuICAgIHZhciB4X2F4aXMgPSBbXTtcbiAgICB2YXIgeV9heGlzID0gW107XG4gICAgZm9yICh2YXIgaSBpbiBqc29uLnBsb3RkYXRhKSB7XG4gICAgICAgIGZvciAodmFyIGogaW4ganNvbi5wbG90ZGF0YVtpXS52YXJuYW1lKSB7XG4gICAgICAgICAgICBpZiAoanNvbi5wbG90ZGF0YVtpXS52YXJuYW1lW2pdID09PSBnZXRfZGF0YVswXSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgaW4ganNvbi5wbG90ZGF0YVtpXS5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHhfYXhpc1trXSA9IGpzb24ucGxvdGRhdGFbaV0uZGF0YVtrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoanNvbi5wbG90ZGF0YVtpXS52YXJuYW1lW2pdID09PSBnZXRfZGF0YVsxXSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgaW4ganNvbi5wbG90ZGF0YVtpXS5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHlfYXhpc1trXSA9IGpzb24ucGxvdGRhdGFbaV0uZGF0YVtrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBiaXZhcmlhdGVQbG90KHhfYXhpcywgeV9heGlzLCBnZXRfZGF0YVswXSwgZ2V0X2RhdGFbMV0pO1xuXG4gICAgbGV0IGhlYXRjaGFydCA9IGVsZW0oJyNoZWF0Y2hhcnQnKTtcbiAgICBsZXQgJGxpbmVjaGFydCA9IGVsZW0oJyNsaW5lY2hhcnQnKTtcbiAgICBsZXQgc2NhdHRlcnBsb3QgPSBlbGVtKCcjc2NhdHRlcnBsb3QnKTtcbiAgICBlbGVtKCcjc2NhdHRlcnBsb3RfaW1nJykub25jbGljayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmYWRlT3V0KHRoaXMsIFwiZmFzdFwiKTtcbiAgICAgICAgZmFkZUluKHRoaXMpO1xuICAgICAgICBmYWRlVG8odGhpcywgXCJmYXN0XCIsIDEuMCk7XG4gICAgICAgIGhlYXRjaGFydC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgICRsaW5lY2hhcnQuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICBiaXZhcmlhdGVQbG90KHhfYXhpcywgeV9heGlzLCBnZXRfZGF0YVswXSwgZ2V0X2RhdGFbMV0pO1xuICAgIH07XG4gICAgZWxlbSgnI2hlYXRtYXBfaW1nJykub25jbGljayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmYWRlT3V0KHRoaXMsIFwiZmFzdFwiKTtcbiAgICAgICAgZmFkZUluKHRoaXMpO1xuICAgICAgICBmYWRlVG8odGhpcywgXCJmYXN0XCIsIDEuMCk7XG4gICAgICAgICRsaW5lY2hhcnQuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICBzY2F0dGVycGxvdC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgIGhlYXRtYXAoZ2V0X2RhdGFbMF0sIGdldF9kYXRhWzFdKTtcbiAgICB9O1xuICAgIGVsZW0oJyNsaW5lY2hhcnRfaW1nJykub25jbGljayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmYWRlT3V0KHRoaXMsIFwiZmFzdFwiKTtcbiAgICAgICAgZmFkZUluKHRoaXMpO1xuICAgICAgICBmYWRlVG8odGhpcywgXCJmYXN0XCIsIDEuMCk7XG4gICAgICAgIGhlYXRjaGFydC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgIHNjYXR0ZXJwbG90LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgbGluZWNoYXJ0KGdldF9kYXRhWzBdLGdldF9kYXRhWzFdKTtcbiAgICB9O1xuXG4gICAgdmFyIGVtcHR5PVtdO1xuICAgIGNyb3NzVGFiUGxvdHMoZ2V0X2RhdGFbMF0sIGdldF9kYXRhWzFdLGVtcHR5KTtcblxuICAgIHZhciBjb3JrID0gW107XG4gICAgdmFyIGNvcnAgPSBbXTtcbiAgICB2YXIgY29ycyA9IFtdO1xuICAgIHZhciB2YXIxID0gW107XG4gICAgdmFyIHZhcjIgPSBbXTtcbiAgICB2YXIgdGFibGVfb2JqID0gW107XG4gICAgdmFyIGNvbG5hbWVzID0gW107XG4gICAgdmFyIGNvbHZhciA9IFtdO1xuICAgIHZhciB0YWJsZV9kYXRhID0gW107XG4gICAgdmFyIHJvd3ZhciA9IFtdO1xuICAgIHZhciByb3duYW1lcyA9IFtdO1xuICAgIGZ1bmN0aW9uIGNyb3NzVGFiX1RhYmxlKGpzb24pIHtcbiAgICAgICAgdGFibGVfZGF0YSA9IFtdO1xuICAgICAgICB0YWJsZV9vYmogPSBbXTtcbiAgICAgICAgbGV0IHB1c2ggPSAoaSwga2V5KSA9PiBqc29uLnRhYnVsYXJbaV1ba2V5XS5tYXAodiA9PiB2KTtcbiAgICAgICAgLy8gZGF0YSBmb3Igc3RhdGlzdGljc1xuICAgICAgICBmb3IgKHZhciBpIGluIGpzb24udGFidWxhcikge1xuICAgICAgICAgICAgaWYgKGkgPT0gbW9kZWxfbmFtZTEgfHwgaSA9PSBtb2RlbF9uYW1lMikge1xuICAgICAgICAgICAgICAgIGNvbG5hbWVzID0gcHVzaChpLCAnY29sbmFtZXMnKTtcbiAgICAgICAgICAgICAgICByb3duYW1lcyA9IHB1c2goaSwgJ3Jvd25hbWVzJyk7XG4gICAgICAgICAgICAgICAgcm93dmFyID0gcHVzaChpLCAncm93dmFyJyk7XG4gICAgICAgICAgICAgICAgY29sdmFyID0gcHVzaChpLCdjb2x2YXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpIGluIGpzb24udGFidWxhcikge1xuICAgICAgICAgICAgaWYgKGkgPT0gbW9kZWxfbmFtZTEgfHwgaSA9PSBtb2RlbF9uYW1lMikge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIG4gaW4ganNvbi50YWJ1bGFyW2ldLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFibGVfZGF0YVtuXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBhID0gMDsgYSA8IGNvbG5hbWVzLmxlbmd0aDsgYSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YWJsZV9kYXRhW25dLnB1c2goanNvbi50YWJ1bGFyW2ldLmRhdGFbbl1bYV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgcm93bmFtZXMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgY29sbmFtZXMubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgICAgICAgICB0YWJsZV9vYmoucHVzaCh7cm93bmFtZTogcm93bmFtZXNbcF0sIGNvbG5hbWU6IGNvbG5hbWVzW2xdLCB2YWx1ZTogdGFibGVfZGF0YVtwXVtsXX0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGQzdGFibGUxKHRhYmxlX29iaik7XG4gICAgfVxuXG4gICAgLy8gZm9yIHRoZSBzdGF0aXN0aWNzXG4gICAgZm9yICh2YXIga2V5IGluIGpzb24uc3RhdGlzdGljYWwpIHtcbiAgICAgICAgaWYgKGtleSA9PSBtb2RlbF9uYW1lMSB8fCBrZXkgPT0gbW9kZWxfbmFtZTIpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGEgaW4ganNvbi5zdGF0aXN0aWNhbFtrZXldLmNvcmspIHtcbiAgICAgICAgICAgICAgICBjb3JrLnB1c2goanNvbi5zdGF0aXN0aWNhbFtrZXldLmNvcmtbYV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGtleTEgaW4ganNvbi5zdGF0aXN0aWNhbCkge1xuICAgICAgICBpZiAoa2V5MSA9PSBtb2RlbF9uYW1lMSB8fCBrZXkxID09IG1vZGVsX25hbWUyKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBiIGluIGpzb24uc3RhdGlzdGljYWxba2V5MV0uY29ycCkge1xuICAgICAgICAgICAgICAgIGNvcnAucHVzaChqc29uLnN0YXRpc3RpY2FsW2tleTFdLmNvcnBbYl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGtleSBpbiBqc29uLnN0YXRpc3RpY2FsKSB7XG4gICAgICAgIGlmIChrZXkgPT0gbW9kZWxfbmFtZTEgfHwga2V5ID09IG1vZGVsX25hbWUyKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBjIGluIGpzb24uc3RhdGlzdGljYWxba2V5XS5jb3JzKSB7XG4gICAgICAgICAgICAgICAgY29ycy5wdXNoKGpzb24uc3RhdGlzdGljYWxba2V5XS5jb3JzW2NdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBrZXkgaW4ganNvbi5zdGF0aXN0aWNhbCkge1xuICAgICAgICBpZiAoa2V5ID09IG1vZGVsX25hbWUxIHx8IGtleSA9PSBtb2RlbF9uYW1lMikge1xuICAgICAgICAgICAgZm9yICh2YXIgZCBpbiBqc29uLnN0YXRpc3RpY2FsW2tleV0udmFyMSkge1xuICAgICAgICAgICAgICAgIHZhcjEucHVzaChqc29uLnN0YXRpc3RpY2FsW2tleV0udmFyMVtkXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIga2V5NCBpbiBqc29uLnN0YXRpc3RpY2FsKSB7XG4gICAgICAgIGlmIChrZXkgPT0gbW9kZWxfbmFtZTEgfHwga2V5ID09IG1vZGVsX25hbWUyKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBlIGluIGpzb24uc3RhdGlzdGljYWxba2V5XS52YXIyKSB7XG4gICAgICAgICAgICAgICAgdmFyMi5wdXNoKGpzb24uc3RhdGlzdGljYWxba2V5XS52YXIyW2VdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFwcC56cGFyYW1zLnp2YXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciByZXN1bHRzQXJyYXkgPSBbXTtcbiAgICB9XG4gICAgZm9yICh2YXIga2V5IGluIGpzb24udGFidWxhcikge1xuICAgICAgICBpZiAoa2V5ID09IFwiY29sbmFtZXNcIikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJjb2xuYW1lcyBmb3VuZFwiKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvYmogPSBqc29uLnRhYnVsYXJba2V5XTtcbiAgICAgICAgcmVzdWx0c0FycmF5LnB1c2gob2JqKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkM3RhYmxlMShkYXRhKSB7XG4gICAgICAgIHZhciB3aWR0aCA9IDEyMCwgLy8gd2lkdGggb2Ygc3ZnXG4gICAgICAgICAgICBoZWlnaHQgPSAxNjAsLy8gaGVpZ2h0IG9mIHN2Z1xuICAgICAgICAgICAgcGFkZGluZyA9IDIyOyAvLyBzcGFjZSBhcm91bmQgdGhlIGNoYXJ0LCBub3QgaW5jbHVkaW5nIGxhYmVsc1xuXG4gICAgICAgIGQzLnNlbGVjdChcIiN0YWJ1bGFyXzJcIilcbiAgICAgICAgICAgIC5odG1sKFwiXCIpXG4gICAgICAgICAgICAuYXBwZW5kKFwiaDVcIilcbiAgICAgICAgICAgIC50ZXh0KFwiQ1JPU1MtVEFCUyBcIilcbiAgICAgICAgICAgIC5zdHlsZShcImNvbG9yXCIsIFwiIzQyNDI0MlwiKTtcblxuICAgICAgICB2YXIgc3YgPSBkMy5zZWxlY3QoXCIjdGFidWxhcl8yXCIpLmFwcGVuZChcInN2Z1wiKS5hdHRyKFwid2lkdGhcIiwgXCIxMDAlXCIpLmF0dHIoXCJoZWlnaHRcIiwgXCIxMDAlXCIpLnN0eWxlKFwib3ZlcmZsb3dcIiwgXCJ2aXNpYmxlXCIpO1xuICAgICAgICB2YXIgZm8gPSBzdi5hcHBlbmQoJ2ZvcmVpZ25PYmplY3QnKS5hdHRyKFwid2lkdGhcIiwgXCIxMDAlXCIpLmF0dHIoXCJoZWlnaHRcIiwgXCIxMDAlXCIpLnN0eWxlKFwicGFkZGluZ1wiLCAxMCkuYXR0cihcIm92ZXJmbG93XCIsIFwidmlzaWJsZVwiKTtcbiAgICAgICAgdmFyIHRhYmxlID0gZm8uYXBwZW5kKFwieGh0bWw6dGFibGVcIikuYXR0cihcImNsYXNzXCIsIFwidGFibGVcIikuc3R5bGUoXCJib3JkZXItY29sbGFwc2VcIiwgXCIgY29sbGFwc2VcIiksXG4gICAgICAgICAgICB0aCA9IHRhYmxlLmFwcGVuZChcInRyXCIpLnN0eWxlKFwiYm9yZGVyXCIsIDEpLnRleHQoXCJfXCIpLnN0eWxlKFwiY29sb3JcIiwgXCIjZmZmXCIpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aC5hcHBlbmQoXCJ0ZFwiKS5zdHlsZShcImJvcmRlci1ib3R0b21cIiwgMSkuc3R5bGUoXCJ0ZXh0LWFsaWduXCIsIFwiY2VudGVyXCIpLnN0eWxlKFwiYmFja2dyb3VuZC1jb2xvclwiLCBwbG90cy5zZWxWYXJDb2xvcikuYXBwZW5kKFwiYlwiKS50ZXh0KGNvbG5hbWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHJvd25hbWVzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICB2YXIgcG9zID0gMDtcbiAgICAgICAgICAgIHZhciB0ciA9IHRhYmxlLmFwcGVuZChcInRyXCIpLnN0eWxlKFwibWFyZ2luLWxlZnRcIiwgMjApLnN0eWxlKFwiYmFja2dyb3VuZC1jb2xvclwiLCBcIiNCREJEQkRcIikuc3R5bGUoXCJib3JkZXJcIiwgMSkuc3R5bGUoXCJ0ZXh0LWFsaWduXCIsIFwiY2VudGVyXCIpLnRleHQocm93bmFtZXNba10pO1xuICAgICAgICAgICAgZm9yICh2YXIgbSA9IDA7IG0gPCBjb2xuYW1lcy5sZW5ndGg7IG0rKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHogPSAwOyB6IDwgZGF0YS5sZW5ndGg7IHorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocm93bmFtZXNba10gPT09IGRhdGFbel0ucm93bmFtZSAmJiBjb2xuYW1lc1ttXSA9PT0gZGF0YVt6XS5jb2xuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ci5hcHBlbmQoXCJ0ZFwiKS5zdHlsZShcImJvcmRlclwiLCAxKS5zdHlsZShcInRleHQtYWxpZ25cIiwgXCJjZW50ZXJcIikuc3R5bGUoXCJwb3NpdGlvblwiLCBcInJlbGF0aXZlXCIpLnN0eWxlKFwiYmFja2dyb3VuZC1jb2xvclwiLCBhcHAudmFyQ29sb3IpLnRleHQoZGF0YVt6XS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjcm9zc1RhYl9UYWJsZShqc29uKTtcblxuICAgIHZhciBwbG90QXZhbD12YXJzaXplMSxwbG90QnZhbD12YXJzaXplMjtcbiAgICBpZiAoaXNOYU4ocGxvdEF2YWwpKSBwbG90QXZhbCA9IDEwO1xuICAgIGlmIChpc05hTihwbG90QnZhbCkpIHBsb3RCdmFsID0gMTA7XG4gICAgbGV0IGNyb3NzdGFicyA9ICB7XG4gICAgICAgIHZhcjE6IHtcbiAgICAgICAgICAgIG5hbWU6IHBsb3RuYW1lYSxcbiAgICAgICAgICAgIHZhbHVlOiBwbG90QXZhbCxcbiAgICAgICAgICAgIGJ1dHRvblR5cGU6IHZhcm4xXG4gICAgICAgIH0sXG4gICAgICAgIHZhcjI6IHtcbiAgICAgICAgICAgIG5hbWU6IHBsb3RuYW1lYixcbiAgICAgICAgICAgIHZhbHVlOiBwbG90QnZhbCxcbiAgICAgICAgICAgIGJ1dHRvblR5cGU6IHZhcm4yXG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcmVtb3ZlRGF0YShrZXkpIHtcbiAgICAgICAgZm9yICh2YXIga2V5MSBpbiBhcHAuenBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFwcC56cGFyYW1zLmhhc093blByb3BlcnR5KGtleTEpICYmIGtleSA9PT0ga2V5MSAmJiBhcHAuenBhcmFtc1trZXkxLmxlbmd0aF0gPiAwKSBhcHAuenBhcmFtc1trZXkxXSA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHpicmVha3MgPSBbXTtcbiAgICBsZXQgemJyZWFrc190YWJ1bGFyID0gW107XG4gICAgZWxlbSgnI1NlbGVjdGlvbkRhdGExJykuY2xpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgIGQzLnNlbGVjdChcIiN0YWJ1bGFyXzJcIikuaHRtbChcIlwiKTtcbiAgICAgICAgcmVtb3ZlRGF0YSgnemNyb3NzdGFiJyk7XG4gICAgICAgIGFwcC56cGFyYW1zLnpjcm9zc3RhYi5wdXNoKGNyb3NzdGFicyk7XG4gICAgICAgIGV4cGxvcmVfY3Jvc3N0YWIoanNvbik7XG4gICAgICAgIGFwcC5lc3RpbWF0ZUxhZGRhLnN0b3AoKTtcbiAgICAgICAgYXBwLmV4cGxvcmVkID0gdHJ1ZTtcbiAgICAgICAgemJyZWFrcy5wdXNoKGNyb3NzdGFicyk7XG4gICAgICAgIHpicmVha3NfdGFidWxhci5wdXNoKGpzb24udGFidWxhcik7XG4gICAgICAgIGQzLnNlbGVjdCgnI2JyZWFrc3BhY2UnKVxuICAgICAgICAgICAgLmFwcGVuZChcInNwYW5cIilcbiAgICAgICAgICAgIC50ZXh0KFwiXFx1MDBBMCBcXHUwMEEwIFxcdTAwQTAgXFx1MDBBMCAgIFwiKVxuICAgICAgICAgICAgLnN0eWxlKFwibWFyZ2luLXRvcFwiLCAwKVxuICAgICAgICAgICAgLnN0eWxlKFwid2hpdGUtc3BhY2VcIiwgXCJwcmVcIilcbiAgICAgICAgICAgIC5zdHlsZShcImRpc3BsYXlcIiwgXCJpbmxpbmUtYmxvY2tcIilcbiAgICAgICAgICAgIC5zdHlsZShcImZsb2F0XCIsIFwibGVmdFwiKVxuICAgICAgICAgICAgLmFwcGVuZChcInNwYW5cIilcbiAgICAgICAgICAgIC5hcHBlbmQoXCJidXR0b25cIikgLy8gdG9wIHN0YWNrIGZvciByZXN1bHRzXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsXCJidG4gYnRuLWRlZmF1bHQgYnRuLXhzXCIpXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsIHpicmVha3MubGVuZ3RoKVxuICAgICAgICAgICAgLnRleHQoXCJicmVhayBcIiArICh6YnJlYWtzLmxlbmd0aCArIDEpKS5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGQzLnNlbGVjdChcIiN0YWJ1bGFyXzJcIikuaHRtbChcIlwiKTtcbiAgICAgICAgICAgICAgICByZW1vdmVEYXRhKCk7XG4gICAgICAgICAgICAgICAgbGV0IGlkID0gdGhpcy5pZCAtIDE7XG4gICAgICAgICAgICAgICAgYXBwLnpwYXJhbXMuemNyb3NzdGFiLnB1c2goemJyZWFrc1tpZF0pO1xuICAgICAgICAgICAgICAgIGV4cGxvcmVfY3Jvc3N0YWIoemJyZWFrc190YWJ1bGFyW2lkXSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgaW5wdXR2YWx1ZTEsaW5wdXR2YWx1ZTI7XG4gICAgICAgICAgICAgICAgaW5wdXR2YWx1ZTE9emJyZWFrc1tpZF0udmFyMS52YWx1ZTtcbiAgICAgICAgICAgICAgICBpbnB1dHZhbHVlMj16YnJlYWtzW2lkXS52YXIyLnZhbHVlO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaW5wdXQxXCIpLnZhbHVlID0gaW5wdXR2YWx1ZTE7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJpbnB1dDJcIikudmFsdWUgPSBpbnB1dHZhbHVlMjtcblxuICAgICAgICAgICAgICAgIHZhciBqc29uX29iaj16YnJlYWtzW2lkXTtcbiAgICAgICAgICAgICAgICB2YXIgdmFybjEsdmFybjIsdmFyc2l6ZTEsdmFyc2l6ZTI7XG4gICAgICAgICAgICAgICAgaWYgKGpzb25fb2JqLmxlbmd0aD09PTApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJicmVhayBub3QgY2FsbGVkXCIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhcm4xPWpzb25fb2JqLnZhcjEuYnV0dG9uVHlwZTtcbiAgICAgICAgICAgICAgICAgICAgdmFybjI9anNvbl9vYmoudmFyMi5idXR0b25UeXBlO1xuICAgICAgICAgICAgICAgICAgICB2YXJzaXplMT1qc29uX29iai52YXIxLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB2YXJzaXplMj1qc29uX29iai52YXIyLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFybjE9PT1cImVxdWlkaXN0YW5jZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcm9zc1RhYlBsb3RzLmVxdWlkaXN0YW5jZShnZXRfZGF0YVswXSwgdmFyc2l6ZTEpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZhcm4xPT09XCJlcXVpbWFzc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcm9zc1RhYlBsb3RzLmVxdWltYXNzKGdldF9kYXRhWzBdLHZhcnNpemUxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodmFybjI9PT1cImVxdWlkaXN0YW5jZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcm9zc1RhYlBsb3RzLmVxdWlkaXN0YW5jZShnZXRfZGF0YVsxXSwgdmFyc2l6ZTIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZhcm4yPT09XCJlcXVpbWFzc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcm9zc1RhYlBsb3RzLmVxdWltYXNzKGdldF9kYXRhWzFdLCB2YXJzaXplMik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIGFzeW5jIGZ1bmN0aW9uIGV4cGxvcmVfY3Jvc3N0YWIoYnRuKSB7XG4gICAgICAgIGlmIChhcHAuZG93bmxvYWRJbmNvbXBsZXRlKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBhcHAuelBvcCgpO1xuXG4gICAgICAgIGFwcC5lc3RpbWF0ZUxhZGRhLnN0YXJ0KCk7XG4gICAgICAgIC8vIHdyaXRlIGxpbmtzIHRvIGZpbGUgJiBydW4gUiBDTURcbiAgICAgICAgYXBwLnpwYXJhbXMuY2FsbEhpc3RvcnkgPSBhcHAuY2FsbEhpc3Rvcnk7XG4gICAgICAgIGxldCBqc29uID0gYXdhaXQgYXBwLm1ha2VSZXF1ZXN0KFJPT0tfU1ZDX1VSTCArICdleHBsb3JlYXBwJywgYXBwLnpwYXJhbXMpO1xuICAgICAgICBhcHAuZXN0aW1hdGVMYWRkYS5zdGFydCgpO1xuICAgICAgICBhcHAuZXhwbG9yZWQgPSBmYWxzZTtcbiAgICAgICAgZDMuanNvbihcInN0YXRpYy9yZXN1bHQuanNvblwiLCAoZXJyLCBqc29uKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybihlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3Jvc3NUYWJfVGFibGUoanNvbik7XG4gICAgICAgICAgICBhcHAuZXN0aW1hdGVMYWRkYS5zdG9wKCk7XG4gICAgICAgICAgICBhcHAuZXhwbG9yZWQgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBkYXRhIGZvciB0aGUgc3RhdGlzdGljYWwgZGl2XG4gICAgdmFyIHN0cmluZzEgPSBjb3JrLnRvU3RyaW5nKCk7XG4gICAgdmFyIHN0cmluZzMgPSBzdHJpbmcxLnN1YnN0cmluZyhzdHJpbmcxLmluZGV4T2YoXCI6XCIpLCBzdHJpbmcxLmxlbmd0aCk7XG4gICAgdmFyIHN0cmluZzIgPSBzdHJpbmcxLnN1YnN0cmluZygwLCBzdHJpbmcxLmluZGV4T2YoXCJjXCIpKTtcbiAgICB2YXIgc3RyaW5nNCA9IGNvcnAudG9TdHJpbmcoKTtcbiAgICB2YXIgc3RyaW5nNiA9IHN0cmluZzQuc3Vic3RyaW5nKHN0cmluZzQuaW5kZXhPZihcIjpcIiksIHN0cmluZzQubGVuZ3RoKTtcbiAgICB2YXIgc3RyaW5nNSA9IHN0cmluZzQuc3Vic3RyaW5nKDAsIHN0cmluZzQuaW5kZXhPZihcImNcIikpO1xuICAgIHZhciBzdHJpbmc3ID0gY29ycy50b1N0cmluZygpO1xuICAgIHZhciBzdHJpbmc5ID0gc3RyaW5nNy5zdWJzdHJpbmcoc3RyaW5nNy5pbmRleE9mKFwiOlwiKSwgc3RyaW5nNy5sZW5ndGgpO1xuICAgIHZhciBzdHJpbmc4ID0gc3RyaW5nNy5zdWJzdHJpbmcoMCwgc3RyaW5nNy5pbmRleE9mKFwiY1wiKSk7XG4gICAgdmFyIHN0YXRpc3RpY2FsX2RhdGEgPSBbXG4gICAgICAgIHtjb3JyZWxhdGlvbjogc3RyaW5nMiwgdmFsdWU6IHN0cmluZzN9LFxuICAgICAgICB7Y29ycmVsYXRpb246IHN0cmluZzUsIHZhbHVlOiBzdHJpbmc2fSxcbiAgICAgICAge2NvcnJlbGF0aW9uOiBzdHJpbmc4LCB2YWx1ZTogc3RyaW5nOX1cbiAgICBdO1xuXG4gICAgZnVuY3Rpb24gZDN0YWJsZShkYXRhKSB7XG4gICAgICAgIGQzLnNlbGVjdChcIiNyZXN1bHRzVmlld19zdGF0aXN0aWNzXCIpXG4gICAgICAgICAgICAuaHRtbChcIlwiKVxuICAgICAgICAgICAgLnN0eWxlKFwiYmFja2dyb3VuZC1jb2xvclwiLCBcIiNmZmZcIilcbiAgICAgICAgICAgIC5hcHBlbmQoXCJoNVwiKVxuICAgICAgICAgICAgLnRleHQoXCJDT1JSRUxBVElPTiBTVEFUSVNUSUNTIFwiKVxuICAgICAgICAgICAgLnN0eWxlKFwiY29sb3JcIiwgXCIjNDI0MjQyXCIpO1xuICAgICAgICB2YXIgdGFibGUgPSBkMy5zZWxlY3QoXCIjcmVzdWx0c1ZpZXdfc3RhdGlzdGljc1wiKS5hcHBlbmQoXCJ0YWJsZVwiKS5hdHRyKFwiY2xhc3NcIiwgXCJ0YWJsZVwiKS5zdHlsZShcImJvcmRlci1jb2xsYXBzZVwiLCBcIiBjb2xsYXBzZVwiKSxcbiAgICAgICAgICAgIHRoID0gdGFibGUuYXBwZW5kKFwidHJcIikuc3R5bGUoXCJib3JkZXJcIiwgMSk7XG4gICAgICAgIGZvciAodmFyIGkgaW4gT2JqZWN0LmtleXMoZGF0YVswXSkpIHtcbiAgICAgICAgICAgIHRoLmFwcGVuZChcInRkXCIpLnN0eWxlKFwiYm9yZGVyLWJvdHRvbVwiLCAxKS5zdHlsZShcInRleHQtYWxpZ25cIiwgXCJsZWZ0XCIpLnN0eWxlKFwiYmFja2dyb3VuZC1jb2xvclwiLCBwbG90cy5zZWxWYXJDb2xvcikuYXBwZW5kKFwiYlwiKS50ZXh0KE9iamVjdC5rZXlzKGRhdGFbMF0pW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciByb3cgaW4gZGF0YSkge1xuICAgICAgICAgICAgdmFyIHRyID0gdGFibGUuYXBwZW5kKFwidHJcIikuc3R5bGUoXCJtYXJnaW4tbGVmdFwiLCA0MCkuc3R5bGUoXCJib3JkZXJcIiwgMSkuc3R5bGUoXCJ0ZXh0LWFsaWduXCIsIFwibGVmdFwiKTtcbiAgICAgICAgICAgIGZvciAodmFyIHRkIGluIGRhdGFbcm93XSlcbiAgICAgICAgICAgICAgICB0ci5hcHBlbmQoXCJ0ZFwiKS5zdHlsZShcImJvcmRlclwiLCAxKS5zdHlsZShcInRleHQtYWxpZ25cIiwgXCJsZWZ0XCIpLnN0eWxlKFwicG9zaXRpb25cIiwgXCJyZWxhdGl2ZVwiKS5zdHlsZShcImJhY2tncm91bmQtY29sb3JcIiwgYXBwLnZhckNvbG9yKS50ZXh0KGRhdGFbcm93XVt0ZF0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGQzdGFibGUoc3RhdGlzdGljYWxfZGF0YSk7XG59XG5cblxuZnVuY3Rpb24gbW9kZWxfc2VsZWN0aW9uKG1vZGVsX3NlbGVjdGlvbl9uYW1lLCBjb3VudF92YWx1ZSwganNvbikge1xuXG4gICAgaWYgKGNvdW50X3ZhbHVlICUgMiA9PSAwICYmIGNvdW50X3ZhbHVlICE9IDApIHtcbiAgICAgICAgZDMuc2VsZWN0KFwiI21vZGVsVmlld1wiKVxuICAgICAgICAgICAgLmFwcGVuZChcInNwYW5cIilcbiAgICAgICAgICAgIC50ZXh0KFwiXFx1MDBBMCBcXHUwMEEwIFxcdTAwQTAgXFx1MDBBMCAgIFxcdTAwQTAgXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJtYXJnaW4tdG9wXCIsIDApXG4gICAgICAgICAgICAuc3R5bGUoXCJ3aGl0ZS1zcGFjZVwiLCBcInByZVwiKVxuICAgICAgICAgICAgLnN0eWxlKFwiZGlzcGxheVwiLCBcImlubGluZS1ibG9ja1wiKVxuICAgICAgICAgICAgLnN0eWxlKFwiZmxvYXRcIiwgXCJsZWZ0XCIpXG4gICAgICAgICAgICAuYXBwZW5kKFwic3BhblwiKVxuICAgICAgICAgICAgLnRleHQoXCJ8XCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJtYXJnaW4tdG9wXCIsIDApXG4gICAgICAgICAgICAuc3R5bGUoXCJ3aGl0ZS1zcGFjZVwiLCBcInByZVwiKVxuICAgICAgICAgICAgLnN0eWxlKFwiZGlzcGxheVwiLCBcImlubGluZS1ibG9ja1wiKVxuICAgICAgICAgICAgLnN0eWxlKFwiZmxvYXRcIiwgXCJsZWZ0XCIpXG4gICAgICAgICAgICAuYXBwZW5kKFwic3BhblwiKVxuICAgICAgICAgICAgLnRleHQoXCJcXHUwMEEwIFxcdTAwQTAgXFx1MDBBMCBcXHUwMEEwICAgXFx1MDBBMCBcIilcbiAgICAgICAgICAgIC5zdHlsZShcIm1hcmdpbi10b3BcIiwgMClcbiAgICAgICAgICAgIC5zdHlsZShcIndoaXRlLXNwYWNlXCIsIFwicHJlXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJkaXNwbGF5XCIsIFwiaW5saW5lLWJsb2NrXCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJmbG9hdFwiLCBcImxlZnRcIik7XG5cbiAgICB9XG4gICAgZDMuc2VsZWN0KFwiI21vZGVsVmlld1wiKVxuICAgICAgICAuYXBwZW5kKFwic3BhblwiKVxuICAgICAgICAudGV4dChcIiBcXHUwMEEwXCIpXG4gICAgICAgIC5zdHlsZShcIm1hcmdpbi10b3BcIiwgMClcbiAgICAgICAgLnN0eWxlKFwiZmxvYXRcIiwgXCJsZWZ0XCIpXG5cbiAgICAgICAgLnN0eWxlKFwiZGlzcGxheVwiLCBcImlubGluZS1ibG9ja1wiKVxuICAgICAgICAuc3R5bGUoXCJ3aGl0ZS1zcGFjZVwiLCBcInByZVwiKVxuICAgICAgICAuc3R5bGUoXCJvdmVyZmxvdy15XCIsIFwiaGlkZGVuXCIpXG4gICAgICAgIC5zdHlsZShcIm92ZXJmbG93LXhcIiwgXCJhdXRvXCIpXG4gICAgICAgIC5hcHBlbmQoXCJidXR0b25cIikvLyB0b3Agc3RhY2sgZm9yIHJlc3VsdHNcbiAgICAvLyAgICAgIC5hcHBlbmQoXCJ4aHRtbDpidXR0b25cIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLFwiYnRuIGJ0bi1vdXRsaW5lLXN1Y2Nlc3NcIilcbiAgICAgICAgLnN0eWxlKFwicGFkZGluZ1wiLFwiNHB4XCIpXG4gICAgICAgIC5hdHRyKFwiaWRcIiwgbW9kZWxfc2VsZWN0aW9uX25hbWUpXG4gICAgICAgIC50ZXh0KG1vZGVsX3NlbGVjdGlvbl9uYW1lKVxuICAgICAgICAuc3R5bGUoJ2JhY2tncm91bmQtY29sb3InLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBjb2xvcjEgPSBcIiNGRkQ1NEZcIjtcbiAgICAgICAgICAgIHJldHVybiBjb3VudCA9PSBjb3VudDEgPyBwbG90cy5zZWxWYXJDb2xvciA6IGNvbG9yMTtcbiAgICAgICAgfSlcbiAgICAgICAgLnN0eWxlKFwiZGlzcGxheVwiLCBcImlubGluZS1ibG9ja1wiKVxuICAgICAgICAuc3R5bGUoXCJ3aGl0ZS1zcGFjZVwiLCBcInByZVwiKVxuICAgICAgICAuc3R5bGUoXCJtYXJnaW4tdG9wXCIsIDApXG4gICAgICAgIC5zdHlsZShcImZsb2F0XCIsIFwibGVmdFwiKVxuICAgICAgICAub24oXCJjbGlja1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBhID0gdGhpcy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IucmVwbGFjZSgvXFxzKi9nLCBcIlwiKTtcbiAgICAgICAgICAgIHZhciBiID0gYXBwLmhleFRvUmdiYShwbG90cy5zZWxWYXJDb2xvcikucmVwbGFjZSgvXFxzKi9nLCBcIlwiKTtcbiAgICAgICAgICAgIGlmIChhLnN1YnN0cigwLCAxNykgPT09IGIuc3Vic3RyKDAsIDE3KSkge1xuICAgICAgICAgICAgICAgIHJldHVybjsgLy9lc2NhcGVzIHRoZSBmdW5jdGlvbiBlYXJseSBpZiB0aGUgZGlzcGxheWVkIG1vZGVsIGlzIGNsaWNrZWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZpeih0aGlzLmlkLCBqc29uLCBtb2RlbF9zZWxlY3Rpb25fbmFtZSk7XG4gICAgICAgICAgICBkMy5zZWxlY3QoXCIjbW9kZWxWaWV3XCIpXG4gICAgICAgICAgICAgICAgLnNlbGVjdEFsbChcImJ1dHRvblwiKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnYmFja2dyb3VuZC1jb2xvcicsIFwiI0ZGRDU0RlwiKTtcbiAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnYmFja2dyb3VuZC1jb2xvcicsIHBsb3RzLnNlbFZhckNvbG9yKTtcbiAgICAgICAgICAgIG0ucmVkcmF3KCk7XG4gICAgICAgIH0pO1xufVxuXG5mdW5jdGlvbiBzaG93TG9nKCkge1xuICAgIGlmIChhcHAubG9nQXJyYXkubGVuZ3RoID4gMCkge1xuICAgICAgICBhcHAuYnlJZCgnbG9nZGl2Jykuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgXCJkaXNwbGF5OmJsb2NrXCIpO1xuICAgICAgICBkMy5zZWxlY3QoXCIjY29sbGFwc2VMb2cgZGl2LnBhbmVsLWJvZHlcIikuc2VsZWN0QWxsKFwicFwiKVxuICAgICAgICAgICAgLmRhdGEoYXBwLmxvZ0FycmF5KVxuICAgICAgICAgICAgLmVudGVyKClcbiAgICAgICAgICAgIC5hcHBlbmQoXCJwXCIpXG4gICAgICAgICAgICAudGV4dChkID0+IGQpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGFwcC5ieUlkKCdsb2dkaXYnKS5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcImRpc3BsYXk6bm9uZVwiKTtcbn1cblxubGV0IGNvdW50ID0gMDtcbmxldCBjb3VudDEgPSAwO1xuXG4vKipcbiAgIGNhbGxlZCBieSBjbGlja2luZyAnRXhwbG9yZScgaW4gZXhwbG9yZSBtb2RlXG4qL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGV4cGxvcmUoKSB7XG4gICAgaWYgKGFwcC5kb3dubG9hZEluY29tcGxldGUoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYXBwLnpQb3AoKTtcbiAgICBjb25zb2xlLmxvZygnenBvcDonLCBhcHAuenBhcmFtcyk7XG5cbiAgICAvLyB3cml0ZSBsaW5rcyB0byBmaWxlICYgcnVuIFIgQ01EXG4gICAgYXBwLnpwYXJhbXMuY2FsbEhpc3RvcnkgPSBhcHAuY2FsbEhpc3Rvcnk7XG4gICAgYXBwLmVzdGltYXRlTGFkZGEuc3RhcnQoKTsgLy8gc3RhcnQgc3Bpbm5lclxuICAgIGxldCBqc29uID0gYXdhaXQgYXBwLm1ha2VSZXF1ZXN0KFJPT0tfU1ZDX1VSTCArICdleHBsb3JlYXBwJywgYXBwLnpwYXJhbXMpO1xuICAgIGFwcC5lc3RpbWF0ZUxhZGRhLnN0b3AoKTtcbiAgICBpZiAoIWpzb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGFwcC5hbGxSZXN1bHRzLnB1c2goanNvbik7XG4gICAgYXBwLmV4cGxvcmVkID0gdHJ1ZTtcbiAgICBhcHAudW5pdmFyaWF0ZV9maW5pc2hlZCA9IGZhbHNlO1xuXG4gICAgZDMuc2VsZWN0KFwiI21vZGVsVmlld1wiKS5odG1sKCcnKTtcbiAgICBkMy5zZWxlY3QoXCIjcmVzdWx0c1ZpZXdfc3RhdGlzdGljc1wiKS5odG1sKCcnKTtcblxuICAgIGQzLnNlbGVjdChcIiNtb2RlbFZpZXdcIilcbiAgICAgICAgLnN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJywgYXBwLmhleFRvUmdiYShhcHAudmFyQ29sb3IpKVxuICAgICAgICAuc3R5bGUoXCJvdmVyZmxvdy15XCIsIFwiaGlkZGVuXCIpXG4gICAgICAgIC5zdHlsZShcIm92ZXJmbG93LXhcIiwgXCJhdXRvXCIpXG4gICAgICAgIC5hcHBlbmQoXCJzcGFuXCIpXG4gICAgICAgIC5zdHlsZShcIndoaXRlLXNwYWNlXCIsIFwicHJlXCIpXG4gICAgICAgIC5zdHlsZShcIm1hcmdpbi10b3BcIiwgMClcbiAgICAgICAgLnN0eWxlKFwiZmxvYXRcIiwgXCJsZWZ0XCIpXG4gICAgICAgIC5zdHlsZShcInBvc2l0aW9uXCIsIFwicmVsYXRpdmVcIilcbiAgICAgICAgLnN0eWxlKFwiY29sb3JcIiwgXCIjNzU3NTc1XCIpXG4gICAgICAgIC50ZXh0KFwiTU9ERUwgU0VMRUNUSU9OIDogIFwiKTtcblxuICAgIGNvdW50ID0gMDtcbiAgICBjb3VudDEgPSAwO1xuICAgIGxldCBtb2RlbF9uYW1lO1xuICAgIGZvciAobGV0IGltZyBpbiBqc29uLmltYWdlcykge1xuICAgICAgICBpZiAoY291bnQgPT09IDApIHtcbiAgICAgICAgICAgIG1vZGVsX25hbWUgPSBpbWc7XG4gICAgICAgIH1cbiAgICAgICAgbW9kZWxfc2VsZWN0aW9uKGltZywgY291bnQsIGpzb24pOyAvLyBmb3IgZW50ZXJpbmcgYWxsIHRoZSB2YXJpYWJsZXNcbiAgICAgICAgY291bnQrKztcbiAgICB9XG4gICAgY291bnQxID0gY291bnQgLSAxO1xuICAgIGFwcC5tb2RlbENvdW50Kys7XG5cbiAgICB2YXIgckNhbGwgPSBbXTtcbiAgICByQ2FsbFswXSA9IGpzb24uY2FsbDtcbiAgICBhcHAubG9nQXJyYXkucHVzaChcImV4cGxvcmU6IFwiLmNvbmNhdChyQ2FsbFswXSkpO1xuICAgIHNob3dMb2coKTtcbiAgICB2aXoobW9kZWxfbmFtZSwganNvbiwgbW9kZWxfbmFtZSk7XG4gICAgbS5yZWRyYXcoKTtcbn1cblxuZXhwb3J0IGxldCBleHBsb3JlVmFyID0gJyc7XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2FsbFRyZWVBcHAobm9kZV92YXIsIGFwcCkge1xuICAgIGV4cGxvcmVWYXIgPSBub2RlX3ZhcjtcbiAgICBhcHAuelBvcCgpO1xuICAgIGFwcC56cGFyYW1zLmNhbGxIaXN0b3J5ID0gYXBwLmNhbGxIaXN0b3J5O1xuXG4gICAgYXBwLmVzdGltYXRlTGFkZGEuc3RhcnQoKTtcbiAgICBsZXQgcmVzID0gYXdhaXQgYXBwLm1ha2VSZXF1ZXN0KFJPT0tfU1ZDX1VSTCArICd0cmVlYXBwJywge3pwYXJhbXM6IGFwcC56cGFyYW1zLCBkdjogbm9kZV92YXJ9KTtcbiAgICBhcHAuZXN0aW1hdGVMYWRkYS5zdG9wKCk7XG4gICAgaWYgKHJlcykge1xuICAgICAgICBhcHAuZXhwbG9yZWQgPSBmYWxzZTtcbiAgICAgICAgYXBwLnVuaXZhcmlhdGVfZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICBtLnJlZHJhdygpO1xuICAgICAgICB1bml2YXJpYXRlUGFydChyZXMsIG5vZGVfdmFyKTtcbiAgICB9XG59XG5cbi8vIEtyaXBhbnNodSA6IEZ1bmN0aW9uIHRvIGNyZWF0ZSBEMyBUcmVlIHVzaW5nIHRoZSBKU09OIHJlc3VsdCBmcm9tIGNhbGwgVHJlZSBhcHBcbmZ1bmN0aW9uIHVuaXZhcmlhdGVQYXJ0KGpzb24sIHZhcl9uYW1lKSB7XG4gICAgYXBwLnNldFJpZ2h0VGFiRXhwbG9yZSgnVW5pdmFyaWF0ZScpO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZGVjaXNpb25UcmVlXCIpLmlubmVySFRNTCA9IFwiXCI7XG4gICAgZDMuc2VsZWN0KFwiI2RlY2lzaW9uVHJlZVwiKVxuICAgICAgICAuc3R5bGUoXCJkaXNwbGF5XCIsIFwiYmxvY2tcIilcbiAgICAgICAgLmFwcGVuZChcInBcIilcbiAgICAgICAgLnN0eWxlKFwibWFyZ2luLXRvcFwiLCBcIjFweFwiKVxuICAgICAgICAudGV4dCh2YXJfbmFtZSk7XG5cbiAgICAvLyByZXF1ZXN0IGZvciByIGNvZGUgdXNpbmcgbm9kZXZhclxuICAgIC8vY29kZSBmb3IgdGhlICBkZWNpc2lvbiB0cmVlIG1hcFxuXG4gICAgdmFyIG0gPSBbMTUsIDEwMCwgMTUsIDEwMF0sXG4gICAgICAgIHcgPSA3MDAgLSBtWzFdIC0gbVszXSxcbiAgICAgICAgaCA9IDUwMCAtIG1bMF0gLSBtWzJdLFxuICAgICAgICBpID0gMCxcbiAgICAgICAgcmVjdF93aWR0aCA9IDYwLFxuICAgICAgICByZWN0X2hlaWdodCA9IDIwLFxuICAgICAgICBtYXhfbGlua193aWR0aCA9IDIwLFxuICAgICAgICBtaW5fbGlua193aWR0aCA9IDEuNSxcbiAgICAgICAgY2hhcl90b19weGwgPSA2LFxuICAgICAgICByb290O1xuXG4gICAgdmFyIHRyZWUgPSBkMy5sYXlvdXQudHJlZSgpXG4gICAgICAgIC5zaXplKFtoLCB3XSk7XG5cbiAgICB2YXIgZGlhZ29uYWwgPSBkMy5zdmcuZGlhZ29uYWwoKVxuICAgICAgICAucHJvamVjdGlvbihmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICByZXR1cm4gW2QueCwgZC55XTtcbiAgICAgICAgfSk7XG5cbiAgICAvLyBzZXQgaGVpZ2h0IG9mIFNWRyB2aWEgaGVpZ2h0IG9mIHRyZWUsIDIwMHB4IHBlciBsYXllclxuICAgIGxldCBnZXRIZWlnaHQgPSAoanNvbl9kYXRhKSA9PiBqc29uX2RhdGEuY2hpbGRyZW4gPyBNYXRoLm1heCguLi5qc29uX2RhdGEuY2hpbGRyZW4ubWFwKHYgPT4gZ2V0SGVpZ2h0KHYpKSkgKyAxIDogMDtcblxuICAgIHZhciB2aXMgPSBkMy5zZWxlY3QoXCIjZGVjaXNpb25UcmVlXCIpLmFwcGVuZChcInN2ZzpzdmdcIilcbiAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCB3ICsgbVsxXSArIG1bM10pXG4gICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGdldEhlaWdodChqc29uKSAqIDIwMCArIDIwKVxuICAgICAgICAuc3R5bGUoJ2hlaWdodCcsICdhdXRvJylcbiAgICAgICAgLmFwcGVuZChcInN2ZzpnXCIpXG4gICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgbVszXSArIFwiLFwiICsgbVswXSArIFwiKVwiKTtcblxuICAgIC8vIGdsb2JhbCBzY2FsZSBmb3IgbGluayB3aWR0aFxuICAgIHZhciBsaW5rX3N0b2tlX3NjYWxlID0gZDMuc2NhbGUubGluZWFyKCk7XG5cbiAgICB2YXIgY29sb3JfbWFwID0gZDMuc2NhbGUuY2F0ZWdvcnkxMCgpO1xuXG4gICAgLy8gc3Ryb2tlIHN0eWxlIG9mIGxpbmsgLSBlaXRoZXIgY29sb3Igb3IgZnVuY3Rpb25cbiAgICB2YXIgc3Ryb2tlX2NhbGxiYWNrID0gXCIjY2NjXCI7XG4gICAgbG9hZF9kYXRhc2V0KGpzb24pXG5cbiAgICBmdW5jdGlvbiBsb2FkX2RhdGFzZXQoanNvbl9kYXRhKSB7XG5cbiAgICAgICAgY29uc29sZS5sb2coXCJvdXIgZGF0YSBmb3IgZGVjaXNpb24gdHJlZVwiLCBqc29uX2RhdGEpO1xuICAgICAgICByb290ID0ganNvbl9kYXRhO1xuICAgICAgICByb290LngwID0gMDtcbiAgICAgICAgcm9vdC55MCA9IDA7XG5cbiAgICAgICAgdmFyIG5fc2FtcGxlcyA9IHJvb3Quc2FtcGxlcztcbiAgICAgICAgdmFyIG5fbGFiZWxzID0gcm9vdC52YWx1ZS5sZW5ndGg7XG5cbiAgICAgICAgaWYgKG5fbGFiZWxzID49IDIpIHtcbiAgICAgICAgICAgIHN0cm9rZV9jYWxsYmFjayA9IG1peF9jb2xvcnM7XG4gICAgICAgIH0gZWxzZSBpZiAobl9sYWJlbHMgPT09IDEpIHtcbiAgICAgICAgICAgIHN0cm9rZV9jYWxsYmFjayA9IG1lYW5faW50ZXJwb2xhdGlvbihyb290KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxpbmtfc3Rva2Vfc2NhbGUgPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAgICAgLmRvbWFpbihbMCwgbl9zYW1wbGVzXSlcbiAgICAgICAgICAgIC5yYW5nZShbbWluX2xpbmtfd2lkdGgsIG1heF9saW5rX3dpZHRoXSk7XG5cbiAgICAgICAgZnVuY3Rpb24gdG9nZ2xlQWxsKGQpIHtcbiAgICAgICAgICAgIGlmIChkICYmIGQuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICBkLmNoaWxkcmVuLmZvckVhY2godG9nZ2xlQWxsKTtcbiAgICAgICAgICAgICAgICB0b2dnbGUoZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBkaXNwbGF5IHRvIHNob3cgYSBmZXcgbm9kZXMuXG4gICAgICAgIHJvb3QuY2hpbGRyZW4uZm9yRWFjaCh0b2dnbGVBbGwpO1xuXG4gICAgICAgIHVwZGF0ZShyb290KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGUoc291cmNlKSB7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IGQzLmV2ZW50ICYmIGQzLmV2ZW50LmFsdEtleSA/IDUwMDAgOiA1MDA7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgbmV3IHRyZWUgbGF5b3V0LlxuICAgICAgICB2YXIgbm9kZXMgPSB0cmVlLm5vZGVzKHJvb3QpLnJldmVyc2UoKTtcblxuICAgICAgICAvLyBOb3JtYWxpemUgZm9yIGZpeGVkLWRlcHRoLlxuICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIGQueSA9IGQuZGVwdGggKiAxODA7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgbm9kZXPigKZcbiAgICAgICAgdmFyIG5vZGUgPSB2aXMuc2VsZWN0QWxsKFwiZy5ub2RlXCIpXG4gICAgICAgICAgICAuZGF0YShub2RlcywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkLmlkIHx8IChkLmlkID0gKytpKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEVudGVyIGFueSBuZXcgbm9kZXMgYXQgdGhlIHBhcmVudCdzIHByZXZpb3VzIHBvc2l0aW9uLlxuICAgICAgICB2YXIgbm9kZUVudGVyID0gbm9kZS5lbnRlcigpLmFwcGVuZChcInN2ZzpnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwibm9kZVwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcInRyYW5zbGF0ZShcIiArIHNvdXJjZS54MCArIFwiLFwiICsgc291cmNlLnkwICsgXCIpXCI7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIHRvZ2dsZShkKTtcbiAgICAgICAgICAgICAgICB1cGRhdGUoZCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBub2RlRW50ZXIuYXBwZW5kKFwic3ZnOnJlY3RcIilcbiAgICAgICAgICAgIC5hdHRyKFwieFwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhYmVsID0gbm9kZV9sYWJlbChkKTtcbiAgICAgICAgICAgICAgICB2YXIgdGV4dF9sZW4gPSBsYWJlbC5sZW5ndGggKiBjaGFyX3RvX3B4bDtcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSBkMy5tYXgoW3JlY3Rfd2lkdGgsIHRleHRfbGVuXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC13aWR0aCAvIDI7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCAxZS02KVxuICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgMWUtNilcbiAgICAgICAgICAgIC5hdHRyKFwicnhcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkLnR5cGUgPT09IFwic3BsaXRcIiA/IDIgOiAwO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5hdHRyKFwicnlcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkLnR5cGUgPT09IFwic3BsaXRcIiA/IDIgOiAwO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5zdHlsZShcInN0cm9rZVwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGQudHlwZSA9PT0gXCJzcGxpdFwiID8gXCJzdGVlbGJsdWVcIiA6IFwib2xpdmVkcmFiXCI7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGQuX2NoaWxkcmVuID8gXCJsaWdodHN0ZWVsYmx1ZVwiIDogXCIjZmZmXCI7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBub2RlRW50ZXIuYXBwZW5kKFwic3ZnOnRleHRcIilcbiAgICAgICAgICAgIC5hdHRyKFwiZHlcIiwgXCIxMnB4XCIpXG4gICAgICAgICAgICAuYXR0cihcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpXG4gICAgICAgICAgICAudGV4dChub2RlX2xhYmVsKVxuICAgICAgICAgICAgLnN0eWxlKFwiZmlsbC1vcGFjaXR5XCIsIDFlLTYpO1xuXG4gICAgICAgIC8vIFRyYW5zaXRpb24gbm9kZXMgdG8gdGhlaXIgbmV3IHBvc2l0aW9uLlxuICAgICAgICB2YXIgbm9kZVVwZGF0ZSA9IG5vZGUudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAuZHVyYXRpb24oZHVyYXRpb24pXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwidHJhbnNsYXRlKFwiICsgZC54ICsgXCIsXCIgKyBkLnkgKyBcIilcIjtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIG5vZGVVcGRhdGUuc2VsZWN0KFwicmVjdFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhYmVsID0gbm9kZV9sYWJlbChkKTtcbiAgICAgICAgICAgICAgICB2YXIgdGV4dF9sZW4gPSBsYWJlbC5sZW5ndGggKiBjaGFyX3RvX3B4bDtcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSBkMy5tYXgoW3JlY3Rfd2lkdGgsIHRleHRfbGVuXSlcbiAgICAgICAgICAgICAgICByZXR1cm4gd2lkdGg7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgcmVjdF9oZWlnaHQpXG4gICAgICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZC5fY2hpbGRyZW4gPyBcImxpZ2h0c3RlZWxibHVlXCIgOiBcIiNmZmZcIjtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIG5vZGVVcGRhdGUuc2VsZWN0KFwidGV4dFwiKVxuICAgICAgICAgICAgLnN0eWxlKFwiZmlsbC1vcGFjaXR5XCIsIDEpO1xuXG4gICAgICAgIC8vIFRyYW5zaXRpb24gZXhpdGluZyBub2RlcyB0byB0aGUgcGFyZW50J3MgbmV3IHBvc2l0aW9uLlxuICAgICAgICB2YXIgbm9kZUV4aXQgPSBub2RlLmV4aXQoKS50cmFuc2l0aW9uKClcbiAgICAgICAgICAgIC5kdXJhdGlvbihkdXJhdGlvbilcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJ0cmFuc2xhdGUoXCIgKyBzb3VyY2UueCArIFwiLFwiICsgc291cmNlLnkgKyBcIilcIjtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAucmVtb3ZlKCk7XG5cbiAgICAgICAgbm9kZUV4aXQuc2VsZWN0KFwicmVjdFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCAxZS02KVxuICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgMWUtNik7XG5cbiAgICAgICAgbm9kZUV4aXQuc2VsZWN0KFwidGV4dFwiKVxuICAgICAgICAgICAgLnN0eWxlKFwiZmlsbC1vcGFjaXR5XCIsIDFlLTYpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgbGlua3NcbiAgICAgICAgdmFyIGxpbmsgPSB2aXMuc2VsZWN0QWxsKFwicGF0aC5saW5rXCIpXG4gICAgICAgICAgICAuZGF0YSh0cmVlLmxpbmtzKG5vZGVzKSwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkLnRhcmdldC5pZDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEVudGVyIGFueSBuZXcgbGlua3MgYXQgdGhlIHBhcmVudCdzIHByZXZpb3VzIHBvc2l0aW9uLlxuICAgICAgICBsaW5rLmVudGVyKCkuaW5zZXJ0KFwic3ZnOnBhdGhcIiwgXCJnXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwibGlua1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJkXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbyA9IHtcbiAgICAgICAgICAgICAgICAgICAgeDogc291cmNlLngwLFxuICAgICAgICAgICAgICAgICAgICB5OiBzb3VyY2UueTBcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBkaWFnb25hbCh7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogbyxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBvXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgLmR1cmF0aW9uKGR1cmF0aW9uKVxuICAgICAgICAgICAgLmF0dHIoXCJkXCIsIGRpYWdvbmFsKVxuICAgICAgICAgICAgLnN0eWxlKFwic3Ryb2tlLXdpZHRoXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGlua19zdG9rZV9zY2FsZShkLnRhcmdldC5zYW1wbGVzKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuc3R5bGUoXCJzdHJva2VcIiwgc3Ryb2tlX2NhbGxiYWNrKTtcblxuICAgICAgICAvLyBUcmFuc2l0aW9uIGxpbmtzIHRvIHRoZWlyIG5ldyBwb3NpdGlvbi5cbiAgICAgICAgbGluay50cmFuc2l0aW9uKClcbiAgICAgICAgICAgIC5kdXJhdGlvbihkdXJhdGlvbilcbiAgICAgICAgICAgIC5hdHRyKFwiZFwiLCBkaWFnb25hbClcbiAgICAgICAgICAgIC5zdHlsZShcInN0cm9rZS13aWR0aFwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpbmtfc3Rva2Vfc2NhbGUoZC50YXJnZXQuc2FtcGxlcyk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnN0eWxlKFwic3Ryb2tlXCIsIHN0cm9rZV9jYWxsYmFjayk7XG5cbiAgICAgICAgLy8gVHJhbnNpdGlvbiBleGl0aW5nIG5vZGVzIHRvIHRoZSBwYXJlbnQncyBuZXcgcG9zaXRpb24uXG4gICAgICAgIGxpbmsuZXhpdCgpLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgLmR1cmF0aW9uKGR1cmF0aW9uKVxuICAgICAgICAgICAgLmF0dHIoXCJkXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbyA9IHtcbiAgICAgICAgICAgICAgICAgICAgeDogc291cmNlLngsXG4gICAgICAgICAgICAgICAgICAgIHk6IHNvdXJjZS55XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlhZ29uYWwoe1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IG8sXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogb1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5yZW1vdmUoKTtcblxuICAgICAgICAvLyBTdGFzaCB0aGUgb2xkIHBvc2l0aW9ucyBmb3IgdHJhbnNpdGlvbi5cbiAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICBkLngwID0gZC54O1xuICAgICAgICAgICAgZC55MCA9IGQueTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gVG9nZ2xlIGNoaWxkcmVuLlxuICAgIGZ1bmN0aW9uIHRvZ2dsZShkKSB7XG4gICAgICAgIGlmIChkLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBkLl9jaGlsZHJlbiA9IGQuY2hpbGRyZW47XG4gICAgICAgICAgICBkLmNoaWxkcmVuID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGQuY2hpbGRyZW4gPSBkLl9jaGlsZHJlbjtcbiAgICAgICAgICAgIGQuX2NoaWxkcmVuID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE5vZGUgbGFiZWxzXG4gICAgZnVuY3Rpb24gbm9kZV9sYWJlbChkKSB7XG4gICAgICAgIGlmIChkLnR5cGUgPT09IFwibGVhZlwiKSB7XG4gICAgICAgICAgICAvLyBsZWFmXG4gICAgICAgICAgICB2YXIgZm9ybWF0dGVyID0gZDMuZm9ybWF0KFwiLjJmXCIpO1xuICAgICAgICAgICAgdmFyIHZhbHMgPSBbXTtcbiAgICAgICAgICAgIGQudmFsdWUuZm9yRWFjaChmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICAgICAgdmFscy5wdXNoKGZvcm1hdHRlcih2KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBcIltcIiArIHZhbHMuam9pbihcIiwgXCIpICsgXCJdXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzcGxpdCBub2RlXG4gICAgICAgICAgICByZXR1cm4gZC5sYWJlbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1peGVzIGNvbG9ycyBhY2NvcmRpbmcgdG8gdGhlIHJlbGF0aXZlIGZyZXF1ZW5jeSBvZiBjbGFzc2VzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1peF9jb2xvcnMoZCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBkLnRhcmdldC52YWx1ZTtcbiAgICAgICAgdmFyIHN1bSA9IGQzLnN1bSh2YWx1ZSk7XG4gICAgICAgIHZhciBjb2wgPSBkMy5yZ2IoMCwgMCwgMCk7XG4gICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24odmFsLCBpKSB7XG4gICAgICAgICAgICB2YXIgbGFiZWxfY29sb3IgPSBkMy5yZ2IoY29sb3JfbWFwKGkpKTtcbiAgICAgICAgICAgIHZhciBtaXhfY29lZiA9IHZhbCAvIHN1bTtcbiAgICAgICAgICAgIGNvbC5yICs9IG1peF9jb2VmICogbGFiZWxfY29sb3IucjtcbiAgICAgICAgICAgIGNvbC5nICs9IG1peF9jb2VmICogbGFiZWxfY29sb3IuZztcbiAgICAgICAgICAgIGNvbC5iICs9IG1peF9jb2VmICogbGFiZWxfY29sb3IuYjtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb2w7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBBIGxpbmVhciBpbnRlcnBvbGF0b3IgZm9yIHZhbHVlWzBdLlxuICAgICAqXG4gICAgICogVXNlZnVsIGZvciBsaW5rIGNvbG9yaW5nIGluIHJlZ3Jlc3Npb24gdHJlZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVhbl9pbnRlcnBvbGF0aW9uKHJvb3QpIHtcblxuICAgICAgICB2YXIgbWF4ID0gMWUtOSxcbiAgICAgICAgICAgIG1pbiA9IDFlOTtcblxuICAgICAgICBmdW5jdGlvbiByZWN1cnNlKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChub2RlLnZhbHVlWzBdID4gbWF4KSB7XG4gICAgICAgICAgICAgICAgbWF4ID0gbm9kZS52YWx1ZVswXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5vZGUudmFsdWVbMF0gPCBtaW4pIHtcbiAgICAgICAgICAgICAgICBtaW4gPSBub2RlLnZhbHVlWzBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4uZm9yRWFjaChyZWN1cnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlY3Vyc2Uocm9vdCk7XG5cbiAgICAgICAgdmFyIHNjYWxlID0gZDMuc2NhbGUubGluZWFyKCkuZG9tYWluKFttaW4sIG1heF0pXG4gICAgICAgICAgICAucmFuZ2UoW1wiIzIxNjZBQ1wiLCBcIiNCMjE4MkJcIl0pO1xuXG4gICAgICAgIGZ1bmN0aW9uIGludGVycG9sYXRvcihkKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NhbGUoZC50YXJnZXQudmFsdWVbMF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGludGVycG9sYXRvcjtcbiAgICB9XG5cblxufVxuXG5cblxuXG5cblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYXNzZXRzL2FwcC9leHBsb3JlLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///14\n')},function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nexports.init = init;\n\nvar _app = __webpack_require__(2);\n\nvar app = _interopRequireWildcard(_app);\n\nvar _plots = __webpack_require__(4);\n\nvar _utils = __webpack_require__(3);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar force = void 0;\nvar nodes = [];\nvar links = [];\nvar circle = void 0,\n    path = void 0;\n\n// mouse event vars\nvar selected_node = null,\n    selected_link = null,\n    mousedown_link = null,\n    mousedown_node = null,\n    mouseup_node = null;\n\nfunction resetMouseVars() {\n    mousedown_node = null;\n    mouseup_node = null;\n    mousedown_link = null;\n}\n\n// update force layout (called automatically each iteration)\nfunction tick() {\n    // draw directed edges with proper padding from node centers\n    path.attr('d', function (d) {\n        var deltaX = d.target.x - d.source.x,\n            deltaY = d.target.y - d.source.y,\n            dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY),\n            normX = deltaX / dist,\n            normY = deltaY / dist,\n            sourcePadding = d.left ? RADIUS + 5 : RADIUS,\n            targetPadding = d.right ? RADIUS + 5 : RADIUS,\n            sourceX = d.source.x + sourcePadding * normX,\n            sourceY = d.source.y + sourcePadding * normY,\n            targetX = d.target.x - targetPadding * normX,\n            targetY = d.target.y - targetPadding * normY;\n        return 'M' + sourceX + ',' + sourceY + 'L' + targetX + ',' + targetY;\n    });\n\n    circle.attr('transform', function (d) {\n        return 'translate(' + d.x + ',' + d.y + ')';\n    });\n    circle.selectAll('circle') // shrink/expand pebbles that join/leave groups\n    .transition().duration(100).attr('r', function (d) {\n        return (0, _app.setPebbleRadius)(d);\n    });\n}\n\nfunction mousemove(d) {\n    if (!mousedown_node) return;\n    // update drag line\n    drag_line.attr('d', 'M' + mousedown_node.x + ',' + mousedown_node.y + 'L' + d3.mouse(this)[0] + ',' + d3.mouse(this)[1]);\n}\n\nfunction mouseup(d) {\n    if (mousedown_node) {\n        drag_line.classed('hidden', true).style('marker-end', '');\n    }\n    // because :active only works in WebKit?\n    svg.classed('active', false);\n    // clear mouse event vars\n    resetMouseVars();\n}\n\n// update graph (called when needed)\nfunction restart(line, line2, visbackground, vis2background, vis, vis2, drag_line) {\n    var forcetoggle = app.forcetoggle,\n        setPebbleCharge = app.setPebbleCharge,\n        k = app.k,\n        zparams = app.zparams,\n        arc3 = app.arc3,\n        dvColor = app.dvColor,\n        arc4 = app.arc4,\n        nomColor = app.nomColor,\n        arc1 = app.arc1,\n        gr1Color = app.gr1Color,\n        arcInd1 = app.arcInd1,\n        arcInd2 = app.arcInd2,\n        gr2Color = app.gr2Color,\n        record_user_metadata = app.record_user_metadata;\n\n    // nodes.index is floating and depends on updates to nodes. a variables index changes when new variables are added.\n\n    circle.call(force.drag);\n    if (forcetoggle[0] == \"true\") {\n        force.gravity(0.1);\n        force.charge(setPebbleCharge);\n        force.start();\n        force.linkStrength(1);\n        k = 4; // strength parameter for group attraction/repulsion\n        if (zparams.zgroup1.length > 0 & zparams.zgroup2.length > 0) {\n            // scale down by number of active groups\n            k = 2.5;\n        }\n    } else {\n        force.gravity(0);\n        force.charge(0);\n        force.linkStrength(0);\n        k = 0;\n    }\n    force.resume();\n\n    // path (link) group\n    path = path.data(links);\n\n    // update existing links\n    // VJD: dashed links between pebbles are \"selected\". this is disabled for now\n    path.classed('selected', function (x) {\n        return null;\n    }).style('marker-start', function (x) {\n        return '';\n    }).style('marker-end', function (x) {\n        return '';\n    });\n\n    // add new links\n    path.enter().append('svg:path').attr('class', 'link').classed('selected', function (x) {\n        return null;\n    }).style('marker-start', function (x) {\n        return '';\n    }).style('marker-end', function (x) {\n        return '';\n    }).on('mousedown', function (d) {\n        // do we ever need to select a link? make it delete..\n        var obj = JSON.stringify(d);\n        for (var j = 0; j < links.length; j++) {\n            if (obj === JSON.stringify(links[j])) {\n                del(links, j);\n            }\n        }\n    });\n\n    // remove old links\n    path.exit().remove();\n\n    // circle (node) group\n    circle = circle.data(nodes, function (x) {\n        return x.id;\n    });\n\n    // update existing nodes (reflexive & selected visual states)\n    // d3.rgb is the function adjusting the color here\n    circle.selectAll('circle').classed('reflexive', function (x) {\n        return x.reflexive;\n    }).style('fill', function (x) {\n        return d3.rgb(x.nodeCol);\n    }).style('stroke', function (x) {\n        return d3.rgb(x.strokeColor);\n    }).style('stroke-width', function (x) {\n        return x.strokeWidth;\n    });\n\n    // add new nodes\n    var g = circle.enter().append('svg:g').attr('id', function (x) {\n        return x.name + 'biggroup';\n    });\n\n    // add plot\n    g.each(function (d) {\n        d3.select(this);\n        if (d.plottype == 'continuous') (0, _plots.densityNode)(d, this);else if (d.plottype == 'bar') (0, _plots.barsNode)(d, this);\n    });\n\n    var append = function append(str, attr) {\n        return function (x) {\n            return str + x[attr || 'id'];\n        };\n    };\n\n    g.append(\"path\").attr(\"id\", append('dvArc')).attr(\"d\", arc3).style(\"fill\", dvColor).attr(\"fill-opacity\", 0).on('mouseover', function (d) {\n        fillThis(this, .3, 0, 100);\n        fill(d, 'dvText', .9, 0, 100);\n    }).on('mouseout', function (d) {\n        fillThis(this, 0, 100, 500);\n        fill(d, 'dvText', 0, 100, 500);\n    }).on('click', function (d) {\n        setColors(d, dvColor);\n        legend(dvColor);\n        //restart();\n        d.group1 = d.group2 = false;\n    });\n\n    g.append(\"text\").attr(\"id\", append('dvText')).attr(\"x\", 6).attr(\"dy\", 11.5).attr(\"fill-opacity\", 0).append(\"textPath\").attr(\"xlink:href\", append('#dvArc')).text(\"Dep Var\");\n\n    g.append(\"path\").attr(\"id\", append('nomArc')).attr(\"d\", arc4).style(\"fill\", nomColor).attr(\"fill-opacity\", 0).on('mouseover', function (d) {\n        if (d.defaultNumchar == \"character\") return;\n        fillThis(this, .3, 0, 100);\n        fill(d, \"nomText\", .9, 0, 100);\n    }).on('mouseout', function (d) {\n        if (d.defaultNumchar == \"character\") return;\n        fillThis(this, 0, 100, 500);\n        fill(d, \"nomText\", 0, 100, 500);\n    }).on('click', function (d) {\n        if (d.defaultNumchar == \"character\") return;\n        setColors(d, nomColor);\n        legend(nomColor);\n        //restart();\n    });\n\n    g.append(\"text\").attr(\"id\", append(\"nomText\")).attr(\"x\", 6).attr(\"dy\", 11.5).attr(\"fill-opacity\", 0).append(\"textPath\").attr(\"xlink:href\", append(\"#nomArc\")).text(\"Nominal\");\n\n    g.append(\"path\").attr(\"id\", append('grArc')).attr(\"d\", arc1).style(\"fill\", gr1Color).attr(\"fill-opacity\", 0).on('mouseover', function (d) {\n        fill(d, \"gr1indicator\", .3, 0, 100);\n        fill(d, \"gr2indicator\", .3, 0, 100);\n        fillThis(this, .3, 0, 100);\n        fill(d, 'grText', .9, 0, 100);\n    }).on('mouseout', function (d) {\n        fill(d, \"gr1indicator\", 0, 100, 500);\n        fill(d, \"gr2indicator\", 0, 100, 500);\n        fillThis(this, 0, 100, 500);\n        fill(d, 'grText', 0, 100, 500);\n    }).on('click', function (d) {\n        //d.group1 = !d.group1;      // This might be easier, but currently set in setColors()\n        setColors(d, gr1Color);\n        legend(gr1Color);\n        //restart();\n    });\n\n    g.append(\"path\").attr(\"id\", append('gr1indicator')).attr(\"d\", arcInd1).style(\"fill\", gr1Color) // something like: zparams.zgroup1.indexOf(node.name) > -1  ?  #FFFFFF : gr1Color)\n    .attr(\"fill-opacity\", 0).on('mouseover', function (d) {\n        fillThis(this, .3, 0, 100);\n        fill(d, \"grArc\", .1, 0, 100);\n        fill(d, 'grText', .9, 0, 100);\n    }).on('mouseout', function (d) {\n        fillThis(this, 0, 100, 500);\n        fill(d, \"grArc\", 0, 100, 500);\n        fill(d, 'grText', 0, 100, 500);\n    }).on('click', function (d) {\n        //d.group1 = !d.group1;      // This might be easier, but currently set in setColors()\n        setColors(d, gr1Color);\n        legend(gr1Color);\n        //restart();\n    });\n\n    g.append(\"path\").attr(\"id\", append('gr2indicator')).attr(\"d\", arcInd2).style(\"fill\", gr2Color) // something like: zparams.zgroup1.indexOf(node.name) > -1  ?  #FFFFFF : gr1Color)\n    .attr(\"fill-opacity\", 0).on('mouseover', function (d) {\n        fillThis(this, .3, 0, 100);\n        fill(d, \"grArc\", .1, 0, 100);\n        fill(d, 'grText', .9, 0, 100);\n    }).on('mouseout', function (d) {\n        fillThis(this, 0, 100, 500);\n        fill(d, \"grArc\", 0, 100, 500);\n        fill(d, 'grText', 0, 100, 500);\n    }).on('click', function (d) {\n        //d.group2 = !d.group2;      // This might be easier, but currently set in setColors()\n        setColors(d, gr2Color);\n        legend(gr2Color);\n        //restart();\n    });\n\n    g.append(\"text\").attr(\"id\", append('grText')).attr(\"x\", 6).attr(\"dy\", 11.5).attr(\"fill-opacity\", 0).append(\"textPath\").attr(\"xlink:href\", append('#grArc')).text(\"Groups\");\n\n    g.append('svg:circle').attr('class', 'node').attr('r', function (d) {\n        return (0, _app.setPebbleRadius)(d);\n    }).style('pointer-events', 'inherit').style('fill', function (d) {\n        return d.nodeCol;\n    }).style('opacity', \"0.5\").style('stroke', function (d) {\n        return d3.rgb(d.strokeColor).toString();\n    }).classed('reflexive', function (d) {\n        return d.reflexive;\n    }).on('dblclick', function (d) {\n        d3.event.stopPropagation(); // stop click from bubbling\n        summaryHold = true;\n        console.log(\"pebble\");\n        console.log(d.group2);\n        if (d.group1) {\n            var len = nodes.length;\n            var hold = [.6, .2, .9, .8, .1, .3, .4];\n            for (var p = 0; p < d.properties.length; p++) {\n                var obj = {\n                    id: len + p,\n                    reflexive: false,\n                    name: d.properties[p],\n                    labl: \"no labels\",\n                    data: [5, 15, 20, 0, 5, 15, 20],\n                    count: hold,\n                    nodeCol: colors(p),\n                    baseCol: colors(p),\n                    strokeColor: selVarColor,\n                    strokeWidth: \"1\",\n                    subsetplot: false,\n                    subsetrange: [\"\", \"\"],\n                    setxplot: false,\n                    setxvals: [\"\", \"\"],\n                    grayout: false,\n                    group1: false,\n                    group2: true,\n                    forefront: false\n                };\n                console.log(\"obj after merge\");\n                nodes.push(obj);\n                nodes.push(obj);\n                console.log(nodes);\n                links.push({\n                    source: nodes[d.id - 1],\n                    target: nodes[nodes.length - 1], // not able to access with object id!!\n                    left: false,\n                    right: true\n                });\n            }\n            //_restart();\n        }\n    }).on('contextmenu', function (d) {\n        // right click on node\n        d3.event.preventDefault();\n        d3.event.stopPropagation();\n\n        rightClickLast = true;\n        mousedown_node = d;\n        selected_node = mousedown_node === selected_node ? null : mousedown_node;\n        selected_link = null;\n\n        // reposition drag line\n        drag_line.style('marker-end', 'url(#end-arrow)').classed('hidden', false).attr('d', 'M' + mousedown_node.x + ',' + mousedown_node.y + 'L' + mousedown_node.x + ',' + mousedown_node.y);\n\n        svg.on('mousemove', mousemove);\n        //restart();\n    }).on('mouseup', function (d) {\n        d3.event.stopPropagation();\n\n        if (rightClickLast) {\n            rightClickLast = false;\n            return;\n        }\n        if (!mousedown_node) return;\n\n        // needed by FF\n        drag_line.classed('hidden', true).style('marker-end', '');\n\n        // check for drag-to-self\n        mouseup_node = d;\n        if (mouseup_node === mousedown_node) {\n            resetMouseVars();\n            return;\n        }\n\n        // unenlarge target node\n        d3.select(this).attr('transform', '');\n\n        // add link to graph (update if exists)\n        // NB: links are strictly source < target; arrows separately specified by booleans\n        var source, target, direction;\n        if (mousedown_node.id < mouseup_node.id) {\n            source = mousedown_node;\n            target = mouseup_node;\n            direction = 'right';\n        } else {\n            source = mouseup_node;\n            target = mousedown_node;\n            direction = 'left';\n        }\n\n        var link = links.filter(function (x) {\n            return x.source == source && x.target == target;\n        })[0];\n        if (link) {\n            link[direction] = true;\n        } else {\n            link = {\n                source: source,\n                target: target,\n                left: false,\n                right: false\n            };\n            link[direction] = true;\n            links.push(link);\n        }\n\n        // select new link\n        selected_link = link;\n        selected_node = null;\n        svg.on('mousemove', null);\n\n        resetMouseVars();\n        //restart();\n    });\n\n    // show node names\n    g.append('svg:text').attr('x', 0).attr('y', 15).attr('class', 'id').text(function (d) {\n        return d.name;\n    });\n\n    // show summary stats on mouseover\n    // SVG doesn't support text wrapping, use html instead\n    g.selectAll(\"circle.node\").on(\"mouseover\", function (d) {\n        tabLeft('tab3');\n        varSummary(d);\n        d.forefront = true;\n\n        byId('transformations').setAttribute('style', 'display:block');\n        byId(\"transSel\").selectedIndex = d.id;\n        transformVar = valueKey[d.id];\n\n        fill(d, \"dvArc\", .1, 0, 100);\n        fill(d, \"dvText\", .5, 0, 100);\n        fill(d, \"grArc\", .1, 0, 100);\n        fill(d, \"grText\", .5, 0, 100);\n\n        if (d.defaultNumchar == \"numeric\") {\n            fill(d, \"nomArc\", .1, 0, 100);\n            fill(d, \"nomText\", .5, 0, 100);\n        }\n        fill(d, \"csArc\", .1, 0, 100);\n        fill(d, \"csText\", .5, 0, 100);\n        fill(d, \"timeArc\", .1, 0, 100);\n        fill(d, \"timeText\", .5, 0, 100);\n\n        m.redraw();\n    }).on('mouseout', function (d) {\n        d.forefront = false;\n        summaryHold || tabLeft(subset ? 'tab2' : 'tab1');\n        'csArc csText timeArc timeText dvArc dvText nomArc nomText grArc grText'.split(' ').map(function (x) {\n            return fill(d, x, 0, 100, 500);\n        });\n        m.redraw();\n    });\n\n    // the transformation variable list is silently updated as pebbles are added/removed\n    d3.select(\"#transSel\").selectAll('li').remove();\n\n    d3.select(\"#transSel\").selectAll('li').data(nodes.map(function (x) {\n        return x.name;\n    })) // set to variables in model space as they're added\n    .enter().append(\"li\").text(function (d) {\n        return d;\n    });\n\n    // remove old nodes\n    circle.exit().remove();\n    force.start();\n\n    // save workspaces\n    console.log('ok ws');\n    record_user_metadata();\n}\n\nfunction init() {\n    var gr1Color = app.gr1Color,\n        gr2Color = app.gr2Color,\n        RADIUS = app.RADIUS,\n        height = app.height,\n        width = app.width,\n        fakeClick = app.fakeClick,\n        myspace = app.myspace;\n\n\n    nodes = Object.values(app.allPipelineInfo);\n\n    // app starts here\n    var svg = d3.select('#whitespace0');\n    svg.selectAll('*').remove();\n\n    var _app$setup_svg = app.setup_svg(svg),\n        _app$setup_svg2 = _slicedToArray(_app$setup_svg, 9),\n        line = _app$setup_svg2[0],\n        line2 = _app$setup_svg2[1],\n        visbackground = _app$setup_svg2[2],\n        vis2background = _app$setup_svg2[3],\n        vis = _app$setup_svg2[4],\n        vis2 = _app$setup_svg2[5],\n        drag_line = _app$setup_svg2[6],\n        path1 = _app$setup_svg2[7],\n        circle1 = _app$setup_svg2[8];\n\n    path = path1;\n    circle = circle1;\n\n    svg.attr('id', function () {\n        return \"whitespace\".concat(myspace);\n    }).attr('height', height).on('mousedown', function (d) {\n        // prevent I-bar on drag\n        d3.event.preventDefault();\n        // because :active only works in WebKit?\n        svg.classed('active', true);\n        if (d3.event.ctrlKey || mousedown_node || mousedown_link) {\n            return;\n        }\n        //restart();\n    }).on('mouseup', mouseup);\n\n    force = d3.layout.force().nodes(nodes).links(links).size([width, height]).linkDistance(150).charge(-800).on('tick', tick);\n\n    d3.select(window).on('click', function () {\n        // all clicks will bubble here unless event.stopPropagation()\n        (0, _utils.fadeOut)('#transList', 100);\n        (0, _utils.fadeOut)('#transSel', 100);\n    });\n\n    restart(line, line2, visbackground, vis2background, vis, vis2, drag_line); // initializes force.layout()\n    fakeClick();\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvYXBwL2xheW91dC5qcz84NjM1Il0sIm5hbWVzIjpbImluaXQiLCJhcHAiLCJmb3JjZSIsIm5vZGVzIiwibGlua3MiLCJjaXJjbGUiLCJwYXRoIiwic2VsZWN0ZWRfbm9kZSIsInNlbGVjdGVkX2xpbmsiLCJtb3VzZWRvd25fbGluayIsIm1vdXNlZG93bl9ub2RlIiwibW91c2V1cF9ub2RlIiwicmVzZXRNb3VzZVZhcnMiLCJ0aWNrIiwiYXR0ciIsImRlbHRhWCIsImQiLCJ0YXJnZXQiLCJ4Iiwic291cmNlIiwiZGVsdGFZIiwieSIsImRpc3QiLCJNYXRoIiwic3FydCIsIm5vcm1YIiwibm9ybVkiLCJzb3VyY2VQYWRkaW5nIiwibGVmdCIsIlJBRElVUyIsInRhcmdldFBhZGRpbmciLCJyaWdodCIsInNvdXJjZVgiLCJzb3VyY2VZIiwidGFyZ2V0WCIsInRhcmdldFkiLCJzZWxlY3RBbGwiLCJ0cmFuc2l0aW9uIiwiZHVyYXRpb24iLCJtb3VzZW1vdmUiLCJkcmFnX2xpbmUiLCJkMyIsIm1vdXNlIiwibW91c2V1cCIsImNsYXNzZWQiLCJzdHlsZSIsInN2ZyIsInJlc3RhcnQiLCJsaW5lIiwibGluZTIiLCJ2aXNiYWNrZ3JvdW5kIiwidmlzMmJhY2tncm91bmQiLCJ2aXMiLCJ2aXMyIiwiZm9yY2V0b2dnbGUiLCJzZXRQZWJibGVDaGFyZ2UiLCJrIiwienBhcmFtcyIsImFyYzMiLCJkdkNvbG9yIiwiYXJjNCIsIm5vbUNvbG9yIiwiYXJjMSIsImdyMUNvbG9yIiwiYXJjSW5kMSIsImFyY0luZDIiLCJncjJDb2xvciIsInJlY29yZF91c2VyX21ldGFkYXRhIiwiY2FsbCIsImRyYWciLCJncmF2aXR5IiwiY2hhcmdlIiwic3RhcnQiLCJsaW5rU3RyZW5ndGgiLCJ6Z3JvdXAxIiwibGVuZ3RoIiwiemdyb3VwMiIsInJlc3VtZSIsImRhdGEiLCJlbnRlciIsImFwcGVuZCIsIm9uIiwib2JqIiwiSlNPTiIsInN0cmluZ2lmeSIsImoiLCJkZWwiLCJleGl0IiwicmVtb3ZlIiwiaWQiLCJyZWZsZXhpdmUiLCJyZ2IiLCJub2RlQ29sIiwic3Ryb2tlQ29sb3IiLCJzdHJva2VXaWR0aCIsImciLCJuYW1lIiwiZWFjaCIsInNlbGVjdCIsInBsb3R0eXBlIiwic3RyIiwiZmlsbFRoaXMiLCJmaWxsIiwic2V0Q29sb3JzIiwibGVnZW5kIiwiZ3JvdXAxIiwiZ3JvdXAyIiwidGV4dCIsImRlZmF1bHROdW1jaGFyIiwidG9TdHJpbmciLCJldmVudCIsInN0b3BQcm9wYWdhdGlvbiIsInN1bW1hcnlIb2xkIiwiY29uc29sZSIsImxvZyIsImxlbiIsImhvbGQiLCJwIiwicHJvcGVydGllcyIsImxhYmwiLCJjb3VudCIsImNvbG9ycyIsImJhc2VDb2wiLCJzZWxWYXJDb2xvciIsInN1YnNldHBsb3QiLCJzdWJzZXRyYW5nZSIsInNldHhwbG90Iiwic2V0eHZhbHMiLCJncmF5b3V0IiwiZm9yZWZyb250IiwicHVzaCIsInByZXZlbnREZWZhdWx0IiwicmlnaHRDbGlja0xhc3QiLCJkaXJlY3Rpb24iLCJsaW5rIiwiZmlsdGVyIiwidGFiTGVmdCIsInZhclN1bW1hcnkiLCJieUlkIiwic2V0QXR0cmlidXRlIiwic2VsZWN0ZWRJbmRleCIsInRyYW5zZm9ybVZhciIsInZhbHVlS2V5IiwibSIsInJlZHJhdyIsInN1YnNldCIsInNwbGl0IiwibWFwIiwiaGVpZ2h0Iiwid2lkdGgiLCJmYWtlQ2xpY2siLCJteXNwYWNlIiwiT2JqZWN0IiwidmFsdWVzIiwiYWxsUGlwZWxpbmVJbmZvIiwic2V0dXBfc3ZnIiwicGF0aDEiLCJjaXJjbGUxIiwiY29uY2F0IiwiY3RybEtleSIsImxheW91dCIsInNpemUiLCJsaW5rRGlzdGFuY2UiLCJ3aW5kb3ciXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O1FBMmRnQkEsSSxHQUFBQSxJOztBQTNkaEI7O0lBQVlDLEc7O0FBRVo7O0FBQ0E7Ozs7QUFFQSxJQUFJQyxjQUFKO0FBQ0EsSUFBSUMsUUFBUSxFQUFaO0FBQ0EsSUFB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RHBCLEVBRUtuRSxFQUZMLENBRVEsV0FGUixFQUVxQixhQUFLO0FBQ2xCO0FBQ0F4QyxXQUFHcUUsS0FBSCxDQUFTcUIsY0FBVDtBQUNBO0FBQ0FyRixZQUFJRixPQUFKLENBQVksUUFBWixFQUFzQixJQUF0QjtBQUNBLFlBQUlILEdBQUdxRSxLQUFILENBQVNpRCxPQUFULElBQW9CckosY0FBcEIsSUFBc0NELGNBQTFDLEVBQTBEO0FBQ3REO0FBQ0g7QUFDRDtBQUNILEtBWEwsRUFZS3dFLEVBWkwsQ0FZUSxTQVpSLEVBWW1CdEMsT0FabkI7O0FBY0F6QyxZQUFRdUMsR0FBR3VILE1BQUgsQ0FBVTlKLEtBQVYsR0FDSEMsS0FERyxDQUNHQSxLQURILEVBRUhDLEtBRkcsQ0FFR0EsS0FGSCxFQUdINkosSUFIRyxDQUdFLENBQUNaLEtBQUQsRUFBUUQsTUFBUixDQUhGLEVBSUhjLFlBSkcsQ0FJVSxHQUpWLEVBS0gzRixNQUxHLENBS0ksQ0FBQyxHQUxMLEVBTUhVLEVBTkcsQ0FNQSxNQU5BLEVBTVFwRSxJQU5SLENBQVI7O0FBUUE0QixPQUFHeUQsTUFBSCxDQUFVaUUsTUFBVixFQUNLbEYsRUFETCxDQUNRLE9BRFIsRUFDaUIsWUFBTTtBQUNmO0FBQ0EsNEJBQVEsWUFBUixFQUFzQixHQUF0QjtBQUNBLDRCQUFRLFdBQVIsRUFBcUIsR0FBckI7QUFDSCxLQUxMOztBQU9BbEMsWUFBUUMsSUFBUixFQUFjQyxLQUFkLEVBQXFCQyxhQUFyQixFQUFvQ0MsY0FBcEMsRUFBb0RDLEdBQXBELEVBQXlEQyxJQUF6RCxFQUErRGIsU0FBL0QsRUExQ21CLENBMEN3RDtBQUMzRThHO0FBQ0giLCJmaWxlIjoiMTUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBhcHAgZnJvbSAnLi9hcHAnO1xuaW1wb3J0IHtzZXRQZWJibGVSYWRpdXN9IGZyb20gJy4vYXBwJztcbmltcG9ydCB7YmFyc05vZGUsIGRlbnNpdHlOb2RlfSBmcm9tICcuL3Bsb3RzJztcbmltcG9ydCB7ZmFkZU91dH0gZnJvbSAnLi91dGlscyc7XG5cbmxldCBmb3JjZTtcbmxldCBub2RlcyA9IFtdO1xubGV0IGxpbmtzID0gW107XG5sZXQgY2lyY2xlLCBwYXRoO1xuXG4vLyBtb3VzZSBldmVudCB2YXJzXG5sZXQgc2VsZWN0ZWRfbm9kZSA9IG51bGwsXG4gICAgc2VsZWN0ZWRfbGluayA9IG51bGwsXG4gICAgbW91c2Vkb3duX2xpbmsgPSBudWxsLFxuICAgIG1vdXNlZG93bl9ub2RlID0gbnVsbCxcbiAgICBtb3VzZXVwX25vZGUgPSBudWxsO1xuXG5mdW5jdGlvbiByZXNldE1vdXNlVmFycygpIHtcbiAgICBtb3VzZWRvd25fbm9kZSA9IG51bGw7XG4gICAgbW91c2V1cF9ub2RlID0gbnVsbDtcbiAgICBtb3VzZWRvd25fbGluayA9IG51bGw7XG59XG5cbi8vIHVwZGF0ZSBmb3JjZSBsYXlvdXQgKGNhbGxlZCBhdXRvbWF0aWNhbGx5IGVhY2ggaXRlcmF0aW9uKVxuZnVuY3Rpb24gdGljaygpIHtcbiAgICAvLyBkcmF3IGRpcmVjdGVkIGVkZ2VzIHdpdGggcHJvcGVyIHBhZGRpbmcgZnJvbSBub2RlIGNlbnRlcnNcbiAgICBwYXRoLmF0dHIoJ2QnLCBkID0+IHtcbiAgICAgICAgdmFyIGRlbHRhWCA9IGQudGFyZ2V0LnggLSBkLnNvdXJjZS54LFxuICAgICAgICAgICAgZGVsdGFZID0gZC50YXJnZXQueSAtIGQuc291cmNlLnksXG4gICAgICAgICAgICBkaXN0ID0gTWF0aC5zcXJ0KGRlbHRhWCAqIGRlbHRhWCArIGRlbHRhWSAqIGRlbHRhWSksXG4gICAgICAgICAgICBub3JtWCA9IGRlbHRhWCAvIGRpc3QsXG4gICAgICAgICAgICBub3JtWSA9IGRlbHRhWSAvIGRpc3QsXG4gICAgICAgICAgICBzb3VyY2VQYWRkaW5nID0gZC5sZWZ0ID8gUkFESVVTICsgNSA6IFJBRElVUyxcbiAgICAgICAgICAgIHRhcmdldFBhZGRpbmcgPSBkLnJpZ2h0ID8gUkFESVVTICsgNSA6IFJBRElVUyxcbiAgICAgICAgICAgIHNvdXJjZVggPSBkLnNvdXJjZS54ICsgKHNvdXJjZVBhZGRpbmcgKiBub3JtWCksXG4gICAgICAgICAgICBzb3VyY2VZID0gZC5zb3VyY2UueSArIChzb3VyY2VQYWRkaW5nICogbm9ybVkpLFxuICAgICAgICAgICAgdGFyZ2V0WCA9IGQudGFyZ2V0LnggLSAodGFyZ2V0UGFkZGluZyAqIG5vcm1YKSxcbiAgICAgICAgICAgIHRhcmdldFkgPSBkLnRhcmdldC55IC0gKHRhcmdldFBhZGRpbmcgKiBub3JtWSk7XG4gICAgICAgIHJldHVybiBgTSR7c291cmNlWH0sJHtzb3VyY2VZfUwke3RhcmdldFh9LCR7dGFyZ2V0WX1gO1xuICAgIH0pO1xuXG4gICAgY2lyY2xlLmF0dHIoJ3RyYW5zZm9ybScsIGQgPT4gJ3RyYW5zbGF0ZSgnICsgZC54ICsgJywnICsgZC55ICsgJyknKTtcbiAgICBjaXJjbGUuc2VsZWN0QWxsKCdjaXJjbGUnKSAvLyBzaHJpbmsvZXhwYW5kIHBlYmJsZXMgdGhhdCBqb2luL2xlYXZlIGdyb3Vwc1xuICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgIC5kdXJhdGlvbigxMDApXG4gICAgICAgIC5hdHRyKCdyJywgZCA9PiBzZXRQZWJibGVSYWRpdXMoZCkpO1xufVxuXG5cbmZ1bmN0aW9uIG1vdXNlbW92ZShkKSB7XG4gICAgaWYgKCFtb3VzZWRvd25fbm9kZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIC8vIHVwZGF0ZSBkcmFnIGxpbmVcbiAgICBkcmFnX2xpbmUuYXR0cignZCcsICdNJyArIG1vdXNlZG93bl9ub2RlLnggKyAnLCcgKyBtb3VzZWRvd25fbm9kZS55ICsgJ0wnICsgZDMubW91c2UodGhpcylbMF0gKyAnLCcgKyBkMy5tb3VzZSh0aGlzKVsxXSk7XG59XG5cbmZ1bmN0aW9uIG1vdXNldXAoZCkge1xuICAgIGlmIChtb3VzZWRvd25fbm9kZSkge1xuICAgICAgICBkcmFnX2xpbmVcbiAgICAgICAgICAgIC5jbGFzc2VkKCdoaWRkZW4nLCB0cnVlKVxuICAgICAgICAgICAgLnN0eWxlKCdtYXJrZXItZW5kJywgJycpO1xuICAgIH1cbiAgICAvLyBiZWNhdXNlIDphY3RpdmUgb25seSB3b3JrcyBpbiBXZWJLaXQ/XG4gICAgc3ZnLmNsYXNzZWQoJ2FjdGl2ZScsIGZhbHNlKTtcbiAgICAvLyBjbGVhciBtb3VzZSBldmVudCB2YXJzXG4gICAgcmVzZXRNb3VzZVZhcnMoKTtcbn1cblxuLy8gdXBkYXRlIGdyYXBoIChjYWxsZWQgd2hlbiBuZWVkZWQpXG5mdW5jdGlvbiByZXN0YXJ0KGxpbmUsIGxpbmUyLCB2aXNiYWNrZ3JvdW5kLCB2aXMyYmFja2dyb3VuZCwgdmlzLCB2aXMyLCBkcmFnX2xpbmUpIHtcbiAgICBsZXQge2ZvcmNldG9nZ2xlLCBzZXRQZWJibGVDaGFyZ2UsIGssIHpwYXJhbXMsIGFyYzMsIGR2Q29sb3IsIGFyYzQsIG5vbUNvbG9yLCBhcmMxLCBncjFDb2xvciwgYXJjSW5kMSwgYXJjSW5kMiwgZ3IyQ29sb3IsIHJlY29yZF91c2VyX21ldGFkYXRhfSA9IGFwcDtcblxuICAgIC8vIG5vZGVzLmluZGV4IGlzIGZsb2F0aW5nIGFuZCBkZXBlbmRzIG9uIHVwZGF0ZXMgdG8gbm9kZXMuIGEgdmFyaWFibGVzIGluZGV4IGNoYW5nZXMgd2hlbiBuZXcgdmFyaWFibGVzIGFyZSBhZGRlZC5cbiAgICBjaXJjbGUuY2FsbChmb3JjZS5kcmFnKTtcbiAgICBpZiAoZm9yY2V0b2dnbGVbMF0gPT0gXCJ0cnVlXCIpIHtcbiAgICAgICAgZm9yY2UuZ3Jhdml0eSgwLjEpO1xuICAgICAgICBmb3JjZS5jaGFyZ2Uoc2V0UGViYmxlQ2hhcmdlKTtcbiAgICAgICAgZm9yY2Uuc3RhcnQoKTtcbiAgICAgICAgZm9yY2UubGlua1N0cmVuZ3RoKDEpO1xuICAgICAgICBrID0gNDsgLy8gc3RyZW5ndGggcGFyYW1ldGVyIGZvciBncm91cCBhdHRyYWN0aW9uL3JlcHVsc2lvblxuICAgICAgICBpZiAoKHpwYXJhbXMuemdyb3VwMS5sZW5ndGggPiAwKSAmICh6cGFyYW1zLnpncm91cDIubGVuZ3RoID4gMCApKSB7IC8vIHNjYWxlIGRvd24gYnkgbnVtYmVyIG9mIGFjdGl2ZSBncm91cHNcbiAgICAgICAgICAgIGsgPSAyLjU7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3JjZS5ncmF2aXR5KDApO1xuICAgICAgICBmb3JjZS5jaGFyZ2UoMCk7XG4gICAgICAgIGZvcmNlLmxpbmtTdHJlbmd0aCgwKTtcbiAgICAgICAgayA9IDA7XG4gICAgfVxuICAgIGZvcmNlLnJlc3VtZSgpO1xuXG4gICAgLy8gcGF0aCAobGluaykgZ3JvdXBcbiAgICBwYXRoID0gcGF0aC5kYXRhKGxpbmtzKTtcblxuICAgIC8vIHVwZGF0ZSBleGlzdGluZyBsaW5rc1xuICAgIC8vIFZKRDogZGFzaGVkIGxpbmtzIGJldHdlZW4gcGViYmxlcyBhcmUgXCJzZWxlY3RlZFwiLiB0aGlzIGlzIGRpc2FibGVkIGZvciBub3dcbiAgICBwYXRoLmNsYXNzZWQoJ3NlbGVjdGVkJywgeCA9PiBudWxsKVxuICAgICAgICAuc3R5bGUoJ21hcmtlci1zdGFydCcsIHggPT4gJycpXG4gICAgICAgIC5zdHlsZSgnbWFya2VyLWVuZCcsIHggPT4gJycpO1xuXG4gICAgLy8gYWRkIG5ldyBsaW5rc1xuICAgIHBhdGguZW50ZXIoKS5hcHBlbmQoJ3N2ZzpwYXRoJylcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2xpbmsnKVxuICAgICAgICAuY2xhc3NlZCgnc2VsZWN0ZWQnLCB4ID0+IG51bGwpXG4gICAgICAgIC5zdHlsZSgnbWFya2VyLXN0YXJ0JywgeCA9PiAnJylcbiAgICAgICAgLnN0eWxlKCdtYXJrZXItZW5kJywgeCA9PiAnJylcbiAgICAgICAgLm9uKCdtb3VzZWRvd24nLCBkID0+IHsgLy8gZG8gd2UgZXZlciBuZWVkIHRvIHNlbGVjdCBhIGxpbms/IG1ha2UgaXQgZGVsZXRlLi5cbiAgICAgICAgICAgIHZhciBvYmogPSBKU09OLnN0cmluZ2lmeShkKTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGlua3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAob2JqID09PSBKU09OLnN0cmluZ2lmeShsaW5rc1tqXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsKGxpbmtzLCBqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgLy8gcmVtb3ZlIG9sZCBsaW5rc1xuICAgIHBhdGguZXhpdCgpLnJlbW92ZSgpO1xuXG4gICAgLy8gY2lyY2xlIChub2RlKSBncm91cFxuICAgIGNpcmNsZSA9IGNpcmNsZS5kYXRhKG5vZGVzLCB4ID0+IHguaWQpO1xuXG4gICAgLy8gdXBkYXRlIGV4aXN0aW5nIG5vZGVzIChyZWZsZXhpdmUgJiBzZWxlY3RlZCB2aXN1YWwgc3RhdGVzKVxuICAgIC8vIGQzLnJnYiBpcyB0aGUgZnVuY3Rpb24gYWRqdXN0aW5nIHRoZSBjb2xvciBoZXJlXG4gICAgY2lyY2xlLnNlbGVjdEFsbCgnY2lyY2xlJylcbiAgICAgICAgLmNsYXNzZWQoJ3JlZmxleGl2ZScsIHggPT4geC5yZWZsZXhpdmUpXG4gICAgICAgIC5zdHlsZSgnZmlsbCcsIHggPT4gZDMucmdiKHgubm9kZUNvbCkpXG4gICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgeCA9PiBkMy5yZ2IoeC5zdHJva2VDb2xvcikpXG4gICAgICAgIC5zdHlsZSgnc3Ryb2tlLXdpZHRoJywgeCA9PiB4LnN0cm9rZVdpZHRoKTtcblxuICAgIC8vIGFkZCBuZXcgbm9kZXNcbiAgICBsZXQgZyA9IGNpcmNsZS5lbnRlcigpXG4gICAgICAgIC5hcHBlbmQoJ3N2ZzpnJylcbiAgICAgICAgLmF0dHIoJ2lkJywgeCA9PiB4Lm5hbWUgKyAnYmlnZ3JvdXAnKTtcblxuICAgIC8vIGFkZCBwbG90XG4gICAgZy5lYWNoKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgZDMuc2VsZWN0KHRoaXMpO1xuICAgICAgICBpZiAoZC5wbG90dHlwZSA9PSAnY29udGludW91cycpIGRlbnNpdHlOb2RlKGQsIHRoaXMpO1xuICAgICAgICBlbHNlIGlmIChkLnBsb3R0eXBlID09ICdiYXInKSBiYXJzTm9kZShkLCB0aGlzKTtcbiAgICB9KTtcblxuICAgIGxldCBhcHBlbmQgPSAoc3RyLCBhdHRyKSA9PiB4ID0+IHN0ciArIHhbYXR0ciB8fCAnaWQnXTtcblxuICAgIGcuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAuYXR0cihcImlkXCIsIGFwcGVuZCgnZHZBcmMnKSlcbiAgICAgICAgLmF0dHIoXCJkXCIsIGFyYzMpXG4gICAgICAgIC5zdHlsZShcImZpbGxcIiwgZHZDb2xvcilcbiAgICAgICAgLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgMClcbiAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICBmaWxsVGhpcyh0aGlzLCAuMywgMCwgMTAwKTtcbiAgICAgICAgICAgIGZpbGwoZCwgJ2R2VGV4dCcsIC45LCAwLCAxMDApO1xuICAgICAgICB9KVxuICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgZmlsbFRoaXModGhpcywgMCwgMTAwLCA1MDApO1xuICAgICAgICAgICAgZmlsbChkLCAnZHZUZXh0JywgMCwgMTAwLCA1MDApO1xuICAgICAgICB9KVxuICAgICAgICAub24oJ2NsaWNrJywgZCA9PiB7XG4gICAgICAgICAgICBzZXRDb2xvcnMoZCwgZHZDb2xvcik7XG4gICAgICAgICAgICBsZWdlbmQoZHZDb2xvcik7XG4gICAgICAgICAgICAvL3Jlc3RhcnQoKTtcbiAgICAgICAgICAgIGQuZ3JvdXAxID0gZC5ncm91cDIgPSBmYWxzZTtcbiAgICAgICAgfSk7XG5cbiAgICBnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgLmF0dHIoXCJpZFwiLCBhcHBlbmQoJ2R2VGV4dCcpKVxuICAgICAgICAuYXR0cihcInhcIiwgNilcbiAgICAgICAgLmF0dHIoXCJkeVwiLCAxMS41KVxuICAgICAgICAuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAwKVxuICAgICAgICAuYXBwZW5kKFwidGV4dFBhdGhcIilcbiAgICAgICAgLmF0dHIoXCJ4bGluazpocmVmXCIsIGFwcGVuZCgnI2R2QXJjJykpXG4gICAgICAgIC50ZXh0KFwiRGVwIFZhclwiKTtcblxuICAgIGcuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAuYXR0cihcImlkXCIsIGFwcGVuZCgnbm9tQXJjJykpXG4gICAgICAgIC5hdHRyKFwiZFwiLCBhcmM0KVxuICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIG5vbUNvbG9yKVxuICAgICAgICAuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAwKVxuICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIGlmIChkLmRlZmF1bHROdW1jaGFyID09IFwiY2hhcmFjdGVyXCIpIHJldHVybjtcbiAgICAgICAgICAgIGZpbGxUaGlzKHRoaXMsIC4zLCAwLCAxMDApO1xuICAgICAgICAgICAgZmlsbChkLCBcIm5vbVRleHRcIiwgLjksIDAsIDEwMCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICBpZiAoZC5kZWZhdWx0TnVtY2hhciA9PSBcImNoYXJhY3RlclwiKSByZXR1cm47XG4gICAgICAgICAgICBmaWxsVGhpcyh0aGlzLCAwLCAxMDAsIDUwMCk7XG4gICAgICAgICAgICBmaWxsKGQsIFwibm9tVGV4dFwiLCAwLCAxMDAsIDUwMCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignY2xpY2snLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICBpZiAoZC5kZWZhdWx0TnVtY2hhciA9PSBcImNoYXJhY3RlclwiKSByZXR1cm47XG4gICAgICAgICAgICBzZXRDb2xvcnMoZCwgbm9tQ29sb3IpO1xuICAgICAgICAgICAgbGVnZW5kKG5vbUNvbG9yKTtcbiAgICAgICAgICAgIC8vcmVzdGFydCgpO1xuICAgICAgICB9KTtcblxuICAgIGcuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAuYXR0cihcImlkXCIsIGFwcGVuZChcIm5vbVRleHRcIikpXG4gICAgICAgIC5hdHRyKFwieFwiLCA2KVxuICAgICAgICAuYXR0cihcImR5XCIsIDExLjUpXG4gICAgICAgIC5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIDApXG4gICAgICAgIC5hcHBlbmQoXCJ0ZXh0UGF0aFwiKVxuICAgICAgICAuYXR0cihcInhsaW5rOmhyZWZcIiwgYXBwZW5kKFwiI25vbUFyY1wiKSlcbiAgICAgICAgLnRleHQoXCJOb21pbmFsXCIpO1xuXG4gICAgZy5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgIC5hdHRyKFwiaWRcIiwgYXBwZW5kKCdnckFyYycpKVxuICAgICAgICAuYXR0cihcImRcIiwgYXJjMSlcbiAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCAgZ3IxQ29sb3IpXG4gICAgICAgIC5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIDApXG4gICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgZmlsbChkLCBcImdyMWluZGljYXRvclwiLCAuMywgMCwgMTAwKTtcbiAgICAgICAgICAgIGZpbGwoZCwgXCJncjJpbmRpY2F0b3JcIiwgLjMsIDAsIDEwMCk7XG4gICAgICAgICAgICBmaWxsVGhpcyh0aGlzLCAuMywgMCwgMTAwKTtcbiAgICAgICAgICAgIGZpbGwoZCwgJ2dyVGV4dCcsIC45LCAwLCAxMDApO1xuICAgICAgICB9KVxuICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgZmlsbChkLCBcImdyMWluZGljYXRvclwiLCAwLCAxMDAsIDUwMCk7XG4gICAgICAgICAgICBmaWxsKGQsIFwiZ3IyaW5kaWNhdG9yXCIsIDAsIDEwMCwgNTAwKTtcbiAgICAgICAgICAgIGZpbGxUaGlzKHRoaXMsIDAsIDEwMCwgNTAwKTtcbiAgICAgICAgICAgIGZpbGwoZCwgJ2dyVGV4dCcsIDAsIDEwMCwgNTAwKTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdjbGljaycsIGQgPT4ge1xuICAgICAgICAgICAgLy9kLmdyb3VwMSA9ICFkLmdyb3VwMTsgICAgICAvLyBUaGlzIG1pZ2h0IGJlIGVhc2llciwgYnV0IGN1cnJlbnRseSBzZXQgaW4gc2V0Q29sb3JzKClcbiAgICAgICAgICAgIHNldENvbG9ycyhkLCBncjFDb2xvcik7XG4gICAgICAgICAgICBsZWdlbmQoZ3IxQ29sb3IpO1xuICAgICAgICAgICAgLy9yZXN0YXJ0KCk7XG4gICAgICAgIH0pO1xuXG4gICAgZy5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgIC5hdHRyKFwiaWRcIiwgYXBwZW5kKCdncjFpbmRpY2F0b3InKSlcbiAgICAgICAgLmF0dHIoXCJkXCIsIGFyY0luZDEpXG4gICAgICAgIC5zdHlsZShcImZpbGxcIiwgZ3IxQ29sb3IpICAvLyBzb21ldGhpbmcgbGlrZTogenBhcmFtcy56Z3JvdXAxLmluZGV4T2Yobm9kZS5uYW1lKSA+IC0xICA/ICAjRkZGRkZGIDogZ3IxQ29sb3IpXG4gICAgICAgIC5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIDApXG4gICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgZmlsbFRoaXModGhpcywgLjMsIDAsIDEwMCk7XG4gICAgICAgICAgICBmaWxsKGQsIFwiZ3JBcmNcIiwgLjEsIDAsIDEwMCk7XG4gICAgICAgICAgICBmaWxsKGQsICdnclRleHQnLCAuOSwgMCwgMTAwKTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIGZpbGxUaGlzKHRoaXMsIDAsIDEwMCwgNTAwKTtcbiAgICAgICAgICAgIGZpbGwoZCwgXCJnckFyY1wiLCAwLCAxMDAsIDUwMCk7XG4gICAgICAgICAgICBmaWxsKGQsICdnclRleHQnLCAwLCAxMDAsIDUwMCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignY2xpY2snLCBkID0+IHtcbiAgICAgICAgICAgIC8vZC5ncm91cDEgPSAhZC5ncm91cDE7ICAgICAgLy8gVGhpcyBtaWdodCBiZSBlYXNpZXIsIGJ1dCBjdXJyZW50bHkgc2V0IGluIHNldENvbG9ycygpXG4gICAgICAgICAgICBzZXRDb2xvcnMoZCwgZ3IxQ29sb3IpO1xuICAgICAgICAgICAgbGVnZW5kKGdyMUNvbG9yKTtcbiAgICAgICAgICAgIC8vcmVzdGFydCgpO1xuICAgICAgICB9KTtcblxuICAgIGcuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAuYXR0cihcImlkXCIsIGFwcGVuZCgnZ3IyaW5kaWNhdG9yJykpXG4gICAgICAgIC5hdHRyKFwiZFwiLCBhcmNJbmQyKVxuICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGdyMkNvbG9yKSAgLy8gc29tZXRoaW5nIGxpa2U6IHpwYXJhbXMuemdyb3VwMS5pbmRleE9mKG5vZGUubmFtZSkgPiAtMSAgPyAgI0ZGRkZGRiA6IGdyMUNvbG9yKVxuICAgICAgICAuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAwKVxuICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIGZpbGxUaGlzKHRoaXMsIC4zLCAwLCAxMDApO1xuICAgICAgICAgICAgZmlsbChkLCBcImdyQXJjXCIsIC4xLCAwLCAxMDApO1xuICAgICAgICAgICAgZmlsbChkLCAnZ3JUZXh0JywgLjksIDAsIDEwMCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICBmaWxsVGhpcyh0aGlzLCAwLCAxMDAsIDUwMCk7XG4gICAgICAgICAgICBmaWxsKGQsIFwiZ3JBcmNcIiwgMCwgMTAwLCA1MDApO1xuICAgICAgICAgICAgZmlsbChkLCAnZ3JUZXh0JywgMCwgMTAwLCA1MDApO1xuICAgICAgICB9KVxuICAgICAgICAub24oJ2NsaWNrJywgZCA9PiB7XG4gICAgICAgICAgICAvL2QuZ3JvdXAyID0gIWQuZ3JvdXAyOyAgICAgIC8vIFRoaXMgbWlnaHQgYmUgZWFzaWVyLCBidXQgY3VycmVudGx5IHNldCBpbiBzZXRDb2xvcnMoKVxuICAgICAgICAgICAgc2V0Q29sb3JzKGQsIGdyMkNvbG9yKTtcbiAgICAgICAgICAgIGxlZ2VuZChncjJDb2xvcik7XG4gICAgICAgICAgICAvL3Jlc3RhcnQoKTtcbiAgICAgICAgfSk7XG5cbiAgICBnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgLmF0dHIoXCJpZFwiLCBhcHBlbmQoJ2dyVGV4dCcpKVxuICAgICAgICAuYXR0cihcInhcIiwgNilcbiAgICAgICAgLmF0dHIoXCJkeVwiLCAxMS41KVxuICAgICAgICAuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAwKVxuICAgICAgICAuYXBwZW5kKFwidGV4dFBhdGhcIilcbiAgICAgICAgLmF0dHIoXCJ4bGluazpocmVmXCIsIGFwcGVuZCgnI2dyQXJjJykpXG4gICAgICAgIC50ZXh0KFwiR3JvdXBzXCIpO1xuXG4gICAgZy5hcHBlbmQoJ3N2ZzpjaXJjbGUnKVxuICAgICAgICAuYXR0cignY2xhc3MnLCAnbm9kZScpXG4gICAgICAgIC5hdHRyKCdyJywgZCA9PiBzZXRQZWJibGVSYWRpdXMoZCkpXG4gICAgICAgIC5zdHlsZSgncG9pbnRlci1ldmVudHMnLCAnaW5oZXJpdCcpXG4gICAgICAgIC5zdHlsZSgnZmlsbCcsIGQgPT4gZC5ub2RlQ29sKVxuICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCBcIjAuNVwiKVxuICAgICAgICAuc3R5bGUoJ3N0cm9rZScsIGQgPT4gZDMucmdiKGQuc3Ryb2tlQ29sb3IpLnRvU3RyaW5nKCkpXG4gICAgICAgIC5jbGFzc2VkKCdyZWZsZXhpdmUnLCBkID0+IGQucmVmbGV4aXZlKVxuICAgICAgICAub24oJ2RibGNsaWNrJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgZDMuZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7IC8vIHN0b3AgY2xpY2sgZnJvbSBidWJibGluZ1xuICAgICAgICAgICAgc3VtbWFyeUhvbGQgPSB0cnVlO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJwZWJibGVcIik7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhkLmdyb3VwMik7XG4gICAgICAgICAgICBpZihkLmdyb3VwMSl7XG4gICAgICAgICAgICAgICAgdmFyIGxlbiA9IG5vZGVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB2YXIgaG9sZCA9IFsuNiwgLjIsIC45LCAuOCwgLjEsIC4zLCAuNF07XG4gICAgICAgICAgICAgICAgZm9yKHZhciBwID0gMDsgcCA8IGQucHJvcGVydGllcy5sZW5ndGg7cCsrKXtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9iaiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBsZW4gKyBwLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmbGV4aXZlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGQucHJvcGVydGllc1twXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmw6IFwibm8gbGFiZWxzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBbNSwgMTUsIDIwLCAwLCA1LCAxNSwgMjBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgY291bnQ6IGhvbGQsXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlQ29sOiBjb2xvcnMocCksXG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlQ29sOiBjb2xvcnMocCksXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VDb2xvcjogc2VsVmFyQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogXCIxXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzZXRwbG90OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNldHJhbmdlOiBbXCJcIiwgXCJcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR4cGxvdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR4dmFsczogW1wiXCIsIFwiXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JheW91dDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cDE6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXAyOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yZWZyb250OiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIm9iaiBhZnRlciBtZXJnZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMucHVzaChvYmopO1xuICAgICAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKG9iaik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKG5vZGVzKTtcbiAgICAgICAgICAgICAgICAgICAgbGlua3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IG5vZGVzW2QuaWQtMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IG5vZGVzW25vZGVzLmxlbmd0aC0xXSwgLy8gbm90IGFibGUgdG8gYWNjZXNzIHdpdGggb2JqZWN0IGlkISFcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvL19yZXN0YXJ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignY29udGV4dG1lbnUnLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAvLyByaWdodCBjbGljayBvbiBub2RlXG4gICAgICAgICAgICBkMy5ldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZDMuZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgICAgIHJpZ2h0Q2xpY2tMYXN0ID0gdHJ1ZTtcbiAgICAgICAgICAgIG1vdXNlZG93bl9ub2RlID0gZDtcbiAgICAgICAgICAgIHNlbGVjdGVkX25vZGUgPSBtb3VzZWRvd25fbm9kZSA9PT0gc2VsZWN0ZWRfbm9kZSA/IG51bGwgOiBtb3VzZWRvd25fbm9kZTtcbiAgICAgICAgICAgIHNlbGVjdGVkX2xpbmsgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyByZXBvc2l0aW9uIGRyYWcgbGluZVxuICAgICAgICAgICAgZHJhZ19saW5lXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdtYXJrZXItZW5kJywgJ3VybCgjZW5kLWFycm93KScpXG4gICAgICAgICAgICAgICAgLmNsYXNzZWQoJ2hpZGRlbicsIGZhbHNlKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdkJywgJ00nICsgbW91c2Vkb3duX25vZGUueCArICcsJyArIG1vdXNlZG93bl9ub2RlLnkgKyAnTCcgKyBtb3VzZWRvd25fbm9kZS54ICsgJywnICsgbW91c2Vkb3duX25vZGUueSk7XG5cbiAgICAgICAgICAgIHN2Zy5vbignbW91c2Vtb3ZlJywgbW91c2Vtb3ZlKTtcbiAgICAgICAgICAgIC8vcmVzdGFydCgpO1xuICAgICAgICB9KVxuICAgICAgICAub24oJ21vdXNldXAnLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICBkMy5ldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAgICAgaWYgKHJpZ2h0Q2xpY2tMYXN0KSB7XG4gICAgICAgICAgICAgICAgcmlnaHRDbGlja0xhc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW1vdXNlZG93bl9ub2RlKSByZXR1cm47XG5cbiAgICAgICAgICAgIC8vIG5lZWRlZCBieSBGRlxuICAgICAgICAgICAgZHJhZ19saW5lXG4gICAgICAgICAgICAgICAgLmNsYXNzZWQoJ2hpZGRlbicsIHRydWUpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdtYXJrZXItZW5kJywgJycpO1xuXG4gICAgICAgICAgICAvLyBjaGVjayBmb3IgZHJhZy10by1zZWxmXG4gICAgICAgICAgICBtb3VzZXVwX25vZGUgPSBkO1xuICAgICAgICAgICAgaWYgKG1vdXNldXBfbm9kZSA9PT0gbW91c2Vkb3duX25vZGUpIHtcbiAgICAgICAgICAgICAgICByZXNldE1vdXNlVmFycygpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdW5lbmxhcmdlIHRhcmdldCBub2RlXG4gICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuYXR0cigndHJhbnNmb3JtJywgJycpO1xuXG4gICAgICAgICAgICAvLyBhZGQgbGluayB0byBncmFwaCAodXBkYXRlIGlmIGV4aXN0cylcbiAgICAgICAgICAgIC8vIE5COiBsaW5rcyBhcmUgc3RyaWN0bHkgc291cmNlIDwgdGFyZ2V0OyBhcnJvd3Mgc2VwYXJhdGVseSBzcGVjaWZpZWQgYnkgYm9vbGVhbnNcbiAgICAgICAgICAgIHZhciBzb3VyY2UsIHRhcmdldCwgZGlyZWN0aW9uO1xuICAgICAgICAgICAgaWYgKG1vdXNlZG93bl9ub2RlLmlkIDwgbW91c2V1cF9ub2RlLmlkKSB7XG4gICAgICAgICAgICAgICAgc291cmNlID0gbW91c2Vkb3duX25vZGU7XG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gbW91c2V1cF9ub2RlO1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9ICdyaWdodCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNvdXJjZSA9IG1vdXNldXBfbm9kZTtcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSBtb3VzZWRvd25fbm9kZTtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSAnbGVmdCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBsaW5rID0gbGlua3MuZmlsdGVyKHggPT4geC5zb3VyY2UgPT0gc291cmNlICYmIHgudGFyZ2V0ID09IHRhcmdldClbMF07XG4gICAgICAgICAgICBpZiAobGluaykge1xuICAgICAgICAgICAgICAgIGxpbmtbZGlyZWN0aW9uXSA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxpbmsgPSB7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBmYWxzZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgbGlua1tkaXJlY3Rpb25dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBsaW5rcy5wdXNoKGxpbmspO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzZWxlY3QgbmV3IGxpbmtcbiAgICAgICAgICAgIHNlbGVjdGVkX2xpbmsgPSBsaW5rO1xuICAgICAgICAgICAgc2VsZWN0ZWRfbm9kZSA9IG51bGw7XG4gICAgICAgICAgICBzdmcub24oJ21vdXNlbW92ZScsIG51bGwpO1xuXG4gICAgICAgICAgICByZXNldE1vdXNlVmFycygpO1xuICAgICAgICAgICAgLy9yZXN0YXJ0KCk7XG4gICAgICAgIH0pO1xuXG4gICAgLy8gc2hvdyBub2RlIG5hbWVzXG4gICAgZy5hcHBlbmQoJ3N2Zzp0ZXh0JylcbiAgICAgICAgLmF0dHIoJ3gnLCAwKVxuICAgICAgICAuYXR0cigneScsIDE1KVxuICAgICAgICAuYXR0cignY2xhc3MnLCAnaWQnKVxuICAgICAgICAudGV4dChkID0+IGQubmFtZSk7XG5cbiAgICAvLyBzaG93IHN1bW1hcnkgc3RhdHMgb24gbW91c2VvdmVyXG4gICAgLy8gU1ZHIGRvZXNuJ3Qgc3VwcG9ydCB0ZXh0IHdyYXBwaW5nLCB1c2UgaHRtbCBpbnN0ZWFkXG4gICAgZy5zZWxlY3RBbGwoXCJjaXJjbGUubm9kZVwiKVxuICAgICAgICAub24oXCJtb3VzZW92ZXJcIiwgZCA9PiB7XG4gICAgICAgICAgICB0YWJMZWZ0KCd0YWIzJyk7XG4gICAgICAgICAgICB2YXJTdW1tYXJ5KGQpO1xuICAgICAgICAgICAgZC5mb3JlZnJvbnQgPSB0cnVlO1xuXG4gICAgICAgICAgICBieUlkKCd0cmFuc2Zvcm1hdGlvbnMnKS5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2Rpc3BsYXk6YmxvY2snKTtcbiAgICAgICAgICAgIGJ5SWQoXCJ0cmFuc1NlbFwiKS5zZWxlY3RlZEluZGV4ID0gZC5pZDtcbiAgICAgICAgICAgIHRyYW5zZm9ybVZhciA9IHZhbHVlS2V5W2QuaWRdO1xuXG4gICAgICAgICAgICBmaWxsKGQsIFwiZHZBcmNcIiwgLjEsIDAsIDEwMCk7XG4gICAgICAgICAgICBmaWxsKGQsIFwiZHZUZXh0XCIsIC41LCAwLCAxMDApO1xuICAgICAgICAgICAgZmlsbChkLCBcImdyQXJjXCIsIC4xLCAwLCAxMDApO1xuICAgICAgICAgICAgZmlsbChkLCBcImdyVGV4dFwiLCAuNSwgMCwgMTAwKTtcblxuICAgICAgICAgICAgaWYgKGQuZGVmYXVsdE51bWNoYXIgPT0gXCJudW1lcmljXCIpIHtcbiAgICAgICAgICAgICAgICBmaWxsKGQsIFwibm9tQXJjXCIsIC4xLCAwLCAxMDApO1xuICAgICAgICAgICAgICAgIGZpbGwoZCwgXCJub21UZXh0XCIsIC41LCAwLCAxMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlsbChkLCBcImNzQXJjXCIsIC4xLCAwLCAxMDApO1xuICAgICAgICAgICAgZmlsbChkLCBcImNzVGV4dFwiLCAuNSwgMCwgMTAwKTtcbiAgICAgICAgICAgIGZpbGwoZCwgXCJ0aW1lQXJjXCIsIC4xLCAwLCAxMDApO1xuICAgICAgICAgICAgZmlsbChkLCBcInRpbWVUZXh0XCIsIC41LCAwLCAxMDApO1xuXG4gICAgICAgICAgICBtLnJlZHJhdygpO1xuICAgICAgICB9KVxuICAgICAgICAub24oJ21vdXNlb3V0JywgZCA9PiB7XG4gICAgICAgICAgICBkLmZvcmVmcm9udCA9IGZhbHNlO1xuICAgICAgICAgICAgc3VtbWFyeUhvbGQgfHwgdGFiTGVmdChzdWJzZXQgPyAndGFiMicgOiAndGFiMScpO1xuICAgICAgICAgICAgJ2NzQXJjIGNzVGV4dCB0aW1lQXJjIHRpbWVUZXh0IGR2QXJjIGR2VGV4dCBub21BcmMgbm9tVGV4dCBnckFyYyBnclRleHQnLnNwbGl0KCcgJykubWFwKHggPT4gZmlsbChkLCB4LCAwLCAxMDAsIDUwMCkpO1xuICAgICAgICAgICAgbS5yZWRyYXcoKTtcbiAgICAgICAgfSk7XG5cbiAgICAvLyB0aGUgdHJhbnNmb3JtYXRpb24gdmFyaWFibGUgbGlzdCBpcyBzaWxlbnRseSB1cGRhdGVkIGFzIHBlYmJsZXMgYXJlIGFkZGVkL3JlbW92ZWRcbiAgICBkMy5zZWxlY3QoXCIjdHJhbnNTZWxcIilcbiAgICAgICAgLnNlbGVjdEFsbCgnbGknKVxuICAgICAgICAucmVtb3ZlKCk7XG5cbiAgICBkMy5zZWxlY3QoXCIjdHJhbnNTZWxcIilcbiAgICAgICAgLnNlbGVjdEFsbCgnbGknKVxuICAgICAgICAuZGF0YShub2Rlcy5tYXAoeCA9PiB4Lm5hbWUpKSAvLyBzZXQgdG8gdmFyaWFibGVzIGluIG1vZGVsIHNwYWNlIGFzIHRoZXkncmUgYWRkZWRcbiAgICAgICAgLmVudGVyKClcbiAgICAgICAgLmFwcGVuZChcImxpXCIpXG4gICAgICAgIC50ZXh0KGQgPT4gZCk7XG5cbiAgICAvLyByZW1vdmUgb2xkIG5vZGVzXG4gICAgY2lyY2xlLmV4aXQoKS5yZW1vdmUoKTtcbiAgICBmb3JjZS5zdGFydCgpO1xuXG4gICAgLy8gc2F2ZSB3b3Jrc3BhY2VzXG4gICAgY29uc29sZS5sb2coJ29rIHdzJyk7XG4gICAgcmVjb3JkX3VzZXJfbWV0YWRhdGEoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgbGV0IHtncjFDb2xvciwgZ3IyQ29sb3IsIFJBRElVUywgaGVpZ2h0LCB3aWR0aCwgZmFrZUNsaWNrLCBteXNwYWNlfSA9IGFwcDtcblxuICAgIG5vZGVzID0gT2JqZWN0LnZhbHVlcyhhcHAuYWxsUGlwZWxpbmVJbmZvKTtcblxuICAgIC8vIGFwcCBzdGFydHMgaGVyZVxuICAgIGxldCBzdmcgPSBkMy5zZWxlY3QoJyN3aGl0ZXNwYWNlMCcpO1xuICAgIHN2Zy5zZWxlY3RBbGwoJyonKS5yZW1vdmUoKTtcblxuICAgIGxldCBbbGluZSwgbGluZTIsIHZpc2JhY2tncm91bmQsIHZpczJiYWNrZ3JvdW5kLCB2aXMsIHZpczIsIGRyYWdfbGluZSwgcGF0aDEsIGNpcmNsZTFdID0gYXBwLnNldHVwX3N2ZyhzdmcpO1xuICAgIHBhdGggPSBwYXRoMTtcbiAgICBjaXJjbGUgPSBjaXJjbGUxO1xuXG4gICAgc3ZnLmF0dHIoJ2lkJywgKCkgPT4gXCJ3aGl0ZXNwYWNlXCIuY29uY2F0KG15c3BhY2UpKVxuICAgICAgICAuYXR0cignaGVpZ2h0JywgaGVpZ2h0KVxuICAgICAgICAub24oJ21vdXNlZG93bicsIGQgPT4ge1xuICAgICAgICAgICAgLy8gcHJldmVudCBJLWJhciBvbiBkcmFnXG4gICAgICAgICAgICBkMy5ldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgLy8gYmVjYXVzZSA6YWN0aXZlIG9ubHkgd29ya3MgaW4gV2ViS2l0P1xuICAgICAgICAgICAgc3ZnLmNsYXNzZWQoJ2FjdGl2ZScsIHRydWUpO1xuICAgICAgICAgICAgaWYgKGQzLmV2ZW50LmN0cmxLZXkgfHwgbW91c2Vkb3duX25vZGUgfHwgbW91c2Vkb3duX2xpbmspIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL3Jlc3RhcnQoKTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdtb3VzZXVwJywgbW91c2V1cCk7XG5cbiAgICBmb3JjZSA9IGQzLmxheW91dC5mb3JjZSgpXG4gICAgICAgIC5ub2Rlcyhub2RlcylcbiAgICAgICAgLmxpbmtzKGxpbmtzKVxuICAgICAgICAuc2l6ZShbd2lkdGgsIGhlaWdodF0pXG4gICAgICAgIC5saW5rRGlzdGFuY2UoMTUwKVxuICAgICAgICAuY2hhcmdlKC04MDApXG4gICAgICAgIC5vbigndGljaycsIHRpY2spO1xuXG4gICAgZDMuc2VsZWN0KHdpbmRvdylcbiAgICAgICAgLm9uKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICAgIC8vIGFsbCBjbGlja3Mgd2lsbCBidWJibGUgaGVyZSB1bmxlc3MgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgICAgICAgIGZhZGVPdXQoJyN0cmFuc0xpc3QnLCAxMDApO1xuICAgICAgICAgICAgZmFkZU91dCgnI3RyYW5zU2VsJywgMTAwKTtcbiAgICAgICAgfSk7XG5cbiAgICByZXN0YXJ0KGxpbmUsIGxpbmUyLCB2aXNiYWNrZ3JvdW5kLCB2aXMyYmFja2dyb3VuZCwgdmlzLCB2aXMyLCBkcmFnX2xpbmUpOyAvLyBpbml0aWFsaXplcyBmb3JjZS5sYXlvdXQoKVxuICAgIGZha2VDbGljaygpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYXNzZXRzL2FwcC9sYXlvdXQuanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///15\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.leftpanel = leftpanel;\n\nvar _mithril = __webpack_require__(0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _Panel = __webpack_require__(29);\n\nvar _Panel2 = _interopRequireDefault(_Panel);\n\nvar _PanelButton = __webpack_require__(6);\n\nvar _PanelButton2 = _interopRequireDefault(_PanelButton);\n\nvar _Dropdown = __webpack_require__(31);\n\nvar _Dropdown2 = _interopRequireDefault(_Dropdown);\n\nvar _PanelList = __webpack_require__(7);\n\nvar _PanelList2 = _interopRequireDefault(_PanelList);\n\nvar _Search = __webpack_require__(5);\n\nvar _Search2 = _interopRequireDefault(_Search);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction leftpanel(pipelines) {\n    return (0, _mithril2.default)(_Panel2.default, {\n        side: 'left',\n        title: 'Data Selection'\n    }, (0, _mithril2.default)('#tab1[style=display: ' + (0, _PanelButton.when)('left', 'tab1') + '; padding: 0 8px; text-align: center]', [(0, _mithril2.default)(_Dropdown2.default, { style: 'margin-bottom: 0.5em; width: 100%', items: ['Problem 1'] }), (0, _mithril2.default)(_PanelList2.default, { items: pipelines, title: 'Info', content: function content(x) {\n            return x;\n        }, onclick: function onclick(el) {\n            return console.log(el.target.id);\n        } })]));\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvYXBwL3Jlc3VsdHMuanM/MGNmOCJdLCJuYW1lcyI6WyJsZWZ0cGFuZWwiLCJwaXBlbGluZXMiLCJzaWRlIiwidGl0bGUiLCJzdHlsZSIsIml0ZW1zIiwiY29udGVudCIsIngiLCJvbmNsaWNrIiwiY29uc29sZSIsImxvZyIsImVsIiwidGFyZ2V0IiwiaWQiXSwibWFwcGluZ3MiOiI7Ozs7O1FBUWdCQSxTLEdBQUFBLFM7O0FBUmhCOzs7O0FBRUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBRU8sU0FBU0EsU0FBVCxDQUFtQkMsU0FBbkIsRUFBOEI7QUFDakMsV0FBTyx3Q0FBUztBQUNaQyxjQUFNLE1BRE07QUFFWkMsZUFBTztBQUZLLEtBQVQsRUFHSixpREFBMEIsdUJBQUssTUFBTCxFQUFhLE1BQWIsQ0FBMUIsNENBQXVGLENBQ3RGLDJDQUFZLEVBQUNDLE9BQU8sbUNBQVIsRUFBNkNDLE9BQU8sQ0FBQyxXQUFELENBQXBELEVBQVosQ0FEc0YsRUFFdEYsNENBQVEsRUFBQ0EsT0FBT0osU0FBUixFQUFtQkUsT0FBTyxNQUExQixFQUFrQ0csU0FBUztBQUFBLG1CQUFLQyxDQUFMO0FBQUEsU0FBM0MsRUFBbURDLFNBQVM7QUFBQSxtQkFBTUMsUUFBUUMsR0FBUixDQUFZQyxHQUFHQyxNQUFILENBQVVDLEVBQXRCLENBQU47QUFBQSxTQUE1RCxFQUFSLENBRnNGLENBQXZGLENBSEksQ0FBUDtBQU9IIiwiZmlsZSI6IjE2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCc7XG5cbmltcG9ydCBQYW5lbCBmcm9tICcuL3ZpZXdzL1BhbmVsJztcbmltcG9ydCBCdXR0b24sIHt3aGVufSBmcm9tICcuL3ZpZXdzL1BhbmVsQnV0dG9uJztcbmltcG9ydCBEcm9wZG93biBmcm9tICcuLi9jb21tb24vYXBwL3ZpZXdzL0Ryb3Bkb3duJztcbmltcG9ydCBMaXN0IGZyb20gJy4vdmlld3MvUGFuZWxMaXN0JztcbmltcG9ydCBTZWFyY2ggZnJvbSAnLi92aWV3cy9TZWFyY2gnO1xuXG5leHBvcnQgZnVuY3Rpb24gbGVmdHBhbmVsKHBpcGVsaW5lcykge1xuICAgIHJldHVybiBtKFBhbmVsLCB7XG4gICAgICAgIHNpZGU6ICdsZWZ0JyxcbiAgICAgICAgdGl0bGU6ICdEYXRhIFNlbGVjdGlvbidcbiAgICB9LCBtKGAjdGFiMVtzdHlsZT1kaXNwbGF5OiAke3doZW4oJ2xlZnQnLCAndGFiMScpfTsgcGFkZGluZzogMCA4cHg7IHRleHQtYWxpZ246IGNlbnRlcl1gLCBbXG4gICAgICAgIG0oRHJvcGRvd24sIHtzdHlsZTogJ21hcmdpbi1ib3R0b206IDAuNWVtOyB3aWR0aDogMTAwJScsIGl0ZW1zOiBbJ1Byb2JsZW0gMSddfSksXG4gICAgICAgIG0oTGlzdCwge2l0ZW1zOiBwaXBlbGluZXMsIHRpdGxlOiAnSW5mbycsIGNvbnRlbnQ6IHggPT4geCwgb25jbGljazogZWwgPT4gY29uc29sZS5sb2coZWwudGFyZ2V0LmlkKX0pXG4gICAgXSkpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYXNzZXRzL2FwcC9yZXN1bHRzLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///16\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mithril = __webpack_require__(0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _app = __webpack_require__(2);\n\nvar app = _interopRequireWildcard(_app);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Subpanel = function () {\n    function Subpanel() {\n        _classCallCheck(this, Subpanel);\n    }\n\n    _createClass(Subpanel, [{\n        key: 'oninit',\n        value: function oninit(vnode) {\n            this.hide = false;\n        }\n    }, {\n        key: 'view',\n        value: function view(vnode) {\n            var _this = this;\n\n            var title = vnode.attrs.title;\n            var legend = title === 'Legend';\n            var target = 'collapse' + title;\n            var z = app.zparams;\n            var side = legend ? 'right' : 'left';\n\n            return (0, _mithril2.default)('#' + (legend ? \"legend.legendary\" : \"logdiv.logbox\") + '.panel.panel-default', {\n                style: _defineProperty({\n                    display: legend && z.ztime.length + z.zcross.length + z.zdv.length + z.znom.length || !legend && app.logArray.length > 0 ? 'block' : 'none'\n                }, side, app.panelWidth[side]) }, (0, _mithril2.default)(\".panel-heading\", (0, _mithril2.default)(\"h3.panel-title\", title, (0, _mithril2.default)('span.glyphicon.glyphicon-large.glyphicon-chevron-' + (this.hide ? 'up' : 'down') + '.pull-right[data-target=#' + target + '][data-toggle=collapse][href=#' + target + ']', {\n                style: 'cursor: pointer',\n                onclick: function onclick(_) {\n                    return _this.hide = !_this.hide;\n                } }))), (0, _mithril2.default)('#' + target + '.panel-collapse.collapse.in', (0, _mithril2.default)(\".panel-body\", !legend ? app.logArray.map(function (x) {\n                return (0, _mithril2.default)('p', x);\n            }) : vnode.attrs.buttons.map(function (x) {\n                return (0, _mithril2.default)('#' + x[0] + '.clearfix.' + (z[x[1]].length === 0 ? \"hide\" : \"show\"), (0, _mithril2.default)(\".rectColor\", (0, _mithril2.default)(\"svg[style=width: 20px; height: 20px]\", (0, _mithril2.default)(\"circle[cx=10][cy=10][fill=white][r=9][stroke=black][stroke-width=2]\"))), (0, _mithril2.default)(\".rectLabel\", x[2]));\n            }))));\n        }\n    }]);\n\n    return Subpanel;\n}();\n\nexports.default = Subpanel;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvYXBwL3ZpZXdzL1N1YnBhbmVsLmpzP2ViYWIiXSwibmFtZXMiOlsiYXBwIiwiU3VicGFuZWwiLCJ2bm9kZSIsImhpZGUiLCJ0aXRsZSIsImF0dHJzIiwibGVnZW5kIiwidGFyZ2V0IiwieiIsInpwYXJhbXMiLCJzaWRlIiwic3R5bGUiLCJkaXNwbGF5IiwienRpbWUiLCJsZW5ndGgiLCJ6Y3Jvc3MiLCJ6ZHYiLCJ6bm9tIiwibG9nQXJyYXkiLCJwYW5lbFdpZHRoIiwib25jbGljayIsIm1hcCIsIngiLCJidXR0b25zIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7O0FBRUE7O0lBQVlBLEc7Ozs7Ozs7Ozs7SUFFTkMsUTs7Ozs7OzsrQkFDS0MsSyxFQUFPO0FBQ1YsaUJBQUtDLElBQUwsR0FBWSxLQUFaO0FBQ0g7Ozs2QkFFSUQsSyxFQUFPO0FBQUE7O0FBQ1IsZ0JBQUlFLFFBQVFGLE1BQU1HLEtBQU4sQ0FBWUQsS0FBeEI7QUFDQSxnQkFBSUUsU0FBU0YsVUFBVSxRQUF2QjtBQUNBLGdCQUFJRyxTQUFTLGFBQWFILEtBQTFCO0FBQ0EsZ0JBQUlJLElBQUlSLElBQUlTLE9BQVo7QUFDQSxnQkFBSUMsT0FBT0osU0FBUyxPQUFULEdBQW1CLE1BQTlCOztBQUVBLG1CQUFPLDhCQUFNQSxTQUFTLGtCQUFULEdBQThCLGVBQXBDLDRCQUEyRTtBQUM5RUs7QUFDSUMsNkJBQVNOLFVBQVVFLEVBQUVLLEtBQUYsQ0FBUUMsTUFBUixHQUFpQk4sRUFBRU8sTUFBRixDQUFTRCxNQUExQixHQUFtQ04sRUFBRVEsR0FBRixDQUFNRixNQUF6QyxHQUFrRE4sRUFBRVMsSUFBRixDQUFPSCxNQUFuRSxJQUE2RSxDQUFDUixNQUFELElBQVdOLElBQUlrQixRQUFKLENBQWFKLE1BQWIsR0FBc0IsQ0FBOUcsR0FBa0gsT0FBbEgsR0FBNEg7QUFEekksbUJBRUtKLElBRkwsRUFFWVYsSUFBSW1CLFVBQUosQ0FBZVQsSUFBZixDQUZaLENBRDhFLEVBQTNFLEVBS0UsdUJBQUUsZ0JBQUYsRUFDRSx1QkFBRSxnQkFBRixFQUNFTixLQURGLEVBRUUsOEVBQXNELEtBQUtELElBQUwsR0FBWSxJQUFaLEdBQWtCLE1BQXhFLGtDQUEwR0ksTUFBMUcsc0NBQWlKQSxNQUFqSixRQUE0SjtBQUN4SkksdUJBQU8saUJBRGlKO0FBRXhKUyx5QkFBUztBQUFBLDJCQUFLLE1BQUtqQixJQUFMLEdBQVksQ0FBQyxNQUFLQSxJQUF2QjtBQUFBLGlCQUYrSSxFQUE1SixDQUZGLENBREYsQ0FMRixFQVdFLDZCQUFNSSxNQUFOLGtDQUNFLHVCQUFFLGFBQUYsRUFBaUIsQ0FBQ0QsTUFBRCxHQUFVTixJQUFJa0IsUUFBSixDQUFhRyxHQUFiLENBQWlCO0FBQUEsdUJBQUssdUJBQUUsR0FBRixFQUFPQyxDQUFQLENBQUw7QUFBQSxhQUFqQixDQUFWLEdBQTZDcEIsTUFBTUcsS0FBTixDQUFZa0IsT0FBWixDQUFvQkYsR0FBcEIsQ0FBd0IsYUFBSztBQUN2Rix1QkFBTyw2QkFBTUMsRUFBRSxDQUFGLENBQU4sbUJBQXVCZCxFQUFFYyxFQUFFLENBQUYsQ0FBRixFQUFRUixNQUFSLEtBQW1CLENBQW5CLEdBQXVCLE1BQXZCLEdBQWdDLE1BQXZELEdBQ0UsdUJBQUUsWUFBRixFQUNFLHVCQUFFLHNDQUFGLEVBQ0UsdUJBQUUscUVBQUYsQ0FERixDQURGLENBREYsRUFJRSx1QkFBRSxZQUFGLEVBQWdCUSxFQUFFLENBQUYsQ0FBaEIsQ0FKRixDQUFQO0FBSWlDLGFBTHlCLENBQTlELENBREYsQ0FYRixDQUFQO0FBa0JIOzs7Ozs7a0JBR1VyQixRIiwiZmlsZSI6IjE3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCc7XG5cbmltcG9ydCAqIGFzIGFwcCBmcm9tICcuLi9hcHAnO1xuXG5jbGFzcyBTdWJwYW5lbCB7XG4gICAgb25pbml0KHZub2RlKSB7XG4gICAgICAgIHRoaXMuaGlkZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZpZXcodm5vZGUpIHtcbiAgICAgICAgbGV0IHRpdGxlID0gdm5vZGUuYXR0cnMudGl0bGU7XG4gICAgICAgIGxldCBsZWdlbmQgPSB0aXRsZSA9PT0gJ0xlZ2VuZCc7XG4gICAgICAgIGxldCB0YXJnZXQgPSAnY29sbGFwc2UnICsgdGl0bGU7XG4gICAgICAgIGxldCB6ID0gYXBwLnpwYXJhbXM7XG4gICAgICAgIGxldCBzaWRlID0gbGVnZW5kID8gJ3JpZ2h0JyA6ICdsZWZ0JztcblxuICAgICAgICByZXR1cm4gbShgIyR7bGVnZW5kID8gXCJsZWdlbmQubGVnZW5kYXJ5XCIgOiBcImxvZ2Rpdi5sb2dib3hcIn0ucGFuZWwucGFuZWwtZGVmYXVsdGAsIHtcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgZGlzcGxheTogbGVnZW5kICYmIHouenRpbWUubGVuZ3RoICsgei56Y3Jvc3MubGVuZ3RoICsgei56ZHYubGVuZ3RoICsgei56bm9tLmxlbmd0aCB8fCAhbGVnZW5kICYmIGFwcC5sb2dBcnJheS5sZW5ndGggPiAwID8gJ2Jsb2NrJyA6ICdub25lJyxcbiAgICAgICAgICAgICAgICBbc2lkZV06IGFwcC5wYW5lbFdpZHRoW3NpZGVdXG4gICAgICAgICAgICB9fSxcbiAgICAgICAgICAgICAgICAgbShcIi5wYW5lbC1oZWFkaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgbShcImgzLnBhbmVsLXRpdGxlXCIsXG4gICAgICAgICAgICAgICAgICAgICB0aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgIG0oYHNwYW4uZ2x5cGhpY29uLmdseXBoaWNvbi1sYXJnZS5nbHlwaGljb24tY2hldnJvbi0ke3RoaXMuaGlkZSA/ICd1cCc6ICdkb3duJ30ucHVsbC1yaWdodFtkYXRhLXRhcmdldD0jJHt0YXJnZXR9XVtkYXRhLXRvZ2dsZT1jb2xsYXBzZV1baHJlZj0jJHt0YXJnZXR9XWAsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogJ2N1cnNvcjogcG9pbnRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgb25jbGljazogXyA9PiB0aGlzLmhpZGUgPSAhdGhpcy5oaWRlfSkpKSxcbiAgICAgICAgICAgICAgICAgbShgIyR7dGFyZ2V0fS5wYW5lbC1jb2xsYXBzZS5jb2xsYXBzZS5pbmAsXG4gICAgICAgICAgICAgICAgICAgbShcIi5wYW5lbC1ib2R5XCIsICFsZWdlbmQgPyBhcHAubG9nQXJyYXkubWFwKHggPT4gbSgncCcsIHgpKSA6IHZub2RlLmF0dHJzLmJ1dHRvbnMubWFwKHggPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbShgIyR7eFswXX0uY2xlYXJmaXguJHt6W3hbMV1dLmxlbmd0aCA9PT0gMCA/IFwiaGlkZVwiIDogXCJzaG93XCJ9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbShcIi5yZWN0Q29sb3JcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKFwic3ZnW3N0eWxlPXdpZHRoOiAyMHB4OyBoZWlnaHQ6IDIwcHhdXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKFwiY2lyY2xlW2N4PTEwXVtjeT0xMF1bZmlsbD13aGl0ZV1bcj05XVtzdHJva2U9YmxhY2tdW3N0cm9rZS13aWR0aD0yXVwiKSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKFwiLnJlY3RMYWJlbFwiLCB4WzJdKSk7fSkpKSk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBTdWJwYW5lbDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Fzc2V0cy9hcHAvdmlld3MvU3VicGFuZWwuanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///17\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mithril = __webpack_require__(0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _common = __webpack_require__(1);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Footer = function () {\n    function Footer() {\n        _classCallCheck(this, Footer);\n    }\n\n    _createClass(Footer, [{\n        key: 'view',\n        value: function view(vnode) {\n            return (0, _mithril2.default)('#footer', {\n                style: {\n                    background: _common.menuColor,\n                    'border-top': _common.borderColor,\n                    bottom: 0,\n                    height: _common.heightFooter + 'px',\n                    position: 'fixed',\n                    width: '100%'\n                }\n            }, vnode.children);\n        }\n    }]);\n\n    return Footer;\n}();\n\nexports.default = Footer;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvY29tbW9uL2FwcC92aWV3cy9Gb290ZXIuanM/YTVjNiJdLCJuYW1lcyI6WyJGb290ZXIiLCJ2bm9kZSIsInN0eWxlIiwiYmFja2dyb3VuZCIsImJvdHRvbSIsImhlaWdodCIsInBvc2l0aW9uIiwid2lkdGgiLCJjaGlsZHJlbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7OztBQUVBOzs7Ozs7SUFFcUJBLE07Ozs7Ozs7NkJBQ1pDLEssRUFBTztBQUNSLG1CQUFPLHVCQUFFLFNBQUYsRUFBYTtBQUNoQkMsdUJBQU87QUFDSEMsaURBREc7QUFFSCxxREFGRztBQUdIQyw0QkFBUSxDQUhMO0FBSUhDLDRCQUFRLHVCQUFlLElBSnBCO0FBS0hDLDhCQUFVLE9BTFA7QUFNSEMsMkJBQU87QUFOSjtBQURTLGFBQWIsRUFTSk4sTUFBTU8sUUFURixDQUFQO0FBVUg7Ozs7OztrQkFaZ0JSLE0iLCJmaWxlIjoiMTguanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbSBmcm9tICdtaXRocmlsJztcblxuaW1wb3J0IHtoZWlnaHRGb290ZXIsIG1lbnVDb2xvciwgYm9yZGVyQ29sb3J9IGZyb20gXCIuLi9jb21tb25cIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRm9vdGVyIHtcbiAgICB2aWV3KHZub2RlKSB7XG4gICAgICAgIHJldHVybiBtKCcjZm9vdGVyJywge1xuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiBtZW51Q29sb3IsXG4gICAgICAgICAgICAgICAgJ2JvcmRlci10b3AnOiBib3JkZXJDb2xvcixcbiAgICAgICAgICAgICAgICBib3R0b206IDAsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHRGb290ZXIgKyAncHgnLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgICAgICAgICAgIHdpZHRoOiAnMTAwJSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdm5vZGUuY2hpbGRyZW4pO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Fzc2V0cy9jb21tb24vYXBwL3ZpZXdzL0Zvb3Rlci5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///18\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mithril = __webpack_require__(0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _ButtonRadio = __webpack_require__(8);\n\nvar _ButtonRadio2 = _interopRequireDefault(_ButtonRadio);\n\nvar _common = __webpack_require__(1);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// ```\n// m(MenuTabbed, {\n//     id: string,\n//     sections: [...,\n//         {\n//             value: string\n//             title: text to use on hover,\n//             idSuffix: (optional) suffix to add to generated id strings\n//             contents: m(...)\n//             display: if 'none', then the button won't be visible on the button bar,\n//             selectWidth: int (optional),\n//             hoverbonus: int (optional)\n//         }],\n//     callback: (value) => console.log(value + \" was clicked!\"),\n//     attrsAll: {attributes to apply to the menu, EG height style}\n//     })\n// ```\n\n// The ids for the generated buttons and content areas are generated via 'idSuffix' passed into sections.\n// For example if idSuffix is 'Type', then there will be html objects with 'btnType' and 'tabType' ids. Defaults to value.\n\nvar MenuTabbed = function () {\n    function MenuTabbed() {\n        _classCallCheck(this, MenuTabbed);\n    }\n\n    _createClass(MenuTabbed, [{\n        key: \"view\",\n        value: function view(vnode) {\n            var _vnode$attrs = vnode.attrs,\n                id = _vnode$attrs.id,\n                sections = _vnode$attrs.sections,\n                callback = _vnode$attrs.callback,\n                selectWidth = _vnode$attrs.selectWidth,\n                hoverBonus = _vnode$attrs.hoverBonus,\n                currentTab = _vnode$attrs.currentTab,\n                attrsAll = _vnode$attrs.attrsAll;\n\n            // If a button is not visible, then create the element for the DOM anyways-- but don't let it affect the css\n\n            var visibleButtons = [];\n            var invisibleButtons = [];\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n                var _loop = function _loop() {\n                    var section = _step.value;\n\n                    if (section['display'] === 'none') invisibleButtons.push(section);else {\n                        section['onclick'] = function () {\n                            return callback(section['value']);\n                        };\n                        visibleButtons.push(section);\n                    }\n                    // Automatically build the id\n\n                    section['id'] = 'btn' + (section['idSuffix'] || section['value']);\n                };\n\n                for (var _iterator = sections[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                    _loop();\n                }\n\n                // Contents to render for the section\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion && _iterator.return) {\n                        _iterator.return();\n                    }\n                } finally {\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                }\n            }\n\n            return (0, _mithril2.default)('#' + id, attrsAll, [(0, _mithril2.default)(_ButtonRadio2.default, {\n                id: id + 'ButtonBar',\n                onclick: callback,\n                sections: visibleButtons,\n                attrsAll: { style: { 'margin-bottom': '5px' } },\n                hoverBonus: hoverBonus,\n                activeSection: currentTab,\n                selectWidth: selectWidth\n            }), (0, _mithril2.default)(_ButtonRadio2.default, {\n                id: id + 'ButtonBarHidden',\n                onclick: callback,\n                sections: invisibleButtons,\n                attrsAll: { style: { display: 'none' } },\n                hoverBonus: hoverBonus,\n                selectWidth: selectWidth\n            }), sections.map(function (section) {\n                return (0, _mithril2.default)(\"div#tab\" + (section['idSuffix'] || section['value']), {\n                    style: {\n                        display: section['value'] === currentTab ? 'block' : 'none',\n                        height: 'calc(100% - 39px)',\n                        overflow: 'auto'\n                    }\n                }, section.contents);\n            })]);\n        }\n    }]);\n\n    return MenuTabbed;\n}();\n\nexports.default = MenuTabbed;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvY29tbW9uL2FwcC92aWV3cy9NZW51VGFiYmVkLmpzP2Y2ODMiXSwibmFtZXMiOlsiTWVudVRhYmJlZCIsInZub2RlIiwiYXR0cnMiLCJpZCIsInNlY3Rpb25zIiwiY2FsbGJhY2siLCJzZWxlY3RXaWR0aCIsImhvdmVyQm9udXMiLCJjdXJyZW50VGFiIiwiYXR0cnNBbGwiLCJ2aXNpYmxlQnV0dG9ucyIsImludmlzaWJsZUJ1dHRvbnMiLCJzZWN0aW9uIiwicHVzaCIsIm9uY2xpY2siLCJzdHlsZSIsImFjdGl2ZVNlY3Rpb24iLCJkaXNwbGF5IiwibWFwIiwiaGVpZ2h0Iiwib3ZlcmZsb3ciLCJjb250ZW50cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7OztBQUNBOzs7O0FBQ0E7Ozs7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7SUFFcUJBLFU7Ozs7Ozs7NkJBRVpDLEssRUFBTztBQUFBLCtCQUNzRUEsTUFBTUMsS0FENUU7QUFBQSxnQkFDSEMsRUFERyxnQkFDSEEsRUFERztBQUFBLGdCQUNDQyxRQURELGdCQUNDQSxRQUREO0FBQUEsZ0JBQ1dDLFFBRFgsZ0JBQ1dBLFFBRFg7QUFBQSxnQkFDcUJDLFdBRHJCLGdCQUNxQkEsV0FEckI7QUFBQSxnQkFDa0NDLFVBRGxDLGdCQUNrQ0EsVUFEbEM7QUFBQSxnQkFDOENDLFVBRDlDLGdCQUM4Q0EsVUFEOUM7QUFBQSxnQkFDMERDLFFBRDFELGdCQUMwREEsUUFEMUQ7O0FBR1I7O0FBQ0EsZ0JBQUlDLGlCQUFpQixFQUFyQjtBQUNBLGdCQUFJQyxtQkFBbUIsRUFBdkI7QUFMUTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBLHdCQU1DQyxPQU5EOztBQU9KLHdCQUFJQSxRQUFRLFNBQVIsTUFBdUIsTUFBM0IsRUFBbUNELGlCQUFpQkUsSUFBakIsQ0FBc0JELE9BQXRCLEVBQW5DLEtBQ0s7QUFDREEsZ0NBQVEsU0FBUixJQUFxQjtBQUFBLG1DQUFNUCxTQUFTTyxRQUFRLE9BQVIsQ0FBVCxDQUFOO0FBQUEseUJBQXJCO0FBQ0FGLHVDQUFlRyxJQUFmLENBQW9CRCxPQUFwQjtBQUNIO0FBQ0Q7O0FBRUFBLDRCQUFRLElBQVIsSUFBZ0IsU0FBU0EsUUFBUSxVQUFSLEtBQXVCQSxRQUFRLE9BQVIsQ0FBaEMsQ0FBaEI7QUFkSTs7QUFNUixxQ0FBb0JSLFFBQXBCLDhIQUE4QjtBQUFBO0FBUzdCOztBQUVEO0FBakJRO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBa0JSLG1CQUFPLHVCQUFFLE1BQU1ELEVBQVIsRUFBWU0sUUFBWixFQUFzQixDQUN6Qiw4Q0FBZTtBQUNYTixvQkFBSUEsS0FBSyxXQURFO0FBRVhXLHlCQUFTVCxRQUZFO0FBR1hELDBCQUFVTSxjQUhDO0FBSVhELDBCQUFVLEVBQUNNLE9BQU8sRUFBQyxpQkFBaUIsS0FBbEIsRUFBUixFQUpDO0FBS1hSLDRCQUFZQSxVQUxEO0FBTVhTLCtCQUFlUixVQU5KO0FBT1hGLDZCQUFhQTtBQVBGLGFBQWYsQ0FEeUIsRUFVekIsOENBQWU7QUFDWEgsb0JBQUlBLEtBQUssaUJBREU7QUFFWFcseUJBQVNULFFBRkU7QUFHWEQsMEJBQVVPLGdCQUhDO0FBSVhGLDBCQUFVLEVBQUNNLE9BQU8sRUFBQ0UsU0FBUyxNQUFWLEVBQVIsRUFKQztBQUtYViw0QkFBWUEsVUFMRDtBQU1YRCw2QkFBYUE7QUFORixhQUFmLENBVnlCLEVBa0J6QkYsU0FBU2MsR0FBVCxDQUFhLFVBQUNOLE9BQUQ7QUFBQSx1QkFBYSxvQ0FBWUEsUUFBUSxVQUFSLEtBQXVCQSxRQUFRLE9BQVIsQ0FBbkMsR0FBdUQ7QUFDN0VHLDJCQUFPO0FBQ0hFLGlDQUFTTCxRQUFRLE9BQVIsTUFBcUJKLFVBQXJCLEdBQWtDLE9BQWxDLEdBQTRDLE1BRGxEO0FBRUhXLGdDQUFRLG1CQUZMO0FBR0hDLGtDQUFVO0FBSFA7QUFEc0UsaUJBQXZELEVBTXZCUixRQUFRUyxRQU5lLENBQWI7QUFBQSxhQUFiLENBbEJ5QixDQUF0QixDQUFQO0FBMEJIOzs7Ozs7a0JBOUNnQnJCLFUiLCJmaWxlIjoiMTkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbSBmcm9tICdtaXRocmlsJ1xuaW1wb3J0IEJ1dHRvblJhZGlvIGZyb20gXCIuL0J1dHRvblJhZGlvXCI7XG5pbXBvcnQge21lcmdlQXR0cmlidXRlc30gZnJvbSBcIi4uL2NvbW1vblwiO1xuXG4vLyBgYGBcbi8vIG0oTWVudVRhYmJlZCwge1xuLy8gICAgIGlkOiBzdHJpbmcsXG4vLyAgICAgc2VjdGlvbnM6IFsuLi4sXG4vLyAgICAgICAgIHtcbi8vICAgICAgICAgICAgIHZhbHVlOiBzdHJpbmdcbi8vICAgICAgICAgICAgIHRpdGxlOiB0ZXh0IHRvIHVzZSBvbiBob3Zlcixcbi8vICAgICAgICAgICAgIGlkU3VmZml4OiAob3B0aW9uYWwpIHN1ZmZpeCB0byBhZGQgdG8gZ2VuZXJhdGVkIGlkIHN0cmluZ3Ncbi8vICAgICAgICAgICAgIGNvbnRlbnRzOiBtKC4uLilcbi8vICAgICAgICAgICAgIGRpc3BsYXk6IGlmICdub25lJywgdGhlbiB0aGUgYnV0dG9uIHdvbid0IGJlIHZpc2libGUgb24gdGhlIGJ1dHRvbiBiYXIsXG4vLyAgICAgICAgICAgICBzZWxlY3RXaWR0aDogaW50IChvcHRpb25hbCksXG4vLyAgICAgICAgICAgICBob3ZlcmJvbnVzOiBpbnQgKG9wdGlvbmFsKVxuLy8gICAgICAgICB9XSxcbi8vICAgICBjYWxsYmFjazogKHZhbHVlKSA9PiBjb25zb2xlLmxvZyh2YWx1ZSArIFwiIHdhcyBjbGlja2VkIVwiKSxcbi8vICAgICBhdHRyc0FsbDoge2F0dHJpYnV0ZXMgdG8gYXBwbHkgdG8gdGhlIG1lbnUsIEVHIGhlaWdodCBzdHlsZX1cbi8vICAgICB9KVxuLy8gYGBgXG5cbi8vIFRoZSBpZHMgZm9yIHRoZSBnZW5lcmF0ZWQgYnV0dG9ucyBhbmQgY29udGVudCBhcmVhcyBhcmUgZ2VuZXJhdGVkIHZpYSAnaWRTdWZmaXgnIHBhc3NlZCBpbnRvIHNlY3Rpb25zLlxuLy8gRm9yIGV4YW1wbGUgaWYgaWRTdWZmaXggaXMgJ1R5cGUnLCB0aGVuIHRoZXJlIHdpbGwgYmUgaHRtbCBvYmplY3RzIHdpdGggJ2J0blR5cGUnIGFuZCAndGFiVHlwZScgaWRzLiBEZWZhdWx0cyB0byB2YWx1ZS5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWVudVRhYmJlZCB7XG5cbiAgICB2aWV3KHZub2RlKSB7XG4gICAgICAgIGxldCB7aWQsIHNlY3Rpb25zLCBjYWxsYmFjaywgc2VsZWN0V2lkdGgsIGhvdmVyQm9udXMsIGN1cnJlbnRUYWIsIGF0dHJzQWxsfSA9IHZub2RlLmF0dHJzO1xuXG4gICAgICAgIC8vIElmIGEgYnV0dG9uIGlzIG5vdCB2aXNpYmxlLCB0aGVuIGNyZWF0ZSB0aGUgZWxlbWVudCBmb3IgdGhlIERPTSBhbnl3YXlzLS0gYnV0IGRvbid0IGxldCBpdCBhZmZlY3QgdGhlIGNzc1xuICAgICAgICBsZXQgdmlzaWJsZUJ1dHRvbnMgPSBbXTtcbiAgICAgICAgbGV0IGludmlzaWJsZUJ1dHRvbnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgc2VjdGlvbiBvZiBzZWN0aW9ucykge1xuICAgICAgICAgICAgaWYgKHNlY3Rpb25bJ2Rpc3BsYXknXSA9PT0gJ25vbmUnKSBpbnZpc2libGVCdXR0b25zLnB1c2goc2VjdGlvbik7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWN0aW9uWydvbmNsaWNrJ10gPSAoKSA9PiBjYWxsYmFjayhzZWN0aW9uWyd2YWx1ZSddKTtcbiAgICAgICAgICAgICAgICB2aXNpYmxlQnV0dG9ucy5wdXNoKHNlY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQXV0b21hdGljYWxseSBidWlsZCB0aGUgaWRcblxuICAgICAgICAgICAgc2VjdGlvblsnaWQnXSA9ICdidG4nICsgKHNlY3Rpb25bJ2lkU3VmZml4J10gfHwgc2VjdGlvblsndmFsdWUnXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb250ZW50cyB0byByZW5kZXIgZm9yIHRoZSBzZWN0aW9uXG4gICAgICAgIHJldHVybiBtKCcjJyArIGlkLCBhdHRyc0FsbCwgW1xuICAgICAgICAgICAgbShCdXR0b25SYWRpbywge1xuICAgICAgICAgICAgICAgIGlkOiBpZCArICdCdXR0b25CYXInLFxuICAgICAgICAgICAgICAgIG9uY2xpY2s6IGNhbGxiYWNrLFxuICAgICAgICAgICAgICAgIHNlY3Rpb25zOiB2aXNpYmxlQnV0dG9ucyxcbiAgICAgICAgICAgICAgICBhdHRyc0FsbDoge3N0eWxlOiB7J21hcmdpbi1ib3R0b20nOiAnNXB4J319LFxuICAgICAgICAgICAgICAgIGhvdmVyQm9udXM6IGhvdmVyQm9udXMsXG4gICAgICAgICAgICAgICAgYWN0aXZlU2VjdGlvbjogY3VycmVudFRhYixcbiAgICAgICAgICAgICAgICBzZWxlY3RXaWR0aDogc2VsZWN0V2lkdGhcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgbShCdXR0b25SYWRpbywge1xuICAgICAgICAgICAgICAgIGlkOiBpZCArICdCdXR0b25CYXJIaWRkZW4nLFxuICAgICAgICAgICAgICAgIG9uY2xpY2s6IGNhbGxiYWNrLFxuICAgICAgICAgICAgICAgIHNlY3Rpb25zOiBpbnZpc2libGVCdXR0b25zLFxuICAgICAgICAgICAgICAgIGF0dHJzQWxsOiB7c3R5bGU6IHtkaXNwbGF5OiAnbm9uZSd9fSxcbiAgICAgICAgICAgICAgICBob3ZlckJvbnVzOiBob3ZlckJvbnVzLFxuICAgICAgICAgICAgICAgIHNlbGVjdFdpZHRoOiBzZWxlY3RXaWR0aFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBzZWN0aW9ucy5tYXAoKHNlY3Rpb24pID0+IG0oYGRpdiN0YWIke3NlY3Rpb25bJ2lkU3VmZml4J10gfHwgc2VjdGlvblsndmFsdWUnXX1gLCB7XG4gICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogc2VjdGlvblsndmFsdWUnXSA9PT0gY3VycmVudFRhYiA/ICdibG9jaycgOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogJ2NhbGMoMTAwJSAtIDM5cHgpJyxcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3c6ICdhdXRvJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHNlY3Rpb24uY29udGVudHMpKVxuICAgICAgICBdKTtcbiAgICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYXNzZXRzL2NvbW1vbi9hcHAvdmlld3MvTWVudVRhYmJlZC5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///19\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mithril = __webpack_require__(0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\n__webpack_require__(32);\n\nvar _common = __webpack_require__(1);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// ```\n// m(Panel, {\n//     side: 'left' || 'right',\n//     label: 'text at top of header',\n//     hover: Bool\n//     contents: m(...),\n//     width: int pixels,\n//     attrsAll: { apply attributes to the outer div }\n//     })\n// ```\n\n// If hover is true, then the canvas is occluded by the panels.\n// If hover is false, then the canvas is resized to maintain a margin as panels are opened/closed or canvas contents overflow.\n//\n// Contents for each partition are described in the sections list.\n// If tabs are set, then the width of the panel may be set in the section options.\n// If headers are set, the width of the panel is set globally.\n//\n// Sometimes the contents of a panel should not be accessible via the tab bar.\n// Setting the toggle 'visible' prevents it from appearing in the tab bar.\n\nvar dot = [_mithril2.default.trust('&#9679;'), (0, _mithril2.default)('br')];\n\nvar Panel = function () {\n    function Panel() {\n        _classCallCheck(this, Panel);\n    }\n\n    _createClass(Panel, [{\n        key: 'view',\n        value: function view(vnode) {\n            var _style;\n\n            var _vnode$attrs = vnode.attrs,\n                side = _vnode$attrs.side,\n                hover = _vnode$attrs.hover,\n                label = _vnode$attrs.label,\n                width = _vnode$attrs.width,\n                attrsAll = _vnode$attrs.attrsAll;\n\n            (0, _common.scrollBarChanged)();\n\n            if (!hover) {\n                (0, _common.setPanelOcclusion)(side, 'calc(' + (_common.panelOpen[side] ? width : '16px') + ' + ' + 2 * _common.panelMargin + 'px)');\n            }\n\n            return (0, _mithril2.default)('#' + side + 'panel.container.sidepanel.clearfix', (0, _common.mergeAttributes)({\n                style: (_style = {\n                    background: _common.menuColor,\n                    border: _common.borderColor,\n                    width: _common.panelOpen[side] ? width : 0,\n                    height: 'calc(100% - ' + (_common.heightHeader + _common.heightFooter) + 'px - ' + 2 * _common.panelMargin + 'px - ' + (_common.canvasScroll['horizontal'] ? _common.scrollbarWidth : 0) + 'px)',\n                    position: 'fixed',\n                    top: _common.heightHeader + _common.panelMargin + 'px'\n                }, _defineProperty(_style, side, (side === 'right' && _common.canvasScroll['vertical'] ? _common.scrollbarWidth : 0) + _common.panelMargin + 'px'), _defineProperty(_style, 'z-index', 100), _style)\n            }, attrsAll), [\n            // handle\n            (0, _mithril2.default)('#toggle' + (side === 'left' ? 'L' : 'R') + 'panelicon.panelbar', {\n                style: _defineProperty({ height: '100%' }, side, 'calc(100% - 16px)')\n            }, (0, _mithril2.default)('span', { onclick: function onclick() {\n                    return (0, _common.togglePanelOpen)(side);\n                } }, dot, dot, dot, dot)),\n            // contents\n            (0, _mithril2.default)('div' + (_common.panelOpen[side] ? '' : '.closepanel'), {\n                style: {\n                    width: 'calc(100% - 8px)', height: '100%',\n                    margin: '0 4px',\n                    display: _common.panelOpen[side] ? 'block' : 'none'\n                }\n            }, [(0, _mithril2.default)('#' + side + 'paneltitle.panel-heading.text-center', (0, _mithril2.default)(\"h3.panel-title\", label)), vnode.children])]);\n        }\n    }]);\n\n    return Panel;\n}();\n\nexports.default = Panel;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvY29tbW9uL2FwcC92aWV3cy9QYW5lbC5qcz82M2U3Il0sIm5hbWVzIjpbImRvdCIsInRydXN0IiwiUGFuZWwiLCJ2bm9kZSIsImF0dHJzIiwic2lkZSIsImhvdmVyIiwibGFiZWwiLCJ3aWR0aCIsImF0dHJzQWxsIiwic3R5bGUiLCJiYWNrZ3JvdW5kIiwiYm9yZGVyIiwiaGVpZ2h0IiwicG9zaXRpb24iLCJ0b3AiLCJvbmNsaWNrIiwibWFyZ2luIiwiZGlzcGxheSIsImNoaWxkcmVuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7O0FBRUE7O0FBRUE7Ozs7Ozs7O0FBZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQU1BLE1BQU0sQ0FBQyxrQkFBRUMsS0FBRixDQUFRLFNBQVIsQ0FBRCxFQUFxQix1QkFBRSxJQUFGLENBQXJCLENBQVo7O0lBRXFCQyxLOzs7Ozs7OzZCQUNaQyxLLEVBQU87QUFBQTs7QUFBQSwrQkFDb0NBLE1BQU1DLEtBRDFDO0FBQUEsZ0JBQ0hDLElBREcsZ0JBQ0hBLElBREc7QUFBQSxnQkFDR0MsS0FESCxnQkFDR0EsS0FESDtBQUFBLGdCQUNVQyxLQURWLGdCQUNVQSxLQURWO0FBQUEsZ0JBQ2lCQyxLQURqQixnQkFDaUJBLEtBRGpCO0FBQUEsZ0JBQ3dCQyxRQUR4QixnQkFDd0JBLFFBRHhCOztBQUVSOztBQUVBLGdCQUFJLENBQUNILEtBQUwsRUFBWTtBQUNSLCtDQUFrQkQsSUFBbEIsYUFBZ0Msa0JBQVVBLElBQVYsSUFBa0JHLEtBQWxCLEdBQTBCLE1BQTFELFlBQXNFLHVCQUF0RTtBQUNIOztBQUVELG1CQUFPLDZCQUFNSCxJQUFOLHlDQUFnRCw2QkFBZ0I7QUFDbkVLO0FBQ0lDLGlEQURKO0FBRUlDLCtDQUZKO0FBR0lKLDJCQUFPLGtCQUFVSCxJQUFWLElBQWtCRyxLQUFsQixHQUEwQixDQUhyQztBQUlJSyw4Q0FBdUIsMkNBQXZCLGNBQTBELHVCQUExRCxjQUFpRixxQkFBYSxZQUFiLDZCQUE4QyxDQUEvSCxTQUpKO0FBS0lDLDhCQUFVLE9BTGQ7QUFNSUMseUJBQUssNkNBQTZCO0FBTnRDLDJDQU9LVixJQVBMLEVBT1ksQ0FBQ0EsU0FBUyxPQUFULElBQW9CLHFCQUFhLFVBQWIsQ0FBcEIsNEJBQWdFLENBQWpFLDBCQUFvRixJQVBoRywyQkFTSSxTQVRKLEVBU2UsR0FUZjtBQURtRSxhQUFoQixFQVlwREksUUFab0QsQ0FBaEQsRUFZTztBQUNWO0FBQ0EsZ0RBQVlKLFNBQVMsTUFBVCxHQUFrQixHQUFsQixHQUF3QixHQUFwQywwQkFBNkQ7QUFDekRLLHlDQUFRRyxRQUFRLE1BQWhCLElBQXlCUixJQUF6QixFQUFnQyxtQkFBaEM7QUFEeUQsYUFBN0QsRUFFRyx1QkFBRSxNQUFGLEVBQVUsRUFBQ1csU0FBUztBQUFBLDJCQUFNLDZCQUFnQlgsSUFBaEIsQ0FBTjtBQUFBLGlCQUFWLEVBQVYsRUFBa0RMLEdBQWxELEVBQXVEQSxHQUF2RCxFQUE0REEsR0FBNUQsRUFBaUVBLEdBQWpFLENBRkgsQ0FGVTtBQUtWO0FBQ0EsNENBQVEsa0JBQVVLLElBQVYsSUFBa0IsRUFBbEIsR0FBdUIsYUFBL0IsR0FBZ0Q7QUFDNUNLLHVCQUFPO0FBQ0hGLDJCQUFPLGtCQURKLEVBQ3dCSyxRQUFRLE1BRGhDO0FBRUhJLDRCQUFRLE9BRkw7QUFHSEMsNkJBQVMsa0JBQVViLElBQVYsSUFBa0IsT0FBbEIsR0FBNEI7QUFIbEM7QUFEcUMsYUFBaEQsRUFNRyxDQUFDLDZCQUFNQSxJQUFOLDJDQUFrRCx1QkFBRSxnQkFBRixFQUFvQkUsS0FBcEIsQ0FBbEQsQ0FBRCxFQUFnRkosTUFBTWdCLFFBQXRGLENBTkgsQ0FOVSxDQVpQLENBQVA7QUEwQkg7Ozs7OztrQkFuQ2dCakIsSyIsImZpbGUiOiIyMC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuXG5pbXBvcnQgJy4uLy4uL2Nzcy9jb21tb24uY3NzJztcblxuaW1wb3J0IHtcbiAgICBwYW5lbE9wZW4sXG4gICAgdG9nZ2xlUGFuZWxPcGVuLFxuICAgIG1lbnVDb2xvcixcbiAgICBib3JkZXJDb2xvcixcbiAgICBoZWlnaHRIZWFkZXIsXG4gICAgaGVpZ2h0Rm9vdGVyLFxuICAgIHBhbmVsTWFyZ2luLFxuICAgIGNhbnZhc1Njcm9sbCxcbiAgICBzY3JvbGxiYXJXaWR0aCxcbiAgICBzZXRQYW5lbE9jY2x1c2lvbixcbiAgICBzY3JvbGxCYXJDaGFuZ2VkLFxuICAgIG1lcmdlQXR0cmlidXRlc1xufSBmcm9tIFwiLi4vY29tbW9uXCI7XG5cbi8vIGBgYFxuLy8gbShQYW5lbCwge1xuLy8gICAgIHNpZGU6ICdsZWZ0JyB8fCAncmlnaHQnLFxuLy8gICAgIGxhYmVsOiAndGV4dCBhdCB0b3Agb2YgaGVhZGVyJyxcbi8vICAgICBob3ZlcjogQm9vbFxuLy8gICAgIGNvbnRlbnRzOiBtKC4uLiksXG4vLyAgICAgd2lkdGg6IGludCBwaXhlbHMsXG4vLyAgICAgYXR0cnNBbGw6IHsgYXBwbHkgYXR0cmlidXRlcyB0byB0aGUgb3V0ZXIgZGl2IH1cbi8vICAgICB9KVxuLy8gYGBgXG5cbi8vIElmIGhvdmVyIGlzIHRydWUsIHRoZW4gdGhlIGNhbnZhcyBpcyBvY2NsdWRlZCBieSB0aGUgcGFuZWxzLlxuLy8gSWYgaG92ZXIgaXMgZmFsc2UsIHRoZW4gdGhlIGNhbnZhcyBpcyByZXNpemVkIHRvIG1haW50YWluIGEgbWFyZ2luIGFzIHBhbmVscyBhcmUgb3BlbmVkL2Nsb3NlZCBvciBjYW52YXMgY29udGVudHMgb3ZlcmZsb3cuXG4vL1xuLy8gQ29udGVudHMgZm9yIGVhY2ggcGFydGl0aW9uIGFyZSBkZXNjcmliZWQgaW4gdGhlIHNlY3Rpb25zIGxpc3QuXG4vLyBJZiB0YWJzIGFyZSBzZXQsIHRoZW4gdGhlIHdpZHRoIG9mIHRoZSBwYW5lbCBtYXkgYmUgc2V0IGluIHRoZSBzZWN0aW9uIG9wdGlvbnMuXG4vLyBJZiBoZWFkZXJzIGFyZSBzZXQsIHRoZSB3aWR0aCBvZiB0aGUgcGFuZWwgaXMgc2V0IGdsb2JhbGx5LlxuLy9cbi8vIFNvbWV0aW1lcyB0aGUgY29udGVudHMgb2YgYSBwYW5lbCBzaG91bGQgbm90IGJlIGFjY2Vzc2libGUgdmlhIHRoZSB0YWIgYmFyLlxuLy8gU2V0dGluZyB0aGUgdG9nZ2xlICd2aXNpYmxlJyBwcmV2ZW50cyBpdCBmcm9tIGFwcGVhcmluZyBpbiB0aGUgdGFiIGJhci5cblxuY29uc3QgZG90ID0gW20udHJ1c3QoJyYjOTY3OTsnKSwgbSgnYnInKV07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBhbmVsIHtcbiAgICB2aWV3KHZub2RlKSB7XG4gICAgICAgIGxldCB7c2lkZSwgaG92ZXIsIGxhYmVsLCB3aWR0aCwgYXR0cnNBbGx9ID0gdm5vZGUuYXR0cnM7XG4gICAgICAgIHNjcm9sbEJhckNoYW5nZWQoKTtcblxuICAgICAgICBpZiAoIWhvdmVyKSB7XG4gICAgICAgICAgICBzZXRQYW5lbE9jY2x1c2lvbihzaWRlLCBgY2FsYygke3BhbmVsT3BlbltzaWRlXSA/IHdpZHRoIDogJzE2cHgnfSArICR7MiAqIHBhbmVsTWFyZ2lufXB4KWApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG0oYCMke3NpZGV9cGFuZWwuY29udGFpbmVyLnNpZGVwYW5lbC5jbGVhcmZpeGAsIG1lcmdlQXR0cmlidXRlcyh7XG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6IG1lbnVDb2xvcixcbiAgICAgICAgICAgICAgICBib3JkZXI6IGJvcmRlckNvbG9yLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBwYW5lbE9wZW5bc2lkZV0gPyB3aWR0aCA6IDAsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBgY2FsYygxMDAlIC0gJHtoZWlnaHRIZWFkZXIgKyBoZWlnaHRGb290ZXJ9cHggLSAkezIgKiBwYW5lbE1hcmdpbn1weCAtICR7Y2FudmFzU2Nyb2xsWydob3Jpem9udGFsJ10gPyBzY3JvbGxiYXJXaWR0aCA6IDB9cHgpYCxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICAgICAgICAgICAgICB0b3A6IGhlaWdodEhlYWRlciArIHBhbmVsTWFyZ2luICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBbc2lkZV06IChzaWRlID09PSAncmlnaHQnICYmIGNhbnZhc1Njcm9sbFsndmVydGljYWwnXSA/IHNjcm9sbGJhcldpZHRoIDogMCkgKyBwYW5lbE1hcmdpbiArICdweCcsXG4gICAgICAgICAgICAgICAgLy8gWydwYWRkaW5nLScgKyBzaWRlXTogJzFweCcsXG4gICAgICAgICAgICAgICAgJ3otaW5kZXgnOiAxMDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgYXR0cnNBbGwpLCBbXG4gICAgICAgICAgICAvLyBoYW5kbGVcbiAgICAgICAgICAgIG0oYCN0b2dnbGUke3NpZGUgPT09ICdsZWZ0JyA/ICdMJyA6ICdSJ31wYW5lbGljb24ucGFuZWxiYXJgLCB7XG4gICAgICAgICAgICAgICAgc3R5bGU6IHtoZWlnaHQ6ICcxMDAlJywgW3NpZGVdOiAnY2FsYygxMDAlIC0gMTZweCknfVxuICAgICAgICAgICAgfSwgbSgnc3BhbicsIHtvbmNsaWNrOiAoKSA9PiB0b2dnbGVQYW5lbE9wZW4oc2lkZSl9LCBkb3QsIGRvdCwgZG90LCBkb3QpKSxcbiAgICAgICAgICAgIC8vIGNvbnRlbnRzXG4gICAgICAgICAgICBtKGBkaXYke3BhbmVsT3BlbltzaWRlXSA/ICcnIDogJy5jbG9zZXBhbmVsJ31gLCB7XG4gICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6ICdjYWxjKDEwMCUgLSA4cHgpJywgaGVpZ2h0OiAnMTAwJScsXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbjogJzAgNHB4JyxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogcGFuZWxPcGVuW3NpZGVdID8gJ2Jsb2NrJyA6ICdub25lJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIFttKGAjJHtzaWRlfXBhbmVsdGl0bGUucGFuZWwtaGVhZGluZy50ZXh0LWNlbnRlcmAsIG0oXCJoMy5wYW5lbC10aXRsZVwiLCBsYWJlbCkpLCB2bm9kZS5jaGlsZHJlbl0pXG4gICAgICAgIF0pO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Fzc2V0cy9jb21tb24vYXBwL3ZpZXdzL1BhbmVsLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///20\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mithril = __webpack_require__(0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _common = __webpack_require__(1);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// ```\n// m(PanelList, {\n//         id: 'id of container',\n//         items: ['Clickable 1', 'Clickable 2', 'Clickable 3'],\n//\n//         colors: { app.selVarColor: ['Clickable 1'] }, (optional)\n//         classes: { 'item-lineout': ['Clickable 1', 'Clickable 3'] }, (optional)\n//\n//         callback: (item) => console.log(item + \" clicked.\"),\n//         popup: (item) => { return 'PopupContent'}, (optional)\n//\n//         attrsAll: {... additional attributes for the entire list},\n//         attrsItems: {... additional attributes for each item}\n//     })\n// ```\n\n// colors is an object that maps a color to a list or set of items with that color. Order colors by increasing priority.\n// classes acts similarly, but one item may have several classes. Standard css rules apply for stacking css classes.\n// popup returns the popup contents when called with the item. If not set, then popup is not drawn\n\nvar PanelList = function () {\n    function PanelList() {\n        _classCallCheck(this, PanelList);\n    }\n\n    _createClass(PanelList, [{\n        key: 'view',\n        value: function view(vnode) {\n            var _vnode$attrs = vnode.attrs,\n                id = _vnode$attrs.id,\n                items = _vnode$attrs.items,\n                colors = _vnode$attrs.colors,\n                classes = _vnode$attrs.classes,\n                callback = _vnode$attrs.callback,\n                popup = _vnode$attrs.popup,\n                attrsAll = _vnode$attrs.attrsAll,\n                attrsItems = _vnode$attrs.attrsItems;\n\n            // set alternate background-color if defined\n\n            var viewColor = {};\n            for (var color in colors || []) {\n                var _iteratorNormalCompletion = true;\n                var _didIteratorError = false;\n                var _iteratorError = undefined;\n\n                try {\n                    for (var _iterator = colors[color][Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                        var item = _step.value;\n                        viewColor[item] = color;\n                    }\n                } catch (err) {\n                    _didIteratorError = true;\n                    _iteratorError = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion && _iterator.return) {\n                            _iterator.return();\n                        }\n                    } finally {\n                        if (_didIteratorError) {\n                            throw _iteratorError;\n                        }\n                    }\n                }\n            } // invert the class -> item object\n            var viewClass = {};\n            for (var css in classes || []) {\n                var _iteratorNormalCompletion2 = true;\n                var _didIteratorError2 = false;\n                var _iteratorError2 = undefined;\n\n                try {\n                    for (var _iterator2 = classes[css][Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                        var _item = _step2.value;\n\n                        viewClass[_item] ? viewClass[_item].push(css) : viewClass[_item] = [css];\n                    }\n                } catch (err) {\n                    _didIteratorError2 = true;\n                    _iteratorError2 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                            _iterator2.return();\n                        }\n                    } finally {\n                        if (_didIteratorError2) {\n                            throw _iteratorError2;\n                        }\n                    }\n                }\n            }return (0, _mithril2.default)('div#' + id, attrsAll, items.map(function (item) {\n                return (0, _mithril2.default)('div#' + (id + item.replace(/\\W/g, '_')), (0, _common.mergeAttributes)({\n                    style: {\n                        'margin-top': '5px',\n                        'text-align': \"center\",\n                        'background-color': viewColor[item] || _common.varColor\n                    },\n                    'class': viewClass[item],\n                    onclick: function onclick() {\n                        return (callback || Function)(item);\n                    }\n                },\n\n                // add popup if defined\n                popup ? {\n                    onmouseover: function onmouseover() {\n                        $(this).popover('toggle');\n                    },\n                    onmouseout: function onmouseout() {\n                        $(this).popover('toggle');\n                    },\n                    'data-container': 'body',\n                    'data-content': popup(item),\n                    'data-html': 'true',\n                    'data-original-title': item,\n                    'data-placement': 'auto',\n                    'data-toggle': 'popover',\n                    'data-trigger': 'hover'\n                } : {},\n\n                // add any additional attributes if passed\n                attrsItems), item);\n            }));\n        }\n    }]);\n\n    return PanelList;\n}();\n\nexports.default = PanelList;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvY29tbW9uL2FwcC92aWV3cy9QYW5lbExpc3QuanM/ZTMyOSJdLCJuYW1lcyI6WyJQYW5lbExpc3QiLCJ2bm9kZSIsImF0dHJzIiwiaWQiLCJpdGVtcyIsImNvbG9ycyIsImNsYXNzZXMiLCJjYWxsYmFjayIsInBvcHVwIiwiYXR0cnNBbGwiLCJhdHRyc0l0ZW1zIiwidmlld0NvbG9yIiwiY29sb3IiLCJpdGVtIiwidmlld0NsYXNzIiwiY3NzIiwicHVzaCIsIm1hcCIsInJlcGxhY2UiLCJzdHlsZSIsIm9uY2xpY2siLCJGdW5jdGlvbiIsIm9ubW91c2VvdmVyIiwiJCIsInBvcG92ZXIiLCJvbm1vdXNlb3V0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7O0FBQ0E7Ozs7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0lBRXFCQSxTOzs7Ozs7OzZCQUNaQyxLLEVBQU87QUFBQSwrQkFDa0VBLE1BQU1DLEtBRHhFO0FBQUEsZ0JBQ0hDLEVBREcsZ0JBQ0hBLEVBREc7QUFBQSxnQkFDQ0MsS0FERCxnQkFDQ0EsS0FERDtBQUFBLGdCQUNRQyxNQURSLGdCQUNRQSxNQURSO0FBQUEsZ0JBQ2dCQyxPQURoQixnQkFDZ0JBLE9BRGhCO0FBQUEsZ0JBQ3lCQyxRQUR6QixnQkFDeUJBLFFBRHpCO0FBQUEsZ0JBQ21DQyxLQURuQyxnQkFDbUNBLEtBRG5DO0FBQUEsZ0JBQzBDQyxRQUQxQyxnQkFDMENBLFFBRDFDO0FBQUEsZ0JBQ29EQyxVQURwRCxnQkFDb0RBLFVBRHBEOztBQUdSOztBQUNBLGdCQUFJQyxZQUFZLEVBQWhCO0FBQ0EsaUJBQUssSUFBSUMsS0FBVCxJQUFrQlAsVUFBVSxFQUE1QjtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFnQyx5Q0FBaUJBLE9BQU9PLEtBQVAsQ0FBakI7QUFBQSw0QkFBU0MsSUFBVDtBQUFnQ0Ysa0NBQVVFLElBQVYsSUFBa0JELEtBQWxCO0FBQWhDO0FBQWhDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxhQUxRLENBT1I7QUFDQSxnQkFBSUUsWUFBWSxFQUFoQjtBQUNBLGlCQUFLLElBQUlDLEdBQVQsSUFBZ0JULFdBQVcsRUFBM0I7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFDSSwwQ0FBaUJBLFFBQVFTLEdBQVIsQ0FBakI7QUFBQSw0QkFBU0YsS0FBVDs7QUFDSUMsa0NBQVVELEtBQVYsSUFBa0JDLFVBQVVELEtBQVYsRUFBZ0JHLElBQWhCLENBQXFCRCxHQUFyQixDQUFsQixHQUE4Q0QsVUFBVUQsS0FBVixJQUFrQixDQUFDRSxHQUFELENBQWhFO0FBREo7QUFESjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsYUFJQSxPQUFPLGdDQUFTWixFQUFULEVBQWVNLFFBQWYsRUFBeUJMLE1BQU1hLEdBQU4sQ0FBVSxVQUFDSixJQUFEO0FBQUEsdUJBQ3RDLGlDQUFTVixLQUFLVSxLQUFLSyxPQUFMLENBQWEsS0FBYixFQUFvQixHQUFwQixDQUFkLEdBQTBDLDZCQUFnQjtBQUNsREMsMkJBQU87QUFDSCxzQ0FBYyxLQURYO0FBRUgsc0NBQWMsUUFGWDtBQUdILDRDQUFvQlIsVUFBVUUsSUFBVjtBQUhqQixxQkFEMkM7QUFNbEQsNkJBQVNDLFVBQVVELElBQVYsQ0FOeUM7QUFPbERPLDZCQUFTO0FBQUEsK0JBQU0sQ0FBQ2IsWUFBWWMsUUFBYixFQUF1QlIsSUFBdkIsQ0FBTjtBQUFBO0FBUHlDLGlCQUFoQjs7QUFVdEM7QUFDQUwsd0JBQVE7QUFDSmMsaUNBQWEsdUJBQVc7QUFBQ0MsMEJBQUUsSUFBRixFQUFRQyxPQUFSLENBQWdCLFFBQWhCO0FBQTBCLHFCQUQvQztBQUVKQyxnQ0FBWSxzQkFBVztBQUFDRiwwQkFBRSxJQUFGLEVBQVFDLE9BQVIsQ0FBZ0IsUUFBaEI7QUFBMEIscUJBRjlDO0FBR0osc0NBQWtCLE1BSGQ7QUFJSixvQ0FBZ0JoQixNQUFNSyxJQUFOLENBSlo7QUFLSixpQ0FBYSxNQUxUO0FBTUosMkNBQXVCQSxJQU5uQjtBQU9KLHNDQUFrQixNQVBkO0FBUUosbUNBQWUsU0FSWDtBQVNKLG9DQUFnQjtBQVRaLGlCQUFSLEdBVUksRUFyQmtDOztBQXVCdEM7QUFDQUgsMEJBeEJzQyxDQUExQyxFQXdCaUJHLElBeEJqQixDQURzQztBQUFBLGFBQVYsQ0FBekIsQ0FBUDtBQTBCSDs7Ozs7O2tCQXhDZ0JiLFMiLCJmaWxlIjoiMjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbSBmcm9tICdtaXRocmlsJ1xuaW1wb3J0IHttZXJnZUF0dHJpYnV0ZXMsIHZhckNvbG9yfSBmcm9tICcuLi9jb21tb24nXG5cbi8vIGBgYFxuLy8gbShQYW5lbExpc3QsIHtcbi8vICAgICAgICAgaWQ6ICdpZCBvZiBjb250YWluZXInLFxuLy8gICAgICAgICBpdGVtczogWydDbGlja2FibGUgMScsICdDbGlja2FibGUgMicsICdDbGlja2FibGUgMyddLFxuLy9cbi8vICAgICAgICAgY29sb3JzOiB7IGFwcC5zZWxWYXJDb2xvcjogWydDbGlja2FibGUgMSddIH0sIChvcHRpb25hbClcbi8vICAgICAgICAgY2xhc3NlczogeyAnaXRlbS1saW5lb3V0JzogWydDbGlja2FibGUgMScsICdDbGlja2FibGUgMyddIH0sIChvcHRpb25hbClcbi8vXG4vLyAgICAgICAgIGNhbGxiYWNrOiAoaXRlbSkgPT4gY29uc29sZS5sb2coaXRlbSArIFwiIGNsaWNrZWQuXCIpLFxuLy8gICAgICAgICBwb3B1cDogKGl0ZW0pID0+IHsgcmV0dXJuICdQb3B1cENvbnRlbnQnfSwgKG9wdGlvbmFsKVxuLy9cbi8vICAgICAgICAgYXR0cnNBbGw6IHsuLi4gYWRkaXRpb25hbCBhdHRyaWJ1dGVzIGZvciB0aGUgZW50aXJlIGxpc3R9LFxuLy8gICAgICAgICBhdHRyc0l0ZW1zOiB7Li4uIGFkZGl0aW9uYWwgYXR0cmlidXRlcyBmb3IgZWFjaCBpdGVtfVxuLy8gICAgIH0pXG4vLyBgYGBcblxuLy8gY29sb3JzIGlzIGFuIG9iamVjdCB0aGF0IG1hcHMgYSBjb2xvciB0byBhIGxpc3Qgb3Igc2V0IG9mIGl0ZW1zIHdpdGggdGhhdCBjb2xvci4gT3JkZXIgY29sb3JzIGJ5IGluY3JlYXNpbmcgcHJpb3JpdHkuXG4vLyBjbGFzc2VzIGFjdHMgc2ltaWxhcmx5LCBidXQgb25lIGl0ZW0gbWF5IGhhdmUgc2V2ZXJhbCBjbGFzc2VzLiBTdGFuZGFyZCBjc3MgcnVsZXMgYXBwbHkgZm9yIHN0YWNraW5nIGNzcyBjbGFzc2VzLlxuLy8gcG9wdXAgcmV0dXJucyB0aGUgcG9wdXAgY29udGVudHMgd2hlbiBjYWxsZWQgd2l0aCB0aGUgaXRlbS4gSWYgbm90IHNldCwgdGhlbiBwb3B1cCBpcyBub3QgZHJhd25cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGFuZWxMaXN0IHtcbiAgICB2aWV3KHZub2RlKSB7XG4gICAgICAgIGxldCB7aWQsIGl0ZW1zLCBjb2xvcnMsIGNsYXNzZXMsIGNhbGxiYWNrLCBwb3B1cCwgYXR0cnNBbGwsIGF0dHJzSXRlbXN9ID0gdm5vZGUuYXR0cnM7XG5cbiAgICAgICAgLy8gc2V0IGFsdGVybmF0ZSBiYWNrZ3JvdW5kLWNvbG9yIGlmIGRlZmluZWRcbiAgICAgICAgbGV0IHZpZXdDb2xvciA9IHt9O1xuICAgICAgICBmb3IgKGxldCBjb2xvciBpbiBjb2xvcnMgfHwgW10pIGZvciAobGV0IGl0ZW0gb2YgY29sb3JzW2NvbG9yXSkgdmlld0NvbG9yW2l0ZW1dID0gY29sb3I7XG5cbiAgICAgICAgLy8gaW52ZXJ0IHRoZSBjbGFzcyAtPiBpdGVtIG9iamVjdFxuICAgICAgICBsZXQgdmlld0NsYXNzID0ge307XG4gICAgICAgIGZvciAobGV0IGNzcyBpbiBjbGFzc2VzIHx8IFtdKVxuICAgICAgICAgICAgZm9yIChsZXQgaXRlbSBvZiBjbGFzc2VzW2Nzc10pXG4gICAgICAgICAgICAgICAgdmlld0NsYXNzW2l0ZW1dID8gdmlld0NsYXNzW2l0ZW1dLnB1c2goY3NzKSA6IHZpZXdDbGFzc1tpdGVtXSA9IFtjc3NdO1xuXG4gICAgICAgIHJldHVybiBtKGBkaXYjJHtpZH1gLCBhdHRyc0FsbCwgaXRlbXMubWFwKChpdGVtKSA9PlxuICAgICAgICAgICAgbShgZGl2IyR7aWQgKyBpdGVtLnJlcGxhY2UoL1xcVy9nLCAnXycpfWAsIG1lcmdlQXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbWFyZ2luLXRvcCc6ICc1cHgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RleHQtYWxpZ24nOiBcImNlbnRlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2JhY2tncm91bmQtY29sb3InOiB2aWV3Q29sb3JbaXRlbV0gfHwgdmFyQ29sb3JcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogdmlld0NsYXNzW2l0ZW1dLFxuICAgICAgICAgICAgICAgICAgICBvbmNsaWNrOiAoKSA9PiAoY2FsbGJhY2sgfHwgRnVuY3Rpb24pKGl0ZW0pXG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8vIGFkZCBwb3B1cCBpZiBkZWZpbmVkXG4gICAgICAgICAgICAgICAgcG9wdXAgPyB7XG4gICAgICAgICAgICAgICAgICAgIG9ubW91c2VvdmVyOiBmdW5jdGlvbigpIHskKHRoaXMpLnBvcG92ZXIoJ3RvZ2dsZScpfSxcbiAgICAgICAgICAgICAgICAgICAgb25tb3VzZW91dDogZnVuY3Rpb24oKSB7JCh0aGlzKS5wb3BvdmVyKCd0b2dnbGUnKX0sXG4gICAgICAgICAgICAgICAgICAgICdkYXRhLWNvbnRhaW5lcic6ICdib2R5JyxcbiAgICAgICAgICAgICAgICAgICAgJ2RhdGEtY29udGVudCc6IHBvcHVwKGl0ZW0pLFxuICAgICAgICAgICAgICAgICAgICAnZGF0YS1odG1sJzogJ3RydWUnLFxuICAgICAgICAgICAgICAgICAgICAnZGF0YS1vcmlnaW5hbC10aXRsZSc6IGl0ZW0sXG4gICAgICAgICAgICAgICAgICAgICdkYXRhLXBsYWNlbWVudCc6ICdhdXRvJyxcbiAgICAgICAgICAgICAgICAgICAgJ2RhdGEtdG9nZ2xlJzogJ3BvcG92ZXInLFxuICAgICAgICAgICAgICAgICAgICAnZGF0YS10cmlnZ2VyJzogJ2hvdmVyJ1xuICAgICAgICAgICAgICAgIH0gOiB7fSxcblxuICAgICAgICAgICAgICAgIC8vIGFkZCBhbnkgYWRkaXRpb25hbCBhdHRyaWJ1dGVzIGlmIHBhc3NlZFxuICAgICAgICAgICAgICAgIGF0dHJzSXRlbXMpLCBpdGVtKSkpO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Fzc2V0cy9jb21tb24vYXBwL3ZpZXdzL1BhbmVsTGlzdC5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///21\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mithril = __webpack_require__(0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _Header = __webpack_require__(9);\n\nvar _Header2 = _interopRequireDefault(_Header);\n\nvar _Table = __webpack_require__(11);\n\nvar _Table2 = _interopRequireDefault(_Table);\n\nvar _Canvas = __webpack_require__(30);\n\nvar _Canvas2 = _interopRequireDefault(_Canvas);\n\nvar _common = __webpack_require__(1);\n\nvar common = _interopRequireWildcard(_common);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// widget for displaying a full-page data preview\n\n// localstorage entries:\n\n// READ FIELDS\n// peekHeader: text in header label\n// peekTableHeaders: headers of table\n// peekTableData: contents of table\n\n// WRITE FIELDS\n// peekMore: boolean set by peek when the bottom of the page is scrolled to\n\nvar Peek = function () {\n    function Peek() {\n        _classCallCheck(this, Peek);\n    }\n\n    _createClass(Peek, [{\n        key: 'oncreate',\n        value: function oncreate() {\n            var _this = this;\n\n            window.addEventListener('storage', function (e) {\n                return onStorageEvent(_this, e);\n            });\n            document.getElementById('canvas').addEventListener('scroll', onScrollEvent);\n        }\n    }, {\n        key: 'oninit',\n        value: function oninit() {\n            this.header = localStorage.getItem('peekHeader') || '';\n            this.tableHeaders = JSON.parse(localStorage.getItem('peekTableHeaders')) || [];\n            this.tableData = JSON.parse(localStorage.getItem('peekTableData')) || [];\n\n            if (this.tableData.length === 0) {\n                localStorage.removeItem('peekMore');\n                localStorage.setItem('peekMore', 'true');\n            }\n        }\n    }, {\n        key: 'view',\n        value: function view() {\n            return [(0, _mithril2.default)(_Header2.default, [(0, _mithril2.default)('div', { style: { 'flex-grow': 1 } }), (0, _mithril2.default)(\"h4\", (0, _mithril2.default)(\"span#headerLabel.label.label-default\", this.header)), (0, _mithril2.default)('div', { style: { 'flex-grow': 1 } })]), (0, _mithril2.default)(_Canvas2.default, {\n                attrsAll: { style: { 'margin-top': common.heightHeader + 'px', height: 'calc(100% - ' + common.heightHeader + 'px)' } }\n            }, (0, _mithril2.default)(_Table2.default, {\n                id: 'peekTable',\n                headers: this.tableHeaders,\n                data: this.tableData,\n                attrsAll: { style: { overflow: 'auto' } }\n            }))];\n        }\n    }]);\n\n    return Peek;\n}();\n\nexports.default = Peek;\n\n\nfunction onScrollEvent() {\n    var canvas = document.getElementById('canvas');\n    if (canvas.scrollTop + canvas.clientHeight === canvas.scrollHeight) {\n        localStorage.removeItem('peekMore');\n        localStorage.setItem('peekMore', 'true');\n    }\n}\n\nfunction onStorageEvent(peek, e) {\n    if (e.key !== 'peekTableData') return;\n\n    peek.header = localStorage.getItem('peekHeader');\n    peek.tableHeaders = JSON.parse(localStorage.getItem('peekTableHeaders')) || [];\n    peek.tableData = JSON.parse(localStorage.getItem('peekTableData')) || [];\n\n    if (peek.tableData.length === 0) localStorage.setItem('peekMore', 'true');\n    _mithril2.default.redraw();\n}\n\n// Adapt the following code in your codebase to update the Peek tab\n\n/*\nlet peekBatchSize = 100;\nlet peekSkip = 0;\nlet peekData = [];\n\nlet peekAllDataReceived = false;\nlet peekIsGetting = false;\n\nfunction onStorageEvent(e) {\n    if (e.key !== 'peekMore' || peekIsGetting) return;\n\n    if (localStorage.getItem('peekMore') === 'true' && !peekAllDataReceived) {\n        localStorage.setItem('peekMore', 'false');\n        peekIsGetting = true;\n        updatePeek();\n    }\n}\nwindow.addEventListener('storage', onStorageEvent);\n\nfunction updatePeek() {\n    m.request({\n        method: 'POST',\n        url: data_url,\n        data: {\n            skip: peekSkip,\n            limit: peekBatchSize,\n        }\n    }).then((response) => {\n        // stop blocking new requests\n        peekIsGetting = false;\n\n        let newData = response['data'];\n\n        // start blocking new requests until peekReset() is called\n        if (newData.length === 0) peekAllDataReceived = true;\n\n        peekData = peekData.concat(newData);\n        peekSkip += newData.length;\n\n        localStorage.setItem('peekTableHeaders', JSON.stringify(headers));\n        localStorage.setItem('peekTableData', JSON.stringify(peekData));\n    });\n}\n\nfunction resetPeek() {\n    peekSkip = 0;\n    peekData = [];\n\n    peekAllDataReceived = false;\n    peekIsGetting = false;\n\n    // provoke a redraw from the peek menu\n    localStorage.removeItem('peekTableData');\n}\n*///# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvY29tbW9uL2FwcC92aWV3cy9QZWVrLmpzP2E5OGYiXSwibmFtZXMiOlsiY29tbW9uIiwiUGVlayIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJlIiwib25TdG9yYWdlRXZlbnQiLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwib25TY3JvbGxFdmVudCIsImhlYWRlciIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJ0YWJsZUhlYWRlcnMiLCJKU09OIiwicGFyc2UiLCJ0YWJsZURhdGEiLCJsZW5ndGgiLCJyZW1vdmVJdGVtIiwic2V0SXRlbSIsInN0eWxlIiwiYXR0cnNBbGwiLCJoZWlnaHRIZWFkZXIiLCJoZWlnaHQiLCJpZCIsImhlYWRlcnMiLCJkYXRhIiwib3ZlcmZsb3ciLCJjYW52YXMiLCJzY3JvbGxUb3AiLCJjbGllbnRIZWlnaHQiLCJzY3JvbGxIZWlnaHQiLCJwZWVrIiwia2V5IiwicmVkcmF3Il0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7O0FBRUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0lBQVlBLE07Ozs7Ozs7O0FBRVo7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7SUFFcUJDLEk7Ozs7Ozs7bUNBQ047QUFBQTs7QUFDUEMsbUJBQU9DLGdCQUFQLENBQXdCLFNBQXhCLEVBQW1DLFVBQUNDLENBQUQ7QUFBQSx1QkFBT0Msc0JBQXFCRCxDQUFyQixDQUFQO0FBQUEsYUFBbkM7QUFDQUUscUJBQVNDLGNBQVQsQ0FBd0IsUUFBeEIsRUFBa0NKLGdCQUFsQyxDQUFtRCxRQUFuRCxFQUE2REssYUFBN0Q7QUFDSDs7O2lDQUVRO0FBQ0wsaUJBQUtDLE1BQUwsR0FBY0MsYUFBYUMsT0FBYixDQUFxQixZQUFyQixLQUFzQyxFQUFwRDtBQUNBLGlCQUFLQyxZQUFMLEdBQW9CQyxLQUFLQyxLQUFMLENBQVdKLGFBQWFDLE9BQWIsQ0FBcUIsa0JBQXJCLENBQVgsS0FBd0QsRUFBNUU7QUFDQSxpQkFBS0ksU0FBTCxHQUFpQkYsS0FBS0MsS0FBTCxDQUFXSixhQUFhQyxPQUFiLENBQXFCLGVBQXJCLENBQVgsS0FBcUQsRUFBdEU7O0FBRUEsZ0JBQUksS0FBS0ksU0FBTCxDQUFlQyxNQUFmLEtBQTBCLENBQTlCLEVBQWlDO0FBQzdCTiw2QkFBYU8sVUFBYixDQUF3QixVQUF4QjtBQUNBUCw2QkFBYVEsT0FBYixDQUFxQixVQUFyQixFQUFpQyxNQUFqQztBQUNIO0FBQ0o7OzsrQkFFTTtBQUNILG1CQUFPLENBQ0gseUNBQVUsQ0FDTix1QkFBRSxLQUFGLEVBQVMsRUFBQ0MsT0FBTyxFQUFDLGFBQWEsQ0FBZCxFQUFSLEVBQVQsQ0FETSxFQUVOLHVCQUFFLElBQUYsRUFBUSx1QkFBRSxzQ0FBRixFQUEwQyxLQUFLVixNQUEvQyxDQUFSLENBRk0sRUFHTix1QkFBRSxLQUFGLEVBQVMsRUFBQ1UsT0FBTyxFQUFDLGFBQWEsQ0FBZCxFQUFSLEVBQVQsQ0FITSxDQUFWLENBREcsRUFNSCx5Q0FBVTtBQUNGQywwQkFBVSxFQUFDRCxPQUFPLEVBQUMsY0FBY25CLE9BQU9xQixZQUFQLEdBQXNCLElBQXJDLEVBQTJDQyx5QkFBdUJ0QixPQUFPcUIsWUFBOUIsUUFBM0MsRUFBUjtBQURSLGFBQVYsRUFFTyx3Q0FBUztBQUNSRSxvQkFBSSxXQURJO0FBRVJDLHlCQUFTLEtBQUtaLFlBRk47QUFHUmEsc0JBQU0sS0FBS1YsU0FISDtBQUlSSywwQkFBVSxFQUFDRCxPQUFPLEVBQUNPLFVBQVUsTUFBWCxFQUFSO0FBSkYsYUFBVCxDQUZQLENBTkcsQ0FBUDtBQWdCSDs7Ozs7O2tCQWxDZ0J6QixJOzs7QUFxQ3JCLFNBQVNPLGFBQVQsR0FBeUI7QUFDckIsUUFBSW1CLFNBQVNyQixTQUFTQyxjQUFULENBQXdCLFFBQXhCLENBQWI7QUFDQSxRQUFJb0IsT0FBT0MsU0FBUCxHQUFtQkQsT0FBT0UsWUFBMUIsS0FBMkNGLE9BQU9HLFlBQXRELEVBQW9FO0FBQ2hFcEIscUJBQWFPLFVBQWIsQ0FBd0IsVUFBeEI7QUFDQVAscUJBQWFRLE9BQWIsQ0FBcUIsVUFBckIsRUFBaUMsTUFBakM7QUFDSDtBQUNKOztBQUVELFNBQVNiLGNBQVQsQ0FBeUIwQixJQUF6QixFQUErQjNCLENBQS9CLEVBQWtDO0FBQzlCLFFBQUlBLEVBQUU0QixHQUFGLEtBQVUsZUFBZCxFQUErQjs7QUFFL0JELFNBQUt0QixNQUFMLEdBQWNDLGFBQWFDLE9BQWIsQ0FBcUIsWUFBckIsQ0FBZDtBQUNBb0IsU0FBS25CLFlBQUwsR0FBb0JDLEtBQUtDLEtBQUwsQ0FBV0osYUFBYUMsT0FBYixDQUFxQixrQkFBckIsQ0FBWCxLQUF3RCxFQUE1RTtBQUNBb0IsU0FBS2hCLFNBQUwsR0FBaUJGLEtBQUtDLEtBQUwsQ0FBV0osYUFBYUMsT0FBYixDQUFxQixlQUFyQixDQUFYLEtBQXFELEVBQXRFOztBQUVBLFFBQUlvQixLQUFLaEIsU0FBTCxDQUFlQyxNQUFmLEtBQTBCLENBQTlCLEVBQWlDTixhQUFhUSxPQUFiLENBQXFCLFVBQXJCLEVBQWlDLE1BQWpDO0FBQ2pDLHNCQUFFZSxNQUFGO0FBQ0g7O0FBRUQ7O0FBRUEiLCJmaWxlIjoiMjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbSBmcm9tICdtaXRocmlsJ1xuXG5pbXBvcnQgSGVhZGVyIGZyb20gJy4vSGVhZGVyJztcbmltcG9ydCBUYWJsZSBmcm9tICcuL1RhYmxlJztcbmltcG9ydCBDYW52YXMgZnJvbSAnLi9DYW52YXMnO1xuaW1wb3J0ICogYXMgY29tbW9uIGZyb20gXCIuLi9jb21tb25cIjtcblxuLy8gd2lkZ2V0IGZvciBkaXNwbGF5aW5nIGEgZnVsbC1wYWdlIGRhdGEgcHJldmlld1xuXG4vLyBsb2NhbHN0b3JhZ2UgZW50cmllczpcblxuLy8gUkVBRCBGSUVMRFNcbi8vIHBlZWtIZWFkZXI6IHRleHQgaW4gaGVhZGVyIGxhYmVsXG4vLyBwZWVrVGFibGVIZWFkZXJzOiBoZWFkZXJzIG9mIHRhYmxlXG4vLyBwZWVrVGFibGVEYXRhOiBjb250ZW50cyBvZiB0YWJsZVxuXG4vLyBXUklURSBGSUVMRFNcbi8vIHBlZWtNb3JlOiBib29sZWFuIHNldCBieSBwZWVrIHdoZW4gdGhlIGJvdHRvbSBvZiB0aGUgcGFnZSBpcyBzY3JvbGxlZCB0b1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQZWVrIHtcbiAgICBvbmNyZWF0ZSgpIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3N0b3JhZ2UnLCAoZSkgPT4gb25TdG9yYWdlRXZlbnQodGhpcywgZSkpO1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2FudmFzJykuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgb25TY3JvbGxFdmVudCk7XG4gICAgfVxuXG4gICAgb25pbml0KCkge1xuICAgICAgICB0aGlzLmhlYWRlciA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdwZWVrSGVhZGVyJykgfHwgJyc7XG4gICAgICAgIHRoaXMudGFibGVIZWFkZXJzID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgncGVla1RhYmxlSGVhZGVycycpKSB8fCBbXTtcbiAgICAgICAgdGhpcy50YWJsZURhdGEgPSBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdwZWVrVGFibGVEYXRhJykpIHx8IFtdO1xuXG4gICAgICAgIGlmICh0aGlzLnRhYmxlRGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdwZWVrTW9yZScpO1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3BlZWtNb3JlJywgJ3RydWUnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZpZXcoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBtKEhlYWRlciwgW1xuICAgICAgICAgICAgICAgIG0oJ2RpdicsIHtzdHlsZTogeydmbGV4LWdyb3cnOiAxfX0pLFxuICAgICAgICAgICAgICAgIG0oXCJoNFwiLCBtKFwic3BhbiNoZWFkZXJMYWJlbC5sYWJlbC5sYWJlbC1kZWZhdWx0XCIsIHRoaXMuaGVhZGVyKSksXG4gICAgICAgICAgICAgICAgbSgnZGl2Jywge3N0eWxlOiB7J2ZsZXgtZ3Jvdyc6IDF9fSksXG4gICAgICAgICAgICBdKSxcbiAgICAgICAgICAgIG0oQ2FudmFzLCB7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJzQWxsOiB7c3R5bGU6IHsnbWFyZ2luLXRvcCc6IGNvbW1vbi5oZWlnaHRIZWFkZXIgKyAncHgnLCBoZWlnaHQ6IGBjYWxjKDEwMCUgLSAke2NvbW1vbi5oZWlnaHRIZWFkZXJ9cHgpYH19XG4gICAgICAgICAgICAgICAgfSwgbShUYWJsZSwge1xuICAgICAgICAgICAgICAgICAgICBpZDogJ3BlZWtUYWJsZScsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMudGFibGVIZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB0aGlzLnRhYmxlRGF0YSxcbiAgICAgICAgICAgICAgICAgICAgYXR0cnNBbGw6IHtzdHlsZToge292ZXJmbG93OiAnYXV0byd9fVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApXG4gICAgICAgIF1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIG9uU2Nyb2xsRXZlbnQoKSB7XG4gICAgbGV0IGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYW52YXMnKTtcbiAgICBpZiAoY2FudmFzLnNjcm9sbFRvcCArIGNhbnZhcy5jbGllbnRIZWlnaHQgPT09IGNhbnZhcy5zY3JvbGxIZWlnaHQpIHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3BlZWtNb3JlJyk7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdwZWVrTW9yZScsICd0cnVlJyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBvblN0b3JhZ2VFdmVudCAocGVlaywgZSkge1xuICAgIGlmIChlLmtleSAhPT0gJ3BlZWtUYWJsZURhdGEnKSByZXR1cm47XG5cbiAgICBwZWVrLmhlYWRlciA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdwZWVrSGVhZGVyJyk7XG4gICAgcGVlay50YWJsZUhlYWRlcnMgPSBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdwZWVrVGFibGVIZWFkZXJzJykpIHx8IFtdO1xuICAgIHBlZWsudGFibGVEYXRhID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgncGVla1RhYmxlRGF0YScpKSB8fCBbXTtcblxuICAgIGlmIChwZWVrLnRhYmxlRGF0YS5sZW5ndGggPT09IDApIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdwZWVrTW9yZScsICd0cnVlJyk7XG4gICAgbS5yZWRyYXcoKTtcbn1cblxuLy8gQWRhcHQgdGhlIGZvbGxvd2luZyBjb2RlIGluIHlvdXIgY29kZWJhc2UgdG8gdXBkYXRlIHRoZSBQZWVrIHRhYlxuXG4vKlxubGV0IHBlZWtCYXRjaFNpemUgPSAxMDA7XG5sZXQgcGVla1NraXAgPSAwO1xubGV0IHBlZWtEYXRhID0gW107XG5cbmxldCBwZWVrQWxsRGF0YVJlY2VpdmVkID0gZmFsc2U7XG5sZXQgcGVla0lzR2V0dGluZyA9IGZhbHNlO1xuXG5mdW5jdGlvbiBvblN0b3JhZ2VFdmVudChlKSB7XG4gICAgaWYgKGUua2V5ICE9PSAncGVla01vcmUnIHx8IHBlZWtJc0dldHRpbmcpIHJldHVybjtcblxuICAgIGlmIChsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgncGVla01vcmUnKSA9PT0gJ3RydWUnICYmICFwZWVrQWxsRGF0YVJlY2VpdmVkKSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdwZWVrTW9yZScsICdmYWxzZScpO1xuICAgICAgICBwZWVrSXNHZXR0aW5nID0gdHJ1ZTtcbiAgICAgICAgdXBkYXRlUGVlaygpO1xuICAgIH1cbn1cbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzdG9yYWdlJywgb25TdG9yYWdlRXZlbnQpO1xuXG5mdW5jdGlvbiB1cGRhdGVQZWVrKCkge1xuICAgIG0ucmVxdWVzdCh7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICB1cmw6IGRhdGFfdXJsLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBza2lwOiBwZWVrU2tpcCxcbiAgICAgICAgICAgIGxpbWl0OiBwZWVrQmF0Y2hTaXplLFxuICAgICAgICB9XG4gICAgfSkudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgLy8gc3RvcCBibG9ja2luZyBuZXcgcmVxdWVzdHNcbiAgICAgICAgcGVla0lzR2V0dGluZyA9IGZhbHNlO1xuXG4gICAgICAgIGxldCBuZXdEYXRhID0gcmVzcG9uc2VbJ2RhdGEnXTtcblxuICAgICAgICAvLyBzdGFydCBibG9ja2luZyBuZXcgcmVxdWVzdHMgdW50aWwgcGVla1Jlc2V0KCkgaXMgY2FsbGVkXG4gICAgICAgIGlmIChuZXdEYXRhLmxlbmd0aCA9PT0gMCkgcGVla0FsbERhdGFSZWNlaXZlZCA9IHRydWU7XG5cbiAgICAgICAgcGVla0RhdGEgPSBwZWVrRGF0YS5jb25jYXQobmV3RGF0YSk7XG4gICAgICAgIHBlZWtTa2lwICs9IG5ld0RhdGEubGVuZ3RoO1xuXG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdwZWVrVGFibGVIZWFkZXJzJywgSlNPTi5zdHJpbmdpZnkoaGVhZGVycykpO1xuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgncGVla1RhYmxlRGF0YScsIEpTT04uc3RyaW5naWZ5KHBlZWtEYXRhKSk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlc2V0UGVlaygpIHtcbiAgICBwZWVrU2tpcCA9IDA7XG4gICAgcGVla0RhdGEgPSBbXTtcblxuICAgIHBlZWtBbGxEYXRhUmVjZWl2ZWQgPSBmYWxzZTtcbiAgICBwZWVrSXNHZXR0aW5nID0gZmFsc2U7XG5cbiAgICAvLyBwcm92b2tlIGEgcmVkcmF3IGZyb20gdGhlIHBlZWsgbWVudVxuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdwZWVrVGFibGVEYXRhJyk7XG59XG4qL1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYXNzZXRzL2NvbW1vbi9hcHAvdmlld3MvUGVlay5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///22\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mithril = __webpack_require__(0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _common = __webpack_require__(1);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// ```\n// m(TextField, {\n//     id: string,\n//     cancellable: Bool NOT IMPLEMENTED\n//     *: any attribute may be passed\n//     })\n// ```\n\n// Can pass attributes directly, for example 'placeholder' or 'oninput'\n\nvar TextField = function () {\n    function TextField() {\n        _classCallCheck(this, TextField);\n    }\n\n    _createClass(TextField, [{\n        key: 'view',\n        value: function view(vnode) {\n            var _vnode$attrs = vnode.attrs,\n                id = _vnode$attrs.id,\n                cancellable = _vnode$attrs.cancellable;\n\n\n            return (0, _mithril2.default)('input#' + id + '.form-control', (0, _common.mergeAttributes)({\n                style: { 'margin': '5px 0', 'width': '100%' }\n            }, vnode.attrs, { oninput: _mithril2.default.withAttr('value', vnode.attrs.oninput) }));\n        }\n    }]);\n\n    return TextField;\n}();\n\nexports.default = TextField;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvY29tbW9uL2FwcC92aWV3cy9UZXh0RmllbGQuanM/OWFkMSJdLCJuYW1lcyI6WyJUZXh0RmllbGQiLCJ2bm9kZSIsImF0dHJzIiwiaWQiLCJjYW5jZWxsYWJsZSIsInN0eWxlIiwib25pbnB1dCIsIndpdGhBdHRyIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7O0FBQ0E7Ozs7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztJQUVxQkEsUzs7Ozs7Ozs2QkFDWkMsSyxFQUFPO0FBQUEsK0JBQ2dCQSxNQUFNQyxLQUR0QjtBQUFBLGdCQUNIQyxFQURHLGdCQUNIQSxFQURHO0FBQUEsZ0JBQ0NDLFdBREQsZ0JBQ0NBLFdBREQ7OztBQUdSLG1CQUFPLGtDQUFXRCxFQUFYLG9CQUE4Qiw2QkFBZ0I7QUFDN0NFLHVCQUFPLEVBQUMsVUFBVSxPQUFYLEVBQW9CLFNBQVMsTUFBN0I7QUFEc0MsYUFBaEIsRUFHakNKLE1BQU1DLEtBSDJCLEVBSWpDLEVBQUNJLFNBQVMsa0JBQUVDLFFBQUYsQ0FBVyxPQUFYLEVBQW9CTixNQUFNQyxLQUFOLENBQVlJLE9BQWhDLENBQVYsRUFKaUMsQ0FBOUIsQ0FBUDtBQU1IOzs7Ozs7a0JBVmdCTixTIiwiZmlsZSI6IjIzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCdcbmltcG9ydCB7bWVyZ2VBdHRyaWJ1dGVzfSBmcm9tIFwiLi4vY29tbW9uXCI7XG5cbi8vIGBgYFxuLy8gbShUZXh0RmllbGQsIHtcbi8vICAgICBpZDogc3RyaW5nLFxuLy8gICAgIGNhbmNlbGxhYmxlOiBCb29sIE5PVCBJTVBMRU1FTlRFRFxuLy8gICAgICo6IGFueSBhdHRyaWJ1dGUgbWF5IGJlIHBhc3NlZFxuLy8gICAgIH0pXG4vLyBgYGBcblxuLy8gQ2FuIHBhc3MgYXR0cmlidXRlcyBkaXJlY3RseSwgZm9yIGV4YW1wbGUgJ3BsYWNlaG9sZGVyJyBvciAnb25pbnB1dCdcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGV4dEZpZWxkIHtcbiAgICB2aWV3KHZub2RlKSB7XG4gICAgICAgIGxldCB7aWQsIGNhbmNlbGxhYmxlfSA9IHZub2RlLmF0dHJzO1xuXG4gICAgICAgIHJldHVybiBtKGBpbnB1dCMke2lkfS5mb3JtLWNvbnRyb2xgLCBtZXJnZUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgIHN0eWxlOiB7J21hcmdpbic6ICc1cHggMCcsICd3aWR0aCc6ICcxMDAlJ31cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2bm9kZS5hdHRycyxcbiAgICAgICAgICAgIHtvbmlucHV0OiBtLndpdGhBdHRyKCd2YWx1ZScsIHZub2RlLmF0dHJzLm9uaW5wdXQpfSlcbiAgICAgICAgKTtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9hc3NldHMvY29tbW9uL2FwcC92aWV3cy9UZXh0RmllbGQuanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///23\n")},function(module,exports){eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvY3NzL2FwcC5jc3M/MmY3ZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIyNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hc3NldHMvY3NzL2FwcC5jc3Ncbi8vIG1vZHVsZSBpZCA9IDI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///24\n")},function(module,exports){eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvcGtncy9MYWRkYS9kaXN0L2xhZGRhLXRoZW1lbGVzcy5taW4uY3NzP2E2ZTEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiMjUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYXNzZXRzL3BrZ3MvTGFkZGEvZGlzdC9sYWRkYS10aGVtZWxlc3MubWluLmNzc1xuLy8gbW9kdWxlIGlkID0gMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///25\n")},function(module,exports){eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvcGtncy9ib290c3RyYXAvY3NzL2Jvb3RzdHJhcC10aGVtZS5taW4uY3NzP2ZiNzQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiMjYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYXNzZXRzL3BrZ3MvYm9vdHN0cmFwL2Nzcy9ib290c3RyYXAtdGhlbWUubWluLmNzc1xuLy8gbW9kdWxlIGlkID0gMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///26\n")},function(module,exports){eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2hvcHNjb3RjaC9kaXN0L2Nzcy9ob3BzY290Y2guY3NzPzYyZmEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiMjcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9ob3BzY290Y2gvZGlzdC9jc3MvaG9wc2NvdGNoLmNzc1xuLy8gbW9kdWxlIGlkID0gMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///27\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n__webpack_require__(24);\n\n__webpack_require__(26);\n\n__webpack_require__(25);\n\n__webpack_require__(27);\n\nvar _hopscotch = __webpack_require__(12);\n\nvar _hopscotch2 = _interopRequireDefault(_hopscotch);\n\nvar _mithril = __webpack_require__(0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _app = __webpack_require__(2);\n\nvar app = _interopRequireWildcard(_app);\n\nvar _explore = __webpack_require__(14);\n\nvar exp = _interopRequireWildcard(_explore);\n\nvar _layout = __webpack_require__(15);\n\nvar layout = _interopRequireWildcard(_layout);\n\nvar _results = __webpack_require__(16);\n\nvar results = _interopRequireWildcard(_results);\n\nvar _utils = __webpack_require__(3);\n\nvar _PanelButton = __webpack_require__(6);\n\nvar _PanelButton2 = _interopRequireDefault(_PanelButton);\n\nvar _PanelList = __webpack_require__(7);\n\nvar _PanelList2 = _interopRequireDefault(_PanelList);\n\nvar _Search = __webpack_require__(5);\n\nvar _Search2 = _interopRequireDefault(_Search);\n\nvar _Subpanel = __webpack_require__(17);\n\nvar _Subpanel2 = _interopRequireDefault(_Subpanel);\n\nvar _common = __webpack_require__(1);\n\nvar common = _interopRequireWildcard(_common);\n\nvar _ButtonRadio = __webpack_require__(8);\n\nvar _ButtonRadio2 = _interopRequireDefault(_ButtonRadio);\n\nvar _Footer = __webpack_require__(18);\n\nvar _Footer2 = _interopRequireDefault(_Footer);\n\nvar _Header = __webpack_require__(9);\n\nvar _Header2 = _interopRequireDefault(_Header);\n\nvar _MenuTabbed = __webpack_require__(19);\n\nvar _MenuTabbed2 = _interopRequireDefault(_MenuTabbed);\n\nvar _Modal = __webpack_require__(10);\n\nvar _Modal2 = _interopRequireDefault(_Modal);\n\nvar _Panel = __webpack_require__(20);\n\nvar _Panel2 = _interopRequireDefault(_Panel);\n\nvar _PanelList3 = __webpack_require__(21);\n\nvar _PanelList4 = _interopRequireDefault(_PanelList3);\n\nvar _Peek = __webpack_require__(22);\n\nvar _Peek2 = _interopRequireDefault(_Peek);\n\nvar _Table = __webpack_require__(11);\n\nvar _Table2 = _interopRequireDefault(_Table);\n\nvar _TextField = __webpack_require__(23);\n\nvar _TextField2 = _interopRequireDefault(_TextField);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar state = {\n    pipelines: [],\n    get_pipelines: async function get_pipelines() {\n        this.pipelines = await app.listpipelines();\n        _mithril2.default.redraw();\n    }\n};\n\nfunction setBackgroundColor(color) {\n    return function () {\n        this.style['background-color'] = color;\n    };\n}\n\nfunction leftpanel(mode) {\n    var _colors;\n\n    if (mode === 'results') {\n        return results.leftpanel(Object.keys(app.allPipelineInfo));\n    }\n\n    var discoveryAllCheck = (0, _mithril2.default)('input#discoveryAllCheck[type=checkbox]', {\n        onclick: _mithril2.default.withAttr(\"checked\", function (checked) {\n            return app.setCheckedDiscoveryProblem(checked);\n        }),\n        checked: app.probtable.length === app.checkedDiscoveryProblems.size\n    });\n    var discoveryTableData = app.probtable.map(function (problem) {\n        return [].concat(_toConsumableArray(problem), [(0, _mithril2.default)('input[type=checkbox]', {\n            onclick: _mithril2.default.withAttr(\"checked\", function (checked) {\n                return app.setCheckedDiscoveryProblem(checked, problem[0]);\n            }),\n            checked: app.checkedDiscoveryProblems.has(problem[0])\n        })]);\n    });\n\n    return (0, _mithril2.default)(_Panel2.default, {\n        side: 'left',\n        label: 'Data Selection',\n        hover: true,\n        width: app.modelLeftPanelWidths[app.leftTab],\n        attrsAll: { style: { 'z-index': 101 } }\n    }, (0, _mithril2.default)(_MenuTabbed2.default, {\n        id: 'leftpanelMenu',\n        attrsAll: { style: { height: 'calc(100% - 39px)' } },\n        currentTab: app.leftTab,\n        callback: app.setLeftTab,\n        sections: [{ value: 'Variables',\n            title: 'Click variable name to add or remove the variable pebble from the modeling space.',\n            contents: [(0, _mithril2.default)(_TextField2.default, {\n                id: 'searchVar',\n                placeholder: 'Search variables and labels',\n                oninput: app.searchVariables\n            }), (0, _mithril2.default)(_PanelList4.default, {\n                id: 'varList',\n                items: app.valueKey,\n                colors: (_colors = {}, _defineProperty(_colors, app.hexToRgba(common.selVarColor), app.nodes.map(function (n) {\n                    return n.name;\n                })), _defineProperty(_colors, app.hexToRgba(common.nomColor), app.zparams.znom), _defineProperty(_colors, app.hexToRgba(common.dvColor), app.zparams.zdv), _colors),\n                classes: { 'item-bordered': app.matchedVariables },\n                callback: app.clickVar,\n                popup: function popup(variable) {\n                    return app.popoverContent(app.findNodeIndex(variable, true));\n                },\n                attrsItems: { 'data-placement': 'right', 'data-original-title': 'Summary Statistics' } })] }, { value: 'Discovery',\n            contents: [(0, _mithril2.default)(_Table2.default, {\n                id: 'discoveryTable',\n                headers: ['Hidden_UID', 'Target', 'Predictors', 'Task', 'Metric', discoveryAllCheck],\n                data: discoveryTableData,\n                activeRow: app.selectedProblem,\n                onclick: app.setSelectedProblem,\n                showUID: false,\n                abbreviation: 40,\n                attrsAll: { style: { height: '80%', overflow: 'auto', display: 'block', 'margin-right': '16px', 'margin-bottom': 0, 'max-width': window.innerWidth - 90 + 'px' } }\n            }), (0, _mithril2.default)('textarea#discoveryInput[style=display:block; float: left; width: 100%; height:calc(20% - 35px); overflow: auto; background-color: white]', {\n                value: app.disco[app.selectedProblem] === undefined ? '' : app.disco[app.selectedProblem].description\n            }), (0, _mithril2.default)(_PanelButton2.default, { id: 'btnSave', onclick: function onclick(_) {\n                    return app.saveDisc('btnSave');\n                }, title: 'Saves your revised problem description.' }, 'Save Desc.'), (0, _mithril2.default)(_PanelButton2.default, { id: 'btnSubmitDisc', classes: 'btn-success', style: 'float: right', onclick: function onclick(_) {\n                    return app.submitDiscProb();\n                }, title: 'Submit all checked discovered problems.' }, 'Submit Disc. Probs.')] }, { value: 'Summary',\n            title: 'Select a variable from within the visualization in the center panel to view its summary statistics.',\n            contents: [(0, _mithril2.default)('center', (0, _mithril2.default)('b', app.summary.name), (0, _mithril2.default)('br'), (0, _mithril2.default)('i', app.summary.labl)), (0, _mithril2.default)('table', app.summary.data.map(function (tr) {\n                return (0, _mithril2.default)('tr', tr.map(function (td) {\n                    return (0, _mithril2.default)('td', { onmouseover: setBackgroundColor('aliceblue'),\n                        onmouseout: setBackgroundColor('f9f9f9') }, td);\n                }));\n            }))],\n            display: 'none' }]\n    }));\n}\n\nvar righttab = function righttab(id, task, title, probDesc) {\n    return (0, _mithril2.default)(_PanelList4.default, {\n        id: id,\n        items: Object.keys(task || {}),\n        colors: _defineProperty({}, app.hexToRgba(common.selVarColor), [app.d3mProblemDescription[probDesc]]),\n        classes: {\n            'item-lineout': Object.keys(task || {}).filter(function (item) {\n                return app.locktoggle && item !== app.d3mProblemDescription[probDesc];\n            })\n        },\n        callback: function callback(value) {\n            return app.setD3mProblemDescription(probDesc, value);\n        },\n        popup: function popup(v) {\n            return task[v][1];\n        },\n        attrsItems: { 'data-placement': 'top', 'data-original-title': title + ' Description' }\n    });\n};\n\nfunction rightpanel(mode) {\n    var thumb = function thumb(idx, id, title) {\n        return (0, _mithril2.default)(\"th\", (0, _mithril2.default)(\"figure\", { style: { float: \"left\" } }, (0, _mithril2.default)('img#' + id + '_img[alt=' + id + '][src=/static/images/thumb' + idx + '.png]', { style: { width: \"75%\", height: \"75%\", border: \"1px solid #ddd\", \"border-radius\": \"3px\", padding: \"5px\", margin: \"3%\", cursor: \"pointer\" } }), (0, _mithril2.default)(\"figcaption\", { style: { \"text-align\": \"center\" } }, title)));\n    };\n\n    if (mode === 'results') return [];\n    if (mode === 'explore') {\n        var sectionsExplore = [{\n            value: 'Univariate',\n            contents: [(0, _mithril2.default)('#decision_prompt', 'Right click pebble variables to draw links between them. Select a variable in the list of linked pebbles below to draw a decision tree for that variable.'), (0, _mithril2.default)('#decisionTree[style=width: 100%; height:80%; overflow-y:scroll; float: left; white-space: nowrap; margin-top: 2px;]'), (0, _mithril2.default)(_PanelList4.default, {\n                id: 'varListExplore',\n                items: app.nodes.map(function (n) {\n                    return n.name;\n                }),\n                colors: _defineProperty({}, app.hexToRgba(common.selVarColor), [exp.exploreVar]),\n                callback: function callback(variable) {\n                    return exp.callTreeApp(variable, app);\n                },\n                attrsAll: { style: { float: 'left', width: '100%', height: '20%' } }\n            })\n            // m('#varList[style=display: block]',\n            //     unique_link_names().map(x => m(`p#${x.replace(/\\W/g, '_')}`, {onclick: _=> exp.callTreeApp(x, app), style: {'background-color': app.varColor}}, x))))\n            ]\n        }, {\n            value: 'Bivariate',\n            contents: [(0, _mithril2.default)('#result_prompt', { style: { display: app.explored ? 'none' : 'block' } }, 'Click \\'Explore\\' for interactive plots.'), (0, _mithril2.default)('#modelView_Container', { style: 'width: 100%; float: left; white-space: nowrap;' }, (0, _mithril2.default)('#modelView', { style: 'width: 100%; float: left' })), app.pipelineTable ? (0, _mithril2.default)(_Table2.default, {\n                id: 'pipelineTableExplore',\n                headers: app.pipelineHeader,\n                data: app.pipelineTable,\n                activeRow: app.selectedPipeline[app.currentMode],\n                onclick: app.setSelectedPipeline,\n                showUID: false,\n                abbreviation: 20\n            }) : undefined, (0, _mithril2.default)('#result_left', { style: { display: app.explored ? 'block' : 'none',\n                    \"width\": \"50%\", \"height\": \"100%\",\n                    \"float\": \"left\", \"overflow-y\": \"auto\",\n                    \"white-space\": \"nowrap\", \"padding-right\": \"10px\" } }, (0, _mithril2.default)('#left_thumbnail', { style: { \"width\": \"100%\", \"white-space\": \"nowrap\" } }, thumb(1, 'scatterplot', \"Scatter Plot\"), thumb(2, 'heatmap', \"Heatmap\"), thumb(3, 'linechart', \"Linechart\")), (0, _mithril2.default)('#result_left1', { style: { width: \"100%\", \"text-align\": \"center\", \"white-space\": \"nowrap\" } }, (0, _mithril2.default)(\".container3[id=scatterplot]\", { style: { \"width\": \"500px\", \"height\": \"80%\", \"float\": \"left\", \"overflow\": \"hidden\" } }), (0, _mithril2.default)(\".container4[id=heatchart]\", { style: { \"display\": \"none\", \"width\": \"500px\", \"height\": \"80%\", \"float\": \"left\", \"overflow\": \"hidden\" } }), (0, _mithril2.default)(\".container4[id=linechart]\", { style: { \"display\": \"none\", \"width\": \"500px\", \"height\": \"80%\", \"float\": \"left\", \"overflow\": \"hidden\" } })), (0, _mithril2.default)(\"div\", { style: { \"display\": \"inline-block\", \"width\": \"100%\", \"float\": \"left\", \"text-align\": \"center\" } }, (0, _mithril2.default)(\"h5#NAcount\", { style: { \" margin-bottom\": \"0\" } })), (0, _mithril2.default)(\".container2[id='resultsView_statistics']\", { style: { \"width\": \"100%\", \"float\": \"left\", \"white-space\": \"nowrap\" } })), (0, _mithril2.default)('#result_right', { style: { display: app.explored ? 'block' : 'none',\n                    width: \"50%\", height: \"100%\",\n                    float: \"right\", \"white-space\": \"nowrap\", \"padding-left\": \"10px\" } }, (0, _mithril2.default)('#resultsView_tabular.container1', { style: { width: \"100%\", height: \"100%\", float: \"left\", overflow: \"auto\", \"white-space\": \"nowrap\" } }, (0, _mithril2.default)('#SelectionData', { style: { width: \"100%\" } }, (0, _mithril2.default)(\"fieldset\", (0, _mithril2.default)(\"h4\", { style: { \"text-align\": \"center\" } }, \"Data Distribution Selection\"), (0, _mithril2.default)(\"p\", \"Enter number for each variable to specify the break points, and select between Equidistant/Equimass\")), (0, _mithril2.default)('#plotBreakInputs', { style: { height: '60px' } }, (0, _mithril2.default)('#forPlotA', { style: { display: 'inline', float: \"left\", width: '50%' } }, (0, _mithril2.default)(\"input#input1[name='fname'][type='text']\", { style: { \"margin-left\": \"2%\" } }), (0, _mithril2.default)('span#tooltipPlotA.tooltiptext[style=visibility: hidden]'), (0, _mithril2.default)(\"button.btn.btn-default.btn-xs#Equidistance1[type='button']\", { style: { float: \"left\", \"margin-left\": \"2%\" } }, \"EQUIDISTANCE\"), (0, _mithril2.default)(\"button.btn.btn-default.btn-xs#Equimass1[type='button']\", { style: { float: \"left\", \"margin-left\": \"2%\" } }, \"EQUIMASS\")), (0, _mithril2.default)('#forPlotB', { style: { display: 'inline', float: \"right\", width: '50%' } }, (0, _mithril2.default)(\"input#input2[name='fname1'][type='text']\", { style: { \"margin-left\": \"2%\" } }), (0, _mithril2.default)('span#tooltipPlotB.tooltiptext1[style=visibility: hidden]'), (0, _mithril2.default)(\"button.btn.btn-default.btn-xs#Equidistance2[type='button']\", { style: { float: \"left\", \"margin-left\": \"2%\" } }, \"EQUIDISTANCE\"), (0, _mithril2.default)(\"button.btn.btn-default.btn-xs#Equimass2[type='button']\", { style: { float: \"left\", \"margin-left\": \"2%\" } }, \"EQUIMASS\"))), (0, _mithril2.default)('div#statusesBivariate', (0, _mithril2.default)(\"div#plotA_status\", { style: { width: '100%' } }), (0, _mithril2.default)(\"div#plotB_status\", { style: { width: '100%' } }), (0, _mithril2.default)('h5[style=color: #ac2925; margin-top: 1%; margin-left: 2%]', 'Selection History')), (0, _mithril2.default)(\"button.btn.btn-default.btn-sm[id='SelectionData1'][type='button']\", { style: { display: \"block\", margin: \"0 auto\", position: \"relative\" } }, \"Create\")), (0, _mithril2.default)('#tabular_1', { style: { width: \"100%\", height: \"200px\" } }, (0, _mithril2.default)('#plotA', { style: { width: exp.get_width('plotA') + '%', height: \"100%\", float: \"left\", overflow: \"hidden\" } }, \"plotA\"), (0, _mithril2.default)('#plotB', { style: { width: exp.get_width('plotB') + '%', height: \"100%\", float: \"right\", overflow: \"hidden\" } }, \"plotB\")), (0, _mithril2.default)('#tabular_2', { style: { width: \"100%\" } })))]\n        }];\n\n        return (0, _mithril2.default)(_Panel2.default, {\n            side: 'right',\n            label: 'Result Exploration',\n            hover: true,\n            width: app.exploreRightPanelWidths[app.rightTabExplore]\n        }, (0, _mithril2.default)(_MenuTabbed2.default, {\n            id: 'rightPanelMenuExplore',\n            currentTab: app.rightTabExplore,\n            callback: app.setRightTabExplore,\n            sections: sectionsExplore,\n            attrsAll: { style: { height: 'calc(100% - 39px)' } }\n        }));\n    }\n\n    // mode == null (model mode)\n\n    var sections = [\n    // {value: 'Models',\n    //  display: app.IS_D3M_DOMAIN ? 'block' : 'none',\n    //  contents: righttab('models')},\n    { value: 'Task Type',\n        idSuffix: 'Type',\n        contents: righttab('types', app.d3mTaskType, 'Task', 'taskType') }, { value: 'Subtype',\n        contents: righttab('subtypes', app.d3mTaskSubtype, 'Task Subtype', 'taskSubtype') }, { value: 'Metrics',\n        contents: righttab('metrics', app.d3mMetrics, 'Metric', 'metric') }, { value: 'Results',\n        display: !app.swandive || app.IS_D3M_DOMAIN ? 'block' : 'none',\n        idSuffix: 'Setx',\n        contents: [(0, _mithril2.default)('#setxRight[style=display:block; float: right; width: 25%; height:100%; background-color: white]', app.pipelineTable ? (0, _mithril2.default)(_Table2.default, {\n            id: 'pipelineTable',\n            headers: app.pipelineHeader,\n            data: app.pipelineTable,\n            activeRow: app.selectedPipeline[app.currentMode],\n            onclick: app.setSelectedPipeline,\n            showUID: false,\n            abbreviation: 20\n        }) : undefined), (0, _mithril2.default)('#setxTop[style=display:block; float: left; width: 75%; height:10%; overflow: auto; background-color: white]', (0, _mithril2.default)(\"button.btn.btn-default.btn-xs#btnPredPlot[type='button']\", {\n            onclick: function onclick() {\n                return app.showPredPlot('btnPredPlot');\n            },\n            style: { float: \"left\", \"margin-left\": \"2%\" }\n        }, \"Prediction Summary\"), (0, _mithril2.default)(\"button.btn.btn-default.btn-xs#btnGenPreds[type='button']\", {\n            onclick: function onclick() {\n                return app.showGenPreds('btnGenPreds');\n            },\n            style: { float: \"left\", \"margin-left\": \"2%\" }\n        }, \"Generate New Predictions\")), (0, _mithril2.default)('#setxLeftPlot[style=display:block; float: left; width: 75%; height:95%; overflow: auto; background-color: white]'), (0, _mithril2.default)('#setxLeft[style=display:none; float: left; width: 75%; height:95%; overflow: auto; background-color: white]'), (0, _mithril2.default)('#setxLeftGen[style=display:none; float: left; width: 75%; height:95%; overflow: auto; background-color: white]', (0, _mithril2.default)('#setxLeftTop[style=display:block; float: left; width: 100%; height:50%; overflow: auto; background-color: white]', (0, _mithril2.default)('#setxLeftTopLeft[style=display:block; float: left; width: 30%; height:100%; overflow: auto; background-color: white]'), (0, _mithril2.default)('#setxLeftTopRight[style=display:block; float: left; width: 70%; height:100%; overflow: auto; background-color: white]')), (0, _mithril2.default)('#setxLeftBottomLeft[style=display:block; float: left; width: 70%; height:50%; overflow: auto; background-color: white]'), (0, _mithril2.default)('#setxLeftBottomRightTop[style=display:block; float: left; width: 30%; height:10%; overflow: auto; background-color: white]', (0, _mithril2.default)(_PanelButton2.default, { id: 'btnExecutePipe',\n            classes: 'btn-default.ladda-button[data-spinner-color=#000000][data-style=zoom-in]',\n            onclick: function onclick() {\n                return app.executepipeline('btnExecutePipe');\n            },\n            style: 'display:inline; float: left; margin-right: 10px',\n            title: 'Execute pipeline.' }, (0, _mithril2.default)('span.ladda-label[style=pointer-events: none]', 'Execute Generation'))), (0, _mithril2.default)('#setxLeftBottomRightBottom[style=display:block; float: left; width: 30%; height:40%; overflow: auto; background-color: white]'))] }];\n\n    return (0, _mithril2.default)(_Panel2.default, {\n        side: 'right',\n        label: 'Model Selection',\n        hover: true,\n        width: app.modelRightPanelWidths[app.rightTab]\n    }, (0, _mithril2.default)(_MenuTabbed2.default, {\n        id: 'rightpanelMenu',\n        currentTab: app.rightTab,\n        callback: app.setRightTab,\n        hoverBonus: 10,\n        selectWidth: 30,\n        sections: sections,\n        attrsAll: { style: { height: 'calc(100% - 39px)' } }\n    }));\n}\n\nvar glyph = function glyph(icon, unstyled) {\n    return (0, _mithril2.default)('span.glyphicon.glyphicon-' + icon + (unstyled ? '' : '[style=color: #818181; font-size: 1em; pointer-events: none]'));\n};\n\nvar Body = function () {\n    function Body() {\n        _classCallCheck(this, Body);\n    }\n\n    _createClass(Body, [{\n        key: 'oninit',\n        value: function oninit(vnode) {\n            if (vnode.attrs.mode) {\n                _mithril2.default.route.set('/model');\n                vnode.attrs.mode = null;\n            };\n            this.about = false;\n            this.usertasks = false;\n            this.cite = false;\n            this.citeHidden = false;\n            this.last_mode = null;\n        }\n    }, {\n        key: 'oncreate',\n        value: function oncreate() {\n            var extract = function extract(name, key, offset, replace) {\n                key = key + '=';\n                var loc = window.location.toString();\n                var val = loc.indexOf(key) > 0 ? loc.substring(loc.indexOf(key) + offset) : '';\n                var idx = val.indexOf('&');\n                val = idx > 0 ? val.substring(0, idx) : val;\n                val = val.replace('#!/model', '');\n                console.log(name, ': ', val);\n                return replace ? val.replace(/%25/g, '%').replace(/%3A/g, ':').replace(/%2F/g, '/') : val;\n            };\n            app.main(extract('fileid', 'dfId', 5), extract('hostname', 'host', 5), extract('ddiurl', 'ddiurl', 7, true), extract('dataurl', 'dataurl', 8, true), extract('apikey', 'key', 4));\n        }\n    }, {\n        key: 'view',\n        value: function view(vnode) {\n            var mode = vnode.attrs.mode;\n\n            var explore_mode = mode === 'explore';\n            var results_mode = mode === 'results';\n\n            var spaceBtn = function spaceBtn(id, onclick, title, icon) {\n                return (0, _mithril2.default)('button#' + id + '.btn.btn-default', { onclick: onclick, title: title }, glyph(icon, true));\n            };\n\n            if (mode != this.last_mode) {\n                app.set_mode(mode);\n                if (explore_mode) {\n                    app.explored = false;\n                    app.univariate_finished = false;\n                    app.setRightTabExplore('Univariate');\n                } else if (results_mode) {\n                    app.setRightTab(IS_D3M_DOMAIN ? 'Task Type' : 'Models');\n                } else if (!mode) {\n                    app.setRightTab(IS_D3M_DOMAIN ? 'Task Type' : 'Models');\n                }\n                app.restart && app.restart();\n                this.last_mode = mode;\n            }\n\n            return (0, _mithril2.default)('main', [(0, _mithril2.default)(_Modal2.default), this.header(mode), this.footer(mode), (0, _mithril2.default)('#main.left.carousel.slide.svg-leftpanel.svg-rightpanel[style=overflow: hidden]', (0, _mithril2.default)(\"#innercarousel.carousel-inner\", { style: { height: 'calc(100% + ' + app.marginTopCarousel + 'px)' } }, (0, _mithril2.default)('#m0.item.active', { style: { height: '100%', 'text-align': \"center\" } }, (0, _mithril2.default)('svg#whitespace'))), (0, _mithril2.default)(\"#spacetools.spaceTool\", { style: { right: app.panelWidth['right'], 'z-index': 16 } }, (0, _mithril2.default)('button#btnLock.btn.btn-default', {\n                class: app.locktoggle ? 'active' : '',\n                onclick: function onclick() {\n                    return app.lockDescription(!app.locktoggle);\n                },\n                title: 'Lock selection of problem description'\n            }, glyph(app.locktoggle ? 'lock' : 'pencil', true)), spaceBtn('btnJoin', function (_) {\n                var _ref;\n\n                var links = [];\n                console.log(\"doing connect all\");\n                if (explore_mode) {\n                    var _iteratorNormalCompletion = true;\n                    var _didIteratorError = false;\n                    var _iteratorError = undefined;\n\n                    try {\n                        var _loop = function _loop() {\n                            var node = _step.value;\n                            var _iteratorNormalCompletion2 = true;\n                            var _didIteratorError2 = false;\n                            var _iteratorError2 = undefined;\n\n                            try {\n                                var _loop2 = function _loop2() {\n                                    var node1 = _step2.value;\n\n                                    if (node !== node1 && links.filter(function (l) {\n                                        return l.target === node1 && l.source === node;\n                                    }).length === 0) {\n                                        links.push({ left: false, right: false, target: node, source: node1 });\n                                    }\n                                };\n\n                                for (var _iterator2 = app.nodes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                                    _loop2();\n                                }\n                            } catch (err) {\n                                _didIteratorError2 = true;\n                                _iteratorError2 = err;\n                            } finally {\n                                try {\n                                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                                        _iterator2.return();\n                                    }\n                                } finally {\n                                    if (_didIteratorError2) {\n                                        throw _iteratorError2;\n                                    }\n                                }\n                            }\n                        };\n\n                        for (var _iterator = app.nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                            _loop();\n                        }\n                    } catch (err) {\n                        _didIteratorError = true;\n                        _iteratorError = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion && _iterator.return) {\n                                _iterator.return();\n                            }\n                        } finally {\n                            if (_didIteratorError) {\n                                throw _iteratorError;\n                            }\n                        }\n                    }\n                } else {\n                    var dvs = app.nodes.filter(function (n) {\n                        return app.zparams.zdv.includes(n.name);\n                    });\n                    var nolink = app.zparams.zdv.concat(app.zparams.zgroup1).concat(app.zparams.zgroup2);\n                    var ivs = app.nodes.filter(function (n) {\n                        return !nolink.includes(n.name);\n                    });\n\n                    links = dvs.map(function (dv) {\n                        return ivs.map(function (iv) {\n                            return {\n                                left: true,\n                                right: false,\n                                target: iv,\n                                source: dv\n                            };\n                        });\n                    });\n                }\n                app.restart((_ref = []).concat.apply(_ref, _toConsumableArray(links)));\n            }, 'Make all possible connections between nodes', 'link'), spaceBtn('btnDisconnect', function (_) {\n                return app.restart([]);\n            }, 'Delete all connections between nodes', 'remove-circle'), spaceBtn('btnForce', app.forceSwitch, 'Pin the variable pebbles to the page', 'pushpin'), spaceBtn('btnEraser', app.erase, 'Wipe all variables from the modeling space', 'magnet')), (0, _mithril2.default)(_Subpanel2.default, { title: \"Legend\",\n                buttons: [['timeButton', 'ztime', 'Time'], ['csButton', 'zcross', 'Cross Sec'], ['dvButton', 'zdv', 'Dep Var'], ['nomButton', 'znom', 'Nom Var'], ['gr1Button', 'zgroup1', 'Group 1'], ['gr2Button', 'zgroup2', 'Group 2']] }), (0, _mithril2.default)(_Subpanel2.default, { title: \"History\" }), leftpanel(mode), rightpanel(mode))]);\n        }\n    }, {\n        key: 'header',\n        value: function header(mode) {\n            var _this = this;\n\n            var userlinks = username === 'no logged in user' ? [{ title: \"Log in\", url: login_url }, { title: \"Sign up\", url: signup_url }] : [{ title: \"Workspaces\", url: workspaces_url }, { title: \"Settings\", url: settings_url }, { title: \"Links\", url: devlinks_url }, { title: \"Logout\", url: logout_url }];\n\n            var _navBtn = function _navBtn(id, left, right, onclick, args, min) {\n                return (0, _mithril2.default)('button#' + id + '.btn.navbar-right', { onclick: onclick,\n                    style: { 'margin-left': left + 'em',\n                        'margin-right': right + 'em',\n                        'min-width': min } }, args);\n            };\n            var navBtn = function navBtn(id, left, right, onclick, args, min) {\n                return _navBtn(id + '.ladda-button[data-spinner-color=#000000][data-style=zoom-in]', left, right, onclick, args, min);\n            };\n            var navBtnGroup = function navBtnGroup(id, onclick, args, min) {\n                return (0, _mithril2.default)('button#' + id + '.btn.navbar-left', { onclick: onclick,\n                    style: { 'min-width': min } }, args);\n            };\n            var navBtn1 = function navBtn1(id, onclick, args, title) {\n                return _navBtn(id + '.btn-default[title=' + title + ']', 2, 0, onclick, args);\n            };\n            var transformation = function transformation(id, list) {\n                return (0, _mithril2.default)('ul#' + id, { style: { display: 'none', 'background-color': app.varColor },\n                    onclick: function onclick(evt) {\n                        var tInput = app.byId('tInput');\n\n                        // if interact is selected, show variable list again\n                        if (this.textContent === 'interact(d,e)') {\n                            tInput.value = tvar.concat('*');\n                            selInteract = true;\n                            (0, _utils.fadeOut)(this.parentNode, 100);\n                            (0, _utils.fadeIn)('#transSel', 100);\n                            evt.stopPropagation();\n                            return;\n                        }\n\n                        var tvar = tInput.value;\n                        var tfunc = this.textContent.replace(\"d\", \"_transvar0\");\n                        var tcall = this.textContent.replace(\"d\", tvar);\n                        tInput.value = tcall;\n                        (0, _utils.fadeOut)(this.parentNode, 100);\n                        evt.stopPropagation();\n                        transform(tvar, tfunc, typeTransform = false);\n                    } }, list.map(function (x) {\n                    return (0, _mithril2.default)('li', x);\n                }));\n            };\n\n            return (0, _mithril2.default)(_Header2.default, {\n                style: mode === 'explore' ? { 'background-image': '-webkit-linear-gradient(top, #fff 0, rgb(227, 242, 254) 100%)' } : {}\n            }, [(0, _mithril2.default)('#dataField.field[style=text-align: center]', [(0, _mithril2.default)('h4#dataName[style=display: inline-block; margin-right:2em; margin-top: 7px]', { onclick: function onclick(_) {\n                    return _this.cite = _this.citeHidden = !_this.citeHidden;\n                },\n                onmouseout: function onmouseout(_) {\n                    return _this.citeHidden || (_this.cite = false);\n                },\n                onmouseover: function onmouseover(_) {\n                    return _this.cite = true;\n                } }, 'Dataset Name'), (0, _mithril2.default)('#cite.panel.panel-default', { style: 'display: ' + (this.cite ? 'block' : 'none') + '; position: absolute; right: 50%; width: 380px; text-align: left; z-index: 50' }, (0, _mithril2.default)('.panel-body')), (0, _mithril2.default)('span', (0, _mithril2.default)('.dropdown[style=float: right; padding-right: 1em]', (0, _mithril2.default)('#drop.button.btn[type=button][data-toggle=dropdown][aria-haspopup=true][aria-expanded=false]', [username, \" \", glyph('triangle-bottom')]), (0, _mithril2.default)('ul.dropdown-menu[role=menu][aria-labelledby=drop]', userlinks.map(function (link) {\n                return (0, _mithril2.default)('a[style=padding: 0.5em]', { href: link.url }, link.title, (0, _mithril2.default)('br'));\n            }))), navBtn('btnEstimate.btn-default', 2, 1, mode === 'explore' ? function (_) {\n                if (app.links.length === 0) {\n                    (0, _Modal.setModal)('Please link pebbles first.', 'Warning', true, 'Ok', true);\n                    return;\n                }\n\n                exp.explore();\n                app.setRightTabExplore('Bivariate');\n            } : app.estimate, (0, _mithril2.default)(\"span.ladda-label\", mode === 'explore' ? 'Explore' : 'Solve This Problem'), '150px'), (0, _mithril2.default)('div.btn-group[role=group][aria-label=\"...\"]', { style: { \"float\": \"right\", \"margin-left\": \"2em\" } }, navBtnGroup('btnTA2.btn-default', function (_) {\n                return _hopscotch2.default.startTour(app.mytour, 0);\n            }, ['Help Tour ', glyph('road')]), navBtnGroup('btnTA2.btn-default', function (_) {\n                return app.helpmaterials('video');\n            }, ['Video ', glyph('expand')]), navBtnGroup('btnTA2.btn-default', function (_) {\n                return app.helpmaterials('manual');\n            }, ['Manual ', glyph('book')])), navBtn1(\"btnReset\", app.reset, glyph('repeat'), 'Reset'), navBtn1('btnEndSession', app.endsession, (0, _mithril2.default)(\"span.ladda-label\", 'Mark Problem Finished'), 'Mark Problem Finished')), (0, _mithril2.default)('#tInput', {\n                style: { display: 'none' },\n                onclick: function onclick(_) {\n                    var transSel = app.byId('transSel');\n                    // if variable list is displayed when input is clicked...\n                    if (transSel.style.display !== 'none') {\n                        (0, _utils.fadeOut)(transSel, 100);\n                        return false;\n                    }\n\n                    var transList = app.byId('transList');\n                    // if function list is displayed when input is clicked...\n                    if (transList.style.display !== 'none') {\n                        (0, _utils.fadeOut)(transList, 100);\n                        return false;\n                    }\n\n                    // highlight the text\n                    //let pos = this.offset();\n                    //pos.top += this.offsetWidth();\n                    (0, _utils.fadeIn)(transSel, 100);\n                    return false;\n                },\n                keyup: function keyup(evt) {\n                    var transSel = app.byId('transSel');\n                    var transList = app.byId('transList');\n                    if (transSel.style.display !== 'none') {\n                        (0, _utils.fadeOut)(transSel, 100);\n                    } else if (transList.style.display !== 'none') {\n                        (0, _utils.fadeOut)(transList, 100);\n                    }\n\n                    if (evt.keyCode == 13) {\n                        // keyup on Enter\n                        var t = transParse(app.byId('tInput').value);\n                        if (!t) {\n                            return;\n                        }\n\n                        transform(t.slice(0, t.length - 1), t[t.length - 1], typeTransform = false);\n                    }\n                }\n            }), (0, _mithril2.default)('#transformations.transformTool', { title: 'Construct transformations of existing variables using valid R syntax. For example, assuming a variable named d, you can enter \"log(d)\" or \"d^2\".' }, [transformation('transSel', ['a', 'b']), transformation('transList', app.transformList)])])]);\n        }\n    }, {\n        key: 'footer',\n        value: function footer(mode) {\n            return (0, _mithril2.default)(_Footer2.default, [(0, _mithril2.default)(_ButtonRadio2.default, { id: 'modeButtonBar',\n                attrsAll: {\n                    style: { 'padding-top': '2px', width: '200px' }, class: 'navbar-left btn-sm' },\n                onclick: app.set_mode,\n                activeSection: mode || 'model',\n                // {value: 'Results', id: 'btnResultsMode'}] VJD: commenting out the results mode button since we don't have this yet\n                sections: [{ value: 'Model' }, { value: 'Explore' }] }), (0, _mithril2.default)(\"a#logID[href=somelink][target=_blank]\", \"Replication\"), (0, _mithril2.default)(\"span[style=color:#337ab7]\", \" | \"),\n            // dev links...\n            (0, _mithril2.default)(\"a[href='/dev-raven-links'][target=_blank]\", \"raven-links\"), (0, _mithril2.default)(\"span[style=color:#337ab7]\", \" | \"), (0, _mithril2.default)(\"span[style=color:#337ab7]\", 'TA2: ' + TA2_SERVER), (0, _mithril2.default)(\"span[style=color:#337ab7]\", \" | \"), (0, _mithril2.default)(\"span[style=color:#337ab7]\", 'TA3TA2 api: ' + TA3TA2_API_VERSION), (0, _mithril2.default)('button.btn.btn-default', {\n                onclick: function onclick(_) {\n                    return window.open('#!/data', 'data');\n                },\n                style: 'float: right; margin: 0.5em; margin-top: 2px'\n            }, 'Peek')]);\n        }\n    }]);\n\n    return Body;\n}();\n\n_mithril2.default.route(document.body, '/model', {\n    '/model': { render: function render() {\n            return (0, _mithril2.default)(Body);\n        } },\n    '/explore': { render: function render() {\n            return (0, _mithril2.default)(Body, { mode: 'explore' });\n        } },\n    '/results': {\n        onmatch: function onmatch() {\n            app.set_mode('results');\n            state.get_pipelines();\n            layout.init();\n        },\n        render: function render() {\n            return (0, _mithril2.default)(Body, { mode: 'results' });\n        }\n    },\n    '/data': _Peek2.default\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvYXBwL2luZGV4LmpzPzMzYmUiXSwibmFtZXMiOlsiYXBwIiwiZXhwIiwibGF5b3V0IiwicmVzdWx0cyIsImNvbW1vbiIsInN0YXRlIiwicGlwZWxpbmVzIiwiZ2V0X3BpcGVsaW5lcyIsImxpc3RwaXBlbGluZXMiLCJyZWRyYXciLCJzZXRCYWNrZ3JvdW5kQ29sb3IiLCJjb2xvciIsInN0eWxlIiwibGVmdHBhbmVsIiwibW9kZSIsIk9iamVjdCIsImtleXMiLCJhbGxQaXBlbGluZUluZm8iLCJkaXNjb3ZlcnlBbGxDaGVjayIsIm9uY2xpY2siLCJ3aXRoQXR0ciIsImNoZWNrZWQiLCJzZXRDaGVja2VkRGlzY292ZXJ5UHJvYmxlbSIsInByb2J0YWJsZSIsImxlbmd0aCIsImNoZWNrZWREaXNjb3ZlcnlQcm9ibGVtcyIsInNpemUiLCJkaXNjb3ZlcnlUYWJsZURhdGEiLCJtYXAiLCJwcm9ibGVtIiwiaGFzIiwic2lkZSIsImxhYmVsIiwiaG92ZXIiLCJ3aWR0aCIsIm1vZGVsTGVmdFBhbmVsV2lkdGhzIiwibGVmdFRhYiIsImF0dHJzQWxsIiwiaWQiLCJoZWlnaHQiLCJjdXJyZW50VGFiIiwiY2FsbGJhY2siLCJzZXRMZWZ0VGFiIiwic2VjdGlvbnMiLCJ2YWx1ZSIsInRpdGxlIiwiY29udGVudHMiLCJwbGFjZWhvbGRlciIsIm9uaW5wdXQiLCJzZWFyY2hWYXJpYWJsZXMiLCJpdGVtcyIsInZhbHVlS2V5IiwiY29sb3JzIiwiaGV4VG9SZ2JhIiwic2VsVmFyQ29sb3IiLCJub2RlcyIsIm4iLCJuYW1lIiwibm9tQ29sb3IiLCJ6cGFyYW1zIiwiem5vbSIsImR2Q29sb3IiLCJ6ZHYiLCJjbGFzc2VzIiwibWF0Y2hlZFZhcmlhYmxlcyIsImNsaWNrVmFyIiwicG9wdXAiLCJ2YXJpYWJsZSIsInBvcG92ZXJDb250ZW50IiwiZmluZE5vZGVJbmRleCIsImF0dHJzSXRlbXMiLCJoZWFkZXJzIiwiZGF0YSIsImFjdGl2ZVJvdyIsInNlbGVjdGVkUHJvYmxlbSIsInNldFNlbGVjdGVkUHJvYmxlbSIsInNob3dVSUQiLCJhYmJyZXZpYXRpb24iLCJvdmVyZmxvdyIsImRpc3BsYXkiLCJ3aW5kb3ciLCJpbm5lcldpZHRoIiwiZGlzY28iLCJ1bmRlZmluZWQiLCJkZXNjcmlwdGlvbiIsInNhdmVEaXNjIiwic3VibWl0RGlzY1Byb2IiLCJzdW1tYXJ5IiwibGFibCIsInRyIiwib25tb3VzZW92ZXIiLCJvbm1vdXNlb3V0IiwidGQiLCJyaWdodHRhYiIsInRhc2siLCJwcm9iRGVzYyIsImQzbVByb2JsZW1EZXNjcmlwdGlvbiIsImZpbHRlciIsImxvY2t0b2dnbGUiLCJpdGVtIiwic2V0RDNtUHJvYmxlbURlc2NyaXB0aW9uIiwidiIsInJpZ2h0cGFuZWwiLCJ0aHVtYiIsImlkeCIsImZsb2F0IiwiYm9yZGVyIiwicGFkZGluZyIsIm1hcmdpbiIsImN1cnNvciIsInNlY3Rpb25zRXhwbG9yZSIsImV4cGxvcmVWYXIiLCJjYWxsVHJlZUFwcCIsImV4cGxvcmVkIiwicGlwZWxpbmVUYWJsZSIsInBpcGVsaW5lSGVhZGVyIiwic2VsZWN0ZWRQaXBlbGluZSIsImN1cnJlbnRNb2RlIiwic2V0U2VsZWN0ZWRQaXBlbGluZSIsInBvc2l0aW9uIiwiZ2V0X3dpZHRoIiwiZXhwbG9yZVJpZ2h0UGFuZWxXaWR0aHMiLCJyaWdodFRhYkV4cGxvcmUiLCJzZXRSaWdodFRhYkV4cGxvcmUiLCJpZFN1ZmZpeCIsImQzbVRhc2tUeXBlIiwiZDNtVGFza1N1YnR5cGUiLCJkM21NZXRyaWNzIiwic3dhbmRpdmUiLCJJU19EM01fRE9NQUlOIiwic2hvd1ByZWRQbG90Iiwic2hvd0dlblByZWRzIiwiZXhlY3V0ZXBpcGVsaW5lIiwibW9kZWxSaWdodFBhbmVsV2lkdGhzIiwicmlnaHRUYWIiLCJzZXRSaWdodFRhYiIsImhvdmVyQm9udXMiLCJzZWxlY3RXaWR0aCIsImdseXBoIiwiaWNvbiIsInVuc3R5bGVkIiwiQm9keSIsInZub2RlIiwiYXR0cnMiLCJyb3V0ZSIsInNldCIsImFib3V0IiwidXNlcnRhc2tzIiwiY2l0ZSIsImNpdGVIaWRkZW4iLCJsYXN0X21vZGUiLCJleHRyYWN0Iiwia2V5Iiwib2Zmc2V0IiwicmVwbGFjZSIsImxvYyIsImxvY2F0aW9uIiwidG9TdHJpbmciLCJ2YWwiLCJpbmRleE9mIiwic3Vic3RyaW5nIiwiY29uc29sZSIsImxvZyIsIm1haW4iLCJleHBsb3JlX21vZGUiLCJyZXN1bHRzX21vZGUiLCJzcGFjZUJ0biIsInNldF9tb2RlIiwidW5pdmFyaWF0ZV9maW5pc2hlZCIsInJlc3RhcnQiLCJoZWFkZXIiLCJmb290ZXIiLCJtYXJnaW5Ub3BDYXJvdXNlbCIsInJpZ2h0IiwicGFuZWxXaWR0aCIsImNsYXNzIiwibG9ja0Rlc2NyaXB0aW9uIiwibGlua3MiLCJub2RlIiwibm9kZTEiLCJsIiwidGFyZ2V0Iiwic291cmNlIiwicHVzaCIsImxlZnQiLCJkdnMiLCJpbmNsdWRlcyIsIm5vbGluayIsImNvbmNhdCIsInpncm91cDEiLCJ6Z3JvdXAyIiwiaXZzIiwiaXYiLCJkdiIsImZvcmNlU3dpdGNoIiwiZXJhc2UiLCJidXR0b25zIiwidXNlcmxpbmtzIiwidXNlcm5hbWUiLCJ1cmwiLCJsb2dpbl91cmwiLCJzaWdudXBfdXJsIiwid29ya3NwYWNlc191cmwiLCJzZXR0aW5nc191cmwiLCJkZXZsaW5rc191cmwiLCJsb2dvdXRfdXJsIiwiX25hdkJ0biIsImFyZ3MiLCJtaW4iLCJuYXZCdG4iLCJuYXZCdG5Hcm91cCIsIm5hdkJ0bjEiLCJ0cmFuc2Zvcm1hdGlvbiIsImxpc3QiLCJ2YXJDb2xvciIsImV2dCIsInRJbnB1dCIsImJ5SWQiLCJ0ZXh0Q29udGVudCIsInR2YXIiLCJzZWxJbnRlcmFjdCIsInBhcmVudE5vZGUiLCJzdG9wUHJvcGFnYXRpb24iLCJ0ZnVuYyIsInRjYWxsIiwidHJhbnNmb3JtIiwidHlwZVRyYW5zZm9ybSIsIngiLCJocmVmIiwibGluayIsImV4cGxvcmUiLCJlc3RpbWF0ZSIsInN0YXJ0VG91ciIsIm15dG91ciIsImhlbHBtYXRlcmlhbHMiLCJyZXNldCIsImVuZHNlc3Npb24iLCJ0cmFuc1NlbCIsInRyYW5zTGlzdCIsImtleXVwIiwia2V5Q29kZSIsInQiLCJ0cmFuc1BhcnNlIiwic2xpY2UiLCJ0cmFuc2Zvcm1MaXN0IiwiYWN0aXZlU2VjdGlvbiIsIlRBMl9TRVJWRVIiLCJUQTNUQTJfQVBJX1ZFUlNJT04iLCJvcGVuIiwiZG9jdW1lbnQiLCJib2R5IiwicmVuZGVyIiwib25tYXRjaCIsImluaXQiXSwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7OztBQUVBOzs7O0FBRUE7O0lBQVlBLEc7O0FBQ1o7O0lBQVlDLEc7O0FBQ1o7O0lBQVlDLE07O0FBQ1o7O0lBQVlDLE87O0FBQ1o7O0FBRUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFFQTs7SUFBWUMsTTs7QUFDWjs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUFFQSxJQUFJQyxRQUFRO0FBQ1JDLGVBQVcsRUFESDtBQUVGQyxpQkFGRSxpQ0FFYztBQUNsQixhQUFLRCxTQUFMLEdBQWlCLE1BQU1OLElBQUlRLGFBQUosRUFBdkI7QUFDQSwwQkFBRUMsTUFBRjtBQUNIO0FBTE8sQ0FBWjs7QUFRQSxTQUFTQyxrQkFBVCxDQUE0QkMsS0FBNUIsRUFBbUM7QUFDL0IsV0FBTyxZQUFXO0FBQ2QsYUFBS0MsS0FBTCxDQUFXLGtCQUFYLElBQWlDRCxLQUFqQztBQUNILEtBRkQ7QUFHSDs7QUFFRCxTQUFTRSxTQUFULENBQW1CQyxJQUFuQixFQUF5QjtBQUFBOztBQUNyQixRQUFJQSxTQUFTLFNBQWIsRUFBd0I7QUFDcEIsZUFBT1gsUUFBUVUsU0FBUixDQUFrQkUsT0FBT0MsSUFBUCxDQUFZaEIsSUFBSWlCLGVBQWhCLENBQWxCLENBQVA7QUFDSDs7QUFFRCxRQUFJQyxvQkFBb0IsdUJBQUUsd0NBQUYsRUFB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QixjQUFVLEVBQUNDLFFBQVE7QUFBQSxtQkFBTSx1QkFBRTlHLElBQUYsQ0FBTjtBQUFBLFNBQVQsRUFEbUI7QUFFN0IsZ0JBQVksRUFBQzhHLFFBQVE7QUFBQSxtQkFBTSx1QkFBRTlHLElBQUYsRUFBUSxFQUFDL0gsTUFBTSxTQUFQLEVBQVIsQ0FBTjtBQUFBLFNBQVQsRUFGaUI7QUFHN0IsZ0JBQVk7QUFDUjhPLGVBRFEscUJBQ0U7QUFDTjVQLGdCQUFJdUssUUFBSixDQUFhLFNBQWI7QUFDQWxLLGtCQUFNRSxhQUFOO0FBQ0FMLG1CQUFPMlAsSUFBUDtBQUNILFNBTE87QUFNUkYsY0FOUSxvQkFNQztBQUNMLG1CQUFPLHVCQUFFOUcsSUFBRixFQUFRLEVBQUMvSCxNQUFNLFNBQVAsRUFBUixDQUFQO0FBQ0g7QUFSTyxLQUhpQjtBQWE3QjtBQWI2QixDQUFqQyIsImZpbGUiOiIyOC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAnLi4vY3NzL2FwcC5jc3MnO1xuaW1wb3J0ICcuLi9wa2dzL2Jvb3RzdHJhcC9jc3MvYm9vdHN0cmFwLXRoZW1lLm1pbi5jc3MnO1xuaW1wb3J0ICcuLi9wa2dzL0xhZGRhL2Rpc3QvbGFkZGEtdGhlbWVsZXNzLm1pbi5jc3MnO1xuaW1wb3J0ICcuLi8uLi9ub2RlX21vZHVsZXMvaG9wc2NvdGNoL2Rpc3QvY3NzL2hvcHNjb3RjaC5jc3MnO1xuXG5pbXBvcnQgaG9wc2NvdGNoIGZyb20gJ2hvcHNjb3RjaCc7XG5cbmltcG9ydCBtIGZyb20gJ21pdGhyaWwnO1xuXG5pbXBvcnQgKiBhcyBhcHAgZnJvbSAnLi9hcHAnO1xuaW1wb3J0ICogYXMgZXhwIGZyb20gJy4vZXhwbG9yZSc7XG5pbXBvcnQgKiBhcyBsYXlvdXQgZnJvbSAnLi9sYXlvdXQnO1xuaW1wb3J0ICogYXMgcmVzdWx0cyBmcm9tICcuL3Jlc3VsdHMnO1xuaW1wb3J0IHtlbGVtLCBmYWRlSW4sIGZhZGVPdXR9IGZyb20gJy4vdXRpbHMnO1xuXG5pbXBvcnQgQnV0dG9uIGZyb20gJy4vdmlld3MvUGFuZWxCdXR0b24nO1xuaW1wb3J0IExpc3QgZnJvbSAnLi92aWV3cy9QYW5lbExpc3QnO1xuaW1wb3J0IFNlYXJjaCBmcm9tICcuL3ZpZXdzL1NlYXJjaCc7XG5pbXBvcnQgU3VicGFuZWwgZnJvbSAnLi92aWV3cy9TdWJwYW5lbCc7XG5cbmltcG9ydCAqIGFzIGNvbW1vbiBmcm9tICcuLi9jb21tb24vYXBwL2NvbW1vbic7XG5pbXBvcnQgQnV0dG9uUmFkaW8gZnJvbSAnLi4vY29tbW9uL2FwcC92aWV3cy9CdXR0b25SYWRpbyc7XG5pbXBvcnQgRm9vdGVyIGZyb20gJy4uL2NvbW1vbi9hcHAvdmlld3MvRm9vdGVyJztcbmltcG9ydCBIZWFkZXIgZnJvbSAnLi4vY29tbW9uL2FwcC92aWV3cy9IZWFkZXInO1xuaW1wb3J0IE1lbnVUYWJiZWQgZnJvbSAnLi4vY29tbW9uL2FwcC92aWV3cy9NZW51VGFiYmVkJztcbmltcG9ydCBNb2RhbCwge3NldE1vZGFsfSBmcm9tICcuLi9jb21tb24vYXBwL3ZpZXdzL01vZGFsJztcbmltcG9ydCBQYW5lbCBmcm9tICcuLi9jb21tb24vYXBwL3ZpZXdzL1BhbmVsJztcbmltcG9ydCBQYW5lbExpc3QgZnJvbSAnLi4vY29tbW9uL2FwcC92aWV3cy9QYW5lbExpc3QnO1xuaW1wb3J0IFBlZWsgZnJvbSAnLi4vY29tbW9uL2FwcC92aWV3cy9QZWVrJztcbmltcG9ydCBUYWJsZSBmcm9tICcuLi9jb21tb24vYXBwL3ZpZXdzL1RhYmxlJztcbmltcG9ydCBUZXh0RmllbGQgZnJvbSAnLi4vY29tbW9uL2FwcC92aWV3cy9UZXh0RmllbGQnO1xuXG5sZXQgc3RhdGUgPSB7XG4gICAgcGlwZWxpbmVzOiBbXSxcbiAgICBhc3luYyBnZXRfcGlwZWxpbmVzKCkge1xuICAgICAgICB0aGlzLnBpcGVsaW5lcyA9IGF3YWl0IGFwcC5saXN0cGlwZWxpbmVzKCk7XG4gICAgICAgIG0ucmVkcmF3KCk7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gc2V0QmFja2dyb3VuZENvbG9yKGNvbG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnN0eWxlWydiYWNrZ3JvdW5kLWNvbG9yJ10gPSBjb2xvcjtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBsZWZ0cGFuZWwobW9kZSkge1xuICAgIGlmIChtb2RlID09PSAncmVzdWx0cycpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdHMubGVmdHBhbmVsKE9iamVjdC5rZXlzKGFwcC5hbGxQaXBlbGluZUluZm8pKTtcbiAgICB9XG5cbiAgICBsZXQgZGlzY292ZXJ5QWxsQ2hlY2sgPSBtKCdpbnB1dCNkaXNjb3ZlcnlBbGxDaGVja1t0eXBlPWNoZWNrYm94XScsIHtcbiAgICAgICAgb25jbGljazogbS53aXRoQXR0cihcImNoZWNrZWRcIiwgKGNoZWNrZWQpID0+IGFwcC5zZXRDaGVja2VkRGlzY292ZXJ5UHJvYmxlbShjaGVja2VkKSksXG4gICAgICAgIGNoZWNrZWQ6IGFwcC5wcm9idGFibGUubGVuZ3RoID09PSBhcHAuY2hlY2tlZERpc2NvdmVyeVByb2JsZW1zLnNpemVcbiAgICB9KTtcbiAgICBsZXQgZGlzY292ZXJ5VGFibGVEYXRhID0gYXBwLnByb2J0YWJsZS5tYXAoKHByb2JsZW0pID0+IFsuLi5wcm9ibGVtLCBtKCdpbnB1dFt0eXBlPWNoZWNrYm94XScsIHtcbiAgICAgICAgb25jbGljazogbS53aXRoQXR0cihcImNoZWNrZWRcIiwgKGNoZWNrZWQpID0+IGFwcC5zZXRDaGVja2VkRGlzY292ZXJ5UHJvYmxlbShjaGVja2VkLCBwcm9ibGVtWzBdKSksXG4gICAgICAgIGNoZWNrZWQ6IGFwcC5jaGVja2VkRGlzY292ZXJ5UHJvYmxlbXMuaGFzKHByb2JsZW1bMF0pXG4gICAgfSldKTtcblxuICAgIHJldHVybiBtKFBhbmVsLCB7XG4gICAgICAgIHNpZGU6ICdsZWZ0JyxcbiAgICAgICAgbGFiZWw6ICdEYXRhIFNlbGVjdGlvbicsXG4gICAgICAgIGhvdmVyOiB0cnVlLFxuICAgICAgICB3aWR0aDogYXBwLm1vZGVsTGVmdFBhbmVsV2lkdGhzW2FwcC5sZWZ0VGFiXSxcbiAgICAgICAgYXR0cnNBbGw6IHtzdHlsZTogeyd6LWluZGV4JzogMTAxfX1cbiAgICB9LCBtKE1lbnVUYWJiZWQsIHtcbiAgICAgICAgaWQ6ICdsZWZ0cGFuZWxNZW51JyxcbiAgICAgICAgYXR0cnNBbGw6IHtzdHlsZToge2hlaWdodDogJ2NhbGMoMTAwJSAtIDM5cHgpJ319LFxuICAgICAgICBjdXJyZW50VGFiOiBhcHAubGVmdFRhYixcbiAgICAgICAgY2FsbGJhY2s6IGFwcC5zZXRMZWZ0VGFiLFxuICAgICAgICBzZWN0aW9uczogW1xuICAgICAgICAgICAge3ZhbHVlOiAnVmFyaWFibGVzJyxcbiAgICAgICAgICAgICB0aXRsZTogJ0NsaWNrIHZhcmlhYmxlIG5hbWUgdG8gYWRkIG9yIHJlbW92ZSB0aGUgdmFyaWFibGUgcGViYmxlIGZyb20gdGhlIG1vZGVsaW5nIHNwYWNlLicsXG4gICAgICAgICAgICAgY29udGVudHM6IFtcbiAgICAgICAgICAgICAgICAgbShUZXh0RmllbGQsIHtcbiAgICAgICAgICAgICAgICAgICAgIGlkOiAnc2VhcmNoVmFyJyxcbiAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiAnU2VhcmNoIHZhcmlhYmxlcyBhbmQgbGFiZWxzJyxcbiAgICAgICAgICAgICAgICAgICAgIG9uaW5wdXQ6IGFwcC5zZWFyY2hWYXJpYWJsZXNcbiAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgIG0oUGFuZWxMaXN0LCB7XG4gICAgICAgICAgICAgICAgICAgICBpZDogJ3Zhckxpc3QnLFxuICAgICAgICAgICAgICAgICAgICAgaXRlbXM6IGFwcC52YWx1ZUtleSxcbiAgICAgICAgICAgICAgICAgICAgIGNvbG9yczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgIFthcHAuaGV4VG9SZ2JhKGNvbW1vbi5zZWxWYXJDb2xvcildOiBhcHAubm9kZXMubWFwKG4gPT4gbi5uYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICBbYXBwLmhleFRvUmdiYShjb21tb24ubm9tQ29sb3IpXTogYXBwLnpwYXJhbXMuem5vbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICBbYXBwLmhleFRvUmdiYShjb21tb24uZHZDb2xvcildOiBhcHAuenBhcmFtcy56ZHZcbiAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICBjbGFzc2VzOiB7J2l0ZW0tYm9yZGVyZWQnOiBhcHAubWF0Y2hlZFZhcmlhYmxlc30sXG4gICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogYXBwLmNsaWNrVmFyLFxuICAgICAgICAgICAgICAgICAgICAgcG9wdXA6ICh2YXJpYWJsZSkgPT4gYXBwLnBvcG92ZXJDb250ZW50KGFwcC5maW5kTm9kZUluZGV4KHZhcmlhYmxlLCB0cnVlKSksXG4gICAgICAgICAgICAgICAgICAgICBhdHRyc0l0ZW1zOiB7J2RhdGEtcGxhY2VtZW50JzogJ3JpZ2h0JywgJ2RhdGEtb3JpZ2luYWwtdGl0bGUnOiAnU3VtbWFyeSBTdGF0aXN0aWNzJ319KV19LFxuICAgICAgICAgICAge3ZhbHVlOiAnRGlzY292ZXJ5JyxcbiAgICAgICAgICAgICBjb250ZW50czogW1xuICAgICAgICAgICAgICAgICBtKFRhYmxlLCB7XG4gICAgICAgICAgICAgICAgICAgICBpZDogJ2Rpc2NvdmVyeVRhYmxlJyxcbiAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IFsnSGlkZGVuX1VJRCcsICdUYXJnZXQnLCAnUHJlZGljdG9ycycsICdUYXNrJywgJ01ldHJpYycsIGRpc2NvdmVyeUFsbENoZWNrXSxcbiAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGRpc2NvdmVyeVRhYmxlRGF0YSxcbiAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZVJvdzogYXBwLnNlbGVjdGVkUHJvYmxlbSxcbiAgICAgICAgICAgICAgICAgICAgIG9uY2xpY2s6IGFwcC5zZXRTZWxlY3RlZFByb2JsZW0sXG4gICAgICAgICAgICAgICAgICAgICBzaG93VUlEOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgIGFiYnJldmlhdGlvbjogNDAsXG4gICAgICAgICAgICAgICAgICAgICBhdHRyc0FsbDoge3N0eWxlOiB7aGVpZ2h0OiAnODAlJywgb3ZlcmZsb3c6ICdhdXRvJywgZGlzcGxheTogJ2Jsb2NrJywgJ21hcmdpbi1yaWdodCc6ICcxNnB4JywgJ21hcmdpbi1ib3R0b20nOiAwLCAnbWF4LXdpZHRoJzogKHdpbmRvdy5pbm5lcldpZHRoIC0gOTApICsgJ3B4J319XG4gICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICBtKCd0ZXh0YXJlYSNkaXNjb3ZlcnlJbnB1dFtzdHlsZT1kaXNwbGF5OmJsb2NrOyBmbG9hdDogbGVmdDsgd2lkdGg6IDEwMCU7IGhlaWdodDpjYWxjKDIwJSAtIDM1cHgpOyBvdmVyZmxvdzogYXV0bzsgYmFja2dyb3VuZC1jb2xvcjogd2hpdGVdJywge1xuICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGFwcC5kaXNjb1thcHAuc2VsZWN0ZWRQcm9ibGVtXSA9PT0gdW5kZWZpbmVkID8gJycgOiBhcHAuZGlzY29bYXBwLnNlbGVjdGVkUHJvYmxlbV0uZGVzY3JpcHRpb25cbiAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgIG0oQnV0dG9uLCB7aWQ6ICdidG5TYXZlJywgb25jbGljazpfPT5hcHAuc2F2ZURpc2MoJ2J0blNhdmUnKSx0aXRsZTogJ1NhdmVzIHlvdXIgcmV2aXNlZCBwcm9ibGVtIGRlc2NyaXB0aW9uLid9LCAnU2F2ZSBEZXNjLicpLFxuICAgICAgICAgICAgICAgICBtKEJ1dHRvbiwge2lkOiAnYnRuU3VibWl0RGlzYycsIGNsYXNzZXM6ICdidG4tc3VjY2VzcycsIHN0eWxlOiAnZmxvYXQ6IHJpZ2h0Jywgb25jbGljazpfPT5hcHAuc3VibWl0RGlzY1Byb2IoKSwgdGl0bGU6ICdTdWJtaXQgYWxsIGNoZWNrZWQgZGlzY292ZXJlZCBwcm9ibGVtcy4nfSwgJ1N1Ym1pdCBEaXNjLiBQcm9icy4nKV19LFxuICAgICAgICAgICAge3ZhbHVlOiAnU3VtbWFyeScsXG4gICAgICAgICAgICAgdGl0bGU6ICdTZWxlY3QgYSB2YXJpYWJsZSBmcm9tIHdpdGhpbiB0aGUgdmlzdWFsaXphdGlvbiBpbiB0aGUgY2VudGVyIHBhbmVsIHRvIHZpZXcgaXRzIHN1bW1hcnkgc3RhdGlzdGljcy4nLFxuICAgICAgICAgICAgIGNvbnRlbnRzOiBbXG4gICAgICAgICAgICAgICAgIG0oJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgICAgbSgnYicsIGFwcC5zdW1tYXJ5Lm5hbWUpLFxuICAgICAgICAgICAgICAgICAgIG0oJ2JyJyksXG4gICAgICAgICAgICAgICAgICAgbSgnaScsIGFwcC5zdW1tYXJ5LmxhYmwpKSxcbiAgICAgICAgICAgICAgICAgbSgndGFibGUnLCBhcHAuc3VtbWFyeS5kYXRhLm1hcCh0ciA9PiBtKCd0cicsIHRyLm1hcChcbiAgICAgICAgICAgICAgICAgICAgIHRkID0+IG0oJ3RkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAge29ubW91c2VvdmVyOiBzZXRCYWNrZ3JvdW5kQ29sb3IoJ2FsaWNlYmx1ZScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25tb3VzZW91dDogc2V0QmFja2dyb3VuZENvbG9yKCdmOWY5ZjknKX0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRkKSkpKSldLFxuICAgICAgICAgICAgIGRpc3BsYXk6ICdub25lJ31cbiAgICAgICAgXVxuICAgIH0pKTtcbn1cblxubGV0IHJpZ2h0dGFiID0gKGlkLCB0YXNrLCB0aXRsZSwgcHJvYkRlc2MpID0+IG0oUGFuZWxMaXN0LCB7XG4gICAgaWQ6IGlkLFxuICAgIGl0ZW1zOiBPYmplY3Qua2V5cyh0YXNrIHx8IHt9KSxcbiAgICBjb2xvcnM6IHtbYXBwLmhleFRvUmdiYShjb21tb24uc2VsVmFyQ29sb3IpXTogW2FwcC5kM21Qcm9ibGVtRGVzY3JpcHRpb25bcHJvYkRlc2NdXX0sXG4gICAgY2xhc3Nlczoge1xuICAgICAgICAnaXRlbS1saW5lb3V0JzogT2JqZWN0LmtleXModGFzayB8fCB7fSlcbiAgICAgICAgICAgIC5maWx0ZXIoaXRlbSA9PiBhcHAubG9ja3RvZ2dsZSAmJiBpdGVtICE9PSBhcHAuZDNtUHJvYmxlbURlc2NyaXB0aW9uW3Byb2JEZXNjXSlcbiAgICB9LFxuICAgIGNhbGxiYWNrOiAodmFsdWUpID0+IGFwcC5zZXREM21Qcm9ibGVtRGVzY3JpcHRpb24ocHJvYkRlc2MsIHZhbHVlKSxcbiAgICBwb3B1cDogdiA9PiB0YXNrW3ZdWzFdLFxuICAgIGF0dHJzSXRlbXM6IHsnZGF0YS1wbGFjZW1lbnQnOiAndG9wJywgJ2RhdGEtb3JpZ2luYWwtdGl0bGUnOiB0aXRsZSArICcgRGVzY3JpcHRpb24nfVxufSk7XG5cbmZ1bmN0aW9uIHJpZ2h0cGFuZWwobW9kZSkge1xuICAgIGxldCB0aHVtYiA9IChpZHgsIGlkLCB0aXRsZSkgPT5cbiAgICAgICAgbShcInRoXCIsXG4gICAgICAgICAgbShcImZpZ3VyZVwiLCB7c3R5bGU6IHtmbG9hdDogXCJsZWZ0XCJ9fSxcbiAgICAgICAgICAgIG0oYGltZyMke2lkfV9pbWdbYWx0PSR7aWR9XVtzcmM9L3N0YXRpYy9pbWFnZXMvdGh1bWIke2lkeH0ucG5nXWAsXG4gICAgICAgICAgICAgIHtzdHlsZToge3dpZHRoOiBcIjc1JVwiLCBoZWlnaHQ6IFwiNzUlXCIsIGJvcmRlcjogXCIxcHggc29saWQgI2RkZFwiLCBcImJvcmRlci1yYWRpdXNcIjogXCIzcHhcIiwgcGFkZGluZzogXCI1cHhcIiwgbWFyZ2luOiBcIjMlXCIsIGN1cnNvcjogXCJwb2ludGVyXCJ9fSksXG4gICAgICAgICAgICBtKFwiZmlnY2FwdGlvblwiLCB7c3R5bGU6IHtcInRleHQtYWxpZ25cIjogXCJjZW50ZXJcIn19LCB0aXRsZSkpKTtcblxuICAgIGlmIChtb2RlID09PSAncmVzdWx0cycpIHJldHVybiBbXTtcbiAgICBpZiAobW9kZSA9PT0gJ2V4cGxvcmUnKSB7XG4gICAgICAgIGxldCBzZWN0aW9uc0V4cGxvcmUgPSBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFsdWU6ICdVbml2YXJpYXRlJyxcbiAgICAgICAgICAgICAgICBjb250ZW50czogW1xuICAgICAgICAgICAgICAgICAgICBtKCcjZGVjaXNpb25fcHJvbXB0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGBSaWdodCBjbGljayBwZWJibGUgdmFyaWFibGVzIHRvIGRyYXcgbGlua3MgYmV0d2VlbiB0aGVtLiBTZWxlY3QgYSB2YXJpYWJsZSBpbiB0aGUgbGlzdCBvZiBsaW5rZWQgcGViYmxlcyBiZWxvdyB0byBkcmF3IGEgZGVjaXNpb24gdHJlZSBmb3IgdGhhdCB2YXJpYWJsZS5gKSxcbiAgICAgICAgICAgICAgICAgICAgbSgnI2RlY2lzaW9uVHJlZVtzdHlsZT13aWR0aDogMTAwJTsgaGVpZ2h0OjgwJTsgb3ZlcmZsb3cteTpzY3JvbGw7IGZsb2F0OiBsZWZ0OyB3aGl0ZS1zcGFjZTogbm93cmFwOyBtYXJnaW4tdG9wOiAycHg7XScpLFxuICAgICAgICAgICAgICAgICAgICBtKFBhbmVsTGlzdCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICd2YXJMaXN0RXhwbG9yZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtczogYXBwLm5vZGVzLm1hcChuID0+IG4ubmFtZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcnM6IHtbYXBwLmhleFRvUmdiYShjb21tb24uc2VsVmFyQ29sb3IpXTogW2V4cC5leHBsb3JlVmFyXX0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogdmFyaWFibGUgPT4gZXhwLmNhbGxUcmVlQXBwKHZhcmlhYmxlLCBhcHApLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnNBbGw6IHtzdHlsZToge2Zsb2F0OiAnbGVmdCcsIHdpZHRoOiAnMTAwJScsIGhlaWdodDogJzIwJSd9fVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAvLyBtKCcjdmFyTGlzdFtzdHlsZT1kaXNwbGF5OiBibG9ja10nLFxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgdW5pcXVlX2xpbmtfbmFtZXMoKS5tYXAoeCA9PiBtKGBwIyR7eC5yZXBsYWNlKC9cXFcvZywgJ18nKX1gLCB7b25jbGljazogXz0+IGV4cC5jYWxsVHJlZUFwcCh4LCBhcHApLCBzdHlsZTogeydiYWNrZ3JvdW5kLWNvbG9yJzogYXBwLnZhckNvbG9yfX0sIHgpKSkpXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogJ0JpdmFyaWF0ZScsXG4gICAgICAgICAgICAgICAgY29udGVudHM6IFtcbiAgICAgICAgICAgICAgICAgICAgbSgnI3Jlc3VsdF9wcm9tcHQnLCB7c3R5bGU6IHtkaXNwbGF5OiBhcHAuZXhwbG9yZWQgPyAnbm9uZScgOiAnYmxvY2snfX0sIGBDbGljayAnRXhwbG9yZScgZm9yIGludGVyYWN0aXZlIHBsb3RzLmApLFxuICAgICAgICAgICAgICAgICAgICBtKCcjbW9kZWxWaWV3X0NvbnRhaW5lcicsIHtzdHlsZTogYHdpZHRoOiAxMDAlOyBmbG9hdDogbGVmdDsgd2hpdGUtc3BhY2U6IG5vd3JhcDtgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG0oJyNtb2RlbFZpZXcnLCB7c3R5bGU6ICd3aWR0aDogMTAwJTsgZmxvYXQ6IGxlZnQnfSkpLFxuICAgICAgICAgICAgICAgICAgICBhcHAucGlwZWxpbmVUYWJsZSA/IG0oVGFibGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAncGlwZWxpbmVUYWJsZUV4cGxvcmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogYXBwLnBpcGVsaW5lSGVhZGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogYXBwLnBpcGVsaW5lVGFibGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVSb3c6IGFwcC5zZWxlY3RlZFBpcGVsaW5lW2FwcC5jdXJyZW50TW9kZV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvbmNsaWNrOiBhcHAuc2V0U2VsZWN0ZWRQaXBlbGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3dVSUQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWJicmV2aWF0aW9uOiAyMFxuICAgICAgICAgICAgICAgICAgICB9KSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgbSgnI3Jlc3VsdF9sZWZ0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtzdHlsZToge2Rpc3BsYXk6IGFwcC5leHBsb3JlZCA/ICdibG9jaycgOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwid2lkdGhcIjogXCI1MCVcIiwgXCJoZWlnaHRcIjogXCIxMDAlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZmxvYXRcIjogXCJsZWZ0XCIsIFwib3ZlcmZsb3cteVwiOiBcImF1dG9cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ3aGl0ZS1zcGFjZVwiOiBcIm5vd3JhcFwiLCBcInBhZGRpbmctcmlnaHRcIjogXCIxMHB4XCJ9fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG0oJyNsZWZ0X3RodW1ibmFpbCcsIHtzdHlsZToge1wid2lkdGhcIjogXCIxMDAlXCIsIFwid2hpdGUtc3BhY2VcIjogXCJub3dyYXBcIn19LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRodW1iKDEsICdzY2F0dGVycGxvdCcsIFwiU2NhdHRlciBQbG90XCIpLCB0aHVtYigyLCAnaGVhdG1hcCcsIFwiSGVhdG1hcFwiKSwgdGh1bWIoMywgJ2xpbmVjaGFydCcsIFwiTGluZWNoYXJ0XCIpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG0oJyNyZXN1bHRfbGVmdDEnLCB7c3R5bGU6IHt3aWR0aDogXCIxMDAlXCIsIFwidGV4dC1hbGlnblwiOiBcImNlbnRlclwiLCBcIndoaXRlLXNwYWNlXCI6IFwibm93cmFwXCJ9fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKFwiLmNvbnRhaW5lcjNbaWQ9c2NhdHRlcnBsb3RdXCIsIHtzdHlsZToge1wid2lkdGhcIjogXCI1MDBweFwiLCBcImhlaWdodFwiOiBcIjgwJVwiLCBcImZsb2F0XCI6IFwibGVmdFwiLCBcIm92ZXJmbG93XCI6IFwiaGlkZGVuXCJ9fSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbShcIi5jb250YWluZXI0W2lkPWhlYXRjaGFydF1cIiwge3N0eWxlOiB7XCJkaXNwbGF5XCI6IFwibm9uZVwiLCBcIndpZHRoXCI6IFwiNTAwcHhcIiwgXCJoZWlnaHRcIjogXCI4MCVcIiwgXCJmbG9hdFwiOiBcImxlZnRcIiwgXCJvdmVyZmxvd1wiOiBcImhpZGRlblwifX0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0oXCIuY29udGFpbmVyNFtpZD1saW5lY2hhcnRdXCIsIHtzdHlsZToge1wiZGlzcGxheVwiOiBcIm5vbmVcIiwgXCJ3aWR0aFwiOiBcIjUwMHB4XCIsIFwiaGVpZ2h0XCI6IFwiODAlXCIsIFwiZmxvYXRcIjogXCJsZWZ0XCIsIFwib3ZlcmZsb3dcIjogXCJoaWRkZW5cIn19KSksXG4gICAgICAgICAgICAgICAgICAgICAgICBtKFwiZGl2XCIsIHtzdHlsZToge1wiZGlzcGxheVwiOiBcImlubGluZS1ibG9ja1wiLCBcIndpZHRoXCI6IFwiMTAwJVwiLCBcImZsb2F0XCI6IFwibGVmdFwiLCBcInRleHQtYWxpZ25cIjogXCJjZW50ZXJcIn19LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0oXCJoNSNOQWNvdW50XCIsIHtzdHlsZToge1wiIG1hcmdpbi1ib3R0b21cIjogXCIwXCJ9fSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbShcIi5jb250YWluZXIyW2lkPSdyZXN1bHRzVmlld19zdGF0aXN0aWNzJ11cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7c3R5bGU6IHtcIndpZHRoXCI6IFwiMTAwJVwiLCBcImZsb2F0XCI6IFwibGVmdFwiLCBcIndoaXRlLXNwYWNlXCI6IFwibm93cmFwXCJ9fSkpLFxuICAgICAgICAgICAgICAgICAgICBtKCcjcmVzdWx0X3JpZ2h0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtzdHlsZToge2Rpc3BsYXk6IGFwcC5leHBsb3JlZCA/ICdibG9jaycgOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBcIjUwJVwiLCBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG9hdDogXCJyaWdodFwiLCBcIndoaXRlLXNwYWNlXCI6IFwibm93cmFwXCIsIFwicGFkZGluZy1sZWZ0XCI6IFwiMTBweFwifX0sXG4gICAgICAgICAgICAgICAgICAgICAgICBtKCcjcmVzdWx0c1ZpZXdfdGFidWxhci5jb250YWluZXIxJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7c3R5bGU6IHt3aWR0aDogXCIxMDAlXCIsIGhlaWdodDogXCIxMDAlXCIsIGZsb2F0OiBcImxlZnRcIiwgb3ZlcmZsb3c6IFwiYXV0b1wiLCBcIndoaXRlLXNwYWNlXCI6IFwibm93cmFwXCJ9fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKCcjU2VsZWN0aW9uRGF0YScsIHtzdHlsZToge3dpZHRoOiBcIjEwMCVcIn19LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKFwiZmllbGRzZXRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0oXCJoNFwiLCB7c3R5bGU6IHtcInRleHQtYWxpZ25cIjogXCJjZW50ZXJcIn19LCBcIkRhdGEgRGlzdHJpYnV0aW9uIFNlbGVjdGlvblwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0oXCJwXCIsIFwiRW50ZXIgbnVtYmVyIGZvciBlYWNoIHZhcmlhYmxlIHRvIHNwZWNpZnkgdGhlIGJyZWFrIHBvaW50cywgYW5kIHNlbGVjdCBiZXR3ZWVuIEVxdWlkaXN0YW50L0VxdWltYXNzXCIpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbSgnI3Bsb3RCcmVha0lucHV0cycsIHtzdHlsZToge2hlaWdodDogJzYwcHgnfX0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKCcjZm9yUGxvdEEnLCB7c3R5bGU6IHtkaXNwbGF5OiAnaW5saW5lJywgZmxvYXQ6IFwibGVmdFwiLCB3aWR0aDogJzUwJSd9fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKFwiaW5wdXQjaW5wdXQxW25hbWU9J2ZuYW1lJ11bdHlwZT0ndGV4dCddXCIsIHtzdHlsZToge1wibWFyZ2luLWxlZnRcIjogXCIyJVwifX0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0oJ3NwYW4jdG9vbHRpcFBsb3RBLnRvb2x0aXB0ZXh0W3N0eWxlPXZpc2liaWxpdHk6IGhpZGRlbl0nKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKFwiYnV0dG9uLmJ0bi5idG4tZGVmYXVsdC5idG4teHMjRXF1aWRpc3RhbmNlMVt0eXBlPSdidXR0b24nXVwiLCB7c3R5bGU6IHtmbG9hdDogXCJsZWZ0XCIsIFwibWFyZ2luLWxlZnRcIjogXCIyJVwifX0sIFwiRVFVSURJU1RBTkNFXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0oXCJidXR0b24uYnRuLmJ0bi1kZWZhdWx0LmJ0bi14cyNFcXVpbWFzczFbdHlwZT0nYnV0dG9uJ11cIiwge3N0eWxlOiB7ZmxvYXQ6IFwibGVmdFwiLCBcIm1hcmdpbi1sZWZ0XCI6IFwiMiVcIn19LCBcIkVRVUlNQVNTXCIpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0oJyNmb3JQbG90QicsIHtzdHlsZToge2Rpc3BsYXk6ICdpbmxpbmUnLCBmbG9hdDogXCJyaWdodFwiLCB3aWR0aDogJzUwJSd9fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKFwiaW5wdXQjaW5wdXQyW25hbWU9J2ZuYW1lMSddW3R5cGU9J3RleHQnXVwiLCB7c3R5bGU6IHtcIm1hcmdpbi1sZWZ0XCI6IFwiMiVcIn19KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKCdzcGFuI3Rvb2x0aXBQbG90Qi50b29sdGlwdGV4dDFbc3R5bGU9dmlzaWJpbGl0eTogaGlkZGVuXScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0oXCJidXR0b24uYnRuLmJ0bi1kZWZhdWx0LmJ0bi14cyNFcXVpZGlzdGFuY2UyW3R5cGU9J2J1dHRvbiddXCIsIHtzdHlsZToge2Zsb2F0OiBcImxlZnRcIiwgXCJtYXJnaW4tbGVmdFwiOiBcIjIlXCJ9fSwgXCJFUVVJRElTVEFOQ0VcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbShcImJ1dHRvbi5idG4uYnRuLWRlZmF1bHQuYnRuLXhzI0VxdWltYXNzMlt0eXBlPSdidXR0b24nXVwiLCB7c3R5bGU6IHtmbG9hdDogXCJsZWZ0XCIsIFwibWFyZ2luLWxlZnRcIjogXCIyJVwifX0sIFwiRVFVSU1BU1NcIikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0oJ2RpdiNzdGF0dXNlc0JpdmFyaWF0ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKFwiZGl2I3Bsb3RBX3N0YXR1c1wiLCB7c3R5bGU6IHt3aWR0aDogJzEwMCUnfX0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbShcImRpdiNwbG90Ql9zdGF0dXNcIiwge3N0eWxlOiB7d2lkdGg6ICcxMDAlJ319KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0oJ2g1W3N0eWxlPWNvbG9yOiAjYWMyOTI1OyBtYXJnaW4tdG9wOiAxJTsgbWFyZ2luLWxlZnQ6IDIlXScsICdTZWxlY3Rpb24gSGlzdG9yeScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKFwiYnV0dG9uLmJ0bi5idG4tZGVmYXVsdC5idG4tc21baWQ9J1NlbGVjdGlvbkRhdGExJ11bdHlwZT0nYnV0dG9uJ11cIiwge3N0eWxlOiB7ZGlzcGxheTogXCJibG9ja1wiLCBtYXJnaW46IFwiMCBhdXRvXCIsIHBvc2l0aW9uOiBcInJlbGF0aXZlXCJ9fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiQ3JlYXRlXCIpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKCcjdGFidWxhcl8xJywge3N0eWxlOiB7d2lkdGg6IFwiMTAwJVwiLCBoZWlnaHQ6IFwiMjAwcHhcIn19LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKCcjcGxvdEEnLCB7c3R5bGU6IHt3aWR0aDogZXhwLmdldF93aWR0aCgncGxvdEEnKSArICclJywgaGVpZ2h0OiBcIjEwMCVcIiwgZmxvYXQ6IFwibGVmdFwiLCBvdmVyZmxvdzogXCJoaWRkZW5cIn19LCBcInBsb3RBXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtKCcjcGxvdEInLCB7c3R5bGU6IHt3aWR0aDogZXhwLmdldF93aWR0aCgncGxvdEInKSArICclJywgaGVpZ2h0OiBcIjEwMCVcIiwgZmxvYXQ6IFwicmlnaHRcIiwgb3ZlcmZsb3c6IFwiaGlkZGVuXCJ9fSwgXCJwbG90QlwiKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbSgnI3RhYnVsYXJfMicsIHtzdHlsZToge3dpZHRoOiBcIjEwMCVcIn19KSkpXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfVxuICAgICAgICBdO1xuXG4gICAgICAgIHJldHVybiBtKFBhbmVsLCB7XG4gICAgICAgICAgICBzaWRlOiAncmlnaHQnLFxuICAgICAgICAgICAgbGFiZWw6ICdSZXN1bHQgRXhwbG9yYXRpb24nLFxuICAgICAgICAgICAgaG92ZXI6IHRydWUsXG4gICAgICAgICAgICB3aWR0aDogYXBwLmV4cGxvcmVSaWdodFBhbmVsV2lkdGhzW2FwcC5yaWdodFRhYkV4cGxvcmVdXG4gICAgICAgIH0sIG0oTWVudVRhYmJlZCwge1xuICAgICAgICAgICAgaWQ6ICdyaWdodFBhbmVsTWVudUV4cGxvcmUnLFxuICAgICAgICAgICAgY3VycmVudFRhYjogYXBwLnJpZ2h0VGFiRXhwbG9yZSxcbiAgICAgICAgICAgIGNhbGxiYWNrOiBhcHAuc2V0UmlnaHRUYWJFeHBsb3JlLFxuICAgICAgICAgICAgc2VjdGlvbnM6IHNlY3Rpb25zRXhwbG9yZSxcbiAgICAgICAgICAgIGF0dHJzQWxsOiB7c3R5bGU6IHtoZWlnaHQ6ICdjYWxjKDEwMCUgLSAzOXB4KSd9fVxuICAgICAgICB9KSk7XG4gICAgfVxuXG4gICAgLy8gbW9kZSA9PSBudWxsIChtb2RlbCBtb2RlKVxuXG4gICAgbGV0IHNlY3Rpb25zID0gW1xuICAgICAgICAvLyB7dmFsdWU6ICdNb2RlbHMnLFxuICAgICAgICAvLyAgZGlzcGxheTogYXBwLklTX0QzTV9ET01BSU4gPyAnYmxvY2snIDogJ25vbmUnLFxuICAgICAgICAvLyAgY29udGVudHM6IHJpZ2h0dGFiKCdtb2RlbHMnKX0sXG4gICAgICAgIHt2YWx1ZTogJ1Rhc2sgVHlwZScsXG4gICAgICAgICBpZFN1ZmZpeDogJ1R5cGUnLFxuICAgICAgICAgY29udGVudHM6IHJpZ2h0dGFiKCd0eXBlcycsIGFwcC5kM21UYXNrVHlwZSwgJ1Rhc2snLCAndGFza1R5cGUnKX0sXG4gICAgICAgIHt2YWx1ZTogJ1N1YnR5cGUnLFxuICAgICAgICAgY29udGVudHM6IHJpZ2h0dGFiKCdzdWJ0eXBlcycsIGFwcC5kM21UYXNrU3VidHlwZSwgJ1Rhc2sgU3VidHlwZScsICd0YXNrU3VidHlwZScpfSxcbiAgICAgICAge3ZhbHVlOiAnTWV0cmljcycsXG4gICAgICAgICBjb250ZW50czogcmlnaHR0YWIoJ21ldHJpY3MnLCBhcHAuZDNtTWV0cmljcywgJ01ldHJpYycsICdtZXRyaWMnKX0sXG4gICAgICAgIHt2YWx1ZTogJ1Jlc3VsdHMnLFxuICAgICAgICAgZGlzcGxheTogIWFwcC5zd2FuZGl2ZSB8fCBhcHAuSVNfRDNNX0RPTUFJTiA/ICdibG9jaycgOiAnbm9uZScsXG4gICAgICAgICBpZFN1ZmZpeDogJ1NldHgnLFxuICAgICAgICAgY29udGVudHM6IFtcbiAgICAgICAgICAgICBtKCcjc2V0eFJpZ2h0W3N0eWxlPWRpc3BsYXk6YmxvY2s7IGZsb2F0OiByaWdodDsgd2lkdGg6IDI1JTsgaGVpZ2h0OjEwMCU7IGJhY2tncm91bmQtY29sb3I6IHdoaXRlXScsXG4gICAgICAgICAgICAgICBhcHAucGlwZWxpbmVUYWJsZSA/IG0oVGFibGUsIHtcbiAgICAgICAgICAgICAgICAgICBpZDogJ3BpcGVsaW5lVGFibGUnLFxuICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGFwcC5waXBlbGluZUhlYWRlcixcbiAgICAgICAgICAgICAgICAgICBkYXRhOiBhcHAucGlwZWxpbmVUYWJsZSxcbiAgICAgICAgICAgICAgICAgICBhY3RpdmVSb3c6IGFwcC5zZWxlY3RlZFBpcGVsaW5lW2FwcC5jdXJyZW50TW9kZV0sXG4gICAgICAgICAgICAgICAgICAgb25jbGljazogYXBwLnNldFNlbGVjdGVkUGlwZWxpbmUsXG4gICAgICAgICAgICAgICAgICAgc2hvd1VJRDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgYWJicmV2aWF0aW9uOiAyMFxuICAgICAgICAgICAgICAgfSkgOiB1bmRlZmluZWQpLFxuICAgICAgICAgICAgIG0oJyNzZXR4VG9wW3N0eWxlPWRpc3BsYXk6YmxvY2s7IGZsb2F0OiBsZWZ0OyB3aWR0aDogNzUlOyBoZWlnaHQ6MTAlOyBvdmVyZmxvdzogYXV0bzsgYmFja2dyb3VuZC1jb2xvcjogd2hpdGVdJyxcbiAgICAgICAgICAgICAgIG0oXCJidXR0b24uYnRuLmJ0bi1kZWZhdWx0LmJ0bi14cyNidG5QcmVkUGxvdFt0eXBlPSdidXR0b24nXVwiLCB7XG4gICAgICAgICAgICAgICAgICAgb25jbGljazogKCkgPT4gYXBwLnNob3dQcmVkUGxvdCgnYnRuUHJlZFBsb3QnKSxcbiAgICAgICAgICAgICAgICAgICBzdHlsZToge2Zsb2F0OiBcImxlZnRcIiwgXCJtYXJnaW4tbGVmdFwiOiBcIjIlXCJ9XG4gICAgICAgICAgICAgICB9LCBcIlByZWRpY3Rpb24gU3VtbWFyeVwiKSxcbiAgICAgICAgICAgICAgIG0oXCJidXR0b24uYnRuLmJ0bi1kZWZhdWx0LmJ0bi14cyNidG5HZW5QcmVkc1t0eXBlPSdidXR0b24nXVwiLCB7XG4gICAgICAgICAgICAgICAgICAgb25jbGljazogKCkgPT4gYXBwLnNob3dHZW5QcmVkcygnYnRuR2VuUHJlZHMnKSxcbiAgICAgICAgICAgICAgICAgICBzdHlsZToge2Zsb2F0OiBcImxlZnRcIiwgXCJtYXJnaW4tbGVmdFwiOiBcIjIlXCJ9XG4gICAgICAgICAgICAgICB9LCBcIkdlbmVyYXRlIE5ldyBQcmVkaWN0aW9uc1wiKSksXG4gICAgICAgICAgICAgbSgnI3NldHhMZWZ0UGxvdFtzdHlsZT1kaXNwbGF5OmJsb2NrOyBmbG9hdDogbGVmdDsgd2lkdGg6IDc1JTsgaGVpZ2h0Ojk1JTsgb3ZlcmZsb3c6IGF1dG87IGJhY2tncm91bmQtY29sb3I6IHdoaXRlXScpLFxuICAgICAgICAgICAgIG0oJyNzZXR4TGVmdFtzdHlsZT1kaXNwbGF5Om5vbmU7IGZsb2F0OiBsZWZ0OyB3aWR0aDogNzUlOyBoZWlnaHQ6OTUlOyBvdmVyZmxvdzogYXV0bzsgYmFja2dyb3VuZC1jb2xvcjogd2hpdGVdJyksXG4gICAgICAgICAgICAgbSgnI3NldHhMZWZ0R2VuW3N0eWxlPWRpc3BsYXk6bm9uZTsgZmxvYXQ6IGxlZnQ7IHdpZHRoOiA3NSU7IGhlaWdodDo5NSU7IG92ZXJmbG93OiBhdXRvOyBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZV0nLFxuICAgICAgICAgICAgICAgbSgnI3NldHhMZWZ0VG9wW3N0eWxlPWRpc3BsYXk6YmxvY2s7IGZsb2F0OiBsZWZ0OyB3aWR0aDogMTAwJTsgaGVpZ2h0OjUwJTsgb3ZlcmZsb3c6IGF1dG87IGJhY2tncm91bmQtY29sb3I6IHdoaXRlXScsXG4gICAgICAgICAgICAgICAgIG0oJyNzZXR4TGVmdFRvcExlZnRbc3R5bGU9ZGlzcGxheTpibG9jazsgZmxvYXQ6IGxlZnQ7IHdpZHRoOiAzMCU7IGhlaWdodDoxMDAlOyBvdmVyZmxvdzogYXV0bzsgYmFja2dyb3VuZC1jb2xvcjogd2hpdGVdJyksXG4gICAgICAgICAgICAgICAgIG0oJyNzZXR4TGVmdFRvcFJpZ2h0W3N0eWxlPWRpc3BsYXk6YmxvY2s7IGZsb2F0OiBsZWZ0OyB3aWR0aDogNzAlOyBoZWlnaHQ6MTAwJTsgb3ZlcmZsb3c6IGF1dG87IGJhY2tncm91bmQtY29sb3I6IHdoaXRlXScpKSxcbiAgICAgICAgICAgICAgIG0oJyNzZXR4TGVmdEJvdHRvbUxlZnRbc3R5bGU9ZGlzcGxheTpibG9jazsgZmxvYXQ6IGxlZnQ7IHdpZHRoOiA3MCU7IGhlaWdodDo1MCU7IG92ZXJmbG93OiBhdXRvOyBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZV0nKSxcbiAgICAgICAgICAgICAgIG0oJyNzZXR4TGVmdEJvdHRvbVJpZ2h0VG9wW3N0eWxlPWRpc3BsYXk6YmxvY2s7IGZsb2F0OiBsZWZ0OyB3aWR0aDogMzAlOyBoZWlnaHQ6MTAlOyBvdmVyZmxvdzogYXV0bzsgYmFja2dyb3VuZC1jb2xvcjogd2hpdGVdJyxcbiAgICAgICAgICAgICAgICAgbShCdXR0b24sXG4gICAgICAgICAgICAgICAgICAge2lkOiAnYnRuRXhlY3V0ZVBpcGUnLFxuICAgICAgICAgICAgICAgICAgICBjbGFzc2VzOiAnYnRuLWRlZmF1bHQubGFkZGEtYnV0dG9uW2RhdGEtc3Bpbm5lci1jb2xvcj0jMDAwMDAwXVtkYXRhLXN0eWxlPXpvb20taW5dJyxcbiAgICAgICAgICAgICAgICAgICAgb25jbGljazogKCkgPT4gYXBwLmV4ZWN1dGVwaXBlbGluZSgnYnRuRXhlY3V0ZVBpcGUnKSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IGBkaXNwbGF5OmlubGluZTsgZmxvYXQ6IGxlZnQ7IG1hcmdpbi1yaWdodDogMTBweGAsXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiAnRXhlY3V0ZSBwaXBlbGluZS4nfSxcbiAgICAgICAgICAgICAgICAgICBtKCdzcGFuLmxhZGRhLWxhYmVsW3N0eWxlPXBvaW50ZXItZXZlbnRzOiBub25lXScsICdFeGVjdXRlIEdlbmVyYXRpb24nKSkpLFxuICAgICAgICAgICAgICAgbSgnI3NldHhMZWZ0Qm90dG9tUmlnaHRCb3R0b21bc3R5bGU9ZGlzcGxheTpibG9jazsgZmxvYXQ6IGxlZnQ7IHdpZHRoOiAzMCU7IGhlaWdodDo0MCU7IG92ZXJmbG93OiBhdXRvOyBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZV0nKSlcbiAgICAgICAgIF19XG4gICAgXTtcblxuICAgIHJldHVybiBtKFBhbmVsLCB7XG4gICAgICAgIHNpZGU6ICdyaWdodCcsXG4gICAgICAgIGxhYmVsOiAnTW9kZWwgU2VsZWN0aW9uJyxcbiAgICAgICAgaG92ZXI6IHRydWUsXG4gICAgICAgIHdpZHRoOiBhcHAubW9kZWxSaWdodFBhbmVsV2lkdGhzW2FwcC5yaWdodFRhYl1cbiAgICB9LCBtKE1lbnVUYWJiZWQsIHtcbiAgICAgICAgaWQ6ICdyaWdodHBhbmVsTWVudScsXG4gICAgICAgIGN1cnJlbnRUYWI6IGFwcC5yaWdodFRhYixcbiAgICAgICAgY2FsbGJhY2s6IGFwcC5zZXRSaWdodFRhYixcbiAgICAgICAgaG92ZXJCb251czogMTAsXG4gICAgICAgIHNlbGVjdFdpZHRoOiAzMCxcbiAgICAgICAgc2VjdGlvbnM6IHNlY3Rpb25zLFxuICAgICAgICBhdHRyc0FsbDoge3N0eWxlOiB7aGVpZ2h0OiAnY2FsYygxMDAlIC0gMzlweCknfX1cbiAgICB9KSk7XG59XG5cblxubGV0IGdseXBoID0gKGljb24sIHVuc3R5bGVkKSA9PiBtKFxuICAgIGBzcGFuLmdseXBoaWNvbi5nbHlwaGljb24tJHtpY29ufWAgKyAodW5zdHlsZWQgPyAnJyA6ICdbc3R5bGU9Y29sb3I6ICM4MTgxODE7IGZvbnQtc2l6ZTogMWVtOyBwb2ludGVyLWV2ZW50czogbm9uZV0nKSk7XG5cbmNsYXNzIEJvZHkge1xuICAgIG9uaW5pdCh2bm9kZSkge1xuICAgICAgICBpZiAodm5vZGUuYXR0cnMubW9kZSkge1xuICAgICAgICAgICAgbS5yb3V0ZS5zZXQoJy9tb2RlbCcpO1xuICAgICAgICAgICAgdm5vZGUuYXR0cnMubW9kZSA9IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYWJvdXQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy51c2VydGFza3MgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jaXRlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2l0ZUhpZGRlbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxhc3RfbW9kZSA9IG51bGw7XG4gICAgfVxuXG4gICAgb25jcmVhdGUoKSB7XG4gICAgICAgIGxldCBleHRyYWN0ID0gKG5hbWUsIGtleSwgb2Zmc2V0LCByZXBsYWNlKSA9PiB7XG4gICAgICAgICAgICBrZXkgPSBrZXkgKyAnPSc7XG4gICAgICAgICAgICBsZXQgbG9jID0gd2luZG93LmxvY2F0aW9uLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBsZXQgdmFsID0gbG9jLmluZGV4T2Yoa2V5KSA+IDAgPyBsb2Muc3Vic3RyaW5nKGxvYy5pbmRleE9mKGtleSkgKyBvZmZzZXQpIDogJyc7XG4gICAgICAgICAgICBsZXQgaWR4ID0gdmFsLmluZGV4T2YoJyYnKTtcbiAgICAgICAgICAgIHZhbCA9IGlkeCA+IDAgPyB2YWwuc3Vic3RyaW5nKDAsIGlkeCkgOiB2YWw7XG4gICAgICAgICAgICB2YWwgPSB2YWwucmVwbGFjZSgnIyEvbW9kZWwnLCAnJyk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhuYW1lLCAnOiAnLCB2YWwpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2UgP1xuICAgICAgICAgICAgICAgIHZhbFxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJTI1L2csICclJylcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyUzQS9nLCAnOicpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8lMkYvZywgJy8nKVxuICAgICAgICAgICAgICAgIDogdmFsO1xuICAgICAgICB9O1xuICAgICAgICBhcHAubWFpbihcbiAgICAgICAgICAgIGV4dHJhY3QoJ2ZpbGVpZCcsICdkZklkJywgNSksXG4gICAgICAgICAgICBleHRyYWN0KCdob3N0bmFtZScsICdob3N0JywgNSksXG4gICAgICAgICAgICBleHRyYWN0KCdkZGl1cmwnLCAnZGRpdXJsJywgNywgdHJ1ZSksXG4gICAgICAgICAgICBleHRyYWN0KCdkYXRhdXJsJywgJ2RhdGF1cmwnLCA4LCB0cnVlKSxcbiAgICAgICAgICAgIGV4dHJhY3QoJ2FwaWtleScsICdrZXknLCA0KSk7XG4gICAgfVxuXG4gICAgdmlldyh2bm9kZSkge1xuICAgICAgICBsZXQge21vZGV9ID0gdm5vZGUuYXR0cnM7XG4gICAgICAgIGxldCBleHBsb3JlX21vZGUgPSBtb2RlID09PSAnZXhwbG9yZSc7XG4gICAgICAgIGxldCByZXN1bHRzX21vZGUgPSBtb2RlID09PSAncmVzdWx0cyc7XG5cbiAgICAgICAgbGV0IHNwYWNlQnRuID0gKGlkLCBvbmNsaWNrLCB0aXRsZSwgaWNvbikgPT4gbShcbiAgICAgICAgICAgIGBidXR0b24jJHtpZH0uYnRuLmJ0bi1kZWZhdWx0YCwge29uY2xpY2ssIHRpdGxlfSwgZ2x5cGgoaWNvbiwgdHJ1ZSkpO1xuXG4gICAgICAgIGlmIChtb2RlICE9IHRoaXMubGFzdF9tb2RlKSB7XG4gICAgICAgICAgICBhcHAuc2V0X21vZGUobW9kZSk7XG4gICAgICAgICAgICBpZiAoZXhwbG9yZV9tb2RlKSB7XG4gICAgICAgICAgICAgICAgYXBwLmV4cGxvcmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYXBwLnVuaXZhcmlhdGVfZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBhcHAuc2V0UmlnaHRUYWJFeHBsb3JlKCdVbml2YXJpYXRlJyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdHNfbW9kZSkge1xuICAgICAgICAgICAgICAgIGFwcC5zZXRSaWdodFRhYihJU19EM01fRE9NQUlOID8gJ1Rhc2sgVHlwZScgOiAnTW9kZWxzJyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFtb2RlKSB7XG4gICAgICAgICAgICAgICAgYXBwLnNldFJpZ2h0VGFiKElTX0QzTV9ET01BSU4gPyAnVGFzayBUeXBlJyA6ICdNb2RlbHMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFwcC5yZXN0YXJ0ICYmIGFwcC5yZXN0YXJ0KCk7XG4gICAgICAgICAgICB0aGlzLmxhc3RfbW9kZSA9IG1vZGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbSgnbWFpbicsIFtcbiAgICAgICAgICAgIG0oTW9kYWwpLFxuICAgICAgICAgICAgdGhpcy5oZWFkZXIobW9kZSksXG4gICAgICAgICAgICB0aGlzLmZvb3Rlcihtb2RlKSxcbiAgICAgICAgICAgIG0oYCNtYWluLmxlZnQuY2Fyb3VzZWwuc2xpZGUuc3ZnLWxlZnRwYW5lbC5zdmctcmlnaHRwYW5lbFtzdHlsZT1vdmVyZmxvdzogaGlkZGVuXWAsXG4gICAgICAgICAgICAgIG0oXCIjaW5uZXJjYXJvdXNlbC5jYXJvdXNlbC1pbm5lclwiLCB7c3R5bGU6IHtoZWlnaHQ6IGBjYWxjKDEwMCUgKyAke2FwcC5tYXJnaW5Ub3BDYXJvdXNlbH1weClgfX0sXG4gICAgICAgICAgICAgICAgbSgnI20wLml0ZW0uYWN0aXZlJywge3N0eWxlOiB7aGVpZ2h0OiAnMTAwJScsICd0ZXh0LWFsaWduJzogXCJjZW50ZXJcIn19LFxuICAgICAgICAgICAgICAgICAgbSgnc3ZnI3doaXRlc3BhY2UnKSkpLFxuICAgICAgICAgICAgICBtKFwiI3NwYWNldG9vbHMuc3BhY2VUb29sXCIsIHtzdHlsZToge3JpZ2h0OiBhcHAucGFuZWxXaWR0aFsncmlnaHQnXSwgJ3otaW5kZXgnOiAxNn19LFxuICAgICAgICAgICAgICAgICAgbShgYnV0dG9uI2J0bkxvY2suYnRuLmJ0bi1kZWZhdWx0YCwge1xuICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOiBhcHAubG9ja3RvZ2dsZSA/ICdhY3RpdmUnIDogJycsXG4gICAgICAgICAgICAgICAgICAgICAgb25jbGljazogKCkgPT4gYXBwLmxvY2tEZXNjcmlwdGlvbighYXBwLmxvY2t0b2dnbGUpLFxuICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiAnTG9jayBzZWxlY3Rpb24gb2YgcHJvYmxlbSBkZXNjcmlwdGlvbidcbiAgICAgICAgICAgICAgICAgIH0sIGdseXBoKGFwcC5sb2NrdG9nZ2xlID8gJ2xvY2snIDogJ3BlbmNpbCcsIHRydWUpKSxcbiAgICAgICAgICAgICAgICBzcGFjZUJ0bignYnRuSm9pbicsIF8gPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGlua3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJkb2luZyBjb25uZWN0IGFsbFwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4cGxvcmVfbW9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgbm9kZSBvZiBhcHAubm9kZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBub2RlMSBvZiBhcHAubm9kZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgIT09IG5vZGUxICYmIGxpbmtzLmZpbHRlcihsID0+IGwudGFyZ2V0ID09PSBub2RlMSAmJiBsLnNvdXJjZSA9PT0gbm9kZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rcy5wdXNoKHtsZWZ0OiBmYWxzZSwgcmlnaHQ6IGZhbHNlLCB0YXJnZXQ6IG5vZGUsIHNvdXJjZTogbm9kZTF9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkdnMgPSBhcHAubm9kZXMuZmlsdGVyKG4gPT4gYXBwLnpwYXJhbXMuemR2LmluY2x1ZGVzKG4ubmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5vbGluayA9IGFwcC56cGFyYW1zLnpkdi5jb25jYXQoYXBwLnpwYXJhbXMuemdyb3VwMSkuY29uY2F0KGFwcC56cGFyYW1zLnpncm91cDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGl2cyA9IGFwcC5ub2Rlcy5maWx0ZXIobiA9PiAhbm9saW5rLmluY2x1ZGVzKG4ubmFtZSkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rcyA9IGR2cy5tYXAoZHYgPT4gaXZzLm1hcChpdiA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogaXYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBkdlxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhcHAucmVzdGFydChbXS5jb25jYXQoLi4ubGlua3MpKTtcbiAgICAgICAgICAgICAgICB9LCAnTWFrZSBhbGwgcG9zc2libGUgY29ubmVjdGlvbnMgYmV0d2VlbiBub2RlcycsICdsaW5rJyksXG4gICAgICAgICAgICAgICAgc3BhY2VCdG4oJ2J0bkRpc2Nvbm5lY3QnLCBfID0+IGFwcC5yZXN0YXJ0KFtdKSwgJ0RlbGV0ZSBhbGwgY29ubmVjdGlvbnMgYmV0d2VlbiBub2RlcycsICdyZW1vdmUtY2lyY2xlJyksXG4gICAgICAgICAgICAgICAgc3BhY2VCdG4oJ2J0bkZvcmNlJywgYXBwLmZvcmNlU3dpdGNoLCAnUGluIHRoZSB2YXJpYWJsZSBwZWJibGVzIHRvIHRoZSBwYWdlJywgJ3B1c2hwaW4nKSxcbiAgICAgICAgICAgICAgICBzcGFjZUJ0bignYnRuRXJhc2VyJywgYXBwLmVyYXNlLCAnV2lwZSBhbGwgdmFyaWFibGVzIGZyb20gdGhlIG1vZGVsaW5nIHNwYWNlJywgJ21hZ25ldCcpKSxcbiAgICAgICAgICAgICAgbShTdWJwYW5lbCxcbiAgICAgICAgICAgICAgICB7dGl0bGU6IFwiTGVnZW5kXCIsXG4gICAgICAgICAgICAgICAgIGJ1dHRvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgIFsndGltZUJ1dHRvbicsICd6dGltZScsICdUaW1lJ10sXG4gICAgICAgICAgICAgICAgICAgICBbJ2NzQnV0dG9uJywgJ3pjcm9zcycsICdDcm9zcyBTZWMnXSxcbiAgICAgICAgICAgICAgICAgICAgIFsnZHZCdXR0b24nLCAnemR2JywgJ0RlcCBWYXInXSxcbiAgICAgICAgICAgICAgICAgICAgIFsnbm9tQnV0dG9uJywgJ3pub20nLCAnTm9tIFZhciddLFxuICAgICAgICAgICAgICAgICAgICAgWydncjFCdXR0b24nLCAnemdyb3VwMScsICdHcm91cCAxJ10sXG4gICAgICAgICAgICAgICAgICAgICBbJ2dyMkJ1dHRvbicsICd6Z3JvdXAyJywgJ0dyb3VwIDInXV19KSxcbiAgICAgICAgICAgICAgbShTdWJwYW5lbCwge3RpdGxlOiBcIkhpc3RvcnlcIn0pLFxuICAgICAgICAgICAgICBsZWZ0cGFuZWwobW9kZSksXG4gICAgICAgICAgICAgIHJpZ2h0cGFuZWwobW9kZSkpXG4gICAgICAgIF0pO1xuICAgIH1cblxuICAgIGhlYWRlcihtb2RlKSB7XG4gICAgICAgIGxldCB1c2VybGlua3MgPSB1c2VybmFtZSA9PT0gJ25vIGxvZ2dlZCBpbiB1c2VyJyA/IFtcbiAgICAgICAgICAgIHt0aXRsZTogXCJMb2cgaW5cIiwgdXJsOiBsb2dpbl91cmx9LFxuICAgICAgICAgICAge3RpdGxlOiBcIlNpZ24gdXBcIiwgdXJsOiBzaWdudXBfdXJsfVxuICAgICAgICBdIDogW3t0aXRsZTogXCJXb3Jrc3BhY2VzXCIsIHVybDogd29ya3NwYWNlc191cmx9LFxuICAgICAgICAgICAge3RpdGxlOiBcIlNldHRpbmdzXCIsIHVybDogc2V0dGluZ3NfdXJsfSxcbiAgICAgICAgICAgIHt0aXRsZTogXCJMaW5rc1wiLCB1cmw6IGRldmxpbmtzX3VybH0sXG4gICAgICAgICAgICB7dGl0bGU6IFwiTG9nb3V0XCIsIHVybDogbG9nb3V0X3VybH1dO1xuXG4gICAgICAgIGxldCBfbmF2QnRuID0gKGlkLCBsZWZ0LCByaWdodCwgb25jbGljaywgYXJncywgbWluKSA9PiBtKFxuICAgICAgICAgICAgYGJ1dHRvbiMke2lkfS5idG4ubmF2YmFyLXJpZ2h0YCxcbiAgICAgICAgICAgIHtvbmNsaWNrOiBvbmNsaWNrLFxuICAgICAgICAgICAgIHN0eWxlOiB7J21hcmdpbi1sZWZ0JzogbGVmdCArICdlbScsXG4gICAgICAgICAgICAgICAgICAgICAnbWFyZ2luLXJpZ2h0JzogcmlnaHQgKyAnZW0nLFxuICAgICAgICAgICAgICAgICAgICAgJ21pbi13aWR0aCc6IG1pbn19LFxuICAgICAgICAgICAgYXJncyk7XG4gICAgICAgIGxldCBuYXZCdG4gPSAoaWQsIGxlZnQsIHJpZ2h0LCBvbmNsaWNrLCBhcmdzLCBtaW4pID0+IF9uYXZCdG4oXG4gICAgICAgICAgICBpZCArICcubGFkZGEtYnV0dG9uW2RhdGEtc3Bpbm5lci1jb2xvcj0jMDAwMDAwXVtkYXRhLXN0eWxlPXpvb20taW5dJyxcbiAgICAgICAgICAgIGxlZnQsIHJpZ2h0LCBvbmNsaWNrLCBhcmdzLCBtaW4pO1xuICAgICAgICBsZXQgbmF2QnRuR3JvdXAgPSAoaWQsIG9uY2xpY2ssIGFyZ3MsIG1pbikgPT4gbShcbiAgICAgICAgICAgIGBidXR0b24jJHtpZH0uYnRuLm5hdmJhci1sZWZ0YCxcbiAgICAgICAgICAgIHtvbmNsaWNrOiBvbmNsaWNrLFxuICAgICAgICAgICAgIHN0eWxlOiB7J21pbi13aWR0aCc6IG1pbn19LFxuICAgICAgICAgICAgYXJncyk7XG4gICAgICAgIGxldCBuYXZCdG4xID0gKGlkLCBvbmNsaWNrLCBhcmdzLCB0aXRsZSkgPT4gX25hdkJ0bihcbiAgICAgICAgICAgIGAke2lkfS5idG4tZGVmYXVsdFt0aXRsZT0ke3RpdGxlfV1gLCAyLCAwLCBvbmNsaWNrLCBhcmdzKTtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWF0aW9uID0gKGlkLCBsaXN0KSA9PiBtKFxuICAgICAgICAgICAgYHVsIyR7aWR9YCxcbiAgICAgICAgICAgIHtzdHlsZToge2Rpc3BsYXk6ICdub25lJywgJ2JhY2tncm91bmQtY29sb3InOiBhcHAudmFyQ29sb3J9LFxuICAgICAgICAgICAgIG9uY2xpY2s6IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgICAgICAgICBsZXQgdElucHV0ID0gYXBwLmJ5SWQoJ3RJbnB1dCcpO1xuXG4gICAgICAgICAgICAgICAgIC8vIGlmIGludGVyYWN0IGlzIHNlbGVjdGVkLCBzaG93IHZhcmlhYmxlIGxpc3QgYWdhaW5cbiAgICAgICAgICAgICAgICAgaWYgKHRoaXMudGV4dENvbnRlbnQgPT09ICdpbnRlcmFjdChkLGUpJykge1xuICAgICAgICAgICAgICAgICAgICAgdElucHV0LnZhbHVlID0gdHZhci5jb25jYXQoJyonKTtcbiAgICAgICAgICAgICAgICAgICAgIHNlbEludGVyYWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgIGZhZGVPdXQodGhpcy5wYXJlbnROb2RlLCAxMDApO1xuICAgICAgICAgICAgICAgICAgICAgZmFkZUluKCcjdHJhbnNTZWwnLCAxMDApO1xuICAgICAgICAgICAgICAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgbGV0IHR2YXIgPSB0SW5wdXQudmFsdWU7XG4gICAgICAgICAgICAgICAgIGxldCB0ZnVuYyA9IHRoaXMudGV4dENvbnRlbnQucmVwbGFjZShcImRcIiwgXCJfdHJhbnN2YXIwXCIpO1xuICAgICAgICAgICAgICAgICBsZXQgdGNhbGwgPSB0aGlzLnRleHRDb250ZW50LnJlcGxhY2UoXCJkXCIsIHR2YXIpO1xuICAgICAgICAgICAgICAgICB0SW5wdXQudmFsdWUgPSB0Y2FsbDtcbiAgICAgICAgICAgICAgICAgZmFkZU91dCh0aGlzLnBhcmVudE5vZGUsIDEwMCk7XG4gICAgICAgICAgICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgdHJhbnNmb3JtKHR2YXIsIHRmdW5jLCB0eXBlVHJhbnNmb3JtID0gZmFsc2UpO1xuICAgICAgICAgICAgIH19LFxuICAgICAgICAgICAgbGlzdC5tYXAoeCA9PiBtKCdsaScsIHgpKSk7XG5cbiAgICAgICAgcmV0dXJuIG0oSGVhZGVyLCB7XG4gICAgICAgICAgICBzdHlsZTogbW9kZSA9PT0gJ2V4cGxvcmUnID8geydiYWNrZ3JvdW5kLWltYWdlJzogJy13ZWJraXQtbGluZWFyLWdyYWRpZW50KHRvcCwgI2ZmZiAwLCByZ2IoMjI3LCAyNDIsIDI1NCkgMTAwJSknfSA6IHt9XG4gICAgICAgIH0sIFttKCcjZGF0YUZpZWxkLmZpZWxkW3N0eWxlPXRleHQtYWxpZ246IGNlbnRlcl0nLCBbXG4gICAgICAgICAgICBtKCdoNCNkYXRhTmFtZVtzdHlsZT1kaXNwbGF5OiBpbmxpbmUtYmxvY2s7IG1hcmdpbi1yaWdodDoyZW07IG1hcmdpbi10b3A6IDdweF0nLFxuICAgICAgICAgICAgICB7b25jbGljazogXyA9PiB0aGlzLmNpdGUgPSB0aGlzLmNpdGVIaWRkZW4gPSAhdGhpcy5jaXRlSGlkZGVuLFxuICAgICAgICAgICAgICAgb25tb3VzZW91dDogXyA9PiB0aGlzLmNpdGVIaWRkZW4gfHwgKHRoaXMuY2l0ZSA9IGZhbHNlKSxcbiAgICAgICAgICAgICAgIG9ubW91c2VvdmVyOiBfID0+IHRoaXMuY2l0ZSA9IHRydWV9LFxuICAgICAgICAgICAgICAnRGF0YXNldCBOYW1lJyksXG4gICAgICAgICAgICBtKCcjY2l0ZS5wYW5lbC5wYW5lbC1kZWZhdWx0JyxcbiAgICAgICAgICAgICAge3N0eWxlOiBgZGlzcGxheTogJHt0aGlzLmNpdGUgPyAnYmxvY2snIDogJ25vbmUnfTsgcG9zaXRpb246IGFic29sdXRlOyByaWdodDogNTAlOyB3aWR0aDogMzgwcHg7IHRleHQtYWxpZ246IGxlZnQ7IHotaW5kZXg6IDUwYH0sXG4gICAgICAgICAgICAgIG0oJy5wYW5lbC1ib2R5JykpLFxuICAgICAgICAgICAgbSgnc3BhbicsXG4gICAgICAgICAgICAgIG0oJy5kcm9wZG93bltzdHlsZT1mbG9hdDogcmlnaHQ7IHBhZGRpbmctcmlnaHQ6IDFlbV0nLFxuICAgICAgICAgICAgICAgIG0oJyNkcm9wLmJ1dHRvbi5idG5bdHlwZT1idXR0b25dW2RhdGEtdG9nZ2xlPWRyb3Bkb3duXVthcmlhLWhhc3BvcHVwPXRydWVdW2FyaWEtZXhwYW5kZWQ9ZmFsc2VdJyxcbiAgICAgICAgICAgICAgICAgIFt1c2VybmFtZSwgXCIgXCIsIGdseXBoKCd0cmlhbmdsZS1ib3R0b20nKV0pLFxuICAgICAgICAgICAgICAgIG0oJ3VsLmRyb3Bkb3duLW1lbnVbcm9sZT1tZW51XVthcmlhLWxhYmVsbGVkYnk9ZHJvcF0nLFxuICAgICAgICAgICAgICAgICAgdXNlcmxpbmtzLm1hcChsaW5rID0+IG0oJ2Fbc3R5bGU9cGFkZGluZzogMC41ZW1dJywge2hyZWY6IGxpbmsudXJsfSwgbGluay50aXRsZSwgbSgnYnInKSkpKSksXG4gICAgICAgICAgICAgIG5hdkJ0bignYnRuRXN0aW1hdGUuYnRuLWRlZmF1bHQnLCAyLCAxLCBtb2RlID09PSAnZXhwbG9yZScgPyBfID0+IHtcbiAgICAgICAgICAgICAgICAgIGlmIChhcHAubGlua3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgc2V0TW9kYWwoJ1BsZWFzZSBsaW5rIHBlYmJsZXMgZmlyc3QuJywgJ1dhcm5pbmcnLCB0cnVlLCAnT2snLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGV4cC5leHBsb3JlKCk7XG4gICAgICAgICAgICAgICAgICBhcHAuc2V0UmlnaHRUYWJFeHBsb3JlKCdCaXZhcmlhdGUnKTtcbiAgICAgICAgICAgICAgfSA6IGFwcC5lc3RpbWF0ZSwgbShcInNwYW4ubGFkZGEtbGFiZWxcIiwgbW9kZSA9PT0gJ2V4cGxvcmUnID8gJ0V4cGxvcmUnIDogJ1NvbHZlIFRoaXMgUHJvYmxlbScpLCAnMTUwcHgnKSxcbiAgICAgICAgICAgICAgbSgnZGl2LmJ0bi1ncm91cFtyb2xlPWdyb3VwXVthcmlhLWxhYmVsPVwiLi4uXCJdJywge3N0eWxlOntcImZsb2F0XCI6XCJyaWdodFwiLCBcIm1hcmdpbi1sZWZ0XCI6IFwiMmVtXCJ9fSxcbiAgICAgICAgICAgICAgICBuYXZCdG5Hcm91cCgnYnRuVEEyLmJ0bi1kZWZhdWx0JywgXyA9PiBob3BzY290Y2guc3RhcnRUb3VyKGFwcC5teXRvdXIsIDApLCBbJ0hlbHAgVG91ciAnLCBnbHlwaCgncm9hZCcpXSksXG4gICAgICAgICAgICAgICAgbmF2QnRuR3JvdXAoJ2J0blRBMi5idG4tZGVmYXVsdCcsIF8gPT4gYXBwLmhlbHBtYXRlcmlhbHMoJ3ZpZGVvJyksIFsnVmlkZW8gJywgZ2x5cGgoJ2V4cGFuZCcpXSksXG4gICAgICAgICAgICAgICAgbmF2QnRuR3JvdXAoJ2J0blRBMi5idG4tZGVmYXVsdCcsIF8gPT4gYXBwLmhlbHBtYXRlcmlhbHMoJ21hbnVhbCcpLCBbJ01hbnVhbCAnLCBnbHlwaCgnYm9vaycpXSkpLFxuICAgICAgICAgICAgICBuYXZCdG4xKFwiYnRuUmVzZXRcIiwgYXBwLnJlc2V0LCBnbHlwaCgncmVwZWF0JyksICdSZXNldCcpLFxuICAgICAgICAgICAgICBuYXZCdG4xKCdidG5FbmRTZXNzaW9uJywgYXBwLmVuZHNlc3Npb24sIG0oXCJzcGFuLmxhZGRhLWxhYmVsXCIsICdNYXJrIFByb2JsZW0gRmluaXNoZWQnKSwgJ01hcmsgUHJvYmxlbSBGaW5pc2hlZCcpKSxcbiAgICAgICAgICAgIG0oJyN0SW5wdXQnLCB7XG4gICAgICAgICAgICAgICAgc3R5bGU6IHtkaXNwbGF5OiAnbm9uZSd9LFxuICAgICAgICAgICAgICAgIG9uY2xpY2s6IF8gPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdHJhbnNTZWwgPSBhcHAuYnlJZCgndHJhbnNTZWwnKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdmFyaWFibGUgbGlzdCBpcyBkaXNwbGF5ZWQgd2hlbiBpbnB1dCBpcyBjbGlja2VkLi4uXG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmFuc1NlbC5zdHlsZS5kaXNwbGF5ICE9PSAnbm9uZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhZGVPdXQodHJhbnNTZWwsIDEwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBsZXQgdHJhbnNMaXN0ID0gYXBwLmJ5SWQoJ3RyYW5zTGlzdCcpO1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBmdW5jdGlvbiBsaXN0IGlzIGRpc3BsYXllZCB3aGVuIGlucHV0IGlzIGNsaWNrZWQuLi5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyYW5zTGlzdC5zdHlsZS5kaXNwbGF5ICE9PSAnbm9uZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhZGVPdXQodHJhbnNMaXN0LCAxMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaGlnaGxpZ2h0IHRoZSB0ZXh0XG4gICAgICAgICAgICAgICAgICAgIC8vbGV0IHBvcyA9IHRoaXMub2Zmc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIC8vcG9zLnRvcCArPSB0aGlzLm9mZnNldFdpZHRoKCk7XG4gICAgICAgICAgICAgICAgICAgIGZhZGVJbih0cmFuc1NlbCwgMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAga2V5dXA6IGV2dCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0cmFuc1NlbCA9IGFwcC5ieUlkKCd0cmFuc1NlbCcpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdHJhbnNMaXN0ID0gYXBwLmJ5SWQoJ3RyYW5zTGlzdCcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHJhbnNTZWwuc3R5bGUuZGlzcGxheSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmYWRlT3V0KHRyYW5zU2VsLCAxMDApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRyYW5zTGlzdC5zdHlsZS5kaXNwbGF5ICE9PSAnbm9uZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhZGVPdXQodHJhbnNMaXN0LCAxMDApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2dC5rZXlDb2RlID09IDEzKSB7IC8vIGtleXVwIG9uIEVudGVyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdCA9IHRyYW5zUGFyc2UoYXBwLmJ5SWQoJ3RJbnB1dCcpLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtKHQuc2xpY2UoMCwgdC5sZW5ndGggLSAxKSwgdFt0Lmxlbmd0aCAtIDFdLCB0eXBlVHJhbnNmb3JtID0gZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBtKCcjdHJhbnNmb3JtYXRpb25zLnRyYW5zZm9ybVRvb2wnLFxuICAgICAgICAgICAgICB7dGl0bGU6ICdDb25zdHJ1Y3QgdHJhbnNmb3JtYXRpb25zIG9mIGV4aXN0aW5nIHZhcmlhYmxlcyB1c2luZyB2YWxpZCBSIHN5bnRheC4gRm9yIGV4YW1wbGUsIGFzc3VtaW5nIGEgdmFyaWFibGUgbmFtZWQgZCwgeW91IGNhbiBlbnRlciBcImxvZyhkKVwiIG9yIFwiZF4yXCIuJ30sXG4gICAgICAgICAgICAgIFt0cmFuc2Zvcm1hdGlvbigndHJhbnNTZWwnLCBbJ2EnLCAnYiddKSxcbiAgICAgICAgICAgICAgIHRyYW5zZm9ybWF0aW9uKCd0cmFuc0xpc3QnLCBhcHAudHJhbnNmb3JtTGlzdCldKVxuICAgICAgICBdKV0pO1xuICAgIH1cblxuICAgIGZvb3Rlcihtb2RlKSB7XG4gICAgICAgIHJldHVybiBtKEZvb3RlciwgW1xuICAgICAgICAgICAgbShCdXR0b25SYWRpbyxcbiAgICAgICAgICAgICAge2lkOiAnbW9kZUJ1dHRvbkJhcicsXG4gICAgICAgICAgICAgICBhdHRyc0FsbDoge1xuICAgICAgICAgICAgICAgICAgc3R5bGU6IHsncGFkZGluZy10b3AnOicycHgnLCB3aWR0aDogJzIwMHB4J30sIGNsYXNzOiAnbmF2YmFyLWxlZnQgYnRuLXNtJ30sXG4gICAgICAgICAgICAgICBvbmNsaWNrOiBhcHAuc2V0X21vZGUsXG4gICAgICAgICAgICAgICBhY3RpdmVTZWN0aW9uOiBtb2RlIHx8ICdtb2RlbCcsXG4gICAgICAgICAgICAgICAvLyB7dmFsdWU6ICdSZXN1bHRzJywgaWQ6ICdidG5SZXN1bHRzTW9kZSd9XSBWSkQ6IGNvbW1lbnRpbmcgb3V0IHRoZSByZXN1bHRzIG1vZGUgYnV0dG9uIHNpbmNlIHdlIGRvbid0IGhhdmUgdGhpcyB5ZXRcbiAgICAgICAgICAgICAgIHNlY3Rpb25zOiBbe3ZhbHVlOiAnTW9kZWwnfSwge3ZhbHVlOiAnRXhwbG9yZSd9XX0pLFxuICAgICAgICAgICAgbShcImEjbG9nSURbaHJlZj1zb21lbGlua11bdGFyZ2V0PV9ibGFua11cIiwgXCJSZXBsaWNhdGlvblwiKSxcbiAgICAgICAgICAgIG0oXCJzcGFuW3N0eWxlPWNvbG9yOiMzMzdhYjddXCIsIFwiIHwgXCIpLFxuICAgICAgICAgICAgLy8gZGV2IGxpbmtzLi4uXG4gICAgICAgICAgICBtKFwiYVtocmVmPScvZGV2LXJhdmVuLWxpbmtzJ11bdGFyZ2V0PV9ibGFua11cIiwgXCJyYXZlbi1saW5rc1wiKSxcbiAgICAgICAgICAgIG0oXCJzcGFuW3N0eWxlPWNvbG9yOiMzMzdhYjddXCIsIFwiIHwgXCIpLFxuICAgICAgICAgICAgbShcInNwYW5bc3R5bGU9Y29sb3I6IzMzN2FiN11cIiwgYFRBMjogJHtUQTJfU0VSVkVSfWApLFxuICAgICAgICAgICAgbShcInNwYW5bc3R5bGU9Y29sb3I6IzMzN2FiN11cIiwgXCIgfCBcIiksXG4gICAgICAgICAgICBtKFwic3BhbltzdHlsZT1jb2xvcjojMzM3YWI3XVwiLCBgVEEzVEEyIGFwaTogJHtUQTNUQTJfQVBJX1ZFUlNJT059YCksXG4gICAgICAgICAgICBtKCdidXR0b24uYnRuLmJ0bi1kZWZhdWx0Jywge1xuICAgICAgICAgICAgICAgIG9uY2xpY2s6IF8gPT4gd2luZG93Lm9wZW4oJyMhL2RhdGEnLCAnZGF0YScpLFxuICAgICAgICAgICAgICAgIHN0eWxlOiAnZmxvYXQ6IHJpZ2h0OyBtYXJnaW46IDAuNWVtOyBtYXJnaW4tdG9wOiAycHgnXG4gICAgICAgICAgICB9LCAnUGVlaycpXG4gICAgICAgIF0pO1xuICAgIH1cbn1cblxubS5yb3V0ZShkb2N1bWVudC5ib2R5LCAnL21vZGVsJywge1xuICAgICcvbW9kZWwnOiB7cmVuZGVyOiAoKSA9PiBtKEJvZHkpfSxcbiAgICAnL2V4cGxvcmUnOiB7cmVuZGVyOiAoKSA9PiBtKEJvZHksIHttb2RlOiAnZXhwbG9yZSd9KX0sXG4gICAgJy9yZXN1bHRzJzoge1xuICAgICAgICBvbm1hdGNoKCkge1xuICAgICAgICAgICAgYXBwLnNldF9tb2RlKCdyZXN1bHRzJyk7XG4gICAgICAgICAgICBzdGF0ZS5nZXRfcGlwZWxpbmVzKCk7XG4gICAgICAgICAgICBsYXlvdXQuaW5pdCgpO1xuICAgICAgICB9LFxuICAgICAgICByZW5kZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gbShCb2R5LCB7bW9kZTogJ3Jlc3VsdHMnfSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgICcvZGF0YSc6IFBlZWtcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYXNzZXRzL2FwcC9pbmRleC5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///28\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.getClasses = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mithril = __webpack_require__(0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _app = __webpack_require__(2);\n\nvar app = _interopRequireWildcard(_app);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar getClasses = exports.getClasses = function getClasses(cls, panel, attrs) {\n    if (panel.closed) {\n        cls += '.closepanel';\n    } else if (attrs.is_explore_mode) {\n        if (app.righttab === 'btnUnivariate' && attrs.univariate_finished) {\n            cls += '[style=width: ' + 45 + '%]';\n        } else if (app.righttab === 'btnBivariate') {\n            cls += '[style=width: ' + 75 + '%]';\n        }\n    } else if (attrs.side === 'left' && app.lefttab === 'tab2') {\n        cls += '.expandpanelfull';\n    }\n    return cls;\n    ;\n};\n\nvar Panel = function () {\n    function Panel() {\n        _classCallCheck(this, Panel);\n    }\n\n    _createClass(Panel, [{\n        key: 'oninit',\n        value: function oninit(vnode) {\n            this.closed = false;\n        }\n    }, {\n        key: 'view',\n        value: function view(vnode) {\n            var _this = this;\n\n            var _vnode$attrs = vnode.attrs,\n                side = _vnode$attrs.side,\n                title = _vnode$attrs.title,\n                buttons = _vnode$attrs.buttons,\n                is_explore_mode = _vnode$attrs.is_explore_mode;\n\n            var btns = buttons || [];\n            var dot = [_mithril2.default.trust('&#9679;'), (0, _mithril2.default)('br')];\n            var width = 100 / btns.length;\n            var expandwidth = 35;\n            var shrinkwidth = 65 / (btns.length - 1);\n            return (0, _mithril2.default)(getClasses('#' + side + 'panel.sidepanel.container.clearfix', this, vnode.attrs), (0, _mithril2.default)('#toggle' + (side === 'left' ? 'L' : 'R') + 'panelicon.panelbar[style=height: 100%]', (0, _mithril2.default)('span', { onclick: function onclick(_) {\n                    return _this.closed = !_this.closed;\n                } }, dot, dot, dot, dot)), (0, _mithril2.default)('#' + side + 'paneltitle.panel-heading.text-center', (0, _mithril2.default)(\"h3.panel-title\", title)), btns.length === 0 ? null : (0, _mithril2.default)('ul' + (side === 'right' ? '#rightpanelbuttons' : '') + '.accordion', btns.map(function (b) {\n                b.attrs.style = b.attrs.style + '; width: 100%';\n                b.attrs.is_explore_mode = is_explore_mode;\n                var id = b.attrs.id;\n                //let w = this.active_btn === id ? shrinkwidth :\n                //this.active_btn === null ? width :\n                //expandwidth;\n                return (0, _mithril2.default)('li', { style: { width: width + '%', 'max-width': '150px' },\n                    onmouseover: function onmouseover(_) {\n                        return _this.active_btn = id;\n                    },\n                    onmouseout: function onmouseout(_) {\n                        return _this.active_btn = null;\n                    } }, b);\n            })), (0, _mithril2.default)('.row-fluid', (0, _mithril2.default)('#' + side + 'panelcontent', (0, _mithril2.default)('#' + side + 'ContentArea[style=height: calc(100vh - 213px); overflow: auto]', vnode.children))));\n        }\n    }]);\n\n    return Panel;\n}();\n\nexports.default = Panel;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvYXBwL3ZpZXdzL1BhbmVsLmpzPzkyNGYiXSwibmFtZXMiOlsiYXBwIiwiZ2V0Q2xhc3NlcyIsImNscyIsInBhbmVsIiwiYXR0cnMiLCJjbG9zZWQiLCJpc19leHBsb3JlX21vZGUiLCJyaWdodHRhYiIsInVuaXZhcmlhdGVfZmluaXNoZWQiLCJzaWRlIiwibGVmdHRhYiIsIlBhbmVsIiwidm5vZGUiLCJ0aXRsZSIsImJ1dHRvbnMiLCJidG5zIiwiZG90IiwidHJ1c3QiLCJ3aWR0aCIsImxlbmd0aCIsImV4cGFuZHdpZHRoIiwic2hyaW5rd2lkdGgiLCJvbmNsaWNrIiwibWFwIiwiYiIsInN0eWxlIiwiaWQiLCJvbm1vdXNlb3ZlciIsImFjdGl2ZV9idG4iLCJvbm1vdXNlb3V0IiwiY2hpbGRyZW4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOzs7O0FBRUE7O0lBQVlBLEc7Ozs7Ozs7O0FBRUwsSUFBSUMsa0NBQWEsU0FBYkEsVUFBYSxDQUFTQyxHQUFULEVBQWNDLEtBQWQsRUFBcUJDLEtBQXJCLEVBQTRCO0FBQ2hELFFBQUlELE1BQU1FLE1BQVYsRUFBa0I7QUFDZEgsZUFBTyxhQUFQO0FBQ0gsS0FGRCxNQUVPLElBQUlFLE1BQU1FLGVBQVYsRUFBMkI7QUFDOUIsWUFBSU4sSUFBSU8sUUFBSixLQUFpQixlQUFqQixJQUFvQ0gsTUFBTUksbUJBQTlDLEVBQW1FO0FBQy9ETixzQ0FBd0IsRUFBeEI7QUFDSCxTQUZELE1BRU8sSUFBSUYsSUFBSU8sUUFBSixLQUFpQixjQUFyQixFQUFxQztBQUN4Q0wsc0NBQXdCLEVBQXhCO0FBQ0g7QUFDSixLQU5NLE1BTUEsSUFBSUUsTUFBTUssSUFBTixLQUFlLE1BQWYsSUFBeUJULElBQUlVLE9BQUosS0FBZ0IsTUFBN0MsRUFBcUQ7QUFDeERSLGVBQU8sa0JBQVA7QUFDSDtBQUNELFdBQU9BLEdBQVA7QUFDSjtBQUNDLENBZE07O0lBZ0JEUyxLOzs7Ozs7OytCQUNLQyxLLEVBQU87QUFDVixpQkFBS1AsTUFBTCxHQUFjLEtBQWQ7QUFDSDs7OzZCQUVJTyxLLEVBQU87QUFBQTs7QUFBQSwrQkFDc0NBLE1BQU1SLEtBRDVDO0FBQUEsZ0JBQ0hLLElBREcsZ0JBQ0hBLElBREc7QUFBQSxnQkFDR0ksS0FESCxnQkFDR0EsS0FESDtBQUFBLGdCQUNVQyxPQURWLGdCQUNVQSxPQURWO0FBQUEsZ0JBQ21CUixlQURuQixnQkFDbUJBLGVBRG5COztBQUVSLGdCQUFJUyxPQUFPRCxXQUFXLEVBQXRCO0FBQ0EsZ0JBQUlFLE1BQU0sQ0FBQyxrQkFBRUMsS0FBRixDQUFRLFNBQVIsQ0FBRCxFQUFxQix1QkFBRSxJQUFGLENBQXJCLENBQVY7QUFDQSxnQkFBSUMsUUFBUSxNQUFNSCxLQUFLSSxNQUF2QjtBQUNBLGdCQUFJQyxjQUFjLEVBQWxCO0FBQ0EsZ0JBQUlDLGNBQWMsTUFBTU4sS0FBS0ksTUFBTCxHQUFjLENBQXBCLENBQWxCO0FBQ0EsbUJBQU8sdUJBQ0hsQixpQkFBZVEsSUFBZix5Q0FBeUQsSUFBekQsRUFBK0RHLE1BQU1SLEtBQXJFLENBREcsRUFFSCxvQ0FBWUssU0FBUyxNQUFULEdBQWtCLEdBQWxCLEdBQXdCLEdBQXBDLDhDQUNFLHVCQUFFLE1BQUYsRUFBVSxFQUFDYSxTQUFTO0FBQUEsMkJBQUssTUFBS2pCLE1BQUwsR0FBYyxDQUFDLE1BQUtBLE1BQXpCO0FBQUEsaUJBQVYsRUFBVixFQUFzRFcsR0FBdEQsRUFBMkRBLEdBQTNELEVBQWdFQSxHQUFoRSxFQUFxRUEsR0FBckUsQ0FERixDQUZHLEVBSUgsNkJBQU1QLElBQU4sMkNBQ0UsdUJBQUUsZ0JBQUYsRUFBb0JJLEtBQXBCLENBREYsQ0FKRyxFQU1IRSxLQUFLSSxNQUFMLEtBQWdCLENBQWhCLEdBQW9CLElBQXBCLEdBQTJCLCtCQUFPVixTQUFTLE9BQVQsR0FBbUIsb0JBQW5CLEdBQTBDLEVBQWpELGtCQUN6Qk0sS0FBS1EsR0FBTCxDQUFTLGFBQUs7QUFDVkMsa0JBQUVwQixLQUFGLENBQVFxQixLQUFSLEdBQWdCRCxFQUFFcEIsS0FBRixDQUFRcUIsS0FBUixHQUFnQixlQUFoQztBQUNBRCxrQkFBRXBCLEtBQUYsQ0FBUUUsZUFBUixHQUEwQkEsZUFBMUI7QUFDQSxvQkFBSW9CLEtBQUtGLEVBQUVwQixLQUFGLENBQVFzQixFQUFqQjtBQUNBO0FBQ0k7QUFDQTtBQUNKLHVCQUFPLHVCQUNILElBREcsRUFFSCxFQUFDRCxPQUFPLEVBQUNQLE9BQU9BLFFBQVEsR0FBaEIsRUFBcUIsYUFBYSxPQUFsQyxFQUFSO0FBQ0NTLGlDQUFhO0FBQUEsK0JBQUssTUFBS0MsVUFBTCxHQUFrQkYsRUFBdkI7QUFBQSxxQkFEZDtBQUVDRyxnQ0FBWTtBQUFBLCtCQUFLLE1BQUtELFVBQUwsR0FBa0IsSUFBdkI7QUFBQSxxQkFGYixFQUZHLEVBS0hKLENBTEcsQ0FBUDtBQU1ILGFBYkQsQ0FEeUIsQ0FOeEIsRUFxQkgsdUJBQUUsWUFBRixFQUNFLDZCQUFNZixJQUFOLG1CQUNFLDZCQUFNQSxJQUFOLHFFQUE0RUcsTUFBTWtCLFFBQWxGLENBREYsQ0FERixDQXJCRyxDQUFQO0FBd0JIOzs7Ozs7a0JBR1VuQixLIiwiZmlsZSI6IjI5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG0gZnJvbSAnbWl0aHJpbCc7XG5cbmltcG9ydCAqIGFzIGFwcCBmcm9tICcuLi9hcHAnO1xuXG5leHBvcnQgbGV0IGdldENsYXNzZXMgPSBmdW5jdGlvbihjbHMsIHBhbmVsLCBhdHRycykge1xuICAgIGlmIChwYW5lbC5jbG9zZWQpIHtcbiAgICAgICAgY2xzICs9ICcuY2xvc2VwYW5lbCc7XG4gICAgfSBlbHNlIGlmIChhdHRycy5pc19leHBsb3JlX21vZGUpIHtcbiAgICAgICAgaWYgKGFwcC5yaWdodHRhYiA9PT0gJ2J0blVuaXZhcmlhdGUnICYmIGF0dHJzLnVuaXZhcmlhdGVfZmluaXNoZWQpIHtcbiAgICAgICAgICAgIGNscyArPSBgW3N0eWxlPXdpZHRoOiAkezQ1fSVdYDtcbiAgICAgICAgfSBlbHNlIGlmIChhcHAucmlnaHR0YWIgPT09ICdidG5CaXZhcmlhdGUnKSB7XG4gICAgICAgICAgICBjbHMgKz0gYFtzdHlsZT13aWR0aDogJHs3NX0lXWA7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGF0dHJzLnNpZGUgPT09ICdsZWZ0JyAmJiBhcHAubGVmdHRhYiA9PT0gJ3RhYjInKSB7XG4gICAgICAgIGNscyArPSAnLmV4cGFuZHBhbmVsZnVsbCc7XG4gICAgfVxuICAgIHJldHVybiBjbHM7XG47XG59O1xuXG5jbGFzcyBQYW5lbCB7XG4gICAgb25pbml0KHZub2RlKSB7XG4gICAgICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmlldyh2bm9kZSkge1xuICAgICAgICBsZXQge3NpZGUsIHRpdGxlLCBidXR0b25zLCBpc19leHBsb3JlX21vZGV9ID0gdm5vZGUuYXR0cnM7XG4gICAgICAgIGxldCBidG5zID0gYnV0dG9ucyB8fCBbXTtcbiAgICAgICAgbGV0IGRvdCA9IFttLnRydXN0KCcmIzk2Nzk7JyksIG0oJ2JyJyldO1xuICAgICAgICBsZXQgd2lkdGggPSAxMDAgLyBidG5zLmxlbmd0aDtcbiAgICAgICAgbGV0IGV4cGFuZHdpZHRoID0gMzU7XG4gICAgICAgIGxldCBzaHJpbmt3aWR0aCA9IDY1IC8gKGJ0bnMubGVuZ3RoIC0gMSk7XG4gICAgICAgIHJldHVybiBtKFxuICAgICAgICAgICAgZ2V0Q2xhc3NlcyhgIyR7c2lkZX1wYW5lbC5zaWRlcGFuZWwuY29udGFpbmVyLmNsZWFyZml4YCwgdGhpcywgdm5vZGUuYXR0cnMpLFxuICAgICAgICAgICAgbShgI3RvZ2dsZSR7c2lkZSA9PT0gJ2xlZnQnID8gJ0wnIDogJ1InfXBhbmVsaWNvbi5wYW5lbGJhcltzdHlsZT1oZWlnaHQ6IDEwMCVdYCxcbiAgICAgICAgICAgICAgbSgnc3BhbicsIHtvbmNsaWNrOiBfID0+IHRoaXMuY2xvc2VkID0gIXRoaXMuY2xvc2VkfSwgZG90LCBkb3QsIGRvdCwgZG90KSksXG4gICAgICAgICAgICBtKGAjJHtzaWRlfXBhbmVsdGl0bGUucGFuZWwtaGVhZGluZy50ZXh0LWNlbnRlcmAsXG4gICAgICAgICAgICAgIG0oXCJoMy5wYW5lbC10aXRsZVwiLCB0aXRsZSkpLFxuICAgICAgICAgICAgYnRucy5sZW5ndGggPT09IDAgPyBudWxsIDogbShgdWwke3NpZGUgPT09ICdyaWdodCcgPyAnI3JpZ2h0cGFuZWxidXR0b25zJyA6ICcnfS5hY2NvcmRpb25gLFxuICAgICAgICAgICAgICBidG5zLm1hcChiID0+IHtcbiAgICAgICAgICAgICAgICAgIGIuYXR0cnMuc3R5bGUgPSBiLmF0dHJzLnN0eWxlICsgJzsgd2lkdGg6IDEwMCUnO1xuICAgICAgICAgICAgICAgICAgYi5hdHRycy5pc19leHBsb3JlX21vZGUgPSBpc19leHBsb3JlX21vZGU7XG4gICAgICAgICAgICAgICAgICBsZXQgaWQgPSBiLmF0dHJzLmlkO1xuICAgICAgICAgICAgICAgICAgLy9sZXQgdyA9IHRoaXMuYWN0aXZlX2J0biA9PT0gaWQgPyBzaHJpbmt3aWR0aCA6XG4gICAgICAgICAgICAgICAgICAgICAgLy90aGlzLmFjdGl2ZV9idG4gPT09IG51bGwgPyB3aWR0aCA6XG4gICAgICAgICAgICAgICAgICAgICAgLy9leHBhbmR3aWR0aDtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBtKFxuICAgICAgICAgICAgICAgICAgICAgICdsaScsXG4gICAgICAgICAgICAgICAgICAgICAge3N0eWxlOiB7d2lkdGg6IHdpZHRoICsgJyUnLCAnbWF4LXdpZHRoJzogJzE1MHB4J30sXG4gICAgICAgICAgICAgICAgICAgICAgIG9ubW91c2VvdmVyOiBfID0+IHRoaXMuYWN0aXZlX2J0biA9IGlkLFxuICAgICAgICAgICAgICAgICAgICAgICBvbm1vdXNlb3V0OiBfID0+IHRoaXMuYWN0aXZlX2J0biA9IG51bGx9LFxuICAgICAgICAgICAgICAgICAgICAgIGIpO1xuICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgICBtKCcucm93LWZsdWlkJyxcbiAgICAgICAgICAgICAgbShgIyR7c2lkZX1wYW5lbGNvbnRlbnRgLFxuICAgICAgICAgICAgICAgIG0oYCMke3NpZGV9Q29udGVudEFyZWFbc3R5bGU9aGVpZ2h0OiBjYWxjKDEwMHZoIC0gMjEzcHgpOyBvdmVyZmxvdzogYXV0b11gLCB2bm9kZS5jaGlsZHJlbikpKSk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBQYW5lbDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Fzc2V0cy9hcHAvdmlld3MvUGFuZWwuanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///29\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mithril = __webpack_require__(0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _common = __webpack_require__(1);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// Interface specification\n\n// ```\n// m(Canvas, {\n//     attrsAll: { additional attributes to apply to the outer div }\n//     }, contents)\n// ```\n\n// Purpose:\n// 1. if a left or right panel is not permitted to occlude the content on the canvas,\n//      this class resizes the contents to maintain a margin away from the panels\n// 2. if the contents of the canvas overflow and cause a scroll bar,\n//      the left and right panel are shifted to maintain a margin\n\nvar Canvas = function () {\n    function Canvas() {\n        _classCallCheck(this, Canvas);\n    }\n\n    _createClass(Canvas, [{\n        key: 'oncreate',\n        value: function oncreate() {\n            // Redraw if scroll bar status has changed\n            (0, _common.callOnResize)(function () {\n                if ((0, _common.scrollBarChanged)()) _mithril2.default.redraw();\n            });\n        }\n    }, {\n        key: 'view',\n        value: function view(vnode) {\n            var attrsAll = vnode.attrs.attrsAll;\n\n            return (0, _mithril2.default)('div#canvas', (0, _common.mergeAttributes)({\n                style: {\n                    width: '100%',\n                    height: 'calc(100% - ' + _common.heightHeader + ' - ' + _common.heightFooter + ')',\n                    'padding-left': _common.panelOcclusion['left'],\n                    'padding-right': _common.panelOcclusion['right'],\n                    position: 'fixed',\n                    overflow: 'auto',\n                    top: _common.heightHeader\n                }\n            }, attrsAll), vnode.children);\n        }\n    }]);\n\n    return Canvas;\n}();\n\nexports.default = Canvas;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvY29tbW9uL2FwcC92aWV3cy9DYW52YXMuanM/NzgwYSJdLCJuYW1lcyI6WyJDYW52YXMiLCJyZWRyYXciLCJ2bm9kZSIsImF0dHJzQWxsIiwiYXR0cnMiLCJzdHlsZSIsIndpZHRoIiwiaGVpZ2h0IiwicG9zaXRpb24iLCJvdmVyZmxvdyIsInRvcCIsImNoaWxkcmVuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7O0FBQ0E7Ozs7OztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7SUFFcUJBLE07Ozs7Ozs7bUNBQ047QUFDUDtBQUNBLHNDQUFhLFlBQU07QUFBQyxvQkFBSSwrQkFBSixFQUF3QixrQkFBRUMsTUFBRjtBQUFXLGFBQXZEO0FBQ0g7Ozs2QkFFSUMsSyxFQUFPO0FBQUEsZ0JBQ0hDLFFBREcsR0FDU0QsTUFBTUUsS0FEZixDQUNIRCxRQURHOztBQUVSLG1CQUFPLHVCQUFFLFlBQUYsRUFBZ0IsNkJBQWdCO0FBQ25DRSx1QkFBTztBQUNIQywyQkFBTyxNQURKO0FBRUhDLHNHQUZHO0FBR0gsb0NBQWdCLHVCQUFlLE1BQWYsQ0FIYjtBQUlILHFDQUFpQix1QkFBZSxPQUFmLENBSmQ7QUFLSEMsOEJBQVUsT0FMUDtBQU1IQyw4QkFBVSxNQU5QO0FBT0hDO0FBUEc7QUFENEIsYUFBaEIsRUFVcEJQLFFBVm9CLENBQWhCLEVBVU9ELE1BQU1TLFFBVmIsQ0FBUDtBQVdIOzs7Ozs7a0JBbkJnQlgsTSIsImZpbGUiOiIzMC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtIGZyb20gJ21pdGhyaWwnXG5pbXBvcnQge2NhbGxPblJlc2l6ZSwgbWVyZ2VBdHRyaWJ1dGVzLCBwYW5lbE9jY2x1c2lvbiwgaGVpZ2h0Rm9vdGVyLCBoZWlnaHRIZWFkZXIsIHNjcm9sbEJhckNoYW5nZWR9IGZyb20gXCIuLi9jb21tb25cIjtcblxuLy8gSW50ZXJmYWNlIHNwZWNpZmljYXRpb25cblxuLy8gYGBgXG4vLyBtKENhbnZhcywge1xuLy8gICAgIGF0dHJzQWxsOiB7IGFkZGl0aW9uYWwgYXR0cmlidXRlcyB0byBhcHBseSB0byB0aGUgb3V0ZXIgZGl2IH1cbi8vICAgICB9LCBjb250ZW50cylcbi8vIGBgYFxuXG4vLyBQdXJwb3NlOlxuLy8gMS4gaWYgYSBsZWZ0IG9yIHJpZ2h0IHBhbmVsIGlzIG5vdCBwZXJtaXR0ZWQgdG8gb2NjbHVkZSB0aGUgY29udGVudCBvbiB0aGUgY2FudmFzLFxuLy8gICAgICB0aGlzIGNsYXNzIHJlc2l6ZXMgdGhlIGNvbnRlbnRzIHRvIG1haW50YWluIGEgbWFyZ2luIGF3YXkgZnJvbSB0aGUgcGFuZWxzXG4vLyAyLiBpZiB0aGUgY29udGVudHMgb2YgdGhlIGNhbnZhcyBvdmVyZmxvdyBhbmQgY2F1c2UgYSBzY3JvbGwgYmFyLFxuLy8gICAgICB0aGUgbGVmdCBhbmQgcmlnaHQgcGFuZWwgYXJlIHNoaWZ0ZWQgdG8gbWFpbnRhaW4gYSBtYXJnaW5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2FudmFzIHtcbiAgICBvbmNyZWF0ZSgpIHtcbiAgICAgICAgLy8gUmVkcmF3IGlmIHNjcm9sbCBiYXIgc3RhdHVzIGhhcyBjaGFuZ2VkXG4gICAgICAgIGNhbGxPblJlc2l6ZSgoKSA9PiB7aWYgKHNjcm9sbEJhckNoYW5nZWQoKSkgbS5yZWRyYXcoKX0pO1xuICAgIH1cblxuICAgIHZpZXcodm5vZGUpIHtcbiAgICAgICAgbGV0IHthdHRyc0FsbH0gPSB2bm9kZS5hdHRycztcbiAgICAgICAgcmV0dXJuIG0oJ2RpdiNjYW52YXMnLCBtZXJnZUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgICAgICAgIGhlaWdodDogYGNhbGMoMTAwJSAtICR7aGVpZ2h0SGVhZGVyfSAtICR7aGVpZ2h0Rm9vdGVyfSlgLFxuICAgICAgICAgICAgICAgICdwYWRkaW5nLWxlZnQnOiBwYW5lbE9jY2x1c2lvblsnbGVmdCddLFxuICAgICAgICAgICAgICAgICdwYWRkaW5nLXJpZ2h0JzogcGFuZWxPY2NsdXNpb25bJ3JpZ2h0J10sXG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgICAgICAgICAgICAgb3ZlcmZsb3c6ICdhdXRvJyxcbiAgICAgICAgICAgICAgICB0b3A6IGhlaWdodEhlYWRlclxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBhdHRyc0FsbCksIHZub2RlLmNoaWxkcmVuKVxuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Fzc2V0cy9jb21tb24vYXBwL3ZpZXdzL0NhbnZhcy5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///30\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mithril = __webpack_require__(0);\n\nvar _mithril2 = _interopRequireDefault(_mithril);\n\nvar _common = __webpack_require__(1);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// Interface specification\n\n// ```\n// m(Dropdown, {\n//     id: 'dropdownID' (applied to button and selectors)\n//     items: ['Item 1', 'Item 2', 'Item 3'],\n//     onclickChild: (value) => console.log(value + \" was clicked.\")\n//     dropWidth: 100 (sets the width of the dropdown)\n//     })\n//  ```\n\nvar Dropdown = function () {\n    function Dropdown() {\n        _classCallCheck(this, Dropdown);\n    }\n\n    _createClass(Dropdown, [{\n        key: 'oninit',\n        value: function oninit(vnode) {\n            this.activeItem = vnode.attrs.items[0];\n        }\n    }, {\n        key: 'view',\n        value: function view(vnode) {\n            var _this = this;\n\n            var _vnode$attrs = vnode.attrs,\n                id = _vnode$attrs.id,\n                items = _vnode$attrs.items,\n                onclickChild = _vnode$attrs.onclickChild,\n                dropWidth = _vnode$attrs.dropWidth;\n\n\n            return (0, _mithril2.default)('.dropdown[style=display: block]', [(0, _mithril2.default)('button.btn.btn-default.dropdown-toggle', Object.assign(vnode.attrs, { 'data-toggle': 'dropdown' }), [this.activeItem, (0, _mithril2.default)('b.caret', { style: { 'margin-left': '5px' } })]), (0, _mithril2.default)('ul.dropdown-menu', { 'aria-labelledby': id, style: { width: dropWidth, 'min-width': 0 } }, items.map(function (item) {\n                return (0, _mithril2.default)('li.dropdown-item', {\n                    value: item,\n                    onclick: function onclick() {\n                        _this.activeItem = item;\n                        onclickChild(item);\n                    },\n                    style: { 'padding-left': '10px' }\n                }, item);\n            }))]);\n        }\n    }]);\n\n    return Dropdown;\n}();\n\nexports.default = Dropdown;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvY29tbW9uL2FwcC92aWV3cy9Ecm9wZG93bi5qcz9kN2E4Il0sIm5hbWVzIjpbIkRyb3Bkb3duIiwidm5vZGUiLCJhY3RpdmVJdGVtIiwiYXR0cnMiLCJpdGVtcyIsImlkIiwib25jbGlja0NoaWxkIiwiZHJvcFdpZHRoIiwiT2JqZWN0IiwiYXNzaWduIiwic3R5bGUiLCJ3aWR0aCIsIm1hcCIsIml0ZW0iLCJ2YWx1ZSIsIm9uY2xpY2siXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7Ozs7QUFFQTs7Ozs7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7SUFFcUJBLFE7Ozs7Ozs7K0JBQ1ZDLEssRUFBTztBQUNWLGlCQUFLQyxVQUFMLEdBQWtCRCxNQUFNRSxLQUFOLENBQVlDLEtBQVosQ0FBa0IsQ0FBbEIsQ0FBbEI7QUFDSDs7OzZCQUVJSCxLLEVBQU87QUFBQTs7QUFBQSwrQkFDbUNBLE1BQU1FLEtBRHpDO0FBQUEsZ0JBQ0hFLEVBREcsZ0JBQ0hBLEVBREc7QUFBQSxnQkFDQ0QsS0FERCxnQkFDQ0EsS0FERDtBQUFBLGdCQUNRRSxZQURSLGdCQUNRQSxZQURSO0FBQUEsZ0JBQ3NCQyxTQUR0QixnQkFDc0JBLFNBRHRCOzs7QUFHUixtQkFBTyx1QkFBRSxpQ0FBRixFQUFxQyxDQUN4Qyx1QkFBRSx3Q0FBRixFQUNJQyxPQUFPQyxNQUFQLENBQWNSLE1BQU1FLEtBQXBCLEVBQTJCLEVBQUMsZUFBZSxVQUFoQixFQUEzQixDQURKLEVBQzZELENBQ3JELEtBQUtELFVBRGdELEVBRXJELHVCQUFFLFNBQUYsRUFBYSxFQUFDUSxPQUFPLEVBQUMsZUFBZSxLQUFoQixFQUFSLEVBQWIsQ0FGcUQsQ0FEN0QsQ0FEd0MsRUFNeEMsdUJBQUUsa0JBQUYsRUFBc0IsRUFBQyxtQkFBbUJMLEVBQXBCLEVBQXdCSyxPQUFPLEVBQUNDLE9BQU9KLFNBQVIsRUFBbUIsYUFBYSxDQUFoQyxFQUEvQixFQUF0QixFQUNJSCxNQUFNUSxHQUFOLENBQVUsVUFBQ0MsSUFBRDtBQUFBLHVCQUFVLHVCQUFFLGtCQUFGLEVBQXNCO0FBQ3RDQywyQkFBT0QsSUFEK0I7QUFFdENFLDZCQUFTLG1CQUFNO0FBQ1gsOEJBQUtiLFVBQUwsR0FBa0JXLElBQWxCO0FBQ0FQLHFDQUFhTyxJQUFiO0FBQ0gscUJBTHFDO0FBTXRDSCwyQkFBTyxFQUFDLGdCQUFnQixNQUFqQjtBQU4rQixpQkFBdEIsRUFPakJHLElBUGlCLENBQVY7QUFBQSxhQUFWLENBREosQ0FOd0MsQ0FBckMsQ0FBUDtBQWlCSDs7Ozs7O2tCQXpCZ0JiLFEiLCJmaWxlIjoiMzEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbSBmcm9tICdtaXRocmlsJ1xuXG5pbXBvcnQge21lcmdlQXR0cmlidXRlc30gZnJvbSBcIi4uL2NvbW1vblwiO1xuXG4vLyBJbnRlcmZhY2Ugc3BlY2lmaWNhdGlvblxuXG4vLyBgYGBcbi8vIG0oRHJvcGRvd24sIHtcbi8vICAgICBpZDogJ2Ryb3Bkb3duSUQnIChhcHBsaWVkIHRvIGJ1dHRvbiBhbmQgc2VsZWN0b3JzKVxuLy8gICAgIGl0ZW1zOiBbJ0l0ZW0gMScsICdJdGVtIDInLCAnSXRlbSAzJ10sXG4vLyAgICAgb25jbGlja0NoaWxkOiAodmFsdWUpID0+IGNvbnNvbGUubG9nKHZhbHVlICsgXCIgd2FzIGNsaWNrZWQuXCIpXG4vLyAgICAgZHJvcFdpZHRoOiAxMDAgKHNldHMgdGhlIHdpZHRoIG9mIHRoZSBkcm9wZG93bilcbi8vICAgICB9KVxuLy8gIGBgYFxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEcm9wZG93biB7XG4gICAgb25pbml0KHZub2RlKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlSXRlbSA9IHZub2RlLmF0dHJzLml0ZW1zWzBdXG4gICAgfVxuXG4gICAgdmlldyh2bm9kZSkge1xuICAgICAgICBsZXQge2lkLCBpdGVtcywgb25jbGlja0NoaWxkLCBkcm9wV2lkdGh9ID0gdm5vZGUuYXR0cnM7XG5cbiAgICAgICAgcmV0dXJuIG0oJy5kcm9wZG93bltzdHlsZT1kaXNwbGF5OiBibG9ja10nLCBbXG4gICAgICAgICAgICBtKCdidXR0b24uYnRuLmJ0bi1kZWZhdWx0LmRyb3Bkb3duLXRvZ2dsZScsXG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih2bm9kZS5hdHRycywgeydkYXRhLXRvZ2dsZSc6ICdkcm9wZG93bid9KSwgW1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZUl0ZW0sXG4gICAgICAgICAgICAgICAgICAgIG0oJ2IuY2FyZXQnLCB7c3R5bGU6IHsnbWFyZ2luLWxlZnQnOiAnNXB4J319KV0pLFxuXG4gICAgICAgICAgICBtKCd1bC5kcm9wZG93bi1tZW51JywgeydhcmlhLWxhYmVsbGVkYnknOiBpZCwgc3R5bGU6IHt3aWR0aDogZHJvcFdpZHRoLCAnbWluLXdpZHRoJzogMH19LFxuICAgICAgICAgICAgICAgIGl0ZW1zLm1hcCgoaXRlbSkgPT4gbSgnbGkuZHJvcGRvd24taXRlbScsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGl0ZW0sXG4gICAgICAgICAgICAgICAgICAgIG9uY2xpY2s6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlSXRlbSA9IGl0ZW07XG4gICAgICAgICAgICAgICAgICAgICAgICBvbmNsaWNrQ2hpbGQoaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7J3BhZGRpbmctbGVmdCc6ICcxMHB4J31cbiAgICAgICAgICAgICAgICB9LCBpdGVtKSlcbiAgICAgICAgICAgIClcbiAgICAgICAgXSk7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYXNzZXRzL2NvbW1vbi9hcHAvdmlld3MvRHJvcGRvd24uanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///31\n")},function(module,exports){eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hc3NldHMvY29tbW9uL2Nzcy9jb21tb24uY3NzPzhjNTYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiMzIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYXNzZXRzL2NvbW1vbi9jc3MvY29tbW9uLmNzc1xuLy8gbW9kdWxlIGlkID0gMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///32\n")},function(module,exports){eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2Nlc3MvYnJvd3Nlci5qcz84MmU0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVUiLCJmaWxlIjoiMzMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Byb2Nlc3MvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///33\n")},function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    "use strict";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== "function") {\n        callback = new Function("" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."\n        // So if we\'re currently running a task, we\'ll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // "too much recursion" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can\'t be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage("", "*");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = "setImmediate$" + Math.random() + "$";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === "string" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener("message", onGlobalMessage, false);\n        } else {\n            global.attachEvent("onmessage", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, "*");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it\'s been called.\n            var script = doc.createElement("script");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don\'t get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === "[object process]") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && "onreadystatechange" in doc.createElement("script")) {\n        // For IE 6–8\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(13), __webpack_require__(33)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanM/NGE4MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMsc0JBQXNCLEVBQUU7QUFDbEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiMzQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgdW5kZWZpbmVkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZiAoZ2xvYmFsLnNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5leHRIYW5kbGUgPSAxOyAvLyBTcGVjIHNheXMgZ3JlYXRlciB0aGFuIHplcm9cbiAgICB2YXIgdGFza3NCeUhhbmRsZSA9IHt9O1xuICAgIHZhciBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICB2YXIgZG9jID0gZ2xvYmFsLmRvY3VtZW50O1xuICAgIHZhciByZWdpc3RlckltbWVkaWF0ZTtcblxuICAgIGZ1bmN0aW9uIHNldEltbWVkaWF0ZShjYWxsYmFjaykge1xuICAgICAgLy8gQ2FsbGJhY2sgY2FuIGVpdGhlciBiZSBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBuZXcgRnVuY3Rpb24oXCJcIiArIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIC8vIENvcHkgZnVuY3Rpb24gYXJndW1lbnRzXG4gICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2kgKyAxXTtcbiAgICAgIH1cbiAgICAgIC8vIFN0b3JlIGFuZCByZWdpc3RlciB0aGUgdGFza1xuICAgICAgdmFyIHRhc2sgPSB7IGNhbGxiYWNrOiBjYWxsYmFjaywgYXJnczogYXJncyB9O1xuICAgICAgdGFza3NCeUhhbmRsZVtuZXh0SGFuZGxlXSA9IHRhc2s7XG4gICAgICByZWdpc3RlckltbWVkaWF0ZShuZXh0SGFuZGxlKTtcbiAgICAgIHJldHVybiBuZXh0SGFuZGxlKys7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaGFuZGxlKSB7XG4gICAgICAgIGRlbGV0ZSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuKHRhc2spIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gdGFzay5jYWxsYmFjaztcbiAgICAgICAgdmFyIGFyZ3MgPSB0YXNrLmFyZ3M7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuSWZQcmVzZW50KGhhbmRsZSkge1xuICAgICAgICAvLyBGcm9tIHRoZSBzcGVjOiBcIldhaXQgdW50aWwgYW55IGludm9jYXRpb25zIG9mIHRoaXMgYWxnb3JpdGhtIHN0YXJ0ZWQgYmVmb3JlIHRoaXMgb25lIGhhdmUgY29tcGxldGVkLlwiXG4gICAgICAgIC8vIFNvIGlmIHdlJ3JlIGN1cnJlbnRseSBydW5uaW5nIGEgdGFzaywgd2UnbGwgbmVlZCB0byBkZWxheSB0aGlzIGludm9jYXRpb24uXG4gICAgICAgIGlmIChjdXJyZW50bHlSdW5uaW5nQVRhc2spIHtcbiAgICAgICAgICAgIC8vIERlbGF5IGJ5IGRvaW5nIGEgc2V0VGltZW91dC4gc2V0SW1tZWRpYXRlIHdhcyB0cmllZCBpbnN0ZWFkLCBidXQgaW4gRmlyZWZveCA3IGl0IGdlbmVyYXRlZCBhXG4gICAgICAgICAgICAvLyBcInRvbyBtdWNoIHJlY3Vyc2lvblwiIGVycm9yLlxuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGFzayA9IHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICAgICAgICAgIGlmICh0YXNrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBydW4odGFzayk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbW1lZGlhdGUoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHsgcnVuSWZQcmVzZW50KGhhbmRsZSk7IH0pO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhblVzZVBvc3RNZXNzYWdlKCkge1xuICAgICAgICAvLyBUaGUgdGVzdCBhZ2FpbnN0IGBpbXBvcnRTY3JpcHRzYCBwcmV2ZW50cyB0aGlzIGltcGxlbWVudGF0aW9uIGZyb20gYmVpbmcgaW5zdGFsbGVkIGluc2lkZSBhIHdlYiB3b3JrZXIsXG4gICAgICAgIC8vIHdoZXJlIGBnbG9iYWwucG9zdE1lc3NhZ2VgIG1lYW5zIHNvbWV0aGluZyBjb21wbGV0ZWx5IGRpZmZlcmVudCBhbmQgY2FuJ3QgYmUgdXNlZCBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgICBpZiAoZ2xvYmFsLnBvc3RNZXNzYWdlICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cykge1xuICAgICAgICAgICAgdmFyIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG9sZE9uTWVzc2FnZSA9IGdsb2JhbC5vbm1lc3NhZ2U7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShcIlwiLCBcIipcIik7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gb2xkT25NZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgLy8gSW5zdGFsbHMgYW4gZXZlbnQgaGFuZGxlciBvbiBgZ2xvYmFsYCBmb3IgdGhlIGBtZXNzYWdlYCBldmVudDogc2VlXG4gICAgICAgIC8vICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vRE9NL3dpbmRvdy5wb3N0TWVzc2FnZVxuICAgICAgICAvLyAqIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL2NvbW1zLmh0bWwjY3Jvc3NEb2N1bWVudE1lc3NhZ2VzXG5cbiAgICAgICAgdmFyIG1lc3NhZ2VQcmVmaXggPSBcInNldEltbWVkaWF0ZSRcIiArIE1hdGgucmFuZG9tKCkgKyBcIiRcIjtcbiAgICAgICAgdmFyIG9uR2xvYmFsTWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlID09PSBnbG9iYWwgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZXZlbnQuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEuaW5kZXhPZihtZXNzYWdlUHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudCgrZXZlbnQuZGF0YS5zbGljZShtZXNzYWdlUHJlZml4Lmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFsLmF0dGFjaEV2ZW50KFwib25tZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKG1lc3NhZ2VQcmVmaXggKyBoYW5kbGUsIFwiKlwiKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZShoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBodG1sID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIDxzY3JpcHQ+IGVsZW1lbnQ7IGl0cyByZWFkeXN0YXRlY2hhbmdlIGV2ZW50IHdpbGwgYmUgZmlyZWQgYXN5bmNocm9ub3VzbHkgb25jZSBpdCBpcyBpbnNlcnRlZFxuICAgICAgICAgICAgLy8gaW50byB0aGUgZG9jdW1lbnQuIERvIHNvLCB0aHVzIHF1ZXVpbmcgdXAgdGhlIHRhc2suIFJlbWVtYmVyIHRvIGNsZWFuIHVwIG9uY2UgaXQncyBiZWVuIGNhbGxlZC5cbiAgICAgICAgICAgIHZhciBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaHRtbC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgICAgIHNjcmlwdCA9IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaHRtbC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBJZiBzdXBwb3J0ZWQsIHdlIHNob3VsZCBhdHRhY2ggdG8gdGhlIHByb3RvdHlwZSBvZiBnbG9iYWwsIHNpbmNlIHRoYXQgaXMgd2hlcmUgc2V0VGltZW91dCBldCBhbC4gbGl2ZS5cbiAgICB2YXIgYXR0YWNoVG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGdsb2JhbCk7XG4gICAgYXR0YWNoVG8gPSBhdHRhY2hUbyAmJiBhdHRhY2hUby5zZXRUaW1lb3V0ID8gYXR0YWNoVG8gOiBnbG9iYWw7XG5cbiAgICAvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IGUuZy4gYnJvd3NlcmlmeSBlbnZpcm9ubWVudHMuXG4gICAgaWYgKHt9LnRvU3RyaW5nLmNhbGwoZ2xvYmFsLnByb2Nlc3MpID09PSBcIltvYmplY3QgcHJvY2Vzc11cIikge1xuICAgICAgICAvLyBGb3IgTm9kZS5qcyBiZWZvcmUgMC45XG4gICAgICAgIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGNhblVzZVBvc3RNZXNzYWdlKCkpIHtcbiAgICAgICAgLy8gRm9yIG5vbi1JRTEwIG1vZGVybiBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChnbG9iYWwuTWVzc2FnZUNoYW5uZWwpIHtcbiAgICAgICAgLy8gRm9yIHdlYiB3b3JrZXJzLCB3aGVyZSBzdXBwb3J0ZWRcbiAgICAgICAgaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZG9jICYmIFwib25yZWFkeXN0YXRlY2hhbmdlXCIgaW4gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIikpIHtcbiAgICAgICAgLy8gRm9yIElFIDbigJM4XG4gICAgICAgIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBvbGRlciBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCk7XG4gICAgfVxuXG4gICAgYXR0YWNoVG8uc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlO1xuICAgIGF0dGFjaFRvLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG59KHR5cGVvZiBzZWxmID09PSBcInVuZGVmaW5lZFwiID8gdHlwZW9mIGdsb2JhbCA9PT0gXCJ1bmRlZmluZWRcIiA/IHRoaXMgOiBnbG9iYWwgOiBzZWxmKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///34\n')},function(module,exports,__webpack_require__){eval("var apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(34);\nexports.setImmediate = setImmediate;\nexports.clearImmediate = clearImmediate;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3RpbWVycy1icm93c2VyaWZ5L21haW4uanM/YjA4OCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjM1LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkge1xuICBpZiAodGltZW91dCkge1xuICAgIHRpbWVvdXQuY2xvc2UoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbCh3aW5kb3csIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBzZXRpbW1lZGlhdGUgYXR0YWNoZXMgaXRzZWxmIHRvIHRoZSBnbG9iYWwgb2JqZWN0XG5yZXF1aXJlKFwic2V0aW1tZWRpYXRlXCIpO1xuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qc1xuLy8gbW9kdWxlIGlkID0gMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///35\n")}]);